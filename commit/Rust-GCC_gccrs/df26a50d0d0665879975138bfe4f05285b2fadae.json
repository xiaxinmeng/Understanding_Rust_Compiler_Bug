{"sha": "df26a50d0d0665879975138bfe4f05285b2fadae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYyNmE1MGQwZDA2NjU4Nzk5NzUxMzhiZmU0ZjA1Mjg1YjJmYWRhZQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2016-07-21T18:41:27Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2016-07-21T18:41:27Z"}, "message": "backport: Makefile.am (myo_inc_dir): Remove.\n\nMerge liboffloadmic from upstream\n\nliboffloadmic/\n\t* Makefile.am (myo_inc_dir): Remove.\n\t(toolexeclib_LTLIBRARIES): Remove libmyo-client.la and\n\tlibmyo-service.la.\n\t(liboffloadmic_cppflags): Remove -DMYO_SUPPORT.\n\t(liboffloadmic_host_la_SOURCES): Remove offload_myo_host.cpp.\n\t(liboffloadmic_target_la_SOURCES): Remove offload_myo_target.cpp.\n\t(liboffloadmic_target_la_LIBADD): Remove libmyo-service.la.\n\t(libmyo_client_la_SOURCES, libmyo_service_la_SOURCES): Remove.\n\t(libmyo_client_la_DEPENDENCIES, libmyo_service_la_DEPENDENCIES): Remove.\n\t(libmyo_client_la_CPPFLAGS, libmyo_service_la_CPPFLAGS): Remove.\n\t(libmyo_client_la_LDFLAGS, libmyo_service_la_LDFLAGS): Remove.\n\t* Makefile.in: Regenerate.\n\t* doc/doxygen/header.tex: Merge from upstream, version 20160715\n\t<https://openmprtl.org/sites/default/files/liboffload_oss_20160715.tgz>.\n\t* runtime/cean_util.cpp: Likewise.\n\t* runtime/cean_util.h: Likewise.\n\t* runtime/coi/coi_client.cpp: Likewise.\n\t* runtime/coi/coi_client.h: Likewise.\n\t* runtime/coi/coi_server.cpp: Likewise.\n\t* runtime/coi/coi_server.h: Likewise.\n\t* runtime/compiler_if_host.cpp: Likewise.\n\t* runtime/compiler_if_host.h: Likewise.\n\t* runtime/compiler_if_target.cpp: Likewise.\n\t* runtime/compiler_if_target.h: Likewise.\n\t* runtime/dv_util.cpp: Likewise.\n\t* runtime/dv_util.h: Likewise.\n\t* runtime/liboffload_error.c: Likewise.\n\t* runtime/liboffload_error_codes.h: Likewise.\n\t* runtime/liboffload_msg.c: Likewise.\n\t* runtime/liboffload_msg.h: Likewise.\n\t* runtime/mic_lib.f90: Likewise.\n\t* runtime/offload.h: Likewise.\n\t* runtime/offload_common.cpp: Likewise.\n\t* runtime/offload_common.h: Likewise.\n\t* runtime/offload_engine.cpp: Likewise.\n\t* runtime/offload_engine.h: Likewise.\n\t* runtime/offload_env.cpp: Likewise.\n\t* runtime/offload_env.h: Likewise.\n\t* runtime/offload_host.cpp: Likewise.\n\t* runtime/offload_host.h: Likewise.\n\t* runtime/offload_iterator.h: Likewise.\n\t* runtime/offload_myo_host.cpp: Likewise.\n\t* runtime/offload_myo_host.h: Likewise.\n\t* runtime/offload_myo_target.cpp: Likewise.\n\t* runtime/offload_myo_target.h: Likewise.\n\t* runtime/offload_omp_host.cpp: Likewise.\n\t* runtime/offload_omp_target.cpp: Likewise.\n\t* runtime/offload_orsl.cpp: Likewise.\n\t* runtime/offload_orsl.h: Likewise.\n\t* runtime/offload_table.cpp: Likewise.\n\t* runtime/offload_table.h: Likewise.\n\t* runtime/offload_target.cpp: Likewise.\n\t* runtime/offload_target.h: Likewise.\n\t* runtime/offload_target_main.cpp: Likewise.\n\t* runtime/offload_timer.h: Likewise.\n\t* runtime/offload_timer_host.cpp: Likewise.\n\t* runtime/offload_timer_target.cpp: Likewise.\n\t* runtime/offload_trace.cpp: Likewise.\n\t* runtime/offload_trace.h: Likewise.\n\t* runtime/offload_util.cpp: Likewise.\n\t* runtime/offload_util.h: Likewise.\n\t* runtime/ofldbegin.cpp: Likewise.\n\t* runtime/ofldend.cpp: Likewise.\n\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n\t* runtime/use_mpss2.txt: Remove.\n\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n\tversion 3.7.1\n\t<http://registrationcenter-download.intel.com/akdlm/irc_nas/9226/\n\tmpss-3.7.1-linux.tar>.\n\t* include/coi/common/COIEvent_common.h: Likewise.\n\t* include/coi/common/COIMacros_common.h: Likewise.\n\t* include/coi/common/COIPerf_common.h: Likewise.\n\t* include/coi/common/COIResult_common.h: Likewise.\n\t* include/coi/common/COISysInfo_common.h: Likewise.\n\t* include/coi/common/COITypes_common.h: Likewise.\n\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n\t* include/coi/sink/COIProcess_sink.h: Likewise.\n\t* include/coi/source/COIBuffer_source.h: Likewise.\n\t* include/coi/source/COIEngine_source.h: Likewise.\n\t* include/coi/source/COIEvent_source.h: Likewise.\n\t* include/coi/source/COIPipeline_source.h: Likewise.\n\t* include/coi/source/COIProcess_source.h: Likewise.\n\t* include/myo/myo.h: Remove.\n\t* include/myo/myoimpl.h: Remove.\n\t* include/myo/myotypes.h: Remove.\n\t* plugin/Makefile.am (AM_LDFLAGS): Remove -lmyo-service.\n\t* plugin/Makefile.in: Regenerate.\n\t* plugin/libgomp-plugin-intelmic.cpp (LD_LIBRARY_PATH_ENV): Remove.\n\t(MIC_LD_LIBRARY_PATH_ENV): Remove.\n\t(init): Do not set MIC_LD_LIBRARY_PATH.  Now liboffloadmic uses only\n\tLD_LIBRARY_PATH.\n\t* plugin/offload_target_main.cpp: Update copyright years.\n\t* runtime/emulator/coi_common.h: Likewise.\n\t* runtime/emulator/coi_device.cpp: Likewise.\n\t* runtime/emulator/coi_device.h: Likewise.\n\t* runtime/emulator/coi_host.cpp: Likewise.\n\t(COIBufferCreate): Allow COI_BUFFER_OPENCL.\n\t(COIEngineGetInfo): Return COI_DEVICE_KNL instead of COI_ISA_x86_64.\n\t* runtime/emulator/coi_host.h: Update copyright years.\n\t* runtime/emulator/coi_version_asm.h: Likewise.\n\t* runtime/emulator/coi_version_linker_script.map: Likewise.\n\t* runtime/emulator/myo_client.cpp: Remove.\n\t* runtime/emulator/myo_service.cpp: Remove.\n\t* runtime/emulator/myo_service.h: Remove.\n\t* runtime/emulator/myo_version_asm.h: Remove.\n\t* runtime/emulator/myo_version_linker_script.map: Remove.\n\nFrom-SVN: r238603", "tree": {"sha": "7c090ff171fce7c1deb3673e9c4ae8ddcbab769b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c090ff171fce7c1deb3673e9c4ae8ddcbab769b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df26a50d0d0665879975138bfe4f05285b2fadae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df26a50d0d0665879975138bfe4f05285b2fadae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df26a50d0d0665879975138bfe4f05285b2fadae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df26a50d0d0665879975138bfe4f05285b2fadae/comments", "author": null, "committer": null, "parents": [{"sha": "ab3af181e659954846e9d6678b04b2670f2da703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3af181e659954846e9d6678b04b2670f2da703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3af181e659954846e9d6678b04b2670f2da703"}], "stats": {"total": 10071, "additions": 4921, "deletions": 5150}, "files": [{"sha": "66253ad8ffee6296104738172c2b810ae09bd1f6", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,3 +1,114 @@\n+2016-07-21  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* Makefile.am (myo_inc_dir): Remove.\n+\t(toolexeclib_LTLIBRARIES): Remove libmyo-client.la and\n+\tlibmyo-service.la.\n+\t(liboffloadmic_cppflags): Remove -DMYO_SUPPORT.\n+\t(liboffloadmic_host_la_SOURCES): Remove offload_myo_host.cpp.\n+\t(liboffloadmic_target_la_SOURCES): Remove offload_myo_target.cpp.\n+\t(liboffloadmic_target_la_LIBADD): Remove libmyo-service.la.\n+\t(libmyo_client_la_SOURCES, libmyo_service_la_SOURCES): Remove.\n+\t(libmyo_client_la_DEPENDENCIES, libmyo_service_la_DEPENDENCIES): Remove.\n+\t(libmyo_client_la_CPPFLAGS, libmyo_service_la_CPPFLAGS): Remove.\n+\t(libmyo_client_la_LDFLAGS, libmyo_service_la_LDFLAGS): Remove.\n+\t* Makefile.in: Regenerate.\n+\t* doc/doxygen/header.tex: Merge from upstream, version 20160715\n+\t<https://openmprtl.org/sites/default/files/liboffload_oss_20160715.tgz>.\n+\t* runtime/cean_util.cpp: Likewise.\n+\t* runtime/cean_util.h: Likewise.\n+\t* runtime/coi/coi_client.cpp: Likewise.\n+\t* runtime/coi/coi_client.h: Likewise.\n+\t* runtime/coi/coi_server.cpp: Likewise.\n+\t* runtime/coi/coi_server.h: Likewise.\n+\t* runtime/compiler_if_host.cpp: Likewise.\n+\t* runtime/compiler_if_host.h: Likewise.\n+\t* runtime/compiler_if_target.cpp: Likewise.\n+\t* runtime/compiler_if_target.h: Likewise.\n+\t* runtime/dv_util.cpp: Likewise.\n+\t* runtime/dv_util.h: Likewise.\n+\t* runtime/liboffload_error.c: Likewise.\n+\t* runtime/liboffload_error_codes.h: Likewise.\n+\t* runtime/liboffload_msg.c: Likewise.\n+\t* runtime/liboffload_msg.h: Likewise.\n+\t* runtime/mic_lib.f90: Likewise.\n+\t* runtime/offload.h: Likewise.\n+\t* runtime/offload_common.cpp: Likewise.\n+\t* runtime/offload_common.h: Likewise.\n+\t* runtime/offload_engine.cpp: Likewise.\n+\t* runtime/offload_engine.h: Likewise.\n+\t* runtime/offload_env.cpp: Likewise.\n+\t* runtime/offload_env.h: Likewise.\n+\t* runtime/offload_host.cpp: Likewise.\n+\t* runtime/offload_host.h: Likewise.\n+\t* runtime/offload_iterator.h: Likewise.\n+\t* runtime/offload_myo_host.cpp: Likewise.\n+\t* runtime/offload_myo_host.h: Likewise.\n+\t* runtime/offload_myo_target.cpp: Likewise.\n+\t* runtime/offload_myo_target.h: Likewise.\n+\t* runtime/offload_omp_host.cpp: Likewise.\n+\t* runtime/offload_omp_target.cpp: Likewise.\n+\t* runtime/offload_orsl.cpp: Likewise.\n+\t* runtime/offload_orsl.h: Likewise.\n+\t* runtime/offload_table.cpp: Likewise.\n+\t* runtime/offload_table.h: Likewise.\n+\t* runtime/offload_target.cpp: Likewise.\n+\t* runtime/offload_target.h: Likewise.\n+\t* runtime/offload_target_main.cpp: Likewise.\n+\t* runtime/offload_timer.h: Likewise.\n+\t* runtime/offload_timer_host.cpp: Likewise.\n+\t* runtime/offload_timer_target.cpp: Likewise.\n+\t* runtime/offload_trace.cpp: Likewise.\n+\t* runtime/offload_trace.h: Likewise.\n+\t* runtime/offload_util.cpp: Likewise.\n+\t* runtime/offload_util.h: Likewise.\n+\t* runtime/ofldbegin.cpp: Likewise.\n+\t* runtime/ofldend.cpp: Likewise.\n+\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n+\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n+\t* runtime/use_mpss2.txt: Remove.\n+\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n+\tversion 3.7.1\n+\t<http://registrationcenter-download.intel.com/akdlm/irc_nas/9226/\n+\tmpss-3.7.1-linux.tar>.\n+\t* include/coi/common/COIEvent_common.h: Likewise.\n+\t* include/coi/common/COIMacros_common.h: Likewise.\n+\t* include/coi/common/COIPerf_common.h: Likewise.\n+\t* include/coi/common/COIResult_common.h: Likewise.\n+\t* include/coi/common/COISysInfo_common.h: Likewise.\n+\t* include/coi/common/COITypes_common.h: Likewise.\n+\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n+\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n+\t* include/coi/sink/COIProcess_sink.h: Likewise.\n+\t* include/coi/source/COIBuffer_source.h: Likewise.\n+\t* include/coi/source/COIEngine_source.h: Likewise.\n+\t* include/coi/source/COIEvent_source.h: Likewise.\n+\t* include/coi/source/COIPipeline_source.h: Likewise.\n+\t* include/coi/source/COIProcess_source.h: Likewise.\n+\t* include/myo/myo.h: Remove.\n+\t* include/myo/myoimpl.h: Remove.\n+\t* include/myo/myotypes.h: Remove.\n+\t* plugin/Makefile.am (AM_LDFLAGS): Remove -lmyo-service.\n+\t* plugin/Makefile.in: Regenerate.\n+\t* plugin/libgomp-plugin-intelmic.cpp (LD_LIBRARY_PATH_ENV): Remove.\n+\t(MIC_LD_LIBRARY_PATH_ENV): Remove.\n+\t(init): Do not set MIC_LD_LIBRARY_PATH.  Now liboffloadmic uses only\n+\tLD_LIBRARY_PATH.\n+\t* plugin/offload_target_main.cpp: Update copyright years.\n+\t* runtime/emulator/coi_common.h: Likewise.\n+\t* runtime/emulator/coi_device.cpp: Likewise.\n+\t* runtime/emulator/coi_device.h: Likewise.\n+\t* runtime/emulator/coi_host.cpp: Likewise.\n+\t(COIBufferCreate): Allow COI_BUFFER_OPENCL.\n+\t(COIEngineGetInfo): Return COI_DEVICE_KNL instead of COI_ISA_x86_64.\n+\t* runtime/emulator/coi_host.h: Update copyright years.\n+\t* runtime/emulator/coi_version_asm.h: Likewise.\n+\t* runtime/emulator/coi_version_linker_script.map: Likewise.\n+\t* runtime/emulator/myo_client.cpp: Remove.\n+\t* runtime/emulator/myo_service.cpp: Remove.\n+\t* runtime/emulator/myo_service.h: Remove.\n+\t* runtime/emulator/myo_version_asm.h: Remove.\n+\t* runtime/emulator/myo_version_linker_script.map: Remove.\n+\n 2016-05-26  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (offload): Change return type"}, {"sha": "c0cf645fdd7a65915b596e83e634d93435410e08", "filename": "liboffloadmic/Makefile.am", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.am?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -37,7 +37,6 @@ SUBDIRS = . plugin\n # Directories.\n build_dir = $(top_builddir)\n coi_inc_dir = $(top_srcdir)/include/coi\n-myo_inc_dir = $(top_srcdir)/include/myo\n libgomp_dir = $(build_dir)/../libgomp\n source_dir = $(top_srcdir)/runtime\n \n@@ -48,12 +47,12 @@ libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n # Target list.\n if LIBOFFLOADMIC_HOST\n   nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n-  toolexeclib_LTLIBRARIES = libcoi_host.la libmyo-client.la liboffloadmic_host.la\n+  toolexeclib_LTLIBRARIES = libcoi_host.la liboffloadmic_host.la\n   nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n   ofld_obj =\n else # LIBOFFLOADMIC_TARGET\n   nodist_toolexeclib_HEADERS = liboffloadmic_target.spec\n-  toolexeclib_LTLIBRARIES = libcoi_device.la libmyo-service.la liboffloadmic_target.la\n+  toolexeclib_LTLIBRARIES = libcoi_device.la liboffloadmic_target.la\n   nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n   ofld_obj = ofldbegin.o ofldend.o\n endif\n@@ -67,7 +66,7 @@ liboffloadmic_sources = runtime/dv_util.cpp \\\n \t\t\truntime/offload_trace.cpp \\\n \t\t\truntime/offload_util.cpp\n \n-liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n+liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n \n liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\truntime/cean_util.cpp \\\n@@ -76,7 +75,6 @@ liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\truntime/offload_engine.cpp \\\n \t\t\t\truntime/offload_env.cpp \\\n \t\t\t\truntime/offload_host.cpp \\\n-\t\t\t\truntime/offload_myo_host.cpp \\\n \t\t\t\truntime/offload_omp_host.cpp \\\n \t\t\t\truntime/offload_orsl.cpp \\\n \t\t\t\truntime/offload_timer_host.cpp \\\n@@ -88,36 +86,27 @@ liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\t  runtime/coi/coi_server.cpp \\\n \t\t\t\t  runtime/compiler_if_target.cpp \\\n-\t\t\t\t  runtime/offload_myo_target.cpp \\\n \t\t\t\t  runtime/offload_omp_target.cpp \\\n \t\t\t\t  runtime/offload_target.cpp \\\n \t\t\t\t  runtime/offload_timer_target.cpp\n \n liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_target_la_LIBADD = libcoi_device.la libmyo-service.la\n+liboffloadmic_target_la_LIBADD = libcoi_device.la\n liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n \n # Emulator.\n libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n-libmyo_client_la_SOURCES = runtime/emulator/myo_client.cpp\n-libmyo_service_la_SOURCES = runtime/emulator/myo_service.cpp\n \n libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-libmyo_client_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n-libmyo_service_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n \n libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n-libmyo_client_la_CPPFLAGS = -I$(myo_inc_dir)\n-libmyo_service_la_CPPFLAGS = -I$(myo_inc_dir)\n \n libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-libmyo_client_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n-libmyo_service_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n \n # ofldbegin, ofldend\n all-local: $(ofld_obj)"}, {"sha": "07727d27331e5877050cbf53e016942c8ed2dd46", "filename": "liboffloadmic/Makefile.in", "status": "modified", "additions": 4, "deletions": 70, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.in?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -149,22 +149,6 @@ libcoi_host_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(CXXFLAGS) $(libcoi_host_la_LDFLAGS) $(LDFLAGS) -o $@\n @LIBOFFLOADMIC_HOST_TRUE@am_libcoi_host_la_rpath = -rpath \\\n @LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n-libmyo_client_la_LIBADD =\n-am_libmyo_client_la_OBJECTS = libmyo_client_la-myo_client.lo\n-libmyo_client_la_OBJECTS = $(am_libmyo_client_la_OBJECTS)\n-libmyo_client_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n-\t$(CXXFLAGS) $(libmyo_client_la_LDFLAGS) $(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_TRUE@am_libmyo_client_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n-libmyo_service_la_LIBADD =\n-am_libmyo_service_la_OBJECTS = libmyo_service_la-myo_service.lo\n-libmyo_service_la_OBJECTS = $(am_libmyo_service_la_OBJECTS)\n-libmyo_service_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n-\t$(CXXFLAGS) $(libmyo_service_la_LDFLAGS) $(LDFLAGS) -o $@\n-@LIBOFFLOADMIC_HOST_FALSE@am_libmyo_service_la_rpath = -rpath \\\n-@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n liboffloadmic_host_la_LIBADD =\n am__objects_1 = liboffloadmic_host_la-dv_util.lo \\\n \tliboffloadmic_host_la-liboffload_error.lo \\\n@@ -180,7 +164,6 @@ am_liboffloadmic_host_la_OBJECTS = $(am__objects_1) \\\n \tliboffloadmic_host_la-offload_engine.lo \\\n \tliboffloadmic_host_la-offload_env.lo \\\n \tliboffloadmic_host_la-offload_host.lo \\\n-\tliboffloadmic_host_la-offload_myo_host.lo \\\n \tliboffloadmic_host_la-offload_omp_host.lo \\\n \tliboffloadmic_host_la-offload_orsl.lo \\\n \tliboffloadmic_host_la-offload_timer_host.lo \\\n@@ -201,7 +184,6 @@ am__objects_2 = liboffloadmic_target_la-dv_util.lo \\\n am_liboffloadmic_target_la_OBJECTS = $(am__objects_2) \\\n \tliboffloadmic_target_la-coi_server.lo \\\n \tliboffloadmic_target_la-compiler_if_target.lo \\\n-\tliboffloadmic_target_la-offload_myo_target.lo \\\n \tliboffloadmic_target_la-offload_omp_target.lo \\\n \tliboffloadmic_target_la-offload_target.lo \\\n \tliboffloadmic_target_la-offload_timer_target.lo\n@@ -236,7 +218,6 @@ CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libcoi_device_la_SOURCES) $(libcoi_host_la_SOURCES) \\\n-\t$(libmyo_client_la_SOURCES) $(libmyo_service_la_SOURCES) \\\n \t$(liboffloadmic_host_la_SOURCES) \\\n \t$(liboffloadmic_target_la_SOURCES)\n MULTISRCTOP = \n@@ -403,7 +384,6 @@ SUBDIRS = . plugin\n # Directories.\n build_dir = $(top_builddir)\n coi_inc_dir = $(top_srcdir)/include/coi\n-myo_inc_dir = $(top_srcdir)/include/myo\n libgomp_dir = $(build_dir)/../libgomp\n source_dir = $(top_srcdir)/runtime\n \n@@ -414,8 +394,8 @@ libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n \n # Target list.\n @LIBOFFLOADMIC_HOST_TRUE@nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n-@LIBOFFLOADMIC_HOST_FALSE@toolexeclib_LTLIBRARIES = libcoi_device.la libmyo-service.la liboffloadmic_target.la\n-@LIBOFFLOADMIC_HOST_TRUE@toolexeclib_LTLIBRARIES = libcoi_host.la libmyo-client.la liboffloadmic_host.la\n+@LIBOFFLOADMIC_HOST_FALSE@toolexeclib_LTLIBRARIES = libcoi_device.la liboffloadmic_target.la\n+@LIBOFFLOADMIC_HOST_TRUE@toolexeclib_LTLIBRARIES = libcoi_host.la liboffloadmic_host.la\n @LIBOFFLOADMIC_HOST_FALSE@nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n @LIBOFFLOADMIC_HOST_TRUE@nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n @LIBOFFLOADMIC_HOST_FALSE@ofld_obj = ofldbegin.o ofldend.o\n@@ -430,15 +410,14 @@ liboffloadmic_sources = runtime/dv_util.cpp \\\n \t\t\truntime/offload_trace.cpp \\\n \t\t\truntime/offload_util.cpp\n \n-liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n+liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\truntime/cean_util.cpp \\\n \t\t\t\truntime/coi/coi_client.cpp \\\n \t\t\t\truntime/compiler_if_host.cpp \\\n \t\t\t\truntime/offload_engine.cpp \\\n \t\t\t\truntime/offload_env.cpp \\\n \t\t\t\truntime/offload_host.cpp \\\n-\t\t\t\truntime/offload_myo_host.cpp \\\n \t\t\t\truntime/offload_omp_host.cpp \\\n \t\t\t\truntime/offload_orsl.cpp \\\n \t\t\t\truntime/offload_timer_host.cpp \\\n@@ -449,33 +428,24 @@ liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\t  runtime/coi/coi_server.cpp \\\n \t\t\t\t  runtime/compiler_if_target.cpp \\\n-\t\t\t\t  runtime/offload_myo_target.cpp \\\n \t\t\t\t  runtime/offload_omp_target.cpp \\\n \t\t\t\t  runtime/offload_target.cpp \\\n \t\t\t\t  runtime/offload_timer_target.cpp\n \n liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_target_la_LIBADD = libcoi_device.la libmyo-service.la\n+liboffloadmic_target_la_LIBADD = libcoi_device.la\n liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n \n # Emulator.\n libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n-libmyo_client_la_SOURCES = runtime/emulator/myo_client.cpp\n-libmyo_service_la_SOURCES = runtime/emulator/myo_service.cpp\n libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n-libmyo_client_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n-libmyo_service_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n-libmyo_client_la_CPPFLAGS = -I$(myo_inc_dir)\n-libmyo_service_la_CPPFLAGS = -I$(myo_inc_dir)\n libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n-libmyo_client_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n-libmyo_service_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n@@ -594,10 +564,6 @@ libcoi_device.la: $(libcoi_device_la_OBJECTS) $(libcoi_device_la_DEPENDENCIES) $\n \t$(libcoi_device_la_LINK) $(am_libcoi_device_la_rpath) $(libcoi_device_la_OBJECTS) $(libcoi_device_la_LIBADD) $(LIBS)\n libcoi_host.la: $(libcoi_host_la_OBJECTS) $(libcoi_host_la_DEPENDENCIES) $(EXTRA_libcoi_host_la_DEPENDENCIES) \n \t$(libcoi_host_la_LINK) $(am_libcoi_host_la_rpath) $(libcoi_host_la_OBJECTS) $(libcoi_host_la_LIBADD) $(LIBS)\n-libmyo-client.la: $(libmyo_client_la_OBJECTS) $(libmyo_client_la_DEPENDENCIES) $(EXTRA_libmyo_client_la_DEPENDENCIES) \n-\t$(libmyo_client_la_LINK) $(am_libmyo_client_la_rpath) $(libmyo_client_la_OBJECTS) $(libmyo_client_la_LIBADD) $(LIBS)\n-libmyo-service.la: $(libmyo_service_la_OBJECTS) $(libmyo_service_la_DEPENDENCIES) $(EXTRA_libmyo_service_la_DEPENDENCIES) \n-\t$(libmyo_service_la_LINK) $(am_libmyo_service_la_rpath) $(libmyo_service_la_OBJECTS) $(libmyo_service_la_LIBADD) $(LIBS)\n liboffloadmic_host.la: $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_DEPENDENCIES) $(EXTRA_liboffloadmic_host_la_DEPENDENCIES) \n \t$(liboffloadmic_host_la_LINK) $(am_liboffloadmic_host_la_rpath) $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_LIBADD) $(LIBS)\n liboffloadmic_target.la: $(liboffloadmic_target_la_OBJECTS) $(liboffloadmic_target_la_DEPENDENCIES) $(EXTRA_liboffloadmic_target_la_DEPENDENCIES) \n@@ -611,8 +577,6 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_device_la-coi_device.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_host_la-coi_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmyo_client_la-myo_client.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmyo_service_la-myo_service.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-cean_util.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-coi_client.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Plo@am__quote@\n@@ -623,7 +587,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_engine.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_env.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_host.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_orsl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_table.Plo@am__quote@\n@@ -637,7 +600,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_table.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_target.Plo@am__quote@\n@@ -736,20 +698,6 @@ libcoi_host_la-coi_host.lo: runtime/emulator/coi_host.cpp\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libcoi_host_la-coi_host.lo `test -f 'runtime/emulator/coi_host.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_host.cpp\n \n-libmyo_client_la-myo_client.lo: runtime/emulator/myo_client.cpp\n-@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_client_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libmyo_client_la-myo_client.lo -MD -MP -MF $(DEPDIR)/libmyo_client_la-myo_client.Tpo -c -o libmyo_client_la-myo_client.lo `test -f 'runtime/emulator/myo_client.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_client.cpp\n-@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libmyo_client_la-myo_client.Tpo $(DEPDIR)/libmyo_client_la-myo_client.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/myo_client.cpp' object='libmyo_client_la-myo_client.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_client_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libmyo_client_la-myo_client.lo `test -f 'runtime/emulator/myo_client.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_client.cpp\n-\n-libmyo_service_la-myo_service.lo: runtime/emulator/myo_service.cpp\n-@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_service_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libmyo_service_la-myo_service.lo -MD -MP -MF $(DEPDIR)/libmyo_service_la-myo_service.Tpo -c -o libmyo_service_la-myo_service.lo `test -f 'runtime/emulator/myo_service.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_service.cpp\n-@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libmyo_service_la-myo_service.Tpo $(DEPDIR)/libmyo_service_la-myo_service.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/myo_service.cpp' object='libmyo_service_la-myo_service.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_service_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libmyo_service_la-myo_service.lo `test -f 'runtime/emulator/myo_service.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_service.cpp\n-\n liboffloadmic_host_la-dv_util.lo: runtime/dv_util.cpp\n @am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-dv_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo -c -o liboffloadmic_host_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n @am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo $(DEPDIR)/liboffloadmic_host_la-dv_util.Plo\n@@ -827,13 +775,6 @@ liboffloadmic_host_la-offload_host.lo: runtime/offload_host.cpp\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_host.lo `test -f 'runtime/offload_host.cpp' || echo '$(srcdir)/'`runtime/offload_host.cpp\n \n-liboffloadmic_host_la-offload_myo_host.lo: runtime/offload_myo_host.cpp\n-@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_myo_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Tpo -c -o liboffloadmic_host_la-offload_myo_host.lo `test -f 'runtime/offload_myo_host.cpp' || echo '$(srcdir)/'`runtime/offload_myo_host.cpp\n-@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_myo_host.cpp' object='liboffloadmic_host_la-offload_myo_host.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_myo_host.lo `test -f 'runtime/offload_myo_host.cpp' || echo '$(srcdir)/'`runtime/offload_myo_host.cpp\n-\n liboffloadmic_host_la-offload_omp_host.lo: runtime/offload_omp_host.cpp\n @am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_omp_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo -c -o liboffloadmic_host_la-offload_omp_host.lo `test -f 'runtime/offload_omp_host.cpp' || echo '$(srcdir)/'`runtime/offload_omp_host.cpp\n @am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo\n@@ -904,13 +845,6 @@ liboffloadmic_target_la-compiler_if_target.lo: runtime/compiler_if_target.cpp\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-compiler_if_target.lo `test -f 'runtime/compiler_if_target.cpp' || echo '$(srcdir)/'`runtime/compiler_if_target.cpp\n \n-liboffloadmic_target_la-offload_myo_target.lo: runtime/offload_myo_target.cpp\n-@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_myo_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Tpo -c -o liboffloadmic_target_la-offload_myo_target.lo `test -f 'runtime/offload_myo_target.cpp' || echo '$(srcdir)/'`runtime/offload_myo_target.cpp\n-@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Plo\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_myo_target.cpp' object='liboffloadmic_target_la-offload_myo_target.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_myo_target.lo `test -f 'runtime/offload_myo_target.cpp' || echo '$(srcdir)/'`runtime/offload_myo_target.cpp\n-\n liboffloadmic_target_la-offload_omp_target.lo: runtime/offload_omp_target.cpp\n @am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_omp_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo -c -o liboffloadmic_target_la-offload_omp_target.lo `test -f 'runtime/offload_omp_target.cpp' || echo '$(srcdir)/'`runtime/offload_omp_target.cpp\n @am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo"}, {"sha": "e91d4be29d66b3bde980900d9ef60fe9f4f3c036", "filename": "liboffloadmic/doc/doxygen/header.tex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -82,7 +82,7 @@\n \n Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.\n \n-This document is Copyright \\textcopyright 2014-2015, Intel Corporation. All rights reserved.\n+This document is Copyright \\textcopyright 2014-2016, Intel Corporation. All rights reserved.\n \n \\pagenumbering{roman}\n \\tableofcontents"}, {"sha": "836e3e830d43ba294a01c01f6d6c4a74e3c582d6", "filename": "liboffloadmic/include/coi/common/COIEngine_common.h", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -56,34 +56,47 @@ extern \"C\" {\n #endif\n #endif // DOXYGEN_SHOULD_SKIP_THIS\n \n-#define COI_MAX_ISA_x86_64_DEVICES 1\n-#define COI_MAX_ISA_MIC_DEVICES 128\n-#define COI_MAX_ISA_KNF_DEVICES COI_MAX_ISA_MIC_DEVICES\n-#define COI_MAX_ISA_KNC_DEVICES COI_MAX_ISA_MIC_DEVICES\n-\n+#define COI_MAX_ISA_x86_64_DEVICES 128\n+#define COI_MAX_ISA_MIC_DEVICES    128\n+#define COI_MAX_ISA_KNF_DEVICES    0\n+#define COI_MAX_ISA_KNC_DEVICES    COI_MAX_ISA_MIC_DEVICES\n+#define COI_MAX_ISA_KNL_DEVICES    COI_MAX_ISA_MIC_DEVICES\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n /// List of ISA types of supported engines.\n ///\n typedef enum\n {\n-    COI_ISA_INVALID = 0,        ///< Represents an invalid ISA.\n-    COI_ISA_x86_64,             ///< The ISA for an x86_64 host engine.\n-    COI_ISA_MIC,                ///< Special value used to represent any device\n-                                ///< in the Intel(R) Many Integrated Core\n-                                ///< architecture family.\n-    COI_ISA_KNF,                ///< ISA for L1OM devices.\n-    COI_ISA_KNC                 ///< ISA for K1OM devices.\n-} COI_ISA_TYPE;\n+    COI_DEVICE_INVALID = 0,        ///< Represents an invalid device type.\n+    COI_DEVICE_SOURCE,             ///< The engine from which offload originates\n+    COI_DEVICE_MIC,                ///< Special value used to represent any device\n+    ///< in the Intel(R) Many Integrated Core family.\n+    COI_DEVICE_DEPRECATED_0,       ///< Placeholder for L1OM devices (deprecated).\n+    COI_DEVICE_KNC,                ///< K1OM devices (Knigts Corner).\n+    COI_DEVICE_KNL,                ///< Knights Landing devices\n+    COI_DEVICE_MAX,\n+    COI_DEVICE_KNF = COI_DEVICE_DEPRECATED_0\n+} COI_DEVICE_TYPE;\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// List of deprecated device types for backward compatibility\n+///\n+#define COI_ISA_INVALID COI_DEVICE_INVALID\n+#define COI_ISA_x86_64  COI_DEVICE_SOURCE\n+#define COI_ISA_MIC     COI_DEVICE_MIC\n+#define COI_ISA_KNF     COI_DEVICE_KNF\n+#define COI_ISA_KNC     COI_DEVICE_KNC\n \n+typedef COI_DEVICE_TYPE COI_ISA_TYPE;\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n /// Get the information about the COIEngine executing this function call.\n ///\n /// @param  out_pType\n-///         [out] The COI_ISA_TYPE of the engine.\n+///         [out] The COI_DEVICE_TYPE of the engine.\n ///\n /// @param  out_pIndex\n ///         [out] The zero-based index of this engine in the collection of\n@@ -96,8 +109,8 @@ typedef enum\n COIACCESSAPI\n COIRESULT\n COIEngineGetIndex(\n-            COI_ISA_TYPE*       out_pType,\n-            uint32_t*           out_pIndex);\n+    COI_DEVICE_TYPE    *out_pType,\n+    uint32_t           *out_pIndex);\n \n #ifdef __cplusplus\n } /* extern \"C\" */"}, {"sha": "9d5623d6edde0414c4bbd55bc26857edc4100390", "filename": "liboffloadmic/include/coi/common/COIEvent_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "d6811c1cd214a5d5d4e48cf8886931828407bae5", "filename": "liboffloadmic/include/coi/common/COIMacros_common.h", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -54,20 +54,20 @@\n     #include <sched.h>\n #ifndef UNREFERENCED_CONST_PARAM\n #define UNREFERENCED_CONST_PARAM(P)     { void* x UNUSED_ATTR = \\\n-                                                 (void*)(uint64_t)P; \\\n-                                        }\n+            (void*)(uint64_t)P; \\\n+}\n #endif\n \n-// This seems to work on everything. \n+// This seems to work on everything.\n #ifndef UNREFERENCED_PARAM\n-#define UNREFERENCED_PARAM(P)          (P = P)\n+    #define UNREFERENCED_PARAM(P)          (P = P)\n #endif\n \n #ifndef SYMBOL_VERSION\n \n-/* Linux support: */\n+        /* Linux support: */\n \n-    #define SYMBOL_VERSION( SYMBOL , VERSION ) SYMBOL ## VERSION\n+        #define SYMBOL_VERSION( SYMBOL , VERSION ) SYMBOL ## VERSION\n \n #endif\n \n@@ -86,80 +86,85 @@\n /* Roughly equivalent to CPU_ISSET(). */\n static inline uint64_t COI_CPU_MASK_ISSET(int bitNumber, const COI_CPU_MASK cpu_mask)\n {\n-  if ((size_t)bitNumber < sizeof(COI_CPU_MASK)*8)\n-        return ((cpu_mask)[bitNumber/64] & (((uint64_t)1) << (bitNumber%64)));\n+    if ((size_t)bitNumber < sizeof(COI_CPU_MASK) * 8)\n+        return ((cpu_mask)[bitNumber / 64] & (((uint64_t)1) << (bitNumber % 64)));\n     return 0;\n }\n \n /* Roughly equivalent to CPU_SET(). */\n static inline void COI_CPU_MASK_SET(int bitNumber, COI_CPU_MASK cpu_mask)\n {\n-  if ((size_t)bitNumber < sizeof(COI_CPU_MASK)*8)\n-        ((cpu_mask)[bitNumber/64] |= (((uint64_t)1) << (bitNumber%64)));\n+    if ((size_t)bitNumber < sizeof(COI_CPU_MASK) * 8)\n+        ((cpu_mask)[bitNumber / 64] |= (((uint64_t)1) << (bitNumber % 64)));\n }\n \n /* Roughly equivalent to CPU_ZERO(). */\n static inline void COI_CPU_MASK_ZERO(COI_CPU_MASK cpu_mask)\n {\n-    memset(cpu_mask,0,sizeof(COI_CPU_MASK));\n+    memset(cpu_mask, 0, sizeof(COI_CPU_MASK));\n }\n \n /* Roughly equivalent to CPU_AND(). */\n static inline void COI_CPU_MASK_AND(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n {\n     const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+    unsigned int i = 0;\n \n-    for(unsigned int i=0;i<loopIterations;++i)\n+    for (; i < loopIterations; ++i)\n         dst[i] = src1[i] & src2[i];\n }\n \n /* Roughly equivalent to CPU_XOR(). */\n static inline void COI_CPU_MASK_XOR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n {\n     const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+    unsigned int i = 0;\n \n-    for(unsigned int i=0;i<loopIterations;++i)\n+    for (; i < loopIterations; ++i)\n         dst[i] = src1[i] ^ src2[i];\n }\n \n /* Roughly equivalent to CPU_OR(). */\n static inline void COI_CPU_MASK_OR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n {\n     const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+    unsigned int i = 0;\n \n-    for(unsigned int i=0;i<loopIterations;++i)\n+    for (; i < loopIterations; ++i)\n         dst[i] = src1[i] | src2[i];\n }\n \n /* Utility function for COI_CPU_MASK_COUNT() below. */\n static inline int __COI_CountBits(uint64_t n)\n {\n-    int cnt=0;\n+    int cnt = 0;\n \n-    for (;n;cnt++)\n-        n &= (n-1);\n+    for (; n; cnt++)\n+        n &= (n - 1);\n     return cnt;\n }\n \n /* Roughly equivalent to CPU_COUNT(). */\n static inline int COI_CPU_MASK_COUNT(const COI_CPU_MASK cpu_mask)\n {\n-    int cnt=0;\n+    int cnt = 0;\n     const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask[0]);\n+    unsigned int i = 0;\n \n-    for(unsigned int i=0;i < loopIterations;++i)\n+    for (; i < loopIterations; ++i)\n     {\n         cnt += __COI_CountBits(cpu_mask[i]);\n     }\n     return cnt;\n }\n \n /* Roughly equivalent to CPU_EQUAL(). */\n-static inline int COI_CPU_MASK_EQUAL(const COI_CPU_MASK cpu_mask1,const COI_CPU_MASK cpu_mask2)\n+static inline int COI_CPU_MASK_EQUAL(const COI_CPU_MASK cpu_mask1, const COI_CPU_MASK cpu_mask2)\n {\n     const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask1[0]);\n+    unsigned int i = 0;\n \n-    for(unsigned int i=0;i < loopIterations;++i)\n+    for (; i < loopIterations; ++i)\n     {\n         if (cpu_mask1[i] != cpu_mask2[i])\n             return 0;\n@@ -169,51 +174,55 @@ static inline int COI_CPU_MASK_EQUAL(const COI_CPU_MASK cpu_mask1,const COI_CPU_\n \n \n /* Utility function to translate from cpu_set * to COI_CPU_MASK. */\n-static inline void COI_CPU_MASK_XLATE(COI_CPU_MASK dest,const cpu_set_t *src)\n+static inline void COI_CPU_MASK_XLATE(COI_CPU_MASK dest, const cpu_set_t *src)\n {\n+    unsigned int i;\n+    unsigned int j;\n     COI_CPU_MASK_ZERO(dest);\n-#if 0\n+    #if 0\n     /* Slightly slower version than the following #else/#endif block. Left here only to\n          document the intent of the code. */\n-    for(unsigned int i=0;i < sizeof(cpu_set_t)*8;++i)\n-        if (CPU_ISSET(i,src))\n-            COI_CPU_MASK_SET(i,dest);\n-#else\n-    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)/sizeof(dest[0]);++i)\n+    for (i = 0; i < sizeof(cpu_set_t) * 8; ++i)\n+        if (CPU_ISSET(i, src))\n+            COI_CPU_MASK_SET(i, dest);\n+    #else\n+    for (i = 0; i < sizeof(COI_CPU_MASK) / sizeof(dest[0]); ++i)\n     {\n-        for(unsigned int j=0;j < 64;++j)\n+        for (j = 0; j < 64; ++j)\n         {\n-            if (CPU_ISSET(i*64+j,src))\n+            if (CPU_ISSET(i * 64 + j, src))\n                 dest[i] |= ((uint64_t)1) << j;\n         }\n     }\n-#endif\n+    #endif\n }\n \n /* Utility function to translate from COI_CPU_MASK to cpu_set *. */\n-static inline void COI_CPU_MASK_XLATE_EX(cpu_set_t *dest,const COI_CPU_MASK src)\n+static inline void COI_CPU_MASK_XLATE_EX(cpu_set_t *dest, const COI_CPU_MASK src)\n {\n+    unsigned int i;\n+    unsigned int j;\n     CPU_ZERO(dest);\n-#if 0\n+    #if 0\n     /* Slightly slower version than the following #else/#endif block. Left here only to\n          document the intent of the code. */\n-    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)*8;++i)\n-        if (COI_CPU_MASK_ISSET(i,src))\n-            CPU_SET(i,dest);\n-#else\n-    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)/sizeof(src[0]);++i)\n+    for (i = 0; i < sizeof(COI_CPU_MASK) * 8; ++i)\n+        if (COI_CPU_MASK_ISSET(i, src))\n+            CPU_SET(i, dest);\n+    #else\n+    for (i = 0; i < sizeof(COI_CPU_MASK) / sizeof(src[0]); ++i)\n     {\n         const uint64_t cpu_mask = src[i];\n \n-        for(unsigned int j=0;j < 64;++j)\n+        for (j = 0; j < 64; ++j)\n         {\n             const uint64_t bit = ((uint64_t)1) << j;\n \n             if (bit & cpu_mask)\n-                CPU_SET(i*64+j,dest);\n+                CPU_SET(i * 64 + j, dest);\n         }\n     }\n-#endif\n+    #endif\n }\n \n "}, {"sha": "0b17e13d670432a16ad26a49f702ab0900d9fece", "filename": "liboffloadmic/include/coi/common/COIPerf_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "1774b8874bafff56d65f3bf0d9287fa08e07877a", "filename": "liboffloadmic/include/coi/common/COIResult_common.h", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -59,67 +59,69 @@ typedef enum COIRESULT\n     COI_SUCCESS = 0,                  ///< The function succeeded without error.\n     COI_ERROR,                        ///< Unspecified error.\n     COI_NOT_INITIALIZED,              ///< The function was called before the\n-                                      ///< system was initialized.\n+    ///< system was initialized.\n     COI_ALREADY_INITIALIZED,          ///< The function was called after the\n-                                      ///< system was initialized.\n+    ///< system was initialized.\n     COI_ALREADY_EXISTS,               ///< Cannot complete the request due to\n-                                      ///< the existence of a similar object.\n+    ///< the existence of a similar object.\n     COI_DOES_NOT_EXIST,               ///< The specified object was not found.\n     COI_INVALID_POINTER,              ///< One of the provided addresses was not\n-                                      ///< valid.\n+    ///< valid.\n     COI_OUT_OF_RANGE,                 ///< One of the arguments contains a value\n-                                      ///< that is invalid.\n+    ///< that is invalid.\n     COI_NOT_SUPPORTED,                ///< This function is not currently\n-                                      ///< supported as used.\n+    ///< supported as used.\n     COI_TIME_OUT_REACHED,             ///< The specified time out caused the\n-                                      ///< function to abort.\n+    ///< function to abort.\n     COI_MEMORY_OVERLAP,               ///< The source and destination range\n-                                      ///< specified overlaps for the same\n-                                      ///< buffer.\n+    ///< specified overlaps for the same\n+    ///< buffer.\n     COI_ARGUMENT_MISMATCH,            ///< The specified arguments are not\n-                                      ///< compatible.\n+    ///< compatible.\n     COI_SIZE_MISMATCH,                ///< The specified size does not match the\n-                                      ///< expected size.\n+    ///< expected size.\n     COI_OUT_OF_MEMORY,                ///< The function was unable to allocate\n-                                      ///< the required memory.\n+    ///< the required memory.\n     COI_INVALID_HANDLE,               ///< One of the provided handles was not\n-                                      ///< valid.\n+    ///< valid.\n     COI_RETRY,                        ///< This function currently can't\n-                                      ///< complete, but might be able to later.\n+    ///< complete, but might be able to later.\n     COI_RESOURCE_EXHAUSTED,           ///< The resource was not large enough.\n     COI_ALREADY_LOCKED,               ///< The object was expected to be\n-                                      ///< unlocked, but was locked.\n+    ///< unlocked, but was locked.\n     COI_NOT_LOCKED,                   ///< The object was expected to be locked,\n-                                      ///< but was unlocked.\n+    ///< but was unlocked.\n     COI_MISSING_DEPENDENCY,           ///< One or more dependent components\n-                                      ///< could not be found.\n+    ///< could not be found.\n     COI_UNDEFINED_SYMBOL,             ///< One or more symbols the component\n-                                      ///< required was not defined in any\n-                                      ///< library.\n+    ///< required was not defined in any\n+    ///< library.\n     COI_PENDING,                      ///< Operation is not finished\n     COI_BINARY_AND_HARDWARE_MISMATCH, ///< A specified binary will not run on\n-                                      ///< the specified hardware.\n+    ///< the specified hardware.\n     COI_PROCESS_DIED,\n     COI_INVALID_FILE,                 ///< The file is invalid for its intended\n-                                      ///< usage in the function.\n+    ///< usage in the function.\n     COI_EVENT_CANCELED,               ///< Event wait on a user event that\n-                                      ///< was unregistered or is being\n-                                      ///< unregistered returns\n-                                      ///< COI_EVENT_CANCELED.\n+    ///< was unregistered or is being\n+    ///< unregistered returns\n+    ///< COI_EVENT_CANCELED.\n     COI_VERSION_MISMATCH,             ///< The version of Intel(R) Coprocessor\n-                                      ///< Offload Infrastructure on the host\n-                                      ///< is not compatible with the version\n-                                      ///< on the device.\n+    ///< Offload Infrastructure on the host\n+    ///< is not compatible with the version\n+    ///< on the device.\n     COI_BAD_PORT,                     ///< The port that the host is set to\n-                                      ///< connect to is invalid.\n+    ///< connect to is invalid.\n     COI_AUTHENTICATION_FAILURE,       ///< The daemon was unable to authenticate\n-                                      ///< the user that requested an engine.\n-                                      ///< Only reported if daemon is set up for\n-                                      ///< authorization. Is also reported in\n-                                      ///< Windows if host can not find user.\n+    ///< the user that requested an engine.\n+    ///< Only reported if daemon is set up for\n+    ///< authorization. Is also reported in\n+    ///< Windows if host can not find user.\n+    COI_COMM_NOT_INITIALIZED,         ///< The function was called before the\n+    ///< comm was initialized.\n+    COI_INCORRECT_FORMAT,             ///< Format of data is incorrect\n     COI_NUM_RESULTS                   ///< Reserved, do not use.\n-}\n-COIRESULT;\n+} COIRESULT;\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -133,9 +135,9 @@ COIRESULT;\n /// @return String version of the passed in COIRESULT code.\n ///\n COIACCESSAPI\n-const char*\n+const char *\n COIResultGetName(\n-            COIRESULT       in_ResultCode);\n+    COIRESULT       in_ResultCode);\n \n #ifdef __cplusplus\n } /* extern \"C\" */"}, {"sha": "cc37647b0c02f81d8f177018bf20724c1a2e8ca2", "filename": "liboffloadmic/include/coi/common/COISysInfo_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "6018b7d0eded2159eedf8867e877ac343ea47f84", "filename": "liboffloadmic/include/coi/common/COITypes_common.h", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -48,10 +48,10 @@\n * @file common/COITypes_common.h\n */\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n-    #include <stdint.h>\n-    #include <wchar.h>\n-    #define COIACCESSAPI /* nothing */\n-    #define COIACCESSAPI2 /* nothing */\n+        #include <stdint.h>\n+        #include <wchar.h>\n+        #define COIACCESSAPI /* nothing */\n+        #define COIACCESSAPI2 /* nothing */\n #endif /* DOXYGEN_SHOULD_SKIP_THIS */\n \n \n@@ -60,16 +60,19 @@ extern \"C\" {\n #endif\n \n \n-struct coievent  { uint64_t opaque[2]; };\n+struct coievent\n+{\n+    uint64_t opaque[2];\n+};\n \n-typedef struct coiprocess  * COIPROCESS;\n-typedef struct coipipeline * COIPIPELINE;\n-typedef struct coifunction * COIFUNCTION;\n-typedef struct coiengine   * COIENGINE;\n+typedef struct coiprocess   *COIPROCESS;\n+typedef struct coipipeline *COIPIPELINE;\n+typedef struct coifunction *COIFUNCTION;\n+typedef struct coiengine    *COIENGINE;\n typedef struct coievent      COIEVENT;\n-typedef struct coibuffer   * COIBUFFER;\n-typedef struct coilibrary  * COILIBRARY;\n-typedef struct coimapinst  * COIMAPINSTANCE;\n+typedef struct coibuffer    *COIBUFFER;\n+typedef struct coilibrary   *COILIBRARY;\n+typedef struct coimapinst   *COIMAPINSTANCE;\n \n typedef uint64_t COI_CPU_MASK[16];\n "}, {"sha": "d36d5860b3e9164273b044c8a017021534d04c30", "filename": "liboffloadmic/include/coi/sink/COIBuffer_sink.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -48,8 +48,8 @@\n * @file sink\\COIBuffer_sink.h\n */\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n+    #include \"../common/COITypes_common.h\"\n+    #include \"../common/COIResult_common.h\"\n #endif // DOXYGEN_SHOULD_SKIP_THIS\n \n #ifdef __cplusplus\n@@ -85,7 +85,7 @@ extern \"C\" {\n ///\n COIRESULT\n COIBufferAddRef(\n-            void*           in_pBuffer);\n+    void           *in_pBuffer);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -121,7 +121,7 @@ COIBufferAddRef(\n ///\n COIRESULT\n COIBufferReleaseRef(\n-            void*           in_pBuffer);\n+    void           *in_pBuffer);\n \n \n #ifdef __cplusplus"}, {"sha": "9cb1087ab6facf0e9ae789e33f2cc1e6418e38d8", "filename": "liboffloadmic/include/coi/sink/COIPipeline_sink.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -52,9 +52,9 @@\n #include \"../common/COIResult_common.h\"\n \n #ifdef __FreeBSD__\n-#define COINATIVELIBEXPORT_VISIBILITY \"extern\"\n+    #define COINATIVELIBEXPORT_VISIBILITY \"extern\"\n #else\n-#define COINATIVELIBEXPORT_VISIBILITY \"default\"\n+    #define COINATIVELIBEXPORT_VISIBILITY \"default\"\n #endif\n \n #ifdef __cplusplus\n@@ -106,13 +106,13 @@ extern \"C\" {\n ///\n typedef void\n (*RunFunctionPtr_t)(\n-            uint32_t        in_BufferCount,\n-            void**          in_ppBufferPointers,\n-            uint64_t*       in_pBufferLengths,\n-            void*           in_pMiscData,\n-            uint16_t        in_MiscDataLength,\n-            void*           in_pReturnValue,\n-            uint16_t        in_ReturnValueLength);\n+    uint32_t        in_BufferCount,\n+    void          **in_ppBufferPointers,\n+    uint64_t       *in_pBufferLengths,\n+    void           *in_pMiscData,\n+    uint16_t        in_MiscDataLength,\n+    void           *in_pReturnValue,\n+    uint16_t        in_ReturnValueLength);\n \n ///////////////////////////////////////////////////////////////////////////////\n ///"}, {"sha": "9438925391e67f114a057078ced1088531f49070", "filename": "liboffloadmic/include/coi/sink/COIProcess_sink.h", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -96,6 +96,75 @@ COIProcessWaitForShutdown();\n COIRESULT\n COIProcessProxyFlush();\n \n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Loads a shared library from host filesystem into the current sink\n+/// process, akin to using dlopen() on a local process in Linux or\n+/// LoadLibrary() in Windows.\n+///\n+/// @param  in_pFileName\n+///         [in] The name of the shared library file on the source's file\n+///         system that is being loaded. If the file name is not an absolute\n+///         path, the file is searched for in the same manner as dependencies.\n+///\n+/// @param  in_pLibraryName\n+///         [in] Name for the shared library. This optional parameter can\n+///         be specified in case the dynamic library doesn't have an\n+///         SO_NAME field. If specified, it will take precedence over\n+///         the SO_NAME if it exists. If it is not specified then\n+///         the library must have a valid SO_NAME field.\n+///\n+///@param   in_LibrarySearchPath\n+///         [in] a path to locate dynamic libraries dependencies for the\n+///         library being loaded. If not NULL, this path will override the\n+///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+/// @param  in_Flags\n+///         [in] Bitmask of the flags that will be passed in as the dlopen()\n+///         \"flag\" parameter on the sink.\n+///\n+/// @param  out_pLibrary\n+///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n+///         that uniquely identifies the loaded library.\n+///\n+/// @return COI_SUCCESS if the library was successfully loaded.\n+///\n+/// @return COI_INVALID_POINTER if in_pFileName is NULL.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_pFileName cannot be found.\n+///\n+/// @return COI_INVALID_FILE if the file is not a valid shared library.\n+///\n+/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n+///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the shared library is missing an SONAME\n+///         and in_pLibraryName is NULL.\n+///\n+/// @return COI_UNDEFINED_SYMBOL if we are unable to load the library due to\n+///         an undefined symbol.\n+///\n+/// @return COI_ALREADY_EXISTS if there is an existing COILIBRARY handle\n+///         that identifies this library, and this COILIBRARY hasn't been\n+///         unloaded yet.\n+///\n+/// @return COI_BINARY_AND_HARDWARE_MISMATCH if the target machine of the\n+///         binary or any of its recursive dependencies does not match the\n+///         engine associated with Process.\n+///\n+/// @return COI_NOT_INITIALIZED if setup of remote process on host is not\n+///         completed yet.\n+///\n+COIRESULT\n+COIProcessLoadSinkLibraryFromFile(\n+    const   char               *in_pFileName,\n+    const   char               *in_pLibraryName,\n+    const   char               *in_LibrarySearchPath,\n+    uint32_t            in_Flags,\n+    COILIBRARY         *out_pLibrary);\n+\n #ifdef __cplusplus\n } /* extern \"C\" */\n #endif"}, {"sha": "7076786aaf9f9eb65c428ec5f15a7e1f21a53948", "filename": "liboffloadmic/include/coi/source/COIBuffer_source.h", "status": "modified", "additions": 174, "deletions": 181, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -48,8 +48,8 @@\n * @file source\\COIBuffer_source.h\n */\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n+    #include \"../common/COITypes_common.h\"\n+    #include \"../common/COIResult_common.h\"\n #endif // DOXYGEN_SHOULD_SKIP_THIS\n \n #ifdef __cplusplus\n@@ -71,14 +71,7 @@ typedef enum COI_BUFFER_TYPE\n     // Reserved values, not used by COI any more\n     COI_BUFFER_RESERVED_1,\n     COI_BUFFER_RESERVED_2,\n-\n-    /// A pinned buffer exists in a shared memory region and is always\n-    /// available for read or write operations.\n-    /// Note: Pinned Buffers larger than 4KB are not supported in\n-    /// Windows 7 kernels.\n-    /// The value of COI_BUFFER_PINNED is set to specific value\n-    /// to maintain compatibility with older versions of COI\n-    COI_BUFFER_PINNED,\n+    COI_BUFFER_RESERVED_3,\n \n     /// OpenCL buffers are similar to Normal buffers except they don't\n     /// stall pipelines and don't follow any read write dependencies.\n@@ -125,7 +118,7 @@ typedef enum COI_BUFFER_TYPE\n #define COI_OPTIMIZE_NO_DMA                0x00000040\n \n /// Hint to the runtime to try to use huge page sizes for backing store on the\n-/// sink. Is currently not compatible with PINNED buffers or the SAME_ADDRESS\n+/// sink. Is currently not compatible with the SAME_ADDRESS\n /// flags or the SINK_MEMORY flag. It is important to note that this is a hint\n /// and internally the runtime may not actually promote to huge pages.\n /// Specifically if the buffer is too small (less than 4KiB for example) then\n@@ -151,26 +144,27 @@ typedef enum COI_BUFFER_TYPE\n #endif\n #define T 1\n #define MTM(_BUFFER, B1, B2, B3, B4, B5, B6, B7, B8, B9) \\\n-(B1 | B2<<1 | B3<<2 | B4<<3 | B5<<4 | B6<<5 | B7<<6 | B8<<7 | B9<<8)\n+    (B1 | B2<<1 | B3<<2 | B4<<3 | B5<<4 | B6<<5 | B7<<6 | B8<<7 | B9<<8)\n #endif\n \n /// \\enum COI_BUFFER_TYPE\n /// This matrix shows the valid combinations of buffer types and buffer flags\n /// that may be passed in to COIBufferCreate and COIBufferCreateFromMemory.\n /// \\code\n static const uint64_t\n-COI_VALID_BUFFER_TYPES_AND_FLAGS[COI_BUFFER_OPENCL+1] = {\n-/*           |       | SAME |      |       |      |       |     |      |      |\n-             | SAME  | ADDR | OPT  | OPT   | OPT  | OPT   | OPT | HUGE | COI  |\n-             | ADDR  | SINK | SRC  | SRC   | SINK | SINK  | NO  | PAGE | SINK |\n-             | SINKS | SRC  | READ | WRITE | READ | WRITE | DMA | SIZE | MEM  |\n-             +-------+------+------+-------+------+-------+-----+------+-----*/\n-MTM(INVALID   ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n-MTM(NORMAL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T  ),\n-MTM(RESERVED1 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n-MTM(RESERVED2 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n-MTM(PINNED    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n-MTM(OPENCL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F  ),\n+COI_VALID_BUFFER_TYPES_AND_FLAGS[COI_BUFFER_OPENCL + 1] =\n+{\n+    /*           |       | SAME |      |       |      |       |     |      |      |\n+                 | SAME  | ADDR | OPT  | OPT   | OPT  | OPT   | OPT | HUGE | COI  |\n+                 | ADDR  | SINK | SRC  | SRC   | SINK | SINK  | NO  | PAGE | SINK |\n+                 | SINKS | SRC  | READ | WRITE | READ | WRITE | DMA | SIZE | MEM  |\n+                 +-------+------+------+-------+------+-------+-----+------+-----*/\n+    MTM(INVALID   ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n+    MTM(NORMAL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T),\n+    MTM(RESERVED1 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n+    MTM(RESERVED2 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n+    MTM(RESERVED3 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F),\n+    MTM(OPENCL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F),\n };\n ///\\endcode\n #undef MTM\n@@ -206,25 +200,26 @@ typedef enum COI_MAP_TYPE\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n // Make the flag mask\n #define MMM(_BUFFER, B1, B2, B3) \\\n-  {  F  , B1, B2, B3}\n+    {  F  , B1, B2, B3}\n #endif\n /// \\enum COI_MAP_TYPE\n /// This matrix shows the valid combinations of buffer types and map\n /// operations that may be passed in to COIBufferMap.\n /// \\code\n static const uint64_t\n COI_VALID_BUFFER_TYPES_AND_MAP\n-[COI_BUFFER_OPENCL+1][COI_MAP_WRITE_ENTIRE_BUFFER+1] = {\n-/*                      | MAP   | MAP   | MAP   |\n-                        | READ  | READ  | WRITE |\n-                        | WRITE | ONLY  | ENTIRE|\n-                        +-------+-------+-------+*/\n-MMM(INVALID             ,   F   ,   F   ,   F   ),\n-MMM(NORMAL              ,   T   ,   T   ,   T   ),\n-MMM(RESERVED1           ,   F   ,   F   ,   F   ),\n-MMM(RESERVED2           ,   F   ,   F   ,   F   ),\n-MMM(PINNED              ,   T   ,   T   ,   T   ),\n-MMM(OPENCL              ,   T   ,   T   ,   T   ),\n+[COI_BUFFER_OPENCL + 1][COI_MAP_WRITE_ENTIRE_BUFFER + 1] =\n+{\n+    /*                      | MAP   | MAP   | MAP   |\n+                            | READ  | READ  | WRITE |\n+                            | WRITE | ONLY  | ENTIRE|\n+                            +-------+-------+-------+*/\n+    MMM(INVALID             ,   F   ,   F   ,   F),\n+    MMM(NORMAL              ,   T   ,   T   ,   T),\n+    MMM(RESERVED1           ,   F   ,   F   ,   F),\n+    MMM(RESERVED2           ,   F   ,   F   ,   F),\n+    MMM(RESERVED3           ,   F   ,   F   ,   F),\n+    MMM(OPENCL              ,   T   ,   T   ,   T),\n };\n ///\\endcode\n #undef MMM\n@@ -246,8 +241,6 @@ typedef enum COI_COPY_TYPE\n     COI_COPY_USE_DMA,\n \n     /// The runtime should use a CPU copy to copy the data.\n-    /// CPU copy is a synchronous copy. So the resulting operations are always\n-    /// blocking (even though a out_pCompletion event is specified).\n     COI_COPY_USE_CPU,\n \n     /// Same as above, but forces moving entire buffer to target process in Ex\n@@ -269,9 +262,6 @@ typedef enum COI_COPY_TYPE\n /// The buffer states are used to indicate whether a buffer is available for\n /// access in a COIPROCESS. This is used with COIBufferSetState.\n ///\n-/// Buffer state holds only for NORMAL Buffers and OPENCL buffers. Pinned\n-/// buffers are always valid everywhere they get created.\n-///\n /// Rules on State Transition of the buffer:\n /// -. When a Buffer is created by default it is valid only on the source,\n ///    except for buffers created with COI_SINK_MEMORY flag which are valid\n@@ -332,12 +322,13 @@ typedef enum COI_COPY_TYPE\n /// The buffer states used with COIBufferSetState call to indicate the new\n /// state of the buffer on a given process\n ///\n-typedef enum {\n+typedef enum\n+{\n     COI_BUFFER_VALID = 0,      // Buffer is valid and up-to-date on the process\n     COI_BUFFER_INVALID ,       // Buffer is not valid, need valid data\n     COI_BUFFER_VALID_MAY_DROP, // Same as valid but will drop the content when\n-                               // evicted to avoid overwriting the shadow\n-                               // memory\n+    // evicted to avoid overwriting the shadow\n+    // memory\n     COI_BUFFER_RESERVED        // Reserved for internal use\n } COI_BUFFER_STATE;\n ///\n@@ -356,7 +347,8 @@ typedef enum {\n //////////////////////////////////////////////////////////////////////////////\n /// The buffer move flags are used to indicate when a buffer should be moved\n /// when it's state is changed. This is used with COIBufferSetState.\n-typedef enum {\n+typedef enum\n+{\n     COI_BUFFER_MOVE = 0,// Dirty data is moved if state change requires it\n     COI_BUFFER_NO_MOVE  // Change state without moving data\n } COI_BUFFER_MOVE_FLAG;\n@@ -366,21 +358,23 @@ typedef enum {\n #define COI_SINK_OWNERS ((COIPROCESS)-2)\n \n // Matrix descriptors used with MultiD Read/Write\n-typedef struct dim_desc {\n+typedef struct dim_desc\n+{\n     int64_t size;       // Size of data type\n     int64_t lindex;     // Lower index, used in Fortran\n     int64_t lower;      // Lower section bound\n     int64_t upper;      // Upper section bound\n     int64_t stride;     // Stride, or number of bytes between the start\n-                        // of one element and start of next one divided\n-                        // by size.\n+    // of one element and start of next one divided\n+    // by size.\n } dim_desc;\n \n-typedef struct arr_desc {\n+typedef struct arr_desc\n+{\n     int64_t base;       // Base address\n     int64_t rank;       // Rank of array, i.e. number of dimensions\n     dim_desc dim[3];    // This array has as many elements as \ufffdrank\ufffd\n-                        // currently limited to 3.\n+    // currently limited to 3.\n } arr_desc;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -451,21 +445,18 @@ typedef struct arr_desc {\n ///\n /// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n ///\n-/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory. This\n-///         error can also be thrown from Windows 7 operating systems if\n-///         COI_BUFFER_PINNED and a size larger than 4KB is requested.\n-///         This is due to a limitation of the Windows 7 memory management unit.\n+/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferCreate(\n-            uint64_t            in_Size,\n-            COI_BUFFER_TYPE     in_Type,\n-            uint32_t            in_Flags,\n-    const   void*               in_pInitData,\n-            uint32_t            in_NumProcesses,\n-    const   COIPROCESS*         in_pProcesses,\n-            COIBUFFER*          out_pBuffer);\n+    uint64_t            in_Size,\n+    COI_BUFFER_TYPE     in_Type,\n+    uint32_t            in_Flags,\n+    const   void               *in_pInitData,\n+    uint32_t            in_NumProcesses,\n+    const   COIPROCESS         *in_pProcesses,\n+    COIBUFFER          *out_pBuffer);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -496,8 +487,8 @@ COIBufferCreate(\n ///         is not page aligned, it will be rounded up.\n ///\n /// @param  in_Type\n-///         [in] The type of the buffer to create. Only COI_BUFFER_NORMAL and\n-///         COI_BUFFER_PINNED buffer types are supported.\n+///         [in] The type of the buffer to create. Only COI_BUFFER_NORMAL\n+///         buffer type is supported.\n ///\n /// @param  in_Flags\n ///         [in] A bitmask of attributes for the newly created buffer.\n@@ -551,7 +542,7 @@ COIBufferCreate(\n /// @return COI_SUCCESS if the buffer was created\n ///\n /// @return COI_NOT_SUPPORTED if the in_Type value is not COI_BUFFER_NORMAL,\n-///         COI_BUFFER_PINNED, or COI_BUFFER_OPENCL.\n+///         or COI_BUFFER_OPENCL.\n ///\n /// @return COI_NOT_SUPPORTED if in_Memory is read-only memory\n ///\n@@ -586,13 +577,13 @@ COIBufferCreate(\n COIACCESSAPI\n COIRESULT\n COIBufferCreateFromMemory(\n-            uint64_t            in_Size,\n-            COI_BUFFER_TYPE     in_Type,\n-            uint32_t            in_Flags,\n-            void*               in_Memory,\n-            uint32_t            in_NumProcesses,\n-    const   COIPROCESS*         in_pProcesses,\n-            COIBUFFER*          out_pBuffer);\n+    uint64_t            in_Size,\n+    COI_BUFFER_TYPE     in_Type,\n+    uint32_t            in_Flags,\n+    void               *in_Memory,\n+    uint32_t            in_NumProcesses,\n+    const   COIPROCESS         *in_pProcesses,\n+    COIBUFFER          *out_pBuffer);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -619,7 +610,7 @@ COIBufferCreateFromMemory(\n COIACCESSAPI\n COIRESULT\n COIBufferDestroy(\n-            COIBUFFER           in_Buffer);\n+    COIBUFFER           in_Buffer);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -647,9 +638,7 @@ COIBufferDestroy(\n ///\n /// Note that different types of buffers behave differently when mapped.\n /// For instance, mapping a COI_BUFFER_NORMAL for write must stall if the\n-/// buffer is currently being written to by a run function. Mapping\n-/// a COI_BUFFER_PINNED buffer will not affect other functions that use\n-/// that buffer since a COI_BUFFER_PINNED buffer can be mapped at any time.\n+/// buffer is currently being written to by a run function.\n /// The asynchronous operation of COIBufferMap will likely be most useful when\n /// paired with a COI_BUFFER_NORMAL.\n ///\n@@ -732,15 +721,15 @@ COIBufferDestroy(\n COIACCESSAPI\n COIRESULT\n COIBufferMap(\n-            COIBUFFER           in_Buffer,\n-            uint64_t            in_Offset,\n-            uint64_t            in_Length,\n-            COI_MAP_TYPE        in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion,\n-            COIMAPINSTANCE*     out_pMapInstance,\n-            void**              out_ppData);\n+    COIBUFFER           in_Buffer,\n+    uint64_t            in_Offset,\n+    uint64_t            in_Length,\n+    COI_MAP_TYPE        in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion,\n+    COIMAPINSTANCE     *out_pMapInstance,\n+    void              **out_ppData);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -787,10 +776,10 @@ COIBufferMap(\n COIACCESSAPI\n COIRESULT\n COIBufferUnmap(\n-            COIMAPINSTANCE      in_MapInstance,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    COIMAPINSTANCE      in_MapInstance,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -820,8 +809,8 @@ COIBufferUnmap(\n COIACCESSAPI\n COIRESULT\n COIBufferGetSinkAddress(\n-            COIBUFFER           in_Buffer,\n-            uint64_t*           out_pAddress);\n+    COIBUFFER           in_Buffer,\n+    uint64_t           *out_pAddress);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -859,9 +848,9 @@ COIBufferGetSinkAddress(\n COIACCESSAPI\n COIRESULT\n COIBufferGetSinkAddressEx(\n-            COIPROCESS          in_Process,\n-            COIBUFFER           in_Buffer,\n-            uint64_t*           out_pAddress);\n+    COIPROCESS          in_Process,\n+    COIBUFFER           in_Buffer,\n+    uint64_t           *out_pAddress);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -947,21 +936,21 @@ COIBufferGetSinkAddressEx(\n ///\n /// @return COI_OUT_OF_RANGE if in_Length is 0.\n ///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n-///         buffer or COI_BUFFER_OPENCL buffer.\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not COI_BUFFER_OPENCL\n+///         buffer.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferWriteEx(\n-            COIBUFFER           in_DestBuffer,\n+    COIBUFFER           in_DestBuffer,\n     const   COIPROCESS          in_DestProcess,\n-            uint64_t            in_Offset,\n-    const   void*               in_pSourceData,\n-            uint64_t            in_Length,\n-            COI_COPY_TYPE       in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    uint64_t            in_Offset,\n+    const   void               *in_pSourceData,\n+    uint64_t            in_Length,\n+    COI_COPY_TYPE       in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1058,21 +1047,21 @@ COIBufferWriteEx(\n ///\n /// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n ///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n-///         buffer or COI_BUFFER_OPENCL buffer.\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not\n+///         a COI_BUFFER_OPENCL buffer.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferWriteMultiD(\n-            COIBUFFER          in_DestBuffer,\n+    COIBUFFER          in_DestBuffer,\n     const   COIPROCESS         in_DestProcess,\n-            uint64_t           in_Offset,\n-            struct arr_desc*   in_DestArray,\n-            struct arr_desc*   in_SrcArray,\n-            COI_COPY_TYPE      in_Type,\n-            uint32_t           in_NumDependencies,\n-    const   COIEVENT*          in_pDependencies,\n-            COIEVENT*          out_pCompletion);\n+    uint64_t           in_Offset,\n+    struct arr_desc   *in_DestArray,\n+    struct arr_desc   *in_SrcArray,\n+    COI_COPY_TYPE      in_Type,\n+    uint32_t           in_NumDependencies,\n+    const   COIEVENT          *in_pDependencies,\n+    COIEVENT          *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1161,20 +1150,20 @@ COIBufferWriteMultiD(\n ///\n /// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n ///\n-/// @return COI_RETRY if in_SourceBuffer is mapped and is not a COI_BUFFER_PINNED\n-///         buffer or COI_BUFFER_OPENCL buffer.\n+/// @return COI_RETRY if in_SourceBuffer is mapped and is not\n+///         a COI_BUFFER_OPENCL buffer.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferReadMultiD(\n-            COIBUFFER          in_SourceBuffer,\n-            uint64_t           in_Offset,\n-            struct arr_desc*   in_DestArray,\n-            struct arr_desc*   in_SrcArray,\n-            COI_COPY_TYPE      in_Type,\n-            uint32_t           in_NumDependencies,\n-    const   COIEVENT*          in_pDependencies,\n-            COIEVENT*          out_pCompletion);\n+    COIBUFFER          in_SourceBuffer,\n+    uint64_t           in_Offset,\n+    struct arr_desc   *in_DestArray,\n+    struct arr_desc   *in_SrcArray,\n+    COI_COPY_TYPE      in_Type,\n+    uint32_t           in_NumDependencies,\n+    const   COIEVENT          *in_pDependencies,\n+    COIEVENT          *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1252,20 +1241,20 @@ COIBufferReadMultiD(\n ///\n /// @return COI_OUT_OF_RANGE if in_Length is 0.\n ///\n-/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n-///         buffer or COI_BUFFER_OPENCL buffer.\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not\n+///         a COI_BUFFER_OPENCL buffer.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferWrite(\n-            COIBUFFER           in_DestBuffer,\n-            uint64_t            in_Offset,\n-    const   void*               in_pSourceData,\n-            uint64_t            in_Length,\n-            COI_COPY_TYPE       in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    COIBUFFER           in_DestBuffer,\n+    uint64_t            in_Offset,\n+    const   void               *in_pSourceData,\n+    uint64_t            in_Length,\n+    COI_COPY_TYPE       in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1343,20 +1332,20 @@ COIBufferWrite(\n ///\n /// @return COI_INVALID_POINTER if the in_pDestData pointer is NULL.\n ///\n-/// @return COI_RETRY if in_SourceBuffer is mapped and is not a\n-///         COI_BUFFER_PINNED buffer or COI_BUFFER_OPENCL buffer.\n+/// @return COI_RETRY if in_SourceBuffer is mapped and is not\n+///         a COI_BUFFER_OPENCL buffer.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferRead(\n-            COIBUFFER           in_SourceBuffer,\n-            uint64_t            in_Offset,\n-            void*               in_pDestData,\n-            uint64_t            in_Length,\n-            COI_COPY_TYPE       in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    COIBUFFER           in_SourceBuffer,\n+    uint64_t            in_Offset,\n+    void               *in_pDestData,\n+    uint64_t            in_Length,\n+    COI_COPY_TYPE       in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1375,6 +1364,8 @@ COIBufferRead(\n /// happen in parallel if they can be assigned to different DMA hardware.\n /// So it is highly recommended to use explicit event dependencies to\n /// order operations where needed.\n+/// When a destroyed buffer (destination or source) is provided to the\n+/// function, then behavior is unspecified.\n ///\n /// @param  in_DestBuffer\n ///         [in] Buffer to copy into.\n@@ -1457,21 +1448,21 @@ COIBufferRead(\n ///         in_NumDependencies is not 0.\n ///\n /// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n-///         COI_BUFFER_PINNED buffers or COI_BUFFER_OPENCL buffers.\n+///         COI_BUFFER_OPENCL buffers.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferCopyEx(\n-            COIBUFFER           in_DestBuffer,\n+    COIBUFFER           in_DestBuffer,\n     const   COIPROCESS          in_DestProcess,\n-            COIBUFFER           in_SourceBuffer,\n-            uint64_t            in_DestOffset,\n-            uint64_t            in_SourceOffset,\n-            uint64_t            in_Length,\n-            COI_COPY_TYPE       in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    COIBUFFER           in_SourceBuffer,\n+    uint64_t            in_DestOffset,\n+    uint64_t            in_SourceOffset,\n+    uint64_t            in_Length,\n+    COI_COPY_TYPE       in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1490,6 +1481,8 @@ COIBufferCopyEx(\n /// happen in parallel if they can be assigned to different DMA hardware.\n /// So it is highly recommended to use explicit event dependencies to\n /// order operations where needed.\n+/// When a destroyed buffer (destination or source) is provided to the\n+/// function, then behavior is unspecified.\n ///\n /// @param  in_DestBuffer\n ///         [in] Buffer to copy into.\n@@ -1564,20 +1557,20 @@ COIBufferCopyEx(\n ///         in_NumDependencies is not 0.\n ///\n /// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n-///         COI_BUFFER_PINNED buffers or COI_BUFFER_OPENCL buffers.\n+///         COI_BUFFER_OPENCL buffers.\n ///\n COIACCESSAPI\n COIRESULT\n COIBufferCopy(\n-            COIBUFFER           in_DestBuffer,\n-            COIBUFFER           in_SourceBuffer,\n-            uint64_t            in_DestOffset,\n-            uint64_t            in_SourceOffset,\n-            uint64_t            in_Length,\n-            COI_COPY_TYPE       in_Type,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    COIBUFFER           in_DestBuffer,\n+    COIBUFFER           in_SourceBuffer,\n+    uint64_t            in_DestOffset,\n+    uint64_t            in_SourceOffset,\n+    uint64_t            in_Length,\n+    COI_COPY_TYPE       in_Type,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1675,13 +1668,13 @@ COIBufferCopy(\n COIACCESSAPI\n COIRESULT\n COIBufferSetState(\n-            COIBUFFER               in_Buffer,\n-            COIPROCESS              in_Process,\n-            COI_BUFFER_STATE        in_State,\n-            COI_BUFFER_MOVE_FLAG    in_DataMove,\n-            uint32_t                in_NumDependencies,\n-    const   COIEVENT*               in_pDependencies,\n-            COIEVENT*               out_pCompletion);\n+    COIBUFFER               in_Buffer,\n+    COIPROCESS              in_Process,\n+    COI_BUFFER_STATE        in_State,\n+    COI_BUFFER_MOVE_FLAG    in_DataMove,\n+    uint32_t                in_NumDependencies,\n+    const   COIEVENT               *in_pDependencies,\n+    COIEVENT               *out_pCompletion);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1726,10 +1719,10 @@ COIBufferSetState(\n COIACCESSAPI\n COIRESULT\n COIBufferCreateSubBuffer(\n-            COIBUFFER   in_Buffer,\n-            uint64_t    in_Length,\n-            uint64_t    in_Offset,\n-            COIBUFFER*  out_pSubBuffer);\n+    COIBUFFER   in_Buffer,\n+    uint64_t    in_Length,\n+    uint64_t    in_Offset,\n+    COIBUFFER  *out_pSubBuffer);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1764,9 +1757,9 @@ COIBufferCreateSubBuffer(\n COIACCESSAPI\n COIRESULT\n COIBufferReleaseRefcnt(\n-            COIPROCESS          in_Process,\n-            COIBUFFER           in_Buffer,\n-            uint64_t            in_ReleaseRefcnt);\n+    COIPROCESS          in_Process,\n+    COIBUFFER           in_Buffer,\n+    uint64_t            in_ReleaseRefcnt);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -1800,9 +1793,9 @@ COIBufferReleaseRefcnt(\n COIACCESSAPI\n COIRESULT\n COIBufferAddRefcnt(\n-            COIPROCESS          in_Process,\n-            COIBUFFER           in_Buffer,\n-            uint64_t            in_AddRefcnt);\n+    COIPROCESS          in_Process,\n+    COIBUFFER           in_Buffer,\n+    uint64_t            in_AddRefcnt);\n \n #ifdef __cplusplus\n } /* extern \"C\" */"}, {"sha": "d4f6c1bd11f574c561ef1b53c0fcb5cac16b5845", "filename": "liboffloadmic/include/coi/source/COIEngine_source.h", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -48,10 +48,10 @@\n * @file source\\COIEngine_source.h\n */\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n-#include <wchar.h>\n-#include \"../common/COITypes_common.h\"\n-#include \"../common/COIResult_common.h\"\n-#include \"../common/COIEngine_common.h\"\n+    #include <wchar.h>\n+    #include \"../common/COITypes_common.h\"\n+    #include \"../common/COIResult_common.h\"\n+    #include \"../common/COIEngine_common.h\"\n #endif // DOXYGEN_SHOULD_SKIP_THIS\n \n #ifdef __cplusplus\n@@ -85,8 +85,8 @@ typedef struct COI_ENGINE_INFO\n     /// The version string identifying the driver.\n     coi_wchar_t  DriverVersion[COI_MAX_DRIVER_VERSION_STR_LEN];\n \n-    /// The ISA supported by the engine.\n-    COI_ISA_TYPE ISA;\n+    /// The DeviceType supported by the engine.\n+    COI_DEVICE_TYPE ISA;\n \n     /// The number of cores on the engine.\n     uint32_t     NumCores;\n@@ -134,9 +134,9 @@ typedef struct COI_ENGINE_INFO\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-/// Returns information related to a specified engine. Note that if Intel(R)\n-/// Coprocessor Offload Infrastructure (Intel(R) COI) is unable to query\n-/// a value it will be returned as zero but the call will still succeed.\n+/// Returns information related to a specified engine. Note that if the runtime\n+/// is unable to query a value it will be returned as zero but the call will\n+/// still succeed.\n ///\n ///\n /// @param  in_EngineHandle\n@@ -165,26 +165,19 @@ typedef struct COI_ENGINE_INFO\n COIACCESSAPI\n COIRESULT\n COIEngineGetInfo(\n-            COIENGINE           in_EngineHandle,\n-            uint32_t            in_EngineInfoSize,\n-            COI_ENGINE_INFO*    out_pEngineInfo);\n+    COIENGINE           in_EngineHandle,\n+    uint32_t            in_EngineInfoSize,\n+    COI_ENGINE_INFO    *out_pEngineInfo);\n \n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-/// Returns the number of engines in the system that match the provided ISA.\n+/// Returns the number of engines in the system that match the provided device type.\n ///\n-/// Note that while it is possible to enumerate different types of Intel(R)\n-/// Xeon Phi(TM) coprocessors on a single host this is not currently\n-/// supported. Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n-/// makes an assumption that all Intel(R) Xeon Phi(TM) coprocessors found\n-/// in the system are the same architecture as the first coprocessor device.\n+/// The number of available coprocessor devices (i.e. cards connected via PCIe)\n+/// is detected by the COI runtime.\n ///\n-/// Also, note that this function returns the number of engines that Intel(R)\n-/// Coprocessor Offload Infrastructure (Intel(R) COI) is able to detect. Not\n-/// all of them may be online.\n-///\n-/// @param  in_ISA\n+/// @param  in_DeviceType\n ///         [in] Specifies the ISA type of the engine requested.\n ///\n /// @param  out_pNumEngines\n@@ -193,38 +186,40 @@ COIEngineGetInfo(\n ///\n /// @return COI_SUCCESS if the function completed without error.\n ///\n-/// @return COI_DOES_NOT_EXIST if the in_ISA parameter is not valid.\n+/// @return COI_DOES_NOT_EXIST if the in_DeviceType parameter is not valid.\n ///\n /// @return COI_INVALID_POINTER if the out_pNumEngines parameter is NULL.\n ///\n+/// @return COI_OUT_OF_RANGE if number of selected devices is greater than 8.\n+///\n COIACCESSAPI\n COIRESULT\n COIEngineGetCount(\n-            COI_ISA_TYPE    in_ISA,\n-            uint32_t*       out_pNumEngines);\n+    COI_DEVICE_TYPE in_DeviceType,\n+    uint32_t       *out_pNumEngines);\n \n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n /// Returns the handle of a user specified engine.\n ///\n-/// @param  in_ISA\n+/// @param  in_DeviceType\n ///         [in] Specifies the ISA type of the engine requested.\n ///\n /// @param  in_EngineIndex\n ///         [in] A unsigned integer which specifies the zero-based position of\n ///         the engine in a collection of engines. The makeup of this\n-///         collection is defined by the in_ISA parameter.\n+///         collection is defined by the in_DeviceType parameter.\n ///\n /// @param  out_pEngineHandle\n-///         [out] The address of an COIENGINE handle.\n+///         [out] The address of a COIENGINE handle.\n ///\n /// @return COI_SUCCESS if the function completed without error.\n ///\n-/// @return COI_DOES_NOT_EXIST if the in_ISA parameter is not valid.\n+/// @return COI_DOES_NOT_EXIST if the in_DeviceType parameter is not valid.\n ///\n /// @return COI_OUT_OF_RANGE if in_EngineIndex is greater than or equal to\n-///         the number of engines that match the in_ISA parameter.\n+///         the number of engines that match the in_DeviceType parameter.\n ///\n /// @return COI_INVALID_POINTER if the out_pEngineHandle parameter is NULL.\n ///\n@@ -237,9 +232,37 @@ COIEngineGetCount(\n COIACCESSAPI\n COIRESULT\n COIEngineGetHandle(\n-            COI_ISA_TYPE    in_ISA,\n-            uint32_t        in_EngineIndex,\n-            COIENGINE*      out_pEngineHandle);\n+    COI_DEVICE_TYPE in_DeviceType,\n+    uint32_t        in_EngineIndex,\n+    COIENGINE      *out_pEngineHandle);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns the hostname for a specified COIEngine.\n+///\n+/// @param  in_EngineHandle\n+///         [in] The connected COI Engine Handle passed in by the user that is\n+///         used to request the hostname of the device connected by this COIEngine.\n+///\n+/// @param  out_Hostname\n+///         [out] The hostname of the device connected by this COIEngine.\n+///         COI will write at most 4096 bytes and the user must make sure that the size\n+///         of the memory pointed by this argument is large enough.\n+///\n+/// @return COI_SUCCESS if the hostname was retrieved without error.\n+///\n+/// @return COI_ERROR if the function was unable to retrieve the hostname and/or\n+///         the retrieved out_Hostname is NULL.\n+///\n+/// @return COI_INVALID_HANDLE if the in_EngineHandle is invalid.\n+///\n+/// @return COI_INVALID_POINTER if the out_Hostname is NULL.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEngineGetHostname(\n+    COIENGINE in_EngineHandle,\n+    char     *out_Hostname);\n \n #ifdef __cplusplus\n } /* extern \"C\" */"}, {"sha": "8c6ad25c76f1785b40f17f96762018da33c5a930", "filename": "liboffloadmic/include/coi/source/COIEvent_source.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -147,12 +147,12 @@ extern \"C\" {\n COIACCESSAPI\n COIRESULT\n COIEventWait(\n-            uint16_t        in_NumEvents,\n-    const   COIEVENT*       in_pEvents,\n-            int32_t         in_TimeoutMilliseconds,\n-            uint8_t         in_WaitForAll,\n-            uint32_t*       out_pNumSignaled,\n-            uint32_t*       out_pSignaledIndices);\n+    uint16_t        in_NumEvents,\n+    const   COIEVENT       *in_pEvents,\n+    int32_t         in_TimeoutMilliseconds,\n+    uint8_t         in_WaitForAll,\n+    uint32_t       *out_pNumSignaled,\n+    uint32_t       *out_pSignaledIndices);\n \n \n \n@@ -174,7 +174,7 @@ COIEventWait(\n COIACCESSAPI\n COIRESULT\n COIEventRegisterUserEvent(\n-            COIEVENT* out_pEvent);\n+    COIEVENT *out_pEvent);\n \n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -188,12 +188,12 @@ COIEventRegisterUserEvent(\n ///\n /// @return COI_INVALID_HANDLE if in_Event is not a UserEvent\n ///\n-/// @return COI_SUCCESS an event is successfully registered\n+/// @return COI_SUCCESS if an event is successfully unregistered\n ///\n COIACCESSAPI\n COIRESULT\n COIEventUnregisterUserEvent(\n-            COIEVENT in_Event);\n+    COIEVENT in_Event);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -225,9 +225,9 @@ COIEventUnregisterUserEvent(\n ///         they can interpret it as they choose.\n ///\n typedef void (*COI_EVENT_CALLBACK)(\n-            COIEVENT            in_Event,\n+    COIEVENT            in_Event,\n     const   COIRESULT           in_Result,\n-    const   void*               in_UserData);\n+    const   void               *in_UserData);\n \n \n \n@@ -285,10 +285,10 @@ typedef void (*COI_EVENT_CALLBACK)(\n COIACCESSAPI\n COIRESULT\n COIEventRegisterCallback(\n-      const COIEVENT                in_Event,\n-            COI_EVENT_CALLBACK      in_Callback,\n-      const void*                   in_UserData,\n-      const uint64_t                in_Flags);\n+    const COIEVENT                in_Event,\n+    COI_EVENT_CALLBACK      in_Callback,\n+    const void                   *in_UserData,\n+    const uint64_t                in_Flags);\n \n \n "}, {"sha": "c13404d7f6a76904f43bad6ddf121ef43a337326", "filename": "liboffloadmic/include/coi/source/COIPipeline_source.h", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -159,10 +159,10 @@ typedef enum COI_ACCESS_FLAGS\n COIACCESSAPI\n COIRESULT\n COIPipelineCreate(\n-            COIPROCESS          in_Process,\n-            COI_CPU_MASK        in_Mask,\n-            uint32_t            in_StackSize,\n-            COIPIPELINE*        out_pPipeline);\n+    COIPROCESS          in_Process,\n+    COI_CPU_MASK        in_Mask,\n+    uint32_t            in_StackSize,\n+    COIPIPELINE        *out_pPipeline);\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n@@ -177,7 +177,7 @@ COIPipelineCreate(\n COIACCESSAPI\n COIRESULT\n COIPipelineDestroy(\n-            COIPIPELINE         in_Pipeline);\n+    COIPIPELINE         in_Pipeline);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -194,8 +194,8 @@ COIPipelineDestroy(\n ///    RunFunctions. Setting it incorrectly can lead to cyclic dependencies\n ///    and can cause the respective pipeline to stall.\n /// 2. RunFunctions can also segfault if enough memory space is not available\n-///    on the sink for the buffers passed in. Pinned buffers and buffers that\n-///    are AddRef'd need to be accounted for available memory space. In other\n+///    on the sink for the buffers passed in. Buffers that are AddRef'd\n+///    need to be accounted for available memory space. In other\n ///    words, this memory is not available for use until it is freed up.\n /// 3. Unexpected segmentation faults or erroneous behavior can occur if\n ///    handles or data passed in to Runfunction gets destroyed before the\n@@ -322,8 +322,8 @@ COIPipelineDestroy(\n /// @return COI_ARGUMENT_MISMATCH if in_pReturnValue is non-NULL but\n ///         in_ReturnValueLen is zero.\n ///\n-/// @return COI_RETRY if any input buffers, which are not pinned buffers,\n-///         are still mapped when passed to the run function.\n+/// @return COI_RETRY if any input buffers are still mapped when\n+///         passed to the run function.\n ///\n /// @return COI_MISSING_DEPENDENCY if buffer was not created on the process\n ///         associated with the pipeline that was passed in.\n@@ -334,18 +334,18 @@ COIPipelineDestroy(\n COIACCESSAPI\n COIRESULT\n COIPipelineRunFunction(\n-            COIPIPELINE         in_Pipeline,\n-            COIFUNCTION         in_Function,\n-            uint32_t            in_NumBuffers,\n-    const   COIBUFFER*          in_pBuffers,\n-    const   COI_ACCESS_FLAGS*   in_pBufferAccessFlags,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-    const   void*               in_pMiscData,\n-            uint16_t            in_MiscDataLen,\n-            void*               out_pAsyncReturnValue,\n-            uint16_t            in_AsyncReturnValueLen,\n-            COIEVENT*           out_pCompletion);\n+    COIPIPELINE         in_Pipeline,\n+    COIFUNCTION         in_Function,\n+    uint32_t            in_NumBuffers,\n+    const   COIBUFFER          *in_pBuffers,\n+    const   COI_ACCESS_FLAGS   *in_pBufferAccessFlags,\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    const   void               *in_pMiscData,\n+    uint16_t            in_MiscDataLen,\n+    void               *out_pAsyncReturnValue,\n+    uint16_t            in_AsyncReturnValueLen,\n+    COIEVENT           *out_pCompletion);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -369,8 +369,8 @@ COIPipelineRunFunction(\n COIACCESSAPI\n COIRESULT\n COIPipelineGetEngine(\n-            COIPIPELINE         in_Pipeline,\n-            COIENGINE*          out_pEngine);\n+    COIPIPELINE         in_Pipeline,\n+    COIENGINE          *out_pEngine);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -404,10 +404,10 @@ COIPipelineGetEngine(\n COIACCESSAPI\n COIRESULT\n COIPipelineSetCPUMask(\n-            COIPROCESS          in_Process,\n-            uint32_t            in_CoreID,\n-            uint8_t             in_ThreadID,\n-            COI_CPU_MASK*       out_pMask);\n+    COIPROCESS          in_Process,\n+    uint32_t            in_CoreID,\n+    uint8_t             in_ThreadID,\n+    COI_CPU_MASK       *out_pMask);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -426,7 +426,7 @@ COIPipelineSetCPUMask(\n COIACCESSAPI\n COIRESULT\n COIPipelineClearCPUMask(\n-            COI_CPU_MASK*       in_Mask);\n+    COI_CPU_MASK       *in_Mask);\n \n #ifdef __cplusplus\n } /* extern \"C\" */"}, {"sha": "1248a915fc38501cab7b97e61a18f098b18a6051", "filename": "liboffloadmic/include/coi/source/COIProcess_source.h", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -158,17 +158,17 @@ extern \"C\" {\n COIACCESSAPI\n COIRESULT\n COIProcessCreateFromFile(\n-            COIENGINE           in_Engine,\n-    const   char*               in_pBinaryName,\n-            int                 in_Argc,\n-    const   char**              in_ppArgv,\n-            uint8_t             in_DupEnv,\n-    const   char**              in_ppAdditionalEnv,\n-            uint8_t             in_ProxyActive,\n-    const   char*               in_Reserved,\n-            uint64_t            in_InitialBufferSpace,\n-    const   char*               in_LibrarySearchPath,\n-            COIPROCESS*         out_pProcess);\n+    COIENGINE           in_Engine,\n+    const   char               *in_pBinaryName,\n+    int                 in_Argc,\n+    const   char              **in_ppArgv,\n+    uint8_t             in_DupEnv,\n+    const   char              **in_ppAdditionalEnv,\n+    uint8_t             in_ProxyActive,\n+    const   char               *in_Reserved,\n+    uint64_t            in_InitialBufferSpace,\n+    const   char               *in_LibrarySearchPath,\n+    COIPROCESS         *out_pProcess);\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n@@ -327,21 +327,21 @@ COIProcessCreateFromFile(\n COIACCESSAPI\n COIRESULT\n COIProcessCreateFromMemory(\n-            COIENGINE           in_Engine,\n-    const   char*               in_pBinaryName,\n-    const   void*               in_pBinaryBuffer,\n-            uint64_t            in_BinaryBufferLength,\n-            int                 in_Argc,\n-    const   char**              in_ppArgv,\n-            uint8_t             in_DupEnv,\n-    const   char**              in_ppAdditionalEnv,\n-            uint8_t             in_ProxyActive,\n-    const   char*               in_Reserved,\n-            uint64_t            in_InitialBufferSpace,\n-    const   char*               in_LibrarySearchPath,\n-    const   char*               in_FileOfOrigin,\n-            uint64_t            in_FileOfOriginOffset,\n-            COIPROCESS*         out_pProcess);\n+    COIENGINE           in_Engine,\n+    const   char               *in_pBinaryName,\n+    const   void               *in_pBinaryBuffer,\n+    uint64_t            in_BinaryBufferLength,\n+    int                 in_Argc,\n+    const   char              **in_ppArgv,\n+    uint8_t             in_DupEnv,\n+    const   char              **in_ppAdditionalEnv,\n+    uint8_t             in_ProxyActive,\n+    const   char               *in_Reserved,\n+    uint64_t            in_InitialBufferSpace,\n+    const   char               *in_LibrarySearchPath,\n+    const   char               *in_FileOfOrigin,\n+    uint64_t            in_FileOfOriginOffset,\n+    COIPROCESS         *out_pProcess);\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n@@ -403,11 +403,11 @@ COIProcessCreateFromMemory(\n COIACCESSAPI\n COIRESULT\n COIProcessDestroy(\n-            COIPROCESS              in_Process,\n-            int32_t                 in_WaitForMainTimeout,\n-            uint8_t                 in_ForceDestroy,\n-            int8_t*                 out_pProcessReturn,\n-            uint32_t*               out_pTerminationCode);\n+    COIPROCESS              in_Process,\n+    int32_t                 in_WaitForMainTimeout,\n+    uint8_t                 in_ForceDestroy,\n+    int8_t                 *out_pProcessReturn,\n+    uint32_t               *out_pTerminationCode);\n \n \n #define COI_MAX_FUNCTION_NAME_LENGTH 256\n@@ -473,10 +473,10 @@ COIProcessDestroy(\n COIACCESSAPI\n COIRESULT\n COIProcessGetFunctionHandles(\n-            COIPROCESS          in_Process,\n-            uint32_t            in_NumFunctions,\n-    const   char**              in_ppFunctionNameArray,\n-            COIFUNCTION*        out_pFunctionHandleArray);\n+    COIPROCESS          in_Process,\n+    uint32_t            in_NumFunctions,\n+    const   char              **in_ppFunctionNameArray,\n+    COIFUNCTION        *out_pFunctionHandleArray);\n \n #if COI_LIBRARY_VERSION >= 2\n /// @name COIProcessLoadLibrary* flags, named after the corresponding\n@@ -607,29 +607,29 @@ COIProcessGetFunctionHandles(\n COIACCESSAPI\n COIRESULT\n COIProcessLoadLibraryFromMemory(\n-            COIPROCESS          in_Process,\n-    const   void*               in_pLibraryBuffer,\n-            uint64_t            in_LibraryBufferLength,\n-    const   char*               in_pLibraryName,\n-    const   char*               in_LibrarySearchPath,\n-    const   char*               in_FileOfOrigin,\n-            uint64_t            in_FileOfOriginOffset,\n-            uint32_t            in_Flags,\n-            COILIBRARY*         out_pLibrary);\n+    COIPROCESS          in_Process,\n+    const   void               *in_pLibraryBuffer,\n+    uint64_t            in_LibraryBufferLength,\n+    const   char               *in_pLibraryName,\n+    const   char               *in_LibrarySearchPath,\n+    const   char               *in_FileOfOrigin,\n+    uint64_t            in_FileOfOriginOffset,\n+    uint32_t            in_Flags,\n+    COILIBRARY         *out_pLibrary);\n __asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n         \"COIProcessLoadLibraryFromMemory@COI_2.0\");\n #else\n \n COIRESULT\n COIProcessLoadLibraryFromMemory(\n-COIPROCESS          in_Process,\n-    const   void*               in_pLibraryBuffer,\n-            uint64_t            in_LibraryBufferLength,\n-    const   char*               in_pLibraryName,\n-    const   char*               in_LibrarySearchPath,\n-    const   char*               in_FileOfOrigin,\n-            uint64_t            in_FileOfOriginOffset,\n-            COILIBRARY*         out_pLibrary);\n+    COIPROCESS          in_Process,\n+    const   void               *in_pLibraryBuffer,\n+    uint64_t            in_LibraryBufferLength,\n+    const   char               *in_pLibraryName,\n+    const   char               *in_LibrarySearchPath,\n+    const   char               *in_FileOfOrigin,\n+    uint64_t            in_FileOfOriginOffset,\n+    COILIBRARY         *out_pLibrary);\n __asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n         \"COIProcessLoadLibraryFromMemory@COI_1.0\");\n #endif\n@@ -689,23 +689,23 @@ __asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n COIACCESSAPI\n COIRESULT\n COIProcessLoadLibraryFromFile(\n-            COIPROCESS          in_Process,\n-    const   char*               in_pFileName,\n-    const   char*               in_pLibraryName,\n-    const   char*               in_LibrarySearchPath,\n-            uint32_t            in_Flags,\n-            COILIBRARY*         out_pLibrary);\n+    COIPROCESS          in_Process,\n+    const   char               *in_pFileName,\n+    const   char               *in_pLibraryName,\n+    const   char               *in_LibrarySearchPath,\n+    uint32_t            in_Flags,\n+    COILIBRARY         *out_pLibrary);\n __asm__(\".symver COIProcessLoadLibraryFromFile,\"\n         \"COIProcessLoadLibraryFromFile@COI_2.0\");\n #else\n \n COIRESULT\n COIProcessLoadLibraryFromFile(\n-            COIPROCESS          in_Process,\n-    const   char*               in_pFileName,\n-    const   char*               in_pLibraryName,\n-    const   char*               in_LibrarySearchPath,\n-            COILIBRARY*         out_pLibrary);\n+    COIPROCESS          in_Process,\n+    const   char               *in_pFileName,\n+    const   char               *in_pLibraryName,\n+    const   char               *in_LibrarySearchPath,\n+    COILIBRARY         *out_pLibrary);\n __asm__(\".symver COIProcessLoadLibraryFromFile,\"\n         \"COIProcessLoadLibraryFromFile@COI_1.0\");\n #endif\n@@ -728,8 +728,8 @@ __asm__(\".symver COIProcessLoadLibraryFromFile,\"\n COIACCESSAPI\n COIRESULT\n COIProcessUnloadLibrary(\n-            COIPROCESS          in_Process,\n-            COILIBRARY          in_Library);\n+    COIPROCESS          in_Process,\n+    COILIBRARY          in_Library);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -792,11 +792,11 @@ COIProcessUnloadLibrary(\n COIACCESSAPI\n COIRESULT\n COIProcessRegisterLibraries(\n-            uint32_t            in_NumLibraries,\n-    const   void**              in_ppLibraryArray,\n-    const   uint64_t*           in_pLibrarySizeArray,\n-    const   char**              in_ppFileOfOriginArray,\n-    const   uint64_t*           in_pFileOfOriginOffSetArray);\n+    uint32_t            in_NumLibraries,\n+    const   void              **in_ppLibraryArray,\n+    const   uint64_t           *in_pLibrarySizeArray,\n+    const   char              **in_ppFileOfOriginArray,\n+    const   uint64_t           *in_pFileOfOriginOffSetArray);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -873,10 +873,10 @@ typedef enum COI_NOTIFICATIONS\n ///         they can interpret it as they choose.\n ///\n typedef void (*COI_NOTIFICATION_CALLBACK)(\n-            COI_NOTIFICATIONS   in_Type,\n-            COIPROCESS          in_Process,\n-            COIEVENT            in_Event,\n-    const   void*               in_UserData);\n+    COI_NOTIFICATIONS   in_Type,\n+    COIPROCESS          in_Process,\n+    COIEVENT            in_Event,\n+    const   void               *in_UserData);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -911,9 +911,9 @@ typedef void (*COI_NOTIFICATION_CALLBACK)(\n ///\n COIACCESSAPI\n COIRESULT COIRegisterNotificationCallback(\n-            COIPROCESS                  in_Process,\n-            COI_NOTIFICATION_CALLBACK   in_Callback,\n-            const   void*               in_UserData);\n+    COIPROCESS                  in_Process,\n+    COI_NOTIFICATION_CALLBACK   in_Callback,\n+    const   void               *in_UserData);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -938,8 +938,8 @@ COIRESULT COIRegisterNotificationCallback(\n ///\n COIACCESSAPI\n COIRESULT COIUnregisterNotificationCallback(\n-            COIPROCESS                  in_Process,\n-            COI_NOTIFICATION_CALLBACK   in_Callback);\n+    COIPROCESS                  in_Process,\n+    COI_NOTIFICATION_CALLBACK   in_Callback);\n \n \n //////////////////////////////////////////////////////////////////////////////\n@@ -964,7 +964,7 @@ COIRESULT COIUnregisterNotificationCallback(\n ///\n COIACCESSAPI\n void COINotificationCallbackSetContext(\n-    const   void*                       in_UserData);\n+    const   void                       *in_UserData);\n \n \n /// @name COIProcessSetCacheSize flags.\n@@ -1139,9 +1139,9 @@ COIRESULT COIProcessSetCacheSize(\n     const   uint32_t            in_HugeFlags,\n     const   uint64_t            in_SmallPagePoolSize,\n     const   uint32_t            in_SmallFlags,\n-            uint32_t            in_NumDependencies,\n-    const   COIEVENT*           in_pDependencies,\n-            COIEVENT*           out_pCompletion);\n+    uint32_t            in_NumDependencies,\n+    const   COIEVENT           *in_pDependencies,\n+    COIEVENT           *out_pCompletion);\n \n \n //////////////////////////////////////////////////////////////////////////////"}, {"sha": "f6f14015c258332d1c8950f519af70ec9e88f746", "filename": "liboffloadmic/include/myo/myo.h", "status": "removed", "additions": 0, "deletions": 619, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,619 +0,0 @@\n-/*\n- * Copyright 2010-2015 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-/**\n- * Description:\n- *   External APIs of MYO runtime (MYO stands for Mine, Yours and Ours).\n- **/\n-\n-#ifndef _MYO_H_\n-#define _MYO_H_\n-\n-#include \"myotypes.h\"\n-#include \"myoimpl.h\"\n-\n-/** @ingroup MYO\n- *  @addtogroup MYO_API\n-@{\n-* @file myo.h \n-*/\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/****************************************************************************\n-    Arena-based APIs\n- ***************************************************************************/\n-\n-/* \n- * Arena is a set of memory pages with the same ownership type. The ownership\n- * type of all the memory pages inside the same arena can only be changed as\n- * a whole. For \"OURS\", it is also the minimal unit of sync operations to\n- * implement \"release consistency\".\n- */\n-\n-/** @fn extern MyoError myoArenaCreate(MyoOwnershipType in_Type, \n- * int in_Property, MyoArena *out_pArena)\n- * @brief Create an arena with specified ownership type and property.\n- * \n- * @param in_Type Specified ownership type (MYO_ARENA_OURS or \n- * MYO_ARENA_MINE).\n- * @param in_Property Specified properties of the arena. Set it \n- * to 0 to use default properties.\n- *\n- *      MYO_RELEASE_CONSISTENCY or MYO_STRONG_RELEASE_CONSISTENCY\n- *      or MYO_STRONG_CONSISTENCY: \n- *\n- *          Consistency modes for \"OURS\" arenas. For MYO_RELEASE_CONSISTENCY,\n- *          there are 2 functions, \"Acquire\" and \"Release\", which are \n- *          used for memory ordering. \"Release\" makes all local stores \n- *          prior to the release globally visible; \"Acquire\" syncs up the \n- *          local memory with all stores that have been made globally \n- *          visible. However, there is no definite answer as to whether \n- *          local stores can be globally visible before reaching a release \n- *          point, nor whether the newest globally visible stores can be \n- *          updated to local before reaching an acquire point. By using \n- *          MYO_STRONG_RELEASE_CONSISTENCY, the answer to these questions\n- *          is \"no\". A sequential consistency model is maintained to the \n- *          arena when using MYO_STRONG_CONSISTENCY. \n- *          MYO_RELEASE_CONSISTENCY is the default property.\n- *\n- *      MYO_UPDATE_ON_DEMAND or MYO_UPDATE_ON_ACQUIRE: \n- *\n- *          Only apply to \"OURS\" arenas with \"Release Consistency\".\n- *          MYO_UPDATE_ON_ACQUIRE means that the shared pages of this \n- *          arena will be updated on acquire point; MYO_UPDATE_ON_DEMAND\n- *          means that the shared pages will not be updated until they \n- *          are accessed. MYO_UPDATE_ON_DEMAND is the default property.\n- *\n- *      MYO_RECORD_DIRTY or MYO_NOT_RECORD_DIRTY:\n- *\n- *          This property controls whether to record dirty pages. \n- *          There will be runtime overhead when recording dirty pages, \n- *          as it can reduce the communication data. It is a trade-off \n- *          for performance. Also when MYO_NOT_RECORD_DIRTY is set for \n- *          \"OURS\" arena, the runtime cannot guarantee the correctness \n- *          when the host and card modify the same shared page between \n- *          the same sync segment. MYO_RECORD_DIRTY is the default \n- *          property.\n- *\n- *      MYO_ONE_VERSION or MYO_MULTI_VERSION: \n- *\n- *          Only apply to \"OURS\" arenas with \"Release Consistency\". When\n- *          MYO_MULTI_VERSION is set, this arena can only be \"release\" on \n- *          HOST side and \"acquire\" on CARD side. Releasing the arena on \n- *          HOST will create a new versioned data and put it into a FIFO; \n- *          acquiring the arena on CARD will get the versioned data \n- *          from the FIFO one by one. MYO_ONE_VERSION is the default \n- *          property.\n- *\n- *      MYO_CONSISTENCY or MYO_NO_CONSISTENCY: \n- *\n- *          Only apply to \"OURS\" arenas with \"Release Consistency\". When \n- *          MYO_NO_CONSISTENCY is set, the consistency of the arena will\n- *          not be maintained. That is, it is a no-op operation when \n- *          calling acquire/release for such arenas. MYO_CONSISTENCY is \n- *          the default property.\n- *\n- *      MYO_HOST_TO_DEVICE and MYO_DEVICE_TO_HOST: \n- *\n- *          When it is certain that there is only one communication\n- *          direction for this arena, it can be created with only\n- *          MYO_HOST_TO_DEVICE or MYO_DEVICE_TO_HOST so the runtime \n- *          can perform optimizations. The default property is \n- *          MYO_HOST_TO_DEVICE | MYO_DEVICE_TO_HOST.\n- *\n- * @param out_pArena Used to store the handle of the created arena.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-CILK_SHARED MyoError myoArenaCreate(MyoOwnershipType in_Type, int in_Property, MyoArena *out_pArena);\n-\n-/** @fn extern MyoError myoArenaDestroy(MyoArena in_Arena)\n- * @brief Destroy an arena. As a result, the arena can not be \n- * referred any more.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-CILK_SHARED MyoError myoArenaDestroy(MyoArena in_Arena);\n-\n-/** @fn extern void *myoArenaMalloc(MyoArena in_Arena, size_t in_Size)\n- * @brief Allocates size bytes from the specified arena, and returns \n- * the start address of the allocated memory. The memory is not \n- * cleared.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @param in_Size Size (bytes) of the required memory space.\n- * @return\n- *      The start address of the allocated memory space.\n- *      NULL: Failed.\n- **/\n-MYOACCESSAPI\n-void *myoArenaMalloc(MyoArena in_Arena, size_t in_Size);\n-\n-/** @fn extern void myoArenaFree(MyoArena in_Arena, void *in_pPtr)\n- * @brief Frees the memory space allocated by myoArenaMalloc to the \n- * specified arena.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @param in_pPtr The start address of the specified memory \n- * space, which must be retured by myoArenaMalloc.\n- * @return\n- **/\n-MYOACCESSAPI\n-void myoArenaFree(MyoArena in_Arena, void *in_pPtr);\n-\n-/** @fn extern void *myoArenaAlignedMalloc(MyoArena in_Arena, \n- *                     size_t in_Size, size_t in_Alignment)\n- * @brief Allocates size bytes from the specified arena. The \n- * start address of the allocated memory will be a multiple of the \n- * alignment, which must be a power of two.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @param in_Size Size (bytes) of the required memory space.\n- * @param in_Alignment The alignment value (must be a power \n- * of two).\n- * @return\n- *      The start address of the allocated memory space.\n- *      NULL: Failed.\n- **/\n-MYOACCESSAPI\n-void *myoArenaAlignedMalloc(MyoArena in_Arena, size_t in_Size, size_t in_Alignment);\n-\n-/** @fn extern void myoArenaAlignedFree(MyoArena in_Arena, void *in_pPtr)\n- * @brief Frees the memory space allocated by myoArenaAlignedMalloc \n- * to the specified arena.\n- *\n- * @param in_Arena Arena handle returned by previous call to\n- * myoArenaCreate.\n- * @param in_pPtr The start address of the specified memory space,\n- * which must be returned by myoArenaAlignedMalloc.\n- * @return\n- **/\n-MYOACCESSAPI\n-void myoArenaAlignedFree(MyoArena in_Arena, void *in_pPtr);\n-\n-/** @fn extern MyoError myoArenaAcquire(MyoArena in_Arena)\n- * @brief myoArenaAcquire is the sync point for \"OURS\" arena with\n- * \"Release Consistency\". myoArenaAcquire is used to obtain all\n- * stores of \"OURS\" arena that have been made globally visible prior\n- * to this point. \n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-CILK_SHARED MyoError myoArenaAcquire(MyoArena in_Arena);\n-\n-/** @fn extern MyoError myoArenaRelease(MyoArena in_Arena)\n- * @brief myoArenaRelease is the sync point for \"OURS\" arena with\n- * \"Release Consistency\". myoArenaRelease is used to flush all prior\n- * stores of \"OURS\" arena to be globally visible.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-CILK_SHARED MyoError myoArenaRelease(MyoArena in_Arena);\n-\n-/** @fn extern MyoError myoArenaAcquireOwnership(MyoArena in_Arena)\n- * @brief Changes the ownership type of the arena to MYO_ARENA_MINE.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoArenaAcquireOwnership(MyoArena in_Arena);\n-\n-/** @fn extern MyoError myoArenaReleaseOwnership(MyoArena in_Arena)\n- * @brief Change the ownership type of the arena to MYO_ARENA_OURS.\n- *\n- * @param in_Arena Arena handle returned by previous call to \n- * myoArenaCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoArenaReleaseOwnership(MyoArena in_Arena);\n-\n-/** @fn extern MyoError myoArenaGetHandle(void *in_pPtr, \n- * MyoArena *out_pArena)\n- * @brief Gets the arena handle of the arena that contains the memory\n- * space pointed to by \"in_pPtr\". This API can be used when it is \n- * not clear which arena handle should be used for other arena \n- * related APIs.\n- * \n- * @param in_pPtr The start address of a chunk of memory space.\n- * @param out_pArena Handle of the arena.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-CILK_SHARED MyoError myoArenaGetHandle(void *in_pPtr, MyoArena *out_pArena);\n-\n-/********************************************************************************\n-    APIs for the default arena\n- *******************************************************************************/\n-\n-/**\n- * There will be a default arena inside MYO runtime, which will be used when\n- * there is no specified arena.\n- **/\n-\n-/** @fn extern void* myoSharedMalloc(size_t in_Size)\n- * @brief Allocates size bytes from the default arena, and returns the\n- * start address of the allocated memory. The memory is not cleared.\n- *\n- @param in_Size Size (bytes) of the required memory space.\n- * @return \n- *      The start address of the allocated memory space.\n- *      NULL: Failed.\n- **/\n-MYOACCESSAPI\n-void* myoSharedMalloc(size_t in_Size);\n-\n-/** @fn extern void  myoSharedFree(void *in_pPtr)\n- * @brief Frees the memory space allocated by myoArenaMalloc to the\n- * default arena.\n- *\n- * @param in_pPtr The start address of the specified memory space,\n- * which must be retured by myoSharedMalloc.\n- * @return\n- **/\n-MYOACCESSAPI\n-void  myoSharedFree(void *in_pPtr);\n-\n-/** @fn extern void* myoSharedAlignedMalloc(size_t in_Size, \n- * size_t in_Alignment)\n- * @brief Allocates size bytes from the default arena. The start \n- * address of the allocated memory will be a multiple of alignment, \n- * which must be a power of two.\n- *\n- * @param in_Size Size (bytes) of the required memory space.\n- * @param in_Alignment The alignment value, which must be an power of two.\n- * @return\n- *      The start address of the allocated memory space.\n- *      NULL: Failed.\n- **/\n-MYOACCESSAPI\n-void* myoSharedAlignedMalloc(size_t in_Size, size_t in_Alignment);\n-\n-/** @fn extern void  myoSharedAlignedFree(void *in_pPtr)\n- * @brief Frees the memory space allocated by myoArenaAlignedMalloc \n- * to the default arena.\n- *\n- * @param in_pPtr The start address of the specified memory space,\n- *      which must be returned by myoArenaAlignedMalloc.\n- * @return\n- **/\n-MYOACCESSAPI\n-void  myoSharedAlignedFree(void *in_pPtr);\n-\n-/** @fn extern MyoError myoAcquire()\n- * @brief myoAcquire is the sync point for the default arena with\n- * \"Release Consistency\". myoAcquire is used to obtain all stores of\n- * the default arena that have been made globally visible prior to \n- * this point.\n- *\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoAcquire();\n-\n-/** @fn extern MyoError myoRelease()\n- * @brief myoRelease is the sync point for the default arena with\n- * \"Release Consistency\". myoRelease is used to flush all prior stores\n- * of the default arena to be globally visible.\n- *\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoRelease();\n-\n-/** @fn extern MyoError myoAcquireOwnership()\n- * @brief Changes the ownership type of the default arena to \n- * MYO_ARENA_MINE.\n- *\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoAcquireOwnership();\n-\n-/** @fn extern MyoError myoReleaseOwnership()\n- * @brief Change the ownership type of the default arena to \n- * MYO_ARENA_OURS.\n- *\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoReleaseOwnership();\n-\n-/*****************************************************************************\n-    APIs for global sync operations.\n- *****************************************************************************/\n-\n-/** @fn extern MyoError myoMutexCreate(MyoMutex *out_pMutex)\n- * @brief Create a mutex and return the mutex handle.\n- *\n- * @param out_pMutex Used to store the handle of the created mutex.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoMutexCreate(MyoMutex *out_pMutex);\n-\n-/** @fn extern MyoError myoMutexLock(MyoMutex in_Mutex)\n- * @brief Lock the mutex. If the mutex is already locked by other peers,\n- * the call blocks until the mutex becomes available. Currently, \n- * attempting to re-acquire the mutex will cause a deadlock.\n- *\n- * @param in_Mutex the mutex handle returned by myoMutexCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoMutexLock(MyoMutex in_Mutex);\n-\n-/** @fn extern MyoError myoMutexUnlock(MyoMutex in_Mutex)\n- * @brief Release the locked mutex.\n- * Currently, attempting to release an unlocked mutex will cause\n- * undefined results.\n- *\n- * @param in_Mutex the mutex handle returned by myoMutexCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoMutexUnlock(MyoMutex in_Mutex);\n-\n-/** @fn extern MyoError myoMutexTryLock(MyoMutex in_Mutex)\n- * @brief Try to lock the mutex. myoMutexTryLock is equivalent to \n- * myoMutexLock, except that myoMutexLock will return immediately if \n- * the mutex is already locked.\n- *\n- * @param in_Mutex the mutex handle returned by myoMutexCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoMutexTryLock(MyoMutex in_Mutex);\n-\n-/** @fn extern MyoError myoMutexDestroy(MyoMutex in_Mutex)\n- * @brief Destroy the mutex.\n- *\n- * @param in_Mutex the mutex handle returned by myoMutexCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoMutexDestroy(MyoMutex in_Mutex);\n-\n-/** @fn extern MyoError myoSemCreate(int in_Value, MyoSem *out_pSem)\n- * @brief Create a semaphore and return the semaphore handle.\n- *\n- * @param in_Value the initial value for the semaphore.\n- * @param out_pSem Used to store the handle of the created semaphore.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoSemCreate(int in_Value, MyoSem *out_pSem);\n-\n-/** @fn extern MyoError myoSemWait(MyoSem in_Sem)\n- * @brief Decrements (locks) the semaphore. If the semaphore value is\n- * greater than zero, then the decrement proceeds and the function\n- * returns immediately, or else the call blocks until the semaphore\n- * value rises above zero.\n- *\n- * @param in_Sem the semaphore handle returned by myoSemCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoSemWait(MyoSem in_Sem);\n-\n-/** @fn extern MyoError myoSemPost(MyoSem in_Sem)\n- * @brief Increments (unlocks) the semaphore. If the semaphore value\n- * becomes greater than zero, one blocked myoSemWait call will be \n- * notified to return.\n- *\n- * @param in_Sem the semaphore handle returned by myoSemCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoSemPost(MyoSem in_Sem);\n-\n-/** @fn extern MyoError myoSemTryWait(MyoSem in_Sem)\n- * @brief Try to lock semaphore. myoSemTryWait is the same as \n- * myoSemAcquire, except that if the decrement cannot be immediately \n- * performed, then the call returns instead of blocking.\n- *\n- * @param in_Sem the semaphore handle returned by myoSemCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoSemTryWait(MyoSem in_Sem);\n-\n-/** @fn extern MyoError myoSemDestroy(MyoSem in_Sem)\n- * @brief Destroy the semaphore.\n- *\n- * @param in_Sem the semaphore handle returned by myoSemCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoSemDestroy(MyoSem in_Sem);\n-\n-/** @fn extern MyoError myoBarrierCreate(int in_Count, MyoBarrier *out_pBarrier) \n- * @brief Create a barrier and return the barrier handle.\n- *\n- * @param in_Count the number of threads that must call\n- * myoBarrierWait before any of them successfully return.\n- * @param out_pBarrier Used to store the handle of the created \n- * barrier.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoBarrierCreate(int in_Count, MyoBarrier *out_pBarrier);\n-\n-/** @fn extern MyoError myoBarrierWait(MyoBarrier in_Barrier)\n- * @brief The caller will block until the required number of threads \n- * have called myoBarrierWait with the same barrier handle.\n- *\n- * @param in_Barrier the barrier handle returned by myoBarrierCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoBarrierWait(MyoBarrier in_Barrier);\n-\n-/** @fn extern MyoError myoBarrierDestroy(MyoBarrier in_Barrier)\n- * @brief Destroy the barrier.\n- *\n- * @param in_Barrier the barrier handle returned by myoBarrierCreate.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoBarrierDestroy(MyoBarrier in_Barrier);\n-\n-/*****************************************************************************\n-    MISC APIs.\n- *****************************************************************************/\n-\n-/**\n- * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n- **/\n-\n-MYOACCESSAPI\n-int myoMyId();\n-/* int myoNumNodes() returns the number of peers, minus one, to\n-   equal the number of cards in the system. */\n-MYOACCESSAPI\n-int myoNumNodes();\n-\n-MYOACCESSAPI\n-unsigned long long myoTicks();\n-MYOACCESSAPI\n-unsigned long long myoWallTime();\n-MYOACCESSAPI\n-void myoStatOn();\n-MYOACCESSAPI\n-void myoStatOff();\n-\n-/** @fn extern MyoError myoGetMemUsage(uint64 *out_memUsedMB) \n- * @brief Retrieves the amount of shared memory currently used.\n- * myoGetMemUsage() fills in out_memUsedMB when the pointer is not NULL.\n- *\n- * @param out_memUsedBytes, pointer to the current size shared memory used.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoGetMemUsage(unsigned int *out_memUsedMB);\n-\n-/** @fn extern MyoError myoHTimeOn(int in_On) \n- * @brief Toggle MYO HTime report feature on/off.\n- *\n- * @param in_On: 1 turn on MYO HTime report\n- *               0 turn off MYO HTime report\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-extern MyoError myoHTimeOn(int in_On);\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif\n-\n- /**\n- * @endcond\n- **/\n-\n-/*! @} */"}, {"sha": "c5a1a41935ed34368279d7c8f1323d48d61874ec", "filename": "liboffloadmic/include/myo/myoimpl.h", "status": "removed", "additions": 0, "deletions": 619, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,619 +0,0 @@\n-/*\n- * Copyright 2010-2015 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-/**\n- Description:\n-    Define APIs of MYO for compiler or pre-processor to transfer original programs.\n- */\n-\n-#ifndef _MYO_IMPL_H_\n-#define _MYO_IMPL_H_\n-\n-/** @ingroup MYO\n- *  @addtogroup MYOIMPL_API\n-@{\n-* @file myoimpl.h \n-*/\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#define EXTERN_C extern \"C\"\n-#else\n-#define EXTERN_C /* nothing */\n-#endif\n-\n-#       define MYOACCESSAPI /* nothing */\n-\n-#ifdef DEFINE_ARENA_API_CILK_SHARED\n-#define CILK_SHARED _Cilk_shared\n-#else\n-#define CILK_SHARED /* nothing */\n-#endif\n-\n-/* **************************************************************************** *\\\n-    APIs to enable functions being remotely called\n-\\* **************************************************************************** */\n-\n-typedef void *(*MyoiRemoteFuncType)(void *);\n-\n-/** @fn extern MyoError myoiRemoteFuncRegister(MyoiRemoteFuncType in_pFuncAddr,\n- * const char *in_pFuncName)\n- * @brief Register a function so that it can be remotely called. This should be\n- * done in myoiUserInit or before calling myoiLibInit. After myoiLibInit,\n- * there will be a table on all peers, which contains the information for\n- * all remotely callable functions.\n- *\n- * @param in_pWrapFuncAddr address of the wrapper function.\n- * @param in_pFuncName name of the function.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-\n-MYOACCESSAPI\n-MyoError myoiRemoteFuncRegister(MyoiRemoteFuncType in_pFuncAddr,\n-        const char *in_pFuncName);\n-/** @fn extern MyoError myoiRemoteFuncLookupByName(char *in_pFuncName, \n- * MyoiRemoteFuncType *out_pWrapFuncAddr)\n- * @brief Get the address of the wrapper function by looking up the table\n- * by name. This API can be used when assigning a function pointer to\n- * remotely callable functions.\n- *\n- * @param in_pFuncName name of the function.\n- * @param out_pWrapFuncAddr address of the wrapper function.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI MyoError myoiRemoteFuncLookupByName(char *in_pFuncName,\n-        MyoiRemoteFuncType *out_pWrapFuncAddr);\n-\n-/** @fn extern MyoError myoiRemoteFuncLookupByAddr(MyoiRemoteFuncType \n- * in_pWrapFuncAddr,char **out_pFuncName)\n- * @brief Get the name of a remote function by looking up the table by\n- * the address. This API can be used when calling a remotely callable \n- * function by a function pointer.\n- *\n- * @param in_pWrapFuncAddr address of the function.\n- * @param out_pFuncName name of the function.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI MyoError myoiRemoteFuncLookupByAddr(MyoiRemoteFuncType in_pWrapFuncAddr,\n-        char **out_pFuncName);\n-\n-//! Host Side Shared Function Pointer Entry Struct\n-typedef struct {\n-    //! Function Name\n-    const char *funcName;\n-    //! Function Address\n-    void *funcAddr;\n-    //! Local Thunk Address\n-    void *localThunkAddr;\n-} MyoiHostSharedFptrEntry;\n-\n-//! Target Side Shared Function Pointer Entry Struct\n-typedef struct {\n-    //! Function Name\n-    const char *funcName;\n-    //! Function Address\n-    void *funcAddr;\n-    //! Wrap Function Address\n-    void *wrapFuncAddr;\n-    //! Locak Thunk Address\n-    void *localThunkAddr;\n-} MyoiTargetSharedFptrEntry;\n-\n-/**\n- * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n- * @fn extern MyoError myoiHostFptrTableRegister(void *in_pAddrOfFptrTable, \n- * int in_NumEntry, int in_Ordered)\n- * @brief Register shared functions on host side. A 16 byte thunk will be \n- * allocated for each function entry in non-coherent shared memory. The \n- * thunk will contain a jump instruction to the local version of the \n- * shared function, which is provided by the second item of the function \n- * entry. Also, the address of the thunk will be stored to the 3rd item \n- * of the function entry for Compiler usage.\n- *\n- * @param in_pAddrOfFptrTable start address of the shared function \n- * table, assuming it follows the format of MyoiHostSharedFptrEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @param in_Ordered whether the table is ordered by function name.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiHostFptrTableRegister(\n-        void *in_pAddrOfFptrTable, int in_NumEntry, int in_Ordered);\n-\n-/** @fn extern MyoError myoiTargetFptrTableRegister(void *in_pAddrOfFptrTable,\n- * int in_NumEntry, int in_Ordered)\n- * @brief Register shared functions on target side. This function is the \n- * same as myoiHostFptrTableRegister, except it does not need to allocate \n- * thunks from non-coherent shared memory for each function entry, but \n- * instead looks up this information from a table retrieved from the \n- * Host side.\n- *\n- * @param in_pAddrOfFptrTable start address of the shared function \n- * table, assuming it follows the format of MyoiTargetSharedFptrEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @param in_Ordered whether the table is ordered by function name.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-extern MyoError myoiTargetFptrTableRegister(\n-        void *in_pAddrOfFptrTable, int in_NumEntry, int in_Ordered);\n-/**\n- * @endcond\n- **/\n-\n-/* *************************************************************************** *\\\n-    APIs for remote function calls\n-\\* *************************************************************************** */\n-\n-typedef void * MyoiRFuncCallHandle;\n-\n-/** @fn extern MyoiRFuncCallHandle myoiRemoteCall(char *in_pFuncName, \n- * void *in_pArgs, int in_deviceNum)\n- * @brief Call a remote callable function. If there are multiple arguments \n- * for the function, pack them to a shared buffer beforehand and take the\n- * address of the shared buffer as this function. After receiving the call \n- * requests from other peers, the arguments should be unpacked from the \n- * shared buffer before calling the target function. The shared buffer \n- * can also be used to store the return value of the function.\n- *\n- * @param in_pFuncName name of the function.\n- * @param in_pArgs address of the shared buffer.\n- * @return\n- *      Handle used to check the result.\n- **/\n-MYOACCESSAPI\n-MyoiRFuncCallHandle myoiRemoteCall(const char *in_pFuncName, void *in_pArgs, int in_deviceNum);\n-\n-/**\n- * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n- * @fn extern MyoError myoiRemoteThunkCall(void *in_funcThunkAddr, void *in_pArgs, int in_deviceNum)\n- * @brief Call a remote callable function. If there are multiple arguments for \n- * the function, pack them to a shared buffer beforehand and take the address\n- * of the shared buffer as this function. After receiving the call requests\n- * from other peers, the arguments should be unpacked from the shared buffer\n- * before calling the target function. The shared buffer can also be used to \n- * store the return value of the function.\n- *\n- * @param in_funcThunkAddr pointer to function thunk in the non-coherent\n- * shared memory.\n- * @param in_pArgs address of the shared buffer.\n- * @PARAM in_deviceNum: device ID (0-N-1) for the MIC device to run \n- * function call.  -1 request causes MYO to schedule an available device.  \n- * For RPC from device to host, in_deviceNum should always be -1.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiRemoteThunkCall(void *in_funcThunkAddr, void *in_pArgs, int in_deviceNum);\n-/**\n- * @endcond\n- **/\n-\n-/** @fn extern MyoError myoiCheckResult(MyoiRFuncCallHandle in_Handle)\n- * @brief Check whether the remote call is done.\n- *\n- * @param in_Handle handle of the remote call.\n- * @return\n- *      MYO_SUCCESS (done); or\n- *      an error number to indicate the error.\n- **/\n-extern MyoError myoiCheckResult(MyoiRFuncCallHandle in_Handle);\n-\n-/** @fn extern MyoError myoiGetResult(MyoiRFuncCallHandle in_Handle)\n- * @brief Wait till the remote call is done.\n- *\n- * @param in_Handle handle of the remote call.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiGetResult(MyoiRFuncCallHandle in_Handle);\n-\n-/* **************************************************************************** *\\\n-    APIs related with shared variables.\n-\\* **************************************************************************** */\n-\n-/* \n- * It is Compiler's responsibility to make sure all shared variables\n- * located in shared memory space and have the same address in all sides.\n- * However, it is hard for Compiler to do this. So we propose a solution\n- * which is changing the definition of all shared variables and accessing\n- * them indirectly, and making sure all shared variables pointing\n- * to the same shared space on all sides. For example,\n- *\n- * \"shared int a;\" is changed to \"shared int *a\";\n- * Also all the accesses to \"a\" is change to \"*a\".\n- *\n- * We suppose the shared memory for each shared variable is allocated on\n- * host side by Compiler. For the upper example, Compiler can call:\n- *\n- * a = (shared int *) myoSharedMalloc(sizeof(shared int));\n- *\n- * Now the issue is how to make \"a\" on other sides also pointing to the\n- * same shared memory on other sides. We provide two methods to do this.\n- * They can be used in a hybrid way.\n- */\n-\n-/* \n- * The first method is calling myoiVarRegister for each shared variable\n- * on all sides in myoiUserInit. On host side, we will get a table containing\n- * a table containing the shared address and name of each shared variable.\n- * After calling myoiUserInit, we will propagate the table to other sides.\n- * On card side, after getting the table from host, myoiUserInit is called.\n- * When calling myoiVarRegister in myoiUserInit, we will make local pointer\n- * of each shared variable pointing to the same shared memory with the local\n- * pointer on host side of the same shared variable pointing to.\n- */\n-\n-/* \n- * The second method suppose that Compiler already have a table on all sides.\n- * On host side, the table contains the name and the shared address of each\n- * shared variable. On card side, the table contains the name of each shared\n- * variable and the address of the local pointer which will pointing to shared\n- * memory space.\n- *\n- * On host side, Compiler generates a call to myoiHostVarTablePropagate\n- * after initializing MYO runtime and making the host side table ready.\n- * On card side, Compiler uses myoiMicVarTableRegister to tell\n- * the runtime where the card side table is.\n- *\n- * Since there may be multiple libraries on card side for the same application,\n- * myoiHostVarTablePropagate and myoiMicVarTableRegister can be called multiple\n- * times and called simultaneously.\n- *\n- * Inside runtime, the local pointer of the same shared variable on all sides\n- * will be make sure pointing to the same shared space by using the information\n- * of the Compiler provided tables.\n- */\n-\n-/* \n- * Comipler knows the following two structures to make sure the var table\n- * has the following format.\n- */\n-\n-/* \n- * This is structure of the Shared var table entry. This table contains \n- * the shared address and name of each shared variable\n- */\n-\n-/** @fn extern MyoError myoiVarRegister(void *in_pAddrOfLocalPtrToShared, char *in_pSVarName)\n- * @brief Register shared variables. Call it on all sides in myoiUserInit. \n- * On host side, make sure calling it after allocating shared memory for \n- * the shared variables by calling myoSharedMalloc.\n- *\n- * @param in_pAddrOfLocalPtrToShared the address assigned by the compiler \n- * for the shared variable, which is the address of a local pointer, \n- * pointing to shared memory space.\n- * @param in_pSVarName name of shared variable.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiVarRegister(\n-        void *in_pAddrOfLocalPtrToShared, const char *in_pSVarName);\n-\n-/*\n- * Compiler knows the following two structures to make sure the var table\n- * has the following format.\n- */\n-\n-/**\n- * This is structure of the Shared var table entry. This table contains \n- * the shared address and name of each shared variable\n- **/\n-typedef struct {\n-    //! Variable Name\n-    const char *varName;\n-    //! Shared Address\n-    void *sharedAddr;\n-} MyoiSharedVarEntry;\n-\n-//! Structure of the var table entry on host\n-typedef struct {\n-    //! Variable Name\n-    const char *varName;\n-    //! Variable Size\n-    int size;\n-    //! Local pointer to Shared var\n-    void *ptrToLocalPtrToShared;\n-} MyoiHostSharedVarEntry;\n-\n-//! Structure of the var table entry on card \n-typedef struct {\n-    //! Variable Name\n-    const char *varName;\n-    //! Local pointer to Shared var\n-    void *ptrToLocalPtrToShared;\n-} MyoiMicSharedVarEntry;\n-\n-/** @fn extern MyoError myoiHostVarTablePropagate(void *in_pAddrOfSVarTable, int in_NumEntry)\n- * @brief Send the host side var table to the card side. Card side will also \n- * have a copy of the host side var table after this propagation, although it \n- * is in an internal format different than the original host side var table, \n- * due to implementation convenience.\n- *\n- * @param in_pAddrOfSVarTable start address of the host side var table,\n- * assuming it follows the format of MyoiSharedVarEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI MyoError myoiHostVarTablePropagate(\n-        void *in_pAddrOfSVarTable, int in_NumEntry);\n-\n-/**\n- * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n- * @fn extern MyoError myoiMicVarTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry)\n- * @brief Tell the runtime where the card side table is.\n- *\n- * @param in_pAddrOfSVarTable start address of the card side var\n- * table, assuming it follows the format of MyoiMicSharedVarEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-extern MyoError myoiMicVarTableRegister(\n-        void *in_pAddrOfSVarTable, int in_NumEntry);\n-/**\n- * @endcond\n- **/\n-\n-/** @fn MyoError myoiHostSharedMallocTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered)\n- * @brief Allocate shared memory for all shared variables in the table. \n- * Also update local address of the shared variable with new shared address.\n- *\n- * @param in_pAddrOfSVarTable start address of the shared variable table,\n- * assuming it follows the format of MyoiHostSharedVarEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @param in_Ordered whether the table ordered by name.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiHostSharedMallocTableRegister(\n-        void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered);\n-\n-/** @fn extern MyoError myoiTargetSharedMallocTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered)\n- * @brief Register the shared variables on the target side.\n- *\n- * @param in_pAddrOfSVarTable start address of the shared varaible table,\n- * assuming it follows the format of MyoiMicSharedVarEntry.\n- * @param in_NumEntry number of entry in the table.\n- * @param in_Ordered whether the table ordered by name.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-extern MyoError myoiTargetSharedMallocTableRegister(\n-        void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered);\n-\n-/** @fn MyoError myoiLibInit(void * in_args, void (*userInitFunc))\n- * @brief Init entry of the MYO library responsible for initializing \n- * the runtime.\n- *\n- * @param in_args mechanism to pass arguments to the Initialization \n- * routine. The default value of NULL would mean the host is blocked \n- * on the completion of myoiLibInit() on all nodes. A subset of the \n- * installed cards can be intialized by passing an array of \n- * MyoiUserParams. For example, in a system with two cards, to run a\n- * MYO application only on the second card, intialize the array as \n- * follows:\n- *      @code \n- *      MyoiUserParams UserParas[64];\n- *      UserParas[0].type = MYOI_USERPARAMS_DEVID; \n- *      UserParas[0].nodeid = 2;\n- *      UserParas[1].type = MYOI_USERPARAMS_LAST_MSG;\n- *      if(MYO_SUCCESS != myoiLibInit(&UserParas, (void*)&myoiUserInit)) {\n- *          printf(\"Failed to initialize MYO runtime\\n\");\n- *          return -1;\n- *      }\n- *      @endcode\n- * This intialization is required only in the client/host side\n- * of the application. The server/card side executable should be\n- * executed only on the second card in this case.\n- *\n- * Another capability for the MyoiUserParams structure in MYO is specifying\n- * a remote procedure call to be executed on the host or card, immediately after\n- * myoiLibInit() completes. This capability is useful because some calls in\n- * MYO return immediately, but do not actually complete until after the MYO\n- * library is completely initialized on all peers.  An example follows,\n- * showing how to cause MYO to execute the registered function named\n- * \"PostMyoLibInitFunction\" on the first card only:\n- *      @code\n- *      MyoiUserParams UserParas[64];\n- *      UserParas[0].type = MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n- *      UserParas[0].nodeid = 1;\n- *      SetPostLibInitFuncName(UserParas[1], \"PostMyoLibInitFunction\");\n- *      UserParas[2].type = MYOI_USERPARAMS_LAST_MSG;\n- *      if(MYO_SUCCESS != myoiLibInit(&UserParas, (void*)&myoiUserInit)) {\n- *          printf(\"Failed to initialize MYO runtime\\n\");\n- *          return -1;\n- *      }\n- *      @endcode\n- *\n- * Note, to cause PostMyoLibInitFunction to be executed on ALL cards,\n- * specify: MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES for the nodeid.\n- * That is:\n- *      @code\n- *      UserParas[0].nodeid = MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES;\n- *      @endcode\n- *\n- * @param userInitFunc Shared variables and remote functions are\n- * registered in this routine, which is called by the runtime during\n- * library initialization. \n- * @return\n- *      MYO_SUCCESS;\n- *      MYO_ERROR;\n- **/\n-MYOACCESSAPI\n-MyoError myoiLibInit(void * in_args, void *userInitFunc /*userInitFunc must be: MyoError (*userInitFunc)(void) */);\n-\n-/** @fn extern MyoError myoiSupportsFeature(MyoFeatureType myoFeature)\n- * @brief Supports runtime query to determine whether a feature is supported\n- * by the myo that is installed on the system. This function is intended to\n- * support client code to query the myo library to determine whether its set\n- * of capabilities are able to support the client's needs.\n- *\n- * @param myoFeature The feature that is to be inquired about.\n- * @return\n- *      MYO_SUCCESS; if the feature is supported.\n- *      MYO_FEATURE_NOT_IMPLEMENTED if the feature is not supported.\n- *\n- * (For more information, please also see the declaration of the MyoFeatureType enum declaration.)\n- **/\n-MYOACCESSAPI\n-MyoError myoiSupportsFeature(MyoFeatureType myoFeature);\n-\n-/** @fn void myoiLibFini()\n- * @brief Finalize the MYO library, all resources held by the runtime are \n- * released by this routine.\n- *\n- * @return\n- **/\n-MYOACCESSAPI\n-void myoiLibFini();\n-\n-/* *************************************************************************** *\\\n-    APIs to set shared memory space consistent/non-consistent.\n-\\* *************************************************************************** */\n-\n-/** @fn extern MyoError myoiSetMemNonConsistent(void *in_pAddr, size_t in_Size)\n- * @brief Set part of the shared memory space to be non-consistent, which\n- * means that the consistency of this part of shared memory space does not \n- * need to be maintained between HOST and cards.\n- *\n- * @param in_pAddr The start address of the specified shared memory space;\n- * @param in_Size The size of the specified shared memory space;\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiSetMemNonConsistent(void *in_pAddr, size_t in_Size);\n-\n-/** @fn extern MyoError myoiSetMemConsistent(void *in_pAddr, size_t in_Size)\n- * @brief Set part of the shared memory space to be consistent, which \n- * means that the consistency of this part of shared memory space needs \n- * to be maintained between HOST and cards.\n- *\n- * @param in_pAddr The start address of the specified shared \n- * memory space.\n- * @param in_size The size of the specified shared memory space.\n- * @return\n- *      MYO_SUCCESS; or\n- *      an error number to indicate the error.\n- **/\n-MYOACCESSAPI\n-MyoError myoiSetMemConsistent(void *in_pAddr, size_t in_Size);\n-\n-/* A collection of external data symbols */\n-EXTERN_C MYOACCESSAPI unsigned int myoiMyId; /* MYO_MYID if on accelerators */\n-EXTERN_C MYOACCESSAPI volatile int myoiInitFlag;\n-\n- //! Structure of the array element that is passed to myoiLibInit() to initialize a subset of the available cards, or\n- //! to specify a remote call function to be called after successful myo library initialization:\n-typedef struct {\n-    //!type = MYOI_USERPARAMS_DEVID or  MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC for each element in the array except\n-    //!the last element, type should be: MYOI_USERPARAMS_LAST_MSG.\n-    int type;\n-    //! nodeid refers to the 'one-based' card index.  Specifying, 1 represents the first card, mic0, 2 represents the\n-    // second card, mic1, 3 represents the third card, mic2, ....).\n-    // NOTE: for type == MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC, specifying MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES\n-    // for nodeid, will execute the named function, on each card in the system, mic0, mic1, mic2, .... micn.\n-    int nodeid;\n-} MyoiUserParams;\n-\n-//!The following two types are dealt with entirely with just one MyoiUserParams structure:\n-//!MYOI_USERPARAMS_DEVID maps node ids.\n-#define MYOI_USERPARAMS_DEVID                             1\n-//!MYOI_USERPARAMS_LAST_MSG terminates the array of MyoiUserParams.\n-#define MYOI_USERPARAMS_LAST_MSG                         -1\n-\n-//!The following type requires setting the node id in a MyoiUserParams structure, and then following the struct\n-//!with a MyoiUserParamsPostLibInit union:\n-#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC            2\n-//!nodeid can be one of the following macros, or a number >=1, corresponding to the card number (1 == mic0,\n-//!2 == mic1, 3 == mic2, ....)\n-//!Setting nodeid to MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES causes the function to be called on all\n-//!cards:\n-#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES  0\n-//!Setting nodeid to MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE causes the function to be called on the\n-//!host instead of the card:\n-#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE -1\n-\n-//!The postLibInit union contains two members that serves two different purposes:\n-//!1. It can be used to stipulate the name of the function to be remotely called from host to card, on successful\n-//!myo library initialization, (member postLibInitRemoveFuncName) using the type:\n-//!MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC.   OR\n-//!2. It can be an actual function pointer (member name: postLibInitHostFuncAddress) that will be called on the host,\n-//!on successful myo library initialization, using the type: MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC, with nodeid:\n-//!MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE\n-typedef union {\n-   const char *postLibInitRemoveFuncName;\n-   void (*postLibInitHostFuncAddress)(void);\n-} MyoiUserParamsPostLibInit;\n-\n-/* These are two macros to help get the information in a MyoiUserParamsPostLibInit union from a MyoiUserParams struct; */\n-#define GetPostLibInitFuncName(USERPARAMS) ((MyoiUserParamsPostLibInit *) (& (USERPARAMS)))->postLibInitRemoveFuncName\n-#define GetPostLibInitFuncAddr(USERPARAMS) ((MyoiUserParamsPostLibInit *) (& (USERPARAMS)))->postLibInitHostFuncAddress\n-\n-/* These are two macros to help set the information in a MyoiUserParamsPostLibInit union from a MyoiUserParams struct; */\n-#define SetPostLibInitFuncName(USERPARAMS,FUNC_NAME) GetPostLibInitFuncName(USERPARAMS) = FUNC_NAME\n-#define SetPostLibInitFuncAddr(USERPARAMS,FUNC_ADDR) GetPostLibInitFuncAddr(USERPARAMS) = FUNC_ADDR\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif // _MYO_IMPL_H_\n-/*! @} */"}, {"sha": "596ad05280cbc6c20580491586ee7272ae4fd4de", "filename": "liboffloadmic/include/myo/myotypes.h", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,151 +0,0 @@\n-/*\n- * Copyright 2010-2015 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-/**\n- Description: Define the types used by APIs of MYO programming.\n- */\n-\n-#ifndef _MYO_TYPES_H_\n-#define _MYO_TYPES_H_\n-\n-#include <string.h> /* For size_t */\n-\n-/** @ingroup MYO\n- *  @addtogroup MYOTYPES\n-@{\n-* @file myotypes.h\n-*/\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/*! MYO Status\n- */\n-typedef enum {\n-    MYO_SUCCESS = 0,      /*!< Success */\n-    MYO_ERROR,            /*!< Error */\n-\n-    MYO_INVALID_ENV,      /*!< Invalid Env */\n-    MYO_INVALID_ARGUMENT, /*!< Invalid Argument */\n-\n-    MYO_NOT_INITIALIZED,  /*!< Not Initialized */\n-    MYO_ALREADY_FINALIZED,/*!< Already Finalized */\n-\n-    MYO_BUF_ERROR,        /*!< Buffer Error */\n-    MYO_OUT_OF_RANGE,     /*!< Out of Range */\n-    MYO_OUT_OF_MEMORY,    /*!< Out of Memory */ \n-\n-    MYO_ALREADY_EXISTS,   /*!< Already Exists */\n-\n-    MYO_EOF,              /*!< EOF */\n-    MYO_FEATURE_NOT_IMPLEMENTED = -1,  /*!< Feature not implemented (see myoiSupportsFeature(). */\n-} MyoError;\n-\n-\n-/*! Arena  Ownership */\n-typedef enum {\n-    MYO_ARENA_MINE = 1, /*!< Arena MINE Ownership */ \n-    MYO_ARENA_OURS,     /*!< Arena OURS Ownership */\n-} MyoOwnershipType;\n-\n-  /*! MYO Features */\n-typedef enum {\n-                                                         /*!< EVERY VALUE that is less than MYO_FEATURE_BEGIN is not implemented.       */\n-  MYO_FEATURE_BEGIN         = 1,                         /*!< The first feature that is supported.                                      */\n-  MYO_FEATURE_POST_LIB_INIT = MYO_FEATURE_BEGIN,         /*!< Allows specifying a function to be executed immediately                   */\n-                                                         /*   after myoiLibInit() completes. This feature was implemented in version    */\n-                                                         /*     3.3 of MPSS.                                                            */\n-  /* MYO_FEATURE_FUTURE_CAPABILITY     = 2,   at some time in the future, as new features are added to MYO, new enumeration constants   */\n-  /*                                 will be added to the MyoFeatureType, and the value of the new enumeration constant will be greater */\n-  /*                                 than the current value of MYO_FEATURE_LAST constant, and then the MYO_FEATURE_LAST constant too,   */\n-  /*                                 will be changed to be the value of the new enumeration constant.  For example, in April, 2014,     */\n-  /*                                 the POST_LIB_INIT feature was implemented in version 3.3 of MPSS, and the MYO_FEATURE_BEGIN        */\n-  /*                                 enumeration constant is the same as the MYO_FEATURE_LAST enumeration constant, and both are equal  */\n-  /*                                 to 1.                                                                                              */\n-  /*                                 Suppose in December, 2014, a new feature is added to the MYO library, for version 3.4 of MPSS.     */\n-  /*                                 Then, MYO_FEATURE_BEGIN enumeration constant will be still the value 1, but the MYO_FEATURE_LAST   */\n-  /*                                 enumeration constant will be set to 2.                                                             */\n-  /*                                 At runtime, one client binary can determine if the MYO that is installed is capable of any         */\n-  /*                                 capability.  For example, suppose a future client binary queries version 3.3 of MYO if it is       */\n-  /*                                 capable of some future feature.  Version 3.3 of MYO will indicate that the feature is not          */\n-  /*                                 implemented to the client.  But, conversely, suppose the future client queries version 3.4 of MYO  */\n-  /*                                 if it is capable of some future feature.  Version 3.4 of MYO will indicate that the feature isd    */\n-  /*                                 supported.                                                                                         */\n-  /*                                                                                                                                    */\n-  /*   Date:        |  MYO_FEATURE_BEGIN: |  MYO_FEATURE_LAST: | MPSS VERSION: | myoiSupportsFeature(MYO_FEATURE_FUTURE_CAPABILITY)     */\n-  /* ---------------+---------------------+--------------------+---------------+---------------------------------------------------     */\n-  /* April, 2014    |         1           |         1          |     3.3       | MYO_FEATURE_NOT_IMPLEMENTED                            */\n-  /* December, 2014 |         1           |         2          |     3.4       | MYO_SUCCESS                                            */\n-  /* ---------------+---------------------+--------------------+---------------+---------------------------------------------------     */\n-  MYO_FEATURE_LAST          = MYO_FEATURE_POST_LIB_INIT, /*!< The last feature that is supported.                                       */\n-                                                         /*!< EVERY VALUE that is greater than MYO_FEATURE_LAST is not implemented.     */\n-  /*!< EVERY VALUE that is greater than or equal to MYO_FEATURE_BEGIN AND less than or equal to MYO_FEATURE_LAST is implemented.        */\n-} MyoFeatureType;  /* (For more information, please also see myoiSupportsFeature() function declaration.)  */\n-\n-/*************************************************************\n- *  define the property of MYO Arena \n- ***********************************************************/\n-#define MYO_CONSISTENCY_MODE            0x3\n-#define MYO_RELEASE_CONSISTENCY         0x1\n-#define MYO_STRONG_RELEASE_CONSISTENCY  0x2\n-#define MYO_STRONG_CONSISTENCY          0x3\n-#define MYO_UPDATE_ON_DEMAND            0x8\n-#define MYO_UPDATE_ON_ACQUIRE           0x10\n-#define MYO_RECORD_DIRTY                0x20\n-#define MYO_NOT_RECORD_DIRTY            0x40\n-#define MYO_ONE_VERSION                 0x80\n-#define MYO_MULTI_VERSIONS              0x100\n-#define MYO_CONSISTENCY                 0x200\n-#define MYO_NO_CONSISTENCY              0x400\n-#define MYO_HOST_TO_DEVICE              0x800\n-#define MYO_DEVICE_TO_HOST              0x1000\n-#define MYO_HYBRID_UPDATE               0x2000\n-typedef unsigned int MyoArena;\n-\n-typedef void * MyoMutex;\n-typedef void * MyoSem;\n-typedef void * MyoBarrier;\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif // _MYO_TYPES_H_\n-/*! @} */"}, {"sha": "d80c970add077a49e7bb0d28e04edf44ded60642", "filename": "liboffloadmic/plugin/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.am?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -59,7 +59,7 @@ else # PLUGIN_TARGET\n   plugin_include_HEADERS = main_target_image.h\n   AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n   AM_CXXFLAGS = $(CXXFLAGS)\n-  AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lmyo-service -lgomp -rdynamic\n+  AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lgomp -rdynamic\n endif\n \n main_target_image.h: offload_target_main"}, {"sha": "e052a4e4b7f8e7e29e92dc1a8b74f29b33548f05", "filename": "liboffloadmic/plugin/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.in?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -326,7 +326,7 @@ target_install_dir = $(accel_search_dir)/lib/gcc/$(accel_target)/$(gcc_version)$\n @PLUGIN_HOST_FALSE@plugin_include_HEADERS = main_target_image.h\n @PLUGIN_HOST_FALSE@AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n @PLUGIN_HOST_FALSE@AM_CXXFLAGS = $(CXXFLAGS)\n-@PLUGIN_HOST_FALSE@AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lmyo-service -lgomp -rdynamic\n+@PLUGIN_HOST_FALSE@AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lgomp -rdynamic\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "26d68b49626b1ccaad3fcce6ec9a3d1fc31e4624", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,6 +1,6 @@\n /* Plugin for offload execution on Intel MIC devices.\n \n-   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Copyright (C) 2014-2016 Free Software Foundation, Inc.\n \n    Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n \n@@ -40,8 +40,6 @@\n #include \"main_target_image.h\"\n #include \"gomp-constants.h\"\n \n-#define LD_LIBRARY_PATH_ENV\t\"LD_LIBRARY_PATH\"\n-#define MIC_LD_LIBRARY_PATH_ENV\t\"MIC_LD_LIBRARY_PATH\"\n #define OFFLOAD_ACTIVE_WAIT_ENV\t\"OFFLOAD_ACTIVE_WAIT\"\n \n #ifdef DEBUG\n@@ -134,41 +132,12 @@ __attribute__((constructor))\n static void\n init (void)\n {\n-  const char *ld_lib_path = getenv (LD_LIBRARY_PATH_ENV);\n-  const char *mic_lib_path = getenv (MIC_LD_LIBRARY_PATH_ENV);\n   const char *active_wait = getenv (OFFLOAD_ACTIVE_WAIT_ENV);\n \n   /* Disable active wait by default to avoid useless CPU usage.  */\n   if (!active_wait)\n     setenv (OFFLOAD_ACTIVE_WAIT_ENV, \"0\", 0);\n \n-  if (!ld_lib_path)\n-    goto out;\n-\n-  /* Add path specified in LD_LIBRARY_PATH to MIC_LD_LIBRARY_PATH, which is\n-     required by liboffloadmic.  */\n-  if (!mic_lib_path)\n-    setenv (MIC_LD_LIBRARY_PATH_ENV, ld_lib_path, 1);\n-  else\n-    {\n-      size_t len = strlen (mic_lib_path) + strlen (ld_lib_path) + 2;\n-      bool use_alloca = len <= 2048;\n-      char *mic_lib_path_new = (char *) (use_alloca ? alloca (len)\n-\t\t\t\t\t\t    : malloc (len));\n-      if (!mic_lib_path_new)\n-\t{\n-\t  fprintf (stderr, \"%s: Can't allocate memory\\n\", __FILE__);\n-\t  exit (1);\n-\t}\n-\n-      sprintf (mic_lib_path_new, \"%s:%s\", mic_lib_path, ld_lib_path);\n-      setenv (MIC_LD_LIBRARY_PATH_ENV, mic_lib_path_new, 1);\n-\n-      if (!use_alloca)\n-\tfree (mic_lib_path_new);\n-    }\n-\n-out:\n   address_table = new ImgDevAddrMap;\n   image_descriptors = new ImgDescMap;\n   num_devices = _Offload_number_of_devices ();"}, {"sha": "ccf7240e2864a5a8834f05752f175500fdf3a2db", "filename": "liboffloadmic/plugin/offload_target_main.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fplugin%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Foffload_target_main.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,6 +1,6 @@\n /* Plugin for offload execution on Intel MIC devices.\n \n-   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+   Copyright (C) 2014-2016 Free Software Foundation, Inc.\n \n    Contributed by Ilya Verbin <ilya.verbin@intel.com>.\n "}, {"sha": "f2c3e48a99ccdb88cab79f596aeb4596e5ad6a0c", "filename": "liboffloadmic/runtime/cean_util.cpp", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcean_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcean_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -395,4 +395,27 @@ void __arr_desc_dump(\n         generate_mem_ranges(spaces, adp, deref, &print_range, print_values);\n     }\n }\n+\n+void noncont_struct_dump(\n+    const char *spaces,\n+    const char *name,\n+    struct NonContigDesc *desc_p)\n+{\n+   OFFLOAD_TRACE(2, \"%s%s NonCont Struct expression %p\\n\",\n+                 spaces, name, desc_p->base);\n+   if (desc_p) {\n+       OFFLOAD_TRACE(2, \"%s%s    base=%p\\n\", spaces, name, desc_p->base);\n+       for (int i = 0; i < desc_p->interval_cnt; i++) {\n+           OFFLOAD_TRACE(2,\"%s    dimension %d: lower=%lld, size=%lld\\n\",\n+               spaces, i, desc_p->interval[i].lower, desc_p->interval[i].size);\n+       }\n+   }\n+}\n+\n+int64_t get_noncont_struct_size(struct NonContigDesc *desc_p)\n+{\n+    int index = desc_p->interval_cnt - 1;\n+    return(desc_p->interval[index].lower + desc_p->interval[index].size);\n+}\n+\n #endif // OFFLOAD_DEBUG"}, {"sha": "1ba8793b653863b18746fbc0ca31e68a4b2da624", "filename": "liboffloadmic/runtime/cean_util.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcean_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcean_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -66,6 +66,17 @@ struct CeanReadRanges {\n     CeanReadDim Dim[1];\n };\n \n+struct IntervalDesc {\n+    int64_t lower;   // Lower  index\n+    int64_t size;    // Size of each element at this interval\n+};\n+\n+struct NonContigDesc {\n+    int64_t base;            // Base address\n+    int64_t interval_cnt;    // Number of intervals\n+    struct IntervalDesc interval[1];\n+};\n+\n // array descriptor length\n #define __arr_desc_length(rank) \\\n     (sizeof(int64_t) + sizeof(Dim_Desc) * (rank))\n@@ -108,6 +119,14 @@ DLL_LOCAL void    __arr_desc_dump(\n     const Arr_Desc *adp,\n     bool dereference,\n     bool print_values);\n+\n+DLL_LOCAL void noncont_struct_dump(\n+    const char *spaces,\n+    const char *name,\n+    struct NonContigDesc *desc_p);\n+\n+DLL_LOCAL int64_t get_noncont_struct_size(struct NonContigDesc *desc_p);\n+\n #define ARRAY_DESC_DUMP(spaces, name, adp, dereference, print_values) \\\n     if (console_enabled >= 2) \\\n         __arr_desc_dump(spaces, name, adp, dereference, print_values);"}, {"sha": "179a3029e9c3bd1f8dbe5fa00cc17fc0e72d924d", "filename": "liboffloadmic/runtime/coi/coi_client.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -456,7 +456,7 @@ bool init(void)\n     EngineGetInfo =\n         (COIRESULT (*)(COIENGINE, uint32_t, COI_ENGINE_INFO*))\n             DL_sym(lib_handle, \"COIEngineGetInfo\", COI_VERSION1);\n-    if (COIEngineGetInfo == 0) {\n+    if (EngineGetInfo == 0) {\n         OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n                             \"COIEngineGetInfo\");\n         fini();"}, {"sha": "b5b0efc49476d497dc22b128adc196bb553cca15", "filename": "liboffloadmic/runtime/coi/coi_client.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -34,6 +34,7 @@\n #define COI_CLIENT_H_INCLUDED\n \n #include <common/COIPerf_common.h>\n+#include <common/COIMacros_common.h>\n #include <source/COIEngine_source.h>\n #include <source/COIProcess_source.h>\n #include <source/COIPipeline_source.h>"}, {"sha": "67aa991eebbcb09fd154d543cc3e43838e420ca7", "filename": "liboffloadmic/runtime/coi/coi_server.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "1afaa3bd810756b3733333f266ff631dbe2c0729", "filename": "liboffloadmic/runtime/coi/coi_server.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "4d8feb467159b6e8895514e075ca3bfc95c7b726", "filename": "liboffloadmic/runtime/compiler_if_host.cpp", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -161,6 +161,8 @@ extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n     return ofld;\n }\n \n+// This routine is called for OpenMP4.5 offload calls\n+// OpenMP 4.5 offload is always optional.\n extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n     const int*  device_num,\n     const char* file,\n@@ -171,8 +173,8 @@ extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n \n     // make sure libray is initialized and at least one device is available\n     if (!__offload_init_library()) {\n-        LIBOFFLOAD_ERROR(c_device_is_not_available);\n-        exit(1);\n+       OFFLOAD_DEBUG_TRACE(2, \"No device available, fall back to host\\n\");\n+       return NULL;\n     }\n \n     // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n@@ -377,6 +379,10 @@ static int offload_offload_wrap(\n     OffloadFlags offload_flags\n )\n {\n+    if (signal) {\n+       ofld->set_signal(*signal);\n+    }\n+\n     bool ret = ofld->offload(name, is_empty, vars, vars2, num_vars,\n                              waits, num_waits, signal, entry_id,\n                              stack_addr, offload_flags);"}, {"sha": "025f6fb2dba70d4be3c2eb9754bfa0dbd93ee2b4", "filename": "liboffloadmic/runtime/compiler_if_host.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "a44bd886147c6381e632563105bf0fb03f1afc61", "filename": "liboffloadmic/runtime/compiler_if_target.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "ebb9b73d0aa7249d220d31b572be4c70a9504535", "filename": "liboffloadmic/runtime/compiler_if_target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "f79cf1f8699a1db188217fe7bfcdc248781514cd", "filename": "liboffloadmic/runtime/dv_util.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fdv_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fdv_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "370ff01637d4b91d2b11fc8f3fe745148ed37340", "filename": "liboffloadmic/runtime/dv_util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fdv_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fdv_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "085a92d83eae9142f561ee869325f9042285a48e", "filename": "liboffloadmic/runtime/emulator/coi_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "c11214723e0fb7a18eb77ab9ca37903b366ce294", "filename": "liboffloadmic/runtime/emulator/coi_device.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "a3778baa6a2a86000625e502ad2d63937835bab7", "filename": "liboffloadmic/runtime/emulator/coi_device.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "6170d8d7f3d669bdde009bfaaf32a5cd9ab0878c", "filename": "liboffloadmic/runtime/emulator/coi_host.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -422,7 +422,7 @@ SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t in_Size,\n   const int ullong_max_len = 20;\n \n   /* Features of liboffloadmic.  */\n-  assert (in_Type == COI_BUFFER_NORMAL);\n+  assert (in_Type == COI_BUFFER_NORMAL || in_Type == COI_BUFFER_OPENCL);\n   assert ((in_Flags & COI_SINK_MEMORY) == 0);\n   assert ((in_Flags & COI_SAME_ADDRESS_SINKS) == 0);\n   assert ((in_Flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n@@ -1617,7 +1617,7 @@ SYMBOL_VERSION (COIEngineGetInfo, 1) (COIENGINE in_EngineHandle,  // Ignored\n \n   assert (out_pEngineInfo != NULL);\n \n-  out_pEngineInfo->ISA = COI_ISA_x86_64;\n+  out_pEngineInfo->ISA = COI_DEVICE_KNL;\n   out_pEngineInfo->NumCores = 1;\n   out_pEngineInfo->NumThreads = 8;\n   out_pEngineInfo->CoreMaxFrequency = SYMBOL_VERSION(COIPerfGetCycleFrequency,1)() / 1000000;"}, {"sha": "82dbc92aef849e960a6d123915800f5ac8ae121c", "filename": "liboffloadmic/runtime/emulator/coi_host.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "e64ba7dcc06445e69ffdfda5f8d3b17790af067a", "filename": "liboffloadmic/runtime/emulator/coi_version_asm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "ea180669858fb172126c2c2c9d8e7fd8bf393280", "filename": "liboffloadmic/runtime/emulator/coi_version_linker_script.map", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2015 Intel Corporation.\n+ * Copyright 2010-2016 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "d9d5f309ed18c5752d7c72940add2c1abca74bfc", "filename": "liboffloadmic/runtime/emulator/myo_client.cpp", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,31 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-/* We don't need to implement any MYO client functions.  */\n-"}, {"sha": "0473253f731c09e486c43ee27ec0241b343903c3", "filename": "liboffloadmic/runtime/emulator/myo_service.cpp", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,203 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#include \"myo_service.h\"\n-\n-#include \"myo_version_asm.h\"\n-\n-\n-extern \"C\"\n-{\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoAcquire, 1) ()\n-{\n-  MYOTRACE (\"myoAcquire\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoRelease, 1) ()\n-{\n-  MYOTRACE (\"myoRelease\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI void\n-SYMBOL_VERSION (myoSharedAlignedFree, 1) (void *ptr)\n-{\n-  MYOTRACE (\"myoSharedAlignedFree\");\n-\n-  assert (false);\n-}\n-\n-\n-MYOACCESSAPI void*\n-SYMBOL_VERSION (myoSharedAlignedMalloc, 1) (size_t size,\n-\t\t\t\t\t    size_t alignment)\n-{\n-  MYOTRACE (\"myoSharedAlignedMalloc\");\n-\n-  assert (false);\n-\n-  return 0;\n-}\n-\n-\n-MYOACCESSAPI void\n-SYMBOL_VERSION (myoSharedFree, 1) (void *ptr)\n-{\n-  MYOTRACE (\"myoSharedFree\");\n- \n-  assert (false);\n-}\n-\n-\n-MYOACCESSAPI void*\n-SYMBOL_VERSION (myoSharedMalloc, 1) (size_t size)\n-{\n-  MYOTRACE (\"myoSharedMalloc\");\n-\n-  assert (false);\n-\n-  return 0;\n-}\n-\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoiLibInit, 1) (void *args,\n-\t\t\t\t void *init_func)\n-{\n-  MYOTRACE (\"myoiLibInit\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI void\n-SYMBOL_VERSION (myoiLibFini, 1) ()\n-{\n-  MYOTRACE (\"myoiLibFini\");\n-\n-  assert (false);\n-}\n-\n-\n-MyoError\n-SYMBOL_VERSION (myoiMicVarTableRegister, 1) (void *table,\n-\t\t\t\t\t     int num)\n-{\n-  MYOTRACE (\"myoiMicVarTableRegister\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoiRemoteFuncRegister, 1) (MyoiRemoteFuncType type,\n-\t\t\t\t\t    const char *name)\n-{\n-  MYOTRACE (\"myoiRemoteFuncRegister\");\n-\n-  /* Looks like we have nothing to do here.  */\n-\n-  return MYO_SUCCESS;\n-}\n-\n-\n-MyoError\n-SYMBOL_VERSION (myoiTargetFptrTableRegister, 1) (void *table,\n-\t\t\t\t\t\t int num,\n-\t\t\t\t\t\t int ordered)\n-{\n-  MYOTRACE (\"myoiTargetFptrTableRegister\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoArenaRelease, 1) (MyoArena in_Arena)\n-{\n-  MYOTRACE (\"myoArenaRelease\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI MyoError\n-SYMBOL_VERSION (myoArenaAcquire, 1) (MyoArena in_Arena)\n-{\n-  MYOTRACE (\"myoArenaAcquire\");\n-\n-  assert (false);\n-\n-  return MYO_ERROR;\n-}\n-\n-\n-MYOACCESSAPI void\n-SYMBOL_VERSION (myoArenaAlignedFree, 1) (MyoArena in_Arena, void *in_pPtr)\n-{\n-  MYOTRACE (\"myoArenaAlignedFree\");\n-\n-  assert (false);\n-}\n-\n-\n-MYOACCESSAPI void *\n-SYMBOL_VERSION (myoArenaAlignedMalloc, 1) (MyoArena in_Arena, size_t in_Size,\n-\t\t\t\t\t   size_t in_Alignment)\n-{\n-  MYOTRACE (\"myoArenaAlignedMalloc\");\n-\n-  assert (false);\n-\n-  return 0;\n-}\n-\n-\n-} // extern \"C\"\n-"}, {"sha": "ffa4a5f8dcd83b34af34d9f522e2738eeddf2c90", "filename": "liboffloadmic/runtime/emulator/myo_service.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,63 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-#ifndef MYO_SERVICE_H_INCLUDED\n-#define MYO_SERVICE_H_INCLUDED\n-\n-#include <myo.h>\n-#include <myoimpl.h>\n-#include <myotypes.h>\n-\n-#include <assert.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#define SYMBOL_VERSION(SYMBOL,VERSION) SYMBOL ## VERSION\n-\n-#define MYOERROR(...)\t\t\t    \\\n-{\t\t\t\t\t    \\\n-  fprintf (stderr, \"MYO ERROR - TARGET: \"); \\\n-  fprintf (stderr, __VA_ARGS__);\t    \\\n-  fprintf (stderr, \"\\n\");\t\t    \\\n-  perror (NULL);\t\t\t    \\\n-  return MYO_ERROR;\t\t\t    \\\n-}\n-\n-#ifdef DEBUG\n-  #define MYOTRACE(...)\t\t\t      \\\n-  {\t\t\t\t\t      \\\n-    fprintf (stderr, \"MYO TRACE - TARGET: \"); \\\n-    fprintf (stderr, __VA_ARGS__);\t      \\\n-    fprintf (stderr, \"\\n\");\t\t      \\\n-  }\n-#else\n-  #define MYOTRACE(...) {}\n-#endif\n-\n-#endif // MYO_SERVICE_H_INCLUDED"}, {"sha": "f4db3ca4ab745713b8ee7877eb537c128c7b677e", "filename": "liboffloadmic/runtime/emulator/myo_version_asm.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2010-2015 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-/*Version for Symbols( only Functions currently versioned)\n-Only that Linux Host Side code is versioned currently*/\n-#if (! defined MYO_MIC_CARD) && (! defined _WIN32)\n-\n-   __asm__(\".symver myoArenaAlignedMalloc1,myoArenaAlignedMalloc@@MYO_1.0\");\n-   __asm__(\".symver myoArenaAlignedFree1,myoArenaAlignedFree@@MYO_1.0\");\n-   __asm__(\".symver myoArenaAcquire1,myoArenaAcquire@@MYO_1.0\");\n-   __asm__(\".symver myoArenaRelease1,myoArenaRelease@@MYO_1.0\");\n-   __asm__(\".symver myoAcquire1,myoAcquire@@MYO_1.0\");\n-   __asm__(\".symver myoRelease1,myoRelease@@MYO_1.0\");\n-   __asm__(\".symver myoSharedAlignedFree1,myoSharedAlignedFree@@MYO_1.0\");\n-   __asm__(\".symver myoSharedAlignedMalloc1,myoSharedAlignedMalloc@@MYO_1.0\");\n-   __asm__(\".symver myoSharedFree1,myoSharedFree@@MYO_1.0\");\n-   __asm__(\".symver myoSharedMalloc1,myoSharedMalloc@@MYO_1.0\");\n-   __asm__(\".symver myoiLibInit1,myoiLibInit@@MYO_1.0\");\n-   __asm__(\".symver myoiLibFini1,myoiLibFini@@MYO_1.0\");\n-   __asm__(\".symver myoiMicVarTableRegister1,myoiMicVarTableRegister@@MYO_1.0\");\n-   __asm__(\".symver myoiRemoteFuncRegister1,myoiRemoteFuncRegister@@MYO_1.0\");\n-   __asm__(\".symver myoiTargetFptrTableRegister1,myoiTargetFptrTableRegister@@MYO_1.0\");\n-\n-#endif"}, {"sha": "8f065bbb4ac41283410aa72feea1b939fb7f8b0f", "filename": "liboffloadmic/runtime/emulator/myo_version_linker_script.map", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,68 +0,0 @@\n-/*\n- * Copyright 2010-2015 Intel Corporation.\n- *\n- * This library is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU Lesser General Public License as published\n- * by the Free Software Foundation, version 2.1.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public\n- * License along with this library; if not, write to the Free Software\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n- * 02110-1301 USA.\n- *\n- * Disclaimer: The codes contained in these modules may be specific\n- * to the Intel Software Development Platform codenamed Knights Ferry,\n- * and the Intel product codenamed Knights Corner, and are not backward\n- * compatible with other Intel products. Additionally, Intel will NOT\n- * support the codes or instruction set in future products.\n- *\n- * Intel offers no warranty of any kind regarding the code. This code is\n- * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n- * any support, assistance, installation, training, or other services\n- * of any kind. Intel is also not obligated to provide any updates,\n- * enhancements or extensions. Intel specifically disclaims any warranty\n- * of merchantability, non-infringement, fitness for any particular\n- * purpose, and any other warranty.\n- *\n- * Further, Intel disclaims all liability of any kind, including but\n- * not limited to liability for infringement of any proprietary rights,\n- * relating to the use of the code, even if Intel is notified of the\n- * possibility of such liability. Except as expressly stated in an Intel\n- * license agreement provided with this code and agreed upon with Intel,\n- * no license, express or implied, by estoppel or otherwise, to any\n- * intellectual property rights is granted herein.\n- */\n-\n-/***\n-* See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info.\n-***/\n-\n-MYO_1.0\n-{\n-  global:\n-    myoArenaAlignedMalloc;\n-    myoArenaAlignedFree;\n-    myoArenaAcquire;\n-    myoArenaRelease;\n-    myoAcquire;\n-    myoRelease;\n-    myoSharedAlignedFree;\n-    myoSharedAlignedMalloc;\n-    myoSharedFree;\n-    myoSharedMalloc;\n-\n-    myoiLibInit;\n-    myoiLibFini;\n-    myoiMicVarTableRegister;\n-    myoiRemoteFuncRegister;\n-    myoiTargetFptrTableRegister;\n-\n-  local:\n-    *;\n-};\n-"}, {"sha": "5dffdb115129873ac43af6e85eabab14dbe6a36e", "filename": "liboffloadmic/runtime/liboffload_error.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error.c?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -63,14 +63,17 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_malloc:\n             write_message(stderr, msg_c_malloc, args);\n             break;\n+        case c_unknown_mic_device_type:\n+            write_message(stderr, msg_c_unknown_mic_device_type, args);\n+            break;\n         case c_offload_malloc:\n             write_message(stderr, msg_c_offload_malloc, args);\n             break;\n         case c_offload1:\n             write_message(stderr, msg_c_offload1, args);\n             break;\n         case c_unknown_var_type:\n-            write_message(stderr, c_unknown_var_type, args);\n+            write_message(stderr, msg_c_unknown_var_type, args);\n             break;\n         case c_invalid_env_var_value:\n             write_message(stderr, msg_c_invalid_env_var_value, args);\n@@ -129,6 +132,21 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_mic_init6:\n             write_message(stderr, msg_c_mic_init6, args);\n             break;\n+        case c_mic_init7:\n+            write_message(stderr, msg_c_mic_init7, args);\n+            break;\n+        case c_mic_init8:\n+            write_message(stderr, msg_c_mic_init8, args);\n+            break;\n+        case c_mic_init9:\n+            write_message(stderr, msg_c_mic_init9, args);\n+            break;\n+        case c_mic_init10:\n+            write_message(stderr, msg_c_mic_init10, args);\n+            break;\n+        case c_mic_init11:\n+            write_message(stderr, msg_c_mic_init11, args);\n+            break;\n         case c_no_static_var_data:\n             write_message(stderr, msg_c_no_static_var_data, args);\n             break;\n@@ -270,21 +288,34 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_cannot_set_affinity:\n             write_message(stderr, msg_c_cannot_set_affinity, args);\n             break;\n+        case c_mixed_versions:\n+            write_message(stderr, msg_c_mixed_versions, args);\n+            break;\n         case c_in_with_preallocated:\n             write_message(stderr, msg_c_in_with_preallocated, args);\n             break;\n         case c_report_no_host_exe:\n             write_message(stderr, msg_c_report_no_host_exe, args);\n             break;\n+        case c_report_no_target_exe:\n+            write_message(stderr, msg_c_report_no_target_exe, args);\n+            break;\n         case c_report_path_buff_overflow:\n             write_message(stderr, msg_c_report_path_buff_overflow, args);\n             break;\n         case c_create_pipeline_for_stream:\n             write_message(stderr, msg_c_create_pipeline_for_stream, args);\n             break;\n+        case c_offload_streams_are_absent:\n+            write_message(stderr, msg_c_offload_streams_are_absent, args);\n+            break;\n         case c_offload_no_stream:\n             write_message(stderr, msg_c_offload_no_stream, args);\n             break;\n+         case c_offload_device_doesnt_match_to_stream:\n+            write_message(stderr,\n+                          msg_c_offload_device_doesnt_match_to_stream, args);\n+            break;\n         case c_get_engine_info:\n             write_message(stderr, msg_c_get_engine_info, args);\n             break;\n@@ -297,6 +328,15 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_unload_library:\n             write_message(stderr, msg_c_unload_library, args);\n             break;\n+        case c_target_myo_library:\n+            write_message(stderr, msg_c_target_myo_library, args);\n+            break;\n+        case c_myo_dl_sym:\n+            write_message(stderr, msg_c_myo_dl_sym, args);\n+            break;\n+        case c_bad_myo_free:\n+            write_message(stderr, msg_c_bad_myo_free, args);\n+            break;\n     }\n     va_end(args);\n }\n@@ -422,6 +462,7 @@ char const * report_get_message_str(error_types input_tag)\n             LIBOFFLOAD_ERROR(c_report_unknown_trace_node);\n             abort();\n     }\n+    return 0;\n }\n \n char const * report_get_host_stage_str(int i)\n@@ -483,6 +524,7 @@ char const * report_get_host_stage_str(int i)\n             LIBOFFLOAD_ERROR(c_report_unknown_timer_node);\n             abort();\n     }\n+    return 0;\n }\n \n char const * report_get_target_stage_str(int i)\n@@ -515,4 +557,5 @@ char const * report_get_target_stage_str(int i)\n             LIBOFFLOAD_ERROR(c_report_unknown_timer_node);\n             abort();\n     }\n+    return 0;\n }"}, {"sha": "d7a71c3e6d452424d766dbbb62562851fbd278a5", "filename": "liboffloadmic/runtime/liboffload_error_codes.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -43,6 +43,7 @@ typedef enum\n     c_send_func_ptr,\n     c_receive_func_ptr,\n     c_malloc,\n+    c_unknown_mic_device_type,\n     c_offload_malloc,\n     c_invalid_env_var_value,\n     c_invalid_env_var_int_value,\n@@ -63,6 +64,11 @@ typedef enum\n     c_mic_init4,\n     c_mic_init5,\n     c_mic_init6,\n+    c_mic_init7,\n+    c_mic_init8,\n+    c_mic_init9,\n+    c_mic_init10,\n+    c_mic_init11,\n     c_no_static_var_data,\n     c_no_ptr_data,\n     c_get_engine_handle,\n@@ -107,6 +113,7 @@ typedef enum\n     c_no_target_exe,\n     c_incorrect_affinity,\n     c_cannot_set_affinity,\n+    c_mixed_versions,\n     c_report_host,\n     c_report_target,\n     c_report_title,\n@@ -172,15 +179,21 @@ typedef enum\n     c_coipipe_max_number,\n     c_in_with_preallocated,\n     c_report_no_host_exe,\n+    c_report_no_target_exe,\n     c_report_path_buff_overflow,\n     c_create_pipeline_for_stream,\n     c_offload_no_stream,\n+    c_offload_device_doesnt_match_to_stream,\n+    c_offload_streams_are_absent,\n     c_get_engine_info,\n     c_clear_cpu_mask,\n     c_set_cpu_mask,\n     c_report_state_stream,\n     c_report_stream,\n-    c_unload_library\n+    c_unload_library,\n+    c_target_myo_library,\n+    c_myo_dl_sym,\n+    c_bad_myo_free\n } error_types;\n \n enum OffloadHostPhase {"}, {"sha": "ffee72f5ae8ac424e988c0bcc17dd81b3ffbb253", "filename": "liboffloadmic/runtime/liboffload_msg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.c?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "93eccd496fd79c0b19150e7cd72c000ec098e4f5", "filename": "liboffloadmic/runtime/liboffload_msg.h", "status": "modified", "additions": 202, "deletions": 176, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -35,6 +35,7 @@ enum {\n \tmsg_c_send_func_ptr,\n \tmsg_c_receive_func_ptr,\n \tmsg_c_malloc,\n+\tmsg_c_unknown_mic_device_type,\n \tmsg_c_offload_malloc,\n \tmsg_c_offload1,\n \tmsg_c_unknown_var_type,\n@@ -57,6 +58,11 @@ enum {\n \tmsg_c_mic_init4,\n \tmsg_c_mic_init5,\n \tmsg_c_mic_init6,\n+\tmsg_c_mic_init7,\n+\tmsg_c_mic_init8,\n+\tmsg_c_mic_init9,\n+\tmsg_c_mic_init10,\n+\tmsg_c_mic_init11,\n \tmsg_c_no_static_var_data,\n \tmsg_c_no_ptr_data,\n \tmsg_c_get_engine_handle,\n@@ -99,6 +105,7 @@ enum {\n \tmsg_c_report_unknown_trace_node,\n \tmsg_c_incorrect_affinity,\n \tmsg_c_cannot_set_affinity,\n+\tmsg_c_mixed_versions,\n \tmsg_c_report_host,\n \tmsg_c_report_mic,\n \tmsg_c_report_title,\n@@ -194,16 +201,22 @@ enum {\n \tmsg_c_pointer_array_mismatch,\n \tmsg_c_in_with_preallocated,\n \tmsg_c_report_no_host_exe,\n+\tmsg_c_report_no_target_exe,\n \tmsg_c_report_path_buff_overflow,\n \tmsg_c_create_pipeline_for_stream,\n \tmsg_c_offload_no_stream,\n+\tmsg_c_offload_device_doesnt_match_to_stream,\n+\tmsg_c_offload_streams_are_absent,\n \tmsg_c_get_engine_info,\n \tmsg_c_clear_cpu_mask,\n \tmsg_c_set_cpu_mask,\n \tmsg_c_report_state_stream,\n \tmsg_c_report_stream,\n \tmsg_c_unload_library,\n-\tlastMsg = 174,\n+\tmsg_c_target_myo_library,\n+\tmsg_c_myo_dl_sym,\n+\tmsg_c_bad_myo_free,\n+\tlastMsg = 187,\n \tfirstMsg = 1\n };\n \n@@ -213,178 +226,191 @@ enum {\n #endif\n \n static char const * MESSAGE_TABLE_NAME[] = {\n-\t/*   0 __dummy__                                */ \"Un-used message\",\n-\t/*   1 msg_c_device_is_not_available            */ \"offload error: cannot offload to MIC - device is not available\",\n-\t/*   2 msg_c_invalid_device_number              */ \"offload error: expected a number greater than or equal to -1\",\n-\t/*   3 msg_c_send_func_ptr                      */ \"offload error: cannot find function name for address %p\",\n-\t/*   4 msg_c_receive_func_ptr                   */ \"offload error: cannot find address of function %s\",\n-\t/*   5 msg_c_malloc                             */ \"offload error: memory allocation failed\",\n-\t/*   6 msg_c_offload_malloc                     */ \"offload error: memory allocation failed (requested=%lld bytes, align %lld)\",\n-\t/*   7 msg_c_offload1                           */ \"offload error: device %d does not have a pending signal for wait(%p)\",\n-\t/*   8 msg_c_unknown_var_type                   */ \"offload error: unknown variable type %d\",\n-\t/*   9 msg_c_invalid_env_var_value              */ \"offload warning: ignoring invalid value specified for %s\",\n-\t/*  10 msg_c_invalid_env_var_int_value          */ \"offload warning: specify an integer value for %s\",\n-\t/*  11 msg_c_invalid_env_report_value           */ \"offload warning: ignoring %s setting; use a value in range 1-3\",\n-\t/*  12 msg_c_offload_signaled1                  */ \"offload error: invalid device number %d specified in _Offload_signaled\",\n-\t/*  13 msg_c_offload_signaled2                  */ \"offload error: invalid signal %p specified for _Offload_signaled\",\n-\t/*  14 msg_c_myowrapper_checkresult             */ \"offload error: %s failed with error %d\",\n-\t/*  15 msg_c_myotarget_checkresult              */ \"offload error: %s failed with error %d\",\n-\t/*  16 msg_c_offload_descriptor_offload         */ \"offload error: cannot find offload entry %s\",\n-\t/*  17 msg_c_merge_var_descs1                   */ \"offload error: unexpected number of variable descriptors\",\n-\t/*  18 msg_c_merge_var_descs2                   */ \"offload error: unexpected variable type\",\n-\t/*  19 msg_c_mic_parse_env_var_list1            */ \"offload_error: MIC environment variable must begin with an alpabetic character\",\n-\t/*  20 msg_c_mic_parse_env_var_list2            */ \"offload_error: MIC environment variable value must be specified with '='\",\n-\t/*  21 msg_c_mic_process_exit_ret               */ \"offload error: process on the device %d unexpectedly exited with code %d\",\n-\t/*  22 msg_c_mic_process_exit_sig               */ \"offload error: process on the device %d was terminated by signal %d (%s)\",\n-\t/*  23 msg_c_mic_process_exit                   */ \"offload error: process on the device %d was unexpectedly terminated\",\n-\t/*  24 msg_c_mic_init3                          */ \"offload warning: ignoring MIC_STACKSIZE setting; use a value >= 16K and a multiple of 4K\",\n-\t/*  25 msg_c_mic_init4                          */ \"offload error: thread key create failed with error %d\",\n-\t/*  26 msg_c_mic_init5                          */ \"offload warning: specify OFFLOAD_DEVICES as comma-separated physical device numbers or 'none'\",\n-\t/*  27 msg_c_mic_init6                          */ \"offload warning: OFFLOAD_DEVICES device number %d does not correspond to a physical device\",\n-\t/*  28 msg_c_no_static_var_data                 */ \"offload error: cannot find data associated with statically allocated variable %p\",\n-\t/*  29 msg_c_no_ptr_data                        */ \"offload error: cannot find data associated with pointer variable %p\",\n-\t/*  30 msg_c_get_engine_handle                  */ \"offload error: cannot get device %d handle (error code %d)\",\n-\t/*  31 msg_c_get_engine_index                   */ \"offload error: cannot get physical index for logical device %d (error code %d)\",\n-\t/*  32 msg_c_process_create                     */ \"offload error: cannot start process on the device %d (error code %d)\",\n-\t/*  33 msg_c_process_set_cache_size             */ \"offload error: cannot reserve buffer on the device %d (error code %d)\",\n-\t/*  34 msg_c_process_get_func_handles           */ \"offload error: cannot get function handles on the device %d (error code %d)\",\n-\t/*  35 msg_c_process_wait_shutdown              */ \"offload error: wait for process shutdown failed on device %d (error code %d)\",\n-\t/*  36 msg_c_process_proxy_flush                */ \"offload error: cannot flush process output on device %d (error code %d)\",\n-\t/*  37 msg_c_load_library                       */ \"offload error: cannot load library to the device %d (error code %d)\",\n-\t/*  38 msg_c_pipeline_create                    */ \"offload error: cannot create pipeline on the device %d (error code %d)\",\n-\t/*  39 msg_c_pipeline_run_func                  */ \"offload error: cannot execute function on the device %d (error code %d)\",\n-\t/*  40 msg_c_pipeline_start_run_funcs           */ \"offload error: cannot start executing pipeline function on the device %d (error code %d)\",\n-\t/*  41 msg_c_buf_create                         */ \"offload error: cannot create buffer on device %d (error code %d)\",\n-\t/*  42 msg_c_buf_create_out_of_mem              */ \"offload error: cannot create buffer on device %d, out of memory\",\n-\t/*  43 msg_c_buf_create_from_mem                */ \"offload error: cannot create buffer from memory on device %d (error code %d)\",\n-\t/*  44 msg_c_buf_destroy                        */ \"offload error: buffer destroy failed (error code %d)\",\n-\t/*  45 msg_c_buf_map                            */ \"offload error: buffer map failed (error code %d)\",\n-\t/*  46 msg_c_buf_unmap                          */ \"offload error: buffer unmap failed (error code %d)\",\n-\t/*  47 msg_c_buf_read                           */ \"offload error: buffer read failed (error code %d)\",\n-\t/*  48 msg_c_buf_write                          */ \"offload error: buffer write failed (error code %d)\",\n-\t/*  49 msg_c_buf_copy                           */ \"offload error: buffer copy failed (error code %d)\",\n-\t/*  50 msg_c_buf_get_address                    */ \"offload error: cannot get buffer address on device %d (error code %d)\",\n-\t/*  51 msg_c_buf_add_ref                        */ \"offload error: cannot reuse buffer memory on device %d (error code %d)\",\n-\t/*  52 msg_c_buf_release_ref                    */ \"offload error: cannot release buffer memory on device %d (error code %d)\",\n-\t/*  53 msg_c_buf_set_state                      */ \"offload error: buffer set state failed (error code %d)\",\n-\t/*  54 msg_c_event_wait                         */ \"offload error: wait for event to become signaled failed (error code %d)\",\n-\t/*  55 msg_c_zero_or_neg_ptr_len                */ \"offload error: memory allocation of zero or negative length is not supported\",\n-\t/*  56 msg_c_zero_or_neg_transfer_size          */ \"offload error: data transfer of zero or negative size is not supported\",\n-\t/*  57 msg_c_bad_ptr_mem_alloc                  */ \"offload error: allocation (base=%p, size=%d) overlaps with existing allocation (base=%p, size=%d)\",\n-\t/*  58 msg_c_bad_ptr_mem_range                  */ \"offload error: data transfer (base=%p, size=%d) not subset of existing allocation (base=%p, size=%d)\",\n-\t/*  59 msg_c_different_src_and_dstn_sizes       */ \"offload error: size of the source %d differs from size of the destination %d\",\n-\t/*  60 msg_c_non_contiguous_dope_vector         */ \"offload error: offload data transfer supports only a single contiguous memory range per variable\",\n-\t/*  61 msg_c_omp_invalid_device_num_env         */ \"offload warning: ignoring %s setting; use a non-negative integer value\",\n-\t/*  62 msg_c_omp_invalid_device_num             */ \"offload error: device number should be a non-negative integer value\",\n-\t/*  63 msg_c_unknown_binary_type                */ \"offload error: unexpected embedded target binary type, expected either an executable or shared library\",\n-\t/*  64 msg_c_multiple_target_exes               */ \"offload error: more that one target executable found\",\n-\t/*  65 msg_c_no_target_exe                      */ \"offload error: target executable is not available\",\n-\t/*  66 msg_c_report_unknown_timer_node          */ \"offload error: unknown timer node\",\n-\t/*  67 msg_c_report_unknown_trace_node          */ \"offload error: unknown trace node\",\n-\t/*  68 msg_c_incorrect_affinity                 */ \"offload error: unknow affinity type %s, specify compact, scatter or balanced\",\n-\t/*  69 msg_c_cannot_set_affinity                */ \"offload_error: unable to set affinity\",\n-\t/*  70 msg_c_report_host                        */ \"HOST\",\n-\t/*  71 msg_c_report_mic                         */ \"MIC\",\n-\t/*  72 msg_c_report_title                       */ \"timer data       (sec)\",\n-\t/*  73 msg_c_report_seconds                     */ \"(seconds)\",\n-\t/*  74 msg_c_report_bytes                       */ \"(bytes)\",\n-\t/*  75 msg_c_report_cpu_time                    */ \"CPU Time\",\n-\t/*  76 msg_c_report_mic_time                    */ \"MIC Time\",\n-\t/*  77 msg_c_report_tag                         */ \"Tag\",\n-\t/*  78 msg_c_report_from_file                   */ \"Offload from file\",\n-\t/*  79 msg_c_report_file                        */ \"File\",\n-\t/*  80 msg_c_report_line                        */ \"Line\",\n-\t/*  81 msg_c_report_cpu_to_mic_data             */ \"CPU->MIC Data\",\n-\t/*  82 msg_c_report_mic_to_cpu_data             */ \"MIC->CPU Data\",\n-\t/*  83 msg_c_report_offload                     */ \"Offload\",\n-\t/*  84 msg_c_report_w_tag                       */ \"Tag %d\",\n-\t/*  85 msg_c_report_state                       */ \"State\",\n-\t/*  86 msg_c_report_start                       */ \"Start target\",\n-\t/*  87 msg_c_report_init                        */ \"Initialize\",\n-\t/*  88 msg_c_report_logical_card                */ \"logical card\",\n-\t/*  89 msg_c_report_physical_card               */ \"physical card\",\n-\t/*  90 msg_c_report_register                    */ \"Register static data tables\",\n-\t/*  91 msg_c_report_init_func                   */ \"Setup target entry\",\n-\t/*  92 msg_c_report_create_buf_host             */ \"Create host buffer\",\n-\t/*  93 msg_c_report_create_buf_mic              */ \"Create target buffer\",\n-\t/*  94 msg_c_report_send_pointer_data           */ \"Send pointer data\",\n-\t/*  95 msg_c_report_sent_pointer_data           */ \"Host->target pointer data\",\n-\t/*  96 msg_c_report_gather_copyin_data          */ \"Gather copyin data\",\n-\t/*  97 msg_c_report_copyin_data                 */ \"Host->target copyin data\",\n-\t/*  98 msg_c_report_state_signal                */ \"Signal\",\n-\t/*  99 msg_c_report_signal                      */ \"signal :\",\n-\t/* 100 msg_c_report_wait                        */ \"waits  :\",\n-\t/* 101 msg_c_report_compute                     */ \"Execute task on target\",\n-\t/* 102 msg_c_report_receive_pointer_data        */ \"Receive pointer data\",\n-\t/* 103 msg_c_report_received_pointer_data       */ \"Target->host pointer data\",\n-\t/* 104 msg_c_report_start_target_func           */ \"Start target entry\",\n-\t/* 105 msg_c_report_var                         */ \"Var\",\n-\t/* 106 msg_c_report_scatter_copyin_data         */ \"Scatter copyin data\",\n-\t/* 107 msg_c_report_gather_copyout_data         */ \"Gather copyout data\",\n-\t/* 108 msg_c_report_scatter_copyout_data        */ \"Scatter copyout data\",\n-\t/* 109 msg_c_report_copyout_data                */ \"Target->host copyout data\",\n-\t/* 110 msg_c_report_unregister                  */ \"Unregister data tables\",\n-\t/* 111 msg_c_report_destroy                     */ \"Destroy\",\n-\t/* 112 msg_c_report_myoinit                     */ \"Initialize MYO\",\n-\t/* 113 msg_c_report_myoregister                 */ \"Register MYO tables\",\n-\t/* 114 msg_c_report_myofini                     */ \"Finalize MYO\",\n-\t/* 115 msg_c_report_mic_myo_shared              */ \"MIC MYO shared table register\",\n-\t/* 116 msg_c_report_mic_myo_fptr                */ \"MIC MYO fptr table register\",\n-\t/* 117 msg_c_report_myosharedmalloc             */ \"MYO shared malloc\",\n-\t/* 118 msg_c_report_myosharedfree               */ \"MYO shared free\",\n-\t/* 119 msg_c_report_myosharedalignedmalloc      */ \"MYO shared aligned malloc\",\n-\t/* 120 msg_c_report_myosharedalignedfree        */ \"MYO shared aligned free\",\n-\t/* 121 msg_c_report_myoacquire                  */ \"MYO acquire\",\n-\t/* 122 msg_c_report_myorelease                  */ \"MYO release\",\n-\t/* 123 msg_c_report_myosupportsfeature          */ \"MYO supports feature\",\n-\t/* 124 msg_c_report_myosharedarenacreate        */ \"MYO shared arena create\",\n-\t/* 125 msg_c_report_myosharedalignedarenamalloc */ \"MYO shared aligned arena malloc\",\n-\t/* 126 msg_c_report_myosharedalignedarenafree   */ \"MYO shared aligned arena free\",\n-\t/* 127 msg_c_report_myoarenaacquire             */ \"MYO arena acquire\",\n-\t/* 128 msg_c_report_myoarenarelease             */ \"MYO arena release\",\n-\t/* 129 msg_c_report_host_total_offload_time     */ \"host: total offload time\",\n-\t/* 130 msg_c_report_host_initialize             */ \"host: initialize target\",\n-\t/* 131 msg_c_report_host_target_acquire         */ \"host: acquire target\",\n-\t/* 132 msg_c_report_host_wait_deps              */ \"host: wait dependencies\",\n-\t/* 133 msg_c_report_host_setup_buffers          */ \"host: setup buffers\",\n-\t/* 134 msg_c_report_host_alloc_buffers          */ \"host: allocate buffers\",\n-\t/* 135 msg_c_report_host_setup_misc_data        */ \"host: setup misc_data\",\n-\t/* 136 msg_c_report_host_alloc_data_buffer      */ \"host: allocate buffer\",\n-\t/* 137 msg_c_report_host_send_pointers          */ \"host: send pointers\",\n-\t/* 138 msg_c_report_host_gather_inputs          */ \"host: gather inputs\",\n-\t/* 139 msg_c_report_host_map_in_data_buffer     */ \"host: map IN data buffer\",\n-\t/* 140 msg_c_report_host_unmap_in_data_buffer   */ \"host: unmap IN data buffer\",\n-\t/* 141 msg_c_report_host_start_compute          */ \"host: initiate compute\",\n-\t/* 142 msg_c_report_host_wait_compute           */ \"host: wait compute\",\n-\t/* 143 msg_c_report_host_start_buffers_reads    */ \"host: initiate pointer reads\",\n-\t/* 144 msg_c_report_host_scatter_outputs        */ \"host: scatter outputs\",\n-\t/* 145 msg_c_report_host_map_out_data_buffer    */ \"host: map OUT data buffer\",\n-\t/* 146 msg_c_report_host_unmap_out_data_buffer  */ \"host: unmap OUT data buffer\",\n-\t/* 147 msg_c_report_host_wait_buffers_reads     */ \"host: wait pointer reads\",\n-\t/* 148 msg_c_report_host_destroy_buffers        */ \"host: destroy buffers\",\n-\t/* 149 msg_c_report_target_total_time           */ \"target: total time\",\n-\t/* 150 msg_c_report_target_descriptor_setup     */ \"target: setup offload descriptor\",\n-\t/* 151 msg_c_report_target_func_lookup          */ \"target: entry lookup\",\n-\t/* 152 msg_c_report_target_func_time            */ \"target: entry time\",\n-\t/* 153 msg_c_report_target_scatter_inputs       */ \"target: scatter inputs\",\n-\t/* 154 msg_c_report_target_add_buffer_refs      */ \"target: add buffer reference\",\n-\t/* 155 msg_c_report_target_compute              */ \"target: compute\",\n-\t/* 156 msg_c_report_target_gather_outputs       */ \"target: gather outputs\",\n-\t/* 157 msg_c_report_target_release_buffer_refs  */ \"target: remove buffer reference\",\n-\t/* 158 msg_c_coi_pipeline_max_number            */ \"number of host threads doing offload exceeds maximum of %d\",\n-\t/* 159 msg_c_ranges_dont_match                  */ \"ranges of source and destination don't match together\",\n-\t/* 160 msg_c_destination_is_over                */ \"insufficient destination memory to transfer source\",\n-\t/* 161 msg_c_slice_of_noncont_array             */ \"a non-contiguous slice may be taken of contiguous arrays only\",\n-\t/* 162 msg_c_pointer_array_mismatch             */ \"number of %s elements is less than described by the source\",\n-\t/* 163 msg_c_in_with_preallocated               */ \"offload error: preallocated targetptr alloc_if(1) may not be used with an in clause\",\n-\t/* 164 msg_c_report_no_host_exe                 */ \"offload error: Cannot find host executable\",\n-\t/* 165 msg_c_report_path_buff_overflow          */ \"offload error: Size of host executable path exceeded 4KB\",\n-\t/* 166 msg_c_create_pipeline_for_stream         */ \"offload error: number of cpus exceeds maximum of %d\",\n-\t/* 167 msg_c_offload_no_stream                  */ \"offload error: the stream isn't found on device %d\",\n-\t/* 168 msg_c_get_engine_info                    */ \"offload error: cannot get device %d info (error code %d)\",\n-\t/* 169 msg_c_clear_cpu_mask                     */ \"offload error: cannot clear cpu mask (error code %d)\",\n-\t/* 170 msg_c_set_cpu_mask                       */ \"offload error: cannot set cpu mask (error code %d)\",\n-\t/* 171 msg_c_report_state_stream                */ \"Stream\",\n-\t/* 172 msg_c_report_stream                      */ \"stream  :\",\n-\t/* 173 msg_c_unload_library                     */ \"offload error: cannot unload library from the device %d (error code %d)\",\n+\t/*   0 __dummy__                                   */ \"Un-used message\",\n+\t/*   1 msg_c_device_is_not_available               */ \"offload error: cannot offload to MIC - device is not available\",\n+\t/*   2 msg_c_invalid_device_number                 */ \"offload error: expected a number greater than or equal to -1\",\n+\t/*   3 msg_c_send_func_ptr                         */ \"offload error: cannot find function name for address %p\",\n+\t/*   4 msg_c_receive_func_ptr                      */ \"offload error: cannot find address of function %s\",\n+\t/*   5 msg_c_malloc                                */ \"offload error: memory allocation failed\",\n+\t/*   6 msg_c_unknown_mic_device_type               */ \"offload error: unknown mic device type \",\n+\t/*   7 msg_c_offload_malloc                        */ \"offload error: memory allocation failed (requested=%lld bytes, align %lld)\",\n+\t/*   8 msg_c_offload1                              */ \"offload error: device %d does not have a pending signal for wait(%p)\",\n+\t/*   9 msg_c_unknown_var_type                      */ \"offload error: unknown variable type %d\",\n+\t/*  10 msg_c_invalid_env_var_value                 */ \"offload warning: ignoring invalid value specified for %s\",\n+\t/*  11 msg_c_invalid_env_var_int_value             */ \"offload warning: specify an integer value for %s\",\n+\t/*  12 msg_c_invalid_env_report_value              */ \"offload warning: ignoring %s setting; use a value in range 1-3\",\n+\t/*  13 msg_c_offload_signaled1                     */ \"offload error: invalid device number %d specified in _Offload_signaled\",\n+\t/*  14 msg_c_offload_signaled2                     */ \"offload error: invalid signal %p specified for _Offload_signaled\",\n+\t/*  15 msg_c_myowrapper_checkresult                */ \"offload error: %s failed with error %d\",\n+\t/*  16 msg_c_myotarget_checkresult                 */ \"offload error: %s failed with error %d\",\n+\t/*  17 msg_c_offload_descriptor_offload            */ \"offload error: cannot find offload entry %s\",\n+\t/*  18 msg_c_merge_var_descs1                      */ \"offload error: unexpected number of variable descriptors\",\n+\t/*  19 msg_c_merge_var_descs2                      */ \"offload error: unexpected variable type\",\n+\t/*  20 msg_c_mic_parse_env_var_list1               */ \"offload_error: MIC environment variable must begin with an alpabetic character\",\n+\t/*  21 msg_c_mic_parse_env_var_list2               */ \"offload_error: MIC environment variable value must be specified with '='\",\n+\t/*  22 msg_c_mic_process_exit_ret                  */ \"offload error: process on the device %d unexpectedly exited with code %d\",\n+\t/*  23 msg_c_mic_process_exit_sig                  */ \"offload error: process on the device %d was terminated by signal %d (%s)\",\n+\t/*  24 msg_c_mic_process_exit                      */ \"offload error: process on the device %d was unexpectedly terminated\",\n+\t/*  25 msg_c_mic_init3                             */ \"offload warning: ignoring MIC_STACKSIZE setting; use a value >= 16K and a multiple of 4K\",\n+\t/*  26 msg_c_mic_init4                             */ \"offload error: thread key create failed with error %d\",\n+\t/*  27 msg_c_mic_init5                             */ \"offload error: specify OFFLOAD_DEVICES as comma-separated physical device numbers or 'none'\",\n+\t/*  28 msg_c_mic_init6                             */ \"offload error: OFFLOAD_DEVICES device number %d does not correspond to a physical device\",\n+\t/*  29 msg_c_mic_init7                             */ \"offload error: specify a number as a device in OFFLOAD_DEVICES\",\n+\t/*  30 msg_c_mic_init8                             */ \"offload error: specify a number as the start of a device range in OFFLOAD_DEVICES\",\n+\t/*  31 msg_c_mic_init9                             */ \"offload error: specify a number as the end of a device range in OFFLOAD_DEVICES\",\n+\t/*  32 msg_c_mic_init10                            */ \"offload error: specify a low to high device range in OFFLOAD_DEVICES\",\n+\t/*  33 msg_c_mic_init11                            */ \"offload error: specify comma-separated device or device ranges in OFFLOAD_DEVICES\",\n+\t/*  34 msg_c_no_static_var_data                    */ \"offload error: cannot find data associated with statically allocated variable %p\",\n+\t/*  35 msg_c_no_ptr_data                           */ \"offload error: cannot find data associated with pointer variable %p\",\n+\t/*  36 msg_c_get_engine_handle                     */ \"offload error: cannot get device %d handle (error code %d)\",\n+\t/*  37 msg_c_get_engine_index                      */ \"offload error: cannot get physical index for logical device %d (error code %d)\",\n+\t/*  38 msg_c_process_create                        */ \"offload error: cannot start process on the device %d (error code %d)\",\n+\t/*  39 msg_c_process_set_cache_size                */ \"offload error: cannot reserve buffer on the device %d (error code %d)\",\n+\t/*  40 msg_c_process_get_func_handles              */ \"offload error: cannot get function handles on the device %d (error code %d)\",\n+\t/*  41 msg_c_process_wait_shutdown                 */ \"offload error: wait for process shutdown failed on device %d (error code %d)\",\n+\t/*  42 msg_c_process_proxy_flush                   */ \"offload error: cannot flush process output on device %d (error code %d)\",\n+\t/*  43 msg_c_load_library                          */ \"offload error: cannot load library %s to the device %d (error code %d)\",\n+\t/*  44 msg_c_pipeline_create                       */ \"offload error: cannot create pipeline on the device %d (error code %d)\",\n+\t/*  45 msg_c_pipeline_run_func                     */ \"offload error: cannot execute function on the device %d (error code %d)\",\n+\t/*  46 msg_c_pipeline_start_run_funcs              */ \"offload error: cannot start executing pipeline function on the device %d (error code %d)\",\n+\t/*  47 msg_c_buf_create                            */ \"offload error: cannot create buffer on device %d (error code %d)\",\n+\t/*  48 msg_c_buf_create_out_of_mem                 */ \"offload error: cannot create buffer on device %d, out of memory\",\n+\t/*  49 msg_c_buf_create_from_mem                   */ \"offload error: cannot create buffer from memory on device %d (error code %d)\",\n+\t/*  50 msg_c_buf_destroy                           */ \"offload error: buffer destroy failed (error code %d)\",\n+\t/*  51 msg_c_buf_map                               */ \"offload error: buffer map failed (error code %d)\",\n+\t/*  52 msg_c_buf_unmap                             */ \"offload error: buffer unmap failed (error code %d)\",\n+\t/*  53 msg_c_buf_read                              */ \"offload error: buffer read failed (error code %d)\",\n+\t/*  54 msg_c_buf_write                             */ \"offload error: buffer write failed (error code %d)\",\n+\t/*  55 msg_c_buf_copy                              */ \"offload error: buffer copy failed (error code %d)\",\n+\t/*  56 msg_c_buf_get_address                       */ \"offload error: cannot get buffer address on device %d (error code %d)\",\n+\t/*  57 msg_c_buf_add_ref                           */ \"offload error: cannot reuse buffer memory on device %d (error code %d)\",\n+\t/*  58 msg_c_buf_release_ref                       */ \"offload error: cannot release buffer memory on device %d (error code %d)\",\n+\t/*  59 msg_c_buf_set_state                         */ \"offload error: buffer set state failed (error code %d)\",\n+\t/*  60 msg_c_event_wait                            */ \"offload error: wait for event to become signaled failed (error code %d)\",\n+\t/*  61 msg_c_zero_or_neg_ptr_len                   */ \"offload error: memory allocation of zero or negative length is not supported\",\n+\t/*  62 msg_c_zero_or_neg_transfer_size             */ \"offload error: data transfer of zero or negative size is not supported\",\n+\t/*  63 msg_c_bad_ptr_mem_alloc                     */ \"offload error: allocation (base=%p, size=%d) overlaps with existing allocation (base=%p, size=%d)\",\n+\t/*  64 msg_c_bad_ptr_mem_range                     */ \"offload error: data transfer (base=%p, size=%d) not subset of existing allocation (base=%p, size=%d)\",\n+\t/*  65 msg_c_different_src_and_dstn_sizes          */ \"offload error: size of the source %d differs from size of the destination %d\",\n+\t/*  66 msg_c_non_contiguous_dope_vector            */ \"offload error: offload data transfer supports only a single contiguous memory range per variable\",\n+\t/*  67 msg_c_omp_invalid_device_num_env            */ \"offload warning: ignoring %s setting; use a non-negative integer value\",\n+\t/*  68 msg_c_omp_invalid_device_num                */ \"offload error: device number should be a non-negative integer value\",\n+\t/*  69 msg_c_unknown_binary_type                   */ \"offload error: unexpected embedded target binary type, expected either an executable or shared library\",\n+\t/*  70 msg_c_multiple_target_exes                  */ \"offload error: more that one target executable found\",\n+\t/*  71 msg_c_no_target_exe                         */ \"offload error: target executable is not available\",\n+\t/*  72 msg_c_report_unknown_timer_node             */ \"offload error: unknown timer node\",\n+\t/*  73 msg_c_report_unknown_trace_node             */ \"offload error: unknown trace node\",\n+\t/*  74 msg_c_incorrect_affinity                    */ \"offload error: unknow affinity type %s, specify compact, scatter or balanced\",\n+\t/*  75 msg_c_cannot_set_affinity                   */ \"offload_error: unable to set affinity\",\n+\t/*  76 msg_c_mixed_versions                        */ \"offload_error: all application executables that contain offload must be built with the same compiler version\",\n+\t/*  77 msg_c_report_host                           */ \"HOST\",\n+\t/*  78 msg_c_report_mic                            */ \"MIC\",\n+\t/*  79 msg_c_report_title                          */ \"timer data       (sec)\",\n+\t/*  80 msg_c_report_seconds                        */ \"(seconds)\",\n+\t/*  81 msg_c_report_bytes                          */ \"(bytes)\",\n+\t/*  82 msg_c_report_cpu_time                       */ \"CPU Time\",\n+\t/*  83 msg_c_report_mic_time                       */ \"MIC Time\",\n+\t/*  84 msg_c_report_tag                            */ \"Tag\",\n+\t/*  85 msg_c_report_from_file                      */ \"Offload from file\",\n+\t/*  86 msg_c_report_file                           */ \"File\",\n+\t/*  87 msg_c_report_line                           */ \"Line\",\n+\t/*  88 msg_c_report_cpu_to_mic_data                */ \"CPU->MIC Data\",\n+\t/*  89 msg_c_report_mic_to_cpu_data                */ \"MIC->CPU Data\",\n+\t/*  90 msg_c_report_offload                        */ \"Offload\",\n+\t/*  91 msg_c_report_w_tag                          */ \"Tag %d\",\n+\t/*  92 msg_c_report_state                          */ \"State\",\n+\t/*  93 msg_c_report_start                          */ \"Start target\",\n+\t/*  94 msg_c_report_init                           */ \"Initialize\",\n+\t/*  95 msg_c_report_logical_card                   */ \"logical card\",\n+\t/*  96 msg_c_report_physical_card                  */ \"physical card\",\n+\t/*  97 msg_c_report_register                       */ \"Register static data tables\",\n+\t/*  98 msg_c_report_init_func                      */ \"Setup target entry\",\n+\t/*  99 msg_c_report_create_buf_host                */ \"Create host buffer\",\n+\t/* 100 msg_c_report_create_buf_mic                 */ \"Create target buffer\",\n+\t/* 101 msg_c_report_send_pointer_data              */ \"Send pointer data\",\n+\t/* 102 msg_c_report_sent_pointer_data              */ \"Host->target pointer data\",\n+\t/* 103 msg_c_report_gather_copyin_data             */ \"Gather copyin data\",\n+\t/* 104 msg_c_report_copyin_data                    */ \"Host->target copyin data\",\n+\t/* 105 msg_c_report_state_signal                   */ \"Signal\",\n+\t/* 106 msg_c_report_signal                         */ \"signal :\",\n+\t/* 107 msg_c_report_wait                           */ \"waits  :\",\n+\t/* 108 msg_c_report_compute                        */ \"Execute task on target\",\n+\t/* 109 msg_c_report_receive_pointer_data           */ \"Receive pointer data\",\n+\t/* 110 msg_c_report_received_pointer_data          */ \"Target->host pointer data\",\n+\t/* 111 msg_c_report_start_target_func              */ \"Start target entry\",\n+\t/* 112 msg_c_report_var                            */ \"Var\",\n+\t/* 113 msg_c_report_scatter_copyin_data            */ \"Scatter copyin data\",\n+\t/* 114 msg_c_report_gather_copyout_data            */ \"Gather copyout data\",\n+\t/* 115 msg_c_report_scatter_copyout_data           */ \"Scatter copyout data\",\n+\t/* 116 msg_c_report_copyout_data                   */ \"Target->host copyout data\",\n+\t/* 117 msg_c_report_unregister                     */ \"Unregister data tables\",\n+\t/* 118 msg_c_report_destroy                        */ \"Destroy\",\n+\t/* 119 msg_c_report_myoinit                        */ \"Initialize MYO\",\n+\t/* 120 msg_c_report_myoregister                    */ \"Register MYO tables\",\n+\t/* 121 msg_c_report_myofini                        */ \"Finalize MYO\",\n+\t/* 122 msg_c_report_mic_myo_shared                 */ \"MIC MYO shared table register\",\n+\t/* 123 msg_c_report_mic_myo_fptr                   */ \"MIC MYO fptr table register\",\n+\t/* 124 msg_c_report_myosharedmalloc                */ \"MYO shared malloc\",\n+\t/* 125 msg_c_report_myosharedfree                  */ \"MYO shared free\",\n+\t/* 126 msg_c_report_myosharedalignedmalloc         */ \"MYO shared aligned malloc\",\n+\t/* 127 msg_c_report_myosharedalignedfree           */ \"MYO shared aligned free\",\n+\t/* 128 msg_c_report_myoacquire                     */ \"MYO acquire\",\n+\t/* 129 msg_c_report_myorelease                     */ \"MYO release\",\n+\t/* 130 msg_c_report_myosupportsfeature             */ \"MYO supports feature\",\n+\t/* 131 msg_c_report_myosharedarenacreate           */ \"MYO shared arena create\",\n+\t/* 132 msg_c_report_myosharedalignedarenamalloc    */ \"MYO shared aligned arena malloc\",\n+\t/* 133 msg_c_report_myosharedalignedarenafree      */ \"MYO shared aligned arena free\",\n+\t/* 134 msg_c_report_myoarenaacquire                */ \"MYO arena acquire\",\n+\t/* 135 msg_c_report_myoarenarelease                */ \"MYO arena release\",\n+\t/* 136 msg_c_report_host_total_offload_time        */ \"host: total offload time\",\n+\t/* 137 msg_c_report_host_initialize                */ \"host: initialize target\",\n+\t/* 138 msg_c_report_host_target_acquire            */ \"host: acquire target\",\n+\t/* 139 msg_c_report_host_wait_deps                 */ \"host: wait dependencies\",\n+\t/* 140 msg_c_report_host_setup_buffers             */ \"host: setup buffers\",\n+\t/* 141 msg_c_report_host_alloc_buffers             */ \"host: allocate buffers\",\n+\t/* 142 msg_c_report_host_setup_misc_data           */ \"host: setup misc_data\",\n+\t/* 143 msg_c_report_host_alloc_data_buffer         */ \"host: allocate buffer\",\n+\t/* 144 msg_c_report_host_send_pointers             */ \"host: send pointers\",\n+\t/* 145 msg_c_report_host_gather_inputs             */ \"host: gather inputs\",\n+\t/* 146 msg_c_report_host_map_in_data_buffer        */ \"host: map IN data buffer\",\n+\t/* 147 msg_c_report_host_unmap_in_data_buffer      */ \"host: unmap IN data buffer\",\n+\t/* 148 msg_c_report_host_start_compute             */ \"host: initiate compute\",\n+\t/* 149 msg_c_report_host_wait_compute              */ \"host: wait compute\",\n+\t/* 150 msg_c_report_host_start_buffers_reads       */ \"host: initiate pointer reads\",\n+\t/* 151 msg_c_report_host_scatter_outputs           */ \"host: scatter outputs\",\n+\t/* 152 msg_c_report_host_map_out_data_buffer       */ \"host: map OUT data buffer\",\n+\t/* 153 msg_c_report_host_unmap_out_data_buffer     */ \"host: unmap OUT data buffer\",\n+\t/* 154 msg_c_report_host_wait_buffers_reads        */ \"host: wait pointer reads\",\n+\t/* 155 msg_c_report_host_destroy_buffers           */ \"host: destroy buffers\",\n+\t/* 156 msg_c_report_target_total_time              */ \"target: total time\",\n+\t/* 157 msg_c_report_target_descriptor_setup        */ \"target: setup offload descriptor\",\n+\t/* 158 msg_c_report_target_func_lookup             */ \"target: entry lookup\",\n+\t/* 159 msg_c_report_target_func_time               */ \"target: entry time\",\n+\t/* 160 msg_c_report_target_scatter_inputs          */ \"target: scatter inputs\",\n+\t/* 161 msg_c_report_target_add_buffer_refs         */ \"target: add buffer reference\",\n+\t/* 162 msg_c_report_target_compute                 */ \"target: compute\",\n+\t/* 163 msg_c_report_target_gather_outputs          */ \"target: gather outputs\",\n+\t/* 164 msg_c_report_target_release_buffer_refs     */ \"target: remove buffer reference\",\n+\t/* 165 msg_c_coi_pipeline_max_number               */ \"number of host threads doing offload exceeds maximum of %d\",\n+\t/* 166 msg_c_ranges_dont_match                     */ \"ranges of source and destination don't match together\",\n+\t/* 167 msg_c_destination_is_over                   */ \"insufficient destination memory to transfer source\",\n+\t/* 168 msg_c_slice_of_noncont_array                */ \"a non-contiguous slice may be taken of contiguous arrays only\",\n+\t/* 169 msg_c_pointer_array_mismatch                */ \"number of %s elements is less than described by the source\",\n+\t/* 170 msg_c_in_with_preallocated                  */ \"offload error: preallocated targetptr alloc_if(1) may not be used with an in clause\",\n+\t/* 171 msg_c_report_no_host_exe                    */ \"offload error: Cannot find host executable\",\n+\t/* 172 msg_c_report_no_target_exe                  */ \"offload error: Cannot find target executable (%s)\",\n+\t/* 173 msg_c_report_path_buff_overflow             */ \"offload error: Size of host executable path exceeded 4KB\",\n+\t/* 174 msg_c_create_pipeline_for_stream            */ \"offload error: number of cpus exceeds maximum of %d\",\n+\t/* 175 msg_c_offload_no_stream                     */ \"offload error: the stream isn't found on device %d\",\n+\t/* 176 msg_c_offload_device_doesnt_match_to_stream */ \"offload_error: the stream was created for device %d\",\n+\t/* 177 msg_c_offload_streams_are_absent            */ \"offload error: there was created no streams\",\n+\t/* 178 msg_c_get_engine_info                       */ \"offload error: cannot get device %d info (error code %d)\",\n+\t/* 179 msg_c_clear_cpu_mask                        */ \"offload error: cannot clear cpu mask (error code %d)\",\n+\t/* 180 msg_c_set_cpu_mask                          */ \"offload error: cannot set cpu mask (error code %d)\",\n+\t/* 181 msg_c_report_state_stream                   */ \"Stream\",\n+\t/* 182 msg_c_report_stream                         */ \"stream  :\",\n+\t/* 183 msg_c_unload_library                        */ \"offload error: cannot unload library from the device %d (error code %d)\",\n+\t/* 184 msg_c_target_myo_library                    */ \"offload error: cannot find MYO library on device %s\",\n+\t/* 185 msg_c_myo_dl_sym                            */ \"offload error: cannot find MYO func on device %s\",\n+\t/* 186 msg_c_bad_myo_free                          */ \"offload error: cannot free MYO shared memory %p\",\n };"}, {"sha": "1874dd97796fe2fb228b28114f91b708e392315a", "filename": "liboffloadmic/runtime/mic_lib.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fmic_lib.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fmic_lib.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fmic_lib.f90?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n !\n-!    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+!    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n !\n !    Redistribution and use in source and binary forms, with or without\n !    modification, are permitted provided that the following conditions"}, {"sha": "b12af3442a56acdcef329fcdfcf9b6cb8228395f", "filename": "liboffloadmic/runtime/offload.h", "status": "modified", "additions": 141, "deletions": 3, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -35,16 +35,19 @@\n #ifndef OFFLOAD_H_INCLUDED\n #define OFFLOAD_H_INCLUDED\n \n+#ifdef __cplusplus\n #if defined(LINUX) || defined(FREEBSD)\n #include <bits/functexcept.h>\n #endif\n+#endif\n \n #include <stddef.h>\n #include <omp.h>\n \n #ifdef TARGET_WINNT\n-// <stdint.h> is not compatible with Windows\n+// <stdint.h> is incompatible on Windows.\n typedef unsigned long long int  uint64_t;\n+typedef   signed long long int   int64_t;\n #else\n #include <stdint.h>\n #endif  // TARGET_WINNT\n@@ -93,7 +96,7 @@ typedef struct {\n     size_t          data_received;  /* number of bytes received by host */\n } _Offload_status;\n \n-typedef uint64_t _Offload_stream;\n+typedef int64_t _Offload_stream;\n \n #define OFFLOAD_STATUS_INIT(x) \\\n     ((x).result = OFFLOAD_DISABLED)\n@@ -119,11 +122,23 @@ extern int _Offload_stream_destroy(\n     _Offload_stream stream  // stream handle\n );\n \n+extern int _Offload_stream_delete(\n+    _Offload_stream handle  // stream handle\n+);\n+\n extern int _Offload_stream_completed(\n     int device,             // MIC device number\n     _Offload_stream handle  // stream handle\n );\n \n+extern int _Offload_device_streams_completed(\n+    int device             // MIC device number\n+);\n+\n+extern int _Offload_stream_is_empty(\n+    _Offload_stream handle  // stream handle\n+);\n+\n /*\n  * _Offload_shared_malloc/free are only supported when offload is enabled\n  * else they are defined to malloc and free\n@@ -165,6 +180,129 @@ extern void omp_set_default_device(int num) __GOMP_NOTHROW;\n extern int  omp_get_default_device(void) __GOMP_NOTHROW;\n extern int  omp_get_num_devices(void) __GOMP_NOTHROW;\n \n+// OpenMP 4.5 APIs\n+\n+/*! \\fn omp_get_initial_device\n+    \\brief Return the device id of the initial device.\n+    \\return Returns the device id of the initial device.\n+*/\n+extern int omp_get_initial_device(\n+    void\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_alloc\n+    \\brief Allocate memory in the device data environment.\n+    \\param size        Number of bytes to allocate.\n+    \\param device_num  The device number on which to allocate.\n+    \\return            Returns a pointer to the allocated memory.  \n+*/\n+extern void* omp_target_alloc(\n+    size_t size, \n+    int    device_num\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_free\n+    \\brief Free memory in the device data environment.\n+    \\param device_ptr  Address of allocated device memory.\n+    \\param device_num  The device number on which to free.\n+*/\n+extern void omp_target_free(\n+    void *device_ptr, \n+    int   device_num\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_is_present\n+    \\brief Test whether a host pointer has corresponding storage on a device.\n+    \\param device_ptr  Address of allocated device memory.\n+    \\param device_num  The device number on which to test..\n+    \\return            true if storage is found, false otherwise.\n+*/\n+extern int omp_target_is_present(\n+    void *ptr,\n+    int device_num\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_memcpy\n+    \\brief Copy memory between host/device pointers.\n+    \\param dst         Address of destination memory.\n+    \\param src         Address of source memory.\n+    \\param length      Number of bytes to copy.\n+    \\param dst_offset  Destination offset in bytes.\n+    \\param src_offset  Source offset in bytes.\n+    \\param dst_device  Destination device number.\n+    \\param src_device  Source device number.\n+    \\return            0 on success, 1 otherwise.\n+*/\n+extern int omp_target_memcpy(\n+    void   *dst, \n+    void   *src, \n+    size_t  length, \n+    size_t  dst_offset, \n+    size_t  src_offset, \n+    int     dst_device,\n+    int     src_device\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_memcpy_rect\n+    \\brief Copy a rectangular subsection from \n+    \\brief one multi-dimensional array to another.\n+    \\param dst           Address of destination array.\n+    \\param src           Address of source array.\n+    \\param element_size  Number of bytes in each array element.\n+    \\param num_dims      Number of dimensions.\n+    \\param volume        Array of element counts to copy in each dimension.\n+    \\param dst_offsets   Destination offsets array.\n+    \\param src_offsets   Source offsets array.\n+    \\param dst_dims      Destination array dimensions array.\n+    \\param src_dims      Source array dimensions array.\n+    \\param dst_device    Destination device number.\n+    \\param src_device    Source device number.\n+    \\return              0 on success, 1 otherwise.\n+*/\n+extern int omp_target_memcpy_rect(\n+    void         *dst,\n+    void         *src,\n+    size_t        element_size,\n+    int           num_dims,\n+    const size_t *volume,\n+    const size_t *dst_offsets,\n+    const size_t *src_offsets,\n+    const size_t *dst_dimensions,\n+    const size_t *src_dimensions,\n+    int           dst_device,\n+    int           src_device\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_associate_ptr\n+    \\brief Map a device pointer to a host pointer.\n+    \\param host_ptr       The host pointer.\n+    \\param device_ptr     The device pointer.\n+    \\param size           Number of bytes to map.\n+    \\param device_offset  Offset on device of mapped memory.\n+    \\param device_num     Device number.\n+    \\return               0 on success, 1 otherwise.\n+*/\n+extern int omp_target_associate_ptr(\n+    void   *host_ptr, \n+    void   *device_ptr,\n+    size_t  size,\n+    size_t  device_offset,\n+    int     device_num\n+) __GOMP_NOTHROW;\n+\n+/*! \\fn omp_target_disassociate_ptr\n+    \\brief Remove a host pointer to device pointer association.\n+    \\param ptr         The host pointer to disassociate.\n+    \\param device_num  Device number.\n+    \\return            0 on success, 1 otherwise.\n+*/\n+extern int omp_target_disassociate_ptr(\n+    void   *host_ptr,\n+    int     device_num\n+) __GOMP_NOTHROW;\n+\n+// End of OpenMP 4.5 APIs\n+\n /* OpenMP API wrappers */\n \n /* Set num_threads on target */"}, {"sha": "af569ae3376e44a53f5c57d2dbe7f719fbff408b", "filename": "liboffloadmic/runtime/offload_common.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "445d47cfad03ba41a118067e112567ff910d7afd", "filename": "liboffloadmic/runtime/offload_common.h", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -58,6 +58,10 @@\n   #define getenv(x)\t    __secure_getenv(x)\n #endif\n \n+// Offload Library versioning\n+DLL_LOCAL extern int offload_version;\n+DLL_LOCAL extern int offload_version_count;\n+\n // The debug routines\n \n // Host console and file logging\n@@ -181,15 +185,30 @@ enum OffloadItemType {\n     c_cean_var,         //!< CEAN variable\n     c_cean_var_ptr,     //!< Pointer to CEAN variable\n     c_data_ptr_array,   //!< Pointer to data pointer array\n+    c_extended_type,    //!< Is used to extend OffloadItemType\n+                        //!< Actual OffloadItemType is in the\n+                        //!< structure VarDescExtendedType\n     c_func_ptr_array,   //!< Pointer to function pointer array\n     c_void_ptr_array,   //!< Pointer to void* pointer array\n-    c_string_ptr_array  //!< Pointer to char* pointer array\n+    c_string_ptr_array, //!< Pointer to char* pointer array\n+    c_data_ptr_ptr,     //!< Pointer to pointer to data (struct member)\n+    c_func_ptr_ptr,     //!< Pointer to pointer to function (struct member)\n+    c_void_ptr_ptr,     //!< Pointer to pointer to void* (struct member)\n+    c_string_ptr_ptr,   //!< Pointer to pointer to string (struct member)\n+    c_cean_var_ptr_ptr  //!< Pointer to pointer to cean var (struct member)\n };\n \n+#define TYPE_IS_PTR_TO_PTR(t) ((t) == c_string_ptr_ptr || \\\n+                            (t) == c_data_ptr_ptr || \\\n+                            (t) == c_func_ptr_ptr || \\\n+                            (t) == c_void_ptr_ptr || \\\n+                            (t) == c_cean_var_ptr_ptr)\n+\n #define VAR_TYPE_IS_PTR(t) ((t) == c_string_ptr || \\\n                             (t) == c_data_ptr || \\\n                             (t) == c_cean_var_ptr || \\\n-                            (t) == c_dv_ptr)\n+                            (t) == c_dv_ptr || \\\n+                            TYPE_IS_PTR_TO_PTR(t))\n \n #define VAR_TYPE_IS_SCALAR(t) ((t) == c_data || \\\n                                (t) == c_void_ptr || \\\n@@ -202,7 +221,6 @@ enum OffloadItemType {\n #define VAR_TYPE_IS_DV_DATA_SLICE(t) ((t) == c_dv_data_slice || \\\n                                       (t) == c_dv_ptr_data_slice)\n \n-\n //! \\enum Specify direction to copy offloaded variable.\n enum OffloadParameterType {\n     c_parameter_unknown = -1, //!< Unknown clause\n@@ -228,7 +246,7 @@ union varDescFlags {\n         uint32_t targetptr : 1;\n         //! \"preallocated\" modifier used\n         uint32_t preallocated : 1;\n-        //! Needs documentation\n+        //! pointer to a pointer array\n         uint32_t is_pointer : 1;\n \n         //! buffer address is sent in data\n@@ -244,8 +262,14 @@ union varDescFlags {\n         uint32_t always_copy : 1;\n         //! \"OpenMP delete\" modifier used\n         uint32_t always_delete : 1;\n+        //! structured data is noncontiguous\n+        uint32_t is_non_cont_struct : 1;\n         //! CPU memory pinning/unpinning operation\n         uint32_t pin : 1;\n+        //! Pointer to device memory\n+        uint32_t is_device_ptr : 1;    \n+        //! Hostpointer with associated device pointer\n+        uint32_t use_device_ptr : 1;\n     };\n     uint32_t bits;\n };\n@@ -384,6 +408,21 @@ const int flag_alloc_start_is_array = 18;\n const int flag_alloc_elements_is_scalar = 19;\n const int flag_alloc_elements_is_array = 20;\n \n+//! Extended Variable Descriptor.  Since VarDesc uses 16 bits for\n+//! OffloadItemType, we have exceeded that limit,  So any Type \n+//! greater than 15 will have Type set in VarDesc as c_extended_type\n+//! and this structure will be used to represent those Types.\n+typedef struct VarDescExtendedType {\n+\n+    // Represents overflow of OffloadItemType\n+    uint32_t extended_type; \n+\n+    //! For extended_type \n+    //! address of the variable\n+    //! Future Types can point to other descriptors\n+    void *ptr;   \n+} VarDescExtendedType;\n+\n // The Marshaller\n class Marshaller\n {"}, {"sha": "b2de56c68eb6effa15cfc073f7b6c48a949945c0", "filename": "liboffloadmic/runtime/offload_engine.cpp", "status": "modified", "additions": 275, "deletions": 45, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -31,6 +31,8 @@\n #include \"offload_engine.h\"\n #include <signal.h>\n #include <errno.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n \n #include <algorithm>\n #include <vector>\n@@ -39,12 +41,19 @@\n #include \"offload_table.h\"\n #include \"offload_iterator.h\"\n \n+#if defined(HOST_WINNT)\n+#define PATH_SEPARATOR \";\"\n+#else\n+#define PATH_SEPARATOR \":\"\n+#endif\n+\n // Static members of Stream class must be described somewhere.\n // This members describe the list of all streams defined in programm\n // via call to _Offload_stream_create.\n uint64_t  Stream::m_streams_count = 0;\n StreamMap Stream::all_streams;\n mutex_t   Stream::m_stream_lock;\n+char*     mic_library_path = 0;\n \n const char* Engine::m_func_names[Engine::c_funcs_total] =\n {\n@@ -115,16 +124,47 @@ void Engine::init(void)\n \n             // it is ready now\n             m_ready = true;\n+           \n+            //  Inform the debugger \n+            if (__dbg_is_attached) {\n+                __dbg_target_so_loaded();\n+            }\n         }\n     }\n }\n \n+void Engine::print_stream_cpu_list(const char * str)\n+{\n+    int count = 0;\n+    char buffer[1024];\n+    CpuEl* cpu_el = m_cpu_head;\n+       \n+    OFFLOAD_DEBUG_TRACE(3,\n+                  \"%s : cpu list as Index(Count) for the streams is :\\n\", str);\n+    buffer[0] = 0;\n+    for (int i = 0; i < m_num_threads; i++) {\n+         cpu_el = m_cpus + i;\n+         if (m_assigned_cpus == 0 || (*m_assigned_cpus)[i]) {\n+             count++;\n+             sprintf(buffer + strlen(buffer), \"%d(%d) \", CPU_INDEX(cpu_el), cpu_el->count);\n+             if (count % 20 == 0) {\n+                 OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", buffer);\n+                 buffer[0] = 0;           \n+             } \n+         }\n+    }\n+    if (count % 20 != 0) {\n+        OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", buffer);\n+    }\n+}\n+\n void Engine::init_process(void)\n {\n     COIENGINE engine;\n     COIRESULT res;\n     const char **environ;\n     char buf[4096];  // For exe path name\n+    char* mic_device_main = 0;\n \n     // create environment for the target process\n     environ = (const char**) mic_env_vars.create_environ_for_card(m_index);\n@@ -148,19 +188,53 @@ void Engine::init_process(void)\n \n     res = COI::EngineGetInfo(engine, sizeof(COI_ENGINE_INFO), &engine_info);\n     check_result(res, c_get_engine_info, m_index, res);\n+    if (mic_library_path == 0 ) {\n+       if (engine_info.ISA == COI_DEVICE_KNC) {\n+          mic_library_path = knc_library_path;\n+       }\n+       else if (engine_info.ISA == COI_DEVICE_KNL) {\n+          mic_library_path = knl_library_path;\n+       }\n+       else {\n+          LIBOFFLOAD_ERROR(c_unknown_mic_device_type);\n+       }\n+    }\n+\n+    // m_cpus is the list of all available threads.\n+    // At the begining all threads made available through OFFLOAD_DEVICES\n+    // or all threads existed at the engine if OFFLOAD_DEVICES isn't set.\n+    // m_cpu_head points to the head of the m_cpus list.\n+    // m_cpus is ordered by number of streams using the thread.\n+    // m_cpu_head points to the least used thread.\n+    // After creating and destroying a stream the m_cpus list must be fixed\n+    // to be ordered.\n+\n+    m_cpus = (CpuEl*)malloc(engine_info.NumThreads * sizeof(CpuEl));\n+    if (m_cpus == NULL)\n+        LIBOFFLOAD_ERROR(c_malloc);\n+    memset(m_cpus, 0, engine_info.NumThreads * sizeof(CpuEl));\n+    CpuEl* prev_cpu = NULL;\n \n-    // m_cpus bitset has 1 for available thread. At the begining all threads\n-    // are available and m_cpus(i) is set to\n-    // 1 for i = [0...engine_info.NumThreads].\n-    m_cpus.reset();\n     for (int i = 0; i < engine_info.NumThreads; i++) {\n-         m_cpus.set(i);\n+         if (m_assigned_cpus == 0 || (*m_assigned_cpus)[i]) {\n+             if (prev_cpu) {\n+                 prev_cpu->next = m_cpus + i;\n+             }\n+             else {\n+                 m_cpu_head = m_cpus + i;\n+             }\n+             m_cpus[i].prev = prev_cpu;\n+             m_cpus[i].count = 0;\n+             prev_cpu = m_cpus + i;\n+         }\n     }\n \n     // The following values will be used at pipeline creation for streams\n     m_num_cores = engine_info.NumCores;\n     m_num_threads = engine_info.NumThreads;\n \n+    print_stream_cpu_list(\"init_process\");\n+\n     // Check if OFFLOAD_DMA_CHANNEL_COUNT is set to 2\n     // Only the value 2 is supported in 16.0\n     if (mic_dma_channel_count == 2) {\n@@ -174,16 +248,45 @@ void Engine::init_process(void)\n             // Note: putenv requires its argument can't be freed or modified.\n             // So no free after call to putenv or elsewhere.\n             char * env_var = strdup(\"COI_DMA_CHANNEL_COUNT=2\");\n-\t    if (env_var == NULL)\n-\t      LIBOFFLOAD_ERROR(c_malloc);\n-            putenv(env_var);  \n+            if (env_var == NULL)\n+                LIBOFFLOAD_ERROR(c_malloc);\n+            putenv(env_var);\n         }\n     }\n \n     // Target executable is not available then use compiler provided offload_main\n     if (__target_exe == 0) {\n-       if (mic_device_main == 0)\n-          LIBOFFLOAD_ERROR(c_report_no_host_exe);\n+       // find target executable to be used if main application is not an\n+       // offload build application.\n+       const char *base_name = \"offload_main\";\n+       if (mic_library_path != 0) {\n+          char *buf = strdup(mic_library_path);\n+          if (buf == NULL)\n+              LIBOFFLOAD_ERROR(c_malloc);\n+          char *try_name = (char*) alloca(strlen(mic_library_path) +\n+                                          strlen(base_name) + 2);\n+          char *dir, *ptr;\n+\n+          for (dir = strtok_r(buf, PATH_SEPARATOR, &ptr); dir != 0;\n+               dir = strtok_r(0, PATH_SEPARATOR, &ptr)) {\n+              // compose a full path\n+              sprintf(try_name, \"%s/%s\", dir, base_name);\n+\n+              // check if such file exists\n+              struct stat st;\n+              if (stat(try_name, &st) == 0 && S_ISREG(st.st_mode)) {\n+                  mic_device_main = strdup(try_name);\n+                  if (mic_device_main == NULL)\n+                      LIBOFFLOAD_ERROR(c_malloc);\n+                  break;\n+              }\n+          }\n+          free(buf);\n+       }\n+       if (mic_device_main == 0) {\n+          LIBOFFLOAD_ERROR(c_report_no_target_exe, \"offload_main\");\n+          exit(1);\n+       }\n \n        OFFLOAD_DEBUG_TRACE(2,\n            \"Loading target executable %s\\n\",mic_device_main);\n@@ -291,12 +394,20 @@ void Engine::init_process(void)\n     if (__dbg_is_attached) {\n         // TODO: we have in-memory executable now.\n         // Check with IDB team what should we provide them now?\n-        if (strlen(__target_exe->name) < MAX_TARGET_NAME) {\n-            strcpy(__dbg_target_exe_name, __target_exe->name);\n+        if (__target_exe == 0) {\n+            strcpy(__dbg_target_exe_name, \"offload_main\");\n+        }\n+        else {\n+            if (strlen(__target_exe->name) < MAX_TARGET_NAME) {\n+                strcpy(__dbg_target_exe_name, __target_exe->name);\n+            }\n         }\n         __dbg_target_so_pid = pid;\n         __dbg_target_id = m_physical_index;\n-        __dbg_target_so_loaded();\n+       // The call to __dbg_target_so_loaded() is moved\n+       // to Engine:init so all the libraries are loaded before\n+       // informing debugger so debugger can access them.\n+       // __dbg_target_so_loaded();\n     }\n }\n \n@@ -364,7 +475,7 @@ void Engine::load_libraries()\n         m_dyn_libs.push_front(DynLib(it->name, it->data, lib));\n \n         if (res != COI_SUCCESS && res != COI_ALREADY_EXISTS) {\n-            check_result(res, c_load_library, m_index, res);\n+            check_result(res, c_load_library, it->origin, m_index, res);\n         }\n     }\n     m_images.clear();\n@@ -499,6 +610,7 @@ void Engine::init_ptr_data(void)\n             if (is_new) {\n                 ptr->mic_addr = ti->addr;\n                 ptr->is_static = true;\n+                ptr->var_alloc_type = (*hi)->var_alloc_type;\n             }\n             ptr->alloc_ptr_data_lock.unlock();\n             hi++;\n@@ -670,8 +782,39 @@ COIPIPELINE Engine::get_pipeline(void)\n             LIBOFFLOAD_ERROR(c_coipipe_max_number, COI_PIPELINE_MAX_PIPELINES);\n             LIBOFFLOAD_ABORT;\n         }\n-        // create pipeline for this thread\n-        res = COI::PipelineCreate(m_process, 0, mic_stack_size, &pipeline);\n+\n+        // Create pipeline for this thread\n+        if (m_assigned_cpus == 0) {\n+            // If m_assigned_cpus is NULL, it implies all threads\n+            // Create the pipeline with no CPU mask\n+            res = COI::PipelineCreate(m_process, 0, mic_stack_size, &pipeline);\n+        } else {\n+            // Create COI CPU mask\n+            COI_CPU_MASK  in_Mask;\n+            res = COI::PipelineClearCPUMask(in_Mask);\n+            check_result(res, c_clear_cpu_mask, m_index, res);\n+\n+            int threads_per_core = m_num_threads / m_num_cores;\n+\n+            // Available threads are defined by examining of m_assigned_cpus bitset.\n+            // We skip thread 0.\n+            for (int i = 1; i < m_num_threads; i++) {\n+                // For available thread i m_assigned_cpus[i] is equal to 1\n+                if ((*m_assigned_cpus)[i]) {\n+                    COI_CPU_MASK_SET(i, in_Mask);\n+                }\n+            }\n+            OFFLOAD_DEBUG_TRACE(2, \"COIPipelineCreate Mask for this CPU thread\\n\"\n+                               \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\"\n+                               \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\",\n+                               in_Mask[0], in_Mask[1], in_Mask[2], in_Mask[3],\n+                               in_Mask[4], in_Mask[5], in_Mask[6], in_Mask[7],\n+                               in_Mask[8], in_Mask[9], in_Mask[10], in_Mask[11],\n+                               in_Mask[12], in_Mask[13], in_Mask[14], in_Mask[15]);\n+\n+            // Create the pipeline with allowable CPUs\n+            res = COI::PipelineCreate(m_process, in_Mask, mic_stack_size, &pipeline);\n+        }\n         check_result(res, c_pipeline_create, m_index, res);\n         thread->set_pipeline(m_index, pipeline);\n     }\n@@ -696,6 +839,33 @@ Stream* Stream::find_stream(uint64_t handle, bool remove)\n     return stream;\n }\n \n+void Engine::move_cpu_el_after(CpuEl* cpu_what, CpuEl* cpu_after)\n+{\n+    if (cpu_what == cpu_after) {\n+        return;\n+    }\n+    CpuEl* cpu_prev = cpu_what->prev;\n+\n+    // remove cpu_what\n+    if (!cpu_prev) {\n+        m_cpu_head = cpu_what->next;\n+    }\n+    else {\n+        cpu_prev->next = cpu_what->next;\n+    }\n+    if (cpu_what->next) {\n+        cpu_what->next->prev = cpu_prev;\n+    }\n+\n+    // insert cpu_what after cpu_after\n+    cpu_what->prev = cpu_after;\n+    cpu_what->next = cpu_after->next;\n+    if (cpu_after->next) {\n+        cpu_after->next->prev = cpu_what;\n+    }\n+    cpu_after->next = cpu_what;\n+}\n+\n COIPIPELINE Engine::get_pipeline(_Offload_stream handle)\n {\n     Stream * stream = Stream::find_stream(handle, false);\n@@ -740,39 +910,60 @@ COIPIPELINE Engine::get_pipeline(_Offload_stream handle)\n \n         int threads_per_core = m_num_threads / m_num_cores;\n \n-        // The \"stream_cpu_num\" available threads is set in mask.\n-        // Available threads are defined by examining of m_cpus bitset.\n-        // We skip thread 0 .\n-        for (int i = 1; i < m_num_threads; i++) {\n-            // for available thread i m_cpus[i] is equal to 1\n-            if (m_cpus[i]) {\n-                res = COI::PipelineSetCPUMask(m_process,\n-                    i / threads_per_core,\n-                    i % threads_per_core,\n-                    in_Mask);\n-\n-                check_result(res, c_set_cpu_mask, res);\n-                // mark thread i as nonavailable\n-                m_cpus.set(i,0);\n-                // Mark thread i as given for the stream.\n-                // In case of stream destroying by call to\n-                // _Offload_stream_destroy we can mark the thread i as\n-                // available.\n-                stream->m_stream_cpus.set(i);\n-                if (--stream_cpu_num <= 0) {\n+\n+        // Available threads is taken from m_cpus list.\n+        // m_cpu_head points to the head of m_cpus.\n+        // the elements of m_cpus is ordered by the number of usage in streams.\n+\n+        CpuEl *cpu_el = m_cpu_head;\n+        CpuEl *cpu_used_el, *cpu_used_prev, *cpu_prev;\n+\n+        for (int i = 0; i < stream_cpu_num; i++) {\n+            COI_CPU_MASK_SET(CPU_INDEX(cpu_el), in_Mask);\n+            stream->m_stream_cpus.set(CPU_INDEX(cpu_el));\n+            //If the number of availabale threads is less than stream_cpu_num,\n+            // the stream_cpu_num is restricted to this number.\n+            if (!cpu_el->next) {\n+                break;\n+            }\n+            if (i + 1 < stream_cpu_num) {\n+                cpu_el = cpu_el->next;\n+            }\n+        }\n+\n+        // assertion : cpu_el points to the last used thread\n+        cpu_used_el = cpu_el;\n+        while (cpu_used_el) {\n+            cpu_used_el->count++;\n+            cpu_el = cpu_prev = cpu_used_el;\n+            cpu_used_prev = cpu_used_el->prev;\n+            if (!cpu_el->next) {\n+                cpu_used_el = cpu_used_prev;\n+                continue;\n+            }\n+            \n+            while (cpu_el) {\n+                if (cpu_used_el->count < cpu_el->count) {\n                     break;\n                 }\n+                // Equal used threads are ordered by thread number to\n+                // assign to a stream as contiguous threads as possible.\n+                else if (cpu_used_el->count == cpu_el->count &&\n+                         CPU_INDEX(cpu_used_el) <  CPU_INDEX(cpu_el)) {\n+                     break;               \n+                }\n+                cpu_prev = cpu_el;\n+                cpu_el = cpu_el->next;\n             }\n+            if (cpu_used_el != cpu_prev) {\n+                move_cpu_el_after(cpu_used_el, cpu_prev);\n+            }\n+            cpu_used_el = cpu_used_prev;\n         }\n+        print_stream_cpu_list(\"get_pipeline\");\n \n-        // if stream_cpu_num is greater than 0 there are not enough\n-        // available threads\n-        if (stream_cpu_num > 0) {\n-            LIBOFFLOAD_ERROR(c_create_pipeline_for_stream, m_num_threads);\n-            LIBOFFLOAD_ABORT;\n-        }\n         // create pipeline for this thread\n-        OFFLOAD_DEBUG_TRACE(2, \"COIPipelineCreate Mask\\n\"\n+        OFFLOAD_DEBUG_TRACE(2, \"COIPipelineCreate Mask for this Stream\\n\"\n                                \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\"\n                                \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\",\n                                in_Mask[0], in_Mask[1], in_Mask[2], in_Mask[3],\n@@ -859,9 +1050,48 @@ void Engine::stream_destroy(_Offload_stream handle)\n         // return cpus for future use\n         for (int i = 0; i < m_num_threads; i++) {\n             if (stream->m_stream_cpus.test(i)) {\n-                m_cpus.set(i);\n+                CpuEl *cpu_el = m_cpus + i;\n+                CpuEl *cpu_first_el = cpu_el;\n+                // decrease count of thread \"i\" and move its CpuEl to the\n+                // proper place into the ordered list\n+                cpu_el->count--;\n+                while (cpu_el->prev) {\n+                    if (cpu_first_el->count > cpu_el->prev->count) {\n+                        break;\n+                    }\n+                    else if (cpu_first_el->count == cpu_el->prev->count &&\n+                             CPU_INDEX(cpu_first_el) > CPU_INDEX(cpu_el->prev)) {\n+                        break;\n+                    }\n+                    cpu_el = cpu_el->prev;\n+                }\n+                cpu_el = cpu_el->prev;\n+                // If cpu_el for thread \"i\" must be moved in the list\n+                if (cpu_first_el != cpu_el) {\n+                    // Thread \"i\" is used the least times. It must be set as\n+                    // the m_cpu_head.\n+                    if (!cpu_el) {\n+                        if (!cpu_first_el->prev) {\n+                            continue;\n+                        }\n+                        // remove cpu_el.\n+                        cpu_first_el->prev->next = cpu_first_el->next;\n+                        if (cpu_first_el->next) {\n+                            cpu_first_el->next->prev = cpu_first_el->prev;\n+                        }\n+                        // make cpu_first_el as new m_cpu_head\n+                        cpu_first_el->prev = NULL;\n+                        cpu_first_el->next = m_cpu_head;\n+                        m_cpu_head->prev = cpu_first_el;\n+                        m_cpu_head = cpu_first_el;\n+                    }\n+                    else {\n+                        move_cpu_el_after(cpu_first_el, cpu_el);\n+                    }\n+                }\n             }\n         }\n+        print_stream_cpu_list(\"stream_destroy\");        \n         delete stream;\n     }\n     else {"}, {"sha": "b4cdad503be3f6b532c512c2506e590076bd7696", "filename": "liboffloadmic/runtime/offload_engine.h", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_engine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_engine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -39,7 +39,7 @@\n #include \"offload_common.h\"\n #include \"coi/coi_client.h\"\n \n-#define SIGNAL_IS_REMOVED ((OffloadDescriptor *)-1)\n+#define SIGNAL_HAS_COMPLETED ((OffloadDescriptor *)-1)\n const int64_t no_stream = -1;\n \n // Address range\n@@ -83,7 +83,7 @@ class PtrData {\n     PtrData(const void *addr, uint64_t len) :\n         cpu_addr(addr, len), cpu_buf(0),\n         mic_addr(0), alloc_disp(0), mic_buf(0), mic_offset(0),\n-        ref_count(0), is_static(false)\n+        ref_count(0), is_static(false), is_omp_associate(false)\n     {}\n \n     //\n@@ -93,7 +93,9 @@ class PtrData {\n         cpu_addr(ptr.cpu_addr), cpu_buf(ptr.cpu_buf),\n         mic_addr(ptr.mic_addr), alloc_disp(ptr.alloc_disp),\n         mic_buf(ptr.mic_buf), mic_offset(ptr.mic_offset),\n-        ref_count(ptr.ref_count), is_static(ptr.is_static)\n+        ref_count(ptr.ref_count), is_static(ptr.is_static),\n+        is_omp_associate(ptr.is_omp_associate),\n+        var_alloc_type(0)\n     {}\n \n     bool operator<(const PtrData &o) const {\n@@ -104,7 +106,7 @@ class PtrData {\n     }\n \n     long add_reference() {\n-        if (is_static) {\n+        if (is_omp_associate || (is_static && !var_alloc_type)) {\n             return LONG_MAX;\n         }\n #ifndef TARGET_WINNT\n@@ -115,7 +117,7 @@ class PtrData {\n     }\n \n     long remove_reference() {\n-        if (is_static) {\n+        if (is_omp_associate || (is_static && !var_alloc_type)) {\n             return LONG_MAX;\n         }\n #ifndef TARGET_WINNT\n@@ -126,7 +128,7 @@ class PtrData {\n     }\n \n     long get_reference() const {\n-        if (is_static) {\n+        if (is_omp_associate || (is_static && !var_alloc_type)) {\n             return LONG_MAX;\n         }\n         return ref_count;\n@@ -151,6 +153,11 @@ class PtrData {\n \n     // if true buffers are created from static memory\n     bool            is_static;\n+\n+    // true if MIC buffer created by omp_target_associate\n+    bool            is_omp_associate;\n+\n+    bool            var_alloc_type;\n     mutex_t         alloc_ptr_data_lock;\n \n private:\n@@ -362,10 +369,16 @@ struct Stream\n     static Stream* find_stream(uint64_t handle, bool remove);\n \n     static _Offload_stream  add_stream(int device, int number_of_cpus) {\n+        _Offload_stream result;\n         m_stream_lock.lock();\n-        all_streams[++m_streams_count] = new Stream(device, number_of_cpus);\n+        result = ++m_streams_count;\n+        all_streams[m_streams_count] = new Stream(device, number_of_cpus);\n         m_stream_lock.unlock();\n-        return(m_streams_count);\n+        return(result);\n+    }\n+\n+    static uint64_t get_streams_count() {\n+        return m_streams_count;\n     }\n \n     typedef std::map<uint64_t, Stream*> StreamMap;\n@@ -390,12 +403,21 @@ struct Stream\n };\n \n typedef std::map<uint64_t, Stream*> StreamMap;\n+typedef std::bitset<COI_MAX_HW_THREADS> micLcpuMask;\n+\n+// ordered by count double linked list of cpus used by streams\n+typedef struct CpuEl{\n+    uint64_t      count; // number of streams using the cpu\n+    struct CpuEl* prev;  // cpu with the same or lesser count\n+    struct CpuEl* next;  // cpu with the same or greater count\n+} CpuEl;\n \n // class representing a single engine\n struct Engine {\n     friend void __offload_init_library_once(void);\n     friend void __offload_fini_library(void);\n \n+#define CPU_INDEX(x) (x - m_cpus)\n #define check_result(res, tag, ...) \\\n     { \\\n         if (res == COI_PROCESS_DIED) { \\\n@@ -420,6 +442,10 @@ struct Engine {\n         return m_process;\n     }\n \n+    bool get_ready() {\n+        return m_ready;\n+    }\n+\n     uint64_t get_thread_id(void);\n \n     // initialize device\n@@ -539,7 +565,7 @@ struct Engine {\n             if (it != m_signal_map.end()) {\n                 desc = it->second;\n                 if (remove) {\n-                    it->second = SIGNAL_IS_REMOVED;\n+                    it->second = SIGNAL_HAS_COMPLETED;\n                 }\n             }\n         }\n@@ -548,8 +574,23 @@ struct Engine {\n         return desc;\n     }\n \n+    void complete_signaled_ofld(const void *signal) {\n+\n+        m_signal_lock.lock();\n+        {\n+            SignalMap::iterator it = m_signal_map.find(signal);\n+            if (it != m_signal_map.end()) {\n+                it->second = SIGNAL_HAS_COMPLETED;\n+            }\n+        }\n+        m_signal_lock.unlock();\n+    }\n+\n     void stream_destroy(_Offload_stream handle);\n \n+    void move_cpu_el_after(CpuEl* cpu_what, CpuEl* cpu_after);\n+    void print_stream_cpu_list(const char *);\n+\n     COIPIPELINE get_pipeline(_Offload_stream stream);\n \n     StreamMap get_stream_map() {\n@@ -564,10 +605,11 @@ struct Engine {\n \n private:\n     Engine() : m_index(-1), m_physical_index(-1), m_process(0), m_ready(false),\n-               m_proc_number(0)\n+               m_proc_number(0), m_assigned_cpus(0), m_cpus(0), m_cpu_head(0)\n     {}\n \n     ~Engine() {\n+        m_ready = false;\n         for (StreamMap::iterator it = m_stream_map.begin();\n              it != m_stream_map.end(); it++) {\n             Stream * stream = it->second;\n@@ -576,6 +618,9 @@ struct Engine {\n         if (m_process != 0) {\n             fini_process(false);\n         }\n+        if (m_assigned_cpus) {\n+            delete m_assigned_cpus;\n+        }\n     }\n \n     // set indexes\n@@ -584,6 +629,12 @@ struct Engine {\n         m_physical_index = physical_index;\n     }\n \n+    // set CPU mask\n+    void set_cpu_mask(micLcpuMask *cpu_mask)\n+    {\n+        m_assigned_cpus = cpu_mask;\n+    }\n+\n     // start process on device\n     void init_process();\n \n@@ -611,6 +662,9 @@ struct Engine {\n     int         m_index;\n     int         m_physical_index;\n \n+    // cpu mask\n+    micLcpuMask *m_assigned_cpus;\n+\n     // number of COI pipes created for the engine\n     long        m_proc_number;\n \n@@ -634,11 +688,12 @@ struct Engine {\n     mutex_t   m_signal_lock;\n \n     // streams\n-    StreamMap m_stream_map;\n-    mutex_t   m_stream_lock;\n-    int       m_num_cores;\n-    int       m_num_threads;\n-    std::bitset<COI_MAX_HW_THREADS> m_cpus;\n+    StreamMap   m_stream_map;\n+    mutex_t     m_stream_lock;\n+    int         m_num_cores;\n+    int         m_num_threads;\n+    CpuEl*      m_cpus;\n+    CpuEl*      m_cpu_head;\n \n     // List of dynamic libraries to be registred\n     DynLibList m_dyn_libs;"}, {"sha": "d1f52f143422f2eb88c3798aba1b51d525205f56", "filename": "liboffloadmic/runtime/offload_env.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_env.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_env.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -212,14 +212,14 @@ MicEnvVarKind MicEnvVar::get_env_var_kind(\n             *env_var_name_length = 3;\n             *env_var_name = *env_var_def = c;\n             *env_var_def = strdup(*env_var_def);\n-\t    if (*env_var_def == NULL)\n-\t      LIBOFFLOAD_ERROR(c_malloc);\n+            if (*env_var_def == NULL)\n+                LIBOFFLOAD_ERROR(c_malloc);\n             return  c_mic_var;\n         }\n         *env_var_def = c + strlen(\"ENV=\");\n         *env_var_def = strdup(*env_var_def);\n-\tif (*env_var_def == NULL)\n-\t  LIBOFFLOAD_ERROR(c_malloc);\n+        if (*env_var_def == NULL)\n+            LIBOFFLOAD_ERROR(c_malloc);\n         return c_mic_card_env;\n     }\n     if (isalpha(*c)) {\n@@ -234,7 +234,7 @@ MicEnvVarKind MicEnvVar::get_env_var_kind(\n     }\n     *env_var_def = strdup(*env_var_def);\n     if (*env_var_def == NULL)\n-      LIBOFFLOAD_ERROR(c_malloc);\n+        LIBOFFLOAD_ERROR(c_malloc);\n     return card_is_set? c_mic_card_var : c_mic_var;\n }\n "}, {"sha": "166b5d9242df3adbfe32420d4841dbbd2d61fb71", "filename": "liboffloadmic/runtime/offload_env.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_env.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_env.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "cab08c43550d7e7872f466c510f5b9aac91c7f20", "filename": "liboffloadmic/runtime/offload_host.cpp", "status": "modified", "additions": 1986, "deletions": 629, "changes": 2615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae"}, {"sha": "4f1ef1392ba5688d66ee2ed49fe7f40948f6c57e", "filename": "liboffloadmic/runtime/offload_host.h", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -88,6 +88,8 @@ class OffloadDescriptor\n         m_inout_buf(0),\n         m_func_desc(0),\n         m_func_desc_size(0),\n+        m_num_in_dependencies(0),\n+        m_p_in_dependencies(0),\n         m_in_deps(0),\n         m_in_deps_total(0),\n         m_in_deps_allocated(0),        \n@@ -102,6 +104,8 @@ class OffloadDescriptor\n         m_preallocated_alloc(false),\n         m_traceback_called(false),\n         m_stream(-1),\n+        m_signal(0),\n+        m_has_signal(0),\n         m_omp_async_last_event_type(c_last_not)\n     {\n         m_wait_all_devices = index == -1;\n@@ -146,6 +150,24 @@ class OffloadDescriptor\n         return(m_stream);\n     }\n \n+    Engine& get_device() {\n+        return m_device;\n+    }\n+\n+    void* get_signal() {\n+        return(m_signal);\n+    }\n+\n+    void set_signal(const void* signal) {\n+        m_has_signal = 1;\n+        m_signal = const_cast<void*>(signal);\n+    }\n+\n+    void cleanup();\n+\n+    uint32_t  m_event_count;\n+    bool      m_has_signal;\n+\n private:\n     bool offload_wrap(const char *name, bool is_empty,\n                  VarDesc *vars, VarDesc2 *vars2, int vars_total,\n@@ -183,19 +205,34 @@ class OffloadDescriptor\n     bool receive_pointer_data(bool is_async, bool first_run, void * info);\n     bool scatter_copyout_data();\n \n-    void cleanup();\n-\n     bool find_ptr_data(PtrData* &ptr_data, void *base, int64_t disp,\n                        int64_t length, bool is_targptr,\n                        bool error_does_not_exist = true);\n+\n+    void find_device_ptr( int64_t* &device_ptr,\n+                       void *host_ptr);\n+\n     bool alloc_ptr_data(PtrData* &ptr_data, void *base, int64_t disp,\n                         int64_t length, int64_t alloc_disp, int align,\n                         bool is_targptr, bool is_prealloc, bool pin);\n     bool create_preallocated_buffer(PtrData* ptr_data, void *base);\n     bool init_static_ptr_data(PtrData *ptr_data);\n     bool init_mic_address(PtrData *ptr_data);\n-    bool offload_stack_memory_manager(const void * stack_begin, int routine_id,\n-                                      int buf_size, int align, bool *is_new);\n+    bool offload_stack_memory_manager(\n+        const void * stack_begin,\n+        int routine_id,\n+        int buf_size,\n+        int align,\n+        bool thread_specific_function_locals,\n+        bool *is_new);\n+    char *get_this_threads_cpu_stack_addr(\n+        const void * stack_begin,\n+        int routine_id,\n+        bool thread_specific_function_locals);\n+    PtrData *get_this_threads_mic_stack_addr(\n+        const void * stack_begin,\n+        int routine_id,\n+        bool thread_specific_function_locals);\n     bool nullify_target_stack(COIBUFFER targ_buf, uint64_t size);\n \n     bool gen_var_descs_for_pointer_array(int i);\n@@ -205,10 +242,20 @@ class OffloadDescriptor\n \n     void report_coi_error(error_types msg, COIRESULT res);\n     _Offload_result translate_coi_error(COIRESULT res) const;\n-    \n+\n     void setup_omp_async_info();\n+\n+    void setup_use_device_ptr(int i);\n+\n+    void register_event_call_back(void (*)(\n+                                      COIEVENT,\n+                                      const COIRESULT,\n+                                      const void*),\n+                                  const COIEVENT *event,\n+                                  const void *info);\n+\n     void register_omp_event_call_back(const COIEVENT *event, const void *info);\n-    \n+\n private:\n     typedef std::list<COIBUFFER> BufferList;\n \n@@ -220,11 +267,17 @@ class OffloadDescriptor\n         int64_t cpu_disp;\n         int64_t cpu_offset;\n         void *alloc;\n-        CeanReadRanges *read_rng_src;\n+        union {\n+            CeanReadRanges *read_rng_src;\n+            NonContigDesc  *noncont_desc;\n+        };\n         CeanReadRanges *read_rng_dst;\n         int64_t ptr_arr_offset;\n         bool is_arr_ptr_el;\n         OmpAsyncLastEventType omp_last_event_type;\n+        int64_t pointer_offset;\n+        uint16_t type_src;\n+        uint16_t type_dst;\n     };\n \n     template<typename T> class ReadArrElements {\n@@ -320,17 +373,36 @@ class OffloadDescriptor\n     // Buffer for transferring copyin/copyout data\n     COIBUFFER m_inout_buf;\n \n+\n     // Dependencies\n     COIEVENT *m_in_deps;\n     uint32_t  m_in_deps_total;\n     uint32_t  m_in_deps_allocated;    \n     COIEVENT *m_out_deps;\n     uint32_t  m_out_deps_total;\n-    uint32_t  m_out_deps_allocated;     \n+    uint32_t  m_out_deps_allocated;\n+\n+    // 2 variables defines input dependencies for current COI API.\n+    // The calls to routines as BufferWrite/PipelineRunFunction/BufferRead\n+    // is supposed to have input dependencies.\n+    // 2 variables below defines the number and vector of dependencies\n+    // in every current moment of offload.\n+    // So any phase of offload can use its values as input dependencies \n+    // for the COI API that the phase calls.\n+    // It means that all phases (of Write, RunFunction,Read) must keep\n+    // the variables correct to be used by following phase.\n+    // If some consequent offloads are connected (i.e. by the same stream)\n+    // the final 2 variables of the offload is used as initial inputs\n+    // for the next offload.\n+    uint32_t  m_num_in_dependencies;\n+    COIEVENT *m_p_in_dependencies;\n \n     // Stream\n     _Offload_stream m_stream;\n \n+    // Signal\n+    void* m_signal;\n+\n     // Timer data\n     OffloadHostTimerData *m_timer_data;\n \n@@ -396,8 +468,11 @@ DLL_LOCAL extern MicEnvVar mic_env_vars;\n // CPU frequency\n DLL_LOCAL extern uint64_t cpu_frequency;\n \n-// LD_LIBRARY_PATH for MIC libraries\n-DLL_LOCAL extern char* mic_library_path;\n+// LD_LIBRARY_PATH for KNC libraries\n+DLL_LOCAL extern char* knc_library_path;\n+\n+// LD_LIBRARY_PATH for KNL libraries\n+DLL_LOCAL extern char* knl_library_path;\n \n // stack size for target\n DLL_LOCAL extern uint32_t mic_stack_size;\n@@ -427,6 +502,11 @@ DLL_LOCAL extern int __omp_device_num;\n // target executable\n DLL_LOCAL extern TargetImage* __target_exe;\n \n+// is true if last loaded image is dll\n+DLL_LOCAL extern bool __current_image_is_dll;\n+// is true if myo library is loaded when dll is loaded\n+DLL_LOCAL extern bool __myo_init_in_so;\n+\n // IDB support\n \n // Called by the offload runtime after initialization of offload infrastructure"}, {"sha": "baf25afbb2fbf6f95006eb2c15221f38394441e4", "filename": "liboffloadmic/runtime/offload_iterator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_iterator.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "621494906413c247a677c8b64df2660da128d96d", "filename": "liboffloadmic/runtime/offload_myo_host.cpp", "status": "removed", "additions": 0, "deletions": 1312, "changes": 1312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,1312 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#if defined(LINUX) || defined(FREEBSD)\n-#include <mm_malloc.h>\n-#endif\n-\n-#include \"offload_myo_host.h\"\n-#include <errno.h>\n-#include <malloc.h>\n-#include \"offload_host.h\"\n-//#include \"offload_util.h\"\n-\n-#define MYO_VERSION1    \"MYO_1.0\"\n-\n-extern \"C\" void __cilkrts_cilk_for_32(void*, void*, uint32_t, int32_t);\n-extern \"C\" void __cilkrts_cilk_for_64(void*, void*, uint64_t, int32_t);\n-\n-#ifndef TARGET_WINNT\n-#pragma weak __cilkrts_cilk_for_32\n-#pragma weak __cilkrts_cilk_for_64\n-#endif // TARGET_WINNT\n-\n-static void __offload_myoProcessDeferredTables();\n-\n-class MyoWrapper {\n-public:\n-    MyoWrapper() : m_lib_handle(0), m_is_available(false)\n-    {}\n-\n-    bool is_available() const {\n-        return m_is_available;\n-    }\n-\n-    bool LoadLibrary(void);\n-\n-    // unloads the library\n-    void UnloadLibrary(void) {\n-//        if (m_lib_handle != 0) {\n-//            DL_close(m_lib_handle);\n-//            m_lib_handle = 0;\n-//        }\n-    }\n-\n-    // Wrappers for MYO client functions\n-    void LibInit(void *arg, void *func) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoinit,\n-                                 \"%s(%p, %p)\\n\", __func__, arg, func);\n-        CheckResult(__func__, m_lib_init(arg, func));\n-    }\n-\n-    void LibFini(void) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myofini, \"%s()\\n\", __func__);\n-        m_lib_fini();\n-    }\n-\n-    void* SharedMalloc(size_t size) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedmalloc,\n-                                 \"%s(%lld)\\n\", __func__, size);\n-        return m_shared_malloc(size);\n-    }\n-\n-    void SharedFree(void *ptr) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedfree,\n-                                 \"%s(%p)\\n\", __func__, ptr);\n-        m_shared_free(ptr);\n-    }\n-\n-    void* SharedAlignedMalloc(size_t size, size_t align) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedmalloc,\n-                                 \"%s(%lld, %lld)\\n\", __func__, size, align);\n-        return m_shared_aligned_malloc(size, align);\n-    }\n-\n-    void SharedAlignedFree(void *ptr) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedfree,\n-                              \"%s(%p)\\n\", __func__, ptr);\n-        m_shared_aligned_free(ptr);\n-    }\n-\n-    void Acquire(void) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoacquire,\n-                              \"%s()\\n\", __func__);\n-        CheckResult(__func__, m_acquire());\n-    }\n-\n-    void Release(void) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myorelease,\n-                            \"%s()\\n\", __func__);\n-        CheckResult(__func__, m_release());\n-    }\n-\n-    void HostVarTablePropagate(void *table, int num_entries) const {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s(%p, %d)\\n\", __func__, table, num_entries);\n-        CheckResult(__func__, m_host_var_table_propagate(table, num_entries));\n-    }\n-\n-    void HostFptrTableRegister(void *table, int num_entries,\n-                               int ordered) const {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoregister,\n-                            \"%s(%p, %d, %d)\\n\", __func__, table,\n-                            num_entries, ordered);\n-        CheckResult(__func__,\n-                    m_host_fptr_table_register(table, num_entries, ordered));\n-    }\n-\n-    void RemoteThunkCall(void *thunk, void *args, int device) {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s(%p, %p, %d)\\n\", __func__, thunk, args,\n-                            device);\n-        CheckResult(__func__, m_remote_thunk_call(thunk, args, device));\n-    }\n-\n-    MyoiRFuncCallHandle RemoteCall(const char *func, void *args, int device) const {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s(%s, %p, %d)\\n\", __func__, func, args,\n-                            device);\n-        return m_remote_call(func, args, device);\n-    }\n-\n-    void GetResult(MyoiRFuncCallHandle handle) const {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s(%p)\\n\", __func__, handle);\n-        CheckResult(__func__, m_get_result(handle));\n-    }\n-\n-    bool PostInitFuncSupported() const {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s()\\n\", __func__);\n-        if (m_feature_available) {\n-            return m_feature_available(MYO_FEATURE_POST_LIB_INIT) ==\n-                       MYO_SUCCESS;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    void CreateVtableArena();\n-\n-    MyoArena GetVtableArena()const {\n-        return m_vtable_arena;\n-    }\n-\n-    void ArenaCreate(\n-        MyoOwnershipType ownership,\n-        int consistency,\n-        MyoArena* arena\n-    ) const\n-    {\n-        OFFLOAD_DEBUG_TRACE(4, \"%s(%d, %d, %p)\\n\",\n-            __func__, ownership, consistency, arena);\n-        CheckResult(__func__, m_arena_create(ownership, consistency, arena));\n-    }\n-\n-    void* SharedAlignedArenaMalloc(\n-        MyoArena arena,\n-        size_t size,\n-        size_t align\n-    ) const\n-    {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedarenamalloc,\n-                                 \"%s(%u, %lld, %lld)\\n\",\n-                                 __func__, arena, size, align);\n-        return m_arena_aligned_malloc(arena, size, align);\n-    }\n-\n-    void* SharedAlignedArenaFree(\n-        MyoArena arena,\n-        void* ptr\n-    ) const\n-    {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedarenafree,\n-                                 \"%s(%u, %p)\\n\", __func__, arena, ptr);\n-        return m_arena_aligned_free(arena, ptr);\n-    }\n-\n-    void ArenaAcquire(\n-        MyoArena arena\n-    ) const\n-    {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoarenaacquire,\n-                              \"%s()\\n\", __func__);\n-        CheckResult(__func__, m_arena_acquire(arena));\n-    }\n-\n-    void ArenaRelease(\n-        MyoArena arena\n-    ) const\n-    {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoarenarelease,\n-                            \"%s()\\n\", __func__);\n-        CheckResult(__func__, m_arena_release(arena));\n-    }\n-\n-private:\n-    void CheckResult(const char *func, MyoError error) const {\n-        if (error != MYO_SUCCESS) {\n-             LIBOFFLOAD_ERROR(c_myowrapper_checkresult, func, error);\n-            exit(1);\n-        }\n-    }\n-\n-private:\n-    void*    m_lib_handle;\n-    bool     m_is_available;\n-    int      m_post_init_func;\n-    MyoArena m_vtable_arena;\n-\n-    // pointers to functions from myo library\n-    MyoError (*m_lib_init)(void*, void*);\n-    void     (*m_lib_fini)(void);\n-    void*    (*m_shared_malloc)(size_t);\n-    void     (*m_shared_free)(void*);\n-    void*    (*m_shared_aligned_malloc)(size_t, size_t);\n-    void     (*m_shared_aligned_free)(void*);\n-    MyoError (*m_acquire)(void);\n-    MyoError (*m_release)(void);\n-    MyoError (*m_host_var_table_propagate)(void*, int);\n-    MyoError (*m_host_fptr_table_register)(void*, int, int);\n-    MyoError (*m_remote_thunk_call)(void*, void*, int);\n-    MyoiRFuncCallHandle (*m_remote_call)(const char*, void*, int);\n-    MyoError (*m_get_result)(MyoiRFuncCallHandle);\n-    MyoError (*m_arena_create)(MyoOwnershipType, int, MyoArena*);\n-    void*    (*m_arena_aligned_malloc)(MyoArena, size_t, size_t);\n-    void*    (*m_arena_aligned_free)(MyoArena, void*);\n-    MyoError (*m_arena_acquire)(MyoArena);\n-    MyoError (*m_arena_release)(MyoArena);\n-    // Placeholder until MYO headers support enum type for feature\n-    MyoError (*m_feature_available)(int feature);\n-};\n-\n-DLL_LOCAL bool MyoWrapper::LoadLibrary(void)\n-{\n-#ifndef TARGET_WINNT\n-    const char *lib_name = \"libmyo-client.so\";\n-#else // TARGET_WINNT\n-    const char *lib_name = \"myo-client.dll\";\n-#endif // TARGET_WINNT\n-\n-    OFFLOAD_DEBUG_TRACE(2, \"Loading MYO library %s ...\\n\", lib_name);\n-\n-    m_lib_handle = DL_open(lib_name);\n-    if (m_lib_handle == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to load the library. errno = %d\\n\",\n-                            errno);\n-        return false;\n-    }\n-\n-    m_lib_init = (MyoError (*)(void*, void*))\n-        DL_sym(m_lib_handle, \"myoiLibInit\", MYO_VERSION1);\n-    if (m_lib_init == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiLibInit\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_lib_fini = (void (*)(void))\n-        DL_sym(m_lib_handle, \"myoiLibFini\", MYO_VERSION1);\n-    if (m_lib_fini == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiLibFini\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_shared_malloc = (void* (*)(size_t))\n-        DL_sym(m_lib_handle, \"myoSharedMalloc\", MYO_VERSION1);\n-    if (m_shared_malloc == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoSharedMalloc\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_shared_free = (void (*)(void*))\n-        DL_sym(m_lib_handle, \"myoSharedFree\", MYO_VERSION1);\n-    if (m_shared_free == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoSharedFree\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_shared_aligned_malloc = (void* (*)(size_t, size_t))\n-        DL_sym(m_lib_handle, \"myoSharedAlignedMalloc\", MYO_VERSION1);\n-    if (m_shared_aligned_malloc == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoSharedAlignedMalloc\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_shared_aligned_free = (void (*)(void*))\n-        DL_sym(m_lib_handle, \"myoSharedAlignedFree\", MYO_VERSION1);\n-    if (m_shared_aligned_free == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoSharedAlignedFree\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_acquire = (MyoError (*)(void))\n-        DL_sym(m_lib_handle, \"myoAcquire\", MYO_VERSION1);\n-    if (m_acquire == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoAcquire\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_release = (MyoError (*)(void))\n-        DL_sym(m_lib_handle, \"myoRelease\", MYO_VERSION1);\n-    if (m_release == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoRelease\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_host_var_table_propagate = (MyoError (*)(void*, int))\n-        DL_sym(m_lib_handle, \"myoiHostVarTablePropagate\", MYO_VERSION1);\n-    if (m_host_var_table_propagate == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiHostVarTablePropagate\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_host_fptr_table_register = (MyoError (*)(void*, int, int))\n-        DL_sym(m_lib_handle, \"myoiHostFptrTableRegister\", MYO_VERSION1);\n-    if (m_host_fptr_table_register == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiHostFptrTableRegister\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_remote_thunk_call = (MyoError (*)(void*, void*, int))\n-        DL_sym(m_lib_handle, \"myoiRemoteThunkCall\", MYO_VERSION1);\n-    if (m_remote_thunk_call == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiRemoteThunkCall\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_remote_call = (MyoiRFuncCallHandle (*)(const char*, void*, int))\n-        DL_sym(m_lib_handle, \"myoiRemoteCall\", MYO_VERSION1);\n-    if (m_remote_call == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiRemoteCall\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_get_result = (MyoError (*)(MyoiRFuncCallHandle))\n-        DL_sym(m_lib_handle, \"myoiGetResult\", MYO_VERSION1);\n-    if (m_get_result == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiGetResult\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_arena_create = (MyoError (*)(MyoOwnershipType, int, MyoArena*))\n-        DL_sym(m_lib_handle, \"myoArenaCreate\", MYO_VERSION1);\n-    if (m_arena_create == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoArenaCreate\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_arena_aligned_malloc = (void* (*)(MyoArena, size_t, size_t))\n-        DL_sym(m_lib_handle, \"myoArenaAlignedMalloc\", MYO_VERSION1);\n-    if (m_arena_aligned_malloc == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoArenaAlignedMalloc\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_arena_aligned_free = (void* (*)(MyoArena, void*))\n-        DL_sym(m_lib_handle, \"myoArenaAlignedFree\", MYO_VERSION1);\n-    if (m_arena_aligned_free == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoArenaAlignedFree\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_arena_acquire = (MyoError (*)(MyoArena))\n-        DL_sym(m_lib_handle, \"myoArenaAcquire\", MYO_VERSION1);\n-    if (m_acquire == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoArenaAcquire\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    m_arena_release = (MyoError (*)(MyoArena))\n-        DL_sym(m_lib_handle, \"myoArenaRelease\", MYO_VERSION1);\n-    if (m_release == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoArenaRelease\");\n-        UnloadLibrary();\n-        return false;\n-    }\n-\n-    // Check for \"feature-available\" API added in MPSS 3.3.\n-    // Not finding it is not an error.\n-    m_feature_available = (MyoError (*)(int))\n-        DL_sym(m_lib_handle, \"myoiSupportsFeature\", MYO_VERSION1);\n-    if (m_feature_available == 0) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n-                            \"myoiSupportsFeature\");\n-    }    \n-\n-    OFFLOAD_DEBUG_TRACE(2, \"The library was successfully loaded\\n\");\n-\n-    // Create arena if supported\n-    CreateVtableArena();\n-    OFFLOAD_DEBUG_TRACE(3, \"Vtable arena created\\n\");\n-\n-    m_is_available = true;\n-\n-    return true;\n-}\n-\n-static bool myo_is_available;\n-static MyoWrapper myo_wrapper;\n-\n-void MyoWrapper::CreateVtableArena()\n-{\n-    MyoArena* vtable_arena;\n-\n-    // Check if this MYO supports arenas for vtables\n-    if (myo_wrapper.PostInitFuncSupported()) {\n-        // Create arena for vtables\n-\t    vtable_arena = (MyoArena *)myo_wrapper.SharedMalloc(sizeof(MyoArena));\n-        myo_wrapper.ArenaCreate(\n-            MYO_ARENA_OURS, MYO_NO_CONSISTENCY, vtable_arena);\n-        m_vtable_arena = *vtable_arena;\n-        OFFLOAD_DEBUG_TRACE(4, \"created arena = %d\\n\", m_vtable_arena);\n-    } else {\n-        m_vtable_arena = 0;\n-    }\n-}\n-\n-struct MyoTable\n-{\n-    MyoTable(SharedTableEntry *tab, int len) : var_tab(tab), var_tab_len(len)\n-    {}\n-\n-    SharedTableEntry*   var_tab;\n-    int                 var_tab_len;\n-};\n-\n-typedef std::list<MyoTable> MyoTableList;\n-static MyoTableList __myo_table_list;\n-static mutex_t      __myo_table_lock;\n-static bool         __myo_tables = false;\n-\n-static void __offload_myo_shared_vtable_process(SharedTableEntry *entry);\n-static void __offload_myo_shared_table_process(SharedTableEntry *entry);\n-static void __offload_myo_shared_init_table_process(InitTableEntry* entry);\n-static void __offload_myo_fptr_table_process(FptrTableEntry *entry);\n-static void __offload_propagate_shared_vars();\n-\n-static void __offload_myoLoadLibrary_once(void)\n-{\n-    if (__offload_init_library()) {\n-        myo_wrapper.LoadLibrary();\n-    }\n-}\n-\n-static bool __offload_myoLoadLibrary(void)\n-{\n-    OFFLOAD_DEBUG_TRACE(4, \"__offload_myoLoadLibrary\\n\");\n-    static OffloadOnceControl ctrl = OFFLOAD_ONCE_CONTROL_INIT;\n-    __offload_run_once(&ctrl, __offload_myoLoadLibrary_once);\n-\n-    return myo_wrapper.is_available();\n-}\n-\n-static void __offload_myoInit_once(void)\n-{\n-    if (!__offload_myoLoadLibrary()) {\n-        return;\n-    }\n-\n-    // initialize all devices\n-    for (int i = 0; i < mic_engines_total; i++) {\n-        mic_engines[i].init();\n-    }\n-\n-    // load and initialize MYO library\n-    OFFLOAD_DEBUG_TRACE(2, \"Initializing MYO library ...\\n\");\n-\n-    COIEVENT events[MIC_ENGINES_MAX];\n-\n-    // One entry per device + \n-    // A pair of entries for the Host postInit func +\n-    // A pair of entries for the MIC postInit func +\n-    // end marker\n-    MyoiUserParams params[MIC_ENGINES_MAX+5];\n-\n-    // Load target library to all devices and\n-    // create libinit parameters for all devices\n-    for (int i = 0; i < mic_engines_total; i++) {\n-        mic_engines[i].init_myo(&events[i]);\n-\n-        params[i].type = MYOI_USERPARAMS_DEVID;\n-        params[i].nodeid = mic_engines[i].get_physical_index() + 1;\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n-            i, params[i].type, params[i].nodeid);\n-    }\n-\n-    // Check if V2 myoLibInit is available\n-    if (myo_wrapper.PostInitFuncSupported()) {\n-        // Set the host post libInit function indicator\n-        params[mic_engines_total].type =\n-            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n-        params[mic_engines_total].nodeid =\n-            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE;\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n-            mic_engines_total,\n-            params[mic_engines_total].type, params[mic_engines_total].nodeid);\n-    \n-        // Set the host post libInit host function address\n-        ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n-            postLibInitHostFuncAddress =\n-                (void (*)())&__offload_propagate_shared_vars;\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %p }\\n\",\n-            mic_engines_total+1,\n-            ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n-                postLibInitHostFuncAddress);\n-    \n-        // Set the target post libInit function indicator\n-        params[mic_engines_total+2].type =\n-            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n-        params[mic_engines_total+2].nodeid =\n-            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES;\n-    \n-        // Set the target post libInit target function name\n-        ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+3]))->\n-            postLibInitRemoveFuncName = \"--vtable_initializer--\";\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %s }\\n\",\n-            mic_engines_total+3,\n-            ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n-                postLibInitRemoveFuncName);\n-    \n-        params[mic_engines_total+4].type = MYOI_USERPARAMS_LAST_MSG;\n-        params[mic_engines_total+4].nodeid = 0;\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n-            mic_engines_total+4,\n-            params[mic_engines_total+4].type,\n-            params[mic_engines_total+4].nodeid);\n-    } else {\n-        params[mic_engines_total].type = MYOI_USERPARAMS_LAST_MSG;\n-        params[mic_engines_total].nodeid = 0;\n-        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n-            mic_engines_total,\n-            params[mic_engines_total].type, params[mic_engines_total].nodeid);\n-    }\n-\n-    // initialize myo runtime on host\n-    myo_wrapper.LibInit(params, 0);\n-\n-    // wait for the target init calls to finish\n-    COIRESULT res;\n-    res = COI::EventWait(mic_engines_total, events, -1, 1, 0, 0);\n-    if (res != COI_SUCCESS) {\n-        LIBOFFLOAD_ERROR(c_event_wait, res);\n-        exit(1);\n-    }\n-\n-    myo_is_available = true;\n-    OFFLOAD_DEBUG_TRACE(2, \"setting myo_is_available=%d\\n\", myo_is_available);\n-\n-    OFFLOAD_DEBUG_TRACE(2, \"Initializing MYO library ... done\\n\");\n-}\n-\n-static bool __offload_myoInit(void)\n-{\n-    static OffloadOnceControl ctrl = OFFLOAD_ONCE_CONTROL_INIT;\n-    __offload_run_once(&ctrl, __offload_myoInit_once);\n-\n-    // Check if using V1 myoLibInit\n-    if (!myo_wrapper.PostInitFuncSupported()) {\n-        __offload_propagate_shared_vars();\n-    }\n-\n-    return myo_is_available;\n-}\n-\n-static void __offload_propagate_shared_vars()\n-{\n-    // Propagate pending shared var tables\n-    if (__myo_tables) {\n-        mutex_locker_t locker(__myo_table_lock);\n-\n-        if (__myo_tables) {\n-            //  Give tables with MYO so it can propagate to target\n-            for(MyoTableList::const_iterator it = __myo_table_list.begin();\n-                it != __myo_table_list.end(); ++it) {\n-#ifdef TARGET_WINNT\n-                for (SharedTableEntry *entry = it->var_tab;\n-                     entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n-                    if (entry->varName == 0) {\n-                        continue;\n-                    }\n-                    myo_wrapper.HostVarTablePropagate(entry, 1);\n-                    OFFLOAD_DEBUG_TRACE(2, \"HostVarTablePropagate(%s, 1)\\n\",\n-                        entry->varName);\n-                }\n-#else // TARGET_WINNT\n-                myo_wrapper.HostVarTablePropagate(it->var_tab,\n-                                                  it->var_tab_len);\n-#endif // TARGET_WINNT\n-            }\n-\n-            __myo_table_list.clear();\n-            __myo_tables = false;\n-        }\n-    }\n-}\n-\n-static bool shared_table_entries(\n-    SharedTableEntry *entry\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    for (; entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n-#ifdef TARGET_WINNT\n-        if (entry->varName == 0) {\n-            continue;\n-        }\n-#endif // TARGET_WINNT\n-\n-        return true;\n-    }\n-\n-    return false;\n-}\n-\n-static bool fptr_table_entries(\n-    FptrTableEntry *entry\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    for (; entry->funcName != MYO_TABLE_END_MARKER(); entry++) {\n-#ifdef TARGET_WINNT\n-        if (entry->funcName == 0) {\n-            continue;\n-        }\n-#endif // TARGET_WINNT\n-\n-        return true;\n-    }\n-\n-    return false;\n-}\n-\n-extern \"C\" void __offload_myoRegisterTables(\n-    InitTableEntry* init_table,\n-    SharedTableEntry *shared_table,\n-    FptrTableEntry *fptr_table\n-)\n-{\n-    // check whether we need to initialize MYO library. It is\n-    // initialized only if at least one myo table is not empty\n-    if (shared_table_entries(shared_table) || fptr_table_entries(fptr_table)) {\n-        // make sure myo library is loaded\n-        __offload_myoLoadLibrary();\n-\n-        // register tables\n-        __offload_myo_shared_table_process(shared_table);\n-        __offload_myo_fptr_table_process(fptr_table);\n-        __offload_myo_shared_init_table_process(init_table);\n-    }\n-}\n-\n-extern \"C\" bool __offload_myoProcessTables(\n-    const void* image,\n-    MYOInitTableList::Node *init_table,\n-    MYOVarTableList::Node  *shared_table,\n-    MYOVarTableList::Node  *shared_vtable,\n-    MYOFuncTableList::Node *fptr_table\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    // Collect the tables in this .dll/.so\n-    __offload_myoRegisterTables1(\n-        init_table, shared_table, shared_vtable, fptr_table);\n-\n-    // Now check what type of module we are dealing with\n-    if (__offload_target_image_is_executable(image)) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Main encountered\\n\");\n-        OFFLOAD_DEBUG_TRACE(2, \"MYO initialization not deferred\\n\");\n-        // MYO tables across dlls have been collected\n-        // Now init MYO and process the tables\n-        __offload_myoProcessDeferredTables();\n-        // Return true to indicate that atexit needs to be calld by ofldbegin\n-        return true;\n-    } else {\n-        // This is a shared library, either auto-loaded or dynamically loaded\n-        // If __target_exe is set, then main has started running\n-        if (__target_exe != 0) {\n-            // Main is running: this is a dynamic load of a shared library\n-            // Finish processing the tables in this library\n-            OFFLOAD_DEBUG_TRACE(2,\n-                \"Dynamically loaded shared library encountered\\n\");\n-            OFFLOAD_DEBUG_TRACE(2,\n-                \"MYO initialization not deferred\\n\");\n-            __offload_myoProcessDeferredTables();\n-        } else {\n-            // Main is not running: this is an auto-loaded shared library\n-            // Tables have been collected, nothing else to do\n-            OFFLOAD_DEBUG_TRACE(2,\n-                \"Auto-loaded shared library encountered\\n\");\n-            OFFLOAD_DEBUG_TRACE(2, \"Deferring initialization of MYO\\n\");\n-        }\n-        return false;\n-    }\n-}\n-\n-// Process contents of all Var tables\n-void MYOVarTableList::process()\n-{\n-    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Var tables:\\n\");\n-\n-    m_lock.lock();\n-\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        __offload_myo_shared_table_process(\n-            (SharedTableEntry*)n->table.entries);\n-    }\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        remove_table(n);\n-    }\n-\n-    m_lock.unlock();\n-}\n-\n-// Process contents of all Var tables\n-void MYOVarTableList::process_vtable()\n-{\n-    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Vtable tables:\\n\");\n-\n-    m_lock.lock();\n-\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        __offload_myo_shared_vtable_process(\n-            (SharedTableEntry*)n->table.entries);\n-    }\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        remove_table(n);\n-    }\n-\n-    m_lock.unlock();\n-}\n-\n-// Process contents of all Func tables\n-void MYOFuncTableList::process()\n-{\n-    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Func tables:\\n\");\n-\n-    m_lock.lock();\n-\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        __offload_myo_fptr_table_process(\n-            (FptrTableEntry*)n->table.entries);\n-    }\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        remove_table(n);\n-    }\n-\n-    m_lock.unlock();\n-}\n-\n-// Process contents of all Init tables\n-void MYOInitTableList::process()\n-{\n-    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Init tables:\\n\");\n-\n-    m_lock.lock();\n-\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        __offload_myo_shared_init_table_process(\n-            (InitTableEntry*)n->table.entries);\n-    }\n-    for (Node *n = m_head; n != 0; n = n->next) {\n-        remove_table(n);\n-    }\n-\n-    m_lock.unlock();\n-}\n-\n-static void __offload_myoProcessDeferredTables()\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s()\\n\", __func__);\n-\n-    // Debug dumps of MYO tables\n-    if (console_enabled >= 2) {\n-        __offload_myo_var_tables.dump();\n-        __offload_myo_vtable_tables.dump();\n-        __offload_myo_func_tables.dump();\n-        __offload_myo_init_tables.dump();\n-    }\n-\n-    if (!__offload_myo_var_tables.is_empty() ||\n-        !__offload_myo_vtable_tables.is_empty() ||\n-        !__offload_myo_func_tables.is_empty() ||\n-        !__offload_myo_init_tables.is_empty())\n-    {\n-        OFFLOAD_DEBUG_TRACE(3, \"MYO usage detected in program\\n\");\n-\n-        // Make sure myo library is loaded\n-        __offload_myoLoadLibrary();\n-        OFFLOAD_DEBUG_TRACE(3, \"Initialized MYO\\n\");\n-\n-        __offload_myo_var_tables.process();\n-        __offload_myo_vtable_tables.process_vtable();\n-        __offload_myo_func_tables.process();\n-        __offload_myo_init_tables.process();\n-        OFFLOAD_DEBUG_TRACE(3, \"Finished processing MYO tables\\n\");\n-    } else {\n-        OFFLOAD_DEBUG_TRACE(3,\n-            \"MYO tables are empty; Will not initialize MYO\\n\");\n-    }\n-}\n-\n-DLL_LOCAL void __offload_myoFini(void)\n-{\n-    if (myo_is_available) {\n-        OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-        COIEVENT events[MIC_ENGINES_MAX];\n-\n-        // kick off myoiLibFini calls on all devices\n-        for (int i = 0; i < mic_engines_total; i++) {\n-            mic_engines[i].fini_myo(&events[i]);\n-        }\n-\n-        // cleanup myo runtime on host\n-        myo_wrapper.LibFini();\n-\n-        // wait for the target fini calls to finish\n-        COIRESULT res;\n-        res = COI::EventWait(mic_engines_total, events, -1, 1, 0, 0);\n-        if (res != COI_SUCCESS) {\n-            LIBOFFLOAD_ERROR(c_event_wait, res);\n-            exit(1);\n-        }\n-    }\n-}\n-\n-static void __offload_myo_shared_table_process(\n-    SharedTableEntry *entry\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    SharedTableEntry *start = entry;\n-    int entries = 0;\n-\n-    // allocate shared memory for vars\n-    for (; entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n-#ifdef TARGET_WINNT\n-        if (entry->varName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4,\n-                \"skip registering a NULL MyoSharedTable entry\\n\");\n-            continue;\n-        }\n-#endif // TARGET_WINNT\n-\n-        OFFLOAD_DEBUG_TRACE(4, \"registering MyoSharedTable entry for %s @%p\\n\",\n-                            entry->varName, entry);\n-\n-        // Invoke the function to create shared memory\n-        reinterpret_cast<void(*)(void)>(entry->sharedAddr)();\n-        entries++;\n-    }\n-\n-    // and table to the list if it is not empty\n-    if (entries > 0) {\n-        mutex_locker_t locker(__myo_table_lock);\n-        __myo_table_list.push_back(MyoTable(start, entries));\n-        __myo_tables = true;\n-    }\n-}\n-\n-static void __offload_myo_shared_vtable_process(\n-    SharedTableEntry *entry\n-)\n-{\n-    SharedTableEntry *start = entry;\n-    int entries = 0;\n-\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    // allocate shared memory for vtables\n-    for (; entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n-#ifdef TARGET_WINNT\n-        if (entry->varName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4,\n-                \"skip registering a NULL MyoSharedVTable entry\\n\");\n-            continue;\n-        }\n-#endif // TARGET_WINNT\n-\n-        OFFLOAD_DEBUG_TRACE(4,\n-            \"registering MyoSharedVTable entry for %s @%p\\n\",\n-                            entry->varName, entry);\n-\n-        // Invoke the function to create shared memory\n-        reinterpret_cast<void(*)(MyoArena)>(entry->sharedAddr)(\n-                                                myo_wrapper.GetVtableArena());\n-        entries++;\n-    }\n-\n-    // add table to the list if it is not empty\n-    if (entries > 0) {\n-        mutex_locker_t locker(__myo_table_lock);\n-        __myo_table_list.push_back(MyoTable(start, entries));\n-        __myo_tables = true;\n-    }\n-}\n-\n-void __offload_myo_shared_init_table_process(InitTableEntry* entry)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-#ifdef TARGET_WINNT\n-    for (; entry->funcName != MYO_TABLE_END_MARKER(); entry++) {\n-        if (entry->funcName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4,\n-                \"skip registering a NULL MyoSharedInit entry\\n\");\n-            continue;\n-        }\n-\n-        //  Invoke the function to init the shared memory\n-        OFFLOAD_DEBUG_TRACE(4, \"execute MyoSharedInit routine for %s\\n\",\n-            entry->funcName);\n-        entry->func(myo_wrapper.GetVtableArena());\n-    }\n-#else // TARGET_WINNT\n-    for (; entry->func != 0; entry++) {\n-        // Invoke the function to init the shared memory\n-        entry->func(myo_wrapper.GetVtableArena());\n-    }\n-#endif // TARGET_WINNT\n-}\n-\n-static void __offload_myo_fptr_table_process(\n-    FptrTableEntry *entry\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    FptrTableEntry *start = entry;\n-    int entries = 0;\n-\n-    for (; entry->funcName != MYO_TABLE_END_MARKER(); entry++) {\n-#ifdef TARGET_WINNT\n-        if (entry->funcName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4,\n-                \"skip registering a NULL MyoFptrTable entry\\n\");\n-            continue;\n-        }\n-#endif // TARGET_WINNT\n-\n-        if (!myo_wrapper.is_available()) {\n-            *(static_cast<void**>(entry->localThunkAddr)) = entry->funcAddr;\n-        }\n-\n-        OFFLOAD_DEBUG_TRACE(4, \"registering MyoFptrTable entry for %s @%p\\n\",\n-                            entry->funcName, entry);\n-\n-#ifdef TARGET_WINNT\n-        if (myo_wrapper.is_available()) {\n-            myo_wrapper.HostFptrTableRegister(entry, 1, false);\n-        }\n-#endif // TARGET_WINNT\n-\n-        entries++;\n-    }\n-\n-#ifndef TARGET_WINNT\n-    if (myo_wrapper.is_available() && entries > 0) {\n-        myo_wrapper.HostFptrTableRegister(start, entries, false);\n-    }\n-#endif // TARGET_WINNT\n-}\n-\n-extern \"C\" int __offload_myoIsAvailable(int target_number)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%d)\\n\", __func__, target_number);\n-\n-    if (target_number >= -2) {\n-        bool is_default_number = (target_number == -2);\n-\n-        if (__offload_myoInit()) {\n-            if (target_number >= 0) {\n-                // User provided the device number\n-                int num = target_number % mic_engines_total;\n-\n-                // reserve device in ORSL\n-                target_number = ORSL::reserve(num) ? num : -1;\n-            }\n-            else {\n-                // try to use device 0\n-                target_number = ORSL::reserve(0) ? 0 : -1;\n-            }\n-\n-            // make sure device is initialized\n-            if (target_number >= 0) {\n-                mic_engines[target_number].init();\n-            }\n-        }\n-        else {\n-            // fallback to CPU\n-            target_number = -1;\n-        }\n-\n-        if (target_number < 0 && !is_default_number) {\n-            LIBOFFLOAD_ERROR(c_device_is_not_available);\n-            exit(1);\n-        }\n-    }\n-    else {\n-        LIBOFFLOAD_ERROR(c_invalid_device_number);\n-        exit(1);\n-    }\n-\n-    return target_number;\n-}\n-\n-extern \"C\" void __offload_myoiRemoteIThunkCall(\n-    void *thunk,\n-    void *arg,\n-    int target_number\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p, %p, %d)\\n\", __func__, thunk, arg,\n-                        target_number);\n-\n-    myo_wrapper.Release();\n-    myo_wrapper.RemoteThunkCall(thunk, arg, target_number);\n-    myo_wrapper.Acquire();\n-\n-    ORSL::release(target_number);\n-}\n-\n-extern \"C\" void* _Offload_shared_malloc(size_t size)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%lld)\\n\", __func__, size);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        return myo_wrapper.SharedMalloc(size);\n-    }\n-    else {\n-        return malloc(size);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_free(void *ptr)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ptr);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.SharedFree(ptr);\n-    }\n-    else {\n-        free(ptr);\n-    }\n-}\n-\n-extern \"C\" void* _Offload_shared_aligned_malloc(size_t size, size_t align)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%lld, %lld)\\n\", __func__, size, align);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        return myo_wrapper.SharedAlignedMalloc(size, align);\n-    }\n-    else {\n-        if (align < sizeof(void*)) {\n-            align = sizeof(void*);\n-        }\n-        return _mm_malloc(size, align);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_aligned_free(void *ptr)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ptr);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.SharedAlignedFree(ptr);\n-    }\n-    else {\n-        _mm_free(ptr);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_arena_create(\n-    MyoOwnershipType ownership,\n-    int consistency,\n-    MyoArena* arena\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%d, %d, %p)\\n\",\n-        __func__, ownership, consistency, arena);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.ArenaCreate(ownership, consistency, arena);\n-    }\n-}\n-\n-extern \"C\" void* _Offload_shared_aligned_arena_malloc(\n-    MyoArena arena,\n-    size_t size,\n-    size_t align\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %lld, %lld)\\n\",\n-        __func__, arena, size, align);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        void *p = myo_wrapper.SharedAlignedArenaMalloc(arena, size, align);\n-        OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %lld, %lld)->%p\\n\",\n-            __func__, arena, size, align, p);\n-        return p;\n-    }\n-    else {\n-        if (align < sizeof(void*)) {\n-            align = sizeof(void*);\n-        }\n-        return _mm_malloc(size, align);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_aligned_arena_free(\n-    MyoArena arena,\n-    void *ptr\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %p)\\n\", __func__, arena, ptr);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.SharedAlignedArenaFree(arena, ptr);\n-    }\n-    else {\n-        _mm_free(ptr);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_arena_acquire(\n-    MyoArena arena\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.ArenaAcquire(arena);\n-    }\n-}\n-\n-extern \"C\" void _Offload_shared_arena_release(\n-    MyoArena arena\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n-\n-    if (__offload_myoLoadLibrary()) {\n-        myo_wrapper.ArenaRelease(arena);\n-    }\n-}\n-\n-extern \"C\" void __intel_cilk_for_32_offload(\n-    int size,\n-    void (*copy_constructor)(void*, void*),\n-    int target_number,\n-    void *raddr,\n-    void *closure_object,\n-    unsigned int iters,\n-    unsigned int grain_size)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    target_number = __offload_myoIsAvailable(target_number);\n-    if (target_number >= 0) {\n-        struct S {\n-            void *M1;\n-            unsigned int M2;\n-            unsigned int M3;\n-            char closure[];\n-        } *args;\n-\n-        args = (struct S*) _Offload_shared_malloc(sizeof(struct S) + size);\n-        if (args == NULL)\n-          LIBOFFLOAD_ERROR(c_malloc);\n-        args->M1 = raddr;\n-        args->M2 = iters;\n-        args->M3 = grain_size;\n-\n-        if (copy_constructor == 0) {\n-            memcpy(args->closure, closure_object, size);\n-        }\n-        else {\n-            copy_constructor(args->closure, closure_object);\n-        }\n-\n-        myo_wrapper.Release();\n-        myo_wrapper.GetResult(\n-            myo_wrapper.RemoteCall(\"__intel_cilk_for_32_offload\",\n-                                   args, target_number)\n-        );\n-        myo_wrapper.Acquire();\n-\n-        _Offload_shared_free(args);\n-\n-        ORSL::release(target_number);\n-    }\n-    else {\n-        __cilkrts_cilk_for_32(raddr,\n-                              closure_object,\n-                              iters,\n-                              grain_size);\n-    }\n-}\n-\n-extern \"C\" void __intel_cilk_for_64_offload(\n-    int size,\n-    void (*copy_constructor)(void*, void*),\n-    int target_number,\n-    void *raddr,\n-    void *closure_object,\n-    uint64_t iters,\n-    uint64_t grain_size)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    target_number = __offload_myoIsAvailable(target_number);\n-    if (target_number >= 0) {\n-        struct S {\n-            void *M1;\n-            uint64_t M2;\n-            uint64_t M3;\n-            char closure[];\n-        } *args;\n-\n-        args = (struct S*) _Offload_shared_malloc(sizeof(struct S) + size);\n-        if (args == NULL)\n-          LIBOFFLOAD_ERROR(c_malloc);\n-        args->M1 = raddr;\n-        args->M2 = iters;\n-        args->M3 = grain_size;\n-\n-        if (copy_constructor == 0) {\n-            memcpy(args->closure, closure_object, size);\n-        }\n-        else {\n-            copy_constructor(args->closure, closure_object);\n-        }\n-\n-        myo_wrapper.Release();\n-        myo_wrapper.GetResult(\n-            myo_wrapper.RemoteCall(\"__intel_cilk_for_64_offload\", args,\n-                                   target_number)\n-        );\n-        myo_wrapper.Acquire();\n-\n-        _Offload_shared_free(args);\n-\n-        ORSL::release(target_number);\n-    }\n-    else {\n-        __cilkrts_cilk_for_64(raddr,\n-                              closure_object,\n-                              iters,\n-                              grain_size);\n-    }\n-}"}, {"sha": "5b9f160f1beef2ebb5c65f7730c4705d373dfaa4", "filename": "liboffloadmic/runtime/offload_myo_host.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,68 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#ifndef OFFLOAD_MYO_HOST_H_INCLUDED\n-#define OFFLOAD_MYO_HOST_H_INCLUDED\n-\n-#include <myotypes.h>\n-#include <myoimpl.h>\n-#include <myo.h>\n-\n-#include \"offload.h\"\n-// undefine the following since offload.h defines them to malloc and free if __INTEL_OFFLOAD \n-// is not defined which is the case when building the offload library\n-#undef _Offload_shared_malloc\n-#undef _Offload_shared_free\n-#undef _Offload_shared_aligned_malloc\n-#undef _Offload_shared_aligned_free\n-#include \"offload_table.h\"\n-\n-// This function retained for compatibility with 15.0\n-extern \"C\" void __offload_myoRegisterTables(\n-    InitTableEntry *init_table,\n-    SharedTableEntry *shared_table,\n-    FptrTableEntry *fptr_table\n-);\n-\n-// Process shared variable, shared vtable and function and init routine tables.\n-// In .dlls/.sos these will be collected together.\n-// In the main program, all collected tables will be processed.\n-extern \"C\" bool __offload_myoProcessTables(\n-    const void* image,\n-    MYOInitTableList::Node *init_table,\n-    MYOVarTableList::Node  *shared_table,\n-    MYOVarTableList::Node  *shared_vtable,\n-    MYOFuncTableList::Node *fptr_table\n-);\n-\n-extern void __offload_myoFini(void);\n-extern bool __offload_myo_init_is_deferred(const void *image);\n-\n-#endif // OFFLOAD_MYO_HOST_H_INCLUDED"}, {"sha": "5160ca951ac36524715585a18887e55e411ea90c", "filename": "liboffloadmic/runtime/offload_myo_target.cpp", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,309 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#include \"offload_myo_target.h\"\n-#include \"offload_target.h\"\n-\n-extern \"C\" void __cilkrts_cilk_for_32(void*, void*, uint32_t, int32_t);\n-extern \"C\" void __cilkrts_cilk_for_64(void*, void*, uint64_t, int32_t);\n-\n-#pragma weak __cilkrts_cilk_for_32\n-#pragma weak __cilkrts_cilk_for_64\n-\n-static void CheckResult(const char *func, MyoError error) {\n-    if (error != MYO_SUCCESS) {\n-       LIBOFFLOAD_ERROR(c_myotarget_checkresult, func, error);\n-        exit(1);\n-    }\n-}\n-\n-static void __offload_myo_shared_table_process(SharedTableEntry *entry)\n-{\n-    int entries = 0;\n-    SharedTableEntry *t_start;\n-\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    t_start = entry;\n-    while (t_start->varName != 0) {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_mic_myo_shared,\n-                              \"myo shared entry name = \\\"%s\\\" addr = %p\\n\",\n-                              t_start->varName, t_start->sharedAddr);\n-        t_start++;\n-        entries++;\n-    }\n-\n-    if (entries > 0) {\n-        OFFLOAD_DEBUG_TRACE(3, \"myoiMicVarTableRegister(%p, %d)\\n\", entry,\n-                            entries);\n-        CheckResult(\"myoiMicVarTableRegister\",\n-                    myoiMicVarTableRegister(entry, entries));\n-    }\n-}\n-\n-static void __offload_myo_shared_vtable_process(SharedTableEntry *entry)\n-{\n-    int entries = 0;\n-    SharedTableEntry *t_start;\n-\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    t_start = entry;\n-    while (t_start->varName != 0) {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_mic_myo_shared,\n-                              \"myo shared vtable entry name\"\n-                              \" = \\\"%s\\\" addr = %p\\n\",\n-                              t_start->varName, t_start->sharedAddr);\n-        t_start++;\n-        entries++;\n-    }\n-\n-    if (entries > 0) {\n-        OFFLOAD_DEBUG_TRACE(3, \"myoiMicVarTableRegister(%p, %d)\\n\", entry,\n-                            entries);\n-        CheckResult(\"myoiMicVarTableRegister\",\n-                    myoiMicVarTableRegister(entry, entries));\n-    }\n-}\n-\n-static void __offload_myo_fptr_table_process(\n-    FptrTableEntry *entry\n-)\n-{\n-    int entries = 0;\n-    FptrTableEntry *t_start;\n-\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    t_start = entry;\n-    while (t_start->funcName != 0) {\n-        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_mic_myo_fptr,\n-                              \"myo fptr entry name = \\\"%s\\\" addr = %p\\n\",\n-                              t_start->funcName, t_start->funcAddr);\n-        t_start++;\n-        entries++;\n-    }\n-\n-    if (entries > 0) {\n-        OFFLOAD_DEBUG_TRACE(3, \"myoiTargetFptrTableRegister(%p, %d, 0)\\n\",\n-                            entry, entries);\n-        CheckResult(\"myoiTargetFptrTableRegister\",\n-                    myoiTargetFptrTableRegister(entry, entries, 0));\n-    }\n-}\n-\n-void __offload_myo_shared_init_table_process(InitTableEntry* entry)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n-\n-    for (; entry->func != 0; entry++) {\n-        // Invoke the function to init the shared memory\n-        OFFLOAD_DEBUG_TRACE(3, \"Invoked a shared init function @%p\\n\",\n-            (void *)(entry->func));\n-        entry->func();\n-    }\n-}\n-\n-extern \"C\" void __offload_myoAcquire(void)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    CheckResult(\"myoAcquire\", myoAcquire());\n-}\n-\n-extern \"C\" void __offload_myoRelease(void)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-    CheckResult(\"myoRelease\", myoRelease());\n-}\n-\n-extern \"C\" void __intel_cilk_for_32_offload_wrapper(void *args_)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    struct S {\n-        void *M1;\n-        unsigned int M2;\n-        unsigned int M3;\n-        char closure[];\n-    } *args = (struct S*) args_;\n-\n-    __cilkrts_cilk_for_32(args->M1, args->closure, args->M2, args->M3);\n-}\n-\n-extern \"C\" void __intel_cilk_for_64_offload_wrapper(void *args_)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    struct S {\n-        void *M1;\n-        uint64_t M2;\n-        uint64_t M3;\n-        char closure[];\n-    } *args = (struct S*) args_;\n-\n-    __cilkrts_cilk_for_64(args->M1, args->closure, args->M2, args->M3);\n-}\n-\n-static void __offload_myo_once_init(void)\n-{\n-    CheckResult(\"myoiRemoteFuncRegister\",\n-                myoiRemoteFuncRegister(\n-                    (MyoiRemoteFuncType) __intel_cilk_for_32_offload_wrapper,\n-                    \"__intel_cilk_for_32_offload\"));\n-    CheckResult(\"myoiRemoteFuncRegister\",\n-                myoiRemoteFuncRegister(\n-                    (MyoiRemoteFuncType) __intel_cilk_for_64_offload_wrapper,\n-                    \"__intel_cilk_for_64_offload\"));\n-}\n-\n-extern \"C\" void __offload_myoRegisterTables(\n-    SharedTableEntry *shared_table,\n-    FptrTableEntry *fptr_table\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    // one time registration of Intel(R) Cilk(TM) language entries\n-    static pthread_once_t once_control = PTHREAD_ONCE_INIT;\n-    pthread_once(&once_control, __offload_myo_once_init);\n-\n-    // register module's tables\n-    if (shared_table->varName == 0 && fptr_table->funcName == 0) {\n-        return;\n-    }\n-\n-    __offload_myo_shared_table_process(shared_table);\n-    __offload_myo_fptr_table_process(fptr_table);\n-}\n-\n-extern \"C\" void __offload_myoProcessTables(\n-    InitTableEntry* init_table,\n-    SharedTableEntry *shared_table,\n-    SharedTableEntry *shared_vtable,\n-    FptrTableEntry *fptr_table\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n-\n-    // one time registration of Intel(R) Cilk(TM) language entries\n-    static pthread_once_t once_control = PTHREAD_ONCE_INIT;\n-    pthread_once(&once_control, __offload_myo_once_init);\n-\n-    // register module's tables\n-    // check slot-1 of the function table because \n-    // slot-0 is predefined with --vtable_initializer--\n-    if (shared_table->varName == 0 &&\n-        shared_vtable->varName == 0 &&\n-        fptr_table[1].funcName == 0) {\n-        return;\n-    }\n-\n-    __offload_myo_shared_table_process(shared_table);\n-    __offload_myo_shared_vtable_process(shared_vtable);\n-    __offload_myo_fptr_table_process(fptr_table);\n-}\n-\n-extern \"C\" void* _Offload_shared_malloc(size_t size)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%lld)\\n\", __func__, size);\n-    return myoSharedMalloc(size);\n-}\n-\n-extern \"C\" void _Offload_shared_free(void *ptr)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ptr);\n-    myoSharedFree(ptr);\n-}\n-\n-extern \"C\" void* _Offload_shared_aligned_malloc(size_t size, size_t align)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%lld, %lld)\\n\", __func__, size, align);\n-    return myoSharedAlignedMalloc(size, align);\n-}\n-\n-extern \"C\" void _Offload_shared_aligned_free(void *ptr)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ptr);\n-    myoSharedAlignedFree(ptr);\n-}\n-\n-extern \"C\" void* _Offload_shared_aligned_arena_malloc(\n-    MyoArena arena,\n-    size_t size,\n-    size_t align\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(\n-        3, \"%s(%u, %lld, %lld)\\n\", __func__, arena, size, align);\n-\n-    return myoArenaAlignedMalloc(arena, size, align);\n-}\n-\n-extern \"C\" void _Offload_shared_aligned_arena_free(\n-    MyoArena arena,\n-    void *ptr\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %p)\\n\", __func__, arena, ptr);\n-\n-    myoArenaAlignedFree(arena, ptr);\n-}\n-\n-extern \"C\" void _Offload_shared_arena_acquire(\n-    MyoArena arena\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n-\n-    myoArenaAcquire(arena);\n-}\n-\n-extern \"C\" void _Offload_shared_arena_release(\n-    MyoArena arena\n-)\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n-\n-    myoArenaRelease(arena);\n-}\n-\n-// temporary workaround for blocking behavior of myoiLibInit/Fini calls\n-extern \"C\" void __offload_myoLibInit()\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s()\\n\", __func__);\n-    CheckResult(\"myoiLibInit\", myoiLibInit(0, 0));\n-}\n-\n-extern \"C\" void __offload_myoLibFini()\n-{\n-    OFFLOAD_DEBUG_TRACE(3, \"%s()\\n\", __func__);\n-    myoiLibFini();\n-}"}, {"sha": "4383aae0b5e65331f74c9a6bf403d7b79d6ac340", "filename": "liboffloadmic/runtime/offload_myo_target.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.h?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1,70 +0,0 @@\n-/*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n-\n-    Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions\n-    are met:\n-\n-      * Redistributions of source code must retain the above copyright\n-        notice, this list of conditions and the following disclaimer.\n-      * Redistributions in binary form must reproduce the above copyright\n-        notice, this list of conditions and the following disclaimer in the\n-        documentation and/or other materials provided with the distribution.\n-      * Neither the name of Intel Corporation nor the names of its\n-        contributors may be used to endorse or promote products derived\n-        from this software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-*/\n-\n-\n-#ifndef OFFLOAD_MYO_TARGET_H_INCLUDED\n-#define OFFLOAD_MYO_TARGET_H_INCLUDED\n-\n-\n-#include \"offload.h\"\n-// undefine the following since offload.h defines them to malloc and free if __INTEL_OFFLOAD\n-// is not defined which is the case when building the offload library\n-#undef _Offload_shared_malloc\n-#undef _Offload_shared_free\n-#undef _Offload_shared_aligned_malloc\n-#undef _Offload_shared_aligned_free\n-#include \"offload_table.h\"\n-\n-// This function retained for compatibility with 15.0\n-extern \"C\" void __offload_myoRegisterTables(\n-    SharedTableEntry *shared_table,\n-    FptrTableEntry *fptr_table\n-);\n-\n-// Process shared variable, shared vtable and function and init routine tables.\n-// On the target side the contents of the tables are registered with MYO.\n-extern \"C\" void __offload_myoProcessTables(\n-    InitTableEntry* init_table,\n-    SharedTableEntry *shared_table,\n-    SharedTableEntry *shared_vtable,\n-    FptrTableEntry *fptr_table\n-);\n-\n-extern \"C\" void __offload_myoAcquire(void);\n-extern \"C\" void __offload_myoRelease(void);\n-\n-// Call the compiler-generated routines for initializing shared variables.\n-// This can only be done after shared memory allocation has been done.\n-extern void __offload_myo_shared_init_table_process(InitTableEntry* entry);\n-\n-// temporary workaround for blocking behavior for myoiLibInit/Fini calls\n-extern \"C\" void __offload_myoLibInit();\n-extern \"C\" void __offload_myoLibFini();\n-\n-#endif // OFFLOAD_MYO_TARGET_H_INCLUDED"}, {"sha": "0439fec313b6c09138a4677919dbb68bf58f484f", "filename": "liboffloadmic/runtime/offload_omp_host.cpp", "status": "modified", "additions": 784, "deletions": 2, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -29,9 +29,11 @@\n \n \n #include <omp.h>\n-#include \"offload.h\"\n+//#include <stdlib.h>\n+//#include \"offload.h\"\n #include \"compiler_if_host.h\"\n \n+\n // OpenMP API\n \n void omp_set_default_device(int num) __GOMP_NOTHROW\n@@ -52,6 +54,786 @@ int omp_get_num_devices() __GOMP_NOTHROW\n     return mic_engines_total;\n }\n \n+// OpenMP 4.5 APIs\n+\n+// COI supports 3-dim multiD transfers\n+#define MAX_ARRAY_RANK 3\n+\n+int omp_get_initial_device(\n+    void\n+) __GOMP_NOTHROW\n+{\n+    return -1;\n+}\n+\n+void* omp_target_alloc(\n+    size_t size, \n+    int    device_num\n+) __GOMP_NOTHROW\n+{\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_alloc(%lld, %d)\\n\", size, device_num);\n+\n+    if (device_num < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    void* result = 0;\n+\n+    // malloc on CPU\n+    if (device_num == -1) {\n+        // We do not check for malloc returning NULL because the \n+        // specification of this API includes the possibility of failure.\n+        // The user will check the returned result\n+        result = malloc(size);\n+        return result;\n+    }\n+\n+    OFFLOAD ofld = OFFLOAD_TARGET_ACQUIRE(\n+                       TARGET_MIC, device_num, 0, NULL, __func__, 0);\n+    if (ofld != 0) {\n+        VarDesc vars[2] = {0};\n+\n+        vars[0].type.src = c_data;\n+        vars[0].type.dst = c_data;\n+        vars[0].direction.bits = c_parameter_in;\n+        vars[0].size = sizeof(size);\n+        vars[0].count = 1;\n+        vars[0].ptr = &size;\n+\n+        vars[1].type.src = c_data;\n+        vars[1].type.dst = c_data;\n+        vars[1].direction.bits = c_parameter_out;\n+        vars[1].size = sizeof(result);\n+        vars[1].count = 1;\n+        vars[1].ptr = &result;\n+\n+        OFFLOAD_OFFLOAD(ofld, \"omp_target_alloc_target\",\n+                        0, 2, vars, NULL, 0, 0, 0);\n+    }\n+    return result;\n+}\n+\n+void omp_target_free(\n+    void *device_ptr, \n+    int   device_num\n+) __GOMP_NOTHROW\n+{\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_free(%p, %d)\\n\", device_ptr, device_num);\n+\n+    if (device_num < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    // free on CPU\n+    if (device_num == -1) {\n+        free(device_ptr);\n+        return;\n+    }\n+\n+    OFFLOAD ofld = OFFLOAD_TARGET_ACQUIRE(\n+                       TARGET_MIC, device_num, 0, NULL, __func__, 0);\n+    if (ofld) {\n+        VarDesc vars[1] = {0};\n+\n+        vars[0].type.src = c_data;\n+        vars[0].type.dst = c_data;\n+        vars[0].direction.bits = c_parameter_in;\n+        vars[0].size = sizeof(device_ptr);\n+        vars[0].count = 1;\n+        vars[0].ptr = &device_ptr;\n+        \n+        OFFLOAD_OFFLOAD(ofld, \"omp_target_free_target\",\n+                        0, 1, vars, NULL, 0, 0, 0);\n+    }\n+}\n+\n+int omp_target_is_present(\n+    void *ptr,\n+    int device_num\n+) __GOMP_NOTHROW\n+{\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_is_present(%p, %d)\\n\", ptr, device_num);\n+\n+    if (device_num < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    if (device_num == -1) {\n+        return false;\n+    }\n+\n+    // If OpenMP allows wrap-around for device numbers, enable next line\n+    //device_num %= mic_engines_total;\n+\n+    // lookup existing association in pointer table\n+    PtrData* ptr_data = mic_engines[device_num].find_ptr_data(ptr);\n+    if (ptr_data == 0) {\n+        OFFLOAD_TRACE(3, \"Address %p is not mapped on device %d\\n\",\n+                      ptr, device_num);\n+        return false;\n+    }\n+\n+    OFFLOAD_TRACE(3, \"Address %p found mapped on device %d\\n\",\n+                  ptr, device_num);\n+    return true;\n+}\n+\n+int omp_target_memcpy(\n+    void   *dst, \n+    void   *src, \n+    size_t  length, \n+    size_t  dst_offset, \n+    size_t  src_offset, \n+    int     dst_device,\n+    int     src_device\n+) __GOMP_NOTHROW\n+{\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_memcpy(%p, %p, %lld, %lld, %lld, %d, %d)\\n\",\n+                  dst, src, length, dst_offset, src_offset, dst_device, src_device);\n+\n+    if (dst_device < -1 || src_device < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    char* srcp = (char *)src + src_offset;\n+    char* dstp = (char *)dst + dst_offset;\n+\n+    if (src_device == -1) {\n+        // Source is CPU\n+        if (dst_device == -1) {\n+            // CPU -> CPU\n+            memcpy(dstp, srcp, length);\n+            return 0;\n+        } else {\n+            // CPU -> MIC\n+            // COIBufferWrite\n+            // If OpenMP allows wrap-around for device numbers, enable next line\n+            //dst_device %= mic_engines_total;\n+\n+            OFFLOAD_TRACE(3, \"Creating buffer from sink memory %llx\\n\", dstp);\n+            COIBUFFER mic_buf;\n+            COIRESULT res = COI::BufferCreateFromMemory(length,\n+                                COI_BUFFER_NORMAL, COI_SINK_MEMORY, dstp,\n+                                1, &mic_engines[dst_device].get_process(),\n+                                &mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_create_from_mem, res);\n+                return 1;\n+            }\n+            res = COI::BufferWrite(mic_buf, 0, srcp, length,\n+                      COI_COPY_UNSPECIFIED, 0, 0, 0);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_write, res);\n+                return 1;\n+            }\n+            res = COI::BufferDestroy(mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_destroy, res);\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    } else {\n+        // Source is device\n+        if (dst_device == -1) {\n+            // MIC -> CPU\n+            // COIBufferRead\n+\n+            // If OpenMP allows wrap-around for device numbers, enable next line\n+            //src_device %= mic_engines_total;\n+\n+            OFFLOAD_TRACE(3, \"Creating buffer from sink memory %llx\\n\", srcp);\n+            COIBUFFER mic_buf;\n+            COIRESULT res = COI::BufferCreateFromMemory(length,\n+                                COI_BUFFER_NORMAL, COI_SINK_MEMORY, srcp,\n+                                1, &mic_engines[src_device].get_process(),\n+                                &mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_create_from_mem, res);\n+                return 1;\n+            }\n+            res = COI::BufferRead(mic_buf, 0, dstp, length,\n+                      COI_COPY_UNSPECIFIED, 0, 0, 0);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_read, res);\n+                return 1;\n+            }\n+            res = COI::BufferDestroy(mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_destroy, res);\n+                return 1;\n+            }\n+            return 0;\n+        } else {\n+            // some MIC -> some MIC\n+            if (src_device == dst_device) {\n+                // MIC local copy will be done as remote memcpy\n+\n+                OFFLOAD ofld = OFFLOAD_TARGET_ACQUIRE(TARGET_MIC, src_device,\n+                                                      0, NULL, __func__, 0);\n+                if (ofld) {\n+                    VarDesc vars[3] = {0};\n+\n+                    vars[0].type.src = c_data;\n+                    vars[0].type.dst = c_data;\n+                    vars[0].direction.bits = c_parameter_in;\n+                    vars[0].size = sizeof(dstp);\n+                    vars[0].count = 1;\n+                    vars[0].ptr = &dstp;\n+\n+                    vars[1].type.src = c_data;\n+                    vars[1].type.dst = c_data;\n+                    vars[1].direction.bits = c_parameter_in;\n+                    vars[1].size = sizeof(srcp);\n+                    vars[1].count = 1;\n+                    vars[1].ptr = &srcp;\n+\n+                    vars[2].type.src = c_data;\n+                    vars[2].type.dst = c_data;\n+                    vars[2].direction.bits = c_parameter_in;\n+                    vars[2].size = sizeof(length);\n+                    vars[2].count = 1;\n+                    vars[2].ptr = &length;\n+        \n+                    OFFLOAD_OFFLOAD(ofld, \"omp_target_memcpy_target\",\n+                                    0, 3, vars, NULL, 0, 0, 0);\n+                    return 0;\n+                } else {\n+                    return 1;\n+                }\n+            } else {\n+                // MICx -> MICy\n+                // Allocate CPU buffer\n+                char *cpu_mem = (char *)malloc(length);\n+                if (cpu_mem == 0) {\n+                    LIBOFFLOAD_ERROR(c_malloc);\n+                    return 1;\n+                }\n+                int retval = 1;\n+                if (omp_target_memcpy(\n+                        cpu_mem, srcp, length, 0, 0, -1, src_device) == 0) {\n+                    retval = omp_target_memcpy(\n+                                 dstp, cpu_mem, length, 0, 0, dst_device, -1);\n+                }\n+                free(cpu_mem);\n+                return retval;\n+            }\n+        }\n+    }\n+}\n+\n+static size_t bytesize_at_this_dimension(\n+    size_t element_size,\n+    int num_dims,\n+    const size_t* dimensions\n+)\n+{\n+    if (num_dims > 1) {\n+        return dimensions[1] * \n+               bytesize_at_this_dimension(\n+                   element_size, num_dims-1, dimensions+1);\n+    } else {\n+        return element_size;\n+    }\n+}\n+\n+static void memcpy_rect(\n+    char         *dst,\n+    char         *src,\n+    size_t        element_size,\n+    int           num_dims,\n+    const size_t *volume,\n+    const size_t *dst_offsets,\n+    const size_t *src_offsets,\n+    const size_t *dst_dimensions,\n+    const size_t *src_dimensions\n+)\n+{\n+    if (num_dims > 1) {\n+        int count = volume[0];\n+        int dst_index = dst_offsets[0];\n+        int src_index = src_offsets[0];\n+        size_t dst_element_size =\n+            bytesize_at_this_dimension(element_size, num_dims, dst_dimensions);\n+        size_t src_element_size =\n+            bytesize_at_this_dimension(element_size, num_dims, src_dimensions);\n+        for (; count>0; dst_index++, src_index++, count--) {\n+            memcpy_rect(dst+dst_element_size*dst_index,\n+                        src+src_element_size*src_index,\n+                        element_size, num_dims-1, volume+1,\n+                        dst_offsets+1, src_offsets+1,\n+                        dst_dimensions+1, src_dimensions+1);\n+        }\n+    } else {\n+        memcpy(dst+dst_offsets[0]*element_size,\n+               src+src_offsets[0]*element_size,\n+               element_size * volume[0]);\n+    }\n+}\n+\n+int omp_target_memcpy_rect(\n+    void         *dst_,\n+    void         *src_,\n+    size_t        element_size,\n+    int           num_dims,\n+    const size_t *volume,\n+    const size_t *dst_offsets,\n+    const size_t *src_offsets,\n+    const size_t *dst_dimensions,\n+    const size_t *src_dimensions,\n+    int           dst_device,\n+    int           src_device\n+) __GOMP_NOTHROW\n+{\n+    char *dst = (char *)dst_;\n+    char *src = (char *)src_;\n+\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_memcpy_rect(%p, %p, %lld, %d, \"\n+                  \"%p, %p, %p, %p, %p, %d, %d)\\n\",\n+                  dst, src, element_size, num_dims,\n+                  volume, dst_offsets, src_offsets,\n+                  dst_dimensions, src_dimensions, dst_device, src_device);\n+    \n+    // MAX_ARRAY_RANK dimensions are supported\n+    if (dst == 0 && src == 0) {\n+        return MAX_ARRAY_RANK;\n+    }\n+\n+    if (num_dims < 1 || num_dims > MAX_ARRAY_RANK ||\n+        element_size < 1 ||\n+        volume == 0 || dst_offsets == 0 || src_offsets == 0 ||\n+        dst_dimensions == 0 || src_dimensions == 0) {\n+        return 1;\n+    }\n+\n+    if (dst_device < -1 || src_device < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    if (src_device == -1) {\n+        // Source is CPU\n+        if (dst_device == -1) {\n+            // CPU -> CPU\n+            memcpy_rect((char*)dst, (char*)src, element_size, num_dims, volume,\n+                        dst_offsets, src_offsets,\n+                        dst_dimensions, src_dimensions);\n+            return 0;\n+        } else {\n+            // CPU -> MIC\n+            // COIBufferWriteMultiD\n+            struct arr_desc dst_desc;\n+            struct arr_desc src_desc;\n+\n+            dst_desc.base = (int64_t)dst;\n+            dst_desc.rank = num_dims;\n+            \n+            src_desc.base = (int64_t)src;\n+            src_desc.rank = num_dims;\n+\n+            for (int i=0; i<num_dims; i++)\n+            {\n+                dst_desc.dim[i].size   = bytesize_at_this_dimension(\n+                                             element_size,\n+                                             num_dims - i,\n+                                             dst_dimensions + i);\n+                dst_desc.dim[i].lindex = 0;\n+                dst_desc.dim[i].lower  = dst_offsets[i];\n+                dst_desc.dim[i].upper  = dst_offsets[i] + volume[i] - 1;\n+                dst_desc.dim[i].stride = 1;\n+                \n+                src_desc.dim[i].size   = bytesize_at_this_dimension(\n+                                             element_size,\n+                                             num_dims - i,\n+                                             src_dimensions + i);\n+                src_desc.dim[i].lindex = 0;\n+                src_desc.dim[i].lower  = src_offsets[i];\n+                src_desc.dim[i].upper  = src_offsets[i] + volume[i] - 1;\n+                src_desc.dim[i].stride = 1;\n+            }\n+            __arr_desc_dump(\"\", \"dst\", (const Arr_Desc*)&dst_desc, false, false);\n+            __arr_desc_dump(\"\", \"src\", (const Arr_Desc*)&src_desc, false, false);\n+            \n+            // If OpenMP allows wrap-around for device numbers, enable next line\n+            //dst_device %= mic_engines_total;\n+                \n+            // Compute MIC buffer size\n+            size_t dst_length = dst_dimensions[0] * bytesize_at_this_dimension(\n+                                                        element_size,\n+                                                        num_dims,\n+                                                        dst_dimensions);\n+\n+            OFFLOAD_TRACE(3,\n+                \"Creating buffer from sink memory %llx of size %lld\\n\",\n+                dst, dst_length);\n+            COIBUFFER mic_buf;\n+            COIRESULT res = COI::BufferCreateFromMemory(dst_length,\n+                                COI_BUFFER_NORMAL, COI_SINK_MEMORY, dst,\n+                                1, &mic_engines[dst_device].get_process(),\n+                                &mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_create_from_mem, res);\n+                return 1;\n+            }\n+            res = COI::BufferWriteMultiD(mic_buf,\n+                      mic_engines[dst_device].get_process(),\n+                      0, &dst_desc, &src_desc,\n+                      COI_COPY_UNSPECIFIED, 0, 0, 0);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_write, res);\n+                return 1;\n+            }\n+            res = COI::BufferDestroy(mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_destroy, res);\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    } else {\n+        // Source is device\n+        if (dst_device == -1) {\n+            // COIBufferReadMultiD\n+            struct arr_desc dst_desc;\n+            struct arr_desc src_desc;\n+\n+            dst_desc.base = (int64_t)dst;\n+            dst_desc.rank = num_dims;\n+            \n+            src_desc.base = (int64_t)src;\n+            src_desc.rank = num_dims;\n+\n+            for (int i=0; i<num_dims; i++)\n+            {\n+                dst_desc.dim[i].size   = bytesize_at_this_dimension(\n+                                             element_size,\n+                                             num_dims - i,\n+                                             dst_dimensions + i);\n+                dst_desc.dim[i].lindex = 0;\n+                dst_desc.dim[i].lower  = dst_offsets[i];\n+                dst_desc.dim[i].upper  = dst_offsets[i] + volume[i] - 1;\n+                dst_desc.dim[i].stride = 1;\n+                \n+                src_desc.dim[i].size   = bytesize_at_this_dimension(\n+                                             element_size,\n+                                             num_dims - i,\n+                                             src_dimensions + i);\n+                src_desc.dim[i].lindex = 0;\n+                src_desc.dim[i].lower  = src_offsets[i];\n+                src_desc.dim[i].upper  = src_offsets[i] + volume[i] - 1;\n+                src_desc.dim[i].stride = 1;\n+            }\n+            __arr_desc_dump(\"\", \"dst\", (const Arr_Desc*)&dst_desc, false, false);\n+            __arr_desc_dump(\"\", \"src\", (const Arr_Desc*)&src_desc, false, false);\n+            \n+            // If OpenMP allows wrap-around for device numbers, enable next line\n+            //src_device %= mic_engines_total;\n+                \n+            // Compute MIC buffer size\n+            size_t src_length = src_dimensions[0] * bytesize_at_this_dimension(\n+                                                        element_size,\n+                                                        num_dims,\n+                                                        src_dimensions);\n+\n+            OFFLOAD_TRACE(3,\n+                \"Creating buffer from sink memory %llx of size %lld\\n\",\n+                src, src_length);\n+            COIBUFFER mic_buf;\n+            COIRESULT res = COI::BufferCreateFromMemory(src_length,\n+                                COI_BUFFER_NORMAL, COI_SINK_MEMORY, src,\n+                                1, &mic_engines[src_device].get_process(),\n+                                &mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_create_from_mem, res);\n+                return 1;\n+            }\n+            res = COI::BufferReadMultiD(mic_buf, 0,\n+                      &dst_desc, &src_desc,\n+                      COI_COPY_UNSPECIFIED, 0, 0, 0);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_write, res);\n+                return 1;\n+            }\n+            res = COI::BufferDestroy(mic_buf);\n+            if (res != COI_SUCCESS) {\n+                LIBOFFLOAD_ERROR(c_buf_destroy, res);\n+                return 1;\n+            }\n+            return 0;\n+        } else {\n+            // some MIC -> some MIC\n+            if (src_device == dst_device) {\n+                // MIC local copy will be done as remote memcpy_rect\n+                struct parameters {\n+                    void   *dst;\n+                    void   *src;\n+                    size_t element_size;\n+                    int    num_dims;\n+                    size_t array_info[MAX_ARRAY_RANK*5];\n+                } parameters = {dst, src, element_size, num_dims};\n+                int result;\n+                \n+                for (int i=0; i<num_dims; i++)\n+                {\n+                    parameters.array_info[i]            = volume[i];\n+                    parameters.array_info[i+num_dims]   = dst_offsets[i];\n+                    parameters.array_info[i+num_dims*2] = src_offsets[i];\n+                    parameters.array_info[i+num_dims*3] = dst_dimensions[i];\n+                    parameters.array_info[i+num_dims*4] = src_dimensions[i];\n+                }\n+\n+                OFFLOAD ofld = OFFLOAD_TARGET_ACQUIRE(TARGET_MIC, src_device,\n+                                                      0, NULL, __func__, 0);\n+                if (ofld) {\n+                    VarDesc vars[1] = {0};\n+\n+                    vars[0].type.src = c_data;\n+                    vars[0].type.dst = c_data;\n+                    vars[0].direction.bits = c_parameter_in;\n+                    vars[0].size = sizeof(parameters) -\n+                                       (MAX_ARRAY_RANK - num_dims) *\n+                                       5 * sizeof(size_t);\n+                    vars[0].count = 1;\n+                    vars[0].ptr = &parameters;\n+        \n+                    OFFLOAD_OFFLOAD(ofld, \"omp_target_memcpy_rect_target\",\n+                                    0, 1, vars, NULL, 0, 0, 0);\n+                    return 0;\n+                } else {\n+                    return 1;\n+                }\n+            } else {\n+                // MICx -> MICy\n+\n+                // Compute transfer byte-count\n+                size_t dst_length = element_size;\n+                for (int i=0; i<num_dims; i++) {\n+                    dst_length *= volume[i];\n+                }\n+\n+                // Allocate CPU buffer\n+                char *cpu_mem = (char *)malloc(dst_length);\n+                if (cpu_mem == 0) {\n+                    LIBOFFLOAD_ERROR(c_malloc);\n+                    return 1;\n+                }\n+\n+                // Create CPU offset and dimension arrays\n+                // The CPU array collects the data in a contiguous block\n+                size_t cpu_offsets[MAX_ARRAY_RANK];\n+                size_t cpu_dimensions[MAX_ARRAY_RANK];\n+                for (int i=0; i<num_dims; i++) {\n+                    cpu_offsets[i] = 0;\n+                    cpu_dimensions[i] = volume[i];\n+                }\n+\n+                int retval = 1;\n+                if (omp_target_memcpy_rect(\n+                        cpu_mem, src, element_size, num_dims, volume,\n+                        cpu_offsets, src_offsets,\n+                        cpu_dimensions, src_dimensions,\n+                        -1, src_device) == 0) {\n+                    retval = omp_target_memcpy_rect(\n+                                 dst, cpu_mem, element_size, num_dims, volume,\n+                                 dst_offsets, cpu_offsets,\n+                                 dst_dimensions, cpu_dimensions,\n+                                 dst_device, -1);\n+                }\n+                free(cpu_mem);\n+                return retval;\n+            }\n+        }\n+    }\n+}\n+\n+// host_ptr is key in table that yields association on device\n+// A COIBUFFER of specified size is created from the memory at \n+//     device_ptr+device_offset on device_num\n+int omp_target_associate_ptr(\n+    void   *host_ptr, \n+    void   *device_ptr,\n+    size_t  size,\n+    size_t  device_offset,\n+    int     device_num\n+) __GOMP_NOTHROW\n+{\n+    COIRESULT res;\n+\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_associate_ptr(%p, %p, %lld, %lld, %d)\\n\",\n+                  host_ptr, device_ptr, size, device_offset, device_num);\n+\n+    if (device_num < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    // Associating to CPU is treated as failure\n+    if (device_num == -1) {\n+        return 1;\n+    }\n+\n+    // An incorrect size is treated as failure\n+    if (size < 0) {\n+        return 1;\n+    }\n+    \n+    // If OpenMP allows wrap-around for device numbers, enable next line\n+    //Engine& device = mic_engines[device_num % mic_engines_total];\n+    Engine& device = mic_engines[device_num];\n+    \n+    // Does host pointer have association already?\n+    // lookup existing association in pointer table\n+    PtrData* ptr_data = device.find_ptr_data(host_ptr);\n+    if (ptr_data != 0) {\n+        OFFLOAD_TRACE(3, \"Address %p is already mapped on device %d\\n\",\n+                      host_ptr, device_num);\n+        // Is current device pointer and offset same as existing?\n+        if ((void*)ptr_data->mic_addr == device_ptr &&\n+            (size_t)ptr_data->alloc_disp == device_offset) {\n+            return 0;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    // Create association\n+    OFFLOAD_TRACE(3, \"Creating association for data: addr %p, length %lld\\n\",\n+                  host_ptr, size);\n+\n+    bool is_new;\n+    ptr_data = device.insert_ptr_data(host_ptr, size, is_new);\n+    ptr_data->is_omp_associate = true;\n+\n+    // create CPU buffer\n+    OFFLOAD_TRACE(3,\n+              \"Creating buffer from source memory %p, length %lld\\n\",\n+              host_ptr, size);\n+\n+    // result is not checked because we can continue without cpu\n+    // buffer. In this case we will use COIBufferRead/Write\n+    // instead of COIBufferCopy.\n+\n+    COI::BufferCreateFromMemory(size,\n+                            COI_BUFFER_OPENCL,\n+                            0,\n+                            host_ptr,\n+                            1,\n+                            &device.get_process(),\n+                            &ptr_data->cpu_buf);\n+\n+    // create MIC buffer\n+    OFFLOAD_TRACE(3,\n+              \"Creating buffer from sink memory: addr %p, size %lld\\n\",\n+              (char *)device_ptr + device_offset, size);\n+    res = COI::BufferCreateFromMemory(size,\n+                                      COI_BUFFER_NORMAL,\n+                                      COI_SINK_MEMORY,\n+                                      device_ptr,\n+                                      1,\n+                                      &device.get_process(),\n+                                      &ptr_data->mic_buf);\n+    if (res != COI_SUCCESS) {\n+        ptr_data->alloc_ptr_data_lock.unlock();\n+        return 1;\n+    }\n+\n+    // make buffer valid on the device.\n+    res = COI::BufferSetState(ptr_data->mic_buf,\n+        device.get_process(),\n+        COI_BUFFER_VALID,\n+        COI_BUFFER_NO_MOVE,\n+        0, 0, 0);\n+    if (res != COI_SUCCESS) {\n+        ptr_data->alloc_ptr_data_lock.unlock();\n+        return 1;\n+    }\n+\n+    res = COI::BufferSetState(ptr_data->mic_buf,\n+        COI_PROCESS_SOURCE,\n+        COI_BUFFER_INVALID,\n+        COI_BUFFER_NO_MOVE,\n+        0, 0, 0);\n+    if (res != COI_SUCCESS) {\n+        ptr_data->alloc_ptr_data_lock.unlock();\n+        return 1;\n+    }\n+    ptr_data->alloc_disp = device_offset;\n+    ptr_data->alloc_ptr_data_lock.unlock();\n+\n+    return 0;\n+}\n+\n+int omp_target_disassociate_ptr(\n+    void   *host_ptr,\n+    int     device_num\n+) __GOMP_NOTHROW\n+{\n+    COIRESULT res;\n+\n+    __offload_init_library();\n+\n+    OFFLOAD_TRACE(2, \"omp_target_disassociate_ptr(%p, %d)\\n\",\n+                  host_ptr, device_num);\n+\n+    if (device_num < -1) {\n+        LIBOFFLOAD_ERROR(c_invalid_device_number);\n+        exit(1);\n+    }\n+\n+    // Dissociating from CPU is treated as failure\n+    if (device_num == -1) {\n+        return 1;\n+    }\n+    \n+    // If OpenMP allows wrap-around for device numbers, enable next line\n+    //Engine& device = mic_engines[device_num % mic_engines_total];\n+    Engine& device = mic_engines[device_num];\n+\n+    // Lookup existing association in pointer table\n+    PtrData* ptr_data = device.find_ptr_data(host_ptr);\n+\n+    // Attempt to disassociate unassociated pointer is a failure\n+    if (ptr_data == 0) {\n+        return 1;\n+    }\n+                    \n+    // Destroy buffers\n+    if (ptr_data->cpu_buf != 0) {\n+        OFFLOAD_TRACE(3, \"Destroying CPU buffer %p\\n\", ptr_data->cpu_buf);\n+        COI::BufferDestroy(ptr_data->cpu_buf);\n+    }\n+    if (ptr_data->mic_buf != 0) {\n+        OFFLOAD_TRACE(3, \"Destroying MIC buffer %p\\n\", ptr_data->mic_buf);\n+        COI::BufferDestroy(ptr_data->mic_buf);\n+    }\n+    \n+    // Remove association from map\n+    OFFLOAD_TRACE(3, \"Removing association for addr %p\\n\",\n+                  ptr_data->cpu_addr.start());\n+    device.remove_ptr_data(ptr_data->cpu_addr.start());\n+\n+    return 0;\n+}\n+\n+// End of OpenMP 4.5 APIs\n+\n+\n // OpenMP API wrappers\n \n static void omp_set_int_target("}, {"sha": "2bcfef5acea629792471d71c236175024a6880f8", "filename": "liboffloadmic/runtime/offload_omp_target.cpp", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -48,6 +48,182 @@ int omp_get_num_devices() __GOMP_NOTHROW\n     return mic_engines_total;\n }\n \n+// OpenMP 4.5 APIs\n+\n+// COI supports 3-dim multiD transfers\n+#define MAX_ARRAY_RANK 3\n+\n+DLL_LOCAL void omp_target_alloc_target(\n+    void *ofld_\n+)\n+{\n+    OFFLOAD ofld = (OFFLOAD) ofld_;\n+    VarDesc vars[2] = {0};\n+    size_t size;\n+    void* memory;\n+\n+    vars[0].type.src = c_data;\n+    vars[0].type.dst = c_data;\n+    vars[0].direction.bits = c_parameter_in;\n+    vars[0].ptr = &size;\n+\n+    vars[1].type.src = c_data;\n+    vars[1].type.dst = c_data;\n+    vars[1].direction.bits = c_parameter_out;\n+    vars[1].ptr = &memory;\n+\n+    OFFLOAD_TARGET_ENTER(ofld, 2, vars, NULL);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_alloc(%lld)\\n\", size);\n+    // We do not check for malloc returning NULL because the \n+    // specification of this API includes the possibility of failure.\n+    // The user will check the returned result\n+    memory = malloc(size);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_alloc allocated at %p\\n\", memory);\n+    OFFLOAD_TARGET_LEAVE(ofld);\n+}\n+\n+DLL_LOCAL void omp_target_free_target(\n+    void *ofld_\n+)\n+{\n+    OFFLOAD ofld = (OFFLOAD) ofld_;\n+    VarDesc vars[1] = {0};\n+    void* memory;\n+\n+    vars[0].type.src = c_data;\n+    vars[0].type.dst = c_data;\n+    vars[0].direction.bits = c_parameter_in;\n+    vars[0].ptr = &memory;\n+\n+    OFFLOAD_TARGET_ENTER(ofld, 1, vars, NULL);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_free(%p)\\n\", memory);\n+    free(memory);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_free freed\\n\");\n+    OFFLOAD_TARGET_LEAVE(ofld);\n+}\n+\n+DLL_LOCAL void omp_target_memcpy_target(\n+    void *ofld_\n+)\n+{\n+    OFFLOAD ofld = (OFFLOAD) ofld_;\n+    VarDesc vars[3] = {0};\n+    void* dst;\n+    void* src;\n+    size_t length;\n+\n+    vars[0].type.src = c_data;\n+    vars[0].type.dst = c_data;\n+    vars[0].direction.bits = c_parameter_in;\n+    vars[0].ptr = &dst;\n+    \n+    vars[1].type.src = c_data;\n+    vars[1].type.dst = c_data;\n+    vars[1].direction.bits = c_parameter_in;\n+    vars[1].ptr = &src;\n+    \n+    vars[2].type.src = c_data;\n+    vars[2].type.dst = c_data;\n+    vars[2].direction.bits = c_parameter_in;\n+    vars[2].ptr = &length;\n+\n+    OFFLOAD_TARGET_ENTER(ofld, 3, vars, NULL);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_memcpy(%p, %p, %lld)\\n\",\n+                        dst, src, length);\n+    memcpy(dst, src, length);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_memcpy done\\n\");\n+    OFFLOAD_TARGET_LEAVE(ofld);\n+}\n+\n+static size_t bytesize_at_this_dimension(\n+    size_t element_size,\n+    int num_dims,\n+    const size_t* dimensions\n+)\n+{\n+    if (num_dims > 1) {\n+        return dimensions[1] * \n+               bytesize_at_this_dimension(\n+                   element_size, num_dims-1, dimensions+1);\n+    } else {\n+        return element_size;\n+    }\n+}\n+\n+static void memcpy_rect(\n+    char         *dst,\n+    char         *src,\n+    size_t        element_size,\n+    int           num_dims,\n+    const size_t *volume,\n+    const size_t *dst_offsets,\n+    const size_t *src_offsets,\n+    const size_t *dst_dimensions,\n+    const size_t *src_dimensions\n+)\n+{\n+    if (num_dims > 1) {\n+        int count = volume[0];\n+        int dst_index = dst_offsets[0];\n+        int src_index = src_offsets[0];\n+        size_t dst_element_size =\n+            bytesize_at_this_dimension(element_size, num_dims, dst_dimensions);\n+        size_t src_element_size =\n+            bytesize_at_this_dimension(element_size, num_dims, src_dimensions);\n+        for (; count>0; dst_index++, src_index++, count--) {\n+            memcpy_rect(dst+dst_element_size*dst_index,\n+                        src+src_element_size*src_index,\n+                        element_size, num_dims-1, volume+1,\n+                        dst_offsets+1, src_offsets+1,\n+                        dst_dimensions+1, src_dimensions+1);\n+        }\n+    } else {\n+        memcpy(dst+dst_offsets[0]*element_size,\n+               src+src_offsets[0]*element_size,\n+               element_size * volume[0]);\n+    }\n+}\n+\n+DLL_LOCAL void omp_target_memcpy_rect_target(\n+    void *ofld_\n+)\n+{\n+    OFFLOAD ofld = (OFFLOAD) ofld_;\n+    VarDesc vars[1] = {0};\n+    struct parameters {\n+        void   *dst;\n+        void   *src;\n+        size_t  element_size;\n+        int     num_dims;\n+        size_t array_info[MAX_ARRAY_RANK*5];\n+    } parameters;\n+\n+    vars[0].type.src = c_data;\n+    vars[0].type.dst = c_data;\n+    vars[0].direction.bits = c_parameter_in;\n+    vars[0].ptr = &parameters;\n+\n+    OFFLOAD_TARGET_ENTER(ofld, 1, vars, NULL);\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_memcpy_rect(%p, %p, %lld, %d)\\n\",\n+                        parameters.dst, parameters.src,\n+                        parameters.element_size, parameters.num_dims);\n+    memcpy_rect(\n+          (char*)parameters.dst, (char*)parameters.src, parameters.element_size,\n+          parameters.num_dims,\n+          &parameters.array_info[0],\n+          &parameters.array_info[parameters.num_dims],\n+          &parameters.array_info[parameters.num_dims*2],\n+          &parameters.array_info[parameters.num_dims*3],\n+          &parameters.array_info[parameters.num_dims*4]);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"omp_target_memcpy_rect done\\n\");\n+    OFFLOAD_TARGET_LEAVE(ofld);\n+}\n+\n+// End of OpenMP 4.5 APIs\n+\n+\n // OpenMP API wrappers\n \n static void omp_send_int_to_host("}, {"sha": "a2ab6743ab5a4baf1793e3e9a03228c50a4d0219", "filename": "liboffloadmic/runtime/offload_orsl.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "4513fcc47494a7392b8121d344f70a9475ac8da3", "filename": "liboffloadmic/runtime/offload_orsl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_orsl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_orsl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "09c4d206e58df51670a493582a798d93c8800495", "filename": "liboffloadmic/runtime/offload_table.cpp", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_table.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_table.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -31,6 +31,16 @@\n #include \"offload_table.h\"\n #include \"offload_common.h\"\n \n+// Offload Library versioning\n+// We initialize version to OFFLOAD_VERSION_16\n+// 15.0 application downgrades this to 1500 for MYO to use the older version.\n+// 15.0 pragma works without needing version-specific code.\n+// 16.0-U2 added a call from ofldbegin.cpp to set the version explicitly.\n+// Pre-16.0-U2 application will find pre-initialized version number as 1600.\n+// Post 16.0-U2 application will set its own version explicitly.\n+int offload_version = OFFLOAD_VERSION_16;\n+int offload_version_count = 0;\n+\n #if !HOST_LIBRARY\n // Predefined offload entries\n extern void omp_set_num_threads_lrb(void*);\n@@ -55,6 +65,12 @@ extern void omp_set_nest_lock_lrb(void*);\n extern void omp_unset_nest_lock_lrb(void*);\n extern void omp_test_nest_lock_lrb(void*);\n \n+// OpenMP 4.5 APIs\n+extern void omp_target_alloc_target(void*);\n+extern void omp_target_free_target(void*);\n+extern void omp_target_memcpy_target(void*);\n+extern void omp_target_memcpy_rect_target(void*);\n+\n // Predefined entries on the target side\n static FuncTable::Entry predefined_entries[] = {\n     \"omp_set_num_threads_target\",\n@@ -98,6 +114,15 @@ static FuncTable::Entry predefined_entries[] = {\n     \"omp_test_nest_lock_target\",\n     (void*) &omp_test_nest_lock_lrb,\n \n+    \"omp_target_alloc_target\",\n+    (void*) &omp_target_alloc_target,\n+    \"omp_target_free_target\",\n+    (void*) &omp_target_free_target,\n+    \"omp_target_memcpy_target\",\n+    (void*) &omp_target_memcpy_target,\n+    \"omp_target_memcpy_rect_target\",\n+    (void*) &omp_target_memcpy_rect_target,\n+\n     (const char*) -1,\n     (void*) -1\n };\n@@ -113,6 +138,28 @@ FuncList __offload_entries(&predefined_table);\n FuncList __offload_entries;\n #endif // !HOST_LIBRARY\n \n+extern \"C\" {\n+\n+// Set library version\n+void __offload_set_version(int v)\n+{\n+    offload_version_count++;\n+    if (offload_version_count == 1)\n+    {\n+        offload_version = v;\n+    }\n+    else\n+    {\n+        // Mix of versions is not supported\n+        if (v != offload_version)\n+        {\n+            LIBOFFLOAD_ERROR(c_mixed_versions);\n+            exit(1);\n+        }\n+    }\n+}\n+\n+}  // extern \"C\"\n // Function table. No predefined entries.\n FuncList __offload_funcs;\n \n@@ -296,6 +343,62 @@ void VarList::table_patch_names(void *buf, int64_t nelems)\n     }\n }\n \n+#if HOST_LIBRARY\n+// 16.0 and earlier compilers used the following VarTable\n+struct OldVarTable {\n+    const char* name;\n+    void*       addr;\n+    // uint64_t var_alloc_type  missing in 16.0 and earlier\n+    uint64_t    size;\n+};\n+\n+static void convert_OldVarTable_to_NewVarTable(VarList::Node *vt_start)\n+{\n+    int table_size = 0;\n+    char * new_var_table;\n+    OldVarTable *old_var_table;\n+\n+    OFFLOAD_DEBUG_TRACE(2, \n+       \"Converting old var table to new var table to support backward compatiblity\\n\");\n+\n+    // Calculate size of memory to be malloced\n+    old_var_table = (OldVarTable *) vt_start->table.entries;\n+    while (old_var_table->name != (const char*) -1) {\n+        table_size++;\n+        old_var_table++;\n+    }\n+\n+    if (table_size != 0) {\n+       // Add 1 to table_size for end of table signature \n+       VarTable::Entry *new_var_table = \n+           new VarTable::Entry[table_size+1];\n+\n+       if (new_var_table  == NULL)\n+          LIBOFFLOAD_ERROR(c_malloc);\n+\n+      old_var_table = (OldVarTable *) vt_start->table.entries;\n+\n+      // Update VarList with new table\n+      vt_start->table.entries = new_var_table;\n+\n+      // Fix up the new table value from old table\n+      for (int i=0; i< table_size; i++) {\n+         new_var_table->name = old_var_table->name;\n+         new_var_table->addr = old_var_table->addr;\n+         new_var_table->size = old_var_table->size;\n+         // Assign value of 0 for the missing field.\n+         // Implying it is neither IMPLICIT or LINK variable as\n+         // they were not supported in earlier compilers\n+         new_var_table->var_alloc_type  = 0;\n+         old_var_table++;\n+         new_var_table++;\n+      }\n+      new_var_table->name = (const char *)-1;\n+   }\n+\n+}\n+#endif //HOST_LIBRARY\n+\n // Adds given list element to the global lookup table list\n extern \"C\" void __offload_register_tables(\n     FuncList::Node *entry_table,\n@@ -311,6 +414,17 @@ extern \"C\" void __offload_register_tables(\n     __offload_funcs.add_table(func_table);\n \n     OFFLOAD_DEBUG_TRACE(2, \"Registering var table %p\\n\", var_table);\n+\n+    // Compiler earlier than 17.0 used a different var_table.\n+    // Convert the old table to new var_table format.\n+    // Only the host table for LINUX has changed.\n+#ifndef  TARGET_WINNT\n+#if HOST_LIBRARY\n+    if (offload_version < OFFLOAD_VERSION_17) {\n+       convert_OldVarTable_to_NewVarTable(var_table);\n+    }\n+#endif\n+#endif\n     __offload_vars.add_table(var_table);\n }\n \n@@ -329,6 +443,14 @@ extern \"C\" void __offload_unregister_tables(\n     __offload_funcs.remove_table(func_table);\n \n     OFFLOAD_DEBUG_TRACE(2, \"Unregistering var table %p\\n\", var_table);\n+#ifndef  TARGET_WINNT\n+#if HOST_LIBRARY\n+    if (offload_version < OFFLOAD_VERSION_17) {\n+       // Free the malloced var_table created for backward compatiblity\n+       delete var_table->table.entries;\n+    }\n+#endif\n+#endif\n     __offload_vars.remove_table(var_table);\n }\n "}, {"sha": "9f9f93261cba791edc0baf957e62a0d5e100d50e", "filename": "liboffloadmic/runtime/offload_table.h", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -37,6 +37,9 @@\n \n #include \"offload_util.h\"\n \n+#define OFFLOAD_VERSION_16   1600\n+#define OFFLOAD_VERSION_17   1700\n+\n // Template representing double linked list of tables\n template <typename T> class TableList {\n public:\n@@ -135,6 +138,15 @@ class DLL_LOCAL FuncList : public TableList<FuncTable> {\n     int64_t m_max_name_len;\n };\n \n+#define VAR_ALLOC_TYPE  uint64_t\n+#define OPENMP_IMPLICIT   1    // Compiler promoted openmp declare var\n+                               // due to implicit use without openmp declare \n+#define OPENMP_LINK       2    // Openmp link clause in openmp declare\n+\n+#define IS_OPENMP_IMPLICIT(var_alloc_type)         (var_alloc_type & 1)\n+#define IS_OPENMP_LINK(var_alloc_type)             (var_alloc_type & 2)\n+#define IS_OPENMP_IMPLICIT_OR_LINK(var_alloc_type) (var_alloc_type & 3)\n+\n // Table entry for static variables\n struct VarTable {\n     //! Variable table entry\n@@ -152,12 +164,8 @@ struct VarTable {\n         void*       addr; //!< Address of the variable\n \n #if HOST_LIBRARY\n+        VAR_ALLOC_TYPE  var_alloc_type;\n         uint64_t    size;\n-\n-#ifdef TARGET_WINNT\n-\t\t// padding to make entry size a power of 2\n-        uint64_t    padding;\n-#endif // TARGET_WINNT\n #endif\n     };\n \n@@ -240,6 +248,9 @@ DLL_LOCAL extern VarList  __offload_vars;\n #pragma section(OFFLOAD_VAR_TABLE_SECTION_END, read, write)\n \n \n+// Set library version\n+extern \"C\" void __offload_set_version(int v);\n+\n // register/unregister given tables\n extern \"C\" void __offload_register_tables(\n     FuncList::Node *entry_table,"}, {"sha": "8273faac13b852d50a27eb2c4075e657601086d0", "filename": "liboffloadmic/runtime/offload_target.cpp", "status": "modified", "additions": 120, "deletions": 28, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -70,7 +70,16 @@ static const char* vardesc_type_as_string[] = {\n     \"dv_ptr_data_slice\",\n     \"cean_var\",\n     \"cean_var_ptr\",\n-    \"c_data_ptr_array\"\n+    \"c_data_ptr_array\",\n+    \"c_extended_type\",\n+    \"c_func_ptr_array\",\n+    \"c_void_ptr_array\",\n+    \"c_string_ptr_array\",\n+    \"c_data_ptr_ptr\",\n+    \"c_func_ptr_ptr\",\n+    \"c_void_ptr_ptr\",\n+    \"c_string_ptr_ptr\",\n+    \"c_cean_var_ptr_ptr\",\n };\n \n int mic_index = -1;\n@@ -115,7 +124,7 @@ static void BufReleaseRef(void * buf)\n         --info->count;\n         if (info->count == 0 && info->is_added) {\n             OFFLOAD_TRACE(1, \"Calling COIBufferReleaseRef AddRef count = %d\\n\",\n-                                              ((RefInfo *) ref_data[buf])->count);\n+                             ((RefInfo *) ref_data[buf])->count);\n             BufferReleaseRef(buf);\n             info->is_added = 0;\n         }\n@@ -210,6 +219,11 @@ void OffloadDescriptor::offload(\n           LIBOFFLOAD_ERROR(c_malloc);\n         memcpy(ofld.m_vars, in_data, var_data_len);\n \n+        ofld.m_vars_extra =\n+            (VarExtra*) malloc(ofld.m_vars_total * sizeof(VarExtra));\n+        if (ofld.m_vars == NULL)\n+          LIBOFFLOAD_ERROR(c_malloc);\n+\n         in_data += var_data_len;\n         func->in_datalen -= var_data_len;\n     }\n@@ -289,15 +303,42 @@ void OffloadDescriptor::merge_var_descs(\n     }\n \n     for (int i = 0; i < m_vars_total; i++) {\n+        // instead of m_vars[i].type.src we will use m_vars_extra[i].type_src\n+\n         if (i < vars_total) {\n             // variable type must match\n             if (m_vars[i].type.bits != vars[i].type.bits) {\n+                OFFLOAD_TRACE(2,\n+                    \"m_vars[%d].type.bits=%08x, vars[%d].type.bits=%08x\\n\",\n+                    i, m_vars[i].type.bits, i, vars[i].type.bits);\n                 LIBOFFLOAD_ERROR(c_merge_var_descs2);\n                 exit(1);\n             }\n \n-            m_vars[i].ptr = vars[i].ptr;\n-            m_vars[i].into = vars[i].into;\n+            if (m_vars[i].type.src == c_extended_type) {\n+                VarDescExtendedType *etype =\n+                    reinterpret_cast<VarDescExtendedType*>(vars[i].ptr);\n+                m_vars_extra[i].type_src = etype->extended_type;\n+                m_vars[i].ptr            = etype->ptr;\n+            }\n+            else {\n+                m_vars_extra[i].type_src = m_vars[i].type.src;\n+                if (!(m_vars[i].flags.use_device_ptr &&\n+                      m_vars[i].type.src == c_dv)) {\n+                    m_vars[i].ptr = vars[i].ptr;\n+                }\n+            }\n+            // instead of m_vars[i].type.dst we will use m_vars_extra[i].type_dst\n+            if (m_vars[i].type.dst == c_extended_type && i < vars_total) {\n+                VarDescExtendedType *etype =\n+                    reinterpret_cast<VarDescExtendedType*>(vars[i].into);\n+                m_vars_extra[i].type_dst = etype->extended_type;\n+                m_vars[i].into           = etype->ptr;\n+            }\n+            else {\n+                m_vars_extra[i].type_dst = m_vars[i].type.dst;\n+                m_vars[i].into = vars[i].into;\n+            }\n \n             const char *var_sname = \"\";\n             if (vars2 != NULL) {\n@@ -309,18 +350,23 @@ void OffloadDescriptor::merge_var_descs(\n                 \"   VarDesc %d, var=%s, %s, %s\\n\",\n                 i, var_sname,\n                 vardesc_direction_as_string[m_vars[i].direction.bits],\n-                vardesc_type_as_string[m_vars[i].type.src]);\n+                vardesc_type_as_string[m_vars_extra[i].type_src]);\n             if (vars2 != NULL && vars2[i].dname != NULL) {\n                 OFFLOAD_TRACE(2, \"              into=%s, %s\\n\", vars2[i].dname,\n-                    vardesc_type_as_string[m_vars[i].type.dst]);\n+                    vardesc_type_as_string[m_vars_extra[i].type_dst]);\n             }\n         }\n+        else {\n+            m_vars_extra[i].type_src = m_vars[i].type.src;\n+            m_vars_extra[i].type_dst = m_vars[i].type.dst;\n+        }\n+\n         OFFLOAD_TRACE(2,\n             \"              type_src=%d, type_dstn=%d, direction=%d, \"\n             \"alloc_if=%d, free_if=%d, align=%d, mic_offset=%d, flags=0x%x, \"\n             \"offset=%lld, size=%lld, count/disp=%lld, ptr=%p into=%p\\n\",\n-            m_vars[i].type.src,\n-            m_vars[i].type.dst,\n+            m_vars_extra[i].type_src,\n+            m_vars_extra[i].type_dst,\n             m_vars[i].direction.bits,\n             m_vars[i].alloc_if,\n             m_vars[i].free_if,\n@@ -352,8 +398,8 @@ void OffloadDescriptor::scatter_copyin_data()\n         void** ptr_addr = src_is_for_mic ?\n                           static_cast<void**>(m_vars[i].ptr) :\n                           static_cast<void**>(m_vars[i].into);\n-        int type = src_is_for_mic ? m_vars[i].type.src :\n-                                    m_vars[i].type.dst;\n+        int type = src_is_for_mic ? m_vars_extra[i].type_src :\n+                                    m_vars_extra[i].type_dst;\n         bool is_static = src_is_for_mic ?\n                          m_vars[i].flags.is_static :\n                          m_vars[i].flags.is_static_dstn;\n@@ -380,8 +426,13 @@ void OffloadDescriptor::scatter_copyin_data()\n                         *(reinterpret_cast<char**>(m_vars[i].ptr)) :\n                         reinterpret_cast<char*>(m_vars[i].into);\n \n+                    // if is_pointer is 1 it means that pointer array itself\n+                    // is defined either via pointer or as class member.\n+                    // i.e. arr_ptr[0:5] or this->ARR[0:5]\n                     if (m_vars[i].flags.is_pointer) {\n-                        dst_arr_ptr = *((char**)dst_arr_ptr);\n+                        int64_t offset = 0;\n+                        m_in.receive_data(&offset, sizeof(offset));\n+                        dst_arr_ptr = *((char**)dst_arr_ptr) + offset;\n                     }\n                     for (; j < max_el; j++) {\n                         if (src_is_for_mic) {\n@@ -397,14 +448,33 @@ void OffloadDescriptor::scatter_copyin_data()\n                 break;\n             case c_data:\n             case c_void_ptr:\n+            case c_void_ptr_ptr:\n             case c_cean_var:\n             case c_dv:\n                 break;\n \n             case c_string_ptr:\n             case c_data_ptr:\n+            case c_string_ptr_ptr:\n+            case c_data_ptr_ptr:\n             case c_cean_var_ptr:\n+            case c_cean_var_ptr_ptr:\n             case c_dv_ptr:\n+                // Don't need ptr_addr value for variables from stack buffer.\n+                // Stack buffer address is set at var_desc with #0.\n+                if (i != 0 && m_vars[i].flags.is_stack_buf) {\n+                    break;\n+                }\n+                if (TYPE_IS_PTR_TO_PTR(m_vars_extra[i].type_src) ||\n+                    TYPE_IS_PTR_TO_PTR(m_vars_extra[i].type_dst)) {\n+                    int64_t offset;\n+\n+                    m_in.receive_data(&offset, sizeof(offset));\n+                    ptr_addr = reinterpret_cast<void**>(\n+                                 reinterpret_cast<char*>(*ptr_addr) + offset);\n+\n+                }\n+\n                 if (m_vars[i].alloc_if && !m_vars[i].flags.preallocated) {\n                     void *buf = NULL;\n                     if (m_vars[i].flags.sink_addr) {\n@@ -431,6 +501,7 @@ void OffloadDescriptor::scatter_copyin_data()\n                                   m_vars[i].mic_offset +\n                                   (m_vars[i].flags.is_stack_buf ?\n                                    0 : m_vars[i].offset);\n+\n                     }\n                     *ptr_addr = ptr;\n                 }\n@@ -446,6 +517,7 @@ void OffloadDescriptor::scatter_copyin_data()\n                 break;\n \n             case c_func_ptr:\n+            case c_func_ptr_ptr:\n                 break;\n \n             case c_dv_data:\n@@ -489,25 +561,29 @@ void OffloadDescriptor::scatter_copyin_data()\n                 LIBOFFLOAD_ERROR(c_unknown_var_type, type);\n                 abort();\n         }\n-        // Release obsolete buffers for stack of persistent objects\n-        if (type = c_data_ptr &&\n+        // Release obsolete buffers for stack of persistent objects.\n+        // The vardesc with i==0 and flags.is_stack_buf==TRUE is always for\n+        // stack buffer pointer.\n+        if (i == 0 &&\n             m_vars[i].flags.is_stack_buf &&\n             !m_vars[i].direction.bits &&\n             m_vars[i].alloc_if &&\n             m_vars[i].size != 0) {\n                 for (int j=0; j < m_vars[i].size; j++) {\n                     void *buf;\n                     m_in.receive_data(&buf, sizeof(buf));\n+                    OFFLOAD_TRACE(4, \"Releasing stack buffer %p\\n\", buf);\n                     BufferReleaseRef(buf);\n                     ref_data.erase(buf);\n                 }\n         }\n         // Do copyin\n-        switch (m_vars[i].type.dst) {\n+        switch (m_vars_extra[i].type_dst) {\n             case c_data_ptr_array:\n                 break;\n             case c_data:\n             case c_void_ptr:\n+            case c_void_ptr_ptr:\n             case c_cean_var:\n                 if (m_vars[i].direction.in &&\n                     !m_vars[i].flags.is_static_dstn) {\n@@ -516,7 +592,7 @@ void OffloadDescriptor::scatter_copyin_data()\n                     char* ptr = m_vars[i].into ?\n                                  static_cast<char*>(m_vars[i].into) :\n                                  static_cast<char*>(m_vars[i].ptr);\n-                    if (m_vars[i].type.dst == c_cean_var) {\n+                    if (m_vars_extra[i].type_dst == c_cean_var) {\n                         m_in.receive_data((&size), sizeof(int64_t));\n                         m_in.receive_data((&disp), sizeof(int64_t));\n                     }\n@@ -542,7 +618,10 @@ void OffloadDescriptor::scatter_copyin_data()\n \n             case c_string_ptr:\n             case c_data_ptr:\n+            case c_string_ptr_ptr:\n+            case c_data_ptr_ptr:\n             case c_cean_var_ptr:\n+            case c_cean_var_ptr_ptr:\n             case c_dv_ptr:\n             case c_dv_data:\n             case c_dv_ptr_data:\n@@ -551,13 +630,14 @@ void OffloadDescriptor::scatter_copyin_data()\n                 break;\n \n             case c_func_ptr:\n+            case c_func_ptr_ptr:\n                 if (m_vars[i].direction.in) {\n                     m_in.receive_func_ptr((const void**) m_vars[i].ptr);\n                 }\n                 break;\n \n             default:\n-                LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars[i].type.dst);\n+                LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars_extra[i].type_dst);\n                 abort();\n         }\n     }\n@@ -579,12 +659,15 @@ void OffloadDescriptor::gather_copyout_data()\n     for (int i = 0; i < m_vars_total; i++) {\n         bool src_is_for_mic = (m_vars[i].direction.out ||\n                                m_vars[i].into == NULL);\n-\n-        switch (m_vars[i].type.src) {\n+        if (m_vars[i].flags.is_stack_buf) {\n+            continue;\n+        }\n+        switch (m_vars_extra[i].type_src) {\n             case c_data_ptr_array:\n                 break;\n             case c_data:\n             case c_void_ptr:\n+            case c_void_ptr_ptr:\n             case c_cean_var:\n                 if (m_vars[i].direction.out &&\n                     !m_vars[i].flags.is_static) {\n@@ -599,7 +682,10 @@ void OffloadDescriptor::gather_copyout_data()\n \n             case c_string_ptr:\n             case c_data_ptr:\n+            case c_string_ptr_ptr:\n+            case c_data_ptr_ptr:\n             case c_cean_var_ptr:\n+            case c_cean_var_ptr_ptr:\n             case c_dv_ptr:\n                 if (m_vars[i].free_if &&\n                     src_is_for_mic &&\n@@ -623,6 +709,7 @@ void OffloadDescriptor::gather_copyout_data()\n                 break;\n \n             case c_func_ptr:\n+            case c_func_ptr_ptr:\n                 if (m_vars[i].direction.out) {\n                     m_out.send_func_ptr(*((void**) m_vars[i].ptr));\n                 }\n@@ -635,10 +722,10 @@ void OffloadDescriptor::gather_copyout_data()\n                 if (src_is_for_mic &&\n                     m_vars[i].free_if &&\n                     !m_vars[i].flags.is_static) {\n-                    ArrDesc *dvp = (m_vars[i].type.src == c_dv_data ||\n-                                    m_vars[i].type.src == c_dv_data_slice) ?\n-                        static_cast<ArrDesc*>(m_vars[i].ptr) :\n-                        *static_cast<ArrDesc**>(m_vars[i].ptr);\n+                    ArrDesc *dvp = (m_vars_extra[i].type_src == c_dv_data ||\n+                               m_vars_extra[i].type_src == c_dv_data_slice) ?\n+                               static_cast<ArrDesc*>(m_vars[i].ptr) :\n+                               *static_cast<ArrDesc**>(m_vars[i].ptr);\n \n                     void *buf = reinterpret_cast<char*>(dvp->Base) -\n                                 m_vars[i].mic_offset -\n@@ -656,23 +743,27 @@ void OffloadDescriptor::gather_copyout_data()\n                 break;\n \n             default:\n-                LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars[i].type.dst);\n+                LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars_extra[i].type_dst);\n                 abort();\n         }\n \n         if (m_vars[i].into) {\n-            switch (m_vars[i].type.dst) {\n+            switch (m_vars_extra[i].type_dst) {\n                 case c_data_ptr_array:\n                     break;\n                 case c_data:\n                 case c_void_ptr:\n+                case c_void_ptr_ptr:\n                 case c_cean_var:\n                 case c_dv:\n                     break;\n \n                 case c_string_ptr:\n                 case c_data_ptr:\n+                case c_string_ptr_ptr:\n+                case c_data_ptr_ptr:\n                 case c_cean_var_ptr:\n+                case c_cean_var_ptr_ptr:\n                 case c_dv_ptr:\n                     if (m_vars[i].direction.in &&\n                         m_vars[i].free_if &&\n@@ -695,6 +786,7 @@ void OffloadDescriptor::gather_copyout_data()\n                     break;\n \n                 case c_func_ptr:\n+                case c_func_ptr_ptr:\n                     break;\n \n                 case c_dv_data:\n@@ -705,8 +797,8 @@ void OffloadDescriptor::gather_copyout_data()\n                         m_vars[i].direction.in &&\n                         !m_vars[i].flags.is_static_dstn) {\n                         ArrDesc *dvp =\n-                            (m_vars[i].type.dst == c_dv_data_slice ||\n-                             m_vars[i].type.dst == c_dv_data) ?\n+                            (m_vars_extra[i].type_dst == c_dv_data_slice ||\n+                             m_vars_extra[i].type_dst == c_dv_data) ?\n                             static_cast<ArrDesc*>(m_vars[i].into) :\n                             *static_cast<ArrDesc**>(m_vars[i].into);\n                         void *buf = reinterpret_cast<char*>(dvp->Base) -\n@@ -726,7 +818,7 @@ void OffloadDescriptor::gather_copyout_data()\n                     break;\n \n                 default:\n-                    LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars[i].type.dst);\n+                    LIBOFFLOAD_ERROR(c_unknown_var_type, m_vars_extra[i].type_dst);\n                     abort();\n             }\n         }"}, {"sha": "8d2971b2418409753c0bf3da2b4c55c76235eff6", "filename": "liboffloadmic/runtime/offload_target.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -43,6 +43,7 @@ class OffloadDescriptor\n     ~OffloadDescriptor() {\n         if (m_vars != 0) {\n             free(m_vars);\n+            free(m_vars_extra);\n         }\n     }\n \n@@ -96,6 +97,14 @@ class OffloadDescriptor\n     VarDesc* m_vars;\n     int      m_vars_total;\n     int      m_offload_number;\n+\n+    // extra data associated with each variable descriptor\n+    struct VarExtra {\n+        uint16_t type_src;\n+        uint16_t type_dst;\n+    };\n+\n+    VarExtra* m_vars_extra;\n };\n \n // one time target initialization in main"}, {"sha": "68f7c3054d56d87dae15ec653fb9cb9b10effc2a", "filename": "liboffloadmic/runtime/offload_target_main.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target_main.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "30a1149b6fb94bd880e200edfa815eb3eb5953e2", "filename": "liboffloadmic/runtime/offload_timer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "3d93508f5d872a87dbebf84049048ff439e2bfec", "filename": "liboffloadmic/runtime/offload_timer_host.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "860f29765803bf0c908e65339accd2d75d261a68", "filename": "liboffloadmic/runtime/offload_timer_target.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "8d69c286f57f1dd6ff424b345d5ac5785e28cf75", "filename": "liboffloadmic/runtime/offload_trace.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "e48aa01f340d5b60f0ef46dd2e6928698c95290c", "filename": "liboffloadmic/runtime/offload_trace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "bb434871f6025b737c5d98a2e6e8daecf1429663", "filename": "liboffloadmic/runtime/offload_util.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "789846239bfcc387d68e1f1ce009fc7c96a5b7fe", "filename": "liboffloadmic/runtime/offload_util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Foffload_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "49d40509c97b52bacb39a78f1807acc551cb1ac9", "filename": "liboffloadmic/runtime/ofldbegin.cpp", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldbegin.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -30,12 +30,16 @@\n \n #if HOST_LIBRARY\n #include \"offload_table.h\"\n+#ifdef MYO_SUPPORT\n #include \"offload_myo_host.h\"\n+#endif // MYO_SUPPORT\n #else\n #include \"compiler_if_target.h\"\n #include \"offload_target.h\"\n+#ifdef MYO_SUPPORT\n #include \"offload_myo_target.h\"\n-#endif\n+#endif // MYO_SUPPORT\n+#endif // HOST_LIBRARY\n \n // Initializes library and registers specified offload image.\n // Don't use this declarations from offload_host.h as offload_table.h\n@@ -254,6 +258,9 @@ static void offload_init()\n {\n     bool success;\n \n+    // Set offload version\n+    __offload_set_version(OFFLOAD_VERSION_17);\n+\n     // register offload tables\n     __offload_register_tables(&__offload_entry_node,\n                               &__offload_func_node,\n@@ -295,8 +302,6 @@ static void offload_init()\n \n #ifndef TARGET_WINNT\n static void offload_fini_so() __attribute__((destructor(101)));\n-#else // TARGET_WINNT\n-static void offload_init_so();\n #endif // TARGET_WINNT\n \n static void offload_fini()"}, {"sha": "3cabc1a00035507508fe59e9cef19b7a0f1e2b3a", "filename": "liboffloadmic/runtime/ofldend.cpp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fofldend.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Fofldend.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldend.cpp?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -30,11 +30,15 @@\n \n #if HOST_LIBRARY\n #include \"offload_table.h\"\n+#ifdef MYO_SUPPORT\n #include \"offload_myo_host.h\"\n+#endif // MYO_SUPPORT\n #else\n #include \"offload_target.h\"\n+#ifdef MYO_SUPPORT\n #include \"offload_myo_target.h\"\n-#endif\n+#endif // MYO_SUPPORT\n+#endif // HOST_LIBRARY\n \n #ifdef TARGET_WINNT\n #define ALLOCATE(name) __declspec(allocate(name))"}, {"sha": "867bae5f33c38e6ba2f539c7399532b8698619be", "filename": "liboffloadmic/runtime/orsl-lite/include/orsl-lite.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "669c40a13584dcbf4cb662a5ffcf09dc3d04317c", "filename": "liboffloadmic/runtime/orsl-lite/lib/orsl-lite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df26a50d0d0665879975138bfe4f05285b2fadae/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c?ref=df26a50d0d0665879975138bfe4f05285b2fadae", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2016 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "47b322c971c3ce34b223693982d647bf2e352923", "filename": "liboffloadmic/runtime/use_mpss2.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3af181e659954846e9d6678b04b2670f2da703/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fuse_mpss2.txt?ref=ab3af181e659954846e9d6678b04b2670f2da703", "patch": "@@ -1 +0,0 @@\n-3.4.1"}]}