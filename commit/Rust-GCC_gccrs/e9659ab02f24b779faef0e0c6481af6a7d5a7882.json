{"sha": "e9659ab02f24b779faef0e0c6481af6a7d5a7882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2NTlhYjAyZjI0Yjc3OWZhZWYwZTBjNjQ4MWFmNmE3ZDVhNzg4Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-03T11:24:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-03T11:24:45Z"}, "message": "class.c, [...]: Add 'static' to make SunOS 4 cc happy.\n\n\t* class.c, decl2.c, method.c, pt.c: Add 'static' to make SunOS 4\n\tcc happy.\n\t* decl2.c (import_export_class): Also return if\n\tCLASSTYPE_INTERFACE_ONLY is set.\n\nFrom-SVN: r25562", "tree": {"sha": "3d0699b917908ac38ab5815d239d22563dec9f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0699b917908ac38ab5815d239d22563dec9f5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9659ab02f24b779faef0e0c6481af6a7d5a7882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9659ab02f24b779faef0e0c6481af6a7d5a7882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9659ab02f24b779faef0e0c6481af6a7d5a7882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9659ab02f24b779faef0e0c6481af6a7d5a7882/comments", "author": null, "committer": null, "parents": [{"sha": "4cdea27381507e52775c8d844ebc9522ded33f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cdea27381507e52775c8d844ebc9522ded33f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cdea27381507e52775c8d844ebc9522ded33f5f"}], "stats": {"total": 70, "additions": 43, "deletions": 27}, "files": [{"sha": "8653f1953af65b6bc38b2d5c2fcaa109a549dfcb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e9659ab02f24b779faef0e0c6481af6a7d5a7882", "patch": "@@ -1,3 +1,11 @@\n+1999-03-03  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c, decl2.c, method.c, pt.c: Add 'static' to make SunOS 4\n+\tcc happy.\n+\n+\t* decl2.c (import_export_class): Also return if\n+\tCLASSTYPE_INTERFACE_ONLY is set.\n+\n 1999-03-03  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl.c (push_overloaded_decl): Only overwrite the old binding if"}, {"sha": "5e71c41e04cbd33dd4324d35f4f799cb85674bbb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e9659ab02f24b779faef0e0c6481af6a7d5a7882", "patch": "@@ -1450,7 +1450,7 @@ alter_access (t, binfo, fdecl, access)\n /* Process the USING_DECL, which is a member of T.  The METHOD_VEC, if\n    non-NULL, is the methods of T.  The FIELDS are the fields of T.  */\n \n-void\n+static void\n handle_using_decl (using_decl, t, method_vec, fields)\n      tree using_decl;\n      tree t;"}, {"sha": "da4cdd569180eb3d3627485469ea3b416406e44d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e9659ab02f24b779faef0e0c6481af6a7d5a7882", "patch": "@@ -2067,7 +2067,7 @@ get_temp_regvar (type, init)\n    returns a VAR_DECL whose size is the same as the size of the\n    ANON_DECL, if one is available.  */\n \n-tree \n+static tree \n build_anon_union_vars (anon_decl, elems, static_p, external_p)\n      tree anon_decl;\n      tree* elems;\n@@ -2474,6 +2474,14 @@ import_export_class (ctype)\n   if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n     return;\n \n+  /* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma interface,\n+     we will have CLASSTYPE_INTERFACE_ONLY set but not\n+     CLASSTYPE_INTERFACE_KNOWN.  In that case, we don't want to use this\n+     heuristic because someone will supply a #pragma implementation\n+     elsewhere, and deducing it here would produce a conflict.  */\n+  if (CLASSTYPE_INTERFACE_ONLY (ctype))\n+    return;\n+\n #ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n   /* FIXME this should really use some sort of target-independent macro.  */\n   if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))"}, {"sha": "f5958f264f93c2dbe2008200d7da503684e3cc23", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e9659ab02f24b779faef0e0c6481af6a7d5a7882", "patch": "@@ -326,7 +326,7 @@ flush_repeats (nrepeats, type)\n /* Returns nonzero iff this is a type to which we will want to make\n    back-references (using the `B' code).  */\n \n-int\n+static int\n is_back_referenceable_type (type)\n      tree type;\n {\n@@ -1040,7 +1040,7 @@ build_qualified_name (decl)\n    non-zero, mangled names for structure/union types are intentionally\n    mangled differently from the method described in the ARM.  */\n \n-void \n+static void \n build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n      tree type;\n      int extra_Gcode;\n@@ -1055,7 +1055,7 @@ build_mangled_name_for_type_with_Gcode (type, extra_Gcode)\n /* Like build_mangled_name_for_type_with_Gcode, but never outputs the\n    `G'.  */\n \n-void\n+static void\n build_mangled_name_for_type (type)\n      tree type;\n {\n@@ -1203,7 +1203,7 @@ build_mangled_name (parmtypes, begin, end)\n \n /* Emit modifiers such as constant, read-only, and volatile.  */\n \n-void \n+static void \n process_modifiers (parmtype) \n      tree parmtype;\n {\n@@ -1231,7 +1231,7 @@ process_modifiers (parmtype)\n    so, return 1 and emit a backreference to TYPE.  Otherwise, add TYPE\n    to the list of back-referenceable types and return 0.  */\n \n-int \n+static int \n check_btype (type) \n      tree type;\n {"}, {"sha": "71237d61a1281d2209900c3549f1404dfd4d547e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9659ab02f24b779faef0e0c6481af6a7d5a7882/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e9659ab02f24b779faef0e0c6481af6a7d5a7882", "patch": "@@ -273,7 +273,7 @@ finish_member_template_decl (decl)\n    that, for example, `template_class_depth (current_class_type)' is\n    always safe.  */\n \n-int \n+static int \n template_class_depth_real (type, count_specializations)\n      tree type;\n      int count_specializations;\n@@ -587,7 +587,7 @@ begin_template_parm_list ()\n /* This routine is called when a specialization is declared.  If it is\n    illegal to declare a specialization here, an error is reported.  */\n \n-void\n+static void\n check_specialization_scope ()\n {\n   tree scope = current_scope ();\n@@ -920,7 +920,7 @@ print_candidates (fns)\n    If it is impossible to determine the result, an error message is\n    issued.  The error_mark_node is returned to indicate failure.  */\n \n-tree\n+static tree\n determine_specialization (template_id, decl, targs_out, \n \t\t\t  need_member_template)\n      tree template_id;\n@@ -1950,7 +1950,7 @@ mark_template_parm (t, data)\n \n /* Process the partial specialization DECL.  */\n \n-tree\n+static tree\n process_partial_specialization (decl)\n      tree decl;\n {\n@@ -3462,7 +3462,7 @@ lookup_template_function (fns, arglist)\n    return the associated TEMPLATE_DECL.  Otherwise, the original\n    DECL is returned.  */\n \n-tree\n+static tree\n maybe_get_template_decl_from_type_decl (decl)\n      tree decl;\n {\n@@ -3912,7 +3912,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n    returned by for_each_template_parm is 0.  If FN is NULL, it is\n    considered to be the function which always returns 1.  */\n \n-int\n+static int\n for_each_template_parm (t, fn, data)\n      tree t;\n      tree_fn_t fn;\n@@ -5091,7 +5091,7 @@ innermost_args (args)\n \n /* Substitute ARGS into the vector of template arguments T.  */\n \n-tree\n+static tree\n tsubst_template_arg_vector (t, args, complain)\n      tree t;\n      tree args;\n@@ -5134,7 +5134,7 @@ tsubst_template_arg_vector (t, args, complain)\n    template <T*, U, class V>' and ARGS is {{int}, {double}} then the\n    result will be `template <int*, double, class V>'.  */\n \n-tree\n+static tree\n tsubst_template_parms (parms, args, complain)\n      tree parms;\n      tree args;\n@@ -5181,7 +5181,7 @@ tsubst_template_parms (parms, args, complain)\n    ENTERING_SCOPE is non-zero, T is the context for a template which\n    we are presently tsubst'ing.  Return the subsituted value.  */\n \n-tree\n+static tree\n tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n      tree t;\n      tree args;\n@@ -5253,7 +5253,7 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n    appropriate.  Return the result of the substitution.  IN_DECL is as\n    for tsubst.  */\n \n-tree\n+static tree\n tsubst_decl (t, args, type, in_decl)\n      tree t;\n      tree args;\n@@ -5771,7 +5771,7 @@ tsubst_decl (t, args, type, in_decl)\n \n /* Substitue into the ARG_TYPES of a function type.  */\n \n-tree\n+static tree\n tsubst_arg_types (arg_types, args, complain, in_decl)\n      tree arg_types;\n      tree args;\n@@ -5878,7 +5878,7 @@ tsubst_function_type (t, args, complain, in_decl)\n \n /* Substitute into the PARMS of a call-declarator.  */\n \n-tree\n+static tree\n tsubst_call_declarator_parms (parms, args, complain, in_decl)\n      tree parms;\n      tree args;\n@@ -7305,7 +7305,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    the argument passed to the call, or the type of the value\n    intialized with the result of the conversion function.  */\n \n-void\n+static void\n maybe_adjust_types_for_deduction (strict, parm, arg)\n      unification_kind_t strict;\n      tree* parm;\n@@ -7847,7 +7847,7 @@ get_template_base (tparms, targs, parm, arg)\n \n /* Returns the level of DECL, which declares a template parameter.  */\n \n-int\n+static int\n template_decl_level (decl)\n      tree decl;\n {\n@@ -7870,7 +7870,7 @@ template_decl_level (decl)\n    cv-qualifiers of each type, given STRICT as documented for unify.\n    Returns non-zero iff the unification is OK on that basis.*/\n \n-int\n+static int\n check_cv_quals_for_unify (strict, arg, parm)\n      int strict;\n      tree arg;\n@@ -7900,7 +7900,7 @@ check_cv_quals_for_unify (strict, arg, parm)\n        Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX\n        case for more information.  */\n \n-int\n+static int\n unify (tparms, targs, parm, arg, strict)\n      tree tparms, targs, parm, arg;\n      int strict;\n@@ -8612,7 +8612,7 @@ most_specialized_instantiation (instantiations, explicit_args)\n    produce an instantiation matching DECL, given the explicit template\n    arguments EXPLICIT_ARGS.  */\n \n-tree\n+static tree\n most_specialized (fns, decl, explicit_args)\n      tree fns, decl, explicit_args;\n {\n@@ -8646,7 +8646,7 @@ most_specialized (fns, decl, explicit_args)\n    if TMPL is `template <class U> void S<int*>::f(U)' this will return\n    `template <class T> template <class U> S<T*>::f(U)'.  */\n \n-tree\n+static tree\n most_general_template (decl)\n      tree decl;\n {\n@@ -8660,7 +8660,7 @@ most_general_template (decl)\n    of TMPL which can produce an instantiation matching ARGS, or\n    error_mark_node if the choice is ambiguous.  */\n \n-tree\n+static tree\n most_specialized_class (tmpl, args)\n      tree tmpl;\n      tree args;\n@@ -8991,7 +8991,7 @@ do_type_instantiation (t, storage)\n    first parameter, and the wrong type for the second.  So, when we go\n    to instantiate the DECL, we regenerate it.  */\n \n-void\n+static void\n regenerate_decl_from_template (decl, tmpl)\n      tree decl;\n      tree tmpl;"}]}