{"sha": "44a845ca0e592ca187fbab07ac9e055b20fb11cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRhODQ1Y2EwZTU5MmNhMTg3ZmJhYjA3YWM5ZTA1NWIyMGZiMTFjYw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-06-08T19:03:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-06-08T19:03:17Z"}, "message": "re PR c++/70507 (integer overflow builtins not constant expressions)\n\n\tPR c++/70507\n\tPR c/68120\n\t* builtins.def (BUILT_IN_ADD_OVERFLOW_P, BUILT_IN_SUB_OVERFLOW_P,\n\tBUILT_IN_MUL_OVERFLOW_P): New builtins.\n\t* builtins.c: Include gimple-fold.h.\n\t(fold_builtin_arith_overflow): Handle\n\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\n\t(fold_builtin_3): Likewise.\n\t* doc/extend.texi (Integer Overflow Builtins): Document\n\t__builtin_{add,sub,mul}_overflow_p.\ngcc/c/\n\t* c-typeck.c (convert_arguments): Don't promote last argument\n\tof BUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\ngcc/cp/\n\t* constexpr.c: Include gimple-fold.h.\n\t(cxx_eval_internal_function): New function.\n\t(cxx_eval_call_expression): Call it.\n\t(potential_constant_expression_1): Handle integer arithmetic\n\toverflow built-ins.\n\t* tree.c (builtin_valid_in_constant_expr_p): Handle\n\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\ngcc/c-family/\n\t* c-common.c (check_builtin_function_arguments): Handle\n\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\ngcc/testsuite/\n\t* c-c++-common/builtin-arith-overflow-1.c: Add test cases.\n\t* c-c++-common/builtin-arith-overflow-2.c: New test.\n\t* g++.dg/ext/builtin-arith-overflow-1.C: New test.\n\t* g++.dg/cpp0x/constexpr-arith-overflow.C: New test.\n\t* g++.dg/cpp1y/constexpr-arith-overflow.C: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r237238", "tree": {"sha": "3a15f43474585970a2b22a98bf6ff1b46fcf075f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a15f43474585970a2b22a98bf6ff1b46fcf075f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44a845ca0e592ca187fbab07ac9e055b20fb11cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a845ca0e592ca187fbab07ac9e055b20fb11cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44a845ca0e592ca187fbab07ac9e055b20fb11cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44a845ca0e592ca187fbab07ac9e055b20fb11cc/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "379aea728edb345f42b19dfade5529f8f9e8a6da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/379aea728edb345f42b19dfade5529f8f9e8a6da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/379aea728edb345f42b19dfade5529f8f9e8a6da"}], "stats": {"total": 1260, "additions": 1235, "deletions": 25}, "files": [{"sha": "89c9f766cce988e287df45b6525d539144b35b2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -1,3 +1,17 @@\n+2016-06-08  Martin Sebor  <msebor@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/70507\n+\tPR c/68120\n+\t* builtins.def (BUILT_IN_ADD_OVERFLOW_P, BUILT_IN_SUB_OVERFLOW_P,\n+\tBUILT_IN_MUL_OVERFLOW_P): New builtins.\n+\t* builtins.c: Include gimple-fold.h.\n+\t(fold_builtin_arith_overflow): Handle\n+\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\n+\t(fold_builtin_3): Likewise.\n+\t* doc/extend.texi (Integer Overflow Builtins): Document\n+\t__builtin_{add,sub,mul}_overflow_p.\n+\n 2016-06-08  Jose E. Marchesi  <jose.marchesi@oracle.com>\n \n \t* config/sparc/driver-sparc.c (cpu_names): Fix the entry for the"}, {"sha": "5d234a5c8278f587b132d31ba558567d6a83f905", "filename": "gcc/builtins.c", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-chkp.h\"\n #include \"internal-fn.h\"\n #include \"case-cfn-macros.h\"\n+#include \"gimple-fold.h\"\n \n \n struct target_builtins default_target_builtins;\n@@ -7943,18 +7944,28 @@ fold_builtin_unordered_cmp (location_t loc, tree fndecl, tree arg0, tree arg1,\n /* Fold __builtin_{,s,u}{add,sub,mul}{,l,ll}_overflow, either into normal\n    arithmetics if it can never overflow, or into internal functions that\n    return both result of arithmetics and overflowed boolean flag in\n-   a complex integer result, or some other check for overflow.  */\n+   a complex integer result, or some other check for overflow.\n+   Similarly fold __builtin_{add,sub,mul}_overflow_p to just the overflow\n+   checking part of that.  */\n \n static tree\n fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n \t\t\t     tree arg0, tree arg1, tree arg2)\n {\n   enum internal_fn ifn = IFN_LAST;\n-  tree type = TREE_TYPE (TREE_TYPE (arg2));\n-  tree mem_arg2 = build_fold_indirect_ref_loc (loc, arg2);\n+  /* The code of the expression corresponding to the type-generic\n+     built-in, or ERROR_MARK for the type-specific ones.  */\n+  enum tree_code opcode = ERROR_MARK;\n+  bool ovf_only = false;\n+\n   switch (fcode)\n     {\n+    case BUILT_IN_ADD_OVERFLOW_P:\n+      ovf_only = true;\n+      /* FALLTHRU */\n     case BUILT_IN_ADD_OVERFLOW:\n+      opcode = PLUS_EXPR;\n+      /* FALLTHRU */\n     case BUILT_IN_SADD_OVERFLOW:\n     case BUILT_IN_SADDL_OVERFLOW:\n     case BUILT_IN_SADDLL_OVERFLOW:\n@@ -7963,7 +7974,12 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n     case BUILT_IN_UADDLL_OVERFLOW:\n       ifn = IFN_ADD_OVERFLOW;\n       break;\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+      ovf_only = true;\n+      /* FALLTHRU */\n     case BUILT_IN_SUB_OVERFLOW:\n+      opcode = MINUS_EXPR;\n+      /* FALLTHRU */\n     case BUILT_IN_SSUB_OVERFLOW:\n     case BUILT_IN_SSUBL_OVERFLOW:\n     case BUILT_IN_SSUBLL_OVERFLOW:\n@@ -7972,7 +7988,12 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n     case BUILT_IN_USUBLL_OVERFLOW:\n       ifn = IFN_SUB_OVERFLOW;\n       break;\n+    case BUILT_IN_MUL_OVERFLOW_P:\n+      ovf_only = true;\n+      /* FALLTHRU */\n     case BUILT_IN_MUL_OVERFLOW:\n+      opcode = MULT_EXPR;\n+      /* FALLTHRU */\n     case BUILT_IN_SMUL_OVERFLOW:\n     case BUILT_IN_SMULL_OVERFLOW:\n     case BUILT_IN_SMULLL_OVERFLOW:\n@@ -7984,13 +8005,37 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n     default:\n       gcc_unreachable ();\n     }\n+\n+  /* For the \"generic\" overloads, the first two arguments can have different\n+     types and the last argument determines the target type to use to check\n+     for overflow.  The arguments of the other overloads all have the same\n+     type.  */\n+  tree type = ovf_only ? TREE_TYPE (arg2) : TREE_TYPE (TREE_TYPE (arg2));\n+\n+  /* For the __builtin_{add,sub,mul}_overflow_p builtins, when the first two\n+     arguments are constant, attempt to fold the built-in call into a constant\n+     expression indicating whether or not it detected an overflow.  */\n+  if (ovf_only\n+      && TREE_CODE (arg0) == INTEGER_CST\n+      && TREE_CODE (arg1) == INTEGER_CST)\n+    /* Perform the computation in the target type and check for overflow.  */\n+    return omit_one_operand_loc (loc, boolean_type_node,\n+\t\t\t\t arith_overflowed_p (opcode, type, arg0, arg1)\n+\t\t\t\t ? boolean_true_node : boolean_false_node,\n+\t\t\t\t arg2);\n+\n   tree ctype = build_complex_type (type);\n   tree call = build_call_expr_internal_loc (loc, ifn, ctype,\n \t\t\t\t\t    2, arg0, arg1);\n   tree tgt = save_expr (call);\n   tree intres = build1_loc (loc, REALPART_EXPR, type, tgt);\n   tree ovfres = build1_loc (loc, IMAGPART_EXPR, type, tgt);\n   ovfres = fold_convert_loc (loc, boolean_type_node, ovfres);\n+\n+  if (ovf_only)\n+    return omit_one_operand_loc (loc, boolean_type_node, ovfres, arg2);\n+\n+  tree mem_arg2 = build_fold_indirect_ref_loc (loc, arg2);\n   tree store\n     = fold_build2_loc (loc, MODIFY_EXPR, void_type_node, mem_arg2, intres);\n   return build2_loc (loc, COMPOUND_EXPR, boolean_type_node, store, ovfres);\n@@ -8340,6 +8385,9 @@ fold_builtin_3 (location_t loc, tree fndecl,\n     case BUILT_IN_ADD_OVERFLOW:\n     case BUILT_IN_SUB_OVERFLOW:\n     case BUILT_IN_MUL_OVERFLOW:\n+    case BUILT_IN_ADD_OVERFLOW_P:\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+    case BUILT_IN_MUL_OVERFLOW_P:\n     case BUILT_IN_SADD_OVERFLOW:\n     case BUILT_IN_SADDL_OVERFLOW:\n     case BUILT_IN_SADDLL_OVERFLOW:"}, {"sha": "ca9bafcbf2fecf0345851e40f763d3720a1a0c11", "filename": "gcc/builtins.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -710,6 +710,9 @@ DEF_C94_BUILTIN        (BUILT_IN_TOWUPPER, \"towupper\", BT_FN_WINT_WINT, ATTR_PUR\n DEF_GCC_BUILTIN        (BUILT_IN_ADD_OVERFLOW, \"add_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n DEF_GCC_BUILTIN        (BUILT_IN_SUB_OVERFLOW, \"sub_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n DEF_GCC_BUILTIN        (BUILT_IN_MUL_OVERFLOW, \"mul_overflow\", BT_FN_BOOL_VAR, ATTR_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_ADD_OVERFLOW_P, \"add_overflow_p\", BT_FN_BOOL_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_SUB_OVERFLOW_P, \"sub_overflow_p\", BT_FN_BOOL_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_MUL_OVERFLOW_P, \"mul_overflow_p\", BT_FN_BOOL_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n /* Clang compatibility.  */\n DEF_GCC_BUILTIN        (BUILT_IN_SADD_OVERFLOW, \"sadd_overflow\", BT_FN_BOOL_INT_INT_INTPTR, ATTR_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_SADDL_OVERFLOW, \"saddl_overflow\", BT_FN_BOOL_LONG_LONG_LONGPTR, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "5ebeaf90ff5d0b9d47f1367455ca965a99535d63", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -1,3 +1,11 @@\n+2016-06-08  Martin Sebor  <msebor@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/70507\n+\tPR c/68120\n+\t* c-common.c (check_builtin_function_arguments): Handle\n+\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\n+\n 2016-06-08  Richard Biener  <rguenther@suse.de>\n \n \t* c-common.c (parse_optimize_options): Improve diagnostic messages."}, {"sha": "d008b040d0d071cd7b2c0a4645f355ec69feb3b3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -9989,6 +9989,23 @@ check_builtin_function_arguments (location_t loc, vec<location_t> arg_loc,\n \t}\n       return false;\n \n+    case BUILT_IN_ADD_OVERFLOW_P:\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+    case BUILT_IN_MUL_OVERFLOW_P:\n+      if (builtin_function_validate_nargs (loc, fndecl, nargs, 3))\n+\t{\n+\t  unsigned i;\n+\t  for (i = 0; i < 3; i++)\n+\t    if (!INTEGRAL_TYPE_P (TREE_TYPE (args[i])))\n+\t      {\n+\t\terror_at (ARG_LOCATION (i), \"argument %u in call to function \"\n+\t\t\t  \"%qE does not have integral type\", i + 1, fndecl);\n+\t\treturn false;\n+\t      }\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       return true;\n     }"}, {"sha": "4d302453ee474fab106f78db9df53467d4158de8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -1,3 +1,11 @@\n+2016-06-08  Martin Sebor  <msebor@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/70507\n+\tPR c/68120\n+\t* c-typeck.c (convert_arguments): Don't promote last argument\n+\tof BUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\n+\n 2016-06-08  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/71418"}, {"sha": "a681d7696d0d670bb6a658f09431ecb0f27fd863", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -3186,6 +3186,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n   const bool type_generic = fundecl\n     && lookup_attribute (\"type generic\", TYPE_ATTRIBUTES (TREE_TYPE (fundecl)));\n   bool type_generic_remove_excess_precision = false;\n+  bool type_generic_overflow_p = false;\n   tree selector;\n \n   /* Change pointer to function to the function itself for\n@@ -3215,8 +3216,15 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t  type_generic_remove_excess_precision = true;\n \t  break;\n \n+\tcase BUILT_IN_ADD_OVERFLOW_P:\n+\tcase BUILT_IN_SUB_OVERFLOW_P:\n+\tcase BUILT_IN_MUL_OVERFLOW_P:\n+\t  /* The last argument of these type-generic builtins\n+\t     should not be promoted.  */\n+\t  type_generic_overflow_p = true;\n+\t  break;\n+\n \tdefault:\n-\t  type_generic_remove_excess_precision = false;\n \t  break;\n \t}\n     }\n@@ -3466,9 +3474,12 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t      parmval = convert (double_type_node, val);\n \t    }\n \t}\n-      else if (excess_precision && !type_generic)\n+      else if ((excess_precision && !type_generic)\n+\t       || (type_generic_overflow_p && parmnum == 2))\n \t/* A \"double\" argument with excess precision being passed\n-\t   without a prototype or in variable arguments.  */\n+\t   without a prototype or in variable arguments.\n+\t   The last argument of __builtin_*_overflow_p should not be\n+\t   promoted.  */\n \tparmval = convert (valtype, val);\n       else if ((invalid_func_diag =\n \t\ttargetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))"}, {"sha": "4162e20ded7565b70575de474ee067aa0fe45921", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -1,3 +1,16 @@\n+2016-06-08  Martin Sebor  <msebor@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/70507\n+\tPR c/68120\n+\t* constexpr.c: Include gimple-fold.h.\n+\t(cxx_eval_internal_function): New function.\n+\t(cxx_eval_call_expression): Call it.\n+\t(potential_constant_expression_1): Handle integer arithmetic\n+\toverflow built-ins.\n+\t* tree.c (builtin_valid_in_constant_expr_p): Handle\n+\tBUILT_IN_{ADD,SUB,MUL}_OVERFLOW_P.\n+\n 2016-06-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* pt.c (tsubst, case TYPENAME_TYPE): Don't delay checking the"}, {"sha": "ba40435ef67d4ae130a83b5d0c5b809723027d9b", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 88, "deletions": 19, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-inline.h\"\n #include \"ubsan.h\"\n+#include \"gimple-fold.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -1255,6 +1256,69 @@ cx_error_context (void)\n   return r;\n }\n \n+/* Evaluate a call T to a GCC internal function when possible and return\n+   the evaluated result or, under the control of CTX, give an error, set\n+   NON_CONSTANT_P, and return the unevaluated call T otherwise.  */\n+\n+static tree\n+cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n+\t\t\t    bool lval,\n+\t\t\t    bool *non_constant_p, bool *overflow_p)\n+{\n+  enum tree_code opcode = ERROR_MARK;\n+\n+  switch (CALL_EXPR_IFN (t))\n+    {\n+    case IFN_UBSAN_NULL:\n+    case IFN_UBSAN_BOUNDS:\n+    case IFN_UBSAN_VPTR:\n+      return void_node;\n+\n+    case IFN_ADD_OVERFLOW:\n+      opcode = PLUS_EXPR;\n+      break;\n+    case IFN_SUB_OVERFLOW:\n+      opcode = MINUS_EXPR;\n+      break;\n+    case IFN_MUL_OVERFLOW:\n+      opcode = MULT_EXPR;\n+      break;\n+\n+    default:\n+      if (!ctx->quiet)\n+\terror_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t  \"call to internal function %qE\", t);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  /* Evaluate constant arguments using OPCODE and return a complex\n+     number containing the result and the overflow bit.  */\n+  tree arg0 = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 0), lval,\n+\t\t\t\t\t    non_constant_p, overflow_p);\n+  tree arg1 = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 1), lval,\n+\t\t\t\t\t    non_constant_p, overflow_p);\n+\n+  if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n+      tree type = TREE_TYPE (TREE_TYPE (t));\n+      tree result = fold_binary_loc (loc, opcode, type,\n+\t\t\t\t     fold_convert_loc (loc, type, arg0),\n+\t\t\t\t     fold_convert_loc (loc, type, arg1));\n+      tree ovf\n+\t= build_int_cst (type, arith_overflowed_p (opcode, type, arg0, arg1));\n+      /* Reset TREE_OVERFLOW to avoid warnings for the overflow.  */\n+      if (TREE_OVERFLOW (result))\n+\tTREE_OVERFLOW (result) = 0;\n+\n+      return build_complex (TREE_TYPE (t), result, ovf);\n+    }\n+\n+  *non_constant_p = true;\n+  return t;\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Evaluate the call expression tree T in the context of OLD_CALL expression\n    evaluation.  */\n@@ -1270,18 +1334,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   bool depth_ok;\n \n   if (fun == NULL_TREE)\n-    switch (CALL_EXPR_IFN (t))\n-      {\n-      case IFN_UBSAN_NULL:\n-      case IFN_UBSAN_BOUNDS:\n-      case IFN_UBSAN_VPTR:\n-\treturn void_node;\n-      default:\n-\tif (!ctx->quiet)\n-\t  error_at (loc, \"call to internal function\");\n-\t*non_constant_p = true;\n-\treturn t;\n-      }\n+    return cxx_eval_internal_function (ctx, t, lval,\n+\t\t\t\t       non_constant_p, overflow_p);\n \n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n@@ -4588,6 +4642,10 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \n \tif (fun == NULL_TREE)\n \t  {\n+\t    /* Reset to allow the function to continue past the end\n+\t       of the block below.  Otherwise return early.  */\n+\t    bool bail = true;\n+\n \t    if (TREE_CODE (t) == CALL_EXPR\n \t\t&& CALL_EXPR_FN (t) == NULL_TREE)\n \t      switch (CALL_EXPR_IFN (t))\n@@ -4598,16 +4656,27 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \t\tcase IFN_UBSAN_BOUNDS:\n \t\tcase IFN_UBSAN_VPTR:\n \t\t  return true;\n+\n+\t\tcase IFN_ADD_OVERFLOW:\n+\t\tcase IFN_SUB_OVERFLOW:\n+\t\tcase IFN_MUL_OVERFLOW:\n+\t\t  bail = false;\n+\n \t\tdefault:\n \t\t  break;\n \t\t}\n-\t    /* fold_call_expr can't do anything with IFN calls.  */\n-\t    if (flags & tf_error)\n-\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n-\t\t\t\"call to internal function\");\n-\t    return false;\n+\n+\t    if (bail)\n+\t      {\n+\t\t/* fold_call_expr can't do anything with IFN calls.  */\n+\t\tif (flags & tf_error)\n+\t\t  error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t    \"call to internal function %qE\", t);\n+\t\treturn false;\n+\t      }\n \t  }\n-\tif (is_overloaded_fn (fun))\n+\n+\tif (fun && is_overloaded_fn (fun))\n \t  {\n \t    if (TREE_CODE (fun) == FUNCTION_DECL)\n \t      {\n@@ -4652,7 +4721,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict,\n \t      i = num_artificial_parms_for (fun);\n \t    fun = DECL_ORIGIN (fun);\n \t  }\n-\telse\n+\telse if (fun)\n           {\n \t    if (RECUR (fun, rval))\n \t      /* Might end up being a constant function pointer.  */;"}, {"sha": "abda6e4f7294a488af588e8501d4d16f693bf0f9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -352,6 +352,12 @@ builtin_valid_in_constant_expr_p (const_tree decl)\n     case BUILT_IN_FUNCTION:\n     case BUILT_IN_LINE:\n \n+      /* The following built-ins are valid in constant expressions\n+\t when their arguments are.  */\n+    case BUILT_IN_ADD_OVERFLOW_P:\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+    case BUILT_IN_MUL_OVERFLOW_P:\n+\n       /* These have constant results even if their operands are\n \t non-constant.  */\n     case BUILT_IN_CONSTANT_P:"}, {"sha": "7da516d7827161aebc1b73d0f97e62d47e5b210e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -9869,6 +9869,47 @@ functions above, except they perform multiplication, instead of addition.\n \n @end deftypefn\n \n+The following built-in functions allow checking if simple arithmetic operation\n+would overflow.\n+\n+@deftypefn {Built-in Function} bool __builtin_add_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)\n+@deftypefnx {Built-in Function} bool __builtin_sub_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)\n+@deftypefnx {Built-in Function} bool __builtin_mul_overflow_p (@var{type1} a, @var{type2} b, @var{type3} c)\n+\n+These built-in functions are similar to @code{__builtin_add_overflow},\n+@code{__builtin_sub_overflow}, or @code{__builtin_mul_overflow}, except that\n+they don't store the result of the arithmetic operation anywhere and the\n+last argument is not a pointer, but some integral expression.\n+\n+The built-in functions promote the first two operands into infinite precision signed type\n+and perform addition on those promoted operands. The result is then\n+cast to the type of the third argument.  If the cast result is equal to the infinite\n+precision result, the built-in functions return false, otherwise they return true.\n+The value of the third argument is ignored, just the side-effects in the third argument\n+are evaluated, and no integral argument promotions are performed on the last argument.\n+\n+For example, the following macro can be used to portably check, at\n+compile-time, whether or not adding two constant integers will overflow,\n+and perform the addition only when it is known to be safe and not to trigger\n+a @option{-Woverflow} warning.\n+\n+@smallexample\n+#define INT_ADD_OVERFLOW_P(a, b) \\\n+   __builtin_add_overflow_p (a, b, (__typeof__ ((a) + (b))) 0)\n+\n+enum @{\n+    A = INT_MAX, B = 3,\n+    C = INT_ADD_OVERFLOW_P (A, B) ? 0 : A + B,\n+    D = __builtin_add_overflow_p (1, SCHAR_MAX, (signed char) 0)\n+@};\n+@end smallexample\n+\n+The compiler will attempt to use hardware instructions to implement\n+these built-in functions where possible, like conditional jump on overflow\n+after addition, conditional jump on carry etc.\n+ \n+@end deftypefn\n+\n @node x86 specific memory model extensions for transactional memory\n @section x86-Specific Memory Model Extensions for Transactional Memory\n "}, {"sha": "cb704589debb9b01a63d3eeb669f6a6dfc291912", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -1,3 +1,14 @@\n+2016-06-08  Martin Sebor  <msebor@redhat.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/70507\n+\tPR c/68120\n+\t* c-c++-common/builtin-arith-overflow-1.c: Add test cases.\n+\t* c-c++-common/builtin-arith-overflow-2.c: New test.\n+\t* g++.dg/ext/builtin-arith-overflow-1.C: New test.\n+\t* g++.dg/cpp0x/constexpr-arith-overflow.C: New test.\n+\t* g++.dg/cpp1y/constexpr-arith-overflow.C: New test.\n+\n 2016-06-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71442"}, {"sha": "0d97f6a9fad4a5619ce22fd8c8f4d38539cfc5b1", "filename": "gcc/testsuite/c-c++-common/builtin-arith-overflow-1.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-1.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -6,6 +6,9 @@ f1 (void)\n   int x = __builtin_add_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n   x += __builtin_sub_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n   x += __builtin_mul_overflow ();\t/* { dg-error \"not enough arguments to function\" } */\n+  x += __builtin_add_overflow_p ();\t/* { dg-error \"not enough arguments to function\" } */\n+  x += __builtin_sub_overflow_p ();\t/* { dg-error \"not enough arguments to function\" } */\n+  x += __builtin_mul_overflow_p ();\t/* { dg-error \"not enough arguments to function\" } */\n   return x;\n }\n \n@@ -15,6 +18,10 @@ f2 (int a, int b, int *c, int d)\n   int x = __builtin_add_overflow (a, b, c, d);\t/* { dg-error \"too many arguments to function\" } */\n   x += __builtin_sub_overflow (a, b, c, d, d, d);\t/* { dg-error \"too many arguments to function\" } */\n   x += __builtin_mul_overflow (a, b, c, d);\t/* { dg-error \"too many arguments to function\" } */\n+  x += __builtin_add_overflow_p (a, b, d, d);\t/* { dg-error \"too many arguments to function\" } */\n+  x += __builtin_sub_overflow_p (a, b, d, d, 1, d);\t/* { dg-error \"too many arguments to function\" } */\n+  x += __builtin_mul_overflow_p (a, b, d, d);\t/* { dg-error \"too many arguments to function\" } */\n+  \n   return x;\n }\n \n@@ -33,6 +40,15 @@ f3 (float fa, int a, _Complex long int ca, double fb, void *pb, int b, enum E eb\n   x += __builtin_add_overflow (a, pb, c);\t/* { dg-error \"argument 2 in call to function\\[^\\n\\r]*does not have integral type\" } */\n   x += __builtin_sub_overflow (a, eb, c);\n   x += __builtin_mul_overflow (a, bb, c);\n+  x += __builtin_add_overflow_p (fa, b, a);\t/* { dg-error \"argument 1 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_sub_overflow_p (ca, b, eb);\t/* { dg-error \"argument 1 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_mul_overflow_p (a, fb, bb);\t/* { dg-error \"argument 2 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_add_overflow_p (a, pb, a);\t/* { dg-error \"argument 2 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_sub_overflow_p (a, eb, eb);\n+  x += __builtin_mul_overflow_p (a, bb, bb);\n+  x += __builtin_add_overflow_p (a, b, fa);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_sub_overflow_p (a, b, ca);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have integral type\" } */\n+  x += __builtin_mul_overflow_p (a, b, c);\t/* { dg-error \"argument 3 in call to function\\[^\\n\\r]*does not have integral type\" } */\n   return x;\n }\n "}, {"sha": "4cbceff3ed2fdc32c31127bd28d948e5dd5325c0", "filename": "gcc/testsuite/c-c++-common/builtin-arith-overflow-2.c", "status": "added", "additions": 493, "deletions": 0, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-arith-overflow-2.c?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -0,0 +1,493 @@\n+/* PR c/68120 - can't easily deal with integer overflow at compile time */\n+/* { dg-do run } */\n+/* { dg-additional-options \"-Wno-long-long\" } */\n+\n+#define SCHAR_MAX    __SCHAR_MAX__\n+#define SHRT_MAX     __SHRT_MAX__\n+#define INT_MAX\t     __INT_MAX__\n+#define LONG_MAX     __LONG_MAX__\n+#define LLONG_MAX    __LONG_LONG_MAX__\n+\t\n+#define SCHAR_MIN    (-__SCHAR_MAX__ - 1)\n+#define SHRT_MIN     (-__SHRT_MAX__ - 1)\n+#define INT_MIN\t     (-__INT_MAX__ - 1)\n+#define LONG_MIN     (-__LONG_MAX__ - 1)\n+#define LLONG_MIN    (-__LONG_LONG_MAX__ - 1)\n+\t\n+#define UCHAR_MAX    (SCHAR_MAX * 2U + 1)\n+#define USHRT_MAX    (SHRT_MAX * 2U + 1)\n+#define UINT_MAX     (INT_MAX * 2U + 1)\n+#define ULONG_MAX    (LONG_MAX * 2LU + 1)\n+#define ULLONG_MAX   (LLONG_MAX * 2LLU + 1)\n+\t\n+#define USCHAR_MIN   (-__USCHAR_MAX__ - 1)\n+#define USHRT_MIN    (-__USHRT_MAX__ - 1)\n+#define UINT_MIN     (-__UINT_MAX__ - 1)\n+#define ULONG_MIN    (-__ULONG_MAX__ - 1)\n+#define ULLONG_MIN   (-__ULONG_LONG_MAX__ - 1)\n+\n+/* Number of failed runtime assertions.  */\n+int nfails;\n+\n+void __attribute__ ((noclone, noinline))\n+runtime_assert (int expr, int line)\n+{\n+  if (!expr)\n+    {\n+      __builtin_printf (\"line %i: assertion failed\\n\", line);\n+      ++nfails;\n+    }\n+}\n+\n+/* Helper macros for run-time testing.  */\n+#define add(x, y) ((x) + (y))\n+#define sadd(x, y) ((x) + (y))\n+#define saddl(x, y) ((x) + (y))\n+#define saddll(x, y) ((x) + (y))\n+#define uadd(x, y) ((x) + (y))\n+#define uaddl(x, y) ((x) + (y))\n+#define uaddll(x, y) ((x) + (y))\n+#define sub(x, y) ((x) - (y))\n+#define ssub(x, y) ((x) - (y))\n+#define ssubl(x, y) ((x) - (y))\n+#define ssubll(x, y) ((x) - (y))\n+#define usub(x, y) ((x) - (y))\n+#define usubl(x, y) ((x) - (y))\n+#define usubll(x, y) ((x) - (y))\n+#define mul(x, y) ((x) * (y))\n+#define smul(x, y) ((x) * (y))\n+#define smull(x, y) ((x) * (y))\n+#define smulll(x, y) ((x) * (y))\n+#define umul(x, y) ((x) * (y))\n+#define umull(x, y) ((x) * (y))\n+#define umulll(x, y) ((x) * (y))\n+\n+int main (void)\n+{\n+\n+#if __cplusplus >= 201103L\n+#  define StaticAssert(expr) static_assert ((expr), #expr)\n+#elif __STDC_VERSION__ >= 201112L\n+#  define StaticAssert(expr) _Static_assert ((expr), #expr)\n+#else\n+  /* The following pragma has no effect due to bug 70888 - #pragma\n+     diagnostic ignored -Wlong-long ineffective with __LONG_LONG_MAX__\n+     in c++98 mode.  */\n+#  pragma GCC diagnostic ignored \"-Wlong-long\"\n+#  pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n+\n+#  define CONCAT(a, b)  a ## b\n+#  define CAT(a, b)     CONCAT (a, b)\n+#  define StaticAssert(expr)\t\t\t\t\t\\\n+     typedef int CAT (StaticAssert_, __LINE__) [1 - 2 * !(expr)]\n+#endif\n+\n+  /* Make extra effort to prevent constant folding seeing the constant\n+     values of the arguments and optimizing the run-time test into\n+     a constant.  */\n+#define RuntimeAssert(op, T, U, x, y, vflow)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    volatile T a = (x), b = (y);\t\t\t\t\t\\\n+    U c = 0;\t\t\t\t\t\t\t\t\\\n+    volatile int vf = __builtin_ ## op ## _overflow (a, b, &c);\t\t\\\n+    runtime_assert ((vf == vflow), __LINE__);\t\t\t\t\\\n+    if (vf == 0)\t\t\t\t\t\t\t\\\n+      runtime_assert (op (a, b) == c, __LINE__);\t\t\t\\\n+  } while (0)\n+\n+  /* Verify that each call to the type-generic __builtin_op_overflow(x, y)\n+     yields a constant expression equal to z indicating whether or not\n+     the constant expression (x op y) overflows when evaluated in type T.  */\n+#  define G_TEST(op, T, x, y, vflow)\t\t\t\t\t\\\n+  RuntimeAssert(op, __typeof__ (op (x, y)), T, x, y, vflow);\t\t\\\n+  StaticAssert ((vflow) == __builtin_ ## op ## _overflow_p ((x), (y), (T)0))\n+\n+  /* Addition.  */\n+  G_TEST (add, signed char,    0,         0,         0);\n+  G_TEST (add, signed char,    0,         SCHAR_MAX, 0);\n+  G_TEST (add, signed char,    1,         SCHAR_MAX, 1);\n+  G_TEST (add, signed char,    SCHAR_MAX, SCHAR_MAX, 1);\n+  G_TEST (add, signed char,    0,         SCHAR_MIN, 0);\n+  G_TEST (add, signed char,   -1,         SCHAR_MIN, 1);\n+  /* Verify any slicing in the result type doesn't prevent the overflow\n+     from being detected.  */\n+  G_TEST (add, signed char,    UCHAR_MAX + 1, 0,     1);\n+  G_TEST (add, signed char,    UCHAR_MAX + 1, 1,     1);\n+  G_TEST (add, signed char,    1, UCHAR_MAX + 1,     1);\n+\n+  G_TEST (add, unsigned char,  0,        0,          0);\n+  /* Verify any slicing in the result type doesn't prevent the overflow\n+     from being detected.  */\n+  G_TEST (add, unsigned char,  UCHAR_MAX + 1, 0,     1);\n+  G_TEST (add, unsigned char,  UCHAR_MAX + 1, 1,     1);\n+  G_TEST (add, unsigned char,  1, UCHAR_MAX + 1,     1);\n+\n+  G_TEST (add, short,          0,         0,         0);\n+  G_TEST (add, short,          0,         SHRT_MAX,  0);\n+  G_TEST (add, short,          1,         SHRT_MAX,  1);\n+  G_TEST (add, short,          SHRT_MAX,  SHRT_MAX,  1);\n+  G_TEST (add, short,          0,         SHRT_MIN,  0);\n+  G_TEST (add, short,         -1,         SHRT_MIN,  1);\n+  G_TEST (add, short,          SHRT_MIN,  SHRT_MIN,  1);\n+\n+  G_TEST (add, int,            0,         0,         0);\n+  G_TEST (add, int,            0,         INT_MAX,   0);\n+  G_TEST (add, int,            1,         INT_MAX,   1);\n+  G_TEST (add, int,            INT_MAX,   INT_MAX,   1);\n+  G_TEST (add, int,            0,         INT_MIN,   0);\n+  G_TEST (add, int,           -1,         INT_MIN,   1);\n+  G_TEST (add, int,            INT_MIN,   INT_MIN,   1);\n+\n+  G_TEST (add, long,           0,         0,         0);\n+  G_TEST (add, long,           0,         LONG_MAX,  0);\n+  G_TEST (add, long,           1,         LONG_MAX,  1);\n+  G_TEST (add, long,           LONG_MAX,  LONG_MAX,  1);\n+  G_TEST (add, long,           0,         LONG_MIN,  0);\n+  G_TEST (add, long,          -1,         LONG_MIN,  1);\n+  G_TEST (add, long,           LONG_MIN,  LONG_MIN,  1);\n+\n+  G_TEST (add, long long,      0,         0,          0);\n+  G_TEST (add, long long,      0,         LLONG_MAX,  0);\n+  G_TEST (add, long long,      1,         LLONG_MAX,  1);\n+  G_TEST (add, long long,      LLONG_MAX, LLONG_MAX,  1);\n+  G_TEST (add, long long,      0,         LLONG_MIN,  0);\n+  G_TEST (add, long long,     -1,         LLONG_MIN,  1);\n+  G_TEST (add, long long,      LLONG_MIN, LLONG_MIN,  1);\n+\n+  /* Subtraction */\n+  G_TEST (sub, unsigned char,  0,         0,          0);\n+  G_TEST (sub, unsigned char,  0,         UCHAR_MAX,  1);\n+  G_TEST (sub, unsigned char,  1,         UCHAR_MAX,  1);\n+\n+  G_TEST (sub, unsigned char,  UCHAR_MAX, UCHAR_MAX,  0);\n+  G_TEST (sub, unsigned short, 0,         0,          0);\n+  G_TEST (sub, unsigned short, 0,         USHRT_MAX,  1);\n+  G_TEST (sub, unsigned short, 1,         USHRT_MAX,  1);\n+  G_TEST (sub, unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+  G_TEST (sub, unsigned,       0,         0,          0);\n+  G_TEST (sub, unsigned,       0,         UINT_MAX,   1);\n+  G_TEST (sub, unsigned,       1,         UINT_MAX,   1);\n+  G_TEST (sub, unsigned,       UINT_MAX,  UINT_MAX,   0);\n+\n+  G_TEST (sub, unsigned long,  0,         0,          0);\n+  G_TEST (sub, unsigned long,  0,         ULONG_MAX,  1);\n+  G_TEST (sub, unsigned long,  1,         ULONG_MAX,  1);\n+  G_TEST (sub, unsigned long,  ULONG_MAX, ULONG_MAX,  0);\n+\n+  G_TEST (sub, unsigned long long,  0,          0,          0);\n+  G_TEST (sub, unsigned long long,  0,          ULLONG_MAX, 1);\n+  G_TEST (sub, unsigned long long,  1,          ULLONG_MAX, 1);\n+  G_TEST (sub, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 0);\n+\n+  G_TEST (sub, signed char,    0,         0,           0);\n+  G_TEST (sub, signed char,    0,         SCHAR_MAX,   0);\n+  G_TEST (sub, signed char,    1,         SCHAR_MAX,   0);\n+  G_TEST (sub, signed char,    SCHAR_MAX, SCHAR_MAX,   0);\n+  G_TEST (sub, signed char,    SCHAR_MIN,         1,   1);\n+  G_TEST (sub, signed char,    0,         SCHAR_MIN,   1);\n+  G_TEST (sub, signed char,   -1,         SCHAR_MIN,   0);\n+\n+  G_TEST (sub, short,          0,         0,           0);\n+  G_TEST (sub, short,          0,         SHRT_MAX,    0);\n+  G_TEST (sub, short,          1,         SHRT_MAX,    0);\n+  G_TEST (sub, short,          SHRT_MAX,  SHRT_MAX,    0);\n+  G_TEST (sub, short,          0,         SHRT_MIN,    1);\n+  G_TEST (sub, short,         -1,         SHRT_MIN,    0);\n+  G_TEST (sub, short,          SHRT_MIN,  SHRT_MIN,    0);\n+\n+  G_TEST (sub, int,            0,         0,           0);\n+  G_TEST (sub, int,            0,         INT_MAX,     0);\n+  G_TEST (sub, int,            1,         INT_MAX,     0);\n+  G_TEST (sub, int,            INT_MAX,   INT_MAX,     0);\n+  G_TEST (sub, int,            0,         INT_MIN,     1);\n+  G_TEST (sub, int,           -1,         INT_MIN,     0);\n+  G_TEST (sub, int,            INT_MIN,   INT_MIN,     0);\n+\n+  G_TEST (sub, long,           0,         0,           0);\n+  G_TEST (sub, long,           0,         LONG_MAX,    0);\n+  G_TEST (sub, long,           1,         LONG_MAX,    0);\n+  G_TEST (sub, long,           LONG_MAX,  LONG_MAX,    0);\n+  G_TEST (sub, long,           0,         LONG_MIN,    1);\n+  G_TEST (sub, long,          -1,         LONG_MIN,    0);\n+  G_TEST (sub, long,           LONG_MIN,  LONG_MIN,    0);\n+\n+  G_TEST (sub, long long,      0,           0,           0);\n+  G_TEST (sub, long long,      0,           LLONG_MAX,   0);\n+  G_TEST (sub, long long,      1,           LLONG_MAX,   0);\n+  G_TEST (sub, long long,      LLONG_MAX,   LLONG_MAX,   0);\n+  G_TEST (sub, long long,      0,           LLONG_MIN,   1);\n+  G_TEST (sub, long long,     -1,           LLONG_MIN,   0);\n+  G_TEST (sub, long long,      LLONG_MIN,   LLONG_MIN,   0);\n+\n+  G_TEST (sub, unsigned char,  0,         0,          0);\n+  G_TEST (sub, unsigned char,  0,         UCHAR_MAX,  1);\n+  G_TEST (sub, unsigned char,  1,         UCHAR_MAX,  1);\n+  G_TEST (sub, unsigned char,  UCHAR_MAX, UCHAR_MAX,  0);\n+\n+  G_TEST (sub, unsigned short, 0,         0,          0);\n+  G_TEST (sub, unsigned short, 0,         USHRT_MAX,  1);\n+  G_TEST (sub, unsigned short, 1,         USHRT_MAX,  1);\n+  G_TEST (sub, unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+  G_TEST (sub, unsigned,       0,         0,          0);\n+  G_TEST (sub, unsigned,       0,         UINT_MAX,   1);\n+  G_TEST (sub, unsigned,       1,         UINT_MAX,   1);\n+  G_TEST (sub, unsigned,       UINT_MAX,  UINT_MAX,   0);\n+\n+  G_TEST (sub, unsigned long,  0,         0,          0);\n+  G_TEST (sub, unsigned long,  0,         ULONG_MAX,  1);\n+  G_TEST (sub, unsigned long,  1,         ULONG_MAX,  1);\n+  G_TEST (sub, unsigned long,  ULONG_MAX, ULONG_MAX,  0);\n+\n+  G_TEST (sub, unsigned long long,  0,          0,          0);\n+  G_TEST (sub, unsigned long long,  0,          ULLONG_MAX, 1);\n+  G_TEST (sub, unsigned long long,  1,          ULLONG_MAX, 1);\n+  G_TEST (sub, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 0);\n+\n+  /* Multiplication.  */\n+  G_TEST (mul, unsigned char,  0,         0,          0);\n+  G_TEST (mul, unsigned char,  0,         UCHAR_MAX,  0);\n+  G_TEST (mul, unsigned char,  1,         UCHAR_MAX,  0);\n+  G_TEST (mul, unsigned char,  2,         UCHAR_MAX,  1);\n+  G_TEST (mul, unsigned char,  UCHAR_MAX, UCHAR_MAX,  1);\n+\n+  G_TEST (mul, unsigned short, 0,         0,          0);\n+  G_TEST (mul, unsigned short, 0,         USHRT_MAX,  0);\n+  G_TEST (mul, unsigned short, 1,         USHRT_MAX,  0);\n+  G_TEST (mul, unsigned short, USHRT_MAX, 2,          1);\n+  G_TEST (mul, unsigned short, USHRT_MAX, USHRT_MAX,  1);\n+\n+  G_TEST (mul, unsigned,       0,         0,          0);\n+  G_TEST (mul, unsigned,       0,         UINT_MAX,   0);\n+  G_TEST (mul, unsigned,       1,         UINT_MAX,   0);\n+  G_TEST (mul, unsigned,       2,         UINT_MAX,   1);\n+  G_TEST (mul, unsigned,       UINT_MAX,  UINT_MAX,   1);\n+\n+  G_TEST (mul, unsigned long,  0,         0,          0);\n+  G_TEST (mul, unsigned long,  0,         ULONG_MAX,  0);\n+  G_TEST (mul, unsigned long,  1,         ULONG_MAX,  0);\n+  G_TEST (mul, unsigned long,  2,         ULONG_MAX,  1);\n+  G_TEST (mul, unsigned long,  ULONG_MAX, ULONG_MAX,  1);\n+\n+  G_TEST (mul, unsigned long long,  0,          0,          0);\n+  G_TEST (mul, unsigned long long,  0,          ULLONG_MAX, 0);\n+  G_TEST (mul, unsigned long long,  1,          ULLONG_MAX, 0);\n+  G_TEST (mul, unsigned long long,  2,          ULLONG_MAX, 1);\n+  G_TEST (mul, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 1);\n+\n+  G_TEST (mul, signed char,  0,         0,           0);\n+  G_TEST (mul, signed char,  0,         SCHAR_MAX,   0);\n+  G_TEST (mul, signed char,  1,         SCHAR_MAX,   0);\n+  G_TEST (mul, signed char,  SCHAR_MAX, SCHAR_MAX,   1);\n+  G_TEST (mul, signed char,  SCHAR_MIN,         1,   0);\n+  G_TEST (mul, signed char,  0,         SCHAR_MIN,   0);\n+  G_TEST (mul, signed char, -1,         SCHAR_MIN,   1);\n+\n+  G_TEST (mul, short,        0,         0,           0);\n+  G_TEST (mul, short,        0,         SHRT_MAX,    0);\n+  G_TEST (mul, short,        1,         SHRT_MAX,    0);\n+  G_TEST (mul, short,        SHRT_MAX,  SHRT_MAX,    1);\n+  G_TEST (mul, short,        0,         SHRT_MIN,    0);\n+  G_TEST (mul, short,       -1,         SHRT_MIN,    1);\n+  G_TEST (mul, short,        SHRT_MIN,  SHRT_MIN,    1);\n+\n+  G_TEST (mul, int,          0,         0,           0);\n+  G_TEST (mul, int,          0,         INT_MAX,     0);\n+  G_TEST (mul, int,          1,         INT_MAX,     0);\n+  G_TEST (mul, int,          INT_MAX,   INT_MAX,     1);\n+  G_TEST (mul, int,          0,         INT_MIN,     0);\n+  G_TEST (mul, int,         -1,         INT_MIN,     1);\n+  G_TEST (mul, int,          INT_MIN,   INT_MIN,     1);\n+\n+  G_TEST (mul, long,         0,         0,           0);\n+  G_TEST (mul, long,         0,         LONG_MAX,    0);\n+  G_TEST (mul, long,         1,         LONG_MAX,    0);\n+  G_TEST (mul, long,         LONG_MAX,  LONG_MAX,    1);\n+  G_TEST (mul, long,         0,         LONG_MIN,    0);\n+  G_TEST (mul, long,        -1,         LONG_MIN,    1);\n+  G_TEST (mul, long,         LONG_MIN,  LONG_MIN,    1);\n+\n+  G_TEST (mul, long long,    0,           0,           0);\n+  G_TEST (mul, long long,    0,           LLONG_MAX,   0);\n+  G_TEST (mul, long long,    1,           LLONG_MAX,   0);\n+  G_TEST (mul, long long,    LLONG_MAX,   LLONG_MAX,   1);\n+  G_TEST (mul, long long,    0,           LLONG_MIN,   0);\n+  G_TEST (mul, long long,   -1,           LLONG_MIN,   1);\n+  G_TEST (mul, long long,    LLONG_MIN,   LLONG_MIN,   1);\n+\n+  G_TEST (mul, unsigned char,  0,         0,          0);\n+  G_TEST (mul, unsigned char,  0,         UCHAR_MAX,  0);\n+  G_TEST (mul, unsigned char,  1,         UCHAR_MAX,  0);\n+  G_TEST (mul, unsigned char,  UCHAR_MAX, UCHAR_MAX,  1);\n+\n+  G_TEST (mul, unsigned short, 0,         0,          0);\n+  G_TEST (mul, unsigned short, 0,         USHRT_MAX,  0);\n+  G_TEST (mul, unsigned short, 1,         USHRT_MAX,  0);\n+  G_TEST (mul, unsigned short, USHRT_MAX, USHRT_MAX,  1);\n+\n+  G_TEST (mul, unsigned,       0,         0,          0);\n+  G_TEST (mul, unsigned,       0,         UINT_MAX,   0);\n+  G_TEST (mul, unsigned,       1,         UINT_MAX,   0);\n+  G_TEST (mul, unsigned,       UINT_MAX,  UINT_MAX,   1);\n+\n+  G_TEST (mul, unsigned long,  0,         0,          0);\n+  G_TEST (mul, unsigned long,  0,         ULONG_MAX,  0);\n+  G_TEST (mul, unsigned long,  1,         ULONG_MAX,  0);\n+  G_TEST (mul, unsigned long,  ULONG_MAX, ULONG_MAX,  1);\n+\n+  G_TEST (mul, unsigned long long,  0,          0,          0);\n+  G_TEST (mul, unsigned long long,  0,          ULLONG_MAX, 0);\n+  G_TEST (mul, unsigned long long,  1,          ULLONG_MAX, 0);\n+  G_TEST (mul, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 1);\n+\n+  /* Verify that each call to the type-specific __builtin_op_overflow\n+     evaluates to a (not-necessarily constant) expression indicating\n+     whether or not the constant expression (x op y) overflows.\n+     The type-specific forms of the built-ins detect overflow after\n+     arithmetic promotions and so unlike the type-generic overloads\n+     cannot detect overflow in char or short types.  */\n+\n+#define T_TEST(op, T, x, y, vflow)\t\t\t\t\\\n+  RuntimeAssert (op, T, __typeof__ ((x) + (y)), x, y, vflow)\n+\n+  /* Signed int addition.  */\n+  T_TEST (sadd,   signed char,    0,         0,         0);\n+  T_TEST (sadd,   signed char,    0,         SCHAR_MAX, 0);\n+  T_TEST (sadd,   signed char,    1,         SCHAR_MAX, 0);\n+  T_TEST (sadd,   signed char,    SCHAR_MAX, SCHAR_MAX, 0);\n+  T_TEST (sadd,   signed char,    0,         SCHAR_MIN, 0);\n+  T_TEST (sadd,   signed char,   -1,         SCHAR_MIN, 0);\n+\n+  T_TEST (sadd,   short,          0,         0,         0);\n+  T_TEST (sadd,   short,          0,         SHRT_MAX,  0);\n+  T_TEST (sadd,   short,          1,         SHRT_MAX,  0);\n+  T_TEST (sadd,   short,          SHRT_MAX,  SHRT_MAX,  0);\n+  T_TEST (sadd,   short,          0,         SHRT_MIN,  0);\n+  T_TEST (sadd,   short,         -1,         SHRT_MIN,  0);\n+  T_TEST (sadd,   short,          SHRT_MIN,  SHRT_MIN,  0);\n+\n+  T_TEST (sadd,   int,            0,         0,         0);\n+  T_TEST (sadd,   int,            0,         INT_MAX,   0);\n+  T_TEST (sadd,   int,            1,         INT_MAX,   1);\n+  T_TEST (sadd,   int,            INT_MAX,   INT_MAX,   1);\n+  T_TEST (sadd,   int,            0,         INT_MIN,   0);\n+  T_TEST (sadd,   int,           -1,         INT_MIN,   1);\n+  T_TEST (sadd,   int,            INT_MIN,   INT_MIN,   1);\n+\n+  /* Signed long addition.  */\n+  T_TEST (saddl,  long,           0L,        0L,        0);\n+  T_TEST (saddl,  long,           0L,        LONG_MAX,  0);\n+  T_TEST (saddl,  long,           1L,        LONG_MAX,  1);\n+  T_TEST (saddl,  long,           LONG_MAX,  LONG_MAX,  1);\n+  T_TEST (saddl,  long,           0L,        LONG_MIN,  0);\n+  T_TEST (saddl,  long,          -1L,        LONG_MIN,  1);\n+  T_TEST (saddl,  long,           LONG_MIN,  LONG_MIN,  1);\n+\n+  T_TEST (saddll, long long,      0LL,       0LL,        0);\n+  T_TEST (saddll, long long,      0LL,       LLONG_MAX,  0);\n+  T_TEST (saddll, long long,      1LL,       LLONG_MAX,  1);\n+  T_TEST (saddll, long long,      LLONG_MAX, LLONG_MAX,  1);\n+  T_TEST (saddll, long long,      0LL,       LLONG_MIN,  0);\n+  T_TEST (saddll, long long,     -1LL,       LLONG_MIN,  1);\n+  T_TEST (saddll, long long,      LLONG_MIN, LLONG_MIN,  1);\n+\n+  /* Unsigned int addition.  */\n+  T_TEST (uadd,   unsigned char,  0U,        0U,         0);\n+  T_TEST (uadd,   unsigned char,  0U,        UCHAR_MAX, 0);\n+  T_TEST (uadd,   unsigned char,  1U,        UCHAR_MAX, 0);\n+  T_TEST (uadd,   unsigned char,  UCHAR_MAX, UCHAR_MAX, 0);\n+\n+  T_TEST (uadd,   unsigned short, 0U,        0U,         0);\n+  T_TEST (uadd,   unsigned short, 0U,        USHRT_MAX,  0);\n+  T_TEST (uadd,   unsigned short, 1U,        USHRT_MAX,  0);\n+  T_TEST (uadd,   unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+  T_TEST (uadd,   unsigned,       0U,        0U,         0);\n+  T_TEST (uadd,   unsigned,       0U,        UINT_MAX,   0);\n+  T_TEST (uadd,   unsigned,       1U,        UINT_MAX,   1);\n+  T_TEST (uadd,   unsigned,       UINT_MAX,  UINT_MAX,   1);\n+\n+  /* Unsigned long addition.  */\n+  T_TEST (uaddl,  unsigned long,  0UL,       0UL,       0);\n+  T_TEST (uaddl,  unsigned long,  0UL,       ULONG_MAX, 0);\n+  T_TEST (uaddl,  unsigned long,  1UL,       ULONG_MAX, 1);\n+  T_TEST (uaddl,  unsigned long,  ULONG_MAX, ULONG_MAX, 1);\n+\n+  T_TEST (uaddll, unsigned long long, 0ULL,       0ULL,       0);\n+  T_TEST (uaddll, unsigned long long, 0ULL,       ULLONG_MAX, 0);\n+  T_TEST (uaddll, unsigned long long, 1ULL,       ULLONG_MAX, 1);\n+  T_TEST (uaddll, unsigned long long, ULLONG_MAX, ULLONG_MAX, 1);\n+\n+  /* Signed int subtraction.  */\n+  T_TEST (ssub,   signed char,    0,         0,          0);\n+  T_TEST (ssub,   signed char,    0,         SCHAR_MAX,  0);\n+  T_TEST (ssub,   signed char,    1,         SCHAR_MAX,  0);\n+  T_TEST (ssub,   signed char,    SCHAR_MAX, SCHAR_MAX,  0);\n+  T_TEST (ssub,   signed char,    0,         SCHAR_MIN,  0);\n+  T_TEST (ssub,   signed char,   -1,         SCHAR_MIN,  0);\n+\n+  T_TEST (ssub,   short,          0,         0,          0);\n+  T_TEST (ssub,   short,          0,         SHRT_MAX,   0);\n+  T_TEST (ssub,   short,          1,         SHRT_MAX,   0);\n+  T_TEST (ssub,   short,          SHRT_MAX,  SHRT_MAX,   0);\n+  T_TEST (ssub,   short,          0,         SHRT_MIN,   0);\n+  T_TEST (ssub,   short,         -1,         SHRT_MIN,   0);\n+  T_TEST (ssub,   short,          SHRT_MIN,  SHRT_MIN,   0);\n+\n+  T_TEST (ssub,   int,            0,         0,          0);\n+  T_TEST (ssub,   int,            0,         INT_MAX,    0);\n+  T_TEST (ssub,   int,            1,         INT_MAX,    0);\n+  T_TEST (ssub,   int,            INT_MAX,   INT_MAX,    0);\n+  T_TEST (ssub,   int,            0,         INT_MIN,    1);\n+  T_TEST (ssub,   int,           -1,         INT_MIN,    0);\n+  T_TEST (ssub,   int,            INT_MIN,   INT_MIN,    0);\n+\n+  /* Signed long subtraction.  */\n+  T_TEST (ssubl,  long,           0L,        0L,         0);\n+  T_TEST (ssubl,  long,           0L,        LONG_MAX,   0);\n+  T_TEST (ssubl,  long,           1L,        LONG_MAX,   0);\n+  T_TEST (ssubl,  long,           LONG_MAX,  LONG_MAX,   0);\n+  T_TEST (ssubl,  long,           0L,        LONG_MIN,   1);\n+  T_TEST (ssubl,  long,          -1L,        LONG_MIN,   0);\n+  T_TEST (ssubl,  long,           LONG_MIN,  LONG_MIN,   0);\n+\n+  /* Signed long long subtraction.  */\n+  T_TEST (ssubll, long long,      0LL,       0LL,        0);\n+  T_TEST (ssubll, long long,      0LL,       LLONG_MAX,  0);\n+  T_TEST (ssubll, long long,      1LL,       LLONG_MAX,  0);\n+  T_TEST (ssubll, long long,      LLONG_MAX, LLONG_MAX,  0);\n+  T_TEST (ssubll, long long,      0LL,       LLONG_MIN,  1);\n+  T_TEST (ssubll, long long,     -1LL,       LLONG_MIN,  0);\n+  T_TEST (ssubll, long long,      LLONG_MIN, LLONG_MIN,  0);\n+\n+  /* Unsigned int subtraction.  */\n+  T_TEST (usub,   unsigned char,  0U,        0U,         0);\n+  T_TEST (usub,   unsigned char,  0U,        UCHAR_MAX,  1);\n+  T_TEST (usub,   unsigned char,  1U,        UCHAR_MAX,  1);\n+  T_TEST (usub,   unsigned char,  UCHAR_MAX, UCHAR_MAX,  0);\n+\n+  T_TEST (usub,   unsigned short, 0U,        0U,         0);\n+  T_TEST (usub,   unsigned short, 0U,        USHRT_MAX,  1);\n+  T_TEST (usub,   unsigned short, 1U,        USHRT_MAX,  1);\n+  T_TEST (usub,   unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+  T_TEST (usub,   unsigned,       0U,        0U,         0);\n+  T_TEST (usub,   unsigned,       0U,        UINT_MAX,   1);\n+  T_TEST (usub,   unsigned,       1U,        UINT_MAX,   1);\n+  T_TEST (usub,   unsigned,       UINT_MAX,  UINT_MAX,   0);\n+\n+  /* Unsigned long subtraction.  */\n+  T_TEST (usubl,  unsigned long,  0UL,       0UL,       0);\n+  T_TEST (usubl,  unsigned long,  0UL,       ULONG_MAX, 1);\n+  T_TEST (usubl,  unsigned long,  1UL,       ULONG_MAX, 1);\n+  T_TEST (usubl,  unsigned long,  ULONG_MAX, ULONG_MAX, 0);\n+\n+  /* Unsigned long long subtraction.  */\n+  T_TEST (usubll, unsigned long long,  0ULL,       0ULL,       0);\n+  T_TEST (usubll, unsigned long long,  0ULL,       ULLONG_MAX, 1);\n+  T_TEST (usubll, unsigned long long,  1ULL,       ULLONG_MAX, 1);\n+  T_TEST (usubll, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 0);\n+\n+  return 0;\n+}"}, {"sha": "a63c0a1ef540d96ba82c8bcaa3963c3f7b3a91e7", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-arith-overflow.C", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -0,0 +1,212 @@\n+// PR c++/70507 - integer overflow builtins not constant expressions\n+// { dg-do compile { target c++11 } }\n+\n+#define SCHAR_MAX    __SCHAR_MAX__\n+#define SHRT_MAX     __SHRT_MAX__\n+#define INT_MAX\t     __INT_MAX__\n+#define LONG_MAX     __LONG_MAX__\n+#define LLONG_MAX    __LONG_LONG_MAX__\n+\t\n+#define SCHAR_MIN    (-__SCHAR_MAX__ - 1)\n+#define SHRT_MIN     (-__SHRT_MAX__ - 1)\n+#define INT_MIN\t     (-__INT_MAX__ - 1)\n+#define LONG_MIN     (-__LONG_MAX__ - 1)\n+#define LLONG_MIN    (-__LONG_LONG_MAX__ - 1)\n+\t\n+#define UCHAR_MAX    (SCHAR_MAX * 2U + 1)\n+#define USHRT_MAX    (SHRT_MAX * 2U + 1)\n+#define UINT_MAX     (INT_MAX * 2U + 1)\n+#define ULONG_MAX    (LONG_MAX * 2LU + 1)\n+#define ULLONG_MAX   (LLONG_MAX * 2LLU + 1)\n+\t\n+#define USCHAR_MIN   (-__USCHAR_MAX__ - 1)\n+#define USHRT_MIN    (-__USHRT_MAX__ - 1)\n+#define UINT_MIN     (-__UINT_MAX__ - 1)\n+#define ULONG_MIN    (-__ULONG_MAX__ - 1)\n+#define ULLONG_MIN   (-__ULONG_LONG_MAX__ - 1)\n+\n+#define Assert(expr) static_assert ((expr), #expr)\n+\n+template <class T>\n+constexpr T add (T x, T y, T z = T ())\n+{\n+  return __builtin_add_overflow (x, y, &z) ? 0 : z;\n+}\n+\n+template <class T>\n+constexpr T sub (T x, T y, T z = T ())\n+{\n+  return __builtin_sub_overflow (x, y, &z) ? 0 : z;\n+}\n+\n+template <class T>\n+constexpr T mul (T x, T y, T z = T ())\n+{\n+  return __builtin_mul_overflow (x, y, &z) ? 0 : z;\n+}\n+\n+#define TEST_ADD(T, x, y, z) Assert (z == add<T>(x, y))\n+#define TEST_SUB(T, x, y, z) Assert (z == sub<T>(x, y))\n+#define TEST_MUL(T, x, y, z) Assert (z == mul<T>(x, y))\n+\n+\n+TEST_ADD (signed char,  0,         0,         0);\n+TEST_ADD (signed char,  0,         SCHAR_MAX, SCHAR_MAX);\n+TEST_ADD (signed char,  1,         SCHAR_MAX, 0);           // overflow\n+TEST_ADD (signed char,  SCHAR_MAX, SCHAR_MAX, 0);           // overflow\n+TEST_ADD (signed char,  0,         SCHAR_MIN, SCHAR_MIN);\n+TEST_ADD (signed char, -1,         SCHAR_MIN, 0);           // overflow\n+\n+TEST_ADD (short,        0,         0,         0);\n+TEST_ADD (short,        0,         SHRT_MAX,  SHRT_MAX);\n+TEST_ADD (short,        1,         SHRT_MAX,  0);           // overflow\n+TEST_ADD (short,        SHRT_MAX,  SHRT_MAX,  0);           // overflow\n+TEST_ADD (short,        0,         SHRT_MIN,  SHRT_MIN);\n+TEST_ADD (short,       -1,         SHRT_MIN,  0);           // overflow\n+TEST_ADD (short,        SHRT_MIN,  SHRT_MIN,  0);           // overflow\n+\n+TEST_ADD (int,          0,         0,         0);\n+TEST_ADD (int,          0,         INT_MAX,   INT_MAX);\n+TEST_ADD (int,          1,         INT_MAX,   0);           // overflow\n+TEST_ADD (int,          INT_MAX,   INT_MAX,   0);           // overflow\n+TEST_ADD (int,          0,         INT_MIN,   INT_MIN);\n+TEST_ADD (int,         -1,         INT_MIN,   0);           // overflow\n+TEST_ADD (int,          INT_MIN,   INT_MIN,   0);           // overflow\n+\n+TEST_ADD (long,         0,         0,         0);\n+TEST_ADD (long,         0,         LONG_MAX,  LONG_MAX);\n+TEST_ADD (long,         1,         LONG_MAX,  0);           // overflow\n+TEST_ADD (long,         LONG_MAX,  LONG_MAX,  0);           // overflow\n+TEST_ADD (long,         0,         LONG_MIN,  LONG_MIN);\n+TEST_ADD (long,        -1,         LONG_MIN,  0);           // overflow\n+TEST_ADD (long,         LONG_MIN,  LONG_MIN,  0);           // overflow\n+\n+TEST_ADD (long long,    0,         0,          0);\n+TEST_ADD (long long,    0,         LLONG_MAX,  LLONG_MAX);\n+TEST_ADD (long long,    1,         LLONG_MAX,  0);          // overflow\n+TEST_ADD (long long,    LLONG_MAX, LLONG_MAX,  0);          // overflow\n+TEST_ADD (long long,    0,         LLONG_MIN,  LLONG_MIN);\n+TEST_ADD (long long,   -1,         LLONG_MIN,  0);          // overflow\n+TEST_ADD (long long,    LLONG_MIN, LLONG_MIN,  0);          // overflow\n+\n+TEST_ADD (unsigned char,  0,         0,         0);\n+TEST_ADD (unsigned char,  0,         UCHAR_MAX, UCHAR_MAX);\n+TEST_ADD (unsigned char,  1,         UCHAR_MAX, 0);         // overflow\n+\n+TEST_ADD (unsigned char,  UCHAR_MAX, UCHAR_MAX, 0);         // overflow\n+TEST_ADD (unsigned short, 0,         0,          0);\n+TEST_ADD (unsigned short, 0,         USHRT_MAX,  USHRT_MAX);\n+TEST_ADD (unsigned short, 1,         USHRT_MAX,  0);        // overflow\n+TEST_ADD (unsigned short, USHRT_MAX, USHRT_MAX,  0);        // overflow\n+\n+TEST_ADD (unsigned,       0,         0,          0);\n+TEST_ADD (unsigned,       0,         UINT_MAX,   UINT_MAX);\n+TEST_ADD (unsigned,       1,         UINT_MAX,   0);        // overflow\n+TEST_ADD (unsigned,       UINT_MAX,  UINT_MAX,   0);        // overflow\n+\n+TEST_ADD (unsigned long,  0,         0,         0);\n+TEST_ADD (unsigned long,  0,         ULONG_MAX, ULONG_MAX);\n+TEST_ADD (unsigned long,  1,         ULONG_MAX, 0);         // overflow\n+TEST_ADD (unsigned long,  ULONG_MAX, ULONG_MAX, 0);         // overflow\n+\n+TEST_ADD (unsigned long long,  0,          0,          0);\n+TEST_ADD (unsigned long long,  0,          ULLONG_MAX, ULLONG_MAX);\n+TEST_ADD (unsigned long long,  1,          ULLONG_MAX, 0);  // overflow\n+TEST_ADD (unsigned long long,  ULLONG_MAX, ULLONG_MAX, 0);  // overflow\n+\n+\n+// Make sure the built-ins are accepted in the following contexts\n+// where constant expressions are required and that they return\n+// the expected overflow value.\n+\n+namespace Enum {\n+\n+enum Add {\n+  a0 = __builtin_add_overflow_p (      1, 1, 0),\n+  a1 = __builtin_add_overflow_p (INT_MAX, 1, 0)\n+};\n+\n+Assert (a0 == 0);\n+Assert (a1 == 1);\n+\n+enum Sub {\n+  s0 = __builtin_sub_overflow_p (      1, 1, 0),\n+  s1 = __builtin_sub_overflow_p (INT_MIN, 1, 0)\n+};\n+\n+Assert (s0 == 0);\n+Assert (s1 == 1);\n+\n+enum Mul {\n+  m0 = __builtin_add_overflow_p (      1,       1, 0),\n+  m1 = __builtin_add_overflow_p (INT_MAX, INT_MAX, 0)\n+};\n+\n+Assert (m0 == 0);\n+Assert (m1 == 1);\n+\n+}   // namespace Enum\n+\n+namespace TemplateArg {\n+\n+template <class T, class U, class V,\n+\t  T x, U y, bool v, bool z = __builtin_add_overflow_p (x, y, V ())>\n+struct Add {\n+  Assert (z == v);\n+};\n+\n+template <class T, class U, class V,\n+\t  T x, U y, bool v, bool z = __builtin_sub_overflow_p (x, y, V ())>\n+struct Sub {\n+  Assert (z == v);\n+};\n+\n+template <class T, class U, class V,\n+\t  T x, U y, bool v, bool z = __builtin_mul_overflow_p (x, y, V ())>\n+struct Mul {\n+  Assert (z == v);\n+};\n+\n+template struct Add<int, int, int,  1,       1, false>;\n+template struct Add<int, int, int,  1, INT_MAX, true>;\n+\n+template struct Sub<int, int, int,  1,       1, false>;\n+template struct Sub<int, int, int, -2, INT_MAX, true>;\n+\n+template struct Mul<int, int, int,  1,               1, false>;\n+template struct Mul<int, int, int,  2, INT_MAX / 2 + 1, true>;\n+\n+}   // namespace TemplateArg\n+\n+#if __cplusplus >= 201402L\n+\n+namespace Initializer {\n+\n+struct Result {\n+  int res;\n+  bool vflow;\n+};\n+\n+constexpr Result\n+add_vflow (int a, int b)\n+{\n+#if 1\n+  Result res = { a + b, __builtin_add_overflow_p (a, b, int ()) };\n+#else\n+  // The following fails to compile because of c++/71391 - error\n+  // on aggregate initialization with side-effects in a constexpr\n+  // function\n+  int c = 0;\n+  Result res = { 0, __builtin_add_overflow (a, b, &c) };\n+  res.c = c;\n+#endif\n+  return res;\n+}\n+\n+constexpr Result sum = add_vflow (123, 456);\n+Assert (sum.res == 123 + 456);\n+Assert (!sum.vflow);\n+\n+}   // namespace Initializer\n+\n+#endif   // __cplusplus >= 201402L"}, {"sha": "7ca0033d217c8fb751edaefbe9f3521ca2b74a8d", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-arith-overflow.C", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-arith-overflow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-arith-overflow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-arith-overflow.C?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -0,0 +1,229 @@\n+// Test to exercise that the type-specific integer arithmetic built-ins\n+// with overflow checking can be used in C++ 14 constant expressions.\n+// -Woverflow is disabled to prevent (bogus?) G++ warnings.\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options \"-Wno-overflow\" }\n+\n+#define SCHAR_MAX    __SCHAR_MAX__\n+#define SHRT_MAX     __SHRT_MAX__\n+#define INT_MAX\t     __INT_MAX__\n+#define LONG_MAX     __LONG_MAX__\n+#define LLONG_MAX    __LONG_LONG_MAX__\n+\t\n+#define SCHAR_MIN    (-__SCHAR_MAX__ - 1)\n+#define SHRT_MIN     (-__SHRT_MAX__ - 1)\n+#define INT_MIN\t     (-__INT_MAX__ - 1)\n+#define LONG_MIN     (-__LONG_MAX__ - 1)\n+#define LLONG_MIN    (-__LONG_LONG_MAX__ - 1)\n+\t\n+#define UCHAR_MAX    (SCHAR_MAX * 2U + 1)\n+#define USHRT_MAX    (SHRT_MAX * 2U + 1)\n+#define UINT_MAX     (INT_MAX * 2U + 1)\n+#define ULONG_MAX    (LONG_MAX * 2LU + 1)\n+#define ULLONG_MAX   (LLONG_MAX * 2LLU + 1)\n+\t\n+#define USCHAR_MIN   (-__USCHAR_MAX__ - 1)\n+#define USHRT_MIN    (-__USHRT_MAX__ - 1)\n+#define UINT_MIN     (-__UINT_MAX__ - 1)\n+#define ULONG_MIN    (-__ULONG_MAX__ - 1)\n+#define ULLONG_MIN   (-__ULONG_LONG_MAX__ - 1)\n+\n+// Helper macros.\n+#define sadd(x, y) ((x) + (y))\n+#define saddl(x, y) ((x) + (y))\n+#define saddll(x, y) ((x) + (y))\n+#define uadd(x, y) ((x) + (y))\n+#define uaddl(x, y) ((x) + (y))\n+#define uaddll(x, y) ((x) + (y))\n+#define ssub(x, y) ((x) - (y))\n+#define ssubl(x, y) ((x) - (y))\n+#define ssubll(x, y) ((x) - (y))\n+#define usub(x, y) ((x) - (y))\n+#define usubl(x, y) ((x) - (y))\n+#define usubll(x, y) ((x) - (y))\n+#define smul(x, y) ((x) * (y))\n+#define smull(x, y) ((x) * (y))\n+#define smulll(x, y) ((x) * (y))\n+#define umul(x, y) ((x) * (y))\n+#define umull(x, y) ((x) * (y))\n+#define umulll(x, y) ((x) * (y))\n+\n+// Result object.\n+template <class T>\n+struct Res\n+{\n+  constexpr Res (T a, bool v): z (a), v (v) { }\n+  T z; bool v;\n+};\n+\n+template <class T>\n+constexpr bool operator== (Res<T> a, Res<T> b)\n+{\n+  return a.z == b.z && a.v == b.v;\n+}\n+\n+#define StaticAssert(expr) static_assert ((expr), #expr)\n+\n+#define CONCAT(a, b)   a ## b\n+#define CAT(a, b)      CONCAT (a, b)\n+\n+// Helper to determine the type of the result of the arithmetic\n+// as specified by the built-ins.\n+template <class T> struct ResType { typedef T type; };\n+template <>        struct ResType<signed char> { typedef int type; };\n+template <>        struct ResType<unsigned char> { typedef unsigned type; };\n+template <>        struct ResType<signed short> { typedef int type; };\n+template <>        struct ResType<unsigned short> { typedef unsigned type; };\n+\n+// Macro to define a single test case verifying that integer overflow\n+// is detected when expected, and when not, that the result matches\n+// the result computed using ordinary arithmetic.  The result cannot\n+// be tested in the presence of overflow since it's not a core\n+// constant expression.\n+#define TEST(op, T, x, y, vflow)\t\t\t\t\t\\\n+  constexpr Res<T> CAT (op, __LINE__)(T a, T b)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    ResType<T>::type c = 0;\t\t\t\t\t\t\\\n+    bool v = __builtin_ ## op ## _overflow (a, b, &c);\t\t\t\\\n+    return Res<T>(c, v);\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  StaticAssert (vflow ? CAT (op, __LINE__)(x, y).v\t\t\t\\\n+\t\t: CAT (op, __LINE__)(x, y) == Res<T>(op (x, y), vflow))\n+\n+/* Signed int addition.  */\n+TEST (sadd,   signed char,    0,         0,         0);\n+TEST (sadd,   signed char,    0,         SCHAR_MAX, 0);\n+TEST (sadd,   signed char,    1,         SCHAR_MAX, 0);\n+TEST (sadd,   signed char,    SCHAR_MAX, SCHAR_MAX, 0);\n+TEST (sadd,   signed char,    0,         SCHAR_MIN, 0);\n+TEST (sadd,   signed char,   -1,         SCHAR_MIN, 0);\n+\n+TEST (sadd,   short,          0,         0,         0);\n+TEST (sadd,   short,          0,         SHRT_MAX,  0);\n+TEST (sadd,   short,          1,         SHRT_MAX,  0);\n+TEST (sadd,   short,          SHRT_MAX,  SHRT_MAX,  0);\n+TEST (sadd,   short,          0,         SHRT_MIN,  0);\n+TEST (sadd,   short,         -1,         SHRT_MIN,  0);\n+TEST (sadd,   short,          SHRT_MIN,  SHRT_MIN,  0);\n+\n+TEST (sadd,   int,            0,         0,         0);\n+TEST (sadd,   int,            0,         INT_MAX,   0);\n+TEST (sadd,   int,            1,         INT_MAX,   1);\n+TEST (sadd,   int,            INT_MAX,   INT_MAX,   1);\n+TEST (sadd,   int,            0,         INT_MIN,   0);\n+TEST (sadd,   int,           -1,         INT_MIN,   1);\n+TEST (sadd,   int,            INT_MIN,   INT_MIN,   1);\n+\n+/* Signed long addition.  */\n+TEST (saddl,  long,           0L,        0L,        0);\n+TEST (saddl,  long,           0L,        LONG_MAX,  0);\n+TEST (saddl,  long,           1L,        LONG_MAX,  1);\n+TEST (saddl,  long,           LONG_MAX,  LONG_MAX,  1);\n+TEST (saddl,  long,           0L,        LONG_MIN,  0);\n+TEST (saddl,  long,          -1L,        LONG_MIN,  1);\n+TEST (saddl,  long,           LONG_MIN,  LONG_MIN,  1);\n+\n+TEST (saddll, long long,      0LL,       0LL,        0);\n+TEST (saddll, long long,      0LL,       LLONG_MAX,  0);\n+TEST (saddll, long long,      1LL,       LLONG_MAX,  1);\n+TEST (saddll, long long,      LLONG_MAX, LLONG_MAX,  1);\n+TEST (saddll, long long,      0LL,       LLONG_MIN,  0);\n+TEST (saddll, long long,     -1LL,       LLONG_MIN,  1);\n+TEST (saddll, long long,      LLONG_MIN, LLONG_MIN,  1);\n+\n+/* Unsigned int addition.  */\n+TEST (uadd,   unsigned char,  0U,        0U,         0);\n+TEST (uadd,   unsigned char,  0U,        UCHAR_MAX, 0);\n+TEST (uadd,   unsigned char,  1U,        UCHAR_MAX, 0);\n+TEST (uadd,   unsigned char,  UCHAR_MAX, UCHAR_MAX, 0);\n+\n+TEST (uadd,   unsigned short, 0U,        0U,         0);\n+TEST (uadd,   unsigned short, 0U,        USHRT_MAX,  0);\n+TEST (uadd,   unsigned short, 1U,        USHRT_MAX,  0);\n+TEST (uadd,   unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+TEST (uadd,   unsigned,       0U,        0U,         0);\n+TEST (uadd,   unsigned,       0U,        UINT_MAX,   0);\n+TEST (uadd,   unsigned,       1U,        UINT_MAX,   1);\n+TEST (uadd,   unsigned,       UINT_MAX,  UINT_MAX,   1);\n+\n+/* Unsigned long addition.  */\n+TEST (uaddl,  unsigned long,  0UL,       0UL,       0);\n+TEST (uaddl,  unsigned long,  0UL,       ULONG_MAX, 0);\n+TEST (uaddl,  unsigned long,  1UL,       ULONG_MAX, 1);\n+TEST (uaddl,  unsigned long,  ULONG_MAX, ULONG_MAX, 1);\n+\n+TEST (uaddll, unsigned long long, 0ULL,       0ULL,       0);\n+TEST (uaddll, unsigned long long, 0ULL,       ULLONG_MAX, 0);\n+TEST (uaddll, unsigned long long, 1ULL,       ULLONG_MAX, 1);\n+TEST (uaddll, unsigned long long, ULLONG_MAX, ULLONG_MAX, 1);\n+\n+/* Signed int subtraction.  */\n+TEST (ssub,   signed char,    0,         0,          0);\n+TEST (ssub,   signed char,    0,         SCHAR_MAX,  0);\n+TEST (ssub,   signed char,    1,         SCHAR_MAX,  0);\n+TEST (ssub,   signed char,    SCHAR_MAX, SCHAR_MAX,  0);\n+TEST (ssub,   signed char,    0,         SCHAR_MIN,  0);\n+TEST (ssub,   signed char,   -1,         SCHAR_MIN,  0);\n+\n+TEST (ssub,   short,          0,         0,          0);\n+TEST (ssub,   short,          0,         SHRT_MAX,   0);\n+TEST (ssub,   short,          1,         SHRT_MAX,   0);\n+TEST (ssub,   short,          SHRT_MAX,  SHRT_MAX,   0);\n+TEST (ssub,   short,          0,         SHRT_MIN,   0);\n+TEST (ssub,   short,         -1,         SHRT_MIN,   0);\n+TEST (ssub,   short,          SHRT_MIN,  SHRT_MIN,   0);\n+\n+TEST (ssub,   int,            0,         0,          0);\n+TEST (ssub,   int,            0,         INT_MAX,    0);\n+TEST (ssub,   int,            1,         INT_MAX,    0);\n+TEST (ssub,   int,            INT_MAX,   INT_MAX,    0);\n+TEST (ssub,   int,            0,         INT_MIN,    1);\n+TEST (ssub,   int,           -1,         INT_MIN,    0);\n+TEST (ssub,   int,            INT_MIN,   INT_MIN,    0);\n+\n+/* Signed long subtraction.  */\n+TEST (ssubl,  long,           0L,        0L,         0);\n+TEST (ssubl,  long,           0L,        LONG_MAX,   0);\n+TEST (ssubl,  long,           1L,        LONG_MAX,   0);\n+TEST (ssubl,  long,           LONG_MAX,  LONG_MAX,   0);\n+TEST (ssubl,  long,           0L,        LONG_MIN,   1);\n+TEST (ssubl,  long,          -1L,        LONG_MIN,   0);\n+TEST (ssubl,  long,           LONG_MIN,  LONG_MIN,   0);\n+\n+/* Signed long long subtraction.  */\n+TEST (ssubll, long long,      0LL,       0LL,        0);\n+TEST (ssubll, long long,      0LL,       LLONG_MAX,  0);\n+TEST (ssubll, long long,      1LL,       LLONG_MAX,  0);\n+TEST (ssubll, long long,      LLONG_MAX, LLONG_MAX,  0);\n+TEST (ssubll, long long,      0LL,       LLONG_MIN,  1);\n+TEST (ssubll, long long,     -1LL,       LLONG_MIN,  0);\n+TEST (ssubll, long long,      LLONG_MIN, LLONG_MIN,  0);\n+\n+/* Unsigned int subtraction.  */\n+TEST (usub,   unsigned char,  0U,        0U,         0);\n+TEST (usub,   unsigned char,  0U,        UCHAR_MAX,  1);\n+TEST (usub,   unsigned char,  1U,        UCHAR_MAX,  1);\n+TEST (usub,   unsigned char,  UCHAR_MAX, UCHAR_MAX,  0);\n+\n+TEST (usub,   unsigned short, 0U,        0U,         0);\n+TEST (usub,   unsigned short, 0U,        USHRT_MAX,  1);\n+TEST (usub,   unsigned short, 1U,        USHRT_MAX,  1);\n+TEST (usub,   unsigned short, USHRT_MAX, USHRT_MAX,  0);\n+\n+TEST (usub,   unsigned,       0U,        0U,         0);\n+TEST (usub,   unsigned,       0U,        UINT_MAX,   1);\n+TEST (usub,   unsigned,       1U,        UINT_MAX,   1);\n+TEST (usub,   unsigned,       UINT_MAX,  UINT_MAX,   0);\n+\n+/* Unsigned long subtraction.  */\n+TEST (usubl,  unsigned long,  0UL,       0UL,       0);\n+TEST (usubl,  unsigned long,  0UL,       ULONG_MAX, 1);\n+TEST (usubl,  unsigned long,  1UL,       ULONG_MAX, 1);\n+TEST (usubl,  unsigned long,  ULONG_MAX, ULONG_MAX, 0);\n+\n+/* Unsigned long long subtraction.  */\n+TEST (usubll, unsigned long long,  0ULL,       0ULL,       0);\n+TEST (usubll, unsigned long long,  0ULL,       ULLONG_MAX, 1);\n+TEST (usubll, unsigned long long,  1ULL,       ULLONG_MAX, 1);\n+TEST (usubll, unsigned long long,  ULLONG_MAX, ULLONG_MAX, 0);"}, {"sha": "669eea2cbd2972fe1e428d3c5cde226f8abd212a", "filename": "gcc/testsuite/g++.dg/ext/builtin-arith-overflow-1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-arith-overflow-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44a845ca0e592ca187fbab07ac9e055b20fb11cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-arith-overflow-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-arith-overflow-1.C?ref=44a845ca0e592ca187fbab07ac9e055b20fb11cc", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+enum A { B = 1, C = 2, D = __builtin_add_overflow_p (B, C, C) };\n+int e[__builtin_add_overflow_p (B, C, C) + 1];\n+template <int N> int foo (int);\n+\n+void\n+bar ()\n+{\n+  foo <__builtin_add_overflow_p (B, C, C) + 1> (0);\n+}"}]}