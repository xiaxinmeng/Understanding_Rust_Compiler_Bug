{"sha": "15e9e6795d044364c9d852f48665778c96728955", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlOWU2Nzk1ZDA0NDM2NGM5ZDg1MmY0ODY2NTc3OGM5NjcyODk1NQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-11-13T12:37:54Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-11-13T12:37:54Z"}, "message": "GCN mkoffload\n\n2019-11-13  Andrew Stubbs  <ams@codesourcery.com>\n\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/mkoffload.c: New file.\n\t* config/gcn/offload.h: New file.\n\nFrom-SVN: r278133", "tree": {"sha": "da05114f07805a07ee0815e475fd935aaff40286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da05114f07805a07ee0815e475fd935aaff40286"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e9e6795d044364c9d852f48665778c96728955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e9e6795d044364c9d852f48665778c96728955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e9e6795d044364c9d852f48665778c96728955", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e9e6795d044364c9d852f48665778c96728955/comments", "author": null, "committer": null, "parents": [{"sha": "b3d14b3aa343eb7fc656e7f4d3c9b2dc04be63be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d14b3aa343eb7fc656e7f4d3c9b2dc04be63be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d14b3aa343eb7fc656e7f4d3c9b2dc04be63be"}], "stats": {"total": 729, "additions": 729, "deletions": 0}, "files": [{"sha": "40b56375b752184c6e114fa7fdef9aa2702cf5a6", "filename": "gcc/config/gcn/mkoffload.c", "status": "added", "additions": 694, "deletions": 0, "changes": 694, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e9e6795d044364c9d852f48665778c96728955/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e9e6795d044364c9d852f48665778c96728955/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.c?ref=15e9e6795d044364c9d852f48665778c96728955", "patch": "@@ -0,0 +1,694 @@\n+/* Offload image generation tool for AMD GCN.\n+\n+   Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Munges GCN assembly into a C source file defining the GCN code as a\n+   string.\n+\n+   This is not a complete assembler.  We presume the source is well\n+   formed from the compiler and can die horribly if it is not.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"obstack.h\"\n+#include \"diagnostic.h\"\n+#include \"intl.h\"\n+#include <libgen.h>\n+#include \"collect-utils.h\"\n+#include \"gomp-constants.h\"\n+\n+const char tool_name[] = \"gcn mkoffload\";\n+\n+#define COMMENT_PREFIX \"#\"\n+\n+struct id_map\n+{\n+  id_map *next;\n+  char *gcn_name;\n+};\n+\n+static id_map *func_ids, **funcs_tail = &func_ids;\n+static id_map *var_ids, **vars_tail = &var_ids;\n+\n+/* Files to unlink.  */\n+static const char *gcn_s1_name;\n+static const char *gcn_s2_name;\n+static const char *gcn_o_name;\n+static const char *gcn_cfile_name;\n+\n+enum offload_abi offload_abi = OFFLOAD_ABI_UNSET;\n+\n+/* Delete tempfiles.  */\n+\n+void\n+tool_cleanup (bool from_signal ATTRIBUTE_UNUSED)\n+{\n+  if (gcn_cfile_name)\n+    maybe_unlink (gcn_cfile_name);\n+  if (gcn_s1_name)\n+    maybe_unlink (gcn_s1_name);\n+  if (gcn_s2_name)\n+    maybe_unlink (gcn_s2_name);\n+  if (gcn_o_name)\n+    maybe_unlink (gcn_o_name);\n+}\n+\n+static void\n+mkoffload_cleanup (void)\n+{\n+  tool_cleanup (false);\n+}\n+\n+/* Unlink FILE unless requested otherwise.  */\n+\n+void\n+maybe_unlink (const char *file)\n+{\n+  if (!save_temps)\n+    {\n+      if (unlink_if_ordinary (file) && errno != ENOENT)\n+\tfatal_error (input_location, \"deleting file %s: %m\", file);\n+    }\n+  else if (verbose)\n+    fprintf (stderr, \"[Leaving %s]\\n\", file);\n+}\n+\n+/* Add or change the value of an environment variable, outputting the\n+   change to standard error if in verbose mode.  */\n+\n+static void\n+xputenv (const char *string)\n+{\n+  if (verbose)\n+    fprintf (stderr, \"%s\\n\", string);\n+  putenv (CONST_CAST (char *, string));\n+}\n+\n+/* Read the whole input file.  It will be NUL terminated (but\n+   remember, there could be a NUL in the file itself.  */\n+\n+static const char *\n+read_file (FILE *stream, size_t *plen)\n+{\n+  size_t alloc = 16384;\n+  size_t base = 0;\n+  char *buffer;\n+\n+  if (!fseek (stream, 0, SEEK_END))\n+    {\n+      /* Get the file size.  */\n+      long s = ftell (stream);\n+      if (s >= 0)\n+\talloc = s + 100;\n+      fseek (stream, 0, SEEK_SET);\n+    }\n+  buffer = XNEWVEC (char, alloc);\n+\n+  for (;;)\n+    {\n+      size_t n = fread (buffer + base, 1, alloc - base - 1, stream);\n+\n+      if (!n)\n+\tbreak;\n+      base += n;\n+      if (base + 1 == alloc)\n+\t{\n+\t  alloc *= 2;\n+\t  buffer = XRESIZEVEC (char, buffer, alloc);\n+\t}\n+    }\n+  buffer[base] = 0;\n+  *plen = base;\n+  return buffer;\n+}\n+\n+/* Parse STR, saving found tokens into PVALUES and return their number.\n+   Tokens are assumed to be delimited by ':'.  */\n+\n+static unsigned\n+parse_env_var (const char *str, char ***pvalues)\n+{\n+  const char *curval, *nextval;\n+  char **values;\n+  unsigned num = 1, i;\n+\n+  curval = strchr (str, ':');\n+  while (curval)\n+    {\n+      num++;\n+      curval = strchr (curval + 1, ':');\n+    }\n+\n+  values = (char **) xmalloc (num * sizeof (char *));\n+  curval = str;\n+  nextval = strchr (curval, ':');\n+  if (nextval == NULL)\n+    nextval = strchr (curval, '\\0');\n+\n+  for (i = 0; i < num; i++)\n+    {\n+      int l = nextval - curval;\n+      values[i] = (char *) xmalloc (l + 1);\n+      memcpy (values[i], curval, l);\n+      values[i][l] = 0;\n+      curval = nextval + 1;\n+      nextval = strchr (curval, ':');\n+      if (nextval == NULL)\n+\tnextval = strchr (curval, '\\0');\n+    }\n+  *pvalues = values;\n+  return num;\n+}\n+\n+/* Auxiliary function that frees elements of PTR and PTR itself.\n+   N is number of elements to be freed.  If PTR is NULL, nothing is freed.\n+   If an element is NULL, subsequent elements are not freed.  */\n+\n+static void\n+free_array_of_ptrs (void **ptr, unsigned n)\n+{\n+  unsigned i;\n+  if (!ptr)\n+    return;\n+  for (i = 0; i < n; i++)\n+    {\n+      if (!ptr[i])\n+\tbreak;\n+      free (ptr[i]);\n+    }\n+  free (ptr);\n+  return;\n+}\n+\n+/* Check whether NAME can be accessed in MODE.  This is like access,\n+   except that it never considers directories to be executable.  */\n+\n+static int\n+access_check (const char *name, int mode)\n+{\n+  if (mode == X_OK)\n+    {\n+      struct stat st;\n+\n+      if (stat (name, &st) < 0 || S_ISDIR (st.st_mode))\n+\treturn -1;\n+    }\n+\n+  return access (name, mode);\n+}\n+\n+/* Parse an input assembler file, extract the offload tables etc.,\n+   and output (1) the assembler code, minus the tables (which can contain\n+   problematic relocations), and (2) a C file with the offload tables\n+   encoded as structured data.  */\n+\n+static void\n+process_asm (FILE *in, FILE *out, FILE *cfile)\n+{\n+  int fn_count = 0, var_count = 0, dims_count = 0;\n+  struct obstack fns_os, vars_os, varsizes_os, dims_os;\n+  obstack_init (&fns_os);\n+  obstack_init (&vars_os);\n+  obstack_init (&varsizes_os);\n+  obstack_init (&dims_os);\n+\n+  struct oaccdims\n+  {\n+    int d[3];\n+    char *name;\n+  } dim;\n+\n+  /* Always add _init_array and _fini_array as kernels.  */\n+  obstack_ptr_grow (&fns_os, xstrdup (\"_init_array\"));\n+  obstack_ptr_grow (&fns_os, xstrdup (\"_fini_array\"));\n+  fn_count += 2;\n+\n+  char buf[1000];\n+  enum { IN_CODE, IN_VARS, IN_FUNCS } state = IN_CODE;\n+  while (fgets (buf, sizeof (buf), in))\n+    {\n+      switch (state)\n+\t{\n+\tcase IN_CODE:\n+\t  {\n+\t    if (sscanf (buf, \" ;; OPENACC-DIMS: %d, %d, %d : %ms\\n\",\n+\t\t\t&dim.d[0], &dim.d[1], &dim.d[2], &dim.name) == 4)\n+\t      {\n+\t\tobstack_grow (&dims_os, &dim, sizeof (dim));\n+\t\tdims_count++;\n+\t      }\n+\t    break;\n+\t  }\n+\tcase IN_VARS:\n+\t  {\n+\t    char *varname;\n+\t    unsigned varsize;\n+\t    if (sscanf (buf, \" .8byte %ms\\n\", &varname))\n+\t      {\n+\t\tobstack_ptr_grow (&vars_os, varname);\n+\t\tfgets (buf, sizeof (buf), in);\n+\t\tif (!sscanf (buf, \" .8byte %u\\n\", &varsize))\n+\t\t  abort ();\n+\t\tobstack_int_grow (&varsizes_os, varsize);\n+\t\tvar_count++;\n+\n+\t\t/* The HSA Runtime cannot locate the symbol if it is not\n+\t\t   exported from the kernel.  */\n+\t\tfprintf (out, \"\\t.global %s\\n\", varname);\n+\t      }\n+\t    break;\n+\t  }\n+\tcase IN_FUNCS:\n+\t  {\n+\t    char *funcname;\n+\t    if (sscanf (buf, \"\\t.8byte\\t%ms\\n\", &funcname))\n+\t      {\n+\t\tobstack_ptr_grow (&fns_os, funcname);\n+\t\tfn_count++;\n+\t\tcontinue;\n+\t      }\n+\t    break;\n+\t  }\n+\t}\n+\n+      char dummy;\n+      if (sscanf (buf, \" .section .gnu.offload_vars%c\", &dummy) > 0)\n+\tstate = IN_VARS;\n+      else if (sscanf (buf, \" .section .gnu.offload_funcs%c\", &dummy) > 0)\n+\tstate = IN_FUNCS;\n+      else if (sscanf (buf, \" .section %c\", &dummy) > 0\n+\t       || sscanf (buf, \" .text%c\", &dummy) > 0\n+\t       || sscanf (buf, \" .bss%c\", &dummy) > 0\n+\t       || sscanf (buf, \" .data%c\", &dummy) > 0\n+\t       || sscanf (buf, \" .ident %c\", &dummy) > 0)\n+\tstate = IN_CODE;\n+\n+      if (state == IN_CODE)\n+\tfputs (buf, out);\n+    }\n+\n+  char **fns = XOBFINISH (&fns_os, char **);\n+  struct oaccdims *dims = XOBFINISH (&dims_os, struct oaccdims *);\n+\n+  fprintf (cfile, \"#include <stdlib.h>\\n\");\n+  fprintf (cfile, \"#include <stdbool.h>\\n\\n\");\n+\n+  char **vars = XOBFINISH (&vars_os, char **);\n+  unsigned *varsizes = XOBFINISH (&varsizes_os, unsigned *);\n+  fprintf (cfile,\n+\t   \"static const struct global_var_info {\\n\"\n+\t   \"  const char *name;\\n\"\n+\t   \"  void *address;\\n\"\n+\t   \"} vars[] = {\\n\");\n+  int i;\n+  for (i = 0; i < var_count; ++i)\n+    {\n+      const char *sep = i < var_count - 1 ? \",\" : \" \";\n+      fprintf (cfile, \"  { \\\"%s\\\", NULL }%s /* size: %u */\\n\", vars[i], sep,\n+\t       varsizes[i]);\n+    }\n+  fprintf (cfile, \"};\\n\\n\");\n+\n+  obstack_free (&vars_os, NULL);\n+  obstack_free (&varsizes_os, NULL);\n+\n+  /* Dump out function idents.  */\n+  fprintf (cfile, \"static const struct hsa_kernel_description {\\n\"\n+\t   \"  const char *name;\\n\"\n+\t   \"  int oacc_dims[3];\\n\"\n+\t   \"} gcn_kernels[] = {\\n  \");\n+  dim.d[0] = dim.d[1] = dim.d[2] = 0;\n+  const char *comma;\n+  for (comma = \"\", i = 0; i < fn_count; comma = \",\\n  \", i++)\n+    {\n+      /* Find if we recorded dimensions for this function.  */\n+      int *d = dim.d;\t\t/* Previously zeroed.  */\n+      for (int j = 0; j < dims_count; j++)\n+\tif (strcmp (fns[i], dims[j].name) == 0)\n+\t  {\n+\t    d = dims[j].d;\n+\t    break;\n+\t  }\n+\n+      fprintf (cfile, \"%s{\\\"%s\\\", {%d, %d, %d}}\", comma,\n+\t       fns[i], d[0], d[1], d[2]);\n+\n+      free (fns[i]);\n+    }\n+  fprintf (cfile, \"\\n};\\n\\n\");\n+\n+  obstack_free (&fns_os, NULL);\n+  for (i = 0; i < dims_count; i++)\n+    free (dims[i].name);\n+  obstack_free (&dims_os, NULL);\n+}\n+\n+/* Embed an object file into a C source file.  */\n+\n+static void\n+process_obj (FILE *in, FILE *cfile)\n+{\n+  size_t len = 0;\n+  const char *input = read_file (in, &len);\n+\n+  /* Dump out an array containing the binary.\n+     FIXME: do this with objcopy.  */\n+  fprintf (cfile, \"static unsigned char gcn_code[] = {\");\n+  for (size_t i = 0; i < len; i += 17)\n+    {\n+      fprintf (cfile, \"\\n\\t\");\n+      for (size_t j = i; j < i + 17 && j < len; j++)\n+\tfprintf (cfile, \"%3u,\", (unsigned char) input[j]);\n+    }\n+  fprintf (cfile, \"\\n};\\n\\n\");\n+\n+  fprintf (cfile,\n+\t   \"static const struct gcn_image {\\n\"\n+\t   \"  size_t size;\\n\"\n+\t   \"  void *image;\\n\"\n+\t   \"} gcn_image = {\\n\"\n+\t   \"  %zu,\\n\"\n+\t   \"  gcn_code\\n\"\n+\t   \"};\\n\\n\",\n+\t   len);\n+\n+  fprintf (cfile,\n+\t   \"static const struct gcn_image_desc {\\n\"\n+\t   \"  const struct gcn_image *gcn_image;\\n\"\n+\t   \"  unsigned kernel_count;\\n\"\n+\t   \"  const struct hsa_kernel_description *kernel_infos;\\n\"\n+\t   \"  unsigned global_variable_count;\\n\"\n+\t   \"  const struct global_var_info *global_variables;\\n\"\n+\t   \"} target_data = {\\n\"\n+\t   \"  &gcn_image,\\n\"\n+\t   \"  sizeof (gcn_kernels) / sizeof (gcn_kernels[0]),\\n\"\n+\t   \"  gcn_kernels,\\n\"\n+\t   \"  sizeof (vars) / sizeof (vars[0]),\\n\"\n+\t   \"  vars\\n\"\n+\t   \"};\\n\\n\");\n+\n+  fprintf (cfile,\n+\t   \"#ifdef __cplusplus\\n\"\n+\t   \"extern \\\"C\\\" {\\n\"\n+\t   \"#endif\\n\"\n+\t   \"extern void GOMP_offload_register_ver\"\n+\t   \" (unsigned, const void *, int, const void *);\\n\"\n+\t   \"extern void GOMP_offload_unregister_ver\"\n+\t   \" (unsigned, const void *, int, const void *);\\n\"\n+\t   \"#ifdef __cplusplus\\n\"\n+\t   \"}\\n\"\n+\t   \"#endif\\n\\n\");\n+\n+  fprintf (cfile, \"extern const void *const __OFFLOAD_TABLE__[];\\n\\n\");\n+\n+  fprintf (cfile, \"static __attribute__((constructor)) void init (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_register_ver (%#x, __OFFLOAD_TABLE__,\"\n+\t   \" %d/*GCN*/, &target_data);\\n\"\n+\t   \"};\\n\",\n+\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_GCN),\n+\t   GOMP_DEVICE_GCN);\n+\n+  fprintf (cfile, \"static __attribute__((destructor)) void fini (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_unregister_ver (%#x, __OFFLOAD_TABLE__,\"\n+\t   \" %d/*GCN*/, &target_data);\\n\"\n+\t   \"};\\n\",\n+\t   GOMP_VERSION_PACK (GOMP_VERSION, GOMP_VERSION_GCN),\n+\t   GOMP_DEVICE_GCN);\n+}\n+\n+/* Compile a C file using the host compiler.  */\n+\n+static void\n+compile_native (const char *infile, const char *outfile, const char *compiler)\n+{\n+  const char *collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n+  if (!collect_gcc_options)\n+    fatal_error (input_location,\n+\t\t \"environment variable COLLECT_GCC_OPTIONS must be set\");\n+\n+  struct obstack argv_obstack;\n+  obstack_init (&argv_obstack);\n+  obstack_ptr_grow (&argv_obstack, compiler);\n+  if (save_temps)\n+    obstack_ptr_grow (&argv_obstack, \"-save-temps\");\n+  if (verbose)\n+    obstack_ptr_grow (&argv_obstack, \"-v\");\n+  switch (offload_abi)\n+    {\n+    case OFFLOAD_ABI_LP64:\n+      obstack_ptr_grow (&argv_obstack, \"-m64\");\n+      break;\n+    case OFFLOAD_ABI_ILP32:\n+      obstack_ptr_grow (&argv_obstack, \"-m32\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  obstack_ptr_grow (&argv_obstack, infile);\n+  obstack_ptr_grow (&argv_obstack, \"-c\");\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, outfile);\n+  obstack_ptr_grow (&argv_obstack, NULL);\n+\n+  const char **new_argv = XOBFINISH (&argv_obstack, const char **);\n+  fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true);\n+  obstack_free (&argv_obstack, NULL);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  FILE *in = stdin;\n+  FILE *out = stdout;\n+  FILE *cfile = stdout;\n+  const char *outname = 0, *offloadsrc = 0;\n+\n+  progname = \"mkoffload\";\n+  diagnostic_initialize (global_dc, 0);\n+\n+  if (atexit (mkoffload_cleanup) != 0)\n+    fatal_error (input_location, \"atexit failed\");\n+\n+  char *collect_gcc = getenv (\"COLLECT_GCC\");\n+  if (collect_gcc == NULL)\n+    fatal_error (input_location, \"COLLECT_GCC must be set.\");\n+  const char *gcc_path = dirname (ASTRDUP (collect_gcc));\n+  const char *gcc_exec = basename (ASTRDUP (collect_gcc));\n+\n+  size_t len = (strlen (gcc_path) + 1 + strlen (GCC_INSTALL_NAME) + 1);\n+  char *driver = XALLOCAVEC (char, len);\n+\n+  if (strcmp (gcc_exec, collect_gcc) == 0)\n+    /* collect_gcc has no path, so it was found in PATH.  Make sure we also\n+       find accel-gcc in PATH.  */\n+    gcc_path = NULL;\n+\n+  int driver_used = 0;\n+  if (gcc_path != NULL)\n+    driver_used = sprintf (driver, \"%s/\", gcc_path);\n+  sprintf (driver + driver_used, \"%s\", GCC_INSTALL_NAME);\n+\n+  bool found = false;\n+  if (gcc_path == NULL)\n+    found = true;\n+  else if (access_check (driver, X_OK) == 0)\n+    found = true;\n+  else\n+    {\n+      /* Don't use alloca pointer with XRESIZEVEC.  */\n+      driver = NULL;\n+      /* Look in all COMPILER_PATHs for GCC_INSTALL_NAME.  */\n+      char **paths = NULL;\n+      unsigned n_paths;\n+      n_paths = parse_env_var (getenv (\"COMPILER_PATH\"), &paths);\n+      for (unsigned i = 0; i < n_paths; i++)\n+\t{\n+\t  len = strlen (paths[i]) + 1 + strlen (GCC_INSTALL_NAME) + 1;\n+\t  driver = XRESIZEVEC (char, driver, len);\n+\t  sprintf (driver, \"%s/%s\", paths[i], GCC_INSTALL_NAME);\n+\t  if (access_check (driver, X_OK) == 0)\n+\t    {\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+      free_array_of_ptrs ((void **) paths, n_paths);\n+    }\n+\n+  if (!found)\n+    fatal_error (input_location,\n+\t\t \"offload compiler %s not found\", GCC_INSTALL_NAME);\n+\n+  /* We may be called with all the arguments stored in some file and\n+     passed with @file.  Expand them into argv before processing.  */\n+  expandargv (&argc, &argv);\n+\n+  /* Scan the argument vector.  */\n+  bool fopenmp = false;\n+  bool fopenacc = false;\n+  for (int i = 1; i < argc; i++)\n+    {\n+#define STR \"-foffload-abi=\"\n+      if (strncmp (argv[i], STR, strlen (STR)) == 0)\n+\t{\n+\t  if (strcmp (argv[i] + strlen (STR), \"lp64\") == 0)\n+\t    offload_abi = OFFLOAD_ABI_LP64;\n+\t  else if (strcmp (argv[i] + strlen (STR), \"ilp32\") == 0)\n+\t    offload_abi = OFFLOAD_ABI_ILP32;\n+\t  else\n+\t    fatal_error (input_location,\n+\t\t\t \"unrecognizable argument of option \" STR);\n+\t}\n+#undef STR\n+      else if (strcmp (argv[i], \"-fopenmp\") == 0)\n+\tfopenmp = true;\n+      else if (strcmp (argv[i], \"-fopenacc\") == 0)\n+\tfopenacc = true;\n+      else if (strcmp (argv[i], \"-save-temps\") == 0)\n+\tsave_temps = true;\n+      else if (strcmp (argv[i], \"-v\") == 0)\n+\tverbose = true;\n+    }\n+  if (!(fopenacc ^ fopenmp))\n+    fatal_error (input_location, \"either -fopenacc or -fopenmp must be set\");\n+\n+  const char *abi;\n+  switch (offload_abi)\n+    {\n+    case OFFLOAD_ABI_LP64:\n+      abi = \"-m64\";\n+      break;\n+    case OFFLOAD_ABI_ILP32:\n+      abi = \"-m32\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gcn_s1_name = make_temp_file (\".mkoffload.1.s\");\n+  gcn_s2_name = make_temp_file (\".mkoffload.2.s\");\n+  gcn_o_name = make_temp_file (\".mkoffload.hsaco\");\n+  gcn_cfile_name = make_temp_file (\".c\");\n+\n+  /* Build arguments for compiler pass.  */\n+  struct obstack cc_argv_obstack;\n+  obstack_init (&cc_argv_obstack);\n+  obstack_ptr_grow (&cc_argv_obstack, driver);\n+  obstack_ptr_grow (&cc_argv_obstack, \"-S\");\n+\n+  if (save_temps)\n+    obstack_ptr_grow (&cc_argv_obstack, \"-save-temps\");\n+  if (verbose)\n+    obstack_ptr_grow (&cc_argv_obstack, \"-v\");\n+  obstack_ptr_grow (&cc_argv_obstack, abi);\n+  obstack_ptr_grow (&cc_argv_obstack, \"-xlto\");\n+  if (fopenmp)\n+    obstack_ptr_grow (&cc_argv_obstack, \"-mgomp\");\n+\n+  for (int ix = 1; ix != argc; ix++)\n+    {\n+      if (!strcmp (argv[ix], \"-o\") && ix + 1 != argc)\n+\toutname = argv[++ix];\n+      else\n+\t{\n+\t  obstack_ptr_grow (&cc_argv_obstack, argv[ix]);\n+\n+\t  if (argv[ix][0] != '-')\n+\t    offloadsrc = argv[ix];\n+\t}\n+    }\n+\n+  obstack_ptr_grow (&cc_argv_obstack, \"-o\");\n+  obstack_ptr_grow (&cc_argv_obstack, gcn_s1_name);\n+  obstack_ptr_grow (&cc_argv_obstack,\n+\t\t    concat (\"-mlocal-symbol-id=\", offloadsrc, NULL));\n+  obstack_ptr_grow (&cc_argv_obstack, NULL);\n+  const char **cc_argv = XOBFINISH (&cc_argv_obstack, const char **);\n+\n+  /* Build arguments for assemble/link pass.  */\n+  struct obstack ld_argv_obstack;\n+  obstack_init (&ld_argv_obstack);\n+  obstack_ptr_grow (&ld_argv_obstack, driver);\n+  obstack_ptr_grow (&ld_argv_obstack, gcn_s2_name);\n+  obstack_ptr_grow (&ld_argv_obstack, \"-lgomp\");\n+\n+  for (int i = 1; i < argc; i++)\n+    if (strncmp (argv[i], \"-l\", 2) == 0\n+\t|| strncmp (argv[i], \"-Wl\", 3) == 0\n+\t|| strncmp (argv[i], \"-march\", 6) == 0)\n+      obstack_ptr_grow (&ld_argv_obstack, argv[i]);\n+\n+  obstack_ptr_grow (&ld_argv_obstack, \"-o\");\n+  obstack_ptr_grow (&ld_argv_obstack, gcn_o_name);\n+  obstack_ptr_grow (&ld_argv_obstack, NULL);\n+  const char **ld_argv = XOBFINISH (&ld_argv_obstack, const char **);\n+\n+  /* Clean up unhelpful environment variables.  */\n+  char *execpath = getenv (\"GCC_EXEC_PREFIX\");\n+  char *cpath = getenv (\"COMPILER_PATH\");\n+  char *lpath = getenv (\"LIBRARY_PATH\");\n+  unsetenv (\"GCC_EXEC_PREFIX\");\n+  unsetenv (\"COMPILER_PATH\");\n+  unsetenv (\"LIBRARY_PATH\");\n+\n+  /* Run the compiler pass.  */\n+  fork_execute (cc_argv[0], CONST_CAST (char **, cc_argv), true);\n+  obstack_free (&cc_argv_obstack, NULL);\n+\n+  in = fopen (gcn_s1_name, \"r\");\n+  if (!in)\n+    fatal_error (input_location, \"cannot open intermediate gcn asm file\");\n+\n+  out = fopen (gcn_s2_name, \"w\");\n+  if (!out)\n+    fatal_error (input_location, \"cannot open '%s'\", gcn_s2_name);\n+\n+  cfile = fopen (gcn_cfile_name, \"w\");\n+  if (!cfile)\n+    fatal_error (input_location, \"cannot open '%s'\", gcn_cfile_name);\n+\n+  process_asm (in, out, cfile);\n+\n+  fclose (in);\n+  fclose (out);\n+\n+  /* Run the assemble/link pass.  */\n+  fork_execute (ld_argv[0], CONST_CAST (char **, ld_argv), true);\n+  obstack_free (&ld_argv_obstack, NULL);\n+\n+  in = fopen (gcn_o_name, \"r\");\n+  if (!in)\n+    fatal_error (input_location, \"cannot open intermediate gcn obj file\");\n+\n+  process_obj (in, cfile);\n+\n+  fclose (in);\n+  fclose (cfile);\n+\n+  xputenv (concat (\"GCC_EXEC_PREFIX=\", execpath, NULL));\n+  xputenv (concat (\"COMPILER_PATH=\", cpath, NULL));\n+  xputenv (concat (\"LIBRARY_PATH=\", lpath, NULL));\n+\n+  compile_native (gcn_cfile_name, outname, collect_gcc);\n+\n+  return 0;\n+}"}, {"sha": "795ee3f0e0e4f7ce7e7328f4705a31f9b27aa6d9", "filename": "gcc/config/gcn/offload.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e9e6795d044364c9d852f48665778c96728955/gcc%2Fconfig%2Fgcn%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e9e6795d044364c9d852f48665778c96728955/gcc%2Fconfig%2Fgcn%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Foffload.h?ref=15e9e6795d044364c9d852f48665778c96728955", "patch": "@@ -0,0 +1,35 @@\n+/* Support for AMD GCN offloading.\n+\n+   Copyright (C) 2014-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GCN_OFFLOAD_H\n+#define GCC_GCN_OFFLOAD_H\n+\n+/* Support for OpenACC acc_on_device.  */\n+\n+#include \"gomp-constants.h\"\n+\n+#define ACCEL_COMPILER_acc_device GOMP_DEVICE_GCN\n+\n+#endif"}]}