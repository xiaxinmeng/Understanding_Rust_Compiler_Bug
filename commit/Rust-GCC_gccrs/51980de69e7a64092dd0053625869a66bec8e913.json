{"sha": "51980de69e7a64092dd0053625869a66bec8e913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5ODBkZTY5ZTdhNjQwOTJkZDAwNTM2MjU4NjlhNjZiZWM4ZTkxMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-03-30T14:12:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-03-30T14:12:49Z"}, "message": "libgcc2.c (throw_helper): Just return the SP offset, rather than a whole udata.\n\n\t* libgcc2.c (throw_helper): Just return the SP offset, rather than\n\ta whole udata.  Include args_size in the offset.\n\t(__throw, __rethrow): Adjust.\n\nFrom-SVN: r26066", "tree": {"sha": "b274bc16a1e2e0a1c3acc72918e9da89ef8f7e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b274bc16a1e2e0a1c3acc72918e9da89ef8f7e9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51980de69e7a64092dd0053625869a66bec8e913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51980de69e7a64092dd0053625869a66bec8e913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51980de69e7a64092dd0053625869a66bec8e913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51980de69e7a64092dd0053625869a66bec8e913/comments", "author": null, "committer": null, "parents": [{"sha": "1504b2b4391de55ac606b006de95127457dbebe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1504b2b4391de55ac606b006de95127457dbebe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1504b2b4391de55ac606b006de95127457dbebe5"}], "stats": {"total": 84, "additions": 49, "deletions": 35}, "files": [{"sha": "4d80ace4aeec184915a810087ab51b48ff198942", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51980de69e7a64092dd0053625869a66bec8e913/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51980de69e7a64092dd0053625869a66bec8e913/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51980de69e7a64092dd0053625869a66bec8e913", "patch": "@@ -1,3 +1,9 @@\n+Tue Mar 30 13:19:36 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* libgcc2.c (throw_helper): Just return the SP offset, rather than\n+\ta whole udata.  Include args_size in the offset.\n+\t(__throw, __rethrow): Adjust.\n+\n Tue Mar 30 11:39:27 1999  Craig Burley  <craig@jcb-sc.com>\n \n \t* extend.texi (Extended Asm): Delete spurious `b' before"}, {"sha": "a902dd3be75a704bb7d8f0a6fac58ecaa1437e34", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51980de69e7a64092dd0053625869a66bec8e913/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51980de69e7a64092dd0053625869a66bec8e913/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=51980de69e7a64092dd0053625869a66bec8e913", "patch": "@@ -3692,16 +3692,21 @@ __unwinding_cleanup ()\n    for a dummy call to a routine __unwinding_cleanup() when there are nothing\n    but cleanups remaining. This allows a debugger to examine the state\n    at which the throw was executed, before any cleanups, rather than\n-   at the terminate point after the stack has been unwound. */\n+   at the terminate point after the stack has been unwound.\n+\n+   EH is the current eh_context structure.\n+   PC is the address of the call to __throw.\n+   MY_UDATA is the unwind information for __throw.\n+   OFFSET_P is where we return the SP adjustment offset.  */\n \n static void *\n-throw_helper (eh, pc, my_udata, udata_p)\n+throw_helper (eh, pc, my_udata, offset_p)\n      struct eh_context *eh;\n      void *pc;\n      frame_state *my_udata;\n-     frame_state **udata_p;\n+     long *offset_p;\n {\n-  frame_state *udata = *udata_p;\n+  frame_state ustruct2, *udata = &ustruct2;\n   frame_state ustruct;\n   frame_state *sub_udata = &ustruct;\n   void *saved_pc = pc;\n@@ -3714,12 +3719,15 @@ throw_helper (eh, pc, my_udata, udata_p)\n   int only_cleanup = 0;\n   int rethrow = 0;\n   int saved_state = 0;\n+  long args_size;\n   __eh_info *eh_info = (__eh_info *)eh->info;\n \n   /* Do we find a handler based on a re-throw PC? */\n   if (eh->table_index != (void *) 0)\n     rethrow = 1;\n \n+  memcpy (udata, my_udata, sizeof (*udata));\n+\n   handler = (void *) 0;\n   for (;;)\n     { \n@@ -3795,6 +3803,8 @@ throw_helper (eh, pc, my_udata, udata_p)\n \n   eh->handler_label = handler;\n \n+  args_size = udata->args_size;\n+\n   if (pc == saved_pc)\n     /* We found a handler in the throw context, no need to unwind.  */\n     udata = my_udata;\n@@ -3847,7 +3857,17 @@ throw_helper (eh, pc, my_udata, udata_p)\n     }\n   /* udata now refers to the frame called by the handler frame.  */\n \n-  *udata_p = udata;\n+  /* We adjust SP by the difference between __throw's CFA and the CFA for\n+     the frame called by the handler frame, because those CFAs correspond\n+     to the SP values at the two call sites.  We need to further adjust by\n+     the args_size of the handler frame itself to get the handler frame's\n+     SP from before the args were pushed for that call.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+  *offset_p = udata->cfa - my_udata->cfa + args_size;\n+#else\n+  *offset_p = my_udata->cfa - udata->cfa - args_size;\n+#endif\n+\t\t       \n   return handler;\n }\n \n@@ -3867,8 +3887,10 @@ __throw ()\n {\n   struct eh_context *eh = (*get_eh_context) ();\n   void *pc, *handler;\n-  frame_state ustruct;\n-  frame_state *udata = &ustruct;\n+  long offset;\n+\n+  /* XXX maybe make my_ustruct static so we don't have to look it up for\n+     each throw.  */\n   frame_state my_ustruct, *my_udata = &my_ustruct;\n \n   /* This is required for C++ semantics.  We must call terminate if we\n@@ -3879,14 +3901,12 @@ __throw ()\n     \n   /* Start at our stack frame.  */\n label:\n-  udata = __frame_state_for (&&label, udata);\n-  if (! udata)\n+  my_udata = __frame_state_for (&&label, my_udata);\n+  if (! my_udata)\n     __terminate ();\n \n   /* We need to get the value from the CFA register. */\n-  udata->cfa = __builtin_dwarf_cfa ();\n-\n-  memcpy (my_udata, udata, sizeof (*udata));\n+  my_udata->cfa = __builtin_dwarf_cfa ();\n \n   /* Do any necessary initialization to access arbitrary stack frames.\n      On the SPARC, this means flushing the register windows.  */\n@@ -3895,17 +3915,11 @@ __throw ()\n   /* Now reset pc to the right throw point.  */\n   pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n \n-  handler = throw_helper (eh, pc, my_udata, &udata);\n+  handler = throw_helper (eh, pc, my_udata, &offset);\n \n   /* Now go!  */\n \n-  __builtin_eh_return ((void *)eh,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t       udata->cfa - my_udata->cfa,\n-#else\n-\t\t       my_udata->cfa - udata->cfa,\n-#endif\n-\t\t       handler);\n+  __builtin_eh_return ((void *)eh, offset, handler);\n \n   /* Epilogue:  restore the handler frame's register values and return\n      to the stub.  */\n@@ -3919,8 +3933,10 @@ __rethrow (index)\n {\n   struct eh_context *eh = (*get_eh_context) ();\n   void *pc, *handler;\n-  frame_state ustruct;\n-  frame_state *udata = &ustruct;\n+  long offset;\n+\n+  /* XXX maybe make my_ustruct static so we don't have to look it up for\n+     each throw.  */\n   frame_state my_ustruct, *my_udata = &my_ustruct;\n \n   /* This is required for C++ semantics.  We must call terminate if we\n@@ -3936,14 +3952,12 @@ __rethrow (index)\n     \n   /* Start at our stack frame.  */\n label:\n-  udata = __frame_state_for (&&label, udata);\n-  if (! udata)\n+  my_udata = __frame_state_for (&&label, my_udata);\n+  if (! my_udata)\n     __terminate ();\n \n   /* We need to get the value from the CFA register. */\n-  udata->cfa = __builtin_dwarf_cfa ();\n-\n-  memcpy (my_udata, udata, sizeof (*udata));\n+  my_udata->cfa = __builtin_dwarf_cfa ();\n \n   /* Do any necessary initialization to access arbitrary stack frames.\n      On the SPARC, this means flushing the register windows.  */\n@@ -3952,17 +3966,11 @@ __rethrow (index)\n   /* Now reset pc to the right throw point.  */\n   pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n \n-  handler = throw_helper (eh, pc, my_udata, &udata);\n+  handler = throw_helper (eh, pc, my_udata, &offset);\n \n   /* Now go!  */\n \n-  __builtin_eh_return ((void *)eh,\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t       udata->cfa - my_udata->cfa,\n-#else\n-\t\t       my_udata->cfa - udata->cfa,\n-#endif\n-\t\t       handler);\n+  __builtin_eh_return ((void *)eh, offset, handler);\n \n   /* Epilogue:  restore the handler frame's register values and return\n      to the stub.  */"}]}