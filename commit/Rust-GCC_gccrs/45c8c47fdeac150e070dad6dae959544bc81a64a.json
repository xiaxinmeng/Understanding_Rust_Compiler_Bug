{"sha": "45c8c47fdeac150e070dad6dae959544bc81a64a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjOGM0N2ZkZWFjMTUwZTA3MGRhZDZkYWU5NTk1NDRiYzgxYTY0YQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@kss-loka.si", "date": "2004-09-08T05:08:26Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2004-09-08T05:08:26Z"}, "message": "i386.c (ix86_prepare_fp_compare_args): Do not force operand 0.0 into register in XFmode.\n\n        * config/i386/i386.c (ix86_prepare_fp_compare_args): Do not\n        force operand 0.0 into register in XFmode. Also do not force\n        operand 0.0 into register if !TARGET_CMOVE.\n\n        * config/i386/i386.md (*cmpfp_0): Delete. Remove comment.\n        (*cmpfp_0_sf, cmpfp_0_df, cmpfp_0_xf): New patterns to\n        implement ftst x87 instruction.\n        (*fp_jcc_7): New insn pattern. Change corresponding split\n        pattern to handle \"general_operand\" instead of\n        \"nonimmediate_operand\".\n\n----------------------------------------------------------------------\n\nFrom-SVN: r87173", "tree": {"sha": "068328e26903f537d44166eefdf174ac4771c301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/068328e26903f537d44166eefdf174ac4771c301"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45c8c47fdeac150e070dad6dae959544bc81a64a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8c47fdeac150e070dad6dae959544bc81a64a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c8c47fdeac150e070dad6dae959544bc81a64a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8c47fdeac150e070dad6dae959544bc81a64a/comments", "author": null, "committer": null, "parents": [{"sha": "70d5fb1c363d07fc927f157735985d74512002ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d5fb1c363d07fc927f157735985d74512002ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d5fb1c363d07fc927f157735985d74512002ee"}], "stats": {"total": 135, "additions": 98, "deletions": 37}, "files": [{"sha": "a6f00a14c57645697ed56a3f321591c8ef02665c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45c8c47fdeac150e070dad6dae959544bc81a64a", "patch": "@@ -1,3 +1,15 @@\n+2004-09-08  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* config/i386/i386.c (ix86_prepare_fp_compare_args): Do not\n+\tforce operand 0.0 into register in XFmode. Also do not force\n+\toperand 0.0 into register if !TARGET_CMOVE.\n+\t* config/i386/i386.md (*cmpfp_0): Delete. Remove comment.\n+\t(*cmpfp_0_sf, cmpfp_0_df, cmpfp_0_xf): New patterns to \n+\timplement ftst x87 instruction.\n+\t(*fp_jcc_7): New insn pattern. Change corresponding split\n+\tpattern to handle \"general_operand\" instead of\n+\t\"nonimmediate_operand\".\n+\n 2004-09-08  Ben Elliston  <bje@au.ibm.com>\n \n \t* doc/rtl.texi (Insns): Document NOTE_INSN_FUNCTION_BEG."}, {"sha": "3199b5756919542ac544dd7f6ce14ddd1fb8b349", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=45c8c47fdeac150e070dad6dae959544bc81a64a", "patch": "@@ -7941,12 +7941,15 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n   int is_sse = SSE_REG_P (op0) | SSE_REG_P (op1);\n \n   /* All of the unordered compare instructions only work on registers.\n-     The same is true of the XFmode compare instructions.  The same is\n-     true of the fcomi compare instructions.  */\n+     The same is true of the fcomi compare instructions.  The same is\n+     true of the XFmode compare instructions if not comparing with\n+     zero (ftst insn is used in this case).  */\n \n   if (!is_sse\n       && (fpcmp_mode == CCFPUmode\n-\t  || op_mode == XFmode\n+\t  || (op_mode == XFmode\n+\t      && ! (standard_80387_constant_p (op0) == 1\n+\t\t    || standard_80387_constant_p (op1) == 1))\n \t  || ix86_use_fcomi_compare (code)))\n     {\n       op0 = force_reg (op_mode, op0);\n@@ -7973,10 +7976,16 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n       if (CONSTANT_P (op1))\n \t{\n-\t  if (standard_80387_constant_p (op1))\n-\t    op1 = force_reg (op_mode, op1);\n-\t  else\n+\t  int tmp = standard_80387_constant_p (op1);\n+\t  if (tmp == 0)\n \t    op1 = validize_mem (force_const_mem (op_mode, op1));\n+\t  else if (tmp == 1)\n+\t    {\n+\t      if (TARGET_CMOVE)\n+\t\top1 = force_reg (op_mode, op1);\n+\t    }\n+\t  else\n+\t    op1 = force_reg (op_mode, op1);\n \t}\n     }\n "}, {"sha": "f08c85a4d44eee29023b3d6842924d1c37a024af", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8c47fdeac150e070dad6dae959544bc81a64a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=45c8c47fdeac150e070dad6dae959544bc81a64a", "patch": "@@ -797,41 +797,65 @@\n ;; CCFPmode\tcompare with exceptions\n ;; CCFPUmode\tcompare with no exceptions\n \n-;; %%% It is an unfortunate fact that ftst has no non-popping variant,\n-;; and that fp moves clobber the condition codes, and that there is\n-;; currently no way to describe this fact to reg-stack.  So there are\n-;; no splitters yet for this.\n-\n-;; %%% YIKES!  This scheme does not retain a strong connection between \n-;; the real compare and the ultimate cc0 user, so CC_REVERSE does not\n-;; work!  Only allow tos/mem with tos in op 0.\n-;;\n-;; Hmm, of course, this is what the actual _hardware_ does.  Perhaps\n-;; things aren't as bad as they sound...\n+(define_insn \"*cmpfp_0_sf\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(unspec:HI\n+\t  [(compare:CCFP\n+\t     (match_operand:SF 1 \"register_operand\" \"f\")\n+\t     (match_operand:SF 2 \"const0_operand\" \"X\"))]\n+\tUNSPEC_FNSTSW))]\n+  \"TARGET_80387\"\n+{\n+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+    {\n+      output_asm_insn (\"ftst\\;fnstsw\\t%0\", operands);\n+      return TARGET_USE_FFREEP ? \"ffreep\\t%y1\" : \"fstp\\t%y1\";\n+    }\n+  else\n+    return \"ftst\\;fnstsw\\t%0\";\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"SF\")])\n \n-(define_insn \"*cmpfp_0\"\n+(define_insn \"*cmpfp_0_df\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n \t(unspec:HI\n-\t  [(compare:CCFP (match_operand 1 \"register_operand\" \"f\")\n-\t\t         (match_operand 2 \"const0_operand\" \"X\"))]\n-\t  UNSPEC_FNSTSW))]\n-  \"TARGET_80387\n-   && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+\t  [(compare:CCFP\n+\t     (match_operand:DF 1 \"register_operand\" \"f\")\n+\t     (match_operand:DF 2 \"const0_operand\" \"X\"))]\n+\tUNSPEC_FNSTSW))]\n+  \"TARGET_80387\"\n {\n   if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-    return \"ftst\\;fnstsw\\t%0\\;fstp\\t%y0\";\n+    {\n+      output_asm_insn (\"ftst\\;fnstsw\\t%0\", operands);\n+      return TARGET_USE_FFREEP ? \"ffreep\\t%y1\" : \"fstp\\t%y1\";\n+    }\n   else\n     return \"ftst\\;fnstsw\\t%0\";\n }\n   [(set_attr \"type\" \"multi\")\n-   (set (attr \"mode\")\n-     (cond [(match_operand:SF 1 \"\" \"\")\n-\t      (const_string \"SF\")\n-\t    (match_operand:DF 1 \"\" \"\")\n-\t      (const_string \"DF\")\n-\t   ]\n-\t   (const_string \"XF\")))])\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*cmpfp_0_xf\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(unspec:HI\n+\t  [(compare:CCFP\n+\t     (match_operand:XF 1 \"register_operand\" \"f\")\n+\t     (match_operand:XF 2 \"const0_operand\" \"X\"))]\n+\tUNSPEC_FNSTSW))]\n+  \"TARGET_80387\"\n+{\n+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+    {\n+      output_asm_insn (\"ftst\\;fnstsw\\t%0\", operands);\n+      return TARGET_USE_FFREEP ? \"ffreep\\t%y1\" : \"fstp\\t%y1\";\n+    }\n+  else\n+    return \"ftst\\;fnstsw\\t%0\";\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"mode\" \"XF\")])\n \n ;; We may not use \"#\" to split and emit these, since the REG_DEAD notes\n ;; used to manage the reg stack popping would not be preserved.\n@@ -13322,6 +13346,25 @@\n    && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n+(define_insn \"*fp_jcc_7\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand 1 \"register_operand\" \"f\")\n+\t\t\t (match_operand 2 \"const_double_operand\" \"C\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))\n+   (clobber (reg:CCFP FPSR_REG))\n+   (clobber (reg:CCFP FLAGS_REG))\n+   (clobber (match_scratch:HI 4 \"=a\"))]\n+  \"TARGET_80387\n+   && FLOAT_MODE_P (GET_MODE (operands[1]))\n+   && operands[2] == CONST0_RTX (GET_MODE (operands[1]))\n+   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n+   && SELECT_CC_MODE (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2]) == CCFPmode\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n+  \"#\")\n+\n (define_split\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n@@ -13343,17 +13386,14 @@\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"\")\n-\t\t\t (match_operand 2 \"nonimmediate_operand\" \"\")])\n+\t\t\t (match_operand 2 \"general_operand\" \"\")])\n \t  (match_operand 3 \"\" \"\")\n \t  (match_operand 4 \"\" \"\")))\n    (clobber (reg:CCFP FPSR_REG))\n    (clobber (reg:CCFP FLAGS_REG))\n    (clobber (match_scratch:HI 5 \"=a\"))]\n   \"reload_completed\"\n-  [(set (pc)\n-\t(if_then_else (match_dup 6)\n-\t  (match_dup 3)\n-\t  (match_dup 4)))]\n+  [(const_int 0)]\n {\n   ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n \t     \t\toperands[3], operands[4], operands[5]);"}]}