{"sha": "84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRjNzFiYjhlY2M4NGY2Y2E1Y2JjNTY3ODZiOWJhNzRlYjA1MDU3ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-07T01:52:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-07T01:52:48Z"}, "message": "compiler: make single Btype for methods table of identical interface type\n    \n    Normally we ensure to build a single Btype for identical types.\n    We did not do this for methods table of identical interface\n    types, however. If there are two identical interface type I, I2,\n    they have the same Btype BI, but different Btypes for their\n    methods tables, BM and BM2. From the backend's point of view\n    only one of them is linked to BI. This can cause inconsitency\n    in the backend's type system, like unresolved placeholder. This\n    CL ensures we create a single Btype for methods table of\n    identical interface type.\n    \n    Reviewed-on: https://go-review.googlesource.com/92436\n\nFrom-SVN: r257436", "tree": {"sha": "24d63e86412abc324b20ce986151d07c70bf01a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24d63e86412abc324b20ce986151d07c70bf01a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/comments", "author": null, "committer": null, "parents": [{"sha": "95b88fd400cdc0300ed5a7ec7abaf90958aef58d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95b88fd400cdc0300ed5a7ec7abaf90958aef58d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95b88fd400cdc0300ed5a7ec7abaf90958aef58d"}], "stats": {"total": 60, "additions": 55, "deletions": 5}, "files": [{"sha": "81e11d1946f311c9ff1afd0249f756092697a5d2", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "patch": "@@ -1,4 +1,4 @@\n-02f11a2d5cf0db2c2675c13d92bb69529f2175dd\n+5fe998e4a18cc1dbbd4869be5c8202bda55adb33\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "eb04fe1e2293bb52984527ec67a82e71e9a5b2a3", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "patch": "@@ -9096,6 +9096,8 @@ Interface_type::get_backend_empty_interface_type(Gogo* gogo)\n   return empty_interface_type;\n }\n \n+Interface_type::Bmethods_map Interface_type::bmethods_map;\n+\n // Return a pointer to the backend representation of the method table.\n \n Btype*\n@@ -9104,6 +9106,21 @@ Interface_type::get_backend_methods(Gogo* gogo)\n   if (this->bmethods_ != NULL && !this->bmethods_is_placeholder_)\n     return this->bmethods_;\n \n+  std::pair<Interface_type*, Bmethods_map_entry> val;\n+  val.first = this;\n+  val.second.btype = NULL;\n+  val.second.is_placeholder = false;\n+  std::pair<Bmethods_map::iterator, bool> ins =\n+    Interface_type::bmethods_map.insert(val);\n+  if (!ins.second\n+      && ins.first->second.btype != NULL\n+      && !ins.first->second.is_placeholder)\n+    {\n+      this->bmethods_ = ins.first->second.btype;\n+      this->bmethods_is_placeholder_ = false;\n+      return this->bmethods_;\n+    }\n+\n   Location loc = this->location();\n \n   std::vector<Backend::Btyped_identifier>\n@@ -9160,10 +9177,14 @@ Interface_type::get_backend_methods(Gogo* gogo)\n   Btype* st = gogo->backend()->struct_type(mfields);\n   Btype* ret = gogo->backend()->pointer_type(st);\n \n-  if (this->bmethods_ != NULL && this->bmethods_is_placeholder_)\n-    gogo->backend()->set_placeholder_pointer_type(this->bmethods_, ret);\n+  if (ins.first->second.btype != NULL\n+      && ins.first->second.is_placeholder)\n+    gogo->backend()->set_placeholder_pointer_type(ins.first->second.btype,\n+                                                  ret);\n   this->bmethods_ = ret;\n+  ins.first->second.btype = ret;\n   this->bmethods_is_placeholder_ = false;\n+  ins.first->second.is_placeholder = false;\n   return ret;\n }\n \n@@ -9174,10 +9195,25 @@ Interface_type::get_backend_methods_placeholder(Gogo* gogo)\n {\n   if (this->bmethods_ == NULL)\n     {\n+      std::pair<Interface_type*, Bmethods_map_entry> val;\n+      val.first = this;\n+      val.second.btype = NULL;\n+      val.second.is_placeholder = false;\n+      std::pair<Bmethods_map::iterator, bool> ins =\n+        Interface_type::bmethods_map.insert(val);\n+      if (!ins.second && ins.first->second.btype != NULL)\n+        {\n+          this->bmethods_ = ins.first->second.btype;\n+          this->bmethods_is_placeholder_ = ins.first->second.is_placeholder;\n+          return this->bmethods_;\n+        }\n+\n       Location loc = this->location();\n-      this->bmethods_ = gogo->backend()->placeholder_pointer_type(\"\", loc,\n-\t\t\t\t\t\t\t\t  false);\n+      Btype* bt = gogo->backend()->placeholder_pointer_type(\"\", loc, false);\n+      this->bmethods_ = bt;\n+      ins.first->second.btype = bt;\n       this->bmethods_is_placeholder_ = true;\n+      ins.first->second.is_placeholder = true;\n     }\n   return this->bmethods_;\n }"}, {"sha": "234e0a6abbda0389f1d571f42bbb8e4d58c2ae48", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=84c71bb8ecc84f6ca5cbc56786b9ba74eb05057e", "patch": "@@ -3185,6 +3185,20 @@ class Interface_type : public Type\n   bool\n   assume_identical(const Interface_type*, const Interface_type*) const;\n \n+  struct Bmethods_map_entry\n+  {\n+    Btype *btype;\n+    bool is_placeholder;\n+  };\n+\n+  // A mapping from Interface_type to the backend type of its bmethods_,\n+  // used to ensure that the backend representation of identical types\n+  // is identical.\n+  typedef Unordered_map_hash(const Interface_type*, Bmethods_map_entry,\n+                             Type_hash_identical, Type_identical) Bmethods_map;\n+\n+  static Bmethods_map bmethods_map;\n+\n   // The list of methods associated with the interface from the\n   // parser.  This will be NULL for the empty interface.  This may\n   // include unnamed interface types."}]}