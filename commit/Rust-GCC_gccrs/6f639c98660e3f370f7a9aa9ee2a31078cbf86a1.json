{"sha": "6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2MzljOTg2NjBlM2YzNzBmN2E5YWE5ZWUyYTMxMDc4Y2JmODZhMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonber@gnat.com", "date": "2004-10-27T13:01:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T13:01:17Z"}, "message": "exp_aggr.adb (Safe_Component): An aggregate component that is an unchecked conversion is safe for in-place use...\n\n2004-10-26  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_aggr.adb (Safe_Component): An aggregate component that is an\n\tunchecked conversion is safe for in-place use if the expression of the\n\tconversion is safe.\n\t(Expand_Array_Aggregate): An aggregate that initializes an allocator may\n\tbe expandable in place even if the aggregate does not come from source.\n\t(Convert_Array_Aggr_In_Allocator): New procedure to initialize the\n\tdesignated object of an allocator in place, rather than building it\n\tfirst on the stack. The previous scheme forces a full copy of the array,\n\tand may be altogether unsusable if the size of the array is too large\n\tfor stack allocation.\n\nFrom-SVN: r89649", "tree": {"sha": "38f58aeaaa79459002a7d7a695dee8c1dacc789c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38f58aeaaa79459002a7d7a695dee8c1dacc789c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1/comments", "author": null, "committer": null, "parents": [{"sha": "057742339839a36409a581887adc9cb529656ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057742339839a36409a581887adc9cb529656ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/057742339839a36409a581887adc9cb529656ba4"}], "stats": {"total": 92, "additions": 84, "deletions": 8}, "files": [{"sha": "d18a02edae727d07d470679317183bae1dcbdd26", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 84, "deletions": 8, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f639c98660e3f370f7a9aa9ee2a31078cbf86a1/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=6f639c98660e3f370f7a9aa9ee2a31078cbf86a1", "patch": "@@ -144,6 +144,16 @@ package body Exp_Aggr is\n    -- Local Subprograms for Array Aggregate Expansion --\n    -----------------------------------------------------\n \n+   procedure Convert_Array_Aggr_In_Allocator\n+     (Decl   : Node_Id;\n+      Aggr   : Node_Id;\n+      Target : Node_Id);\n+   --  If the aggregate appears within an allocator and can be expanded in\n+   --  place, this routine generates the individual assignments to components\n+   --  of the designated object. This is an optimization over the general\n+   --  case, where a temporary is first created on the stack and then used to\n+   --  construct the allocated object on the heap.\n+\n    procedure Convert_To_Positional\n      (N                    : Node_Id;\n       Max_Others_Replicate : Nat     := 5;\n@@ -2348,7 +2358,10 @@ package body Exp_Aggr is\n       Access_Type : constant Entity_Id := Etype (Temp);\n \n    begin\n-      if Has_Default_Init_Comps (Aggr) then\n+      if Is_Array_Type (Typ) then\n+         Convert_Array_Aggr_In_Allocator (Decl, Aggr, Occ);\n+\n+      elsif Has_Default_Init_Comps (Aggr) then\n          declare\n             L          : constant List_Id := New_List;\n             Init_Stmts : List_Id;\n@@ -2491,6 +2504,34 @@ package body Exp_Aggr is\n       Initialize_Discriminants (N, Typ);\n    end Convert_Aggr_In_Object_Decl;\n \n+   -------------------------------------\n+   -- Convert_array_Aggr_In_Allocator --\n+   -------------------------------------\n+\n+   procedure Convert_Array_Aggr_In_Allocator\n+     (Decl   : Node_Id;\n+      Aggr   : Node_Id;\n+      Target : Node_Id)\n+   is\n+      Aggr_Code : List_Id;\n+      Typ       : constant Entity_Id := Etype (Aggr);\n+      Ctyp      : constant Entity_Id := Component_Type (Typ);\n+\n+   begin\n+      --  The target is an explicit dereference of the allocated object.\n+      --  Generate component assignments to it, as for an aggregate that\n+      --  appears on the right-hand side of an assignment statement.\n+\n+      Aggr_Code :=\n+        Build_Array_Aggr_Code (Aggr,\n+          Ctype       => Ctyp,\n+          Index       => First_Index (Typ),\n+          Into        => Target,\n+          Scalar_Comp => Is_Scalar_Type (Ctyp));\n+\n+      Insert_Actions_After (Decl, Aggr_Code);\n+   end Convert_Array_Aggr_In_Allocator;\n+\n    ----------------------------\n    -- Convert_To_Assignments --\n    ----------------------------\n@@ -3451,7 +3492,10 @@ package body Exp_Aggr is\n                            and then Check_Component (Right_Opnd (Comp)))\n \n                  or else (Nkind (Comp) = N_Selected_Component\n-                           and then Check_Component (Prefix (Comp)));\n+                           and then Check_Component (Prefix (Comp)))\n+\n+                 or else (Nkind (Comp) = N_Unchecked_Type_Conversion\n+                           and then Check_Component (Expression (Comp)));\n             end Check_Component;\n \n          --  Start of processing for Safe_Component\n@@ -3511,7 +3555,17 @@ package body Exp_Aggr is\n             end if;\n \n             Aggr_In := First_Index (Etype (N));\n-            Obj_In  := First_Index (Etype (Name (Parent (N))));\n+            if Nkind (Parent (N)) = N_Assignment_Statement then\n+               Obj_In  := First_Index (Etype (Name (Parent (N))));\n+\n+            else\n+               --  Context is an allocator. Check bounds of aggregate\n+               --  against given type in qualified expression.\n+\n+               pragma Assert (Nkind (Parent (Parent (N))) = N_Allocator);\n+               Obj_In :=\n+                 First_Index (Etype (Entity (Subtype_Mark (Parent (N)))));\n+            end if;\n \n             while Present (Aggr_In) loop\n                Get_Index_Bounds (Aggr_In, Aggr_Lo, Aggr_Hi);\n@@ -4000,20 +4054,33 @@ package body Exp_Aggr is\n       --  create a temporary. The analysis for safety of on-line assignment\n       --  is delicate, i.e. we don't know how to do it fully yet ???\n \n+      --  For allocators we assign to the designated object in place if the\n+      --  aggregate meets the same conditions as other in-place assignments.\n+      --  In this case the aggregate may not come from source but was created\n+      --  for default initialization, e.g. with Initialize_Scalars.\n+\n       if Requires_Transient_Scope (Typ) then\n          Establish_Transient_Scope\n            (N, Sec_Stack => Has_Controlled_Component (Typ));\n       end if;\n \n       if Has_Default_Init_Comps (N) then\n          Maybe_In_Place_OK := False;\n+\n+      elsif Is_Bit_Packed_Array (Typ)\n+        or else Has_Controlled_Component (Typ)\n+      then\n+         Maybe_In_Place_OK := False;\n+\n       else\n          Maybe_In_Place_OK :=\n-           Comes_From_Source (N)\n-             and then Nkind (Parent (N)) = N_Assignment_Statement\n-             and then not Is_Bit_Packed_Array (Typ)\n-             and then not Has_Controlled_Component (Typ)\n-             and then In_Place_Assign_OK;\n+          (Nkind (Parent (N)) = N_Assignment_Statement\n+             and then Comes_From_Source (N)\n+             and then In_Place_Assign_OK)\n+\n+          or else\n+            (Nkind (Parent (Parent (N))) = N_Allocator\n+              and then In_Place_Assign_OK);\n       end if;\n \n       if not Has_Default_Init_Comps (N)\n@@ -4046,6 +4113,15 @@ package body Exp_Aggr is\n             Set_Etype (Tmp, Typ);\n          end if;\n \n+      elsif Maybe_In_Place_OK\n+        and then Nkind (Parent (N)) = N_Qualified_Expression\n+        and then Nkind (Parent (Parent (N))) = N_Allocator\n+      then\n+         Set_Expansion_Delayed (N);\n+         return;\n+\n+      --  In the remaining cases  the aggregate is the RHS of an assignment.\n+\n       elsif Maybe_In_Place_OK\n         and then Is_Entity_Name (Name (Parent (N)))\n       then"}]}