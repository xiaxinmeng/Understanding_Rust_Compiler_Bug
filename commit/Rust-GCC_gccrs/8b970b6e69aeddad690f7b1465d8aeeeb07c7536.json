{"sha": "8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5NzBiNmU2OWFlZGRhZDY5MGY3YjE0NjVkOGFlZWViMDdjNzUzNg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2015-06-30T16:46:45Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2015-06-30T16:46:45Z"}, "message": "IA MCU psABI support: testsuite\n\nWe run Intel MCU psABI tests on Linux/ia32 with -miamcu.  Since Intel\nMCU psABI has a different calling convention, the only Linux libc function\nallowed is \"abort\".\n\nasm-support.S contains some support functions as well as a subset of\nsoft-fp, which is written in assembly with x87 instructions, to provide\nintrinsics needed by -miamcu so that Intel MCU psABI tests can run on\nLinux.\n\n\t* gcc.target/i386/iamcu/abi-iamcu.exp: New file.\n\t* gcc.target/i386/iamcu/args.h: Likewise.\n\t* gcc.target/i386/iamcu/asm-support.S: Likewise.\n\t* gcc.target/i386/iamcu/defines.h: Likewise.\n\t* gcc.target/i386/iamcu/macros.h: Likewise.\n\t* gcc.target/i386/iamcu/test_3_element_struct_and_unions.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_64bit_returning.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_alignment.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_array_size_and_align.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_returning.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_sizes.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_struct_size_and_align.c: Likewise.\n\t* gcc.target/i386/iamcu/test_basic_union_size_and_align.c: Likewise.\n\t* gcc.target/i386/iamcu/test_bitfields.c: Likewise.\n\t* gcc.target/i386/iamcu/test_complex_returning.c: Likewise.\n\t* gcc.target/i386/iamcu/test_passing_floats.c: Likewise.\n\t* gcc.target/i386/iamcu/test_passing_integers.c: Likewise.\n\t* gcc.target/i386/iamcu/test_passing_structs.c: Likewise.\n\t* gcc.target/i386/iamcu/test_passing_structs_and_unions.c: Likewise.\n\t* gcc.target/i386/iamcu/test_passing_unions.c: Likewise.\n\t* gcc.target/i386/iamcu/test_struct_returning.c: Likewise.\n\t* gcc.target/i386/iamcu/test_varargs.c: Likewise.\n\nFrom-SVN: r225199", "tree": {"sha": "890a747b830c9982992cb3332cff8437ea2a9a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/890a747b830c9982992cb3332cff8437ea2a9a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb78b51ca0b545a8d6b0b72a3aa108f3012de4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb78b51ca0b545a8d6b0b72a3aa108f3012de4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb78b51ca0b545a8d6b0b72a3aa108f3012de4ee"}], "stats": {"total": 3458, "additions": 3458, "deletions": 0}, "files": [{"sha": "33877d4d798c9b1f7c1659d3079b9ee314d2cd26", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -1,3 +1,28 @@\n+2015-06-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/iamcu/abi-iamcu.exp: New file.\n+\t* gcc.target/i386/iamcu/args.h: Likewise.\n+\t* gcc.target/i386/iamcu/asm-support.S: Likewise.\n+\t* gcc.target/i386/iamcu/defines.h: Likewise.\n+\t* gcc.target/i386/iamcu/macros.h: Likewise.\n+\t* gcc.target/i386/iamcu/test_3_element_struct_and_unions.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_64bit_returning.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_alignment.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_array_size_and_align.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_returning.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_sizes.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_struct_size_and_align.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_basic_union_size_and_align.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_bitfields.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_complex_returning.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_passing_floats.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_passing_integers.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_passing_structs.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_passing_structs_and_unions.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_passing_unions.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_struct_returning.c: Likewise.\n+\t* gcc.target/i386/iamcu/test_varargs.c: Likewise.\n+\n 2015-06-30  Marek Polacek  <polacek@redhat.com>\n \n \t* gcc.dg/fold-minus-6.c: New test."}, {"sha": "b5b3261039aa2a9421bc59cfb4916115211ae1f9", "filename": "gcc/testsuite/gcc.target/i386/iamcu/abi-iamcu.exp", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fabi-iamcu.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fabi-iamcu.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fabi-iamcu.exp?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,42 @@\n+# Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The Intel MCU psABI testsuite needs one additional assembler file for\n+# most testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+\n+if { (![istarget x86_64-*-linux*] && ![istarget i?86-*-linux*])\n+     || ![is-effective-target ia32] } then {\n+  return\n+}\n+\n+\n+torture-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-miamcu -W -Wall -Wno-abi\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+\tc-torture-execute [list $src \\\n+\t\t\t\t$srcdir/$subdir/asm-support.S] \\\n+\t\t\t\t$additional_flags\n+    }\n+}\n+\n+torture-finish"}, {"sha": "f8abde401556121f4c5690270011a1c069959946", "filename": "gcc/testsuite/gcc.target/i386/iamcu/args.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fargs.h?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,77 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 eax\n+#define I1 edx\n+#define I2 ecx\n+\n+typedef unsigned int size_t;\n+\n+extern void (*callthis)(void);\n+extern unsigned long eax,ebx,ecx,edx,esi,edi,esp,ebp;\n+extern unsigned long sret_eax;\n+extern volatile unsigned long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+extern void *iamcu_memset (void *, int, size_t);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all scratch integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%eax, %%eax\\n\\t\" \\\n+\t\t    \"xor %%edx, %%edx\\n\\t\" \\\n+\t\t    \"xor %%ecx, %%ecx\\n\\t\" \\\n+\t\t    ::: \"eax\", \"edx\", \"ecx\");\n+\n+/* Clear all scratch integer registers, excluding the one used to return\n+   aggregate.  */\n+#define clear_non_sret_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%edx, %%ebx\\n\\t\" \\\n+\t\t    \"xor %%ecx, %%ecx\\n\\t\" \\\n+\t\t    ::: \"edx\", \"ecx\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long eax, ebx, ecx, edx, esi, edi;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs, iregbits;\n+extern unsigned int num_iregs;\n+\n+#define check_int_arguments do { \\\n+  assert (num_iregs <= 0 || (iregs.I0 & iregbits.I0) == (I0 & iregbits.I0)); \\\n+  assert (num_iregs <= 1 || (iregs.I1 & iregbits.I1) == (I1 & iregbits.I1)); \\\n+  assert (num_iregs <= 2 || (iregs.I2 & iregbits.I2) == (I2 & iregbits.I2)); \\\n+  } while (0)\n+\n+#define check_char_arguments check_int_arguments\n+#define check_short_arguments check_int_arguments\n+#define check_long_arguments check_int_arguments\n+#define check_float_arguments check_int_arguments\n+#define check_double_arguments check_int_arguments\n+#define check_ldouble_arguments check_int_arguments\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  eax = edx = ecx = 0; \\\n+  iamcu_memset (&iregs, 0, sizeof iregs);\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+/* Clear both hardware and register structs for integers, excluding the\n+   one used to return aggregate.  */\n+#define clear_non_sret_int_registers \\\n+  clear_struct_registers \\\n+  clear_non_sret_int_hardware_registers\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "b4a4a140e54ce761d13513be4c8751418e69aa93", "filename": "gcc/testsuite/gcc.target/i386/iamcu/asm-support.S", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fasm-support.S?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,302 @@\n+\t.comm\tcallthis,4,4\n+\t.comm\teax,4,4\n+\t.comm\tebx,4,4\n+\t.comm\tecx,4,4\n+\t.comm\tedx,4,4\n+\t.comm\tesi,4,4\n+\t.comm\tedi,4,4\n+\t.comm\tesp,4,4\n+\t.comm\tebp,4,4\n+\t.comm\tsret_eax,4,4\n+\t.comm   volatile_var,4,4\n+\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+\tmovl\t%eax, eax\n+\tmovl\t%ebx, ebx\n+\tmovl\t%ecx, ecx\n+\tmovl\t%edx, edx\n+\tmovl\t%edi, edi\n+\tmovl\t%esi, esi\n+\tmovl\t%ebp, ebp\n+\tmovl\t%esp, esp\n+\tjmp\t*callthis\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovl\t%eax, sret_eax\n+\tcall\t*callthis\n+\tmovl\t%eax, eax\n+\tmovl\t%edx, edx\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.p2align 4,,15\n+\t.globl\t__nesf2\n+\t.type\t__nesf2, @function\n+__nesf2:\n+\t.cfi_startproc\n+\tsubl\t$4, %esp\n+\t.cfi_def_cfa_offset 8\n+\tmovl\t%eax, (%esp)\n+\tmovl\t$1, %eax\n+\tfildl\t(%esp)\n+\tmovl\t%edx, (%esp)\n+\txorl\t%edx, %edx\n+\tfildl\t(%esp)\n+\tfucomip\t%st(1), %st\n+\tfstp\t%st(0)\n+\tsetp\t%dl\n+\tcmove\t%edx, %eax\n+\taddl\t$4, %esp\n+\t.cfi_def_cfa_offset 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__nesf2, .-__nesf2\n+\n+\t.p2align 4,,15\n+\t.globl\t__nedf2\n+\t.type\t__nedf2, @function\n+__nedf2:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tandl\t$-8, %esp\n+\tsubl\t$8, %esp\n+\tmovl\t%eax, (%esp)\n+\tmovl\t$1, %eax\n+\tmovl\t%edx, 4(%esp)\n+\txorl\t%edx, %edx\n+\tfildq\t(%esp)\n+\tfildq\t8(%ebp)\n+\tfucomip\t%st(1), %st\n+\tfstp\t%st(0)\n+\tsetp\t%dl\n+\tcmove\t%edx, %eax\n+\tleave\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__nedf2, .-__nedf2\n+\n+\t.p2align 4,,15\n+\t.globl\t__addsf3\n+\t.type\t__addsf3, @function\n+__addsf3:\n+\t.cfi_startproc\n+\tsubl\t$4, %esp\n+\t.cfi_def_cfa_offset 8\n+\tmovl\t%eax, (%esp)\n+\tflds\t(%esp)\n+\tmovl\t%edx, (%esp)\n+\tflds\t(%esp)\n+\tfaddp\t%st, %st(1)\n+\tfstps\t(%esp)\n+\tmovl\t(%esp), %eax\n+\taddl\t$4, %esp\n+\t.cfi_def_cfa_offset 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__addsf3, .-__addsf3\n+\n+\t.p2align 4,,15\n+\t.globl\t__adddf3\n+\t.type\t__adddf3, @function\n+__adddf3:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tandl\t$-8, %esp\n+\tsubl\t$8, %esp\n+\tmovl\t%eax, (%esp)\n+\tmovl\t%edx, 4(%esp)\n+\tfldl\t(%esp)\n+\tfaddl\t8(%ebp)\n+\tfstpl\t(%esp)\n+\tmovl\t(%esp), %eax\n+\tmovl\t4(%esp), %edx\n+\tleave\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__adddf3, .-__adddf3\n+\n+\t.p2align 4,,15\n+\t.globl\t__floatsisf\n+\t.type\t__floatsisf, @function\n+__floatsisf:\n+\t.cfi_startproc\n+\tsubl\t$4, %esp\n+\t.cfi_def_cfa_offset 8\n+\tmovl\t%eax, (%esp)\n+\tfildl\t(%esp)\n+\taddl\t$4, %esp\n+\t.cfi_def_cfa_offset 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__floatsisf, .-__floatsisf\n+\n+\t.p2align 4,,15\n+\t.globl\t__floatunsisf\n+\t.type\t__floatunsisf, @function\n+__floatunsisf:\n+\t.cfi_startproc\n+\tsubl\t$8, %esp\n+\t.cfi_def_cfa_offset 12\n+\txorl\t%edx, %edx\n+\tmovl\t%eax, (%esp)\n+\tmovl\t%edx, 4(%esp)\n+\tfildq\t(%esp)\n+\taddl\t$8, %esp\n+\t.cfi_def_cfa_offset 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__floatunsisf, .-__floatunsisf\n+\n+\t.globl\t__extendsfdf2\n+\t.type\t__extendsfdf2, @function\n+__extendsfdf2:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tandl\t$-8, %esp\n+\tsubl\t$8, %esp\n+\tmovl\t%eax, (%esp)\n+\tflds\t(%esp)\n+\tfstpl\t(%esp)\n+\tmovl\t(%esp), %eax\n+\tmovl\t4(%esp), %edx\n+\tleave\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__extendsfdf2, .-__extendsfdf2\n+\n+\t.p2align 4,,15\n+\t.globl\t__truncdfsf2\n+\t.type\t__truncdfsf2, @function\n+__truncdfsf2:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tandl\t$-8, %esp\n+\tsubl\t$12, %esp\n+\tmovl\t%eax, (%esp)\n+\tmovl\t%edx, 4(%esp)\n+\tfldl\t(%esp)\n+\tfstps\t(%esp)\n+\tmovl\t(%esp), %eax\n+\tleave\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+\t.cfi_endproc\n+\t.size\t__truncdfsf2, .-__truncdfsf2\n+\n+\t.p2align 4,,15\n+\t.globl\tiamcu_memset\n+\t.type\tiamcu_memset, @function\n+iamcu_memset:\n+\t.cfi_startproc\n+\tpushl\t%edi\n+\t.cfi_adjust_cfa_offset 4\n+\t.cfi_rel_offset %edi, 0\n+\tmovl\t%eax, %edi\n+\tmovzbl\t%dl, %eax\n+\tmovl\t%edi, %edx\n+\trep stosb\n+\tmovl\t%edx, %eax\n+\tpopl\t%edi\n+\t.cfi_adjust_cfa_offset -4\n+\t.cfi_restore %edi\n+\tret\n+\t.cfi_endproc\n+\t.size\tiamcu_memset, .-iamcu_memset\n+\n+\t.p2align 4,,15\n+\t.globl\tiamcu_noprintf\n+\t.type\tiamcu_noprintf, @function\n+iamcu_noprintf:\n+\t.cfi_startproc\n+\tpushl\t%ebp\n+\t.cfi_def_cfa_offset 8\n+\t.cfi_offset 5, -8\n+\tmovl\t%esp, %ebp\n+\t.cfi_def_cfa_register 5\n+\tcmpl\t$-1414676753, 8(%ebp)\n+\tfldl\t16(%ebp)\n+\tfldl\t28(%ebp)\n+\tjne\t7f\n+\tcmpl\t$256, 12(%ebp)\n+\tjne\t8f\n+\tflds\t.LCiamcu_noprintf0\n+\tmovl\t$1, %eax\n+\tfucomip\t%st(2), %st\n+\tfstp\t%st(1)\n+\tsetp\t%dl\n+\tcmovne\t%eax, %edx\n+\ttestb\t%dl, %dl\n+\tjne\t9f\n+\tcmpl\t$-1146241297, 24(%ebp)\n+\tjne\t10f\n+\tflds\t.LCiamcu_noprintf1\n+\tfucomip\t%st(1), %st\n+\tfstp\t%st(0)\n+\tsetp\t%dl\n+\tcmove\t%edx, %eax\n+\ttestb\t%al, %al\n+\tjne\t2f\n+\tcmpl\t$259, 36(%ebp)\n+\tjne\t2f\n+\tpopl\t%ebp\n+\t.cfi_remember_state\n+\t.cfi_restore 5\n+\t.cfi_def_cfa 4, 4\n+\tret\n+7:\n+\t.cfi_restore_state\n+\tfstp\t%st(0)\n+\tfstp\t%st(0)\n+\tjmp\t2f\n+8:\n+\tfstp\t%st(0)\n+\tfstp\t%st(0)\n+\t.p2align 4,,3\n+\tjmp\t2f\n+9:\n+\tfstp\t%st(0)\n+\tjmp\t2f\n+10:\n+\tfstp\t%st(0)\n+2:\n+\tcall\tabort\n+\t.cfi_endproc\n+\t.size\tiamcu_noprintf, .-iamcu_noprintf\n+\t.section\t.rodata.cst4,\"aM\",@progbits,4\n+\t.align 4\n+.LCiamcu_noprintf0:\n+\t.long\t1132494848\n+\t.align 4\n+.LCiamcu_noprintf1:\n+\t.long\t1132527616"}, {"sha": "e715f4247f5ea0e26b822ecc8b028a4e7081d599", "filename": "gcc/testsuite/gcc.target/i386/iamcu/defines.h", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fdefines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fdefines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fdefines.h?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,110 @@\n+#ifndef DEFINED_DEFINES_H\n+#define DEFINED_DEFINES_H\n+\n+typedef unsigned long long ulonglong;\n+typedef long double ldouble;\n+\n+/* These defines determines what part of the test should be run.  When\n+   GCC implements these parts, the defines should be uncommented to\n+   enable testing.  */\n+\n+/* Scalar type long double.  */\n+#define CHECK_LONG_DOUBLE\n+\n+/* Scalar type __float128.  */\n+#define CHECK_FLOAT128\n+\n+/* Returning of complex type.  */\n+#define CHECK_COMPLEX\n+\n+/* Structs with size > 8.  */\n+#define CHECK_LARGER_STRUCTS\n+\n+/* Checks for passing floats and doubles.  */\n+#define CHECK_FLOAT_DOUBLE_PASSING\n+\n+/* Union passing with not-extremely-simple unions.  */\n+#define CHECK_LARGER_UNION_PASSING\n+\n+/* Variable args.  */\n+#define CHECK_VARARGS\n+\n+/* Check argument passing and returning for scalar types with sizeof > 8.  */\n+#define CHECK_LARGE_SCALAR_PASSING\n+\n+/* Defines for sizing and alignment.  */\n+\n+#define TYPE_SIZE_CHAR         1\n+#define TYPE_SIZE_SHORT        2\n+#define TYPE_SIZE_INT          4\n+#define TYPE_SIZE_LONG         4\n+#define TYPE_SIZE_LONG_LONG    8\n+#define TYPE_SIZE_FLOAT        4\n+#define TYPE_SIZE_DOUBLE       8\n+#define TYPE_SIZE_LONG_DOUBLE  8\n+#define TYPE_SIZE_FLOAT128     16\n+#define TYPE_SIZE_ENUM         4\n+#define TYPE_SIZE_POINTER      4\n+\n+#define TYPE_ALIGN_CHAR        1\n+#define TYPE_ALIGN_SHORT       2\n+#define TYPE_ALIGN_INT         4\n+#define TYPE_ALIGN_LONG        4\n+#define TYPE_ALIGN_LONG_LONG   4\n+#define TYPE_ALIGN_FLOAT       4\n+#define TYPE_ALIGN_DOUBLE      4\n+#define TYPE_ALIGN_LONG_DOUBLE 4\n+#define TYPE_ALIGN_FLOAT128    4\n+#define TYPE_ALIGN_ENUM        4\n+#define TYPE_ALIGN_POINTER     4\n+\n+/* These defines control the building of the list of types to check. There\n+   is a string identifying the type (with a comma after), a size of the type\n+   (also with a comma and an integer for adding to the total amount of types)\n+   and an alignment of the type (which is currently not really needed since\n+   the abi specifies that alignof == sizeof for all scalar types).  */\n+#ifdef CHECK_LONG_DOUBLE\n+#define CLD_STR \"long double\",\n+#define CLD_SIZ TYPE_SIZE_LONG_DOUBLE,\n+#define CLD_ALI TYPE_ALIGN_LONG_DOUBLE,\n+#define CLD_RET \"???\",\n+#else\n+#define CLD_STR\n+#define CLD_SIZ\n+#define CLD_ALI\n+#define CLD_RET\n+#endif\n+#ifdef CHECK_FLOAT128\n+#define CF128_STR \"__float128\",\n+#define CF128_SIZ TYPE_SIZE_FLOAT128,\n+#define CF128_ALI TYPE_ALIGN_FLOAT128,\n+#define CF128_RET \"???\",\n+#else\n+#define CF128_STR\n+#define CF128_SIZ\n+#define CF128_ALI\n+#define CF128_RET\n+#endif\n+\n+/* Used in size and alignment tests.  */\n+enum dummytype { enumtype };\n+\n+extern void abort (void);\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+#ifdef __GNUC__\n+#define PACKED __attribute__((__packed__))\n+#else\n+#warning Some tests will fail due to missing __packed__ support\n+#define PACKED\n+#endif\n+\n+#endif /* DEFINED_DEFINES_H */"}, {"sha": "98fbc660f277504edecccd7425b1cca41a19932f", "filename": "gcc/testsuite/gcc.target/i386/iamcu/macros.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Fmacros.h?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,53 @@\n+#ifndef MACROS_H\n+\n+#define check_size(_t, _size) assert(sizeof(_t) == (_size))\n+\n+#define check_align(_t, _align) assert(__alignof__(_t) == (_align))\n+\n+#define check_align_lv(_t, _align) assert(__alignof__(_t) == (_align) \\\n+\t\t\t\t\t  && (((unsigned long)&(_t)) & ((_align) - 1) ) == 0)\n+\n+#define check_basic_struct_size_and_align(_type, _size, _align) { \\\n+  struct _str { _type dummy; } _t; \\\n+  check_size(_t, _size); \\\n+  check_align_lv(_t, _align); \\\n+}\n+\n+#define check_array_size_and_align(_type, _size, _align) { \\\n+  _type _a[1]; _type _b[2]; _type _c[16]; \\\n+  struct _str { _type _a[1]; } _s; \\\n+  check_align_lv(_a[0], _align); \\\n+  check_size(_a, _size); \\\n+  check_size(_b, (_size*2)); \\\n+  check_size(_c, (_size*16)); \\\n+  check_size(_s, _size); \\\n+  check_align_lv(_s._a[0], _align); \\\n+}\n+\n+#define check_basic_union_size_and_align(_type, _size, _align) { \\\n+  union _union { _type dummy; } _u; \\\n+  check_size(_u, _size); \\\n+  check_align_lv(_u, _align); \\\n+}\n+\n+#define run_signed_tests2(_function, _arg1, _arg2) \\\n+  _function(_arg1, _arg2); \\\n+  _function(signed _arg1, _arg2); \\\n+  _function(unsigned _arg1, _arg2);\n+\n+#define run_signed_tests3(_function, _arg1, _arg2, _arg3) \\\n+  _function(_arg1, _arg2, _arg3); \\\n+  _function(signed _arg1, _arg2, _arg3); \\\n+  _function(unsigned _arg1, _arg2, _arg3);\n+\n+/* Check size of a struct and a union of three types.  */\n+\n+#define check_struct_and_union3(type1, type2, type3, struct_size, align_size) \\\n+{ \\\n+  struct _str { type1 t1; type2 t2; type3 t3; } _t; \\\n+  union _uni { type1 t1; type2 t2; type3 t3; } _u; \\\n+  check_size(_t, struct_size); \\\n+  check_size(_u, align_size); \\\n+}\n+\n+#endif // MACROS_H"}, {"sha": "7bec21199340ca1633ab8d738c33f08e500c8a9a", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_3_element_struct_and_unions.c", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_3_element_struct_and_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_3_element_struct_and_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_3_element_struct_and_unions.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,521 @@\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+/* Check structs and unions of all permutations of 3 basic types.  */\n+int\n+main (void)\n+{\n+  check_struct_and_union3(char, char, char, 3, 1);\n+  check_struct_and_union3(char, char, short, 4, 2);\n+  check_struct_and_union3(char, char, int, 8, 4);\n+  check_struct_and_union3(char, char, long, 8, 4);\n+  check_struct_and_union3(char, char, long long, 12, 8);\n+  check_struct_and_union3(char, char, float, 8, 4);\n+  check_struct_and_union3(char, char, double, 12, 8);\n+  check_struct_and_union3(char, char, long double, 12, 8);\n+  check_struct_and_union3(char, short, char, 6, 2);\n+  check_struct_and_union3(char, short, short, 6, 2);\n+  check_struct_and_union3(char, short, int, 8, 4);\n+  check_struct_and_union3(char, short, long, 8, 4);\n+  check_struct_and_union3(char, short, long long, 12, 8);\n+  check_struct_and_union3(char, short, float, 8, 4);\n+  check_struct_and_union3(char, short, double, 12, 8);\n+  check_struct_and_union3(char, short, long double, 12, 8);\n+  check_struct_and_union3(char, int, char, 12, 4);\n+  check_struct_and_union3(char, int, short, 12, 4);\n+  check_struct_and_union3(char, int, int, 12, 4);\n+  check_struct_and_union3(char, int, long, 12, 4);\n+  check_struct_and_union3(char, int, long long, 16, 8);\n+  check_struct_and_union3(char, int, float, 12, 4);\n+  check_struct_and_union3(char, int, double, 16, 8);\n+  check_struct_and_union3(char, int, long double, 16, 8);\n+  check_struct_and_union3(char, long, char, 12, 4);\n+  check_struct_and_union3(char, long, short, 12, 4);\n+  check_struct_and_union3(char, long, int, 12, 4);\n+  check_struct_and_union3(char, long, long, 12, 4);\n+  check_struct_and_union3(char, long, long long, 16, 8);\n+  check_struct_and_union3(char, long, float, 12, 4);\n+  check_struct_and_union3(char, long, double, 16, 8);\n+  check_struct_and_union3(char, long, long double, 16, 8);\n+  check_struct_and_union3(char, long long, char, 16, 8);\n+  check_struct_and_union3(char, long long, short, 16, 8);\n+  check_struct_and_union3(char, long long, int, 16, 8);\n+  check_struct_and_union3(char, long long, long, 16, 8);\n+  check_struct_and_union3(char, long long, long long, 20, 8);\n+  check_struct_and_union3(char, long long, float, 16, 8);\n+  check_struct_and_union3(char, long long, double, 20, 8);\n+  check_struct_and_union3(char, long long, long double, 20, 8);\n+  check_struct_and_union3(char, float, char, 12, 4);\n+  check_struct_and_union3(char, float, short, 12, 4);\n+  check_struct_and_union3(char, float, int, 12, 4);\n+  check_struct_and_union3(char, float, long, 12, 4);\n+  check_struct_and_union3(char, float, long long, 16, 8);\n+  check_struct_and_union3(char, float, float, 12, 4);\n+  check_struct_and_union3(char, float, double, 16, 8);\n+  check_struct_and_union3(char, float, long double, 16, 8);\n+  check_struct_and_union3(char, double, char, 16, 8);\n+  check_struct_and_union3(char, double, short, 16, 8);\n+  check_struct_and_union3(char, double, int, 16, 8);\n+  check_struct_and_union3(char, double, long, 16, 8);\n+  check_struct_and_union3(char, double, long long, 20, 8);\n+  check_struct_and_union3(char, double, float, 16, 8);\n+  check_struct_and_union3(char, double, double, 20, 8);\n+  check_struct_and_union3(char, double, long double, 20, 8);\n+  check_struct_and_union3(char, long double, char, 16, 8);\n+  check_struct_and_union3(char, long double, short, 16, 8);\n+  check_struct_and_union3(char, long double, int, 16, 8);\n+  check_struct_and_union3(char, long double, long, 16, 8);\n+  check_struct_and_union3(char, long double, long long, 20, 8);\n+  check_struct_and_union3(char, long double, float, 16, 8);\n+  check_struct_and_union3(char, long double, double, 20, 8);\n+  check_struct_and_union3(char, long double, long double, 20, 8);\n+  check_struct_and_union3(short, char, char, 4, 2);\n+  check_struct_and_union3(short, char, short, 6, 2);\n+  check_struct_and_union3(short, char, int, 8, 4);\n+  check_struct_and_union3(short, char, long, 8, 4);\n+  check_struct_and_union3(short, char, long long, 12, 8);\n+  check_struct_and_union3(short, char, float, 8, 4);\n+  check_struct_and_union3(short, char, double, 12, 8);\n+  check_struct_and_union3(short, char, long double, 12, 8);\n+  check_struct_and_union3(short, short, char, 6, 2);\n+  check_struct_and_union3(short, short, short, 6, 2);\n+  check_struct_and_union3(short, short, int, 8, 4);\n+  check_struct_and_union3(short, short, long, 8, 4);\n+  check_struct_and_union3(short, short, long long, 12, 8);\n+  check_struct_and_union3(short, short, float, 8, 4);\n+  check_struct_and_union3(short, short, double, 12, 8);\n+  check_struct_and_union3(short, short, long double, 12, 8);\n+  check_struct_and_union3(short, int, char, 12, 4);\n+  check_struct_and_union3(short, int, short, 12, 4);\n+  check_struct_and_union3(short, int, int, 12, 4);\n+  check_struct_and_union3(short, int, long, 12, 4);\n+  check_struct_and_union3(short, int, long long, 16, 8);\n+  check_struct_and_union3(short, int, float, 12, 4);\n+  check_struct_and_union3(short, int, double, 16, 8);\n+  check_struct_and_union3(short, int, long double, 16, 8);\n+  check_struct_and_union3(short, long, char, 12, 4);\n+  check_struct_and_union3(short, long, short, 12, 4);\n+  check_struct_and_union3(short, long, int, 12, 4);\n+  check_struct_and_union3(short, long, long, 12, 4);\n+  check_struct_and_union3(short, long, long long, 16, 8);\n+  check_struct_and_union3(short, long, float, 12, 4);\n+  check_struct_and_union3(short, long, double, 16, 8);\n+  check_struct_and_union3(short, long, long double, 16, 8);\n+  check_struct_and_union3(short, long long, char, 16, 8);\n+  check_struct_and_union3(short, long long, short, 16, 8);\n+  check_struct_and_union3(short, long long, int, 16, 8);\n+  check_struct_and_union3(short, long long, long, 16, 8);\n+  check_struct_and_union3(short, long long, long long, 20, 8);\n+  check_struct_and_union3(short, long long, float, 16, 8);\n+  check_struct_and_union3(short, long long, double, 20, 8);\n+  check_struct_and_union3(short, long long, long double, 20, 8);\n+  check_struct_and_union3(short, float, char, 12, 4);\n+  check_struct_and_union3(short, float, short, 12, 4);\n+  check_struct_and_union3(short, float, int, 12, 4);\n+  check_struct_and_union3(short, float, long, 12, 4);\n+  check_struct_and_union3(short, float, long long, 16, 8);\n+  check_struct_and_union3(short, float, float, 12, 4);\n+  check_struct_and_union3(short, float, double, 16, 8);\n+  check_struct_and_union3(short, float, long double, 16, 8);\n+  check_struct_and_union3(short, double, char, 16, 8);\n+  check_struct_and_union3(short, double, short, 16, 8);\n+  check_struct_and_union3(short, double, int, 16, 8);\n+  check_struct_and_union3(short, double, long, 16, 8);\n+  check_struct_and_union3(short, double, long long, 20, 8);\n+  check_struct_and_union3(short, double, float, 16, 8);\n+  check_struct_and_union3(short, double, double, 20, 8);\n+  check_struct_and_union3(short, double, long double, 20, 8);\n+  check_struct_and_union3(short, long double, char, 16, 8);\n+  check_struct_and_union3(short, long double, short, 16, 8);\n+  check_struct_and_union3(short, long double, int, 16, 8);\n+  check_struct_and_union3(short, long double, long, 16, 8);\n+  check_struct_and_union3(short, long double, long long, 20, 8);\n+  check_struct_and_union3(short, long double, float, 16, 8);\n+  check_struct_and_union3(short, long double, double, 20, 8);\n+  check_struct_and_union3(short, long double, long double, 20, 8);\n+  check_struct_and_union3(int, char, char, 8, 4);\n+  check_struct_and_union3(int, char, short, 8, 4);\n+  check_struct_and_union3(int, char, int, 12, 4);\n+  check_struct_and_union3(int, char, long, 12, 4);\n+  check_struct_and_union3(int, char, long long, 16, 8);\n+  check_struct_and_union3(int, char, float, 12, 4);\n+  check_struct_and_union3(int, char, double, 16, 8);\n+  check_struct_and_union3(int, char, long double, 16, 8);\n+  check_struct_and_union3(int, short, char, 8, 4);\n+  check_struct_and_union3(int, short, short, 8, 4);\n+  check_struct_and_union3(int, short, int, 12, 4);\n+  check_struct_and_union3(int, short, long, 12, 4);\n+  check_struct_and_union3(int, short, long long, 16, 8);\n+  check_struct_and_union3(int, short, float, 12, 4);\n+  check_struct_and_union3(int, short, double, 16, 8);\n+  check_struct_and_union3(int, short, long double, 16, 8);\n+  check_struct_and_union3(int, int, char, 12, 4);\n+  check_struct_and_union3(int, int, short, 12, 4);\n+  check_struct_and_union3(int, int, int, 12, 4);\n+  check_struct_and_union3(int, int, long, 12, 4);\n+  check_struct_and_union3(int, int, long long, 16, 8);\n+  check_struct_and_union3(int, int, float, 12, 4);\n+  check_struct_and_union3(int, int, double, 16, 8);\n+  check_struct_and_union3(int, int, long double, 16, 8);\n+  check_struct_and_union3(int, long, char, 12, 4);\n+  check_struct_and_union3(int, long, short, 12, 4);\n+  check_struct_and_union3(int, long, int, 12, 4);\n+  check_struct_and_union3(int, long, long, 12, 4);\n+  check_struct_and_union3(int, long, long long, 16, 8);\n+  check_struct_and_union3(int, long, float, 12, 4);\n+  check_struct_and_union3(int, long, double, 16, 8);\n+  check_struct_and_union3(int, long, long double, 16, 8);\n+  check_struct_and_union3(int, long long, char, 16, 8);\n+  check_struct_and_union3(int, long long, short, 16, 8);\n+  check_struct_and_union3(int, long long, int, 16, 8);\n+  check_struct_and_union3(int, long long, long, 16, 8);\n+  check_struct_and_union3(int, long long, long long, 20, 8);\n+  check_struct_and_union3(int, long long, float, 16, 8);\n+  check_struct_and_union3(int, long long, double, 20, 8);\n+  check_struct_and_union3(int, long long, long double, 20, 8);\n+  check_struct_and_union3(int, float, char, 12, 4);\n+  check_struct_and_union3(int, float, short, 12, 4);\n+  check_struct_and_union3(int, float, int, 12, 4);\n+  check_struct_and_union3(int, float, long, 12, 4);\n+  check_struct_and_union3(int, float, long long, 16, 8);\n+  check_struct_and_union3(int, float, float, 12, 4);\n+  check_struct_and_union3(int, float, double, 16, 8);\n+  check_struct_and_union3(int, float, long double, 16, 8);\n+  check_struct_and_union3(int, double, char, 16, 8);\n+  check_struct_and_union3(int, double, short, 16, 8);\n+  check_struct_and_union3(int, double, int, 16, 8);\n+  check_struct_and_union3(int, double, long, 16, 8);\n+  check_struct_and_union3(int, double, long long, 20, 8);\n+  check_struct_and_union3(int, double, float, 16, 8);\n+  check_struct_and_union3(int, double, double, 20, 8);\n+  check_struct_and_union3(int, double, long double, 20, 8);\n+  check_struct_and_union3(int, long double, char, 16, 8);\n+  check_struct_and_union3(int, long double, short, 16, 8);\n+  check_struct_and_union3(int, long double, int, 16, 8);\n+  check_struct_and_union3(int, long double, long, 16, 8);\n+  check_struct_and_union3(int, long double, long long, 20, 8);\n+  check_struct_and_union3(int, long double, float, 16, 8);\n+  check_struct_and_union3(int, long double, double, 20, 8);\n+  check_struct_and_union3(int, long double, long double, 20, 8);\n+  check_struct_and_union3(long, char, char, 8, 4);\n+  check_struct_and_union3(long, char, short, 8, 4);\n+  check_struct_and_union3(long, char, int, 12, 4);\n+  check_struct_and_union3(long, char, long, 12, 4);\n+  check_struct_and_union3(long, char, long long, 16, 8);\n+  check_struct_and_union3(long, char, float, 12, 4);\n+  check_struct_and_union3(long, char, double, 16, 8);\n+  check_struct_and_union3(long, char, long double, 16, 8);\n+  check_struct_and_union3(long, short, char, 8, 4);\n+  check_struct_and_union3(long, short, short, 8, 4);\n+  check_struct_and_union3(long, short, int, 12, 4);\n+  check_struct_and_union3(long, short, long, 12, 4);\n+  check_struct_and_union3(long, short, long long, 16, 8);\n+  check_struct_and_union3(long, short, float, 12, 4);\n+  check_struct_and_union3(long, short, double, 16, 8);\n+  check_struct_and_union3(long, short, long double, 16, 8);\n+  check_struct_and_union3(long, int, char, 12, 4);\n+  check_struct_and_union3(long, int, short, 12, 4);\n+  check_struct_and_union3(long, int, int, 12, 4);\n+  check_struct_and_union3(long, int, long, 12, 4);\n+  check_struct_and_union3(long, int, long long, 16, 8);\n+  check_struct_and_union3(long, int, float, 12, 4);\n+  check_struct_and_union3(long, int, double, 16, 8);\n+  check_struct_and_union3(long, int, long double, 16, 8);\n+  check_struct_and_union3(long, long, char, 12, 4);\n+  check_struct_and_union3(long, long, short, 12, 4);\n+  check_struct_and_union3(long, long, int, 12, 4);\n+  check_struct_and_union3(long, long, long, 12, 4);\n+  check_struct_and_union3(long, long, long long, 16, 8);\n+  check_struct_and_union3(long, long, float, 12, 4);\n+  check_struct_and_union3(long, long, double, 16, 8);\n+  check_struct_and_union3(long, long, long double, 16, 8);\n+  check_struct_and_union3(long, long long, char, 16, 8);\n+  check_struct_and_union3(long, long long, short, 16, 8);\n+  check_struct_and_union3(long, long long, int, 16, 8);\n+  check_struct_and_union3(long, long long, long, 16, 8);\n+  check_struct_and_union3(long, long long, long long, 20, 8);\n+  check_struct_and_union3(long, long long, float, 16, 8);\n+  check_struct_and_union3(long, long long, double, 20, 8);\n+  check_struct_and_union3(long, long long, long double, 20, 8);\n+  check_struct_and_union3(long, float, char, 12, 4);\n+  check_struct_and_union3(long, float, short, 12, 4);\n+  check_struct_and_union3(long, float, int, 12, 4);\n+  check_struct_and_union3(long, float, long, 12, 4);\n+  check_struct_and_union3(long, float, long long, 16, 8);\n+  check_struct_and_union3(long, float, float, 12, 4);\n+  check_struct_and_union3(long, float, double, 16, 8);\n+  check_struct_and_union3(long, float, long double, 16, 8);\n+  check_struct_and_union3(long, double, char, 16, 8);\n+  check_struct_and_union3(long, double, short, 16, 8);\n+  check_struct_and_union3(long, double, int, 16, 8);\n+  check_struct_and_union3(long, double, long, 16, 8);\n+  check_struct_and_union3(long, double, long long, 20, 8);\n+  check_struct_and_union3(long, double, float, 16, 8);\n+  check_struct_and_union3(long, double, double, 20, 8);\n+  check_struct_and_union3(long, double, long double, 20, 8);\n+  check_struct_and_union3(long, long double, char, 16, 8);\n+  check_struct_and_union3(long, long double, short, 16, 8);\n+  check_struct_and_union3(long, long double, int, 16, 8);\n+  check_struct_and_union3(long, long double, long, 16, 8);\n+  check_struct_and_union3(long, long double, long long, 20, 8);\n+  check_struct_and_union3(long, long double, float, 16, 8);\n+  check_struct_and_union3(long, long double, double, 20, 8);\n+  check_struct_and_union3(long, long double, long double, 20, 8);\n+  check_struct_and_union3(long long, char, char, 12, 8);\n+  check_struct_and_union3(long long, char, short, 12, 8);\n+  check_struct_and_union3(long long, char, int, 16, 8);\n+  check_struct_and_union3(long long, char, long, 16, 8);\n+  check_struct_and_union3(long long, char, long long, 20, 8);\n+  check_struct_and_union3(long long, char, float, 16, 8);\n+  check_struct_and_union3(long long, char, double, 20, 8);\n+  check_struct_and_union3(long long, char, long double, 20, 8);\n+  check_struct_and_union3(long long, short, char, 12, 8);\n+  check_struct_and_union3(long long, short, short, 12, 8);\n+  check_struct_and_union3(long long, short, int, 16, 8);\n+  check_struct_and_union3(long long, short, long, 16, 8);\n+  check_struct_and_union3(long long, short, long long, 20, 8);\n+  check_struct_and_union3(long long, short, float, 16, 8);\n+  check_struct_and_union3(long long, short, double, 20, 8);\n+  check_struct_and_union3(long long, short, long double, 20, 8);\n+  check_struct_and_union3(long long, int, char, 16, 8);\n+  check_struct_and_union3(long long, int, short, 16, 8);\n+  check_struct_and_union3(long long, int, int, 16, 8);\n+  check_struct_and_union3(long long, int, long, 16, 8);\n+  check_struct_and_union3(long long, int, long long, 20, 8);\n+  check_struct_and_union3(long long, int, float, 16, 8);\n+  check_struct_and_union3(long long, int, double, 20, 8);\n+  check_struct_and_union3(long long, int, long double, 20, 8);\n+  check_struct_and_union3(long long, long, char, 16, 8);\n+  check_struct_and_union3(long long, long, short, 16, 8);\n+  check_struct_and_union3(long long, long, int, 16, 8);\n+  check_struct_and_union3(long long, long, long, 16, 8);\n+  check_struct_and_union3(long long, long, long long, 20, 8);\n+  check_struct_and_union3(long long, long, float, 16, 8);\n+  check_struct_and_union3(long long, long, double, 20, 8);\n+  check_struct_and_union3(long long, long, long double, 20, 8);\n+  check_struct_and_union3(long long, long long, char, 20, 8);\n+  check_struct_and_union3(long long, long long, short, 20, 8);\n+  check_struct_and_union3(long long, long long, int, 20, 8);\n+  check_struct_and_union3(long long, long long, long, 20, 8);\n+  check_struct_and_union3(long long, long long, long long, 24, 8);\n+  check_struct_and_union3(long long, long long, float, 20, 8);\n+  check_struct_and_union3(long long, long long, double, 24, 8);\n+  check_struct_and_union3(long long, long long, long double, 24, 8);\n+  check_struct_and_union3(long long, float, char, 16, 8);\n+  check_struct_and_union3(long long, float, short, 16, 8);\n+  check_struct_and_union3(long long, float, int, 16, 8);\n+  check_struct_and_union3(long long, float, long, 16, 8);\n+  check_struct_and_union3(long long, float, long long, 20, 8);\n+  check_struct_and_union3(long long, float, float, 16, 8);\n+  check_struct_and_union3(long long, float, double, 20, 8);\n+  check_struct_and_union3(long long, float, long double, 20, 8);\n+  check_struct_and_union3(long long, double, char, 20, 8);\n+  check_struct_and_union3(long long, double, short, 20, 8);\n+  check_struct_and_union3(long long, double, int, 20, 8);\n+  check_struct_and_union3(long long, double, long, 20, 8);\n+  check_struct_and_union3(long long, double, long long, 24, 8);\n+  check_struct_and_union3(long long, double, float, 20, 8);\n+  check_struct_and_union3(long long, double, double, 24, 8);\n+  check_struct_and_union3(long long, double, long double, 24, 8);\n+  check_struct_and_union3(long long, long double, char, 20, 8);\n+  check_struct_and_union3(long long, long double, short, 20, 8);\n+  check_struct_and_union3(long long, long double, int, 20, 8);\n+  check_struct_and_union3(long long, long double, long, 20, 8);\n+  check_struct_and_union3(long long, long double, long long, 24, 8);\n+  check_struct_and_union3(long long, long double, float, 20, 8);\n+  check_struct_and_union3(long long, long double, double, 24, 8);\n+  check_struct_and_union3(long long, long double, long double, 24, 8);\n+  check_struct_and_union3(float, char, char, 8, 4);\n+  check_struct_and_union3(float, char, short, 8, 4);\n+  check_struct_and_union3(float, char, int, 12, 4);\n+  check_struct_and_union3(float, char, long, 12, 4);\n+  check_struct_and_union3(float, char, long long, 16, 8);\n+  check_struct_and_union3(float, char, float, 12, 4);\n+  check_struct_and_union3(float, char, double, 16, 8);\n+  check_struct_and_union3(float, char, long double, 16, 8);\n+  check_struct_and_union3(float, short, char, 8, 4);\n+  check_struct_and_union3(float, short, short, 8, 4);\n+  check_struct_and_union3(float, short, int, 12, 4);\n+  check_struct_and_union3(float, short, long, 12, 4);\n+  check_struct_and_union3(float, short, long long, 16, 8);\n+  check_struct_and_union3(float, short, float, 12, 4);\n+  check_struct_and_union3(float, short, double, 16, 8);\n+  check_struct_and_union3(float, short, long double, 16, 8);\n+  check_struct_and_union3(float, int, char, 12, 4);\n+  check_struct_and_union3(float, int, short, 12, 4);\n+  check_struct_and_union3(float, int, int, 12, 4);\n+  check_struct_and_union3(float, int, long, 12, 4);\n+  check_struct_and_union3(float, int, long long, 16, 8);\n+  check_struct_and_union3(float, int, float, 12, 4);\n+  check_struct_and_union3(float, int, double, 16, 8);\n+  check_struct_and_union3(float, int, long double, 16, 8);\n+  check_struct_and_union3(float, long, char, 12, 4);\n+  check_struct_and_union3(float, long, short, 12, 4);\n+  check_struct_and_union3(float, long, int, 12, 4);\n+  check_struct_and_union3(float, long, long, 12, 4);\n+  check_struct_and_union3(float, long, long long, 16, 8);\n+  check_struct_and_union3(float, long, float, 12, 4);\n+  check_struct_and_union3(float, long, double, 16, 8);\n+  check_struct_and_union3(float, long, long double, 16, 8);\n+  check_struct_and_union3(float, long long, char, 16, 8);\n+  check_struct_and_union3(float, long long, short, 16, 8);\n+  check_struct_and_union3(float, long long, int, 16, 8);\n+  check_struct_and_union3(float, long long, long, 16, 8);\n+  check_struct_and_union3(float, long long, long long, 20, 8);\n+  check_struct_and_union3(float, long long, float, 16, 8);\n+  check_struct_and_union3(float, long long, double, 20, 8);\n+  check_struct_and_union3(float, long long, long double, 20, 8);\n+  check_struct_and_union3(float, float, char, 12, 4);\n+  check_struct_and_union3(float, float, short, 12, 4);\n+  check_struct_and_union3(float, float, int, 12, 4);\n+  check_struct_and_union3(float, float, long, 12, 4);\n+  check_struct_and_union3(float, float, long long, 16, 8);\n+  check_struct_and_union3(float, float, float, 12, 4);\n+  check_struct_and_union3(float, float, double, 16, 8);\n+  check_struct_and_union3(float, float, long double, 16, 8);\n+  check_struct_and_union3(float, double, char, 16, 8);\n+  check_struct_and_union3(float, double, short, 16, 8);\n+  check_struct_and_union3(float, double, int, 16, 8);\n+  check_struct_and_union3(float, double, long, 16, 8);\n+  check_struct_and_union3(float, double, long long, 20, 8);\n+  check_struct_and_union3(float, double, float, 16, 8);\n+  check_struct_and_union3(float, double, double, 20, 8);\n+  check_struct_and_union3(float, double, long double, 20, 8);\n+  check_struct_and_union3(float, long double, char, 16, 8);\n+  check_struct_and_union3(float, long double, short, 16, 8);\n+  check_struct_and_union3(float, long double, int, 16, 8);\n+  check_struct_and_union3(float, long double, long, 16, 8);\n+  check_struct_and_union3(float, long double, long long, 20, 8);\n+  check_struct_and_union3(float, long double, float, 16, 8);\n+  check_struct_and_union3(float, long double, double, 20, 8);\n+  check_struct_and_union3(float, long double, long double, 20, 8);\n+  check_struct_and_union3(double, char, char, 12, 8);\n+  check_struct_and_union3(double, char, short, 12, 8);\n+  check_struct_and_union3(double, char, int, 16, 8);\n+  check_struct_and_union3(double, char, long, 16, 8);\n+  check_struct_and_union3(double, char, long long, 20, 8);\n+  check_struct_and_union3(double, char, float, 16, 8);\n+  check_struct_and_union3(double, char, double, 20, 8);\n+  check_struct_and_union3(double, char, long double, 20, 8);\n+  check_struct_and_union3(double, short, char, 12, 8);\n+  check_struct_and_union3(double, short, short, 12, 8);\n+  check_struct_and_union3(double, short, int, 16, 8);\n+  check_struct_and_union3(double, short, long, 16, 8);\n+  check_struct_and_union3(double, short, long long, 20, 8);\n+  check_struct_and_union3(double, short, float, 16, 8);\n+  check_struct_and_union3(double, short, double, 20, 8);\n+  check_struct_and_union3(double, short, long double, 20, 8);\n+  check_struct_and_union3(double, int, char, 16, 8);\n+  check_struct_and_union3(double, int, short, 16, 8);\n+  check_struct_and_union3(double, int, int, 16, 8);\n+  check_struct_and_union3(double, int, long, 16, 8);\n+  check_struct_and_union3(double, int, long long, 20, 8);\n+  check_struct_and_union3(double, int, float, 16, 8);\n+  check_struct_and_union3(double, int, double, 20, 8);\n+  check_struct_and_union3(double, int, long double, 20, 8);\n+  check_struct_and_union3(double, long, char, 16, 8);\n+  check_struct_and_union3(double, long, short, 16, 8);\n+  check_struct_and_union3(double, long, int, 16, 8);\n+  check_struct_and_union3(double, long, long, 16, 8);\n+  check_struct_and_union3(double, long, long long, 20, 8);\n+  check_struct_and_union3(double, long, float, 16, 8);\n+  check_struct_and_union3(double, long, double, 20, 8);\n+  check_struct_and_union3(double, long, long double, 20, 8);\n+  check_struct_and_union3(double, long long, char, 20, 8);\n+  check_struct_and_union3(double, long long, short, 20, 8);\n+  check_struct_and_union3(double, long long, int, 20, 8);\n+  check_struct_and_union3(double, long long, long, 20, 8);\n+  check_struct_and_union3(double, long long, long long, 24, 8);\n+  check_struct_and_union3(double, long long, float, 20, 8);\n+  check_struct_and_union3(double, long long, double, 24, 8);\n+  check_struct_and_union3(double, long long, long double, 24, 8);\n+  check_struct_and_union3(double, float, char, 16, 8);\n+  check_struct_and_union3(double, float, short, 16, 8);\n+  check_struct_and_union3(double, float, int, 16, 8);\n+  check_struct_and_union3(double, float, long, 16, 8);\n+  check_struct_and_union3(double, float, long long, 20, 8);\n+  check_struct_and_union3(double, float, float, 16, 8);\n+  check_struct_and_union3(double, float, double, 20, 8);\n+  check_struct_and_union3(double, float, long double, 20, 8);\n+  check_struct_and_union3(double, double, char, 20, 8);\n+  check_struct_and_union3(double, double, short, 20, 8);\n+  check_struct_and_union3(double, double, int, 20, 8);\n+  check_struct_and_union3(double, double, long, 20, 8);\n+  check_struct_and_union3(double, double, long long, 24, 8);\n+  check_struct_and_union3(double, double, float, 20, 8);\n+  check_struct_and_union3(double, double, double, 24, 8);\n+  check_struct_and_union3(double, double, long double, 24, 8);\n+  check_struct_and_union3(double, long double, char, 20, 8);\n+  check_struct_and_union3(double, long double, short, 20, 8);\n+  check_struct_and_union3(double, long double, int, 20, 8);\n+  check_struct_and_union3(double, long double, long, 20, 8);\n+  check_struct_and_union3(double, long double, long long, 24, 8);\n+  check_struct_and_union3(double, long double, float, 20, 8);\n+  check_struct_and_union3(double, long double, double, 24, 8);\n+  check_struct_and_union3(double, long double, long double, 24, 8);\n+  check_struct_and_union3(long double, char, char, 12, 8);\n+  check_struct_and_union3(long double, char, short, 12, 8);\n+  check_struct_and_union3(long double, char, int, 16, 8);\n+  check_struct_and_union3(long double, char, long, 16, 8);\n+  check_struct_and_union3(long double, char, long long, 20, 8);\n+  check_struct_and_union3(long double, char, float, 16, 8);\n+  check_struct_and_union3(long double, char, double, 20, 8);\n+  check_struct_and_union3(long double, char, long double, 20, 8);\n+  check_struct_and_union3(long double, short, char, 12, 8);\n+  check_struct_and_union3(long double, short, short, 12, 8);\n+  check_struct_and_union3(long double, short, int, 16, 8);\n+  check_struct_and_union3(long double, short, long, 16, 8);\n+  check_struct_and_union3(long double, short, long long, 20, 8);\n+  check_struct_and_union3(long double, short, float, 16, 8);\n+  check_struct_and_union3(long double, short, double, 20, 8);\n+  check_struct_and_union3(long double, short, long double, 20, 8);\n+  check_struct_and_union3(long double, int, char, 16, 8);\n+  check_struct_and_union3(long double, int, short, 16, 8);\n+  check_struct_and_union3(long double, int, int, 16, 8);\n+  check_struct_and_union3(long double, int, long, 16, 8);\n+  check_struct_and_union3(long double, int, long long, 20, 8);\n+  check_struct_and_union3(long double, int, float, 16, 8);\n+  check_struct_and_union3(long double, int, double, 20, 8);\n+  check_struct_and_union3(long double, int, long double, 20, 8);\n+  check_struct_and_union3(long double, long, char, 16, 8);\n+  check_struct_and_union3(long double, long, short, 16, 8);\n+  check_struct_and_union3(long double, long, int, 16, 8);\n+  check_struct_and_union3(long double, long, long, 16, 8);\n+  check_struct_and_union3(long double, long, long long, 20, 8);\n+  check_struct_and_union3(long double, long, float, 16, 8);\n+  check_struct_and_union3(long double, long, double, 20, 8);\n+  check_struct_and_union3(long double, long, long double, 20, 8);\n+  check_struct_and_union3(long double, long long, char, 20, 8);\n+  check_struct_and_union3(long double, long long, short, 20, 8);\n+  check_struct_and_union3(long double, long long, int, 20, 8);\n+  check_struct_and_union3(long double, long long, long, 20, 8);\n+  check_struct_and_union3(long double, long long, long long, 24, 8);\n+  check_struct_and_union3(long double, long long, float, 20, 8);\n+  check_struct_and_union3(long double, long long, double, 24, 8);\n+  check_struct_and_union3(long double, long long, long double, 24, 8);\n+  check_struct_and_union3(long double, float, char, 16, 8);\n+  check_struct_and_union3(long double, float, short, 16, 8);\n+  check_struct_and_union3(long double, float, int, 16, 8);\n+  check_struct_and_union3(long double, float, long, 16, 8);\n+  check_struct_and_union3(long double, float, long long, 20, 8);\n+  check_struct_and_union3(long double, float, float, 16, 8);\n+  check_struct_and_union3(long double, float, double, 20, 8);\n+  check_struct_and_union3(long double, float, long double, 20, 8);\n+  check_struct_and_union3(long double, double, char, 20, 8);\n+  check_struct_and_union3(long double, double, short, 20, 8);\n+  check_struct_and_union3(long double, double, int, 20, 8);\n+  check_struct_and_union3(long double, double, long, 20, 8);\n+  check_struct_and_union3(long double, double, long long, 24, 8);\n+  check_struct_and_union3(long double, double, float, 20, 8);\n+  check_struct_and_union3(long double, double, double, 24, 8);\n+  check_struct_and_union3(long double, double, long double, 24, 8);\n+  check_struct_and_union3(long double, long double, char, 20, 8);\n+  check_struct_and_union3(long double, long double, short, 20, 8);\n+  check_struct_and_union3(long double, long double, int, 20, 8);\n+  check_struct_and_union3(long double, long double, long, 20, 8);\n+  check_struct_and_union3(long double, long double, long long, 24, 8);\n+  check_struct_and_union3(long double, long double, float, 20, 8);\n+  check_struct_and_union3(long double, long double, double, 24, 8);\n+  check_struct_and_union3(long double, long double, long double, 24, 8);\n+  return 0;\n+}"}, {"sha": "ecece94b793d0728d3467d0ee1e18a4733b88db0", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_64bit_returning.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_64bit_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_64bit_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_64bit_returning.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,57 @@\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+long long\n+fun_test_returning_long_long (void)\n+{\n+  volatile_var++;\n+  return (long long) 0xabadbeefabadbeefLL;\n+}\n+\n+double\n+fun_test_returning_double (void)\n+{\n+  volatile_var++;\n+  return (double) 12345678.0;\n+}\n+\n+union\n+{\n+  long long ll;\n+  double d;\n+} test_64;\n+\n+int\n+main (void)\n+{\n+  unsigned failed = 0;\n+  long long ll;\n+  double d;\n+\n+  clear_struct_registers;\n+  test_64.ll = 0xabadbeefabadbeefLL;\n+\n+  ll = WRAP_RET (fun_test_returning_long_long)();\n+  if (ll != test_64.ll\n+      || (test_64.ll & 0xffffffff) != eax\n+      || ((test_64.ll >> 32) & 0xffffffff) != edx)\n+    failed++;\n+\n+  clear_struct_registers;\n+  test_64.d = 12345678.0;\n+\n+  d = WRAP_RET (fun_test_returning_double)();\n+  if (d != test_64.d\n+      || (test_64.ll & 0xffffffff) != eax\n+      || ((test_64.ll >> 32) & 0xffffffff) != edx)\n+    printf (\"fail double\\n\"), failed++;\n+\n+  if (failed)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "f14cf17023683a37939b11c25dfee32225672e6d", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_alignment.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_alignment.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,33 @@\n+/* This checks alignment of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests2(check_align, char, TYPE_ALIGN_CHAR);\n+  run_signed_tests2(check_align, short, TYPE_ALIGN_SHORT);\n+  run_signed_tests2(check_align, int, TYPE_ALIGN_INT);\n+  run_signed_tests2(check_align, long, TYPE_ALIGN_LONG);\n+  run_signed_tests2(check_align, long long, TYPE_ALIGN_LONG_LONG);\n+  check_align(enumtype, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_align(float, TYPE_ALIGN_FLOAT);\n+  check_align(double, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_align(long double, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_align(__float128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Pointer types.  */\n+  check_align(void *, TYPE_ALIGN_POINTER);\n+  check_align(void (*)(), TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "e4b6369c19a6fc213f10d742218f2dcca685c80f", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_array_size_and_align.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_array_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_array_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_array_size_and_align.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,32 @@\n+/* Test of simple arrays, size and alignment.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_array_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_array_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_array_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_array_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_array_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+  check_array_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_array_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_array_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_array_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_array_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_array_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "23efa6e5c01c89696075d1a3c87c10b78190a2f3", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_returning.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_returning.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,52 @@\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+char\n+fun_test_returning_char (void)\n+{\n+  volatile_var++;\n+  return 64;\n+}\n+\n+short\n+fun_test_returning_short (void)\n+{\n+  volatile_var++;\n+  return 65;\n+}\n+\n+int\n+fun_test_returning_int (void)\n+{\n+  volatile_var++;\n+  return 66;\n+}\n+\n+long\n+fun_test_returning_long (void)\n+{\n+  volatile_var++;\n+  return 67;\n+}\n+\n+float\n+fun_test_returning_float (void)\n+{\n+  volatile_var++;\n+  return 68;\n+}\n+\n+#define def_test_returning_type(fun, type, ret, reg) \\\n+  { type var = WRAP_RET (fun) (); \\\n+  assert (ret == (type) reg && ret == var); }\n+int\n+main (void)\n+{\n+  def_test_returning_type(fun_test_returning_char, char, 64, eax);\n+  def_test_returning_type(fun_test_returning_short, short, 65, eax);\n+  def_test_returning_type(fun_test_returning_int, int, 66, eax);\n+  def_test_returning_type(fun_test_returning_long, long, 67, eax);\n+  def_test_returning_type(fun_test_returning_float, float, 68, eax);\n+  return 0;\n+}"}, {"sha": "6582fc638a6eb5f30af29b8ba6e166102ec47414", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_sizes.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_sizes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_sizes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_sizes.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,36 @@\n+/* This checks sizes of basic types.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests2(check_size, char, TYPE_SIZE_CHAR);\n+  run_signed_tests2(check_size, short, TYPE_SIZE_SHORT);\n+  run_signed_tests2(check_size, int, TYPE_SIZE_INT);\n+  run_signed_tests2(check_size, long, TYPE_SIZE_LONG);\n+  run_signed_tests2(check_size, long long, TYPE_SIZE_LONG_LONG);\n+#ifdef CHECK_INT128\n+  run_signed_tests2(check_size, __int128, TYPE_SIZE_INT128);\n+#endif\n+  check_size(enumtype, TYPE_SIZE_ENUM);\n+\n+  /* Floating point types.  */\n+  check_size(float, TYPE_SIZE_FLOAT);\n+  check_size(double, TYPE_SIZE_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_size(long double, TYPE_SIZE_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_size(__float128, TYPE_SIZE_FLOAT128);\n+#endif\n+\n+  /* Pointer types.  */\n+  check_size(void *, TYPE_SIZE_POINTER);\n+  check_size(void (*)(), TYPE_SIZE_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "3b5027ffaafb1132169de49a675993b5e299afbc", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_struct_size_and_align.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_struct_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_struct_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_struct_size_and_align.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,33 @@\n+/* This checks size and alignment of structs with a single basic type\n+   element. All basic types are checked.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_basic_struct_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_basic_struct_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_basic_struct_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_basic_struct_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_basic_struct_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+  check_basic_struct_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_basic_struct_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_basic_struct_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_basic_struct_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_basic_struct_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_basic_struct_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "93ba5ffb8d64dce80cb4acaabaa0fbfe71e8f150", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_basic_union_size_and_align.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_union_size_and_align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_union_size_and_align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_basic_union_size_and_align.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,32 @@\n+/* Test of simple unions, size and alignment.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+int\n+main (void)\n+{\n+  /* Integral types.  */\n+  run_signed_tests3(check_basic_union_size_and_align, char, TYPE_SIZE_CHAR, TYPE_ALIGN_CHAR);\n+  run_signed_tests3(check_basic_union_size_and_align, short, TYPE_SIZE_SHORT, TYPE_ALIGN_SHORT);\n+  run_signed_tests3(check_basic_union_size_and_align, int, TYPE_SIZE_INT, TYPE_ALIGN_INT);\n+  run_signed_tests3(check_basic_union_size_and_align, long, TYPE_SIZE_LONG, TYPE_ALIGN_LONG);\n+  run_signed_tests3(check_basic_union_size_and_align, long long, TYPE_SIZE_LONG_LONG, TYPE_ALIGN_LONG_LONG);\n+  check_basic_union_size_and_align(enum dummytype, TYPE_SIZE_ENUM, TYPE_ALIGN_ENUM);\n+\n+  /* Floating point types.  */\n+  check_basic_union_size_and_align(float, TYPE_SIZE_FLOAT, TYPE_ALIGN_FLOAT);\n+  check_basic_union_size_and_align(double, TYPE_SIZE_DOUBLE, TYPE_ALIGN_DOUBLE);\n+#ifdef CHECK_LONG_DOUBLE\n+  check_basic_union_size_and_align(long double, TYPE_SIZE_LONG_DOUBLE, TYPE_ALIGN_LONG_DOUBLE);\n+#endif\n+#ifdef CHECK_FLOAT128\n+  check_basic_union_size_and_align(__float128, TYPE_SIZE_FLOAT128, TYPE_ALIGN_FLOAT128);\n+#endif\n+\n+  /* Pointer types. The function pointer doesn't work with these macros.  */\n+  check_basic_union_size_and_align(void *, TYPE_SIZE_POINTER, TYPE_ALIGN_POINTER);\n+\n+  return 0;\n+}"}, {"sha": "0b1c29333dc78db463a9da6de72b061c09bb8e07", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_bitfields.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_bitfields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_bitfields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_bitfields.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,162 @@\n+/* This is a small test to see if bitfields are working.  It is only a\n+   few structs and a union and a test to see if they have the correct\n+   size, if values can be read and written and a couple of argument\n+   passing tests.  No alignment testing is done.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+\n+\n+/* These five bitfields are taken from the System V ABI, Intel 386\n+   architecture supplement.  */\n+\n+/* Word aligned, sizeof is 4.  */\n+struct RightToLeft\n+{\n+  int j:5;\n+  int k:6;\n+  int m:7;\n+};\n+\n+/* Word aligned, sizeof is 12.  */\n+struct BoundaryAlignment\n+{\n+  short s:9;\n+  int   j:9;\n+  char  c;\n+  short t:9;\n+  short u:9;\n+  char  d;\n+};\n+\n+/* Halfword aligned, sizeof is 2.  */\n+struct StorageUnitSharing\n+{\n+  char  c;\n+  short s:8;\n+};\n+\n+/* Halfword aligned, sizeof is 2.  */\n+union Allocation\n+{\n+  char  c;\n+  short s:8;\n+};\n+\n+/* Byte aligned, sizeof is 9.  */\n+struct Unnamed\n+{\n+  char  c;\n+  int    :0;\n+  char  d;\n+  short  :9;\n+  char  e;\n+  char   :0;\n+};\n+\n+/* Extra struct testing bitfields in larger types.\n+   Doubleword aligned, sizeof is 8.  */\n+struct LargerTypes\n+{\n+  long long l:33;\n+  int       i:31;\n+};\n+\n+\n+void\n+passing1 (struct RightToLeft str, int j, int k, int m)\n+{\n+  assert (str.j == j);\n+  assert (str.k == k);\n+  assert (str.m == m);\n+}\n+\n+void\n+passing2 (struct BoundaryAlignment str, short s, int j, char c, short t,\n+\t  short u, char d)\n+{\n+  assert (str.s == s);\n+  assert (str.j == j);\n+  assert (str.c == c);\n+  assert (str.t == t);\n+  assert (str.u == u);\n+  assert (str.d == d);\n+}\n+\n+void\n+passing3 (struct StorageUnitSharing str, char c, short s)\n+{\n+  assert (str.c == c);\n+  assert (str.s == s);\n+}\n+\n+void\n+passing4 (struct Unnamed str, char c, char d, char e)\n+{\n+  assert (str.c == c);\n+  assert (str.d == d);\n+  assert (str.e == e);\n+}\n+\n+void\n+passing5 (struct LargerTypes str, long long l, int i)\n+{\n+  assert (str.l == l);\n+  assert (str.i == i);\n+}\n+\n+\n+void\n+passingU (union Allocation u, char c)\n+{\n+  assert (u.c == c);\n+  assert (u.s == c);\n+}\n+\n+\n+int\n+main (void)\n+{\n+  struct RightToLeft str1;\n+  struct BoundaryAlignment str2;\n+  struct StorageUnitSharing str3;\n+  struct Unnamed str4;\n+  struct LargerTypes str5;\n+  union Allocation u;\n+\n+  /* Check sizeof's.  */\n+  check_size(str1, 4);\n+  check_size(str2, 12);\n+  check_size(str3, 2);\n+  check_size(str4, 9);\n+  check_size(str5, 8);\n+  check_size(u, 2);\n+\n+  /* Check alignof's.  */\n+  check_align_lv(str1, 4);\n+  check_align_lv(str2, 4);\n+  check_align_lv(str3, 2);\n+  check_align_lv(str4, 1);\n+  check_align_lv(str5, 4);\n+  check_align_lv(u, 2);\n+\n+  /* Check passing.  */\n+  str1.j = str2.s = str3.c = str4.c = str5.l = 4;\n+  str1.k = str2.j = str3.s = str4.d = str5.i = 5;\n+  str1.m = str2.c = str4.e = 6;\n+  str2.t = 7;\n+  str2.u = 8;\n+  str2.d = 9;\n+  passing1 (str1, 4, 5, 6);\n+  passing2 (str2, 4, 5, 6, 7, 8, 9);\n+  passing3 (str3, 4, 5);\n+  passing4 (str4, 4, 5, 6);\n+  passing5 (str5, 4, 5);\n+\n+  u.c = 5;\n+  passingU (u, 5);\n+  u.s = 6;\n+  passingU (u, 6);\n+\n+  return 0;\n+}"}, {"sha": "9e9678d7b024146323f21f8845aaea2260462ef9", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_complex_returning.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_complex_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_complex_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_complex_returning.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,83 @@\n+/* This is a small test case for returning a complex number. Written by\n+   Andreas Jaeger.  */\n+\n+#include \"defines.h\"\n+\n+\n+#define BUILD_F_COMPLEX(real, imag) \\\n+  ({ __complex__ float __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+#define BUILD_D_COMPLEX(real, imag) \\\n+  ({ __complex__ double __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+#define BUILD_LD_COMPLEX(real, imag) \\\n+  ({ __complex__ long double __retval; \\\n+     __real__ __retval = (real); \\\n+     __imag__ __retval = (imag); \\\n+     __retval; })\n+\n+__complex__ float\n+aj_f_times2 (__complex__ float x)\n+{\n+  __complex__ float res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+__complex__ double\n+aj_d_times2 (__complex__ double x)\n+{\n+  __complex__ double res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+__complex__ long double\n+aj_ld_times2 (__complex__ long double x)\n+{\n+  __complex__ long double res;\n+\n+  __real__ res = (2.0 * __real__ x);\n+  __imag__ res = (2.0 * __imag__ x);\n+\n+  return res;\n+}\n+\n+int\n+main (void)\n+{\n+#ifdef CHECK_COMPLEX\n+  _Complex float fc, fd;\n+  _Complex double dc, dd;\n+  _Complex long double ldc, ldd;\n+\n+  fc = BUILD_LD_COMPLEX (2.0f, 3.0f);\n+  fd = aj_f_times2 (fc);\n+\n+  assert (__real__ fd == 4.0f && __imag__ fd == 6.0f);\n+\n+  dc = BUILD_LD_COMPLEX (2.0, 3.0);\n+  dd = aj_ld_times2 (dc);\n+\n+  assert (__real__ dd == 4.0 && __imag__ dd == 6.0);\n+\n+  ldc = BUILD_LD_COMPLEX (2.0L, 3.0L);\n+  ldd = aj_ld_times2 (ldc);\n+\n+  assert (__real__ ldd == 4.0L && __imag__ ldd == 6.0L);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "6bb24ccd75cb3f1a7d825e67b2f5c26c62ed3dba", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_passing_floats.c", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_floats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_floats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_floats.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,608 @@\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  float f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_float;\n+\n+struct\n+{\n+  double f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_double;\n+\n+struct\n+{\n+  ldouble f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20, f21, f22, f23;\n+} values_ldouble;\n+\n+void\n+fun_check_float_passing_float8_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_float_passing_float8_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_float16_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+  assert (values_float.f8 == f8);\n+  assert (values_float.f9 == f9);\n+  assert (values_float.f10 == f10);\n+  assert (values_float.f11 == f11);\n+  assert (values_float.f12 == f12);\n+  assert (values_float.f13 == f13);\n+  assert (values_float.f14 == f14);\n+  assert (values_float.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_float_passing_float16_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_float20_values (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED, float f16 ATTRIBUTE_UNUSED, float f17 ATTRIBUTE_UNUSED, float f18 ATTRIBUTE_UNUSED, float f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_float.f0 == f0);\n+  assert (values_float.f1 == f1);\n+  assert (values_float.f2 == f2);\n+  assert (values_float.f3 == f3);\n+  assert (values_float.f4 == f4);\n+  assert (values_float.f5 == f5);\n+  assert (values_float.f6 == f6);\n+  assert (values_float.f7 == f7);\n+  assert (values_float.f8 == f8);\n+  assert (values_float.f9 == f9);\n+  assert (values_float.f10 == f10);\n+  assert (values_float.f11 == f11);\n+  assert (values_float.f12 == f12);\n+  assert (values_float.f13 == f13);\n+  assert (values_float.f14 == f14);\n+  assert (values_float.f15 == f15);\n+  assert (values_float.f16 == f16);\n+  assert (values_float.f17 == f17);\n+  assert (values_float.f18 == f18);\n+  assert (values_float.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_float_passing_float20_regs (float f0 ATTRIBUTE_UNUSED, float f1 ATTRIBUTE_UNUSED, float f2 ATTRIBUTE_UNUSED, float f3 ATTRIBUTE_UNUSED, float f4 ATTRIBUTE_UNUSED, float f5 ATTRIBUTE_UNUSED, float f6 ATTRIBUTE_UNUSED, float f7 ATTRIBUTE_UNUSED, float f8 ATTRIBUTE_UNUSED, float f9 ATTRIBUTE_UNUSED, float f10 ATTRIBUTE_UNUSED, float f11 ATTRIBUTE_UNUSED, float f12 ATTRIBUTE_UNUSED, float f13 ATTRIBUTE_UNUSED, float f14 ATTRIBUTE_UNUSED, float f15 ATTRIBUTE_UNUSED, float f16 ATTRIBUTE_UNUSED, float f17 ATTRIBUTE_UNUSED, float f18 ATTRIBUTE_UNUSED, float f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_float_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double8_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_float_passing_double8_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double16_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+  assert (values_double.f8 == f8);\n+  assert (values_double.f9 == f9);\n+  assert (values_double.f10 == f10);\n+  assert (values_double.f11 == f11);\n+  assert (values_double.f12 == f12);\n+  assert (values_double.f13 == f13);\n+  assert (values_double.f14 == f14);\n+  assert (values_double.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_float_passing_double16_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_float_passing_double20_values (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED, double f16 ATTRIBUTE_UNUSED, double f17 ATTRIBUTE_UNUSED, double f18 ATTRIBUTE_UNUSED, double f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_double.f0 == f0);\n+  assert (values_double.f1 == f1);\n+  assert (values_double.f2 == f2);\n+  assert (values_double.f3 == f3);\n+  assert (values_double.f4 == f4);\n+  assert (values_double.f5 == f5);\n+  assert (values_double.f6 == f6);\n+  assert (values_double.f7 == f7);\n+  assert (values_double.f8 == f8);\n+  assert (values_double.f9 == f9);\n+  assert (values_double.f10 == f10);\n+  assert (values_double.f11 == f11);\n+  assert (values_double.f12 == f12);\n+  assert (values_double.f13 == f13);\n+  assert (values_double.f14 == f14);\n+  assert (values_double.f15 == f15);\n+  assert (values_double.f16 == f16);\n+  assert (values_double.f17 == f17);\n+  assert (values_double.f18 == f18);\n+  assert (values_double.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_float_passing_double20_regs (double f0 ATTRIBUTE_UNUSED, double f1 ATTRIBUTE_UNUSED, double f2 ATTRIBUTE_UNUSED, double f3 ATTRIBUTE_UNUSED, double f4 ATTRIBUTE_UNUSED, double f5 ATTRIBUTE_UNUSED, double f6 ATTRIBUTE_UNUSED, double f7 ATTRIBUTE_UNUSED, double f8 ATTRIBUTE_UNUSED, double f9 ATTRIBUTE_UNUSED, double f10 ATTRIBUTE_UNUSED, double f11 ATTRIBUTE_UNUSED, double f12 ATTRIBUTE_UNUSED, double f13 ATTRIBUTE_UNUSED, double f14 ATTRIBUTE_UNUSED, double f15 ATTRIBUTE_UNUSED, double f16 ATTRIBUTE_UNUSED, double f17 ATTRIBUTE_UNUSED, double f18 ATTRIBUTE_UNUSED, double f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_double_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble8_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble8_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble16_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+  assert (values_ldouble.f8 == f8);\n+  assert (values_ldouble.f9 == f9);\n+  assert (values_ldouble.f10 == f10);\n+  assert (values_ldouble.f11 == f11);\n+  assert (values_ldouble.f12 == f12);\n+  assert (values_ldouble.f13 == f13);\n+  assert (values_ldouble.f14 == f14);\n+  assert (values_ldouble.f15 == f15);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble16_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+void\n+fun_check_x87_passing_ldouble20_values (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED, ldouble f16 ATTRIBUTE_UNUSED, ldouble f17 ATTRIBUTE_UNUSED, ldouble f18 ATTRIBUTE_UNUSED, ldouble f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_ldouble.f0 == f0);\n+  assert (values_ldouble.f1 == f1);\n+  assert (values_ldouble.f2 == f2);\n+  assert (values_ldouble.f3 == f3);\n+  assert (values_ldouble.f4 == f4);\n+  assert (values_ldouble.f5 == f5);\n+  assert (values_ldouble.f6 == f6);\n+  assert (values_ldouble.f7 == f7);\n+  assert (values_ldouble.f8 == f8);\n+  assert (values_ldouble.f9 == f9);\n+  assert (values_ldouble.f10 == f10);\n+  assert (values_ldouble.f11 == f11);\n+  assert (values_ldouble.f12 == f12);\n+  assert (values_ldouble.f13 == f13);\n+  assert (values_ldouble.f14 == f14);\n+  assert (values_ldouble.f15 == f15);\n+  assert (values_ldouble.f16 == f16);\n+  assert (values_ldouble.f17 == f17);\n+  assert (values_ldouble.f18 == f18);\n+  assert (values_ldouble.f19 == f19);\n+\n+}\n+\n+void\n+fun_check_x87_passing_ldouble20_regs (ldouble f0 ATTRIBUTE_UNUSED, ldouble f1 ATTRIBUTE_UNUSED, ldouble f2 ATTRIBUTE_UNUSED, ldouble f3 ATTRIBUTE_UNUSED, ldouble f4 ATTRIBUTE_UNUSED, ldouble f5 ATTRIBUTE_UNUSED, ldouble f6 ATTRIBUTE_UNUSED, ldouble f7 ATTRIBUTE_UNUSED, ldouble f8 ATTRIBUTE_UNUSED, ldouble f9 ATTRIBUTE_UNUSED, ldouble f10 ATTRIBUTE_UNUSED, ldouble f11 ATTRIBUTE_UNUSED, ldouble f12 ATTRIBUTE_UNUSED, ldouble f13 ATTRIBUTE_UNUSED, ldouble f14 ATTRIBUTE_UNUSED, ldouble f15 ATTRIBUTE_UNUSED, ldouble f16 ATTRIBUTE_UNUSED, ldouble f17 ATTRIBUTE_UNUSED, ldouble f18 ATTRIBUTE_UNUSED, ldouble f19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_ldouble_arguments;\n+}\n+\n+#define def_check_float_passing8(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7);\n+\n+#define def_check_float_passing16(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15);\n+\n+#define def_check_float_passing20(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  values_ ## TYPE .f16 = _f16; \\\n+  values_ ## TYPE .f17 = _f17; \\\n+  values_ ## TYPE .f18 = _f18; \\\n+  values_ ## TYPE .f19 = _f19; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19);\n+\n+#define def_check_x87_passing8(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7);\n+\n+#define def_check_x87_passing16(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15);\n+\n+#define def_check_x87_passing20(_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .f0 = _f0; \\\n+  values_ ## TYPE .f1 = _f1; \\\n+  values_ ## TYPE .f2 = _f2; \\\n+  values_ ## TYPE .f3 = _f3; \\\n+  values_ ## TYPE .f4 = _f4; \\\n+  values_ ## TYPE .f5 = _f5; \\\n+  values_ ## TYPE .f6 = _f6; \\\n+  values_ ## TYPE .f7 = _f7; \\\n+  values_ ## TYPE .f8 = _f8; \\\n+  values_ ## TYPE .f9 = _f9; \\\n+  values_ ## TYPE .f10 = _f10; \\\n+  values_ ## TYPE .f11 = _f11; \\\n+  values_ ## TYPE .f12 = _f12; \\\n+  values_ ## TYPE .f13 = _f13; \\\n+  values_ ## TYPE .f14 = _f14; \\\n+  values_ ## TYPE .f15 = _f15; \\\n+  values_ ## TYPE .f16 = _f16; \\\n+  values_ ## TYPE .f17 = _f17; \\\n+  values_ ## TYPE .f18 = _f18; \\\n+  values_ ## TYPE .f19 = _f19; \\\n+  WRAP_CALL(_func1) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19); \\\n+  \\\n+  clear_int_registers; \\\n+  if (sizeof (TYPE) == 4) \\\n+    { \\\n+      u.f = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      u.f = _f1; \\\n+      iregs.I1 = u.i[0]; \\\n+      u.f = _f2; \\\n+      iregs.I2 = u.i[0]; \\\n+      num_iregs = 3; \\\n+    } \\\n+  else \\\n+    { \\\n+      u.d = _f0; \\\n+      iregs.I0 = u.i[0]; \\\n+      iregs.I1 = u.i[1]; \\\n+      num_iregs = 2; \\\n+    } \\\n+  WRAP_CALL(_func2) (_f0, _f1, _f2, _f3, _f4, _f5, _f6, _f7, _f8, _f9, _f10, _f11, _f12, _f13, _f14, _f15, _f16, _f17, _f18, _f19);\n+\n+void\n+test_floats_on_stack ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_float_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_float_passing_float8_values, fun_check_float_passing_float8_regs, float);\n+\n+  def_check_float_passing16(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, fun_check_float_passing_float16_values, fun_check_float_passing_float16_regs, float);\n+}\n+\n+void\n+test_too_many_floats ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_float_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_float_passing_float20_values, fun_check_float_passing_float20_regs, float);\n+}\n+\n+void\n+test_doubles_on_stack ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_float_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_float_passing_double8_values, fun_check_float_passing_double8_regs, double);\n+\n+  def_check_float_passing16(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, fun_check_float_passing_double16_values, fun_check_float_passing_double16_regs, double);\n+}\n+\n+void\n+test_too_many_doubles ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_float_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_float_passing_double20_values, fun_check_float_passing_double20_regs, double);\n+}\n+\n+void\n+test_long_doubles_on_stack ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_x87_passing8(32, 33, 34, 35, 36, 37, 38, 39, fun_check_x87_passing_ldouble8_values, fun_check_x87_passing_ldouble8_regs, ldouble);\n+}\n+\n+void\n+test_too_many_long_doubles ()\n+{\n+  union\n+    {\n+      float f;\n+      double d;\n+      int i[2];\n+    } u;\n+  def_check_x87_passing20(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, fun_check_x87_passing_ldouble20_values, fun_check_x87_passing_ldouble20_regs, ldouble);\n+}\n+\n+void\n+test_float128s_on_stack ()\n+{\n+}\n+\n+void\n+test_too_many_float128s ()\n+{\n+}\n+\n+\n+int\n+main (void)\n+{\n+  test_floats_on_stack ();\n+  test_too_many_floats ();\n+  test_doubles_on_stack ();\n+  test_too_many_doubles ();\n+  test_long_doubles_on_stack ();\n+  test_too_many_long_doubles ();\n+  test_float128s_on_stack ();\n+  test_too_many_float128s ();\n+  return 0;\n+}"}, {"sha": "046e14037edb3331633c481198559c0bf3436a08", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_passing_integers.c", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_integers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_integers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_integers.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,182 @@\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  int i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values_int;\n+\n+struct\n+{\n+  long i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17, i18, i19, i20, i21, i22, i23;\n+} values_long;\n+\n+void\n+fun_check_int_passing_int6_values (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_int.i0 == i0);\n+  assert (values_int.i1 == i1);\n+  assert (values_int.i2 == i2);\n+  assert (values_int.i3 == i3);\n+  assert (values_int.i4 == i4);\n+  assert (values_int.i5 == i5);\n+\n+}\n+\n+void\n+fun_check_int_passing_int6_regs (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_int_arguments;\n+}\n+\n+void\n+fun_check_int_passing_int12_values (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED, int i6 ATTRIBUTE_UNUSED, int i7 ATTRIBUTE_UNUSED, int i8 ATTRIBUTE_UNUSED, int i9 ATTRIBUTE_UNUSED, int i10 ATTRIBUTE_UNUSED, int i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_int.i0 == i0);\n+  assert (values_int.i1 == i1);\n+  assert (values_int.i2 == i2);\n+  assert (values_int.i3 == i3);\n+  assert (values_int.i4 == i4);\n+  assert (values_int.i5 == i5);\n+  assert (values_int.i6 == i6);\n+  assert (values_int.i7 == i7);\n+  assert (values_int.i8 == i8);\n+  assert (values_int.i9 == i9);\n+  assert (values_int.i10 == i10);\n+  assert (values_int.i11 == i11);\n+\n+}\n+\n+void\n+fun_check_int_passing_int12_regs (int i0 ATTRIBUTE_UNUSED, int i1 ATTRIBUTE_UNUSED, int i2 ATTRIBUTE_UNUSED, int i3 ATTRIBUTE_UNUSED, int i4 ATTRIBUTE_UNUSED, int i5 ATTRIBUTE_UNUSED, int i6 ATTRIBUTE_UNUSED, int i7 ATTRIBUTE_UNUSED, int i8 ATTRIBUTE_UNUSED, int i9 ATTRIBUTE_UNUSED, int i10 ATTRIBUTE_UNUSED, int i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_int_arguments;\n+}\n+\n+void\n+fun_check_int_passing_long6_values (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_long.i0 == i0);\n+  assert (values_long.i1 == i1);\n+  assert (values_long.i2 == i2);\n+  assert (values_long.i3 == i3);\n+  assert (values_long.i4 == i4);\n+  assert (values_long.i5 == i5);\n+\n+}\n+\n+void\n+fun_check_int_passing_long6_regs (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_long_arguments;\n+}\n+\n+void\n+fun_check_int_passing_long12_values (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED, long i6 ATTRIBUTE_UNUSED, long i7 ATTRIBUTE_UNUSED, long i8 ATTRIBUTE_UNUSED, long i9 ATTRIBUTE_UNUSED, long i10 ATTRIBUTE_UNUSED, long i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  assert (values_long.i0 == i0);\n+  assert (values_long.i1 == i1);\n+  assert (values_long.i2 == i2);\n+  assert (values_long.i3 == i3);\n+  assert (values_long.i4 == i4);\n+  assert (values_long.i5 == i5);\n+  assert (values_long.i6 == i6);\n+  assert (values_long.i7 == i7);\n+  assert (values_long.i8 == i8);\n+  assert (values_long.i9 == i9);\n+  assert (values_long.i10 == i10);\n+  assert (values_long.i11 == i11);\n+\n+}\n+\n+void\n+fun_check_int_passing_long12_regs (long i0 ATTRIBUTE_UNUSED, long i1 ATTRIBUTE_UNUSED, long i2 ATTRIBUTE_UNUSED, long i3 ATTRIBUTE_UNUSED, long i4 ATTRIBUTE_UNUSED, long i5 ATTRIBUTE_UNUSED, long i6 ATTRIBUTE_UNUSED, long i7 ATTRIBUTE_UNUSED, long i8 ATTRIBUTE_UNUSED, long i9 ATTRIBUTE_UNUSED, long i10 ATTRIBUTE_UNUSED, long i11 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_long_arguments;\n+}\n+\n+#define def_check_int_passing6(_i0, _i1, _i2, _i3, _i4, _i5, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .i0 = _i0; \\\n+  values_ ## TYPE .i1 = _i1; \\\n+  values_ ## TYPE .i2 = _i2; \\\n+  values_ ## TYPE .i3 = _i3; \\\n+  values_ ## TYPE .i4 = _i4; \\\n+  values_ ## TYPE .i5 = _i5; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5); \\\n+  \\\n+  clear_int_registers; \\\n+  iregs.I0 = _i0; \\\n+  iregs.I1 = _i1; \\\n+  iregs.I2 = _i2; \\\n+  num_iregs = 3; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5);\n+\n+#define def_check_int_passing12(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11, _func1, _func2, TYPE) \\\n+  values_ ## TYPE .i0 = _i0; \\\n+  values_ ## TYPE .i1 = _i1; \\\n+  values_ ## TYPE .i2 = _i2; \\\n+  values_ ## TYPE .i3 = _i3; \\\n+  values_ ## TYPE .i4 = _i4; \\\n+  values_ ## TYPE .i5 = _i5; \\\n+  values_ ## TYPE .i6 = _i6; \\\n+  values_ ## TYPE .i7 = _i7; \\\n+  values_ ## TYPE .i8 = _i8; \\\n+  values_ ## TYPE .i9 = _i9; \\\n+  values_ ## TYPE .i10 = _i10; \\\n+  values_ ## TYPE .i11 = _i11; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11); \\\n+  \\\n+  clear_int_registers; \\\n+  iregs.I0 = _i0; \\\n+  iregs.I1 = _i1; \\\n+  iregs.I2 = _i2; \\\n+  num_iregs = 3; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9, _i10, _i11);\n+\n+void\n+test_ints_on_stack ()\n+{\n+  def_check_int_passing6(32, 33, 34, 35, 36, 37, fun_check_int_passing_int6_values, fun_check_int_passing_int6_regs, int);\n+}\n+\n+void\n+test_too_many_ints ()\n+{\n+  def_check_int_passing12(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, fun_check_int_passing_int12_values, fun_check_int_passing_int12_regs, int);\n+}\n+\n+void\n+test_longs_on_stack ()\n+{\n+  def_check_int_passing6(32, 33, 34, 35, 36, 37, fun_check_int_passing_long6_values, fun_check_int_passing_long6_regs, long);\n+}\n+\n+void\n+test_too_many_longs ()\n+{\n+  def_check_int_passing12(32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, fun_check_int_passing_long12_values, fun_check_int_passing_long12_regs, long);\n+}\n+\n+int\n+main (void)\n+{\n+  test_ints_on_stack ();\n+  test_too_many_ints ();\n+  test_longs_on_stack ();\n+  test_too_many_longs ();\n+  return 0;\n+}"}, {"sha": "1660a4d430b8b8603ca36d943e23c17f433c0253", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_passing_structs.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,237 @@\n+/* This tests passing of structs. */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+#include <complex.h>\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct long_struct\n+{\n+  long l;\n+};\n+\n+struct longlong2_struct\n+{\n+  long long ll1, ll2;\n+};\n+\n+struct longlong3_struct\n+{\n+  long long ll1, ll2, ll3;\n+};\n+\n+/* Check that the struct is passed as the individual members in iregs.  */\n+void\n+check_struct_passing1 (struct int_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing2 (struct long_struct ls ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing3 (struct longlong2_struct ls ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing4 (struct longlong3_struct ls ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ls.ll1 == esp+4);\n+  assert ((unsigned long)&ls.ll2 == esp+12);\n+  assert ((unsigned long)&ls.ll3 == esp+20);\n+}\n+\n+struct flex1_struct\n+{\n+  long i;\n+  long flex[];\n+};\n+\n+struct flex2_struct\n+{\n+  long i;\n+  long flex[0];\n+};\n+\n+void\n+check_struct_passing7 (struct flex1_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_struct_passing8 (struct flex2_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+struct complex1_struct\n+{\n+  __complex__ float x;\n+};\n+\n+struct complex1a_struct\n+{\n+  long l;\n+  union\n+    {\n+      float f;\n+      int i;\n+    } u;\n+};\n+\n+void\n+check_struct_passing9 (struct complex1_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+struct long3_struct\n+{\n+  long l1, l2, l3;\n+};\n+\n+void\n+check_struct_passing10 (struct long3_struct ls ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ls.l1 == esp+4);\n+  assert ((unsigned long)&ls.l2 == esp+8);\n+  assert ((unsigned long)&ls.l3 == esp+12);\n+}\n+\n+struct char3_struct\n+{\n+  char c1, c2, c3;\n+};\n+\n+void\n+check_struct_passing11 (struct char3_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+struct char7_struct\n+{\n+  char c1, c2, c3, c4, c5, c6, c7;\n+};\n+\n+void\n+check_struct_passing12 (struct char7_struct is ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+static struct flex1_struct f1s = { 60, { } };\n+static struct flex2_struct f2s = { 61, { } };\n+\n+int\n+main (void)\n+{\n+  struct int_struct is = { 48 };\n+  struct long_struct ls = { 49 };\n+#ifdef CHECK_LARGER_STRUCTS\n+  struct longlong2_struct ll2s = { 50, 51 };\n+  struct longlong3_struct ll3s = { 52, 53, 54 };\n+  struct long3_struct l3s = { 60, 61, 62 };\n+#endif\n+  struct complex1_struct c1s = { ( -13.4 + 3.5*I ) };\n+  union\n+    {\n+      struct complex1_struct c;\n+      struct complex1a_struct u;\n+    } c1u;\n+  struct char3_struct c3 = { 0x12, 0x34, 0x56 };\n+  union\n+    {\n+      struct char3_struct c;\n+      int i;\n+    } c3u;\n+  struct char7_struct c7 = { 0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56 };\n+  union\n+    {\n+      struct char7_struct c;\n+      struct\n+\t{\n+\t  int i0, i1;\n+\t} i;\n+    } c7u;\n+\n+  clear_struct_registers;\n+  iregs.I0 = is.i;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing1)(is);\n+\n+  clear_struct_registers;\n+  iregs.I0 = ls.l;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing2)(ls);\n+\n+#ifdef CHECK_LARGER_STRUCTS\n+  clear_struct_registers;\n+  num_iregs = 0;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing3)(ll2s);\n+  WRAP_CALL (check_struct_passing4)(ll3s);\n+  WRAP_CALL (check_struct_passing10)(l3s);\n+#endif\n+\n+  clear_struct_registers;\n+  iregs.I0 = f1s.i;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing7)(f1s);\n+\n+  clear_struct_registers;\n+  iregs.I0 = f2s.i;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing8)(f2s);\n+\n+  clear_struct_registers;\n+  c1u.c = c1s;\n+  iregs.I0 = c1u.u.l;\n+  iregs.I1 = c1u.u.u.i;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing9)(c1s);\n+\n+  clear_struct_registers;\n+  c3u.c = c3;\n+  iregs.I0 = c3u.i;\n+  iregbits.I0 = 0xffffff;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing11)(c3);\n+\n+  clear_struct_registers;\n+  c7u.c = c7;\n+  iregs.I0 = c7u.i.i0;\n+  iregs.I1 = c7u.i.i1;\n+  iregbits.I0 = 0xffffffff;\n+  iregbits.I1 = 0xffffff;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_struct_passing12)(c7);\n+\n+  return 0;\n+}"}, {"sha": "ff6354cd6fc936d2bafc3e791c59f1bedd8c8568", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_passing_structs_and_unions.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs_and_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs_and_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_structs_and_unions.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,97 @@\n+/* This tests passing of structs. Only integers are tested.  */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct longlong_struct\n+{\n+  long long ll;\n+};\n+\n+struct long2_struct\n+{\n+  long long ll1, ll2;\n+};\n+\n+struct long3_struct\n+{\n+  long l1, l2, l3;\n+};\n+\n+union un1\n+{\n+  char c;\n+  int i;\n+};\n+\n+union un2\n+{\n+  char c1;\n+  long l;\n+  char c2;\n+};\n+\n+union un3\n+{\n+  struct int_struct is;\n+  struct longlong_struct ls;\n+  union un1 un;\n+};\n+\n+\n+void\n+check_mixed_passing1 (char c1 ATTRIBUTE_UNUSED, struct int_struct is ATTRIBUTE_UNUSED, char c2 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_mixed_passing2 (char c1 ATTRIBUTE_UNUSED, struct long3_struct ls ATTRIBUTE_UNUSED, char c2 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ls.l1 == esp+4);\n+  assert ((unsigned long)&ls.l2 == esp+8);\n+  assert ((unsigned long)&ls.l3 == esp+12);\n+}\n+\n+int\n+main (void)\n+{\n+  struct int_struct is = { 64 };\n+#ifdef CHECK_LARGER_STRUCTS\n+  struct long3_struct l3s = { 65, 66, 67 };\n+#endif\n+\n+  clear_struct_registers;\n+  iregs.I0 = 8;\n+  iregs.I1 = 64;\n+  iregs.I2 = 9;\n+  num_iregs = 3;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_mixed_passing1)(8, is, 9);\n+\n+#ifdef CHECK_LARGER_STRUCTS\n+  clear_struct_registers;\n+  iregs.I0 = 10;\n+  iregbits.I0 = 0xff;\n+  iregs.I1 = 11;\n+  iregbits.I1 = 0xff;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  WRAP_CALL (check_mixed_passing2)(10, l3s, 11);\n+#endif\n+\n+  return 0;\n+}"}, {"sha": "534fc8505ed8a8a236b5d52a69bd7709b17a02f5", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_passing_unions.c", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_passing_unions.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,221 @@\n+/* This tests passing of structs.  */\n+\n+#include \"defines.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+struct int_struct\n+{\n+  int i;\n+};\n+\n+struct long_struct\n+{\n+  long l;\n+};\n+\n+union un1\n+{\n+  char c;\n+  int i;\n+};\n+\n+union un2\n+{\n+  char c1;\n+  long l;\n+  char c2;\n+};\n+\n+union un3\n+{\n+  struct int_struct is;\n+  struct long_struct ls;\n+  union un1 un;\n+};\n+\n+\n+void\n+check_union_passing1(union un1 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_union_passing2(union un2 u1 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_union_passing3(union un3 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+#define check_union_passing1 WRAP_CALL(check_union_passing1)\n+#define check_union_passing2 WRAP_CALL(check_union_passing2)\n+#define check_union_passing3 WRAP_CALL(check_union_passing3)\n+\n+union un4\n+{\n+  int i;\n+  float f;\n+};\n+\n+union un5\n+{\n+  long long ll;\n+  double d;\n+};\n+\n+void\n+check_union_passing4(union un4 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un4 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+void\n+check_union_passing5(union un5 u ATTRIBUTE_UNUSED)\n+{\n+  check_int_arguments;\n+}\n+\n+#define check_union_passing4 WRAP_CALL(check_union_passing4)\n+#define check_union_passing5 WRAP_CALL(check_union_passing5)\n+\n+union un6\n+{\n+  __float128 f128;\n+  int i;\n+};\n+\n+\n+void\n+check_union_passing6(union un6 u ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.f128 == esp+4);\n+  assert ((unsigned long)&u.i == esp+4);\n+}\n+\n+#define check_union_passing6 WRAP_CALL(check_union_passing6)\n+\n+int\n+main (void)\n+{\n+  union un1 u1;\n+#ifdef CHECK_LARGER_UNION_PASSING\n+  union un2 u2;\n+  union un3 u3;\n+  struct int_struct is;\n+  struct long_struct ls;\n+#endif /* CHECK_LARGER_UNION_PASSING */\n+  union un4 u4[8];\n+  union un5 u5 = { { 48.394, 39.3, -397.9, 3484.9 } };\n+  int i;\n+  union un6 u6;\n+\n+  /* Check a union with char, int.  */\n+  clear_struct_registers;\n+  u1.i = 0;  /* clear the struct to not have high bits left */\n+  u1.c = 32;\n+  iregs.I0 = 32;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing1(u1);\n+  u1.i = 0;  /* clear the struct to not have high bits left */\n+  u1.i = 33;\n+  iregs.I0 = 33;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing1(u1);\n+\n+  /* Check a union with char, long, char.  */\n+#ifdef CHECK_LARGER_UNION_PASSING\n+  clear_struct_registers;\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.c1 = 34;\n+  iregs.I0 = 34;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.l = 35;\n+  iregs.I0 = 35;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+  u2.l = 0;  /* clear the struct to not have high bits left */\n+  u2.c2 = 36;\n+  iregs.I0 = 36;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing2(u2);\n+\n+  /* check a union containing two structs and a union.  */\n+  clear_struct_registers;\n+  is.i = 37;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.is = is;\n+  iregs.I0 = 37;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  ls.l = 38;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.ls = ls;\n+  iregs.I0 = 38;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  u1.c = 39;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.un = u1;\n+  iregs.I0 = 39;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+  u1.i = 40;\n+  u3.ls.l = 0;  /* clear the struct to not have high bits left */\n+  u3.un = u1;\n+  iregs.I0 = 40;\n+  num_iregs = 1;\n+  clear_int_hardware_registers;\n+  check_union_passing3(u3);\n+#endif /* CHECK_LARGER_UNION_PASSING */\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    u4[i].f = 32 + i;\n+  iregs.I0 = u4[0].i;\n+  iregs.I1 = u4[1].i;\n+  iregs.I2 = u4[2].i;\n+  num_iregs = 3;\n+  clear_int_hardware_registers;\n+  check_union_passing4(u4[0], u4[1], u4[2], u4[3],\n+\t\t       u4[4], u4[5], u4[6], u4[7]);\n+\n+  clear_struct_registers;\n+  iregs.I0 = u5.ll & 0xffffffff;\n+  iregs.I1 = (u5.ll >> 32) & 0xffffffff;\n+  num_iregs = 2;\n+  clear_int_hardware_registers;\n+  check_union_passing5(u5);\n+\n+  u6.i = 2;\n+  check_union_passing6(u6);\n+\n+  return 0;\n+}"}, {"sha": "49a6b1f0a6e9635c5469f09c44d3cf7db06b275e", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_struct_returning.c", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_struct_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_struct_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_struct_returning.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,362 @@\n+/* This tests returning of structures.  */\n+\n+#include \"defines.h\"\n+#include \"macros.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregbits = { ~0, ~0, ~0, ~0, ~0, ~0 };\n+struct IntegerRegisters iregs;\n+unsigned int num_iregs;\n+\n+int current_test;\n+int num_failed = 0;\n+\n+typedef enum {\n+  EAX = 0,\n+  EAX_EDX,\n+  LONG_LONG,\n+  FLOAT,\n+  DOUBLE,\n+  FLOAT_FLOAT,\n+  EAX_FLOAT,\n+  FLOAT_EDX,\n+  MEM\n+} Type;\n+\n+/* Structures which should be returned in EAX/LONG_LONG/EAX_EDX.  */\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; iamcu_memset (&s, 0, sizeof(s)); B; return s; }\n+\n+D(1,char m1, EAX, s.m1=42)\n+D(2,short m1, EAX, s.m1=42)\n+D(3,int m1, EAX, s.m1=42)\n+D(4,char m1[3], EAX, s.m1[0]=42)\n+D(5,char m1[4], EAX, s.m1[0]=42)\n+D(6,char m1;char m2; char m3, EAX, s.m1=42)\n+D(7,char m1;short m2, EAX, s.m1=42)\n+\n+D(30,long long m1, LONG_LONG, s.m1=0xadadbeefadadbeefLL)\n+\n+D(50,short m1;int m2, EAX_EDX, s.m1=42; s.m2=43)\n+D(51,char m1;int m2, EAX_EDX, s.m1=42; s.m2=43)\n+D(52,char m1[5], EAX_EDX, s.m1[0]=42; s.m1[4]=43)\n+D(53,char m1[6], EAX_EDX, s.m1[0]=42; s.m1[4]=43)\n+D(54,char m1[7], EAX_EDX, s.m1[0]=42; s.m1[4]=43)\n+D(55,char m1[8], EAX_EDX, s.m1[0]=42; s.m1[4]=43)\n+D(56,char m1;short m2[2], EAX_EDX, s.m1=42; s.m2[1]=43)\n+D(57,short m1[4], EAX_EDX, s.m1[0]=42; s.m1[2]=43)\n+D(58,int m1[2], EAX_EDX, s.m1[0]=42; s.m1[1]=43)\n+D(59,int m1;char m2, EAX_EDX, s.m1=42; s.m2=43)\n+D(60,int m1;short m2, EAX_EDX, s.m1=42; s.m2=43)\n+D(61,int m1;short m2; char m3, EAX_EDX, s.m1=42; s.m2=43)\n+D(62,int m1;char m2; short m3, EAX_EDX, s.m1=42; s.m2=43)\n+\n+/* Packed members.  */\n+D(100,short m1[1];int m2 PACKED, EAX_EDX, s.m1[0]=42; s.m2=43)\n+D(101,char m1; short m2 PACKED; char m3, EAX_EDX, s.m1=42; s.m3=43)\n+\n+/* Structures which should be returned in FLOAT/DOUBLE.  */\n+#undef D\n+#define D(I,MEMBERS,C,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = C; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; iamcu_memset (&s, 0, sizeof(s)); B; return s; }\n+\n+D(200,float f, FLOAT, s.f=42)\n+D(201,double d, DOUBLE, s.d=42)\n+\n+D(300,float m;char m2, FLOAT_EDX, s.m=42; s.m2=43)\n+D(301,float m;short m2, FLOAT_EDX, s.m=42; s.m2=43)\n+D(302,float m;int m2, FLOAT_EDX, s.m=42; s.m2=43)\n+\n+D(400,char m1; float m2, EAX_FLOAT, s.m1=42; s.m2=43)\n+D(401,short m1; float m2, EAX_FLOAT, s.m1=42; s.m2=43)\n+D(402,int m1; float m2, EAX_FLOAT, s.m1=42; s.m2=43)\n+\n+D(500,float m;float m2, FLOAT_FLOAT, s.m=42; s.m2=43)\n+D(501,float f[2], FLOAT, s.f[0]=42; s.f[1]=43)\n+\n+/* Structures which should be returned in MEM.  */\n+void *struct_addr;\n+#undef D\n+#define D(I,MEMBERS) struct S_ ## I { MEMBERS ; }; Type class_ ## I = MEM; \\\n+struct S_ ## I f_ ## I (void) { union {unsigned char c; struct S_ ## I s;} u; iamcu_memset (&u.s, 0, sizeof(u.s)); u.c = 42; return u.s; }\n+\n+/* Too large.  */\n+D(600,char m1[17])\n+D(601,short m1[9])\n+D(602,int m1[5])\n+D(603,long m1[3])\n+D(604,short m1[8];char c)\n+D(605,char m1[1];int i[4])\n+D(606,float m1[5])\n+D(607,double m1[3])\n+D(608,char m1[1];float f[4])\n+D(609,char m1[1];double d[2])\n+D(610,__complex long double m1[1])\n+\n+/* Too large due to padding.  */\n+D(611,char m1[1]; int i; char c2)\n+\n+/* Special tests.  */\n+#undef D\n+#define D(I,MEMBERS,B) struct S_ ## I { MEMBERS ; }; Type class_ ## I = MEM; \\\n+struct S_ ## I f_ ## I (void) { struct S_ ## I s; B; return s; }\n+D(700,float f[4], s.f[0] = s.f[1] = s.f[2] = s.f[3] = 42)\n+\n+void\n+check_eax (void)\n+{\n+  switch (current_test)\n+    {\n+    case 1:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+      eax &= 0xff;\n+      break;\n+    case 2:\n+      eax &= 0xffff;\n+      break;\n+    case 3:\n+      eax &= 0xffff;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (eax != 42)\n+    num_failed++;\n+}\n+\n+void\n+check_eax_edx (void)\n+{\n+  unsigned long long ll = eax | ((unsigned long long) edx) << 32;\n+  switch (current_test)\n+    {\n+    case 50:\n+      eax &= 0xffff;\n+      break;\n+    case 52:\n+    case 53:\n+    case 54:\n+    case 55:\n+      edx &= 0xff;\n+    case 51:\n+      eax &= 0xff;\n+      break;\n+    case 56:\n+      eax &= 0xff;\n+      edx &= 0xffff;\n+      break;\n+    case 57:\n+      eax &= 0xffff;\n+      edx &= 0xffff;\n+      break;\n+    case 58:\n+      break;\n+    case 59:\n+    case 62:\n+      edx &= 0xff;\n+      break;\n+    case 60:\n+    case 61:\n+      edx &= 0xffff;\n+      break;\n+    case 100:\n+      eax &= 0xffff;\n+      edx = (ll >> 16) & 0xffffffff;\n+      break;\n+    case 101:\n+      edx = (eax >> 24) & 0xff;\n+      eax &= 0xff;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (eax != 42 || edx != 43)\n+    num_failed++;\n+}\n+\n+void\n+check_float_edx (void)\n+{\n+  union\n+    {\n+      unsigned long l;\n+      float f;\n+    } ueax;\n+  switch (current_test)\n+    {\n+    case 300:\n+      edx &= 0xff;\n+      break;\n+    case 301:\n+      edx &= 0xffff;\n+      break;\n+    case 302:\n+      edx &= 0xffff;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  ueax.l = eax;\n+  if (ueax.f != 42 || edx != 43)\n+    num_failed++;\n+}\n+\n+void\n+check_eax_float (void)\n+{\n+  union\n+    {\n+      unsigned long l;\n+      float f;\n+    } uedx;\n+  switch (current_test)\n+    {\n+    case 400:\n+      eax &= 0xff;\n+      break;\n+    case 401:\n+      eax &= 0xffff;\n+      break;\n+    case 402:\n+      eax &= 0xffff;\n+      break;\n+    default:\n+      abort ();\n+    }\n+  uedx.l = edx;\n+  if (eax != 42 || uedx.f != 43)\n+    num_failed++;\n+}\n+\n+void\n+check_float_float (void)\n+{\n+  union\n+    {\n+      unsigned long l;\n+      float f;\n+    } ueax, uedx;\n+  switch (current_test)\n+    {\n+    case 500:\n+    case 501:\n+      break;\n+    default:\n+      abort ();\n+    }\n+  ueax.l = eax;\n+  uedx.l = edx;\n+  if (ueax.f != 42 || uedx.f != 43)\n+    num_failed++;\n+}\n+\n+void\n+check_all (Type class, unsigned long size)\n+{\n+  union\n+    {\n+      struct\n+\t{\n+\t  unsigned long eax;\n+\t  unsigned long edx;\n+\t} eax_edx;\n+      unsigned long long ll;\n+      float f;\n+      double d;\n+    } u;\n+\n+  switch (class)\n+    {\n+    case EAX:\n+      check_eax ();\n+      break;\n+    case LONG_LONG:\n+      if (0xadadbeefL != eax || 0xadadbeefL != edx)\n+\tnum_failed++;\n+      break;\n+    case EAX_EDX:\n+      check_eax_edx ();\n+      break;\n+    case FLOAT:\n+      u.eax_edx.eax = eax;\n+      if (u.f != 42)\n+\tnum_failed++;\n+      break;\n+    case DOUBLE:\n+      u.eax_edx.eax = eax;\n+      u.eax_edx.edx = edx;\n+      if (u.d != 42)\n+\tnum_failed++;\n+      break;\n+    case FLOAT_EDX:\n+      check_float_edx ();\n+      break;\n+    case FLOAT_FLOAT:\n+      check_float_float ();\n+      break;\n+    case EAX_FLOAT:\n+      check_eax_float ();\n+      break;\n+    case MEM:\n+      /* sret_eax contains a slot whose address is given to the f_*\n+\t functions.  The slot may be a temporary one on stack.  When\n+\t this function is called, hopefully this slot hasn't be\n+\t overriden.  */\n+      if (sret_eax != eax)\n+\tnum_failed++;\n+      else if (current_test < 700)\n+\t{\n+\t  if (*(unsigned char*)sret_eax != 42\n+\t      || *(unsigned char*)struct_addr != 42)\n+\t    num_failed++;\n+\t}\n+      else\n+\t{\n+\t  if (*(float *)sret_eax != 42\n+\t      || *(float *)struct_addr != 42)\n+\t    num_failed++;\n+\t}\n+      break;\n+    }\n+}\n+\n+#undef D\n+#define D(I) { static struct S_ ## I s; current_test = I; struct_addr = (void*)&s; \\\n+  clear_non_sret_int_registers; \\\n+  s = WRAP_RET(f_ ## I) (); \\\n+  check_all(class_ ## I, sizeof(s)); \\\n+}\n+\n+int\n+main (void)\n+{\n+  D(1) D(2) D(3) D(4) D(5) D(6) D(7)\n+\n+  D(30)\n+\n+  D(50) D(51) D(52) D(53) D(54) D(55) D(56) D(57) D(58) D(59)\n+  D(60) D(61) D(62)\n+\n+  D(100) D(101)\n+\n+  D(200) D(201)\n+\n+  D(300) D(301) D(302)\n+\n+  D(400) D(401) D(402)\n+\n+  D(500) D(501)\n+\n+  D(600) D(601) D(602) D(603) D(604) D(605) D(606) D(607) D(608) D(609)\n+  D(610) D(611)\n+\n+  D(700)\n+\n+  if (num_failed)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "124bef17c621a7a97fffa6a61390eeb4465b0e01", "filename": "gcc/testsuite/gcc.target/i386/iamcu/test_varargs.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_varargs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b970b6e69aeddad690f7b1465d8aeeeb07c7536/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_varargs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fiamcu%2Ftest_varargs.c?ref=8b970b6e69aeddad690f7b1465d8aeeeb07c7536", "patch": "@@ -0,0 +1,101 @@\n+/* Test variable number of arguments passed to functions.  */\n+\n+#include <stdarg.h>\n+#include \"defines.h\"\n+\n+\n+#define ARG_INT     1\n+#define ARG_DOUBLE  2\n+#define ARG_POINTER 3\n+\n+union types\n+{\n+  int ivalue;\n+  double dvalue;\n+  void *pvalue;\n+};\n+\n+struct arg\n+{\n+  int type;\n+  union types value;\n+};\n+\n+struct arg *arglist;\n+\n+/* This tests the argumentlist to see if it matches the format string which\n+   is printf-like. Nothing will be printed of course. It can handle ints,\n+   doubles and void pointers. The given value will be tested against the\n+   values given in arglist.\n+   This test only assures that the variable argument passing is working.\n+   No attempt is made to see if argument passing is done the right way.  */\n+void\n+__attribute__ ((noinline))\n+noprintf (char *format, ...)\n+{\n+  va_list va_arglist;\n+  char *c;\n+\n+  int ivalue;\n+  double dvalue;\n+  void *pvalue;\n+  struct arg *argp = arglist;\n+\n+  va_start (va_arglist, format);\n+  for (c = format; *c; c++)\n+    if (*c == '%')\n+      {\n+\tswitch (*++c)\n+\t  {\n+\t  case 'd':\n+\t    assert (argp->type == ARG_INT);\n+\t    ivalue = va_arg (va_arglist, int);\n+\t    assert (argp->value.ivalue == ivalue);\n+\t    break;\n+\t  case 'f':\n+\t    assert (argp->type == ARG_DOUBLE);\n+\t    dvalue = va_arg (va_arglist, double);\n+\t    assert (argp->value.dvalue == dvalue);\n+\t    break;\n+\t  case 'p':\n+\t    assert (argp->type == ARG_POINTER);\n+\t    pvalue = va_arg (va_arglist, void *);\n+\t    assert (argp->value.pvalue == pvalue);\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\n+\targp++;\n+      }\n+}\n+\n+extern void iamcu_noprintf (char *, ...);\n+\n+int\n+main (void)\n+{\n+#ifdef CHECK_VARARGS\n+  float f = 258.0;\n+  struct arg al[5];\n+\n+  al[0].type = ARG_INT;\n+  al[0].value.ivalue = 256;\n+  al[1].type = ARG_DOUBLE;\n+  al[1].value.dvalue = 257.0;\n+  al[2].type = ARG_POINTER;\n+  al[2].value.pvalue = al;\n+  al[3].type = ARG_DOUBLE;\n+  al[3].value.dvalue = f;\n+  al[4].type = ARG_INT;\n+  al[4].value.ivalue = 259;\n+\n+  arglist = al;\n+  noprintf(\"%d%f%p%f%d\", 256, 257.0, al, f, 259);\n+\n+  iamcu_noprintf ((char *) 0xabadbeef, 256, 257.0,\n+\t\t  (void *) 0xbbadbeef, f, 259);\n+#endif\n+\n+  return 0;\n+}"}]}