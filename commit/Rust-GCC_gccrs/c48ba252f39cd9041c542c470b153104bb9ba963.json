{"sha": "c48ba252f39cd9041c542c470b153104bb9ba963", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ4YmEyNTJmMzljZDkwNDFjNTQyYzQ3MGIxNTMxMDRiYjliYTk2Mw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-08-26T08:40:47Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-08-26T08:40:47Z"}, "message": "loop.c (check_dbra_loop): Add some code that would allow reversal of some loops without a known constant...\n\n\t* loop.c (check_dbra_loop): Add some code that would allow reversal\n\tof some loops without a known constant loop end if it were enabled.\n\nFrom-SVN: r22000", "tree": {"sha": "0cdbe55ac202a9e06d293294a8eb3236212766e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cdbe55ac202a9e06d293294a8eb3236212766e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c48ba252f39cd9041c542c470b153104bb9ba963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48ba252f39cd9041c542c470b153104bb9ba963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c48ba252f39cd9041c542c470b153104bb9ba963", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c48ba252f39cd9041c542c470b153104bb9ba963/comments", "author": null, "committer": null, "parents": [{"sha": "ef75736785c9ea83d2f9b01a03aeef0b45501e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef75736785c9ea83d2f9b01a03aeef0b45501e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef75736785c9ea83d2f9b01a03aeef0b45501e72"}], "stats": {"total": 271, "additions": 207, "deletions": 64}, "files": [{"sha": "fb27fbf283d00d2dd77027c58b1bdb36e4cb238a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48ba252f39cd9041c542c470b153104bb9ba963/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48ba252f39cd9041c542c470b153104bb9ba963/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c48ba252f39cd9041c542c470b153104bb9ba963", "patch": "@@ -1,3 +1,8 @@\n+Wed Aug 26 16:35:37 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (check_dbra_loop): Add some code that would allow reversal\n+\tof some loops without a known constant loop end if it were enabled.\n+\n Wed Aug 26 11:08:44 1998  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* mips.md (lshrsi3_internal2+2): Fix type-o."}, {"sha": "a34106df26b3f2d619b453cd1230e99defa597a6", "filename": "gcc/loop.c", "status": "modified", "additions": 202, "deletions": 64, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c48ba252f39cd9041c542c470b153104bb9ba963/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c48ba252f39cd9041c542c470b153104bb9ba963/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c48ba252f39cd9041c542c470b153104bb9ba963", "patch": "@@ -6777,7 +6777,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t    }\n \t}\n     }\n-  else if (num_mem_sets <= 1)\n+  else if (INTVAL (bl->biv->add_val) > 0)\n     {\n       /* Try to change inc to dec, so can apply above optimization.  */\n       /* Can do this if:\n@@ -6797,10 +6797,6 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t which is reversible.  */\n       int reversible_mem_store = 1;\n \n-      for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n-\tif (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n-\t  num_nonfixed_reads += count_nonfixed_reads (PATTERN (p));\n-\n       if (bl->giv_count == 0\n \t  && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n \t{\n@@ -6824,39 +6820,51 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\t  /* Don't bother about the end test.  */\n \t\t  ;\n \t\telse if (reg_mentioned_p (bivreg, PATTERN (p)))\n-\t\t  /* Any other use of the biv is no good.  */\n \t\t  {\n \t\t    no_use_except_counting = 0;\n \t\t    break;\n \t\t  }\n \t      }\n \t}\n \n-      /* If the loop has a single store, and the destination address is\n-\t invariant, then we can't reverse the loop, because this address\n-\t might then have the wrong value at loop exit.\n-\t This would work if the source was invariant also, however, in that\n-\t case, the insn should have been moved out of the loop.  */\n-\n-      if (num_mem_sets == 1)\n-\treversible_mem_store\n-\t  = (! unknown_address_altered\n-\t     && ! invariant_p (XEXP (loop_store_mems[0], 0)));\n+      if (no_use_except_counting)\n+\t; /* no need to worry about MEMs.  */\n+      else if (num_mem_sets <= 1)\n+\t{\n+\t  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n+\t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n+\t      num_nonfixed_reads += count_nonfixed_reads (PATTERN (p));\n+\n+\t  /* If the loop has a single store, and the destination address is\n+\t     invariant, then we can't reverse the loop, because this address\n+\t     might then have the wrong value at loop exit.\n+\t     This would work if the source was invariant also, however, in that\n+\t     case, the insn should have been moved out of the loop.  */\n+\n+\t  if (num_mem_sets == 1)\n+\t    reversible_mem_store\n+\t      = (! unknown_address_altered\n+\t\t && ! invariant_p (XEXP (loop_store_mems[0], 0)));\n+\t}\n+      else\n+\treturn 0;\n \n       /* This code only acts for innermost loops.  Also it simplifies\n \t the memory address check by only reversing loops with\n \t zero or one memory access.\n \t Two memory accesses could involve parts of the same array,\n-\t and that can't be reversed.  */\n-\n-      if (num_nonfixed_reads <= 1\n-\t  && !loop_has_call\n-\t  && !loop_has_volatile\n-\t  && reversible_mem_store\n-\t  && (no_use_except_counting\n-\t      || ((bl->giv_count + bl->biv_count + num_mem_sets\n-\t\t   + num_movables + compare_and_branch == insn_count)\n-\t\t  && (bl == loop_iv_list && bl->next == 0))))\n+\t and that can't be reversed.\n+\t If the biv is used only for counting, than we don't need to worry\n+\t about all these things.  */\n+\n+      if ((num_nonfixed_reads <= 1\n+\t   && !loop_has_call\n+\t   && !loop_has_volatile\n+\t   && reversible_mem_store\n+\t   && (bl->giv_count + bl->biv_count + num_mem_sets\n+\t      + num_movables + compare_and_branch == insn_count)\n+\t   && (bl == loop_iv_list && bl->next == 0))\n+\t  || no_use_except_counting)\n \t{\n \t  rtx tem;\n \n@@ -6874,46 +6882,125 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t     confusing.  */\n \n \t  if (comparison\n-\t      && GET_CODE (XEXP (comparison, 1)) == CONST_INT\n-\t      /* LE gets turned into LT */\n-\t      && GET_CODE (comparison) == LT\n-\t      && GET_CODE (bl->initial_value) == CONST_INT)\n+\t      /* for constants, LE gets turned into LT */\n+\t      && (GET_CODE (comparison) == LT\n+\t\t  || (GET_CODE (comparison) == LE\n+\t\t      && no_use_except_counting)))\n \t    {\n-\t      HOST_WIDE_INT add_val, comparison_val;\n-\t      rtx initial_value;\n+\t      HOST_WIDE_INT add_val, add_adjust, comparison_val;\n+\t      rtx initial_value, comparison_value;\n+\t      int nonneg = 0;\n+\t      enum rtx_code cmp_code;\n+\t      int comparison_const_width;\n+\t      unsigned HOST_WIDE_INT comparison_sign_mask;\n+\t      rtx vtop;\n \n \t      add_val = INTVAL (bl->biv->add_val);\n-\t      comparison_val = INTVAL (XEXP (comparison, 1));\n-\t      final_value = XEXP (comparison, 1);\n+\t      comparison_value = XEXP (comparison, 1);\n+\t      comparison_const_width\n+\t\t= GET_MODE_BITSIZE (GET_MODE (XEXP (comparison, 1)));\n+\t      if (comparison_const_width > HOST_BITS_PER_WIDE_INT)\n+\t\tcomparison_const_width = HOST_BITS_PER_WIDE_INT;\n+\t      comparison_sign_mask\n+\t\t= (unsigned HOST_WIDE_INT)1 << (comparison_const_width - 1);\n+\n+\t      if (GET_CODE (comparison_value) == CONST_INT)\n+\t\tcomparison_val = INTVAL (comparison_value);\n \t      initial_value = bl->initial_value;\n \t\t\n \t      /* Normalize the initial value if it is an integer and \n \t\t has no other use except as a counter.  This will allow\n \t\t a few more loops to be reversed.  */\n \t      if (no_use_except_counting\n+\t\t  && GET_CODE (comparison_value) == CONST_INT\n \t\t  && GET_CODE (initial_value) == CONST_INT)\n \t\t{\n \t\t  comparison_val = comparison_val - INTVAL (bl->initial_value);\n-\t\t  /* Check for overflow.  If comparison_val ends up as a\n-\t\t     negative value, then we can't reverse the loop.  */\n-\t\t  if (comparison_val >= 0)\n-\t\t    initial_value = const0_rtx;\n+\t\t  /* The code below requires comparison_val to be a multiple\n+\t\t     of add_val in order to do the loop reversal, so\n+\t\t     round up comparison_val to a multiple of add_val.\n+\t\t     Since comparison_value is constant, we know that the\n+\t\t     current comparison code is LT.  */\n+\t\t  comparison_val = comparison_val + add_val - 1;\n+\t\t  comparison_val\n+\t\t    -= (unsigned HOST_WIDE_INT) comparison_val % add_val;\n+\t\t  /* We postpone overflow checks for COMPARISON_VAL here;\n+\t\t     even if there is an overflow, we might still be able to\n+\t\t     reverse the loop, if converting the loop exit test to\n+\t\t     NE is possible.  */\n+\t\t  initial_value = const0_rtx;\n \t\t}\n \n+#if 0\n+\t      /* Check if there is a NOTE_INSN_LOOP_VTOP note.  If there is,\n+\t\t that means that this is a for or while style loop, with\n+\t\t a loop exit test at the start.  Thus, we can assume that\n+\t\t the loop condition was true when the loop was entered.\n+\t\t This allows us to change the loop exit condition to an\n+\t\t equality test.\n+\t\t We start at the end and search backwards for the previous\n+\t\t NOTE.  If there is no NOTE_INSN_LOOP_VTOP for this loop,\n+\t\t the search will stop at the NOTE_INSN_LOOP_CONT.  */\n+\t      vtop = loop_end;\n+\t      do\n+\t\tvtop = PREV_INSN (vtop);\n+\t      while (GET_CODE (vtop) != NOTE);\n+\t      if (NOTE_LINE_NUMBER (vtop) != NOTE_INSN_LOOP_VTOP)\n+\t\tvtop = NULL_RTX;\n+#else\n+\t      vtop = NULL_RTX;\n+#endif\n+\t\t\n+\t      /* First check if we can do a vanilla loop reversal.  */\n+\t      if (initial_value == const0_rtx\n+\t\t  /* If we have a decrement_and_branch_on_count, prefer\n+\t\t     the NE test, since this will allow that instruction to\n+\t\t     be generated.  */\n+#if ! defined (HAVE_decrement_and_branch_on_zero) && defined (HAVE_decrement_and_branch_on_count)\n+\t\t  && (add_val != 1 || ! vtop)\n+#endif\n+\t\t  && GET_CODE (comparison_value) == CONST_INT\n+\t\t     /* Now do postponed overflow checks on COMPARISON_VAL.  */\n+\t\t  && ! (((comparison_val - add_val) ^ INTVAL (comparison_value))\n+\t\t\t& comparison_sign_mask))\n+\t\t{\n+\t\t  /* Register will always be nonnegative, with value\n+\t\t     0 on last iteration */\n+\t\t  add_adjust = add_val;\n+\t\t  nonneg = 1;\n+\t\t  cmp_code = GE;\n+\t\t}\n+\t      else if (add_val == 1 && vtop)\n+\t\t{\n+\t\t  add_adjust = 0;\n+\t\t  cmp_code = NE;\n+\t\t}\n+\t      else\n+\t\treturn 0;\n+\n+\t      if (GET_CODE (comparison) == LE)\n+\t\tadd_adjust -= add_val;\n+\n \t      /* If the initial value is not zero, or if the comparison\n \t\t value is not an exact multiple of the increment, then we\n \t\t can not reverse this loop.  */\n-\t      if (initial_value != const0_rtx\n-\t\t  || (comparison_val % add_val) != 0)\n-\t\treturn 0;\n+\t      if (initial_value == const0_rtx\n+\t\t  && GET_CODE (comparison_value) == CONST_INT)\n+\t\t{\n+\t\t  if (((unsigned HOST_WIDE_INT) comparison_val % add_val) != 0)\n+\t\t    return 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (! no_use_except_counting || add_val != 1)\n+\t\t    return 0;\n+\t\t}\n \n \t      /* Reset these in case we normalized the initial value\n \t\t and comparison value above.  */\n \t      bl->initial_value = initial_value;\n-\t      XEXP (comparison, 1) = GEN_INT (comparison_val);\n-\n-\t      /* Register will always be nonnegative, with value\n-\t\t 0 on last iteration if loop reversed */\n+\t      if (GET_CODE (comparison_value) == CONST_INT)\n+\t\tcomparison_value = GEN_INT (comparison_val);\n \n \t      /* Save some info needed to produce the new insns.  */\n \t      reg = bl->biv->dest_reg;\n@@ -6922,13 +7009,60 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\tjump_label = XEXP (SET_SRC (PATTERN (PREV_INSN (loop_end))), 2);\n \t      new_add_val = GEN_INT (- INTVAL (bl->biv->add_val));\n \n-\t      start_value = GEN_INT (INTVAL (XEXP (comparison, 1))\n-\t\t\t\t     - INTVAL (bl->biv->add_val));\n-\n-\t      /* Initialize biv to start_value before loop start.\n+\t      final_value = comparison_value;\n+\t      /* Set start_value; if this is not a CONST_INT, we need\n+\t\t to generate a SUB.\n+\t\t Initialize biv to start_value before loop start.\n \t\t The old initializing insn will be deleted as a\n \t\t dead store by flow.c.  */\n-\t      emit_insn_before (gen_move_insn (reg, start_value), loop_start);\n+\t      if (initial_value == const0_rtx\n+\t\t  && GET_CODE (comparison_value) == CONST_INT)\n+\t\t{\n+\t\t  start_value = GEN_INT (comparison_val - add_adjust);\n+\t\t  emit_insn_before (gen_move_insn (reg, start_value),\n+\t\t\t\t    loop_start);\n+\t\t}\n+\t      else if (GET_CODE (initial_value) == CONST_INT)\n+\t\t{\n+\t\t  rtx offset = GEN_INT (-INTVAL (initial_value) - add_adjust);\n+\t\t  enum machine_mode mode = GET_MODE (reg);\n+\t\t  enum insn_code icode\n+\t\t    = add_optab->handlers[(int) mode].insn_code;\n+\t\t  if (! (*insn_operand_predicate[icode][0]) (reg, mode)\n+\t\t      || ! ((*insn_operand_predicate[icode][1])\n+\t\t\t    (comparison_value, mode))\n+\t\t      || ! (*insn_operand_predicate[icode][2]) (offset, mode))\n+\t\t    return 0;\n+\t\t  start_value\n+\t\t    = gen_rtx_PLUS (mode, comparison_value, offset);\n+\t\t  emit_insn_before ((GEN_FCN (icode)\n+\t\t\t\t     (reg, comparison_value, offset)),\n+\t\t\t\t    loop_start);\n+\t\t  if (GET_CODE (comparison) == LE)\n+\t\t    final_value = gen_rtx_PLUS (mode, comparison_value,\n+\t\t\t\t\t\tGEN_INT (add_val));\n+\t\t}\n+\t      else if (! add_adjust)\n+\t\t{\n+\t\t  enum machine_mode mode = GET_MODE (reg);\n+\t\t  enum insn_code icode\n+\t\t    = sub_optab->handlers[(int) mode].insn_code;\n+\t\t  if (! (*insn_operand_predicate[icode][0]) (reg, mode)\n+\t\t      || ! ((*insn_operand_predicate[icode][1])\n+\t\t\t    (comparison_value, mode))\n+\t\t      || ! ((*insn_operand_predicate[icode][2])\n+\t\t\t    (initial_value, mode)))\n+\t\t    return 0;\n+\t\t  start_value\n+\t\t    = gen_rtx_MINUS (mode, comparison_value, initial_value);\n+\t\t  emit_insn_before ((GEN_FCN (icode)\n+\t\t\t\t     (reg, comparison_value, initial_value)),\n+\t\t\t\t    loop_start);\n+\t\t}\n+\t      else\n+\t\t/* We could handle the other cases too, but it'll be\n+\t\t   better to have a testcase first.  */\n+\t\treturn 0;\n \n \t      /* Add insn to decrement register, and delete insn\n \t\t that incremented the register.  */\n@@ -6960,29 +7094,33 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \n \t      /* Add new compare/branch insn at end of loop.  */\n \t      start_sequence ();\n-\t      emit_cmp_insn (reg, const0_rtx, GE, NULL_RTX,\n+\t      emit_cmp_insn (reg, const0_rtx, cmp_code, NULL_RTX,\n \t\t\t     GET_MODE (reg), 0, 0);\n-\t      emit_jump_insn (gen_bge (XEXP (jump_label, 0)));\n+\t      emit_jump_insn ((*bcc_gen_fctn[(int) cmp_code])\n+\t\t\t      (XEXP (jump_label, 0)));\n \t      tem = gen_sequence ();\n \t      end_sequence ();\n \t      emit_jump_insn_before (tem, loop_end);\n \n-\t      for (tem = PREV_INSN (loop_end);\n-\t\t   tem && GET_CODE (tem) != JUMP_INSN; tem = PREV_INSN (tem))\n-\t\t;\n-\t      if (tem)\n+\t      if (nonneg)\n \t\t{\n-\t\t  JUMP_LABEL (tem) = XEXP (jump_label, 0);\n+\t\t  for (tem = PREV_INSN (loop_end);\n+\t\t       tem && GET_CODE (tem) != JUMP_INSN;\n+\t\t       tem = PREV_INSN (tem))\n+\t\t    ;\n+\t\t  if (tem)\n+\t\t    {\n+\t\t      JUMP_LABEL (tem) = XEXP (jump_label, 0);\n \n-\t\t  /* Increment of LABEL_NUSES done above.  */\n-\t\t  /* Register is now always nonnegative,\n-\t\t     so add REG_NONNEG note to the branch.  */\n-\t\t  REG_NOTES (tem) = gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX,\n-\t\t\t\t\t\t       REG_NOTES (tem));\n+\t\t      /* Increment of LABEL_NUSES done above.  */\n+\t\t      /* Register is now always nonnegative,\n+\t\t\t so add REG_NONNEG note to the branch.  */\n+\t\t      REG_NOTES (tem) = gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX,\n+\t\t\t\t\t\t\t   REG_NOTES (tem));\n+\t\t    }\n+\t\t  bl->nonneg = 1;\n \t\t}\n \n-\t      bl->nonneg = 1;\n-\n \t      /* Mark that this biv has been reversed.  Each giv which depends\n \t\t on this biv, and which is also live past the end of the loop\n \t\t will have to be fixed up.  */"}]}