{"sha": "f314b9b1682cb72cde6561b8e05eba08d94e1edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxNGI5YjE2ODJjYjcyY2RlNjU2MWI4ZTA1ZWJhMDhkOTRlMWVkZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2001-08-11T20:56:12Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2001-08-11T20:56:12Z"}, "message": "Bring s390 backend back in sync with branch.\n\nFrom-SVN: r44810", "tree": {"sha": "6c8e65d8e2e8cf26742027be9ca1a8e9bac32a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c8e65d8e2e8cf26742027be9ca1a8e9bac32a17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f314b9b1682cb72cde6561b8e05eba08d94e1edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f314b9b1682cb72cde6561b8e05eba08d94e1edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f314b9b1682cb72cde6561b8e05eba08d94e1edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f314b9b1682cb72cde6561b8e05eba08d94e1edd/comments", "author": null, "committer": null, "parents": [{"sha": "dddba20582b31693ee7b83ff0be038bc0a39fc25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dddba20582b31693ee7b83ff0be038bc0a39fc25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dddba20582b31693ee7b83ff0be038bc0a39fc25"}], "stats": {"total": 554, "additions": 390, "deletions": 164}, "files": [{"sha": "18244a12d575ba8157538b8ff0161d20b94436bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,3 +1,51 @@\n+2001-08-11  Ulrich Weigand  <uweigand@de.ibm.com>\n+ \n+ \t* config/s390/s390.c (targetm): Define TARGET_ASM_OPEN_PAREN\n+\tand TARGET_ASM_CLOSE_PAREN.\n+\t(regclass_map): CC register belongs to class NO_REGS.\n+\t(legitimize_pic_address): Don't generate unnecessary moves \n+\t(to avoid confusing loop optimization).\n+ \t(check_and_change_labels): Replace jump_long by indirect_jump.\n+\t(s390_final_chunkify): Don't start a new literal pool on section \n+\tswitch in 64-bit code.\n+\t(s390_va_start, s390_va_arg): Fixed incorrect sizes for 64-bit.\n+\t\n+\t* config/s390/s390.h (TARGET_SWITCHES): Renamed debug_arg to debug.\n+\t(MAX_BITS_PER_WORD, MAX_LONG_TYPE_SIZE): Set to 64 (for 64-bit).\n+\t(HARD_REGNO_MODE_OK, RETURN_IN_MEMORY): Support complex integer \n+\tmodes correctly.\n+\t(reg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS): Remove CC_REGS.\n+\t(EH_RETURN_HANDLER_RTX): Fixed incorrect offset for 64-bit.\n+\t(CONST_COSTS): Fixed incorrect costs.\n+\n+\t* config/s390/s390.md (fixuns_trunc[sd]f[sd]i2, udivsi3, umodsi3):\n+\tUse emit_jump instead of emit_jump_insn (gen_jump).\n+\t(divsi3, modsi3): Clobber low word of divmoddisi3 before shifting \n+\t(to avoid confusing flow analysis).\n+\t(tablejump, tablejump1, tablejump2): Removed.  Replaced by casesi.\n+\t(casesi, casesi_jump): New.\n+\t(jump_long): Removed.  Functionality merged into indirect_jump.\n+\t(indirect_jump): Accept address_operand, not just register_operand.\n+\t(cjump_long, icjump_long): Use same logic as indirect_jump.\n+\t(builtin_setjmp_setup, builtin_setjmp_receiver, builtin_longjmp):\n+\tFixed broken setjmp/longjmp handling.\n+\t(do_builtin_setjmp_setup): Removed.\n+\n+\t* config/s390/linux.h (ASM_OUTPUT_DOUBLE_INT): Work around\n+\tbroken GNU as versions that don't accept .quad with large\n+\tnegative values.  Use hexadecimal output instead.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Adapt to new casesi insn.\n+\t(ASM_OPEN_PAREN, ASM_CLOSE_PAREN, FUNCTION_PROLOGUE,\n+\tFUNCTION_EPILOGUE): Removed.  Now in targetm.\n+\n+\t* config/s390/linux64.h (CALL_USED_REGISTERS): Add CC register.\n+\n+\t* config/s390/fixdfdi.h: Add missing copyright statement.\n+\tFix type conflicts on 64-bit.  Add missing SFmode routines.\n+\n+\t* s390.c, s390.h, s390.md, linux.h, linux64.h: Fixed incorrect\n+\temail address.\n+\n 2001-08-11  Richard Henderson  <rth@redhat.com>\n \n \t* rtl.h (REG_EH_RETHROW): Remove."}, {"sha": "4f1fb352f1b1c061c7b10eea09b96a70e58d951e", "filename": "gcc/config/s390/fixdfdi.h", "status": "modified", "additions": 179, "deletions": 12, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Ffixdfdi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ffixdfdi.h?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,29 +1,56 @@\n+/* Definitions of target machine for GNU compiler, for IBM S/390\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n+                  Ulrich Weigand (uweigand@de.ibm.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */ \n+\n #ifdef L_fixunsdfdi\n #define EXPD(fp)\t(((fp.l.upper) >> 20) & 0x7FF)\n #define EXCESSD\t\t1022\n #define SIGNBIT\t\t0x80000000\n #define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n #define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n-#define HIDDEND_LL\t((long long)1 << 52)\n+#define HIDDEND_LL\t((UDItype_x)1 << 52)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n \n union double_long {\n     double d;\n     struct {\n-      long upper;\n-      unsigned long lower;\n+      SItype_x upper;\n+      USItype_x lower;\n     } l;\n-    long long ll;\n+    UDItype_x ll;\n };\n \n \n /* convert double to unsigned int */\n-unsigned long long\n+UDItype_x\n __fixunsdfdi (double a1)\n {\n     register union double_long dl1;\n     register int exp;\n-    register long long l;\n+    register UDItype_x l;\n \n     dl1.d = a1;\n \n@@ -71,24 +98,29 @@ __fixunsdfdi (double a1)\n #define SIGND(fp)\t((fp.l.upper) & SIGNBIT)\n #define MANTD_LL(fp)\t((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)\n #define FRACD_LL(fp)\t(fp.ll & (HIDDEND_LL-1))\n-#define HIDDEND_LL\t((long long)1 << 52)\n+#define HIDDEND_LL\t((UDItype_x)1 << 52)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n \n union double_long {\n     double d;\n     struct {\n-      long upper;\n-      unsigned long lower;\n+      SItype_x upper;\n+      USItype_x lower;\n     } l;\n-    long long ll;\n+    UDItype_x ll;\n };\n \n /* convert double to int */\n-long long\n+DItype_x\n __fixdfdi (double a1)\n {\n     register union double_long dl1;\n     register int exp;\n-    register long long l;\n+    register DItype_x l;\n \n     dl1.d = a1;\n \n@@ -132,3 +164,138 @@ __fixdfdi (double a1)\n #endif\n #undef L_fixdfdi\n \n+#ifdef L_fixunssfdi\n+#define EXP(fp)         (((fp.l) >> 23) & 0xFF)\n+#define EXCESS          126\n+#define SIGNBIT         0x80000000\n+#define SIGN(fp)        ((fp.l) & SIGNBIT)\n+#define HIDDEN          (1 << 23)\n+#define MANT(fp)        (((fp.l) & 0x7FFFFF) | HIDDEN)\n+#define FRAC(fp)        ((fp.l) & 0x7FFFFF)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n+\n+union float_long\n+  {\n+    float f;\n+    USItype_x l;\n+  };\n+\n+/* convert float to unsigned int */\n+UDItype_x\n+__fixunssfdi (float a1)\n+{\n+    register union float_long fl1;\n+    register int exp;\n+    register UDItype_x l;\n+\n+    fl1.f = a1;\n+\n+    /* +/- 0, denormalized, negativ */\n+\n+    if (!EXP (fl1) || SIGN(fl1))\n+      return 0;\n+\n+    exp = EXP (fl1) - EXCESS - 24;\n+\n+    /* number < 1 */\n+\n+    if (exp < -24)\n+      return 0;\n+\n+    /* NaN */\n+\n+    if ((EXP(fl1) == 0xff) && (FRAC(fl1) != 0)) /* NaN */\n+      return 0x0ULL;\n+\n+    /* Number big number & + inf */\n+\n+    if (exp >= 41) {\n+      return 0xFFFFFFFFFFFFFFFFULL;\n+    }\n+\n+    l = MANT(fl1);\n+\n+    if (exp > 0)\n+      l <<= exp;\n+    else \n+      l >>= -exp;\n+\n+    return l;\n+}\n+#define __fixunssfdi ___fixunssfdi\n+#endif\n+#undef L_fixunssfdi\n+\n+#ifdef L_fixsfdi\n+#define EXP(fp)         (((fp.l) >> 23) & 0xFF)\n+#define EXCESS          126\n+#define SIGNBIT         0x80000000\n+#define SIGN(fp)        ((fp.l) & SIGNBIT)\n+#define HIDDEN          (1 << 23)\n+#define MANT(fp)        (((fp.l) & 0x7FFFFF) | HIDDEN)\n+#define FRAC(fp)        ((fp.l) & 0x7FFFFF)\n+\n+typedef int DItype_x __attribute__ ((mode (DI)));\n+typedef unsigned int UDItype_x __attribute__ ((mode (DI)));\n+typedef int SItype_x __attribute__ ((mode (SI)));\n+typedef unsigned int USItype_x __attribute__ ((mode (SI)));\n+\n+union float_long\n+  {\n+    float f;\n+    USItype_x l;\n+  };\n+\n+/* convert double to int */\n+DItype_x\n+__fixsfdi (float a1)\n+{\n+    register union float_long fl1;\n+    register int exp;\n+    register DItype_x l;\n+\n+    fl1.f = a1;\n+\n+    /* +/- 0, denormalized */\n+\n+    if (!EXP (fl1))\n+      return 0;\n+\n+    exp = EXP (fl1) - EXCESS - 24;\n+\n+    /* number < 1 */\n+\n+    if (exp < -24)\n+      return 0;\n+\n+    /* NaN */\n+\n+    if ((EXP(fl1) == 0xff) && (FRAC(fl1) != 0)) /* NaN */\n+      return 0x8000000000000000ULL;\n+\n+    /* Number big number & +/- inf */\n+\n+    if (exp >= 40) {\n+\tl = (long long)1<<63;\n+\tif (!SIGN(fl1))\n+\t    l--;\n+\treturn l;\n+    }\n+\n+    l = MANT(fl1);\n+\n+    if (exp > 0)\n+      l <<= exp;\n+    else \n+      l >>= -exp;\n+\n+    return (SIGN (fl1) ? -l : l);\n+}\n+#define __fixsfdi ___fixsfdi\n+#endif\n+#undef L_fixsfdi\n+"}, {"sha": "0e5d17976b8fb2bf53e55585b7c2c91db1ee1bee", "filename": "gcc/config/s390/linux.h", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux.h?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,7 +1,7 @@\n /* Definitions for Linux for S/390.\n    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (weigand@de.ibm.com).\n+                  Ulrich Weigand (uweigand@de.ibm.com).\n \n This file is part of GNU CC.\n \n@@ -138,10 +138,14 @@ Boston, MA 02111-1307, USA.  */\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n \n-#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)      \\\n-do { fprintf (FILE, \"%s\\t\", ASM_QUAD);          \\\n-  output_addr_const (FILE,(VALUE));             \\\n-  putc ('\\n',FILE);                             \\\n+#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)      \t\t\t\\\n+do { fprintf ((FILE), \"%s\\t\", ASM_QUAD);          \t\t\t\\\n+  /* Work around bug in some GNU as versions */\t\t\t\t\\\n+  if (GET_CODE (VALUE) == CONST_INT && INTVAL (VALUE) < INT_MIN)\t\\\n+    fprintf ((FILE), HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    output_addr_const ((FILE), (VALUE));            \t\t\t\\\n+  putc ('\\n', (FILE));                             \t\t\t\\\n  } while (0)\n \n \n@@ -180,22 +184,14 @@ do { fprintf (FILE, \"%s\\t\", ASM_LONG);          \\\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\\\n-  fprintf (FILE, \"%s %s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+  fprintf (FILE, \"%s\\t%s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n \t   LPREFIX, VALUE)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  fprintf (FILE, \"%s %s%d-.LT%X_%X\\n\" ,TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n-\t   LPREFIX, VALUE, s390_function_count,s390_pool_count)\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#undef ASM_OPEN_PAREN\n-#undef ASM_CLOSE_PAREN\n-#define ASM_OPEN_PAREN \"\"\n-#define ASM_CLOSE_PAREN \"\"\n+  fprintf (FILE, \"%s\\t%s%d-%s%d\\n\", TARGET_64BIT?ASM_QUAD:ASM_LONG, \t\\\n+\t   LPREFIX, VALUE, LPREFIX, REL)\n \n \n \n@@ -293,24 +289,6 @@ do {                                                                    \\\n \n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n-/*\n- * This macro generates the assembly code for function entry.\n- */\n-\n-#define FUNCTION_PROLOGUE(FILE, LSIZE) s390_function_prologue (FILE, LSIZE)\n-\n-/* This macro generates the assembly code for function exit, on machines\n-   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n-   return instructions are generated for each return statement.  Args are\n-   same as for FUNCTION_PROLOGUE.\n-  \n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, LSIZE) s390_function_epilogue(FILE, LSIZE)\n-\n /* Select section for constant in constant pool. \n    We are in the right section. \n    undef for 64 bit mode (linux64.h)."}, {"sha": "36fa1c786a06f20d8b9662a8ae7c99f4be9d2f7f", "filename": "gcc/config/s390/linux64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Flinux64.h?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,7 +1,7 @@\n /* Definitions for Linux for s/390 zSeries\n    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (weigand@de.ibm.com).\n+                  Ulrich Weigand (uweigand@de.ibm.com).\n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -77,6 +77,6 @@ Boston, MA 02111-1307, USA.  */\n   1, 1, 1, 1, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n   0, 0, 0, 0, \t\t\t\t\t\\\n-  1 }\n+  1, 1 }\n \n #endif"}, {"sha": "33307a877002efe45965c852cb67279c95aaafd3", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,7 +1,7 @@\n /* Subroutines used for code generation on IBM S/390 and zSeries\n    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (weigand@de.ibm.com).\n+                  Ulrich Weigand (uweigand@de.ibm.com).\n \n This file is part of GNU CC.\n \n@@ -53,6 +53,12 @@ Boston, MA 02111-1307, USA.  */\n #undef  TARGET_ASM_FUNCTION_EPILOGUE \n #define TARGET_ASM_FUNCTION_EPILOGUE s390_function_epilogue\n \n+#undef  TARGET_ASM_OPEN_PAREN\n+#define TARGET_ASM_OPEN_PAREN \"\"\n+\n+#undef  TARGET_ASM_CLOSE_PAREN\n+#define TARGET_ASM_CLOSE_PAREN \"\"\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n extern int reload_completed;\n@@ -173,7 +179,7 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n   FP_REGS,      FP_REGS,   FP_REGS,   FP_REGS,\n-  ADDR_REGS,    CC_REGS \n+  ADDR_REGS,    NO_REGS \n };\n \n \n@@ -959,11 +965,6 @@ legitimize_pic_address (orig, reg)\n                   case 112:\n                   case 114:\n                     new = force_const_mem (SImode, orig);\n-                    if (reg != 0)\n-                      {\n-                        emit_move_insn (reg, new);\n-                        new = reg;\n-                      }\n                     break;\n \n                   /* @GOTENT is OK as is.  */\n@@ -1080,11 +1081,6 @@ legitimize_pic_address (orig, reg)\n                 abort();\n \n               new = force_const_mem (SImode, orig);\n-              if (reg != 0)\n-                {\n-                  emit_move_insn (reg, new);\n-                  new = reg;\n-                }\n             }\n \n           /* Otherwise, compute the sum.  */\n@@ -1700,7 +1696,7 @@ check_and_change_labels (rtx insn, int *ltorg_uids)\n \t\t}\n \t      \n \t      emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t      tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t      tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n \t      remove_insn (insn);\n \t      INSN_ADDRESSES_NEW (tmp, -1);\n \t      return tmp;\n@@ -1736,7 +1732,7 @@ check_and_change_labels (rtx insn, int *ltorg_uids)\n \t\t  label1 = gen_label_rtx ();\n \t\t  emit_jump_insn_before (gen_icjump (label1, XEXP (body, 0)), insn);\n \t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t\t  tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n \t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n \t\t  remove_insn (insn);\n \t\t  return tmp;\n@@ -1770,7 +1766,7 @@ check_and_change_labels (rtx insn, int *ltorg_uids)\n \t\t  label1 = gen_label_rtx ();\n \t\t  emit_jump_insn_before (gen_cjump (label1, XEXP (body, 0)), insn);\n \t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t\t  tmp = emit_jump_insn_before (gen_jump_long (jump), insn);\n+\t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n \t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n \t\t  remove_insn (insn);\n \t\t  return tmp;\n@@ -1862,7 +1858,7 @@ s390_final_chunkify (int chunkify)\n \t      warning (\"no code label found\");\n \t    }\n \t} \n-      else if (GET_CODE (PATTERN (insn)) == ASM_INPUT) \n+      else if (GET_CODE (PATTERN (insn)) == ASM_INPUT && !TARGET_64BIT) \n \t{\n \t  asms = XSTR (PATTERN (insn),0);\n \t  \n@@ -2732,7 +2728,7 @@ s390_va_start (int stdarg_p, tree valist, rtx nextarg)\n   off = INTVAL (current_function_arg_offset_rtx);\n   off = off < 0 ? 0 : off;\n   if (! stdarg_p)\n-    off = off > 0 ? off - 4 : off;\n+    off = off > 0 ? off - UNITS_PER_WORD : off;\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\",\n \t     n_gpr, n_fpr, off);\n@@ -2809,7 +2805,7 @@ s390_va_arg (tree valist, tree type)\n       indirect_p = 1;\n       reg = gpr;\n       n_reg = 1;\n-      sav_ofs = 8;\n+      sav_ofs = 2 * UNITS_PER_WORD;\n       sav_scale = UNITS_PER_WORD;\n       size = UNITS_PER_WORD;\n       max_reg = 4;\n@@ -2826,7 +2822,7 @@ s390_va_arg (tree valist, tree type)\n       indirect_p = 0;\n       reg = fpr;\n       n_reg = 1;\n-      sav_ofs = 16 * UNITS_PER_WORD;;\n+      sav_ofs = 16 * UNITS_PER_WORD;\n       sav_scale = 8;\n       /* TARGET_64BIT has up to 4 parameter in fprs */\n       max_reg = TARGET_64BIT ? 3 : 1;"}, {"sha": "fb98ba858aabaaac95a8dd46013a76d904a126fa", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler, for IBM S/390\n    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (weigand@de.ibm.com).\n+                  Ulrich Weigand (uweigand@de.ibm.com).\n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify\n@@ -54,8 +54,8 @@ extern int target_flags;\n   { \"no-backchain\", -2,N_(\"Don't set backchain (faster, but debug harder\")}, \\\n   { \"small-exec\",    4,N_(\"Use bras for execucable < 64k\")},           \\\n   { \"no-small-exec\",-4,N_(\"Don't use bras\")},            \t       \\\n-  { \"debug_arg\",     8,N_(\"Additional debug prints\")},        \t       \\\n-  { \"no-debug_arg\", -8,N_(\"Don't print additional debug prints\")},     \\\n+  { \"debug\",         8,N_(\"Additional debug prints\")},        \t       \\\n+  { \"no-debug\",     -8,N_(\"Don't print additional debug prints\")},     \\\n   { \"64\",           16,N_(\"64 bit mode\")},         \t               \\\n   { \"31\",          -16,N_(\"31 bit mode\")},                             \\\n   { \"mvcle\",        32,N_(\"mvcle use\")},         \t               \\\n@@ -95,7 +95,7 @@ extern int current_function_outgoing_args_size;\n /* Width in bits of a \"word\", which is the contents of a machine register.  */\n \n #define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n-#define MAX_BITS_PER_WORD 32\n+#define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n \n@@ -121,7 +121,7 @@ extern int current_function_outgoing_args_size;\n    target machine.  If you don't define this, the default is one\n    word.  */\n #define LONG_TYPE_SIZE (TARGET_64BIT ? 64 : 32)\n-#define MAX_LONG_TYPE_SIZE 32\n+#define MAX_LONG_TYPE_SIZE 64\n \n /* A C expression for the size in bits of the type `long long' on the\n    target machine.  If you don't define this, the default is two\n@@ -330,8 +330,7 @@ do\t\t\t\t\t\t\t\t\\\n    (GET_MODE_CLASS(MODE) == MODE_FLOAT ||                           \\\n     GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT) :                   \\\n    INT_REGNO_P(REGNO)?                                              \\\n-    (!((TARGET_64BIT && (MODE) == TImode) ||                        \\\n-     (!TARGET_64BIT && (MODE) == DImode)) || ((REGNO) & 1) == 0 ) : \\\n+    (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1)) :        \\\n    CC_REGNO_P(REGNO)?                                               \\\n      GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n    0)\n@@ -427,15 +426,15 @@ while (0)\n enum reg_class\n {\n   NO_REGS, ADDR_REGS, GENERAL_REGS,\n-  FP_REGS, CC_REGS, ALL_REGS, LIM_REG_CLASSES\n+  FP_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES                                                 \\\n-{ \"NO_REGS\",\"ADDR_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"CC_REGS\", \"ALL_REGS\" }\n+{ \"NO_REGS\",\"ADDR_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.  This is an initializer for\n    a vector of HARD_REG_SET of length N_REG_CLASSES.\n@@ -447,7 +446,6 @@ enum reg_class\n   { 0x0000fffe, 0x00000001 },\t/* ADDR_REGS */\t\t\\\n   { 0x0000ffff, 0x00000001 },\t/* GENERAL_REGS */\t\\\n   { 0xffff0000, 0x00000000 },\t/* FP_REGS */\t\t\\\n-  { 0x00000000, 0x00000002 },\t/* CC_REGS */\t\t\\\n   { 0xffffffff, 0x00000003 },\t/* ALL_REGS */\t\t\\\n }\n \n@@ -591,7 +589,8 @@ extern enum reg_class regclass_map[];\t/* smalled class containing REGNO   */\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 6 : INVALID_REGNUM)\n #define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, 10)\n #define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -40))\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, \\\n+                                     TARGET_64BIT? -48 : -40))\n \n /* Define this if pushing a word on the stack makes the stack pointer a\n    smaller address.  */\n@@ -767,10 +766,10 @@ CUMULATIVE_ARGS;\n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.  */\n \n-#define RETURN_IN_MEMORY(type)       \t\t\\\n-  (TYPE_MODE (type) == BLKmode || \t\t\\\n-   TYPE_MODE (type) == DCmode  || \t\t\\\n-   TYPE_MODE (type) == SCmode)\n+#define RETURN_IN_MEMORY(type)       \t\t\t\t\\\n+  (TYPE_MODE (type) == BLKmode || \t\t\t\t\\\n+   GET_MODE_CLASS (TYPE_MODE (type)) == MODE_COMPLEX_INT  ||\t\\\n+   GET_MODE_CLASS (TYPE_MODE (type)) == MODE_COMPLEX_FLOAT)\n \n /* Mode of stack savearea.\n    FUNCTION is VOIDmode because calling convention maintains SP.\n@@ -1569,11 +1568,11 @@ do {                                                                       \\\n        if ((OUTER_CODE == PLUS) &&                              \\\n \t   ((INTVAL (RTX) > 32767) ||                           \\\n \t   (INTVAL (RTX) < -32768))) \t                        \\\n-         return 3;                                              \\\n+         return COSTS_N_INSNS (3);                              \\\n   case LABEL_REF:                                               \\\n   case SYMBOL_REF:                                              \\\n   case CONST_DOUBLE:                                            \\\n-    return 1;                                                   \\\n+    return 0;                                                   \\\n \n \n /* Like `CONST_COSTS' but applies to nonconstant RTL expressions."}, {"sha": "31a5097c069433dded6a124e10bd22c41172ae22", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 118, "deletions": 80, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f314b9b1682cb72cde6561b8e05eba08d94e1edd/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=f314b9b1682cb72cde6561b8e05eba08d94e1edd", "patch": "@@ -1,7 +1,7 @@\n ;;- Machine description for GNU compiler -- S/390 / zSeries version.\n ;;  Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n ;;  Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-;;                 Ulrich Weigand (weigand@de.ibm.com).\n+;;                 Ulrich Weigand (uweigand@de.ibm.com).\n ;; This file is part of GNU CC.\n \n ;; GNU CC is free software; you can redistribute it and/or modify\n@@ -2397,7 +2397,7 @@\n   emit_insn (gen_subdf3 (temp, operands[1], force_const_mem (DFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x10000000000000000ULL, DFmode))));\n   emit_insn (gen_fix_truncdfdi2_ieee (operands[0], temp, GEN_INT(7)));\n-  emit_jump_insn (gen_jump (label2));\n+  emit_jump (label2);\n \n   emit_label (label1);\n   emit_insn (gen_fix_truncdfdi2_ieee (operands[0], operands[1], GEN_INT(5)));\n@@ -2447,7 +2447,7 @@\n   emit_insn (gen_subdf3 (temp, operands[1], force_const_mem (DFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x100000000ULL, DFmode))));\n   emit_insn (gen_fix_truncdfsi2_ieee (operands[0], temp, GEN_INT (7)));\n-  emit_jump_insn (gen_jump (label2));\n+  emit_jump (label2);\n \n   emit_label (label1);\n   emit_insn (gen_fix_truncdfsi2_ieee (operands[0], operands[1], GEN_INT (5)));\n@@ -2538,7 +2538,7 @@\n   emit_insn (gen_subsf3 (temp, operands[1], force_const_mem (SFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x10000000000000000ULL, SFmode))));\n   emit_insn (gen_fix_truncsfdi2_ieee (operands[0], temp, GEN_INT(7)));\n-  emit_jump_insn (gen_jump (label2));\n+  emit_jump (label2);\n \n   emit_label (label1);\n   emit_insn (gen_fix_truncsfdi2_ieee (operands[0], operands[1], GEN_INT(5)));\n@@ -2588,7 +2588,7 @@\n   emit_insn (gen_subsf3 (temp, operands[1], force_const_mem (SFmode,\n \tCONST_DOUBLE_FROM_REAL_VALUE (0x100000000ULL, SFmode))));\n   emit_insn (gen_fix_truncsfsi2_ieee (operands[0], temp, GEN_INT (7)));\n-  emit_jump_insn (gen_jump (label2));\n+  emit_jump (label2);\n \n   emit_label (label1);\n   emit_insn (gen_fix_truncsfsi2_ieee (operands[0], operands[1], GEN_INT (5)));\n@@ -3754,7 +3754,7 @@\n   else\n     operands[2] = force_reg (SImode, operands[2]);\n \n-  emit_insn (gen_rtx_CLOBBER (DImode, tmp));\n+  emit_insn (gen_rtx_CLOBBER (SImode, gen_rtx_SUBREG (SImode, tmp, 4)));\n   emit_move_insn (gen_rtx_SUBREG (SImode, tmp, 0), operands[1]);\n   emit_insn (gen_ashrdi3 (tmp, tmp, GEN_INT (32))); \n   emit_insn (gen_divmoddisi3 (tmp, tmp, operands[2]));\n@@ -3776,7 +3776,7 @@\n   else\n     operands[2] = force_reg (SImode, operands[2]);\n \n-  emit_insn (gen_rtx_CLOBBER (DImode, tmp));\n+  emit_insn (gen_rtx_CLOBBER (SImode, gen_rtx_SUBREG (SImode, tmp, 4)));\n   emit_insn (gen_movsi (gen_rtx_SUBREG (SImode, tmp, 0), operands[1]));\n   emit_insn (gen_ashrdi3 (tmp, tmp, GEN_INT (32))); \n   emit_insn (gen_divmoddisi3 (tmp, tmp, operands[2]));\n@@ -3858,10 +3858,10 @@\n       emit_move_insn (gen_rtx_SUBREG (SImode, tmp, 0), const0_rtx);\n       emit_move_insn (gen_rtx_SUBREG (SImode, tmp, 4), operands[1]);\n       emit_insn (gen_divmoddisi3 (tmp, tmp, operands[2]));\n-      emit_jump_insn (gen_jump (label3));\n+      emit_jump (label3);\n       emit_label (label1);\n       emit_move_insn (dr_1, operands[1]);\n-      emit_jump_insn (gen_jump (label3));\n+      emit_jump (label3);\n       emit_label (label2);\n       emit_move_insn (dr_1, const1_rtx);\n       emit_label (label3);\n@@ -3924,10 +3924,10 @@\n       emit_move_insn (gen_rtx_SUBREG (SImode, tmp, 0), const0_rtx);\n       emit_move_insn (gen_rtx_SUBREG (SImode, tmp, 4), operands[1]);\n       emit_insn (gen_divmoddisi3 (tmp, tmp, operands[2]));\n-      emit_jump_insn (gen_jump (label3));\n+      emit_jump (label3);\n       emit_label (label1);\n       emit_move_insn (dr_0, const0_rtx);\n-      emit_jump_insn (gen_jump (label3));\n+      emit_jump (label3);\n       emit_label (label2);\n       emit_insn (gen_subsi3 (dr_0, dr_0, operands[2]));\n       emit_label (label3);\n@@ -5043,15 +5043,24 @@\n       (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n       (const_int 4) (const_int 6)))])\n \n-(define_insn \"cjump_long\"\n+(define_insn \"*cjump_long\"\n  [(set (pc)\n        (if_then_else\n          (match_operator 1 \"comparison_operator\" [(reg 33) (const_int 0)])\n-\t (match_operand 0 \"memory_operand\" \"m\")\n+\t (match_operand 0 \"address_operand\" \"p\")\n \t (pc)))]\n   \"\"\n-  \"b%C1\\\\t%0\"\n-  [(set_attr \"op_type\" \"RX\")])\n+  \"*\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \\\"b%C1r\\\\t%0\\\";\n+  else\n+    return \\\"b%C1\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"atype\" \"mem\")])\n \n \n ;;\n@@ -5077,15 +5086,24 @@\n      (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n      (const_int 4) (const_int 6)))])\n \n-(define_insn \"icjump_long\"\n+(define_insn \"*icjump_long\"\n  [(set (pc)\n        (if_then_else\n          (match_operator 1 \"comparison_operator\" [(reg 33) (const_int 0)])\n-\t (pc)\n-\t (match_operand 0 \"memory_operand\" \"m\")))]\n+         (pc)\n+\t (match_operand 0 \"address_operand\" \"p\")))]\n   \"\"\n-  \"b%D1\\\\t%0\"\n-  [(set_attr \"op_type\" \"RX\")])\n+  \"*\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \\\"b%D1r\\\\t%0\\\";\n+  else\n+    return \\\"b%D1\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"atype\" \"mem\")])\n \n \n ;;\n@@ -5164,53 +5182,79 @@\n ;\n \n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"a\"))]\n+ [(set (pc) (match_operand 0 \"address_operand\" \"p\"))]\n   \"\"\n-  \"br\\\\t%0\"\n-  [(set_attr \"op_type\" \"RX\")])\n-\n-(define_insn \"jump_long\"\n-  [(set (pc) (match_operand 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"b\\\\t%a0\"\n-  [(set_attr \"op_type\" \"RX\")\n-   (set_attr \"atype\"   \"mem\")])\n-\n+  \"*\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \\\"br\\\\t%0\\\";\n+  else\n+    return \\\"b\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"atype\" \"mem\")])\n \n ;\n-; tablejump instruction pattern(s).\n+; casesi instruction pattern(s).\n ;\n \n-(define_expand \"tablejump\"\n-  [(parallel\n-    [(set (pc) (match_operand 0 \"register_operand\" \"a\"))\n-     (use (label_ref (match_operand 1 \"\" \"\")))])]\n+(define_insn \"casesi_jump\"\n+ [(set (pc) (match_operand 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"\n+  \"*\n {\n-  if (flag_pic)\n-    {\n-      rtx base;\n-      base = gen_rtx_REG (Pmode, BASE_REGISTER);\n-      base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base), 101);\n-      operands[0] = gen_rtx_PLUS (Pmode, base, operands[0]);\n-    }\n-}\")\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \\\"br\\\\t%0\\\";\n+  else\n+    return \\\"b\\\\t%a0\\\";\n+}\"\n+  [(set (attr \"op_type\") \n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"atype\" \"mem\")])\n \n-(define_insn \"*tablejump1\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"a\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (label_ref (match_operand 3 \"\" \"\"))\n+   (label_ref (match_operand 4 \"\" \"\"))]\n   \"\"\n-  \"br\\\\t%0\"\n-  [(set_attr \"op_type\" \"RX\")])\n+  \"\n+{\n+   rtx index  = gen_reg_rtx (SImode);\n+   rtx base   = gen_reg_rtx (Pmode);\n+   rtx target = gen_reg_rtx (Pmode);\n+\n+   emit_move_insn (index, operands[0]);\n+   emit_insn (gen_subsi3 (index, index, operands[1]));\n+   emit_cmp_and_jump_insns (index, operands[2], GTU, NULL_RTX, SImode, 1,\n+                            0, operands[4]);\n+\n+   if (Pmode != SImode)\n+     index = convert_to_mode (Pmode, index, 1);\n+   if (GET_CODE (index) != REG)\n+     index = copy_to_mode_reg (Pmode, index);\n+\n+   if (TARGET_64BIT)\n+       emit_insn (gen_ashldi3 (index, index, GEN_INT (3)));\n+   else\n+       emit_insn (gen_ashlsi3 (index, index, GEN_INT (2)));\n \n-(define_insn \"*tablejump2\"\n-  [(set (pc) (match_operand 0 \"address_operand\" \"p\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"b\\\\t%a0\"\n-  [(set_attr \"op_type\" \"RX\")\n-   (set_attr \"atype\"   \"mem\")])\n+   emit_move_insn (base, gen_rtx_LABEL_REF (Pmode, operands[3]));\n+\n+   index = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, base, index));\n+   emit_move_insn (target, index);\n+\n+   if (flag_pic)\n+     target = gen_rtx_PLUS (Pmode, base, target);\n+   emit_jump_insn (gen_casesi_jump (target, operands[3]));\n+\n+   DONE;\n+}\")\n \n \n ;;\n@@ -5518,54 +5562,48 @@\n   \"\"\n   \"\n {\n-  emit_insn (gen_do_builtin_setjmp_setup (operands[0]));\n+  rtx base = gen_rtx_MEM (Pmode, plus_constant (operands[0], 4 * GET_MODE_SIZE (Pmode)));\n+  rtx basereg = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\n+  emit_move_insn (base, basereg);\n   DONE;\n }\")\n \n (define_expand \"builtin_setjmp_receiver\"\n   [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))] 2)]\n-  \"\"\n+  \"flag_pic\"\n   \"\n {\n-  emit_insn (gen_blockage ());\n+  rtx gotreg = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n+  rtx got = gen_rtx_SYMBOL_REF (Pmode, \\\"_GLOBAL_OFFSET_TABLE_\\\");\n+  SYMBOL_REF_FLAG (got) = 1;\n+\n+  emit_move_insn (gotreg, got);\n+  emit_insn (gen_rtx_USE (VOIDmode, gotreg));\n   DONE;\n }\")\n \n-(define_expand \"do_builtin_setjmp_setup\"\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"a\")\n-\t\t   (const_int 12)))\n-      (reg:SI 12))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t   (const_int 16)))\n-      (reg:SI 13)) ]\n-  \"\"\n-  \"\")\n-\n (define_expand \"builtin_longjmp\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n   \"\"\n   \"\n {\n   /* The elements of the buffer are, in order:  */\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n-  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 4));\n-  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 8));\n-  rtx gotv = gen_rtx_MEM (Pmode, plus_constant (operands[0], 12));\n-  rtx basev = gen_rtx_MEM (Pmode, plus_constant (operands[0], 16));\n-  rtx base = gen_rtx_REG (Pmode, 13);\n-  rtx got = gen_rtx_REG (Pmode, 12);\n+  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], GET_MODE_SIZE (Pmode)));\n+  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2 * GET_MODE_SIZE (Pmode)));\n+  rtx base = gen_rtx_MEM (Pmode, plus_constant (operands[0], 4 * GET_MODE_SIZE (Pmode)));\n+  rtx basereg = gen_rtx_REG (Pmode, BASE_REGISTER);\n   rtx jmp = gen_rtx_REG (Pmode, 14);\n \n   emit_move_insn (jmp, lab);\n-  emit_move_insn (got, gotv);\n-  emit_move_insn (base, basev);\n+  emit_move_insn (basereg, base);\n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n   emit_move_insn (hard_frame_pointer_rtx, fp);\n \n   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n   emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n-  emit_insn (gen_rtx_USE (VOIDmode, got));\n-  emit_insn (gen_rtx_USE (VOIDmode, base));\n+  emit_insn (gen_rtx_USE (VOIDmode, basereg));\n   emit_indirect_jump (jmp);\n   DONE;\n }\")"}]}