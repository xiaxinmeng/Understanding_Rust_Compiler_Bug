{"sha": "c735f8f1a0c5a5d1e114e45390b35882f539ff69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczNWY4ZjFhMGM1YTVkMWUxMTRlNDUzOTBiMzU4ODJmNTM5ZmY2OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-08-15T12:38:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-08-15T12:38:50Z"}, "message": "Implement P0848R3, Conditionally Trivial Special Member Functions.\n\nWith Concepts, overloads of special member functions can differ in\nconstraints, and this paper clarifies how that affects class properties: if\na class has a more constrained trivial copy constructor and a less\nconstrained non-trivial copy constructor, it is still trivially copyable.\n\n\t* tree.c (special_memfn_p): New.\n\t* class.c (add_method): When overloading, hide ineligible special\n\tmember fns.\n\t(check_methods): Set TYPE_HAS_COMPLEX_* here.\n\t* decl.c (grok_special_member_properties): Not here.\n\t* name-lookup.c (push_class_level_binding_1): Move overloaded\n\tfunctions case down, accept FUNCTION_DECL as target_decl.\n\nFrom-SVN: r274534", "tree": {"sha": "1ea2d4c11b3a6cdb3a137df04d979591a4e9277a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ea2d4c11b3a6cdb3a137df04d979591a4e9277a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c735f8f1a0c5a5d1e114e45390b35882f539ff69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c735f8f1a0c5a5d1e114e45390b35882f539ff69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c735f8f1a0c5a5d1e114e45390b35882f539ff69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c735f8f1a0c5a5d1e114e45390b35882f539ff69/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "84cc60bf83e03267f5794a16b3eb83508a3196ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84cc60bf83e03267f5794a16b3eb83508a3196ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84cc60bf83e03267f5794a16b3eb83508a3196ce"}], "stats": {"total": 253, "additions": 233, "deletions": 20}, "files": [{"sha": "25172ace36fcfaca64faac789c1c5bba66b39de4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -1,3 +1,14 @@\n+2019-08-14  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0848R3, Conditionally Trivial Special Member Functions.\n+\t* tree.c (special_memfn_p): New.\n+\t* class.c (add_method): When overloading, hide ineligible special\n+\tmember fns.\n+\t(check_methods): Set TYPE_HAS_COMPLEX_* here.\n+\t* decl.c (grok_special_member_properties): Not here.\n+\t* name-lookup.c (push_class_level_binding_1): Move overloaded\n+\tfunctions case down, accept FUNCTION_DECL as target_decl.\n+\n 2019-08-14  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR c++/91436"}, {"sha": "cc53b15401a309e1b4b6028b3b576660c2d5479b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -994,6 +994,9 @@ add_method (tree type, tree method, bool via_using)\n   tree *slot = find_member_slot (type, DECL_NAME (method));\n   tree current_fns = slot ? *slot : NULL_TREE;\n \n+  /* See below.  */\n+  int losem = -1;\n+\n   /* Check to see if we've already got this method.  */\n   for (ovl_iterator iter (current_fns); iter; ++iter)\n     {\n@@ -1070,9 +1073,48 @@ add_method (tree type, tree method, bool via_using)\n       if (compparms (parms1, parms2)\n \t  && (!DECL_CONV_FN_P (fn)\n \t      || same_type_p (TREE_TYPE (fn_type),\n-\t\t\t      TREE_TYPE (method_type)))\n-          && equivalently_constrained (fn, method))\n+\t\t\t      TREE_TYPE (method_type))))\n \t{\n+          if (!equivalently_constrained (fn, method))\n+\t    {\n+\t      special_function_kind sfk = special_memfn_p (method);\n+\n+\t      if (sfk == sfk_none)\n+\t\t/* Non-special member functions coexist if they are not\n+\t\t   equivalently constrained.  */\n+\t\tcontinue;\n+\n+\t      /* P0848: For special member functions, deleted, unsatisfied, or\n+\t\t less constrained overloads are ineligible.  We implement this\n+\t\t by removing them from CLASSTYPE_MEMBER_VEC.  Destructors don't\n+\t\t use the notion of eligibility, and the selected destructor can\n+\t\t be deleted, but removing unsatisfied or less constrained\n+\t\t overloads has the same effect as overload resolution.  */\n+\t      bool dtor = (sfk == sfk_destructor);\n+\t      if (losem == -1)\n+\t\tlosem = ((!dtor && DECL_DELETED_FN (method))\n+\t\t\t || !constraints_satisfied_p (method));\n+\t      bool losef = ((!dtor && DECL_DELETED_FN (fn))\n+\t\t\t    || !constraints_satisfied_p (fn));\n+\t      int win;\n+\t      if (losem || losef)\n+\t\twin = losem - losef;\n+\t      else\n+\t\twin = more_constrained (fn, method);\n+\t      if (win > 0)\n+\t\t/* Leave FN in the method vec, discard METHOD.  */\n+\t\treturn false;\n+\t      else if (win < 0)\n+\t\t{\n+\t\t  /* Remove FN, add METHOD.  */\n+\t\t  current_fns = iter.remove_node (current_fns);\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t/* Let them coexist for now.  */\n+\t\tcontinue;\n+\t    }\n+\n \t  /* If these are versions of the same function, process and\n \t     move on.  */\n \t  if (TREE_CODE (fn) == FUNCTION_DECL\n@@ -4468,18 +4510,58 @@ check_methods (tree t)\n \t      vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n \t  }\n \n-\t/* All user-provided destructors are non-trivial.\n-\t   Constructors and assignment ops are handled in\n-\t   grok_special_member_properties.  */\n-\tif (DECL_DESTRUCTOR_P (x) && user_provided_p (x))\n-\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n \tif (!DECL_VIRTUAL_P (x)\n \t    && lookup_attribute (\"transaction_safe_dynamic\",\n \t\t\t\t DECL_ATTRIBUTES (x)))\n \t  error_at (DECL_SOURCE_LOCATION (x),\n \t\t    \"%<transaction_safe_dynamic%> may only be specified for \"\n \t\t    \"a virtual function\");\n       }\n+\n+  /* Check whether the eligible special member functions (P0848) are\n+     user-provided.  add_method arranged that the CLASSTYPE_MEMBER_VEC only\n+     has the eligible ones; TYPE_FIELDS also contains ineligible overloads,\n+     which is why this needs to be separate from the loop above.  */\n+\n+  if (tree dtor = CLASSTYPE_DESTRUCTOR (t))\n+    {\n+      if (TREE_CODE (dtor) == OVERLOAD)\n+\t{\n+\t  /* P0848: At the end of the definition of a class, overload\n+\t     resolution is performed among the prospective destructors declared\n+\t     in that class with an empty argument list to select the destructor\n+\t     for the class, also known as the selected destructor. The program\n+\t     is ill-formed if overload resolution fails. */\n+\t  auto_diagnostic_group d;\n+\t  error_at (location_of (t), \"destructor for %qT is ambiguous\", t);\n+\t  print_candidates (dtor);\n+\t}\n+      else if (user_provided_p (dtor))\n+\tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = true;\n+    }\n+\n+  for (ovl_iterator i (CLASSTYPE_CONSTRUCTORS (t)); i; ++i)\n+    {\n+      tree fn = *i;\n+      if (!user_provided_p (fn))\n+\t/* Might be trivial.  */;\n+      else if (copy_fn_p (fn))\n+\tTYPE_HAS_COMPLEX_COPY_CTOR (t) = true;\n+      else if (move_fn_p (fn))\n+\tTYPE_HAS_COMPLEX_MOVE_CTOR (t) = true;\n+    }\n+\n+  for (ovl_iterator i (get_class_binding_direct (t, assign_op_identifier));\n+       i; ++i)\n+    {\n+      tree fn = *i;\n+      if (!user_provided_p (fn))\n+\t/* Might be trivial.  */;\n+      else if (copy_fn_p (fn))\n+\tTYPE_HAS_COMPLEX_COPY_ASSIGN (t) = true;\n+      else if (move_fn_p (fn))\n+\tTYPE_HAS_COMPLEX_MOVE_ASSIGN (t) = true;\n+    }\n }\n \n /* FN is a constructor or destructor.  Clone the declaration to create\n@@ -4950,7 +5032,7 @@ set_method_tm_attributes (tree t)\n /* Returns true if FN is a default constructor.  */\n \n bool\n-default_ctor_p (tree fn)\n+default_ctor_p (const_tree fn)\n {\n   return (DECL_CONSTRUCTOR_P (fn)\n \t  && sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (fn)));"}, {"sha": "05f91861b42417c0ffe31396214b6320da5ebd10", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -6313,7 +6313,7 @@ extern void determine_key_method\t\t(tree);\n extern void check_for_override\t\t\t(tree, tree);\n extern void push_class_stack\t\t\t(void);\n extern void pop_class_stack\t\t\t(void);\n-extern bool default_ctor_p\t\t\t(tree);\n+extern bool default_ctor_p\t\t\t(const_tree);\n extern bool type_has_user_nondefault_constructor (tree);\n extern tree in_class_defaulted_default_constructor (tree);\n extern bool user_provided_p\t\t\t(tree);\n@@ -7322,6 +7322,7 @@ extern tree cp_build_qualified_type_real\t(tree, int, tsubst_flags_t);\n extern bool cv_qualified_p\t\t\t(const_tree);\n extern tree cv_unqualified\t\t\t(tree);\n extern special_function_kind special_function_p (const_tree);\n+extern special_function_kind special_memfn_p\t(const_tree);\n extern int count_trees\t\t\t\t(tree);\n extern int char_type_p\t\t\t\t(tree);\n extern void verify_stmt_tree\t\t\t(tree);"}, {"sha": "08b7baa40e004b78aa6b46240c59403367acb0fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -13534,15 +13534,11 @@ grok_special_member_properties (tree decl)\n \t     are no other parameters or else all other parameters have\n \t     default arguments.  */\n \t  TYPE_HAS_COPY_CTOR (class_type) = 1;\n-\t  if (user_provided_p (decl))\n-\t    TYPE_HAS_COMPLEX_COPY_CTOR (class_type) = 1;\n \t  if (ctor > 1)\n \t    TYPE_HAS_CONST_COPY_CTOR (class_type) = 1;\n \t}\n       else if (sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (decl)))\n \tTYPE_HAS_DEFAULT_CONSTRUCTOR (class_type) = 1;\n-      else if (move_fn_p (decl) && user_provided_p (decl))\n-\tTYPE_HAS_COMPLEX_MOVE_CTOR (class_type) = 1;\n       else if (is_list_ctor (decl))\n \tTYPE_HAS_LIST_CTOR (class_type) = 1;\n \n@@ -13563,13 +13559,9 @@ grok_special_member_properties (tree decl)\n       if (assop)\n \t{\n \t  TYPE_HAS_COPY_ASSIGN (class_type) = 1;\n-\t  if (user_provided_p (decl))\n-\t    TYPE_HAS_COMPLEX_COPY_ASSIGN (class_type) = 1;\n \t  if (assop != 1)\n \t    TYPE_HAS_CONST_COPY_ASSIGN (class_type) = 1;\n \t}\n-      else if (move_fn_p (decl) && user_provided_p (decl))\n-\tTYPE_HAS_COMPLEX_MOVE_ASSIGN (class_type) = 1;\n     }\n   else if (IDENTIFIER_CONV_OP_P (DECL_NAME (decl)))\n     TYPE_HAS_CONVERSION (class_type) = true;"}, {"sha": "5f5ff81f4054b435e2c66ea357f6e72b7a173b94", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -4504,9 +4504,6 @@ push_class_level_binding_1 (tree name, tree x)\n \t\tbinding->type = NULL_TREE;\n \t    }\n \t}\n-      else if (TREE_CODE (target_decl) == OVERLOAD\n-\t       && OVL_P (target_bval))\n-\told_decl = bval;\n       else if (TREE_CODE (decl) == USING_DECL\n \t       && TREE_CODE (bval) == USING_DECL\n \t       && same_type_p (USING_DECL_SCOPE (decl),\n@@ -4525,6 +4522,9 @@ push_class_level_binding_1 (tree name, tree x)\n       else if (TREE_CODE (bval) == USING_DECL\n \t       && OVL_P (target_decl))\n \treturn true;\n+      else if (OVL_P (target_decl)\n+\t       && OVL_P (target_bval))\n+\told_decl = bval;\n \n       if (old_decl && binding->scope == class_binding_level)\n \t{"}, {"sha": "bca92100621a49edd28ef8a493192411b8f83b30", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -5015,6 +5015,31 @@ special_function_p (const_tree decl)\n   return sfk_none;\n }\n \n+/* As above, but only if DECL is a special member function as per 11.3.3\n+   [special]: default/copy/move ctor, copy/move assignment, or destructor.  */\n+\n+special_function_kind\n+special_memfn_p (const_tree decl)\n+{\n+  switch (special_function_kind sfk = special_function_p (decl))\n+    {\n+    case sfk_constructor:\n+      if (!default_ctor_p (decl))\n+\tbreak;\n+      gcc_fallthrough();\n+    case sfk_copy_constructor:\n+    case sfk_copy_assignment:\n+    case sfk_move_assignment:\n+    case sfk_move_constructor:\n+    case sfk_destructor:\n+      return sfk;\n+\n+    default:\n+      break;\n+    }\n+  return sfk_none;\n+}\n+\n /* Returns nonzero if TYPE is a character type, including wchar_t.  */\n \n int"}, {"sha": "5dcd649d1f851235cbd62f9ba9facf25404de9e8", "filename": "gcc/testsuite/g++.dg/concepts/pr89036.C", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr89036.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr89036.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr89036.C?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -6,3 +6,13 @@ struct Y {\n   ~Y() requires(true) = default;\n   ~Y() requires(false) {}\n };\n+\n+Y<int> y;\n+\n+template<typename T>\n+struct X {\n+  ~X() requires(sizeof(T) == 8) = default;\n+  ~X() requires(sizeof(T) != 8) {}\n+};\n+\n+X<int> x;"}, {"sha": "8f5806ee1afe683b29e32badaec27b0904966e2f", "filename": "gcc/testsuite/g++.dg/cpp2a/cond-triv1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1.C?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -0,0 +1,46 @@\n+// Testcase from P0848R0\n+// { dg-do compile { target concepts } }\n+\n+#include <type_traits>\n+\n+template <typename T>\n+class optional\n+{\n+  struct empty {};\n+  union {\n+    empty _ = { };\n+    T value;\n+  };\n+  bool engaged = false;\n+\n+public:\n+  constexpr optional() = default;\n+\n+  constexpr optional(optional const&)\n+    requires std::is_trivially_copy_constructible_v<T>\n+    = default;\n+  constexpr optional(optional const& o)\n+    : engaged (o.engaged)\n+  {\n+    if (engaged)\n+      new (&value) T (o.value);\n+  }\n+\n+  ~optional()\n+    requires std::is_trivially_destructible_v<T>\n+    = default;\n+  ~optional()\n+  {\n+    if (engaged)\n+      value.~T();\n+  }\n+\n+  // ...\n+};\n+\n+struct A { A(); A(const A&); ~A(); };\n+\n+static_assert(std::is_trivially_copy_constructible_v<optional<int>>);\n+static_assert(!std::is_trivially_copy_constructible_v<optional<A>>);\n+static_assert(std::is_trivially_destructible_v<optional<int>>);\n+static_assert(!std::is_trivially_destructible_v<optional<A>>);"}, {"sha": "febd109abd7490830d4226afe0727b3d1c4de99b", "filename": "gcc/testsuite/g++.dg/cpp2a/cond-triv1a.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c735f8f1a0c5a5d1e114e45390b35882f539ff69/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcond-triv1a.C?ref=c735f8f1a0c5a5d1e114e45390b35882f539ff69", "patch": "@@ -0,0 +1,46 @@\n+// Like cond-triv1.C, but with the declaration order swapped.\n+// { dg-do compile { target concepts } }\n+\n+#include <type_traits>\n+\n+template <typename T>\n+class optional\n+{\n+  struct empty {};\n+  union {\n+    empty _ = { };\n+    T value;\n+  };\n+  bool engaged = false;\n+\n+public:\n+  constexpr optional() = default;\n+\n+  constexpr optional(optional const& o)\n+    : engaged (o.engaged)\n+  {\n+    if (engaged)\n+      new (&value) T (o.value);\n+  }\n+  constexpr optional(optional const&)\n+    requires std::is_trivially_copy_constructible_v<T>\n+    = default;\n+\n+  ~optional()\n+  {\n+    if (engaged)\n+      value.~T();\n+  }\n+  ~optional()\n+    requires std::is_trivially_destructible_v<T>\n+    = default;\n+\n+  // ...\n+};\n+\n+struct A { A(); A(const A&); ~A(); };\n+\n+static_assert(std::is_trivially_copy_constructible_v<optional<int>>);\n+static_assert(!std::is_trivially_copy_constructible_v<optional<A>>);\n+static_assert(std::is_trivially_destructible_v<optional<int>>);\n+static_assert(!std::is_trivially_destructible_v<optional<A>>);"}]}