{"sha": "8a04a5fb07f94a2154b362741104f9d48d3e612d", "node_id": "C_kwDOANBUbNoAKDhhMDRhNWZiMDdmOTRhMjE1NGIzNjI3NDExMDRmOWQ0OGQzZTYxMmQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-20T05:29:59Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-26T06:20:11Z"}, "message": "Attempt to resolve all incoming paths to a PHI.\n\nThe code that threads incoming paths to a PHI is duplicating what we\ndo generically in find_paths_to_names.  This shortcoming is actually\none of the reasons we aren't threading all possible paths into a PHI.\nFor example, we give up after finding one threadable path, but some\nPHIs have multiple threadable paths:\n\n      // x_5 = PHI <10(4), 20(5), ...>\n      // if (x_5 > 5)\n\nAddressing this not only fixes the oversight, but simplifies the\nPHI handling code, since we can consider the PHI fully resolved upon\nreturn.\n\nInterestingly, for ssa-thread-12.c the main thread everything was\nhinging on was unreachable.  With this patch, we call\nmaybe_register_path() earlier.  In doing so, the solver realizes\nthat any path starting with 4->8 is unreachable and can be avoided.\nThis caused the cascade of threadable paths that depended on this\nto no longer happen.  Since threadable paths in thread[34] was the only\nthing this test was testing, there's no longer anything to test.  Neat!\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c (back_threader::resolve_phi):\n\tAttempt to resolve all incoming paths to a PHI.\n\t(back_threader::resolve_def): Always return true for PHIs.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr21090.c: Adjust for threading.\n\t* gcc.dg/tree-ssa/ssa-thread-12.c: Removed.", "tree": {"sha": "7bff38ae0b98c28d25f3d6c5093521844879e0fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bff38ae0b98c28d25f3d6c5093521844879e0fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a04a5fb07f94a2154b362741104f9d48d3e612d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a04a5fb07f94a2154b362741104f9d48d3e612d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a04a5fb07f94a2154b362741104f9d48d3e612d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a04a5fb07f94a2154b362741104f9d48d3e612d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d012338bf87f427b7420f2f309963c29fe33ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d012338bf87f427b7420f2f309963c29fe33ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d012338bf87f427b7420f2f309963c29fe33ba"}], "stats": {"total": 145, "additions": 21, "deletions": 124}, "files": [{"sha": "92a87688601366f2b401fd6f3e6dc75c2cd28a51", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21090.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a04a5fb07f94a2154b362741104f9d48d3e612d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a04a5fb07f94a2154b362741104f9d48d3e612d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21090.c?ref=8a04a5fb07f94a2154b362741104f9d48d3e612d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1 -fdelete-null-pointer-checks\" } */\n+/* { dg-options \"-O2 -fno-thread-jumps -fdisable-tree-evrp -fdump-tree-vrp1 -fdelete-null-pointer-checks\" } */\n \n int g, h;\n "}, {"sha": "08c0b8d3bcc6c4546468d86c5999f26be9ad0bda", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-12.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d012338bf87f427b7420f2f309963c29fe33ba/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d012338bf87f427b7420f2f309963c29fe33ba/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c?ref=f6d012338bf87f427b7420f2f309963c29fe33ba", "patch": "@@ -1,73 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread3-details -fdump-tree-thread4-details -fno-finite-loops --param early-inlining-insns=14 -fno-inline-functions\" } */\n-/* { dg-final { scan-tree-dump \"Registering jump thread\" \"thread3\" } } */\n-/* { dg-final { scan-tree-dump \"Registering jump thread\" \"thread4\" } } */\n-\n-typedef struct bitmap_head_def *bitmap;\n-typedef const struct bitmap_head_def *const_bitmap;\n-typedef struct VEC_int_base\n-{\n-}\n-VEC_int_base;\n-typedef struct VEC_int_heap\n-{\n-  VEC_int_base base;\n-}\n-VEC_int_heap;\n-typedef unsigned long BITMAP_WORD;\n-typedef struct bitmap_element_def\n-{\n-  struct bitmap_element_def *next;\n-  unsigned int indx;\n-}\n-bitmap_element;\n-typedef struct bitmap_head_def\n-{\n-}\n-bitmap_head;\n-typedef struct\n-{\n-  bitmap_element *elt1;\n-  bitmap_element *elt2;\n-  BITMAP_WORD bits;\n-}\n-bitmap_iterator;\n-static __inline__ void\n-bmp_iter_and_compl_init (bitmap_iterator * bi, const_bitmap map1,\n-\t\t\t const_bitmap map2, unsigned start_bit,\n-\t\t\t unsigned *bit_no)\n-{\n-}\n-\n-static __inline__ void\n-bmp_iter_next (bitmap_iterator * bi, unsigned *bit_no)\n-{\n-}\n-\n-static __inline__ unsigned char\n-bmp_iter_and_compl (bitmap_iterator * bi, unsigned *bit_no)\n-{\n-  if (bi->bits)\n-    {\n-      while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)\n-\tbi->elt2 = bi->elt2->next;\n-    }\n-}\n-\n-extern int VEC_int_base_length (VEC_int_base *);\n-bitmap\n-compute_idf (bitmap def_blocks, bitmap_head * dfs)\n-{\n-  bitmap_iterator bi;\n-  unsigned bb_index, i;\n-  VEC_int_heap *work_stack;\n-  bitmap phi_insertion_points;\n-  while ((VEC_int_base_length (((work_stack) ? &(work_stack)->base : 0))) > 0)\n-    {\n-      for (bmp_iter_and_compl_init\n-\t   (&(bi), (&dfs[bb_index]), (phi_insertion_points), (0), &(i));\n-\t   bmp_iter_and_compl (&(bi), &(i)); bmp_iter_next (&(bi), &(i)))\n-\t{\n-\t}\n-    }\n-}"}, {"sha": "a6b9893abbdf35e8feae1b3eafe38af1de205098", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 20, "deletions": 50, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a04a5fb07f94a2154b362741104f9d48d3e612d/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a04a5fb07f94a2154b362741104f9d48d3e612d/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=8a04a5fb07f94a2154b362741104f9d48d3e612d", "patch": "@@ -83,7 +83,7 @@ class back_threader\n   edge maybe_register_path ();\n   bool find_paths_to_names (basic_block bb, bitmap imports);\n   bool resolve_def (tree name, bitmap interesting, vec<tree> &worklist);\n-  bool resolve_phi (gphi *phi, bitmap imports);\n+  void resolve_phi (gphi *phi, bitmap imports);\n   edge find_taken_edge (const vec<basic_block> &path);\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n   edge find_taken_edge_switch (const vec<basic_block> &path, gswitch *);\n@@ -243,17 +243,14 @@ populate_worklist (vec<tree> &worklist, bitmap bits)\n     }\n }\n \n-// If taking any of the incoming edges to a PHI causes the final\n-// conditional of the current path to be constant, register the\n-// path(s), and return TRUE.\n+// Find jump threading paths that go through a PHI.\n \n-bool\n+void\n back_threader::resolve_phi (gphi *phi, bitmap interesting)\n {\n   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_phi_result (phi)))\n-    return true;\n+    return;\n \n-  bool done = false;\n   for (size_t i = 0; i < gimple_phi_num_args (phi); ++i)\n     {\n       edge e = gimple_phi_arg_edge (phi, i);\n@@ -275,53 +272,24 @@ back_threader::resolve_phi (gphi *phi, bitmap interesting)\n \t  continue;\n \t}\n \n-      // FIXME: We currently stop looking if we find a threadable path\n-      // through a PHI.  This is pessimistic, as there can be multiple\n-      // paths that can resolve the path.  For example:\n-      //\n-      // x_5 = PHI <10(4), 20(5), ...>\n-      // if (x_5 > 5)\n-\n       tree arg = gimple_phi_arg_def (phi, i);\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  unsigned v = SSA_NAME_VERSION (arg);\n-\n-\t  // Avoid loops as in: x_5 = PHI <x_5(2), ...>.\n-\t  if (bitmap_bit_p (interesting, v))\n-\t    continue;\n+      unsigned v = 0;\n \n+      if (TREE_CODE (arg) == SSA_NAME\n+\t  && !bitmap_bit_p (interesting, SSA_NAME_VERSION (arg)))\n+\t{\n+\t  // Record that ARG is interesting when searching down this path.\n+\t  v = SSA_NAME_VERSION (arg);\n+\t  gcc_checking_assert (v != 0);\n \t  bitmap_set_bit (interesting, v);\n \t  bitmap_set_bit (m_imports, v);\n+\t}\n \n-\t  // When resolving unknowns, see if the incoming SSA can be\n-\t  // resolved on entry without having to keep looking back.\n-\t  bool keep_looking = true;\n-\t  if (m_resolve)\n-\t    {\n-\t      m_path.safe_push (e->src);\n-\t      if (maybe_register_path ())\n-\t\t{\n-\t\t  keep_looking = false;\n-\t\t  m_visited_bbs.add (e->src);\n-\t\t}\n-\t      m_path.pop ();\n-\t    }\n-\t  if (keep_looking)\n-\t    done |= find_paths_to_names (e->src, interesting);\n+      find_paths_to_names (e->src, interesting);\n \n-\t  bitmap_clear_bit (interesting, v);\n-\t}\n-      else if (TREE_CODE (arg) == INTEGER_CST)\n-\t{\n-\t  m_path.safe_push (e->src);\n-\t  edge taken_edge = maybe_register_path ();\n-\t  if (taken_edge && taken_edge != UNREACHABLE_EDGE)\n-\t    done = true;\n-\t  m_path.pop ();\n-\t}\n+      if (v)\n+\tbitmap_clear_bit (interesting, v);\n     }\n-  return done;\n }\n \n // If the definition of NAME causes the final conditional of the\n@@ -333,9 +301,11 @@ back_threader::resolve_def (tree name, bitmap interesting, vec<tree> &worklist)\n   gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n \n   // Handle PHIs.\n-  if (is_a<gphi *> (def_stmt)\n-      && resolve_phi (as_a<gphi *> (def_stmt), interesting))\n-    return true;\n+  if (is_a<gphi *> (def_stmt))\n+    {\n+      resolve_phi (as_a<gphi *> (def_stmt), interesting);\n+      return true;\n+    }\n \n   // Defer copies of SSAs by adding the source to the worklist.\n   if (gimple_assign_single_p (def_stmt)"}]}