{"sha": "d2d668fbbb3625987fa4117e63df38fa745874bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkNjY4ZmJiYjM2MjU5ODdmYTQxMTdlNjNkZjM4ZmE3NDU4NzRiZA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2011-11-15T03:46:08Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2011-11-15T03:46:08Z"}, "message": "ipa-cp.c (ipa_value_from_jfunc): Make global.\n\n\t* ipa-cp.c (ipa_value_from_jfunc): Make global.\n\t(ipa_cst_from_jfunc): Remove, use ipa_value_from_jfunc instead.\n\t(get_indirect_edge_target): Rename, make global.\n\t(devirtualization_time_bonus, estimate_local_effects,)\n\t(ipcp_discover_new_direct_edges): Update.\n\t* ipa-inline-analysis.c (evaluate_conditions_for_edge):\n\tGeneralize to also handle types.  Rename to ...\n\t(evaluate_properties_for_edge): Use instead of\n\tevaluate_conditions_for_edge.\n\t(estimate_edge_devirt_benefit): New function.\n\t(estimate_calls_size_and_time): Use it.\n\t(estimate_node_size_and_time, estimate_ipcp_clone_size_and_time,)\n\t(inline_merge_summary):\tUpdate.\n\t(do_estimate_edge_time, do_estimate_edge_growth): Update.  Calculate\n\tparameter information at the call site and pass it on to subroutines.\n\t* tree-inline.c (estimate_num_insns): Distinguish between direct and\n\tindirect calls.\n\t(init_inline_once): Set size and time costs or indirect calls.\n\t* tree-inline.h (eni_weights): Add indirect_call_cost.\n\nFrom-SVN: r181377", "tree": {"sha": "1efbbc4ccd7ffb98f0069e2281a731e60cdb0fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1efbbc4ccd7ffb98f0069e2281a731e60cdb0fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2d668fbbb3625987fa4117e63df38fa745874bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d668fbbb3625987fa4117e63df38fa745874bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d668fbbb3625987fa4117e63df38fa745874bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d668fbbb3625987fa4117e63df38fa745874bd/comments", "author": null, "committer": null, "parents": [{"sha": "e3790e8a9f45bd38f4cf3aa1df6bbf1020b2931c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3790e8a9f45bd38f4cf3aa1df6bbf1020b2931c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3790e8a9f45bd38f4cf3aa1df6bbf1020b2931c"}], "stats": {"total": 250, "additions": 189, "deletions": 61}, "files": [{"sha": "01476a996939ba907cfcdb102ac49c95c1c14c1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -1,3 +1,25 @@\n+2011-11-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* ipa-cp.c (ipa_value_from_jfunc): Make global.\n+\t(ipa_cst_from_jfunc): Remove, use ipa_value_from_jfunc instead.\n+\t(get_indirect_edge_target): Rename, make global.\n+\t(devirtualization_time_bonus, estimate_local_effects,)\n+\t(ipcp_discover_new_direct_edges): Update.\n+\t* ipa-inline-analysis.c (evaluate_conditions_for_edge):\n+\tGeneralize to also handle types.  Rename to ...\n+\t(evaluate_properties_for_edge): Use instead of\n+\tevaluate_conditions_for_edge.\n+\t(estimate_edge_devirt_benefit): New function.\n+\t(estimate_calls_size_and_time): Use it.\n+\t(estimate_node_size_and_time, estimate_ipcp_clone_size_and_time,)\n+\t(inline_merge_summary):\tUpdate.\n+\t(do_estimate_edge_time, do_estimate_edge_growth): Update.  Calculate\n+\tparameter information at the call site and pass it on to subroutines.\n+\t* tree-inline.c (estimate_num_insns): Distinguish between direct and\n+\tindirect calls.\n+\t(init_inline_once): Set size and time costs or indirect calls.\n+\t* tree-inline.h (eni_weights): Add indirect_call_cost.\n+\n 2011-11-15  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/51005"}, {"sha": "10e1834ce7bf6d7959b771472c99dfb805e27749", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -693,7 +693,7 @@ ipa_value_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n    describes the caller node so that pass-through jump functions can be\n    evaluated.  */\n \n-static tree\n+tree\n ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n {\n   if (jfunc->type == IPA_JF_CONST)\n@@ -753,21 +753,6 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n     return NULL_TREE;\n }\n \n-/* Determine whether JFUNC evaluates to a constant and if so, return it.\n-   Otherwise return NULL. INFO describes the caller node so that pass-through\n-   jump functions can be evaluated.  */\n-\n-tree\n-ipa_cst_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n-{\n-  tree res = ipa_value_from_jfunc (info, jfunc);\n-\n-  if (res && TREE_CODE (res) == TREE_BINFO)\n-    return NULL_TREE;\n-  else\n-    return res;\n-}\n-\n \n /* If checking is enabled, verify that no lattice is in the TOP state, i.e. not\n    bottom, not containing a variable component and without any known value at\n@@ -1112,10 +1097,10 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n    (which can contain both constants and binfos) or KNOWN_BINFOS (which can be\n    NULL) return the destination.  */\n \n-static tree\n-get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t  VEC (tree, heap) *known_vals,\n-\t\t\t  VEC (tree, heap) *known_binfos)\n+tree\n+ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n+\t\t\t      VEC (tree, heap) *known_vals,\n+\t\t\t      VEC (tree, heap) *known_binfos)\n {\n   int param_index = ie->indirect_info->param_index;\n   HOST_WIDE_INT token, anc_offset;\n@@ -1185,7 +1170,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       struct inline_summary *isummary;\n       tree target;\n \n-      target = get_indirect_edge_target (ie, known_csts, known_binfos);\n+      target = ipa_get_indirect_edge_target (ie, known_csts, known_binfos);\n       if (!target)\n \tcontinue;\n \n@@ -1344,7 +1329,8 @@ estimate_local_effects (struct cgraph_node *node)\n \n       init_caller_stats (&stats);\n       cgraph_for_node_and_aliases (node, gather_caller_stats, &stats, false);\n-      estimate_ipcp_clone_size_and_time (node, known_csts, &size, &time);\n+      estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+\t\t\t\t\t &size, &time);\n       time -= devirtualization_time_bonus (node, known_csts, known_binfos);\n       time -= removable_params_cost;\n       size -= stats.n_calls * removable_params_cost;\n@@ -1415,7 +1401,8 @@ estimate_local_effects (struct cgraph_node *node)\n \t  else\n \t    continue;\n \n-\t  estimate_ipcp_clone_size_and_time (node, known_csts, &size, &time);\n+\t  estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+\t\t\t\t\t     &size, &time);\n \t  time_benefit = base_time - time\n \t    + devirtualization_time_bonus (node, known_csts, known_binfos)\n \t    + removable_params_cost + emc;\n@@ -1673,7 +1660,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       tree target;\n \n       next_ie = ie->next_callee;\n-      target = get_indirect_edge_target (ie, known_vals, NULL);\n+      target = ipa_get_indirect_edge_target (ie, known_vals, NULL);\n       if (target)\n \tipa_make_edge_direct_to_target (ie, target);\n     }"}, {"sha": "9ff247b103a2a974efbe4bc94a91de537b44ad30", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 143, "deletions": 33, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -710,15 +710,25 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n /* Work out what conditions might be true at invocation of E.  */\n \n-static clause_t\n-evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n+static void\n+evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n+\t\t\t      clause_t *clause_ptr,\n+\t\t\t      VEC (tree, heap) **known_vals_ptr,\n+\t\t\t      VEC (tree, heap) **known_binfos_ptr)\n {\n-  clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n   struct inline_summary *info = inline_summary (callee);\n   int i;\n \n-  if (ipa_node_params_vector && info->conds)\n+  if (clause_ptr)\n+    *clause_ptr = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n+  if (known_vals_ptr)\n+    *known_vals_ptr = NULL;\n+  if (known_binfos_ptr)\n+    *known_binfos_ptr = NULL;\n+\n+  if (ipa_node_params_vector\n+      && ((clause_ptr && info->conds) || known_vals_ptr || known_binfos_ptr))\n     {\n       struct ipa_node_params *parms_info;\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n@@ -731,29 +741,42 @@ evaluate_conditions_for_edge (struct cgraph_edge *e, bool inline_p)\n       else\n         parms_info = IPA_NODE_REF (e->caller);\n \n-      if (count)\n-        VEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      if (count && (info->conds || known_vals_ptr))\n+\tVEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      if (count && known_binfos_ptr)\n+\tVEC_safe_grow_cleared (tree, heap, *known_binfos_ptr, count);\n+\n       for (i = 0; i < count; i++)\n \t{\n-\t  tree cst = ipa_cst_from_jfunc (parms_info,\n-\t\t\t\t\t ipa_get_ith_jump_func (args, i));\n+\t  tree cst = ipa_value_from_jfunc (parms_info,\n+\t\t\t\t\t   ipa_get_ith_jump_func (args, i));\n \t  if (cst)\n-\t    VEC_replace (tree, known_vals, i, cst);\n+\t    {\n+\t      if (info->conds && TREE_CODE (cst) != TREE_BINFO)\n+\t\tVEC_replace (tree, known_vals, i, cst);\n+\t      else if (known_binfos_ptr != NULL)\n+\t\tVEC_replace (tree, *known_binfos_ptr, i, cst);\n+\t    }\n \t  else if (inline_p\n \t\t   && !VEC_index (inline_param_summary_t,\n \t\t\t\t  es->param,\n \t\t\t\t  i)->change_prob)\n \t    VEC_replace (tree, known_vals, i, error_mark_node);\n \t}\n-      clause = evaluate_conditions_for_known_args (callee,\n-\t\t\t\t\t\t   inline_p, known_vals);\n-      VEC_free (tree, heap, known_vals);\n+\n+      if (clause_ptr && info->conds)\n+\t*clause_ptr = evaluate_conditions_for_known_args (callee, inline_p,\n+\t\t\t\t\t\t\t  known_vals);\n+\n+      if (known_vals_ptr)\n+\t*known_vals_ptr = known_vals;\n+      else\n+\tVEC_free (tree, heap, known_vals);\n     }\n-  else\n-    for (i = 0; i < (int)VEC_length (condition, info->conds); i++)\n-      clause |= 1 << (i + predicate_first_dynamic_condition);\n \n-  return clause;\n+  if (clause_ptr && !info->conds)\n+    for (i = 0; i < (int)VEC_length (condition, info->conds); i++)\n+      *clause_ptr |= 1 << (i + predicate_first_dynamic_condition);\n }\n \n \n@@ -2169,11 +2192,71 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n }\n \n \n-/* Increase SIZE and TIME for size and time needed to handle all calls in NODE.  */\n+/* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS and\n+   KNOWN_BINFOS.  */\n+\n+static void\n+estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n+\t\t\t      int *size, int *time, int prob,\n+\t\t\t      VEC (tree, heap) *known_vals,\n+\t\t\t      VEC (tree, heap) *known_binfos)\n+{\n+  tree target;\n+  struct cgraph_node *callee;\n+  struct inline_summary *isummary;\n+  int edge_size = 0, edge_time = 0;\n+\n+  if (!known_vals || !known_binfos)\n+    return;\n+\n+  target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos);\n+  if (!target)\n+    return;\n+\n+  /* Account for difference in cost between indirect and direct calls.  */\n+  *size -= ((eni_size_weights.indirect_call_cost - eni_size_weights.call_cost)\n+\t    * INLINE_SIZE_SCALE);\n+  *time -= ((eni_time_weights.indirect_call_cost - eni_time_weights.call_cost)\n+\t    * INLINE_TIME_SCALE * prob / REG_BR_PROB_BASE);\n+\n+  callee = cgraph_get_node (target);\n+  if (!callee || !callee->analyzed)\n+    return;\n+  isummary = inline_summary (callee);\n+  if (!isummary->inlinable)\n+    return;\n+\n+  estimate_edge_size_and_time (ie, &edge_size, &edge_time, prob);\n+\n+  /* Count benefit only from functions that definitely will be inlined\n+     if additional context from NODE's caller were available.  */\n+  if (edge_size >= isummary->size * INLINE_SIZE_SCALE)\n+    {\n+      /* Subtract size and time that we added for edge IE.  */\n+      *size -= edge_size;\n+      *time -= edge_time;\n+\n+      /* Subtract benefit from inlining devirtualized call.  */\n+      *size -= edge_size - isummary->size * INLINE_SIZE_SCALE;\n+      *time -= edge_time - (isummary->time * INLINE_TIME_SCALE * prob\n+\t\t\t    / REG_BR_PROB_BASE);\n+\n+      /* TODO: estimate benefit from optimizing CALLEE's body provided\n+\t additional context from IE call site.\n+\t For insipiration see ipa-cp.c: devirtualization_time_bonus().  */\n+    }\n+}\n+\n+\n+/* Increase SIZE and TIME for size and time needed to handle all calls in NODE.\n+   POSSIBLE_TRUTHS, KNOWN_VALS and KNOWN_BINFOS describe context of the call\n+   site.  */\n \n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n-\t\t\t      clause_t possible_truths)\n+\t\t\t      clause_t possible_truths,\n+\t\t\t      VEC (tree, heap) *known_vals,\n+\t\t\t      VEC (tree, heap) *known_binfos)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n@@ -2189,25 +2272,32 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t    }\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, time,\n-\t\t\t\t\t  possible_truths);\n+\t\t\t\t\t  possible_truths,\n+\t\t\t\t\t  known_vals, known_binfos);\n \t}\n     }\n-  /* TODO: look for devirtualizing oppurtunities.  */\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n       if (!es->predicate || evaluate_predicate (es->predicate, possible_truths))\n-        estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n+\t{\n+\t  estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n+\t  estimate_edge_devirt_benefit (e, size, time, REG_BR_PROB_BASE,\n+\t\t\t\t\tknown_vals, known_binfos);\n+\t}\n     }\n }\n \n \n /* Estimate size and time needed to execute NODE assuming\n-   POSSIBLE_TRUTHS clause. */\n+   POSSIBLE_TRUTHS clause, and KNOWN_VALS and KNOWN_BINFOS information\n+   about NODE's arguments. */\n \n static void\n estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n+\t\t\t     VEC (tree, heap) *known_vals,\n+\t\t\t     VEC (tree, heap) *known_binfos,\n \t\t       \t     int *ret_size, int *ret_time,\n \t\t\t     VEC (inline_param_summary_t, heap)\n \t\t\t       *inline_param_summary)\n@@ -2258,7 +2348,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n-  estimate_calls_size_and_time (node, &size, &time, possible_truths);\n+  estimate_calls_size_and_time (node, &size, &time, possible_truths,\n+\t\t\t\tknown_vals, known_binfos);\n   time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n \n@@ -2276,17 +2367,20 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n /* Estimate size and time needed to execute callee of EDGE assuming that\n    parameters known to be constant at caller of EDGE are propagated.\n-   KNOWN_VALs is a vector of assumed known constant values for parameters.  */\n+   KNOWN_VALS and KNOWN_BINFOS are vectors of assumed known constant values\n+   and types for parameters.  */\n \n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   VEC (tree, heap) *known_vals,\n+\t\t\t\t   VEC (tree, heap) *known_binfos,\n \t\t                   int *ret_size, int *ret_time)\n {\n   clause_t clause;\n \n   clause = evaluate_conditions_for_known_args (node, false, known_vals);\n-  estimate_node_size_and_time (node, clause, ret_size, ret_time,\n+  estimate_node_size_and_time (node, clause, known_vals, known_binfos,\n+\t\t\t       ret_size, ret_time,\n \t\t\t       NULL);\n }\n \n@@ -2542,9 +2636,9 @@ inline_merge_summary (struct cgraph_edge *edge)\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n-      clause = evaluate_conditions_for_edge (edge, true);\n+      evaluate_properties_for_edge (edge, true, &clause, NULL, NULL);\n       if (count)\n-        VEC_safe_grow_cleared (int, heap, operand_map, count);\n+\tVEC_safe_grow_cleared (int, heap, operand_map, count);\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n@@ -2588,7 +2682,8 @@ inline_merge_summary (struct cgraph_edge *edge)\n   for (i = 0; VEC_iterate (size_time_entry, info->entry, i, e); i++)\n     info->size += e->size, info->time += e->time;\n   estimate_calls_size_and_time (to, &info->size, &info->time,\n-\t\t\t\t~(clause_t)(1 << predicate_false_condition));\n+\t\t\t\t~(clause_t)(1 << predicate_false_condition),\n+\t\t\t\tNULL, NULL);\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -2616,13 +2711,21 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   int time;\n   int size;\n   gcov_type ret;\n+  struct cgraph_node *callee;\n+  clause_t clause;\n+  VEC (tree, heap) *known_vals;\n+  VEC (tree, heap) *known_binfos;\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n+  callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n+\n   gcc_checking_assert (edge->inline_failed);\n-  estimate_node_size_and_time (cgraph_function_or_thunk_node (edge->callee,\n-\t\t\t\t\t\t\t      NULL),\n-\t\t\t       evaluate_conditions_for_edge (edge, true),\n+  evaluate_properties_for_edge (edge, true,\n+\t\t\t\t&clause, &known_vals, &known_binfos);\n+  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n \t\t\t       &size, &time, es->param);\n+  VEC_free (tree, heap, known_vals);\n+  VEC_free (tree, heap, known_binfos);\n \n   ret = (((gcov_type)time\n \t   - es->call_stmt_time) * edge->frequency\n@@ -2656,6 +2759,9 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n {\n   int size;\n   struct cgraph_node *callee;\n+  clause_t clause;\n+  VEC (tree, heap) *known_vals;\n+  VEC (tree, heap) *known_binfos;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -2668,13 +2774,17 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n       gcc_checking_assert (size);\n       return size - (size > 0);\n     }\n+\n   callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n-  estimate_node_size_and_time (callee,\n-\t\t\t       evaluate_conditions_for_edge (edge, true),\n+  evaluate_properties_for_edge (edge, true,\n+\t\t\t\t&clause, &known_vals, &known_binfos);\n+  estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n \t\t\t       &size, NULL, NULL);\n+  VEC_free (tree, heap, known_vals);\n+  VEC_free (tree, heap, known_binfos);\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n   return size - inline_edge_summary (edge)->call_stmt_size;\n }"}, {"sha": "a2c6cac0147417b117ee3581db8a6047259ab302", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -169,6 +169,7 @@ int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tVEC (tree, heap) *known_vals,\n+\t\t\t\t\tVEC (tree, heap) *known_binfos,\n \t\t\t\t\tint *, int *);\n int do_estimate_growth (struct cgraph_node *);\n void inline_merge_summary (struct cgraph_edge *edge);"}, {"sha": "1a609a5b5b79684581ef5f02603844caefca8503", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -346,6 +346,9 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) **new_edges);\n \n /* Indirect edge and binfo processing.  */\n+tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n+\t\t\t\t   VEC (tree, heap) *known_csts,\n+\t\t\t\t   VEC (tree, heap) *known_binfs);\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n \n /* Functions related to both.  */\n@@ -437,8 +440,8 @@ void ipa_prop_write_jump_functions (cgraph_node_set set);\n void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n-tree ipa_cst_from_jfunc (struct ipa_node_params *info,\n-\t\t\t struct ipa_jump_func *jfunc);\n+tree ipa_value_from_jfunc (struct ipa_node_params *info,\n+\t\t\t   struct ipa_jump_func *jfunc);\n \n \n /* From tree-sra.c:  */"}, {"sha": "22604030d4a1d24a6b43accf11a67530fca5f85a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -3521,7 +3521,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n     case GIMPLE_CALL:\n       {\n \ttree decl = gimple_call_fndecl (stmt);\n-\tstruct cgraph_node *node;\n+\tstruct cgraph_node *node = NULL;\n \n \t/* Do not special case builtins where we see the body.\n \t   This just confuse inliner.  */\n@@ -3556,7 +3556,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n \t      }\n \t  }\n \n-\tcost = weights->call_cost;\n+\tcost = node ? weights->call_cost : weights->indirect_call_cost;\n \tif (gimple_call_lhs (stmt))\n \t  cost += estimate_move_cost (TREE_TYPE (gimple_call_lhs (stmt)));\n \tfor (i = 0; i < gimple_call_num_args (stmt); i++)\n@@ -3674,6 +3674,7 @@ void\n init_inline_once (void)\n {\n   eni_size_weights.call_cost = 1;\n+  eni_size_weights.indirect_call_cost = 3;\n   eni_size_weights.target_builtin_call_cost = 1;\n   eni_size_weights.div_mod_cost = 1;\n   eni_size_weights.omp_cost = 40;\n@@ -3686,6 +3687,7 @@ init_inline_once (void)\n      underestimating the cost does less harm than overestimating it, so\n      we choose a rather small value here.  */\n   eni_time_weights.call_cost = 10;\n+  eni_time_weights.indirect_call_cost = 15;\n   eni_time_weights.target_builtin_call_cost = 1;\n   eni_time_weights.div_mod_cost = 10;\n   eni_time_weights.omp_cost = 40;"}, {"sha": "ba0b2c46995c6f9d825999550dc5d939378e536f", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d668fbbb3625987fa4117e63df38fa745874bd/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=d2d668fbbb3625987fa4117e63df38fa745874bd", "patch": "@@ -135,6 +135,9 @@ typedef struct eni_weights_d\n   /* Cost per call.  */\n   unsigned call_cost;\n \n+  /* Cost per indirect call.  */\n+  unsigned indirect_call_cost;\n+\n   /* Cost per call to a target specific builtin */\n   unsigned target_builtin_call_cost;\n "}]}