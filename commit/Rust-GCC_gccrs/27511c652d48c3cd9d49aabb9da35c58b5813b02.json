{"sha": "27511c652d48c3cd9d49aabb9da35c58b5813b02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1MTFjNjUyZDQ4YzNjZDlkNDlhYWJiOWRhMzVjNThiNTgxM2IwMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T13:12:37Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-12-17T13:12:37Z"}, "message": "cse.c (cse_find_path): Don't wrap a gcc_assert in ENABLE_CHECKING.\n\n\t* cse.c (cse_find_path): Don't wrap a gcc_assert in ENABLE_CHECKING.\n\t(cse_extended_basic_block): When truncating a path while processing\n\tit, make sure to clear the visited bit on the basic blocks in the\n\ttruncated part of the path.\n\t(cse_main): Use reverse completion order, not DFS order, to walk\n\tthe CFG.\n\t(gate_handle_cse): Revert erroneous commit of a counter.\n\nFrom-SVN: r119985", "tree": {"sha": "cc9c266ef1bc257bbe93f684bd3bb24144d88eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc9c266ef1bc257bbe93f684bd3bb24144d88eaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27511c652d48c3cd9d49aabb9da35c58b5813b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27511c652d48c3cd9d49aabb9da35c58b5813b02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27511c652d48c3cd9d49aabb9da35c58b5813b02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27511c652d48c3cd9d49aabb9da35c58b5813b02/comments", "author": null, "committer": null, "parents": [{"sha": "96fb470d746061e78c452e35533d534e44b269bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fb470d746061e78c452e35533d534e44b269bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fb470d746061e78c452e35533d534e44b269bb"}], "stats": {"total": 39, "additions": 30, "deletions": 9}, "files": [{"sha": "45cecefc3418b6ad4cc1dbee44fd0524107d67ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27511c652d48c3cd9d49aabb9da35c58b5813b02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27511c652d48c3cd9d49aabb9da35c58b5813b02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27511c652d48c3cd9d49aabb9da35c58b5813b02", "patch": "@@ -1,3 +1,13 @@\n+2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cse.c (cse_find_path): Don't wrap a gcc_assert in ENABLE_CHECKING.\n+\t(cse_extended_basic_block): When truncating a path while processing\n+\tit, make sure to clear the visited bit on the basic blocks in the\n+\ttruncated part of the path.\n+\t(cse_main): Use reverse completion order, not DFS order, to walk\n+\tthe CFG.\n+\t(gate_handle_cse): Revert erroneous commit of a counter.\n+\n 2006-12-17  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cse.c (this_insn_cc0, this_insn_cc0_mode): New global"}, {"sha": "bd33190b51878f03063039002a5814bb49d333a1", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27511c652d48c3cd9d49aabb9da35c58b5813b02/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27511c652d48c3cd9d49aabb9da35c58b5813b02/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=27511c652d48c3cd9d49aabb9da35c58b5813b02", "patch": "@@ -5905,11 +5905,10 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \t    {\n \t      basic_block bb2 = e->dest;\n \n-#if ENABLE_CHECKING\n \t      /* We should only see blocks here that we have not\n \t\t visited yet.  */\n \t      gcc_assert (!TEST_BIT (cse_visited_basic_blocks, bb2->index));\n-#endif\n+\n \t      SET_BIT (cse_visited_basic_blocks, bb2->index);\n \t      data->path[path_size++].bb = bb2;\n \t      bb = bb2;\n@@ -6119,7 +6118,21 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t{\n \t  basic_block next_bb = ebb_data->path[path_entry + 1].bb;\n \t  if (!find_edge (bb, next_bb))\n-\t    ebb_data->path_size = path_entry + 1;\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  path_size--;\n+\n+\t\t  /* If we truncate the path, we must also reset the\n+\t\t     visited bit on the remaining blocks in the path,\n+\t\t     or we will never visit them at all.  */\n+\t\t  RESET_BIT (cse_visited_basic_blocks,\n+\t\t\t     ebb_data->path[path_size].bb->index);\n+\t\t  ebb_data->path[path_size].bb = NULL;\n+\t\t}\n+\t      while (path_size - 1 != path_entry);\n+\t      ebb_data->path_size = path_size;\n+\t    }\n \t}\n \n       /* If this is a conditional jump insn, record any known\n@@ -6159,7 +6172,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n {\n   struct cse_basic_block_data ebb_data;\n   basic_block bb;\n-  int *dfs_order = XNEWVEC (int, last_basic_block);\n+  int *rc_order = XNEWVEC (int, last_basic_block);\n   int i, n_blocks;\n \n   init_cse_reg_info (nregs);\n@@ -6199,15 +6212,15 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n \n   /* Loop over basic blocks in DFS order,\n      excluding the ENTRY and EXIT blocks.  */\n-  n_blocks = pre_and_rev_post_order_compute (dfs_order, NULL, false);\n+  n_blocks = pre_and_rev_post_order_compute (NULL, rc_order, false);\n   i = 0;\n   while (i < n_blocks)\n     {\n       /* Find the first block in the DFS queue that we have not yet\n \t processed before.  */\n       do\n \t{\n-\t  bb = BASIC_BLOCK (dfs_order[i++]);\n+\t  bb = BASIC_BLOCK (rc_order[i++]);\n \t}\n       while (TEST_BIT (cse_visited_basic_blocks, bb->index)\n \t     && i < n_blocks);\n@@ -6243,7 +6256,7 @@ cse_main (rtx f ATTRIBUTE_UNUSED, int nregs)\n   free (reg_eqv_table);\n   free (ebb_data.path);\n   sbitmap_free (cse_visited_basic_blocks);\n-  free (dfs_order);\n+  free (rc_order);\n   rtl_hooks = general_rtl_hooks;\n \n   return cse_jumps_altered || recorded_label_ref;\n@@ -6963,9 +6976,7 @@ gate_handle_cse (void)\n static unsigned int\n rest_of_handle_cse (void)\n {\n-static int counter = 0;\n   int tem;\n-counter++;\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n "}]}