{"sha": "5423609c57f756be5db8981d4ebb11a80d44f6e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyMzYwOWM1N2Y3NTZiZTVkYjg5ODFkNGViYjExYTgwZDQ0ZjZlOQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-04-21T13:49:49Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-04-21T13:49:49Z"}, "message": "decl.c (predef_filenames, [...]): New globals\n\nWed Apr 21 11:13:36 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* decl.c (predef_filenames, predef_filenames_size): New globals\n\t(init_decl_processing): predef_filenames and predef_filenames_size\n \tinitialized.\n\t* java-tree.h (predef_filenames, predef_filenames_size): Declared\n \textern.\n\t* jcf-parse.c (predefined_filename_p): New function.\n\t(yyparse): Check that files on the command line are specified only\n \tonce and issue a warning otherwise.\n\t* parse.h (JPRIMITIVE_TYPE_OR_VOID_P): New macro.\n\t* parse.y (source_end_java_method): Nullify NOP method bodies, to\n \tavoid a gcc warning with -W -Wall turned on.\n\t(java_expand_classes): Abort if errors were encountered.\n\t(java_complete_lhs): If the cross reference flag is set, wrap\n \tfield DECL node around a WFL when resolving expression name.\n\nFrom-SVN: r26578", "tree": {"sha": "6a4397f5304c150cbe5d79eab70071c1fe5a446a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a4397f5304c150cbe5d79eab70071c1fe5a446a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5423609c57f756be5db8981d4ebb11a80d44f6e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5423609c57f756be5db8981d4ebb11a80d44f6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5423609c57f756be5db8981d4ebb11a80d44f6e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5423609c57f756be5db8981d4ebb11a80d44f6e9/comments", "author": null, "committer": null, "parents": [{"sha": "9d9cf1661deded9d4030041ba8a4dc6a80df78c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d9cf1661deded9d4030041ba8a4dc6a80df78c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d9cf1661deded9d4030041ba8a4dc6a80df78c7"}], "stats": {"total": 148, "additions": 132, "deletions": 16}, "files": [{"sha": "cac0f2bb53fa0be59bea86f41071cd8b5ff73b34", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -1,3 +1,20 @@\n+Wed Apr 21 11:13:36 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* decl.c (predef_filenames, predef_filenames_size): New globals\n+\t(init_decl_processing): predef_filenames and predef_filenames_size\n+ \tinitialized.\n+\t* java-tree.h (predef_filenames, predef_filenames_size): Declared\n+ \textern.\n+\t* jcf-parse.c (predefined_filename_p): New function.\n+\t(yyparse): Check that files on the command line are specified only\n+ \tonce and issue a warning otherwise.\n+\t* parse.h (JPRIMITIVE_TYPE_OR_VOID_P): New macro.\n+\t* parse.y (source_end_java_method): Nullify NOP method bodies, to\n+ \tavoid a gcc warning with -W -Wall turned on.\n+\t(java_expand_classes): Abort if errors were encountered.\n+\t(java_complete_lhs): If the cross reference flag is set, wrap\n+ \tfield DECL node around a WFL when resolving expression name.\n+\t\n Mon Apr 19 14:44:48 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* lang.c (lang_decode_option): Fixed returned value when parsing\n@@ -6,7 +23,7 @@ Mon Apr 19 14:44:48 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n  \tflag_emit_xref is set.\n \t(resolve_expression_name): Do not build static field access when\n  \tflag_emit_xref is set.\n-\t(resolve_field_access): No special treatement on `length' when\n+\t(resolve_field_access): No special treatment on `length' when\n  \tflag_emit_xref is set. Do not build qualified static field access\n  \twhen flag_emit_xref is set.\n \t(patch_invoke): Keep the method DECL as operand 0 of the CALL_EXPR"}, {"sha": "f248ad2fb40717f03a62efa81c7d0aab40886e6d", "filename": "gcc/java/decl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -257,6 +257,8 @@ tree string_type_node;\n tree throwable_type_node;\n tree runtime_exception_type_node;\n tree error_exception_type_node;\n+tree *predef_filenames;\n+int  predef_filenames_size;\n \n tree boolean_type_node;\n \n@@ -540,6 +542,9 @@ init_decl_processing ()\n   float_zero_node = build_real (float_type_node, dconst0);\n   double_zero_node = build_real (double_type_node, dconst0);\n \n+  /* As your adding items here, please update the code right after\n+     this section, so that the filename containing the source code of\n+     the pre-defined class gets registered correctly. */\n   unqualified_object_id_node = get_identifier (\"Object\");\n   object_type_node = lookup_class (get_identifier (\"java.lang.Object\"));\n   object_ptr_type_node = promote_type (object_type_node);\n@@ -551,6 +556,17 @@ init_decl_processing ()\n   error_exception_type_node = \n     lookup_class (get_identifier (\"java.lang.Error\"));\n \n+  /* This section has to be updated as items are added to the previous\n+     section. */\n+  predef_filenames_size = 6;\n+  predef_filenames = (tree *)xmalloc (predef_filenames_size * sizeof (tree));\n+  predef_filenames [0] = get_identifier (\"java/lang/Class.java\");\n+  predef_filenames [1] = get_identifier (\"java/lang/Error.java\");\n+  predef_filenames [2] = get_identifier (\"java/lang/Object.java\");\n+  predef_filenames [3] = get_identifier (\"java/lang/RuntimeException.java\");\n+  predef_filenames [4] = get_identifier (\"java/lang/String.java\");\n+  predef_filenames [5] = get_identifier (\"java/lang/Throwable.java\");\n+\n   methodtable_type = make_node (RECORD_TYPE);\n   layout_type (methodtable_type);\n   build_decl (TYPE_DECL, get_identifier (\"methodtable\"), methodtable_type);"}, {"sha": "eb318f1f5ef32a93a2939084e282c8cde441e86f", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -202,6 +202,9 @@ extern tree throwable_type_node;\n extern tree runtime_exception_type_node;\n extern tree error_exception_type_node;\n \n+extern tree *predef_filenames;\n+extern int predef_filenames_size;\n+\n extern tree byte_array_type_node;\n extern tree short_array_type_node;\n extern tree int_array_type_node;"}, {"sha": "054c239ff72a21567b07c749f78f526948e6a4d1", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -761,6 +761,17 @@ parse_source_file (file)\n   java_parse_abort_on_error ();\n }\n \n+static int\n+predefined_filename_p (node)\n+     tree node;\n+{\n+  int i;\n+  for (i = 0; i < predef_filenames_size; i++)\n+    if (predef_filenames [i] == node)\n+      return 1;\n+  return 0;\n+}\n+\n int\n yyparse ()\n {\n@@ -780,6 +791,8 @@ yyparse ()\n       if (list[0]) \n \t{\n \t  char *value;\n+\t  tree id;\n+\t  int twice = 0;\n \n \t  int len = strlen (list);\n \t  /* FIXME: this test is only needed until our .java parser is\n@@ -792,9 +805,42 @@ yyparse ()\n \n \t  obstack_grow0 (&temporary_obstack, list, len);\n \t  value = obstack_finish (&temporary_obstack);\n-\t  node = get_identifier (value);\n-\t  IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n-\t  current_file_list = tree_cons (NULL_TREE, node, current_file_list);\n+\n+\t  /* Exclude file that we see twice on the command line. For\n+\t     all files except {Class,Error,Object,RuntimeException,String,\n+\t     Throwable}.java we can rely on maybe_get_identifier. For\n+\t     these files, we need to do a linear search of\n+\t     current_file_list. This search happens only for these\n+\t     files, presumably only when we're recompiling libgcj. */\n+\t     \n+\t  if ((id = maybe_get_identifier (value)))\n+\t    {\n+\t      if (predefined_filename_p (id))\n+\t\t{\n+\t\t  tree c;\n+\t\t  for (c = current_file_list; c; c = TREE_CHAIN (c))\n+\t\t    if (TREE_VALUE (c) == id)\n+\t\t      twice = 1;\n+\t\t}\n+\t      else\n+\t\ttwice = 1;\n+\t    }\n+\n+\t  if (twice)\n+\t    {\n+\t      char *saved_input_filename = input_filename;\n+\t      input_filename = value;\n+\t      warning (\"source file seen twice on command line and will be \"\n+\t\t       \"compiled only once.\");\n+\t      input_filename = saved_input_filename;\n+\t    }\n+\t  else\n+\t    {\n+\t      node = get_identifier (value);\n+\t      IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n+\t      current_file_list = tree_cons (NULL_TREE, node, \n+\t\t\t\t\t     current_file_list);\n+\t    }\n \t}\n       list = next;\n     }"}, {"sha": "f283692fa21f92f902027805933d291d889b7e9f", "filename": "gcc/java/parse.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -2226,7 +2226,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/x1/java/install/share/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2419,7 +2419,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/x1/java/install/share/bison.simple\"\n+#line 196 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4678,7 +4678,7 @@ case 493:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/x1/java/install/share/bison.simple\"\n+#line 498 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -8087,9 +8087,16 @@ source_end_java_method ()\n   /* Set EH language codes */\n   java_set_exception_lang_code ();\n \n+  /* Turn function bodies with only a NOP expr null, so they don't get\n+     generated at all and we won't get warnings when using the -W\n+     -Wall flags. */\n+  if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) == empty_stmt_node)\n+    BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) = NULL_TREE;\n+\n   /* Generate function's code */\n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl))\n-      && ! flag_emit_class_files)\n+      && ! flag_emit_class_files\n+      && ! flag_emit_xref)\n     expand_expr_stmt (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)));\n \n   /* pop out of its parameters */\n@@ -8098,7 +8105,7 @@ source_end_java_method ()\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   /* Generate rtl for function exit.  */\n-  if (! flag_emit_class_files)\n+  if (! flag_emit_class_files && ! flag_emit_xref)\n     {\n       lineno = DECL_SOURCE_LINE_LAST (fndecl);\n       /* Emit catch-finally clauses */\n@@ -8502,7 +8509,7 @@ java_expand_finals ()\n void\n java_expand_classes ()\n {\n-  int save_error_count = java_error_count;\n+  int save_error_count = 0;\n   java_parse_abort_on_error ();\n   if (!(ctxp = ctxp_for_generation))\n     return;\n@@ -8692,7 +8699,7 @@ resolve_expression_name (id, orig)\n \t      /* Otherwise build what it takes to access the field */\n \t      decl = build_field_ref ((fs ? NULL_TREE : current_this),\n \t\t\t\t      current_class, name);\n-\t      if (fs && !flag_emit_class_files)\n+\t      if (fs && !flag_emit_class_files && !flag_emit_xref)\n \t\tdecl = build_class_init (current_class, decl);\n \t      /* We may be asked to save the real field access node */\n \t      if (orig)\n@@ -8741,7 +8748,7 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \n   /* Resolve the LENGTH field of an array here */\n   if (DECL_NAME (decl) == length_identifier_node && TYPE_ARRAY_P (type_found)\n-      && ! flag_emit_class_files)\n+      && ! flag_emit_class_files && ! flag_emit_xref)\n     {\n       tree length = build_java_array_length_access (where_found);\n       field_ref =\n@@ -8770,7 +8777,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \t\t\t\t     type_found, DECL_NAME (decl));\n       if (field_ref == error_mark_node)\n \treturn error_mark_node;\n-      if (is_static && !static_final_found && !flag_emit_class_files)\n+      if (is_static && !static_final_found \n+\t  && !flag_emit_class_files && !flag_emit_xref)\n \t{\n \t  field_ref = build_class_init (type_found, field_ref);\n \t  /* If the static field was identified by an expression that\n@@ -9612,7 +9620,7 @@ patch_invoke (patch, method, args)\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n   \n-  if (flag_emit_class_files)\n+  if (flag_emit_class_files || flag_emit_xref)\n     func = method;\n   else\n     {\n@@ -9658,7 +9666,7 @@ patch_invoke (patch, method, args)\n     {\n       tree class = DECL_CONTEXT (method);\n       tree c1, saved_new, size, new;\n-      if (flag_emit_class_files)\n+      if (flag_emit_class_files || flag_emit_xref)\n \t{\n \t  TREE_TYPE (patch) = build_pointer_type (class);\n \t  return patch;\n@@ -10523,9 +10531,17 @@ java_complete_lhs (node)\n       if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n \t{\n+\t  tree wfl = node;\n \t  node = resolve_expression_name (node, NULL);\n \t  if (node == error_mark_node)\n \t    return node;\n+\t  /* Keep line number information somewhere were it doesn't\n+\t     disrupt the completion process. */\n+\t  if (flag_emit_xref)\n+\t    {\n+\t      EXPR_WFL_NODE (wfl) = TREE_OPERAND (node, 1);\n+\t      TREE_OPERAND (node, 1) = wfl;\n+\t    }\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t}\n       else\n@@ -11255,6 +11271,7 @@ patch_assignment (node, wfl_op1, wfl_op2)\n \n   /* 10.10: Array Store Exception runtime check */\n   if (!flag_emit_class_files\n+      && !flag_emit_xref\n       && lvalue_from_array \n       && JREFERENCE_TYPE_P (TYPE_ARRAY_ELEMENT (lhs_type))\n       && !CLASS_FINAL (TYPE_NAME (GET_SKIP_TYPE (rhs_type))))"}, {"sha": "fb489e005087d769b5c7d865db299b2bb6982a7e", "filename": "gcc/java/parse.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -177,6 +177,9 @@ extern tree stabilize_reference PROTO ((tree));\n \t\t\t\t  && (JNUMERIC_TYPE_P ((TYPE))\t\t  \\\n \t\t\t\t  || TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n \n+#define JPRIMITIVE_TYPE_OR_VOID_P(TYPE) \\\n+  (JPRIMITIVE_TYPE_P (TYPE) || ((TYPE) == void_type_node))\n+\n #define JBSC_TYPE_P(TYPE) ((TYPE) && (((TYPE) == byte_type_node)\t\\\n \t\t\t\t      || ((TYPE) == short_type_node)\t\\\n \t\t\t\t      || ((TYPE) == char_type_node)))"}, {"sha": "4652ff2d0188280e3e897f6ce78d7d90825ed318", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5423609c57f756be5db8981d4ebb11a80d44f6e9/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5423609c57f756be5db8981d4ebb11a80d44f6e9", "patch": "@@ -5486,6 +5486,12 @@ source_end_java_method ()\n   /* Set EH language codes */\n   java_set_exception_lang_code ();\n \n+  /* Turn function bodies with only a NOP expr null, so they don't get\n+     generated at all and we won't get warnings when using the -W\n+     -Wall flags. */\n+  if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) == empty_stmt_node)\n+    BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl)) = NULL_TREE;\n+\n   /* Generate function's code */\n   if (BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (fndecl))\n       && ! flag_emit_class_files\n@@ -5902,7 +5908,7 @@ java_expand_finals ()\n void\n java_expand_classes ()\n {\n-  int save_error_count = java_error_count;\n+  int save_error_count = 0;\n   java_parse_abort_on_error ();\n   if (!(ctxp = ctxp_for_generation))\n     return;\n@@ -7924,9 +7930,17 @@ java_complete_lhs (node)\n       if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n \t{\n+\t  tree wfl = node;\n \t  node = resolve_expression_name (node, NULL);\n \t  if (node == error_mark_node)\n \t    return node;\n+\t  /* Keep line number information somewhere were it doesn't\n+\t     disrupt the completion process. */\n+\t  if (flag_emit_xref)\n+\t    {\n+\t      EXPR_WFL_NODE (wfl) = TREE_OPERAND (node, 1);\n+\t      TREE_OPERAND (node, 1) = wfl;\n+\t    }\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t}\n       else"}]}