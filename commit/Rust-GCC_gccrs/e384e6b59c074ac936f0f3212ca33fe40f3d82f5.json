{"sha": "e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM4NGU2YjU5YzA3NGFjOTM2ZjBmMzIxMmNhMzNmZTQwZjNkODJmNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2012-05-14T12:08:31Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2012-05-14T12:08:31Z"}, "message": "attribs.c (decl_attributes): Avoid emitting a warning if ATTR_FLAG_BUILT_IN.\n\n\t* attribs.c (decl_attributes): Avoid emitting a warning if\n\tATTR_FLAG_BUILT_IN.\n\t* doc/rtl.texi (CALL_INSN_FUNCTION_USAGE): Use lowercase for rtx\n\tcodes.  Document meaning of sets inside CALL_INSN_FUNCTION_USAGE.\n\t* c-family/c-common.c (DEF_ATTR_STRING): Define and undefine as\n\tnecessary.\n\t* builtin-attrs.def (DEF_ATTR_FOR_STRING): Define.  Use it to\n\tdefine a string \"1\".\n\t(ATTR_RET1_NOTHROW_NONNULL_LEAF): New attr definition.\n\t* builtins.def (BUILT_IN_MEMCPY, BUILT_IN_MEMMOVE, BUILT_IN_MEMSET,\n\tBUILT_IN_STRCPY): Use it for these functions.\n\t* postreload.c (reload_combine): Deal with SETs inside\n\tCALL_INSN_FUNCTION_USAGE.\n\t* caller-save.c (setup_save_areas, save_call_clobbered_regs):\n\tLook for REG_RETURNED notes and use a cheap restore if possible.\n\t* ira-int.h (struct ira_allocno): New member cheap_calls_crossed_num.\n\t(ALLOCNO_CHEAP_CALLS_CROSSED_NUM): New macro.\n\t* ira-build.c (ira_create_allocno, create_cap_allocno,\n\tpropagate_allocno_info, propagate_some_info_from_allocno,\n\tcopy_info_to_removed_store_destination, ira_flattening): Handle it.\n\t* ira-lives.c (pseudo_regno_single_word_and_live_p,\n\tfind_call_crossed_cheap_reg): New static functions.\n\t(process_bb_node_lives): Look for SETs in CALL_INSN_FUNCTION_USAGE,\n\tand set ALLOCNO_CHEAP_CALLS_CROSSED_NUM if possible.  Also make\n\ta REG_RETURNED note in that case.\n\t* ira.c (setup_reg_renumber): Change assert to allow cases where\n\tallocnos only cross calls for which they are cheap to restore.\n\t* ira-costs.c (ira_tune_allocno_costs): Compare\n\tALLOCNO_CALLS_CROSSED_NUM to ALLOCNO_CHEAP_CALLS_CROSSED_NUM rather\n\tthan 0.\n\t* reg-notes.def (REG_RETURNED): New note.\n\t* cse.c (cse_insn): Likewise.\n\t* sched-deps.c (sched_analyze_insn): Likewise.\n\t* expr.c (init_block_move_fn): Set a \"fn spec\" attribute.\n\t* calls.c (decl_return_flags): New static function.\n\t(expand_call): Generate a SET in CALL_INSN_FUNCTION_USAGE for\n\tfunctions that return one of their arguments.\n\t* lto/lto-lang.c (handle_fnspec_attribute): New static function.\n\t(lto_attribute_table): Add \"fn spec\".\n\t(DEF_ATTR_STRING): Define and undefine along with the other macros.\n\t* regcprop.c (struct kill_set_value_data): New.\n\t(kill_set_value): Interpret data as a pointer to such a struct.\n\tDo nothing if the caller wants the register to be ignored.\n\t(copyprop_hardreg_forward_1): Handle SETs in CALL_INSN_FUNCTION_USAGE.\n\ntestsuite/\n\t* gcc.target/i386/retarg.c: New test.\n\nFrom-SVN: r187459", "tree": {"sha": "f9965bd4902a6a182ee0908a0ebd8e8bbd34a1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9965bd4902a6a182ee0908a0ebd8e8bbd34a1cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/comments", "author": null, "committer": null, "parents": [{"sha": "92290a187e25ed1b21ff99de259421e7b540349e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92290a187e25ed1b21ff99de259421e7b540349e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92290a187e25ed1b21ff99de259421e7b540349e"}], "stats": {"total": 422, "additions": 383, "deletions": 39}, "files": [{"sha": "bd8f7759033248e5250c7f61aea3f6c0506d7b1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -1,3 +1,50 @@\n+2012-05-14  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* attribs.c (decl_attributes): Avoid emitting a warning if\n+\tATTR_FLAG_BUILT_IN.\n+\t* doc/rtl.texi (CALL_INSN_FUNCTION_USAGE): Use lowercase for rtx\n+\tcodes.  Document meaning of sets inside CALL_INSN_FUNCTION_USAGE.\n+\t* c-family/c-common.c (DEF_ATTR_STRING): Define and undefine as\n+\tnecessary.\n+\t* builtin-attrs.def (DEF_ATTR_FOR_STRING): Define.  Use it to\n+\tdefine a string \"1\".\n+\t(ATTR_RET1_NOTHROW_NONNULL_LEAF): New attr definition.\n+\t* builtins.def (BUILT_IN_MEMCPY, BUILT_IN_MEMMOVE, BUILT_IN_MEMSET,\n+\tBUILT_IN_STRCPY): Use it for these functions.\n+\t* postreload.c (reload_combine): Deal with SETs inside\n+\tCALL_INSN_FUNCTION_USAGE.\n+\t* caller-save.c (setup_save_areas, save_call_clobbered_regs):\n+\tLook for REG_RETURNED notes and use a cheap restore if possible.\n+\t* ira-int.h (struct ira_allocno): New member cheap_calls_crossed_num.\n+\t(ALLOCNO_CHEAP_CALLS_CROSSED_NUM): New macro.\n+\t* ira-build.c (ira_create_allocno, create_cap_allocno,\n+\tpropagate_allocno_info, propagate_some_info_from_allocno,\n+\tcopy_info_to_removed_store_destination, ira_flattening): Handle it.\n+\t* ira-lives.c (pseudo_regno_single_word_and_live_p,\n+\tfind_call_crossed_cheap_reg): New static functions.\n+\t(process_bb_node_lives): Look for SETs in CALL_INSN_FUNCTION_USAGE,\n+\tand set ALLOCNO_CHEAP_CALLS_CROSSED_NUM if possible.  Also make\n+\ta REG_RETURNED note in that case.\n+\t* ira.c (setup_reg_renumber): Change assert to allow cases where\n+\tallocnos only cross calls for which they are cheap to restore.\n+\t* ira-costs.c (ira_tune_allocno_costs): Compare\n+\tALLOCNO_CALLS_CROSSED_NUM to ALLOCNO_CHEAP_CALLS_CROSSED_NUM rather\n+\tthan 0.\n+\t* reg-notes.def (REG_RETURNED): New note.\n+\t* cse.c (cse_insn): Likewise.\n+\t* sched-deps.c (sched_analyze_insn): Likewise.\n+\t* expr.c (init_block_move_fn): Set a \"fn spec\" attribute.\n+\t* calls.c (decl_return_flags): New static function.\n+\t(expand_call): Generate a SET in CALL_INSN_FUNCTION_USAGE for\n+\tfunctions that return one of their arguments.\n+\t* lto/lto-lang.c (handle_fnspec_attribute): New static function.\n+\t(lto_attribute_table): Add \"fn spec\".\n+\t(DEF_ATTR_STRING): Define and undefine along with the other macros.\n+\t* regcprop.c (struct kill_set_value_data): New.\n+\t(kill_set_value): Interpret data as a pointer to such a struct.\n+\tDo nothing if the caller wants the register to be ignored.\n+\t(copyprop_hardreg_forward_1): Handle SETs in CALL_INSN_FUNCTION_USAGE.\n+\n 2012-05-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/53340"}, {"sha": "ce480208f99748ed18baa270e095bd42b74f4af1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -5902,11 +5902,13 @@ enum built_in_attribute\n {\n #define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n #define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n #define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n #include \"builtin-attrs.def\"\n #undef DEF_ATTR_NULL_TREE\n #undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n   ATTR_LAST\n@@ -5922,6 +5924,8 @@ install_builtin_attributes (void)\n   built_in_attributes[(int) ENUM] = NULL_TREE;\n #define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);\n #define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = get_identifier (STRING);\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n@@ -5932,6 +5936,7 @@ install_builtin_attributes (void)\n #include \"builtin-attrs.def\"\n #undef DEF_ATTR_NULL_TREE\n #undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n }"}, {"sha": "d3af4141f4e4660f0262dd2b06d00bada26df112", "filename": "gcc/attribs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -312,8 +312,9 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n       if (spec == NULL)\n \t{\n-\t  warning (OPT_Wattributes, \"%qE attribute directive ignored\",\n-\t\t   name);\n+\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n+\t    warning (OPT_Wattributes, \"%qE attribute directive ignored\",\n+\t\t     name);\n \t  continue;\n \t}\n       else if (list_length (args) < spec->min_length"}, {"sha": "9eb5e71c9b4eef452b37e4b734e705a3ad487125", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -59,6 +59,14 @@ DEF_ATTR_FOR_INT (5)\n DEF_ATTR_FOR_INT (6)\n #undef DEF_ATTR_FOR_INT\n \n+/* Construct a tree for a given string and a list containing it.  */\n+#define DEF_ATTR_FOR_STRING(ENUM, VALUE)\t\t\t\t\t\\\n+  DEF_ATTR_STRING (ATTR_##ENUM, VALUE)\t\t\t\\\n+  DEF_ATTR_TREE_LIST (ATTR_LIST_##ENUM, ATTR_NULL,\t\\\n+\t\t      ATTR_##ENUM, ATTR_NULL)\n+DEF_ATTR_FOR_STRING (STR1, \"1\")\n+#undef DEF_ATTR_FOR_STRING\n+\n /* Construct a tree for a list of two integers.  */\n #define DEF_LIST_INT_INT(VALUE1, VALUE2)\t\t\t\t \\\n   DEF_ATTR_TREE_LIST (ATTR_LIST_##VALUE1##_##VALUE2, ATTR_NULL,\t\t \\\n@@ -84,6 +92,7 @@ DEF_ATTR_IDENT (ATTR_NONNULL, \"nonnull\")\n DEF_ATTR_IDENT (ATTR_NORETURN, \"noreturn\")\n DEF_ATTR_IDENT (ATTR_NOTHROW, \"nothrow\")\n DEF_ATTR_IDENT (ATTR_LEAF, \"leaf\")\n+DEF_ATTR_IDENT (ATTR_FNSPEC, \"fn spec\")\n DEF_ATTR_IDENT (ATTR_PRINTF, \"printf\")\n DEF_ATTR_IDENT (ATTR_ASM_FPRINTF, \"asm_fprintf\")\n DEF_ATTR_IDENT (ATTR_GCC_DIAG, \"gcc_diag\")\n@@ -170,6 +179,10 @@ DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_5, ATTR_NONNULL, ATTR_LIST_5, \\\n /* Nothrow const functions whose pointer parameter(s) are all nonnull.  */\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL, ATTR_CONST, ATTR_NULL, \\\n \t\t\tATTR_NOTHROW_NONNULL)\n+/* Nothrow leaf functions whose pointer parameter(s) are all nonnull,\n+   and which return their first argument.  */\n+DEF_ATTR_TREE_LIST (ATTR_RET1_NOTHROW_NONNULL_LEAF, ATTR_FNSPEC, ATTR_LIST_STR1, \\\n+\t\t\tATTR_NOTHROW_NONNULL_LEAF)\n /* Nothrow const leaf functions whose pointer parameter(s) are all nonnull.  */\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL_LEAF, ATTR_CONST, ATTR_NULL, \\\n \t\t\tATTR_NOTHROW_NONNULL_LEAF)"}, {"sha": "de45724998eaeb97907ebfbeb11fcd3810791398", "filename": "gcc/builtins.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -532,18 +532,18 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_BZERO, \"bzero\", BT_FN_VOID_PTR_SIZE, ATTR_NOTHR\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_INDEX, \"index\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_MEMCHR, \"memchr\", BT_FN_PTR_CONST_PTR_INT_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_MEMCMP, \"memcmp\", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_MEMCPY, \"memcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_MEMMOVE, \"memmove\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_MEMCPY, \"memcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_MEMMOVE, \"memmove\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY, \"mempcpy\", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_MEMSET, \"memset\", BT_FN_PTR_PTR_INT_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_MEMSET, \"memset\", BT_FN_PTR_PTR_INT_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_RINDEX, \"rindex\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY, \"stpcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPNCPY, \"stpncpy\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCASECMP, \"strcasecmp\", BT_FN_INT_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCAT, \"strcat\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCHR, \"strchr\", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCMP, \"strcmp\", BT_FN_INT_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n-DEF_LIB_BUILTIN        (BUILT_IN_STRCPY, \"strcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_LIB_BUILTIN        (BUILT_IN_STRCPY, \"strcpy\", BT_FN_STRING_STRING_CONST_STRING, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_STRCSPN, \"strcspn\", BT_FN_SIZE_CONST_STRING_CONST_STRING, ATTR_PURE_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRDUP, \"strdup\", BT_FN_STRING_CONST_STRING, ATTR_MALLOC_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNDUP, \"strndup\", BT_FN_STRING_CONST_STRING_SIZE, ATTR_MALLOC_NOTHROW_NONNULL_LEAF)\n@@ -757,8 +757,8 @@ DEF_BUILTIN_STUB (BUILT_IN_ALLOCA_WITH_ALIGN, \"__builtin_alloca_with_align\")\n \n /* Object size checking builtins.  */\n DEF_GCC_BUILTIN\t       (BUILT_IN_OBJECT_SIZE, \"object_size\", BT_FN_SIZE_CONST_PTR_INT, ATTR_PURE_NOTHROW_LEAF_LIST)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, \"__memmove_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, \"__memmove_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY_CHK, \"__mempcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMSET_CHK, \"__memset_chk\", BT_FN_PTR_PTR_INT_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY_CHK, \"__stpcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)"}, {"sha": "f32a94a7c65a14d3f0253ccacb06efaf85f88eb5", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -4603,11 +4603,13 @@ enum built_in_attribute\n {\n #define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n #define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n #define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n #include \"builtin-attrs.def\"\n #undef DEF_ATTR_NULL_TREE\n #undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n   ATTR_LAST\n@@ -5926,6 +5928,8 @@ c_init_attributes (void)\n   built_in_attributes[(int) ENUM] = NULL_TREE;\n #define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = build_int_cst (integer_type_node, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);\n #define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = get_identifier (STRING);\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\"}, {"sha": "c8f3b145946e9060db28504bd42fcb415bab9063", "filename": "gcc/caller-save.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -433,6 +433,8 @@ setup_save_areas (void)\n   /* Create hard reg saved regs.  */\n   for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n+      rtx cheap;\n+\n       insn = chain->insn;\n       next = chain->next;\n       if (!CALL_P (insn)\n@@ -466,14 +468,17 @@ setup_save_areas (void)\n \t      new_saved_hard_reg (regno, freq);\n \t    SET_HARD_REG_BIT (hard_regs_used, regno);\n \t  }\n+      cheap = find_reg_note (insn, REG_RETURNED, NULL);\n+      if (cheap)\n+\tcheap = XEXP (cheap, 0);\n       /* Look through all live pseudos, mark their hard registers.  */\n       EXECUTE_IF_SET_IN_REG_SET\n \t(&chain->live_throughout, FIRST_PSEUDO_REGISTER, regno, rsi)\n \t{\n \t  int r = reg_renumber[regno];\n \t  int bound;\n \n-\t  if (r < 0)\n+\t  if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t    continue;\n \n \t  bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n@@ -508,12 +513,18 @@ setup_save_areas (void)\n       memset (saved_reg_conflicts, 0, saved_regs_num * saved_regs_num);\n       for (chain = reload_insn_chain; chain != 0; chain = next)\n \t{\n+\t  rtx cheap;\n \t  call_saved_regs_num = 0;\n \t  insn = chain->insn;\n \t  next = chain->next;\n \t  if (!CALL_P (insn)\n \t      || find_reg_note (insn, REG_NORETURN, NULL))\n \t    continue;\n+\n+\t  cheap = find_reg_note (insn, REG_RETURNED, NULL);\n+\t  if (cheap)\n+\t    cheap = XEXP (cheap, 0);\n+\n \t  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,\n \t\t\t\t   &chain->live_throughout);\n \t  COPY_HARD_REG_SET (used_regs, call_used_reg_set);\n@@ -546,7 +557,7 @@ setup_save_areas (void)\n \t      int r = reg_renumber[regno];\n \t      int bound;\n \n-\t      if (r < 0)\n+\t      if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t\tcontinue;\n \n \t      bound = r + hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n@@ -796,6 +807,11 @@ save_call_clobbered_regs (void)\n \t      unsigned regno;\n \t      HARD_REG_SET hard_regs_to_save;\n \t      reg_set_iterator rsi;\n+\t      rtx cheap;\n+\n+\t      cheap = find_reg_note (insn, REG_RETURNED, NULL);\n+\t      if (cheap)\n+\t\tcheap = XEXP (cheap, 0);\n \n \t      /* Use the register life information in CHAIN to compute which\n \t\t regs are live during the call.  */\n@@ -817,7 +833,7 @@ save_call_clobbered_regs (void)\n \t\t  int nregs;\n \t\t  enum machine_mode mode;\n \n-\t\t  if (r < 0)\n+\t\t  if (r < 0 || regno_reg_rtx[regno] == cheap)\n \t\t    continue;\n \t\t  nregs = hard_regno_nregs[r][PSEUDO_REGNO_MODE (regno)];\n \t\t  mode = HARD_REGNO_CALLER_SAVE_MODE\n@@ -851,6 +867,17 @@ save_call_clobbered_regs (void)\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (hard_regs_saved, regno))\n \t\t  n_regs_saved++;\n+\t      \n+\t      if (cheap\n+\t\t  && HARD_REGISTER_P (cheap)\n+\t\t  && TEST_HARD_REG_BIT (call_used_reg_set, REGNO (cheap)))\n+\t\t{\n+\t\t  rtx call_set = single_set (insn);\n+\t\t  rtx dest = SET_DEST (call_set);\n+\t\t  rtx pat = gen_rtx_SET (VOIDmode, cheap,\n+\t\t\t\t\t copy_rtx (dest));\n+\t\t  chain = insert_one_insn (chain, 0, -1, pat);\n+\t\t}\n \t    }\n           last = chain;\n \t}"}, {"sha": "03c92168a24e5c76015e7189ac2f888002edd623", "filename": "gcc/calls.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -574,6 +574,41 @@ special_function_p (const_tree fndecl, int flags)\n   return flags;\n }\n \n+/* Similar to special_function_p; return a set of ERF_ flags for the\n+   function FNDECL.  */\n+static int\n+decl_return_flags (tree fndecl)\n+{\n+  tree attr;\n+  tree type = TREE_TYPE (fndecl);\n+  if (!type)\n+    return 0;\n+\n+  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+  if (!attr)\n+    return 0;\n+\n+  attr = TREE_VALUE (TREE_VALUE (attr));\n+  if (!attr || TREE_STRING_LENGTH (attr) < 1)\n+    return 0;\n+\n+  switch (TREE_STRING_POINTER (attr)[0])\n+    {\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+      return ERF_RETURNS_ARG | (TREE_STRING_POINTER (attr)[0] - '1');\n+\n+    case 'm':\n+      return ERF_NOALIAS;\n+\n+    case '.':\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Return nonzero when FNDECL represents a call to setjmp.  */\n \n int\n@@ -2247,8 +2282,9 @@ expand_call (tree exp, rtx target, int ignore)\n      (on machines that lack push insns), or 0 if space not preallocated.  */\n   rtx argblock = 0;\n \n-  /* Mask of ECF_ flags.  */\n+  /* Mask of ECF_ and ERF_ flags.  */\n   int flags = 0;\n+  int return_flags = 0;\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      saved, if any.  */\n@@ -2293,6 +2329,7 @@ expand_call (tree exp, rtx target, int ignore)\n     {\n       fntype = TREE_TYPE (fndecl);\n       flags |= flags_from_decl_or_type (fndecl);\n+      return_flags |= decl_return_flags (fndecl);\n     }\n   else\n     {\n@@ -3105,6 +3142,20 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t\t\t   VOIDmode, void_type_node,\n \t\t\t\t\t\t   true);\n \n+      if (pass == 1 && (return_flags & ERF_RETURNS_ARG))\n+\t{\n+\t  int arg_nr = return_flags & ERF_RETURN_ARG_MASK;\n+\t  if (PUSH_ARGS_REVERSED)\n+\t    arg_nr = num_actuals - arg_nr - 1;\n+\t  if (args[arg_nr].reg\n+\t      && valreg\n+\t      && REG_P (valreg)\n+\t      && GET_MODE (args[arg_nr].reg) == GET_MODE (valreg))\n+\t  call_fusage\n+\t    = gen_rtx_EXPR_LIST (TYPE_MODE (TREE_TYPE (args[arg_nr].tree_value)),\n+\t\t\t\t gen_rtx_SET (VOIDmode, valreg, args[arg_nr].reg),\n+\t\t\t\t call_fusage);\n+\t}\n       /* All arguments and registers used for the call must be set up by\n \t now!  */\n "}, {"sha": "0ad7b2e2a46cd141c4e6ddacedbb9e013f95a954", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -4312,7 +4312,8 @@ canonicalize_insn (rtx insn, struct set **psets, int n_sets)\n   if (CALL_P (insn))\n     {\n       for (tem = CALL_INSN_FUNCTION_USAGE (insn); tem; tem = XEXP (tem, 1))\n-\tXEXP (tem, 0) = canon_reg (XEXP (tem, 0), insn);\n+\tif (GET_CODE (XEXP (tem, 0)) != SET)\n+\t  XEXP (tem, 0) = canon_reg (XEXP (tem, 0), insn);\n     }\n \n   if (GET_CODE (x) == SET && GET_CODE (SET_SRC (x)) == CALL)"}, {"sha": "3f8c094bfa0a329b0e3750ad3efd7437a4814883", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -3455,20 +3455,26 @@ unpredictably.\n @code{call_insn} insns have the same extra fields as @code{insn} insns,\n accessed in the same way and in addition contain a field\n @code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of\n-@code{expr_list} expressions) containing @code{use} and @code{clobber}\n-expressions that denote hard registers and @code{MEM}s used or\n-clobbered by the called function.\n+@code{expr_list} expressions) containing @code{use}, @code{clobber} and\n+sometimes @code{set} expressions that denote hard registers and\n+@code{mem}s used or clobbered by the called function.\n \n-A @code{MEM} generally points to a stack slots in which arguments passed\n+A @code{mem} generally points to a stack slot in which arguments passed\n to the libcall by reference (@pxref{Register Arguments,\n TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is\n caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),\n-the stack slot will be mentioned in @code{CLOBBER} and @code{USE}\n-entries; if it's callee-copied, only a @code{USE} will appear, and the\n-@code{MEM} may point to addresses that are not stack slots.\n-\n-@code{CLOBBER}ed registers in this list augment registers specified in\n-@code{CALL_USED_REGISTERS} (@pxref{Register Basics}).\n+the stack slot will be mentioned in @code{clobber} and @code{use}\n+entries; if it's callee-copied, only a @code{use} will appear, and the\n+@code{mem} may point to addresses that are not stack slots.\n+\n+Registers occurring inside a @code{clobber} in this list augment\n+registers specified in @code{CALL_USED_REGISTERS} (@pxref{Register\n+Basics}).\n+\n+If the list contains a @code{set} involving two registers, it indicates\n+that the function returns one of its arguments.  Such a @code{set} may\n+look like a no-op if the same register holds the argument and the return\n+value.\n \n @findex code_label\n @findex CODE_LABEL_NUMBER"}, {"sha": "0d52725ae070c0f1a4c25aa2fcf4d8b8022499c8", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -1386,7 +1386,7 @@ init_block_move_fn (const char *asmspec)\n {\n   if (!block_move_fn)\n     {\n-      tree args, fn;\n+      tree args, fn, attrs, attr_args;\n \n       fn = get_identifier (\"memcpy\");\n       args = build_function_type_list (ptr_type_node, ptr_type_node,\n@@ -1401,6 +1401,11 @@ init_block_move_fn (const char *asmspec)\n       DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;\n       DECL_VISIBILITY_SPECIFIED (fn) = 1;\n \n+      attr_args = build_tree_list (NULL_TREE, build_string (1, \"1\"));\n+      attrs = tree_cons (get_identifier (\"fn spec\"), attr_args, NULL);\n+\n+      decl_attributes (&fn, attrs, ATTR_FLAG_BUILT_IN);\n+\n       block_move_fn = fn;\n     }\n \n@@ -8190,10 +8195,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t      || DECL_RTL (treeop1) == stack_pointer_rtx\n \t      || DECL_RTL (treeop1) == arg_pointer_rtx))\n \t{\n-\t  tree t = treeop1;\n-\n-\t  treeop1 = TREE_OPERAND (treeop0, 0);\n-\t  TREE_OPERAND (treeop0, 0) = t;\n+\t  gcc_unreachable ();\n \t}\n \n       /* If the result is to be ptr_mode and we are adding an integer to"}, {"sha": "2edab52b1e5ca7992cf57e25e42b3d7de8b7e137", "filename": "gcc/ira-build.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -508,6 +508,7 @@ ira_create_allocno (int regno, bool cap_p,\n   ALLOCNO_HARD_REGNO (a) = -1;\n   ALLOCNO_CALL_FREQ (a) = 0;\n   ALLOCNO_CALLS_CROSSED_NUM (a) = 0;\n+  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a) = 0;\n #ifdef STACK_REGS\n   ALLOCNO_NO_STACK_REG_P (a) = false;\n   ALLOCNO_TOTAL_NO_STACK_REG_P (a) = false;\n@@ -904,6 +905,7 @@ create_cap_allocno (ira_allocno_t a)\n   merge_hard_reg_conflicts (a, cap, false);\n \n   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);\n+  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (cap) = ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     {\n       fprintf (ira_dump_file, \"    Creating cap \");\n@@ -1707,6 +1709,8 @@ propagate_allocno_info (void)\n \t  merge_hard_reg_conflicts (a, parent_a, true);\n \t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n+\t  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n+\t    += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t  aclass = ALLOCNO_CLASS (a);\n@@ -2082,6 +2086,8 @@ propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n   ALLOCNO_FREQ (a) += ALLOCNO_FREQ (from_a);\n   ALLOCNO_CALL_FREQ (a) += ALLOCNO_CALL_FREQ (from_a);\n   ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);\n+  ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)\n+    += ALLOCNO_CHEAP_CALLS_CROSSED_NUM (from_a);\n   ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a)\n     += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);\n   if (! ALLOCNO_BAD_SPILL_P (from_a))\n@@ -2709,6 +2715,8 @@ copy_info_to_removed_store_destinations (int regno)\n       ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n       ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n+      ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n+\t+= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n       ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t+= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n       merged_p = true;\n@@ -2804,6 +2812,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      ALLOCNO_CALL_FREQ (parent_a) -= ALLOCNO_CALL_FREQ (a);\n \t      ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t\t-= ALLOCNO_CALLS_CROSSED_NUM (a);\n+\t      ALLOCNO_CHEAP_CALLS_CROSSED_NUM (parent_a)\n+\t\t-= ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a);\n \t      ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n \t\t-= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n \t      ira_assert (ALLOCNO_CALLS_CROSSED_NUM (parent_a) >= 0"}, {"sha": "5d061942f8367c59e901486752530525eb9e037e", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -2107,7 +2107,8 @@ ira_tune_allocno_costs (void)\n       mode = ALLOCNO_MODE (a);\n       n = ira_class_hard_regs_num[aclass];\n       min_cost = INT_MAX;\n-      if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+      if (ALLOCNO_CALLS_CROSSED_NUM (a)\n+\t  != ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a))\n \t{\n \t  ira_allocate_and_set_costs\n \t    (&ALLOCNO_HARD_REG_COSTS (a), aclass,"}, {"sha": "02bec132614c3da9a7798bc31b7c4428b9735335", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -376,6 +376,9 @@ struct ira_allocno\n   int call_freq;\n   /* Accumulated number of the intersected calls.  */\n   int calls_crossed_num;\n+  /* The number of calls across which it is live, but which should not\n+     affect register preferences.  */\n+  int cheap_calls_crossed_num;\n   /* Array of usage costs (accumulated and the one updated during\n      coloring) for each hard register of the allocno class.  The\n      member value can be NULL if all costs are the same and equal to\n@@ -418,6 +421,7 @@ struct ira_allocno\n #define ALLOCNO_HARD_REGNO(A) ((A)->hard_regno)\n #define ALLOCNO_CALL_FREQ(A) ((A)->call_freq)\n #define ALLOCNO_CALLS_CROSSED_NUM(A) ((A)->calls_crossed_num)\n+#define ALLOCNO_CHEAP_CALLS_CROSSED_NUM(A) ((A)->cheap_calls_crossed_num)\n #define ALLOCNO_MEM_OPTIMIZED_DEST(A) ((A)->mem_optimized_dest)\n #define ALLOCNO_MEM_OPTIMIZED_DEST_P(A) ((A)->mem_optimized_dest_p)\n #define ALLOCNO_SOMEWHERE_RENAMED_P(A) ((A)->somewhere_renamed_p)"}, {"sha": "ad451f5b3f971ee73e684d845f6e5784f8ed001d", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -241,6 +241,24 @@ dec_register_pressure (enum reg_class pclass, int nregs)\n     }\n }\n \n+/* Determine from the objects_live bitmap whether REGNO is currently live,\n+   and occupies only one object.  Return false if we have no information.  */\n+static bool\n+pseudo_regno_single_word_and_live_p (int regno)\n+{\n+  ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  ira_object_t obj;\n+\n+  if (a == NULL)\n+    return false;\n+  if (ALLOCNO_NUM_OBJECTS (a) > 1)\n+    return false;\n+\n+  obj = ALLOCNO_OBJECT (a, 0);\n+\n+  return sparseset_bit_p (objects_live, OBJECT_CONFLICT_ID (obj));\n+}\n+\n /* Mark the pseudo register REGNO as live.  Update all information about\n    live ranges and register pressure.  */\n static void\n@@ -1043,6 +1061,67 @@ bb_has_abnormal_call_pred (basic_block bb)\n   return false;\n }\n \n+/* Look through the CALL_INSN_FUNCTION_USAGE of a call insn INSN, and see if\n+   we find a SET rtx that we can use to deduce that a register can be cheaply\n+   caller-saved.  Return such a register, or NULL_RTX if none is found.  */\n+static rtx\n+find_call_crossed_cheap_reg (rtx insn)\n+{\n+  rtx cheap_reg = NULL_RTX;\n+  rtx exp = CALL_INSN_FUNCTION_USAGE (insn);\n+\n+  while (exp != NULL)\n+    {\n+      rtx x = XEXP (exp, 0);\n+      if (GET_CODE (x) == SET)\n+\t{\n+\t  exp = x;\n+\t  break;\n+\t}\n+      exp = XEXP (exp, 1);\n+    }\n+  if (exp != NULL)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (insn);\n+      rtx reg = SET_SRC (exp);\n+      rtx prev = PREV_INSN (insn);\n+      while (prev && !(INSN_P (prev)\n+\t\t       && BLOCK_FOR_INSN (prev) != bb))\n+\t{\n+\t  if (NONDEBUG_INSN_P (prev))\n+\t    {\n+\t      rtx set = single_set (prev);\n+\n+\t      if (set && rtx_equal_p (SET_DEST (set), reg))\n+\t\t{\n+\t\t  rtx src = SET_SRC (set);\n+\t\t  if (!REG_P (src) || HARD_REGISTER_P (src)\n+\t\t      || !pseudo_regno_single_word_and_live_p (REGNO (src)))\n+\t\t    break;\n+\t\t  if (!modified_between_p (src, prev, insn))\n+\t\t    cheap_reg = src;\n+\t\t  break;\n+\t\t}\n+\t      if (set && rtx_equal_p (SET_SRC (set), reg))\n+\t\t{\n+\t\t  rtx dest = SET_DEST (set);\n+\t\t  if (!REG_P (dest) || HARD_REGISTER_P (dest)\n+\t\t      || !pseudo_regno_single_word_and_live_p (REGNO (dest)))\n+\t\t    break;\n+\t\t  if (!modified_between_p (dest, prev, insn))\n+\t\t    cheap_reg = dest;\n+\t\t  break;\n+\t\t}\n+\n+\t      if (reg_overlap_mentioned_p (reg, PATTERN (prev)))\n+\t\tbreak;\n+\t    }\n+\t  prev = PREV_INSN (prev);\n+\t}\n+    }\n+  return cheap_reg;\n+}  \n+\n /* Process insns of the basic block given by its LOOP_TREE_NODE to\n    update allocno live ranges, allocno hard register conflicts,\n    intersected calls, and register pressure info for allocnos for the\n@@ -1185,6 +1264,13 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \n \t  if (call_p)\n \t    {\n+\t      /* Try to find a SET in the CALL_INSN_FUNCTION_USAGE, and from\n+\t\t there, try to find a pseudo that is live across the call but\n+\t\t can be cheaply reconstructed from the return value.  */\n+\t      rtx cheap_reg = find_call_crossed_cheap_reg (insn);\n+\t      if (cheap_reg != NULL_RTX)\n+\t\tadd_reg_note (insn, REG_RETURNED, cheap_reg);\n+\n \t      last_call_num++;\n \t      sparseset_clear (allocnos_processed);\n \t      /* The current set of live allocnos are live across the call.  */\n@@ -1226,6 +1312,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t  /* Mark it as saved at the next call.  */\n \t\t  allocno_saved_at_call[num] = last_call_num + 1;\n \t\t  ALLOCNO_CALLS_CROSSED_NUM (a)++;\n+\t\t  if (cheap_reg != NULL_RTX\n+\t\t      && ALLOCNO_REGNO (a) == (int) REGNO (cheap_reg))\n+\t\t    ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a)++;\n \t\t}\n \t    }\n "}, {"sha": "4d1ff0efb3a091929965833eb7de1fef08629e6c", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -1962,6 +1962,8 @@ setup_reg_renumber (void)\n \t\t\t\t\t\t  call_used_reg_set))\n \t    {\n \t      ira_assert (!optimize || flag_caller_saves\n+\t\t\t  || (ALLOCNO_CALLS_CROSSED_NUM (a)\n+\t\t\t      == ALLOCNO_CHEAP_CALLS_CROSSED_NUM (a))\n \t\t\t  || regno >= ira_reg_equiv_len\n \t\t\t  || ira_reg_equiv_const[regno]\n \t\t\t  || ira_reg_equiv_invariant_p[regno]);"}, {"sha": "280d88359deae2a727a9973273a8a0a4cbb91197", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -53,6 +53,7 @@ static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n static tree ignore_attribute (tree *, tree, tree, int, bool *);\n \n static tree handle_format_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n \n /* Table of machine-independent attributes supported in GIMPLE.  */\n@@ -83,6 +84,8 @@ const struct attribute_spec lto_attribute_table[] =\n \t\t\t      handle_sentinel_attribute, false },\n   { \"type generic\",           0, 0, false, true, true,\n \t\t\t      handle_type_generic_attribute, false },\n+  { \"fn spec\",\t \t      1, 1, false, true, true,\n+\t\t\t      handle_fnspec_attribute, false },\n   { \"transaction_pure\",\t      0, 0, false, true, true,\n \t\t\t      handle_transaction_pure_attribute, false },\n   /* For internal use only.  The leading '*' both prevents its usage in\n@@ -110,11 +113,13 @@ enum built_in_attribute\n {\n #define DEF_ATTR_NULL_TREE(ENUM) ENUM,\n #define DEF_ATTR_INT(ENUM, VALUE) ENUM,\n+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,\n #define DEF_ATTR_IDENT(ENUM, STRING) ENUM,\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,\n #include \"builtin-attrs.def\"\n #undef DEF_ATTR_NULL_TREE\n #undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n   ATTR_LAST\n@@ -483,6 +488,20 @@ handle_format_arg_attribute (tree * ARG_UNUSED (node), tree ARG_UNUSED (name),\n }\n \n \n+/* Handle a \"fn spec\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n+\t\t\t tree args, int ARG_UNUSED (flags),\n+\t\t\t bool *no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (args\n+\t      && TREE_CODE (TREE_VALUE (args)) == STRING_CST\n+\t      && !TREE_CHAIN (args));\n+  return NULL_TREE;\n+}\n+\n /* Cribbed from c-common.c.  */\n \n static void\n@@ -568,6 +587,8 @@ lto_init_attributes (void)\n   built_in_attributes[(int) ENUM] = NULL_TREE;\n #define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);\n+#define DEF_ATTR_STRING(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);\n #define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = get_identifier (STRING);\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\\n@@ -578,6 +599,7 @@ lto_init_attributes (void)\n #include \"builtin-attrs.def\"\n #undef DEF_ATTR_NULL_TREE\n #undef DEF_ATTR_INT\n+#undef DEF_ATTR_STRING\n #undef DEF_ATTR_IDENT\n #undef DEF_ATTR_TREE_LIST\n }"}, {"sha": "7f333063e19879a477fbd3b74d6ea901c40d5781", "filename": "gcc/postreload.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -1358,8 +1358,10 @@ reload_combine (void)\n \t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n \t       link = XEXP (link, 1))\n \t    {\n-\t      rtx usage_rtx = XEXP (XEXP (link, 0), 0);\n-\t      if (REG_P (usage_rtx))\n+\t      rtx setuse = XEXP (link, 0);\n+\t      rtx usage_rtx = XEXP (setuse, 0);\n+\t      if ((GET_CODE (setuse) == USE || GET_CODE (setuse) == CLOBBER)\n+\t\t  && REG_P (usage_rtx))\n \t        {\n \t\t  unsigned int i;\n \t\t  unsigned int start_reg = REGNO (usage_rtx);"}, {"sha": "640abb217d5ff44a9f6c6fe754c134cd738328fb", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -212,3 +212,8 @@ REG_NOTE (TM)\n    for pushed arguments.  This will only be generated when\n    ACCUMULATE_OUTGOING_ARGS is false.  */\n REG_NOTE (ARGS_SIZE)\n+\n+/* Used for communication between IRA and caller-save.c, indicates\n+   that the return value of a call can be used to reinitialize a\n+   pseudo reg.  */\n+REG_NOTE (RETURNED)"}, {"sha": "4d6ea29f7f7c2c9055e775e289ee7c704afdbfcf", "filename": "gcc/regcprop.c", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -254,18 +254,27 @@ kill_clobbered_value (rtx x, const_rtx set, void *data)\n     kill_value (x, vd);\n }\n \n+/* A structure passed as data to kill_set_value through note_stores.  */\n+struct kill_set_value_data\n+{\n+  struct value_data *vd;\n+  rtx ignore_set_reg;\n+};\n+  \n /* Called through note_stores.  If X is set, not clobbered, kill its\n    current value and install it as the root of its own value list.  */\n \n static void\n kill_set_value (rtx x, const_rtx set, void *data)\n {\n-  struct value_data *const vd = (struct value_data *) data;\n+  struct kill_set_value_data *ksvd = (struct kill_set_value_data *) data;\n+  if (rtx_equal_p (x, ksvd->ignore_set_reg))\n+    return;\n   if (GET_CODE (set) != CLOBBER)\n     {\n-      kill_value (x, vd);\n+      kill_value (x, ksvd->vd);\n       if (REG_P (x))\n-\tset_value_regno (REGNO (x), GET_MODE (x), vd);\n+\tset_value_regno (REGNO (x), GET_MODE (x), ksvd->vd);\n     }\n }\n \n@@ -743,6 +752,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       rtx set;\n       bool replaced[MAX_RECOG_OPERANDS];\n       bool changed = false;\n+      struct kill_set_value_data ksvd;\n \n       if (!NONDEBUG_INSN_P (insn))\n \t{\n@@ -976,14 +986,39 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t    note_uses (&PATTERN (insn), cprop_find_used_regs, vd);\n \t}\n \n+      ksvd.vd = vd;\n+      ksvd.ignore_set_reg = NULL_RTX;\n+\n       /* Clobber call-clobbered registers.  */\n       if (CALL_P (insn))\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n-\t    kill_value_regno (i, 1, vd);\n+\t{\n+\t  int set_regno = INVALID_REGNUM;\n+\t  int set_nregs = 0;\n+\t  rtx exp;\n+\t  for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))\n+\t    {\n+\t      rtx x = XEXP (exp, 0);\n+\t      if (GET_CODE (x) == SET)\n+\t\t{\n+\t\t  rtx dest = SET_DEST (x);\n+\t\t  kill_value (dest, vd);\n+\t\t  set_value_regno (REGNO (dest), GET_MODE (dest), vd);\n+\t\t  copy_value (dest, SET_SRC (x), vd);\n+\t\t  ksvd.ignore_set_reg = dest;\n+\t\t  set_regno = REGNO (dest);\n+\t\t  set_nregs\n+\t\t    = hard_regno_nregs[set_regno][GET_MODE (dest)];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)\n+\t\t&& (i < set_regno || i >= set_regno + set_nregs))\n+\t      kill_value_regno (i, 1, vd);\n+\t}\n \n       /* Notice stores.  */\n-      note_stores (PATTERN (insn), kill_set_value, vd);\n+      note_stores (PATTERN (insn), kill_set_value, &ksvd);\n \n       /* Notice copies.  */\n       if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))"}, {"sha": "fece83ec3937c222233498d6cfa345ba0ad892bf", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -2870,7 +2870,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t{\n \t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n \t    sched_analyze_1 (deps, XEXP (link, 0), insn);\n-\t  else\n+\t  else if (GET_CODE (XEXP (link, 0)) != SET)\n \t    sched_analyze_2 (deps, XEXP (link, 0), insn);\n \t}\n       /* Don't schedule anything after a tail call, tail call needs"}, {"sha": "8b90aa8daffd16d891b5372d9b3a655b61b0990e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -1,3 +1,7 @@\n+2012-05-14  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* gcc.target/i386/retarg.c: New test.\n+\n 2012-05-13  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n \n \tPR fortran/45170"}, {"sha": "3af770d861e7a62c1a5d964217917eb90e2091f3", "filename": "gcc/testsuite/gcc.target/i386/retarg.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fretarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e384e6b59c074ac936f0f3212ca33fe40f3d82f5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fretarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fretarg.c?ref=e384e6b59c074ac936f0f3212ca33fe40f3d82f5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <string.h>\n+\n+void *p (void *x, void *y, int z)\n+{\n+  memcpy (x, y, z);\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"%rdi\" } } */"}]}