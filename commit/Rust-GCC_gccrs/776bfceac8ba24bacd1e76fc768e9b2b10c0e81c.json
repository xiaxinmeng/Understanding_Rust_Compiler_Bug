{"sha": "776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2YmZjZWFjOGJhMjRiYWNkMWU3NmZjNzY4ZTliMmIxMGMwZTgxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-03T10:04:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-03T10:04:28Z"}, "message": "Pass more vector types to append_pattern_def_seq\n\nThe PR85694 series added a vectype argument to append_pattern_def_seq.\nThis patch makes more callers use it.\n\n2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_recog_rotate_pattern)\n\t(vect_recog_vector_vector_shift_pattern, vect_recog_divmod_pattern)\n\t(vect_recog_mixed_size_cond_pattern, adjust_bool_pattern_cast)\n\t(adjust_bool_pattern, vect_recog_bool_pattern): Pass the vector\n\ttype to append_pattern_def_seq instead of creating a stmt_vec_info\n\tdirectly.\n\t(build_mask_conversion): Likewise.  Remove vinfo argument.\n\t(vect_add_conversion_to_patterm): Likewise, renaming to...\n\t(vect_add_conversion_to_pattern): ...this.\n\t(vect_recog_mask_conversion_pattern): Update call to\n\tbuild_mask_conversion.  Pass the vector type to\n\tappend_pattern_def_seq here too.\n\t(vect_recog_gather_scatter_pattern): Update call to\n\tvect_add_conversion_to_pattern.\n\nFrom-SVN: r262338", "tree": {"sha": "a67ec26fc6816b67c271c58a8fbbfc0268021eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a67ec26fc6816b67c271c58a8fbbfc0268021eb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9c58fb7aa5e719a3ce9acd94740371e139c035be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c58fb7aa5e719a3ce9acd94740371e139c035be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c58fb7aa5e719a3ce9acd94740371e139c035be"}], "stats": {"total": 125, "additions": 43, "deletions": 82}, "files": [{"sha": "338442904c91f94a554fa49fe450dc4ad5c703f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "patch": "@@ -1,3 +1,20 @@\n+2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_rotate_pattern)\n+\t(vect_recog_vector_vector_shift_pattern, vect_recog_divmod_pattern)\n+\t(vect_recog_mixed_size_cond_pattern, adjust_bool_pattern_cast)\n+\t(adjust_bool_pattern, vect_recog_bool_pattern): Pass the vector\n+\ttype to append_pattern_def_seq instead of creating a stmt_vec_info\n+\tdirectly.\n+\t(build_mask_conversion): Likewise.  Remove vinfo argument.\n+\t(vect_add_conversion_to_patterm): Likewise, renaming to...\n+\t(vect_add_conversion_to_pattern): ...this.\n+\t(vect_recog_mask_conversion_pattern): Update call to\n+\tbuild_mask_conversion.  Pass the vector type to\n+\tappend_pattern_def_seq here too.\n+\t(vect_recog_gather_scatter_pattern): Update call to\n+\tvect_add_conversion_to_pattern.\n+\n 2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (new_pattern_def_seq): Delete."}, {"sha": "8e289508357b5cca4e1436b39acaa0d4e0357829", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 26, "deletions": 82, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776bfceac8ba24bacd1e76fc768e9b2b10c0e81c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=776bfceac8ba24bacd1e76fc768e9b2b10c0e81c", "patch": "@@ -2090,7 +2090,6 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   else\n     {\n       tree vecstype = get_vectype_for_scalar_type (stype);\n-      stmt_vec_info def_stmt_vinfo;\n \n       if (vecstype == NULL_TREE)\n \treturn NULL;\n@@ -2103,12 +2102,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t  gcc_assert (!new_bb);\n \t}\n       else\n-\t{\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t}\n+\tappend_pattern_def_seq (stmt_vinfo, def_stmt, vecstype);\n \n       def2 = vect_recog_temp_ssa_var (stype, NULL);\n       tree mask = build_int_cst (stype, GET_MODE_PRECISION (smode) - 1);\n@@ -2121,12 +2115,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t  gcc_assert (!new_bb);\n \t}\n       else\n-\t{\n-\t  def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n-\t  set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t  STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecstype;\n-\t  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-\t}\n+\tappend_pattern_def_seq (stmt_vinfo, def_stmt, vecstype);\n     }\n \n   var1 = vect_recog_temp_ssa_var (type, NULL);\n@@ -2252,12 +2241,8 @@ vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n \t\t\t\t       TYPE_PRECISION (TREE_TYPE (oprnd1)));\n \t      def = vect_recog_temp_ssa_var (TREE_TYPE (rhs1), NULL);\n \t      def_stmt = gimple_build_assign (def, BIT_AND_EXPR, rhs1, mask);\n-\t      stmt_vec_info new_stmt_info\n-\t\t= new_stmt_vec_info (def_stmt, vinfo);\n-\t      set_vinfo_for_stmt (def_stmt, new_stmt_info);\n-\t      STMT_VINFO_VECTYPE (new_stmt_info)\n-\t\t= get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n-\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      tree vecstype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt, vecstype);\n \t    }\n \t}\n     }\n@@ -2688,11 +2673,9 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   tree oprnd0, oprnd1, vectype, itype, cond;\n   gimple *pattern_stmt, *def_stmt;\n   enum tree_code rhs_code;\n-  vec_info *vinfo = stmt_vinfo->vinfo;\n   optab optab;\n   tree q;\n   int dummy_int, prec;\n-  stmt_vec_info def_stmt_vinfo;\n \n   if (!is_gimple_assign (last_stmt))\n     return NULL;\n@@ -2792,18 +2775,12 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t      def_stmt = gimple_build_assign (var, COND_EXPR, cond,\n \t\t\t\t\t      build_int_cst (utype, -1),\n \t\t\t\t\t      build_int_cst (utype, 0));\n-\t      def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n-\t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n-\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt, vecutype);\n \t      var = vect_recog_temp_ssa_var (utype, NULL);\n \t      def_stmt = gimple_build_assign (var, RSHIFT_EXPR,\n \t\t\t\t\t      gimple_assign_lhs (def_stmt),\n \t\t\t\t\t      shift);\n-\t      def_stmt_vinfo = new_stmt_vec_info (def_stmt, vinfo);\n-\t      set_vinfo_for_stmt (def_stmt, def_stmt_vinfo);\n-\t      STMT_VINFO_VECTYPE (def_stmt_vinfo) = vecutype;\n-\t      append_pattern_def_seq (stmt_vinfo, def_stmt);\n+\t      append_pattern_def_seq (stmt_vinfo, def_stmt, vecutype);\n \t      signmask = vect_recog_temp_ssa_var (itype, NULL);\n \t      def_stmt\n \t\t= gimple_build_assign (signmask, NOP_EXPR, var);\n@@ -3110,10 +3087,8 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n   gimple *last_stmt = stmt_vinfo->stmt;\n   tree cond_expr, then_clause, else_clause;\n-  stmt_vec_info def_stmt_info;\n   tree type, vectype, comp_vectype, itype = NULL_TREE, vecitype;\n   gimple *pattern_stmt, *def_stmt;\n-  vec_info *vinfo = stmt_vinfo->vinfo;\n   tree orig_type0 = NULL_TREE, orig_type1 = NULL_TREE;\n   gimple *def_stmt0 = NULL, *def_stmt1 = NULL;\n   bool promotion;\n@@ -3218,10 +3193,7 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   pattern_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n \t\t\t\t      NOP_EXPR, gimple_assign_lhs (def_stmt));\n \n-  append_pattern_def_seq (stmt_vinfo, def_stmt);\n-  def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n-  set_vinfo_for_stmt (def_stmt, def_stmt_info);\n-  STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n+  append_pattern_def_seq (stmt_vinfo, def_stmt, vecitype);\n   *type_out = vectype;\n \n   vect_pattern_detected (\"vect_recog_mixed_size_cond_pattern\", last_stmt);\n@@ -3337,10 +3309,8 @@ adjust_bool_pattern_cast (tree type, tree var, stmt_vec_info stmt_info)\n {\n   gimple *cast_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n \t\t\t\t\t   NOP_EXPR, var);\n-  stmt_vec_info patt_vinfo = new_stmt_vec_info (cast_stmt, stmt_info->vinfo);\n-  set_vinfo_for_stmt (cast_stmt, patt_vinfo);\n-  STMT_VINFO_VECTYPE (patt_vinfo) = get_vectype_for_scalar_type (type);\n-  append_pattern_def_seq (stmt_info, cast_stmt);\n+  append_pattern_def_seq (stmt_info, cast_stmt,\n+\t\t\t  get_vectype_for_scalar_type (type));\n   return gimple_assign_lhs (cast_stmt);\n }\n \n@@ -3514,13 +3484,8 @@ adjust_bool_pattern (tree var, tree out_type,\n     }\n \n   gimple_set_location (pattern_stmt, loc);\n-  /* ???  Why does vect_mark_pattern_stmts set the vector type on all\n-     pattern def seq stmts instead of just letting auto-detection do\n-     its work?  */\n-  stmt_vec_info patt_vinfo = new_stmt_vec_info (pattern_stmt, stmt_info->vinfo);\n-  set_vinfo_for_stmt (pattern_stmt, patt_vinfo);\n-  STMT_VINFO_VECTYPE (patt_vinfo) = get_vectype_for_scalar_type (itype);\n-  append_pattern_def_seq (stmt_info, pattern_stmt);\n+  append_pattern_def_seq (stmt_info, pattern_stmt,\n+\t\t\t  get_vectype_for_scalar_type (itype));\n   defs.put (var, gimple_assign_lhs (pattern_stmt));\n }\n \n@@ -3718,7 +3683,6 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   gimple *last_stmt = stmt_vinfo->stmt;\n   enum tree_code rhs_code;\n   tree var, lhs, rhs, vectype;\n-  stmt_vec_info new_stmt_info;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *pattern_stmt;\n \n@@ -3777,10 +3741,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t  if (!useless_type_conversion_p (type, TREE_TYPE (lhs)))\n \t    {\n \t      tree new_vectype = get_vectype_for_scalar_type (type);\n-\t      new_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n-\t      set_vinfo_for_stmt (pattern_stmt, new_stmt_info);\n-\t      STMT_VINFO_VECTYPE (new_stmt_info) = new_vectype;\n-\t      append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t      append_pattern_def_seq (stmt_vinfo, pattern_stmt, new_vectype);\n \n \t      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n \t      pattern_stmt = gimple_build_assign (lhs, CONVERT_EXPR, tmp);\n@@ -3857,11 +3818,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n \t  rhs = vect_recog_temp_ssa_var (type, NULL);\n \t  pattern_stmt = gimple_build_assign (rhs, COND_EXPR, var, cst1, cst0);\n-\n-\t  pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n-\t  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n-\t  STMT_VINFO_VECTYPE (pattern_stmt_info) = new_vectype;\n-\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt, new_vectype);\n \t}\n \n       lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vectype), lhs);\n@@ -3897,20 +3854,15 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n    Return converted mask.  */\n \n static tree\n-build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo,\n-\t\t       vec_info *vinfo)\n+build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo)\n {\n   gimple *stmt;\n   tree masktype, tmp;\n-  stmt_vec_info new_stmt_info;\n \n   masktype = build_same_sized_truth_vector_type (vectype);\n   tmp = vect_recog_temp_ssa_var (TREE_TYPE (masktype), NULL);\n   stmt = gimple_build_assign (tmp, CONVERT_EXPR, mask);\n-  new_stmt_info = new_stmt_vec_info (stmt, vinfo);\n-  set_vinfo_for_stmt (stmt, new_stmt_info);\n-  STMT_VINFO_VECTYPE (new_stmt_info) = masktype;\n-  append_pattern_def_seq (stmt_vinfo, stmt);\n+  append_pattern_def_seq (stmt_vinfo, stmt, masktype);\n \n   return tmp;\n }\n@@ -3982,7 +3934,7 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \treturn NULL;\n \n-      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo);\n \n       if (load)\n \t{\n@@ -4109,16 +4061,12 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t  tmp = vect_recog_temp_ssa_var (TREE_TYPE (rhs1), NULL);\n \t  pattern_stmt = gimple_build_assign (tmp, rhs1);\n \t  rhs1 = tmp;\n-\n-\t  pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n-\t  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n-\t  STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype2;\n-\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt, vectype2);\n \t}\n \n       if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype1),\n \t\t    TYPE_VECTOR_SUBPARTS (vectype2)))\n-\ttmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+\ttmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo);\n       else\n \ttmp = rhs1;\n \n@@ -4158,14 +4106,14 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       vectype1 = get_mask_type_for_scalar_type (rhs1_type);\n       if (!vectype1)\n \treturn NULL;\n-      rhs2 = build_mask_conversion (rhs2, vectype1, stmt_vinfo, vinfo);\n+      rhs2 = build_mask_conversion (rhs2, vectype1, stmt_vinfo);\n     }\n   else\n     {\n       vectype1 = get_mask_type_for_scalar_type (rhs2_type);\n       if (!vectype1)\n \treturn NULL;\n-      rhs1 = build_mask_conversion (rhs1, vectype1, stmt_vinfo, vinfo);\n+      rhs1 = build_mask_conversion (rhs1, vectype1, stmt_vinfo);\n     }\n \n   lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n@@ -4237,7 +4185,7 @@ vect_convert_mask_for_vectype (tree mask, tree vectype,\n       if (mask_vectype\n \t  && maybe_ne (TYPE_VECTOR_SUBPARTS (vectype),\n \t\t       TYPE_VECTOR_SUBPARTS (mask_vectype)))\n-\tmask = build_mask_conversion (mask, vectype, stmt_info, vinfo);\n+\tmask = build_mask_conversion (mask, vectype, stmt_info);\n     }\n   return mask;\n }\n@@ -4251,19 +4199,15 @@ vect_convert_mask_for_vectype (tree mask, tree vectype,\n    to STMT_INFO.  */\n \n static tree\n-vect_add_conversion_to_patterm (tree type, tree value,\n-\t\t\t\tstmt_vec_info stmt_info,\n-\t\t\t\tvec_info *vinfo)\n+vect_add_conversion_to_pattern (tree type, tree value, stmt_vec_info stmt_info)\n {\n   if (useless_type_conversion_p (type, TREE_TYPE (value)))\n     return value;\n \n   tree new_value = vect_recog_temp_ssa_var (type, NULL);\n   gassign *conversion = gimple_build_assign (new_value, CONVERT_EXPR, value);\n-  stmt_vec_info new_stmt_info = new_stmt_vec_info (conversion, vinfo);\n-  set_vinfo_for_stmt (conversion, new_stmt_info);\n-  STMT_VINFO_VECTYPE (new_stmt_info) = get_vectype_for_scalar_type (type);\n-  append_pattern_def_seq (stmt_info, conversion);\n+  append_pattern_def_seq (stmt_info, conversion,\n+\t\t\t  get_vectype_for_scalar_type (type));\n   return new_value;\n }\n \n@@ -4309,8 +4253,8 @@ vect_recog_gather_scatter_pattern (stmt_vec_info stmt_info, tree *type_out)\n      latter to the same width as the vector elements.  */\n   tree base = gs_info.base;\n   tree offset_type = vect_get_gather_scatter_offset_type (&gs_info);\n-  tree offset = vect_add_conversion_to_patterm (offset_type, gs_info.offset,\n-\t\t\t\t\t\tstmt_info, loop_vinfo);\n+  tree offset = vect_add_conversion_to_pattern (offset_type, gs_info.offset,\n+\t\t\t\t\t\tstmt_info);\n \n   /* Build the new pattern statement.  */\n   tree scale = size_int (gs_info.scale);"}]}