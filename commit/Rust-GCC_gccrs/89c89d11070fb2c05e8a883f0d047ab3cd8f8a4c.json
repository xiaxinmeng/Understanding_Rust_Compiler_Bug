{"sha": "89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljODlkMTEwNzBmYjJjMDVlOGE4ODNmMGQwNDdhYjNjZDhmOGE0Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-15T21:06:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-15T21:06:46Z"}, "message": "(FLO_union_type): Add words field if double precision to get at the separate words.\n\n(FLO_union_type): Add words field if double precision to get at the separate\nwords.\n(FLO_union_type, pack_d, unpack_d): Use FLOAT_BIT_ORDER_MISMATCH to\ndetermine when the bitfields need to be reversed, and\nFLOAT_WORD_ORDER_MISMATCH when the words need to be reversed.\n\nFrom-SVN: r10357", "tree": {"sha": "857fa43e61108d43a169ba52c0d0509f5d94683d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/857fa43e61108d43a169ba52c0d0509f5d94683d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c/comments", "author": null, "committer": null, "parents": [{"sha": "6136d594d931622e71aa909d6709dbda712bfdc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6136d594d931622e71aa909d6709dbda712bfdc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6136d594d931622e71aa909d6709dbda712bfdc8"}], "stats": {"total": 28, "additions": 23, "deletions": 5}, "files": [{"sha": "4ee08f1629bded30d9c8a29a9f6c01ed3534fb5a", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=89c89d11070fb2c05e8a883f0d047ab3cd8f8a4c", "patch": "@@ -243,7 +243,11 @@ typedef union\n   FLO_type value;\n   fractype value_raw;\n \n-#ifdef FLOAT_WORD_ORDER_MISMATCH\n+#ifndef FLOAT\n+  halffractype words[2];\n+#endif\n+\n+#ifdef FLOAT_BIT_ORDER_MISMATCH\n   struct\n     {\n       fractype fraction:FRACBITS __attribute__ ((packed));\n@@ -254,8 +258,6 @@ typedef union\n #endif\n \n #ifdef _DEBUG_BITFLOAT\n-  halffractype l[2];\n-\n   struct\n     {\n       unsigned int sign:1 __attribute__ ((packed));\n@@ -414,7 +416,7 @@ pack_d ( fp_number_type *  src)\n   /* We previously used bitfields to store the number, but this doesn't\n      handle little/big endian systems conviently, so use shifts and\n      masks */\n-#ifdef FLOAT_WORD_ORDER_MISMATCH\n+#ifdef FLOAT_BIT_ORDER_MISMATCH\n   dst.bits.fraction = fraction;\n   dst.bits.exp = exp;\n   dst.bits.sign = sign;\n@@ -424,6 +426,14 @@ pack_d ( fp_number_type *  src)\n   dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);\n #endif\n \n+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)\n+  {\n+    halffractype tmp = dst.words[0];\n+    dst.words[0] = dst.words[1];\n+    dst.words[1] = tmp;\n+  }\n+#endif\n+\n   return dst.value;\n }\n \n@@ -437,7 +447,15 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n   int exp;\n   int sign;\n \n-#ifdef FLOAT_WORD_ORDER_MISMATCH\n+#if defined(FLOAT_WORD_ORDER_MISMATCH) && !defined(FLOAT)\n+  FLO_union_type swapped;\n+\n+  swapped.words[0] = src->words[1];\n+  swapped.words[1] = src->words[0];\n+  src = &swapped;\n+#endif\n+  \n+#ifdef FLOAT_BIT_ORDER_MISMATCH\n   fraction = src->bits.fraction;\n   exp = src->bits.exp;\n   sign = src->bits.sign;"}]}