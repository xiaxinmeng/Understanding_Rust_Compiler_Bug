{"sha": "04be694e4d9132523f01de8d9873c6b07164afb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRiZTY5NGU0ZDkxMzI1MjNmMDFkZThkOTg3M2M2YjA3MTY0YWZiMg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-12-04T14:37:01Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-12-04T14:37:01Z"}, "message": "ipa-prop.h (ipa_alignment): New type.\n\n2014-12-04  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_alignment): New type.\n\t(ipa_jump_func): New field alignment.\n\t(ipcp_transformation_summary) New type.\n\t(ipcp_grow_transformations_if_necessary): Declare.\n\t(ipa_node_agg_replacements): Removed.\n\t(ipcp_transformations): Declare.\n\t(ipcp_get_transformation_summary): New function.\n\t(ipa_get_agg_replacements_for_node): Use it.\n\t* ipa-cp.c (ipcp_param_lattices): New field alignment.\n\t(print_all_lattices): Also print alignment.\n\t(alignment_bottom_p): New function.\n\t(set_alignment_to_bottom): Likewise.\n\t(set_all_contains_variable): Also set alignment to bottom.\n\t(initialize_node_lattices): Likewise.\n\t(propagate_alignment_accross_jump_function): New function.\n\t(propagate_constants_accross_call): Call it.\n\t(ipcp_store_alignment_results): New function.\n\t(ipcp_driver): Call it.\n\t* ipa-prop.c (ipa_node_agg_replacements): Removed.\n\t(ipcp_transformations): New.\n\t(ipa_print_node_jump_functions_for_edge): Also print alignment.\n\t(ipa_set_jf_unknown): New function.\n\t(detect_type_change_from_memory_writes): Use ipa_set_jf_unknown.\n\t(ipa_compute_jump_functions_for_edge): Also calculate alignment.\n\t(update_jump_functions_after_inlining): Use ipa_set_jf_unknown.\n\t(ipcp_grow_transformations_if_necessary): New function.\n\t(ipa_set_node_agg_value_chain): Use ipcp_transformations.\n\t(ipa_node_removal_hook): Likewise.\n\t(ipa_node_duplication_hook): Also duplicate alignment results.\n\t(ipa_write_jump_function): Also stream alignments.\n\t(ipa_read_jump_function): Use ipa_set_jf_unknown, also stream\n\talignments.\n\t(write_agg_replacement_chain): Renamed to\n\twrite_ipcp_transformation_info, also stream alignments.\n\t(read_agg_replacement_chain): Renamed to\n\tread_ipcp_transformation_info, also stream alignments.\n\t(ipa_prop_write_all_agg_replacement): Renamed to\n\tipcp_write_transformation_summaries. Stream always.\n\t(ipa_prop_read_all_agg_replacement): Renamed to\n\tipcp_read_transformation_summaries.\n\t(ipcp_update_alignments): New function.\n\t(ipcp_transform_function): Call it, free also alignments.\n\ntestsuite/\n\t* gcc.dg/ipa/propalign-1.c: New test.\n\t* gcc.dg/ipa/propalign-2.c: Likewise.\n\nFrom-SVN: r218369", "tree": {"sha": "eaa3f2883edec074e9afd98dc3aa04cb23c6a0aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa3f2883edec074e9afd98dc3aa04cb23c6a0aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04be694e4d9132523f01de8d9873c6b07164afb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04be694e4d9132523f01de8d9873c6b07164afb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04be694e4d9132523f01de8d9873c6b07164afb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04be694e4d9132523f01de8d9873c6b07164afb2/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de665bbd932894baef6fa51a9989ab089602434f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de665bbd932894baef6fa51a9989ab089602434f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de665bbd932894baef6fa51a9989ab089602434f"}], "stats": {"total": 622, "additions": 567, "deletions": 55}, "files": [{"sha": "7902ac01ed67d088bf6ef7d3321db72dfd5f292b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -1,3 +1,48 @@\n+2014-12-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_alignment): New type.\n+\t(ipa_jump_func): New field alignment.\n+\t(ipcp_transformation_summary) New type.\n+\t(ipcp_grow_transformations_if_necessary): Declare.\n+\t(ipa_node_agg_replacements): Removed.\n+\t(ipcp_transformations): Declare.\n+\t(ipcp_get_transformation_summary): New function.\n+\t(ipa_get_agg_replacements_for_node): Use it.\n+\t* ipa-cp.c (ipcp_param_lattices): New field alignment.\n+\t(print_all_lattices): Also print alignment.\n+\t(alignment_bottom_p): New function.\n+\t(set_alignment_to_bottom): Likewise.\n+\t(set_all_contains_variable): Also set alignment to bottom.\n+\t(initialize_node_lattices): Likewise.\n+\t(propagate_alignment_accross_jump_function): New function.\n+\t(propagate_constants_accross_call): Call it.\n+\t(ipcp_store_alignment_results): New function.\n+\t(ipcp_driver): Call it.\n+\t* ipa-prop.c (ipa_node_agg_replacements): Removed.\n+\t(ipcp_transformations): New.\n+\t(ipa_print_node_jump_functions_for_edge): Also print alignment.\n+\t(ipa_set_jf_unknown): New function.\n+\t(detect_type_change_from_memory_writes): Use ipa_set_jf_unknown.\n+\t(ipa_compute_jump_functions_for_edge): Also calculate alignment.\n+\t(update_jump_functions_after_inlining): Use ipa_set_jf_unknown.\n+\t(ipcp_grow_transformations_if_necessary): New function.\n+\t(ipa_set_node_agg_value_chain): Use ipcp_transformations.\n+\t(ipa_node_removal_hook): Likewise.\n+\t(ipa_node_duplication_hook): Also duplicate alignment results.\n+\t(ipa_write_jump_function): Also stream alignments.\n+\t(ipa_read_jump_function): Use ipa_set_jf_unknown, also stream\n+\talignments.\n+\t(write_agg_replacement_chain): Renamed to\n+\twrite_ipcp_transformation_info, also stream alignments.\n+\t(read_agg_replacement_chain): Renamed to\n+\tread_ipcp_transformation_info, also stream alignments.\n+\t(ipa_prop_write_all_agg_replacement): Renamed to\n+\tipcp_write_transformation_summaries. Stream always.\n+\t(ipa_prop_read_all_agg_replacement): Renamed to\n+\tipcp_read_transformation_summaries.\n+\t(ipcp_update_alignments): New function.\n+\t(ipcp_transform_function): Call it, free also alignments.\n+\n 2014-12-04  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (replace_stmt_with_simplification): Properly"}, {"sha": "3baa11586264b32601d9b9913fb7f516ee320263", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 167, "deletions": 2, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -262,6 +262,9 @@ class ipcp_param_lattices\n   ipcp_lattice<ipa_polymorphic_call_context> ctxlat;\n   /* Lattices describing aggregate parts.  */\n   ipcp_agg_lattice *aggs;\n+  /* Alignment information.  Very basic one value lattice where !known means\n+     TOP and zero alignment bottom.  */\n+  ipa_alignment alignment;\n   /* Number of aggregate lattices */\n   int aggs_count;\n   /* True if aggregate data were passed by reference (as opposed to by\n@@ -444,6 +447,13 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  plats->itself.print (f, dump_sources, dump_benefits);\n \t  fprintf (f, \"         ctxs: \");\n \t  plats->ctxlat.print (f, dump_sources, dump_benefits);\n+\t  if (plats->alignment.known && plats->alignment.align > 0)\n+\t    fprintf (f, \"         Alignment %u, misalignment %u\\n\",\n+\t\t     plats->alignment.align, plats->alignment.misalign);\n+\t  else if (plats->alignment.known)\n+\t    fprintf (f, \"         Alignment unusable\\n\");\n+\t  else\n+\t    fprintf (f, \"         Alignment unknown\\n\");\n \t  if (plats->virt_call)\n \t    fprintf (f, \"        virt_call flag set\\n\");\n \n@@ -761,6 +771,27 @@ set_agg_lats_contain_variable (struct ipcp_param_lattices *plats)\n   return ret;\n }\n \n+/* Return true if alignment information in PLATS is known to be unusable.  */\n+\n+static inline bool\n+alignment_bottom_p (ipcp_param_lattices *plats)\n+{\n+  return plats->alignment.known && (plats->alignment.align == 0);\n+}\n+\n+/* Set alignment information in PLATS to unusable.  Return true if it\n+   previously was usable or unknown.  */\n+\n+static inline bool\n+set_alignment_to_bottom (ipcp_param_lattices *plats)\n+{\n+  if (alignment_bottom_p (plats))\n+    return false;\n+  plats->alignment.known = true;\n+  plats->alignment.align = 0;\n+  return true;\n+}\n+\n /* Mark bot aggregate and scalar lattices as containing an unknown variable,\n    return true is any of them has not been marked as such so far.  */\n \n@@ -771,6 +802,7 @@ set_all_contains_variable (struct ipcp_param_lattices *plats)\n   ret = plats->itself.set_contains_variable ();\n   ret |= plats->ctxlat.set_contains_variable ();\n   ret |= set_agg_lats_contain_variable (plats);\n+  ret |= set_alignment_to_bottom (plats);\n   return ret;\n }\n \n@@ -807,6 +839,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t      plats->itself.set_to_bottom ();\n \t      plats->ctxlat.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n+\t      set_alignment_to_bottom (plats);\n \t    }\n \t  else\n \t    set_all_contains_variable (plats);\n@@ -1369,6 +1402,77 @@ propagate_context_accross_jump_function (cgraph_edge *cs,\n   return ret;\n }\n \n+/* Propagate alignments across jump function JFUNC that is associated with\n+   edge CS and update DEST_LAT accordingly.  */\n+\n+static bool\n+propagate_alignment_accross_jump_function (struct cgraph_edge *cs,\n+\t\t\t\t\t   struct ipa_jump_func *jfunc,\n+\t\t\t\t\t   struct ipcp_param_lattices *dest_lat)\n+{\n+  if (alignment_bottom_p (dest_lat))\n+    return false;\n+\n+  ipa_alignment cur;\n+  cur.known = false;\n+  if (jfunc->alignment.known)\n+    cur = jfunc->alignment;\n+  else if (jfunc->type == IPA_JF_PASS_THROUGH\n+\t   || jfunc->type == IPA_JF_ANCESTOR)\n+    {\n+      struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+      struct ipcp_param_lattices *src_lats;\n+      HOST_WIDE_INT offset = 0;\n+      int src_idx;\n+\n+      if (jfunc->type == IPA_JF_PASS_THROUGH)\n+\t{\n+\t  enum tree_code op = ipa_get_jf_pass_through_operation (jfunc);\n+\t  if (op != NOP_EXPR)\n+\t    {\n+\t      if (op != POINTER_PLUS_EXPR\n+\t\t  && op != PLUS_EXPR\n+\t\t  && op != MINUS_EXPR)\n+\t\tgoto prop_fail;\n+\t      tree operand = ipa_get_jf_pass_through_operand (jfunc);\n+\t      if (!tree_fits_shwi_p (operand))\n+\t\tgoto prop_fail;\n+\t      offset = tree_to_shwi (operand);\n+\t    }\n+\t  src_idx = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t}\n+      else\n+\t{\n+\t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t  offset = ipa_get_jf_ancestor_offset (jfunc);\n+\t}\n+\n+      src_lats = ipa_get_parm_lattices (caller_info, src_idx);\n+      if (!src_lats->alignment.known\n+\t  || alignment_bottom_p (src_lats))\n+\tgoto prop_fail;\n+\n+      cur = src_lats->alignment;\n+      cur.misalign = (cur.misalign + offset) % cur.align;\n+    }\n+\n+  if (cur.known)\n+    {\n+      if (!dest_lat->alignment.known)\n+\t{\n+\t  dest_lat->alignment = cur;\n+\t  return true;\n+\t}\n+      else if (dest_lat->alignment.align == cur.align\n+\t       && dest_lat->alignment.misalign == cur.misalign)\n+\treturn false;\n+    }\n+\n+ prop_fail:\n+  set_alignment_to_bottom (dest_lat);\n+  return true;\n+}\n+\n /* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n    NEW_AGGS_BY_REF and if not, mark all aggs as bottoms and return true (in all\n    other cases, return false).  If there are no aggregate items, set\n@@ -1705,6 +1809,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n \t\t\t\t\t\t\t &dest_plats->itself);\n \t  ret |= propagate_context_accross_jump_function (cs, jump_func, i,\n \t\t\t\t\t\t\t  &dest_plats->ctxlat);\n+\t  ret |= propagate_alignment_accross_jump_function (cs, jump_func,\n+\t\t\t\t\t\t\t    dest_plats);\n \t  ret |= propagate_aggs_accross_jump_function (cs, jump_func,\n \t\t\t\t\t\t       dest_plats);\n \t}\n@@ -4190,6 +4296,63 @@ ipcp_decision_stage (struct ipa_topo_info *topo)\n     }\n }\n \n+/* Look up all alignment information that we have discovered and copy it over\n+   to the transformation summary.  */\n+\n+static void\n+ipcp_store_alignment_results (void)\n+{\n+  cgraph_node *node;\n+\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+  {\n+    ipa_node_params *info = IPA_NODE_REF (node);\n+    bool dumped_sth = false;\n+    bool found_useful_result = false;\n+\n+   if (info->ipcp_orig_node)\n+      info = IPA_NODE_REF (info->ipcp_orig_node);\n+\n+   unsigned count = ipa_get_param_count (info);\n+   for (unsigned i = 0; i < count ; i++)\n+     {\n+       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+       if (plats->alignment.known\n+\t   && plats->alignment.align > 0)\n+\t {\n+\t   found_useful_result = true;\n+\t   break;\n+\t }\n+     }\n+   if (!found_useful_result)\n+     continue;\n+\n+  ipcp_grow_transformations_if_necessary ();\n+   ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+   vec_safe_reserve_exact (ts->alignments, count);\n+\n+   for (unsigned i = 0; i < count ; i++)\n+     {\n+       ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n+\n+       if (plats->alignment.align == 0)\n+\t plats->alignment.known = false;\n+\n+       ts->alignments->quick_push (plats->alignment);\n+       if (!dump_file || !plats->alignment.known)\n+\t continue;\n+       if (!dumped_sth)\n+\t {\n+\t   fprintf (dump_file, \"Propagated alignment info for function %s/%i:\\n\",\n+\t\t    node->name (), node->order);\n+\t   dumped_sth = true;\n+\t }\n+       fprintf (dump_file, \"  param %i: align: %u, misalign: %u\\n\",\n+\t\ti, plats->alignment.align, plats->alignment.misalign);\n+     }\n+  }\n+}\n+\n /* The IPCP driver.  */\n \n static unsigned int\n@@ -4231,6 +4394,8 @@ ipcp_driver (void)\n   ipcp_propagate_stage (&topo);\n   /* Decide what constant propagation and cloning should be performed.  */\n   ipcp_decision_stage (&topo);\n+  /* Store results of alignment propagation. */\n+  ipcp_store_alignment_results ();\n \n   /* Free all IPCP structures.  */\n   free_toporder_info (&topo);\n@@ -4303,9 +4468,9 @@ class pass_ipa_cp : public ipa_opt_pass_d\n \t\t      ipcp_generate_summary, /* generate_summary */\n \t\t      ipcp_write_summary, /* write_summary */\n \t\t      ipcp_read_summary, /* read_summary */\n-\t\t      ipa_prop_write_all_agg_replacement, /*\n+\t\t      ipcp_write_transformation_summaries, /*\n \t\t      write_optimization_summary */\n-\t\t      ipa_prop_read_all_agg_replacement, /*\n+\t\t      ipcp_read_transformation_summaries, /*\n \t\t      read_optimization_summary */\n \t\t      NULL, /* stmt_fixup */\n \t\t      0, /* function_transform_todo_flags_start */"}, {"sha": "c6e7868989f7ae1438d39652220f4aea4a8ad031", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 221, "deletions": 44, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -133,8 +133,8 @@ struct func_body_info\n \n /* Vector where the parameter infos are actually stored. */\n vec<ipa_node_params> ipa_node_params_vector;\n-/* Vector of known aggregate values in cloned nodes.  */\n-vec<ipa_agg_replacement_value_p, va_gc> *ipa_node_agg_replacements;\n+/* Vector of IPA-CP transformation data for each clone.  */\n+vec<ipcp_transformation_summary, va_gc> *ipcp_transformations;\n /* Vector where the parameter infos are actually stored. */\n vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n@@ -372,6 +372,15 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t  fprintf (f, \"         Context: \");\n \t  ctx->dump (dump_file);\n \t}\n+\n+      if (jump_func->alignment.known)\n+\t{\n+\t  fprintf (f, \"         Alignment: %u, misalignment: %u\\n\",\n+\t\t   jump_func->alignment.align,\n+\t\t   jump_func->alignment.misalign);\n+\t}\n+      else\n+\tfprintf (f, \"         Unknown alignment\\n\");\n     }\n }\n \n@@ -444,6 +453,15 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n+/* Set jfunc to be a know-really nothing jump function.  */\n+\n+static void\n+ipa_set_jf_unknown (struct ipa_jump_func *jfunc)\n+{\n+  jfunc->type = IPA_JF_UNKNOWN;\n+  jfunc->alignment.known = false;\n+}\n+\n /* Set JFUNC to be a copy of another jmp (to be used by jump function\n    combination code).  The two functions will share their rdesc.  */\n \n@@ -748,7 +766,7 @@ detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n   if (!tci.type_maybe_changed)\n     return false;\n \n-  jfunc->type = IPA_JF_UNKNOWN;\n+  ipa_set_jf_unknown (jfunc);\n   return true;\n }\n \n@@ -1715,6 +1733,24 @@ ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t    useful_context = true;\n \t}\n \n+      if (POINTER_TYPE_P (TREE_TYPE(arg)))\n+\t{\n+\t  unsigned HOST_WIDE_INT hwi_bitpos;\n+\t  unsigned align;\n+\n+\t  if (get_pointer_alignment_1 (arg, &align, &hwi_bitpos)\n+\t      && align > BITS_PER_UNIT)\n+\t    {\n+\t      jfunc->alignment.known = true;\n+\t      jfunc->alignment.align = align;\n+\t      jfunc->alignment.misalign = hwi_bitpos / BITS_PER_UNIT;\n+\t    }\n+\t  else\n+\t    gcc_assert (!jfunc->alignment.known);\n+\t}\n+      else\n+\tgcc_assert (!jfunc->alignment.known);\n+\n       if (is_gimple_ip_invariant (arg))\n \tipa_set_jf_constant (jfunc, arg, cs);\n       else if (!is_gimple_reg_type (TREE_TYPE (arg))\n@@ -2412,7 +2448,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t     don't.  */\n \t  if (dst_fid >= ipa_get_cs_argument_count (top))\n \t    {\n-\t      dst->type = IPA_JF_UNKNOWN;\n+\t      ipa_set_jf_unknown (dst);\n \t      continue;\n \t    }\n \n@@ -2466,7 +2502,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\tsrc->value.ancestor.agg_preserved;\n \t    }\n \t  else\n-\t    dst->type = IPA_JF_UNKNOWN;\n+\t    ipa_set_jf_unknown (dst);\n \t}\n       else if (dst->type == IPA_JF_PASS_THROUGH)\n \t{\n@@ -2504,7 +2540,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      switch (src->type)\n \t\t{\n \t\tcase IPA_JF_UNKNOWN:\n-\t\t  dst->type = IPA_JF_UNKNOWN;\n+\t\t  ipa_set_jf_unknown (dst);\n \t\t  break;\n \t\tcase IPA_JF_CONST:\n \t\t  ipa_set_jf_cst_copy (dst, src);\n@@ -2558,7 +2594,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t}\n \t    }\n \t  else\n-\t    dst->type = IPA_JF_UNKNOWN;\n+\t    ipa_set_jf_unknown (dst);\n \t}\n     }\n }\n@@ -3329,18 +3365,24 @@ ipa_free_all_node_params (void)\n   ipa_node_params_vector.release ();\n }\n \n+/* Grow ipcp_transformations if necessary.  */\n+\n+void\n+ipcp_grow_transformations_if_necessary (void)\n+{\n+  if (vec_safe_length (ipcp_transformations)\n+      <= (unsigned) symtab->cgraph_max_uid)\n+    vec_safe_grow_cleared (ipcp_transformations, symtab->cgraph_max_uid + 1);\n+}\n+\n /* Set the aggregate replacements of NODE to be AGGVALS.  */\n \n void\n ipa_set_node_agg_value_chain (struct cgraph_node *node,\n \t\t\t      struct ipa_agg_replacement_value *aggvals)\n {\n-  if (vec_safe_length (ipa_node_agg_replacements)\n-      <= (unsigned) symtab->cgraph_max_uid)\n-    vec_safe_grow_cleared (ipa_node_agg_replacements,\n-\t\t\t   symtab->cgraph_max_uid + 1);\n-\n-  (*ipa_node_agg_replacements)[node->uid] = aggvals;\n+  ipcp_grow_transformations_if_necessary ();\n+  (*ipcp_transformations)[node->uid].agg_values = aggvals;\n }\n \n /* Hook that is called by cgraph.c when an edge is removed.  */\n@@ -3381,8 +3423,11 @@ ipa_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   /* During IPA-CP updating we can be called on not-yet analyze clones.  */\n   if (ipa_node_params_vector.length () > (unsigned)node->uid)\n     ipa_free_node_params_substructures (IPA_NODE_REF (node));\n-  if (vec_safe_length (ipa_node_agg_replacements) > (unsigned)node->uid)\n-    (*ipa_node_agg_replacements)[(unsigned)node->uid] = NULL;\n+  if (vec_safe_length (ipcp_transformations) > (unsigned)node->uid)\n+    {\n+      (*ipcp_transformations)[(unsigned)node->uid].agg_values = NULL;\n+      (*ipcp_transformations)[(unsigned)node->uid].alignments = NULL;\n+    }\n }\n \n /* Hook that is called by cgraph.c when an edge is duplicated.  */\n@@ -3510,21 +3555,35 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   new_info->node_enqueued = old_info->node_enqueued;\n \n   old_av = ipa_get_agg_replacements_for_node (src);\n-  if (!old_av)\n-    return;\n-\n-  new_av = NULL;\n-  while (old_av)\n+  if (old_av)\n     {\n-      struct ipa_agg_replacement_value *v;\n+      new_av = NULL;\n+      while (old_av)\n+\t{\n+\t  struct ipa_agg_replacement_value *v;\n \n-      v = ggc_alloc<ipa_agg_replacement_value> ();\n-      memcpy (v, old_av, sizeof (*v));\n-      v->next = new_av;\n-      new_av = v;\n-      old_av = old_av->next;\n+\t  v = ggc_alloc<ipa_agg_replacement_value> ();\n+\t  memcpy (v, old_av, sizeof (*v));\n+\t  v->next = new_av;\n+\t  new_av = v;\n+\t  old_av = old_av->next;\n+\t}\n+      ipa_set_node_agg_value_chain (dst, new_av);\n+    }\n+\n+  ipcp_transformation_summary *src_trans = ipcp_get_transformation_summary (src);\n+\n+  if (src_trans && vec_safe_length (src_trans->alignments) > 0)\n+    {\n+      ipcp_grow_transformations_if_necessary ();\n+      src_trans = ipcp_get_transformation_summary (src);\n+      const vec<ipa_alignment, va_gc> *src_alignments = src_trans->alignments;\n+      vec<ipa_alignment, va_gc> *&dst_alignments\n+\t= ipcp_get_transformation_summary (dst)->alignments;\n+      vec_safe_reserve_exact (dst_alignments, src_alignments->length ());\n+      for (unsigned i = 0; i < src_alignments->length (); ++i)\n+\tdst_alignments->quick_push ((*src_alignments)[i]);\n     }\n-  ipa_set_node_agg_value_chain (dst, new_av);\n }\n \n \n@@ -4452,6 +4511,15 @@ ipa_write_jump_function (struct output_block *ob,\n       streamer_write_uhwi (ob, item->offset);\n       stream_write_tree (ob, item->value, true);\n     }\n+\n+  bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, jump_func->alignment.known, 1);\n+  streamer_write_bitpack (&bp);\n+  if (jump_func->alignment.known)\n+    {\n+      streamer_write_uhwi (ob, jump_func->alignment.align);\n+      streamer_write_uhwi (ob, jump_func->alignment.misalign);\n+    }\n }\n \n /* Read in jump function JUMP_FUNC from IB.  */\n@@ -4470,7 +4538,7 @@ ipa_read_jump_function (struct lto_input_block *ib,\n   switch (jftype)\n     {\n     case IPA_JF_UNKNOWN:\n-      jump_func->type = IPA_JF_UNKNOWN;\n+      ipa_set_jf_unknown (jump_func);\n       break;\n     case IPA_JF_CONST:\n       ipa_set_jf_constant (jump_func, stream_read_tree (ib, data_in), cs);\n@@ -4517,6 +4585,17 @@ ipa_read_jump_function (struct lto_input_block *ib,\n       item.value = stream_read_tree (ib, data_in);\n       jump_func->agg.items->quick_push (item);\n     }\n+\n+  struct bitpack_d bp = streamer_read_bitpack (ib);\n+  bool alignment_known = bp_unpack_value (&bp, 1);\n+  if (alignment_known)\n+    {\n+      jump_func->alignment.known = true;\n+      jump_func->alignment.align = streamer_read_uhwi (ib);\n+      jump_func->alignment.misalign = streamer_read_uhwi (ib);\n+    }\n+  else\n+    jump_func->alignment.known = false;\n }\n \n /* Stream out parts of cgraph_indirect_call_info corresponding to CS that are\n@@ -4828,7 +4907,7 @@ ipa_update_after_lto_read (void)\n }\n \n void\n-write_agg_replacement_chain (struct output_block *ob, struct cgraph_node *node)\n+write_ipcp_transformation_info (output_block *ob, cgraph_node *node)\n {\n   int node_ref;\n   unsigned int count = 0;\n@@ -4856,14 +4935,38 @@ write_agg_replacement_chain (struct output_block *ob, struct cgraph_node *node)\n       bp_pack_value (&bp, av->by_ref, 1);\n       streamer_write_bitpack (&bp);\n     }\n+\n+  ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+  if (ts && vec_safe_length (ts->alignments) > 0)\n+    {\n+      count = ts->alignments->length ();\n+\n+      streamer_write_uhwi (ob, count);\n+      for (unsigned i = 0; i < count; ++i)\n+\t{\n+\t  ipa_alignment *parm_al = &(*ts->alignments)[i];\n+\n+\t  struct bitpack_d bp;\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, parm_al->known, 1);\n+\t  streamer_write_bitpack (&bp);\n+\t  if (parm_al->known)\n+\t    {\n+\t      streamer_write_uhwi (ob, parm_al->align);\n+\t      streamer_write_hwi_in_range (ob->main_stream, 0, parm_al->align,\n+\t\t\t\t\t   parm_al->misalign);\n+\t    }\n+\t}\n+    }\n+  else\n+    streamer_write_uhwi (ob, 0);\n }\n \n /* Stream in the aggregate value replacement chain for NODE from IB.  */\n \n static void\n-read_agg_replacement_chain (struct lto_input_block *ib,\n-\t\t\t    struct cgraph_node *node,\n-\t\t\t    struct data_in *data_in)\n+read_ipcp_transformation_info (lto_input_block *ib, cgraph_node *node,\n+\t\t\t       data_in *data_in)\n {\n   struct ipa_agg_replacement_value *aggvals = NULL;\n   unsigned int count, i;\n@@ -4884,31 +4987,52 @@ read_agg_replacement_chain (struct lto_input_block *ib,\n       aggvals = av;\n     }\n   ipa_set_node_agg_value_chain (node, aggvals);\n+\n+  count = streamer_read_uhwi (ib);\n+  if (count > 0)\n+    {\n+      ipcp_grow_transformations_if_necessary ();\n+\n+      ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+      vec_safe_grow_cleared (ts->alignments, count);\n+\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  ipa_alignment *parm_al;\n+\t  parm_al = &(*ts->alignments)[i];\n+\t  struct bitpack_d bp;\n+\t  bp = streamer_read_bitpack (ib);\n+\t  parm_al->known = bp_unpack_value (&bp, 1);\n+\t  if (parm_al->known)\n+\t    {\n+\t      parm_al->align = streamer_read_uhwi (ib);\n+\t      parm_al->misalign\n+\t\t= streamer_read_hwi_in_range (ib, \"ipa-prop misalign\",\n+\t\t\t\t\t      0, parm_al->align);\n+\t    }\n+\t}\n+    }\n }\n \n /* Write all aggregate replacement for nodes in set.  */\n \n void\n-ipa_prop_write_all_agg_replacement (void)\n+ipcp_write_transformation_summaries (void)\n {\n   struct cgraph_node *node;\n   struct output_block *ob;\n   unsigned int count = 0;\n   lto_symtab_encoder_iterator lsei;\n   lto_symtab_encoder_t encoder;\n \n-  if (!ipa_node_agg_replacements)\n-    return;\n-\n   ob = create_output_block (LTO_section_ipcp_transform);\n   encoder = ob->decl_state->symtab_node_encoder;\n   ob->symbol = NULL;\n   for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ()\n-\t  && ipa_get_agg_replacements_for_node (node) != NULL)\n+      if (node->has_gimple_body_p ())\n \tcount++;\n     }\n \n@@ -4918,9 +5042,8 @@ ipa_prop_write_all_agg_replacement (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->has_gimple_body_p ()\n-\t  && ipa_get_agg_replacements_for_node (node) != NULL)\n-\twrite_agg_replacement_chain (ob, node);\n+      if (node->has_gimple_body_p ())\n+\twrite_ipcp_transformation_info (ob, node);\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n   produce_asm (ob, NULL);\n@@ -4962,7 +5085,7 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n       gcc_assert (node->definition);\n-      read_agg_replacement_chain (&ib_main, node, data_in);\n+      read_ipcp_transformation_info (&ib_main, node, data_in);\n     }\n   lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n \t\t\t len);\n@@ -4972,7 +5095,7 @@ read_replacements_section (struct lto_file_decl_data *file_data,\n /* Read IPA-CP aggregate replacements.  */\n \n void\n-ipa_prop_read_all_agg_replacement (void)\n+ipcp_read_transformation_summaries (void)\n {\n   struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n   struct lto_file_decl_data *file_data;\n@@ -5139,6 +5262,58 @@ ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n \n }\n \n+/* Update alignment of formal parameters as described in\n+   ipcp_transformation_summary.  */\n+\n+static void\n+ipcp_update_alignments (struct cgraph_node *node)\n+{\n+  tree fndecl = node->decl;\n+  tree parm = DECL_ARGUMENTS (fndecl);\n+  tree next_parm = parm;\n+  ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+  if (!ts || vec_safe_length (ts->alignments) == 0)\n+    return;\n+  const vec<ipa_alignment, va_gc> &alignments = *ts->alignments;\n+  unsigned count = alignments.length ();\n+\n+  for (unsigned i = 0; i < count; ++i, parm = next_parm)\n+    {\n+      if (node->clone.combined_args_to_skip\n+\t  && bitmap_bit_p (node->clone.combined_args_to_skip, i))\n+\tcontinue;\n+      gcc_checking_assert (parm);\n+      next_parm = DECL_CHAIN (parm);\n+\n+      if (!alignments[i].known || !is_gimple_reg (parm))\n+\tcontinue;\n+      tree ddef = ssa_default_def (DECL_STRUCT_FUNCTION (node->decl), parm);\n+      if (!ddef)\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Adjusting alignment of param %u to %u, \"\n+\t\t \"misalignment to %u\\n\", i, alignments[i].align,\n+\t\t alignments[i].misalign);\n+\n+      struct ptr_info_def *pi = get_ptr_info (ddef);\n+      gcc_checking_assert (pi);\n+      unsigned old_align;\n+      unsigned old_misalign;\n+      bool old_known = get_ptr_info_alignment (pi, &old_align, &old_misalign);\n+\n+      if (old_known\n+\t  && old_align >= alignments[i].align)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    But the alignment was already %u.\\n\",\n+\t\t     old_align);\n+\t  continue;\n+\t}\n+      set_ptr_info_alignment (pi, alignments[i].align, alignments[i].misalign);\n+    }\n+}\n+\n /* IPCP transformation phase doing propagation of aggregate values.  */\n \n unsigned int\n@@ -5157,6 +5332,7 @@ ipcp_transform_function (struct cgraph_node *node)\n     fprintf (dump_file, \"Modification phase of node %s/%i\\n\",\n \t     node->name (), node->order);\n \n+  ipcp_update_alignments (node);\n   aggval = ipa_get_agg_replacements_for_node (node);\n   if (!aggval)\n       return 0;\n@@ -5186,7 +5362,8 @@ ipcp_transform_function (struct cgraph_node *node)\n     free_ipa_bb_info (bi);\n   fbi.bb_infos.release ();\n   free_dominance_info (CDI_DOMINATORS);\n-  (*ipa_node_agg_replacements)[node->uid] = NULL;\n+  (*ipcp_transformations)[node->uid].agg_values = NULL;\n+  (*ipcp_transformations)[node->uid].alignments = NULL;\n   descriptors.release ();\n \n   if (!something_changed)"}, {"sha": "76b503382a66021a86228c885b39f24d76ff2e24", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -144,6 +144,17 @@ struct GTY(()) ipa_agg_jump_function\n \n typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n \n+/* Info about pointer alignments. */\n+struct GTY(()) ipa_alignment\n+{\n+  /* The data fields below are valid only if known is true.  */\n+  bool known;\n+  /* See ptr_info_def and get_pointer_alignment_1 for description of these\n+     two.  */\n+  unsigned align;\n+  unsigned misalign;\n+};\n+\n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n@@ -153,6 +164,9 @@ struct GTY (()) ipa_jump_func\n      description.  */\n   struct ipa_agg_jump_function agg;\n \n+  /* Information about alignment of pointers. */\n+  struct ipa_alignment alignment;\n+\n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n      function context.  constant represents the actual constant in constant jump\n@@ -402,10 +416,19 @@ struct GTY(()) ipa_agg_replacement_value\n   bool by_ref;\n };\n \n-typedef struct ipa_agg_replacement_value *ipa_agg_replacement_value_p;\n+/* Structure holding information for the transformation phase of IPA-CP.  */\n+\n+struct GTY(()) ipcp_transformation_summary\n+{\n+  /* Linked list of known aggregate values.  */\n+  ipa_agg_replacement_value *agg_values;\n+  /* Alignment information for pointers.  */\n+  vec<ipa_alignment, va_gc> *alignments;\n+};\n \n void ipa_set_node_agg_value_chain (struct cgraph_node *node,\n \t\t\t\t   struct ipa_agg_replacement_value *aggvals);\n+void ipcp_grow_transformations_if_necessary (void);\n \n /* ipa_edge_args stores information related to a callsite and particularly its\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n@@ -451,8 +474,8 @@ ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)\n \n /* Vector where the parameter infos are actually stored. */\n extern vec<ipa_node_params> ipa_node_params_vector;\n-/* Vector of known aggregate values in cloned nodes.  */\n-extern GTY(()) vec<ipa_agg_replacement_value_p, va_gc> *ipa_node_agg_replacements;\n+/* Vector of IPA-CP transformation data for each clone.  */\n+extern GTY(()) vec<ipcp_transformation_summary, va_gc> *ipcp_transformations;\n /* Vector where the parameter infos are actually stored. */\n extern GTY(()) vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n@@ -510,14 +533,21 @@ ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)\n   return ((unsigned) edge->uid < vec_safe_length (ipa_edge_args_vector));\n }\n \n+static inline ipcp_transformation_summary *\n+ipcp_get_transformation_summary (cgraph_node *node)\n+{\n+  if ((unsigned) node->uid >= vec_safe_length (ipcp_transformations))\n+    return NULL;\n+  return &(*ipcp_transformations)[node->uid];\n+}\n+\n /* Return the aggregate replacements for NODE, if there are any.  */\n \n static inline struct ipa_agg_replacement_value *\n-ipa_get_agg_replacements_for_node (struct cgraph_node *node)\n+ipa_get_agg_replacements_for_node (cgraph_node *node)\n {\n-  if ((unsigned) node->uid >= vec_safe_length (ipa_node_agg_replacements))\n-    return NULL;\n-  return (*ipa_node_agg_replacements)[node->uid];\n+  ipcp_transformation_summary *ts = ipcp_get_transformation_summary (node);\n+  return ts ? ts->agg_values : NULL;\n }\n \n /* Function formal parameters related computations.  */\n@@ -646,8 +676,8 @@ void ipa_dump_agg_replacement_values (FILE *f,\n \t\t\t\t      struct ipa_agg_replacement_value *av);\n void ipa_prop_write_jump_functions (void);\n void ipa_prop_read_jump_functions (void);\n-void ipa_prop_write_all_agg_replacement (void);\n-void ipa_prop_read_all_agg_replacement (void);\n+void ipcp_write_transformation_summaries (void);\n+void ipcp_read_transformation_summaries (void);\n void ipa_update_after_lto_read (void);\n int ipa_get_param_decl_index (struct ipa_node_params *, tree);\n tree ipa_value_from_jfunc (struct ipa_node_params *info,"}, {"sha": "a0a78dc62b1d4bfe7189de393e7315fd2cf42606", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -1,3 +1,8 @@\n+2014-12-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/propalign-1.c: New test.\n+\t* gcc.dg/ipa/propalign-2.c: Likewise.\n+\n 2014-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/56493"}, {"sha": "4997c994fa42a827a428ffb701be722c586bb12a", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-1.c?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+extern int fail_the_test(void *);\n+extern int pass_the_test(void *);\n+extern int diversion (void *);\n+\n+static int __attribute__((noinline))\n+foo (void *p)\n+{\n+  uintptr_t a = (uintptr_t) p;\n+\n+  if (a % 4)\n+    return fail_the_test (p);\n+  else\n+    return pass_the_test (p);\n+}\n+\n+int\n+bar (void)\n+{\n+  double buf[8] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+  return foo (&buf);\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Adjusting alignment of param\" \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"fail_the_test\" \"optimized\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5a52648832fddb61042fafc2ca4b9b3dd392df83", "filename": "gcc/testsuite/gcc.dg/ipa/propalign-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04be694e4d9132523f01de8d9873c6b07164afb2/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropalign-2.c?ref=04be694e4d9132523f01de8d9873c6b07164afb2", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-early-inlining -fdump-ipa-cp -fdump-tree-optimized\" } */\n+\n+#include <stdint.h>\n+\n+extern int fail_the_test(void *);\n+extern int pass_the_test(void *);\n+extern int diversion (void *);\n+\n+struct somestruct\n+{\n+  void *whee;\n+  void *oops;\n+};\n+\n+struct container\n+{\n+  struct somestruct first;\n+  struct somestruct buf[32];\n+};\n+\n+static int __attribute__((noinline))\n+foo (void *p)\n+{\n+  uintptr_t a = (uintptr_t) p;\n+\n+  if (a % 4)\n+    return fail_the_test (p);\n+  else\n+    return pass_the_test (p);\n+}\n+\n+int\n+bar (void)\n+{\n+  struct container c;\n+  return foo (c.buf);\n+}\n+\n+\n+static int\n+through (struct somestruct *p)\n+{\n+  diversion (p);\n+  return foo (&p[16]);\n+}\n+\n+int\n+bar2 (void)\n+{\n+  struct container c;\n+  through (c.buf);\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Adjusting alignment of param\" \"cp\" } } */\n+/* { dg-final { scan-tree-dump-not \"fail_the_test\" \"optimized\" } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}