{"sha": "1515785dd0555ab9c9462012bde1060a586e8e39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUxNTc4NWRkMDU1NWFiOWM5NDYyMDEyYmRlMTA2MGE1ODZlOGUzOQ==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2010-06-23T08:28:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T08:28:20Z"}, "message": "decl.c (intrin_types_incompatible_p): New function, helper for ...\n\n2010-06-23  Olivier Hainque  <hainque@adacore.com>\n\n\t* gcc-interface/decl.c (intrin_types_incompatible_p): New function,\n\thelper for ...\n\t(intrin_arglists_compatible_p, intrin_return_compatible_p): New\n\tfunctions, helpers for ...\n\t(intrin_profiles_compatible_p): New function, replacement for ...\n\t(compatible_signatures_p): Removed.\n\t(gnat_to_gnu_entity) <case E_Procedure>: If -Wextra, warn on\n\tattempt to bind an unregistered builtin function.  When we have\n\tone, use it and warn on profile incompatibilities.\n\nFrom-SVN: r161257", "tree": {"sha": "238a10e5b32aa0c488387c153703a0e5d0000ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/238a10e5b32aa0c488387c153703a0e5d0000ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1515785dd0555ab9c9462012bde1060a586e8e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1515785dd0555ab9c9462012bde1060a586e8e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1515785dd0555ab9c9462012bde1060a586e8e39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1515785dd0555ab9c9462012bde1060a586e8e39/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "422f3939c395a9978bde5d8497a0b31482436a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/422f3939c395a9978bde5d8497a0b31482436a4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/422f3939c395a9978bde5d8497a0b31482436a4e"}], "stats": {"total": 260, "additions": 224, "deletions": 36}, "files": [{"sha": "ea8c7f5f4a10c596dacd2b0139d5d34961b2c4a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1515785dd0555ab9c9462012bde1060a586e8e39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1515785dd0555ab9c9462012bde1060a586e8e39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1515785dd0555ab9c9462012bde1060a586e8e39", "patch": "@@ -1,3 +1,15 @@\n+2010-06-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gcc-interface/decl.c (intrin_types_incompatible_p): New function,\n+\thelper for ...\n+\t(intrin_arglists_compatible_p, intrin_return_compatible_p): New\n+\tfunctions, helpers for ...\n+\t(intrin_profiles_compatible_p): New function, replacement for ...\n+\t(compatible_signatures_p): Removed.\n+\t(gnat_to_gnu_entity) <case E_Procedure>: If -Wextra, warn on\n+\tattempt to bind an unregistered builtin function.  When we have\n+\tone, use it and warn on profile incompatibilities.\n+\n 2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "020bc45a635495f9425c26b20f745e46e9552557", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 212, "deletions": 36, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1515785dd0555ab9c9462012bde1060a586e8e39/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1515785dd0555ab9c9462012bde1060a586e8e39/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1515785dd0555ab9c9462012bde1060a586e8e39", "patch": "@@ -154,13 +154,24 @@ static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n-static int compatible_signatures_p (tree, tree);\n static tree create_field_decl_from (tree, tree, tree, tree, tree, tree);\n static tree get_rep_part (tree);\n static tree get_variant_part (tree);\n static tree create_variant_part_from (tree, tree, tree, tree, tree);\n static void copy_and_substitute_in_size (tree, tree, tree);\n static void rest_of_type_decl_compilation_no_defer (tree);\n+\n+/* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n+   to pass around calls performing profile compatibilty checks.  */\n+\n+typedef struct {\n+  Entity_Id gnat_entity;  /* The Ada subprogram entity.  */\n+  tree ada_fntype;        /* The corresponding GCC type node.  */\n+  tree btin_fntype;       /* The GCC builtin function type node.  */\n+} intrin_binding_t;\n+\n+static bool intrin_profiles_compatible_p (intrin_binding_t *);\n+\n \f\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, return the equivalent GCC tree for that entity (a ..._DECL node)\n@@ -3906,9 +3917,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   We still want the parameter associations to take place because the\n \t   proper generation of calls depends on it (a GNAT parameter without\n \t   a corresponding GCC tree has a very specific meaning), so we don't\n-\t   just break here.  */\n-\tif (Convention (gnat_entity) == Convention_Intrinsic)\n-\t  gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n+\t   just \"break;\" here.  */\n+\tif (Convention (gnat_entity) == Convention_Intrinsic\n+\t    && Present (Interface_Name (gnat_entity)))\n+\t  {\n+\t    gnu_builtin_decl = builtin_decl_for (gnu_ext_name);\n+\n+\t    /* Post a \"Wextra\" warning if we couldn't find the decl.  Absence\n+\t       of a real intrinsic for an import is most often unexpected but\n+\t       allows hooking in alternate bodies, convenient in some cases so\n+\t       we don't want the warning to be unconditional.  */\n+\t    if (gnu_builtin_decl == NULL_TREE && extra_warnings)\n+\t      post_error (\"?gcc intrinsic not found for&!\", gnat_entity);\n+\t  }\n \n \t/* ??? What if we don't find the builtin node above ? warn ? err ?\n \t   In the current state we neither warn nor err, and calls will just\n@@ -4204,21 +4225,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    | (TYPE_QUAL_CONST * const_flag)\n \t\t\t\t    | (TYPE_QUAL_VOLATILE * volatile_flag));\n \n-\t/* If we have a builtin decl for that function, check the signatures\n-\t   compatibilities.  If the signatures are compatible, use the builtin\n-\t   decl.  If they are not, we expect the checker predicate to have\n-\t   posted the appropriate errors, and just continue with what we have\n-\t   so far.  */\n+\t/* If we have a builtin decl for that function, use it.  Check if the\n+\t   profiles are compatible and warn if they are not.  The checker is\n+\t   expected to post extra diagnostics in this case.  */\n \tif (gnu_builtin_decl)\n \t  {\n-\t    tree gnu_builtin_type = TREE_TYPE (gnu_builtin_decl);\n+\t    intrin_binding_t inb;\n \n-\t    if (compatible_signatures_p (gnu_type, gnu_builtin_type))\n-\t      {\n-\t\tgnu_decl = gnu_builtin_decl;\n-\t\tgnu_type = gnu_builtin_type;\n-\t\tbreak;\n-\t      }\n+\t    inb.gnat_entity = gnat_entity;\n+\t    inb.ada_fntype = gnu_type;\n+\t    inb.btin_fntype = TREE_TYPE (gnu_builtin_decl);\n+\n+\t    if (!intrin_profiles_compatible_p (&inb))\n+\t      post_error\n+\t\t(\"?profile of& doesn't match the builtin it binds!\",\n+\t\t gnat_entity);\n+\n+\t    gnu_decl = gnu_builtin_decl;\n+\t    gnu_type = TREE_TYPE (gnu_builtin_decl);\n+\t    break;\n \t  }\n \n \t/* If there was no specified Interface_Name and the external and\n@@ -8036,32 +8061,183 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, bool comp_p)\n \t\t   gnat_error_point, gnat_entity);\n }\n \f\n-/* Check if FTYPE1 and FTYPE2, two potentially different function type nodes,\n-   have compatible signatures so that a call using one type may be safely\n-   issued if the actual target function type is the other.  Return 1 if it is\n-   the case, 0 otherwise, and post errors on the incompatibilities.\n \n-   This is used when an Ada subprogram is mapped onto a GCC builtin, to ensure\n-   that calls to the subprogram will have arguments suitable for the later\n-   underlying builtin expansion.  */\n+/* Helper for the intrin compatibility checks family.  Evaluate whether\n+   two types are definitely incompatible.  */\n \n-static int\n-compatible_signatures_p (tree ftype1, tree ftype2)\n+static bool\n+intrin_types_incompatible_p (tree t1, tree t2)\n+{\n+  enum tree_code code;\n+\n+  if (TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+    return false;\n+\n+  if (TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return true;\n+\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return true;\n+\n+  code = TREE_CODE (t1);\n+\n+  switch (code)\n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+      return TYPE_PRECISION (t1) != TYPE_PRECISION (t2);\n+\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      /* Assume designated types are ok.  We'd need to account for char * and\n+\t void * variants to do better, which could rapidly get messy and isn't\n+\t clearly worth the effort.  */\n+      return false;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+/* Helper for intrin_profiles_compatible_p, to perform compatibility checks\n+   on the Ada/builtin argument lists for the INB binding.  */\n+\n+static bool\n+intrin_arglists_compatible_p (intrin_binding_t * inb)\n+{\n+  tree ada_args = TYPE_ARG_TYPES (inb->ada_fntype);\n+  tree btin_args = TYPE_ARG_TYPES (inb->btin_fntype);\n+\n+  /* Sequence position of the last argument we checked.  */\n+  int argpos = 0;\n+\n+  while (ada_args != 0 || btin_args != 0)\n+    {\n+      tree ada_type, btin_type;\n+\n+      /* If one list is shorter than the other, they fail to match.  */\n+      if (ada_args == 0 || btin_args == 0)\n+\treturn false;\n+\n+      ada_type = TREE_VALUE (ada_args);\n+      btin_type = TREE_VALUE (btin_args);\n+\n+      /* If we're done with the Ada args and not with the internal builtin\n+\t args, complain.  */\n+      if (ada_type == void_type_node\n+\t  && btin_type != void_type_node)\n+\t{\n+\t  post_error (\"?Ada arguments list too short!\", inb->gnat_entity);\n+\t  return false;\n+\t}\n+\n+      /* If we're done with the internal builtin args, check the remaining\n+\t args on the Ada side.  If they are all ints, assume these are access\n+\t levels and just ignore them with a conditional warning. Complain\n+\t otherwise.  */\n+      if (btin_type == void_type_node\n+\t  && ada_type != void_type_node)\n+\t{\n+\t  while (TREE_CODE (ada_type) == INTEGER_TYPE)\n+\t    {\n+\t      ada_args = TREE_CHAIN (ada_args);\n+\t      ada_type = TREE_VALUE (ada_args);\n+\t    }\n+\n+\t  if (ada_type != void_type_node)\n+\t    {\n+\t      post_error_ne_num (\"?Ada arguments list too long (> ^)!\",\n+\t\t\t\t inb->gnat_entity, inb->gnat_entity,\n+\t\t\t\t argpos);\n+\t      return false;\n+\t    }\n+\n+\t  else\n+\t    {\n+\t      if (extra_warnings)\n+\t\tpost_error (\"?trailing Ada integer args ignored for \"\n+\t\t\t    \"intrinsic binding!\",\n+\t\t\t    inb->gnat_entity);\n+\t      return true;\n+\t    }\n+\t}\n+\n+      /* Otherwise, check that types match for the current argument.  */\n+      argpos ++;\n+      if (intrin_types_incompatible_p (ada_type, btin_type))\n+\t{\n+\t  post_error_ne_num (\"?intrinsic binding type mismatch on argument ^!\",\n+\t\t\t     inb->gnat_entity, inb->gnat_entity, argpos);\n+\t  return false;\n+\t}\n+\n+      ada_args = TREE_CHAIN (ada_args);\n+      btin_args = TREE_CHAIN (btin_args);\n+    }\n+\n+  return true;\n+}\n+\n+/* Helper for intrin_profiles_compatible_p, to perform compatibility checks\n+   on the Ada/builtin return values for the INB binding.  */\n+\n+static bool\n+intrin_return_compatible_p (intrin_binding_t * inb)\n+{\n+  tree ada_return_type = TREE_TYPE (inb->ada_fntype);\n+  tree btin_return_type = TREE_TYPE (inb->btin_fntype);\n+\n+  if (VOID_TYPE_P (btin_return_type)\n+      && VOID_TYPE_P (ada_return_type))\n+    return true;\n+\n+  if (VOID_TYPE_P (ada_return_type)\n+      && !VOID_TYPE_P (btin_return_type))\n+    {\n+      if (extra_warnings)\n+\tpost_error (\"?builtin function imported as Ada procedure!\",\n+\t\t    inb->gnat_entity);\n+      return true;\n+    }\n+\n+  if (intrin_types_incompatible_p (btin_return_type, ada_return_type))\n+    {\n+      post_error (\"?intrinsic binding type mismatch on return value!\",\n+\t\t  inb->gnat_entity);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Check and return whether the Ada and gcc builtin profiles bound by INB are\n+   compatible.  Issue relevant warnings when they are not.\n+\n+   This is intended as a light check to diagnose the most obvious cases, not\n+   as a full fledged type compatiblity predicate.  It is the programmer's\n+   responsibility to ensure correctness of the Ada declarations in Imports,\n+   especially when binding straight to a compiler internal.  */\n+\n+static bool\n+intrin_profiles_compatible_p (intrin_binding_t * inb)\n {\n-  /* As of now, we only perform very trivial tests and consider it's the\n-     programmer's responsibility to ensure the type correctness in the Ada\n-     declaration, as in the regular Import cases.\n+  /* Check compatibility on return values and argument lists, each responsible\n+     for posting warnings as appropriate.  Ensure use of the proper sloc for\n+     this purpose.  */\n+\n+  bool arglists_compatible_p, return_compatible_p;\n+  location_t saved_location = input_location;\n+\n+  Sloc_to_locus (Sloc (inb->gnat_entity), &input_location);\n \n-     Mismatches typically result in either error messages from the builtin\n-     expander, internal compiler errors, or in a real call sequence.  This\n-     should be refined to issue diagnostics helping error detection and\n-     correction.  */\n+  return_compatible_p = intrin_return_compatible_p (inb);\n+  arglists_compatible_p = intrin_arglists_compatible_p (inb);\n \n-  /* Almost fake test, ensuring a use of each argument.  */\n-  if (ftype1 == ftype2)\n-    return 1;\n+  input_location = saved_location;\n \n-  return 1;\n+  return return_compatible_p && arglists_compatible_p;\n }\n \f\n /* Return a FIELD_DECL node modeled on OLD_FIELD.  FIELD_TYPE is its type"}]}