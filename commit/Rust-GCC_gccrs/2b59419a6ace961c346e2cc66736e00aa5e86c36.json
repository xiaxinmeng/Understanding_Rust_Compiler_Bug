{"sha": "2b59419a6ace961c346e2cc66736e00aa5e86c36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1OTQxOWE2YWNlOTYxYzM0NmUyY2M2NjczNmUwMGFhNWU4NmMzNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-05-02T20:42:23Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-05-02T20:42:23Z"}, "message": "(remap_split_bivs): New function.\n\n(unroll_loop): When remapping split bivs in the last instruction,\nhandle JUMP_INSNs in addition to INSNs.\n\nFrom-SVN: r7186", "tree": {"sha": "a672bf679f2cb389c84fa1488bdd5e2e35b9b82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a672bf679f2cb389c84fa1488bdd5e2e35b9b82f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b59419a6ace961c346e2cc66736e00aa5e86c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b59419a6ace961c346e2cc66736e00aa5e86c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b59419a6ace961c346e2cc66736e00aa5e86c36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b59419a6ace961c346e2cc66736e00aa5e86c36/comments", "author": null, "committer": null, "parents": [{"sha": "94c5035ecafac92b022b262289ff85ff43cad58d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c5035ecafac92b022b262289ff85ff43cad58d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c5035ecafac92b022b262289ff85ff43cad58d"}], "stats": {"total": 92, "additions": 57, "deletions": 35}, "files": [{"sha": "66e63d7af0e65541ccee5f5582c4b669769fc2ab", "filename": "gcc/unroll.c", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59419a6ace961c346e2cc66736e00aa5e86c36/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59419a6ace961c346e2cc66736e00aa5e86c36/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=2b59419a6ace961c346e2cc66736e00aa5e86c36", "patch": "@@ -201,6 +201,7 @@ static rtx approx_final_value ();\n static int find_splittable_regs ();\n static int find_splittable_givs ();\n static rtx fold_rtx_mult_add ();\n+static rtx remap_split_bivs ();\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n@@ -1032,47 +1033,15 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   /* If the loop is being partially unrolled, and the iteration variables\n      are being split, and are being renamed for the split, then must fix up\n-     the compare instruction at the end of the loop to refer to the new\n+     the compare/jump instruction at the end of the loop to refer to the new\n      registers.  This compare isn't copied, so the registers used in it\n      will never be replaced if it isn't done here.  */\n \n   if (unroll_type == UNROLL_MODULO)\n     {\n       insn = NEXT_INSN (copy_end);\n-      if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SET)\n-\t{\n-#if 0\n-\t  /* If non-reduced/final-value givs were split, then this would also\n-\t     have to remap those givs.  */\n-#endif\n-\n-\t  tem = SET_SRC (PATTERN (insn));\n-\t  /* The set source is a register.  */\n-\t  if (GET_CODE (tem) == REG)\n-\t    {\n-\t      if (REGNO (tem) < max_reg_before_loop\n-\t\t  && reg_iv_type[REGNO (tem)] == BASIC_INDUCT)\n-\t\tSET_SRC (PATTERN (insn))\n-\t\t  = reg_biv_class[REGNO (tem)]->biv->src_reg;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The set source is a compare of some sort.  */\n-\t      tem = XEXP (SET_SRC (PATTERN (insn)), 0);\n-\t      if (GET_CODE (tem) == REG\n-\t\t  && REGNO (tem) < max_reg_before_loop\n-\t\t  && reg_iv_type[REGNO (tem)] == BASIC_INDUCT)\n-\t\tXEXP (SET_SRC (PATTERN (insn)), 0)\n-\t\t  = reg_biv_class[REGNO (tem)]->biv->src_reg;\n-\t      \n-\t      tem = XEXP (SET_SRC (PATTERN (insn)), 1);\n-\t      if (GET_CODE (tem) == REG\n-\t\t  && REGNO (tem) < max_reg_before_loop\n-\t\t  && reg_iv_type[REGNO (tem)] == BASIC_INDUCT)\n-\t\tXEXP (SET_SRC (PATTERN (insn)), 1)\n-\t\t  = reg_biv_class[REGNO (tem)]->biv->src_reg;\n-\t    }\n-\t}\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+\tPATTERN (insn) = remap_split_bivs (PATTERN (insn));\n     }\n \n   /* For unroll_number - 1 times, make a copy of each instruction\n@@ -3311,3 +3280,56 @@ loop_iterations (loop_start, loop_end)\n \n   return tempu / i + ((tempu % i) != 0);\n }\n+\n+/* Replace uses of split bivs with their split psuedo register.  This is\n+   for original instructions which remain after loop unrolling without\n+   copying.  */\n+\n+static rtx\n+remap_split_bivs (x)\n+     rtx x;\n+{\n+  register enum rtx_code code;\n+  register int i;\n+  register char *fmt;\n+\n+  if (x == 0)\n+    return x;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return x;\n+\n+    case REG:\n+#if 0\n+      /* If non-reduced/final-value givs were split, then this would also\n+\t have to remap those givs also.  */\n+#endif\n+      if (REGNO (x) < max_reg_before_loop\n+\t  && reg_iv_type[REGNO (x)] == BASIC_INDUCT)\n+\treturn reg_biv_class[REGNO (x)]->biv->src_reg;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = remap_split_bivs (XEXP (x, i));\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    XVECEXP (x, i, j) = remap_split_bivs (XVECEXP (x, i, j));\n+\t}\n+    }\n+  return x;\n+}"}]}