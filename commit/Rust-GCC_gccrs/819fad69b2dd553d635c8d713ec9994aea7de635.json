{"sha": "819fad69b2dd553d635c8d713ec9994aea7de635", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5ZmFkNjliMmRkNTUzZDYzNWM4ZDcxM2VjOTk5NGFlYTdkZTYzNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T09:38:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-04T09:38:06Z"}, "message": "gigi.h (fill_vms_descriptor): Add third parameter gnat_actual\n\n2008-08-04  Doug Rupp  <rupp@adacore.com>\n\n\t* gigi.h (fill_vms_descriptor): Add third parameter gnat_actual\n\t* trans.c (call_to_gnu): Call fill_vms_descriptor with new parameter.\n\t* utils2.c (fill_vms_descriptor): Add third parameter for error sloc and\n\tuse it.  Calculate pointer range overflow using 64bit types.\n\nFrom-SVN: r138594", "tree": {"sha": "d77eb384b7e3af0d0ac468083db50e6cb85fa864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d77eb384b7e3af0d0ac468083db50e6cb85fa864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/819fad69b2dd553d635c8d713ec9994aea7de635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819fad69b2dd553d635c8d713ec9994aea7de635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819fad69b2dd553d635c8d713ec9994aea7de635", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819fad69b2dd553d635c8d713ec9994aea7de635/comments", "author": null, "committer": null, "parents": [{"sha": "48fbb62da172a73e7b585a272fada37f28443d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48fbb62da172a73e7b585a272fada37f28443d27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48fbb62da172a73e7b585a272fada37f28443d27"}], "stats": {"total": 74, "additions": 58, "deletions": 16}, "files": [{"sha": "beef1a470dccfa0bdbd6edd097f0400828763f5e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=819fad69b2dd553d635c8d713ec9994aea7de635", "patch": "@@ -1,3 +1,38 @@\n+2008-08-04  Doug Rupp  <rupp@adacore.com>\n+\n+\t* gigi.h (fill_vms_descriptor): Add third parameter gnat_actual\n+\t* trans.c (call_to_gnu): Call fill_vms_descriptor with new parameter.\n+\t* utils2.c (fill_vms_descriptor): Add third parameter for error sloc and\n+\tuse it.  Calculate pointer range overflow using 64bit types.\n+\n+2008-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Access_Definition): A formal object declaration is a\n+\tlegal context for an anonymous access to subprogram.\n+\n+\t* sem_ch4.adb (Analyze_One_Call): If the call can be interpreted as an\n+\tindirect call, report success to the caller to include possible\n+\tinterpretation.\n+\n+\t* sem_ch6.adb (Check_Return_Type_Indication): Apply proper conformance\n+\tcheck when the type\n+\tof the extended return is an anonymous access_to_subprogram type.\n+\n+\t* sem_res.adb:\n+\t(Resolve_Call): Insert a dereference if the type of the subprogram is an\n+\taccess_to_subprogram and the context requires its return type, and a\n+\tdereference has not been introduced previously.\n+\n+2008-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* usage.adb (Usage): Minor rewording of -gnatwz switch, to improve\n+\tgnatcheck support in GPS.\n+\n+2008-08-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* mlib.adb (Create_Sym_Links): Create relative symbolic links when\n+\trequested\n+\n 2008-08-04  Vincent Celier  <celier@adacore.com>\n \n \t* gprep.adb (Process_One_File): Call Prep.Preprocess with a Boolean"}, {"sha": "1b3fa24137c17e687a636ff8e2dc3862c74aeb66", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=819fad69b2dd553d635c8d713ec9994aea7de635", "patch": "@@ -853,8 +853,10 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Node_Id gnat_node, bool);\n \n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record. */\n-extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal);\n+   GNAT_FORMAL is how we find the descriptor record. GNAT_ACTUAL is how\n+   we derive the source location on a C_E */\n+extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal,\n+                                 Node_Id gnat_actual);\n \n /* Indicate that we need to make the address of EXPR_NODE and it therefore\n    should not be allocated in a register.  Return true if successful.  */"}, {"sha": "97ff3bd2269863851bceac609ac3e52412e6d2e1", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=819fad69b2dd553d635c8d713ec9994aea7de635", "patch": "@@ -2392,7 +2392,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  else\n \t    gnu_actual = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t fill_vms_descriptor (gnu_actual,\n-\t\t\t\t\t\t\t      gnat_formal));\n+\t\t\t\t\t\t\t      gnat_formal,\n+\t\t\t\t\t\t\t      gnat_actual));\n \t}\n       else\n \t{"}, {"sha": "89fb5f0f419254ca1492a80da68a1e2596b11734", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819fad69b2dd553d635c8d713ec9994aea7de635/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=819fad69b2dd553d635c8d713ec9994aea7de635", "patch": "@@ -2160,11 +2160,11 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \f\n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n    GNAT_FORMAL is how we find the descriptor record.  GNAT_ACTUAL is\n-   how we find the allocator size which determines whether to use the\n-   alternate 64bit descriptor. */\n+   how we derive the source location to raise C_E on an out of range\n+   pointer. */\n \n tree\n-fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n+fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n {\n   tree field;\n   tree parm_decl = get_gnu_tree (gnat_formal);\n@@ -2173,7 +2173,6 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n   int do_range_check =\n       strcmp (\"MBO\",\n \t      IDENTIFIER_POINTER (DECL_NAME (TYPE_FIELDS (record_type))));\n-  tree malloc64low = build_int_cstu (long_integer_type_node, 0x80000000);\n \n   expr = maybe_unconstrained_array (expr);\n   gnat_mark_addressable (expr);\n@@ -2189,15 +2188,20 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n       if (do_range_check &&\n           strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), \"POINTER\") == 0)\n         {\n-          tree t = build3 (COND_EXPR, void_type_node,\n-\t\t\t   build_binary_op (GE_EXPR, long_integer_type_node,\n-\t\t\t\t\t    convert (long_integer_type_node,\n-\t\t\t\t\t\t     conexpr), \n-\t\t\t\t\t    malloc64low),\n-\t\t\t   build_call_raise (CE_Range_Check_Failed, Empty,\n-\t\t\t\t\t     N_Raise_Constraint_Error),\n-\t\t\t   NULL_TREE);\n-\t  add_stmt_with_node (t, gnat_formal);\n+\t  tree pointer64type =\n+\t     build_pointer_type_for_mode (void_type_node, DImode, false);\n+\t  tree addr64expr = build_unary_op (ADDR_EXPR, pointer64type, expr);\n+\t  tree malloc64low =\n+\t     build_int_cstu (long_integer_type_node, 0x80000000);\n+\n+\t  add_stmt (build3 (COND_EXPR, void_type_node,\n+\t\t\t    build_binary_op (GE_EXPR, long_integer_type_node,\n+\t\t\t\t\t     convert (long_integer_type_node,\n+\t\t\t\t\t\t      addr64expr), \n+\t\t\t\t\t     malloc64low),\n+\t\t\t    build_call_raise (CE_Range_Check_Failed, gnat_actual,\n+\t\t\t\t\t      N_Raise_Constraint_Error),\n+\t\t\t    NULL_TREE));\n         }\n       const_list = tree_cons (field, conexpr, const_list);\n     }"}]}