{"sha": "ab487f123ade7120fbe5304b91e45091c3bc0d96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0ODdmMTIzYWRlNzEyMGZiZTUzMDRiOTFlNDUwOTFjM2JjMGQ5Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:45:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-04T01:45:02Z"}, "message": "(PLACEHOLDER_EXPR, WITH_RECORD_EXPR): New tree codes.\n\nFrom-SVN: r5579", "tree": {"sha": "44a67cde1a7e85e4c1dfd830c982ef56364c65f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44a67cde1a7e85e4c1dfd830c982ef56364c65f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab487f123ade7120fbe5304b91e45091c3bc0d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab487f123ade7120fbe5304b91e45091c3bc0d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab487f123ade7120fbe5304b91e45091c3bc0d96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab487f123ade7120fbe5304b91e45091c3bc0d96/comments", "author": null, "committer": null, "parents": [{"sha": "0c0600d5d578c46eab15040d81cf2029ecdea225", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c0600d5d578c46eab15040d81cf2029ecdea225", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c0600d5d578c46eab15040d81cf2029ecdea225"}], "stats": {"total": 46, "additions": 46, "deletions": 0}, "files": [{"sha": "97ee43ed67bbd04a48ab9dc205f598087929d10f", "filename": "gcc/tree.def", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab487f123ade7120fbe5304b91e45091c3bc0d96/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab487f123ade7120fbe5304b91e45091c3bc0d96/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ab487f123ade7120fbe5304b91e45091c3bc0d96", "patch": "@@ -442,6 +442,52 @@ DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n    which is not at precisely the same time that this value is computed.  */\n DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n \n+/* The following two codes are used in languages that have types where\n+   the position and/or sizes of fields vary from object to object of the\n+   same type, i.e., where some other field in the object contains a value\n+   that is used in the computation of another field's offset or size.\n+\n+   For example, a record type with a discriminant in Ada is such a type.\n+   This mechanism is also used to create \"fat pointers\" for unconstrained\n+   array types in Ada; the fat pointer is a structure one of whose fields is\n+   a pointer to the actual array type and the other field is a pointer to a\n+   template, which is a structure containing the bounds of the array.  The\n+   bounds in the type pointed to by the first field in the fat pointer refer\n+   to the values in the template.\n+\n+   These \"self-references\" are doing using a PLACEHOLDER_EXPR.  This is a\n+   node that will later be replaced with the object being referenced.  Its type\n+   is that of the object and selects which object to use from a chain of\n+   references (see below).\n+\n+   When we wish to evaluate a size or offset, we check it is contains a\n+   placeholder.  If it does, we construct a WITH_RECORD_EXPR that contains\n+   both the expression we wish to evaluate and an expression within which the\n+   object may be found.  The latter expression is the object itself in\n+   the simple case of an Ada record with discriminant, but it can be the\n+   array in the case of an unconstrained array.\n+\n+   In the latter case, we need the fat pointer, because the bounds of the\n+   array can only be accessed from it.  However, we rely here on the fact that\n+   the expression for the array contains the dereference of the fat pointer\n+   that obtained the array pointer.\n+\n+   Accordingly, when looking for the object to substitute in place of\n+   a PLACEHOLDER_EXPR, we look down the first operand of the expression\n+   passed as the second operand to WITH_RECORD_EXPR until we find something\n+   of the desired type or reach a constant.  */\n+\n+/* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n+   evaluating this expression.  The type of this expression is used to\n+   find the record to replace it.  */\n+DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", \"x\", 0)\n+\n+/* Provide an expression that references a record to be used in place\n+   of a PLACEHOLDER_EXPR.  The record to be used is the record within\n+   operand 1 that has the same type as the PLACEHOLDER_EXPR in\n+   operand 0.  */\n+DEFTREECODE (WITH_RECORD_EXPR, \"with_record_expr\", \"e\", 2)\n+\n /* Simple arithmetic.  Operands must have the same machine mode\n    and the value shares that mode.  */\n DEFTREECODE (PLUS_EXPR, \"plus_expr\", \"2\", 2)"}]}