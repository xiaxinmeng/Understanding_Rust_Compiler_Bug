{"sha": "fba4b86109078adda686acc0102a923de709146d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhNGI4NjEwOTA3OGFkZGE2ODZhY2MwMTAyYTkyM2RlNzA5MTQ2ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-01-05T00:43:53Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-01-05T00:43:53Z"}, "message": "re PR target/71977 (powerpc64: Use VSR when operating on float and integer)\n\n[gcc]\n2017-01-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/71977\n\tPR target/70568\n\tPR target/78823\n\t* config/rs6000/predicates.md (sf_subreg_operand): New predicate.\n\t(altivec_register_operand): Do not return true if the operand\n\tcontains a SUBREG mixing SImode and SFmode.\n\t(vsx_register_operand): Likewise.\n\t(vsx_reg_sfsubreg_ok): New predicate.\n\t(vfloat_operand): Do not return true if the operand contains a\n\tSUBREG mixing SImode and SFmode.\n\t(vint_operand): Likewise.\n\t(vlogical_operand): Likewise.\n\t(gpc_reg_operand): Likewise.\n\t(int_reg_operand): Likewise.\n\t* config/rs6000/rs6000-protos.h (valid_sf_si_move): Add\n\tdeclaration.\n\t* config/rs6000/rs6000.c (valid_sf_si_move): New function to\n\tdetermine if a MOVSI or MOVSF operation contains SUBREGs that mix\n\tSImode and SFmode.\n\t(rs6000_emit_move_si_sf_subreg): New helper function.\n\t(rs6000_emit_move): Call rs6000_emit_move_si_sf_subreg to possbily\n\tfixup SUBREGs involving SImode and SFmode.\n\t* config/rs6000/vsx.md (SFBOOL_*): New constants that are operand\n\tnumbers for the new peephole2 optimization.\n\t(peephole2 for SFmode unions): New peephole2 to optimize cases in\n\tthe GLIBC math library that do AND/IOR/XOR operations on single\n\tprecision floating point.\n\t* config/rs6000/rs6000.h (TARGET_NO_SF_SUBREG): New internal\n\ttarget macros to say whether we need to avoid SUBREGs mixing\n\tSImode and SFmode.\n\t(TARGET_ALLOW_SF_SUBREG): Likewise.\n\t* config/rs6000/rs6000.md (UNSPEC_SF_FROM_SI): New unspecs.\n\t(UNSPEC_SI_FROM_SF): Likewise.\n\t(iorxor): Change spacing.\n\t(and_ior_xor): New iterator for AND, IOR, and XOR.\n\t(movsi_from_sf): New insns for SImode/SFmode SUBREG support.\n\t(movdi_from_sf_zero_ext): Likewise.\n\t(mov<mode>_hardfloat, FMOVE32 iterator): Use register_operand\n\tinstead of gpc_reg_operand.  Add SImode/SFmode SUBREG support.\n\t(movsf_from_si): New insn for SImode/SFmode SUBREG support.\n\t(fma<mode>4): Use gpc_reg_operand instead of register_operand.\n\t(fms<mode>4): Likewise.\n\t(fnma<mode>4): Likewise.\n\t(fnms<mode>4): Likewise.\n\t(nfma<mode>4): Likewise.\n\t(nfms<mode>4): Likewise.\n\n[gcc/testsuite]\n2017-01-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/71977\n\tPR target/70568\n\tPR target/78823\n\t* gcc.target/powerpc/pr71977-1.c: New tests to check whether on\n\t64-bit VSX systems with direct move, whether we optimize common\n\tcode sequences in the GLIBC math library for float math functions.\n\t* gcc.target/powerpc/pr71977-2.c: Likewise.\n\nFrom-SVN: r244084", "tree": {"sha": "1ffb01e9976fb8f0d809af16216a991e6b0ed161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ffb01e9976fb8f0d809af16216a991e6b0ed161"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba4b86109078adda686acc0102a923de709146d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba4b86109078adda686acc0102a923de709146d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba4b86109078adda686acc0102a923de709146d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba4b86109078adda686acc0102a923de709146d/comments", "author": null, "committer": null, "parents": [{"sha": "179925d29437d746823df8f4612c8b42652773d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/179925d29437d746823df8f4612c8b42652773d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/179925d29437d746823df8f4612c8b42652773d1"}], "stats": {"total": 734, "additions": 699, "deletions": 35}, "files": [{"sha": "e0a57f12768395c2d3226f5f4bd90a3b993a459e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -1,3 +1,52 @@\n+2017-01-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/71977\n+\tPR target/70568\n+\tPR target/78823\n+\t* config/rs6000/predicates.md (sf_subreg_operand): New predicate.\n+\t(altivec_register_operand): Do not return true if the operand\n+\tcontains a SUBREG mixing SImode and SFmode.\n+\t(vsx_register_operand): Likewise.\n+\t(vsx_reg_sfsubreg_ok): New predicate.\n+\t(vfloat_operand): Do not return true if the operand contains a\n+\tSUBREG mixing SImode and SFmode.\n+\t(vint_operand): Likewise.\n+\t(vlogical_operand): Likewise.\n+\t(gpc_reg_operand): Likewise.\n+\t(int_reg_operand): Likewise.\n+\t* config/rs6000/rs6000-protos.h (valid_sf_si_move): Add\n+\tdeclaration.\n+\t* config/rs6000/rs6000.c (valid_sf_si_move): New function to\n+\tdetermine if a MOVSI or MOVSF operation contains SUBREGs that mix\n+\tSImode and SFmode.\n+\t(rs6000_emit_move_si_sf_subreg): New helper function.\n+\t(rs6000_emit_move): Call rs6000_emit_move_si_sf_subreg to possbily\n+\tfixup SUBREGs involving SImode and SFmode.\n+\t* config/rs6000/vsx.md (SFBOOL_*): New constants that are operand\n+\tnumbers for the new peephole2 optimization.\n+\t(peephole2 for SFmode unions): New peephole2 to optimize cases in\n+\tthe GLIBC math library that do AND/IOR/XOR operations on single\n+\tprecision floating point.\n+\t* config/rs6000/rs6000.h (TARGET_NO_SF_SUBREG): New internal\n+\ttarget macros to say whether we need to avoid SUBREGs mixing\n+\tSImode and SFmode.\n+\t(TARGET_ALLOW_SF_SUBREG): Likewise.\n+\t* config/rs6000/rs6000.md (UNSPEC_SF_FROM_SI): New unspecs.\n+\t(UNSPEC_SI_FROM_SF): Likewise.\n+\t(iorxor): Change spacing.\n+\t(and_ior_xor): New iterator for AND, IOR, and XOR.\n+\t(movsi_from_sf): New insns for SImode/SFmode SUBREG support.\n+\t(movdi_from_sf_zero_ext): Likewise.\n+\t(mov<mode>_hardfloat, FMOVE32 iterator): Use register_operand\n+\tinstead of gpc_reg_operand.  Add SImode/SFmode SUBREG support.\n+\t(movsf_from_si): New insn for SImode/SFmode SUBREG support.\n+\t(fma<mode>4): Use gpc_reg_operand instead of register_operand.\n+\t(fms<mode>4): Likewise.\n+\t(fnma<mode>4): Likewise.\n+\t(fnms<mode>4): Likewise.\n+\t(nfma<mode>4): Likewise.\n+\t(nfms<mode>4): Likewise.\n+\n 2017-01-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/64767"}, {"sha": "3d69fc86deef20984f38e727e05e1e4f48d82c18", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -31,12 +31,47 @@\n        (match_test \"REGNO (op) == CTR_REGNO\n \t\t    || REGNO (op) > LAST_VIRTUAL_REGISTER\")))\n \n+;; Return 1 if op is a SUBREG that is used to look at a SFmode value as\n+;; and integer or vice versa.\n+;;\n+;; In the normal case where SFmode is in a floating point/vector register, it\n+;; is stored as a DFmode and has a different format.  If we don't transform the\n+;; value, things that use logical operations on the values will get the wrong\n+;; value.\n+;;\n+;; If we don't have 64-bit and direct move, this conversion will be done by\n+;; store and load, instead of by fiddling with the bits within the register.\n+(define_predicate \"sf_subreg_operand\"\n+  (match_code \"subreg\")\n+{\n+  rtx inner_reg = SUBREG_REG (op);\n+  machine_mode inner_mode = GET_MODE (inner_reg);\n+\n+  if (TARGET_ALLOW_SF_SUBREG || !REG_P (inner_reg))\n+    return 0;\n+\n+  if ((mode == SFmode && GET_MODE_CLASS (inner_mode) == MODE_INT)\n+       || (GET_MODE_CLASS (mode) == MODE_INT && inner_mode == SFmode))\n+    {\n+      if (INT_REGNO_P (REGNO (inner_reg)))\n+\treturn 0;\n+\n+      return 1;\n+    }\n+  return 0;\n+})\n+\n ;; Return 1 if op is an Altivec register.\n (define_predicate \"altivec_register_operand\"\n   (match_operand 0 \"register_operand\")\n {\n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n \n   if (!REG_P (op))\n     return 0;\n@@ -50,6 +85,27 @@\n ;; Return 1 if op is a VSX register.\n (define_predicate \"vsx_register_operand\"\n   (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (!REG_P (op))\n+    return 0;\n+\n+  if (REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+    return 1;\n+\n+  return VSX_REGNO_P (REGNO (op));\n+})\n+\n+;; Like vsx_register_operand, but allow SF SUBREGS\n+(define_predicate \"vsx_reg_sfsubreg_ok\"\n+  (match_operand 0 \"register_operand\")\n {\n   if (GET_CODE (op) == SUBREG)\n     op = SUBREG_REG (op);\n@@ -69,7 +125,12 @@\n   (match_operand 0 \"register_operand\")\n {\n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n \n   if (!REG_P (op))\n     return 0;\n@@ -86,7 +147,12 @@\n   (match_operand 0 \"register_operand\")\n {\n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n \n   if (!REG_P (op))\n     return 0;\n@@ -103,7 +169,13 @@\n   (match_operand 0 \"register_operand\")\n {\n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n \n   if (!REG_P (op))\n     return 0;\n@@ -221,14 +293,22 @@\n        (match_test \"IN_RANGE (INTVAL (op), 0, 15)\")))\n \n ;; Return 1 if op is a register that is not special.\n+;; Disallow (SUBREG:SF (REG:SI)) and (SUBREG:SI (REG:SF)) on VSX systems where\n+;; you need to be careful in moving a SFmode to SImode and vice versa due to\n+;; the fact that SFmode is represented as DFmode in the VSX registers.\n (define_predicate \"gpc_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n   if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n \n   if (!REG_P (op))\n     return 0;\n@@ -246,15 +326,21 @@\n })\n \n ;; Return 1 if op is a general purpose register.  Unlike gpc_reg_operand, don't\n-;; allow floating point or vector registers.\n+;; allow floating point or vector registers.  Since vector registers are not\n+;; allowed, we don't have to reject SFmode/SImode subregs.\n (define_predicate \"int_reg_operand\"\n   (match_operand 0 \"register_operand\")\n {\n   if ((TARGET_E500_DOUBLE || TARGET_SPE) && invalid_e500_subreg (op, mode))\n     return 0;\n \n   if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n+    {\n+      if (TARGET_NO_SF_SUBREG && sf_subreg_operand (op, mode))\n+\treturn 0;\n+\n+      op = SUBREG_REG (op);\n+    }\n \n   if (!REG_P (op))\n     return 0;\n@@ -266,6 +352,8 @@\n })\n \n ;; Like int_reg_operand, but don't return true for pseudo registers\n+;; We don't have to check for SF SUBREGS because pseudo registers\n+;; are not allowed, and SF SUBREGs are ok within GPR registers.\n (define_predicate \"int_reg_operand_not_pseudo\"\n   (match_operand 0 \"register_operand\")\n {"}, {"sha": "c20d3b5271e354c8de9d28588e27d198443d5108", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -153,6 +153,7 @@ extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n+extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (machine_mode);\n extern machine_mode rs6000_secondary_memory_needed_mode (machine_mode);"}, {"sha": "fe858738d380571cbe258cbb6a1362aadfdb29e9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -10402,6 +10402,78 @@ rs6000_emit_le_vsx_move (rtx dest, rtx source, machine_mode mode)\n     }\n }\n \n+/* Return whether a SFmode or SImode move can be done without converting one\n+   mode to another.  This arrises when we have:\n+\n+\t(SUBREG:SF (REG:SI ...))\n+\t(SUBREG:SI (REG:SF ...))\n+\n+   and one of the values is in a floating point/vector register, where SFmode\n+   scalars are stored in DFmode format.  */\n+\n+bool\n+valid_sf_si_move (rtx dest, rtx src, machine_mode mode)\n+{\n+  if (TARGET_ALLOW_SF_SUBREG)\n+    return true;\n+\n+  if (mode != SFmode && GET_MODE_CLASS (mode) != MODE_INT)\n+    return true;\n+\n+  if (!SUBREG_P (src) || !sf_subreg_operand (src, mode))\n+    return true;\n+\n+  /*.  Allow (set (SUBREG:SI (REG:SF)) (SUBREG:SI (REG:SF))).  */\n+  if (SUBREG_P (dest))\n+    {\n+      rtx dest_subreg = SUBREG_REG (dest);\n+      rtx src_subreg = SUBREG_REG (src);\n+      return GET_MODE (dest_subreg) == GET_MODE (src_subreg);\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Helper function to change moves with:\n+\n+\t(SUBREG:SF (REG:SI)) and\n+\t(SUBREG:SI (REG:SF))\n+\n+   into separate UNSPEC insns.  In the PowerPC architecture, scalar SFmode\n+   values are stored as DFmode values in the VSX registers.  We need to convert\n+   the bits before we can use a direct move or operate on the bits in the\n+   vector register as an integer type.\n+\n+   Skip things like (set (SUBREG:SI (...) (SUBREG:SI (...)).  */\n+\n+static bool\n+rs6000_emit_move_si_sf_subreg (rtx dest, rtx source, machine_mode mode)\n+{\n+  if (TARGET_DIRECT_MOVE_64BIT && !reload_in_progress && !reload_completed\n+      && !lra_in_progress\n+      && (!SUBREG_P (dest) || !sf_subreg_operand (dest, mode))\n+      && SUBREG_P (source) && sf_subreg_operand (source, mode))\n+    {\n+      rtx inner_source = SUBREG_REG (source);\n+      machine_mode inner_mode = GET_MODE (inner_source);\n+\n+      if (mode == SImode && inner_mode == SFmode)\n+\t{\n+\t  emit_insn (gen_movsi_from_sf (dest, inner_source));\n+\t  return true;\n+\t}\n+\n+      if (mode == SFmode && inner_mode == SImode)\n+\t{\n+\t  emit_insn (gen_movsf_from_si (dest, inner_source));\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n@@ -10432,6 +10504,11 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       gcc_unreachable ();\n     }\n \n+  /* See if we need to special case SImode/SFmode SUBREG moves.  */\n+  if ((mode == SImode || mode == SFmode) && SUBREG_P (source)\n+      && rs6000_emit_move_si_sf_subreg (dest, source, mode))\n+    return;\n+\n   /* Check if GCC is setting up a block move that will end up using FP\n      registers as temporaries.  We must make sure this is acceptable.  */\n   if (GET_CODE (operands[0]) == MEM"}, {"sha": "0180e0c3dfd851998a8b3fa37759e2babb2fd67f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -608,6 +608,12 @@ extern int rs6000_vector_align[];\n \t\t\t\t && TARGET_POWERPC64)\n #define TARGET_VEXTRACTUB\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n \t\t\t\t && TARGET_UPPER_REGS_DI && TARGET_POWERPC64)\n+\n+\n+/* Whether we should avoid (SUBREG:SI (REG:SF) and (SUBREG:SF (REG:SI).  */\n+#define TARGET_NO_SF_SUBREG\tTARGET_DIRECT_MOVE_64BIT\n+#define TARGET_ALLOW_SF_SUBREG\t(!TARGET_DIRECT_MOVE_64BIT)\n+\n /* This wants to be set for p8 and newer.  On p7, overlapping unaligned\n    loads are slow. */\n #define TARGET_EFFICIENT_OVERLAPPING_UNALIGNED TARGET_EFFICIENT_UNALIGNED_VSX"}, {"sha": "f7c1ab26a9917476a8d9ef02b19332174350658b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 253, "deletions": 28, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -150,6 +150,8 @@\n    UNSPEC_IEEE128_CONVERT\n    UNSPEC_SIGNBIT\n    UNSPEC_DOLOOP\n+   UNSPEC_SF_FROM_SI\n+   UNSPEC_SI_FROM_SF\n   ])\n \n ;;\n@@ -561,7 +563,8 @@\n (define_code_attr return_str [(return \"\") (simple_return \"simple_\")])\n \n ; Logical operators.\n-(define_code_iterator iorxor [ior xor])\n+(define_code_iterator iorxor\t\t[ior xor])\n+(define_code_iterator and_ior_xor\t[and ior xor])\n \n ; Signed/unsigned variants of ops.\n (define_code_iterator any_extend\t[sign_extend zero_extend])\n@@ -6768,6 +6771,157 @@\n   [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,mtjmpr,*,*,fpstore,fpload\")\n    (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4\")])\n \n+;; Like movsi, but adjust a SF value to be used in a SI context, i.e.\n+;; (set (reg:SI ...) (subreg:SI (reg:SF ...) 0))\n+;;\n+;; Because SF values are actually stored as DF values within the vector\n+;; registers, we need to convert the value to the vector SF format when\n+;; we need to use the bits in a union or similar cases.  We only need\n+;; to do this transformation when the value is a vector register.  Loads,\n+;; stores, and transfers within GPRs are assumed to be safe.\n+;;\n+;; This is a more general case of reload_gpr_from_vsxsf.  That insn must have\n+;; no alternatives, because the call is created as part of secondary_reload,\n+;; and operand #2's register class is used to allocate the temporary register.\n+;; This function is called before reload, and it creates the temporary as\n+;; needed.\n+\n+;;\t\tMR           LWZ          LFIWZX       LXSIWZX   STW\n+;;\t\tSTFS         STXSSP       STXSSPX      VSX->GPR  MTVSRWZ\n+;;\t\tVSX->VSX\n+\n+(define_insn_and_split \"movsi_from_sf\"\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\"\n+\t\t\"=r,         r,           ?*wI,        ?*wH,     m,\n+\t\t m,          wY,          Z,           r,        wIwH,\n+\t\t ?wK\")\n+\n+\t(unspec:SI [(match_operand:SF 1 \"input_operand\"\n+\t\t\"r,          m,           Z,           Z,        r,\n+\t\t f,          wu,          wu,          wIwH,     r,\n+\t\t wK\")]\n+\t\t    UNSPEC_SI_FROM_SF))\n+\n+   (clobber (match_scratch:V4SF 2\n+\t\t\"=X,         X,           X,           X,        X,\n+\t\t X,          X,           X,           wa,       X,\n+\t\t wa\"))]\n+\n+  \"TARGET_NO_SF_SUBREG\n+   && (register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   mr %0,%1\n+   lwz%U1%X1 %0,%1\n+   lfiwzx %0,%y1\n+   lxsiwzx %x0,%y1\n+   stw%U0%X0 %1,%0\n+   stfs%U0%X0 %1,%0\n+   stxssp %1,%0\n+   stxsspx %x1,%y0\n+   #\n+   mtvsrwz %x0,%1\n+   #\"\n+  \"&& reload_completed\n+   && register_operand (operands[0], SImode)\n+   && vsx_reg_sfsubreg_ok (operands[1], SFmode)\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op0_di = gen_rtx_REG (DImode, REGNO (op0));\n+\n+  emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n+\n+  if (int_reg_operand (op0, SImode))\n+    {\n+      emit_insn (gen_p8_mfvsrd_4_disf (op0_di, op2));\n+      emit_insn (gen_lshrdi3 (op0_di, op0_di, GEN_INT (32)));\n+    }\n+  else\n+    {\n+      rtx op1_v16qi = gen_rtx_REG (V16QImode, REGNO (op1));\n+      rtx byte_off = VECTOR_ELT_ORDER_BIG ? const0_rtx : GEN_INT (12);\n+      emit_insn (gen_vextract4b (op0_di, op1_v16qi, byte_off));\n+    }\n+\n+  DONE;\n+}\n+  [(set_attr \"type\"\n+\t\t\"*,          load,        fpload,      fpload,   store,\n+\t\t fpstore,    fpstore,     fpstore,     mftgpr,   mffgpr,\n+\t\t veclogical\")\n+\n+   (set_attr \"length\"\n+\t\t\"4,          4,           4,           4,        4,\n+\t\t 4,          4,           4,           12,       4,\n+\t\t 8\")])\n+\n+;; movsi_from_sf with zero extension\n+;;\n+;;\t\tRLDICL       LWZ          LFIWZX       LXSIWZX   VSX->GPR\n+;;\t\tMTVSRWZ      VSX->VSX\n+\n+(define_insn_and_split \"*movdi_from_sf_zero_ext\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\"\n+\t\t\"=r,         r,           ?*wI,        ?*wH,     r,\n+\t\twIwH,        ?wK\")\n+\n+\t(zero_extend:DI\n+\t (unspec:SI [(match_operand:SF 1 \"input_operand\"\n+\t\t\"r,          m,           Z,           Z,        wIwH,\n+\t\t r,          wK\")]\n+\t\t    UNSPEC_SI_FROM_SF)))\n+\n+   (clobber (match_scratch:V4SF 2\n+\t\t\"=X,         X,           X,           X,        wa,\n+\t\t X,          wa\"))]\n+\n+  \"TARGET_DIRECT_MOVE_64BIT\n+   && (register_operand (operands[0], DImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"@\n+   rldicl %0,%1,0,32\n+   lwz%U1%X1 %0,%1\n+   lfiwzx %0,%y1\n+   lxsiwzx %x0,%y1\n+   #\n+   mtvsrwz %x0,%1\n+   #\"\n+  \"&& reload_completed\n+   && vsx_reg_sfsubreg_ok (operands[1], SFmode)\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+\n+  emit_insn (gen_vsx_xscvdpspn_scalar (op2, op1));\n+\n+  if (int_reg_operand (op0, DImode))\n+    {\n+      emit_insn (gen_p8_mfvsrd_4_disf (op0, op2));\n+      emit_insn (gen_lshrdi3 (op0, op0, GEN_INT (32)));\n+    }\n+  else\n+    {\n+      rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));\n+      rtx op1_v16qi = gen_rtx_REG (V16QImode, REGNO (op1));\n+      rtx byte_off = VECTOR_ELT_ORDER_BIG ? const0_rtx : GEN_INT (12);\n+      emit_insn (gen_vextract4b (op0_si, op1_v16qi, byte_off));\n+    }\n+\n+  DONE;\n+}\n+  [(set_attr \"type\"\n+\t\t\"*,          load,        fpload,      fpload,  mftgpr,\n+\t\t mffgpr,     veclogical\")\n+\n+   (set_attr \"length\"\n+\t\t\"4,          4,           4,           4,        12,\n+\t\t 4,          8\")])\n+\n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n \n@@ -6977,9 +7131,11 @@\n \t \"m,         <f32_lm>,  <f32_lm2>, Z,         r,         <f32_sr>,\n \t  <f32_sr2>, <f32_av>,  <zero_fp>, <zero_fp>, r,         <f32_dm>,\n \t  f,         <f32_vsx>, r,         r,         *h,        0\"))]\n-  \"(gpc_reg_operand (operands[0], <MODE>mode)\n-   || gpc_reg_operand (operands[1], <MODE>mode))\n-   && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n+  \"(register_operand (operands[0], <MODE>mode)\n+   || register_operand (operands[1], <MODE>mode))\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT\n+   && (TARGET_ALLOW_SF_SUBREG\n+       || valid_sf_si_move (operands[0], operands[1], <MODE>mode))\"\n   \"@\n    lwz%U1%X1 %0,%1\n    <f32_li>\n@@ -7021,6 +7177,75 @@\n   [(set_attr \"type\" \"*,mtjmpr,mfjmpr,load,store,*,*,*,*,*\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,8,4\")])\n \n+;; Like movsf, but adjust a SI value to be used in a SF context, i.e.\n+;; (set (reg:SF ...) (subreg:SF (reg:SI ...) 0))\n+;;\n+;; Because SF values are actually stored as DF values within the vector\n+;; registers, we need to convert the value to the vector SF format when\n+;; we need to use the bits in a union or similar cases.  We only need\n+;; to do this transformation when the value is a vector register.  Loads,\n+;; stores, and transfers within GPRs are assumed to be safe.\n+;;\n+;; This is a more general case of reload_vsx_from_gprsf.  That insn must have\n+;; no alternatives, because the call is created as part of secondary_reload,\n+;; and operand #2's register class is used to allocate the temporary register.\n+;; This function is called before reload, and it creates the temporary as\n+;; needed.\n+\n+;;\t    LWZ          LFS        LXSSP      LXSSPX     STW        STFIWX\n+;;\t    STXSIWX      GPR->VSX   VSX->GPR   GPR->GPR\n+(define_insn_and_split \"movsf_from_si\"\n+  [(set (match_operand:SF 0 \"rs6000_nonimmediate_operand\"\n+\t    \"=!r,       f,         wb,        wu,        m,         Z,\n+\t     Z,         wy,        ?r,        !r\")\n+\n+\t(unspec:SF [(match_operand:SI 1 \"input_operand\" \n+\t    \"m,         m,         wY,        Z,         r,         f,\n+\t     wu,        r,         wy,        r\")]\n+\t\t   UNSPEC_SF_FROM_SI))\n+\n+   (clobber (match_scratch:DI 2\n+\t    \"=X,        X,         X,         X,         X,         X,\n+             X,         r,         X,         X\"))]\n+\n+  \"TARGET_NO_SF_SUBREG\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SImode))\"\n+  \"@\n+   lwz%U1%X1 %0,%1\n+   lfs%U1%X1 %0,%1\n+   lxssp %0,%1\n+   lxsspx %x0,%y1\n+   stw%U0%X0 %1,%0\n+   stfiwx %1,%y0\n+   stxsiwx %x1,%y0\n+   #\n+   mfvsrwz %0,%x1\n+   mr %0,%1\"\n+\n+  \"&& reload_completed\n+   && vsx_reg_sfsubreg_ok (operands[0], SFmode)\n+   && int_reg_operand_not_pseudo (operands[1], SImode)\"\n+  [(const_int 0)]\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx op2 = operands[2];\n+  rtx op1_di = gen_rtx_REG (DImode, REGNO (op1));\n+\n+  /* Move SF value to upper 32-bits for xscvspdpn.  */\n+  emit_insn (gen_ashldi3 (op2, op1_di, GEN_INT (32)));\n+  emit_insn (gen_p8_mtvsrd_sf (op0, op2));\n+  emit_insn (gen_vsx_xscvspdpn_directmove (op0, op0));\n+  DONE;\n+}\n+  [(set_attr \"length\"\n+\t    \"4,          4,         4,         4,         4,         4,\n+\t     4,          12,        4,         4\")\n+   (set_attr \"type\"\n+\t    \"load,       fpload,    fpload,    fpload,    store,     fpstore,\n+\t     fpstore,    vecfloat,  mffgpr,    *\")])\n+\n \f\n ;; Move 64-bit binary/decimal floating point\n (define_expand \"mov<mode>\"\n@@ -13231,11 +13456,11 @@\n ;; Note that the conditions for expansion are in the FMA_F iterator.\n \n (define_expand \"fma<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(fma:FMA_F\n-\t  (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t  (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t  (match_operand:FMA_F 3 \"register_operand\" \"\")))]\n+\t  (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -13255,11 +13480,11 @@\n \n ; Altivec only has fma and nfms.\n (define_expand \"fms<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(fma:FMA_F\n-\t  (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t  (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t  (neg:FMA_F (match_operand:FMA_F 3 \"register_operand\" \"\"))))]\n+\t  (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t  (neg:FMA_F (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\"))))]\n   \"!VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n   \"\")\n \n@@ -13279,34 +13504,34 @@\n \n ;; If signed zeros are ignored, -(a * b - c) = -a * b + c.\n (define_expand \"fnma<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(neg:FMA_F\n \t  (fma:FMA_F\n-\t    (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t    (neg:FMA_F (match_operand:FMA_F 3 \"register_operand\" \"\")))))]\n+\t    (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t    (neg:FMA_F (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\")))))]\n   \"!HONOR_SIGNED_ZEROS (<MODE>mode)\"\n   \"\")\n \n ;; If signed zeros are ignored, -(a * b + c) = -a * b - c.\n (define_expand \"fnms<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(neg:FMA_F\n \t  (fma:FMA_F\n-\t    (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 3 \"register_operand\" \"\"))))]\n+\t    (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\"))))]\n   \"!HONOR_SIGNED_ZEROS (<MODE>mode) && !VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n   \"\")\n \n ; Not an official optab name, but used from builtins.\n (define_expand \"nfma<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(neg:FMA_F\n \t  (fma:FMA_F\n-\t    (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 3 \"register_operand\" \"\"))))]\n+\t    (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\"))))]\n   \"!VECTOR_UNIT_ALTIVEC_P (<MODE>mode)\"\n   \"\")\n \n@@ -13327,12 +13552,12 @@\n \n ; Not an official optab name, but used from builtins.\n (define_expand \"nfms<mode>4\"\n-  [(set (match_operand:FMA_F 0 \"register_operand\" \"\")\n+  [(set (match_operand:FMA_F 0 \"gpc_reg_operand\" \"\")\n \t(neg:FMA_F\n \t  (fma:FMA_F\n-\t    (match_operand:FMA_F 1 \"register_operand\" \"\")\n-\t    (match_operand:FMA_F 2 \"register_operand\" \"\")\n-\t    (neg:FMA_F (match_operand:FMA_F 3 \"register_operand\" \"\")))))]\n+\t    (match_operand:FMA_F 1 \"gpc_reg_operand\" \"\")\n+\t    (match_operand:FMA_F 2 \"gpc_reg_operand\" \"\")\n+\t    (neg:FMA_F (match_operand:FMA_F 3 \"gpc_reg_operand\" \"\")))))]\n   \"\"\n   \"\")\n "}, {"sha": "e054f5c7caa092836aa9205330df7d88fea08347", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -3897,3 +3897,149 @@\n   \"TARGET_P9_VECTOR\"\n   \"xxinsertw %x0,%x1,%3\"\n   [(set_attr \"type\" \"vecperm\")])\n+\n+\f\n+\n+;; Operand numbers for the following peephole2\n+(define_constants\n+  [(SFBOOL_TMP_GPR\t\t 0)\t\t;; GPR temporary\n+   (SFBOOL_TMP_VSX\t\t 1)\t\t;; vector temporary\n+   (SFBOOL_MFVSR_D\t\t 2)\t\t;; move to gpr dest\n+   (SFBOOL_MFVSR_A\t\t 3)\t\t;; move to gpr src\n+   (SFBOOL_BOOL_D\t\t 4)\t\t;; and/ior/xor dest\n+   (SFBOOL_BOOL_A1\t\t 5)\t\t;; and/ior/xor arg1\n+   (SFBOOL_BOOL_A2\t\t 6)\t\t;; and/ior/xor arg1\n+   (SFBOOL_SHL_D\t\t 7)\t\t;; shift left dest\n+   (SFBOOL_SHL_A\t\t 8)\t\t;; shift left arg\n+   (SFBOOL_MTVSR_D\t\t 9)\t\t;; move to vecter dest\n+   (SFBOOL_BOOL_A_DI\t\t10)\t\t;; SFBOOL_BOOL_A1/A2 as DImode\n+   (SFBOOL_TMP_VSX_DI\t\t11)\t\t;; SFBOOL_TMP_VSX as DImode\n+   (SFBOOL_MTVSR_D_V4SF\t\t12)])\t\t;; SFBOOL_MTVSRD_D as V4SFmode\n+\n+;; Attempt to optimize some common GLIBC operations using logical operations to\n+;; pick apart SFmode operations.  For example, there is code from e_powf.c\n+;; after macro expansion that looks like:\n+;;\n+;;\ttypedef union {\n+;;\t  float value;\n+;;\t  uint32_t word;\n+;;\t} ieee_float_shape_type;\n+;;\n+;;\tfloat t1;\n+;;\tint32_t is;\n+;;\n+;;\tdo {\n+;;\t  ieee_float_shape_type gf_u;\n+;;\t  gf_u.value = (t1);\n+;;\t  (is) = gf_u.word;\n+;;\t} while (0);\n+;;\n+;;\tdo {\n+;;\t  ieee_float_shape_type sf_u;\n+;;\t  sf_u.word = (is & 0xfffff000);\n+;;\t  (t1) = sf_u.value;\n+;;\t} while (0);\n+;;\n+;;\n+;; This would result in two direct move operations (convert to memory format,\n+;; direct move to GPR, do the AND operation, direct move to VSX, convert to\n+;; scalar format).  With this peephole, we eliminate the direct move to the\n+;; GPR, and instead move the integer mask value to the vector register after a\n+;; shift and do the VSX logical operation.\n+\n+;; The insns for dealing with SFmode in GPR registers looks like:\n+;; (set (reg:V4SF reg2) (unspec:V4SF [(reg:SF reg1)] UNSPEC_VSX_CVDPSPN))\n+;;\n+;; (set (reg:DI reg3) (unspec:DI [(reg:V4SF reg2)] UNSPEC_P8V_RELOAD_FROM_VSX))\n+;;\n+;; (set (reg:DI reg3) (lshiftrt:DI (reg:DI reg3) (const_int 32)))\n+;;\n+;; (set (reg:DI reg5) (and:DI (reg:DI reg3) (reg:DI reg4)))\n+;;\n+;; (set (reg:DI reg6) (ashift:DI (reg:DI reg5) (const_int 32)))\n+;;\n+;; (set (reg:SF reg7) (unspec:SF [(reg:DI reg6)] UNSPEC_P8V_MTVSRD))\n+;;\n+;; (set (reg:SF reg7) (unspec:SF [(reg:SF reg7)] UNSPEC_VSX_CVSPDPN))\n+\n+(define_peephole2\n+  [(match_scratch:DI SFBOOL_TMP_GPR \"r\")\n+   (match_scratch:V4SF SFBOOL_TMP_VSX \"wa\")\n+\n+   ;; MFVSRD\n+   (set (match_operand:DI SFBOOL_MFVSR_D \"int_reg_operand\")\n+\t(unspec:DI [(match_operand:V4SF SFBOOL_MFVSR_A \"vsx_register_operand\")]\n+\t\t   UNSPEC_P8V_RELOAD_FROM_VSX))\n+\n+   ;; SRDI\n+   (set (match_dup SFBOOL_MFVSR_D)\n+\t(lshiftrt:DI (match_dup SFBOOL_MFVSR_D)\n+\t\t     (const_int 32)))\n+\n+   ;; AND/IOR/XOR operation on int\n+   (set (match_operand:SI SFBOOL_BOOL_D \"int_reg_operand\")\n+\t(and_ior_xor:SI (match_operand:SI SFBOOL_BOOL_A1 \"int_reg_operand\")\n+\t\t\t(match_operand:SI SFBOOL_BOOL_A2 \"reg_or_cint_operand\")))\n+\n+   ;; SLDI\n+   (set (match_operand:DI SFBOOL_SHL_D \"int_reg_operand\")\n+\t(ashift:DI (match_operand:DI SFBOOL_SHL_A \"int_reg_operand\")\n+\t\t   (const_int 32)))\n+\n+   ;; MTVSRD\n+   (set (match_operand:SF SFBOOL_MTVSR_D \"vsx_register_operand\")\n+\t(unspec:SF [(match_dup SFBOOL_SHL_D)] UNSPEC_P8V_MTVSRD))]\n+\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\n+   /* The REG_P (xxx) tests prevents SUBREG's, which allows us to use REGNO\n+      to compare registers, when the mode is different.  */\n+   && REG_P (operands[SFBOOL_MFVSR_D]) && REG_P (operands[SFBOOL_BOOL_D])\n+   && REG_P (operands[SFBOOL_BOOL_A1]) && REG_P (operands[SFBOOL_SHL_D])\n+   && REG_P (operands[SFBOOL_SHL_A])   && REG_P (operands[SFBOOL_MTVSR_D])\n+   && (REG_P (operands[SFBOOL_BOOL_A2])\n+       || CONST_INT_P (operands[SFBOOL_BOOL_A2]))\n+   && (REGNO (operands[SFBOOL_BOOL_D]) == REGNO (operands[SFBOOL_MFVSR_D])\n+       || peep2_reg_dead_p (3, operands[SFBOOL_MFVSR_D]))\n+   && (REGNO (operands[SFBOOL_MFVSR_D]) == REGNO (operands[SFBOOL_BOOL_A1])\n+       || (REG_P (operands[SFBOOL_BOOL_A2])\n+\t   && REGNO (operands[SFBOOL_MFVSR_D])\n+\t\t== REGNO (operands[SFBOOL_BOOL_A2])))\n+   && REGNO (operands[SFBOOL_BOOL_D]) == REGNO (operands[SFBOOL_SHL_A])\n+   && (REGNO (operands[SFBOOL_SHL_D]) == REGNO (operands[SFBOOL_BOOL_D])\n+       || peep2_reg_dead_p (4, operands[SFBOOL_BOOL_D]))\n+   && peep2_reg_dead_p (5, operands[SFBOOL_SHL_D])\"\n+  [(set (match_dup SFBOOL_TMP_GPR)\n+\t(ashift:DI (match_dup SFBOOL_BOOL_A_DI)\n+\t\t   (const_int 32)))\n+\n+   (set (match_dup SFBOOL_TMP_VSX_DI)\n+\t(match_dup SFBOOL_TMP_GPR))\n+\n+   (set (match_dup SFBOOL_MTVSR_D_V4SF)\n+\t(and_ior_xor:V4SF (match_dup SFBOOL_MFVSR_A)\n+\t\t\t  (match_dup SFBOOL_TMP_VSX)))]\n+{\n+  rtx bool_a1 = operands[SFBOOL_BOOL_A1];\n+  rtx bool_a2 = operands[SFBOOL_BOOL_A2];\n+  int regno_mfvsr_d = REGNO (operands[SFBOOL_MFVSR_D]);\n+  int regno_tmp_vsx = REGNO (operands[SFBOOL_TMP_VSX]);\n+  int regno_mtvsr_d = REGNO (operands[SFBOOL_MTVSR_D]);\n+\n+  if (CONST_INT_P (bool_a2))\n+    {\n+      rtx tmp_gpr = operands[SFBOOL_TMP_GPR];\n+      emit_move_insn (tmp_gpr, bool_a2);\n+      operands[SFBOOL_BOOL_A_DI] = tmp_gpr;\n+    }\n+  else\n+    {\n+      int regno_bool_a1 = REGNO (bool_a1);\n+      int regno_bool_a2 = REGNO (bool_a2);\n+      int regno_bool_a = (regno_mfvsr_d == regno_bool_a1\n+\t\t\t  ? regno_bool_a2 : regno_bool_a1);\n+      operands[SFBOOL_BOOL_A_DI] = gen_rtx_REG (DImode, regno_bool_a);\n+    }\n+\n+  operands[SFBOOL_TMP_VSX_DI] = gen_rtx_REG (DImode, regno_tmp_vsx);\n+  operands[SFBOOL_MTVSR_D_V4SF] = gen_rtx_REG (V4SFmode, regno_mtvsr_d);\n+})"}, {"sha": "90a5c1099b9c5919c5851c56f40292f969f83297", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -1,3 +1,13 @@\n+2016-12-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/71977\n+\tPR target/70568\n+\tPR target/78823\n+\t* gcc.target/powerpc/pr71977-1.c: New tests to check whether on\n+\t64-bit VSX systems with direct move, whether we optimize common\n+\tcode sequences in the GLIBC math library for float math functions.\n+\t* gcc.target/powerpc/pr71977-2.c: Likewise.\n+\n 2017-01-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/64767"}, {"sha": "c4413b8747a236b0ecf14033c31e4057df33bf09", "filename": "gcc/testsuite/gcc.target/powerpc/pr71977-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-1.c?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+#include <stdint.h>\n+\n+typedef union\n+{\n+  float value;\n+  uint32_t word;\n+} ieee_float_shape_type;\n+\n+float\n+mask_and_float_var (float f, uint32_t mask)\n+{ \n+  ieee_float_shape_type u;\n+\n+  u.value = f;\n+  u.word &= mask;\n+\n+  return u.value;\n+}\n+\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxland \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]and \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]mfvsrd \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]stxv\"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]lxv\"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]srdi \"   } } */"}, {"sha": "8ec1b6126adc4edab51e12e5272d890eb363d009", "filename": "gcc/testsuite/gcc.target/powerpc/pr71977-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba4b86109078adda686acc0102a923de709146d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr71977-2.c?ref=fba4b86109078adda686acc0102a923de709146d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+#include <stdint.h>\n+\n+typedef union\n+{\n+  float value;\n+  uint32_t word;\n+} ieee_float_shape_type;\n+\n+float\n+mask_and_float_sign (float f)\n+{ \n+  ieee_float_shape_type u;\n+\n+  u.value = f;\n+  u.word &= 0x80000000;\n+\n+  return u.value;\n+}\n+\n+/* { dg-final { scan-assembler     \"\\[ \\t\\]xxland \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]and \"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]mfvsrd \" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]stxv\"    } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]lxv\"     } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]srdi \"   } } */"}]}