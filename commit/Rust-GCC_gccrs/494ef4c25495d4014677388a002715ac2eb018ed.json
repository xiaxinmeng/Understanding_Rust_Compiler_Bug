{"sha": "494ef4c25495d4014677388a002715ac2eb018ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk0ZWY0YzI1NDk1ZDQwMTQ2NzczODhhMDAyNzE1YWMyZWIwMThlZA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-16T19:32:21Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-16T19:32:21Z"}, "message": "re PR fortran/25264 (write to internal unit from the string itself gives wrong result ?)\n\n2005-12-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/25264\n\tPR libgfortran/25349\n\t* io/unit.c (get_unit): Delete code that cleared the string when the\n\tunit was opened, which is too soon.\n\t* io/transfer.c (next_record_w): Pass done flag in.  Change logic for\n\tsetting max_pos.  Add code to position unit and pad record as needed.\n\nFrom-SVN: r108671", "tree": {"sha": "ed85a1c7eab7de8f4194a119aa77e351e168bcda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed85a1c7eab7de8f4194a119aa77e351e168bcda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/494ef4c25495d4014677388a002715ac2eb018ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494ef4c25495d4014677388a002715ac2eb018ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494ef4c25495d4014677388a002715ac2eb018ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494ef4c25495d4014677388a002715ac2eb018ed/comments", "author": null, "committer": null, "parents": [{"sha": "282b7663e6a1695244b185fbd09e7e993a94c594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/282b7663e6a1695244b185fbd09e7e993a94c594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/282b7663e6a1695244b185fbd09e7e993a94c594"}], "stats": {"total": 80, "additions": 67, "deletions": 13}, "files": [{"sha": "f46b469c56b1b761b6301d1ff165b78775c6b0ae", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=494ef4c25495d4014677388a002715ac2eb018ed", "patch": "@@ -1,3 +1,12 @@\n+2005-12-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/25264\n+\tPR libgfortran/25349\n+\t* io/unit.c (get_unit): Delete code that cleared the string when the\n+\tunit was opened, which is too soon.\n+\t* io/transfer.c (next_record_w): Pass done flag in.  Change logic for\n+\tsetting max_pos.  Add code to position unit and pad record as needed.\n+\n 2005-12-13  Richard Sandiford  <richard@codesourcery.com>\n \t    Victor Leikehman  <LEI@il.ibm.com>\n "}, {"sha": "7696643deb904c852b856ce3735c194965d879ce", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 58, "deletions": 10, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=494ef4c25495d4014677388a002715ac2eb018ed", "patch": "@@ -1746,13 +1746,14 @@ next_record_r (st_parameter_dt *dtp)\n /* Position to the next record in write mode.  */\n \n static void\n-next_record_w (st_parameter_dt *dtp)\n+next_record_w (st_parameter_dt *dtp, int done)\n {\n-  gfc_offset c, m, record;\n-  int bytes_left, length;\n+  gfc_offset c, m, record, max_pos;\n+  int length;\n   char *p;\n \n   /* Zero counters for X- and T-editing.  */\n+  max_pos = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \n   switch (current_mode (dtp))\n@@ -1831,18 +1832,31 @@ next_record_w (st_parameter_dt *dtp)\n \t{\n \t  if (is_array_io (dtp))\n \t    {\n-\t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n-\t      p = salloc_w (dtp->u.p.current_unit->s, &bytes_left);\n+\t      length = (int) dtp->u.p.current_unit->bytes_left;\n+\t      \n+\t      /* If the farthest position reached is greater than current\n+\t      position, adjust the position and set length to pad out\n+\t      whats left.  Otherwise just pad whats left.\n+\t      (for character array unit) */\n+\t      m = dtp->u.p.current_unit->recl\n+\t\t\t- dtp->u.p.current_unit->bytes_left;\n+\t      if (max_pos > m)\n+\t\t{\n+\t\t  length = (int) (max_pos - m);\n+\t\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n+\t\t}\n+\n+\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n \t      if (p == NULL)\n \t\t{\n \t\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t\t  return;\n \t\t}\n-\t      memset(p, ' ', bytes_left);\n+\t      memset(p, ' ', length);\n \n \t      /* Now that the current record has been padded out,\n \t\t determine where the next record in the array is. */\n-\n \t      record = next_array_record (dtp, dtp->u.p.current_unit->ls);\n \n \t      /* Now seek to this record */\n@@ -1856,13 +1870,47 @@ next_record_w (st_parameter_dt *dtp)\n \t  else\n \t    {\n \t      length = 1;\n+\n+\t      /* If this is the last call to next_record move to the farthest\n+\t\t position reached and set length to pad out the remainder\n+\t\t of the record. (for character scaler unit) */\n+\t      if (done)\n+\t\t{\n+\t\t  m = dtp->u.p.current_unit->recl\n+\t\t\t- dtp->u.p.current_unit->bytes_left;\n+\t\t  if (max_pos > m)\n+\t\t    {\n+\t\t      length = (int) (max_pos - m);\n+\t\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t\t      length = (int) (dtp->u.p.current_unit->recl - max_pos);\n+\t\t    }\n+\t\t  else\n+\t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n+\t\t}\n \t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n \t      if (p == NULL)\n-\t\tgoto io_error;\n+\t\t{\n+\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t\t  return;\n+\t\t}\n+\t      memset (p, ' ', length);\n \t    }\n- \t}\n+\t}\n       else\n \t{\n+\t  /* If this is the last call to next_record move to the farthest\n+\t  position reached in preparation for completing the record.\n+\t  (for file unit) */\n+\t  if (done)\n+\t    {\n+\t      m = dtp->u.p.current_unit->recl -\n+\t\t\tdtp->u.p.current_unit->bytes_left;\n+\t      if (max_pos > m)\n+\t\t{\n+\t\t  length = (int) (max_pos - m);\n+\t\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t\t}\n+ \t    }\n #ifdef HAVE_CRLF\n \t  length = 2;\n #else\n@@ -1905,7 +1953,7 @@ next_record (st_parameter_dt *dtp, int done)\n   if (dtp->u.p.mode == READING)\n     next_record_r (dtp);\n   else\n-    next_record_w (dtp);\n+    next_record_w (dtp, done);\n \n   /* keep position up to date for INQUIRE */\n   dtp->u.p.current_unit->flags.position = POSITION_ASIS;"}, {"sha": "337e10c44c3145431c78e34c4c166d0edf1345c8", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494ef4c25495d4014677388a002715ac2eb018ed/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=494ef4c25495d4014677388a002715ac2eb018ed", "patch": "@@ -384,9 +384,6 @@ get_unit (st_parameter_dt *dtp, int do_create)\n       internal_unit.maxrec=0;\n       internal_unit.current_record=0;\n \n-      if (dtp->u.p.mode==WRITING && !is_array_io (dtp))\n-        empty_internal_buffer (internal_unit.s);\n-\n       /* Set flags for the internal unit */\n \n       internal_unit.flags.access = ACCESS_SEQUENTIAL;"}]}