{"sha": "ed9a473c741f85685e8d9160155c16a92c010ca7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5YTQ3M2M3NDFmODU2ODVlOGQ5MTYwMTU1YzE2YTkyYzAxMGNhNw==", "commit": {"author": {"name": "Marc Poulhi\u00e8s", "email": "dkm@kataplop.net", "date": "2021-08-12T11:45:15Z"}, "committer": {"name": "Marc", "email": "dkm@kataplop.net", "date": "2021-08-18T20:59:48Z"}, "message": "typecheck + backend: add module support\n\nTypechecking and backend for Modules.\n\nref #432\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "9e1a7ec2b211376e6caf64c112c47da5acb3cb2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e1a7ec2b211376e6caf64c112c47da5acb3cb2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed9a473c741f85685e8d9160155c16a92c010ca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9a473c741f85685e8d9160155c16a92c010ca7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9a473c741f85685e8d9160155c16a92c010ca7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9a473c741f85685e8d9160155c16a92c010ca7/comments", "author": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd1d9c1af7c7afa43ebac162f9427420ea2314ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd1d9c1af7c7afa43ebac162f9427420ea2314ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd1d9c1af7c7afa43ebac162f9427420ea2314ff"}], "stats": {"total": 70, "additions": 51, "deletions": 19}, "files": [{"sha": "8b36289db38c0539d27499980918c0f34ccf2525", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=ed9a473c741f85685e8d9160155c16a92c010ca7", "patch": "@@ -301,6 +301,12 @@ class CompileItem : public HIRCompileBase\n       }\n   }\n \n+  void visit (HIR::ModuleBodied &module) override\n+  {\n+    for (auto &item : module.get_items ())\n+      CompileItem::compile (item.get (), ctx, compile_fns);\n+  }\n+\n private:\n   CompileItem (Context *ctx, bool compile_fns, TyTy::BaseType *concrete)\n     : HIRCompileBase (ctx), compile_fns (compile_fns), concrete (concrete)"}, {"sha": "b9b5084c2ae03c31e5f53cfe3233d2623381a505", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=ed9a473c741f85685e8d9160155c16a92c010ca7", "patch": "@@ -88,6 +88,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     {\n       // must be a call to a function\n       Bexpression *fn = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+      rust_assert (fn != nullptr);\n \n       std::vector<Bexpression *> args;\n       expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {"}, {"sha": "d39b2ee03ac44404a4ad4f148b3f848e366ecfdf", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=ed9a473c741f85685e8d9160155c16a92c010ca7", "patch": "@@ -936,6 +936,10 @@ class TypeCheckExpr : public TypeCheckBase\n     if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n+    // this is the case where the name resolver has already fully resolved the\n+    // name, which means all the work is already done.\n+    bool name_resolved_fully = offset >= expr.get_num_segments ();\n+\n     if (expr.get_num_segments () == 1)\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n@@ -1052,7 +1056,7 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \trust_assert (path_resolved_id == resolved_node_id);\n       }\n-    else\n+    else if (!name_resolved_fully)\n       {\n \tresolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n \t\t\t\t\tresolved_node_id);\n@@ -1214,6 +1218,8 @@ class TypeCheckExpr : public TypeCheckBase\n     for (size_t i = 0; i < expr.get_num_segments (); i++)\n       {\n \tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+\tbool have_more_segments = (expr.get_num_segments () - 1 != i);\n \tbool is_root = *offset == 0;\n \tNodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n \n@@ -1238,6 +1244,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t    resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n \t  }\n \n+\t// ref_node_id is the NodeId that the segments refers to.\n \tif (ref_node_id == UNKNOWN_NODEID)\n \t  {\n \t    if (is_root)\n@@ -1265,27 +1272,33 @@ class TypeCheckExpr : public TypeCheckBase\n \n \t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t      }\n+\n \t    return root_tyty;\n \t  }\n \n-\t// FIXME\n-\t// modules are not going to have an explicit TyTy.In this case we\n-\t// can probably do some kind of check. By looking up if the HirId ref\n-\t// node is a module and continue. If the path expression is single\n-\t// segment of module we can error with expected value but found module\n-\t// or something.\n-\t//\n-\t// Something like this\n-\t//\n-\t// bool seg_is_module = mappings->lookup_module (ref);\n-\t// if (seg_is_module)\n-\t//   {\n-\t//     if (have_more_segments)\n-\t//       continue;\n-\t//\n-\t//     rust_error_at (seg.get_locus (), \"expected value\");\n-\t//     return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t//   }\n+\tauto seg_is_module\n+\t  = (nullptr\n+\t     != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t\t ref));\n+\n+\tif (seg_is_module)\n+\t  {\n+\t    // A::B::C::this_is_a_module::D::E::F\n+\t    //          ^^^^^^^^^^^^^^^^\n+\t    //          Currently handling this.\n+\t    if (have_more_segments)\n+\t      {\n+\t\t(*offset)++;\n+\t\tcontinue;\n+\t      }\n+\n+\t    // In the case of :\n+\t    // A::B::C::this_is_a_module\n+\t    //          ^^^^^^^^^^^^^^^^\n+\t    // This is an error, we are not expecting a module.\n+\t    rust_error_at (seg.get_locus (), \"expected value\");\n+\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  }\n \n \tTyTy::BaseType *lookup = nullptr;\n \tif (!context->lookup_type (ref, &lookup))"}, {"sha": "372171f09665662b63021b373a706f86868f270a", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=ed9a473c741f85685e8d9160155c16a92c010ca7", "patch": "@@ -156,6 +156,12 @@ class TypeCheckItem : public TypeCheckBase\n       expected_ret_tyty->unify (block_expr_ty);\n   }\n \n+  void visit (HIR::ModuleBodied &module) override\n+  {\n+    for (auto &item : module.get_items ())\n+      TypeCheckItem::Resolve (item.get ());\n+  }\n+\n private:\n   TypeCheckItem () : TypeCheckBase () {}\n };"}, {"sha": "aad5cb9ba84a190866160144fb59a3a9db1fd40b", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9a473c741f85685e8d9160155c16a92c010ca7/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=ed9a473c741f85685e8d9160155c16a92c010ca7", "patch": "@@ -101,6 +101,12 @@ class TypeCheckTopLevel : public TypeCheckBase\n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n+  void visit (HIR::ModuleBodied &module) override\n+  {\n+    for (auto &item : module.get_items ())\n+      TypeCheckTopLevel::Resolve (item.get ());\n+  }\n+\n   void visit (HIR::StructStruct &struct_decl) override\n   {\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;"}]}