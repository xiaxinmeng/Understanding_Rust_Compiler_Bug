{"sha": "c14b9960142c1daeff4f6098819beaed1edae50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE0Yjk5NjAxNDJjMWRhZWZmNGY2MDk4ODE5YmVhZWQxZWRhZTUwZQ==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "2002-03-21T06:59:43Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "2002-03-21T06:59:43Z"}, "message": "alias.c: (nonlocal_mentioned_p): Use for_each_rtx.\n\n\t* alias.c: (nonlocal_mentioned_p): Use for_each_rtx.\n\t(nonlocal_mentioned_p_1): New function.\n\t(nonlocal_referenced_p, nonlocal_referenced_p_1): Likewise.\n\t(nonlocal_set_p, nonlocal_set_p_1): Likewise.\n\t(mark_constant_function): Recognize pure functions.\n\t* rtl.h (global_reg_mentioned_p): New prototype.\n\t* rtlanal.c (global_reg_mentioned_p,\n\tglobal_reg_mentioned_p_1): New function.\n\nFrom-SVN: r51113", "tree": {"sha": "6b14d4c2f9960628888847cc9e4f77a205cf4a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b14d4c2f9960628888847cc9e4f77a205cf4a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c14b9960142c1daeff4f6098819beaed1edae50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14b9960142c1daeff4f6098819beaed1edae50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14b9960142c1daeff4f6098819beaed1edae50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14b9960142c1daeff4f6098819beaed1edae50e/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "380f343b245bdc410e2f5bd0fcddaa294511d834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/380f343b245bdc410e2f5bd0fcddaa294511d834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/380f343b245bdc410e2f5bd0fcddaa294511d834"}], "stats": {"total": 387, "additions": 330, "deletions": 57}, "files": [{"sha": "ddc27263e7c51f321e0088aa9b93e6a10ab79461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c14b9960142c1daeff4f6098819beaed1edae50e", "patch": "@@ -1,3 +1,14 @@\n+Thu Mar 21 01:55:06 EST 2002  John Wehle  (john@feith.com)\n+\n+\t* alias.c: (nonlocal_mentioned_p): Use for_each_rtx.\n+\t(nonlocal_mentioned_p_1): New function.\n+\t(nonlocal_referenced_p, nonlocal_referenced_p_1): Likewise.\n+\t(nonlocal_set_p, nonlocal_set_p_1): Likewise.\n+\t(mark_constant_function): Recognize pure functions.\n+\t* rtl.h (global_reg_mentioned_p): New prototype.\n+\t* rtlanal.c (global_reg_mentioned_p,\n+\tglobal_reg_mentioned_p_1): New function.\n+\n 2002-03-21  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* fixinc/inclhack.def (alpha_assert): Fix assert macro in Tru64"}, {"sha": "42d8e18210dfa868387de10dc9cce767a52a3e85", "filename": "gcc/alias.c", "status": "modified", "additions": 241, "deletions": 57, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c14b9960142c1daeff4f6098819beaed1edae50e", "patch": "@@ -108,7 +108,13 @@ static tree decl_for_component_ref\tPARAMS ((tree));\n static rtx adjust_offset_for_component_ref PARAMS ((tree, rtx));\n static int nonoverlapping_memrefs_p\tPARAMS ((rtx, rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n+\n+static int nonlocal_mentioned_p_1       PARAMS ((rtx *, void *));\n static int nonlocal_mentioned_p         PARAMS ((rtx));\n+static int nonlocal_referenced_p_1      PARAMS ((rtx *, void *));\n+static int nonlocal_referenced_p        PARAMS ((rtx));\n+static int nonlocal_set_p_1             PARAMS ((rtx *, void *));\n+static int nonlocal_set_p               PARAMS ((rtx));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -2233,36 +2239,23 @@ output_dependence (mem, x)\n {\n   return write_dependence_p (mem, x, /*writep=*/1);\n }\n-\n-/* Returns non-zero if X mentions something which is not\n-   local to the function and is not constant.  */\n+\f\n+/* A subroutine of nonlocal_mentioned_p, returns 1 if *LOC mentions\n+   something which is not local to the function and is not constant.  */\n \n static int\n-nonlocal_mentioned_p (x)\n-     rtx x;\n+nonlocal_mentioned_p_1 (loc, data)\n+     rtx *loc;\n+     void *data ATTRIBUTE_UNUSED;\n {\n+  rtx x = *loc;\n   rtx base;\n-  RTX_CODE code;\n   int regno;\n \n-  code = GET_CODE (x);\n-\n-  if (GET_RTX_CLASS (code) == 'i')\n-    {\n-      /* Constant functions can be constant if they don't use\n-         scratch memory used to mark function w/o side effects.  */\n-      if (code == CALL_INSN && CONST_OR_PURE_CALL_P (x))\n-        {\n-\t  x = CALL_INSN_FUNCTION_USAGE (x);\n-\t  if (x == 0)\n-\t    return 0;\n-        }\n-      else\n-        x = PATTERN (x);\n-      code = GET_CODE (x);\n-    }\n+  if (! x)\n+    return 0;\n \n-  switch (code)\n+  switch (GET_CODE (x))\n     {\n     case SUBREG:\n       if (GET_CODE (SUBREG_REG (x)) == REG)\n@@ -2344,72 +2337,263 @@ nonlocal_mentioned_p (x)\n       break;\n     }\n \n-  /* Recursively scan the operands of this expression.  */\n+  return 0;\n+}\n+\n+/* Returns non-zero if X might mention something which is not\n+   local to the function and is not constant.  */\n \n-  {\n-    const char *fmt = GET_RTX_FORMAT (code);\n-    int i;\n-    \n-    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-      {\n-\tif (fmt[i] == 'e' && XEXP (x, i))\n-\t  {\n-\t    if (nonlocal_mentioned_p (XEXP (x, i)))\n-\t      return 1;\n-\t  }\n-\telse if (fmt[i] == 'E')\n-\t  {\n-\t    int j;\n-\t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      if (nonlocal_mentioned_p (XVECEXP (x, i, j)))\n-\t\treturn 1;\n-\t  }\n-      }\n-  }\n+static int\n+nonlocal_mentioned_p (x)\n+     rtx x;\n+{\n+\n+  if (INSN_P (x))\n+    {\n+      if (GET_CODE (x) == CALL_INSN)\n+\t{\n+\t  if (! CONST_OR_PURE_CALL_P (x))\n+\t    return 1;\n+\t  x = CALL_INSN_FUNCTION_USAGE (x);\n+\t  if (x == 0)\n+\t    return 0;\n+        }\n+      else\n+        x = PATTERN (x);\n+    }\n+\n+  return for_each_rtx (&x, nonlocal_mentioned_p_1, NULL);\n+}\n+\n+/* A subroutine of nonlocal_referenced_p, returns 1 if *LOC references\n+   something which is not local to the function and is not constant.  */\n+\n+static int\n+nonlocal_referenced_p_1 (loc, data)\n+     rtx *loc;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *loc;\n+\n+  if (! x)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case MEM:\n+    case REG:\n+    case SYMBOL_REF:\n+    case SUBREG:\n+      return nonlocal_mentioned_p (x);\n+\n+    case CALL:\n+      /* Non-constant calls and recursion are not local.  */\n+      return 1;\n+\n+    case SET:\n+      if (nonlocal_mentioned_p (SET_SRC (x)))\n+\treturn 1;\n+\n+      if (GET_CODE (SET_DEST (x)) == MEM)\n+\treturn nonlocal_mentioned_p (XEXP (SET_DEST (x), 0));\n+\n+      /* If the destination is anything other than a CC0, PC,\n+\t MEM, REG, or a SUBREG of a REG that occupies all of\n+\t the REG, then X references nonlocal memory if it is\n+\t mentioned in the destination.  */\n+      if (GET_CODE (SET_DEST (x)) != CC0\n+\t  && GET_CODE (SET_DEST (x)) != PC\n+\t  && GET_CODE (SET_DEST (x)) != REG\n+\t  && ! (GET_CODE (SET_DEST (x)) == SUBREG\n+\t\t&& GET_CODE (SUBREG_REG (SET_DEST (x))) == REG\n+\t\t&& (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n+\t\t      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t    == ((GET_MODE_SIZE (GET_MODE (SET_DEST (x)))\n+\t\t\t + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))))\n+\treturn nonlocal_mentioned_p (SET_DEST (x));\n+      return 0;\n+\n+    case CLOBBER:\n+      if (GET_CODE (XEXP (x, 0)) == MEM)\n+\treturn nonlocal_mentioned_p (XEXP (XEXP (x, 0), 0));\n+      return 0;\n+\n+    case USE:\n+      return nonlocal_mentioned_p (XEXP (x, 0));\n+\n+    case ASM_INPUT:\n+    case UNSPEC_VOLATILE:\n+      return 1;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+\n+    /* FALLTHROUGH */\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Returns non-zero if X might reference something which is not\n+   local to the function and is not constant.  */\n+\n+static int\n+nonlocal_referenced_p (x)\n+     rtx x;\n+{\n+\n+  if (INSN_P (x))\n+    {\n+      if (GET_CODE (x) == CALL_INSN)\n+\t{\n+\t  if (! CONST_OR_PURE_CALL_P (x))\n+\t    return 1;\n+\t  x = CALL_INSN_FUNCTION_USAGE (x);\n+\t  if (x == 0)\n+\t    return 0;\n+        }\n+      else\n+        x = PATTERN (x);\n+    }\n+\n+  return for_each_rtx (&x, nonlocal_referenced_p_1, NULL);\n+}\n+\n+/* A subroutine of nonlocal_set_p, returns 1 if *LOC sets\n+   something which is not local to the function and is not constant.  */\n+\n+static int\n+nonlocal_set_p_1 (loc, data)\n+     rtx *loc;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *loc;\n+\n+  if (! x)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CALL:\n+      /* Non-constant calls and recursion are not local.  */\n+      return 1;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case POST_INC:\n+    case POST_DEC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return nonlocal_mentioned_p (XEXP (x, 0));\n+\n+    case SET:\n+      if (nonlocal_mentioned_p (SET_DEST (x)))\n+\treturn 1;\n+      return nonlocal_set_p (SET_SRC (x));\n+\n+    case CLOBBER:\n+      return nonlocal_mentioned_p (XEXP (x, 0));\n+\n+    case USE:\n+      return 0;\n+\n+    case ASM_INPUT:\n+    case UNSPEC_VOLATILE:\n+      return 1;\n+\n+    case ASM_OPERANDS:\n+      if (MEM_VOLATILE_P (x))\n+\treturn 1;\n+\n+    /* FALLTHROUGH */\n+\n+    default:\n+      break;\n+    }\n \n   return 0;\n }\n \n+/* Returns non-zero if X might set something which is not\n+   local to the function and is not constant.  */\n+\n+static int\n+nonlocal_set_p (x)\n+     rtx x;\n+{\n+\n+  if (INSN_P (x))\n+    {\n+      if (GET_CODE (x) == CALL_INSN)\n+\t{\n+\t  if (! CONST_OR_PURE_CALL_P (x))\n+\t    return 1;\n+\t  x = CALL_INSN_FUNCTION_USAGE (x);\n+\t  if (x == 0)\n+\t    return 0;\n+        }\n+      else\n+        x = PATTERN (x);\n+    }\n+\n+  return for_each_rtx (&x, nonlocal_set_p_1, NULL);\n+}\n+\n /* Mark the function if it is constant.  */\n \n void\n mark_constant_function ()\n {\n   rtx insn;\n-  int nonlocal_mentioned;\n+  int nonlocal_memory_referenced;\n \n   if (TREE_PUBLIC (current_function_decl)\n       || TREE_READONLY (current_function_decl)\n       || DECL_IS_PURE (current_function_decl)\n       || TREE_THIS_VOLATILE (current_function_decl)\n-      || TYPE_MODE (TREE_TYPE (current_function_decl)) == VOIDmode)\n+      || TYPE_MODE (TREE_TYPE (current_function_decl)) == VOIDmode\n+      || current_function_has_nonlocal_goto)\n     return;\n \n   /* A loop might not return which counts as a side effect.  */\n   if (mark_dfs_back_edges ())\n     return;\n \n-  nonlocal_mentioned = 0;\n+  nonlocal_memory_referenced = 0;\n \n   init_alias_analysis ();\n \n-  /* Determine if this is a constant function.  */\n+  /* Determine if this is a constant or pure function.  */\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && nonlocal_mentioned_p (insn))\n-      {\n-\tnonlocal_mentioned = 1;\n-\tbreak;\n-      }\n+    {\n+      if (! INSN_P (insn))\n+\tcontinue;\n \n-  end_alias_analysis ();\n+      if (nonlocal_set_p (insn) || global_reg_mentioned_p (insn)\n+\t  || volatile_refs_p (PATTERN (insn)))\n+  \tbreak;\n \n+      if (! nonlocal_memory_referenced)\n+\tnonlocal_memory_referenced = nonlocal_referenced_p (insn);\n+    }\n+  \n+  end_alias_analysis ();\n+  \n   /* Mark the function.  */\n-\n-  if (! nonlocal_mentioned)\n+  \n+  if (insn)\n+    ;\n+  else if (nonlocal_memory_referenced)\n+    DECL_IS_PURE (current_function_decl) = 1;\n+  else\n     TREE_READONLY (current_function_decl) = 1;\n }\n-\n+\f\n \n static HARD_REG_SET argument_registers;\n "}, {"sha": "3c511550e38548ace459326244f378c677a28ac0", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c14b9960142c1daeff4f6098819beaed1edae50e", "patch": "@@ -1461,6 +1461,7 @@ extern int rtx_addr_varies_p\t\tPARAMS ((rtx, int));\n extern HOST_WIDE_INT get_integer_term\tPARAMS ((rtx));\n extern rtx get_related_value\t\tPARAMS ((rtx));\n extern rtx get_jump_table_offset\tPARAMS ((rtx, rtx *));\n+extern int global_reg_mentioned_p\tPARAMS ((rtx));\n extern int reg_mentioned_p\t\tPARAMS ((rtx, rtx));\n extern int count_occurrences\t\tPARAMS ((rtx, rtx, int));\n extern int reg_referenced_p\t\tPARAMS ((rtx, rtx));"}, {"sha": "79ccf9d4bc0836d2cdb18549306ed9fd52ee861b", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c14b9960142c1daeff4f6098819beaed1edae50e/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c14b9960142c1daeff4f6098819beaed1edae50e", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n \n /* Forward declarations */\n+static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n@@ -483,6 +484,82 @@ get_jump_table_offset (insn, earliest)\n   return x;\n }\n \f\n+/* A subroutine of global_reg_mentioned_p, returns 1 if *LOC mentions\n+   a global register.  */\n+\n+static int\n+global_reg_mentioned_p_1 (loc, data)\n+     rtx *loc;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  int regno;\n+  rtx x = *loc;\n+\n+  if (! x)\n+    return 0;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SUBREG:\n+      if (GET_CODE (SUBREG_REG (x)) == REG)\n+\t{\n+\t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n+\t      && global_regs[subreg_regno (x)])\n+\t    return 1;\n+\t  return 0;\n+\t}\n+      break;\n+\n+    case REG:\n+      regno = REGNO (x);\n+      if (regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n+\treturn 1;\n+      return 0;\n+\n+    case SCRATCH:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case CALL:\n+      /* A non-constant call might use a global register.  */\n+      return 1;\n+\n+    default:\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Returns non-zero if X mentions a global register.  */\n+\n+int\n+global_reg_mentioned_p (x)\n+     rtx x;\n+{\n+\n+  if (INSN_P (x))\n+    {\n+      if (GET_CODE (x) == CALL_INSN)\n+\t{\n+\t  if (! CONST_OR_PURE_CALL_P (x))\n+\t    return 1;\n+\t  x = CALL_INSN_FUNCTION_USAGE (x);\n+\t  if (x == 0)\n+\t    return 0;\n+        }\n+      else\n+        x = PATTERN (x);\n+    }\n+\n+  return for_each_rtx (&x, global_reg_mentioned_p_1, NULL);\n+}\n+\f\n /* Return the number of places FIND appears within X.  If COUNT_DEST is\n    zero, we do not count occurrences inside the destination of a SET.  */\n "}]}