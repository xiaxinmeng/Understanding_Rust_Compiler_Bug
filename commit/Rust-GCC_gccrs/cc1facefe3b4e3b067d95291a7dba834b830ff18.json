{"sha": "cc1facefe3b4e3b067d95291a7dba834b830ff18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MxZmFjZWZlM2I0ZTNiMDY3ZDk1MjkxYTdkYmE4MzRiODMwZmYxOA==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2019-10-18T05:13:26Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2019-10-18T05:13:26Z"}, "message": "re PR target/86753 (gcc.target/aarch64/sve/vcond_[45].c fail after recent combine patch)\n\n2019-10-18  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\t    Richard Sandiford  <richard.sandiford@arm.com>\n\n\tPR target/86753\n\t* tree-vectorizer.h (scalar_cond_masked_key): New struct,\n\tand define hashmap traits for it.\n\t(loop_vec_info::scalar_cond_masked_set): New member.\n\t(vect_record_loop_mask): Adjust prototype.\n\t* tree-vectorizer.c (scalar_cond_masked_key::get_cond_ops_from_tree):\n\tImplement method.\n\t* tree-vect-loop.c (vectorizable_reduction): Pass NULL as last arg to\n\tvect_record_loop_mask.\n\t(vectorizable_live_operation): Likewise.\n\t(vect_record_loop_mask): New param scalar_mask. Add entry\n\tcond, loop_mask\tto scalar_cond_masked_set if scalar_mask is non NULL.\n\t* tree-vect-stmts.c (check_load_store_masking): New param scalar_mask.\n\tPass it as last arg to vect_record_loop_mask.\n\t(vectorizable_call): Pass scalar_mask as last arg to\n\tvect_record_loop_mask.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Check if another part of vectorized code\n\tapplies loop_mask to condition or to it's inverse, and if yes,\n\tapply loop_mask to result of vector comparison.\n\ntestsuite/\n\t* gcc.target/aarch64/sve/cond_cnot_2.c: Remove XFAIL\n\tfrom { scan-assembler-not {\\tsel\\t}.\n\t* gcc.target/aarch64/sve/cond_convert_1.c: Adjust to make\n\tonly one load conditional.\n\t* gcc.target/aarch64/sve/cond_convert_4.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_unary_2.c: Likewise.\n\t* gcc.target/aarch64/sve/vcond_4.c: Remove XFAIL's.\n\t* gcc.target/aarch64/sve/vcond_5.c: Likewise.\n\nCo-Authored-By: Richard Sandiford <richard.sandiford@arm.com>\n\nFrom-SVN: r277141", "tree": {"sha": "656904edfbf10a3b87dfff157ab33cc839fa0460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/656904edfbf10a3b87dfff157ab33cc839fa0460"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc1facefe3b4e3b067d95291a7dba834b830ff18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1facefe3b4e3b067d95291a7dba834b830ff18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc1facefe3b4e3b067d95291a7dba834b830ff18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc1facefe3b4e3b067d95291a7dba834b830ff18/comments", "author": null, "committer": null, "parents": [{"sha": "4aa255f52588be89a56b2d30ebada235c7bb7c15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa255f52588be89a56b2d30ebada235c7bb7c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aa255f52588be89a56b2d30ebada235c7bb7c15"}], "stats": {"total": 324, "additions": 281, "deletions": 43}, "files": [{"sha": "273d13c92c31a4013c38136789477bbf011edbc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -1,3 +1,28 @@\n+2019-10-18  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR target/86753\n+\t* tree-vectorizer.h (scalar_cond_masked_key): New struct,\n+\tand define hashmap traits for it.\n+\t(loop_vec_info::scalar_cond_masked_set): New member.\n+\t(vect_record_loop_mask): Adjust prototype.\n+\t* tree-vectorizer.c (scalar_cond_masked_key::get_cond_ops_from_tree):\n+\tImplement method.\n+\t* tree-vect-loop.c (vectorizable_reduction): Pass NULL as last arg to\n+\tvect_record_loop_mask.\n+\t(vectorizable_live_operation): Likewise.\n+\t(vect_record_loop_mask): New param scalar_mask. Add entry\n+\tcond, loop_mask\tto scalar_cond_masked_set if scalar_mask is non NULL.\n+\t* tree-vect-stmts.c (check_load_store_masking): New param scalar_mask.\n+\tPass it as last arg to vect_record_loop_mask.\n+\t(vectorizable_call): Pass scalar_mask as last arg to\n+\tvect_record_loop_mask.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Check if another part of vectorized code\n+\tapplies loop_mask to condition or to it's inverse, and if yes,\n+\tapply loop_mask to result of vector comparison.\n+\n 2019-10-17  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa.c (pa_output_indirect_call): Fix typos in last change."}, {"sha": "fc6345794682d1ec692af40f9776117ea9384f3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -1,3 +1,16 @@\n+2019-10-18  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\t    Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR target/86753\n+\t* gcc.target/aarch64/sve/cond_cnot_2.c: Remove XFAIL\n+\tfrom { scan-assembler-not {\\tsel\\t}.\n+\t* gcc.target/aarch64/sve/cond_convert_1.c: Adjust to make\n+\tonly one load conditional.\n+\t* gcc.target/aarch64/sve/cond_convert_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_unary_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/vcond_4.c: Remove XFAIL's.\n+\t* gcc.target/aarch64/sve/vcond_5.c: Likewise.\n+\n 2019-10-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/92056"}, {"sha": "3df2431be3816fa1af4954f41935dfe95d471cf1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_cnot_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_cnot_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_cnot_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_cnot_2.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -32,4 +32,4 @@ TEST_ALL (DEF_LOOP)\n /* { dg-final { scan-assembler-not {\\tmov\\tz} } } */\n /* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */\n /* Currently we canonicalize the ?: so that !b[i] is the \"false\" value.  */\n-/* { dg-final { scan-assembler-not {\\tsel\\t} { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "86064ebfcba897e1a6ee77b43d93e3869b35cc55", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_convert_1.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_1.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -11,7 +11,10 @@\n \t\t   INT_TYPE *__restrict pred, int n)\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n-      r[i] = pred[i] ? (FLOAT_TYPE) a[i] : b[i];\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tFLOAT_TYPE bi = b[i];\t\t\t\t\t\\\n+\tr[i] = pred[i] ? (FLOAT_TYPE) a[i] : bi;\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n   }\n \n #define TEST_ALL(T) \\"}, {"sha": "e3a947b26983ee33d43a01be4219fed9ac527745", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_convert_4.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_convert_4.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -11,7 +11,10 @@\n \t\t   INT_TYPE *__restrict pred, int n)\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n-      r[i] = pred[i] ? (INT_TYPE) a[i] : b[i];\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tINT_TYPE bi = b[i];\t\t\t\t\t\\\n+\tr[i] = pred[i] ? (INT_TYPE) a[i] : bi;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n   }\n \n #define TEST_ALL(T) \\"}, {"sha": "97d1b8f5d4554d3a74b07c939ee2e5942b40d570", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_unary_2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_unary_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_unary_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_unary_2.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -13,7 +13,10 @@\n \t\t      TYPE *__restrict pred, int n)\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n-      r[i] = pred[i] ? OP (a[i]) : b[i];\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE bi = b[i];\t\t\t\t\t\t\\\n+\tr[i] = pred[i] ? OP (a[i]) : bi;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n   }\n \n #define TEST_INT_TYPE(T, TYPE) \\"}, {"sha": "b38f23e87baa2251dd1a60732b5707527648406e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_4.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_4.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -98,44 +98,44 @@ TEST_CMP (nugt)\n /* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 { xfail *-*-* } } } */\n \n /* 5 for lt, 5 for ult and 5 for nult.  */\n-/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 } } */\n \n /* 5 for le, 5 for ule and 5 for nule.  */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 } } */\n \n /* 5 for gt, 5 for ugt and 5 for nugt.  */\n-/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 } } */\n \n /* 5 for ge, 5 for uge and 5 for nuge.  */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 30 } } */\n \n /* { dg-final { scan-assembler-not {\\tfcmuo\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} } } */\n /* 3 loops * 5 invocations for all 12 unordered comparisons.  */\n-/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 180 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 180 } } */\n \n /* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 7 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 14 { xfail *-*-* } } } */\n \n /* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 { xfail *-*-* } } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 42 } } */\n \n /* { dg-final { scan-assembler-not {\\tfcmuo\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} } } */\n /* 3 loops * 5 invocations, with 2 invocations having ncopies == 2,\n    for all 12 unordered comparisons.  */\n-/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 252 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 252 } } */"}, {"sha": "2f16fbff5225d35f18dceada85f1fabe2c7a2692", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_5.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_5.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -19,16 +19,16 @@\n /* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 40 { xfail *-*-* } } } */\n \n /* 5 for le, 5 for ule and 5 for nule.  */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 30 } } */\n \n /* 5 for gt, 5 for ugt, 5 for nueq and 5 for nugt.  */\n /* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} 20 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 40 { xfail *-*-* } } } */\n \n /* 5 for ge, 5 for uge and 5 for nuge.  */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} 15 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 30 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} 15 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s} 30 } } */\n \n /* { dg-final { scan-assembler-not {\\tfcmuo\\tp[0-9]+\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0} } } */\n /* 3 loops * 5 invocations for ordered, unordered amd ueq.  */\n@@ -43,14 +43,14 @@\n /* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 28 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 56 { xfail *-*-* } } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 42 } } */\n \n /* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 28 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 56 { xfail *-*-* } } } */\n \n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 21 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 42 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} 21 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d} 42 } } */\n \n /* { dg-final { scan-assembler-not {\\tfcmuo\\tp[0-9]+\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0} } } */\n /* 3 loops * 5 invocations, with 2 invocations having ncopies == 2,"}, {"sha": "10920acc9e01506fd495ebc09fbe6e2ef17c5b19", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -6330,7 +6330,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t}\n       else\n \tvect_record_loop_mask (loop_vinfo, masks, ncopies * vec_num,\n-\t\t\t       vectype_in);\n+\t\t\t       vectype_in, NULL);\n     }\n   if (dump_enabled_p ()\n       && reduction_type == FOLD_LEFT_REDUCTION)\n@@ -7561,7 +7561,7 @@ vectorizable_live_operation (stmt_vec_info stmt_info,\n \t      gcc_assert (ncopies == 1 && !slp_node);\n \t      vect_record_loop_mask (loop_vinfo,\n \t\t\t\t     &LOOP_VINFO_MASKS (loop_vinfo),\n-\t\t\t\t     1, vectype);\n+\t\t\t\t     1, vectype, NULL);\n \t    }\n \t}\n       return true;\n@@ -7760,11 +7760,12 @@ vect_double_mask_nunits (tree type)\n \n /* Record that a fully-masked version of LOOP_VINFO would need MASKS to\n    contain a sequence of NVECTORS masks that each control a vector of type\n-   VECTYPE.  */\n+   VECTYPE.  If SCALAR_MASK is nonnull, the fully-masked loop would AND\n+   these vector masks with the vector version of SCALAR_MASK.  */\n \n void\n vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n-\t\t       unsigned int nvectors, tree vectype)\n+\t\t       unsigned int nvectors, tree vectype, tree scalar_mask)\n {\n   gcc_assert (nvectors != 0);\n   if (masks->length () < nvectors)\n@@ -7775,6 +7776,13 @@ vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n   unsigned int nscalars_per_iter\n     = exact_div (nvectors * TYPE_VECTOR_SUBPARTS (vectype),\n \t\t LOOP_VINFO_VECT_FACTOR (loop_vinfo)).to_constant ();\n+\n+  if (scalar_mask)\n+    {\n+      scalar_cond_masked_key cond (scalar_mask, nvectors);\n+      loop_vinfo->scalar_cond_masked_set.add (cond);\n+    }\n+\n   if (rgm->max_nscalars_per_iter < nscalars_per_iter)\n     {\n       rgm->max_nscalars_per_iter = nscalars_per_iter;"}, {"sha": "acdd90784dcf4d6d354c85da2766884835be98bc", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -1879,7 +1879,8 @@ static tree permute_vec_elements (tree, tree, tree, stmt_vec_info,\n    says how the load or store is going to be implemented and GROUP_SIZE\n    is the number of load or store statements in the containing group.\n    If the access is a gather load or scatter store, GS_INFO describes\n-   its arguments.\n+   its arguments.  If the load or store is conditional, SCALAR_MASK is the\n+   condition under which it occurs.\n \n    Clear LOOP_VINFO_CAN_FULLY_MASK_P if a fully-masked loop is not\n    supported, otherwise record the required mask types.  */\n@@ -1888,7 +1889,7 @@ static void\n check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t\t\t  vec_load_store_type vls_type, int group_size,\n \t\t\t  vect_memory_access_type memory_access_type,\n-\t\t\t  gather_scatter_info *gs_info)\n+\t\t\t  gather_scatter_info *gs_info, tree scalar_mask)\n {\n   /* Invariant loads need no special support.  */\n   if (memory_access_type == VMAT_INVARIANT)\n@@ -1912,7 +1913,7 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t  return;\n \t}\n       unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n-      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype);\n+      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n       return;\n     }\n \n@@ -1936,7 +1937,7 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t  return;\n \t}\n       unsigned int ncopies = vect_get_num_copies (loop_vinfo, vectype);\n-      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype);\n+      vect_record_loop_mask (loop_vinfo, masks, ncopies, vectype, scalar_mask);\n       return;\n     }\n \n@@ -1974,7 +1975,7 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned int nvectors;\n   if (can_div_away_from_zero_p (group_size * vf, nunits, &nvectors))\n-    vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype);\n+    vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype, scalar_mask);\n   else\n     gcc_unreachable ();\n }\n@@ -3436,7 +3437,9 @@ vectorizable_call (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  unsigned int nvectors = (slp_node\n \t\t\t\t   ? SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node)\n \t\t\t\t   : ncopies);\n-\t  vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype_out);\n+\t  tree scalar_mask = gimple_call_arg (stmt_info->stmt, mask_opno);\n+\t  vect_record_loop_mask (loop_vinfo, masks, nvectors,\n+\t\t\t\t vectype_out, scalar_mask);\n \t}\n       return true;\n     }\n@@ -7390,7 +7393,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \tcheck_load_store_masking (loop_vinfo, vectype, vls_type, group_size,\n-\t\t\t\t  memory_access_type, &gs_info);\n+\t\t\t\t  memory_access_type, &gs_info, mask);\n \n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       vect_model_store_cost (stmt_info, ncopies, rhs_dt, memory_access_type,\n@@ -8637,7 +8640,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo))\n \tcheck_load_store_masking (loop_vinfo, vectype, VLS_LOAD, group_size,\n-\t\t\t\t  memory_access_type, &gs_info);\n+\t\t\t\t  memory_access_type, &gs_info, mask);\n \n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n       vect_model_load_cost (stmt_info, ncopies, memory_access_type,\n@@ -10007,6 +10010,35 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* Handle cond expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n+      tree loop_mask = NULL_TREE;\n+      bool swap_cond_operands = false;\n+\n+      /* See whether another part of the vectorized code applies a loop\n+\t mask to the condition, or to its inverse.  */\n+\n+      if (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo))\n+\t{\n+\t  scalar_cond_masked_key cond (cond_expr, ncopies);\n+\t  if (loop_vinfo->scalar_cond_masked_set.contains (cond))\n+\t    {\n+\t      vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+\t      loop_mask = vect_get_loop_mask (gsi, masks, ncopies, vectype, j);\n+\t    }\n+\t  else\n+\t    {\n+\t      bool honor_nans = HONOR_NANS (TREE_TYPE (cond.op0));\n+\t      cond.code = invert_tree_comparison (cond.code, honor_nans);\n+\t      if (loop_vinfo->scalar_cond_masked_set.contains (cond))\n+\t\t{\n+\t\t  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n+\t\t  loop_mask = vect_get_loop_mask (gsi, masks, ncopies,\n+\t\t\t\t\t\t  vectype, j);\n+\t\t  cond_code = cond.code;\n+\t\t  swap_cond_operands = true;\n+\t\t}\n+\t    }\n+\t}\n+\n       stmt_vec_info new_stmt_info = NULL;\n       if (j == 0)\n \t{\n@@ -10084,6 +10116,9 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n           vec_then_clause = vec_oprnds2[i];\n           vec_else_clause = vec_oprnds3[i];\n \n+\t  if (swap_cond_operands)\n+\t    std::swap (vec_then_clause, vec_else_clause);\n+\n \t  if (masked)\n \t    vec_compare = vec_cond_lhs;\n \t  else\n@@ -10122,6 +10157,50 @@ vectorizable_condition (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t}\n \t    }\n+\n+\t  /* If we decided to apply a loop mask to the result of the vector\n+             comparison, AND the comparison with the mask now.  Later passes\n+             should then be able to reuse the AND results between mulitple\n+             vector statements.\n+\n+\t     For example:\n+\t     for (int i = 0; i < 100; ++i)\n+\t       x[i] = y[i] ? z[i] : 10;\n+\n+\t     results in following optimized GIMPLE:\n+\n+\t     mask__35.8_43 = vect__4.7_41 != { 0, ... };\n+\t     vec_mask_and_46 = loop_mask_40 & mask__35.8_43;\n+\t     _19 = &MEM[base: z_12(D), index: ivtmp_56, step: 4, offset: 0B];\n+\t     vect_iftmp.11_47 = .MASK_LOAD (_19, 4B, vec_mask_and_46);\n+\t     vect_iftmp.12_52 = VEC_COND_EXPR <vec_mask_and_46,\n+\t\t\t\t\t       vect_iftmp.11_47, { 10, ... }>;\n+\n+\t     instead of using a masked and unmasked forms of\n+\t     vec != { 0, ... } (masked in the MASK_LOAD,\n+\t     unmasked in the VEC_COND_EXPR).  */\n+\n+\t  if (loop_mask)\n+\t    {\n+\t      if (COMPARISON_CLASS_P (vec_compare))\n+\t\t{\n+\t\t  tree tmp = make_ssa_name (vec_cmp_type);\n+\t\t  tree op0 = TREE_OPERAND (vec_compare, 0);\n+\t\t  tree op1 = TREE_OPERAND (vec_compare, 1);\n+\t\t  gassign *g = gimple_build_assign (tmp,\n+\t\t\t\t\t\t    TREE_CODE (vec_compare),\n+\t\t\t\t\t\t    op0, op1);\n+\t\t  vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t\t  vec_compare = tmp;\n+\t\t}\n+\n+\t      tree tmp2 = make_ssa_name (vec_cmp_type);\n+\t      gassign *g = gimple_build_assign (tmp2, BIT_AND_EXPR,\n+\t\t\t\t\t\tvec_compare, loop_mask);\n+\t      vect_finish_stmt_generation (stmt_info, g, gsi);\n+\t      vec_compare = tmp2;\n+\t    }\n+\n \t  if (reduction_type == EXTRACT_LAST_REDUCTION)\n \t    {\n \t      if (!is_gimple_val (vec_compare))"}, {"sha": "1a0cc93582b3fbb01d7797b15728f2abc70182f8", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -1515,3 +1515,36 @@ make_pass_ipa_increase_alignment (gcc::context *ctxt)\n {\n   return new pass_ipa_increase_alignment (ctxt);\n }\n+\n+/* If the condition represented by T is a comparison or the SSA name\n+   result of a comparison, extract the comparison's operands.  Represent\n+   T as NE_EXPR <T, 0> otherwise.  */\n+\n+void\n+scalar_cond_masked_key::get_cond_ops_from_tree (tree t)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == tcc_comparison)\n+    {\n+      this->code = TREE_CODE (t);\n+      this->op0 = TREE_OPERAND (t, 0);\n+      this->op1 = TREE_OPERAND (t, 1);\n+      return;\n+    }\n+\n+  if (TREE_CODE (t) == SSA_NAME)\n+    if (gassign *stmt = dyn_cast<gassign *> (SSA_NAME_DEF_STMT (t)))\n+      {\n+\ttree_code code = gimple_assign_rhs_code (stmt);\n+\tif (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t  {\n+\t    this->code = code;\n+\t    this->op0 = gimple_assign_rhs1 (stmt);\n+\t    this->op1 = gimple_assign_rhs2 (stmt);\n+\t    return;\n+\t  }\n+      }\n+\n+  this->code = NE_EXPR;\n+  this->op0 = t;\n+  this->op1 = build_zero_cst (TREE_TYPE (t));\n+}"}, {"sha": "5c3b3c9b91eecc2c48ef9985255335cf37841ce4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc1facefe3b4e3b067d95291a7dba834b830ff18/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=cc1facefe3b4e3b067d95291a7dba834b830ff18", "patch": "@@ -177,7 +177,75 @@ typedef class _slp_instance {\n #define SLP_TREE_TWO_OPERATORS(S)\t\t (S)->two_operators\n #define SLP_TREE_DEF_TYPE(S)\t\t\t (S)->def_type\n \n+/* Key for map that records association between\n+   scalar conditions and corresponding loop mask, and\n+   is populated by vect_record_loop_mask.  */\n \n+struct scalar_cond_masked_key\n+{\n+  scalar_cond_masked_key (tree t, unsigned ncopies_)\n+    : ncopies (ncopies_)\n+  {\n+    get_cond_ops_from_tree (t);\n+  }\n+\n+  void get_cond_ops_from_tree (tree);\n+\n+  unsigned ncopies;\n+  tree_code code;\n+  tree op0;\n+  tree op1;\n+};\n+\n+template<>\n+struct default_hash_traits<scalar_cond_masked_key>\n+{\n+  typedef scalar_cond_masked_key compare_type;\n+  typedef scalar_cond_masked_key value_type;\n+\n+  static inline hashval_t\n+  hash (value_type v)\n+  {\n+    inchash::hash h;\n+    h.add_int (v.code);\n+    inchash::add_expr (v.op0, h, 0);\n+    inchash::add_expr (v.op1, h, 0);\n+    h.add_int (v.ncopies);\n+    return h.end ();\n+  }\n+\n+  static inline bool\n+  equal (value_type existing, value_type candidate)\n+  {\n+    return (existing.ncopies == candidate.ncopies\n+           && existing.code == candidate.code\n+           && operand_equal_p (existing.op0, candidate.op0, 0)\n+           && operand_equal_p (existing.op1, candidate.op1, 0));\n+  }\n+\n+  static inline void\n+  mark_empty (value_type &v)\n+  {\n+    v.ncopies = 0;\n+  }\n+\n+  static inline bool\n+  is_empty (value_type v)\n+  {\n+    return v.ncopies == 0;\n+  }\n+\n+  static inline void mark_deleted (value_type &) {}\n+\n+  static inline bool is_deleted (const value_type &)\n+  {\n+    return false;\n+  }\n+\n+  static inline void remove (value_type &) {}\n+};\n+\n+typedef hash_set<scalar_cond_masked_key> scalar_cond_masked_set_type;\n \n /* Describes two objects whose addresses must be unequal for the vectorized\n    loop to be valid.  */\n@@ -426,6 +494,9 @@ typedef class _loop_vec_info : public vec_info {\n      on inactive scalars.  */\n   vec_loop_masks masks;\n \n+  /* Set of scalar conditions that have loop mask applied.  */\n+  scalar_cond_masked_set_type scalar_cond_masked_set;\n+\n   /* If we are using a loop mask to align memory addresses, this variable\n      contains the number of vector elements that we should skip in the\n      first iteration of the vector loop (i.e. the number of leading\n@@ -1637,7 +1708,7 @@ extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *,\n extern tree vect_halve_mask_nunits (tree);\n extern tree vect_double_mask_nunits (tree);\n extern void vect_record_loop_mask (loop_vec_info, vec_loop_masks *,\n-\t\t\t\t   unsigned int, tree);\n+\t\t\t\t   unsigned int, tree, tree);\n extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n \t\t\t\tunsigned int, tree, unsigned int);\n extern stmt_vec_info info_for_reduction (stmt_vec_info);"}]}