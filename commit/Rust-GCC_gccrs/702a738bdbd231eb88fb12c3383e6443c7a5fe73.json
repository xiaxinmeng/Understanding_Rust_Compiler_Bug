{"sha": "702a738bdbd231eb88fb12c3383e6443c7a5fe73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAyYTczOGJkYmQyMzFlYjg4ZmIxMmMzMzgzZTY0NDNjN2E1ZmU3Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-19T19:46:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-19T19:46:59Z"}, "message": "re PR fortran/42783 (Bogus Array bounds violation with optional array argument)\n\n2010-01-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42783\n\t* trans-decl.c (add_argument_checking): Do not use the backend\n\tdecl directly to test for the presence of an optional dummy\n\targument.  Use gfc_conv_expr_present, remembering to set the\n\tsymbol referenced.\n\n\tPR fortran/42772\n\t* trans-decl.c (gfc_generate_function_code): Small white space\n\tchanges. If 'recurcheckvar' is NULL do not try to reset it.\n\n2010-01-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42783\n\t* gfortran.dg/bounds_check_15.f90 : New test.\n\nFrom-SVN: r156046", "tree": {"sha": "59f59cd796bef5a176ee21db239f922538ac3c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59f59cd796bef5a176ee21db239f922538ac3c28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/702a738bdbd231eb88fb12c3383e6443c7a5fe73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702a738bdbd231eb88fb12c3383e6443c7a5fe73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/702a738bdbd231eb88fb12c3383e6443c7a5fe73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/702a738bdbd231eb88fb12c3383e6443c7a5fe73/comments", "author": null, "committer": null, "parents": [{"sha": "a4f3bbc6e36c1afa4d4d660b4735161ac7fc1184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f3bbc6e36c1afa4d4d660b4735161ac7fc1184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f3bbc6e36c1afa4d4d660b4735161ac7fc1184"}], "stats": {"total": 89, "additions": 73, "deletions": 16}, "files": [{"sha": "bbf484cd7553014f2936678994cc7140c1f50cf8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=702a738bdbd231eb88fb12c3383e6443c7a5fe73", "patch": "@@ -1,3 +1,15 @@\n+2010-01-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42783\n+\t* trans-decl.c (add_argument_checking): Do not use the backend\n+\tdecl directly to test for the presence of an optional dummy\n+\targument.  Use gfc_conv_expr_present, remembering to set the\n+\tsymbol referenced.\n+\n+\tPR fortran/42772\n+\t* trans-decl.c (gfc_generate_function_code): Small white space\n+\tchanges. If 'recurcheckvar' is NULL do not try to reset it.\n+\n 2010-01-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/42545"}, {"sha": "062310af6af7c7571cb02085449330eeb1f42bbe", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=702a738bdbd231eb88fb12c3383e6443c7a5fe73", "patch": "@@ -3999,8 +3999,9 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t\t\t\t       cl->passed_length,\n \t\t\t\t       fold_convert (gfc_charlen_type_node,\n \t\t\t\t\t\t     integer_zero_node));\n-\t    not_absent = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t      fsym->backend_decl, null_pointer_node);\n+\t    /* The symbol needs to be referenced for gfc_get_symbol_decl.  */\n+\t    fsym->attr.referenced = 1;\n+\t    not_absent = gfc_conv_expr_present (fsym);\n \n \t    absent_failed = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t\t not_0length, not_absent);\n@@ -4256,7 +4257,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   stmtblock_t block;\n   stmtblock_t body;\n   tree result;\n-  tree recurcheckvar = NULL;\n+  tree recurcheckvar = NULL_TREE;\n   gfc_symbol *sym;\n   int rank;\n   bool is_recursive;\n@@ -4330,8 +4331,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n    is_recursive = sym->attr.recursive\n \t\t  || (sym->attr.entry_master\n \t\t      && sym->ns->entries->sym->attr.recursive);\n-   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION) && !is_recursive\n-       && !gfc_option.flag_recursive)\n+   if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n+\t  && !is_recursive\n+\t  && !gfc_option.flag_recursive)\n      {\n        char * msg;\n \n@@ -4348,7 +4350,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n     }\n \n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n-      && sym->attr.subroutine)\n+        && sym->attr.subroutine)\n     {\n       tree alternate_return;\n       alternate_return = gfc_get_fake_result_decl (sym, 0);\n@@ -4395,8 +4397,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n       else\n \tresult = sym->result->backend_decl;\n \n-      if (result != NULL_TREE && sym->attr.function\n-\t  && !sym->attr.pointer)\n+      if (result != NULL_TREE\n+\t    && sym->attr.function\n+\t    && !sym->attr.pointer)\n \t{\n \t  if (sym->ts.type == BT_DERIVED\n \t      && sym->ts.u.derived->attr.alloc_comp)\n@@ -4413,8 +4416,10 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* Reset recursion-check variable.  */\n-      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION) && !is_recursive\n-\t  && !gfc_option.flag_openmp)\n+      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n+\t     && !is_recursive\n+\t     && !gfc_option.flag_openmp\n+\t     && recurcheckvar != NULL_TREE)\n \t{\n \t  gfc_add_modify (&block, recurcheckvar, boolean_false_node);\n \t  recurcheckvar = NULL;\n@@ -4445,12 +4450,14 @@ gfc_generate_function_code (gfc_namespace * ns)\n     {\n       gfc_add_expr_to_block (&block, tmp);\n       /* Reset recursion-check variable.  */\n-      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION) && !is_recursive\n-\t  && !gfc_option.flag_openmp)\n-      {\n-\tgfc_add_modify (&block, recurcheckvar, boolean_false_node);\n-\trecurcheckvar = NULL;\n-      }\n+      if ((gfc_option.rtcheck & GFC_RTCHECK_RECURSION)\n+\t     && !is_recursive\n+\t     && !gfc_option.flag_openmp\n+\t     && recurcheckvar != NULL_TREE)\n+\t{\n+\t  gfc_add_modify (&block, recurcheckvar, boolean_false_node);\n+\t  recurcheckvar = NULL_TREE;\n+\t}\n     }\n \n "}, {"sha": "bdbed55c45bafa37a4c7103268ed1f53a7f07112", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=702a738bdbd231eb88fb12c3383e6443c7a5fe73", "patch": "@@ -1,3 +1,8 @@\n+2010-01-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42783\n+\t* gfortran.dg/bounds_check_15.f90 : New test.\n+\n 2010-01-19  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/41783"}, {"sha": "947ffb2f4b4b5a14814c9014dc2fb5dafd767d84", "filename": "gcc/testsuite/gfortran.dg/bounds_check_15.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/702a738bdbd231eb88fb12c3383e6443c7a5fe73/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_15.f90?ref=702a738bdbd231eb88fb12c3383e6443c7a5fe73", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! Test the fix for PR42783, in which a bogus array bounds violation\n+! with missing optional array argument.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+!\n+program gfcbug99\n+  implicit none\n+  character(len=8), parameter :: mnem_list(2) = \"A\"\n+\n+  call foo (mnem_list)  ! This call succeeds\n+  call foo ()           ! This call fails\n+contains\n+  subroutine foo (mnem_list)\n+    character(len=8) ,intent(in) ,optional :: mnem_list(:)\n+\n+    integer            :: i,j\n+    character(len=256) :: ml\n+    ml = ''\n+    j = 0\n+    if (present (mnem_list)) then\n+       do i = 1, size (mnem_list)\n+          if (mnem_list(i) /= \"\") then\n+             j = j + 1\n+             if (j > len (ml)/8) call abort ()\n+             ml((j-1)*8+1:(j-1)*8+8) = mnem_list(i)\n+          end if\n+       end do\n+    end if\n+    if (j > 0) print *, trim (ml(1:8))\n+  end subroutine foo\n+end program gfcbug99"}]}