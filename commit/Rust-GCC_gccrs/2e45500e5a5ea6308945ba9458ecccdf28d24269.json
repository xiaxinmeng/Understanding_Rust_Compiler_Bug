{"sha": "2e45500e5a5ea6308945ba9458ecccdf28d24269", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0NTUwMGU1YTVlYTYzMDg5NDViYTk0NThlY2NjZGYyOGQyNDI2OQ==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-04-06T09:28:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:28:33Z"}, "message": "uintp.ads, uintp.adb (UI_Div_Rem): New subprogram, extending previous implementation of UI_Div.\n\n2007-04-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* uintp.ads, uintp.adb (UI_Div_Rem): New subprogram, extending previous\n\timplementation of UI_Div.\n\t(UI_Div): Reimplement as a call to UI_Div_Rem.\n\t(UI_Rem): Take advantage of the fact that UI_Div_Rem provides the\n\tremainder, avoiding the cost of a multiplication and a subtraction.\n\t(UI_Modular_Inverse): Take advantage of the fact that UI_Div_Rem\n\tprovides both quotient and remainder in a single computation.\n\t(UI_Modular_Exponentiation, UI_Modular_Inverse): New modular arithmetic\n\tfunctions for uint.\n\t(UI_Modular_Inverse): Add a note that the behaviour of this subprogram\n\tis undefined if the given n is not inversible.\n\nFrom-SVN: r123603", "tree": {"sha": "9f79fd08002a2888dd7edf0387a56e70b06d129d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f79fd08002a2888dd7edf0387a56e70b06d129d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e45500e5a5ea6308945ba9458ecccdf28d24269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e45500e5a5ea6308945ba9458ecccdf28d24269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e45500e5a5ea6308945ba9458ecccdf28d24269", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e45500e5a5ea6308945ba9458ecccdf28d24269/comments", "author": null, "committer": null, "parents": [{"sha": "d72eef2995c548bcec77bebacf09e1a8a22151c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72eef2995c548bcec77bebacf09e1a8a22151c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72eef2995c548bcec77bebacf09e1a8a22151c4"}], "stats": {"total": 295, "additions": 245, "deletions": 50}, "files": [{"sha": "01d45b3ed3e3e0d45e93d673bf2a96e02ec89a6c", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 211, "deletions": 27, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e45500e5a5ea6308945ba9458ecccdf28d24269/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e45500e5a5ea6308945ba9458ecccdf28d24269/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=2e45500e5a5ea6308945ba9458ecccdf28d24269", "patch": "@@ -166,10 +166,20 @@ package body Uintp is\n    function Sum_Double_Digits (Left : Uint; Sign : Int) return Int;\n    --  Same as above but work in New_Base = Base * Base\n \n+   procedure UI_Div_Rem\n+     (Left, Right       : Uint;\n+      Quotient          : out Uint;\n+      Remainder         : out Uint;\n+      Discard_Quotient  : Boolean;\n+      Discard_Remainder : Boolean);\n+   --  Compute euclidian division of Left by Right, and return Quotient and\n+   --  signed Remainder (Left rem Right).\n+   --  If Discard_Quotient is True, Quotient is left unchanged.\n+   --  If Discard_Remainder is True, Remainder is left unchanged.\n+\n    function Vector_To_Uint\n      (In_Vec   : UI_Vector;\n-      Negative : Boolean)\n-      return     Uint;\n+      Negative : Boolean) return Uint;\n    --  Functions that calculate values in UI_Vectors, call this function\n    --  to create and return the Uint value. In_Vec contains the multiple\n    --  precision (Base) representation of a non-negative value. Leading\n@@ -1244,13 +1254,49 @@ package body Uintp is\n    end UI_Div;\n \n    function UI_Div (Left, Right : Uint) return Uint is\n+      Quotient  : Uint;\n+      Remainder : Uint;\n+   begin\n+      UI_Div_Rem\n+        (Left, Right,\n+         Quotient, Remainder,\n+         Discard_Quotient  => False,\n+         Discard_Remainder => True);\n+      return Quotient;\n+   end UI_Div;\n+\n+   ----------------\n+   -- UI_Div_Rem --\n+   ----------------\n+\n+   procedure UI_Div_Rem\n+     (Left, Right       : Uint;\n+      Quotient          : out Uint;\n+      Remainder         : out Uint;\n+      Discard_Quotient  : Boolean;\n+      Discard_Remainder : Boolean)\n+   is\n    begin\n       pragma Assert (Right /= Uint_0);\n \n       --  Cases where both operands are represented directly\n \n       if Direct (Left) and then Direct (Right) then\n-         return UI_From_Int (Direct_Val (Left) / Direct_Val (Right));\n+         declare\n+            DV_Left  : constant Int := Direct_Val (Left);\n+            DV_Right : constant Int := Direct_Val (Right);\n+\n+         begin\n+            if not Discard_Quotient then\n+               Quotient := UI_From_Int (DV_Left / DV_Right);\n+            end if;\n+\n+            if not Discard_Remainder then\n+               Remainder := UI_From_Int (DV_Left rem DV_Right);\n+            end if;\n+\n+            return;\n+         end;\n       end if;\n \n       declare\n@@ -1260,17 +1306,54 @@ package body Uintp is\n          L_Vec       : UI_Vector (1 .. L_Length);\n          R_Vec       : UI_Vector (1 .. R_Length);\n          D           : Int;\n-         Remainder   : Int;\n+         Remainder_I : Int;\n          Tmp_Divisor : Int;\n          Carry       : Int;\n          Tmp_Int     : Int;\n          Tmp_Dig     : Int;\n \n+         procedure UI_Div_Vector\n+           (L_Vec     : UI_Vector;\n+            R_Int     : Int;\n+            Quotient  : out UI_Vector;\n+            Remainder : out Int);\n+         pragma Inline (UI_Div_Vector);\n+         --  Specialised variant for case where the divisor is a single digit\n+\n+         procedure UI_Div_Vector\n+           (L_Vec     : UI_Vector;\n+            R_Int     : Int;\n+            Quotient  : out UI_Vector;\n+            Remainder : out Int)\n+         is\n+            Tmp_Int : Int;\n+\n+         begin\n+            Remainder := 0;\n+            for J in L_Vec'Range loop\n+               Tmp_Int := Remainder * Base + abs L_Vec (J);\n+               Quotient (Quotient'First + J - L_Vec'First) := Tmp_Int / R_Int;\n+               Remainder := Tmp_Int rem R_Int;\n+            end loop;\n+\n+            if L_Vec (L_Vec'First) < Int_0 then\n+               Remainder := -Remainder;\n+            end if;\n+         end UI_Div_Vector;\n+\n+      --  Start of processing for UI_Div_Rem\n+\n       begin\n          --  Result is zero if left operand is shorter than right\n \n          if L_Length < R_Length then\n-            return Uint_0;\n+            if not Discard_Quotient then\n+               Quotient := Uint_0;\n+            end if;\n+            if not Discard_Remainder then\n+               Remainder := Left;\n+            end if;\n+            return;\n          end if;\n \n          Init_Operand (Left, L_Vec);\n@@ -1282,22 +1365,24 @@ package body Uintp is\n          --  ordinary long division by hand).\n \n          if R_Length = Int_1 then\n-            Remainder := 0;\n             Tmp_Divisor := abs R_Vec (1);\n \n             declare\n-               Quotient : UI_Vector (1 .. L_Length);\n+               Quotient_V : UI_Vector (1 .. L_Length);\n \n             begin\n-               for J in L_Vec'Range loop\n-                  Tmp_Int      := Remainder * Base + abs L_Vec (J);\n-                  Quotient (J) := Tmp_Int / Tmp_Divisor;\n-                  Remainder    := Tmp_Int rem Tmp_Divisor;\n-               end loop;\n+               UI_Div_Vector (L_Vec, Tmp_Divisor, Quotient_V, Remainder_I);\n \n-               return\n-                 Vector_To_Uint\n-                   (Quotient, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+               if not Discard_Quotient then\n+                  Quotient :=\n+                    Vector_To_Uint\n+                      (Quotient_V, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+               end if;\n+\n+               if not Discard_Remainder then\n+                  Remainder := UI_From_Int (Remainder_I);\n+               end if;\n+               return;\n             end;\n          end if;\n \n@@ -1308,7 +1393,7 @@ package body Uintp is\n          Algorithm_D : declare\n             Dividend     : UI_Vector (1 .. L_Length + 1);\n             Divisor      : UI_Vector (1 .. R_Length);\n-            Quotient     : UI_Vector (1 .. Q_Length);\n+            Quotient_V   : UI_Vector (1 .. Q_Length);\n             Divisor_Dig1 : Int;\n             Divisor_Dig2 : Int;\n             Q_Guess      : Int;\n@@ -1359,7 +1444,7 @@ package body Uintp is\n             Divisor_Dig1 := Divisor (1);\n             Divisor_Dig2 := Divisor (2);\n \n-            for J in Quotient'Range loop\n+            for J in Quotient_V'Range loop\n \n                --  [ CALCULATE Q (hat) ] (step D3 in the algorithm)\n \n@@ -1382,7 +1467,7 @@ package body Uintp is\n                   Q_Guess := Q_Guess - 1;\n                end loop;\n \n-               --  [ MULTIPLY & SUBTRACT] (step D4). Q_Guess * Divisor is\n+               --  [ MULTIPLY & SUBTRACT ] (step D4). Q_Guess * Divisor is\n                --  subtracted from the remaining dividend.\n \n                Carry := 0;\n@@ -1433,15 +1518,31 @@ package body Uintp is\n \n                --  Finally we can get the next quotient digit\n \n-               Quotient (J) := Q_Guess;\n+               Quotient_V (J) := Q_Guess;\n             end loop;\n \n-            return Vector_To_Uint\n-              (Quotient, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+            --  [ UNNORMALIZE ] (step D8)\n+\n+            if not Discard_Quotient then\n+               Quotient := Vector_To_Uint\n+                 (Quotient_V, (L_Vec (1) < Int_0 xor R_Vec (1) < Int_0));\n+            end if;\n \n+            if not Discard_Remainder then\n+               declare\n+                  Remainder_V : UI_Vector (1 .. R_Length);\n+                  Discard_Int : Int;\n+               begin\n+                  UI_Div_Vector\n+                    (Dividend (Dividend'Last - R_Length + 1 .. Dividend'Last),\n+                     D,\n+                     Remainder_V, Discard_Int);\n+                  Remainder := Vector_To_Uint (Remainder_V, L_Vec (1) < Int_0);\n+               end;\n+            end if;\n          end Algorithm_D;\n       end;\n-   end UI_Div;\n+   end UI_Div_Rem;\n \n    ------------\n    -- UI_Eq --\n@@ -2046,6 +2147,83 @@ package body Uintp is\n       end if;\n    end UI_Mod;\n \n+   -------------------------------\n+   -- UI_Modular_Exponentiation --\n+   -------------------------------\n+\n+   function UI_Modular_Exponentiation\n+     (B      : Uint;\n+      E      : Uint;\n+      Modulo : Uint) return Uint\n+   is\n+      M : constant Save_Mark := Mark;\n+\n+      Result   : Uint := Uint_1;\n+      Base     : Uint := B;\n+      Exponent : Uint := E;\n+\n+   begin\n+      while Exponent /= Uint_0 loop\n+         if Least_Sig_Digit (Exponent) rem Int'(2) = Int'(1) then\n+            Result := (Result * Base) rem Modulo;\n+         end if;\n+\n+         Exponent := Exponent / Uint_2;\n+         Base := (Base * Base) rem Modulo;\n+      end loop;\n+\n+      Release_And_Save (M, Result);\n+      return Result;\n+   end UI_Modular_Exponentiation;\n+\n+   ------------------------\n+   -- UI_Modular_Inverse --\n+   ------------------------\n+\n+   function UI_Modular_Inverse (N : Uint; Modulo : Uint) return Uint is\n+      M : constant Save_Mark := Mark;\n+      U : Uint;\n+      V : Uint;\n+      Q : Uint;\n+      R : Uint;\n+      X : Uint;\n+      Y : Uint;\n+      T : Uint;\n+      S : Int := 1;\n+\n+   begin\n+      U := Modulo;\n+      V := N;\n+\n+      X := Uint_1;\n+      Y := Uint_0;\n+\n+      loop\n+         UI_Div_Rem\n+           (U, V,\n+            Quotient => Q, Remainder => R,\n+            Discard_Quotient  => False,\n+            Discard_Remainder => False);\n+\n+         U := V;\n+         V := R;\n+\n+         T := X;\n+         X := Y + Q * X;\n+         Y := T;\n+         S := -S;\n+\n+         exit when R = Uint_1;\n+      end loop;\n+\n+      if S = Int'(-1) then\n+         X := Modulo - X;\n+      end if;\n+\n+      Release_And_Save (M, X);\n+      return X;\n+   end UI_Modular_Inverse;\n+\n    ------------\n    -- UI_Mul --\n    ------------\n@@ -2246,6 +2424,7 @@ package body Uintp is\n             return UI_From_Int (Direct_Val (Left) rem Direct_Val (Right));\n \n          else\n+\n             --  Special cases when Right is less than 13 and Left is larger\n             --  larger than one digit. All of these algorithms depend on the\n             --  base being 2 ** 15 We work with Abs (Left) and Abs(Right)\n@@ -2375,15 +2554,20 @@ package body Uintp is\n \n             --  Else fall through to general case\n \n-            --  ???This needs to be improved. We have the Rem when we do the\n-            --  Div. Div throws it away!\n-\n-            --  The special case Length (Left) = Length(right) = 1 in Div\n+            --  The special case Length (Left) = Length (Right) = 1 in Div\n             --  looks slow. It uses UI_To_Int when Int should suffice. ???\n          end if;\n       end if;\n \n-      return Left - (Left / Right) * Right;\n+      declare\n+         Quotient, Remainder : Uint;\n+      begin\n+         UI_Div_Rem\n+           (Left, Right, Quotient, Remainder,\n+            Discard_Quotient  => True,\n+            Discard_Remainder => False);\n+         return Remainder;\n+      end;\n    end UI_Rem;\n \n    ------------"}, {"sha": "ad4782b2ae6161b1b94bc169ac33e71056350842", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e45500e5a5ea6308945ba9458ecccdf28d24269/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e45500e5a5ea6308945ba9458ecccdf28d24269/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=2e45500e5a5ea6308945ba9458ecccdf28d24269", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -224,6 +224,17 @@ package Uintp is\n    pragma Inline (UI_Sub);\n    --  Returns difference of two integer values\n \n+   function UI_Modular_Exponentiation\n+     (B      : Uint;\n+      E      : Uint;\n+      Modulo : Uint) return Uint;\n+   --  Efficiently compute (B ** E) rem Modulo\n+\n+   function UI_Modular_Inverse (N : Uint; Modulo : Uint) return Uint;\n+   --  Compute the multiplicative inverse of N in modular arithmetics with the\n+   --  given Modulo (uses Euclid's algorithm). Note: the call is considered\n+   --  to be erroneous (and the behavior is undefined) if n is not inversible.\n+\n    function UI_From_Dint (Input : Dint) return Uint;\n    --  Converts Dint value to universal integer form\n \n@@ -392,29 +403,29 @@ private\n    --  a multi-digit format using Base as the base. This value is chosen so\n    --  that the product Base*Base is within the range of allowed Int values.\n \n-   --  Base is defined to allow efficient execution of the primitive\n-   --  operations (a0, b0, c0) defined in the section \"The Classical\n-   --  Algorithms\" (sec. 4.3.1) of Donald Knuth's \"The Art of Computer\n-   --  Programming\", Vol. 2. These algorithms are used in this package.\n+   --  Base is defined to allow efficient execution of the primitive operations\n+   --  (a0, b0, c0) defined in the section \"The Classical Algorithms\"\n+   --  (sec. 4.3.1) of Donald Knuth's \"The Art of Computer  Programming\",\n+   --  Vol. 2. These algorithms are used in this package.\n \n    Base_Bits : constant := 15;\n    --  Number of bits in base value\n \n    Base : constant Int := 2 ** Base_Bits;\n \n-   --  Values in the range -(Base+1) .. maxdirect are encoded directly as\n-   --  Uint values by adding a bias value. The value of maxdirect is chosen\n+   --  Values in the range -(Base+1) .. Max_Direct are encoded directly as\n+   --  Uint values by adding a bias value. The value of Max_Direct is chosen\n    --  so that a directly represented number always fits in two digits when\n    --  represented in base format.\n \n    Min_Direct : constant Int := -(Base - 1);\n    Max_Direct : constant Int := (Base - 1) * (Base - 1);\n \n    --  The following values define the bias used to store Uint values which\n-   --  are in this range, as well as the biased values for the first and\n-   --  last values in this range. We use a new derived type for these\n-   --  constants to avoid accidental use of Uint arithmetic on these\n-   --  values, which is never correct.\n+   --  are in this range, as well as the biased values for the first and last\n+   --  values in this range. We use a new derived type for these constants to\n+   --  avoid accidental use of Uint arithmetic on these values, which is never\n+   --  correct.\n \n    type Ctrl is range Int'First .. Int'Last;\n \n@@ -466,23 +477,23 @@ private\n       Save_Udigit : Int;\n    end record;\n \n-   --  Values outside the range that is represented directly are stored\n-   --  using two tables. The secondary table Udigits contains sequences of\n-   --  Int values consisting of the digits of the number in a radix Base\n-   --  system. The digits are stored from most significant to least\n-   --  significant with the first digit only carrying the sign.\n+   --  Values outside the range that is represented directly are stored using\n+   --  two tables. The secondary table Udigits contains sequences of Int values\n+   --  consisting of the digits of the number in a radix Base system. The\n+   --  digits are stored from most significant to least significant with the\n+   --  first digit only carrying the sign.\n \n    --  There is one entry in the primary Uints table for each distinct Uint\n    --  value. This table entry contains the length (number of digits) and\n    --  a starting offset of the value in the Udigits table.\n \n    Uint_First_Entry : constant Uint := Uint (Uint_Table_Start);\n \n-   --  Some subprograms defined in this package manipulate the Udigits\n-   --  table directly, while for others it is more convenient to work with\n-   --  locally defined arrays of the digits of the Universal Integers.\n-   --  The type UI_Vector is defined for this purpose and some internal\n-   --  subprograms used for converting from one to the other are defined.\n+   --  Some subprograms defined in this package manipulate the Udigits table\n+   --  directly, while for others it is more convenient to work with locally\n+   --  defined arrays of the digits of the Universal Integers. The type\n+   --  UI_Vector is defined for this purpose and some internal subprograms\n+   --  used for converting from one to the other are defined.\n \n    type UI_Vector is array (Pos range <>) of Int;\n    --  Vector containing the integer values of a Uint value\n@@ -522,7 +533,7 @@ private\n      Table_Name           => \"Udigits\");\n \n    --  Note: the reason these tables are defined here in the private part of\n-   --  the spec, rather than in the body, is that they are refrerenced\n-   --  directly by gigi.\n+   --  the spec, rather than in the body, is that they are referenced directly\n+   --  by gigi.\n \n end Uintp;"}]}