{"sha": "988db853d9eed0b01b2ab465a524ad919b2b66cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg4ZGI4NTNkOWVlZDBiMDFiMmFiNDY1YTUyNGFkOTE5YjJiNjZjZg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2015-04-16T20:57:46Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2015-04-16T20:57:46Z"}, "message": "class.c (resolve_address_of_overloaded_function, [...]): Rename tsubst_flags_t parameter flags -> complain.\n\n2015-04-16  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* class.c (resolve_address_of_overloaded_function, instantiate_type):\n\tRename tsubst_flags_t parameter flags -> complain.\n\nFrom-SVN: r222159", "tree": {"sha": "723f90e4388cf5e92d9d8e19f1dd3b7f724920fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/723f90e4388cf5e92d9d8e19f1dd3b7f724920fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/988db853d9eed0b01b2ab465a524ad919b2b66cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/988db853d9eed0b01b2ab465a524ad919b2b66cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/988db853d9eed0b01b2ab465a524ad919b2b66cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/988db853d9eed0b01b2ab465a524ad919b2b66cf/comments", "author": null, "committer": null, "parents": [{"sha": "6e3957da3145a2d2a1d8837d6a78aa1663245764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e3957da3145a2d2a1d8837d6a78aa1663245764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e3957da3145a2d2a1d8837d6a78aa1663245764"}], "stats": {"total": 55, "additions": 30, "deletions": 25}, "files": [{"sha": "b3feab14b09d18df7caf0cb80399b4799af89b85", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988db853d9eed0b01b2ab465a524ad919b2b66cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988db853d9eed0b01b2ab465a524ad919b2b66cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=988db853d9eed0b01b2ab465a524ad919b2b66cf", "patch": "@@ -1,3 +1,8 @@\n+2015-04-16  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* class.c (resolve_address_of_overloaded_function, instantiate_type):\n+\tRename tsubst_flags_t parameter flags -> complain.\n+\n 2015-04-16  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* call.c (build_op_delete_call, build_over_call): Check mark_used"}, {"sha": "d80d312e7d2997984df6fbb81a9f71d10e8d1fa9", "filename": "gcc/cp/class.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988db853d9eed0b01b2ab465a524ad919b2b66cf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988db853d9eed0b01b2ab465a524ad919b2b66cf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=988db853d9eed0b01b2ab465a524ad919b2b66cf", "patch": "@@ -7471,7 +7471,7 @@ pop_lang_context (void)\n static tree\n resolve_address_of_overloaded_function (tree target_type,\n \t\t\t\t\ttree overload,\n-\t\t\t\t\ttsubst_flags_t flags,\n+\t\t\t\t\ttsubst_flags_t complain,\n \t\t\t\t\tbool template_only,\n \t\t\t\t\ttree explicit_targs,\n \t\t\t\t\ttree access_path)\n@@ -7531,7 +7531,7 @@ resolve_address_of_overloaded_function (tree target_type,\n     target_type = build_reference_type (target_type);\n   else\n     {\n-      if (flags & tf_error)\n+      if (complain & tf_error)\n \terror (\"cannot resolve overloaded function %qD based on\"\n \t       \" conversion to type %qT\",\n \t       DECL_NAME (OVL_FUNCTION (overload)), target_type);\n@@ -7667,7 +7667,7 @@ resolve_address_of_overloaded_function (tree target_type,\n   if (matches == NULL_TREE)\n     {\n       /* There were *no* matches.  */\n-      if (flags & tf_error)\n+      if (complain & tf_error)\n \t{\n \t  error (\"no matches converting function %qD to type %q#T\",\n \t\t DECL_NAME (OVL_CURRENT (overload)),\n@@ -7695,7 +7695,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \n       if (match)\n \t{\n-\t  if (flags & tf_error)\n+\t  if (complain & tf_error)\n \t    {\n \t      error (\"converting overloaded function %qD to type %q#T is ambiguous\",\n \t\t     DECL_NAME (OVL_FUNCTION (overload)),\n@@ -7717,11 +7717,11 @@ resolve_address_of_overloaded_function (tree target_type,\n   fn = TREE_PURPOSE (matches);\n \n   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n-      && !(flags & tf_ptrmem_ok) && !flag_ms_extensions)\n+      && !(complain & tf_ptrmem_ok) && !flag_ms_extensions)\n     {\n       static int explained;\n \n-      if (!(flags & tf_error))\n+      if (!(complain & tf_error))\n \treturn error_mark_node;\n \n       permerror (input_location, \"assuming pointer to member %qD\", fn);\n@@ -7742,20 +7742,20 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (fn == NULL)\n \treturn error_mark_node;\n       /* Mark all the versions corresponding to the dispatcher as used.  */\n-      if (!(flags & tf_conv))\n+      if (!(complain & tf_conv))\n \tmark_versions_used (fn);\n     }\n \n   /* If we're doing overload resolution purely for the purpose of\n      determining conversion sequences, we should not consider the\n      function used.  If this conversion sequence is selected, the\n      function will be marked as used at this point.  */\n-  if (!(flags & tf_conv))\n+  if (!(complain & tf_conv))\n     {\n       /* Make =delete work with SFINAE.  */\n-      if (DECL_DELETED_FN (fn) && !(flags & tf_error))\n+      if (DECL_DELETED_FN (fn) && !(complain & tf_error))\n \treturn error_mark_node;\n-      if (!mark_used (fn, flags) && !(flags & tf_error))\n+      if (!mark_used (fn, complain) && !(complain & tf_error))\n \treturn error_mark_node;\n     }\n \n@@ -7765,11 +7765,11 @@ resolve_address_of_overloaded_function (tree target_type,\n   if (DECL_FUNCTION_MEMBER_P (fn))\n     {\n       gcc_assert (access_path);\n-      perform_or_defer_access_check (access_path, fn, fn, flags);\n+      perform_or_defer_access_check (access_path, fn, fn, complain);\n     }\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n-    return cp_build_addr_expr (fn, flags);\n+    return cp_build_addr_expr (fn, complain);\n   else\n     {\n       /* The target must be a REFERENCE_TYPE.  Above, cp_build_unary_op\n@@ -7783,7 +7783,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \n /* This function will instantiate the type of the expression given in\n    RHS to match the type of LHSTYPE.  If errors exist, then return\n-   error_mark_node. FLAGS is a bit mask.  If TF_ERROR is set, then\n+   error_mark_node. COMPLAIN is a bit mask.  If TF_ERROR is set, then\n    we complain on errors.  If we are not complaining, never modify rhs,\n    as overload resolution wants to try many possible instantiations, in\n    the hope that at least one will work.\n@@ -7792,16 +7792,16 @@ resolve_address_of_overloaded_function (tree target_type,\n    function, or a pointer to member function.  */\n \n tree\n-instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n+instantiate_type (tree lhstype, tree rhs, tsubst_flags_t complain)\n {\n-  tsubst_flags_t flags_in = flags;\n+  tsubst_flags_t complain_in = complain;\n   tree access_path = NULL_TREE;\n \n-  flags &= ~tf_ptrmem_ok;\n+  complain &= ~tf_ptrmem_ok;\n \n   if (lhstype == unknown_type_node)\n     {\n-      if (flags & tf_error)\n+      if (complain & tf_error)\n \terror (\"not enough type information\");\n       return error_mark_node;\n     }\n@@ -7819,7 +7819,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \t;\n       else\n \t{\n-\t  if (flags & tf_error)\n+\t  if (complain & tf_error)\n \t    error (\"cannot convert %qE from type %qT to type %qT\",\n \t\t   rhs, TREE_TYPE (rhs), fntype);\n \t  return error_mark_node;\n@@ -7836,7 +7836,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n      deduce any type information.  */\n   if (TREE_CODE (rhs) == NON_DEPENDENT_EXPR)\n     {\n-      if (flags & tf_error)\n+      if (complain & tf_error)\n \terror (\"not enough type information\");\n       return error_mark_node;\n     }\n@@ -7859,7 +7859,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       {\n \ttree member = TREE_OPERAND (rhs, 1);\n \n-\tmember = instantiate_type (lhstype, member, flags);\n+\tmember = instantiate_type (lhstype, member, complain);\n \tif (member != error_mark_node\n \t    && TREE_SIDE_EFFECTS (TREE_OPERAND (rhs, 0)))\n \t  /* Do not lose object's side effects.  */\n@@ -7871,7 +7871,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case OFFSET_REF:\n       rhs = TREE_OPERAND (rhs, 1);\n       if (BASELINK_P (rhs))\n-\treturn instantiate_type (lhstype, rhs, flags_in);\n+\treturn instantiate_type (lhstype, rhs, complain_in);\n \n       /* This can happen if we are forming a pointer-to-member for a\n \t member template.  */\n@@ -7885,25 +7885,25 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \ttree args = TREE_OPERAND (rhs, 1);\n \n \treturn\n-\t  resolve_address_of_overloaded_function (lhstype, fns, flags_in,\n+\t  resolve_address_of_overloaded_function (lhstype, fns, complain_in,\n \t\t\t\t\t\t  /*template_only=*/true,\n \t\t\t\t\t\t  args, access_path);\n       }\n \n     case OVERLOAD:\n     case FUNCTION_DECL:\n       return\n-\tresolve_address_of_overloaded_function (lhstype, rhs, flags_in,\n+\tresolve_address_of_overloaded_function (lhstype, rhs, complain_in,\n \t\t\t\t\t\t/*template_only=*/false,\n \t\t\t\t\t\t/*explicit_targs=*/NULL_TREE,\n \t\t\t\t\t\taccess_path);\n \n     case ADDR_EXPR:\n     {\n       if (PTRMEM_OK_P (rhs))\n-\tflags |= tf_ptrmem_ok;\n+\tcomplain |= tf_ptrmem_ok;\n \n-      return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n+      return instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n     }\n \n     case ERROR_MARK:"}]}