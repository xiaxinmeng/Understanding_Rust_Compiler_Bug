{"sha": "a69901850b00e526125cb0500ea08d207dfbce03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY5OTAxODUwYjAwZTUyNjEyNWNiMDUwMGVhMDhkMjA3ZGZiY2UwMw==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@amelek.gda.pl", "date": "2005-03-06T21:50:36Z"}, "committer": {"name": "Marek Michalkiewicz", "email": "marekm@gcc.gnu.org", "date": "2005-03-06T21:50:36Z"}, "message": "re PR target/20288 (AVR assignment of a value through a 16 bit pointer generates out of order code)\n\n\tPR target/20288\n\t* config/avr/avr.c (print_operand): Add 'p' and 'r'.\n\t(out_movhi_r_mr): Read low byte of volatile MEM first.\n\t(out_movhi_mr_r): Write high byte of volatile MEM first.\n\nFrom-SVN: r95993", "tree": {"sha": "10f2b1db6d15ea7f5daa0088199a79ff12f28620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10f2b1db6d15ea7f5daa0088199a79ff12f28620"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a69901850b00e526125cb0500ea08d207dfbce03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69901850b00e526125cb0500ea08d207dfbce03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a69901850b00e526125cb0500ea08d207dfbce03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a69901850b00e526125cb0500ea08d207dfbce03/comments", "author": null, "committer": null, "parents": [{"sha": "b261a494d6e7e1759b5fa00d2c5824d1ca148fe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b261a494d6e7e1759b5fa00d2c5824d1ca148fe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b261a494d6e7e1759b5fa00d2c5824d1ca148fe3"}], "stats": {"total": 115, "additions": 91, "deletions": 24}, "files": [{"sha": "52b36d7625fa8bf9e883713be3e0a29b67d1d023", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a69901850b00e526125cb0500ea08d207dfbce03", "patch": "@@ -1,3 +1,10 @@\n+2005-03-06  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n+\n+\tPR target/20288\n+\t* config/avr/avr.c (print_operand): Add 'p' and 'r'.\n+\t(out_movhi_r_mr): Read low byte of volatile MEM first.\n+\t(out_movhi_mr_r): Write high byte of volatile MEM first.\n+\n 2005-03-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cselib.c (reg_values, reg_values_size): Make them static."}, {"sha": "e7a453ee63cc5a6e936fea4b835f93668193c4c1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 82, "deletions": 24, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a69901850b00e526125cb0500ea08d207dfbce03", "patch": "@@ -1120,6 +1120,16 @@ print_operand (FILE *file, rtx x, int code)\n \n \t  print_operand (file, XEXP (addr, 1), 0);\n \t}\n+      else if (code == 'p' || code == 'r')\n+        {\n+          if (GET_CODE (addr) != POST_INC && GET_CODE (addr) != PRE_DEC)\n+            fatal_insn (\"bad address, not post_inc or pre_dec:\", addr);\n+          \n+          if (code == 'p')\n+            print_operand_address (file, XEXP (addr, 0));  /* X, Y, Z */\n+          else\n+            print_operand (file, XEXP (addr, 0), 0);  /* r26, r28, r30 */\n+        }\n       else if (GET_CODE (addr) == PLUS)\n \t{\n \t  print_operand_address (file, XEXP (addr,0));\n@@ -1835,6 +1845,9 @@ out_movhi_r_mr (rtx insn, rtx op[], int *l)\n   rtx base = XEXP (src, 0);\n   int reg_dest = true_regnum (dest);\n   int reg_base = true_regnum (base);\n+  /* \"volatile\" forces reading low byte first, even if less efficient,\n+     for correct operation with 16-bit I/O registers.  */\n+  int mem_volatile_p = MEM_VOLATILE_P (src);\n   int tmp;\n \n   if (!l)\n@@ -1928,6 +1941,25 @@ out_movhi_r_mr (rtx insn, rtx op[], int *l)\n       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n \tfatal_insn (\"incorrect insn:\", insn);\n \n+      if (mem_volatile_p)\n+        {\n+          if (REGNO (XEXP (base, 0)) == REG_X)\n+            {\n+              *l = 4;\n+              return (AS2 (sbiw,r26,2)  CR_TAB\n+                      AS2 (ld,%A0,X+)   CR_TAB\n+                      AS2 (ld,%B0,X)    CR_TAB\n+                      AS2 (sbiw,r26,1));\n+            }\n+          else\n+            {\n+              *l = 3;\n+              return (AS2 (sbiw,%r1,2)   CR_TAB\n+                      AS2 (ld,%A0,%p1)  CR_TAB\n+                      AS2 (ldd,%B0,%p1+1));\n+            }\n+        }\n+\n       *l = 2;\n       return (AS2 (ld,%B0,%1) CR_TAB\n \t      AS2 (ld,%A0,%1));\n@@ -2508,7 +2540,11 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n   rtx base = XEXP (dest, 0);\n   int reg_base = true_regnum (base);\n   int reg_src = true_regnum (src);\n+  /* \"volatile\" forces writing high byte first, even if less efficient,\n+     for correct operation with 16-bit I/O registers.  */\n+  int mem_volatile_p = MEM_VOLATILE_P (dest);\n   int tmp;\n+\n   if (!l)\n     l = &tmp;\n   if (CONSTANT_ADDRESS_P (base))\n@@ -2528,33 +2564,33 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n         {\n           if (reg_src == REG_X)\n             {\n-\t      /* \"st X+,r26\" is undefined */\n-              if (reg_unused_after (insn, src))\n+              /* \"st X+,r26\" and \"st -X,r26\" are undefined.  */\n+              if (!mem_volatile_p && reg_unused_after (insn, src))\n \t\treturn *l=4, (AS2 (mov,__tmp_reg__,r27) CR_TAB\n \t\t\t      AS2 (st,X,r26)            CR_TAB\n \t\t\t      AS2 (adiw,r26,1)          CR_TAB\n \t\t\t      AS2 (st,X,__tmp_reg__));\n               else\n \t\treturn *l=5, (AS2 (mov,__tmp_reg__,r27) CR_TAB\n-\t\t\t      AS2 (st,X,r26)            CR_TAB\n \t\t\t      AS2 (adiw,r26,1)          CR_TAB\n \t\t\t      AS2 (st,X,__tmp_reg__)    CR_TAB\n-\t\t\t      AS2 (sbiw,r26,1));\n+                              AS2 (sbiw,r26,1)          CR_TAB\n+                              AS2 (st,X,r26));\n             }\n           else\n             {\n-              if (reg_unused_after (insn, base))\n+              if (!mem_volatile_p && reg_unused_after (insn, base))\n                 return *l=2, (AS2 (st,X+,%A1) CR_TAB\n                               AS2 (st,X,%B1));\n               else\n-                return *l=3, (AS2 (st  ,X+,%A1) CR_TAB\n-                              AS2 (st  ,X,%B1) CR_TAB\n-                              AS2 (sbiw,r26,1));\n+                return *l=3, (AS2 (adiw,r26,1) CR_TAB\n+                              AS2 (st,X,%B1)   CR_TAB\n+                              AS2 (st,-X,%A1));\n             }\n         }\n       else\n-        return  *l=2, (AS2 (st ,%0,%A1)    CR_TAB\n-                       AS2 (std,%0+1,%B1));\n+        return  *l=2, (AS2 (std,%0+1,%B1) CR_TAB\n+                       AS2 (st,%0,%A1));\n     }\n   else if (GET_CODE (base) == PLUS)\n     {\n@@ -2567,46 +2603,68 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n \n \t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n \t    return *l = 4, (AS2 (adiw,r28,%o0-62) CR_TAB\n-\t\t\t    AS2 (std,Y+62,%A1)    CR_TAB\n \t\t\t    AS2 (std,Y+63,%B1)    CR_TAB\n+\t\t\t    AS2 (std,Y+62,%A1)    CR_TAB\n \t\t\t    AS2 (sbiw,r28,%o0-62));\n \n \t  return *l = 6, (AS2 (subi,r28,lo8(-%o0)) CR_TAB\n \t\t\t  AS2 (sbci,r29,hi8(-%o0)) CR_TAB\n-\t\t\t  AS2 (st,Y,%A1)           CR_TAB\n \t\t\t  AS2 (std,Y+1,%B1)        CR_TAB\n+\t\t\t  AS2 (st,Y,%A1)           CR_TAB\n \t\t\t  AS2 (subi,r28,lo8(%o0))  CR_TAB\n \t\t\t  AS2 (sbci,r29,hi8(%o0)));\n \t}\n       if (reg_base == REG_X)\n \t{\n \t  /* (X + d) = R */\n \t  if (reg_src == REG_X)\n-\t    {\n+            {\n \t      *l = 7;\n \t      return (AS2 (mov,__tmp_reg__,r26)  CR_TAB\n \t\t      AS2 (mov,__zero_reg__,r27) CR_TAB\n-\t\t      AS2 (adiw,r26,%o0)         CR_TAB\n-\t\t      AS2 (st,X+,__tmp_reg__)    CR_TAB\n+                      AS2 (adiw,r26,%o0+1)       CR_TAB\n \t\t      AS2 (st,X,__zero_reg__)    CR_TAB\n+\t\t      AS2 (st,-X,__tmp_reg__)    CR_TAB\n \t\t      AS1 (clr,__zero_reg__)     CR_TAB\n-\t\t      AS2 (sbiw,r26,%o0+1));\n+                      AS2 (sbiw,r26,%o0));\n \t    }\n \t  *l = 4;\n-\t  return (AS2 (adiw,r26,%o0) CR_TAB\n-\t\t  AS2 (st,X+,%A1)    CR_TAB\n-\t\t  AS2 (st,X,%B1)     CR_TAB\n-\t\t  AS2 (sbiw,r26,%o0+1));\n+          return (AS2 (adiw,r26,%o0+1) CR_TAB\n+                  AS2 (st,X,%B1)       CR_TAB\n+                  AS2 (st,-X,%A1)      CR_TAB\n+                  AS2 (sbiw,r26,%o0));\n \t}\n-      return *l=2, (AS2 (std,%A0,%A1)    CR_TAB\n-\t\t    AS2 (std,%B0,%B1));\n+      return *l=2, (AS2 (std,%B0,%B1)    CR_TAB\n+                    AS2 (std,%A0,%A1));\n     }\n   else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     return *l=2, (AS2 (st,%0,%B1) CR_TAB\n \t\t  AS2 (st,%0,%A1));\n   else if (GET_CODE (base) == POST_INC) /* (R++) */\n-    return *l=2, (AS2 (st,%0,%A1)  CR_TAB\n-\t\t  AS2 (st,%0,%B1));\n+    {\n+      if (mem_volatile_p)\n+        {\n+          if (REGNO (XEXP (base, 0)) == REG_X)\n+            {\n+              *l = 4;\n+              return (AS2 (adiw,r26,1)  CR_TAB\n+                      AS2 (st,X,%B1)    CR_TAB\n+                      AS2 (st,-X,%A1)   CR_TAB\n+                      AS2 (adiw,r26,2));\n+            }\n+          else\n+            {\n+              *l = 3;\n+              return (AS2 (std,%p0+1,%B1) CR_TAB\n+                      AS2 (st,%p0,%A1)    CR_TAB\n+                      AS2 (adiw,%r0,2));\n+            }\n+        }\n+\n+      *l = 2;\n+      return (AS2 (st,%0,%A1)  CR_TAB\n+            AS2 (st,%0,%B1));\n+    }\n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n }"}, {"sha": "458b1db36f9c02aa2adcdb350d0961fc791a29e9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a69901850b00e526125cb0500ea08d207dfbce03/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=a69901850b00e526125cb0500ea08d207dfbce03", "patch": "@@ -30,6 +30,8 @@\n ;;  j  Branch condition.\n ;;  k  Reverse branch condition.\n ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n+;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)\n+;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)\n ;;  ~  Output 'r' if not AVR_MEGA.\n \n ;; UNSPEC usage:"}]}