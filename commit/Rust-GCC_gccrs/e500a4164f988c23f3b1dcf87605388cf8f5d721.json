{"sha": "e500a4164f988c23f3b1dcf87605388cf8f5d721", "node_id": "C_kwDOANBUbNoAKGU1MDBhNDE2NGY5ODhjMjNmM2IxZGNmODc2MDUzODhjZjhmNWQ3MjE", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-28T12:19:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-28T12:19:54Z"}, "message": "Refactor trait resolution code into cc file from header", "tree": {"sha": "ccc3867821df55dec28b033bede7499a599f3eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccc3867821df55dec28b033bede7499a599f3eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e500a4164f988c23f3b1dcf87605388cf8f5d721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e500a4164f988c23f3b1dcf87605388cf8f5d721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e500a4164f988c23f3b1dcf87605388cf8f5d721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e500a4164f988c23f3b1dcf87605388cf8f5d721/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be158fc97f7f4d43d60797f2af27c86753b0ffb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be158fc97f7f4d43d60797f2af27c86753b0ffb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be158fc97f7f4d43d60797f2af27c86753b0ffb5"}], "stats": {"total": 376, "additions": 197, "deletions": 179}, "files": [{"sha": "823cb76a02d7df5db0f280fab91b956edad8a1ee", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e500a4164f988c23f3b1dcf87605388cf8f5d721/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e500a4164f988c23f3b1dcf87605388cf8f5d721/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=e500a4164f988c23f3b1dcf87605388cf8f5d721", "patch": "@@ -61,8 +61,199 @@ ResolveTraitItemToRef::visit (HIR::TraitItemFunc &fn)\n \t\t\t\t self, std::move (substitutions), locus);\n }\n \n+ResolveTraitItemToRef::ResolveTraitItemToRef (\n+  TyTy::BaseType *self,\n+  std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n+  : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n+    substitutions (std::move (substitutions))\n+{}\n+\n // TraitItemReference items\n \n+TraitReference *\n+TraitResolver::Resolve (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.go (path);\n+}\n+\n+TraitReference *\n+TraitResolver::Lookup (HIR::TypePath &path)\n+{\n+  TraitResolver resolver;\n+  return resolver.lookup_path (path);\n+}\n+\n+TraitResolver::TraitResolver () : TypeCheckBase () {}\n+\n+TraitReference *\n+TraitResolver::go (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t     &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item\n+    = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (trait_reference != nullptr);\n+\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\ttrait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+\n+  TyTy::BaseType *self = nullptr;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+  for (auto &generic_param : trait_reference->get_generic_params ())\n+    {\n+      switch (generic_param.get ()->get_kind ())\n+\t{\n+\tcase HIR::GenericParam::GenericKind::LIFETIME:\n+\t  // Skipping Lifetime completely until better handling.\n+\t  break;\n+\n+\t  case HIR::GenericParam::GenericKind::TYPE: {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n+\t    substitutions.push_back (\n+\t      TyTy::SubstitutionParamMapping (typaram, param_type));\n+\n+\t    if (typaram.get_type_representation ().compare (\"Self\") == 0)\n+\t      {\n+\t\tself = param_type;\n+\t      }\n+\t  }\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self != nullptr);\n+\n+  // Check if there is a super-trait, and apply this bound to the Self\n+  // TypeParam\n+  std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+\n+  // copy the substitition mappings\n+  std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n+  for (auto &sub : substitutions)\n+    self_subst_copy.push_back (sub.clone ());\n+\n+  // They also inherit themselves as a bound this enables a trait item to\n+  // reference other Self::trait_items\n+  auto self_hrtb\n+    = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\tstd::move (self_subst_copy),\n+\t\t\t\ttrait_reference->get_locus ());\n+  specified_bounds.push_back (self_hrtb);\n+\n+  // look for any\n+  std::vector<const TraitReference *> super_traits;\n+  if (trait_reference->has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait_reference->get_type_param_bounds ())\n+\t{\n+\t  if (bound->get_bound_type ()\n+\t      == HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\t    {\n+\t      HIR::TraitBound *b\n+\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t      // FIXME this might be recursive we need a check for that\n+\t      auto predicate = get_predicate_from_bound (b->get_path ());\n+\t      specified_bounds.push_back (predicate);\n+\t      super_traits.push_back (predicate.get ());\n+\t    }\n+\t}\n+    }\n+  self->inherit_bounds (specified_bounds);\n+\n+  std::vector<TraitItemReference> item_refs;\n+  for (auto &item : trait_reference->get_trait_items ())\n+    {\n+      // make a copy of the substs\n+      std::vector<TyTy::SubstitutionParamMapping> item_subst;\n+      for (auto &sub : substitutions)\n+\titem_subst.push_back (sub.clone ());\n+\n+      TraitItemReference trait_item_ref\n+\t= ResolveTraitItemToRef::Resolve (*item.get (), self,\n+\t\t\t\t\t  std::move (item_subst));\n+      item_refs.push_back (std::move (trait_item_ref));\n+    }\n+\n+  TraitReference trait_object (trait_reference, item_refs,\n+\t\t\t       std::move (super_traits),\n+\t\t\t       std::move (substitutions));\n+  context->insert_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n+\n+  tref = &TraitReference::error_node ();\n+  bool ok = context->lookup_trait_reference (\n+    trait_reference->get_mappings ().get_defid (), &tref);\n+  rust_assert (ok);\n+\n+  // hook to allow the trait to resolve its optional item blocks, we cant\n+  // resolve the blocks of functions etc because it can end up in a recursive\n+  // loop of trying to resolve traits as required by the types\n+  tref->on_resolved ();\n+\n+  return tref;\n+}\n+\n+TraitReference *\n+TraitResolver::lookup_path (HIR::TypePath &path)\n+{\n+  NodeId ref;\n+  if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t       &ref))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HirId hir_node = UNKNOWN_HIRID;\n+  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t     &hir_node))\n+    {\n+      rust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n+      return &TraitReference::error_node ();\n+    }\n+\n+  HIR::Item *resolved_item\n+    = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+  rust_assert (resolved_item != nullptr);\n+  resolved_item->accept_vis (*this);\n+  rust_assert (trait_reference != nullptr);\n+\n+  TraitReference *tref = &TraitReference::error_node ();\n+  if (context->lookup_trait_reference (\n+\ttrait_reference->get_mappings ().get_defid (), &tref))\n+    {\n+      return tref;\n+    }\n+  return &TraitReference::error_node ();\n+}\n+\n void\n TraitItemReference::on_resolved ()\n {"}, {"sha": "91e94ccab243502e605bd17d580426a72676f0aa", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 6, "deletions": 179, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e500a4164f988c23f3b1dcf87605388cf8f5d721/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e500a4164f988c23f3b1dcf87605388cf8f5d721/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=e500a4164f988c23f3b1dcf87605388cf8f5d721", "patch": "@@ -52,10 +52,7 @@ class ResolveTraitItemToRef : public TypeCheckBase\n private:\n   ResolveTraitItemToRef (\n     TyTy::BaseType *self,\n-    std::vector<TyTy::SubstitutionParamMapping> &&substitutions)\n-    : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n-      substitutions (std::move (substitutions))\n-  {}\n+    std::vector<TyTy::SubstitutionParamMapping> &&substitutions);\n \n   TraitItemReference resolved;\n   TyTy::BaseType *self;\n@@ -67,186 +64,16 @@ class TraitResolver : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TraitReference *Resolve (HIR::TypePath &path)\n-  {\n-    TraitResolver resolver;\n-    return resolver.go (path);\n-  }\n+  static TraitReference *Resolve (HIR::TypePath &path);\n \n-  static TraitReference *Lookup (HIR::TypePath &path)\n-  {\n-    TraitResolver resolver;\n-    return resolver.lookup_path (path);\n-  }\n+  static TraitReference *Lookup (HIR::TypePath &path);\n \n private:\n-  TraitResolver () : TypeCheckBase () {}\n-\n-  TraitReference *go (HIR::TypePath &path)\n-  {\n-    NodeId ref;\n-    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &ref))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HirId hir_node = UNKNOWN_HIRID;\n-    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n-\t\t\t\t       &hir_node))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HIR::Item *resolved_item\n-      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n-\n-    rust_assert (resolved_item != nullptr);\n-    resolved_item->accept_vis (*this);\n-    rust_assert (trait_reference != nullptr);\n-\n-    TraitReference *tref = &TraitReference::error_node ();\n-    if (context->lookup_trait_reference (\n-\t  trait_reference->get_mappings ().get_defid (), &tref))\n-      {\n-\treturn tref;\n-      }\n-\n-    TyTy::BaseType *self = nullptr;\n-    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-    for (auto &generic_param : trait_reference->get_generic_params ())\n-      {\n-\tswitch (generic_param.get ()->get_kind ())\n-\t  {\n-\t  case HIR::GenericParam::GenericKind::LIFETIME:\n-\t    // Skipping Lifetime completely until better handling.\n-\t    break;\n-\n-\t    case HIR::GenericParam::GenericKind::TYPE: {\n-\t      auto param_type\n-\t\t= TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t      context->insert_type (generic_param->get_mappings (), param_type);\n-\n-\t      auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n-\t      substitutions.push_back (\n-\t\tTyTy::SubstitutionParamMapping (typaram, param_type));\n-\n-\t      if (typaram.get_type_representation ().compare (\"Self\") == 0)\n-\t\t{\n-\t\t  self = param_type;\n-\t\t}\n-\t    }\n-\t    break;\n-\t  }\n-      }\n-    rust_assert (self != nullptr);\n-\n-    // Check if there is a super-trait, and apply this bound to the Self\n-    // TypeParam\n-    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n-\n-    // copy the substitition mappings\n-    std::vector<TyTy::SubstitutionParamMapping> self_subst_copy;\n-    for (auto &sub : substitutions)\n-      self_subst_copy.push_back (sub.clone ());\n+  TraitResolver ();\n \n-    // They also inherit themselves as a bound this enables a trait item to\n-    // reference other Self::trait_items\n-    auto self_hrtb\n-      = TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n-\t\t\t\t  std::move (self_subst_copy),\n-\t\t\t\t  trait_reference->get_locus ());\n-    specified_bounds.push_back (self_hrtb);\n+  TraitReference *go (HIR::TypePath &path);\n \n-    // look for any\n-    std::vector<const TraitReference *> super_traits;\n-    if (trait_reference->has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : trait_reference->get_type_param_bounds ())\n-\t  {\n-\t    if (bound->get_bound_type ()\n-\t\t== HIR::TypeParamBound::BoundType::TRAITBOUND)\n-\t      {\n-\t\tHIR::TraitBound *b\n-\t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n-\n-\t\t// FIXME this might be recursive we need a check for that\n-\t\tauto predicate = get_predicate_from_bound (b->get_path ());\n-\t\tspecified_bounds.push_back (predicate);\n-\t\tsuper_traits.push_back (predicate.get ());\n-\t      }\n-\t  }\n-      }\n-    self->inherit_bounds (specified_bounds);\n-\n-    std::vector<TraitItemReference> item_refs;\n-    for (auto &item : trait_reference->get_trait_items ())\n-      {\n-\t// make a copy of the substs\n-\tstd::vector<TyTy::SubstitutionParamMapping> item_subst;\n-\tfor (auto &sub : substitutions)\n-\t  item_subst.push_back (sub.clone ());\n-\n-\tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get (), self,\n-\t\t\t\t\t    std::move (item_subst));\n-\titem_refs.push_back (std::move (trait_item_ref));\n-      }\n-\n-    TraitReference trait_object (trait_reference, item_refs,\n-\t\t\t\t std::move (super_traits),\n-\t\t\t\t std::move (substitutions));\n-    context->insert_trait_reference (\n-      trait_reference->get_mappings ().get_defid (), std::move (trait_object));\n-\n-    tref = &TraitReference::error_node ();\n-    bool ok = context->lookup_trait_reference (\n-      trait_reference->get_mappings ().get_defid (), &tref);\n-    rust_assert (ok);\n-\n-    // hook to allow the trait to resolve its optional item blocks, we cant\n-    // resolve the blocks of functions etc because it can end up in a recursive\n-    // loop of trying to resolve traits as required by the types\n-    tref->on_resolved ();\n-\n-    return tref;\n-  }\n-\n-  TraitReference *lookup_path (HIR::TypePath &path)\n-  {\n-    NodeId ref;\n-    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n-\t\t\t\t\t &ref))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to node-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HirId hir_node = UNKNOWN_HIRID;\n-    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n-\t\t\t\t       &hir_node))\n-      {\n-\trust_error_at (path.get_locus (), \"Failed to resolve path to hir-id\");\n-\treturn &TraitReference::error_node ();\n-      }\n-\n-    HIR::Item *resolved_item\n-      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n-\n-    rust_assert (resolved_item != nullptr);\n-    resolved_item->accept_vis (*this);\n-    rust_assert (trait_reference != nullptr);\n-\n-    TraitReference *tref = &TraitReference::error_node ();\n-    if (context->lookup_trait_reference (\n-\t  trait_reference->get_mappings ().get_defid (), &tref))\n-      {\n-\treturn tref;\n-      }\n-    return &TraitReference::error_node ();\n-  }\n+  TraitReference *lookup_path (HIR::TypePath &path);\n \n   HIR::Trait *trait_reference;\n "}]}