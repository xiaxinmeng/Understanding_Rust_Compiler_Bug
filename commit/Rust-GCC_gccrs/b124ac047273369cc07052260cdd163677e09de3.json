{"sha": "b124ac047273369cc07052260cdd163677e09de3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEyNGFjMDQ3MjczMzY5Y2MwNzA1MjI2MGNkZDE2MzY3N2UwOWRlMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-18T13:39:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-18T13:39:29Z"}, "message": "Initial revision\n\nFrom-SVN: r214", "tree": {"sha": "596116dd0ea01decf4a46ef63457e0d61191aa6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/596116dd0ea01decf4a46ef63457e0d61191aa6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b124ac047273369cc07052260cdd163677e09de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b124ac047273369cc07052260cdd163677e09de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b124ac047273369cc07052260cdd163677e09de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b124ac047273369cc07052260cdd163677e09de3/comments", "author": null, "committer": null, "parents": [{"sha": "ee1456320273bf7761b81c4daa2c6acc3187d446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee1456320273bf7761b81c4daa2c6acc3187d446", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee1456320273bf7761b81c4daa2c6acc3187d446"}], "stats": {"total": 4323, "additions": 4323, "deletions": 0}, "files": [{"sha": "6904cc5e400da0c2ecfa059c71c5f003eb325cbf", "filename": "gcc/config/romp/romp.h", "status": "added", "additions": 1595, "deletions": 0, "changes": 1595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b124ac047273369cc07052260cdd163677e09de3/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b124ac047273369cc07052260cdd163677e09de3/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=b124ac047273369cc07052260cdd163677e09de3", "patch": "@@ -0,0 +1,1595 @@\n+/* Definitions of target machine for GNU compiler, for ROMP chip.\n+   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dibm032 -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION ;\n+\n+/* Add -lfp_p when running with -p or -pg.  */\n+#define LIB_SPEC \"%{pg:-lfp_p}%{p:-lfp_p} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+/* Flag to generate all multiplies as an in-line sequence of multiply-step\n+   insns instead of calling a library routine.  */\n+#define TARGET_IN_LINE_MUL (target_flags & 1)\n+\n+/* Flag to generate padded floating-point data blocks.  Otherwise, we generate\n+   them the minimum size.  This trades off execution speed against size.  */\n+#define TARGET_FULL_FP_BLOCKS (target_flags & 2)\n+\n+/* Flag to pass and return floating point values in floating point registers.\n+   Since this violates the linkage convention, we feel free to destroy fr2\n+   and fr3 on function calls.\n+   fr1-fr3 are used to pass the arguments. */\n+#define TARGET_FP_REGS (target_flags & 4)\n+\n+/* Flag to return structures of more than one word in memory.  This is for\n+   compatibility with the MetaWare HighC (hc) compiler.  */\n+#define TARGET_HC_STRUCT_RETURN (target_flags & 010)\n+\n+extern int target_flags;\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES\t\t\\\n+  { {\"in-line-mul\", 1},\t\t\\\n+    {\"call-lib-mul\", -1},\t\\\n+    {\"full-fp-blocks\", 2},\t\\\n+    {\"minimum-fp-blocks\", -2},\t\\\n+    {\"fp-arg-in-fpregs\", 4},\t\\\n+    {\"fp-arg-in-gregs\", -4},\t\\\n+    {\"hc-struct-return\", 010},  \\\n+    {\"nohc-struct-return\", - 010}, \\\n+    { \"\", TARGET_DEFAULT}}\n+\n+#define TARGET_DEFAULT 3\n+\n+/* Define this to change the optimizations peformed by default.  */\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL) \n+\n+/* Define this to modify the options specified by the user.\n+\n+   On the ROMP, we turn on various flags if optimization is selected.\n+   More get turned on if debugging is off.  */\n+\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (optimize)\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      flag_force_addr = 1;\t\t\\\n+      flag_force_mem = 1;\t\t\\\n+      if (write_symbols == NO_DEBUG)\t\\\n+\tflag_omit_frame_pointer = 1;\t\\\n+    }\t\t\t\t\t\\\n+}\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+/* That is true on ROMP. */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on ROMP.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered. \n+\n+   For ROMP we can decide arbitrarily since there are no machine instructions\n+   for them.  Might as well be consistent with bits and bytes. */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   ROMP has 16 fullword registers and 8 floating point registers.\n+\n+   In addition, the difference between the frame and argument pointers is\n+   a function of the number of registers saved, so we need to have a register\n+   to use for AP that will later be eliminated in favor of sp or fp.  This is\n+   a normal register, but it is fixed.  */\n+\n+#define FIRST_PSEUDO_REGISTER 25\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On ROMP, r1 is used for the stack and r14 is used for a\n+   data area pointer.\n+\n+   HACK WARNING:  On the RT, there is a bug in code generation for\n+   the MC68881 when the first and third operands are the same floating-point\n+   register.  See the definition of the FINAL_PRESCAN_INSN macro for details.\n+   Here we need to reserve fr0 for this purpose.  */\n+#define FIXED_REGISTERS  \\\n+ {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1,\t\t\t\t\t\t\t\\\n+  1, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS\t\t\t\t\\\n+ {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1,\t\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0}\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+\tfr0, fr1\t(not saved)\n+\tfr2 ... fr6\n+\tfr7\t\t(more expensive for some FPA's)\n+\tr0\t\t(not saved and won't conflict with parameter register)\n+\tr4, r3, r2\t(not saved, highest used first to make less conflict)\n+\tr5\t\t(not saved, but forces r6 to be saved if DI/DFmode)\n+\tr15, r14, r13, r12, r11, r10, r9, r8, r7, r6 (less to save)\n+\tr1, ap \t\t\t*/\n+\n+#define REG_ALLOC_ORDER\t\t\\\n+  {17, 18,\t\t\t\\\n+   19, 20, 21, 22, 23,\t\t\\\n+   24,\t\t\t\t\\\n+   0,\t\t\t\t\\\n+   4, 3, 2,\t\t\t\\\n+   5,\t\t\t\t\\\n+   15, 14, 13, 12, 11, 10,\t\\\n+   9, 8, 7, 6, \t\t\t\\\n+   1, 16}\n+\n+/* True if register is floating-point.  */\n+#define FP_REGNO_P(N) ((N) >= 17)\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On ROMP, ordinary registers hold 32 bits worth;\n+   a single floating point register is always enough for\n+   anything that can be stored in them at all.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (FP_REGNO_P (REGNO) ? GET_MODE_NUNITS (MODE)\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On ROMP, the cpu registers can hold any mode but the float registers\n+   can hold only floating point. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  (! FP_REGNO_P (REGNO) || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+/* A C expression returning the cost of moving data from a register of class\n+   CLASS1 to one of CLASS2.\n+\n+   On the ROMP, access to floating-point registers is expensive (even between\n+   two FP regs.)  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\\\n+  (2 + 10 * ((CLASS1) == FP_REGS) + 10 * (CLASS2 == FP_REGS))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* ROMP pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 1\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 13\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 16\n+\n+/* Place to put static chain when calling a function that requires it.  */\n+#define STATIC_CHAIN\t\t\t\t\t\t\t\\\n+  gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, stack_pointer_rtx,\t\t\\\n+\t\t\t\tgen_rtx (CONST_INT, VOIDmode, -36)))\n+\n+/* Place where static chain is found upon entry to routine.  */\n+#define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n+  gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, arg_pointer_rtx,\t\t\\\n+\t\t\t\tgen_rtx (CONST_INT, VOIDmode, -20)))\n+\n+/* Place that structure value return address is placed.\n+\n+   On the ROMP, it is passed as an extra parameter.  */\n+#define STRUCT_VALUE\t0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The ROMP has two types of registers, general and floating-point.\n+\n+   However, r0 is special in that it cannot be used as a base register.\n+   So make a class for registers valid as base registers.\n+\n+   For floating-point support, add classes that just consist of r0 and\n+   r15, respectively.  */\n+\n+enum reg_class { NO_REGS, R0_REGS, R15_REGS, BASE_REGS, GENERAL_REGS,\n+\t\t FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"R0_REGS\", \"R15_REGS\", \"BASE_REGS\", \"GENERAL_REGS\", \\\n+  \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x00001, 0x08000, 0x1fffe, 0x1ffff,  \\\n+\t\t\t    0x1fe0000, 0x1ffffff }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+ ((REGNO) == 0 ? GENERAL_REGS : FP_REGNO_P (REGNO) ? FP_REGS : BASE_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS BASE_REGS\n+#define BASE_REG_CLASS BASE_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS\t\t\\\n+   : (C) == 'b' ? BASE_REGS\t\\\n+   : (C) == 'z' ? R0_REGS\t\\\n+   : (C) == 't' ? R15_REGS\t\\\n+   : NO_REGS)\n+\n+/* The letters I, J, K, L, M, N, and P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   `I' is constants less than 16\n+   `J' is negative constants greater than -16\n+   `K' is the range for a normal D insn.\n+   `L' is a constant with only the low-order 16 bits set\n+   `M' is a constant with only the high-order 16 bits set\n+   `N' is a single-bit constant\n+   `O' is a constant with either the high-order or low-order 16 bits all ones\n+   `P' is the complement of a single-bit constant\n+  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t   \\\n+   ( (C) == 'I' ? (unsigned) (VALUE) < 0x10\t\t   \\\n+   : (C) == 'J' ? (VALUE) < 0 && (VALUE) > -16\t\t   \\\n+   : (C) == 'K' ? (unsigned) ((VALUE) + 0x8000) < 0x10000  \\\n+   : (C) == 'L' ? ((VALUE) & 0xffff0000) == 0\t\t   \\\n+   : (C) == 'M' ? ((VALUE) & 0xffff) == 0\t\t   \\\n+   : (C) == 'N' ? exact_log2 (VALUE) >= 0\t\t   \\\n+   : (C) == 'O' ? ((VALUE) & 0xffff) == 0xffff\t\t   \\\n+\t\t  || ((VALUE) & 0xffff0000) == 0xffff0000  \\\n+   : (C) == 'P' ? exact_log2 (~ (VALUE)) >= 0\t\t   \\\n+   : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.\n+   No floating-point constants on ROMP.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n+\n+/* Optional extra constraints for this machine.\n+\n+   For the ROMP, `Q' means that this is a memory operand but not a symbolic\n+   memory operand.  Note that an unassigned pseudo register is such a\n+   memory operand.  If register allocation has not been done, we reject\n+   pseudos, since we assume (hope) that they will get hard registers.\n+\n+   `R' means that this is a constant pool reference to the current function.\n+   This is just r14 and so can be treated as a register.  We bother with this\n+   just in move insns as that is the only place it is likely to occur.\n+\n+   `S' means that this is the address of a constant pool location.  This is\n+   equal to r14 plus a constant.  We also only check for this in move insns. */\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ?\t\t\t\t\t\t\\\n+   ((GET_CODE (OP) == REG\t\t\t\t\\\n+     && REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n+     && reg_renumber != 0\t\t\t\t\\\n+     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n+    || (memory_operand (OP, VOIDmode)\t\t\t\\\n+        && ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n+   : (C) == 'R' ? current_function_operand (OP, VOIDmode) \\\n+   : (C) == 'S' ? constant_pool_address_operand (OP, VOIDmode) \\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+\n+   For the ROMP, if X is a memory reference that involves a symbol,\n+   we must use a BASE_REGS register instead of GENERAL_REGS\n+   to do the reload. The argument of MEM be either REG, PLUS, or SYMBOL_REF\n+   to be valid, so we assume that this is the case.\n+\n+   Also, if X is an integer class, ensure that floating-point registers\n+   aren't used.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n+  ((CLASS) == FP_REGS && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\\\n+   ? GENERAL_REGS :\t\t\t\t\t\t\t\\\n+   (CLASS) != GENERAL_REGS ? (CLASS) :\t\t\t\t\t\\\n+   GET_CODE (X) != MEM ? GENERAL_REGS :\t\t\t\t\t\\\n+   GET_CODE (XEXP (X, 0)) == SYMBOL_REF ? BASE_REGS :\t\t\t\\\n+   GET_CODE (XEXP (X, 0)) == LABEL_REF ? BASE_REGS :\t\t\t\\\n+   GET_CODE (XEXP (X, 0)) == CONST ? BASE_REGS :\t\t\t\\\n+   GET_CODE (XEXP (X, 0)) == REG ? GENERAL_REGS :\t\t\t\\\n+   GET_CODE (XEXP (X, 0)) != PLUS ? GENERAL_REGS :\t\t\t\\\n+   GET_CODE (XEXP (XEXP (X, 0), 1)) == SYMBOL_REF ? BASE_REGS :\t\t\\\n+   GET_CODE (XEXP (XEXP (X, 0), 1)) == LABEL_REF ? BASE_REGS :\t\t\\\n+   GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST ? BASE_REGS : GENERAL_REGS)\n+\n+/* Return the register class of a scratch register needed to store into\n+   OUT from a register of class CLASS in MODE.  \n+\n+   On the ROMP, we cannot store into a symbolic memory address from an\n+   integer register; we need a BASE_REGS register as a scratch to do it.  */\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT) \\\n+  (GET_MODE_CLASS (MODE) == MODE_INT && symbolic_memory_operand (OUT, MODE) \\\n+   ? BASE_REGS : NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.\n+\n+   On ROMP, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FP_REGS ? 1\t\t\t\\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.\n+   On the ROMP, if we set the frame pointer to 15 words below the highest\n+   address of the highest local variable, the first 16 words will be\n+   addressable via D-short insns. */\n+#define STARTING_FRAME_OFFSET 64\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On ROMP, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.\n+   On the ROMP, we define the argument pointer to the start of the argument\n+   area.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register.  The value is the number of bytes.  */\n+#define REG_PARM_STACK_SPACE(FNDECL) 16\n+\n+/* This is the difference between the logical top of stack and the actual sp.\n+\n+   For the ROMP, sp points past the words allocated for the first four outgoing\n+   arguments (they are part of the callee's frame).  */\n+#define STACK_POINTER_OFFSET -16\n+\n+/* Define this if the maximum size of all the outgoing args is to be\n+   accumulated and pushed during the prologue.  The amount can be\n+   found in the variable current_function_outgoing_args_size.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.\n+\n+   On ROMP the value is found in r2, unless the machine specific option\n+   fp-arg-in-fpregs is selected, in which case FP return values are in fr1 */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE),\t\\\n+\t   (TARGET_FP_REGS &&\t\t\\\n+\t    GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT) ? 18 : 2)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 2)\n+\n+/* The definition of this macro implies that there are cases where\n+   a scalar value cannot be returned in registers.\n+\n+   For the ROMP, if compatibility with HC is required, anything of\n+   type DImode is returned in memory.  */\n+\n+#define RETURN_IN_MEMORY(type) \\\n+  (TARGET_HC_STRUCT_RETURN && TYPE_MODE (type) == DImode)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+\n+   On ROMP, r2 is the only register thus used unless fp values are to be\n+   returned in fp regs, in which case fr1 is also used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 2 || ((N) == 18 && TARGET_FP_REGS))\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On ROMP, these are r2-r5 (and fr1-fr4 if fp regs are used).  */\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\\\n+  (((N) <= 5 && (N) >= 2) || (TARGET_FP_REGS && (N) > 17 && (N) < 21))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the ROMP, this is a structure.  The first word is the number of\n+   words of (integer only if -mfp-arg-in-fpregs is specified) arguments\n+   scanned so far (including the invisible argument, if any, which holds\n+   the structure-value-address).  The second word hold the corresponding\n+   value for floating-point arguments, except that both single and double\n+   count as one register.  */\n+\n+struct rt_cargs {int gregs, fregs; };\n+#define CUMULATIVE_ARGS struct rt_cargs \n+\n+#define USE_FP_REG(MODE,CUM)\t\t\t\t\t\\\n+  (TARGET_FP_REGS && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+   && (CUM).fregs < 3)\n+\n+/* Define intermediate macro to compute the size (in registers) of an argument\n+   for the ROMP.  */\n+\n+#define ROMP_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n+(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n+ : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n+ ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n+ : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On ROMP, the offset normally starts at 0, but starts at 4 bytes\n+   when the function gets a structure-value-address as an\n+   invisible first argument.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+  (CUM).gregs = 0,\t\t\t\t\\\n+  (CUM).fregs = 0\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+{ if (NAMED)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (USE_FP_REG(MODE, CUM))\t\t\t\\\n+\t(CUM).fregs++;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t(CUM).gregs += ROMP_ARG_SIZE (MODE, TYPE, NAMED); \\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On ROMP the first four words of args are normally in registers\n+   and the rest are pushed.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n+  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n+  : USE_FP_REG(MODE,CUM) ? gen_rtx(REG, (MODE),(CUM.fregs) + 17)\t\\\n+  : (CUM).gregs < 4 ? gen_rtx(REG, (MODE), 2 + (CUM).gregs) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n+   : USE_FP_REG(MODE,CUM) ? 0\t\t\t\t\t\t\\\n+   : (((CUM).gregs < 4\t\t\t\t\t\t\t\\\n+       && 4 < ((CUM).gregs + ROMP_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n+      ? 4 - (CUM).gregs : 0))\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n+\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if (TARGET_FP_REGS)\t\t\t\t\t\t\t\\\n+    error (\"can't have varargs with -mfp-arg-in-fp-regs\");\t\t\\\n+  else if ((CUM).gregs < 4)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int first_reg_offset = (CUM).gregs;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n+\tfirst_reg_offset += ROMP_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (first_reg_offset > 4)\t\t\t\t\t\t\\\n+\tfirst_reg_offset = 4;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (! NO_RTL && first_reg_offset != 4)\t\t\t\t\\\n+\tmove_block_from_reg\t\t\t\t\t\t\\\n+\t  (2 + first_reg_offset,\t\t\t\t\t\\\n+\t   gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t    plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t   first_reg_offset * 4)), \t\t\\\n+\t   4 - first_reg_offset);\t\t\t\t\t\\\n+      PRETEND_SIZE = (4 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This macro produces the initial definition of a function name.\n+   On the ROMP, we need to place an extra '.' in the function name.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n+{ if (TREE_PUBLIC(DECL))\t\t\t\t\\\n+    fprintf (FILE, \"\\t.globl _.%s\\n\", NAME);\t\t\\\n+  fprintf (FILE, \"_.%s:\\n\", NAME);\t\t\t\\\n+}\n+\n+/* This macro is used to output the start of the data area.\n+\n+   On the ROMP, the _name is a pointer to the data area.  At that\n+   location is the address of _.name, which is really the name of\n+   the function.  We need to set all this up here.\n+\n+   The global declaration of the data area, if needed, is done in \n+   `assemble_function', where it thinks it is globalizing the function\n+   itself.  */\n+\n+#define ASM_OUTPUT_POOL_PROLOGUE(FILE, NAME, DECL, SIZE)\t\\\n+{ extern int data_offset;\t\t\t\t\t\\\n+  data_section ();\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.align 2\\n\");\t\t\t\t\\\n+  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long _.%s, 0, \", NAME);\t\t\t\\\n+  if (current_function_calls_alloca)\t\t\t\t\\\n+    fprintf (FILE, \"0x%x\\n\",\t\t\t\t\t\\\n+\t     0xf6900000 + current_function_outgoing_args_size); \\\n+  else\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"0\\n\");\t\t\t\t\t\\\n+  data_offset = ((SIZE) + 12 + 3) / 4;\t\t\t\t\\\n+}\n+\n+/* Select section for constant in constant pool.\n+\n+   On ROMP, all constants are in the data area.  */\n+\n+#define SELECT_RTX_SECTION(MODE, X)\tdata_section ()\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) output_prolog (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+  fprintf(FILE, \"\\tcas r0,r15,r0\\n\\tbali r15,mcount\\n\");\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+/* #define EXIT_IGNORE_STACK\t1\t*/\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.\n+\n+   On the ROMP, we have a problem.  There are no free registers to use\n+   to construct the static chain and function addresses.  Hence we use\n+   the following kludge:  r15 (the return address) is first saved in mq.\n+   Then we use r15 to form the function address.  We then branch to the\n+   function and restore r15 in the delay slot.  This makes it appear that\n+   the function was called directly from the caller.\n+\n+   (Note that the function address built is actually that of the data block.\n+   This is passed in r0 and the actual routine address is loaded into r15.)\n+\n+   In addition, note that the address of the \"called function\", in this case\n+   the trampoline, is actually the address of the data area.  So we need to\n+   make a fake data area that will contain the address of the trampoline.\n+   Note that this must be defined as two half-words, since the trampoline\n+   template (as opposed to the trampoline on the stack) is only half-word\n+   aligned.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\\\n+{\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.short 0,0\\n\");\t\\\n+  fprintf (FILE, \"\\tcau r0,0(r0)\\n\");\t\\\n+  fprintf (FILE, \"\\toil r0,r0,0\\n\");\t\\\n+  fprintf (FILE, \"\\tmts r10,r15\\n\");\t\\\n+  fprintf (FILE, \"\\tst r0,-36(r1)\\n\");\t\\\n+  fprintf (FILE, \"\\tcau r15,0(r0)\\n\");\t\\\n+  fprintf (FILE, \"\\toil r15,r15,0\\n\");\t\\\n+  fprintf (FILE, \"\\tcas r0,r15,r0\\n\");\t\\\n+  fprintf (FILE, \"\\tls r15,0(r15)\\n\");\t\\\n+  fprintf (FILE, \"\\tbrx r15\\n\");\t\\\n+  fprintf (FILE, \"\\tmfs r10,r15\\n\");\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE    36\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   On the RT, the static chain and function addresses are written in\n+   two 16-bit sections.\n+\n+   We also need to write the address of the first instruction in\n+   the trampoline into the first word of the trampoline to simulate a\n+   data area.  */\n+\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  rtx _addr, _temp;\t\t\t\t\t\t\\\n+  rtx _val;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  _temp = expand_binop (SImode, add_optab, ADDR,\t\t\\\n+\t\t\tgen_rtx (CONST_INT, VOIDmode, 4),\t\\\n+\t\t\t0, 1, OPTAB_LIB_WIDEN);\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\t\\\n+\t\t\t   memory_address (SImode, ADDR)), _temp); \\\n+\t\t\t\t\t\t\t\t\\\n+  _val = force_reg (SImode, CXT);\t\t\t\t\\\n+  _addr = memory_address (HImode, plus_constant (ADDR, 10));\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+\t\t  gen_lowpart (HImode, _val));\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\\\n+\t\t\tbuild_int_2 (16, 0), 0, 1);\t\t\\\n+  _addr = memory_address (HImode, plus_constant (ADDR, 6));\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+\t\t  gen_lowpart (HImode, _temp));\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  _val = force_reg (SImode, FNADDR);\t\t\t\t\\\n+  _addr = memory_address (HImode, plus_constant (ADDR, 24));\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+\t\t  gen_lowpart (HImode, _val));\t\t\t\\\n+  _temp = expand_shift (RSHIFT_EXPR, SImode, _val,\t\t\\\n+\t\t\tbuild_int_2 (16, 0), 0, 1);\t\t\\\n+  _addr = memory_address (HImode, plus_constant (ADDR, 20));\t\\\n+  emit_move_insn (gen_rtx (MEM, HImode, _addr),\t\t\t\\\n+\t\t  gen_lowpart (HImode, _temp));\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated on the ROMP.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer.\n+\n+   In addition, we use the elimination mechanism to see if r14 is needed.\n+   Initially we assume that it isn't.  If it is, we spill it.  This is done\n+   by making it an eliminable register.  It doesn't matter what we replace\n+   it with, since it will never occur in the rtl at this point.  */\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ { 14, 0}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   For the ROMP, if frame pointer elimination is being done, we would like to\n+   convert ap into fp, not sp.\n+\n+   We need r14 if various conditions (tested in romp_using_r14) are true.\n+\n+   All other eliminations are valid.  */\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : (FROM) == 14 ? ! romp_using_r14 ()\t\t\t\t\\\n+  : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (romp_pushes_stack ())\t\t\t\t\t\t\\\n+\t(OFFSET) = ((get_frame_size () - 64)\t\t\t\t\\\n+\t\t    + current_function_outgoing_args_size);\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(OFFSET) = - (romp_sa_size () + 64);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n+    (OFFSET) = romp_sa_size () - 16 + 64;\t\t\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (romp_pushes_stack ())\t\t\t\t\t\t\\\n+\t(OFFSET) = (get_frame_size () + (romp_sa_size () - 16)\t\t\\\n+\t\t    + current_function_outgoing_args_size);\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t(OFFSET) = -16;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((FROM) == 14)\t\t\t\t\t\t\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+ ? (REGNO) < 16 && (REGNO) != 0 && (REGNO) != 16\t\t\\\n+ : (reg_renumber[REGNO] < 16 && reg_renumber[REGNO] >= 0\t\\\n+    && reg_renumber[REGNO] != 16))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the ROMP, there is a bit of a hack here.  Basically, we wish to\n+   only issue instructions that are not `as' macros.  However, in the\n+   case of `get', `load', and `store', if the operand is a relocatable\n+   symbol (possibly +/- an integer), there is no way to express the\n+   resulting split-relocation except with the macro.  Therefore, allow\n+   either a constant valid in a normal (sign-extended) D-format insn or\n+   a relocatable expression.\n+\n+   Also, for DFmode and DImode, we must ensure that both words are\n+   addressable.\n+\n+   We define two macros: The first is given an offset (0 or 4) and indicates\n+   that the operand is a CONST_INT that is valid for that offset.  The second\n+   indicates a valid non-CONST_INT constant.  */\n+\n+#define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+   && (unsigned) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n+\n+#define LEGITIMATE_ADDRESS_CONSTANT_P(X)\t\t\t\t\\\n+ (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+  || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+      && (GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n+          || GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n+      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT))\n+\n+/* Include all constant integers and constant double, but exclude \n+   SYMBOL_REFs that are to be obtained from the data area (see below).  */\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\\\n+  ((LEGITIMATE_ADDRESS_CONSTANT_P (X)\t\t\\\n+    || GET_CODE (X) == CONST_INT\t\t\\\n+    || GET_CODE (X) == CONST_DOUBLE)\t\t\\\n+   && ! (GET_CODE (X) == SYMBOL_REF && (X)->integrated))\n+\n+/* For no good reason, we do the same as the other RT compilers and load\n+   the addresses of data areas for a function from our data area.  That means\n+   that we need to mark such SYMBOL_REFs.  We do so here.  */\n+#define ENCODE_SEGMENT_INFO(DECL)\t\t\t\\\n+  if (TREE_CODE (TREE_TYPE (DECL)) == FUNCTION_TYPE)\t\\\n+    XEXP (DECL_RTL (DECL), 0)->integrated = 1;\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 0\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)\t\t\\\n+  (REGNO (X) != 0 && (REGNO (X) < 17 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the ROMP, a legitimate address is either a legitimate constant,\n+   a register plus a legitimate constant, or a register.  See the\n+   discussion at the LEGITIMATE_ADDRESS_CONSTANT_P macro.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) != CONST_INT && LEGITIMATE_ADDRESS_CONSTANT_P (X))\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+      && LEGITIMATE_ADDRESS_CONSTANT_P (XEXP (X, 1)))\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\t\t\\\n+      && (((MODE) != DFmode && (MODE) != DImode)\t\t\t\\\n+\t  || (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4))))\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   On ROMP, check for the sum of a register with a constant\n+   integer that is out of range.  If so, generate code to add the\n+   constant with the low-order 16 bits masked to the register and force\n+   this result into another register (this can be done with `cau').\n+   Then generate an address of REG+(CONST&0xffff), allowing for the \n+   possibility of bit 16 being a one.\n+\n+   If the register is not OK for a base register, abort.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n+    && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+    && (unsigned) (INTVAL (XEXP (X, 1)) + 0x8000) >= 0x10000)\t\\\n+    { int high_int, low_int;\t\t\t\t\t\\\n+      if (! REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+\tabort ();\t\t\t\t\t\t\\\n+      high_int = INTVAL (XEXP (X, 1)) >> 16;\t\t\t\\\n+      low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\\\n+      if (low_int & 0x8000)\t\t\t\t\t\\\n+\thigh_int += 1, low_int |= 0xffff0000;\t\t\t\\\n+      (X) = gen_rtx (PLUS, SImode,\t\t\t\t\\\n+\t\t     force_operand\t\t\t\t\\\n+\t\t     \t(gen_rtx (PLUS, SImode, XEXP (X, 0), \\\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, \\\n+\t\t\t\t\t\t      high_int << 16)), 0),\\\n+\t\t     gen_rtx (CONST_INT, VOIDmode, low_int));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+\n+   On the ROMP this is true only if the address is valid with a zero offset\n+   but not with an offset of four (this means it cannot be used as an\n+   address for DImode or DFmode).  Since we know it is valid, we just check\n+   for an address that is not valid with an offset of four.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n+{ if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n+      && ! LEGITIMATE_ADDRESS_CONSTANT_P (XEXP (ADDR, 1))\t\\\n+      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 4))\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Define this if some processing needs to be done immediately before\n+   emitting code for an insn.\n+\n+   This is used on the ROMP, to compensate for a bug in the floating-point\n+   code.  When a floating-point operation is done with the first and third\n+   operands both the same floating-point register, it will generate bad code\n+   for the MC68881.  So we must detect this.  If it occurs, we patch the \n+   first operand to be fr0 and insert a move insn to move it to the desired\n+   destination.  */\n+#define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS)\t\t\t\\\n+  { rtx op0, op1, op2, operation, tem;\t\t\t\t\t\\\n+    if (NOPERANDS >= 3\t&& get_attr_type (INSN) == TYPE_FP)\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\top0 = OPERANDS[0];\t\t\t\t\t\t\\\n+\toperation = OPERANDS[1];\t\t\t\t\t\\\n+\tif (float_conversion (operation, VOIDmode))\t\t\t\\\n+\t  operation = XEXP (operation, 0);\t\t\t\t\\\n+        if (float_binary (operation, VOIDmode))\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    op1 = XEXP (operation, 0), op2 = XEXP (operation, 1);\t\\\n+\t    if (float_conversion (op1, VOIDmode))\t\t\t\\\n+\t      op1 = XEXP (op1, 0);\t\t\t\t\t\\\n+\t    if (float_conversion (op2, VOIDmode))\t\t\t\\\n+\t      op2 = XEXP (op2, 0);\t\t\t\t\t\\\n+\t    if (rtx_equal_p (op0, op2)\t\t\t\t\t\\\n+\t\t&& (GET_CODE (operation) == PLUS\t\t\t\\\n+\t\t    || GET_CODE (operation) == MULT))\t\t\t\\\n+\t      tem = op1, op1 = op2, op2 = tem;\t\t\t\t\\\n+\t    if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0))\t\\\n+\t\t&& GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2))\t\\\n+\t\t&& REGNO (op0) == REGNO (op2))\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\ttem = gen_rtx (REG, GET_MODE (op0), 17);\t\t\\\n+\t\temit_insn_after (gen_move_insn (op0, tem), INSN);\t\\\n+\t\tSET_DEST (XVECEXP (PATTERN (INSN), 0, 0)) = tem; \t\\\n+\t\tOPERANDS[0] = tem;\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.\n+\n+   We actually lie a bit here as overflow conditions are different.  But\n+   they aren't being checked anyway.  */\n+\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Nonzero if access to memory by bytes is no faster than for words.\n+   Also non-zero if doing byte operations (specifically shifts) in registers\n+   is undesirable.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define if normal loads of shorter-than-word items from memory clears\n+   the rest of the bigs in the register.  */\n+#define BYTE_LOADS_ZERO_EXTEND\n+\n+/* This is BSD, so it wants DBX format.  */\n+#define DBX_DEBUGGING_INFO\n+\n+/* We don't have GAS for the RT yet, so don't write out special\n+   .stabs in cc1plus.  */\n+   \n+#define FASCIST_ASSEMBLER\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* Don't try to use the `x' type-cross-reference character in DBX data.\n+   Also has the consequence of putting each struct, union or enum\n+   into a separate .stabs, containing only cross-refs to the others.  */\n+#define DBX_NO_XREFS\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* Mode of a function address in a call instruction (for indexing purposes).\n+\n+   Doesn't matter on ROMP.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this if shift instructions ignore all but the low-order\n+   few bits. */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    return 0;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   References to our own data area are really references to r14, so they\n+   are very cheap.  Multiples and divides are very expensive.  */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\\\n+    return current_function_operand (X, Pmode) ? 0 : COSTS_N_INSNS (2);\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return TARGET_IN_LINE_MUL ? COSTS_N_INSNS (19) : COSTS_N_INSNS (25); \\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (45);\n+\n+/* Compute the cost of an address.  This is meant to approximate the size\n+   and/or execution delay of an insn using that address.  If the cost is\n+   approximated by the RTL complexity, including CONST_COSTS above, as\n+   is usually the case for CISC machines, this macro should not be defined.\n+   For aggressively RISCy machines, only one insn format is allowed, so\n+   this macro should be a constant.  The value of this macro only matters\n+   for valid addresses.\n+\n+   For the ROMP, everything is cost 0 except for addresses involving\n+   symbolic constants, which are cost 1.  */\n+\n+#define ADDRESS_COST(RTX)\t\t\t\t\\\n+  ((GET_CODE (RTX) == SYMBOL_REF\t\t\t\\\n+    && ! CONSTANT_POOL_ADDRESS_P (RTX))\t\t\t\\\n+   || GET_CODE (RTX) == LABEL_REF\t\t\t\\\n+   || (GET_CODE (RTX) == CONST\t\t\t\t\\\n+       && ! constant_pool_address_operand (RTX, Pmode))\t\\\n+   || (GET_CODE (RTX) == PLUS\t\t\t\t\\\n+       && ((GET_CODE (XEXP (RTX, 1)) == SYMBOL_REF\t\\\n+\t    && ! CONSTANT_POOL_ADDRESS_P (XEXP (RTX, 0))) \\\n+\t   || GET_CODE (XEXP (RTX, 1)) == LABEL_REF\t\\\n+\t   || GET_CODE (XEXP (RTX, 1)) == CONST)))\n+\n+/* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n+   should be adjusted to reflect any required changes.  This macro is used when\n+   there is some systematic length adjustment required that would be difficult\n+   to express in the length attribute.\n+\n+   On the ROMP, there are two adjustments:  First, a 2-byte insn in the delay\n+   slot of a CALL (including floating-point operations) actually takes four\n+   bytes.  Second, we have to make the worst-case alignment assumption for\n+   address vectors.  */\n+\n+#define ADJUST_INSN_LENGTH(X,LENGTH)\t\t\t\t\t\\\n+  if (GET_CODE (X) == INSN && GET_CODE (PATTERN (X)) == SEQUENCE\t\\\n+      && GET_CODE (XVECEXP (PATTERN (X), 0, 0)) != JUMP_INSN\t\t\\\n+      && get_attr_length (XVECEXP (PATTERN (X), 0, 1)) == 2)\t\t\\\n+    (LENGTH) += 2;\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == JUMP_INSN && GET_CODE (PATTERN (X)) == ADDR_VEC) \\\n+    (LENGTH) += 2;\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* Set if condition code (really not-Z) is stored in `test bit'.  */\n+#define CC_IN_TB\t 01000\n+\n+/* Set if condition code is set by an unsigned compare. */\n+#define\tCC_UNSIGNED        02000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(BODY,INSN) \\\n+  update_cc (BODY, INSN)\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\\\n+{ extern char *version_string;\t\t\t\t\\\n+  fprintf (FILE, \"\\t.globl .oVncs\\n\\t.set .oVncs,0\\n\") ; \\\n+  fprintf (FILE, \"\\t.globl .oVgcc%s\\n\\t.set .oVgcc%s,0\\n\", \\\n+\t   version_string, version_string);\t\t\\\n+}\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before instructions and read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\\\n+ \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"ap\",\t\t\\\n+ \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\" }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.\n+\n+   WARNING:  Believe it or not, the ROMP assembler has a bug in its\n+   handling of single-precision floating-point values making it impossible\n+   to output such values in the expected way.  Therefore, it must be output\n+   in hex.  THIS WILL NOT WORK IF CROSS-COMPILING FROM A MACHINE THAT DOES\n+   NOT USE IEEE-FORMAT FLOATING-POINT, but there is nothing that can be done\n+   about it short of fixing the assembler.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\\\n+  do { union { int i; float f; } u_i_f;\t\t\\\n+       u_i_f.f = (VALUE);\t\t\t\\\n+       fprintf (FILE, \"\\t.long 0x%x\\n\", u_i_f.i);\\\n+     } while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.short \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output code to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsis r1,4\\n\\tsts %s,0(r1)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tls r1,0(r1)\\n\\tais r1,4\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (ROMP does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  abort ()\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%d\\n\", (SIZE)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n+\n+/* Define which CODE values are valid.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n+  ((CODE) == '.' || (CODE) == '#')\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\\\n+{ register rtx addr = ADDR;\t\t\t\t\t\\\n+  register rtx base = 0, offset = addr;\t\t\t\t\\\n+  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n+    base = addr, offset = const0_rtx;\t\t\t\t\\\n+  else if (GET_CODE (addr) == PLUS\t\t\t\t\\\n+\t   && GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+    base = XEXP (addr, 0), offset = XEXP (addr, 1);\t\t\\\n+  else if (GET_CODE (addr) == SYMBOL_REF\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (addr))\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      offset = gen_rtx (CONST_INT, VOIDmode, get_pool_offset (addr) + 12);  \\\n+      base = gen_rtx (REG, SImode, 14);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (addr) == CONST\t\t\t\t\\\n+\t   && GET_CODE (XEXP (addr, 0)) == PLUS\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT\t\\\n+\t   && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (addr, 0), 0))) \\\n+    {\t\t\t\t\t\t\t\t\\\n+      offset = plus_constant (XEXP (XEXP (addr, 0), 1),\t\t\\\n+\t\t\t      (get_pool_offset (XEXP (XEXP (addr, 0), 0)) \\\n+\t\t\t       + 12));\t\t\t\t\\\n+      base = gen_rtx (REG, SImode, 14);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  output_addr_const (FILE, offset);\t\t\t\t\\\n+  if (base)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"(%s)\", reg_names [REGNO (base)]);\t\t\\\n+}\n+\n+/* Define the codes that are matched by predicates in aux-output.c.  */\n+\n+#define PREDICATE_CODES \\\n+  {\"zero_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n+  {\"short_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n+  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n+  {\"current_function_operand\", {MEM}},\t\t\t\t\\\n+  {\"constant_pool_address_operand\", {SUBREG, CONST}},\t\t\\\n+  {\"romp_symbolic_operand\", {LABEL_REF, SYMBOL_REF, CONST}},\t\\\n+  {\"constant_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST, CONST_INT}}, \\\n+  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"reg_or_any_cint_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"reg_or_D_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"reg_or_add_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF,\t\\\n+\t\t\t  PLUS, CONST, CONST_INT}}, \t\t\\\n+  {\"reg_or_and_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+  {\"reg_or_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+  {\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\\\n+  {\"romp_operand\", {SUBREG, MEM, REG, CONST_INT, CONST, LABEL_REF, \\\n+\t\t    SYMBOL_REF, CONST_DOUBLE}},\t\t\t\\\n+  {\"reg_0_operand\", {REG}},\t\t\t\t\t\\\n+  {\"reg_15_operand\", {REG}},\t\t\t\t\t\\\n+  {\"float_binary\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n+  {\"float_unary\", {NEG, ABS}},\t\t\t\t\t\\\n+  {\"float_conversion\", {FLOAT_TRUNCATE, FLOAT_EXTEND, FLOAT, FIX}},\n+\n+/* Define functions defined in aux-output.c and used in templates.  */\n+\n+extern char *output_in_line_mul ();\n+extern char *output_fpop ();"}, {"sha": "6d732fed263f0e0af1286040d6eaad46163df062", "filename": "gcc/config/romp/romp.md", "status": "added", "additions": 2728, "deletions": 0, "changes": 2728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b124ac047273369cc07052260cdd163677e09de3/gcc%2Fconfig%2Fromp%2Fromp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b124ac047273369cc07052260cdd163677e09de3/gcc%2Fconfig%2Fromp%2Fromp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.md?ref=b124ac047273369cc07052260cdd163677e09de3", "patch": "@@ -0,0 +1,2728 @@\n+;;- Machine description for ROMP chip for GNU C compiler\n+;;   Copyright (C) 1988, 1991 Free Software Foundation, Inc.\n+;;   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\f\n+;; Define the attributes for the ROMP.\n+\n+;; Insn type.  Used to default other attribute values.\n+\n+(define_attr \"type\"\n+  \"branch,return,fp,load,loadz,store,call,address,arith,compare,multi,misc\"\n+  (const_string \"arith\"))\n+\n+;; Length in bytes.\n+\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"branch\")\n+\t (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int -256))\n+\t\t\t    (le (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int 254)))\n+\t\t       (const_int 2)\n+\t\t       (const_int 4))\n+\t (eq_attr \"type\" \"return\")\t(const_int 2)\n+\t (eq_attr \"type\" \"fp\")\t\t(const_int 10)\n+\t (eq_attr \"type\" \"call\")\t(const_int 4)\n+\t (eq_attr \"type\" \"load\")\n+\t   (cond [(match_operand 1 \"short_memory_operand\" \"\") (const_int 2)\n+\t\t  (match_operand 1 \"symbolic_memory_operand\" \"\") (const_int 8)]\n+\t\t (const_int 4))\n+         (eq_attr \"type\" \"loadz\")\n+\t   (cond [(match_operand 1 \"zero_memory_operand\" \"\") (const_int 2)\n+\t\t  (match_operand 1 \"symbolic_memory_operand\" \"\") (const_int 8)]\n+\t\t (const_string \"4\"))\n+\t (eq_attr \"type\" \"store\")\n+\t   (cond [(match_operand 0 \"short_memory_operand\" \"\") (const_int 2)\n+\t\t  (match_operand 0 \"symbolic_memory_operand\" \"\") (const_int 8)]\n+\t\t (const_int 4))]\n+\t(const_int 4)))\n+\n+;; Whether insn can be placed in a delay slot.\n+\n+(define_attr \"in_delay_slot\" \"yes,no\" \n+  (cond [(eq_attr \"length\" \"8,10,38\")\t\t\t(const_string \"no\")\n+\t (eq_attr \"type\" \"branch,return,call,multi\")\t(const_string \"no\")]\n+\t(const_string \"yes\")))\n+\n+;; Whether insn needs a delay slot.\n+(define_attr \"needs_delay_slot\" \"yes,no\"\n+  (if_then_else (eq_attr \"type\" \"branch,return,call\")\n+\t\t(const_string \"yes\") (const_string \"no\")))\n+\n+;; What insn does to the condition code.\n+\n+(define_attr \"cc\"\n+  \"clobber,none,sets,change0,copy1to0,compare,tbit\"\n+  (cond [(eq_attr \"type\" \"load,loadz\")\t\t(const_string \"change0\")\n+\t (eq_attr \"type\" \"store\")\t\t(const_string \"none\")\n+\t (eq_attr \"type\" \"fp,call\")\t\t(const_string \"clobber\")\n+\t (eq_attr \"type\" \"branch,return\")\t(const_string \"none\")\n+\t (eq_attr \"type\" \"address\")\t\t(const_string \"change0\")\n+\t (eq_attr \"type\" \"compare\")\t\t(const_string \"compare\")\n+\t (eq_attr \"type\" \"arith\")\t\t(const_string \"sets\")]\n+\t(const_string \"clobber\")))\n+\f\n+;; Define attributes for `asm' insns.\n+\n+(define_asm_attributes [(set_attr \"type\" \"misc\")\n+\t\t\t(set_attr \"length\" \"8\")\n+\t\t\t(set_attr \"in_delay_slot\" \"no\")\n+\t\t\t(set_attr \"cc\" \"clobber\")])\n+\n+;; Define the delay slot requirements for branches and calls.  We don't have\n+;; any annulled insns.\n+;;\n+(define_delay (eq_attr \"needs_delay_slot\" \"yes\")\n+  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n+\n+;; We cannot give a floating-point comparison a delay slot, even though it\n+;; could make use of it.  This is because it would confuse next_cc0_user\n+;; to do so.  Other fp insns can't get a delay slow because they set their\n+;; result and use their input after the delay slot insn is executed.  This\n+;; isn't what reorg.c expects.  \n+\n+;; Define load & store delays.  These were obtained by measurements done by\n+;; jfc@athena.mit.edu.\n+;;\n+;; In general, the memory unit can support at most two simultaneous operations.\n+;;\n+;; Loads take 5 cycles to return the data and can be pipelined up to the\n+;; limit of two simultaneous operations.\n+(define_function_unit \"memory\" 1 2 (eq_attr \"type\" \"load,loadz\") 5 0)\n+\n+;; Stores do not return data, but tie up the memory unit for 2 cycles if the\n+;; next insn is also a store.\n+(define_function_unit \"memory\" 1 2 (eq_attr \"type\" \"store\") 1 2\n+  [(eq_attr \"type\" \"store\")])\n+\f\n+;; Move word instructions.\n+;;\n+;; If destination is memory but source is not register, force source to\n+;; register.\n+;;\n+;; If source is a constant that is too large to load in a single insn, build\n+;; it in two pieces.\n+;;\n+;; If destination is memory and source is a register, a temporary register\n+;; will be needed.  In that case, make a PARALLEL of the SET and a\n+;; CLOBBER of a SCRATCH to allocate the required temporary.\n+;;\n+;; This temporary is ACTUALLY only needed when the destination is a\n+;; relocatable expression.  For generating RTL, however, we always\n+;; place the CLOBBER.  In insns where it is not needed, the SCRATCH will\n+;; not be allocated to a register.\n+;;\n+;; Also, avoid creating pseudo-registers or SCRATCH rtx's during reload as\n+;; they will not be correctly handled.  We never need pseudos for that\n+;; case anyway.\n+;;\n+;; We do not use DEFINE_SPLIT for loading constants because the number\n+;; of cases in the resulting unsplit insn would be too high to deal\n+;; with practically.\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (GET_CODE (op1) == REG && REGNO (op1) == 16)\n+    DONE;\n+\n+  if (GET_CODE (op0) == REG && REGNO (op0) == 16)\n+    DONE;\n+\n+  if (GET_CODE (op0) == MEM && ! reload_in_progress)\n+    {\n+      emit_insn (gen_storesi (operands[0], force_reg (SImode, operands[1])));\n+      DONE;\n+    }\n+  else if (GET_CODE (op1) == CONST_INT)\n+    {\n+      int const_val = INTVAL (op1);\n+\n+      /* Try a number of cases to see how to best load the constant.  */\n+      if ((const_val & 0xffff) == 0\n+\t  || (const_val & 0xffff0000) == 0\n+\t  || (unsigned) (const_val + 0x8000) < 0x10000)\n+\t/* Can do this in one insn, so generate it.  */\n+\t;\n+      else if (((- const_val) & 0xffff) == 0\n+\t       || ((- const_val) & 0xffff0000) == 0\n+\t       || (unsigned) ((- const_val) + 0x8000) < 0x10000)\n+\t{\n+\t  /* Can do this by loading the negative constant and then negating. */\n+\t  emit_move_insn (operands[0],\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, - const_val));\n+\t  emit_insn (gen_negsi2 (operands[0], operands[0]));\n+\t  DONE;\n+\t}\n+      else\n+\t/* Do this the long way.  */\n+\t{\n+\t  unsigned int high_part = const_val & 0xffff0000;\n+\t  unsigned int low_part = const_val & 0xffff;\n+\t  int i;\n+\n+\t  if (low_part >= 0x10 && exact_log2 (low_part) >= 0)\n+\t    i = high_part, high_part = low_part, low_part = i;\n+\n+\t  emit_move_insn (operands[0],\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode, low_part));\n+\t  emit_insn (gen_iorsi3 (operands[0], operands[0],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode, high_part)));\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\n+;; Move from a symbolic memory location to a register is special.  In this\n+;; case, we know in advance that the register cannot be r0, so we can improve\n+;; register allocation by treating it separately.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(match_operand:SI 1 \"symbolic_memory_operand\" \"m\"))]\n+  \"\"\n+  \"load %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+;; Generic single-word move insn.  We avoid the case where the destination is\n+;; a symbolic address, as that needs a temporary register.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,r,r,r,b,Q\")\n+\t(match_operand:SI 1 \"romp_operand\" \"rR,I,K,L,M,S,s,Q,m,r\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   cas %0,%1,r0\n+   lis %0,%1\n+   cal %0,%1(r0)\n+   cal16 %0,%1(r0)\n+   cau %0,%H1(r0)\n+   ail %0,r14,%C1\n+   get %0,$%1\n+   l%M1 %0,%1\n+   load %0,%1\n+   st%M0 %1,%0\"\n+  [(set_attr \"type\" \"address,address,address,address,address,arith,misc,load,load,store\")\n+   (set_attr \"length\" \"2,2,4,4,4,4,8,*,*,*\")])\n+\n+(define_insn \"storesi\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=Q,m\")\n+\t(match_operand:SI 1 \"register_operand\" \"r,r\"))\n+   (clobber (match_scratch:SI 2 \"=X,&b\"))]\n+  \"\"\n+  \"@\n+   st%M0 %1,%0\n+   store %1,%0,%2\"\n+  [(set_attr \"type\" \"store\")])\n+\n+;; This pattern is used by reload when we store into a symbolic address.  It\n+;; provides the temporary register required.  This pattern is only used\n+;; when SECONDARY_OUTPUT_RELOAD_CLASS returns something other than\n+;; NO_REGS, so we need not have any predicates here.\n+\n+(define_expand \"reload_outsi\"\n+  [(set (match_operand:SI 0 \"symbolic_memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"\" \"r\"))\n+   (match_operand:SI 2 \"\" \"=&b\")]\n+  \"\"\n+  \"\")\n+\f\n+;; Now do the same for the QI move instructions.\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+\n+  if (GET_CODE (op0) == MEM && ! reload_in_progress)\n+    {\n+      emit_insn (gen_storeqi (operands[0], force_reg (QImode, operands[1])));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=b\")\n+\t(match_operand:QI 1 \"symbolic_memory_operand\" \"m\"))]\n+  \"\" \n+  \"loadc %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,b,Q\")\n+\t(match_operand:QI 1 \"romp_operand\" \"r,I,n,s,Q,m,r\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   cas %0,%1,r0\n+   lis %0,%1\n+   cal %0,%L1(r0)\n+   get %0,$%1\n+   lc%M1 %0,%1\n+   loadc %0,%1\n+   stc%M0 %1,%0\"\n+  [(set_attr \"type\" \"address,address,address,misc,load,load,store\")\n+   (set_attr \"length\" \"2,2,4,8,*,*,*\")])\n+\n+(define_insn \"storeqi\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=Q,m\")\n+\t(match_operand:QI 1 \"register_operand\" \"r,r\"))\n+   (clobber (match_scratch:SI 2 \"=X,&b\"))]\n+  \"\"\n+  \"@\n+   stc%M0 %1,%0\n+   storec %1,%0,%2\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_expand \"reload_outqi\"\n+  [(set (match_operand:QI 0 \"symbolic_memory_operand\" \"=m\")\n+\t(match_operand:QI 1 \"\" \"r\"))\n+   (match_operand:SI 2 \"\" \"=&b\")]\n+  \"\"\n+  \"\")\n+\f\n+;; Finally, the HI instructions.\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+\n+  if (GET_CODE (op0) == MEM && ! reload_in_progress)\n+    {\n+      emit_insn (gen_storehi (operands[0], force_reg (HImode, operands[1])));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=b\")\n+\t(match_operand:HI 1 \"symbolic_memory_operand\" \"m\"))]\n+  \"\"\n+  \"loadha %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,b,Q\")\n+\t(match_operand:HI 1 \"romp_operand\" \"r,I,n,s,Q,m,r\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+   cas %0,%1,r0\n+   lis %0,%1\n+   cal %0,%L1(r0)\n+   get %0,$%1\n+   lh%N1 %0,%1\n+   loadh %0,%1\n+   sth%M0 %1,%0\"\n+  [(set_attr \"type\" \"address,address,address,misc,loadz,loadz,store\")\n+   (set_attr \"length\" \"2,2,4,8,*,*,*\")])\n+\n+(define_insn \"storehi\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"=Q,m\")\n+\t(match_operand:HI 1 \"register_operand\" \"r,r\"))\n+   (clobber (match_scratch:SI 2 \"=X,&b\"))]\n+  \"\"\n+  \"@\n+   sth%M0 %1,%0\n+   storeh %1,%0,%2\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_expand \"reload_outhi\"\n+  [(set (match_operand:HI 0 \"symbolic_memory_operand\" \"=m\")\n+\t(match_operand:HI 1 \"\" \"r\"))\n+   (match_operand:SI 2 \"\" \"=&b\")]\n+  \"\"\n+  \"\")\n+\f\n+;; For DI move, if we have a constant, break the operation apart into\n+;; two SImode moves because the optimizer may be able to do a better job\n+;; with the resulting code.\n+;;\n+;; For memory stores, make the required pseudo for a temporary in case we\n+;; are storing into an absolute address.\n+;;\n+;; We need to be careful about the cases where the output is a register that is\n+;; the second register of the input.\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+ \n+  if (CONSTANT_P (op1))\n+    {\n+      rtx insns;\n+\n+      start_sequence ();\n+      emit_move_insn (operand_subword (op0, 0, 1, DImode),\n+\t\t      operand_subword (op1, 0, 1, DImode));\n+      emit_move_insn (operand_subword (op0, 1, 1, DImode),\n+\t\t      operand_subword (op1, 1, 1, DImode));\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, op0, op1, 0, op1);\n+      DONE;\n+    }\n+\n+  if (GET_CODE (op0) == MEM && ! reload_in_progress)\n+    {\n+      emit_insn (gen_storedi (operands[0], force_reg (DImode, operands[1])));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"\"\n+ [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n+       (match_operand:DI 1 \"reg_or_mem_operand\" \"r,Q,m,r\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"cas %O0,%O1,r0\\;cas %0,%1,r0\\\";\n+      else\n+\treturn \\\"cas %0,%1,r0\\;cas %O0,%O1,r0\\\";\n+    case 1:\n+      /* Here we must see which word to load first.  We default to the\n+\t low-order word unless it occurs in the address.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], 0))\n+\treturn \\\"l%M1 %O0,%O1\\;l%M1 %0,%1\\\";\n+      else\n+\treturn \\\"l%M1 %0,%1\\;l%M1 %O0,%O1\\\";\n+    case 2:\n+      return \\\"get %O0,$%1\\;ls %0,0(%O0)\\;ls %O0,4(%O0)\\\";\n+    case 3:\n+      return \\\"st%M0 %1,%0\\;st%M0 %O1,%O0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"cc\" \"change0,change0,change0,none\")\n+   (set_attr \"length\" \"4,12,8,8\")])\n+\n+(define_insn \"storedi\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=Q,m\")\n+\t(match_operand:DI 1 \"register_operand\" \"r,r\"))\n+   (clobber (match_scratch:SI 2 \"=X,&b\"))]\n+  \"\"\n+  \"@\n+   st%M0 %1,%0\\;st%M0 %O1,%O0\n+   get %2,$%0\\;sts %1,0(%2)\\;sts %O1,4(%2)\"\n+  [(set_attr \"type\" \"multi,multi\")\n+   (set_attr \"cc\" \"none,none\")\n+   (set_attr \"length\" \"8,12\")])\n+\n+(define_expand \"reload_outdi\"\n+  [(set (match_operand:DI 0 \"symbolic_memory_operand\" \"=m\")\n+\t(match_operand:DI 1 \"\" \"r\"))\n+   (match_operand:SI 2 \"\" \"=&b\")]\n+  \"\"\n+  \"\")\n+\n+;; Split symbolic memory operands differently.  We first load the address\n+;; into a register and then do the two loads or stores.  We can only do\n+;; this if operand_subword won't produce a SUBREG, which is only when\n+;; operands[0] is a hard register.  Thus, these won't be used during the\n+;; first insn scheduling pass.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"symbolic_memory_operand\" \"\"))]\n+  \"GET_CODE (operands[0]) == REG\n+   && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 6) (match_dup 7))]\n+  \"\n+{ operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+  operands[3] = XEXP (operands[1], 0);\n+  operands[4] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[5] = gen_rtx (MEM, SImode, operands[2]);\n+  operands[6] = operands[2];\n+  operands[7] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, SImode, operands[2],\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 4)));\n+\n+  if (operands[2] == 0 || operands[4] == 0)\n+    FAIL;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"symbolic_memory_operand\" \"\")\n+\t(match_operand:DI 1 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))] \n+  \"GET_CODE (operands[0]) == REG\n+   && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))\n+   (set (match_dup 6) (match_dup 7))]\n+  \"\n+{ operands[3] = XEXP (operands[0], 0);\n+  operands[4] = gen_rtx (MEM, SImode, operands[2]);\n+  operands[5] = operand_subword (operands[1], 0, 0, DImode);\n+  operands[6] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, SImode, operands[2],\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 4)));\n+  operands[7] = operand_subword (operands[1], 1, 0, DImode);\n+\n+  if (operands[5] == 0 || operands[7] == 0)\n+    FAIL;\n+}\")\n+\n+;; If the output is a register and the input is memory, we have to be careful\n+;; and see which word needs to be loaded first.\n+;;\n+;; Note that this case doesn't have a CLOBBER.   Therefore, we must either\n+;; be after reload or operand[0] must not be a MEM.  So we don't need a\n+;; CLOBBER on the new insns either.\n+;;\n+;; Due to a bug in sched.c, we do not want to split this insn if both\n+;; operands are registers and they overlap unless reload has completed.\n+(define_split\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"! symbolic_memory_operand (operands[0], DImode)\n+   && ! symbolic_memory_operand (operands[1], DImode)\n+   && ! (GET_CODE (operands[0]) == REG\n+         && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[1]) == REG\n+         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n+\t && ! reload_completed\n+\t && reg_overlap_mentioned_p (operands[0], operands[1]))\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[0]) != REG\n+      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t      operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 0, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 1, 0, DImode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 1, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 0, 0, DImode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n+\n+(define_split\n+ [(set (match_operand:DI 0 \"general_operand\" \"\")\n+       (match_operand:DI 1 \"general_operand\" \"\"))\n+  (clobber (match_operand:SI 6 \"register_operand\" \"\"))]\n+  \"! symbolic_memory_operand (operands[0], DImode)\n+   && ! symbolic_memory_operand (operands[1], DImode)\n+   && ! (GET_CODE (operands[0]) == REG\n+         && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)\n+   && ! (GET_CODE (operands[1]) == REG\n+         && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER)\"\n+ [(parallel [(set (match_dup 2) (match_dup 3))\n+\t     (clobber (match_dup 7))])\n+  (parallel [(set (match_dup 4) (match_dup 5))\n+\t     (clobber (match_dup 8))])]\n+ \"\n+{ if (GET_CODE (operands[0]) != REG\n+      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t      operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 0, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 1, 0, DImode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+      operands[3] = operand_subword (operands[1], 1, 0, DImode);\n+      operands[4] = operand_subword (operands[0], 0, 0, DImode);\n+      operands[5] = operand_subword (operands[1], 0, 0, DImode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+\n+  /* We must be sure to make two different SCRATCH operands, since they\n+     are not allowed to be shared.  After reload, however, we only have\n+     a SCRATCH if we won't use the operand, so it is allowed to share it\n+     then.  */\n+  if (reload_completed || GET_CODE (operands[6]) != SCRATCH)\n+    operands[7] = operands[8] = operands[6];\n+  else\n+    {\n+      operands[7] = gen_rtx (SCRATCH, SImode);\n+      operands[8] = gen_rtx (SCRATCH, SImode);\n+    }\n+}\")\n+\n+;; Define move insns for SF, and DF.\n+;;\n+;; For register-register copies or a copy of something to itself, emit a\n+;; single SET insn since it will likely be optimized away.\n+;;\n+;; Otherwise, emit a floating-point move operation unless both input and\n+;; output are either constant, memory, or a non-floating-point hard register.\n+(define_expand \"movdf\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (match_operand:DF 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (op0 == op1)\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, op0, op1));\n+      DONE;\n+    }\n+\n+  if ((GET_CODE (op0) == MEM\n+       || (GET_CODE (op0) == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER\n+\t   && ! FP_REGNO_P (REGNO (op0))))\n+      && (GET_CODE (op1) == MEM\n+\t  || GET_CODE (op1) == CONST_DOUBLE\n+\t  || (GET_CODE (op1) == REG && REGNO (op1) < FIRST_PSEUDO_REGISTER\n+\t      && ! FP_REGNO_P (REGNO (op1)) && ! rtx_equal_p (op0, op1))))\n+    {\n+      rtx insns;\n+\n+      if (GET_CODE (op1) == CONST_DOUBLE)\n+\top1 = force_const_mem (DFmode, op1);\n+\n+      start_sequence ();\n+      if (GET_CODE (operands[0]) != REG\n+\t  || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t\t  operands[1]), 0)\n+\t{\n+\t  emit_move_insn (operand_subword (op0, 0, 1, DFmode),\n+\t\t\t  operand_subword_force (op1, 0, DFmode));\n+\t  emit_move_insn (operand_subword (op0, 1, 1, DFmode),\n+\t\t\t  operand_subword_force (op1, 1, DFmode));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (operand_subword (op0, 1, 1, DFmode),\n+\t\t\t  operand_subword_force (op1, 1, DFmode));\n+\t  emit_move_insn (operand_subword (op0, 0, 1, DFmode),\n+\t\t\t  operand_subword_force (op1, 0, DFmode));\n+\t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, op0, op1, 0, op1);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"movsf\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (match_operand:SF 1 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\n+{ rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  \n+  if (op0 == op1)\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, op0, op1));\n+      DONE;\n+    }\n+\n+  if ((GET_CODE (op0) == MEM\n+       || (GET_CODE (op0) == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER\n+\t   && ! FP_REGNO_P (REGNO (op0))))\n+       && (GET_CODE (op1) == MEM\n+\t   || GET_CODE (op1) == CONST_DOUBLE\n+\t   || (GET_CODE (op1) == REG && REGNO (op1) < FIRST_PSEUDO_REGISTER\n+\t       && ! FP_REGNO_P (REGNO (op1)))))\n+    {\n+      rtx last;\n+\n+      if (GET_CODE (op1) == CONST_DOUBLE)\n+\top1 = force_const_mem (SFmode, op1);\n+\n+      last = emit_move_insn (operand_subword (op0, 0, 1, SFmode),\n+\t\t\t     operand_subword_force (op1, 0, SFmode));\n+\n+      REG_NOTES (last) = gen_rtx (EXPR_LIST, REG_EQUAL, op1, REG_NOTES (last));\n+      DONE;\n+    }\n+}\")\n+\n+;; Define the move insns for SF and DF.  Check for all general regs\n+;; in the FP insns and make them non-FP if so.  Do the same if the input and\n+;; output are the same (the insn will be deleted in this case and we don't\n+;; want to think there are FP insns when there might not be).\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=*frg\")\n+\t(match_dup 0))]\n+  \"\"\n+  \"nopr r0\"\n+  [(set_attr \"type\" \"address\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=r,*fr,r,r,Q,m,frg\")\n+\t(match_operand:SF 1 \"general_operand\" \"r,0,Q,m,r,r,frg\"))\n+   (clobber (match_operand:SI 2 \"reg_0_operand\" \"=&z,z,z,z,z,z,z\"))\n+   (clobber (match_operand:SI 3 \"reg_15_operand\" \"=&t,t,t,t,t,t,t\"))]\n+  \"\"\n+  \"*\n+{ switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"cas %0,%1,r0\\\";\n+    case 1:\n+      return \\\"nopr r0\\\";\n+    case 2:\n+      return \\\"l%M1 %0,%1\\\";\n+    case 3:\n+      return \\\"load %0,%1\\\";\n+    case 4:\n+      return \\\"st%M0 %1,%0\\\";\n+    case 5:\n+      return \\\"store %1,%0,%3\\\";\n+    default:\n+      return output_fpop (SET, operands[0], operands[1], 0, insn);\n+    }\n+}\"\n+  [(set_attr \"type\" \"address,address,load,load,store,store,fp\")\n+   (set_attr \"length\" \"2,2,*,*,*,*,*\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=*frg\")\n+\t(match_dup 0))]\n+  \"\"\n+  \"nopr r0\"\n+  [(set_attr \"type\" \"address\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,*fr,r,r,Q,m,frg\")\n+\t(match_operand:DF 1 \"general_operand\" \"r,0,Q,m,r,r,*frg\"))\n+   (clobber (match_operand:SI 2 \"reg_0_operand\" \"=&z,z,z,z,z,z,z\"))\n+   (clobber (match_operand:SI 3 \"reg_15_operand\" \"=&t,t,t,t,t,t,t\"))]\n+  \"\"\n+  \"*\n+{ switch (which_alternative)\n+    {\n+    case 0:\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"cas %O0,%O1,r0\\;cas %0,%1,r0\\\";\n+      else\n+\treturn \\\"cas %0,%1,r0\\;cas %O0,%O1,r0\\\";\n+    case 1:\n+      return \\\"nopr r0\\\";\n+    case 2:\n+      /* Here we must see which word to load first.  We default to the\n+\t low-order word unless it occurs in the address.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], 0))\n+\treturn \\\"l%M1 %O0,%O1\\;l%M1 %0,%1\\\";\n+      else\n+\treturn \\\"l%M1 %0,%1\\;l%M1 %O0,%O1\\\";\n+    case 3:\n+      return \\\"get %3,$%1\\;ls %0,0(%3)\\;ls %O0,4(%3)\\\";\n+    case 4:\n+      return \\\"st%M0 %1,%0\\;st%M0 %O1,%O0\\\";\n+    case 5:\n+      return \\\"get %3,$%0\\;sts %1,0(%3)\\;sts %O1,4(%3)\\\";\n+    default:\n+      return output_fpop (SET, operands[0], operands[1], 0, insn);\n+    }\n+}\"\n+  [(set_attr \"type\" \"address,multi,multi,multi,multi,multi,fp\")\n+   (set_attr \"length\" \"2,4,*,*,*,*,*\")])\n+\n+;; Split all the above cases that involve multiple insns and no floating-point\n+;; data block.  If before reload, we can make a SCRATCH.  Otherwise, use\n+;; register 15.\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"symbolic_memory_operand\" \"\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 16\"\n+  [(set (reg:SI 15) (match_dup 2))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n+  \"\n+{ operands[2] = XEXP (operands[1], 0);\n+  operands[3] = operand_subword (operands[0], 0, 0, DFmode);\n+  operands[4] = gen_rtx (MEM, SImode, gen_rtx (REG, SImode, 15));\n+  operands[5] = operand_subword (operands[0], 0, 1, DFmode);\n+  operands[6] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, SImode, gen_rtx (REG, SImode, 15),\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 4)));\n+\n+  if (operands[3] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"symbolic_memory_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 16\"\n+  [(set (reg:SI 15) (match_dup 2))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n+  \"\n+{ operands[2] = XEXP (operands[0], 0);\n+  operands[3] = gen_rtx (MEM, SImode, gen_rtx (REG, SImode, 15));\n+  operands[4] = operand_subword (operands[1], 0, 0, DFmode);\n+  operands[5] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, SImode, gen_rtx (REG, SImode, 15),\n+\t\t\t\t  gen_rtx (CONST_INT, VOIDmode, 4)));\n+  operands[6] = operand_subword (operands[1], 1, 0, DFmode);\n+\n+  if (operands[4] == 0 || operands[6] == 0)\n+    FAIL;\n+}\")\n+\n+;; If the output is a register and the input is memory, we have to be careful\n+;; and see which word needs to be loaded first.  We also cannot to the\n+;; split if the input is a constant because it would result in invalid\n+;; insns.  When the output is a MEM, we must put a CLOBBER on each of the\n+;; resulting insn, when it is not a MEM, we must not.\n+(define_split\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 15\"\n+  [(parallel [(set (match_dup 2) (match_dup 3))\n+\t      (clobber (match_dup 6))])\n+   (parallel [(set (match_dup 4) (match_dup 5))\n+\t      (clobber (match_dup 7))])]\n+  \"\n+{ operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n+  operands[3] = operand_subword (operands[1], 0, 0, DFmode);\n+  operands[4] = operand_subword (operands[0], 1, 0, DFmode);\n+  operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+\n+  if (reload_completed)\n+    operands[6] = operands[7] = gen_rtx (REG, SImode, 15);\n+  else\n+    {\n+      operands[6] = gen_rtx (SCRATCH, SImode);\n+      operands[7] = gen_rtx (SCRATCH, SImode);\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"nonmemory_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"! symbolic_memory_operand (operands[1], DFmode)\n+   && GET_CODE (operands[1]) != CONST_DOUBLE\n+   && (GET_CODE (operands[0]) != REG || REGNO (operands[0]) < 15)\n+   && (GET_CODE (operands[1]) != REG || REGNO (operands[1]) < 15)\n+   && (GET_CODE (operands[0]) == REG || GET_CODE (operands[1]) == REG)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"\n+{ if (GET_CODE (operands[0]) != REG\n+      || ! refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t      operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, DFmode);\n+      operands[3] = operand_subword (operands[1], 0, 0, DFmode);\n+      operands[4] = operand_subword (operands[0], 1, 0, DFmode);\n+      operands[5] = operand_subword (operands[1], 1, 0, DFmode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, DFmode);\n+      operands[3] = operand_subword (operands[1], 1, 0, DFmode);\n+      operands[4] = operand_subword (operands[0], 0, 0, DFmode);\n+      operands[5] = operand_subword (operands[1], 0, 0, DFmode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    FAIL;\n+}\")\n+\f\n+;; Conversions from one integer mode to another.\n+;; It is possible sometimes to sign- or zero-extend while fetching from memory.\n+;;\n+;; First, sign-extensions:\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(sign_extend:SI (match_operand:HI 1 \"symbolic_memory_operand\" \"m\")))]\n+  \"\"\n+  \"loadha %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,b\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,Q,m\")))]\n+  \"\"\n+  \"@\n+   exts %0,%1\n+   lha%M1 %0,%1\n+   loadha %0,%1\"\n+  [(set_attr \"type\" \"arith,load,load\")\n+   (set_attr \"length\" \"2,*,*\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t   (const_int 24)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_dup 2)\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"\n+{ operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode); }\")\n+\n+(define_expand \"extendqihi2\"\n+  [(set (match_dup 2)\n+\t(ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t   (const_int 24)))\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_dup 2)\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"\n+{ operands[0] = gen_lowpart (SImode, operands[0]);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_reg_rtx (SImode); }\")\n+\n+;; Define peepholes to eliminate an instruction when we are doing a sign\n+;; extension but cannot clobber the input.\n+;;\n+;; In this case we will shift left 24 bits, but need a copy first.  The shift\n+;; can be replaced by a \"mc03\" instruction, but this can only be done if\n+;; followed by the right shift of 24 or more bits.\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(subreg:SI (match_operand:QI 1 \"register_operand\" \"\") 0))\n+   (set (match_dup 0)\n+\t(ashift:SI (match_dup 0)\n+\t\t   (const_int 24)))\n+   (set (match_dup 0)\n+\t(ashiftrt:SI (match_dup 0)\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+  \"INTVAL (operands[2]) >= 24\"\n+  \"mc03 %0,%1\\;sari16 %0,%S2\"\n+ [(set_attr \"type\" \"multi\")\n+  (set_attr \"length\" \"4\")\n+  (set_attr \"cc\" \"sets\")])\n+\n+;; Now zero extensions:\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"b\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(zero_extend:SI (match_operand:HI 1 \"symbolic_memory_operand\" \"m\")))]\n+  \"\"\n+  \"loadh %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,b\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,Q,m\")))]\n+  \"\"\n+  \"@\n+   nilz %0,%1,65535\n+   lh%N1 %0,%1\n+   loadh %0,%1\"\n+  [(set_attr \"type\" \"arith,loadz,load\")])\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(zero_extend:SI (match_operand:QI 1 \"symbolic_memory_operand\" \"m\")))]\n+  \"\"\n+  \"loadc %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,b\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,Q,m\")))]\n+  \"\"\n+  \"@\n+   nilz %0,%1,255\n+   lc%M1 %0,%1\n+   loadc %0,%1\"\n+  [(set_attr \"type\" \"arith,load,load\")])\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=b\")\n+\t(zero_extend:HI (match_operand:QI 1 \"symbolic_memory_operand\" \"m\")))]\n+  \"\"\n+  \"loadc %0,%1\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,b\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"r,Q,m\")))]\n+  \"\"\n+  \"@\n+   nilz %0,%1,255\n+   lc%M1 %0,%1\n+   loadc %0,%1\"\n+  [(set_attr \"type\" \"arith,load,load\")])\n+\f\n+;; Various extract and insertion operations.\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 8)\n+    FAIL;\n+\n+  if (GET_CODE (operands[3]) != CONST_INT)\n+    FAIL;\n+\n+  if (INTVAL (operands[3]) != 0 && INTVAL (operands[3]) != 8\n+      && INTVAL (operands[3]) != 16 && INTVAL (operands[3]) != 24)\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) & 7) == 0\"\n+  \"lis %0,0\\;mc3%B2 %0,%1\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"cc\" \"change0\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) & 7) == 0\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 24))\n+\t(zero_extract:SI (match_dup 1) (const_int 8) (match_dup 2)))]\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 24))\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"(INTVAL (operands[2]) & 7) == 0\"\n+  \"mc3%B2 %0,%1\"\n+  [(set_attr \"type\" \"address\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  if (GET_CODE (operands[1]) != CONST_INT)\n+    FAIL;\n+\n+  if (INTVAL (operands[1]) == 1)\n+    {\n+      emit_insn (gen_bit_insv (operands[0], operands[1], operands[2],\n+\t\t\t       operands[3]));\n+      DONE;\n+    }\n+  else if (INTVAL (operands[1]) == 8\n+\t   && (INTVAL (operands[2]) % 8 == 0))\n+    ;\t\t\t\t/* Accept aligned byte-wide field. */\n+  else\n+    FAIL;\n+}\")\n+\n+;; For a single-bit insert, it is better to explicitly generate references\n+;; to the T bit.  We will call the T bit \"CC0\" because it can be clobbered\n+;; by some CC0 sets (single-bit tests).\n+\n+(define_expand \"bit_insv\"\n+  [(set (cc0)\n+\t(zero_extract:SI (match_operand:SI 3 \"register_operand\" \"\")\n+\t\t\t (const_int 1)\n+\t\t\t (const_int 31)))\n+  (set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t(match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"const_int_operand\" \"\"))\n+       (ne (cc0) (const_int 0)))]\n+  \"\"\n+  \"\")\n+\t\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 8)\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\"))\n+\t(match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"(INTVAL (operands[1]) & 7) == 0\"\n+  \"mc%B1%.3 %0,%2\"\n+  [(set_attr \"type\" \"address\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; This pattern cannot have any input reloads since if references CC0.\n+;; So we have to add code to support memory, which is the only other\n+;; thing that a \"register_operand\" can become.  There is still a problem\n+;; if the address isn't valid and *it* needs a reload, but there is no\n+;; way to solve that problem, so let's hope it never happens.\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r,m\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n,m\"))\n+\t(ne (cc0) (const_int 0)))\n+   (match_scratch 2 \"=X,b\")]\n+  \"\"\n+  \"@\n+   mftbi%t1 %0,%S1\n+   l%M0 %2,%0\\;mftb%t1 %2,%S1\\;st%M0 %2,%0\"\n+  [(set_attr \"type\" \"*,multi\")\n+   (set_attr \"cc\" \"none,none\")\n+   (set_attr \"length\" \"2,10\")])\n+\f\n+;; Arithmetic instructions.  First, add and subtract.\n+;;\n+;; It may be that the second input is either large or small enough that\n+;; the operation cannot be done in a single insn.  In that case, emit two.\n+(define_expand \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (unsigned) (INTVAL (operands[2]) + 0x8000) >= 0x10000\n+      && (INTVAL (operands[2]) & 0xffff) != 0)\n+    {\n+      int low = INTVAL (operands[2]) & 0xffff;\n+      int high = (unsigned) INTVAL (operands[2]) >> 16;\n+\n+      if (low & 0x8000)\n+\thigh++, low |= 0xffff0000;\n+\n+      emit_insn (gen_addsi3 (operands[0], operands[1],\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, high << 16)));\n+      operands[1] = operands[0];\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, low);\n+    }\n+}\")\n+\n+;; Put the insn to add a symbolic constant to a register separately to\n+;; improve register allocation since it has different register requirements.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=b\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%b\")\n+\t\t (match_operand:SI 2 \"romp_symbolic_operand\" \"s\")))]\n+   \"\"\n+   \"get %0,$%2(%1)\"\n+   [(set_attr \"type\" \"address\")\n+    (set_attr \"length\" \"8\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r,r,b\")\n+\t(plus:SI (match_operand:SI 1 \"reg_or_add_operand\" \"%0,0,r,b,0,r,b\")\n+\t\t (match_operand:SI 2 \"reg_or_add_operand\" \"I,J,K,M,r,b,s\")))]\n+  \"register_operand (operands[1], SImode)\n+   || register_operand (operands[2], SImode)\"\n+  \"@\n+   ais %0,%2\n+   sis %0,%n2\n+   ail %0,%1,%2\n+   cau %0,%H2(%1)\n+   a %0,%2\n+   cas %0,%1,%2\n+   get %0,$%2(%1)\"\n+  [(set_attr \"type\" \"arith,arith,arith,address,arith,address,misc\")\n+   (set_attr \"length\" \"2,2,4,4,2,2,8\")])\n+\n+;; Now subtract.\n+;;\n+;; 1.\tIf third operand is constant integer, convert it to add of the negative\n+;;\tof that integer.\n+;; 2.\tIf the second operand is not a valid constant integer, force it into a\n+;;\tregister.\n+(define_expand \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_any_cint_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"reg_or_any_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands [2]) == CONST_INT)\n+    {\n+      emit_insn (gen_addsi3 (operands[0], operands[1], \n+\t\t\t     gen_rtx (CONST_INT,\n+\t\t\t\t      VOIDmode, - INTVAL (operands[2]))));\n+      DONE;\n+    }\n+  else\n+    operands[2] = force_reg (SImode, operands[2]);\n+\n+  if (GET_CODE (operands[1]) != CONST_INT\n+      || (unsigned) (INTVAL (operands[1]) + 0x8000) >= 0x10000)\n+    operands[1] = force_reg (SImode, operands[1]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"reg_or_D_operand\" \"K,0,r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r,r,0\")))]\n+  \"\"\n+  \"@\n+   sfi %0,%2,%1\n+   s %0,%2\n+   sf %0,%1\"\n+  [(set_attr \"length\" \"4,2,2\")])\n+\f\n+;; Multiply either calls a special RT routine or is done in-line, depending\n+;; on the value of a -m flag.\n+;;\n+;; First define the way we call the subroutine.\n+(define_expand \"mulsi3_subr\"\n+  [(set (reg:SI 2) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (reg:SI 3) (match_operand:SI 2 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 2) (mult:SI (reg:SI 2) (reg:SI 3)))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(reg:SI 2))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_IN_LINE_MUL)\n+    {\n+      emit_insn (gen_mulsi3_subr (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n+\n+;; Define the patterns to match.\n+;; We would like to provide a delay slot for the insns that call internal\n+;; routines, but doing so is risky since reorg will think that the use of\n+;; r2 and r3 is completed in the insn needing the delay slot.  Also, it\n+;; won't know that the cc will be clobbered.  So take the safe approach\n+;; and don't give them delay slots.\n+(define_insn \"\"\n+  [(set (reg:SI 2)\n+\t(mult:SI (reg:SI 2) (reg:SI 3)))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"! TARGET_IN_LINE_MUL\"\n+  \"bali%# r15,lmul$$\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"in_delay_slot\" \"no\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_IN_LINE_MUL\"\n+  \"*\n+{ return output_in_line_mul (); }\"\n+  [(set_attr \"length\" \"38\")\n+   (set_attr \"type\" \"multi\")])\n+\f\n+;; Handle divide and modulus.  The same function returns both values,\n+;; so use divmodsi4.  This divides arg 1 by arg 2 with quotient to go\n+;; into arg 0 and remainder in arg 3.\n+;;\n+;; We want to put REG_EQUAL notes for the two outputs.  So we need a\n+;; function to do everything else.\n+(define_expand \"divmodsi4_doit\"\n+  [(set (reg:SI 2)\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (reg:SI 3)\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 2) (div:SI (reg:SI 2) (reg:SI 3)))\n+\t      (set (reg:SI 3) (mod:SI (reg:SI 2) (reg:SI 3)))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"divmodsi4\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (div:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"\")))\n+\t      (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t\t   (mod:SI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  emit_insn (gen_divmodsi4_doit (operands[1], operands[2]));\n+  insn = emit_move_insn (operands[0], gen_rtx (REG, SImode, 2));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t      gen_rtx (DIV, SImode, operands[1],\n+\t\t\t\t       operands[2]),\n+\t\t\t      REG_NOTES (insn));\n+  insn = emit_move_insn (operands[3], gen_rtx (REG, SImode, 3));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t      gen_rtx (MOD, SImode, operands[1],\n+\t\t\t\t       operands[2]),\n+\t\t\t      REG_NOTES (insn));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 2)\n+\t(div:SI (reg:SI 2) (reg:SI 3)))\n+   (set (reg:SI 3)\n+\t(mod:SI (reg:SI 2) (reg:SI 3)))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"\"\n+  \"bali%# r15,ldiv$$\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"in_delay_slot\" \"no\")])\n+\n+;; Similarly for unsigned divide.\n+(define_expand \"udivmodsi4_doit\"\n+  [(set (reg:SI 2)\n+\t(match_operand:SI 0 \"register_operand\" \"\"))\n+   (set (reg:SI 3)\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 2) (udiv:SI (reg:SI 2) (reg:SI 3)))\n+\t      (set (reg:SI 3) (umod:SI (reg:SI 2) (reg:SI 3)))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"udivmodsi4\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (udiv:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"\")))\n+\t      (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t\t   (umod:SI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  emit_insn (gen_udivmodsi4_doit (operands[1], operands[2]));\n+  insn = emit_move_insn (operands[0], gen_rtx (REG, SImode, 2));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t      gen_rtx (UDIV, SImode, operands[1],\n+\t\t\t\t       operands[2]),\n+\t\t\t      REG_NOTES (insn));\n+  insn = emit_move_insn (operands[3], gen_rtx (REG, SImode, 3));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t      gen_rtx (UMOD, SImode, operands[1],\n+\t\t\t\t       operands[2]),\n+\t\t\t      REG_NOTES (insn));\n+  DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:SI 2)\n+\t(udiv:SI (reg:SI 2) (reg:SI 3)))\n+   (set (reg:SI 3)\n+\t(umod:SI (reg:SI 2) (reg:SI 3)))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 15))]\n+  \"\"\n+  \"bali%# r15,uldiv$$\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"in_delay_slot\" \"no\")])\n+\f\n+;; Define DImode arithmetic operations.\n+;;\n+;; It is possible to do certain adds and subtracts with constants in a single\n+;; insn, but it doesn't seem worth the trouble.\n+;;\n+;; Don't use DEFINE_SPLIT on these because the dependency on CC can't be\n+;; easily tracked in that case!\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"a %O0,%O2\\;ae %0,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"s %O0,%O2\\;se %0,%2\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,&r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"0,r\")))]\n+  \"\"\n+  \"twoc %O0,%O1\\;onec %0,%1\\;aei %0,%0,0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")])\n+\f\n+;; Unary arithmetic operations.\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(abs:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"abs %0,%1\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"twoc %0,%1\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"onec %0,%1\"\n+  [(set_attr \"length\" \"2\")])\n+\n+\f\n+;; Logical insns: AND, IOR, and XOR\n+;;\n+;; If the operation is being performed on a 32-bit constant such that\n+;; it cannot be done in one insn, do it in two.  We may lose a bit on\n+;; CSE in pathological cases, but it seems better doing it this way.\n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_any_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int top = (unsigned) INTVAL (operands[2]) >> 16;\n+      int bottom = INTVAL (operands[2]) & 0xffff;\n+\n+      if (top != 0 && top != 0xffff && bottom != 0 && bottom != 0xffff)\n+\t{\n+\t  emit_insn (gen_andsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t  (top << 16) | 0xffff)));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, 0xffff0000 | bottom);\n+\t}\n+    }\n+}\");\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"reg_or_and_operand\" \"%0,r,0\")\n+\t\t(match_operand:SI 2 \"reg_or_and_operand\" \"P,LMO,r\")))]\n+  \"register_operand (operands[1], SImode)\n+   || register_operand (operands[2], SImode)\"\n+  \"@\n+   clrb%k2 %0,%b2\n+   ni%z2 %0,%1,%Z2\n+   n %0,%2\"\n+  [(set_attr \"length\" \"2,4,2\")])\n+\n+;; logical OR (IOR)\n+(define_expand \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_any_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int top = (unsigned) INTVAL (operands[2]) >> 16;\n+      int bottom = INTVAL (operands[2]) & 0xffff;\n+\n+      if (top != 0 && bottom != 0)\n+\t{\n+\t  emit_insn (gen_iorsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode, (top << 16))));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, bottom);\n+\t}\n+    }\n+}\");\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"reg_or_cint_operand\" \"%0,r,0\")\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"N,LM,r\")))]\n+  \"register_operand (operands[1], SImode)\n+   || register_operand (operands[2], SImode)\"\n+  \"@\n+   setb%h2 %0,%b2\n+   oi%h2 %0,%1,%H2\n+   o %0,%2\"\n+  [(set_attr \"length\" \"2,4,2\")])\n+\n+;; exclusive-or (XOR)\n+(define_expand \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t(match_operand:SI 2 \"reg_or_any_cint_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int top = (unsigned) INTVAL (operands[2]) >> 16;\n+      int bottom = INTVAL (operands[2]) & 0xffff;\n+\n+      if (top == 0xffff && bottom == 0xffff)\n+\t{\n+\t  emit_insn (gen_one_cmplsi2 (operands[0], operands[1]));\n+\t  DONE;\n+\t}\n+      else if (top != 0 && bottom != 0)\n+\t{\n+\t  emit_insn (gen_xorsi3 (operands[0], operands[1],\n+\t\t\t\t gen_rtx (CONST_INT, VOIDmode, (top << 16))));\n+\t  operands[1] = operands[0];\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode, bottom);\n+\t}\n+    }\n+}\");\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"reg_or_cint_operand\" \"%r,0\")\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"LM,r\")))]\n+  \"register_operand (operands[1], SImode)\n+   || register_operand (operands[2], SImode)\"\n+  \"@\n+   xi%h2 %0,%1,%H2\n+   x %0,%2\"\n+  [(set_attr \"length\" \"4,2\")])\n+\f\n+;; Various shift insns\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t     (match_operand:QI 2 \"reg_or_cint_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   sar %0,%2\n+   sari%s2 %0,%S2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t     (match_operand:QI 2 \"reg_or_cint_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   sr %0,%2\n+   sri%s2 %0,%S2\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"cas %0,%1,%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"address\")])\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"reg_or_cint_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   sl %0,%2\n+   sli%s2 %0,%S2\"\n+  [(set_attr \"length\" \"2\")])\n+\f\n+;; Function call insns:\n+;;\n+;; On the ROMP, &fcn is actually a pointer to the data area, which is passed\n+;; to the function in r0.  &.fcn is the actual starting address of the\n+;; function.  Also, the word at &fcn contains &.fcn.\n+;;\n+;; For both functions that do and don't return values, there are two cases:\n+;; where the function's address is a constant, and where it isn't.\n+;;\n+;; Operand 1 (2 for `call_value') is the number of arguments and is not used.\n+(define_expand \"call\"\n+  [(use (reg:SI 0))\n+   (parallel [(call (mem:SI (match_operand:SI 0 \"address_operand\" \"\"))\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != CONST_INT)\n+    abort();\n+\n+  operands[0] = XEXP (operands[0], 0);\n+  if (GET_CODE (operands[0]) == SYMBOL_REF)\n+    {\n+      extern rtx get_symref ();\n+      char *real_fcnname =\n+\t\t(char *) alloca (strlen (XSTR (operands[0], 0)) + 2);\n+\n+      /* Copy the data area address to r0.  */\n+      emit_move_insn (gen_rtx (REG, SImode, 0),\n+\t\t      force_reg (SImode, operands[0]));\n+      strcpy (real_fcnname, \\\".\\\");\n+      strcat (real_fcnname, XSTR (operands[0], 0));\n+      operands[0] = get_symref (real_fcnname);\n+    }\n+  else\n+    {\n+      rtx data_access;\n+\n+      emit_move_insn (gen_rtx (REG, SImode, 0),\n+\t\t      force_reg (SImode, operands[0]));\n+      data_access = gen_rtx (MEM, SImode, operands[0]);\n+      RTX_UNCHANGING_P (data_access) = 1;\n+      operands[0] = copy_to_reg (data_access);\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"b\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (clobber (reg:SI 15))]\n+  \"\"\n+  \"balr%# r15,%0\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"\"\n+  [(call (mem:SI (match_operand:SI 0 \"romp_symbolic_operand\" \"i\"))\n+\t (match_operand 1 \"\" \"g\"))\n+   (clobber (reg:SI 15))]\n+  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n+  \"bali%# r15,%0\"\n+  [(set_attr \"type\" \"call\")])\n+\n+;; Call a function and return a value.\n+(define_expand \"call_value\"\n+  [(use (reg:SI 0))\n+   (parallel [(set (match_operand 0 \"\" \"=fg\")\n+\t\t   (call (mem:SI (match_operand:SI 1 \"address_operand\" \"\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != CONST_INT)\n+    abort();\n+\n+  operands[1] = XEXP (operands[1], 0);\n+  if (GET_CODE (operands[1]) == SYMBOL_REF)\n+    {\n+      extern rtx get_symref ();\n+      char *real_fcnname =\n+\t\t(char *) alloca (strlen (XSTR (operands[1], 0)) + 2);\n+\n+      /* Copy the data area address to r0.  */\n+      emit_move_insn (gen_rtx (REG, SImode, 0),\n+\t\t      force_reg (SImode, operands[1]));\n+      strcpy (real_fcnname, \\\".\\\");\n+      strcat (real_fcnname, XSTR (operands[1], 0));\n+      operands[1] = get_symref (real_fcnname);\n+    }\n+  else\n+    {\n+      rtx data_access;\n+\n+      emit_move_insn (gen_rtx (REG, SImode, 0),\n+\t\t      force_reg (SImode, operands[1]));\n+      data_access = gen_rtx (MEM, SImode, operands[1]);\n+      RTX_UNCHANGING_P (data_access) = 1;\n+      operands[1] = copy_to_reg (data_access);\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"b\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (clobber (reg:SI 15))]\n+  \"\"\n+  \"balr%# r15,%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"call\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=fg\")\n+\t(call (mem:SI (match_operand:SI 1 \"romp_symbolic_operand\" \"i\"))\n+\t      (match_operand 2 \"\" \"g\")))\n+   (clobber (reg:SI 15))]\n+  \"GET_CODE (operands[1]) == SYMBOL_REF\"\n+  \"bali%# r15,%1\"\n+  [(set_attr \"type\" \"call\")])\n+\n+;; No operation insn.\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nopr r0\"\n+  [(set_attr \"type\" \"address\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\f\n+;; Here are the floating-point operations.\n+;;\n+;; Start by providing DEFINE_EXPAND for each operation.\n+;; The insns will be handled with MATCH_OPERATOR; the methodology will be\n+;; discussed below.\n+\n+;; First the conversion operations.\n+\n+(define_expand \"truncdfsf2\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (float_truncate:SF (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"extendsfdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (float_extend:DF (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"floatsisf2\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (float:SF (match_operand:SI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"floatsidf2\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (float:DF (match_operand:SI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"fix_truncsfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t   (fix:SI (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"fix_truncdfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t   (fix:SI (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\f\n+;; Now the binary operations.\n+\n+(define_expand \"addsf3\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (plus:SF (match_operand:SF 1 \"general_operand\" \"\")\n+\t\t\t    (match_operand:SF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"adddf3\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (plus:DF (match_operand:DF 1 \"general_operand\" \"\")\n+\t\t\t    (match_operand:DF 2 \"general_operand\" \"\")))\n+\t       (clobber (reg:SI 0))\n+\t       (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"subsf3\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (minus:SF (match_operand:SF 1 \"general_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"subdf3\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (minus:DF (match_operand:DF 1 \"general_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"mulsf3\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (mult:SF (match_operand:SF 1 \"general_operand\" \"\")\n+\t\t\t    (match_operand:SF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"muldf3\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (mult:DF (match_operand:DF 1 \"general_operand\" \"\")\n+\t\t\t    (match_operand:DF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"divsf3\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (div:SF (match_operand:SF 1 \"general_operand\" \"\")\n+\t\t\t   (match_operand:SF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"divdf3\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (div:DF (match_operand:DF 1 \"general_operand\" \"\")\n+\t\t\t   (match_operand:DF 2 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\f\n+;; Unary floating-point operations.\n+;;\n+;; Negations can be done without floating-point, since this is IEEE.\n+;; But we cannot do this if an operand is a hard FP register, since\n+;; the SUBREG we create would not be valid.\n+(define_expand \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! (GET_CODE (operands[0]) == REG\n+\t && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n+\t && FP_REGNO_P (REGNO (operands[0])))\n+      && ! (GET_CODE (operands[1]) == REG\n+\t    && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n+\t    && FP_REGNO_P (REGNO (operands[1]))))\n+    {\n+      rtx result;\n+      rtx target = operand_subword (operands[0], 0, 1, SFmode);\n+\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, SFmode),\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n+\t\t\t     target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      /* Make a place for REG_EQUAL.  */\n+      emit_move_insn (operands[0], operands[0]);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! (GET_CODE (operands[0]) == REG\n+\t && REGNO (operands[0]) < FIRST_PSEUDO_REGISTER\n+\t && FP_REGNO_P (REGNO (operands[0])))\n+      && ! (GET_CODE (operands[1]) == REG\n+\t    && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n+\t    && FP_REGNO_P (REGNO (operands[1]))))\n+    {\n+      rtx result;\n+      rtx target = operand_subword (operands[0], 0, 1, DFmode);\n+      rtx insns;\n+\n+      start_sequence ();\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, DFmode),\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, 0x80000000),\n+\t\t\t     target, 0, OPTAB_WIDEN);\n+      if (result == 0)\n+\tabort ();\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+  \n+      emit_move_insn (operand_subword (operands[0], 1, 1, DFmode),\n+\t\t      operand_subword_force (operands[1], 1, DFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"abssf2\"\n+  [(parallel [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t   (abs:SF (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"absdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t   (abs:DF (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\f\n+;; Any floating-point operation can be either SFmode or DFmode, and each\n+;; operand (including the output) can be either a normal operand or a\n+;; conversion from a normal operand.\n+;;\n+;; We use MATCH_OPERATOR to match a floating-point binary or unary operator\n+;; and input and output conversions.  So we need 2^N patterns for each type\n+;; of operation, where N is the number of operands, including the output.\n+;; There are thus a total of 14 patterns, 8 for binary operations, 4 for\n+;; unary operations and two for conversion/move operations (only one\n+;; operand can have a conversion for move operations).  In addition, we have\n+;; to be careful that a floating-point reload register doesn't get allocated\n+;; for an integer.  We take care of this for inputs with PREFERRED_RELOAD_CLASS\n+;; but need to have two different constraints for outputs.  This means that\n+;; we have to duplicate each pattern where the output could be an integer.\n+;; This adds another 7 patterns, for a total of 21.\n+\n+;; Start with conversion operations (moves are done above).\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operand 2 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 3 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 4 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (SET, operands[0], operands[2], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operand 2 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 3 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 4 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (SET, operands[0], operands[2], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\f\n+;; Next, binary floating-point operations.\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_binary\"\n+\t\t[(match_operand 2 \"general_operand\" \"frg\")\n+\t\t (match_operand 3 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 4 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 5 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[2], operands[3])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], \n+\t\t      operands[2], operands[3], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_binary\"\n+\t\t[(match_operand 2 \"general_operand\" \"frg\")\n+\t\t (match_operator 3 \"float_conversion\"\n+\t\t\t[(match_operand 4 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[2], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], \n+\t\t      operands[2], operands[4], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_binary\"\n+\t\t[(match_operator 2 \"float_conversion\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")])\n+\t\t (match_operand 4 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[3], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], \n+\t\t      operands[3], operands[4], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_binary\"\n+\t\t[(match_operator 2 \"float_conversion\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")])\n+\t\t (match_operator 4 \"float_conversion\"\n+\t\t\t[(match_operand 5 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 6 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 7 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[3], operands[5])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], \n+\t\t      operands[3], operands[5], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")\n+\t\t\t (match_operand 4 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[3], operands[4], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")\n+\t\t\t (match_operand 4 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[3], operands[4], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")\n+\t\t\t (match_operator 4 \"float_conversion\"\n+\t\t\t \t[(match_operand 5 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 6 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 7 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[3], operands[5], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")\n+\t\t\t (match_operator 4 \"float_conversion\"\n+\t\t\t \t[(match_operand 5 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 6 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 7 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], operands[4])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[3], operands[5], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])\n+\t\t\t (match_operand 5 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 6 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 7 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], operands[5])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[4], operands[5], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])\n+\t\t\t (match_operand 5 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 6 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 7 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], operands[5])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[4], operands[5], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])\n+\t\t\t (match_operator 5 \"float_conversion\"\n+\t\t\t \t[(match_operand 6 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 7 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 8 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], operands[6])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[4], operands[6], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_binary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])\n+\t\t\t (match_operator 5 \"float_conversion\"\n+\t\t\t \t[(match_operand 6 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 7 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 8 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], operands[6])\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], \n+\t\t      operands[4], operands[6], insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\f\n+;; Unary floating-point operations.\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_unary\"\n+\t\t[(match_operand 2 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 3 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 4 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[2], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], operands[2],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_unary\"\n+\t\t[(match_operator 2 \"float_conversion\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 4 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 5 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[1]), operands[3], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[1]), operands[0], operands[3],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_unary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 4 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 5 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], operands[3],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_unary\"\n+\t\t\t[(match_operand 3 \"general_operand\" \"frg\")])]))\n+   (clobber (match_operand:SI 4 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 5 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[3], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], operands[3],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_unary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], operands[4],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"general_operand\" \"=frg\")\n+\t(match_operator 1 \"float_conversion\"\n+\t\t[(match_operator 2 \"float_unary\"\n+\t\t\t[(match_operator 3 \"float_conversion\"\n+\t\t\t \t[(match_operand 4 \"general_operand\" \"frg\")])])]))\n+   (clobber (match_operand:SI 5 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 6 \"reg_15_operand\" \"=&t\"))]\n+  \"check_precision (GET_MODE (operands[2]), operands[4], 0)\"\n+  \"*\n+{ return output_fpop (GET_CODE (operands[2]), operands[0], operands[4],\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\f\n+;; Compare insns are next.  Note that the ROMP has two types of compares,\n+;; signed & unsigned, and one type of branch.  Use the routine\n+;; `next_insn_tests_no_unsigned' to see which type to use.\n+(define_expand \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"\")\n+  \t\t (match_operand:SI 1 \"reg_or_cint_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+;; Signed compare, `test' first.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"next_insn_tests_no_unsigned (insn)\"\n+  \"cis %0,0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operand:SI 0 \"register_operand\" \"r,r,r\"))\n+   (set (match_operand:SI 1 \"reg_or_nonsymb_mem_operand\" \"=0,r,Q\")\n+\t(match_dup 0))]\n+  \"next_insn_tests_no_unsigned (insn)\"\n+  \"@\n+   cis %1,0\n+   nilo %1,%0,65535\n+   st%M1 %0,%1\\;cis %0,0\"\n+  [(set_attr \"type\" \"compare,compare,store\")\n+   (set_attr \"length\" \"2,4,6\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_cint_operand\" \"I,K,r\")))]\n+  \"next_insn_tests_no_unsigned (insn)\"\n+  \"@\n+   cis %0,%1\n+   cil %0,%1\n+   c %0,%1\"\n+  [(set_attr \"length\" \"2,4,2\")\n+   (set_attr \"type\" \"compare\")])\n+\n+;; Unsigned comparisons, `test' first, again.\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"! next_insn_tests_no_unsigned (insn)\"\n+  \"clil %0,0\"\n+  [(set_attr \"type\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+        (compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_cint_operand\" \"K,r\")))]\n+  \"! next_insn_tests_no_unsigned (insn)\"\n+  \"@\n+   clil %0,%1\n+   cl %0,%1\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"type\" \"compare\")])\n+\n+;; Bit test insn.  Many cases are converted into this by combine.  This\n+;; uses the ROMP test bit.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extract (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t      (const_int 1)\n+\t\t      (match_operand:SI 1 \"reg_or_any_cint_operand\" \"r,n\")))]\n+  \"next_insn_tests_no_inequality (insn)\"\n+  \"@\n+   mttb %0,%1\n+   mttbi%t1 %0,%S1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"cc\" \"tbit\")])\n+\f\n+;; Floating-point comparisons.  There are two, equality and order.\n+;; The difference will be that a trap for NaN will be given on the orderr\n+;; comparisons only.\n+\n+(define_expand \"cmpsf\"\n+  [(parallel [(set (cc0) (compare (match_operand:SF 0 \"general_operand\" \"\")\n+\t\t\t\t  (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"cmpdf\"\n+  [(parallel [(set (cc0) (compare (match_operand:DF 0 \"general_operand\" \"\")\n+\t\t\t\t  (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"tstsf\"\n+  [(parallel [(set (cc0) (match_operand:SF 0 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"tstdf\"\n+  [(parallel [(set (cc0) (match_operand:DF 0 \"general_operand\" \"\"))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 15))])]\n+  \"\"\n+  \"\")\n+\f\n+;; There are four cases for compare and two for test.  These correspond\n+;; to each input having a floating-point conversion or not.\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand 0 \"general_operand\" \"frg\")\n+\t\t       (match_operand 1 \"general_operand\" \"frg\")))\n+   (clobber (match_operand:SI 2 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 3 \"reg_15_operand\" \"=&t\"))]\n+  \"GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[0], operands[1], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operand 0 \"general_operand\" \"frg\")\n+\t\t       (match_operator 1 \"float_conversion\"\n+\t\t\t      [(match_operand 2 \"general_operand\" \"frg\")])))\n+   (clobber (match_operand:SI 3 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 4 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[0], operands[2], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operator 0 \"float_conversion\"\n+\t\t\t      [(match_operand 1 \"general_operand\" \"frg\")])\n+\t\t       (match_operand 2 \"general_operand\" \"frg\")))\n+   (clobber (match_operand:SI 3 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 4 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[1], operands[2], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (compare (match_operator 0 \"float_conversion\"\n+\t\t\t      [(match_operand 1 \"general_operand\" \"frg\")])\n+\t\t       (match_operator 2 \"float_conversion\"\n+\t\t\t      [(match_operand 3 \"general_operand\" \"frg\")])))\n+   (clobber (match_operand:SI 4 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 5 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[1], operands[3], 0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operand 0 \"general_operand\" \"frg\"))\n+   (clobber (match_operand:SI 1 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 2 \"reg_15_operand\" \"=&t\"))]\n+  \"GET_MODE (operands[0]) == SFmode || GET_MODE (operands[0]) == DFmode\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[0], immed_real_const_1 (0, 0,\n+\t\t\t\t\t\t       GET_MODE (operands[0])),\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"\"\n+  [(set (cc0) (match_operator 0 \"float_conversion\"\n+\t\t\t[(match_operand 1 \"general_operand\" \"frg\")]))\n+   (clobber (match_operand:SI 2 \"reg_0_operand\" \"=&z\"))\n+   (clobber (match_operand:SI 3 \"reg_15_operand\" \"=&t\"))]\n+  \"\"\n+  \"*\n+{ return output_fpop (next_insn_tests_no_inequality (insn) ? EQ : GE,\n+\t\t      operands[1], immed_real_const_1 (0, 0,\n+\t\t\t\t\t\t       GET_MODE (operands[1])),\n+\t\t      0, insn);\n+}\"\n+  [(set_attr \"type\" \"fp\")\n+   (set_attr \"cc\" \"compare\")])\n+\f\n+;; Branch insns.  Unsigned vs. signed have already\n+;; been taken care of.  The only insns that need to be concerned about the\n+;; test bit are beq and bne because the rest are either always true,\n+;; always false, or converted to EQ or NE.\n+\n+;; For conditional branches, we use `define_expand' and just have two patterns\n+;; that match them.  Operand printing does most of the work.\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\f\n+;; Define both directions of branch and return.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (restore_compare_p (operands[1]))\n+    return 0;\n+  else if (get_attr_length (insn) == 2)\n+    return \\\"j%j1 %l0\\\";\n+  else\n+    return \\\"b%j1%# %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (return)\n+\t\t      (pc)))]\n+  \"null_epilogue ()\"\n+  \"*\n+{\n+  if (restore_compare_p (operands[0]))\n+    return 0;\n+  else\n+    return \\\"b%j0r%# r15\\\";\n+}\"\n+  [(set_attr \"type\" \"return\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (restore_compare_p (operands[1]))\n+    return 0;\n+  else if (get_attr_length (insn) == 2)\n+    return \\\"j%J1 %l0\\\";\n+  else\n+    return \\\"b%J1%# %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (return)))]\n+  \"null_epilogue ()\"\n+  \"*\n+{\n+  if (restore_compare_p (operands[0]))\n+    return 0;\n+  else\n+    return \\\"b%J0r%# r15\\\";\n+}\"\n+  [(set_attr \"type\" \"return\")])\n+\n+;; Unconditional branch and return.\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"j %l0\\\";\n+  else\n+    return \\\"b%# %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"return\"\n+  [(return)]\n+  \"null_epilogue ()\"\n+  \"br%# r15\"\n+  [(set_attr \"type\" \"return\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"br%# %0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Table jump for switch statements:\n+(define_insn \"tablejump\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"br%# %0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"2\")])\n+\f\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}