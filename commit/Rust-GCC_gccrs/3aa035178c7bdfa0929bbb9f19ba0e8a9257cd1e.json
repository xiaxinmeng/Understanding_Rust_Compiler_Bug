{"sha": "3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhMDM1MTc4YzdiZGZhMDkyOWJiYjlmMTliYTBlOGE5MjU3Y2QxZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2013-01-18T10:57:36Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2013-01-18T10:57:36Z"}, "message": "re PR rtl-optimization/55547 (Alias analysis does not handle AND addresses correctly)\n\nPR rtl-optimization/55547\nPR rtl-optimization/53827\nPR debug/53671\nPR debug/49888\n* alias.c (offset_overlap_p): New, factored out of...\n(memrefs_conflict_p): ... this.  Use absolute sizes.  Retain\nthe conservative special case for symbolic constants.  Don't\nadjust zero sizes on alignment.\n\nFrom-SVN: r195289", "tree": {"sha": "2b024acfe15d6f6f0810bffc2284f1ac1df7c6b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b024acfe15d6f6f0810bffc2284f1ac1df7c6b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e/comments", "author": null, "committer": null, "parents": [{"sha": "c664546f0e9d12d8f3249b67982e0b192e112bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c664546f0e9d12d8f3249b67982e0b192e112bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c664546f0e9d12d8f3249b67982e0b192e112bef"}], "stats": {"total": 57, "additions": 39, "deletions": 18}, "files": [{"sha": "6eff629fe0b6aa637d15766673e13a0d5ea9c06d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "patch": "@@ -1,3 +1,14 @@\n+2013-01-18  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/55547\n+\tPR rtl-optimization/53827\n+\tPR debug/53671\n+\tPR debug/49888\n+\t* alias.c (offset_overlap_p): New, factored out of...\n+\t(memrefs_conflict_p): ... this.  Use absolute sizes.  Retain\n+\tthe conservative special case for symbolic constants.  Don't\n+\tadjust zero sizes on alignment.\n+\n 2013-01-18  Bernd Schmidt  <bernds@codesourcery.com>\n \n \tPR rtl-optimization/52573"}, {"sha": "f3cd014f089d09a39374b5b982d9a3b0059311bc", "filename": "gcc/alias.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3aa035178c7bdfa0929bbb9f19ba0e8a9257cd1e", "patch": "@@ -1904,6 +1904,20 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n   return addr;\n }\n \n+/* Return TRUE if an object X sized at XSIZE bytes and another object\n+   Y sized at YSIZE bytes, starting C bytes after X, may overlap.  If\n+   any of the sizes is zero, assume an overlap, otherwise use the\n+   absolute value of the sizes as the actual sizes.  */\n+\n+static inline bool\n+offset_overlap_p (HOST_WIDE_INT c, int xsize, int ysize)\n+{\n+  return (xsize == 0 || ysize == 0\n+\t  || (c >= 0\n+\t      ? (abs (xsize) > c)\n+\t      : (abs (ysize) > -c)));\n+}\n+\n /* Return one if X and Y (memory addresses) reference the\n    same location in memory or if the references overlap.\n    Return zero if they do not overlap, else return\n@@ -1976,23 +1990,17 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n   else if (GET_CODE (x) == LO_SUM)\n     x = XEXP (x, 1);\n   else\n-    x = addr_side_effect_eval (x, xsize, 0);\n+    x = addr_side_effect_eval (x, abs (xsize), 0);\n   if (GET_CODE (y) == HIGH)\n     y = XEXP (y, 0);\n   else if (GET_CODE (y) == LO_SUM)\n     y = XEXP (y, 1);\n   else\n-    y = addr_side_effect_eval (y, ysize, 0);\n+    y = addr_side_effect_eval (y, abs (ysize), 0);\n \n   if (rtx_equal_for_memref_p (x, y))\n     {\n-      if (xsize <= 0 || ysize <= 0)\n-\treturn 1;\n-      if (c >= 0 && xsize > c)\n-\treturn 1;\n-      if (c < 0 && ysize+c > 0)\n-\treturn 1;\n-      return 0;\n+      return offset_overlap_p (c, xsize, ysize);\n     }\n \n   /* This code used to check for conflicts involving stack references and\n@@ -2062,8 +2070,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t  x0 = canon_rtx (XEXP (x, 0));\n \t  y0 = canon_rtx (XEXP (y, 0));\n \t  if (rtx_equal_for_memref_p (x0, y0))\n-\t    return (xsize == 0 || ysize == 0\n-\t\t    || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n+\t    return offset_overlap_p (c, xsize, ysize);\n \n \t  /* Can't properly adjust our sizes.  */\n \t  if (!CONST_INT_P (x1))\n@@ -2093,7 +2100,8 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t{\n \t  if (xsize > 0)\n \t    xsize = -xsize;\n-\t  xsize += sc + 1;\n+\t  if (xsize)\n+\t    xsize += sc + 1;\n \t  c -= sc + 1;\n \t  return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n \t\t\t\t     ysize, y, c);\n@@ -2107,7 +2115,8 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t{\n \t  if (ysize > 0)\n \t    ysize = -ysize;\n-\t  ysize += sc + 1;\n+\t  if (ysize)\n+\t    ysize += sc + 1;\n \t  c += sc + 1;\n \t  return memrefs_conflict_p (xsize, x,\n \t\t\t\t     ysize, canon_rtx (XEXP (y, 0)), c);\n@@ -2119,8 +2128,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       if (CONST_INT_P (x) && CONST_INT_P (y))\n \t{\n \t  c += (INTVAL (y) - INTVAL (x));\n-\t  return (xsize <= 0 || ysize <= 0\n-\t\t  || (c >= 0 && xsize > c) || (c < 0 && ysize+c > 0));\n+\t  return offset_overlap_p (c, xsize, ysize);\n \t}\n \n       if (GET_CODE (x) == CONST)\n@@ -2136,10 +2144,12 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \treturn memrefs_conflict_p (xsize, x, ysize,\n \t\t\t\t   canon_rtx (XEXP (y, 0)), c);\n \n+      /* Assume a potential overlap for symbolic addresses that went\n+\t through alignment adjustments (i.e., that have negative\n+\t sizes), because we can't know how far they are from each\n+\t other.  */\n       if (CONSTANT_P (y))\n-\treturn (xsize <= 0 || ysize <= 0\n-\t\t|| (rtx_equal_for_memref_p (x, y)\n-\t\t    && ((c >= 0 && xsize > c) || (c < 0 && ysize+c > 0))));\n+\treturn (xsize < 0 || ysize < 0 || offset_overlap_p (c, xsize, ysize));\n \n       return -1;\n     }"}]}