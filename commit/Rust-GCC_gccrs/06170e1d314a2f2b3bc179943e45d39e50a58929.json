{"sha": "06170e1d314a2f2b3bc179943e45d39e50a58929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxNzBlMWQzMTRhMmYyYjNiYzE3OTk0M2U0NWQzOWU1MGE1ODkyOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-12-29T19:21:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-12-29T19:21:07Z"}, "message": "tree-outof-ssa.c (insert_backedge_copies): New function.\n\n        * tree-outof-ssa.c (insert_backedge_copies): New function.\n        (rewrite_out_of_ssa): Use it.\n\nFrom-SVN: r92711", "tree": {"sha": "3393581eba86088a1c6fee0f538c7d87833c2e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3393581eba86088a1c6fee0f538c7d87833c2e92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06170e1d314a2f2b3bc179943e45d39e50a58929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06170e1d314a2f2b3bc179943e45d39e50a58929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06170e1d314a2f2b3bc179943e45d39e50a58929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06170e1d314a2f2b3bc179943e45d39e50a58929/comments", "author": null, "committer": null, "parents": [{"sha": "263db5562a10538d65228c821f44cea0b9d9650f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/263db5562a10538d65228c821f44cea0b9d9650f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/263db5562a10538d65228c821f44cea0b9d9650f"}], "stats": {"total": 102, "additions": 102, "deletions": 0}, "files": [{"sha": "6e071508532d90b57677eca1fecbd28d9688d4fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06170e1d314a2f2b3bc179943e45d39e50a58929/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06170e1d314a2f2b3bc179943e45d39e50a58929/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06170e1d314a2f2b3bc179943e45d39e50a58929", "patch": "@@ -1,3 +1,8 @@\n+2004-12-29  Jeff Law  <law@redhat.com>\n+\n+\t* tree-outof-ssa.c (insert_backedge_copies): New function.\n+\t(rewrite_out_of_ssa): Use it.\n+\n 2004-12-29  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/18179"}, {"sha": "ecd23ede219c1ccaf4d5d65a3cd3c545ed576282", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06170e1d314a2f2b3bc179943e45d39e50a58929/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06170e1d314a2f2b3bc179943e45d39e50a58929/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=06170e1d314a2f2b3bc179943e45d39e50a58929", "patch": "@@ -2362,6 +2362,95 @@ remove_ssa_form (FILE *dump, var_map map, int flags)\n   dump_file = save;\n }\n \n+/* Search every PHI node for arguments associated with backedges which\n+   we can trivially determine will need a copy (the argument is either\n+   not an SSA_NAME or the argument has a different underlying variable\n+   than the PHI result).\n+\n+   Insert a copy from the PHI argument to a new destination at the\n+   end of the block with the backedge to the top of the loop.  Update\n+   the PHI argument to reference this new destination.  */\n+\n+static void\n+insert_backedge_copies (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  tree result = PHI_RESULT (phi);\n+\t  tree result_var;\n+\t  int i;\n+\n+\t  if (!is_gimple_reg (result))\n+\t    continue;\n+\n+\t  result_var = SSA_NAME_VAR (result);\n+\t  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+\t    {\n+\t      tree arg = PHI_ARG_DEF (phi, i);\n+\t      edge e = PHI_ARG_EDGE (phi, i);\n+\n+\t      /* If the argument is not an SSA_NAME, then we will\n+\t\t need a constant initialization.  If the argument is\n+\t\t an SSA_NAME with a different underlying variable and\n+\t\t we are not combining temporaries, then we will\n+\t\t need a copy statement.  */\n+\t      if ((e->flags & EDGE_DFS_BACK)\n+\t\t  && (TREE_CODE (arg) != SSA_NAME\n+\t\t      || (!flag_tree_combine_temps\n+\t\t\t  && SSA_NAME_VAR (arg) != result_var)))\n+\t\t{\n+\t\t  tree stmt, name, last = NULL;\n+\t\t  block_stmt_iterator bsi;\n+\n+\t\t  bsi = bsi_last (PHI_ARG_EDGE (phi, i)->src);\n+\t\t  if (!bsi_end_p (bsi))\n+\t\t    last = bsi_stmt (bsi);\n+\n+\t\t  /* In theory the only way we ought to get back to the\n+\t\t     start of a loop should be with a COND_EXPR or GOTO_EXPR.\n+\t\t     However, better safe than sorry. \n+\n+\t\t     If the block ends with a control statment or\n+\t\t     something that might throw, then we have to\n+\t\t     insert this assignment before the last\n+\t\t     statement.  Else insert it after the last statement.  */\n+\t\t  if (last && stmt_ends_bb_p (last))\n+\t\t    {\n+\t\t      /* If the last statement in the block is the definition\n+\t\t\t site of the PHI argument, then we can't insert\n+\t\t\t anything after it.  */\n+\t\t      if (TREE_CODE (arg) == SSA_NAME\n+\t\t\t  && SSA_NAME_DEF_STMT (arg) == last)\n+\t\t\tcontinue;\n+\t\t    }\n+\n+\t\t  /* Create a new instance of the underlying\n+\t\t     variable of the PHI result.  */\n+\t\t  stmt = build (MODIFY_EXPR, TREE_TYPE (result_var),\n+\t\t\t\tNULL, PHI_ARG_DEF (phi, i));\n+\t\t  name = make_ssa_name (result_var, stmt);\n+\t\t  TREE_OPERAND (stmt, 0) = name;\n+\n+\t\t  /* Insert the new statement into the block and update\n+\t\t     the PHI node.  */\n+\t\t  if (last && stmt_ends_bb_p (last))\n+\t\t    bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n+\t\t  else\n+\t\t    bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+\t\t  modify_stmt (stmt);\n+\t\t  SET_PHI_ARG_DEF (phi, i, name);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Take the current function out of SSA form, as described in\n    R. Morgan, ``Building an Optimizing Compiler'',\n    Butterworth-Heinemann, Boston, MA, 1998. pp 176-186.  */\n@@ -2373,6 +2462,14 @@ rewrite_out_of_ssa (void)\n   int var_flags = 0;\n   int ssa_flags = (SSANORM_REMOVE_ALL_PHIS | SSANORM_USE_COALESCE_LIST);\n \n+  /* If elimination of a PHI requires inserting a copy on a backedge,\n+     then we will have to split the backedge which has numerous\n+     undesirable performance effects.\n+\n+     A significant number of such cases can be handled here by inserting\n+     copies into the loop itself.  */\n+  insert_backedge_copies ();\n+\n   if (!flag_tree_live_range_split)\n     ssa_flags |= SSANORM_COALESCE_PARTITIONS;\n     "}]}