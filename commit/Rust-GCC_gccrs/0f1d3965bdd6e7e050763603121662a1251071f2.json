{"sha": "0f1d3965bdd6e7e050763603121662a1251071f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYxZDM5NjViZGQ2ZTdlMDUwNzYzNjAzMTIxNjYyYTEyNTEwNzFmMg==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "yuri.s.rumyantsev@intel.com", "date": "2013-06-03T17:20:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-06-03T17:20:02Z"}, "message": "i386.c (ix86_lea_outperforms): Fix formatting.\n\n\t* config/i386/i386.c (ix86_lea_outperforms): Fix formatting.\n\t(ix86_avoid_lea_for_addr): Likewise.\n\t(exact_dependency_1): Likewise.\n\t(ix86_adjust_cost): Likewise.\n\t(swap_top_of_ready_list): Fix formatting and !reload_completed check\n\tremoved.\n\t(do_reorder_for_imul): Fix typo, formatting and\n\t!reload_completed check removed.\n\t(ix86_sched_reorder): Fix typo and formatting.\n\t(fold_builtin_cpu): Move M_INTEL_SLM at the end of processor types\n\tlist.\n\n\t* config/i386/cpuinfo.c (INTEL_SLM): New enum value.\n\nFrom-SVN: r199611", "tree": {"sha": "2e78fc64ddae2f4822b4aac4c73a60017b418308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e78fc64ddae2f4822b4aac4c73a60017b418308"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1d3965bdd6e7e050763603121662a1251071f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1d3965bdd6e7e050763603121662a1251071f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1d3965bdd6e7e050763603121662a1251071f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1d3965bdd6e7e050763603121662a1251071f2/comments", "author": null, "committer": null, "parents": [{"sha": "3bc30db4f11f5c821fa7f22aece11a04591cb68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc30db4f11f5c821fa7f22aece11a04591cb68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc30db4f11f5c821fa7f22aece11a04591cb68a"}], "stats": {"total": 264, "additions": 138, "deletions": 126}, "files": [{"sha": "d39bddc03b0bd6e8f8016d64d0471f069705a5ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -1,3 +1,17 @@\n+2013-06-03  Yuri Rumyantsev  <yuri.s.rumyantsev@intel.com>\n+\n+\t* config/i386/i386.c (ix86_lea_outperforms): Fix formatting.\n+\t(ix86_avoid_lea_for_addr): Likewise.\n+\t(exact_dependency_1): Likewise.\n+\t(ix86_adjust_cost): Likewise.\n+\t(swap_top_of_ready_list): Fix formatting and !reload_completed check\n+\tremoved.\n+\t(do_reorder_for_imul): Fix typo, formatting and\n+\t!reload_completed check removed.\n+\t(ix86_sched_reorder): Fix typo and formatting.\n+\t(fold_builtin_cpu): Move M_INTEL_SLM at the end of processor types\n+\tlist.\n+\n 2013-06-03  Sofiane Naci  <sofiane.naci@arm.com>\n \n \t* config/aarch64/aarch64.md (*movdi_aarch64): Define \"simd\" attribute.\n@@ -269,8 +283,6 @@\n \t* config/i386/i386.md (cpu): Add new value \"slm\".\n \t(slm.md): Include slm.md.\n \n-\t* libgcc/config/i386/cpuinfo.c (INTEL_SLM): New enum value.\n-\n 2013-05-30  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n "}, {"sha": "77962c14521db704c52743e1b4d6e8845cb9fe47", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 112, "deletions": 118, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -17407,11 +17407,11 @@ ix86_lea_outperforms (rtx insn, unsigned int regno0, unsigned int regno1,\n   if (ix86_tune == PROCESSOR_SLM)\n     {\n       if (has_scale)\n-        return true;\n+\treturn true;\n       if (split_cost < 1)\n-        return false;\n+\treturn false;\n       if (regno0 == regno1 || regno0 == regno2)\n-        return false;\n+\treturn false;\n       return true;\n     }\n \n@@ -17605,7 +17605,7 @@ ix86_avoid_lea_for_addr (rtx insn, rtx operands[])\n     }\n \n   return !ix86_lea_outperforms (insn, regno0, regno1, regno2, split_cost,\n-                                parts.scale > 1);\n+\t\t\t\tparts.scale > 1);\n }\n \n /* Emit x86 binary operand CODE in mode MODE, where the first operand\n@@ -24402,7 +24402,7 @@ exact_dependency_1 (rtx addr, rtx insn)\n     {\n     case MEM:\n       if (rtx_equal_p (addr, insn))\n-        return true;\n+\treturn true;\n       break;\n     case REG:\n     CASE_CONST_ANY:\n@@ -24420,17 +24420,17 @@ exact_dependency_1 (rtx addr, rtx insn)\n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     {\n       switch (*format_ptr++)\n-       {\n-       case 'e':\n-         if (exact_dependency_1 (addr, XEXP (insn, i)))\n-           return true;\n-         break;\n-       case 'E':\n-         for (j = 0; j < XVECLEN (insn, i); j++)\n-           if (exact_dependency_1 (addr, XVECEXP (insn, i, j)))\n-             return true;\n-         break;\n-       }\n+\t{\n+\tcase 'e':\n+\t  if (exact_dependency_1 (addr, XEXP (insn, i)))\n+\t    return true;\n+\t  break;\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (insn, i); j++)\n+\t    if (exact_dependency_1 (addr, XVECEXP (insn, i, j)))\n+\t      return true;\n+\t    break;\n+\t}\n     }\n   return false;\n }\n@@ -24610,35 +24610,35 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n     case PROCESSOR_SLM:\n       if (!reload_completed)\n-        return cost;\n+\treturn cost;\n \n       /* Increase cost of integer loads.  */\n       memory = get_attr_memory (dep_insn);\n       if (memory == MEMORY_LOAD || memory == MEMORY_BOTH)\n-        {\n-          enum attr_unit unit = get_attr_unit (dep_insn);\n-          if (unit == UNIT_INTEGER && cost == 1)\n-            {\n-              if (memory == MEMORY_LOAD)\n-                cost = 3;\n-              else\n-                {\n-                  /* Increase cost of ld/st for short int types only\n-                     because of store forwarding issue.  */\n-                  rtx set = single_set (dep_insn);\n-                  if (set && (GET_MODE (SET_DEST (set)) == QImode\n-                              || GET_MODE (SET_DEST (set)) == HImode))\n-                    {\n-                      /* Increase cost of store/load insn if exact\n-                         dependence exists and it is load insn.  */\n-                      enum attr_memory insn_memory = get_attr_memory (insn);\n-                      if (insn_memory == MEMORY_LOAD\n-                          && exact_store_load_dependency (dep_insn, insn))\n-                        cost = 3;\n-                    }\n-                }\n-            }\n-        }\n+\t{\n+\t  enum attr_unit unit = get_attr_unit (dep_insn);\n+\t  if (unit == UNIT_INTEGER && cost == 1)\n+\t    {\n+\t      if (memory == MEMORY_LOAD)\n+\t\tcost = 3;\n+\t      else\n+\t\t{\n+\t\t  /* Increase cost of ld/st for short int types only\n+\t\t     because of store forwarding issue.  */\n+\t\t  rtx set = single_set (dep_insn);\n+\t\t  if (set && (GET_MODE (SET_DEST (set)) == QImode\n+\t\t\t      || GET_MODE (SET_DEST (set)) == HImode))\n+\t\t    {\n+\t\t      /* Increase cost of store/load insn if exact\n+\t\t\t dependence exists and it is load insn.  */\n+\t\t      enum attr_memory insn_memory = get_attr_memory (insn);\n+\t\t      if (insn_memory == MEMORY_LOAD\n+\t\t\t  && exact_store_load_dependency (dep_insn, insn))\n+\t\t\tcost = 3;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n \n     default:\n       break;\n@@ -24688,7 +24688,7 @@ ia32_multipass_dfa_lookahead (void)\n        ready list.\n    Return index of IMUL producer if it was found and -1 otherwise.  */\n static int\n-do_reoder_for_imul(rtx *ready, int n_ready)\n+do_reorder_for_imul (rtx *ready, int n_ready)\n {\n   rtx insn, set, insn1, insn2;\n   sd_iterator_def sd_it;\n@@ -24699,10 +24699,6 @@ do_reoder_for_imul(rtx *ready, int n_ready)\n   if (ix86_tune != PROCESSOR_ATOM)\n     return index;\n \n-  /* Do not perform ready list reodering for pre-reload schedule pass.  */\n-  if (!reload_completed)\n-    return index;\n-\n   /* Check that IMUL instruction is on the top of ready list.  */\n   insn = ready[n_ready - 1];\n   set = single_set (insn);\n@@ -24713,53 +24709,53 @@ do_reoder_for_imul(rtx *ready, int n_ready)\n     return index;\n \n   /* Search for producer of independent IMUL instruction.  */\n-  for (i = n_ready - 2; i>= 0; i--)\n+  for (i = n_ready - 2; i >= 0; i--)\n     {\n       insn = ready[i];\n       if (!NONDEBUG_INSN_P (insn))\n-        continue;\n+\tcontinue;\n       /* Skip IMUL instruction.  */\n       insn2 = PATTERN (insn);\n       if (GET_CODE (insn2) == PARALLEL)\n-        insn2 = XVECEXP (insn2, 0, 0);\n+\tinsn2 = XVECEXP (insn2, 0, 0);\n       if (GET_CODE (insn2) == SET\n-          && GET_CODE (SET_SRC (insn2)) == MULT\n-          && GET_MODE (SET_SRC (insn2)) == SImode)\n-        continue;\n+\t  && GET_CODE (SET_SRC (insn2)) == MULT\n+\t  && GET_MODE (SET_SRC (insn2)) == SImode)\n+\tcontinue;\n \n       FOR_EACH_DEP (insn, SD_LIST_FORW, sd_it, dep)\n-        {\n-          rtx con;\n+\t{\n+\t  rtx con;\n \t  con = DEP_CON (dep);\n \t  if (!NONDEBUG_INSN_P (con))\n \t    continue;\n-          insn1 = PATTERN (con);\n-          if (GET_CODE (insn1) == PARALLEL)\n-            insn1 = XVECEXP (insn1, 0, 0);\n-\n-          if (GET_CODE (insn1) == SET\n-              && GET_CODE (SET_SRC (insn1)) == MULT\n-              && GET_MODE (SET_SRC (insn1)) == SImode)\n-            {\n-              sd_iterator_def sd_it1;\n-              dep_t dep1;\n-              /* Check if there is no other dependee for IMUL.  */\n-              index = i;\n-              FOR_EACH_DEP (con, SD_LIST_BACK, sd_it1, dep1)\n-                {\n-                  rtx pro;\n-                  pro = DEP_PRO (dep1);\n+\t  insn1 = PATTERN (con);\n+\t  if (GET_CODE (insn1) == PARALLEL)\n+\t    insn1 = XVECEXP (insn1, 0, 0);\n+\n+\t  if (GET_CODE (insn1) == SET\n+\t      && GET_CODE (SET_SRC (insn1)) == MULT\n+\t      && GET_MODE (SET_SRC (insn1)) == SImode)\n+\t    {\n+\t      sd_iterator_def sd_it1;\n+\t      dep_t dep1;\n+\t      /* Check if there is no other dependee for IMUL.  */\n+\t      index = i;\n+\t      FOR_EACH_DEP (con, SD_LIST_BACK, sd_it1, dep1)\n+\t\t{\n+\t\t  rtx pro;\n+\t\t  pro = DEP_PRO (dep1);\n \t\t  if (!NONDEBUG_INSN_P (pro))\n \t\t    continue;\n-                  if (pro != insn)\n-                    index = -1;\n-                }\n-              if (index >= 0)\n-                break;\n-            }\n-        }\n+\t\t  if (pro != insn)\n+\t\t    index = -1;\n+\t\t}\n+\t      if (index >= 0)\n+\t\tbreak;\n+\t    }\n+\t}\n       if (index >= 0)\n-        break;\n+\tbreak;\n     }\n   return index;\n }\n@@ -24769,7 +24765,7 @@ do_reoder_for_imul(rtx *ready, int n_ready)\n    scheduled earlier. Applied for Silvermont only.\n    Return true if top 2 insns must be interchanged.  */\n static bool\n-swap_top_of_ready_list(rtx *ready, int n_ready)\n+swap_top_of_ready_list (rtx *ready, int n_ready)\n {\n   rtx top = ready[n_ready - 1];\n   rtx next = ready[n_ready - 2];\n@@ -24782,8 +24778,6 @@ swap_top_of_ready_list(rtx *ready, int n_ready)\n \n   if (ix86_tune != PROCESSOR_SLM)\n     return false;\n-  if (!reload_completed)\n-    return false;\n \n   if (!NONDEBUG_INSN_P (top))\n     return false;\n@@ -24803,37 +24797,37 @@ swap_top_of_ready_list(rtx *ready, int n_ready)\n   if (INSN_PRIORITY_KNOWN (top) && INSN_PRIORITY_KNOWN (next))\n     {\n       if (INSN_PRIORITY (top) != INSN_PRIORITY (next))\n-        return false;\n+\treturn false;\n       /* Determine winner more precise.  */\n       FOR_EACH_DEP (top, SD_LIST_RES_BACK, sd_it, dep)\n-        {\n-          rtx pro;\n-          pro = DEP_PRO (dep);\n-          if (!NONDEBUG_INSN_P (pro))\n-            continue;\n-          if (INSN_TICK (pro) > clock1)\n-            clock1 = INSN_TICK (pro);\n-        }\n+\t{\n+\t  rtx pro;\n+\t  pro = DEP_PRO (dep);\n+\t  if (!NONDEBUG_INSN_P (pro))\n+\t    continue;\n+\t  if (INSN_TICK (pro) > clock1)\n+\t    clock1 = INSN_TICK (pro);\n+\t}\n       FOR_EACH_DEP (next, SD_LIST_RES_BACK, sd_it, dep)\n-        {\n-          rtx pro;\n-          pro = DEP_PRO (dep);\n-          if (!NONDEBUG_INSN_P (pro))\n-            continue;\n-          if (INSN_TICK (pro) > clock2)\n-            clock2 = INSN_TICK (pro);\n-        }\n+\t{\n+\t  rtx pro;\n+\t  pro = DEP_PRO (dep);\n+\t  if (!NONDEBUG_INSN_P (pro))\n+\t    continue;\n+\t  if (INSN_TICK (pro) > clock2)\n+\t    clock2 = INSN_TICK (pro);\n+\t}\n \n       if (clock1 == clock2)\n-      {\n-        /* Determine winner - load must win. */\n-        enum attr_memory memory1, memory2;\n-        memory1 = get_attr_memory (top);\n-        memory2 = get_attr_memory (next);\n-        if (memory2 == MEMORY_LOAD && memory1 != MEMORY_LOAD)\n-          return true;\n-      }\n-      return (bool) (clock2 < clock1);\n+\t{\n+\t  /* Determine winner - load must win. */\n+\t  enum attr_memory memory1, memory2;\n+\t  memory1 = get_attr_memory (top);\n+\t  memory2 = get_attr_memory (next);\n+\t  if (memory2 == MEMORY_LOAD && memory1 != MEMORY_LOAD)\n+\t    return true;\n+\t}\n+\treturn (bool) (clock2 < clock1);\n     }\n   return false;\n   #undef INSN_TICK\n@@ -24842,8 +24836,8 @@ swap_top_of_ready_list(rtx *ready, int n_ready)\n /* Perform possible reodering of ready list for Atom/Silvermont only.\n    Return issue rate.  */\n static int\n-ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n-                   int clock_var)\n+ix86_sched_reorder (FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n+\t\t   int clock_var)\n {\n   int issue_rate = -1;\n   int n_ready = *pn_ready;\n@@ -24852,7 +24846,7 @@ ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n   int index = -1;\n \n   /* Set up issue rate.  */\n-  issue_rate = ix86_issue_rate();\n+  issue_rate = ix86_issue_rate ();\n \n   /* Do reodering for Atom/SLM only.  */\n   if (ix86_tune != PROCESSOR_ATOM && ix86_tune != PROCESSOR_SLM)\n@@ -24866,24 +24860,24 @@ ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n   if (!reload_completed)\n     return issue_rate;\n \n-  if ((index = do_reoder_for_imul (ready, n_ready)) >= 0)\n+  if ((index = do_reorder_for_imul (ready, n_ready)) >= 0)\n     {\n       if (sched_verbose > 1)\n-        fprintf(dump, \";;\\tatom sched_reorder: put %d insn on top\\n\",\n-                INSN_UID (ready[index]));\n+\tfprintf (dump, \";;\\tatom sched_reorder: put %d insn on top\\n\",\n+\t\t INSN_UID (ready[index]));\n \n       /* Put IMUL producer (ready[index]) at the top of ready list.  */\n-      insn= ready[index];\n+      insn = ready[index];\n       for (i = index; i < n_ready - 1; i++)\n-        ready[i] = ready[i + 1];\n+\tready[i] = ready[i + 1];\n       ready[n_ready - 1] = insn;\n       return issue_rate;\n     }\n   if (clock_var != 0 && swap_top_of_ready_list (ready, n_ready))\n     {\n       if (sched_verbose > 1)\n-        fprintf(dump, \";;\\tslm sched_reorder: swap %d and %d insns\\n\",\n-                INSN_UID (ready[n_ready - 1]), INSN_UID (ready[n_ready - 2]));\n+\tfprintf (dump, \";;\\tslm sched_reorder: swap %d and %d insns\\n\",\n+\t\t INSN_UID (ready[n_ready - 1]), INSN_UID (ready[n_ready - 2]));\n       /* Swap 2 top elements of ready list.  */\n       insn = ready[n_ready - 1];\n       ready[n_ready - 1] = ready[n_ready - 2];\n@@ -30054,11 +30048,11 @@ fold_builtin_cpu (tree fndecl, tree *args)\n     M_AMD,\n     M_CPU_TYPE_START,\n     M_INTEL_ATOM,\n-    M_INTEL_SLM,\n     M_INTEL_CORE2,\n     M_INTEL_COREI7,\n     M_AMDFAM10H,\n     M_AMDFAM15H,\n+    M_INTEL_SLM,\n     M_CPU_SUBTYPE_START,\n     M_INTEL_COREI7_NEHALEM,\n     M_INTEL_COREI7_WESTMERE,"}, {"sha": "5dcd69f621d2128c7f6fac18e3e9cdb7ff2cd5d1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -445,7 +445,7 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n #define TARGET_AVOID_MEM_OPND_FOR_CMOVE \\\n \tix86_tune_features[X86_TUNE_AVOID_MEM_OPND_FOR_CMOVE]\n #define TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS \\\n-        ix86_tune_features[X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS]\n+\tix86_tune_features[X86_TUNE_SPLIT_MEM_OPND_FOR_FP_CONVERTS]\n \n /* Feature tests against the various architecture variations.  */\n enum ix86_arch_indices {"}, {"sha": "018678dc850292d761d7039dff6728b12cfa356d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -3628,8 +3628,8 @@\n ;; It's more profitable to split and then extend in the same register.\n (define_peephole2\n   [(set (match_operand:DF 0 \"register_operand\")\n-        (float_extend:DF\n-          (match_operand:SF 1 \"memory_operand\")))]\n+\t(float_extend:DF\n+\t  (match_operand:SF 1 \"memory_operand\")))]\n   \"TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS\n    && optimize_insn_for_speed_p ()\n    && SSE_REG_P (operands[0])\"\n@@ -3781,8 +3781,8 @@\n ;; It's more profitable to split and then extend in the same register.\n (define_peephole2\n   [(set (match_operand:SF 0 \"register_operand\")\n-        (float_truncate:SF\n-          (match_operand:DF 1 \"memory_operand\")))]\n+\t(float_truncate:SF\n+\t  (match_operand:DF 1 \"memory_operand\")))]\n   \"TARGET_SPLIT_MEM_OPND_FOR_FP_CONVERTS\n    && optimize_insn_for_speed_p ()\n    && SSE_REG_P (operands[0])\""}, {"sha": "04e2aaebc181f05d61b05ffc664a59570212b4d1", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -1,3 +1,7 @@\n+2013-06-03  Yuri Rumyantsev  <yuri.s.rumyantsev@intel.com>\n+\n+\t* config/i386/cpuinfo.c (INTEL_SLM): New enum value.\n+\n 2013-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sol2-unwind.h (MD_FALLBACK_FRAME_STATE_FOR): Do not set"}, {"sha": "b7e64c3d720a8279b188a84de1aabc8c91d90984", "filename": "libgcc/config/i386/cpuinfo.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1d3965bdd6e7e050763603121662a1251071f2/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1d3965bdd6e7e050763603121662a1251071f2/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c?ref=0f1d3965bdd6e7e050763603121662a1251071f2", "patch": "@@ -47,14 +47,16 @@ enum processor_vendor\n   VENDOR_MAX\n };\n \n+/* Any new types or subtypes have to be inserted at the end. */\n+\n enum processor_types\n {\n   INTEL_ATOM = 1,\n-  INTEL_SLM,\n   INTEL_CORE2,\n   INTEL_COREI7,\n   AMDFAM10H,\n   AMDFAM15H,\n+  INTEL_SLM,\n   CPU_TYPE_MAX\n };\n "}]}