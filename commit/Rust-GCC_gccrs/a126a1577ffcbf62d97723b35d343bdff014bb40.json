{"sha": "a126a1577ffcbf62d97723b35d343bdff014bb40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEyNmExNTc3ZmZjYmY2MmQ5NzcyM2IzNWQzNDNiZGZmMDE0YmI0MA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-14T19:37:12Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-04-14T19:44:01Z"}, "message": "coroutines: Fix compile error with symmetric transfers [PR94359]\n\nFor symmetric transfers to work with C++20 coroutines, it is\ncurrently necessary to tail call the callee coroutine from resume\nmethod of the caller coroutine. The current codegen marks these\nresume calls as \"MUST_TAIL_CALL\" to indicate that the tail call is\nrequired for correctness.\n\nUnfortunately, several targets have ABI constraints that prevent\nan indirect tail-call, which results in the PRs compile error.\n\nThe change here tests the target sibcall hook for the resume\nexpression and only marks it as requiring a tail call if that's\nsupported.\n\nThis doesn't fix the underlying problem; that really a solution is\nneeded to allow the tail-calls (or equivalent) to take place - but\nthat will be deferred until next stage 1.\n\ngcc/cp/ChangeLog:\n\n2020-04-14  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94359\n\t* coroutines.cc (build_actor_fn): Check that the target can\n\tsupport the resume tailcall before mandating it.\n\ngcc/testsuite/ChangeLog:\n\n2020-04-14  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR c++/94359\n\t* g++.dg/coroutines/torture/symmetric-transfer-00-basic.C:\n\tExpect a run fail for targets without arbitrary indirect\n\ttail-calls.", "tree": {"sha": "b46f6c8e2e85b8ec56e92db98944b333edbd04ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b46f6c8e2e85b8ec56e92db98944b333edbd04ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a126a1577ffcbf62d97723b35d343bdff014bb40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a126a1577ffcbf62d97723b35d343bdff014bb40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a126a1577ffcbf62d97723b35d343bdff014bb40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a126a1577ffcbf62d97723b35d343bdff014bb40/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa9a57ed91deb57d43fc25891d88867258e06795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9a57ed91deb57d43fc25891d88867258e06795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9a57ed91deb57d43fc25891d88867258e06795"}], "stats": {"total": 43, "additions": 35, "deletions": 8}, "files": [{"sha": "4547674190e13d5f4488c2b07d8466397577d053", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a126a1577ffcbf62d97723b35d343bdff014bb40", "patch": "@@ -1,3 +1,9 @@\n+2020-04-14  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94359\n+\t* coroutines.cc (build_actor_fn): Check that the target can\n+\tsupport the resume tailcall before mandating it.\n+\n 2020-04-14  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/85278"}, {"sha": "e4ba642d527a0ba531dfff20a087ef244bbeb77f", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=a126a1577ffcbf62d97723b35d343bdff014bb40", "patch": "@@ -2376,14 +2376,22 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree resume = build_call_expr_loc\n     (loc, builtin_decl_explicit (BUILT_IN_CORO_RESUME), 1, addr);\n \n+  /* In order to support an arbitrary number of coroutine continuations,\n+     we must tail call them.  However, some targets might not support this\n+     for indirect calls, or calls between DSOs.\n+     FIXME: see if there's an alternate strategy for such targets.  */\n   /* Now we have the actual call, and we can mark it as a tail.  */\n   CALL_EXPR_TAILCALL (resume) = true;\n-  /* ... and for optimisation levels 0..1, mark it as requiring a tail-call\n-     for correctness.  It seems that doing this for optimisation levels that\n-     normally perform tail-calling, confuses the ME (or it would be logical\n-     to put this on unilaterally).  */\n-  if (optimize < 2)\n-    CALL_EXPR_MUST_TAIL_CALL (resume) = true;\n+  /* Temporarily, switch cfun so that we can use the target hook.  */\n+  push_struct_function (actor);\n+  if (targetm.function_ok_for_sibcall (NULL_TREE, resume))\n+    {\n+      /* ... and for optimisation levels 0..1, which do not normally tail-\n+\t-call, mark it as requiring a tail-call for correctness.  */\n+      if (optimize < 2)\n+\tCALL_EXPR_MUST_TAIL_CALL (resume) = true;\n+    }\n+  pop_cfun ();\n   resume = coro_build_cvt_void_expr_stmt (resume, loc);\n   add_stmt (resume);\n \n@@ -3951,7 +3959,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   push_deferring_access_checks (dk_no_check);\n \n-  /* Actor ...  */\n+  /* Build the actor...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n \t\t  &local_var_uses, param_dtor_list, initial_await, final_await,\n \t\t  body_aw_points.await_number, frame_size);"}, {"sha": "3a3a1c5946512b2c9c87caa80b493d4408c2cb9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a126a1577ffcbf62d97723b35d343bdff014bb40", "patch": "@@ -1,3 +1,10 @@\n+2020-04-14  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/94359\n+\t* g++.dg/coroutines/torture/symmetric-transfer-00-basic.C:\n+\tExpect a run fail for targets without arbitrary indirect\n+\ttail-calls.\n+\n 2020-04-14  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/93207"}, {"sha": "6f379c8e77ae0e18b769c4e1ae8e9cb551f24647", "filename": "gcc/testsuite/g++.dg/coroutines/torture/symmetric-transfer-00-basic.C", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a126a1577ffcbf62d97723b35d343bdff014bb40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C?ref=a126a1577ffcbf62d97723b35d343bdff014bb40", "patch": "@@ -1,4 +1,10 @@\n-//  { dg-do run }\n+// { dg-do run }\n+// See PR94359 - some targets are unable to make general indirect tailcalls\n+// for example, between different DSOs.\n+// { dg-xfail-run-if \"\" { hppa*-*-hpux11* } }\n+// { dg-xfail-run-if \"\" { ia64-*-linux-gnu } }\n+// { dg-xfail-run-if \"\" { { lp64 && { powerpc*-linux-gnu } } || { *-*-aix* } } }\n+// { dg-xfail-run-if \"\" { sparc*-*-* } }\n \n #if __has_include(<coroutine>)\n "}]}