{"sha": "92efc019ed9fc057bec55149aff7fe8c261f0d85", "node_id": "C_kwDOANBUbNoAKDkyZWZjMDE5ZWQ5ZmMwNTdiZWM1NTE0OWFmZjdmZThjMjYxZjBkODU", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T16:36:45Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T17:37:46Z"}, "message": "ifcvt: Run second pass if it is possible to omit a temporary.\n\nIf one of the to-be-converted SETs requires the original comparison\n(i.e. in order to generate a min/max insn) but no other insn after it\ndoes, we can omit creating temporaries, thus facilitating costing.\n\ngcc/ChangeLog:\n\n\t* ifcvt.cc (noce_convert_multiple_sets_1): New function.\n\t(noce_convert_multiple_sets): Call function a second time if we can\n\timprove the first try.", "tree": {"sha": "4b0fc0f4367989a1ad130f15c773602c44247b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b0fc0f4367989a1ad130f15c773602c44247b9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92efc019ed9fc057bec55149aff7fe8c261f0d85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92efc019ed9fc057bec55149aff7fe8c261f0d85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92efc019ed9fc057bec55149aff7fe8c261f0d85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92efc019ed9fc057bec55149aff7fe8c261f0d85/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d249933e6b46e05595fe4208da530c790b677ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d249933e6b46e05595fe4208da530c790b677ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d249933e6b46e05595fe4208da530c790b677ac0"}], "stats": {"total": 225, "additions": 150, "deletions": 75}, "files": [{"sha": "fe250d508e10267ad72f364b4210842d890fa3c8", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 150, "deletions": 75, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92efc019ed9fc057bec55149aff7fe8c261f0d85/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92efc019ed9fc057bec55149aff7fe8c261f0d85/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=92efc019ed9fc057bec55149aff7fe8c261f0d85", "patch": "@@ -100,6 +100,12 @@ static void noce_emit_move_insn (rtx, rtx);\n static rtx_insn *block_has_only_trap (basic_block);\n static void need_cmov_or_rewire (basic_block, hash_set<rtx_insn *> *,\n \t\t\t\t hash_map<rtx_insn *, int> *);\n+static bool noce_convert_multiple_sets_1 (struct noce_if_info *,\n+\t\t\t\t\t  hash_set<rtx_insn *> *,\n+\t\t\t\t\t  hash_map<rtx_insn *, int> *,\n+\t\t\t\t\t  auto_vec<rtx> *,\n+\t\t\t\t\t  auto_vec<rtx> *,\n+\t\t\t\t\t  auto_vec<rtx_insn *> *, int *);\n \f\n /* Count the number of non-jump active insns in BB.  */\n \n@@ -3256,23 +3262,146 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   rtx x = XEXP (cond, 0);\n   rtx y = XEXP (cond, 1);\n \n-  rtx cc_cmp = cond_exec_get_condition (jump);\n-  rtx rev_cc_cmp = cond_exec_get_condition (jump, /* get_reversed */ true);\n-\n   /* The true targets for a conditional move.  */\n   auto_vec<rtx> targets;\n   /* The temporaries introduced to allow us to not consider register\n      overlap.  */\n   auto_vec<rtx> temporaries;\n   /* The insns we've emitted.  */\n   auto_vec<rtx_insn *> unmodified_insns;\n-  int count = 0;\n \n   hash_set<rtx_insn *> need_no_cmov;\n   hash_map<rtx_insn *, int> rewired_src;\n \n   need_cmov_or_rewire (then_bb, &need_no_cmov, &rewired_src);\n \n+  int last_needs_comparison = -1;\n+\n+  bool ok = noce_convert_multiple_sets_1\n+    (if_info, &need_no_cmov, &rewired_src, &targets, &temporaries,\n+     &unmodified_insns, &last_needs_comparison);\n+  if (!ok)\n+      return false;\n+\n+  /* If there are insns that overwrite part of the initial\n+     comparison, we can still omit creating temporaries for\n+     the last of them.\n+     As the second try will always create a less expensive,\n+     valid sequence, we do not need to compare and can discard\n+     the first one.  */\n+  if (last_needs_comparison != -1)\n+    {\n+      end_sequence ();\n+      start_sequence ();\n+      ok = noce_convert_multiple_sets_1\n+\t(if_info, &need_no_cmov, &rewired_src, &targets, &temporaries,\n+\t &unmodified_insns, &last_needs_comparison);\n+      /* Actually we should not fail anymore if we reached here,\n+\t but better still check.  */\n+      if (!ok)\n+\t  return false;\n+    }\n+\n+  /* We must have seen some sort of insn to insert, otherwise we were\n+     given an empty BB to convert, and we can't handle that.  */\n+  gcc_assert (!unmodified_insns.is_empty ());\n+\n+  /* Now fixup the assignments.  */\n+  for (unsigned i = 0; i < targets.length (); i++)\n+    if (targets[i] != temporaries[i])\n+      noce_emit_move_insn (targets[i], temporaries[i]);\n+\n+  /* Actually emit the sequence if it isn't too expensive.  */\n+  rtx_insn *seq = get_insns ();\n+\n+  if (!targetm.noce_conversion_profitable_p (seq, if_info))\n+    {\n+      end_sequence ();\n+      return FALSE;\n+    }\n+\n+  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+    set_used_flags (insn);\n+\n+  /* Mark all our temporaries and targets as used.  */\n+  for (unsigned i = 0; i < targets.length (); i++)\n+    {\n+      set_used_flags (temporaries[i]);\n+      set_used_flags (targets[i]);\n+    }\n+\n+  set_used_flags (cond);\n+  set_used_flags (x);\n+  set_used_flags (y);\n+\n+  unshare_all_rtl_in_chain (seq);\n+  end_sequence ();\n+\n+  if (!seq)\n+    return FALSE;\n+\n+  for (insn = seq; insn; insn = NEXT_INSN (insn))\n+    if (JUMP_P (insn)\n+\t|| recog_memoized (insn) == -1)\n+      return FALSE;\n+\n+  emit_insn_before_setloc (seq, if_info->jump,\n+\t\t\t   INSN_LOCATION (unmodified_insns.last ()));\n+\n+  /* Clean up THEN_BB and the edges in and out of it.  */\n+  remove_edge (find_edge (test_bb, join_bb));\n+  remove_edge (find_edge (then_bb, join_bb));\n+  redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n+  delete_basic_block (then_bb);\n+  num_true_changes++;\n+\n+  /* Maybe merge blocks now the jump is simple enough.  */\n+  if (can_merge_blocks_p (test_bb, join_bb))\n+    {\n+      merge_blocks (test_bb, join_bb);\n+      num_true_changes++;\n+    }\n+\n+  num_updated_if_blocks++;\n+  if_info->transform_name = \"noce_convert_multiple_sets\";\n+  return TRUE;\n+}\n+\n+/* This goes through all relevant insns of IF_INFO->then_bb and tries to\n+   create conditional moves.  In case a simple move sufficis the insn\n+   should be listed in NEED_NO_CMOV.  The rewired-src cases should be\n+   specified via REWIRED_SRC.  TARGETS, TEMPORARIES and UNMODIFIED_INSNS\n+   are specified and used in noce_convert_multiple_sets and should be passed\n+   to this function..  */\n+\n+static bool\n+noce_convert_multiple_sets_1 (struct noce_if_info *if_info,\n+\t\t\t      hash_set<rtx_insn *> *need_no_cmov,\n+\t\t\t      hash_map<rtx_insn *, int> *rewired_src,\n+\t\t\t      auto_vec<rtx> *targets,\n+\t\t\t      auto_vec<rtx> *temporaries,\n+\t\t\t      auto_vec<rtx_insn *> *unmodified_insns,\n+\t\t\t      int *last_needs_comparison)\n+{\n+  basic_block then_bb = if_info->then_bb;\n+  rtx_insn *jump = if_info->jump;\n+  rtx_insn *cond_earliest;\n+\n+  /* Decompose the condition attached to the jump.  */\n+  rtx cond = noce_get_condition (jump, &cond_earliest, false);\n+\n+  rtx cc_cmp = cond_exec_get_condition (jump);\n+  rtx rev_cc_cmp = cond_exec_get_condition (jump, /* get_reversed */ true);\n+\n+  rtx_insn *insn;\n+  int count = 0;\n+\n+  targets->truncate (0);\n+  temporaries->truncate (0);\n+  unmodified_insns->truncate (0);\n+\n+  bool second_try = *last_needs_comparison != -1;\n+\n   FOR_BB_INSNS (then_bb, insn)\n     {\n       /* Skip over non-insns.  */\n@@ -3286,9 +3415,9 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n       rtx temp;\n \n       rtx new_val = SET_SRC (set);\n-      if (int *ii = rewired_src.get (insn))\n-\tnew_val = simplify_replace_rtx (new_val, targets[*ii],\n-\t\t\t\t\ttemporaries[*ii]);\n+      if (int *ii = rewired_src->get (insn))\n+\tnew_val = simplify_replace_rtx (new_val, (*targets)[*ii],\n+\t\t\t\t\t(*temporaries)[*ii]);\n       rtx old_val = target;\n \n       /* As we are transforming\n@@ -3316,16 +3445,20 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t Therefore we introduce a temporary every time we are about to\n \t overwrite a variable used in the check.  Costing of a sequence with\n \t these is going to be inaccurate so only use temporaries when\n-\t needed.  */\n-      if (reg_overlap_mentioned_p (target, cond))\n+\t needed.\n+\n+\t If performing a second try, we know how many insns require a\n+\t temporary.  For the last of these, we can omit creating one.  */\n+      if (reg_overlap_mentioned_p (target, cond)\n+\t  && (!second_try || count < *last_needs_comparison))\n \ttemp = gen_reg_rtx (GET_MODE (target));\n       else\n \ttemp = target;\n \n       /* We have identified swap-style idioms before.  A normal\n \t set will need to be a cmov while the first instruction of a swap-style\n \t idiom can be a regular move.  This helps with costing.  */\n-      bool need_cmov = !need_no_cmov.contains (insn);\n+      bool need_cmov = !need_no_cmov->contains (insn);\n \n       /* If we had a non-canonical conditional jump (i.e. one where\n \t the fallthrough is to the \"else\" case) we need to reverse\n@@ -3400,6 +3533,8 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t{\n \t  seq = seq1;\n \t  temp_dest = temp_dest1;\n+\t  if (!second_try)\n+\t    *last_needs_comparison = count;\n \t}\n       else if (seq2 != NULL_RTX)\n \t{\n@@ -3418,75 +3553,15 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \n       /* Bookkeeping.  */\n       count++;\n-      targets.safe_push (target);\n-      temporaries.safe_push (temp_dest);\n-      unmodified_insns.safe_push (insn);\n-    }\n-\n-  /* We must have seen some sort of insn to insert, otherwise we were\n-     given an empty BB to convert, and we can't handle that.  */\n-  gcc_assert (!unmodified_insns.is_empty ());\n-\n-  /* Now fixup the assignments.  */\n-  for (int i = 0; i < count; i++)\n-    if (targets[i] != temporaries[i])\n-      noce_emit_move_insn (targets[i], temporaries[i]);\n-\n-  /* Actually emit the sequence if it isn't too expensive.  */\n-  rtx_insn *seq = get_insns ();\n-\n-  if (!targetm.noce_conversion_profitable_p (seq, if_info))\n-    {\n-      end_sequence ();\n-      return FALSE;\n-    }\n-\n-  for (insn = seq; insn; insn = NEXT_INSN (insn))\n-    set_used_flags (insn);\n-\n-  /* Mark all our temporaries and targets as used.  */\n-  for (int i = 0; i < count; i++)\n-    {\n-      set_used_flags (temporaries[i]);\n-      set_used_flags (targets[i]);\n+      targets->safe_push (target);\n+      temporaries->safe_push (temp_dest);\n+      unmodified_insns->safe_push (insn);\n     }\n \n-  set_used_flags (cond);\n-  set_used_flags (x);\n-  set_used_flags (y);\n-\n-  unshare_all_rtl_in_chain (seq);\n-  end_sequence ();\n-\n-  if (!seq)\n-    return FALSE;\n-\n-  for (insn = seq; insn; insn = NEXT_INSN (insn))\n-    if (JUMP_P (insn)\n-\t|| recog_memoized (insn) == -1)\n-      return FALSE;\n-\n-  emit_insn_before_setloc (seq, if_info->jump,\n-\t\t\t   INSN_LOCATION (unmodified_insns.last ()));\n+  return true;\n+}\n \n-  /* Clean up THEN_BB and the edges in and out of it.  */\n-  remove_edge (find_edge (test_bb, join_bb));\n-  remove_edge (find_edge (then_bb, join_bb));\n-  redirect_edge_and_branch_force (single_succ_edge (test_bb), join_bb);\n-  delete_basic_block (then_bb);\n-  num_true_changes++;\n \n-  /* Maybe merge blocks now the jump is simple enough.  */\n-  if (can_merge_blocks_p (test_bb, join_bb))\n-    {\n-      merge_blocks (test_bb, join_bb);\n-      num_true_changes++;\n-    }\n-\n-  num_updated_if_blocks++;\n-  if_info->transform_name = \"noce_convert_multiple_sets\";\n-  return TRUE;\n-}\n \n /* Return true iff basic block TEST_BB is comprised of only\n    (SET (REG) (REG)) insns suitable for conversion to a series"}]}