{"sha": "946730d09eb43a80c79a8afe2c6695dc5272d246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ2NzMwZDA5ZWI0M2E4MGM3OWE4YWZlMmM2Njk1ZGM1MjcyZDI0Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:42:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:42:23Z"}, "message": "Initial revision\n\nFrom-SVN: r8050", "tree": {"sha": "d20b07c0c12f9c4285a24da3e9100c4c73a414d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d20b07c0c12f9c4285a24da3e9100c4c73a414d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/946730d09eb43a80c79a8afe2c6695dc5272d246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946730d09eb43a80c79a8afe2c6695dc5272d246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/946730d09eb43a80c79a8afe2c6695dc5272d246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/946730d09eb43a80c79a8afe2c6695dc5272d246/comments", "author": null, "committer": null, "parents": [{"sha": "c83c42d9a87921d377f82e8588e6d86d61162247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83c42d9a87921d377f82e8588e6d86d61162247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83c42d9a87921d377f82e8588e6d86d61162247"}], "stats": {"total": 1988, "additions": 1988, "deletions": 0}, "files": [{"sha": "467cb204037cf1a0f35a32c452d0fb65ddb368e7", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "added", "additions": 1988, "deletions": 0, "changes": 1988, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/946730d09eb43a80c79a8afe2c6695dc5272d246/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/946730d09eb43a80c79a8afe2c6695dc5272d246/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=946730d09eb43a80c79a8afe2c6695dc5272d246", "patch": "@@ -0,0 +1,1988 @@\n+/* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Michael Collison (collison@world.std.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 1, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+extern char *low_reg_names[];\n+extern char *text_seg_name;\n+extern char *rsect_text;\n+extern char *data_seg_name;\n+extern char *rsect_data;\n+extern char *bss_seg_name;\n+extern char *rsect_bss;\n+extern char *const_seg_name;\n+extern char *rsect_const;\n+extern char *chip_name;\n+extern char *save_chip_name;\n+extern struct rtx_def *dsp16xx_compare_op0, *dsp16xx_compare_op1;\n+extern struct rtx_def *(*dsp16xx_compare_gen)();\n+extern struct rtx_def *gen_compare_reg();\n+extern struct rtx_def *dsp16xx_addhf3_libcall;\n+extern struct rtx_def *dsp16xx_subhf3_libcall;\n+extern struct rtx_def *dsp16xx_mulhf3_libcall;\n+extern struct rtx_def *dsp16xx_divhf3_libcall;\n+extern struct rtx_def *dsp16xx_cmphf3_libcall;\n+extern struct rtx_def *dsp16xx_fixhfhi2_libcall;\n+extern struct rtx_def *dsp16xx_floathihf2_libcall;\n+extern struct rtx_def *dsp16xx_neghf2_libcall;\n+extern struct rtx_def *dsp16xx_umulhi3_libcall;\n+extern struct rtx_def *dsp16xx_mulhi3_libcall;\n+extern struct rtx_def *dsp16xx_udivqi3_libcall;\n+extern struct rtx_def *dsp16xx_udivhi3_libcall;\n+extern struct rtx_def *dsp16xx_divqi3_libcall;\n+extern struct rtx_def *dsp16xx_divhi3_libcall;\n+extern struct rtx_def *dsp16xx_modqi3_libcall;\n+extern struct rtx_def *dsp16xx_modhi3_libcall;\n+extern struct rtx_def *dsp16xx_umodqi3_libcall;\n+extern struct rtx_def *dsp16xx_umodhi3_libcall;\n+\n+extern struct rtx_def *dsp16xx_ashrhi3_libcall;\n+extern struct rtx_def *dsp16xx_ashlhi3_libcall;\n+extern struct rtx_def *dsp16xx_lshrhi3_libcall;\n+\n+\n+extern int hard_regno_mode_ok ();\n+extern enum reg_class dsp16xx_reg_class_from_letter ();\n+extern enum reg_class dsp16xx_limit_reload_class ();\n+extern int hard_regno_nregs ();\n+extern int regno_reg_class ();\n+extern int move_operand ();\n+extern int symbolic_address_p ();\n+extern int Y_address ();\n+extern int call_address_operand ();\n+extern void notice_update_cc();\n+extern void function_prologue ();\n+extern void function_epilogue ();\n+extern int  dsp1600_comparison_reverse ();\n+extern void double_reg_from_memory ();\n+extern void double_reg_to_memory ();\n+extern void bss_section ();\n+extern struct rtx_def *dsp16xx_function_arg ();\n+extern void dsp16xx_function_arg_advance ();\n+extern enum rtx_code next_cc_user_code ();\n+extern enum rtx_code save_next_cc_user_code;\n+extern struct rtx_def *gen_tst_reg ();\n+extern char *output_block_move();\n+\n+/* RUN-TIME TARGET SPECIFICATION */\n+#define DSP16XX   1\n+\n+/* Name of the AT&T assembler */\n+\n+#define ASM_PROG \"as1600\"\n+\n+/* Name of the AT&T linker */\n+\n+#define LD_PROG \"ld1600\"\n+\n+/* Define which switches take word arguments */\n+#define WORD_SWITCH_TAKES_ARG(STR)              \\\n+  (!strcmp (STR, \"ifile\") ? 1 :                 \\\n+   0)\n+\n+#ifdef  CC1_SPEC\n+#undef  CC1_SPEC\n+#endif\n+#define CC1_SPEC       \"\"\n+\n+/* Define this as a spec to call the AT&T assembler */\n+\n+#define CROSS_ASM_SPEC   \"%{!S:as1600 %a %i\\n }\"\n+\n+/* Define this as a spec to call the AT&T linker */\n+\n+#define CROSS_LINK_SPEC  \"%{!c:%{!M:%{!MM:%{!E:%{!S:ld1600 %l %X %{o*} %{m} \\\n+\t\t\t%{r} %{s} %{t} %{u*} %{x}\\\n+\t\t\t%{!A:%{!nostdlib:%S}} %{static:}\\\n+\t\t\t%{L*} %D %o %{!nostdlib:-le1600 %L -le1600 %{!A:%E}}\\n }}}}}\"\n+\n+/* Nothing complicated here, just link with libc.a under normal\n+   circumstances */\n+#define LIB_SPEC \"-lc\"\n+\n+/* Specify the startup file to link with. */\n+#define STARTFILE_SPEC \"%{mmap1:m1_crt0.o%s}  \\\n+%{mmap2:m2_crt0.o%s}                          \\\n+%{mmap3:m3_crt0.o%s}                          \\\n+%{mmap4:m4_crt0.o%s}                          \\\n+%{!mmap*: %{!ifile*: m4_crt0.o%s} %{ifile*:     \\\n+%eA -ifile option requires a -map option}}\"\n+\n+/* Specify the end file to link with */\n+\n+#define ENDFILE_SPEC \"%{mmap1:m1_crtn.o%s}  \\\n+%{mmap2:m2_crtn.o%s}                          \\\n+%{mmap3:m3_crtn.o%s}                          \\\n+%{mmap4:m4_crtn.o%s}                          \\\n+%{!mmap*: %{!ifile*: m4_crtn.o%s} %{ifile*:     \\\n+%eA -ifile option requires a -map option}}\"\n+\n+\n+/* Tell gcc where to look for the startfile */\n+#define STANDARD_STARTFILE_PREFIX   \"/d1600/lib\"\n+\n+/* Tell gcc where to look for it's executables */\n+#define STANDARD_EXEC_PREFIX  \"/d1600/bin\"\n+\n+/* Command line options to the AT&T assembler */\n+#define ASM_SPEC  \"%{V} %{v:%{!V:-V}} %{g*:-g}\"\n+\n+/* Command line options for the AT&T linker */\n+#define LINK_SPEC \"%{V} %{v:%{!V:-V}} %{minit:-i}  \\\n+%{!ifile*:%{mmap1:-ifile m1_deflt.if%s}         \\\n+          %{mmap2:-ifile m2_deflt.if%s}         \\\n+          %{mmap3:-ifile m3_deflt.if%s}         \\\n+          %{mmap4:-ifile m4_deflt.if%s}         \\\n+          %{!mmap*:-ifile m4_deflt.if%s}}       \\\n+%{ifile*} %{!r:-a}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#ifdef __MSDOS__\n+#define CPP_PREDEFINES \"-Ddsp1600 -DDSP1600 -DMSDOS\"\n+#else\n+#define CPP_PREDEFINES \"-Ddsp1600 -DDSP1600 -Ddsp1610 -DDSP1610\"\n+#endif\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+#define MASK_REGPARM         0x00000001    /* Pass parameters in registers */\n+#define MASK_NEAR_CALL       0x00000002    /* The call is on the same 4k page */\n+#define MASK_NEAR_JUMP       0x00000004    /* The jump is on the same 4k page */\n+#define MASK_BMU             0x00000008    /* Use the 'bmu' shift instructions */\n+#define MASK_OPTIMIZE_MEMORY 0x00000010    /* Optimize to conserve memory */\n+#define MASK_OPTIMIZE_SPEED  0x00000020    /* Optimize for speed */\n+#define MASK_MAP1            0x00000040    /* Link with map1 */\n+#define MASK_MAP2            0x00000080    /* Link with map2 */\n+#define MASK_MAP3            0x00000100    /* Link with map3 */\n+#define MASK_MAP4            0x00000200    /* Link with map4 */\n+#define MASK_YBASE_HIGH      0x00000400    /* The ybase register window starts high */\n+#define MASK_INIT\t     0x00000800    /* Have the linker generate tables to\n+\t\t\t\t\t      initialize data at startup */\n+#define MASK_INLINE_MULT     0x00001000    /* Inline 32 bit multiplies */\n+#define MASK_RESERVE_YBASE   0x00002000    /* Reserved the ybase registers */\n+\n+/* Compile passing first two args in regs 0 and 1.\n+   This exists only to test compiler features that will\n+   be needed for RISC chips.  It is not usable\n+   and is not intended to be usable on this cpu.  */\n+#define TARGET_REGPARM   (target_flags & MASK_REGPARM)\n+\n+/* The call is on the same 4k page, so instead of loading\n+   the 'pt' register and branching, we can branch directly */\n+\n+#define TARGET_NEAR_CALL (target_flags & MASK_NEAR_CALL)\n+\n+/* The jump is on the same 4k page, so instead of loading\n+   the 'pt' register and branching, we can branch directly */\n+\n+#define TARGET_NEAR_JUMP (target_flags & MASK_NEAR_JUMP)\n+\n+/* Generate shift instructions to use the 1610 Bit Manipulation\n+   Unit. */\n+#define TARGET_BMU (target_flags & MASK_BMU)\n+\n+/* Optimize to conseverve memory */\n+#define TARGET_OPTIMIZE_MEMORY (target_flags & MASK_OPTIMIZE_MEMORY)\n+\n+/* Optimize for maximum speed */\n+#define TARGET_OPTIMIZE_SPEED   (target_flags & MASK_OPTIMIZE_SPEED)\n+\n+#define TARGET_YBASE_HIGH (target_flags & MASK_YBASE_HIGH)\n+\n+/* Direct the linker to output extra info for initialized data */\n+#define TARGET_MASK_INIT (target_flags & MASK_INIT)\n+\n+#define TARGET_INLINE_MULT (target_flags & MASK_INLINE_MULT)\n+\n+/* Reserve the ybase registers *(0) - *(31) */\n+#define TARGET_RESERVE_YBASE (target_flags & MASK_RESERVE_YBASE)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+\n+#define TARGET_SWITCHES                        \\\n+  {\t\t\t\t               \\\n+    { \"regparm\",       MASK_REGPARM},\t       \\\n+    { \"no-regparm\",   -MASK_REGPARM},\t       \\\n+    { \"no-near-call\", -MASK_NEAR_CALL},        \\\n+    { \"near-jump\",     MASK_NEAR_JUMP},        \\\n+    { \"no-near-jump\", -MASK_NEAR_JUMP},        \\\n+    { \"bmu\",           MASK_BMU},              \\\n+    { \"no-bmu\",       -MASK_BMU},              \\\n+    { \"Om\",            MASK_OPTIMIZE_MEMORY},  \\\n+    { \"Os\",            MASK_OPTIMIZE_SPEED},   \\\n+    { \"map1\",          MASK_MAP1},             \\\n+    { \"map2\",          MASK_MAP2},             \\\n+    { \"map3\",          MASK_MAP3},             \\\n+    { \"map4\",          MASK_MAP4},             \\\n+    { \"ybase-high\",    MASK_YBASE_HIGH},       \\\n+    { \"init\",          MASK_INIT},             \\\n+    { \"inline-mult\",   MASK_INLINE_MULT},      \\\n+    { \"reserve-ybase\", MASK_RESERVE_YBASE},    \\\n+    { \"\",              TARGET_DEFAULT}         \\\n+  }\n+\n+/* Default target_flags if no switches are specified */\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT  MASK_OPTIMIZE_MEMORY|MASK_REGPARM|MASK_YBASE_HIGH\n+#endif\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable. \n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  { \"text=\",\t&text_seg_name\t},\t\t\t\t\\\n+  { \"data=\",\t&data_seg_name\t},\t\t\t\t\\\n+  { \"bss=\",\t&bss_seg_name\t},\t\t\t\t\\\n+  { \"const=\",   &const_seg_name },                              \\\n+  { \"chip=\",    &chip_name      }                               \\\n+}\n+\n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed. */\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL)                   \\\n+{                                                     \\\n+    flag_gnu_linker             = FALSE;              \\\n+                                                      \\\n+    if (LEVEL)                                        \\\n+    {                                                 \\\n+\tflag_omit_frame_pointer = TRUE;               \\\n+\tflag_thread_jumps       = TRUE;               \\\n+    }                                                 \\\n+                                                      \\\n+    if (LEVEL >= 2)                                   \\\n+    {                                                 \\\n+\tflag_strength_reduce         = TRUE;          \\\n+\tflag_cse_follow_jumps        = TRUE;          \\\n+\tflag_cse_skip_blocks         = TRUE;          \\\n+\tflag_expensive_optimizations = TRUE;          \\\n+\tflag_rerun_cse_after_loop    = TRUE;          \\\n+    }                                                 \\\n+                                                      \\\n+    if (LEVEL >= 3)                                   \\\n+    {                                                 \\\n+       flag_inline_functions = 1;                     \\\n+    }                                                 \\\n+}\n+\f\n+/* STORAGE LAYOUT */\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+ */\n+#define BITS_BIG_ENDIAN  1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.\n+   We define big-endian, but since the 1600 series cannot address bytes\n+   it does not matter. */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is numbered.\n+   For the 1600 we can decide arbitrarily since there are no machine instructions for them. */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 16\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 16\n+\n+/* Maximum number of bits in a word. */\n+#define MAX_BITS_PER_WORD 16\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 1\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 16\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 16\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Biggest alignment that any data type can require on this machine, in bits.  */\n+#define BIGGEST_ALIGNMENT 16\n+\n+/* Biggest alignment that any structure field can require on this machine, in bits */\n+#define BIGGEST_FIELD_ALIGNMENT 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* Number of bits which any structure or union's size must be a multiple of. Each structure\n+   or union's size is rounded up to a multiple of this */\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT  1\n+\n+/* An integer expression for the size in bits of the largest integer machine mode that\n+   should actually be used. All integer machine modes of this size or smaller can be\n+   used for structures and unions with the appropriate sizes. */\n+#define MAX_FIXED_MODE_SIZE 32\n+\f\n+/* LAYOUT OF SOURCE LANGUAGE DATA TYPES */\n+\n+#define CHAR_TYPE_SIZE         16\n+#define SHORT_TYPE_SIZE        16\n+#define INT_TYPE_SIZE          16\n+#define LONG_TYPE_SIZE         32\n+#define LONG_LONG_TYPE_SIZE    32\n+#define FLOAT_TYPE_SIZE        32\n+#define DOUBLE_TYPE_SIZE       32\n+#define LONG_DOUBLE_TYPE_SIZE  32\n+\n+/* An expression whose value is 1 or 0, according to whether the type char should be\n+   signed or unsigned by default. */\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* A C expression to determine whether to give an enum type only as many bytes\n+   as it takes to represent the range of possible values of that type. A nonzero\n+   value means to do that; a zero value means all enum types should be allocated\n+   like int. */\n+\n+#define DEFAULT_SHORT_ENUMS 0\n+\n+/* A C expression for a string describing the name of the data type to use for\n+   size values. */\n+\n+#define SIZE_TYPE    \"long unsigned int\"\n+\n+/* A C expression for a string describing the name of the datat type to use for the\n+   result of subtracting two pointers */\n+\n+#define PTRDIFF_TYPE \"long int\"\n+\n+#define TARGET_BELL     '\\a'\n+#define TARGET_BS       '\\b'\n+#define TARGET_TAB      '\\t'\n+#define TARGET_NEWLINE  '\\n'\n+#define TARGET_VT       '\\v'\n+#define TARGET_FF       '\\f'\n+#define TARGET_CR       '\\r'\n+\n+\f\n+/* REGISTER USAGE.  */\n+\n+#define ALL_16_BIT_REGISTERS  1\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to FIRST_PSEUDO_REGISTER-1 */\n+\n+#define FIRST_PSEUDO_REGISTER REG_YBASE31 + 1\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   The registers are layed out as follows:\n+\n+   {a0,a0l,a1,a1l,x,y,yl,p,pl} - Data Arithmetic Unit\n+   {r0,r1,r2,r3,j,k,ybase} - Y Space Address Arithmetic Unit\n+   {pt} - X Space Address Arithmetic Unit\n+   {ar0,ar1,ar2,ar3} - Bit Manipulation UNit\n+   {pr} - Return Address Register\n+\n+   We reserve r2 for the Stack Pointer.\n+   We specify r3 for the Frame Pointer but allow the compiler\n+   to omit it when possible since we have so few pointer registers. */\n+\n+#define REG_A0     0\n+#define REG_A0L    1\n+#define REG_A1     2\n+#define REG_A1L    3 \n+#define REG_X      4\n+#define REG_Y      5\n+#define REG_YL     6\n+#define REG_PROD   7\n+#define REG_PRODL  8\n+#define REG_R0     9\n+#define REG_R1     10\n+#define REG_R2     11\n+#define REG_R3     12\n+#define REG_J      13\n+#define REG_K      14\n+#define REG_YBASE  15\n+#define REG_PT     16\n+#define REG_AR0    17\n+#define REG_AR1    18\n+#define REG_AR2    19\n+#define REG_AR3    20\n+#define REG_C0     21\n+#define REG_C1     22\n+#define REG_C2     23\n+#define REG_PR     24\n+#define REG_RB     25\n+#define REG_YBASE0 26\n+#define REG_YBASE1 27\n+#define REG_YBASE2 28\n+#define REG_YBASE3 29\n+#define REG_YBASE4 30\n+#define REG_YBASE5 31\n+#define REG_YBASE6 32\n+#define REG_YBASE7 33\n+#define REG_YBASE8 34\n+#define REG_YBASE9 35\n+#define REG_YBASE10 36\n+#define REG_YBASE11 37\n+#define REG_YBASE12 38\n+#define REG_YBASE13 39\n+#define REG_YBASE14 40\n+#define REG_YBASE15 41\n+#define REG_YBASE16 42\n+#define REG_YBASE17 43\n+#define REG_YBASE18 44\n+#define REG_YBASE19 45\n+#define REG_YBASE20 46\n+#define REG_YBASE21 47\n+#define REG_YBASE22 48\n+#define REG_YBASE23 49\n+#define REG_YBASE24 50\n+#define REG_YBASE25 51\n+#define REG_YBASE26 52\n+#define REG_YBASE27 53\n+#define REG_YBASE28 54\n+#define REG_YBASE29 55\n+#define REG_YBASE30 56\n+#define REG_YBASE31 57\n+\n+/* Do we have a accumulator register? */\n+#define IS_ACCUM_REG(REGNO) ((REGNO) >= REG_A0 && (REGNO) <= REG_A1L)\n+#define IS_ACCUM_LOW_REG(REGNO) ((REGNO) == REG_A0L || (REGNO) == REG_A1L)\n+\n+/* Do we have a virtual ybase register */\n+#define IS_YBASE_REGISTER_WINDOW(REGNO) ((REGNO) >= REG_YBASE0 && (REGNO) <= REG_YBASE31)\n+\n+#define IS_ADDRESS_REGISTER(REGNO) ((REGNO) >= REG_R0 && (REGNO) <= REG_R3)\n+\n+#define FIXED_REGISTERS     \\\n+{0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+ 0, 0, 0, 1, 0, 0, 1,       \\\n+ 1,                         \\\n+ 0, 0, 0, 0,                \\\n+ 1, 1, 1,                   \\\n+ 0, 0,                      \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,    \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,    \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,    \\\n+ 0, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   On the 1610 'a0' holds return values from functions. 'r0' holds\n+   structure-value addresses.\n+\n+   In addition we don't save either j, k, ybase or any of the\n+   bit manipulation registers.  */\n+\n+\n+#define CALL_USED_REGISTERS   \\\n+{1, 1, 1, 1, 0, 1, 1, 1, 1,   \\\n+ 1, 0, 0, 1, 1, 1, 1,         \\\n+ 1,                           \\\n+ 0, 0, 1, 1,                  \\\n+ 1, 1, 1,                     \\\n+ 0, 1,                        \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,      \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,      \\\n+ 0, 0, 0, 0, 0, 0, 0, 0,      \\\n+ 0, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   We allocate in the following order:\n+ */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\\\n+{ REG_R0, REG_R1, REG_R2, REG_PROD, REG_Y, REG_X,       \\\n+  REG_PRODL, REG_YL, REG_AR0, REG_AR1,                  \\\n+  REG_RB, REG_A0, REG_A1, REG_A0L,                      \\\n+  REG_A1L, REG_AR2, REG_AR3,                            \\\n+  REG_YBASE, REG_J, REG_K, REG_PR, REG_PT, REG_C0,      \\\n+  REG_C1, REG_C2, REG_R3,\t\t\t\t\\\n+  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n+  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n+  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n+  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n+  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n+  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n+  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n+  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31 }\n+\n+/* Zero or more C statements that may conditionally modify two\n+   variables `fixed_regs' and `call_used_regs' (both of type `char\n+   []') after they have been initialized from the two preceding\n+   macros.\n+\n+   This is necessary in case the fixed or call-clobbered registers\n+   depend on target flags.\n+\n+   You need not define this macro if it has no work to do.\n+\n+   If the usage of an entire class of registers depends on the target\n+   flags, you may indicate this to GCC by using this macro to modify\n+   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n+   the classes which should not be used by GCC.  Also define the macro\n+   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n+   letter for a class that shouldn't be used.\n+\n+   (However, if this class is not included in `GENERAL_REGS' and all\n+   of the insn patterns whose constraints permit this class are\n+   controlled by target switches, then GCC will automatically avoid\n+   using these registers when the target switches are opposed to\n+   them.)  If the user tells us there is no BMU, we can't use\n+   ar0-ar3 for regsiter allocation */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!TARGET_BMU)\t\t\t\t\t\t        \\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfor (regno = REG_AR0; regno <= REG_AR3; regno++)\t        \\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_RESERVE_YBASE)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfor (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\t        \\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Determine which register classes are very likely used by spill registers.\n+   local-alloc.c won't allocate pseudos that have these classes as their\n+   preferred class unless they are \"preferred or nothing\".  */\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n+ ((CLASS) != ALL_REGS && (CLASS) != YBASE_VIRT_REGS)\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers. */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)                                 \\\n+  (GET_MODE_SIZE(MODE))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok(REGNO, MODE)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t     \\\n+  (((MODE1) == (MODE2)) ||                           \\\n+   (GET_MODE_CLASS((MODE1)) == MODE_FLOAT)           \\\n+    == (GET_MODE_CLASS((MODE2)) == MODE_FLOAT))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* DSP1600 pc isn't overloaded on a register.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  \n+   This is r3 in our case */\n+#define STACK_POINTER_REGNUM  REG_R3\n+\n+/* Base register for access to local variables of the function.\n+   This is r2 in our case   */\n+#define FRAME_POINTER_REGNUM  REG_R2\n+\n+/* We can debug without the frame pointer */\n+#define CAN_DEBUG_WITHOUT_FP 1\n+\n+/* The 1610 saves the return address in this register */\n+#define RETURN_ADDRESS_REGNUM REG_PR\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n+\n+/* Register in which static-chain is passed to a function.  */\n+\n+#define STATIC_CHAIN_REGNUM 4\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  This is 'r0' in our case */\n+#define STRUCT_VALUE_REGNUM   REG_R0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+\n+enum reg_class \n+{ \n+    NO_REGS, \n+    A0H_REG,\n+    A0L_REG,\n+    A0_REG,\n+    A1H_REG,\n+    ACCUM_HIGH_REGS,\n+    A1L_REG,\n+    ACCUM_LOW_REGS, \n+    A1_REG,\n+    ACCUM_REGS, \n+    X_REG, \n+    X_OR_ACCUM_LOW_REGS,\n+    X_OR_ACCUM_REGS,\n+    YH_REG,\n+    YH_OR_ACCUM_HIGH_REGS,\n+    X_OR_YH_REGS,\n+    YL_REG,\n+    YL_OR_ACCUM_LOW_REGS,\n+    X_OR_YL_REGS,\n+    X_OR_Y_REGS,\n+    Y_REG,\n+    ACCUM_OR_Y_REGS,\n+    PH_REG,\n+    X_OR_PH_REGS, \n+    PL_REG, \n+    PL_OR_ACCUM_LOW_REGS,\n+    X_OR_PL_REGS,\n+    YL_OR_PL_OR_ACCUM_LOW_REGS,\n+    P_REG,\n+    ACCUM_OR_P_REGS,\n+    YL_OR_P_REGS,\n+    ACCUM_LOW_OR_YL_OR_P_REGS,\n+    Y_OR_P_REGS,\n+    ACCUM_Y_OR_P_REGS, \n+    NO_FRAME_Y_ADDR_REGS,\n+    Y_ADDR_REGS, \n+    ACCUM_LOW_OR_Y_ADDR_REGS,\n+    ACCUM_OR_Y_ADDR_REGS,\n+    X_OR_Y_ADDR_REGS,\n+    Y_OR_Y_ADDR_REGS,\n+    P_OR_Y_ADDR_REGS,\n+    NON_HIGH_YBASE_ELIGIBLE_REGS,\n+    YBASE_ELIGIBLE_REGS,\n+    J_REG,\n+    J_OR_DAU_16_BIT_REGS,\n+    BMU_REGS, \n+    NOHIGH_NON_ADDR_REGS,\n+    NON_ADDR_REGS,\n+    SLOW_MEM_LOAD_REGS,\n+    NOHIGH_NON_YBASE_REGS,\n+    NO_ACCUM_NON_YBASE_REGS,\n+    NON_YBASE_REGS,\n+    YBASE_VIRT_REGS,\n+    ACCUM_LOW_OR_YBASE_REGS,\n+    ACCUM_OR_YBASE_REGS,\n+    X_OR_YBASE_REGS,\n+    Y_OR_YBASE_REGS,\n+    ACCUM_LOW_YL_PL_OR_YBASE_REGS,\n+    P_OR_YBASE_REGS,\n+    ACCUM_Y_P_OR_YBASE_REGS,\n+    Y_ADDR_OR_YBASE_REGS,\n+    YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS,\n+    YBASE_OR_YBASE_ELIGIBLE_REGS,\n+    NO_HIGH_ALL_REGS,\n+    ALL_REGS, \n+    LIM_REG_CLASSES \n+};\n+\n+/* GENERAL_REGS must be the name of a register class */\n+#define GENERAL_REGS ALL_REGS\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES        \\\n+{                              \\\n+    \"NO_REGS\",                 \\\n+    \"A0H_REG\",                 \\\n+    \"A0L_REG\",                 \\\n+    \"A0_REG\",                  \\\n+    \"A1H_REG\",                 \\\n+    \"ACCUM_HIGH_REGS\",         \\\n+    \"A1L_REG\",                 \\\n+    \"ACCUM_LOW_REGS\",          \\\n+    \"A1_REG\",                  \\\n+    \"ACCUM_REGS\",              \\\n+    \"X_REG\",                   \\\n+    \"X_OR_ACCUM_LOW_REGS\",     \\\n+    \"X_OR_ACCUM_REGS\",         \\\n+    \"YH_REG\",                  \\\n+    \"YH_OR_ACCUM_HIGH_REGS\",   \\\n+    \"X_OR_YH_REGS\",            \\\n+    \"YL_REG\",                  \\\n+    \"YL_OR_ACCUM_LOW_REGS\",    \\\n+    \"X_OR_YL_REGS\",            \\\n+    \"X_OR_Y_REGS\",             \\\n+    \"Y_REG\",                   \\\n+    \"ACCUM_OR_Y_REGS\",         \\\n+    \"PH_REG\",                  \\\n+    \"X_OR_PH_REGS\",            \\\n+    \"PL_REG\",                  \\\n+    \"PL_OR_ACCUM_LOW_REGS\",    \\\n+    \"X_OR_PL_REGS\",            \\\n+    \"PL_OR_YL_OR_ACCUM_LOW_REGS\", \\\n+    \"P_REG\",                   \\\n+    \"ACCUM_OR_P_REGS\",         \\\n+    \"YL_OR_P_REGS\",            \\\n+    \"ACCUM_LOW_OR_YL_OR_P_REGS\", \\\n+    \"Y_OR_P_REGS\",             \\\n+    \"ACCUM_Y_OR_P_REGS\",       \\\n+    \"NO_FRAME_Y_ADDR_REGS\",      \\\n+    \"Y_ADDR_REGS\",               \\\n+    \"ACCUM_LOW_OR_Y_ADDR_REGS\",  \\\n+    \"ACCUM_OR_Y_ADDR_REGS\",    \\\n+    \"X_OR_Y_ADDR_REGS\",        \\\n+    \"Y_OR_Y_ADDR_REGS\",        \\\n+    \"P_OR_Y_ADDR_REGS\",        \\\n+    \"NON_HIGH_YBASE_ELIGIBLE_REGS\", \\\n+    \"YBASE_ELIGIBLE_REGS\",     \\\n+    \"J_REG\",                   \\\n+    \"J_OR_DAU_16_BIT_REGS\",    \\\n+    \"BMU_REGS\",                \\\n+    \"NOHIGH_NON_ADDR_REGS\",    \\\n+    \"NON_ADDR_REGS\",           \\\n+    \"SLOW_MEM_LOAD_REGS\",      \\\n+    \"NOHIGH_NON_YBASE_REGS\",   \\\n+    \"NO_ACCUM_NON_YBASE_REGS\", \\\n+    \"NON_YBASE_REGS\",          \\\n+    \"YBASE_VIRT_REGS\",         \\\n+    \"ACCUM_LOW_OR_YBASE_REGS\", \\\n+    \"ACCUM_OR_YBASE_REGS\",     \\\n+    \"X_OR_YBASE_REGS\",         \\\n+    \"Y_OR_YBASE_REGS\",         \\\n+    \"ACCUM_LOW_YL_PL_OR_YBASE_REGS\", \\\n+    \"P_OR_YBASE_REGS\",         \\\n+    \"ACCUM_Y_P_OR_YBASE_REGS\", \\\n+    \"Y_ADDR_OR_YBASE_REGS\",    \\\n+    \"YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS\", \\\n+    \"YBASE_OR_YBASE_ELIGIBLE_REGS\", \\\n+    \"NO_HIGH_ALL_REGS\",        \\\n+    \"ALL_REGS\"                 \\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS   \\\n+{                            \\\n+    {0x00000000,  0x00000000},      /* no reg */                             \\\n+    {0x00000001,  0x00000000},      /* a0h */                                \\\n+    {0x00000002,  0x00000000},      /* a0l */                                \\\n+    {0x00000003,  0x00000000},      /* a0h:a0l */                            \\\n+    {0x00000004,  0x00000000},      /* a1h */                                \\\n+    {0x00000005,  0x00000000},      /* accum high */                         \\\n+    {0x00000008,  0x00000000},      /* a1l */                                \\\n+    {0x0000000A,  0x00000000},      /* accum low */                          \\\n+    {0x0000000c,  0x00000000},      /* a1h:a1l */                            \\\n+    {0x0000000f,  0x00000000},      /* accum regs */                         \\\n+    {0x00000010,  0x00000000},      /* x reg */                              \\\n+    {0x0000001A,  0x00000000},      /* x & accum_low_regs */                 \\\n+    {0x0000001f,  0x00000000},      /* x & accum regs */                     \\\n+    {0x00000020,  0x00000000},      /* y high */                             \\\n+    {0x00000025,  0x00000000},      /* yh, accum high */                     \\\n+    {0x00000030,  0x00000000},      /* x & yh */                             \\\n+    {0x00000040,  0x00000000},      /* y low */                              \\\n+    {0x0000004A,  0x00000000},      /* y low, accum_low */                   \\\n+    {0x00000050,  0x00000000},      /* x & yl */                             \\\n+    {0x00000060,  0x00000000},      /* yl:yh */                              \\\n+    {0x00000070,  0x00000000},      /* x, yh,a nd yl */                      \\\n+    {0x0000006F,  0x00000000},      /* accum, y */                           \\\n+    {0x00000080,  0x00000000},      /* p high */                             \\\n+    {0x00000090,  0x00000000},      /* x & ph */                             \\\n+    {0x00000100,  0x00000000},      /* p low */                              \\\n+    {0x0000010A,  0x00000000},      /* p_low and accum_low */                \\\n+    {0x00000110,  0x00000000},      /* x & pl */                             \\\n+    {0x0000014A,  0x00000000},      /* pl,yl,a1l,a0l */                      \\\n+    {0x00000180,  0x00000000},      /* pl:ph */                              \\\n+    {0x0000018F,  0x00000000},      /* accum, p */                           \\\n+    {0x000001C0,  0x00000000},      /* pl:ph and yl */                       \\\n+    {0x000001CA,  0x00000000},      /* pl:ph, yl, a0l, a1l */                \\\n+    {0x000001E0,  0x00000000},      /* y or p */                             \\\n+    {0x000001EF,  0x00000000},      /* accum, y or p */                      \\\n+    {0x00000E00,  0x00000000},      /* r0-r2 */                              \\\n+    {0x00001E00,  0x00000000},      /* r0-r3 */                              \\\n+    {0x00001E0A,  0x00000000},      /* r0-r3, accum_low */                   \\\n+    {0x00001E0F,  0x00000000},      /* accum,r0-r3 */                        \\\n+    {0x00001E10,  0x00000000},      /* x,r0-r3 */                            \\\n+    {0x00001E60,  0x00000000},      /* y,r0-r3 */                            \\\n+    {0x00001F80,  0x00000000},      /* p,r0-r3 */                            \\\n+    {0x00001FDA,  0x00000000},      /* ph:pl, r0-r3, x,a0l,a1l */            \\\n+    {0x00001fff,  0x00000000},      /* accum,x,y,p,r0-r3 */                  \\\n+    {0x00002000,  0x00000000},      /* j */                                  \\\n+    {0x00002025,  0x00000000},      /* j, yh, a1h, a0h */                    \\\n+    {0x001E0000,  0x00000000},      /* ar0-ar3 */                            \\\n+    {0x03FFE1DA,  0x00000000},      /* non_addr except yh,a0h,a1h */         \\\n+    {0x03FFE1FF,  0x00000000},      /* non_addr regs */                      \\\n+    {0x03FFFF8F,  0x00000000},      /* non ybase except yh, yl, and x */     \\\n+    {0x03FFFFDA,  0x00000000},      /* non ybase regs except yh,a0h,a1h */   \\\n+    {0x03FFFFF0,  0x00000000},      /* non ybase except a0,a0l,a1,a1l */     \\\n+    {0x03FFFFFF,  0x00000000},      /* non ybase regs */                     \\\n+    {0xFC000000,  0x03FFFFFF},      /* virt ybase regs */                    \\\n+    {0xFC00000A,  0x03FFFFFF},      /* accum_low, virt ybase regs */         \\\n+    {0xFC00000F,  0x03FFFFFF},      /* accum, virt ybase regs */             \\\n+    {0xFC000010,  0x03FFFFFF},      /* x,virt ybase regs */                  \\\n+    {0xFC000060,  0x03FFFFFF},      /* y,virt ybase regs */                  \\\n+    {0xFC00014A,  0x03FFFFFF},      /* accum_low, yl, pl, ybase */           \\\n+    {0xFC000180,  0x03FFFFFF},      /* p,virt ybase regs */                  \\\n+    {0xFC0001EF,  0x03FFFFFF},      /* accum,y,p,ybase regs */               \\\n+    {0xFC001E00,  0x03FFFFFF},      /* r0-r3, ybase regs */                  \\\n+    {0xFC001FDA,  0x03FFFFFF},      /* r0-r3, pl:ph,yl,x,a1l,a0l */          \\\n+    {0xFC001FFF,  0x03FFFFFF},      /* virt ybase, ybase eligible regs */    \\\n+    {0xFCFFFFDA,  0x03FFFFFF},      /* all regs except yh,a0h,a1h */         \\\n+    {0xFFFFFFFF,  0x03FFFFFF}       /* all regs */                           \\\n+}\n+\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) regno_reg_class(REGNO)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS NO_REGS\n+#define BASE_REG_CLASS  Y_ADDR_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description. */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  dsp16xx_reg_class_from_letter(C)\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)  \\\n+   secondary_reload_class(CLASS, MODE, X)\n+\n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers. */\n+\n+#define SMALL_REGISTER_CLASSES\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+/* A C expression which is nonzero if register REGNO is suitable for use\n+   as a base register in operand addresses. It may be either a suitable\n+   hard register or a pseudo register that has been allocated such a\n+   hard register. \n+\n+  On the 1610 the Y address pointers can be used as a base registers */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+(((REGNO) >= REG_R0 && (REGNO) < REG_R3 + 1) || ((unsigned) reg_renumber[REGNO] >= REG_R0  \\\n+                                   && (unsigned) reg_renumber[REGNO] < REG_R3 + 1))\n+\n+#define REGNO_OK_FOR_YBASE_P(REGNO) \\\n+  (((REGNO) == REG_YBASE) || ((unsigned) reg_renumber[REGNO] == REG_YBASE))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)  0\n+\n+#ifdef ALL_16_BIT_REGISTERS\n+#define IS_32_BIT_REG(REGNO)  0\n+#else\n+#define IS_32_BIT_REG(REGNO)     \\\n+  ((REGNO) == REG_A0 || (REGNO) == REG_A1 || (REGNO) == REG_Y || (REGNO) == REG_PROD)\n+#endif\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   Also, we must ensure that a PLUS is reloaded either\n+   into an accumulator or an address register.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t preferred_reload_class (X, CLASS)\n+\n+/*   A C expression that places additional restrictions on the register\n+     class to use when it is necessary to be able to hold a value of\n+     mode MODE in a reload register for which class CLASS would\n+     ordinarily be used.\n+\n+     Unlike `PREFERRED_RELOAD_CLASS', this macro should be used when\n+     there are certain modes that simply can't go in certain reload\n+     classes.\n+\n+     The value is a register class; perhaps CLASS, or perhaps another,\n+     smaller class.\n+\n+     Don't define this macro unless the target machine has limitations\n+     which require the macro to do something nontrivial. */\n+\n+#if 0\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) dsp16xx_limit_reload_class (MODE, CLASS)\n+#endif\n+\n+/* A C expression for the maximum number of consecutive registers of class CLASS\n+   needed to hold a vlaue of mode MODE */\n+#define CLASS_MAX_NREGS(CLASS, MODE)                                \\\n+    class_max_nregs(CLASS, MODE)\n+\n+/* The letters 'I' through 'P' in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the 16xx, the following constraints are used:\n+   'I' requires a non-negative 16-bit value.\n+   'J' requires a non-negative 9-bit value\n+   'K' requires a constant 0 operand.\n+   'L' requires 16-bit value\n+   'M' 32-bit value -- low 16-bits zero\n+ */\n+\n+#define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n+#define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n+#define SHORT_IMMEDIATE(X)  (SHORT_INTVAL (INTVAL(X)))\n+#define SHORT_INTVAL(I)     ((unsigned) (I) < 0x100)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)                           \\\n+   ((C) == 'I' ? (SMALL_INTVAL(VALUE))                            \\\n+    : (C) == 'J' ? (SHORT_INTVAL(VALUE))                          \\\n+    : (C) == 'K' ? ((VALUE) == 0)                                 \\\n+    : (C) == 'L' ? ! ((VALUE) & ~0x0000ffff)\t                  \\\n+    : (C) == 'M' ? ! ((VALUE) & ~0xffff0000)\t                  \\\n+    : (C) == 'N' ? ((VALUE) == -1 || (VALUE) == 1 ||              \\\n+                    (VALUE) == -2 || (VALUE) == 2)                \\\n+    : 0)\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)   1\n+\n+/* Optional extra constraints for this machine */\n+#define EXTRA_CONSTRAINT(OP,C)                                    \\\n+  ((C) == 'R' ? symbolic_address_p (OP)                           \\\n+   : 0)\n+\f\n+/* DESCRIBING STACK LAYOUT AND CALLING CONVENTIONS */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+/* #define STACK_GROWS_DOWNWARD */\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+#define ARGS_GROW_DOWNWARD\n+\n+/* We use post decrement on the 1600 because there isn't\n+   a pre-decrement addressing mode. This means that we\n+   assume the stack pointer always points at the next\n+   FREE location on the stack. */\n+#define STACK_PUSH_CODE POST_INC\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET  0\n+\n+/* Offset from the stack pointer register to the first\n+   location at which outgoing arguments are placed. */\n+#define STACK_POINTER_OFFSET (0)\n+\n+struct dsp16xx_frame_info\n+{\n+  unsigned long total_size;\t/* # bytes that the entire frame takes up */\n+  unsigned long var_size;\t/* # bytes that variables take up */\n+  unsigned long args_size;\t/* # bytes that outgoing arguments take up */\n+  unsigned long extra_size;\t/* # bytes of extra gunk */\n+  unsigned int  reg_size;\t/* # bytes needed to store regs */\n+  long\t\tfp_save_offset;\t/* offset from vfp to store registers */\n+  unsigned long sp_save_offset;\t/* offset from new sp to store registers */\n+  int\t\tinitialized;\t/* != 0 if frame size already calculated */\n+  int\t\tnum_regs;\t/* number of registers saved */\n+  int           function_makes_calls;  /* Does the function make calls */\n+};\n+\n+extern struct dsp16xx_frame_info current_frame_info;\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by. */\n+/* #define PUSH_ROUNDING(BYTES) ((BYTES)) */\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   'current_function_outgoing_args_size'. No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.\n+\n+   It is not proper to define both 'PUSH_ROUNDING' and\n+   'ACCUMULATE_OUTGOING_ARGS'. */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Offset of first parameter from the argument pointer\n+   register value. */\n+\n+#define FIRST_PARM_OFFSET(FNDECL)   (0)\n+\n+/* Value is 1 if returning from a function call automatically\n+   pops the arguments described by the number-of-args field in the call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name. */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE, STACK_SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0. On the 1610 all function return their values\n+   in a0 (i.e. the upper 16 bits). If the return value is 32-bits the\n+   entire register is significant. */\n+\n+#define VALUE_REGNO(MODE)  (REG_Y)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), VALUE_REGNO(TYPE_MODE(VALTYPE)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, VALUE_REGNO(MODE))\n+\n+/* 1 if N is a possible register number for a function value. */\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_Y)\n+\f\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the 1610 all args are pushed, except if -mregparm is specified\n+   then the first two words of arguments are passed in a0, a1. */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  dsp16xx_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+/* Define the first register to be used for argument passing */\n+#define FIRST_REG_FOR_FUNCTION_ARG REG_Y\n+\n+/* Define the profitablity of saving registers around calls.\n+   NOTE: For now we turin this off because of a bug in the\n+   caller-saves code and also because i'm not sure it is helpful\n+   on the 1610. */\n+\n+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n+\n+/* This indicates that an argument is to be passed with an invisible reference\n+   (i.e., a pointer to the object is passed).\n+\n+   On the dsp16xx, we do this if it must be passed on the stack.  */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (MUST_PASS_IN_STACK (MODE, TYPE))\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  (0)\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go. */\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0. */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)  ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  dsp16xx_function_arg_advance (&CUM, MODE,TYPE, NAMED)\n+\n+/* 1 if N is a possible register number for function argument passing. */\n+#define FUNCTION_ARG_REGNO_P(N)   \\\n+  ((N) == REG_Y || (N) == REG_YL || (N) == REG_PROD || (N) == REG_PRODL)\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used. */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     function_prologue(FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry. */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)        fatal(\"Profiling not implemented yet.\")\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done. */\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  fatal(\"Profiling not implemented yet.\")\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file. */\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t        fatal(\"Profiling not implemented yet.\")\n+\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK  (0)\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) fatal (\"Trampolines not yet implemented\");\n+\n+/* Length in units of the trampoline for entering a nested function.\n+   This is a dummy value  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function. */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+  fatal (\"Trampolines not yet implemented\");\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning. */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE)   function_epilogue(FILE, SIZE)\n+\n+/* A C expression which is nonzero if a function must have and use a\n+   frame pointer. If its value is nonzero the functions will have a\n+   frame pointer. */\n+#define FRAME_POINTER_REQUIRED  (current_function_calls_alloca)\n+\n+/* A C statement to store in the variable 'DEPTH' the difference\n+   between the frame pointer and the stack pointer values immediately\n+   after the function prologue. */\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)                     \\\n+{  (DEPTH) = initial_frame_pointer_offset();\t                \\\n+}\n+\f\n+/* IMPLICIT CALLS TO LIBRARY ROUTINES */\n+\n+#define ADDHF3_LIBCALL      \"__Emulate_addhf3\"\n+#define SUBHF3_LIBCALL      \"__Emulate_subhf3\"\n+#define MULHF3_LIBCALL      \"__Emulate_mulhf3\"\n+#define DIVHF3_LIBCALL      \"__Emulate_divhf3\"\n+#define CMPHF3_LIBCALL      \"__Emulate_cmphf3\"\n+#define FIXHFHI2_LIBCALL    \"__Emulate_fixhfhi2\"\n+#define FLOATHIHF2_LIBCALL  \"__Emulate_floathihf2\"\n+#define NEGHF2_LIBCALL      \"__Emulate_neghf2\"\n+\n+#define UMULHI3_LIBCALL     \"__Emulate_umulhi3\"\n+#define MULHI3_LIBCALL      \"__Emulate_mulhi3\"\n+#define UDIVQI3_LIBCALL     \"__Emulate_udivqi3\"\n+#define UDIVHI3_LIBCALL     \"__Emulate_udivhi3\"\n+#define DIVQI3_LIBCALL      \"__Emulate_divqi3\"\n+#define DIVHI3_LIBCALL      \"__Emulate_divhi3\"\n+#define MODQI3_LIBCALL      \"__Emulate_modqi3\"\n+#define MODHI3_LIBCALL      \"__Emulate_modhi3\"\n+#define UMODQI3_LIBCALL     \"__Emulate_umodqi3\"\n+#define UMODHI3_LIBCALL     \"__Emulate_umodhi3\"\n+#define ASHRHI3_LIBCALL     \"__Emulate_ashrhi3\"\n+#define LSHRHI3_LIBCALL     \"__Emulate_lshrhi3\"\n+#define ASHLHI3_LIBCALL     \"__Emulate_ashlhi3\"\n+#define LSHLHI3_LIBCALL     \"__Emulate_lshlhi3\"   /* NOT USED */\n+\n+/* Define this macro if calls to the ANSI C library functions memcpy and\n+   memset should be generated instead of the BSD function bcopy & bzero. */\n+#define TARGET_MEM_FUNCTIONS\n+\n+\f\n+/* ADDRESSING MODES */\n+\n+/* The 1610 has post-increment and decrement, but no pre-modify */\n+#define HAVE_POST_INCREMENT\n+#define HAVE_POST_DECREMENT\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)  0\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X)    \\\n+    ((REGNO (X) >= REG_R0 && REGNO (X) < REG_R3 + 1 )          \\\n+       || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+\n+/* Nonzero if X is the 'ybase' register */\n+#define REG_OK_FOR_YBASE_P(X)   \\\n+  (REGNO(X) == REG_YBASE || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+/* Nonzero if X is the 'ybase' register */\n+#define REG_OK_FOR_YBASE_P(X) REGNO_OK_FOR_YBASE_P (REGNO(X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the 1610, the actual legitimate addresses must be N (N must fit in\n+   5 bits), *rn (register indirect), *rn++, or *rn-- */\n+\n+#define INT_FITS_5_BITS(I)    ((unsigned long) (I) < 0x20)\n+#define INT_FITS_16_BITS(I)   ((unsigned long) (I) < 0x10000)\n+#define YBASE_CONST_OFFSET(I)       ((I) >= -31 && (I) <= 0)\n+#define YBASE_OFFSET(X)       (GET_CODE (X) == CONST_INT && YBASE_CONST_OFFSET (INTVAL(X)))\n+\n+#define FITS_16_BITS(X)       (GET_CODE (X) == CONST_INT && INT_FITS_16_BITS(INTVAL(X)))\n+#define FITS_5_BITS(X)        (GET_CODE (X) == CONST_INT && INT_FITS_5_BITS(INTVAL(X)))\n+#define ILLEGAL_HIMODE_ADDR(MODE, CONST)  ((MODE) == HImode && CONST == -31)\n+\n+#define INDIRECTABLE_ADDRESS_P(X)                            \\\n+    ((GET_CODE(X) == REG && REG_OK_FOR_BASE_P(X))            \\\n+  || ((GET_CODE(X) == POST_DEC || GET_CODE(X) == POST_INC)   \\\n+       && REG_P(XEXP(X,0)) && REG_OK_FOR_BASE_P(XEXP(X,0)))  \\\n+  || (GET_CODE(X) == CONST_INT && (unsigned long) (X) < 0x20))\n+\n+\n+#define INDEXABLE_ADDRESS_P(X,MODE)                                 \\\n+   ((GET_CODE(X) == PLUS && GET_CODE (XEXP (X,0)) == REG &&         \\\n+     XEXP(X,0) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,1)) &&   \\\n+     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,1)))) ||              \\\n+    (GET_CODE(X) == PLUS && GET_CODE (XEXP (X,1)) == REG &&         \\\n+     XEXP(X,1) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,0)) &&  \\\n+     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,0)))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                     \\\n+{\t\t\t\t\t\t\t            \\\n+    if (INDIRECTABLE_ADDRESS_P(X))                                  \\\n+        goto ADDR;                                                  \\\n+}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the 1610, we need not do anything.  However, if we don't,\n+   `memory_address' will try lots of things to get a valid address, most of\n+   which will result in dead code and extra pseudos.  So we make the address\n+   valid here.\n+\n+   This is easy:  The only valid addresses are an offset from a register\n+   and we know the address isn't valid.  So just call either `force_operand'\n+   or `force_reg' unless this is a (plus (reg ...) (const_int 0)).  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n+{ if (GET_CODE (X) == PLUS && XEXP (X, 1) == const0_rtx)\t\\\n+    X = XEXP (x, 0);\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == MULT || GET_CODE (X) == PLUS)\t\t\\\n+    X = force_operand (X, 0);\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    X = force_reg (Pmode, X);\t\t\t\t\t\\\n+  goto WIN;\t\t\t\t\t\t\t\\\n+}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 1610, only postdecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand).  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+#define LEGITIMATE_CONSTANT_P(X) (1)\n+\n+\f\n+/* CONDITION CODE INFORMATION */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's. */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+   notice_update_cc( (EXP) )\n+\f\n+/* DESCRIBING RELATIVE COSTS OF OPERATIONS */\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement. */\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)                                \\\n+  case CONST_INT:\t\t\t\t\t\t        \\\n+    return 0;                                                           \\\n+  case LABEL_REF:\t\t\t\t\t\t        \\\n+  case SYMBOL_REF:\t\t\t\t\t\t        \\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+                                                                        \\\n+  case CONST_DOUBLE:\t\t\t\t\t\t        \\\n+    return COSTS_N_INSNS (2);\n+\n+/* Like CONST_COSTS but applies to nonsonstant RTL expressions.\n+   This can be used, for example to indicate how costly a multiply\n+   instruction is. */\n+#define RTX_COSTS(X,CODE,OUTER_CODE)                            \\\n+  case MEM:                                                     \\\n+    return GET_MODE (X) == QImode ? COSTS_N_INSNS (2) :         \\\n+                                    COSTS_N_INSNS (4);          \\\n+  case DIV:                                                     \\\n+  case MOD:                                                     \\\n+    return COSTS_N_INSNS (38);                                  \\\n+  case MULT:                                                    \\\n+    if (GET_MODE (X) == QImode)                                 \\\n+        return COSTS_N_INSNS (2);                               \\\n+    else                                                        \\\n+        return COSTS_N_INSNS (38);                              \\\n+  case PLUS:                                                    \\\n+    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)              \\\n+    {                                                           \\\n+        if (GET_CODE (XEXP (X,1)) == CONST_INT)                 \\\n+        {                                                       \\\n+            int number = INTVAL(XEXP (X,1));                    \\\n+            if (number == 1)                                    \\\n+               return COSTS_N_INSNS (1);                        \\\n+            if (INT_FITS_16_BITS(number))                       \\\n+                return COSTS_N_INSNS (2);                       \\\n+            else                                                \\\n+                return COSTS_N_INSNS (4);                       \\\n+        }                                                       \\\n+        return COSTS_N_INSNS (1);                               \\\n+    }                                                           \\\n+    else                                                        \\\n+        return COSTS_N_INSNS (38);                              \\\n+  case MINUS:                                                   \\\n+    if (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)              \\\n+    {                                                           \\\n+        if (GET_CODE (XEXP (X,1)) == CONST_INT)                 \\\n+        {                                                       \\\n+            if (INT_FITS_16_BITS(INTVAL(XEXP(X,1))))            \\\n+                return COSTS_N_INSNS (2);                       \\\n+            else                                                \\\n+                return COSTS_N_INSNS (4);                       \\\n+        }                                                       \\\n+        return COSTS_N_INSNS (1);                               \\\n+    }                                                           \\\n+    else                                                        \\\n+        return COSTS_N_INSNS (38);                              \\\n+  case AND: case IOR: case XOR:                                 \\\n+    if (GET_CODE (XEXP (X,1)) == CONST_INT)                     \\\n+      {                                                         \\\n+        if (INT_FITS_16_BITS(INTVAL(XEXP(X,1))))                \\\n+            return COSTS_N_INSNS (2);                           \\\n+        else                                                    \\\n+            return COSTS_N_INSNS (4);                           \\\n+      }                                                         \\\n+    return COSTS_N_INSNS (1);                                   \\\n+  case NEG: case NOT:                                           \\\n+    return COSTS_N_INSNS (1);                                   \\\n+  case ASHIFT:                                                  \\\n+  case ASHIFTRT:                                                \\\n+  case LSHIFT:                                                  \\\n+  case LSHIFTRT:                                                \\\n+    if (GET_CODE (XEXP (X,1)) == CONST_INT)                     \\\n+      {                                                         \\\n+        int number = INTVAL(XEXP (X,1));                        \\\n+        if (number == 1 || number == 4 || number == 8 ||        \\\n+            number == 16)                                       \\\n+            return COSTS_N_INSNS (1);                           \\\n+        else                                                    \\\n+            return COSTS_N_INSNS (2);                           \\\n+      }                                                         \\\n+    return COSTS_N_INSNS (1);\n+\n+/* An expression giving the cost of an addressing mode that contains\n+   address. */\n+#define ADDRESS_COST(ADDR)  dsp16xx_address_cost (ADDR)\n+\n+/* A c expression for the cost of moving data from a register in\n+   class FROM to one in class TO. The classes are expressed using\n+   the enumeration values such as GENERAL_REGS. A value of 2 is\n+   the default. */\n+#define REGISTER_MOVE_COST(FROM,TO)  dsp16xx_register_move_cost (FROM, TO)\n+\n+/* A C expression for the cost of moving data of mode MODE between\n+   a register and memory. A value of 2 is the default. */\n+#define MEMORY_MOVE_COST(MODE)                                  \\\n+  (GET_MODE_CLASS(MODE) == MODE_INT && MODE == QImode ? 12       \\\n+   : 16)\n+\n+/* A C expression for the cost of a branch instruction. A value of\n+   1 is the default; */\n+#define BRANCH_COST 2\n+\f\n+\n+/* Define this because otherwise gcc will try to put the function address\n+   in any old pseudo register. We can only use pt. */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this macro as a C expression which is nonzero if accessing less\n+   than a word of memory (i.e a char or short) is no faster than accessing\n+   a word of memory, i.e if such access require more than one instruction\n+   or if ther is no difference in cost between byte and (aligned) word\n+   loads. */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this macro if zero-extension (of a char or short to an int) can\n+   be done faster if the destination is a register that is know to be zero. */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Define this macro if unaligned accesses have a cost many times greater than\n+   aligned accesses, for example if they are emulated in a trap handler */\n+/* define SLOW_UNALIGNED_ACCESS */\n+\n+/* Define this macro to inhibit strength reduction of memory addresses */\n+/* #define DONT_REDUCE_ADDR */\n+\n+\f\n+/* DIVIDING THE OUTPUT IN SECTIONS */\n+/* Output before read-only data.  */\n+\n+#define DEFAULT_TEXT_SEG_NAME \".text\"\n+#define TEXT_SECTION_ASM_OP  rsect_text\n+\n+/* Output before constants and strings */\n+#define DEFAULT_CONST_SEG_NAME  \".const\"\n+#define READONLY_SECTION_ASM_OP rsect_const\n+#define READONLY_DATA_SECTION   const_section\n+\n+/* Output before writable data.  */\n+#define DEFAULT_DATA_SEG_NAME \".data\"\n+#define DATA_SECTION_ASM_OP  rsect_data\n+\n+#define DEFAULT_BSS_SEG_NAME \".bss\"\n+#define BSS_SECTION_ASM_OP rsect_bss\n+\n+/* We will default to using 1610 if the user doesn't\n+   specify it. */\n+#define DEFAULT_CHIP_NAME \"1610\"\n+\n+/* A list of names for sections other than the standard two, which are\n+   'in_text' and 'in_data'. */\n+#define EXTRA_SECTIONS in_bss, in_const\n+\n+#define EXTRA_SECTION_FUNCTIONS  \\\n+void                                                               \\\n+const_section ()                                                   \\\n+{                                                                  \\\n+    if (in_section != in_const)                                    \\\n+    {                                                              \\\n+        fprintf (asm_out_file, \"%s\\n\", READONLY_SECTION_ASM_OP);   \\\n+\tin_section = in_const;                                     \\\n+    }                                                              \\\n+}                                                                  \\\n+void\t\t\t\t\t\t\t\t   \\\n+bss_section ()\t\t\t\t\t\t\t   \\\n+{\t\t\t\t\t\t\t\t   \\\n+    if (in_section != in_bss) {\t\t\t\t\t   \\\n+\tfprintf (asm_out_file, \"%s\\n\", BSS_SECTION_ASM_OP);\t   \\\n+\tin_section = in_bss;\t\t\t\t\t   \\\n+    }\t\t\t\t\t\t\t\t   \\\n+}\n+\n+\f\n+/* THE OVERALL FRAMEWORK OF AN ASSEMBLER FILE */\n+\n+/* Output at beginning of assembler file.  */\n+#define ASM_FILE_START(FILE) dsp16xx_file_start () \n+\n+/* Prevent output of .gcc_compiled */\n+#define ASM_IDENTIFY_GCC(FILE)   \n+\n+/* A C string constant describing how to begin a comment in the target\n+   assembler language. */\n+/* define ASM_COMMENT_START */\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \"\"\n+\f\n+/* OUTPUT OF DATA */\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  asm_output_float (FILE,VALUE)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  asm_output_float (FILE, VALUE)\n+\n+/* This is how to output and assembler line defininf a 'float' constant of\n+   size HFmode. */\n+#define ASM_OUTPUT_SHORT_FLOAT(FILE,VALUE)  asm_output_float (FILE, VALUE)\n+\n+/* This is how to output an assembler line defining an `char' constant.  */\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)              \\\n+( fprintf (FILE, \"\\tint \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line defining an `short' constant.  */\n+#define ASM_OUTPUT_SHORT(FILE,EXP)   asm_output_long(FILE,INTVAL(EXP))\n+\n+/* This is how to output an assembler line defining a 'int' constant. */\n+#define ASM_OUTPUT_INT(FILE, EXP)    asm_output_long(FILE,INTVAL(EXP))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)    ASM_OUTPUT_CHAR(FILE,VALUE)\n+\n+/* This is how we output a 'c' character string. For the 16xx\n+   assembler we have to do it one letter at a time */\n+\n+#define ASCII_LENGTH 10\n+\n+#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n+    unsigned char *_hide_p = (unsigned char *) (MYSTRING);\t\t      \\\n+    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n+      unsigned char *p = _hide_p;\t\t\t\t\t      \\\n+      int thissize = _hide_thissize;\t\t\t\t\t      \\\n+      int i;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  register int c = p[i];\t\t\t\t\t      \\\n+\t  \t\t\t\t\t\t\t\t      \\\n+\t  if (i % ASCII_LENGTH == 0) \\\n+\t    fprintf (asm_out_file, \"\\tint \");\t\t\t\t      \\\n+\t    \t\t\t\t\t\t\t\t\\\n+\t  if (c >= ' ' && c < 0177 && c != '\\'')\t\t\t      \\\n+\t  {\t\t\t\t\t\t\t\t      \\\n+\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n+\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n+\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n+\t  }\t\t\t\t\t\t\t\t      \\\n+\t  else\t\t\t\t\t\t\t\t      \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      fprintf (asm_out_file, \"%d\", c);\t\t\t              \\\n+\t      /* After an octal-escape, if a digit follows,\t\t      \\\n+\t\t terminate one string constant and start another.\t      \\\n+\t\t The Vax assembler fails to stop reading the escape\t      \\\n+\t\t after three digits, so this is the only way we\t\t      \\\n+\t\t can get it to parse the data properly.  \t\t      \\\n+\t      if (i < thissize - 1\t\t\t\t\t      \\\n+\t\t  && p[i + 1] >= '0' && p[i + 1] <= '9')\t\t      \\\n+\t\tfprintf (asm_out_file, \"\\'\\n\\tint \\'\");\t\t              \\\n+\t\t*/ \\\n+\t  }\t\t\t\t\t\t\t\t      \\\n+\t  /* if: \\\n+\t     we are not at the last char (i != thissize -1) \\\n+\t     and (we are not at a line break multiple  \\\n+\t     but i == 0) (it will be the very first time) \\\n+\t     then put out a comma to extend. \\\n+\t   */ \\\n+\t  if ((i != thissize - 1) && ((i + 1) % ASCII_LENGTH))\t      \\\n+\t    fprintf(asm_out_file, \",\");\t \t                      \\\n+\t  if (!((i + 1) % ASCII_LENGTH)) \\\n+\t    fprintf (asm_out_file, \"\\n\");\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      fprintf (asm_out_file, \"\\n\");\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  }\t\t\t\t\t\t\t\t\t      \\\n+  while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable or function\n+   named NAME. LABELNO is an integer which is different for\n+   each call. */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int len = strlen (NAME);\t\t\t\t\t\t\\\n+    char *temp = (char *) alloca (len + 3);\t\t\t\t\\\n+    temp[0] = 'L';\t\t\t\t\t\t\t\\\n+    strcpy (&temp[1], (NAME));\t\t\t\t\t\t\\\n+    temp[len + 1] = '_';\t\t\t\t\t\t\\\n+    temp[len + 2] = 0;\t\t\t\t\t\t\t\\\n+    (OUTPUT) = (char *) alloca (strlen (NAME) + 11);\t\t\t\\\n+    ASM_GENERATE_INTERNAL_LABEL (OUTPUT, temp, LABELNO);\t\t\\\n+  } while (0)\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+\f\n+/* OUTPUT OF UNINITIALIZED VARIABLES */\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+  asm_output_common (FILE, NAME, SIZE, ROUNDED);\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+  asm_output_local (FILE, NAME, SIZE, ROUNDED);\n+\f\n+/* OUTPUT AND GENERATION OF LABELS */\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".global \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* A C statement to output to the stdio stream any text necessary\n+   for declaring the name of an external symbol named name which\n+   is referenced in this compilation but not defined. */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)   \\\n+{\t\t\t\t\t\\\n+\tfprintf (FILE, \".extern \");\t\\\n+\tassemble_name (FILE, NAME);\t\\\n+\tfprintf (FILE, \"\\n\");\t\t\\\n+}\n+/* A C statement to output on stream an assembler pseudo-op to\n+   declare a library function named external. */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)    \\\n+{\t\t\t\t\t\t\\\n+\tfprintf (FILE, \".extern \");\t\t\\\n+\tassemble_name (FILE, XSTR (FUN, 0));\t\\\n+\tfprintf (FILE, \"\\n\");\t\t\t\\\n+}\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+\f\n+/* OUTPUT OF ASSEMBLER INSTRUCTIONS */\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"a0\", \"a0l\", \"a1\", \"a1l\", \"x\", \"y\", \"yl\", \"p\", \"pl\",  \\\n+ \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n+ \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n+ \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n+ \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n+ \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n+ \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n+ \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n+ \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n+ \"*(30)\", \"*(31)\" }\n+\n+#define HIMODE_REGISTER_NAMES \\\n+{\"a0\", \"a0\", \"a1\", \"a1\", \"x\", \"y\", \"y\", \"p\", \"p\",  \\\n+ \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n+ \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n+ \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n+ \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n+ \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n+ \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n+ \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n+ \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n+ \"*(30)\", \"*(31)\" }\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)  0\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+   \n+   DSP1610 extensions for operand codes:\n+\n+   %H - print lower 16 bits of constant\n+   %U - print upper 16 bits of constant\n+   %w - print low half of register (e.g 'a0l')\n+   %u - print upper half of register (e.g 'a0')\n+   %b - print high half of accumulator for F3 ALU instructions\n+   %h - print constant in decimal   */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE, X, CODE)\n+\n+\n+/* Print a memory address as an operand to reference that memory location. */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address (FILE, ADDR)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code since it is used only for profiling  */\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)    fatal(\"Profiling not implemented yet.\");\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code since it is used only for profiling  */\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)     fatal(\"Profiling not implemented yet.\"); \n+\f\n+/* OUTPUT OF DISPATCH TABLES */\n+\n+/* This macro should be provided on machines where the addresses in a dispatch\n+   table are relative to the table's own address. */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\tint L%d-L%d\\n\", VALUE, REL)\n+\n+/* This macro should be provided on machines where the addresses in a dispatch\n+   table are absolute. */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\tint L%d\\n\", VALUE)\n+\n+/* ASSEMBLER COMMANDS FOR ALIGNMENT */\n+\n+/* This is how to output an assembler line that says to advance \n+   the location counter to a multiple of 2**LOG bytes. We should\n+   not have to do any alignemnt since the 1610 is a word machine. */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\n+\n+/* Define this macro if ASM_OUTPUT_SKIP should not be used in the text section\n+   because it fails to put zero1 in the bytes that are skipped. */\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t%d * int 0\\n\", (SIZE))\n+\n+/* CONTROLLING DEBUGGING INFORMATION FORMAT */\n+\n+/* Define this macro if GCC should produce COFF-style debugging output\n+   for SDB in response to the '-g' option */\n+#define SDB_DEBUGGING_INFO\n+\n+/* Support generating stabs for the listing file generator */\n+#define DBX_DEBUGGING_INFO\n+\n+/* The default format when -g is given is still COFF debug info */\n+#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n+\n+#define DBX_REGISTER_NUMBER(REGNO)   (REGNO)\n+\f\n+/* MISCELLANEOUS PARAMETERS */\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE QImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE  */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this if the library function 'vprintf' is available on your system. */\n+#define HAVE_VPRINTF\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 1\n+\n+/* Defining this macro causes the compiler to omit a sign-extend, zero-extend,\n+   or bitwise 'and' instruction that truncates the count of a shift operation\n+   to a width equal to the number of bits needed to represent the size of the\n+   object being shifted. Do not define this macro unless the trucation applies\n+   to both shoft operations and bit-field operations (if any). */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* An alias for the machine mode used for pointers */\n+#define Pmode  QImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE  QImode\n+\n+#if !defined(__DATE__)\n+#define TARGET_VERSION fprintf (stderr, \" (%s)\", VERSION_INFO1)\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (%s, %s)\", VERSION_INFO1, __DATE__)\n+#endif\n+\n+#define VERSION_INFO1 \"AT&T DSP16xx C Cross Compiler, version 1.2.0\"\n+\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* If this macro is defined, GNU CC gathers statistics about the number and\n+   kind of tree node it allocates during each run. The option '-fstats' will\n+   tell the compiler to print these statistics about the sizes of it obstacks. */\n+#define GATHER_STATISTICS\n+\n+/* Define this so gcc does not output a call to __main, since we\n+   are not currently supporting c++. */\n+#define INIT_SECTION_ASM_OP  1"}]}