{"sha": "a300b8d99432d03d58595799fe063ce0f92ca0b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMwMGI4ZDk5NDMyZDAzZDU4NTk1Nzk5ZmUwNjNjZTBmOTJjYTBiOQ==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-09-08T00:29:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-08T00:29:35Z"}, "message": "global.c: Update comments.\n\n        * global.c: Update comments.\n        (global_alloc): Assign allocation-numbers\n        even for registers allocated by local_alloc in case\n        they are later spilled and retry_global_alloc is called.\n        (mark_reg_store, mark_reg_clobber,\n        mark_reg_conflicts, mark_reg_death): Always record a\n        conflict with a pseudo register even if it has been\n        assigned to a hard register.\n        (dump_conflicts): Don't list pseudo registers already assigned to\n        a hard register as needing to be allocated, but do list their\n        conflicts.\n        * local-alloc.c: Update comment.\n\nFrom-SVN: r22322", "tree": {"sha": "70f176ebecd3be04faa26ac11a0c698bb19fb472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70f176ebecd3be04faa26ac11a0c698bb19fb472"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a300b8d99432d03d58595799fe063ce0f92ca0b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a300b8d99432d03d58595799fe063ce0f92ca0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a300b8d99432d03d58595799fe063ce0f92ca0b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a300b8d99432d03d58595799fe063ce0f92ca0b9/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b877abdeccf1ddf63ab038c1c325b8c8123a3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b877abdeccf1ddf63ab038c1c325b8c8123a3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b877abdeccf1ddf63ab038c1c325b8c8123a3a2"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "05de1f3ca6ad03ae4afb716312e6b8a118b0e0b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a300b8d99432d03d58595799fe063ce0f92ca0b9", "patch": "@@ -1,3 +1,18 @@\n+Sat Sep  5 16:34:34 EDT 1998  John Wehle  (john@feith.com)\n+\n+\t* global.c: Update comments.\n+\t(global_alloc): Assign allocation-numbers\n+\teven for registers allocated by local_alloc in case\n+\tthey are later spilled and retry_global_alloc is called.\n+\t(mark_reg_store, mark_reg_clobber,\n+\tmark_reg_conflicts, mark_reg_death): Always record a\n+\tconflict with a pseudo register even if it has been\n+\tassigned to a hard register.\n+\t(dump_conflicts): Don't list pseudo registers already assigned to\n+\ta hard register as needing to be allocated, but do list their\n+\tconflicts.\n+\t* local-alloc.c: Update comment.\n+\n Mon Sep  7 23:38:01 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* configure.in: Check for bogus GCC_EXEC_PREFIX and LIBRARY_PATH."}, {"sha": "b069584ccdc10c801492255eb96299fc62bc3431", "filename": "gcc/global.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=a300b8d99432d03d58595799fe063ce0f92ca0b9", "patch": "@@ -45,8 +45,9 @@ Boston, MA 02111-1307, USA.  */\n    reg for it.  The reload pass is independent in other respects\n    and it is run even when stupid register allocation is in use.\n \n-   1. count the pseudo-registers still needing allocation\n-   and assign allocation-numbers (allocnos) to them.\n+   1. Assign allocation-numbers (allocnos) to the pseudo-registers\n+   still needing allocations and to the pseudo-registers currently\n+   allocated by local-alloc which may be spilled by reload.\n    Set up tables reg_allocno and allocno_reg to map \n    reg numbers to allocnos and vice versa.\n    max_allocno gets the number of allocnos in use.\n@@ -56,27 +57,26 @@ Boston, MA 02111-1307, USA.  */\n    for conflicts between allocnos and explicit hard register use\n    (which includes use of pseudo-registers allocated by local_alloc).\n \n-   3. for each basic block\n+   3. For each basic block\n     walk forward through the block, recording which\n-    unallocated registers and which hardware registers are live.\n-    Build the conflict matrix between the unallocated registers\n-    and another of unallocated registers versus hardware registers.\n+    pseudo-registers and which hardware registers are live.\n+    Build the conflict matrix between the pseudo-registers\n+    and another of pseudo-registers versus hardware registers.\n     Also record the preferred hardware registers\n-    for each unallocated one.\n+    for each pseudo-register.\n \n    4. Sort a table of the allocnos into order of\n    desirability of the variables.\n \n    5. Allocate the variables in that order; each if possible into\n    a preferred register, else into another register.  */\n \f\n-/* Number of pseudo-registers still requiring allocation\n-   (not allocated by local_allocate).  */\n+/* Number of pseudo-registers which are candidates for allocation. */\n \n static int max_allocno;\n \n /* Indexed by (pseudo) reg number, gives the allocno, or -1\n-   for pseudo registers already allocated by local_allocate.  */\n+   for pseudo registers which are not to be allocated.  */\n \n int *reg_allocno;\n \n@@ -389,13 +389,13 @@ global_alloc (file)\n     /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n        that we are supposed to refrain from putting in a hard reg.\n        -2 means do make an allocno but don't allocate it.  */\n-    if (REG_N_REFS (i) != 0 && reg_renumber[i] < 0 && REG_LIVE_LENGTH (i) != -1\n+    if (REG_N_REFS (i) != 0 && REG_LIVE_LENGTH (i) != -1\n \t/* Don't allocate pseudos that cross calls,\n \t   if this function receives a nonlocal goto.  */\n \t&& (! current_function_has_nonlocal_label\n \t    || REG_N_CALLS_CROSSED (i) == 0))\n       {\n-\tif (reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n+\tif (reg_renumber[i] < 0 && reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n \t  reg_allocno[i] = reg_allocno[reg_may_share[i]];\n \telse\n \t  reg_allocno[i] = max_allocno++;\n@@ -433,7 +433,7 @@ global_alloc (file)\n   bzero ((char *) local_reg_live_length, sizeof local_reg_live_length);\n   bzero ((char *) local_reg_n_refs, sizeof local_reg_n_refs);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_allocno[i] < 0 && reg_renumber[i] >= 0)\n+    if (reg_renumber[i] >= 0)\n       {\n \tint regno = reg_renumber[i];\n \tint endregno = regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (i));\n@@ -561,7 +561,8 @@ global_alloc (file)\n \t except for parameters marked with reg_live_length[regno] == -2.  */\n \n       for (i = 0; i < max_allocno; i++)\n-\tif (REG_LIVE_LENGTH (allocno_reg[allocno_order[i]]) >= 0)\n+\tif (reg_renumber[allocno_reg[allocno_order[i]]] < 0\n+\t    && REG_LIVE_LENGTH (allocno_reg[allocno_order[i]]) >= 0)\n \t  {\n \t    /* If we have more than one register class,\n \t       first try allocating in the class that is cheapest\n@@ -1364,9 +1365,6 @@ mark_reg_store (orig_reg, setter)\n \n   regno = REGNO (reg);\n \n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno] /* + word */;\n-\n   /* Either this is one of the max_allocno pseudo regs not allocated,\n      or it is or has a hardware reg.  First handle the pseudo-regs.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -1377,8 +1375,12 @@ mark_reg_store (orig_reg, setter)\n \t  record_one_conflict (regno);\n \t}\n     }\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno] /* + word */;\n+\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  else if (! fixed_regs[regno])\n+  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n       register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n@@ -1420,9 +1422,6 @@ mark_reg_clobber (reg, setter)\n \n   regno = REGNO (reg);\n \n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno] /* + word */;\n-\n   /* Either this is one of the max_allocno pseudo regs not allocated,\n      or it is or has a hardware reg.  First handle the pseudo-regs.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -1433,8 +1432,12 @@ mark_reg_clobber (reg, setter)\n \t  record_one_conflict (regno);\n \t}\n     }\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno] /* + word */;\n+\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  else if (! fixed_regs[regno])\n+  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n       register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n@@ -1463,18 +1466,19 @@ mark_reg_conflicts (reg)\n \n   regno = REGNO (reg);\n \n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n   /* Either this is one of the max_allocno pseudo regs not allocated,\n      or it is or has a hardware reg.  First handle the pseudo-regs.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       if (reg_allocno[regno] >= 0)\n \trecord_one_conflict (regno);\n     }\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  else if (! fixed_regs[regno])\n+  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n       register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n@@ -1494,19 +1498,20 @@ mark_reg_death (reg)\n {\n   register int regno = REGNO (reg);\n \n-  /* For pseudo reg, see if it has been assigned a hardware reg.  */\n-  if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno];\n-\n   /* Either this is one of the max_allocno pseudo regs not allocated,\n      or it is a hardware reg.  First handle the pseudo-regs.  */\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       if (reg_allocno[regno] >= 0)\n \tCLEAR_ALLOCNO_LIVE (reg_allocno[regno]);\n     }\n+\n+  /* For pseudo reg, see if it has been assigned a hardware reg.  */\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n-  else if (! fixed_regs[regno])\n+  if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n       /* Pseudo regs already assigned hardware regs are treated\n \t almost the same as explicit hardware regs.  */\n@@ -1661,10 +1666,20 @@ dump_conflicts (file)\n {\n   register int i;\n   register int has_preferences;\n-  fprintf (file, \";; %d regs to allocate:\", max_allocno);\n+  register int nregs;\n+  nregs = 0;\n+  for (i = 0; i < max_allocno; i++)\n+    {\n+      if (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+        continue;\n+      nregs++;\n+    }\n+  fprintf (file, \";; %d regs to allocate:\", nregs);\n   for (i = 0; i < max_allocno; i++)\n     {\n       int j;\n+      if (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+\tcontinue;\n       fprintf (file, \" %d\", allocno_reg[allocno_order[i]]);\n       for (j = 0; j < max_regno; j++)\n \tif (reg_allocno[j] == allocno_order[i]"}, {"sha": "5dbde5218f8f2cffcfd052255294665668529901", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a300b8d99432d03d58595799fe063ce0f92ca0b9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a300b8d99432d03d58595799fe063ce0f92ca0b9", "patch": "@@ -55,8 +55,8 @@ Boston, MA 02111-1307, USA.  */\n    But this is currently disabled since tying in global_alloc is not\n    yet implemented.  */\n \n-/* Pseudos allocated here cannot be reallocated by global.c if the hard\n-   register is used as a spill register.  So we don't allocate such pseudos\n+/* Pseudos allocated here can be reallocated by global.c if the hard register\n+   is used as a spill register.  Currently we don't allocate such pseudos\n    here if their preferred class is likely to be used by spills.  */\n \n #include \"config.h\""}]}