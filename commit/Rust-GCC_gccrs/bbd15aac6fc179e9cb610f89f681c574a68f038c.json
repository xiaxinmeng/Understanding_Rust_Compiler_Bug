{"sha": "bbd15aac6fc179e9cb610f89f681c574a68f038c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkMTVhYWM2ZmMxNzllOWNiNjEwZjg5ZjY4MWM1NzRhNjhmMDM4Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-17T04:08:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-17T04:08:01Z"}, "message": "cp-tree.h (flag_new_abi): Move.\n\n\t* cp-tree.h (flag_new_abi): Move.\n\t(flag_use_cxa_atexit): Likewise.\n\t(flag_honor_std): Likewise.\n\t(flag_rtti): Likewise.\n\t(vbase_offsets_in_vtable_p): Define.\n\t(vptrs_present_everywhere_p): Likewise.\n\t(TYPE_CONTAINS_VPTR_P): Likewise.\n\t(dfs_walk_real): Declare.\n\t* class.c (build_vbase_pointer_fields): Check\n\tvbase_offsets_in_vtable_p.\n\t(dfs_build_vbase_offset_vtbl_entries): Record the vbase indices in\n\tBINFO_VPTR_FIELD.\n\t(build_vbase_offset_vtbl_entries): Simplify.\n\t(build_vbase_offset_vtbl_entries): Adjust.\n\t(build_vbase_pointer): Add ability to look up vbase offsets in\n\tvtable.\n\t(start_vtable): New function.\n\t(add_virtual_function): Use it.\n\t(determine_primary_base): Use TYPE_CONTAINS_VPTR_P.\n\t(num_extra_vtbl_entries): Use vbase_offsets_in_vtable_p.\n\t(build_vtbl_initializer): Take the type of the complete object as\n\tinput.  Use it to correctly calculate vbase offsets.\n\t(dfs_finish_vtbls): Pass the complete type to\n\tbuild_vtbl_initializer.\n\t(check_bases_and_members): Use TYPE_CONTAINS_VPTR_P.\n\t(create_vtable_ptr): Create a vtable even if there are no\n\tnew virtual functions, under the new ABI.\n\t(finish_struct_1): Likewise.\n\t(get_vfield_name): Use TYPE_CONTAINS_VPTR_P.\n\t* decl.c (exapnd_static_init): Remove call to\n\tpreserve_initializer.\n\t* decl2.c (mark_vtable_entries): Tweak to handle vbase offsets in\n\tvtables.\n\t* init.c (initialize_vtbl_ptrs): Initialize them in pre-order.\n\t(expand_virtual_init): Use vbase_offsets_in_vtable_p.\n\t(construct_virtual_bases): Don't initialize virtual base pointers\n\tunder the new ABI.\n\t(build_aggr_init): Clean up comment.\n\t(expand_aggr_init_1): Likewise.\n\t* rtti.c (expand_class_desc): Store the virtual function table\n\tindex where the vbase offset lives in the offset field.\n\t* search.c (dfs_walk_real): Make it global.\n\t(dfs_debug_mark): Use TYPE_CONTAINS_VPTR_P.\n\t* tree.c (make_binfo): Don't clear BINFO_VPTR_FIELD.\n\n\t* tinfo.h (USItype): Make it signed under the new ABI.\n\t* tinfo.cc (convert_to_base): New function.  Encapsulate base\n\tconversion logic here.\n\t(__class_type_info::do_upcast): Use it.\n\t(__class_type_info::do_dyncast): Likewise.\n\t(__class_type_info::do_find_public_subobj): Likewise.\n\nFrom-SVN: r31452", "tree": {"sha": "42b7f7c924e40aafb6389868bb1bc5b33ec746bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b7f7c924e40aafb6389868bb1bc5b33ec746bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbd15aac6fc179e9cb610f89f681c574a68f038c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd15aac6fc179e9cb610f89f681c574a68f038c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbd15aac6fc179e9cb610f89f681c574a68f038c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd15aac6fc179e9cb610f89f681c574a68f038c/comments", "author": null, "committer": null, "parents": [{"sha": "2a198bc4bf775957b2cfbe5cf2b21b5f3c2d1482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a198bc4bf775957b2cfbe5cf2b21b5f3c2d1482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a198bc4bf775957b2cfbe5cf2b21b5f3c2d1482"}], "stats": {"total": 507, "additions": 335, "deletions": 172}, "files": [{"sha": "f8f2bdf285d78f14f542c25d65b57cf0e80e3abc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -1,5 +1,57 @@\n 2000-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (flag_new_abi): Move.\n+\t(flag_use_cxa_atexit): Likewise.\n+\t(flag_honor_std): Likewise.\n+\t(flag_rtti): Likewise.\n+\t(vbase_offsets_in_vtable_p): Define.\n+\t(vptrs_present_everywhere_p): Likewise.\n+\t(TYPE_CONTAINS_VPTR_P): Likewise.\n+\t(dfs_walk_real): Declare.\n+\t* class.c (build_vbase_pointer_fields): Check\n+\tvbase_offsets_in_vtable_p.\n+\t(dfs_build_vbase_offset_vtbl_entries): Record the vbase indices in\n+\tBINFO_VPTR_FIELD.\n+\t(build_vbase_offset_vtbl_entries): Simplify.\n+\t(build_vbase_offset_vtbl_entries): Adjust.\n+\t(build_vbase_pointer): Add ability to look up vbase offsets in\n+\tvtable. \n+\t(start_vtable): New function.\n+\t(add_virtual_function): Use it.\n+\t(determine_primary_base): Use TYPE_CONTAINS_VPTR_P.\n+\t(num_extra_vtbl_entries): Use vbase_offsets_in_vtable_p.\n+\t(build_vtbl_initializer): Take the type of the complete object as\n+\tinput.  Use it to correctly calculate vbase offsets.\n+\t(dfs_finish_vtbls): Pass the complete type to\n+\tbuild_vtbl_initializer.\n+\t(check_bases_and_members): Use TYPE_CONTAINS_VPTR_P.\n+\t(create_vtable_ptr): Create a vtable even if there are no\n+\tnew virtual functions, under the new ABI.\n+\t(finish_struct_1): Likewise.\n+\t(get_vfield_name): Use TYPE_CONTAINS_VPTR_P.\n+\t* decl.c (exapnd_static_init): Remove call to\n+\tpreserve_initializer.\n+\t* decl2.c (mark_vtable_entries): Tweak to handle vbase offsets in\n+\tvtables.\n+\t* init.c (initialize_vtbl_ptrs): Initialize them in pre-order.\n+\t(expand_virtual_init): Use vbase_offsets_in_vtable_p.\n+\t(construct_virtual_bases): Don't initialize virtual base pointers\n+\tunder the new ABI.\n+\t(build_aggr_init): Clean up comment.\n+\t(expand_aggr_init_1): Likewise.\n+\t* rtti.c (expand_class_desc): Store the virtual function table\n+\tindex where the vbase offset lives in the offset field.\n+\t* search.c (dfs_walk_real): Make it global.\n+\t(dfs_debug_mark): Use TYPE_CONTAINS_VPTR_P.\n+\t* tree.c (make_binfo): Don't clear BINFO_VPTR_FIELD.\n+\t\n+\t* tinfo.h (USItype): Make it signed under the new ABI.\n+\t* tinfo.cc (convert_to_base): New function.  Encapsulate base\n+\tconversion logic here.\n+\t(__class_type_info::do_upcast): Use it.\n+\t(__class_type_info::do_dyncast): Likewise.\n+\t(__class_type_info::do_find_public_subobj): Likewise.\n+\t\n \t* init.c (construct_virtual_bases): Don't look up the addresses of\n \tvirtual bases at run-time.\n "}, {"sha": "8c1073e64bf4fa6dd0fb1fdc158a6e28a878d3cf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 131, "deletions": 82, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -115,7 +115,7 @@ static tree resolve_address_of_overloaded_function PROTO((tree, tree, int,\n \t\t\t\t\t\t\t  int, tree));\n static void build_vtable_entry_ref PROTO((tree, tree, tree));\n static tree build_vtable_entry_for_fn PROTO((tree, tree));\n-static tree build_vtbl_initializer PROTO((tree));\n+static tree build_vtbl_initializer PROTO((tree, tree));\n static int count_fields PROTO((tree));\n static int add_fields_to_vec PROTO((tree, tree, int));\n static void check_bitfield_decl PROTO((tree));\n@@ -145,7 +145,8 @@ static void remove_base_fields PROTO((tree));\n static tree dfs_set_offset_for_shared_vbases PROTO((tree, void *));\n static tree dfs_set_offset_for_unshared_vbases PROTO((tree, void *));\n static tree dfs_build_vbase_offset_vtbl_entries PROTO((tree, void *));\n-static tree build_vbase_offset_vtbl_entries PROTO((tree));\n+static tree build_vbase_offset_vtbl_entries PROTO((tree, tree));\n+static void start_vtable PROTO((tree, int *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -178,9 +179,12 @@ build_vbase_pointer_fields (rec, empty_p)\n   tree decl;\n   int i;\n \n-  /* Handle basetypes almost like fields, but record their\n-     offsets differently.  */\n+  /* Under the new ABI, there are no vbase pointers in the object.\n+     Instead, the offsets are stored in the vtable.  */\n+  if (vbase_offsets_in_vtable_p ())\n+    return NULL_TREE;\n \n+  /* Loop over the baseclasses, adding vbase pointers as needed.  */\n   for (i = 0; i < n_baseclasses; i++)\n     {\n       register tree base_binfo = TREE_VEC_ELT (binfos, i);\n@@ -251,80 +255,74 @@ dfs_build_vbase_offset_vtbl_entries (binfo, data)\n   else if (TREE_VIA_VIRTUAL (binfo))\n     {\n       tree init;\n+      tree vbase;\n+\n+      /* Remember the index to the vbase offset for this virtual\n+\t base.  */\n+      vbase = BINFO_FOR_VBASE (TREE_TYPE (binfo), TREE_PURPOSE (list));\n+      if (!TREE_VALUE (list))\n+\tBINFO_VPTR_FIELD (vbase) = build_int_2 (-1, 0);\n+      else\n+\t{\n+\t  BINFO_VPTR_FIELD (vbase) = TREE_PURPOSE (TREE_VALUE (list));\n+\t  BINFO_VPTR_FIELD (vbase) = ssize_binop (MINUS_EXPR,\n+\t\t\t\t\t\t  BINFO_VPTR_FIELD (vbase),\n+\t\t\t\t\t\t  integer_one_node);\n+\t}\n \n+      /* And record the offset at which this virtual base lies in the\n+\t vtable.  */\n       init = BINFO_OFFSET (binfo);\n-      init = build1 (NOP_EXPR, vtable_entry_type, init);\n-      TREE_VALUE (list) = tree_cons (NULL_TREE, init, TREE_VALUE (list));\n+      TREE_VALUE (list) = tree_cons (BINFO_VPTR_FIELD (vbase),\n+\t\t\t\t     init, \n+\t\t\t\t     TREE_VALUE (list));\n     }\n \n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n   \n   return NULL_TREE;\n }\n \n-/* Returns the initializers for the vbase offset entries in the\n-   vtable, in reverse order.  */\n+/* Returns the initializers for the vbase offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T), in\n+   reverse order.  */\n \n static tree\n-build_vbase_offset_vtbl_entries (binfo)\n+build_vbase_offset_vtbl_entries (binfo, t)\n      tree binfo;\n+     tree t;\n {\n-  tree type;\n   tree inits;\n   tree init;\n+  tree list;\n \n   /* Under the old ABI, pointers to virtual bases are stored in each\n      object.  */\n-  if (!flag_new_abi)\n+  if (!vbase_offsets_in_vtable_p ())\n     return NULL_TREE;\n \n   /* If there are no virtual baseclasses, then there is nothing to\n      do.  */\n-  type = BINFO_TYPE (binfo);\n-  if (!TYPE_USES_VIRTUAL_BASECLASSES (type))\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n     return NULL_TREE;\n \n   inits = NULL_TREE;\n \n-  /* Under the new ABI, the vtable contains offsets to all virtual\n-     bases.  The ABI specifies different layouts depending on whether\n-     or not *all* of the bases of this type are virtual.  */\n-  if (CLASSTYPE_N_BASECLASSES (type) \n-      == list_length (CLASSTYPE_VBASECLASSES (type)))\n-    {\n-      /* In this case, the offsets are allocated from right to left of\n-\t the declaration order in which the virtual bases appear.  */\n-      int i;\n-\n-      for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-\t{\n-\t  tree vbase = BINFO_BASETYPE (binfo, i);\n-\t  init = BINFO_OFFSET (vbase);\n-\t  init = build1 (NOP_EXPR, vtable_entry_type, init);\n-\t  inits = tree_cons (NULL_TREE, init, inits);\n-\t}\n-    }\n-  else\n-    {\n-      tree list;\n-\n-      /* While in this case, the offsets are allocated in the reverse\n-\t order of a depth-first left-to-right traversal of the\n-\t hierarchy.  We use BINFO_VTABLE_PATH_MARKED because we are\n-\t ourselves during a dfs_walk, and so BINFO_MARKED is already\n-\t in use.  */\n-      list = build_tree_list (type, NULL_TREE);\n-      TREE_TYPE (list) = binfo;\n-      dfs_walk (binfo,\n-\t\tdfs_build_vbase_offset_vtbl_entries,\n-\t\tdfs_vtable_path_unmarked_real_bases_queue_p,\n-\t\tlist);\n-      dfs_walk (binfo,\n-\t\tdfs_vtable_path_unmark,\n-\t\tdfs_vtable_path_marked_real_bases_queue_p,\n-\t\tlist);\n-      inits = nreverse (TREE_VALUE (list));\n-    }\n+  /* The offsets are allocated in the reverse order of a\n+     depth-first left-to-right traversal of the hierarchy.  We use\n+     BINFO_VTABLE_PATH_MARKED because we are ourselves during a\n+     dfs_walk, and so BINFO_MARKED is already in use.  */\n+  list = build_tree_list (t, NULL_TREE);\n+  TREE_TYPE (list) = binfo;\n+  dfs_walk (binfo,\n+\t    dfs_build_vbase_offset_vtbl_entries,\n+\t    dfs_vtable_path_unmarked_real_bases_queue_p,\n+\t    list);\n+  dfs_walk (binfo,\n+\t    dfs_vtable_path_unmark,\n+\t    dfs_vtable_path_marked_real_bases_queue_p,\n+\t    list);\n+  inits = nreverse (TREE_VALUE (list));\n \n   /* We've now got offsets in the right oder.  However, the offsets\n      we've stored are offsets from the beginning of the complete\n@@ -334,26 +332,55 @@ build_vbase_offset_vtbl_entries (binfo)\n       tree exp = TREE_VALUE (init);\n \n       exp = ssize_binop (MINUS_EXPR, exp, BINFO_OFFSET (binfo));\n-      exp = build1 (NOP_EXPR, vtable_entry_type, TREE_VALUE (init));\n+      exp = build1 (NOP_EXPR, vtable_entry_type, exp);\n       exp = fold (exp);\n       TREE_CONSTANT (exp) = 1;\n+      /* The dfs_build_vbase_offset_vtbl_entries routine uses the\n+\t TREE_PURPOSE to scribble in.  But, we need to clear it now so\n+\t that the values are not perceived as labeled initializers.  */\n+      TREE_PURPOSE (init) = NULL_TREE;\n       TREE_VALUE (init) = exp;\n     }\n \n   return inits;\n }\n \n /* Returns a pointer to the virtual base class of EXP that has the\n-   indicated TYPE.  */\n+   indicated TYPE.  EXP is of class type, not a pointer type.  */\n \n static tree\n build_vbase_pointer (exp, type)\n      tree exp, type;\n {\n-  char *name;\n-  FORMAT_VBASE_NAME (name, type);\n-\n-  return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n+  if (vbase_offsets_in_vtable_p ())\n+    {\n+      tree vbase;\n+      tree vbase_ptr;\n+\n+      /* Find the shared copy of TYPE; that's where the vtable offset\n+\t is recorded.  */\n+      vbase = BINFO_FOR_VBASE (type, TREE_TYPE (exp));\n+      /* Find the virtual function table pointer.  */\n+      vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n+      /* Compute the location where the offset will lie.  */\n+      vbase_ptr = build_binary_op (PLUS_EXPR, \n+\t\t\t\t   vbase_ptr,\n+\t\t\t\t   BINFO_VPTR_FIELD (vbase));\n+      vbase_ptr = build1 (NOP_EXPR, \n+\t\t\t  build_pointer_type (ptrdiff_type_node),\n+\t\t\t  vbase_ptr);\n+      /* Add the contents of this location to EXP.  */\n+      return build (PLUS_EXPR,\n+\t\t    build_pointer_type (type),\n+\t\t    build_unary_op (ADDR_EXPR, exp, /*noconvert=*/0),\n+\t\t    build1 (INDIRECT_REF, ptrdiff_type_node, vbase_ptr));\n+    }\n+  else\n+    {\n+      char *name;\n+      FORMAT_VBASE_NAME (name, type);\n+      return build_component_ref (exp, get_identifier (name), NULL_TREE, 0);\n+    }\n }\n \n /* Build multi-level access to EXPR using hierarchy path PATH.\n@@ -1100,6 +1127,25 @@ get_vtable_entry_n (virtuals, n)\n   return virtuals;\n }\n \n+/* Call this function whenever its known that a vtable for T is going\n+   to be needed.  It's safe to call it more than once.  *HAS_VIRTUAL_P\n+   is initialized to the number of slots that are reserved at the\n+   beginning of the vtable for RTTI information.  */\n+\n+static void\n+start_vtable (t, has_virtual_p)\n+     tree t;\n+     int *has_virtual_p;\n+{\n+  if (*has_virtual_p == 0 && ! CLASSTYPE_COM_INTERFACE (t))\n+    {\n+      if (flag_vtable_thunks)\n+\t*has_virtual_p = 2;\n+      else\n+\t*has_virtual_p = 1;\n+    }\n+}\n+\n /* Add a virtual function to all the appropriate vtables for the class\n    T.  DECL_VINDEX(X) should be error_mark_node, if we want to\n    allocate a new slot in our table.  If it is error_mark_node, we\n@@ -1139,13 +1185,7 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n       /* If we are using thunks, use two slots at the front, one\n \t for the offset pointer, one for the tdesc pointer.\n          For ARM-style vtables, use the same slot for both.  */\n-      if (*has_virtual == 0 && ! CLASSTYPE_COM_INTERFACE (t))\n-\t{\n-\t  if (flag_vtable_thunks)\n-\t    *has_virtual = 2;\n-\t  else\n-\t    *has_virtual = 1;\n-\t}\n+      start_vtable (t, has_virtual);\n \n       /* Build a new INT_CST for this DECL_VINDEX.  */\n       {\n@@ -1767,7 +1807,7 @@ determine_primary_base (t, has_virtual_p)\n       tree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n       tree basetype = BINFO_TYPE (base_binfo);\n \n-      if (TYPE_POLYMORPHIC_P (basetype))\n+      if (TYPE_CONTAINS_VPTR_P (basetype))\n \t{\n \t  /* Even a virtual baseclass can contain our RTTI\n \t     information.  But, we prefer a non-virtual polymorphic\n@@ -2287,9 +2327,8 @@ num_extra_vtbl_entries (binfo)\n   tree type;\n   int entries;\n \n-\n   /* Under the old ABI, there are no entries at negative offsets.  */\n-  if (!flag_new_abi)\n+  if (!vbase_offsets_in_vtable_p ())\n     return size_zero_node;\n \n   type = BINFO_TYPE (binfo);\n@@ -2317,18 +2356,20 @@ size_extra_vtbl_entries (binfo)\n   return fold (offset);\n }\n \n-/* Construct the initializer for BINFOs virtual function table.  */\n+/* Construct the initializer for BINFOs virtual function table.  BINFO\n+   is part of the hierarchy dominated by T.  */\n \n static tree\n-build_vtbl_initializer (binfo)\n+build_vtbl_initializer (binfo, t)\n      tree binfo;\n+     tree t;\n {\n   tree v = BINFO_VIRTUALS (binfo);\n   tree inits = NULL_TREE;\n   tree type = BINFO_TYPE (binfo);\n \n   /* Add entries to the vtable for offsets to our virtual bases.  */\n-  inits = build_vbase_offset_vtbl_entries (binfo);\n+  inits = build_vbase_offset_vtbl_entries (binfo, t);\n \n   /* Process the RTTI stuff at the head of the list.  If we're not\n      using vtable thunks, then the RTTI entry is just an ordinary\n@@ -2397,7 +2438,7 @@ build_vtbl_initializer (binfo)\n static tree\n dfs_finish_vtbls (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n   if (!BINFO_PRIMARY_MARKED_P (binfo)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n@@ -2409,7 +2450,7 @@ dfs_finish_vtbls (binfo, data)\n       decl = BINFO_VTABLE (binfo);\n       context = DECL_CONTEXT (decl);\n       DECL_CONTEXT (decl) = 0;\n-      DECL_INITIAL (decl) = build_vtbl_initializer (binfo);\n+      DECL_INITIAL (decl) = build_vtbl_initializer (binfo, (tree) data);\n       cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n       DECL_CONTEXT (decl) = context;\n     }\n@@ -4112,9 +4153,9 @@ check_bases_and_members (t, empty_p)\n   /* Check all the method declarations.  */\n   check_methods (t);\n \n-  /* A nearly-empty class has to be polymorphic; a nearly empty class\n-     contains a vptr.  */\n-  if (!TYPE_POLYMORPHIC_P (t))\n+  /* A nearly-empty class has to be vptr-containing; a nearly empty\n+     class contains just a vptr.  */\n+  if (!TYPE_CONTAINS_VPTR_P (t))\n     CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \n   /* Do some bookkeeping that will guide the generation of implicitly\n@@ -4177,6 +4218,12 @@ create_vtable_ptr (t, empty_p, has_virtual_p,\n       add_virtual_function (pending_virtuals_p, pending_hard_virtuals_p,\n \t\t\t    has_virtual_p, fn, t);\n \n+  /* Even if there weren't any new virtual functions, we might need a\n+     new virtual function table if we're supposed to include vptrs in\n+     all classes that need them.  */\n+  if (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ())\n+    start_vtable (t, has_virtual_p);\n+    \n   /* If we couldn't find an appropriate base class, create a new field\n      here.  */\n   if (*has_virtual_p && !TYPE_VFIELD (t))\n@@ -4771,7 +4818,7 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n \n-  if (flag_rtti && TYPE_POLYMORPHIC_P (t) && !pending_hard_virtuals)\n+  if (flag_rtti && TYPE_CONTAINS_VPTR_P (t) && !pending_hard_virtuals)\n     modify_all_vtables (t, NULL_TREE);\n \n   for (pending_hard_virtuals = nreverse (pending_hard_virtuals);\n@@ -4802,9 +4849,9 @@ finish_struct_1 (t)\n \t}\n     }\n \n-  /* Under our model of GC, every C++ class gets its own virtual\n-     function table, at least virtually.  */\n-  if (pending_virtuals)\n+  /* If necessary, create the vtable for this class.  */\n+  if (pending_virtuals\n+      || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ()))\n     {\n       pending_virtuals = nreverse (pending_virtuals);\n       /* We must enter these virtuals into the table.  */\n@@ -4836,6 +4883,8 @@ finish_struct_1 (t)\n \n       CLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n+  /* If we didn't need a new vtable, see if we should copy one from\n+     the base.  */\n   else if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n     {\n       tree binfo = CLASSTYPE_PRIMARY_BINFO (t);\n@@ -4855,7 +4904,7 @@ finish_struct_1 (t)\n \tCLASSTYPE_NEEDS_VIRTUAL_REINIT (t) = 1;\n     }\n \n-  if (TYPE_POLYMORPHIC_P (t))\n+  if (TYPE_CONTAINS_VPTR_P (t))\n     {\n       CLASSTYPE_VSIZE (t) = has_virtual;\n       if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n@@ -6004,7 +6053,7 @@ get_vfield_name (type)\n   char *buf;\n \n   while (BINFO_BASETYPES (binfo)\n-\t && TYPE_POLYMORPHIC_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n+\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASETYPE (binfo, 0)))\n \t && ! TREE_VIA_VIRTUAL (BINFO_BASETYPE (binfo, 0)))\n     binfo = BINFO_BASETYPE (binfo, 0);\n "}, {"sha": "b171b1fdf57607b315aadc8011a63be926271854", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -177,7 +177,44 @@ Boston, MA 02111-1307, USA.  */\n #define RECORD_OR_UNION_TYPE_CHECK(NODE)\tNODE\n \n #endif\n+\f\n+/* ABI control.  */\n+\n+/* Nonzero to enable experimental ABI changes.  */\n+\n+extern int flag_new_abi;\n+\n+/* Nonzero to use __cxa_atexit, rather than atexit, to register\n+   destructors for local statics and global objects.  */\n+\n+extern int flag_use_cxa_atexit;\n+\n+/* Nonzero to not ignore namespace std. */\n \n+extern int flag_honor_std;\n+\n+/* Nonzero means generate 'rtti' that give run-time type information.  */\n+\n+extern int flag_rtti;\n+\n+/* Nonzero if virtual base class offsets are stored in the virtual\n+   function table.  Zero if, instead, a pointer to the virtual base is\n+   stored in the object itself.  */\n+#define vbase_offsets_in_vtable_p() (flag_new_abi)\n+\n+/* Nonzero if a derived class that needs a vptr should always get one,\n+   even if a non-primary base class already has one.  For example,\n+   given:\n+\n+     struct S { int i; virtual void f(); };\n+     struct T : virtual public S {};\n+\n+   one could either reuse the vptr in `S' for `T', or create a new\n+   vptr for `T'.  If this flag is nonzero we choose the latter\n+   alternative; otherwise, we choose the former.  */\n+#define vptrs_present_everywhere_p() (flag_new_abi)\n+\n+\f\n /* Language-dependent contents of an identifier.  */\n \n struct lang_identifier\n@@ -2156,6 +2193,12 @@ struct lang_decl\n    polymorphic class.  */\n #define TYPE_POLYMORPHIC_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n \n+/* Nonzero if this class has a virtual function table pointer.  */\n+#define TYPE_CONTAINS_VPTR_P(NODE) \t\t\\\n+  (TYPE_POLYMORPHIC_P (NODE) \t\t\t\\\n+   || (vbase_offsets_in_vtable_p () \t\t\\\n+       && TYPE_USES_VIRTUAL_BASECLASSES (NODE)))\n+\n extern int flag_new_for_scope;\n \n /* This flag is true of a local VAR_DECL if it was declared in a for\n@@ -3160,10 +3203,6 @@ extern struct pending_inline *pending_inlines;\n \n extern int flag_this_is_variable;\n \n-/* Nonzero means generate 'rtti' that give run-time type information.  */\n-\n-extern int flag_rtti;\n-\n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n \n@@ -3187,19 +3226,6 @@ extern int flag_implicit_templates;\n \n extern int flag_weak;\n \n-/* Nonzero to enable experimental ABI changes.  */\n-\n-extern int flag_new_abi;\n-\n-/* Nonzero to use __cxa_atexit, rather than atexit, to register\n-   destructors for local statics and global objects.  */\n-\n-extern int flag_use_cxa_atexit;\n-\n-/* Nonzero to not ignore namespace std. */\n-\n-extern int flag_honor_std;\n-\n /* Nonzero if we should expand functions calls inline at the tree\n    level, rather than at the RTL level.  */\n \n@@ -3961,6 +3987,11 @@ extern tree dfs_walk                            PROTO((tree,\n \t\t\t\t\t\t       tree (*)(tree, void *),\n \t\t\t\t\t\t       tree (*) (tree, void *),\n \t\t\t\t\t\t       void *));\n+extern tree dfs_walk_real                      PROTO ((tree, \n+\t\t\t\t\t\t       tree (*) (tree, void *),\n+\t\t\t\t\t\t       tree (*) (tree, void *),\n+\t\t\t\t\t\t       tree (*) (tree, void *),\n+\t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PROTO((tree, void *));\n extern tree dfs_vbase_unmark                    PROTO((tree, void *));\n extern tree dfs_vtable_path_unmark              PROTO((tree, void *));"}, {"sha": "0a5dc568f48059ba08a8668081822e20d450f1b5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -8201,15 +8201,7 @@ expand_static_init (decl, init)\n       finish_if_stmt ();\n     }\n   else\n-    {\n-      /* This code takes into account memory allocation policy of\n-\t `start_decl'.  Namely, if TYPE_NEEDS_CONSTRUCTING does not\n-\t hold for this object, then we must make permanent the storage\n-\t currently in the temporary obstack.  */\n-      if (!TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n-\tpreserve_initializer ();\n-      static_aggregates = tree_cons (init, decl, static_aggregates);\n-    }\n+    static_aggregates = tree_cons (init, decl, static_aggregates);\n }\n \n /* Finish the declaration of a catch-parameter.  */"}, {"sha": "10d071e4ec3769f76c975eac6aefaa0676f0e3ca", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -2296,8 +2296,9 @@ mark_vtable_entries (decl)\n       fnaddr = (flag_vtable_thunks ? TREE_VALUE (entries) \n \t\t: FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries)));\n \n-      if (TREE_CODE (fnaddr) == NOP_EXPR)\n-\t/* RTTI offset.  */\n+      if (TREE_CODE (fnaddr) != ADDR_EXPR)\n+\t/* This entry is an offset: a virtual base class offset, a\n+\t   virtual call offset, and RTTI offset, etc.  */\n \tcontinue;\n \n       fn = TREE_OPERAND (fnaddr, 0);"}, {"sha": "b5a1ac43bf8344de2850c80be3f11520c3e0a492", "filename": "gcc/cp/init.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -119,8 +119,12 @@ initialize_vtbl_ptrs (type, addr)\n {\n   tree list = build_tree_list (type, addr);\n \n-  dfs_walk (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, \n-\t    dfs_unmarked_real_bases_queue_p, list);\n+  /* Walk through the hierarchy, initializing the vptr in each base\n+     class.  We do these in pre-order because under the new ABI we\n+     can't find the virtual bases for a class until we've initialized\n+     the vtbl for that class.  */\n+  dfs_walk_real (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, \n+\t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n   dfs_walk (TYPE_BINFO (type), dfs_unmark,\n \t    dfs_marked_real_bases_queue_p, type);\n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n@@ -657,7 +661,7 @@ expand_virtual_init (binfo, decl)\n   vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n   /* Under the new ABI, we need to point into the middle of the\n      vtable.  */\n-  if (flag_new_abi)\n+  if (vbase_offsets_in_vtable_p ())\n     vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, \n \t\t  size_extra_vtbl_entries (binfo));\n \n@@ -720,7 +724,7 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n /* Construct the virtual base-classes of THIS_REF (whose address is\n    THIS_PTR).  The object has the indicated TYPE.  The construction\n    actually takes place only if FLAG is non-zero.  INIT_LIST is list\n-   of initialization for constructor to perform.  */\n+   of initializations for constructors to perform.  */\n \n static void\n construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n@@ -731,21 +735,25 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n      tree flag;\n {\n   tree vbases;\n-  tree result;\n-  tree if_stmt;\n \n   /* If there are no virtual baseclasses, we shouldn't even be here.  */\n   my_friendly_assert (TYPE_USES_VIRTUAL_BASECLASSES (type), 19990621);\n \n   /* First set the pointers in our object that tell us where to find\n      our virtual baseclasses.  */\n-  if_stmt = begin_if_stmt ();\n-  finish_if_stmt_cond (flag, if_stmt);\n-  result = init_vbase_pointers (type, this_ptr);\n-  if (result)\n-    finish_expr_stmt (build_compound_expr (result));\n-  finish_then_clause (if_stmt);\n-  finish_if_stmt ();\n+  if (!vbase_offsets_in_vtable_p ())\n+    {\n+      tree if_stmt;\n+      tree result;\n+\n+      if_stmt = begin_if_stmt ();\n+      finish_if_stmt_cond (flag, if_stmt);\n+      result = init_vbase_pointers (type, this_ptr);\n+      if (result)\n+\tfinish_expr_stmt (build_compound_expr (result));\n+      finish_then_clause (if_stmt);\n+      finish_if_stmt ();\n+    }\n \n   /* Now, run through the baseclasses, initializing each.  */ \n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases;\n@@ -1019,11 +1027,6 @@ finish_init_stmts (stmt_expr, compound_stmt)\n    If `init' is a CONSTRUCTOR, then we emit a warning message,\n    explaining that such initializations are invalid.\n \n-   ALIAS_THIS is nonzero iff we are initializing something which is\n-   essentially an alias for current_class_ref.  In this case, the base\n-   constructor may move it on us, and we must keep track of such\n-   deviations.\n-\n    If INIT resolves to a CALL_EXPR which happens to return\n    something of the type we are looking for, then we know\n    that we can safely use that call to perform the\n@@ -1217,8 +1220,6 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n    from TRUE_EXP.  In constructors, we don't know anything about\n    the value being initialized.\n \n-   ALIAS_THIS serves the same purpose it serves for expand_aggr_init.\n-\n    FLAGS is just passes to `build_method_call'.  See that function for\n    its description.  */\n "}, {"sha": "cddefe7dae2a28c0d20be897aed0a65b2a18689f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -1,5 +1,5 @@\n /* RunTime Type Identification\n-   Copyright (C) 1995, 96-97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 96-97, 1998, 1999, 2000 Free Software Foundation, Inc.\n    Mostly written by Jason Merrill (jason@cygnus.com).\n \n This file is part of GNU CC.\n@@ -811,7 +811,8 @@ expand_class_desc (tdecl, type)\n \t\t\t     (type_info_type_node,\n \t\t\t      TYPE_QUAL_CONST)));\n       fields [1] = build_lang_decl\n-\t(FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n+\t(FIELD_DECL, NULL_TREE, \n+\t flag_new_abi ? intSI_type_node : unsigned_intSI_type_node);\n       DECL_BIT_FIELD (fields[1]) = 1;\n       DECL_FIELD_SIZE (fields[1]) = 29;\n \n@@ -839,15 +840,26 @@ expand_class_desc (tdecl, type)\n \n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n-\t  tree t = BINFO_TYPE (binfo);\n-\t  const char *name;\n-\t  tree field;\n-\n-\t  FORMAT_VBASE_NAME (name, t);\n-\t  field = lookup_field (type, get_identifier (name), 0, 0);\n-\t  offset = size_binop (FLOOR_DIV_EXPR, \n-\t\tDECL_FIELD_BITPOS (field), size_int (BITS_PER_UNIT));\n-\t  offset = convert (sizetype, offset);\n+\t  if (!vbase_offsets_in_vtable_p ())\n+\t    {\n+\t      tree t = BINFO_TYPE (binfo);\n+\t      const char *name;\n+\t      tree field;\n+\n+\t      FORMAT_VBASE_NAME (name, t);\n+\t      field = lookup_field (type, get_identifier (name), 0, 0);\n+\t      offset = size_binop (FLOOR_DIV_EXPR, \n+\t\t\t\t   DECL_FIELD_BITPOS (field), \n+\t\t\t\t   size_int (BITS_PER_UNIT));\n+\t      offset = convert (sizetype, offset);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Under the new ABI, we store the vtable offset at which\n+\t\t the virtual base offset can be found.  */\n+\t      tree vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), type);\n+\t      offset = convert (sizetype, BINFO_VPTR_FIELD (vbase));\n+\t    }\n \t}\n       else\n \toffset = BINFO_OFFSET (binfo);"}, {"sha": "d29cdb57705144bdd56a3ff3d0fd305a6da9495a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -126,11 +126,6 @@ static tree bfs_walk\n \t       void *));\n static tree lookup_field_queue_p PROTO((tree, void *));\n static tree lookup_field_r PROTO((tree, void *));\n-static tree dfs_walk_real PROTO ((tree, \n-\t\t\t\t  tree (*) (tree, void *),\n-\t\t\t\t  tree (*) (tree, void *),\n-\t\t\t\t  tree (*) (tree, void *),\n-\t\t\t\t  void *));\n static tree get_virtuals_named_this_r PROTO ((tree, void *));\n static tree context_for_name_lookup PROTO ((tree));\n static tree canonical_binfo PROTO ((tree));\n@@ -1773,7 +1768,7 @@ bfs_walk (binfo, fn, qfn, data)\n    performed, and PREFN is called in preorder, while POSTFN is called\n    in postorder.  */\n \n-static tree\n+tree\n dfs_walk_real (binfo, prefn, postfn, qfn, data)\n      tree binfo;\n      tree (*prefn) PROTO((tree, void *));\n@@ -3200,9 +3195,9 @@ maybe_suppress_debug_info (t)\n     TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n   else if (CLASSTYPE_INTERFACE_KNOWN (t))\n     /* Don't set it.  */;\n-  /* If the class has virtual functions, write out the debug info\n-     along with the vtable.  */\n-  else if (TYPE_POLYMORPHIC_P (t))\n+  /* If the class has a vtable, write out the debug info along with\n+     the vtable.  */\n+  else if (TYPE_CONTAINS_VPTR_P (t))\n     TYPE_DECL_SUPPRESS_DEBUG (TYPE_MAIN_DECL (t)) = 1;\n \n   /* Otherwise, just emit the debug info normally.  */"}, {"sha": "18a00b0b19a4464a175d41fd41077ff02a808b08", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -1,5 +1,5 @@\n // Methods for type_info for -*- C++ -*- Run Time Type Identification.\n-// Copyright (C) 1994, 1996, 1998, 1999 Free Software Foundation\n+// Copyright (C) 1994, 1996, 1998, 1999, 2000 Free Software Foundation\n \n // This file is part of GNU CC.\n \n@@ -31,6 +31,34 @@\n #include \"tinfo.h\"\n #include \"new\"\t\t\t// for placement new\n \n+namespace\n+{\n+// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n+// using OFFSET.\n+inline void*\n+convert_to_base (void *addr, bool is_virtual, USItype offset)\n+{\n+  if (!addr)\n+    return NULL;\n+\n+  if (!is_virtual)\n+    return (char *) addr + offset;\n+\n+#ifdef __GXX_ABI_VERSION\n+  // Under the new ABI, the offset gives us an index into the vtable,\n+  // which contains an offset to the virtual base.  The vptr is always\n+  // the first thing in the object.\n+  std::ptrdiff_t *vtable = *((std::ptrdiff_t **) addr);\n+  return ((char *) addr) + vtable[offset];\n+#else\n+  // Under the old ABI, the offset gives us the address of a pointer\n+  // to the virtual base.\n+  return *((void **) ((char *) addr + offset));\n+#endif\n+}\n+\n+}\n+\n // This file contains the minimal working set necessary to link with code\n // that uses virtual functions and -frtti but does not actually use RTTI\n // functionality.\n@@ -254,14 +282,11 @@ do_upcast (sub_kind access_path,\n       upcast_result result2;\n       void *p = objptr;\n       sub_kind sub_access = access_path;\n-      if (p)\n-        p = (char *)p + base_list[i].offset;\n+      p = convert_to_base (p, \n+\t\t\t   base_list[i].is_virtual,\n+\t\t\t   base_list[i].offset);\n       if (base_list[i].is_virtual)\n-        {\n-          if (p)\n-            p = *(void **)p;\n-\t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n-        }\n+\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n       if (base_list[i].access != PUBLIC)\n         sub_access = sub_kind (sub_access & ~contained_public_mask);\n       if (base_list[i].base->do_upcast (sub_access, target, p, result2))\n@@ -344,13 +369,13 @@ do_dyncast (int boff, sub_kind access_path,\n   for (size_t i = n_bases; i--;)\n     {\n       dyncast_result result2;\n-      void *p = (char *)objptr + base_list[i].offset;\n+      void *p;\n       sub_kind sub_access = access_path;\n+      p = convert_to_base (objptr, \n+\t\t\t   base_list[i].is_virtual,\n+\t\t\t   base_list[i].offset);\n       if (base_list[i].is_virtual)\n-        {\n-\t  p = *(void **)p;\n-\t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n-\t}\n+\tsub_access = sub_kind (sub_access | contained_virtual_mask);\n       if (base_list[i].access != PUBLIC)\n         sub_access = sub_kind (sub_access & ~contained_public_mask);\n       \n@@ -492,13 +517,15 @@ do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *s\n     {\n       if (base_list[i].access != PUBLIC)\n         continue; // Not public, can't be here.\n-      void *p = (char *)objptr + base_list[i].offset;\n-      if (base_list[i].is_virtual)\n-        {\n-          if (boff == -1)\n-            continue; // Not a virtual base, so can't be here.\n-          p = *(void **)p;\n-        }\n+      void *p;\n+\n+      if (base_list[i].is_virtual && boff == -1)\n+\t// Not a virtual base, so can't be here.\n+\tcontinue;\n+      \n+      p = convert_to_base (objptr, \n+\t\t\t   base_list[i].is_virtual,\n+\t\t\t   base_list[i].offset);\n \n       sub_kind base_kind = base_list[i].base->do_find_public_subobj\n                               (boff, subtype, p, subptr);"}, {"sha": "116c7a8dd0f796c5e1e4c77353cb1f59fd2e56d7", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -1,5 +1,5 @@\n // RTTI support internals for -*- C++ -*-\n-// Copyright (C) 1994, 1995, 1996, 1998, 1999 Free Software Foundation\n+// Copyright (C) 1994, 1995, 1996, 1998, 1999, 2000 Free Software Foundation\n \n #include \"typeinfo\"\n \n@@ -167,7 +167,11 @@ class __si_type_info : public __user_type_info {\n \n // type_info for a general class.\n \n+#ifdef __GXX_ABI_VERSION\n+typedef int USItype __attribute__ ((mode (SI)));\n+#else\n typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n+#endif\n \n struct __class_type_info : public __user_type_info {\n   enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };"}, {"sha": "3c342d5f87727f214f98d9c15db223817ccbe33b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd15aac6fc179e9cb610f89f681c574a68f038c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bbd15aac6fc179e9cb610f89f681c574a68f038c", "patch": "@@ -860,7 +860,6 @@ make_binfo (offset, binfo, vtable, virtuals)\n   BINFO_OFFSET (new_binfo) = offset;\n   BINFO_VTABLE (new_binfo) = vtable;\n   BINFO_VIRTUALS (new_binfo) = virtuals;\n-  BINFO_VPTR_FIELD (new_binfo) = NULL_TREE;\n \n   if (binfo && BINFO_BASETYPES (binfo) != NULL_TREE)\n     BINFO_BASETYPES (new_binfo) = copy_node (BINFO_BASETYPES (binfo));      "}]}