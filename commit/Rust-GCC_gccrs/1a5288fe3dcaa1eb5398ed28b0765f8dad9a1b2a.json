{"sha": "1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a", "node_id": "C_kwDOANBUbNoAKDFhNTI4OGZlM2RjYWExZWI1Mzk4ZWQyOGIwNzY1ZjhkYWQ5YTFiMmE", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:02Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:02Z"}, "message": "aarch64: Use an array of aarch64_vec_op_counts\n\n-mtune=neoverse-512tvb uses two issue rates, one for Neoverse V1\nand one with more generic parameters.  We use both rates when\nmaking a choice between scalar, Advanced SIMD and SVE code.\n\nPreviously we calculated the Neoverse V1 issue rates from the\nmore generic issue rates, but by removing m_scalar_ops and\n(later) m_advsimd_ops, it becomes easier to track multiple\nissue rates directly.\n\nThis patch therefore converts m_ops and (temporarily) m_advsimd_ops\ninto arrays.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_vec_op_count): Allow default\n\tinitialization.\n\t(aarch64_vec_op_count::base_issue_info): Remove handling of null\n\tissue_infos.\n\t(aarch64_vec_op_count::simd_issue_info): Likewise.\n\t(aarch64_vec_op_count::sve_issue_info): Likewise.\n\t(aarch64_vector_costs::m_ops): Turn into a vector.\n\t(aarch64_vector_costs::m_advsimd_ops): Likewise.\n\t(aarch64_vector_costs::aarch64_vector_costs): Add entries to\n\tthe vectors based on aarch64_tune_params.\n\t(aarch64_vector_costs::analyze_loop_vinfo): Update the pred_ops\n\tof all entries in m_ops.\n\t(aarch64_vector_costs::add_stmt_cost): Call count_ops for all\n\tentries in m_ops.\n\t(aarch64_estimate_min_cycles_per_iter): Remove issue_info\n\tparameter and get the information from the ops instead.\n\t(aarch64_vector_costs::adjust_body_cost_sve): Take a\n\taarch64_vec_issue_info instead of a aarch64_vec_op_count.\n\t(aarch64_vector_costs::adjust_body_cost): Update call accordingly.\n\tExit earlier if m_ops is empty for either cost structure.", "tree": {"sha": "12491f79216fcfd7b463467d9325fd73009b0749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12491f79216fcfd7b463467d9325fd73009b0749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6756706ea636d6f9aab85cef22659cc35143476f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6756706ea636d6f9aab85cef22659cc35143476f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6756706ea636d6f9aab85cef22659cc35143476f"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "71c44d6327e56312d27509afb45343769eb21f4b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=1a5288fe3dcaa1eb5398ed28b0765f8dad9a1b2a", "patch": "@@ -14710,6 +14710,7 @@ aarch64_first_cycle_multipass_dfa_lookahead_guard (rtx_insn *insn,\n class aarch64_vec_op_count\n {\n public:\n+  aarch64_vec_op_count () = default;\n   aarch64_vec_op_count (const aarch64_vec_issue_info *, unsigned int);\n \n   unsigned int vec_flags () const { return m_vec_flags; }\n@@ -14739,14 +14740,14 @@ class aarch64_vec_op_count\n \n private:\n   /* The issue information for the core.  */\n-  const aarch64_vec_issue_info *m_issue_info;\n+  const aarch64_vec_issue_info *m_issue_info = nullptr;\n \n   /* - If M_VEC_FLAGS is zero then this structure describes scalar code\n      - If M_VEC_FLAGS & VEC_ADVSIMD is nonzero then this structure describes\n        Advanced SIMD code.\n      - If M_VEC_FLAGS & VEC_ANY_SVE is nonzero then this structure describes\n        SVE code.  */\n-  unsigned int m_vec_flags;\n+  unsigned int m_vec_flags = 0;\n };\n \n aarch64_vec_op_count::\n@@ -14765,9 +14766,7 @@ aarch64_vec_op_count::base_issue_info () const\n {\n   if (auto *ret = simd_issue_info ())\n     return ret;\n-  if (m_issue_info)\n-    return m_issue_info->scalar;\n-  return nullptr;\n+  return m_issue_info->scalar;\n }\n \n /* If the structure describes vector code and we have associated issue\n@@ -14777,7 +14776,7 @@ aarch64_vec_op_count::simd_issue_info () const\n {\n   if (auto *ret = sve_issue_info ())\n     return ret;\n-  if (m_issue_info && m_vec_flags)\n+  if (m_vec_flags)\n     return m_issue_info->advsimd;\n   return nullptr;\n }\n@@ -14787,7 +14786,7 @@ aarch64_vec_op_count::simd_issue_info () const\n const aarch64_sve_vec_issue_info *\n aarch64_vec_op_count::sve_issue_info () const\n {\n-  if (m_issue_info && (m_vec_flags & VEC_ANY_SVE))\n+  if (m_vec_flags & VEC_ANY_SVE)\n     return m_issue_info->sve;\n   return nullptr;\n }\n@@ -14809,7 +14808,7 @@ class aarch64_vector_costs : public vector_costs\n   void analyze_loop_vinfo (loop_vec_info);\n   void count_ops (unsigned int, vect_cost_for_stmt, stmt_vec_info, tree,\n \t\t  aarch64_vec_op_count *, unsigned int);\n-  fractional_cost adjust_body_cost_sve (const aarch64_vec_issue_info *,\n+  fractional_cost adjust_body_cost_sve (const aarch64_vec_op_count *,\n \t\t\t\t\tfractional_cost, fractional_cost,\n \t\t\t\t\tbool, unsigned int, unsigned int *,\n \t\t\t\t\tbool *);\n@@ -14853,13 +14852,14 @@ class aarch64_vector_costs : public vector_costs\n \n   /* Used only when vectorizing loops.  Estimates the number and kind of\n      operations that would be needed by one iteration of the scalar\n-     or vector loop.  */\n-  aarch64_vec_op_count m_ops;\n+     or vector loop.  There is one entry for each tuning option of\n+     interest.  */\n+  auto_vec<aarch64_vec_op_count, 2> m_ops;\n \n-  /* Used only when vectorizing loops for SVE.  It estimates what the\n-     equivalent Advanced SIMD-only code would need in order to perform\n-     the same work as one iteration of the SVE loop.  */\n-  aarch64_vec_op_count m_advsimd_ops;\n+  /* Used only when vectorizing loops for SVE.  For the first element of M_OPS,\n+     it estimates what the equivalent Advanced SIMD-only code would need\n+     in order to perform the same work as one iteration of the SVE loop.  */\n+  auto_vec<aarch64_vec_op_count, 1> m_advsimd_ops;\n \n   /* Used to detect cases in which we end up costing the same load twice,\n      once to account for results that are actually used and once to account\n@@ -14871,10 +14871,16 @@ aarch64_vector_costs::aarch64_vector_costs (vec_info *vinfo,\n \t\t\t\t\t    bool costing_for_scalar)\n   : vector_costs (vinfo, costing_for_scalar),\n     m_vec_flags (costing_for_scalar ? 0\n-\t\t : aarch64_classify_vector_mode (vinfo->vector_mode)),\n-    m_ops (aarch64_tune_params.vec_costs->issue_info, m_vec_flags),\n-    m_advsimd_ops (aarch64_tune_params.vec_costs->issue_info, VEC_ADVSIMD)\n+\t\t : aarch64_classify_vector_mode (vinfo->vector_mode))\n {\n+  if (auto *issue_info = aarch64_tune_params.vec_costs->issue_info)\n+    {\n+      m_ops.quick_push ({ issue_info, m_vec_flags });\n+      if (m_vec_flags & VEC_ANY_SVE)\n+\tm_advsimd_ops.quick_push ({ issue_info, VEC_ADVSIMD });\n+      if (aarch64_tune_params.vec_costs == &neoverse512tvb_vector_cost)\n+\tm_ops.quick_push ({ &neoversev1_vec_issue_info, m_vec_flags });\n+    }\n }\n \n /* Implement TARGET_VECTORIZE_CREATE_COSTS.  */\n@@ -15001,18 +15007,17 @@ aarch64_vector_costs::analyze_loop_vinfo (loop_vec_info loop_vinfo)\n \n   /* Record the issue information for any SVE WHILE instructions that the\n      loop needs.  */\n-  auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n-  if (issue_info\n-      && issue_info->sve\n-      && !LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n+  if (!m_ops.is_empty () && !LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n     {\n       unsigned int num_masks = 0;\n       rgroup_controls *rgm;\n       unsigned int num_vectors_m1;\n       FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), num_vectors_m1, rgm)\n \tif (rgm->type)\n \t  num_masks += num_vectors_m1 + 1;\n-      m_ops.pred_ops += num_masks * issue_info->sve->while_pred_ops;\n+      for (auto &ops : m_ops)\n+\tif (auto *issue = ops.sve_issue_info ())\n+\t  ops.pred_ops += num_masks * issue->while_pred_ops;\n     }\n }\n \n@@ -15788,12 +15793,13 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n \t  && (!LOOP_VINFO_LOOP (loop_vinfo)->inner || in_inner_loop_p)\n \t  && stmt_cost != 0)\n \t{\n-\t  count_ops (count, kind, stmt_info, vectype, &m_ops, 1);\n-\t  if (aarch64_sve_mode_p (m_vinfo->vector_mode))\n+\t  for (auto &ops : m_ops)\n+\t    count_ops (count, kind, stmt_info, vectype, &ops, 1);\n+\t  for (auto &ops : m_advsimd_ops)\n \t    /* Record estimates for a possible Advanced SIMD version\n \t       of the SVE code.  */\n-\t    count_ops (count, kind, stmt_info, vectype,\n-\t\t       &m_advsimd_ops, aarch64_estimated_sve_vq ());\n+\t    count_ops (count, kind, stmt_info, vectype, &ops,\n+\t\t       aarch64_estimated_sve_vq ());\n \t}\n \n       /* If we're applying the SVE vs. Advanced SIMD unrolling heuristic,\n@@ -15824,13 +15830,12 @@ aarch64_vec_op_count::dump () const\n \t\t   \"  reduction latency = %d\\n\", reduction_latency);\n }\n \n-/* Use ISSUE_INFO to estimate the minimum number of cycles needed to issue\n-   the operations described by OPS.  This is a very simplistic model!  */\n+/* Estimate the minimum number of cycles needed to issue the operations\n+   described by OPS.  This is a very simplistic model!  */\n static fractional_cost\n-aarch64_estimate_min_cycles_per_iter\n-  (const aarch64_vec_op_count *ops,\n-   const aarch64_base_vec_issue_info *issue_info)\n+aarch64_estimate_min_cycles_per_iter (const aarch64_vec_op_count *ops)\n {\n+  auto *issue_info = ops->base_issue_info ();\n   fractional_cost cycles = MAX (ops->reduction_latency, 1);\n   cycles = std::max (cycles, { ops->stores, issue_info->stores_per_cycle });\n   cycles = std::max (cycles, { ops->loads + ops->stores,\n@@ -15852,32 +15857,34 @@ aarch64_estimate_min_cycles_per_iter\n \n fractional_cost\n aarch64_vector_costs::\n-adjust_body_cost_sve (const aarch64_vec_issue_info *issue_info,\n+adjust_body_cost_sve (const aarch64_vec_op_count *ops,\n \t\t      fractional_cost scalar_cycles_per_iter,\n \t\t      fractional_cost advsimd_cycles_per_iter,\n \t\t      bool could_use_advsimd, unsigned int orig_body_cost,\n \t\t      unsigned int *body_cost, bool *should_disparage)\n {\n+  auto *issue_info = ops->sve_issue_info ();\n+\n   /* Estimate the minimum number of cycles per iteration needed to issue\n      non-predicate operations.  */\n   fractional_cost sve_nonpred_issue_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&m_ops, issue_info->sve);\n+    = aarch64_estimate_min_cycles_per_iter (ops);\n \n   /* Estimate the minimum number of cycles per iteration needed to rename\n      SVE instructions.\n \n      ??? For now this is done inline rather than via cost tables, since it\n      isn't clear how it should be parameterized for the general case.  */\n   fractional_cost sve_rename_cycles_per_iter = 0;\n-  if (issue_info == &neoverse512tvb_vec_issue_info)\n+  if (issue_info == &neoverse512tvb_sve_issue_info)\n     /* + 1 for an addition.  We've already counted a general op for each\n        store, so we don't need to account for stores separately.  The branch\n        reads no registers and so does not need to be counted either.\n \n        ??? This value is very much on the pessimistic side, but seems to work\n        pretty well in practice.  */\n     sve_rename_cycles_per_iter\n-      = { m_ops.general_ops + m_ops.loads + m_ops.pred_ops + 1, 5 };\n+      = { ops->general_ops + ops->loads + ops->pred_ops + 1, 5 };\n \n   /* Combine the rename and non-predicate issue limits into a single value.  */\n   fractional_cost sve_nonpred_cycles_per_iter\n@@ -15886,23 +15893,23 @@ adjust_body_cost_sve (const aarch64_vec_issue_info *issue_info,\n   /* Separately estimate the minimum number of cycles per iteration needed\n      to issue the predicate operations.  */\n   fractional_cost sve_pred_issue_cycles_per_iter\n-    = { m_ops.pred_ops, issue_info->sve->pred_ops_per_cycle };\n+    = { ops->pred_ops, issue_info->pred_ops_per_cycle };\n \n   /* Calculate the overall limit on the number of cycles per iteration.  */\n   fractional_cost sve_cycles_per_iter\n     = std::max (sve_nonpred_cycles_per_iter, sve_pred_issue_cycles_per_iter);\n \n   if (dump_enabled_p ())\n     {\n-      m_ops.dump ();\n+      ops->dump ();\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"  estimated cycles per iteration = %f\\n\",\n \t\t       sve_cycles_per_iter.as_double ());\n-      if (m_ops.pred_ops)\n+      if (ops->pred_ops)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"    predicate issue = %f\\n\",\n \t\t\t sve_pred_issue_cycles_per_iter.as_double ());\n-      if (m_ops.pred_ops || sve_rename_cycles_per_iter)\n+      if (ops->pred_ops || sve_rename_cycles_per_iter)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"    non-predicate issue = %f\\n\",\n \t\t\t sve_nonpred_issue_cycles_per_iter.as_double ());\n@@ -15987,7 +15994,11 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t\t  const aarch64_vector_costs *scalar_costs,\n \t\t  unsigned int body_cost)\n {\n-  const auto &scalar_ops = scalar_costs->m_ops;\n+  if (scalar_costs->m_ops.is_empty () || m_ops.is_empty ())\n+    return body_cost;\n+\n+  const auto &scalar_ops = scalar_costs->m_ops[0];\n+  const auto &vector_ops = m_ops[0];\n   unsigned int estimated_vf = vect_vf_for_cost (loop_vinfo);\n   unsigned int orig_body_cost = body_cost;\n   bool should_disparage = false;\n@@ -16030,16 +16041,12 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t}\n     }\n \n-  auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n-  if (!issue_info)\n-    return body_cost;\n-\n   fractional_cost scalar_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&scalar_ops, issue_info->scalar);\n+    = aarch64_estimate_min_cycles_per_iter (&scalar_ops);\n   scalar_cycles_per_iter *= estimated_vf;\n \n   fractional_cost vector_cycles_per_iter\n-    = aarch64_estimate_min_cycles_per_iter (&m_ops, m_ops.base_issue_info ());\n+    = aarch64_estimate_min_cycles_per_iter (&vector_ops);\n \n   if (dump_enabled_p ())\n     {\n@@ -16055,7 +16062,7 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t\t       estimated_vf, scalar_cycles_per_iter.as_double ());\n     }\n \n-  if ((m_vec_flags & VEC_ANY_SVE) && issue_info->sve)\n+  if (vector_ops.sve_issue_info ())\n     {\n       bool could_use_advsimd\n \t= (aarch64_autovec_preference != 2\n@@ -16064,15 +16071,14 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t   && !m_saw_sve_only_op);\n \n       fractional_cost advsimd_cycles_per_iter\n-\t= aarch64_estimate_min_cycles_per_iter (&m_advsimd_ops,\n-\t\t\t\t\t\tissue_info->advsimd);\n+\t= aarch64_estimate_min_cycles_per_iter (&m_advsimd_ops[0]);\n       if (dump_enabled_p ())\n \t{\n \t  if (could_use_advsimd)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"Advanced SIMD issue estimate:\\n\");\n-\t      m_advsimd_ops.dump ();\n+\t      m_advsimd_ops[0].dump ();\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"  estimated cycles per iteration = %f\\n\",\n \t\t\t       advsimd_cycles_per_iter.as_double ());\n@@ -16083,7 +16089,7 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"SVE issue estimate:\\n\");\n \t}\n       vector_cycles_per_iter\n-\t= adjust_body_cost_sve (issue_info, scalar_cycles_per_iter,\n+\t= adjust_body_cost_sve (&vector_ops, scalar_cycles_per_iter,\n \t\t\t\tadvsimd_cycles_per_iter, could_use_advsimd,\n \t\t\t\torig_body_cost, &body_cost, &should_disparage);\n \n@@ -16095,8 +16101,7 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Neoverse V1 estimate:\\n\");\n-\t  adjust_body_cost_sve (&neoversev1_vec_issue_info,\n-\t\t\t\tscalar_cycles_per_iter * 2,\n+\t  adjust_body_cost_sve (&m_ops[1], scalar_cycles_per_iter * 2,\n \t\t\t\tadvsimd_cycles_per_iter * 2,\n \t\t\t\tcould_use_advsimd, orig_body_cost,\n \t\t\t\t&body_cost, &should_disparage);\n@@ -16108,7 +16113,7 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Vector issue estimate:\\n\");\n-\t  m_ops.dump ();\n+\t  vector_ops.dump ();\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"  estimated cycles per iteration = %f\\n\",\n \t\t\t   vector_cycles_per_iter.as_double ());\n@@ -16155,7 +16160,7 @@ adjust_body_cost (loop_vec_info loop_vinfo,\n      vector code is an improvement, even if adding the other (non-loop-carried)\n      latencies tends to hide this saving.  We therefore reduce the cost of the\n      vector loop body in proportion to the saving.  */\n-  else if (scalar_ops.reduction_latency > m_ops.reduction_latency\n+  else if (scalar_ops.reduction_latency > vector_ops.reduction_latency\n \t   && scalar_ops.reduction_latency == scalar_cycles_per_iter\n \t   && scalar_cycles_per_iter > vector_cycles_per_iter\n \t   && !should_disparage)"}]}