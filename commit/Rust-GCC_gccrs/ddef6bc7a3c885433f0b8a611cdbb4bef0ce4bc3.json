{"sha": "ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRlZjZiYzdhM2M4ODU0MzNmMGI4YTYxMWNkYmI0YmVmMGNlNGJjMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-04-03T15:06:12Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2001-04-03T15:06:12Z"}, "message": "Use byte offsets in SUBREGs instead of words.\n\n2001-04-03  Jakub Jelinek  <jakub@redhat.com>\n\t    David S. Miller  <davem@pierdol.cobaltmicro.com>\n            Andrew MacLeod  <amacleod@redhat.com>\n\n\tUse byte offsets in SUBREGs instead of words.\n\n\t* alias.c (nonlocal_mentioned_p): Use subreg_regno function.\n\t* caller-save.c (mark_set_regs): Change callers of subreg_hard_regno\n\tto pass new argument.\n\t(add_stored_regs): Use subreg_regno_offset function.\n\t* calls.c (expand_call): For non-paradoxical SUBREG take endianess\n\tinto account.\n\t(precompute_arguments): Use gen_lowpart_SUBREG.\n\t* combine.c (try_combine): Replace explicit XEXP with SUBREG_REG.\n\t(combine_simplify_rtx): Rework to use SUBREG_BYTE.\n\t(simplify_set): Rework to use SUBREG_BYTE.\n\t(expand_field_assignment): Use SUBREG_BYTE.\n\t(make_extraction): Use SUBREG_BYTE.\n\t(if_then_else_cond): Use SUBREG_BYTE.\n\t(apply_distributive_law): Use SUBREG_BYTE and fixup subreg comments.\n\t(gen_lowpart_for_combine): Compute full byte offset.\n\t* cse.c (mention_regs): Use SUBREG_BYTE.\n\t(remove_invalid_subreg_refs): Rework to use SUBREG_BYTE.\n\t(canon_hash): Use SUBREG_BYTE.\n\t(fold_rtx): Pass SUBREG_BYTE div UNITS_PER_WORD to operand_subword.\n\t(gen_lowpart_if_possible): Formatting.\n\t* dbxout.c (dbxout_symbol_location): Compute SUBREG hard regnos\n\tcorrectly.\n\t* dwarf2out.c (is_pseudo_reg): Fixup explicit XEXP into SUBREG_REG\n\t(mem_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n\t(loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n\t* dwarfout.c (is_pseudo_reg): Fixup explicit XEXP into SUBREG_REG\n\t(output_mem_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n\t(output_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n\t* emit-rtl.c (gen_rtx_SUBREG): New function, used to verify\n\tcertain invariants about SUBREGs the compiler creates.\n\t(gen_lowpart_SUBREG): New function.\n\t(subreg_hard_regno): New function to get the final register number.\n\t(gen_lowpart_common): Use SUBREG_BYTE.\n\t(gen_imagpart): Spacing nits.\n\t(subreg_realpart_p): Use SUBREG_BYTE.\n\t(gen_highpart): Use SUBREG_BYTE.\n\t(subreg_lowpart_p): Always compute endian corrected goal offset,\n\teven at the byte level, then compare against that.\n\t(constant_subword): New function, pulled out all constant cases\n\tfrom operand_subword and changed second argument name to offset.\n\t(operand_subword): Detect non REG/SUBREG/CONCAT/MEM cases early\n\tand call constant_subword to do the work.  Return const0_rtx if\n\tlooking for a word outside of OP.\n\t(operand_subword_force): Change second arg name to offset.\n\t* expmed.c (store_bit_field): Use SUBREG_BYTE.\n\t(store_split_bit_field): Use SUBREG_BYTE.\n\t(extract_bit_field): Use SUBREG_BYTE.\n\t(extract_split_bit_field): Use SUBREG_BYTE.\n\t(expand_shift): Use SUBREG_BYTE.\n\t* expr.c (store_expr, expand_expr): Use gen_lowpart_SUBREG.\n\t* final.c (alter_subreg) Use subreg_hard_regno and SUBREG_BYTE.\n\t* flow.c (set_noop_p): Use SUBREG_BYTE.\n\t(mark_set_1): Remove ALTER_HARD_SUBREG. Use subreg_regno_offset instead.\n\t* function.c (fixup_var_refs_1): Fixup explicit XEXP into a SUBREG_REG.\n\t(fixup_memory_subreg): Use SUBREG_BYTE and remove byte endian\n\tcorrection code.\n\t(optimize_bit_field): Use SUBREG_BYTE.\n\t(purge_addressof_1): Use SUBREG_BYTE.\n\t(purge_single_hard_subreg_set): Use subreg_regno_offset function.\n\t(assign_params): Mark arguments SUBREG_PROMOTED_VAR_P if they are\n\tactually promoted by the caller and PROMOTE_FOR_CALLS_ONLY is true.\n\t* gengenrtl.c (special_rtx): Add SUBREG.\n\t* global.c (mark_reg_store): Use SUBREG_BYTE.\n\t(set_preference): Rework to use subreg_regno_offset and SUBREG_BYTE.\n\t* ifcvt (noce_emit_move_insn): Use SUBREG_BYTE.\n\t* integrate.c (copy_rtx_and_substitute): Use SUBREG_BYTE and make sure\n\tfinal byte offset is congruent to subreg's mode size.\n\t(subst_constants): Use SUBREG_BYTE.\n\t(mark_stores): Use subreg_regno_offset function.\n\t* jump.c (rtx_renumbered_equal_p, true_regnum): Use subreg_regno_offset\n\tfunction and SUBREG_BYTE.\n\t* local-alloc.c (combine_regs): Use subreg_regno_offset function.\n\t(reg_is_born): Use subreg_hard_regno.\n\t* recog.c (valid_replace_rtx_1): Use SUBREG_BYTE and remove byte\n\tendian correction code.  Don't combine subregs unless resulting\n\toffset aligns with type.  Fix subreg constant extraction for DImode.\n\tSimplify SUBREG of VOIDmode CONST_DOUBLE.\n\t(general_operand): Remove dead mode_altering_drug code.\n\t(indirect_operand): Use SUBREG_BYTE.\n\t(constrain_operands): Use subreg_regno_offset function.\n\t* reg-stack.c (get_true_reg): Use subreg_regno_offset function.\n\t* regmove.c (regmove_optimize): Use SUBREG_BYTE.\n\t(optimize_reg_copy_3): Use gen_lowpart_SUBREG.\n\t* regs.h (REG_SIZE): Allow target to override.\n\t(REGMODE_NATURAL_SIZE): New macro which target can override.\n\t* reload.c (reload_inner_reg_of_subreg): subreg_regno should be used\n\ton the entire subreg rtx.\n\t(push_reload): Use SUBREG_BYTE in comments and code.\n\t(find_dummy_reload): Use subreg_regno_offset.  Only adjust offsets\n\tfor hard registers inside subregs.\n\t(operands_match_p): Use subreg_regno_offset.\n\t(find_reloads): Use SUBREG_BYTE and only advance offset for subregs\n\tcontaining hard regs.\n\t(find_reload_toplev): Use SUBREG_BYTE.  Remove byte endian\n\tcorrections when fixing up MEM subregs.\n\t(find_reloads_address_1): Use SUBREG_BYTE, subreg_regno, and\n\tsubreg_regno_offset where appropriate.\n\t(find_reloads_subreg_address): Use SUBREG_BYTE.  Remove\n\tbyte endian corrections when fixing up MEM subregs.\n\t(subst_reloads): When combining two subregs, make sure final\n\toffset is congruent to subreg's mode size.\n\t(find_replacement): Use SUBREG_BYTE and subreg_regno_offset.\n\t(refers_to_regno_for_reload_p): Use subreg_regno.\n\t(reg_overlap_mentioned_for_reload_p): Use subreg_regno_offset.\n\t* reload1.c (eliminate_regs) Use SUBREG_BYTE. Remove byte endian\n\tcorrection code for memory subreg fixups.\n\t(forget_old_reload_1): Use subreg_regno_offset.\n\t(choose_reload_regs): Use subreg_regno.\n\t(emit_input_reload_insns): Use SUBREG_BYTE.\n\t(reload_combine_note_store): Use subreg_regno_offset.\n\t(move2add_note_store): Use subreg_regno_offset.\n\t* resource.c (update_live_status, mark_referenced_resources): Use\n\tsubreg_regno function.\n\t(mark_set_resources): Use subreg_regno function.\n\t* rtl.h (SUBREG_WORD): Rename to SUBREG_BYTE.\n\t(subreg_regno_offset, subreg_regno): Define prototypes.\n\t(subreg_hard_regno, constant_subword, gen_rtx_SUBREG): Newi functions.\n\t(gen_lowpart_SUBREG): Add prototype.\n\t* rtl.texi (subreg): Update to reflect new byte offset representation.\n\tAdd mentioning of the effect that BYTES_BIG_ENDIAN has on subregs now.\n\t* rtlanal.c (refers_to_regno_p): Use subreg_regno.\n\t(reg_overlap_mentioned_p): Use subreg_regno.\n\t(replace_regs); Make sure final offset of combined subreg is\n\tcongruent to size of subreg's mode.\n\t(subreg_regno_offset): New function.\n\t(subreg_regno): New function.\n\t* sched-vis.c (print_value): Change SUBREG_WORD to SUBREG_BYTE.\n\t* sdbout.c (sdbout_symbol): Compute offset using alter_subreg.\n\t* stmt.c (expand_anon_union_decl): Use gen_lowpart_SUBREG.\n\t* tm.texi (ALTER_HARD_SUBREG): Remove, it is now dead.\n\t(SUBREG_REGNO_OFFSET): Describe SUBREG_REGNO_OFFSET overrides.\n\t* config/a29k/a29k.c (gpc_reg_operand): Use subreg_regno.\n\t(a29k_get_reloaded_address): Use SUBREG_BYTE.\n\t(print_operand): Use SUBREG_BYTE.\n\t* config/alpha/alpha.c (print_operand_address): Use SUBREG_BYTE.\n\t* config/arm/arm.c (arm_reload_in_hi): Use SUBREG_BYTE.\n\t(arm_reload_out_hi): Use SUBREG_BYTE.\n\t* config/d30v/d30v.c (d30v_split_double): Use subreg_regno_offset\n\tinstead of SUBREG_WORD.\n\t(d30v_print_operand_memory_reference): Use subreg_regno_offset.\n\t* config/dsp16xx/dsp16xx.md (extendqihi2, zero_extendqihi2): Fix\n\tSUBREG creation to use byte offset.\n\t* config/h8300/h8300.md (Unnamed HImode zero extraction and 16bit\n\tinverted load insns): Fix explicit rtl subregs to use byte\n\toffsets.\n\t* config/i370/i370.md (cmpstrsi, movstrsi, mulsi3, divsi3,\n\tudivsi3, umodsi3): Generate SUBREGs with byte offsets.\n\t* config/i860/i860.c (single_insn_src_p): Use SUBREG_BYTE.\n\t* config/i860/i860.md (mulsi3_big): Fixup explicit SUBREGs in rtl\n\tto use byte offsets.\n\t(unnamed fmlow.dd insn): Fixup SUBREGS to use byte offsets.\n\t* config/i960/i960.md (extendhisi2): Generate SUBREGs with byte\n\toffsets, also make sure it is congruent to SUBREG's mode size.\n\t(extendqisi2, extendqihi2, zero_extendhisi2, zero_extendqisi2,\n\tunnamed ldob insn): Generate SUBREGs with byte offset.\n\t(zero_extendqihi2): SUBREG's are byte offsets.\n\t* config/m68hc11/m68hc11.c (m68hc11_gen_lowpart): Use SUBREG_BYTE.\n\t(m68hc11_gen_highpart): Use SUBREG_BYTE.\n\t* config/m68k/m68k.md (zero_extendhisi2, zero_extendqihi2,\n\tzero-extendqisi2): Generate SUBREGs with byte offset.\n\t(umulsidi3, mulsidi3, subreghi1ashrdi_const32,\n\tsubregsi1ashrdi_const32, subreg1lshrdi_const32): Fixup explicit\n\tsubregs in rtl to use byte offsets.\n\t* config/m88k/m88k.md (extendsidi2): fixup subregs to use byte offset.\n\t* config/mips/mips.c (mips_move_1word): Use subreg_regno_offset.\n\t(mips_move_2words): Use subreg_regno_offset.\n\t(mips_secondary_reload_class): Use subreg_regno_offset.\n\t* config/mips/mips.md (DImode plus, minus, move, and logical op\n\tsplits): Fixup explicit subregs in rtl to use byte offsets.\n\t* config/mn10200/mn10200.c (print_operand): Use subreg_regno function.\n\t* config/mn10300/mn10300.c (print_operand): Use subreg_regno function.\n\t* config/ns32k/ns32k.md (udivmoddisi4): Fix explicit subregs in\n\trtl to use byte offsets.\n\t* config/pa/pa.c (emit_move_sequence): Use SUBREG_BYTE.\n\t* config/pa/pa.md (floatunssisf2, floatunssidf2, mulsi3): fix explicit\n\tsubregs to use byte offsets.\n\t* config/pdp11/pdp11.md (zero_extendhisi2, modhi3, modhi3+1):\n\tFixup explicit subregs in rtl to use byte offsets.\n\t* config/romp/romp.c (memory_offset_in_range_p): Use SUBREG_BYTE\n\tand remove byte endian correction code.\n\t* config/sh/sh.c (output_movedouble): Use subreg_regno.\n\t(gen_ashift_hi): Use SUBREG_BYTE.\n\t(regs_used): Use subreg_regno_offset.\n\t(machine_dependent_reorg): Use subreg_regno_offset.\n\t* config/sh/sh.h (INDEX_REGISTER_RTX_P): Use SUBREG_BYTE.\n\t* config/sh/sh.md (DImode and DFmode move splits): Use subreg_regno.\n\t(movdf_i4): Subregs are byte offsets now.\n\t* config/sparc/sparc.c (ultra_find_type): Use SUBREG_BYTE.\n\t* config/sparc/sparc.h (ALTER_HARD_SUBREG): Removed.\n\t(REGMODE_NATURAL_SIZE): Override.\n\t(REG_SIZE): For SUBREG check float mode on SUBREG_REG's mode.\n\t* config/sparc/sparc.md (TFmode move splits): Generate SUBREGs\n\twith byte offsets.\n\t(zero_extendhisi2, zero_extendqidi2_insn, extendhisi2,\n\textendqihi2, sign_extendqihi2_insn, sign_extendqisi2_insn,\n\textendqidi2): Generate SUBREGs with byte offsets, also make sure\n\tit is congruent to SUBREG's mode size.\n\t(smulsi3_highpart_v8plus): Fix explicit subregs in rtl to use byte\n\toffsets.\n\t(cmp_siqi_trunc, cmp_siqi_trunc_set, cmp_diqi_trunc,\n\tcmp_diqi_trunc_set, lshrdi3_v8plus+1, lshrdi3_v8plus+2,\n\tlshrdi3_v8plus+3, lshrdi3_v8plus+4): Use proper\n\tSUBREG_BYTE offset for non-paradoxical subregs in patterns.\n\t* config/v850/v850.c (print_operand, output_move_double): Use\n\tsubreg_regno function.\n\nCo-Authored-By: Andrew MacLeod <amacleod@redhat.com>\nCo-Authored-By: David S. Miller <davem@pierdol.cobaltmicro.com>\n\nFrom-SVN: r41058", "tree": {"sha": "28cfaed9a88de9b20638576026f15f0a1d8b06e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28cfaed9a88de9b20638576026f15f0a1d8b06e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "924c96ebc4c736cd20d0a36a3973686854e2a152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924c96ebc4c736cd20d0a36a3973686854e2a152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924c96ebc4c736cd20d0a36a3973686854e2a152"}], "stats": {"total": 2511, "additions": 1639, "deletions": 872}, "files": [{"sha": "a63667af04c9b83b3e6efa58b3b0690e004c4263", "filename": "gcc/ChangeLog", "status": "modified", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1,3 +1,215 @@\n+2001-04-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    David S. Miller  <davem@pierdol.cobaltmicro.com>\n+            Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tUse byte offsets in SUBREGs instead of words.\n+\n+\t* alias.c (nonlocal_mentioned_p): Use subreg_regno function.\n+\t* caller-save.c (mark_set_regs): Change callers of subreg_hard_regno\n+\tto pass new argument.\n+\t(add_stored_regs): Use subreg_regno_offset function.\n+\t* calls.c (expand_call): For non-paradoxical SUBREG take endianess\n+\tinto account.\n+\t(precompute_arguments): Use gen_lowpart_SUBREG.\n+\t* combine.c (try_combine): Replace explicit XEXP with SUBREG_REG.\n+\t(combine_simplify_rtx): Rework to use SUBREG_BYTE.\n+\t(simplify_set): Rework to use SUBREG_BYTE.\n+\t(expand_field_assignment): Use SUBREG_BYTE.\n+\t(make_extraction): Use SUBREG_BYTE.\n+\t(if_then_else_cond): Use SUBREG_BYTE.\n+\t(apply_distributive_law): Use SUBREG_BYTE and fixup subreg comments.\n+\t(gen_lowpart_for_combine): Compute full byte offset.\n+\t* cse.c (mention_regs): Use SUBREG_BYTE.\n+\t(remove_invalid_subreg_refs): Rework to use SUBREG_BYTE.\n+\t(canon_hash): Use SUBREG_BYTE.\n+\t(fold_rtx): Pass SUBREG_BYTE div UNITS_PER_WORD to operand_subword.\n+\t(gen_lowpart_if_possible): Formatting.\n+\t* dbxout.c (dbxout_symbol_location): Compute SUBREG hard regnos\n+\tcorrectly.\n+\t* dwarf2out.c (is_pseudo_reg): Fixup explicit XEXP into SUBREG_REG\n+\t(mem_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n+\t(loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n+\t* dwarfout.c (is_pseudo_reg): Fixup explicit XEXP into SUBREG_REG\n+\t(output_mem_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n+\t(output_loc_descriptor): Fixup explicit XEXP into SUBREG_REG\n+\t* emit-rtl.c (gen_rtx_SUBREG): New function, used to verify\n+\tcertain invariants about SUBREGs the compiler creates.\n+\t(gen_lowpart_SUBREG): New function.\n+\t(subreg_hard_regno): New function to get the final register number.\n+\t(gen_lowpart_common): Use SUBREG_BYTE.\n+\t(gen_imagpart): Spacing nits.\n+\t(subreg_realpart_p): Use SUBREG_BYTE.\n+\t(gen_highpart): Use SUBREG_BYTE.\n+\t(subreg_lowpart_p): Always compute endian corrected goal offset,\n+\teven at the byte level, then compare against that.\n+\t(constant_subword): New function, pulled out all constant cases\n+\tfrom operand_subword and changed second argument name to offset.\n+\t(operand_subword): Detect non REG/SUBREG/CONCAT/MEM cases early\n+\tand call constant_subword to do the work.  Return const0_rtx if \n+\tlooking for a word outside of OP.\n+\t(operand_subword_force): Change second arg name to offset.\n+\t* expmed.c (store_bit_field): Use SUBREG_BYTE.\n+\t(store_split_bit_field): Use SUBREG_BYTE.\n+\t(extract_bit_field): Use SUBREG_BYTE.\n+\t(extract_split_bit_field): Use SUBREG_BYTE.\n+\t(expand_shift): Use SUBREG_BYTE.\n+\t* expr.c (store_expr, expand_expr): Use gen_lowpart_SUBREG. \n+\t* final.c (alter_subreg) Use subreg_hard_regno and SUBREG_BYTE.\n+\t* flow.c (set_noop_p): Use SUBREG_BYTE.\n+\t(mark_set_1): Remove ALTER_HARD_SUBREG. Use subreg_regno_offset instead.\n+\t* function.c (fixup_var_refs_1): Fixup explicit XEXP into a SUBREG_REG.\n+\t(fixup_memory_subreg): Use SUBREG_BYTE and remove byte endian\n+\tcorrection code.\n+\t(optimize_bit_field): Use SUBREG_BYTE.\n+\t(purge_addressof_1): Use SUBREG_BYTE.\n+\t(purge_single_hard_subreg_set): Use subreg_regno_offset function.\n+\t(assign_params): Mark arguments SUBREG_PROMOTED_VAR_P if they are \n+\tactually promoted by the caller and PROMOTE_FOR_CALLS_ONLY is true.\n+\t* gengenrtl.c (special_rtx): Add SUBREG.\n+\t* global.c (mark_reg_store): Use SUBREG_BYTE.\n+\t(set_preference): Rework to use subreg_regno_offset and SUBREG_BYTE.\n+\t* ifcvt (noce_emit_move_insn): Use SUBREG_BYTE.\n+\t* integrate.c (copy_rtx_and_substitute): Use SUBREG_BYTE and make sure\n+\tfinal byte offset is congruent to subreg's mode size.\n+\t(subst_constants): Use SUBREG_BYTE.\n+\t(mark_stores): Use subreg_regno_offset function.\n+\t* jump.c (rtx_renumbered_equal_p, true_regnum): Use subreg_regno_offset\n+\tfunction and SUBREG_BYTE.\n+\t* local-alloc.c (combine_regs): Use subreg_regno_offset function.\n+\t(reg_is_born): Use subreg_hard_regno.\n+\t* recog.c (valid_replace_rtx_1): Use SUBREG_BYTE and remove byte\n+\tendian correction code.  Don't combine subregs unless resulting \n+\toffset aligns with type.  Fix subreg constant extraction for DImode.\n+\tSimplify SUBREG of VOIDmode CONST_DOUBLE.\n+\t(general_operand): Remove dead mode_altering_drug code.\n+\t(indirect_operand): Use SUBREG_BYTE.\n+\t(constrain_operands): Use subreg_regno_offset function.\n+\t* reg-stack.c (get_true_reg): Use subreg_regno_offset function.\n+\t* regmove.c (regmove_optimize): Use SUBREG_BYTE.\n+\t(optimize_reg_copy_3): Use gen_lowpart_SUBREG.\n+\t* regs.h (REG_SIZE): Allow target to override.\n+\t(REGMODE_NATURAL_SIZE): New macro which target can override.\n+\t* reload.c (reload_inner_reg_of_subreg): subreg_regno should be used \n+\ton the entire subreg rtx.\n+\t(push_reload): Use SUBREG_BYTE in comments and code.\n+\t(find_dummy_reload): Use subreg_regno_offset.  Only adjust offsets\n+\tfor hard registers inside subregs.\n+\t(operands_match_p): Use subreg_regno_offset.\n+\t(find_reloads): Use SUBREG_BYTE and only advance offset for subregs \n+\tcontaining hard regs.\n+\t(find_reload_toplev): Use SUBREG_BYTE.  Remove byte endian\n+\tcorrections when fixing up MEM subregs.\n+\t(find_reloads_address_1): Use SUBREG_BYTE, subreg_regno, and\n+\tsubreg_regno_offset where appropriate.\n+\t(find_reloads_subreg_address): Use SUBREG_BYTE.  Remove\n+\tbyte endian corrections when fixing up MEM subregs.\n+\t(subst_reloads): When combining two subregs, make sure final\n+\toffset is congruent to subreg's mode size.\n+\t(find_replacement): Use SUBREG_BYTE and subreg_regno_offset.\n+\t(refers_to_regno_for_reload_p): Use subreg_regno.\n+\t(reg_overlap_mentioned_for_reload_p): Use subreg_regno_offset.\n+\t* reload1.c (eliminate_regs) Use SUBREG_BYTE. Remove byte endian\n+\tcorrection code for memory subreg fixups.\n+\t(forget_old_reload_1): Use subreg_regno_offset.\n+\t(choose_reload_regs): Use subreg_regno.\n+\t(emit_input_reload_insns): Use SUBREG_BYTE.\n+\t(reload_combine_note_store): Use subreg_regno_offset.\n+\t(move2add_note_store): Use subreg_regno_offset.\n+\t* resource.c (update_live_status, mark_referenced_resources): Use \n+\tsubreg_regno function.\n+\t(mark_set_resources): Use subreg_regno function.\n+\t* rtl.h (SUBREG_WORD): Rename to SUBREG_BYTE.\n+\t(subreg_regno_offset, subreg_regno): Define prototypes.\n+\t(subreg_hard_regno, constant_subword, gen_rtx_SUBREG): Newi functions.\n+\t(gen_lowpart_SUBREG): Add prototype.\n+\t* rtl.texi (subreg): Update to reflect new byte offset representation.\n+\tAdd mentioning of the effect that BYTES_BIG_ENDIAN has on subregs now.\n+\t* rtlanal.c (refers_to_regno_p): Use subreg_regno.\n+\t(reg_overlap_mentioned_p): Use subreg_regno.\n+\t(replace_regs); Make sure final offset of combined subreg is\n+\tcongruent to size of subreg's mode.\n+\t(subreg_regno_offset): New function.\n+\t(subreg_regno): New function.\n+\t* sched-vis.c (print_value): Change SUBREG_WORD to SUBREG_BYTE.\n+\t* sdbout.c (sdbout_symbol): Compute offset using alter_subreg.\n+\t* stmt.c (expand_anon_union_decl): Use gen_lowpart_SUBREG.\n+\t* tm.texi (ALTER_HARD_SUBREG): Remove, it is now dead.\n+\t(SUBREG_REGNO_OFFSET): Describe SUBREG_REGNO_OFFSET overrides.\n+\t* config/a29k/a29k.c (gpc_reg_operand): Use subreg_regno.\n+\t(a29k_get_reloaded_address): Use SUBREG_BYTE.\n+\t(print_operand): Use SUBREG_BYTE.\n+\t* config/alpha/alpha.c (print_operand_address): Use SUBREG_BYTE.\n+\t* config/arm/arm.c (arm_reload_in_hi): Use SUBREG_BYTE.\n+\t(arm_reload_out_hi): Use SUBREG_BYTE.\n+\t* config/d30v/d30v.c (d30v_split_double): Use subreg_regno_offset\n+\tinstead of SUBREG_WORD.\n+\t(d30v_print_operand_memory_reference): Use subreg_regno_offset.\n+\t* config/dsp16xx/dsp16xx.md (extendqihi2, zero_extendqihi2): Fix\n+\tSUBREG creation to use byte offset.\n+\t* config/h8300/h8300.md (Unnamed HImode zero extraction and 16bit\n+\tinverted load insns): Fix explicit rtl subregs to use byte\n+\toffsets.\n+\t* config/i370/i370.md (cmpstrsi, movstrsi, mulsi3, divsi3,\n+\tudivsi3, umodsi3): Generate SUBREGs with byte offsets.\n+\t* config/i860/i860.c (single_insn_src_p): Use SUBREG_BYTE.\n+\t* config/i860/i860.md (mulsi3_big): Fixup explicit SUBREGs in rtl\n+\tto use byte offsets.\n+\t(unnamed fmlow.dd insn): Fixup SUBREGS to use byte offsets.\n+\t* config/i960/i960.md (extendhisi2): Generate SUBREGs with byte\n+\toffsets, also make sure it is congruent to SUBREG's mode size.\n+\t(extendqisi2, extendqihi2, zero_extendhisi2, zero_extendqisi2,\n+\tunnamed ldob insn): Generate SUBREGs with byte offset.\n+\t(zero_extendqihi2): SUBREG's are byte offsets.\n+\t* config/m68hc11/m68hc11.c (m68hc11_gen_lowpart): Use SUBREG_BYTE.\n+\t(m68hc11_gen_highpart): Use SUBREG_BYTE.\n+\t* config/m68k/m68k.md (zero_extendhisi2, zero_extendqihi2,\n+\tzero-extendqisi2): Generate SUBREGs with byte offset.\n+\t(umulsidi3, mulsidi3, subreghi1ashrdi_const32,\n+\tsubregsi1ashrdi_const32, subreg1lshrdi_const32): Fixup explicit\n+\tsubregs in rtl to use byte offsets.\n+\t* config/m88k/m88k.md (extendsidi2): fixup subregs to use byte offset.\n+\t* config/mips/mips.c (mips_move_1word): Use subreg_regno_offset.\n+\t(mips_move_2words): Use subreg_regno_offset.\n+\t(mips_secondary_reload_class): Use subreg_regno_offset.\n+\t* config/mips/mips.md (DImode plus, minus, move, and logical op\n+\tsplits): Fixup explicit subregs in rtl to use byte offsets.\n+\t* config/mn10200/mn10200.c (print_operand): Use subreg_regno function.\n+\t* config/mn10300/mn10300.c (print_operand): Use subreg_regno function.\n+\t* config/ns32k/ns32k.md (udivmoddisi4): Fix explicit subregs in\n+\trtl to use byte offsets.\n+\t* config/pa/pa.c (emit_move_sequence): Use SUBREG_BYTE.\n+\t* config/pa/pa.md (floatunssisf2, floatunssidf2, mulsi3): fix explicit\n+\tsubregs to use byte offsets.\n+\t* config/pdp11/pdp11.md (zero_extendhisi2, modhi3, modhi3+1):\n+\tFixup explicit subregs in rtl to use byte offsets.\n+\t* config/romp/romp.c (memory_offset_in_range_p): Use SUBREG_BYTE\n+\tand remove byte endian correction code.\n+\t* config/sh/sh.c (output_movedouble): Use subreg_regno.\n+\t(gen_ashift_hi): Use SUBREG_BYTE.\n+\t(regs_used): Use subreg_regno_offset.\n+\t(machine_dependent_reorg): Use subreg_regno_offset.\n+\t* config/sh/sh.h (INDEX_REGISTER_RTX_P): Use SUBREG_BYTE.\n+\t* config/sh/sh.md (DImode and DFmode move splits): Use subreg_regno.\n+\t(movdf_i4): Subregs are byte offsets now.\n+\t* config/sparc/sparc.c (ultra_find_type): Use SUBREG_BYTE.\n+\t* config/sparc/sparc.h (ALTER_HARD_SUBREG): Removed.\n+\t(REGMODE_NATURAL_SIZE): Override.\n+\t(REG_SIZE): For SUBREG check float mode on SUBREG_REG's mode.\n+\t* config/sparc/sparc.md (TFmode move splits): Generate SUBREGs\n+\twith byte offsets.\n+\t(zero_extendhisi2, zero_extendqidi2_insn, extendhisi2,\n+\textendqihi2, sign_extendqihi2_insn, sign_extendqisi2_insn,\n+\textendqidi2): Generate SUBREGs with byte offsets, also make sure\n+\tit is congruent to SUBREG's mode size.\n+\t(smulsi3_highpart_v8plus): Fix explicit subregs in rtl to use byte\n+\toffsets.\n+\t(cmp_siqi_trunc, cmp_siqi_trunc_set, cmp_diqi_trunc, \n+\tcmp_diqi_trunc_set, lshrdi3_v8plus+1, lshrdi3_v8plus+2, \n+\tlshrdi3_v8plus+3, lshrdi3_v8plus+4): Use proper\n+\tSUBREG_BYTE offset for non-paradoxical subregs in patterns.\n+\t* config/v850/v850.c (print_operand, output_move_double): Use \n+\tsubreg_regno function.\n+\n 2001-04-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in (target_subdir): Use target_alias, not target."}, {"sha": "d69b38392fe6963ffaed9428a626d6922674a922", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1880,7 +1880,7 @@ nonlocal_mentioned_p (x)\n \t{\n \t  /* Global registers are not local.  */\n \t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n-\t      && global_regs[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)])\n+\t      && global_regs[subreg_regno (x)])\n \t    return 1;\n \t  return 0;\n \t}"}, {"sha": "602159d5eb07e18df1dcbf265fb262ef601f4332", "filename": "gcc/caller-save.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -487,18 +487,21 @@ mark_set_regs (reg, setter, data)\n {\n   register int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n-  int word = 0;\n \n   if (GET_CODE (reg) == SUBREG)\n     {\n-      word = SUBREG_WORD (reg);\n-      reg = SUBREG_REG (reg);\n-    }\n+      rtx inner = SUBREG_REG (reg);\n+      if (GET_CODE (inner) != REG || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n+\treturn;\n \n-  if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+      regno = subreg_hard_regno (reg, 1);\n+    }\n+  else if (GET_CODE (reg) == REG\n+\t   && REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+    regno = REGNO (reg);\n+  else\n     return;\n \n-  regno = REGNO (reg) + word;\n   endregno = regno + HARD_REGNO_NREGS (regno, mode);\n \n   for (i = regno; i < endregno; i++)\n@@ -517,21 +520,24 @@ add_stored_regs (reg, setter, data)\n {\n   register int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n-  int word = 0;\n+  int offset = 0;\n \n   if (GET_CODE (setter) == CLOBBER)\n     return;\n \n-  while (GET_CODE (reg) == SUBREG)\n+  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n     {\n-      word += SUBREG_WORD (reg);\n+      offset = subreg_regno_offset (REGNO (SUBREG_REG (reg)),\n+\t\t\t\t    GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t    SUBREG_BYTE (reg),\n+\t\t\t\t    GET_MODE (reg));\n       reg = SUBREG_REG (reg);\n     }\n \n   if (GET_CODE (reg) != REG || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n     return;\n \n-  regno = REGNO (reg) + word;\n+  regno = REGNO (reg) + offset;\n   endregno = regno + HARD_REGNO_NREGS (regno, mode);\n \n   for (i = regno; i < endregno; i++)"}, {"sha": "694eeeee4e603408beb21d40a3288720fc5069fc", "filename": "gcc/calls.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1462,6 +1462,8 @@ precompute_arguments (flags, num_actuals, args)\n     if ((flags & (ECF_CONST | ECF_PURE))\n \t|| calls_function (args[i].tree_value, !ACCUMULATE_OUTGOING_ARGS))\n       {\n+\tenum machine_mode mode;\n+\n \t/* If this is an addressable type, we cannot pre-evaluate it.  */\n \tif (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n \t  abort ();\n@@ -1481,11 +1483,11 @@ precompute_arguments (flags, num_actuals, args)\n \targs[i].initial_value = args[i].value\n \t  = protect_from_queue (args[i].value, 0);\n \n-\tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != args[i].mode)\n+\tmode = TYPE_MODE (TREE_TYPE (args[i].tree_value));\n+\tif (mode != args[i].mode)\n \t  {\n \t    args[i].value\n-\t      = convert_modes (args[i].mode,\n-\t\t\t       TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t      = convert_modes (args[i].mode, mode,\n \t\t\t       args[i].value, args[i].unsignedp);\n #ifdef PROMOTE_FOR_CALL_ONLY\n \t    /* CSE will replace this only if it contains args[i].value\n@@ -1495,8 +1497,7 @@ precompute_arguments (flags, num_actuals, args)\n \t\t&& GET_MODE_CLASS (args[i].mode) == MODE_INT)\n \t      {\n \t\targs[i].initial_value\n-\t\t  = gen_rtx_SUBREG (TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n-\t\t\t\t    args[i].value, 0);\n+\t\t  = gen_lowpart_SUBREG (mode, args[i].value);\n \t\tSUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;\n \t\tSUBREG_PROMOTED_UNSIGNED_P (args[i].initial_value)\n \t\t  = args[i].unsignedp;\n@@ -3272,13 +3273,25 @@ expand_call (exp, target, ignore)\n \t{\n \t  tree type = TREE_TYPE (exp);\n \t  int unsignedp = TREE_UNSIGNED (type);\n+\t  int offset = 0;\n \n \t  /* If we don't promote as expected, something is wrong.  */\n \t  if (GET_MODE (target)\n \t      != promote_mode (type, TYPE_MODE (type), &unsignedp, 1))\n \t    abort ();\n \n-\t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, 0);\n+\tif ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+\t    && GET_MODE_SIZE (GET_MODE (target))\n+\t       > GET_MODE_SIZE (TYPE_MODE (type)))\n+\t  {\n+\t    offset = GET_MODE_SIZE (GET_MODE (target))\n+\t\t     - GET_MODE_SIZE (TYPE_MODE (type));\n+\t    if (! BYTES_BIG_ENDIAN)\n+\t      offset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t    else if (! WORDS_BIG_ENDIAN)\n+\t      offset %= UNITS_PER_WORD;\n+\t  }\n+\t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n \t  SUBREG_PROMOTED_VAR_P (target) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (target) = unsignedp;\n \t}"}, {"sha": "ee5631c82636647eb9cc0e6f58d85f9d9060e404", "filename": "gcc/combine.c", "status": "modified", "additions": 109, "deletions": 56, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2249,7 +2249,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t     be written as a ZERO_EXTEND.  */\n \t  if (split_code == SUBREG && GET_CODE (SUBREG_REG (*split)) == MEM)\n \t    SUBST (*split, gen_rtx_ZERO_EXTEND  (split_mode,\n-\t\t\t\t\t\t XEXP (*split, 0)));\n+\t\t\t\t\t\t SUBREG_REG (*split)));\n #endif\n \n \t  newi2pat = gen_rtx_SET (VOIDmode, newdest, *split);\n@@ -3773,27 +3773,17 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n \t{\n \t  rtx inner = SUBREG_REG (x);\n-\t  int endian_offset = 0;\n+\t  int offset = SUBREG_BYTE (x);\n \t  /* Don't change the mode of the MEM\n \t     if that would change the meaning of the address.  */\n \t  if (MEM_VOLATILE_P (SUBREG_REG (x))\n \t      || mode_dependent_address_p (XEXP (inner, 0)))\n \t    return gen_rtx_CLOBBER (mode, const0_rtx);\n \n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      if (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-\t\tendian_offset += UNITS_PER_WORD - GET_MODE_SIZE (mode);\n-\t      if (GET_MODE_SIZE (GET_MODE (inner)) < UNITS_PER_WORD)\n-\t\tendian_offset -= (UNITS_PER_WORD\n-\t\t\t\t  - GET_MODE_SIZE (GET_MODE (inner)));\n-\t    }\n \t  /* Note if the plus_constant doesn't make a valid address\n \t     then this combination won't be accepted.  */\n \t  x = gen_rtx_MEM (mode,\n-\t\t\t   plus_constant (XEXP (inner, 0),\n-\t\t\t\t\t  (SUBREG_WORD (x) * UNITS_PER_WORD\n-\t\t\t\t\t   + endian_offset)));\n+\t\t\t   plus_constant (XEXP (inner, 0), offset));\n \t  MEM_COPY_ATTRIBUTES (x, inner);\n \t  return x;\n \t}\n@@ -3806,12 +3796,58 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t or not at all if changing back to starting mode.  */\n       if (GET_CODE (SUBREG_REG (x)) == SUBREG)\n \t{\n-\t  if (mode == GET_MODE (SUBREG_REG (SUBREG_REG (x)))\n-\t      && SUBREG_WORD (x) == 0 && SUBREG_WORD (SUBREG_REG (x)) == 0)\n-\t    return SUBREG_REG (SUBREG_REG (x));\n+\t  int final_offset;\n+\t  enum machine_mode outer_mode, inner_mode;\n+\n+\t  /* If the innermost mode is the same as the goal mode,\n+\t     and the low word is being referenced in both SUBREGs,\n+\t     return the innermost element.  */\n+\t  if (mode == GET_MODE (SUBREG_REG (SUBREG_REG (x))))\n+\t    {\n+\t      int inner_word = SUBREG_BYTE (SUBREG_REG (x));\n+\t      int outer_word = SUBREG_BYTE (x);\n+\n+\t      inner_word = (inner_word / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t      outer_word = (outer_word / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t      if (inner_word == 0\n+\t\t  && outer_word == 0)\n+\t\treturn SUBREG_REG (SUBREG_REG (x));\n+\t    }\n+\n+\t  outer_mode = GET_MODE (SUBREG_REG (x));\n+\t  inner_mode = GET_MODE (SUBREG_REG (SUBREG_REG (x)));\n+\t  final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (SUBREG_REG(x));\n+\n+\t  if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+\t      && GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (mode)\n+\t      && GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (inner_mode))\n+\t    {\n+\t      /* Inner SUBREG is paradoxical, outer is not.  On big endian\n+\t\t we have to special case this.  */\n+\t      if (SUBREG_BYTE (SUBREG_REG (x)))\n+\t\tabort(); /* Can a paradoxical subreg have nonzero offset? */\n+\t      if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n+\t        final_offset = SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n+\t\t\t       + GET_MODE_SIZE (inner_mode);\n+\t      else if (WORDS_BIG_ENDIAN)\n+\t\tfinal_offset = (final_offset % UNITS_PER_WORD)\n+\t\t\t       + ((SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n+\t\t\t\t   + GET_MODE_SIZE (inner_mode))\n+\t\t\t\t  * UNITS_PER_WORD) / UNITS_PER_WORD;\n+\t      else\n+\t\tfinal_offset = ((final_offset * UNITS_PER_WORD)\n+\t\t\t\t/ UNITS_PER_WORD)\n+\t\t\t       + ((SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n+\t\t\t\t   + GET_MODE_SIZE (inner_mode))\n+\t\t\t\t  % UNITS_PER_WORD);\n+\t    }\n \n-\t  SUBST_INT (SUBREG_WORD (x),\n-\t\t     SUBREG_WORD (x) + SUBREG_WORD (SUBREG_REG (x)));\n+\t  /* The SUBREG rules are that the byte offset must be\n+\t     some multiple of the toplevel SUBREG's mode.  */\n+\t  final_offset = (final_offset / GET_MODE_SIZE (mode));\n+\t  final_offset = (final_offset * GET_MODE_SIZE (mode));\n+\n+\t  SUBST_INT (SUBREG_BYTE (x), final_offset);\n \t  SUBST (SUBREG_REG (x), SUBREG_REG (SUBREG_REG (x)));\n \t}\n \n@@ -3831,10 +3867,10 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n #endif\n \t  && REGNO (SUBREG_REG (x)) != STACK_POINTER_REGNUM)\n \t{\n-\t  if (HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (x)) + SUBREG_WORD (x),\n-\t\t\t\t  mode))\n-\t    return gen_rtx_REG (mode,\n-\t\t\t\tREGNO (SUBREG_REG (x)) + SUBREG_WORD (x));\n+\t  int final_regno = subreg_hard_regno (x, 0);\n+\n+\t  if (HARD_REGNO_MODE_OK (final_regno, mode))\n+\t    return gen_rtx_REG (mode, final_regno);\n \t  else\n \t    return gen_rtx_CLOBBER (mode, const0_rtx);\n \t}\n@@ -3849,7 +3885,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && GET_MODE_SIZE (op0_mode) > UNITS_PER_WORD\n \t  && GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n-\t  temp = operand_subword (SUBREG_REG (x), SUBREG_WORD (x),\n+\t  temp = operand_subword (SUBREG_REG (x),\n+\t\t\t\t  (SUBREG_BYTE (x) / UNITS_PER_WORD),\n \t\t\t\t  0, op0_mode);\n \t  if (temp)\n \t    return temp;\n@@ -3863,11 +3900,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       if (CONSTANT_P (SUBREG_REG (x))\n \t  && ((GET_MODE_SIZE (op0_mode) <= UNITS_PER_WORD\n \t      || ! WORDS_BIG_ENDIAN)\n-\t      ? SUBREG_WORD (x) == 0\n-\t      : (SUBREG_WORD (x)\n-\t\t == ((GET_MODE_SIZE (op0_mode)\n-\t\t      - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n-\t\t     / UNITS_PER_WORD)))\n+\t      ? SUBREG_BYTE (x) == 0\n+\t      : (SUBREG_BYTE (x)\n+\t\t == (GET_MODE_SIZE (op0_mode) - GET_MODE_SIZE (mode))))\n \t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (op0_mode)\n \t  && (! WORDS_BIG_ENDIAN\n \t      || GET_MODE_BITSIZE (op0_mode) <= BITS_PER_WORD))\n@@ -3879,8 +3914,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (op0_mode))\n \t{\n \t  if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t      && (WORDS_BIG_ENDIAN || SUBREG_WORD (x) != 0))\n-\t    return operand_subword (SUBREG_REG (x), SUBREG_WORD (x), 0, mode);\n+\t      && (WORDS_BIG_ENDIAN || SUBREG_BYTE (x) != 0))\n+\t    return constant_subword (SUBREG_REG (x), \n+\t\t\t\t     SUBREG_BYTE (x) / UNITS_PER_WORD, mode);\n \t  return SUBREG_REG (x);\n \t}\n \n@@ -5157,14 +5193,14 @@ simplify_set (x)\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n       && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != NIL\n-      && SUBREG_WORD (src) == 0\n+      && SUBREG_BYTE (src) == 0\n       && (GET_MODE_SIZE (GET_MODE (src))\n \t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n       && GET_CODE (SUBREG_REG (src)) == MEM)\n     {\n       SUBST (SET_SRC (x),\n \t     gen_rtx (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))),\n-\t\t      GET_MODE (src), XEXP (src, 0)));\n+\t\t      GET_MODE (src), SUBREG_REG (src)));\n \n       src = SET_SRC (x);\n     }\n@@ -5756,9 +5792,11 @@ expand_field_assignment (x)\n       if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n \t  && GET_CODE (XEXP (SET_DEST (x), 0)) == SUBREG)\n \t{\n+\t  int byte_offset = SUBREG_BYTE (XEXP (SET_DEST (x), 0));\n+\n \t  inner = SUBREG_REG (XEXP (SET_DEST (x), 0));\n \t  len = GET_MODE_BITSIZE (GET_MODE (XEXP (SET_DEST (x), 0)));\n-\t  pos = GEN_INT (BITS_PER_WORD * SUBREG_WORD (XEXP (SET_DEST (x), 0)));\n+\t  pos = GEN_INT (BITS_PER_WORD * (byte_offset / UNITS_PER_WORD));\n \t}\n       else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n \t       && GET_CODE (XEXP (SET_DEST (x), 1)) == CONST_INT)\n@@ -5996,18 +6034,26 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  /* We can't call gen_lowpart_for_combine here since we always want\n \t     a SUBREG and it would sometimes return a new hard register.  */\n \t  if (tmode != inner_mode)\n-\t    new = gen_rtx_SUBREG (tmode, inner,\n-\t\t\t\t  (WORDS_BIG_ENDIAN\n-\t\t\t\t   && (GET_MODE_SIZE (inner_mode)\n-\t\t\t\t       > UNITS_PER_WORD)\n-\t\t\t\t   ? (((GET_MODE_SIZE (inner_mode)\n-\t\t\t\t\t- GET_MODE_SIZE (tmode))\n-\t\t\t\t       / UNITS_PER_WORD)\n-\t\t\t\t      - pos / BITS_PER_WORD)\n-\t\t\t\t   : pos / BITS_PER_WORD));\n-\t  else\n-\t    new = inner;\n-\t}\n+\t    {\n+\t      int final_word = pos / BITS_PER_WORD;\n+\n+\t      if (WORDS_BIG_ENDIAN\n+\t\t  && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD)\n+\t\tfinal_word = ((GET_MODE_SIZE (inner_mode)\n+\t\t\t       - GET_MODE_SIZE (tmode))\n+\t\t\t      / UNITS_PER_WORD) - final_word;\n+\n+\t      final_word *= UNITS_PER_WORD;\n+\t      if (BYTES_BIG_ENDIAN &&\n+\t\t  GET_MODE_SIZE (inner_mode) > GET_MODE_SIZE (tmode))\n+\t\tfinal_word += (GET_MODE_SIZE (inner_mode)\n+\t\t\t       - GET_MODE_SIZE (tmode)) % UNITS_PER_WORD;\n+\n+\t      new = gen_rtx_SUBREG (tmode, inner, final_word);\n+\t    }\n+  \t  else\n+  \t    new = inner;\n+  \t}\n       else\n \tnew = force_to_mode (inner, tmode,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n@@ -7395,11 +7441,11 @@ if_then_else_cond (x, ptrue, pfalse)\n \t   || GET_CODE (SUBREG_REG (x)) == MEM\n \t   || CONSTANT_P (SUBREG_REG (x)))\n \t  && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t  && (WORDS_BIG_ENDIAN || SUBREG_WORD (x) != 0))\n+\t  && (WORDS_BIG_ENDIAN || SUBREG_BYTE (x) >= UNITS_PER_WORD))\n \t{\n-\t  true0 = operand_subword (true0, SUBREG_WORD (x), 0,\n+\t  true0 = operand_subword (true0, SUBREG_BYTE (x) / UNITS_PER_WORD, 0,\n \t\t\t\t   GET_MODE (SUBREG_REG (x)));\n-\t  false0 = operand_subword (false0, SUBREG_WORD (x), 0,\n+\t  false0 = operand_subword (false0, SUBREG_BYTE (x) / UNITS_PER_WORD, 0,\n \t\t\t\t    GET_MODE (SUBREG_REG (x)));\n \t}\n       *ptrue = force_to_mode (true0, mode, ~(HOST_WIDE_INT) 0, NULL_RTX, 0);\n@@ -7772,7 +7818,7 @@ apply_distributive_law (x)\n \n     case SUBREG:\n       /* Non-paradoxical SUBREGs distributes over all operations, provided\n-\t the inner modes and word numbers are the same, this is an extraction\n+\t the inner modes and byte offsets are the same, this is an extraction\n \t of a low-order part, we don't convert an fp operation to int or\n \t vice versa, and we would not be converting a single-word\n \t operation into a multi-word operation.  The latter test is not\n@@ -7783,7 +7829,7 @@ apply_distributive_law (x)\n \t We produce the result slightly differently in this case.  */\n \n       if (GET_MODE (SUBREG_REG (lhs)) != GET_MODE (SUBREG_REG (rhs))\n-\t  || SUBREG_WORD (lhs) != SUBREG_WORD (rhs)\n+\t  || SUBREG_BYTE (lhs) != SUBREG_BYTE (rhs)\n \t  || ! subreg_lowpart_p (lhs)\n \t  || (GET_MODE_CLASS (GET_MODE (lhs))\n \t      != GET_MODE_CLASS (GET_MODE (SUBREG_REG (lhs))))\n@@ -9853,13 +9899,19 @@ gen_lowpart_for_combine (mode, x)\n      include an explicit SUBREG or we may simplify it further in combine.  */\n   else\n     {\n-      int word = 0;\n+      int offset = 0;\n \n-      if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n-\tword = ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n-\t\t/ UNITS_PER_WORD);\n-      return gen_rtx_SUBREG (mode, x, word);\n+      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+\t  && GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n+\t{\n+\t  int difference = (GET_MODE_SIZE (GET_MODE (x))\n+\t\t\t    - GET_MODE_SIZE (mode));\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    offset += difference % UNITS_PER_WORD;\n+\t}\n+      return gen_rtx_SUBREG (mode, x, offset);\n     }\n }\n \f\n@@ -11927,6 +11979,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n \t that accesses one word of a multi-word item, some\n \t piece of everything register in the expression is used by\n \t this insn, so remove any old death.  */\n+      /* ??? So why do we test for equality of the sizes?  */\n \n       if (GET_CODE (dest) == ZERO_EXTRACT\n \t  || GET_CODE (dest) == STRICT_LOW_PART"}, {"sha": "65c6240a3bc60f106e97cdcde34a479cee470aaa", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -262,9 +262,10 @@ gpc_reg_operand (op, mode)\n     regno = REGNO (op);\n   else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n     {\n-      regno = REGNO (SUBREG_REG (op));\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\tregno += SUBREG_WORD (op);\n+      if (REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n+\tregno = subreg_regno (op);\n+      else\n+\tregno = REGNO (SUBREG_REG (op));\n     }\n   else\n     return 0;\n@@ -467,7 +468,7 @@ a29k_get_reloaded_address (op)\n {\n   if (GET_CODE (op) == SUBREG)\n     {\n-      if (SUBREG_WORD (op) != 0)\n+      if (SUBREG_BYTE (op) != 0)\n \tabort ();\n \n       op = SUBREG_REG (op);\n@@ -1187,7 +1188,8 @@ print_operand (file, x, code)\n       if (GET_MODE (SUBREG_REG (XEXP (x, 0))) == SFmode)\n \tfprintf (file, \"$float\");\n       else\n-\tfprintf (file, \"$double%d\", SUBREG_WORD (XEXP (x, 0)));\n+\tfprintf (file, \"$double%d\", \n+\t\t (SUBREG_BYTE (XEXP (x, 0)) / GET_MODE_SIZE (GET_MODE (x))));      \n       memcpy ((char *) &u,\n \t      (char *) &CONST_DOUBLE_LOW (SUBREG_REG (XEXP (x, 0))), sizeof u);\n       fprintf (file, \"(%.20e)\", u.d);"}, {"sha": "c6aa2eec7faca045ceab07396da5a38675385355", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -4098,7 +4098,8 @@ print_operand_address (file, addr)\n     basereg = REGNO (addr);\n   else if (GET_CODE (addr) == SUBREG\n \t   && GET_CODE (SUBREG_REG (addr)) == REG)\n-    basereg = REGNO (SUBREG_REG (addr)) + SUBREG_WORD (addr);\n+    basereg = REGNO (SUBREG_REG (addr))\n+\t      + SUBREG_BYTE (addr) / GET_MODE_SIZE (GET_MODE (addr));\n   else if (GET_CODE (addr) == CONST_INT)\n     offset = INTVAL (addr);\n   else"}, {"sha": "b89392efad2639962f8b310551e9469377344403", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -4748,11 +4748,7 @@ arm_reload_in_hi (operands)\n \n   if (GET_CODE (ref) == SUBREG)\n     {\n-      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n-\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      offset = SUBREG_BYTE (ref);\n       ref = SUBREG_REG (ref);\n     }\n \n@@ -4865,11 +4861,7 @@ arm_reload_out_hi (operands)\n \n   if (GET_CODE (ref) == SUBREG)\n     {\n-      offset = SUBREG_WORD (ref) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (ref)))\n-\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (SUBREG_REG (ref)))));\n+      offset = SUBREG_BYTE (ref);\n       ref = SUBREG_REG (ref);\n     }\n "}, {"sha": "b8f30aa7c5fcfc4f817a2fbcba63b4b56ff8ee59", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2667,10 +2667,13 @@ d30v_split_double (value, p_high, p_low)\n   switch (GET_CODE (value))\n     {\n     case SUBREG:\n-      offset = SUBREG_WORD (value);\n-      value = SUBREG_REG (value);\n-      if (GET_CODE (value) != REG)\n+      if (GET_CODE (SUBREG_REG (value)) != REG)\n \tabort ();\n+      offset = subreg_regno_offset (REGNO (SUBREG_REG (value)),\n+\t\t\t\t    GET_MODE (SUBREG_REG (value)),\n+\t\t\t\t    SUBREG_BYTE (value),\n+\t\t\t\t    GET_MODE (value));\n+      value = SUBREG_REG (value);\n \n       /* fall through */\n \n@@ -2795,7 +2798,10 @@ d30v_print_operand_memory_reference (stream, x)\n \n       if (GET_CODE (x0) == SUBREG)\n \t{\n-\t  offset0 = SUBREG_WORD (x0);\n+\t  offset0 = subreg_regno_offset (REGNO (SUBREG_REG (x0)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (x0)),\n+\t\t\t\t\t SUBREG_BYTE (x0),\n+\t\t\t\t\t GET_MODE (x0));\n \t  x0 = SUBREG_REG (x0);\n \t}\n \n@@ -2828,7 +2834,10 @@ d30v_print_operand_memory_reference (stream, x)\n       switch (GET_CODE (x1))\n \t{\n \tcase SUBREG:\n-\t  offset1 = SUBREG_WORD (x1);\n+\t  offset1 = subreg_regno_offset (REGNO (SUBREG_REG (x1)),\n+\t\t\t\t\t GET_MODE (SUBREG_REG (x1)),\n+\t\t\t\t\t SUBREG_BYTE (x1),\n+\t\t\t\t\t GET_MODE (x1));\n \t  x1 = SUBREG_REG (x1);\n \t  if (GET_CODE (x1) != REG)\n \t    fatal_insn (\"Bad insn to d30v_print_operand_memory_reference:\", x);"}, {"sha": "4c65a89bfbe393b804f4a2be1658cbfc7ba85976", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1258,7 +1258,7 @@\n   \"\n {\n \toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], 1);\n+\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], GET_MODE_SIZE (QImode));\n }\")\n \n ;;(define_insn \"extendqihi2\"\n@@ -1308,7 +1308,7 @@\n   \"\n {\n \toperands[2] = gen_reg_rtx (HImode);\n-\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], 1);\n+\toperands[3] = gen_rtx_SUBREG (QImode, operands[2], GET_MODE_SIZE (QImode));\n }\")\n \n "}, {"sha": "d79750aeb23dacfa686558835342816ed41b19b4", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1925,7 +1925,7 @@\n \t(subreg:HI (zero_extract:SI\n \t\t     (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t     (const_int 1)\n-\t\t     (match_operand:HI 2 \"immediate_operand\" \"n\")) 1))]\n+\t\t     (match_operand:HI 2 \"immediate_operand\" \"n\")) 2))]\n   \"\"\n   \"sub.w\t%0,%0\\;bld\t%Z2,%Y1\\;bst\t#0,%X0\"\n   [(set_attr \"cc\" \"clobber\")\n@@ -1966,7 +1966,7 @@\n \t\t  (subreg:HI\n \t\t    (lshiftrt:SI\n \t\t      (match_operand:SI 1 \"register_operand\" \"Ur\")\n-\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 1))\n+\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\")) 2))\n \t\t(const_int 1)))]\n   \"INTVAL (operands[2]) < 16\"\n   \"sub.w\t%0,%0\\;bild\t%Z2,%Y1\\;bst\t#0,%X0\""}, {"sha": "5de8931d21bf8bfaef3f54f8b54b039a6bb56bb8", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -537,12 +537,12 @@ check_label_emit ();\n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                         force_operand (XEXP (mem1, 0), NULL_RTX));\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 1), len);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n \n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),\n                         force_operand (XEXP (mem2, 0), NULL_RTX));\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 1), len);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);\n \n         /* Compare! */\n         emit_insn (gen_cmpstrsi_1 (result, reg1, reg2));\n@@ -1409,11 +1409,11 @@ check_label_emit ();\n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                         force_operand (XEXP (mem1, 0), NULL_RTX));\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 1), len);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n \n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0), zippo);\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 1), zippo);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), zippo);\n \n         /* Copy! */\n         emit_insn (gen_movstrsi_1 (reg1, reg2));\n@@ -1476,12 +1476,12 @@ check_label_emit ();\n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg1));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 0),\n                         force_operand (XEXP (mem1, 0), NULL_RTX));\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, 1), len);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg1, GET_MODE_SIZE (SImode)), len);\n \n         emit_insn (gen_rtx_CLOBBER (VOIDmode, reg2));\n         emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 0),\n                         force_operand (XEXP (mem2, 0), NULL_RTX));\n-        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, 1), len);\n+        emit_move_insn (gen_rtx_SUBREG (SImode, reg2, GET_MODE_SIZE (SImode)), len);\n \n         /* Copy! */\n         emit_insn (gen_movstrsi_1 (reg1, reg2));\n@@ -2425,11 +2425,12 @@ check_label_emit ();\n        * Dunno how to untwist it elegantly; but it seems to work for now.\n        */\n       emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t  gen_rtx_SUBREG (SImode, r, 1), operands[1]));\n+\t\t\t  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode)),\n+\t\t\t\t\t  operands[1]));\n       emit_insn (gen_rtx_SET (VOIDmode, r,\n \t\t\t  gen_rtx_MULT (DImode, r, operands[2])));\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_SUBREG (SImode, r, 1)));\n+\t\t\t  gen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));\n     }\n   DONE;\n }\")\n@@ -2534,7 +2535,7 @@ check_label_emit ();\n   emit_insn (gen_rtx_SET (VOIDmode, r,\n \t\t\tgen_rtx_DIV (DImode, r, operands[2])));\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\tgen_rtx_SUBREG (SImode, r, 1)));\n+\t\t\tgen_rtx_SUBREG (SImode, r, GET_MODE_SIZE (SImode))));\n   DONE;\n }\")\n \n@@ -2552,7 +2553,7 @@ check_label_emit ();\n {\n   rtx dr = gen_reg_rtx (DImode);\n   rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);\n-  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, 1);\n+  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, GET_MODE_SIZE (SImode));\n \n \n   if (GET_CODE (operands[2]) == CONST_INT)"}, {"sha": "4789f70fe0008c0de9736bf2304a86f8a8907a18", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -340,7 +340,7 @@ single_insn_src_p (op, mode)\n       return 1;\n \n     case SUBREG:\n-      if (SUBREG_WORD (op) != 0)\n+      if (SUBREG_BYTE (op) != 0)\n \treturn 0;\n       return single_insn_src_p (SUBREG_REG (op), mode);\n "}, {"sha": "5778964f5bee181cf0fab52f3882b86bab0291cb", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1730,12 +1730,12 @@\n }\")\n \n (define_expand \"mulsi3_big\"\n-  [(set (subreg:SI (match_dup 4) 1) (match_operand:SI 1 \"general_operand\" \"\"))\n-   (set (subreg:SI (match_dup 5) 1) (match_operand:SI 2 \"general_operand\" \"\"))\n+  [(set (subreg:SI (match_dup 4) 4) (match_operand:SI 1 \"general_operand\" \"\"))\n+   (set (subreg:SI (match_dup 5) 4) (match_operand:SI 2 \"general_operand\" \"\"))\n    (clobber (match_dup 3))\n-   (set (subreg:SI (match_dup 3) 1)\n-\t(mult:SI (subreg:SI (match_dup 4) 1) (subreg:SI (match_dup 5) 1)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 1))]\n+   (set (subreg:SI (match_dup 3) 4)\n+\t(mult:SI (subreg:SI (match_dup 4) 4) (subreg:SI (match_dup 5) 4)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 4))]\n   \"WORDS_BIG_ENDIAN\"\n   \"\n {\n@@ -1752,9 +1752,9 @@\n   \"fmlow.dd %2,%1,%0\")\n \n (define_insn \"\"\n-  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 1)\n-\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 1)\n-\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 1)))]\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 4)\n+\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 4)\n+\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 4)))]\n   \"WORDS_BIG_ENDIAN\"\n   \"fmlow.dd %2,%1,%0\")\n \f"}, {"sha": "424fb87056e4edc243d2c61025c11d0b1ad21aaa", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1211,15 +1211,17 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_word = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n+\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n+\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n \t  operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n       emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n@@ -1246,15 +1248,17 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_word = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n+\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n+\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n \t  operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n@@ -1282,24 +1286,28 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_word = 0;\n-      int op1_subreg_word = 0;\n+      int op0_subreg_byte = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n+\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n+\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n \t  operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       if (GET_CODE (operand0) == SUBREG)\n \t{\n-\t  op0_subreg_word = SUBREG_WORD (operand0);\n+\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n+\t  op0_subreg_byte /= GET_MODE_SIZE (SImode);\n+\t  op0_subreg_byte *= GET_MODE_SIZE (SImode);\n \t  operand0 = SUBREG_REG (operand0);\n \t}\n       if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_word);\n+\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n@@ -1327,15 +1335,17 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_word = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n+\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n+\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n \t  operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n       emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n@@ -1367,15 +1377,17 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_word = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n-\t  operand1 = SUBREG_REG (operand1);\n+          op1_subreg_byte = SUBREG_BYTE (operand1);\n+          op1_subreg_byte /= GET_MODE_SIZE (SImode);\n+          op1_subreg_byte *= GET_MODE_SIZE (SImode);\n+          operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n@@ -1403,24 +1415,24 @@\n     {\n       rtx temp = gen_reg_rtx (SImode);\n       rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_word = 0;\n-      int op1_subreg_word = 0;\n+      int op0_subreg_byte = 0;\n+      int op1_subreg_byte = 0;\n \n       if (GET_CODE (operand1) == SUBREG)\n \t{\n-\t  op1_subreg_word = SUBREG_WORD (operand1);\n+\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n \t  operand1 = SUBREG_REG (operand1);\n \t}\n       if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_word);\n+\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n \n       if (GET_CODE (operand0) == SUBREG)\n \t{\n-\t  op0_subreg_word = SUBREG_WORD (operand0);\n+\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n \t  operand0 = SUBREG_REG (operand0);\n \t}\n       if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_word);\n+\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n \n       emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n       emit_insn (gen_lshrsi3 (operand0, temp, shift_24));"}, {"sha": "0075c39abc654f8e6ff461ee006788c583658725", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1739,12 +1739,12 @@ m68hc11_gen_lowpart (mode, x)\n     return gen_rtx (REG, mode, HARD_B_REGNUM);\n \n   /* gen_lowpart crashes when it is called with a SUBREG.  */\n-  if (GET_CODE (x) == SUBREG && SUBREG_WORD (x) != 0)\n+  if (GET_CODE (x) == SUBREG && SUBREG_BYTE (x) != 0)\n     {\n       if (mode == SImode)\n-\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + 2);\n+\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 2);\n       else if (mode == HImode)\n-\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + 1);\n+\treturn gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_BYTE (x) + 1);\n       else\n \tabort ();\n     }\n@@ -1844,7 +1844,7 @@ m68hc11_gen_highpart (mode, x)\n     }\n \n   /* gen_highpart crashes when it is called with a SUBREG.  */\n-  if (GET_CODE (x) == SUBREG && SUBREG_WORD (x) != 0)\n+  if (GET_CODE (x) == SUBREG && SUBREG_BYTE (x) != 0)\n     {\n       return gen_rtx (SUBREG, mode, XEXP (x, 0), XEXP (x, 1));\n     }"}, {"sha": "c74b1424e57fb54b481899da309effaed5366bc0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1554,7 +1554,7 @@\n   operands[1] = make_safe_from (operands[1], operands[0]);\n   if (GET_CODE (operands[0]) == SUBREG)\n     operands[2] = gen_rtx_SUBREG (HImode, SUBREG_REG (operands[0]),\n-\t\t\t\t  SUBREG_WORD (operands[0]));\n+\t\t\t\t  SUBREG_BYTE (operands[0]));\n   else\n     operands[2] = gen_rtx_SUBREG (HImode, operands[0], 0);\n }\")\n@@ -1570,7 +1570,7 @@\n   operands[1] = make_safe_from (operands[1], operands[0]);\n   if (GET_CODE (operands[0]) == SUBREG)\n     operands[2] = gen_rtx_SUBREG (QImode, SUBREG_REG (operands[0]),\n-\t\t\t\t  SUBREG_WORD (operands[0]));\n+\t\t\t\t  SUBREG_BYTE (operands[0]));\n   else\n     operands[2] = gen_rtx_SUBREG (QImode, operands[0], 0);\n }\")\n@@ -1586,7 +1586,7 @@\n   operands[1] = make_safe_from (operands[1], operands[0]);\n   if (GET_CODE (operands[0]) == SUBREG)\n     operands[2] = gen_rtx_SUBREG (QImode, SUBREG_REG (operands[0]),\n-\t\t\t\t  SUBREG_WORD (operands[0]));\n+\t\t\t\t  SUBREG_BYTE (operands[0]));\n   else\n     operands[2] = gen_rtx_SUBREG (QImode, operands[0], 0);\n }\")\n@@ -3096,7 +3096,7 @@\n ;; the high-numbered word of the DImode operand[0] and operand[1].\n (define_expand \"umulsidi3\"\n   [(parallel\n-    [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 1)\n+    [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 4)\n \t  (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n      (set (subreg:SI (match_dup 0) 0)\n@@ -3135,7 +3135,7 @@\n \n (define_expand \"mulsidi3\"\n   [(parallel\n-    [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 1)\n+    [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"\") 4)\n \t  (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"\")))\n      (set (subreg:SI (match_dup 0) 0)\n@@ -4731,7 +4731,7 @@\n (define_insn \"subreghi1ashrdi_const32\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n     (subreg:HI (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n-            (const_int 32)) 1))]\n+            (const_int 32)) 4))]\n   \"\"\n   \"*\n {\n@@ -4743,7 +4743,7 @@\n (define_insn \"subregsi1ashrdi_const32\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n     (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n-            (const_int 32)) 1))]\n+            (const_int 32)) 4))]\n   \"\"\n   \"*\n {\n@@ -4894,10 +4894,10 @@\n ;;(define_insn \"\"\n ;;        [(set (cc0)\n ;;            (subreg:SI (lshiftrt:DI (match_operand:DI 0 \"general_operand\" \"ro\")\n-;;                    (const_int 32)) 1))\n+;;                    (const_int 32)) 4))\n ;;        (set (match_operand:SI 1 \"general_operand\" \"=dm\")\n ;;            (subreg:SI (lshiftrt:DI (match_dup 0)\n-;;                    (const_int 32)) 1))]\n+;;                    (const_int 32)) 4))]\n ;;  \"\"\n ;;  \"*\n ;;{\n@@ -4924,7 +4924,7 @@\n (define_insn \"subreg1lshrdi_const32\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n     (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n-            (const_int 32)) 1))]\n+            (const_int 32)) 4))]\n   \"\"\n   \"*\n {"}, {"sha": "7a1ac64ed1839b367d06d7d0a78ab7e572729691", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2295,10 +2295,10 @@\n ;;- sign extension instructions\n \n (define_expand \"extendsidi2\"\n-  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=r\") 4)\n         (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (subreg:SI (match_dup 0) 0)\n-        (ashiftrt:SI (subreg:SI (match_dup 0) 1)\n+        (ashiftrt:SI (subreg:SI (match_dup 0) 4)\n                      (const_int 31)))]\n   \"\"\n   \"\")"}, {"sha": "aeccb3fae20e7633ed66392dd3dcc49e18942d99", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1833,20 +1833,26 @@ mips_move_1word (operands, insn, unsignedp)\n   enum rtx_code code0 = GET_CODE (op0);\n   enum rtx_code code1 = GET_CODE (op1);\n   enum machine_mode mode = GET_MODE (op0);\n-  int subreg_word0 = 0;\n-  int subreg_word1 = 0;\n+  int subreg_offset0 = 0;\n+  int subreg_offset1 = 0;\n   enum delay_type delay = DELAY_NONE;\n \n   while (code0 == SUBREG)\n     {\n-      subreg_word0 += SUBREG_WORD (op0);\n+      subreg_offset0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (op0)),\n+\t\t\t\t\t     SUBREG_BYTE (op0),\n+\t\t\t\t\t     GET_MODE (op0));\n       op0 = SUBREG_REG (op0);\n       code0 = GET_CODE (op0);\n     }\n \n   while (code1 == SUBREG)\n     {\n-      subreg_word1 += SUBREG_WORD (op1);\n+      subreg_offset1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (op1)),\n+\t\t\t\t\t     SUBREG_BYTE (op1),\n+\t\t\t\t\t     GET_MODE (op1));\n       op1 = SUBREG_REG (op1);\n       code1 = GET_CODE (op1);\n     }\n@@ -1857,11 +1863,11 @@ mips_move_1word (operands, insn, unsignedp)\n \n   if (code0 == REG)\n     {\n-      int regno0 = REGNO (op0) + subreg_word0;\n+      int regno0 = REGNO (op0) + subreg_offset0;\n \n       if (code1 == REG)\n \t{\n-\t  int regno1 = REGNO (op1) + subreg_word1;\n+\t  int regno1 = REGNO (op1) + subreg_offset1;\n \n \t  /* Just in case, don't do anything for assigning a register\n \t     to itself, unless we are filling a delay slot.  */\n@@ -2146,7 +2152,7 @@ mips_move_1word (operands, insn, unsignedp)\n \n       if (code1 == REG)\n \t{\n-\t  int regno1 = REGNO (op1) + subreg_word1;\n+\t  int regno1 = REGNO (op1) + subreg_offset1;\n \n \t  if (GP_REG_P (regno1))\n \t    {\n@@ -2225,13 +2231,16 @@ mips_move_2words (operands, insn)\n   rtx op1 = operands[1];\n   enum rtx_code code0 = GET_CODE (operands[0]);\n   enum rtx_code code1 = GET_CODE (operands[1]);\n-  int subreg_word0 = 0;\n-  int subreg_word1 = 0;\n+  int subreg_offset0 = 0;\n+  int subreg_offset1 = 0;\n   enum delay_type delay = DELAY_NONE;\n \n   while (code0 == SUBREG)\n     {\n-      subreg_word0 += SUBREG_WORD (op0);\n+      subreg_offset0 += subreg_regno_offset (REGNO (SUBREG_REG (op0)),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (op0)),\n+\t\t\t\t\t     SUBREG_BYTE (op0),\n+\t\t\t\t\t     GET_MODE (op0));\n       op0 = SUBREG_REG (op0);\n       code0 = GET_CODE (op0);\n     }\n@@ -2244,7 +2253,10 @@ mips_move_2words (operands, insn)\n \n   while (code1 == SUBREG)\n     {\n-      subreg_word1 += SUBREG_WORD (op1);\n+      subreg_offset1 += subreg_regno_offset (REGNO (SUBREG_REG (op1)),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (op1)),\n+\t\t\t\t\t     SUBREG_BYTE (op1),\n+\t\t\t\t\t     GET_MODE (op1));\n       op1 = SUBREG_REG (op1);\n       code1 = GET_CODE (op1);\n     }\n@@ -2262,11 +2274,11 @@ mips_move_2words (operands, insn)\n \n   if (code0 == REG)\n     {\n-      int regno0 = REGNO (op0) + subreg_word0;\n+      int regno0 = REGNO (op0) + subreg_offset0;\n \n       if (code1 == REG)\n \t{\n-\t  int regno1 = REGNO (op1) + subreg_word1;\n+\t  int regno1 = REGNO (op1) + subreg_offset1;\n \n \t  /* Just in case, don't do anything for assigning a register\n \t     to itself, unless we are filling a delay slot.  */\n@@ -2603,7 +2615,7 @@ mips_move_2words (operands, insn)\n     {\n       if (code1 == REG)\n \t{\n-\t  int regno1 = REGNO (op1) + subreg_word1;\n+\t  int regno1 = REGNO (op1) + subreg_offset1;\n \n \t  if (FP_REG_P (regno1))\n \t    ret = \"s.d\\t%1,%0\";\n@@ -7888,7 +7900,10 @@ mips_secondary_reload_class (class, mode, x, in_p)\n \t{\n \t  while (GET_CODE (x) == SUBREG)\n \t    {\n-\t      off += SUBREG_WORD (x);\n+\t      off += subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+\t\t\t\t\t  GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t\t  SUBREG_BYTE (x),\n+\t\t\t\t\t  GET_MODE (x));\n \t      x = SUBREG_REG (x);\n \t    }\n "}, {"sha": "d7c421327d6ba2fb65af77a943aae4df5345bccc", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -790,12 +790,12 @@\n \t(ltu:SI (subreg:SI (match_dup 0) 0)\n \t\t(subreg:SI (match_dup 2) 0)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(plus:SI (subreg:SI (match_dup 1) 1)\n-\t\t (subreg:SI (match_dup 2) 1)))\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(plus:SI (subreg:SI (match_dup 1) 4)\n+\t\t (subreg:SI (match_dup 2) 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(plus:SI (subreg:SI (match_dup 0) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(plus:SI (subreg:SI (match_dup 0) 4)\n \t\t (match_dup 3)))]\n   \"\")\n \n@@ -812,13 +812,13 @@\n    && (REGNO (operands[0]) != REGNO (operands[1])\n        || REGNO (operands[0]) != REGNO (operands[2]))\"\n \n-  [(set (subreg:SI (match_dup 0) 1)\n-\t(plus:SI (subreg:SI (match_dup 1) 1)\n-\t\t (subreg:SI (match_dup 2) 1)))\n+  [(set (subreg:SI (match_dup 0) 4)\n+\t(plus:SI (subreg:SI (match_dup 1) 4)\n+\t\t (subreg:SI (match_dup 2) 4)))\n \n    (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 1)\n-\t\t(subreg:SI (match_dup 2) 1)))\n+\t(ltu:SI (subreg:SI (match_dup 0) 4)\n+\t\t(subreg:SI (match_dup 2) 4)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(plus:SI (subreg:SI (match_dup 1) 0)\n@@ -865,8 +865,8 @@\n \t(ltu:SI (subreg:SI (match_dup 0) 0)\n \t\t(match_dup 2)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(plus:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(plus:SI (subreg:SI (match_dup 1) 4)\n \t\t (match_dup 3)))]\n   \"\")\n \n@@ -881,12 +881,12 @@\n    && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\n    && INTVAL (operands[2]) > 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1)\n-\t(plus:SI (subreg:SI (match_dup 1) 1)\n+  [(set (subreg:SI (match_dup 0) 4)\n+\t(plus:SI (subreg:SI (match_dup 1) 4)\n \t\t (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 0) 1)\n+\t(ltu:SI (subreg:SI (match_dup 0) 4)\n \t\t(match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -1307,12 +1307,12 @@\n \t(minus:SI (subreg:SI (match_dup 1) 0)\n \t\t  (subreg:SI (match_dup 2) 0)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(minus:SI (subreg:SI (match_dup 1) 1)\n-\t\t  (subreg:SI (match_dup 2) 1)))\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(minus:SI (subreg:SI (match_dup 1) 4)\n+\t\t  (subreg:SI (match_dup 2) 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(minus:SI (subreg:SI (match_dup 0) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(minus:SI (subreg:SI (match_dup 0) 4)\n \t\t  (match_dup 3)))]\n   \"\")\n \n@@ -1328,12 +1328,12 @@\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 1)\n-\t        (subreg:SI (match_dup 2) 1)))\n+\t(ltu:SI (subreg:SI (match_dup 1) 4)\n+\t        (subreg:SI (match_dup 2) 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(minus:SI (subreg:SI (match_dup 1) 1)\n-\t\t  (subreg:SI (match_dup 2) 1)))\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(minus:SI (subreg:SI (match_dup 1) 4)\n+\t\t  (subreg:SI (match_dup 2) 4)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(minus:SI (subreg:SI (match_dup 1) 0)\n@@ -1378,8 +1378,8 @@\n \t(minus:SI (subreg:SI (match_dup 1) 0)\n \t\t  (match_dup 2)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(minus:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(minus:SI (subreg:SI (match_dup 1) 4)\n \t\t  (match_dup 3)))]\n   \"\")\n \n@@ -1395,11 +1395,11 @@\n    && INTVAL (operands[2]) > 0\"\n \n   [(set (match_dup 3)\n-\t(ltu:SI (subreg:SI (match_dup 1) 1)\n+\t(ltu:SI (subreg:SI (match_dup 1) 4)\n \t\t(match_dup 2)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(minus:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(minus:SI (subreg:SI (match_dup 1) 4)\n \t\t  (match_dup 2)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -3121,7 +3121,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (not:SI (subreg:SI (match_dup 1) 0)))\n-   (set (subreg:SI (match_dup 0) 1) (not:SI (subreg:SI (match_dup 1) 1)))]\n+   (set (subreg:SI (match_dup 0) 4) (not:SI (subreg:SI (match_dup 1) 4)))]\n   \"\")\n \n \f\n@@ -3224,7 +3224,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (and:SI (subreg:SI (match_dup 1) 0) (subreg:SI (match_dup 2) 0)))\n-   (set (subreg:SI (match_dup 0) 1) (and:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n+   (set (subreg:SI (match_dup 0) 4) (and:SI (subreg:SI (match_dup 1) 4) (subreg:SI (match_dup 2) 4)))]\n   \"\")\n \n (define_insn \"anddi3_internal1\"\n@@ -3325,7 +3325,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (ior:SI (subreg:SI (match_dup 1) 0) (subreg:SI (match_dup 2) 0)))\n-   (set (subreg:SI (match_dup 0) 1) (ior:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n+   (set (subreg:SI (match_dup 0) 4) (ior:SI (subreg:SI (match_dup 1) 4) (subreg:SI (match_dup 2) 4)))]\n   \"\")\n \n (define_expand \"xorsi3\"\n@@ -3429,7 +3429,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (xor:SI (subreg:SI (match_dup 1) 0) (subreg:SI (match_dup 2) 0)))\n-   (set (subreg:SI (match_dup 0) 1) (xor:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n+   (set (subreg:SI (match_dup 0) 4) (xor:SI (subreg:SI (match_dup 1) 4) (subreg:SI (match_dup 2) 4)))]\n   \"\")\n \n (define_insn \"xordi3_immed\"\n@@ -3478,7 +3478,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[2]) == REG && GP_REG_P (REGNO (operands[2]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (and:SI (not:SI (subreg:SI (match_dup 1) 0)) (not:SI (subreg:SI (match_dup 2) 0))))\n-   (set (subreg:SI (match_dup 0) 1) (and:SI (not:SI (subreg:SI (match_dup 1) 1)) (not:SI (subreg:SI (match_dup 2) 1))))]\n+   (set (subreg:SI (match_dup 0) 4) (and:SI (not:SI (subreg:SI (match_dup 1) 4)) (not:SI (subreg:SI (match_dup 2) 4))))]\n   \"\")\n \f\n ;;\n@@ -4917,7 +4917,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n \n   [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n-   (set (subreg:SI (match_dup 0) 1) (subreg:SI (match_dup 1) 1))]\n+   (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n   \"\")\n \n (define_insn \"movdi_internal2\"\n@@ -6147,7 +6147,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[0]) == REG && GP_REG_P (REGNO (operands[0]))\n    && GET_CODE (operands[1]) == REG && GP_REG_P (REGNO (operands[1]))\"\n   [(set (subreg:SI (match_dup 0) 0) (subreg:SI (match_dup 1) 0))\n-   (set (subreg:SI (match_dup 0) 1) (subreg:SI (match_dup 1) 1))]\n+   (set (subreg:SI (match_dup 0) 4) (subreg:SI (match_dup 1) 4))]\n   \"\")\n \n ;; Instructions to load the global pointer register.\n@@ -6516,7 +6516,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1) (ashift:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n+  [(set (subreg:SI (match_dup 0) 4) (ashift:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n@@ -6533,8 +6533,8 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 0) (ashift:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 1) (const_int 0))]\n+  [(set (subreg:SI (match_dup 0) 0) (ashift:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n+   (set (subreg:SI (match_dup 0) 4) (const_int 0))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n \n@@ -6574,16 +6574,16 @@ move\\\\t%0,%z4\\\\n\\\\\n    && (INTVAL (operands[2]) & 63) < 32\n    && (INTVAL (operands[2]) & 63) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1)\n-\t(ashift:SI (subreg:SI (match_dup 1) 1)\n+  [(set (subreg:SI (match_dup 0) 4)\n+\t(ashift:SI (subreg:SI (match_dup 1) 4)\n \t\t   (match_dup 2)))\n \n    (set (match_dup 3)\n \t(lshiftrt:SI (subreg:SI (match_dup 1) 0)\n \t\t     (match_dup 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(ior:SI (subreg:SI (match_dup 0) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(ior:SI (subreg:SI (match_dup 0) 4)\n \t\t(match_dup 3)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -6614,15 +6614,15 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t   (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 1)\n+\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n \t\t     (match_dup 4)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(ior:SI (subreg:SI (match_dup 0) 0)\n \t\t(match_dup 3)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(ashift:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(ashift:SI (subreg:SI (match_dup 1) 4)\n \t\t   (match_dup 2)))]\n   \"\n {\n@@ -6871,8 +6871,8 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 1) (ashiftrt:SI (subreg:SI (match_dup 1) 1) (const_int 31)))]\n+  [(set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n+   (set (subreg:SI (match_dup 0) 4) (ashiftrt:SI (subreg:SI (match_dup 1) 4) (const_int 31)))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n \n@@ -6887,7 +6887,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n+  [(set (subreg:SI (match_dup 0) 4) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (const_int 31)))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n@@ -6932,15 +6932,15 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t     (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 1)\n+\t(ashift:SI (subreg:SI (match_dup 1) 4)\n \t\t   (match_dup 4)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(ior:SI (subreg:SI (match_dup 0) 0)\n \t\t(match_dup 3)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(ashiftrt:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(ashiftrt:SI (subreg:SI (match_dup 1) 4)\n \t\t     (match_dup 2)))]\n   \"\n {\n@@ -6962,16 +6962,16 @@ move\\\\t%0,%z4\\\\n\\\\\n    && (INTVAL (operands[2]) & 63) < 32\n    && (INTVAL (operands[2]) & 63) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 1)\n+  [(set (subreg:SI (match_dup 0) 4)\n+\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n \t\t     (match_dup 2)))\n \n    (set (match_dup 3)\n \t(ashift:SI (subreg:SI (match_dup 1) 0)\n \t\t   (match_dup 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(ior:SI (subreg:SI (match_dup 0) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(ior:SI (subreg:SI (match_dup 0) 4)\n \t\t(match_dup 3)))\n \n    (set (subreg:SI (match_dup 0) 0)\n@@ -7255,8 +7255,8 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 0) (lshiftrt:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n-   (set (subreg:SI (match_dup 0) 1) (const_int 0))]\n+  [(set (subreg:SI (match_dup 0) 0) (lshiftrt:SI (subreg:SI (match_dup 1) 4) (match_dup 2)))\n+   (set (subreg:SI (match_dup 0) 4) (const_int 0))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n \n@@ -7272,7 +7272,7 @@ move\\\\t%0,%z4\\\\n\\\\\n    && GET_CODE (operands[1]) == REG && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n    && (INTVAL (operands[2]) & 32) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1) (lshiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n+  [(set (subreg:SI (match_dup 0) 4) (lshiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n \n   \"operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\")\n@@ -7317,15 +7317,15 @@ move\\\\t%0,%z4\\\\n\\\\\n \t\t     (match_dup 2)))\n \n    (set (match_dup 3)\n-\t(ashift:SI (subreg:SI (match_dup 1) 1)\n+\t(ashift:SI (subreg:SI (match_dup 1) 4)\n \t\t   (match_dup 4)))\n \n    (set (subreg:SI (match_dup 0) 0)\n \t(ior:SI (subreg:SI (match_dup 0) 0)\n \t\t(match_dup 3)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n \t\t     (match_dup 2)))]\n   \"\n {\n@@ -7347,16 +7347,16 @@ move\\\\t%0,%z4\\\\n\\\\\n    && (INTVAL (operands[2]) & 63) < 32\n    && (INTVAL (operands[2]) & 63) != 0\"\n \n-  [(set (subreg:SI (match_dup 0) 1)\n-\t(lshiftrt:SI (subreg:SI (match_dup 1) 1)\n+  [(set (subreg:SI (match_dup 0) 4)\n+\t(lshiftrt:SI (subreg:SI (match_dup 1) 4)\n \t\t     (match_dup 2)))\n \n    (set (match_dup 3)\n \t(ashift:SI (subreg:SI (match_dup 1) 0)\n \t\t   (match_dup 4)))\n \n-   (set (subreg:SI (match_dup 0) 1)\n-\t(ior:SI (subreg:SI (match_dup 0) 1)\n+   (set (subreg:SI (match_dup 0) 4)\n+\t(ior:SI (subreg:SI (match_dup 0) 4)\n \t\t(match_dup 3)))\n \n    (set (subreg:SI (match_dup 0) 0)"}, {"sha": "1a4f9dd0f030826eb7d8c4d92152160b637ba10a", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -162,8 +162,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n \t    break;\n \n \t  case CONST_DOUBLE:\n@@ -222,8 +221,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)] + 1);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x) + 1]);\n \t    break;\n \n \t  case CONST_DOUBLE:\n@@ -322,8 +320,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n \t    break;\n \n \t  case CONST_INT:"}, {"sha": "7f1c0363587b997b1e0c8c786929ed9635cb6c40", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -143,8 +143,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n \t    break;\n \n \t  case CONST_DOUBLE:\n@@ -204,8 +203,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)] + 1);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x) + 1]);\n \t    break;\n \n \t  case CONST_DOUBLE:\n@@ -289,8 +287,7 @@ print_operand (file, x, code)\n \t    break;\n \n \t  case SUBREG:\n-\t    fprintf (file, \"%s\",\n-\t\t     reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)]);\n+\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n \t    break;\n \n \t  /* This will only be single precision....  */"}, {"sha": "f7646d391d61910e3f146ceaeabbd264f2a30871", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1275,7 +1275,7 @@\n ;; Retain this insn which *does* have a pattern indicating what it does,\n ;; just in case the compiler is smart enough to recognize a substitution.\n (define_insn \"udivmoddisi4\"\n-  [(set (subreg:SI (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\") 1)\n+  [(set (subreg:SI (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\") 4)\n \t(truncate:SI (udiv:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n \t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))))\n    (set (subreg:SI (match_operand:DI 3 \"nonimmediate_operand\" \"=0\") 0)\n@@ -1338,7 +1338,7 @@\n   \"deiw %2,%0\")\n \n (define_insn \"udivmoddihi4\"\n-  [(set (subreg:HI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+  [(set (subreg:HI (match_operand:DI 0 \"register_operand\" \"=r\") 2)\n \t(truncate:HI (udiv:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t (zero_extend:DI (match_operand:HI 2 \"nonimmediate_operand\" \"rm\")))))\n    (set (subreg:HI (match_operand:DI 3 \"register_operand\" \"=0\") 0)"}, {"sha": "502d204e74da2e964bb313b22c0deff106b70dab", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1192,11 +1192,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t   && GET_CODE (SUBREG_REG (operand0)) == REG\n \t   && REGNO (SUBREG_REG (operand0)) >= FIRST_PSEUDO_REGISTER)\n     {\n-     /* We must not alter SUBREG_WORD (operand0) since that would confuse\n+     /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand0),\n \t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand0))],\n-\t\t\t\t SUBREG_WORD (operand0));\n+\t\t\t\t SUBREG_BYTE (operand0));\n       operand0 = alter_subreg (temp);\n     }\n \n@@ -1209,11 +1209,11 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t   && GET_CODE (SUBREG_REG (operand1)) == REG\n \t   && REGNO (SUBREG_REG (operand1)) >= FIRST_PSEUDO_REGISTER)\n     {\n-     /* We must not alter SUBREG_WORD (operand0) since that would confuse\n+     /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n \tthe code which tracks sets/uses for delete_output_reload.  */\n       rtx temp = gen_rtx_SUBREG (GET_MODE (operand1),\n \t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand1))],\n-\t\t\t\t SUBREG_WORD (operand1));\n+\t\t\t\t SUBREG_BYTE (operand1));\n       operand1 = alter_subreg (temp);\n     }\n "}, {"sha": "baeef934243f365a56173749f28e550d2b9b15c8", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -3505,9 +3505,9 @@\n    (set_attr \"length\" \"4\")])\n \n (define_expand \"floatunssisf2\"\n-  [(set (subreg:SI (match_dup 2) 1)\n+  [(set (subreg:SI (match_dup 2) 4)\n \t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (subreg:SI (match_dup 2) 0)\n+   (set (subreg:SI (match_dup 2) 4)\n \t(const_int 0))\n    (set (match_operand:SF 0 \"register_operand\" \"\")\n \t(float:SF (match_dup 2)))]\n@@ -3523,7 +3523,7 @@\n }\")\n \n (define_expand \"floatunssidf2\"\n-  [(set (subreg:SI (match_dup 2) 1)\n+  [(set (subreg:SI (match_dup 2) 4)\n \t(match_operand:SI 1 \"register_operand\" \"\"))\n    (set (subreg:SI (match_dup 2) 0)\n \t(const_int 0))\n@@ -3891,7 +3891,7 @@\n \t  \n \t}\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t      gen_rtx_SUBREG (SImode, scratch, 1)));\n+\t\t\t      gen_rtx_SUBREG (SImode, scratch, GET_MODE_SIZE (SImode))));\n       DONE;\n     }\n   operands[3] = gen_reg_rtx (SImode);"}, {"sha": "7fc7f8dc2818fe4f3672d4b5d5bbc04d06b7a847", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -766,7 +766,7 @@\n (define_expand \"zero_extendhisi2\"\n   [(set (subreg:HI \n           (match_dup 0)\n-          1)\n+          2)\n         (match_operand:HI 1 \"register_operand\" \"r\"))\n    (set (subreg:HI \n           (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1782,16 +1782,16 @@\n   [(set_attr \"length\" \"2\")])\n \n (define_expand \"modhi3\"\n-  [(set (subreg:HI (match_dup 1) 1)\n+  [(set (subreg:HI (match_dup 1) 2)\n \t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"g\")))\n    (set (match_operand:HI 0 \"general_operand\" \"=r\")\n-        (subreg:HI (match_dup 1) 1))]\n+        (subreg:HI (match_dup 1) 2))]\n   \"TARGET_45\"\n   \"\")\n \n (define_insn \"\"\n-  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 1)\n+  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 4)\n \t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"TARGET_45\"\n@@ -1802,11 +1802,11 @@\n ;  [(parallel [(set (subreg:HI (match_dup 1) 0)\n ;\t           (div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n ;\t\t           (match_operand:HI 2 \"general_operand\" \"g\")))\n-;              (set (subreg:HI (match_dup 1) 1)\n+;              (set (subreg:HI (match_dup 1) 2)\n ;\t           (mod:HI (match_dup 1)\n ;\t\t           (match_dup 2)))])\n ;   (set (match_operand:HI 3 \"general_operand\" \"=r\")\n-;        (subreg:HI (match_dup 1) 1))\n+;        (subreg:HI (match_dup 1) 2))\n ;   (set (match_operand:HI 0 \"general_operand\" \"=r\")\n ;        (subreg:HI (match_dup 1) 0))]\n ;  \"TARGET_45\"\n@@ -1816,7 +1816,7 @@\n ;  [(set (subreg:HI (match_operand:SI 0 \"general_operand\" \"=r\") 0)\n ;\t           (div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n ;\t\t           (match_operand:HI 2 \"general_operand\" \"g\")))\n-;   (set (subreg:HI (match_dup 0) 1)\n+;   (set (subreg:HI (match_dup 0) 2)\n ;\t           (mod:HI (match_dup 1)\n ;\t\t           (match_dup 2)))]\n ;  \"TARGET_45\""}, {"sha": "8cabb46e825cf57eb86964fb339b31b13652ef6e", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -269,12 +269,7 @@ memory_offset_in_range_p (op, mode, low, high)\n \n   while (GET_CODE (op) == SUBREG)\n     {\n-      offset += SUBREG_WORD (op) * UNITS_PER_WORD;\n-#if BYTES_BIG_ENDIAN\n-      offset -= (min (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n-\t\t - min (UNITS_PER_WORD,\n-\t\t\tGET_MODE_SIZE (GET_MODE (SUBREG_REG (op)))));\n-#endif\n+      offset += SUBREG_BYTE (op);\n       op = SUBREG_REG (op);\n     }\n "}, {"sha": "d8d4ef3581b497ec34724e824e0845d1cc72bba2", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -666,7 +666,7 @@ output_movedouble (insn, operands, mode)\n       if (GET_CODE (inside) == REG)\n \tptrreg = REGNO (inside);\n       else if (GET_CODE (inside) == SUBREG)\n-\tptrreg = REGNO (SUBREG_REG (inside)) + SUBREG_WORD (inside);\n+\tptrreg = subreg_regno (inside);\n       else if (GET_CODE (inside) == PLUS)\n \t{\n \t  ptrreg = REGNO (XEXP (inside, 0));\n@@ -1143,13 +1143,13 @@ gen_ashift_hi (type, n, reg)\n \t gen_ashift_hi is only called in contexts where we know that the\n \t sign extension works out correctly.  */\n       {\n-\tint word = 0;\n+\tint offset = 0;\n \tif (GET_CODE (reg) == SUBREG)\n \t  {\n-\t    word = SUBREG_WORD (reg);\n+\t    offset = SUBREG_BYTE (reg);\n \t    reg = SUBREG_REG (reg);\n \t  }\n-\tgen_ashift (type, n, gen_rtx_SUBREG (SImode, reg, word));\n+\tgen_ashift (type, n, gen_rtx_SUBREG (SImode, reg, offset));\n \tbreak;\n       }\n     case ASHIFT:\n@@ -2516,7 +2516,11 @@ regs_used (x, is_dest)\n \t  break;\n \tif (REGNO (y) < 16)\n \t  return (((1 << HARD_REGNO_NREGS (0, GET_MODE (x))) - 1)\n-\t\t  << (REGNO (y) + SUBREG_WORD (x) + is_dest));\n+\t\t  << (REGNO (y) +\n+\t\t      subreg_regno_offset (REGNO (y),\n+\t\t\t\t\t   GET_MODE (y),\n+\t\t\t\t\t   SUBREG_BYTE (x),\n+\t\t\t\t\t   GET_MODE (x)) + is_dest));\n \treturn 0;\n       }\n     case SET:\n@@ -3260,7 +3264,10 @@ machine_dependent_reorg (first)\n \t\t      mode = HImode;\n \t\t      while (GET_CODE (dst) == SUBREG)\n \t\t\t{\n-\t\t\t  offset += SUBREG_WORD (dst);\n+\t\t\t  offset += subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n+\t\t\t\t\t\t\t GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t\t\t\t SUBREG_BYTE (dst),\n+\t\t\t\t\t\t\t GET_MODE (dst));\n \t\t\t  dst = SUBREG_REG (dst);\n \t\t\t}\n \t\t      dst = gen_rtx_REG (HImode, REGNO (dst) + offset);"}, {"sha": "a71ba3cc79643374eb880eddd77e305103dfd856", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1401,7 +1401,7 @@ extern int current_function_anonymous_args;\n   ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n    || (GET_CODE (X) == SUBREG\t\t\t\t\\\n        && GET_CODE (SUBREG_REG (X)) == REG\t\t\\\n-       && SUBREG_OK_FOR_INDEX_P (SUBREG_REG (X), SUBREG_WORD (X))))\n+       && SUBREG_OK_FOR_INDEX_P (SUBREG_REG (X), SUBREG_BYTE (X))))\n \n /* Jump to LABEL if X is a valid address RTX.  This must also take\n    REG_OK_STRICT into account when deciding about valid registers, but it uses"}, {"sha": "420c33630a8ce2587a3bc0cccd94efe5b0759940", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2591,7 +2591,7 @@\n   if (GET_CODE (operands[0]) == REG)\n     regno = REGNO (operands[0]);\n   else if (GET_CODE (operands[0]) == SUBREG)\n-    regno = REGNO (SUBREG_REG (operands[0])) + SUBREG_WORD (operands[0]);\n+    regno = subreg_regno (operands[0]);\n   else if (GET_CODE (operands[0]) == MEM)\n     regno = -1;\n \n@@ -2729,7 +2729,7 @@\n       mem = operands[1];\n       store_p = 0;\n     }\n-  if (GET_CODE (mem) == SUBREG && SUBREG_WORD (mem) == 0)\n+  if (GET_CODE (mem) == SUBREG && SUBREG_BYTE (mem) == 0)\n     mem = SUBREG_REG (mem);\n   if (GET_CODE (mem) == MEM)\n     {\n@@ -2751,7 +2751,7 @@\n \t  mem = copy_rtx (mem);\n \t  PUT_MODE (mem, SImode);\n \t  word0 = alter_subreg (gen_rtx (SUBREG, SImode, regop, 0));\n-\t  word1 = alter_subreg (gen_rtx (SUBREG, SImode, regop, 1));\n+\t  word1 = alter_subreg (gen_rtx (SUBREG, SImode, regop, 4));\n \t  if (store_p || ! refers_to_regno_p (REGNO (word0),\n \t\t\t\t\t      REGNO (word0) + 1, addr, 0))\n \t    {\n@@ -2963,7 +2963,7 @@\n   if (GET_CODE (operands[0]) == REG)\n     regno = REGNO (operands[0]);\n   else if (GET_CODE (operands[0]) == SUBREG)\n-    regno = REGNO (SUBREG_REG (operands[0])) + SUBREG_WORD (operands[0]);\n+    regno = subreg_regno (operands[0]);\n   else if (GET_CODE (operands[0]) == MEM)\n     regno = -1;\n "}, {"sha": "782d2a725d346bf9bc8b6f2780514627a990c82d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -7494,8 +7494,8 @@ ultra_find_type (type_mask, list, start)\n \t\t\t\t  && GET_CODE (SET_SRC (pat)) == SUBREG\n \t\t\t\t  && REGNO (SUBREG_REG (SET_DEST (slot_pat))) ==\n \t\t\t\t       REGNO (SUBREG_REG (SET_SRC (pat)))\n-\t\t\t\t  && SUBREG_WORD (SET_DEST (slot_pat)) ==\n-\t\t\t\t       SUBREG_WORD (SET_SRC (pat)))))\n+\t\t\t\t  && SUBREG_BYTE (SET_DEST (slot_pat)) ==\n+\t\t\t\t       SUBREG_BYTE (SET_SRC (pat)))))\n \t\t      || (check_fpmode_conflict == 1\n \t\t\t  && GET_CODE (slot_insn) == INSN\n \t\t\t  && GET_CODE (slot_pat) == SET"}, {"sha": "d65908eb35373c0008cf6a1eb9d14fa496aff716", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1146,25 +1146,34 @@ while (0)\n        : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* A subreg in 64 bit mode will have the wrong offset for a floating point\n-   register.  The least significant part is at offset 1, compared to 0 for\n-   integer registers.  This only applies when FMODE is a larger mode.\n-   We also need to handle a special case of TF-->DF conversions.  */\n-#define ALTER_HARD_SUBREG(TMODE, WORD, FMODE, REGNO)\t\t\t\\\n-     (TARGET_ARCH64\t\t\t\t\t\t\t\\\n-      && (REGNO) >= SPARC_FIRST_FP_REG\t\t\t\t\t\\\n-      && (REGNO) <= SPARC_LAST_V9_FP_REG\t\t\t\t\\\n-      && (TMODE) == SImode\t\t\t\t\t\t\\\n-      && !((FMODE) == QImode || (FMODE) == HImode)\t\t\t\\\n-      ? ((REGNO) + 1)\t\t\t\t\t\t\t\\\n-      : ((TMODE) == DFmode && (FMODE) == TFmode)\t\t\t\\\n-        ? ((REGNO) + ((WORD) * 2))\t\t\t\t\t\\\n-        : ((REGNO) + (WORD)))\n+/* Due to the ARCH64 descrepancy above we must override these\n+   next two macros too.  */\n+#define REG_SIZE(R) \\\n+  (TARGET_ARCH64\t\t\t\t\t\t\t\\\n+   && ((GET_CODE (R) == REG\t\t\t\t\t\t\\\n+        && ((REGNO (R) >= FIRST_PSEUDO_REGISTER\t\t\t\t\\\n+\t     && FLOAT_MODE_P (GET_MODE (R)))\t\t\t\t\\\n+\t    || (REGNO (R) < FIRST_PSEUDO_REGISTER\t\t\t\\\n+\t\t&& REGNO (R) >= 32)))\t\t\t\t\t\\\n+       || (GET_CODE (R) == SUBREG\t\t\t\t\t\\\n+\t   && ((REGNO (SUBREG_REG (R)) >= FIRST_PSEUDO_REGISTER\t\t\\\n+\t     && FLOAT_MODE_P (GET_MODE (SUBREG_REG (R))))\t\t\\\n+\t    || (REGNO (SUBREG_REG (R)) < FIRST_PSEUDO_REGISTER\t\t\\\n+\t\t&& REGNO (SUBREG_REG (R)) >= 32))))\t\t\t\\\n+   ? (GET_MODE_SIZE (GET_MODE (R)) + 3) / 4\t\t\t\t\\\n+   : (GET_MODE_SIZE (GET_MODE (R)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+#define REGMODE_NATURAL_SIZE(MODE) \\\n+  ((TARGET_ARCH64 && FLOAT_MODE_P (MODE)) ? 4 : UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    See sparc.c for how we initialize this.  */\n extern int *hard_regno_mode_classes;\n extern int sparc_mode_class[];\n+\n+/* ??? Because of the funny way we pass parameters we should allow certain\n+   ??? types of float/complex values to be in integer registers during\n+   ??? RTL generation.  This only matters on arch32.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((hard_regno_mode_classes[REGNO] & sparc_mode_class[MODE]) != 0)\n "}, {"sha": "cf7ae09819652b3d1de4652a09b27f33ffaba424", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -4546,15 +4546,17 @@\n {\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift_16 = GEN_INT (16);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (SImode);\n+      op1_subbyte *= GET_MODE_SIZE (SImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subbyte),\n \t\t\t  shift_16));\n   emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n   DONE;\n@@ -4624,15 +4626,17 @@\n {\n   rtx temp = gen_reg_rtx (DImode);\n   rtx shift_48 = GEN_INT (48);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (DImode);\n+      op1_subbyte *= GET_MODE_SIZE (DImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subbyte),\n \t\t\t  shift_48));\n   emit_insn (gen_lshrdi3 (operand0, temp, shift_48));\n   DONE;\n@@ -4794,7 +4798,7 @@\n \n (define_insn \"*cmp_siqi_trunc\"\n   [(set (reg:CC 100)\n-\t(compare:CC (subreg:QI (match_operand:SI 0 \"register_operand\" \"r\") 0)\n+\t(compare:CC (subreg:QI (match_operand:SI 0 \"register_operand\" \"r\") 3)\n \t\t    (const_int 0)))]\n   \"\"\n   \"andcc\\\\t%0, 0xff, %%g0\"\n@@ -4803,18 +4807,18 @@\n \n (define_insn \"*cmp_siqi_trunc_set\"\n   [(set (reg:CC 100)\n-\t(compare:CC (subreg:QI (match_operand:SI 1 \"register_operand\" \"r\") 0)\n+\t(compare:CC (subreg:QI (match_operand:SI 1 \"register_operand\" \"r\") 3)\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(subreg:QI (match_dup 1) 0))]\n+\t(subreg:QI (match_dup 1) 3))]\n   \"\"\n   \"andcc\\\\t%1, 0xff, %0\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*cmp_diqi_trunc\"\n   [(set (reg:CC 100)\n-\t(compare:CC (subreg:QI (match_operand:DI 0 \"register_operand\" \"r\") 0)\n+\t(compare:CC (subreg:QI (match_operand:DI 0 \"register_operand\" \"r\") 7)\n \t\t    (const_int 0)))]\n   \"TARGET_ARCH64\"\n   \"andcc\\\\t%0, 0xff, %%g0\"\n@@ -4823,10 +4827,10 @@\n \n (define_insn \"*cmp_diqi_trunc_set\"\n   [(set (reg:CC 100)\n-\t(compare:CC (subreg:QI (match_operand:DI 1 \"register_operand\" \"r\") 0)\n+\t(compare:CC (subreg:QI (match_operand:DI 1 \"register_operand\" \"r\") 7)\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(subreg:QI (match_dup 1) 0))]\n+\t(subreg:QI (match_dup 1) 7))]\n   \"TARGET_ARCH64\"\n   \"andcc\\\\t%1, 0xff, %0\"\n   [(set_attr \"type\" \"compare\")\n@@ -4846,15 +4850,17 @@\n {\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift_16 = GEN_INT (16);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (SImode);\n+      op1_subbyte *= GET_MODE_SIZE (SImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subbyte),\n \t\t\t  shift_16));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n   DONE;\n@@ -4876,23 +4882,27 @@\n {\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift_24 = GEN_INT (24);\n-  int op1_subword = 0;\n-  int op0_subword = 0;\n+  int op1_subbyte = 0;\n+  int op0_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (SImode);\n+      op1_subbyte *= GET_MODE_SIZE (SImode);\n       operand1 = XEXP (operand1, 0);\n     }\n   if (GET_CODE (operand0) == SUBREG)\n     {\n-      op0_subword = SUBREG_WORD (operand0);\n+      op0_subbyte = SUBREG_BYTE (operand0);\n+      op0_subbyte /= GET_MODE_SIZE (SImode);\n+      op0_subbyte *= GET_MODE_SIZE (SImode);\n       operand0 = XEXP (operand0, 0);\n     }\n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subbyte),\n \t\t\t  shift_24));\n   if (GET_MODE (operand0) != SImode)\n-    operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subword);\n+    operand0 = gen_rtx_SUBREG (SImode, operand0, op0_subbyte);\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n   DONE;\n }\")\n@@ -4913,15 +4923,17 @@\n {\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift_24 = GEN_INT (24);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (SImode);\n+      op1_subbyte *= GET_MODE_SIZE (SImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subword),\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1, op1_subbyte),\n \t\t\t  shift_24));\n   emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n   DONE;\n@@ -4943,15 +4955,17 @@\n {\n   rtx temp = gen_reg_rtx (DImode);\n   rtx shift_56 = GEN_INT (56);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (DImode);\n+      op1_subbyte *= GET_MODE_SIZE (DImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subbyte),\n \t\t\t  shift_56));\n   emit_insn (gen_ashrdi3 (operand0, temp, shift_56));\n   DONE;\n@@ -4973,15 +4987,17 @@\n {\n   rtx temp = gen_reg_rtx (DImode);\n   rtx shift_48 = GEN_INT (48);\n-  int op1_subword = 0;\n+  int op1_subbyte = 0;\n \n   if (GET_CODE (operand1) == SUBREG)\n     {\n-      op1_subword = SUBREG_WORD (operand1);\n+      op1_subbyte = SUBREG_BYTE (operand1);\n+      op1_subbyte /= GET_MODE_SIZE (DImode);\n+      op1_subbyte *= GET_MODE_SIZE (DImode);\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subword),\n+  emit_insn (gen_ashldi3 (temp, gen_rtx_SUBREG (DImode, operand1, op1_subbyte),\n \t\t\t  shift_48));\n   emit_insn (gen_ashrdi3 (operand0, temp, shift_48));\n   DONE;\n@@ -6275,7 +6291,7 @@\n \t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n \t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n \t  (match_operand:SI 3 \"const_int_operand\" \"i,i\"))\n-\t 1))\n+\t 4))\n    (clobber (match_scratch:SI 4 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n   \"@\n@@ -8346,7 +8362,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:SI (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (const_int 32)) 0)\n+\t\t\t\t\t     (const_int 32)) 4)\n \t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")))]\n   \"TARGET_ARCH64\n    && ((GET_CODE (operands[2]) == CONST_INT\n@@ -8366,7 +8382,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (const_int 32)) 0)\n+\t\t\t\t\t     (const_int 32)) 4)\n \t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")))]\n   \"TARGET_ARCH64\n    && ((GET_CODE (operands[2]) == CONST_INT\n@@ -8386,7 +8402,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ashiftrt:SI (subreg:SI (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 0)\n+\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 4)\n \t\t     (match_operand:SI 3 \"small_int_or_double\" \"n\")))]\n   \"TARGET_ARCH64\n    && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[3]) == CONST_INT\n@@ -8405,7 +8421,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:SI (subreg:SI (lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 0)\n+\t\t\t\t\t     (match_operand:SI 2 \"small_int_or_double\" \"n\")) 4)\n \t\t     (match_operand:SI 3 \"small_int_or_double\" \"n\")))]\n   \"TARGET_ARCH64\n    && GET_CODE (operands[2]) == CONST_INT && GET_CODE (operands[3]) == CONST_INT"}, {"sha": "a074d953604c1e443a71a7a4d9aa7fa1fd891c97", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -541,7 +541,7 @@ print_operand (file, x, code)\n \t  fputs (reg_names[REGNO (x)], file);\n \t  break;\n \tcase SUBREG:\n-\t  fputs (reg_names[REGNO (SUBREG_REG (x)) + SUBREG_WORD (x)], file);\n+\t  fputs (reg_names[subreg_regno (x)], file);\n \t  break;\n \tcase CONST_INT:\n \tcase SYMBOL_REF:\n@@ -823,7 +823,7 @@ output_move_double (operands)\n       if (GET_CODE (inside) == REG)\n  \tptrreg = REGNO (inside);\n       else if (GET_CODE (inside) == SUBREG)\n-\tptrreg = REGNO (SUBREG_REG (inside)) + SUBREG_WORD (inside);\n+\tptrreg = subreg_regno (inside);\n       else if (GET_CODE (inside) == PLUS)\n \tptrreg = REGNO (XEXP (inside, 0));\n       else if (GET_CODE (inside) == LO_SUM)"}, {"sha": "2b487510eae630648fba747120652358cb074110", "filename": "gcc/cse.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1220,11 +1220,11 @@ mention_regs (x)\n \t  /* If reg_tick has been incremented more than once since\n \t     reg_in_table was last set, that means that the entire\n \t     register has been set before, so discard anything memorized\n-\t     for the entrire register, including all SUBREG expressions.  */\n+\t     for the entire register, including all SUBREG expressions.  */\n \t  if (REG_IN_TABLE (i) != REG_TICK (i) - 1)\n \t    remove_invalid_refs (i);\n \t  else\n-\t    remove_invalid_subreg_refs (i, SUBREG_WORD (x), GET_MODE (x));\n+\t    remove_invalid_subreg_refs (i, SUBREG_BYTE (x), GET_MODE (x));\n \t}\n \n       REG_IN_TABLE (i) = REG_TICK (i);\n@@ -2004,32 +2004,31 @@ remove_invalid_refs (regno)\n       }\n }\n \n-/* Likewise for a subreg with subreg_reg WORD and mode MODE.  */\n+/* Likewise for a subreg with subreg_reg REGNO, subreg_byte OFFSET,\n+   and mode MODE.  */\n static void\n-remove_invalid_subreg_refs (regno, word, mode)\n+remove_invalid_subreg_refs (regno, offset, mode)\n      unsigned int regno;\n-     unsigned int word;\n+     unsigned int offset;\n      enum machine_mode mode;\n {\n   unsigned int i;\n   struct table_elt *p, *next;\n-  unsigned int end = word + (GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD;\n+  unsigned int end = offset + (GET_MODE_SIZE (mode) - 1);\n \n   for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n       {\n-\trtx exp;\n+\trtx exp = p->exp;\n \tnext = p->next_same_hash;\n \n-\texp = p->exp;\n-\tif (GET_CODE (p->exp) != REG\n+\tif (GET_CODE (exp) != REG\n \t    && (GET_CODE (exp) != SUBREG\n \t\t|| GET_CODE (SUBREG_REG (exp)) != REG\n \t\t|| REGNO (SUBREG_REG (exp)) != regno\n-\t\t|| (((SUBREG_WORD (exp)\n-\t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1) / UNITS_PER_WORD)\n-\t\t     >= word)\n-\t\t    && SUBREG_WORD (exp) <= end))\n+\t\t|| (((SUBREG_BYTE (exp)\n+\t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1)) >= offset)\n+\t\t    && SUBREG_BYTE (exp) <= end))\n \t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n \t  remove_from_table (p, i);\n       }\n@@ -2302,7 +2301,8 @@ canon_hash (x, mode)\n \tif (GET_CODE (SUBREG_REG (x)) == REG)\n \t  {\n \t    hash += (((unsigned) SUBREG << 7)\n-\t\t     + REGNO (SUBREG_REG (x)) + SUBREG_WORD (x));\n+\t\t     + REGNO (SUBREG_REG (x))\n+\t\t     + (SUBREG_BYTE (x) / UNITS_PER_WORD));\n \t    return hash;\n \t  }\n \tbreak;\n@@ -3413,7 +3413,8 @@ fold_rtx (x, insn)\n \t  if (GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n \t      && GET_MODE (SUBREG_REG (x)) != VOIDmode)\n-\t    new = operand_subword (folded_arg0, SUBREG_WORD (x), 0,\n+\t    new = operand_subword (folded_arg0,\n+\t\t\t\t   (SUBREG_BYTE (x) / UNITS_PER_WORD), 0,\n \t\t\t\t   GET_MODE (SUBREG_REG (x)));\n \t  if (new == 0 && subreg_lowpart_p (x))\n \t    new = gen_lowpart_if_possible (mode, folded_arg0);\n@@ -4393,10 +4394,12 @@ gen_lowpart_if_possible (mode, x)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n \t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n       if (BYTES_BIG_ENDIAN)\n-\t/* Adjust the address so that the address-after-the-data is\n-\t   unchanged.  */\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n+\t{\n+\t  /* Adjust the address so that the address-after-the-data is\n+\t     unchanged.  */\n+\t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n+\t}\n       new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n       if (! memory_address_p (mode, XEXP (new, 0)))\n \treturn 0;"}, {"sha": "207ba2a155dd5d64154dd2b07af2e38a3fec320e", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2024,20 +2024,15 @@ dbxout_symbol_location (decl, type, suffix, home)\n   else if (GET_CODE (home) == SUBREG)\n     {\n       rtx value = home;\n-      int offset = 0;\n+\n       while (GET_CODE (value) == SUBREG)\n-\t{\n-\t  offset += SUBREG_WORD (value);\n-\t  value = SUBREG_REG (value);\n-\t}\n+\tvalue = SUBREG_REG (value);\n       if (GET_CODE (value) == REG)\n \t{\n-\t  regno = REGNO (value);\n-\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t  if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t    return 0;\n-\t  regno += offset;\n \t}\n-      alter_subreg (home);\n+      regno = REGNO (alter_subreg (home));\n     }\n \n   /* The kind-of-variable letter depends on where"}, {"sha": "873d0b6d97e2598bf2dae2adf0137c457c47ee57", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -3494,7 +3494,7 @@ is_pseudo_reg (rtl)\n {\n   return ((GET_CODE (rtl) == REG && REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n \t  || (GET_CODE (rtl) == SUBREG\n-\t      && REGNO (XEXP (rtl, 0)) >= FIRST_PSEUDO_REGISTER));\n+\t      && REGNO (SUBREG_REG (rtl)) >= FIRST_PSEUDO_REGISTER));\n }\n \n /* Return a reference to a type, with its const and volatile qualifiers\n@@ -7038,7 +7038,7 @@ mem_loc_descriptor (rtl, mode)\n          up an entire register.  For now, just assume that it is\n          legitimate to make the Dwarf info refer to the whole register which\n          contains the given subreg.  */\n-      rtl = XEXP (rtl, 0);\n+      rtl = SUBREG_REG (rtl);\n \n       /* Fall through.  */\n \n@@ -7182,7 +7182,7 @@ loc_descriptor (rtl)\n          up an entire register.  For now, just assume that it is\n          legitimate to make the Dwarf info refer to the whole register which\n          contains the given subreg.  */\n-      rtl = XEXP (rtl, 0);\n+      rtl = SUBREG_REG (rtl);\n \n       /* Fall through.  */\n "}, {"sha": "80b06ae1754093b55b65f7b01d1a74b42ca30b33", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -817,7 +817,7 @@ is_pseudo_reg (rtl)\n {\n   return (((GET_CODE (rtl) == REG) && (REGNO (rtl) >= FIRST_PSEUDO_REGISTER))\n           || ((GET_CODE (rtl) == SUBREG)\n-\t      && (REGNO (XEXP (rtl, 0)) >= FIRST_PSEUDO_REGISTER)));\n+\t      && (REGNO (SUBREG_REG (rtl)) >= FIRST_PSEUDO_REGISTER)));\n }\n \n inline static tree\n@@ -1630,7 +1630,7 @@ output_mem_loc_descriptor (rtl)\n \t   legitimate to make the Dwarf info refer to the whole register\n \t   which contains the given subreg.  */\n \n-\trtl = XEXP (rtl, 0);\n+\trtl = SUBREG_REG (rtl);\n \t/* Drop thru.  */\n \n       case REG:\n@@ -1714,7 +1714,7 @@ output_loc_descriptor (rtl)\n \t   legitimate to make the Dwarf info refer to the whole register\n \t   which contains the given subreg.  */\n \n-\trtl = XEXP (rtl, 0);\n+\trtl = SUBREG_REG (rtl);\n \t/* Drop thru.  */\n \n     case REG:"}, {"sha": "7b715c6f69dd027f5e0361d3aa3355622b57560d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 365, "deletions": 235, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -348,6 +348,55 @@ gen_rtx_MEM (mode, addr)\n \n   return rt;\n }\n+\n+rtx\n+gen_rtx_SUBREG (mode, reg, offset)\n+     enum machine_mode mode;\n+     rtx reg;\n+     int offset;\n+{\n+  /* This is the most common failure type.\n+     Catch it early so we can see who does it.  */\n+  if ((offset % GET_MODE_SIZE (mode)) != 0)\n+    abort ();\n+\n+  /* This check isn't usable right now because combine will\n+     throw arbitrary crap like a CALL into a SUBREG in\n+     gen_lowpart_for_combine so we must just eat it.  */\n+#if 0\n+  /* Check for this too.  */\n+  if (offset >= GET_MODE_SIZE (GET_MODE (reg)))\n+    abort ();\n+#endif\n+  return gen_rtx_fmt_ei (SUBREG, mode, reg, offset);\n+}\n+\n+/* Generate a SUBREG representing the least-significant part\n+ * of REG if MODE is smaller than mode of REG, otherwise\n+ * paradoxical SUBREG. */\n+rtx\n+gen_lowpart_SUBREG (mode, reg)\n+     enum machine_mode mode;\n+     rtx reg;\n+{\n+  enum machine_mode inmode;\n+  int offset;\n+\n+  inmode = GET_MODE (reg);\n+  if (inmode == VOIDmode)\n+    inmode = mode;\n+  offset = 0;\n+  if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (inmode)\n+      && (WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN))\n+    {\n+      offset = GET_MODE_SIZE (inmode) - GET_MODE_SIZE (mode);\n+      if (! BYTES_BIG_ENDIAN)\n+\toffset = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      else if (! WORDS_BIG_ENDIAN)\n+\toffset %= UNITS_PER_WORD;\n+    }\n+  return gen_rtx_SUBREG (mode, reg, offset);\n+}\n \f\n /* rtx gen_rtx (code, mode, [element1, ..., elementn])\n **\n@@ -650,6 +699,38 @@ get_first_label_num ()\n   return first_label_num;\n }\n \f\n+/* Return the final regno of X, which is a SUBREG of a hard\n+   register.  */\n+int\n+subreg_hard_regno (x, check_mode)\n+     register rtx x;\n+     int check_mode;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  unsigned int byte_offset, base_regno, final_regno;\n+  rtx reg = SUBREG_REG (x);\n+\n+  /* This is where we attempt to catch illegal subregs\n+     created by the compiler.  */\n+  if (GET_CODE (x) != SUBREG\n+      || GET_CODE (reg) != REG)\n+    abort ();\n+  base_regno = REGNO (reg);\n+  if (base_regno >= FIRST_PSEUDO_REGISTER)\n+    abort ();\n+  if (! HARD_REGNO_MODE_OK (base_regno, GET_MODE (reg)))\n+    abort ();\n+\n+  /* Catch non-congruent offsets too.  */\n+  byte_offset = SUBREG_BYTE (x);\n+  if ((byte_offset % GET_MODE_SIZE (mode)) != 0)\n+    abort ();\n+\n+  final_regno = subreg_regno (x);\n+\n+  return final_regno;\n+}\n+\n /* Return a value representing some low-order bits of X, where the number\n    of low-order bits is given by MODE.  Note that no conversion is done\n    between floating-point and fixed-point values, rather, the bit \n@@ -666,22 +747,29 @@ gen_lowpart_common (mode, x)\n      enum machine_mode mode;\n      register rtx x;\n {\n-  int word = 0;\n+  int msize = GET_MODE_SIZE (mode);\n+  int xsize = GET_MODE_SIZE (GET_MODE (x));\n+  int offset = 0;\n \n   if (GET_MODE (x) == mode)\n     return x;\n \n   /* MODE must occupy no more words than the mode of X.  */\n   if (GET_MODE (x) != VOIDmode\n-      && ((GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n-\t  > ((GET_MODE_SIZE (GET_MODE (x)) + (UNITS_PER_WORD - 1))\n-\t     / UNITS_PER_WORD)))\n+      && ((msize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD\n+\t  > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n     return 0;\n \n-  if (WORDS_BIG_ENDIAN && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n-    word = ((GET_MODE_SIZE (GET_MODE (x))\n-\t     - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n-\t    / UNITS_PER_WORD);\n+  if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+      && xsize > msize)\n+    {\n+      int difference = xsize - msize;\n+\n+      if (WORDS_BIG_ENDIAN)\n+\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset += difference % UNITS_PER_WORD;\n+    }\n \n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)\n       && (GET_MODE_CLASS (mode) == MODE_INT\n@@ -703,39 +791,40 @@ gen_lowpart_common (mode, x)\n \treturn gen_rtx_fmt_e (GET_CODE (x), mode, XEXP (x, 0));\n     }\n   else if (GET_CODE (x) == SUBREG\n-\t   && (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t       || GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n+\t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || GET_MODE_SIZE (mode) == GET_MODE_UNIT_SIZE (GET_MODE (x))))\n-    return (GET_MODE (SUBREG_REG (x)) == mode && SUBREG_WORD (x) == 0\n-\t    ? SUBREG_REG (x)\n-\t    : gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + word));\n+    {\n+      int final_offset;\n+\n+      if (GET_MODE (SUBREG_REG (x)) == mode && subreg_lowpart_p (x))\n+\treturn SUBREG_REG (x);\n+\n+      /* When working with SUBREGs the rule is that the byte\n+\t offset must be a multiple of the SUBREG's mode.  */\n+      final_offset = SUBREG_BYTE (x) + offset;\n+      final_offset = (final_offset / GET_MODE_SIZE (mode));\n+      final_offset = (final_offset * GET_MODE_SIZE (mode));\n+      return gen_rtx_SUBREG (mode, SUBREG_REG (x), final_offset);   \n+    }\n   else if (GET_CODE (x) == REG)\n     {\n-      /* Let the backend decide how many registers to skip.  This is needed\n-         in particular for Sparc64 where fp regs are smaller than a word.  */\n-      /* ??? Note that subregs are now ambiguous, in that those against\n-\t pseudos are sized by the Word Size, while those against hard\n-\t regs are sized by the underlying register size.  Better would be\n-\t to always interpret the subreg offset parameter as bytes or bits.  */\n-\n-      if (WORDS_BIG_ENDIAN && REGNO (x) < FIRST_PSEUDO_REGISTER\n-\t  && GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n-\tword = (HARD_REGNO_NREGS (REGNO (x), GET_MODE (x))\n-\t\t- HARD_REGNO_NREGS (REGNO (x), mode));\n-\n-      /* If the register is not valid for MODE, return 0.  If we don't\n-\t do this, there is no way to fix up the resulting REG later.  \n-\t But we do do this if the current REG is not valid for its\n-\t mode.  This latter is a kludge, but is required due to the\n-\t way that parameters are passed on some machines, most\n-\t notably Sparc.  */\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER\n-\t  && ! HARD_REGNO_MODE_OK (REGNO (x) + word, mode)\n-\t  && HARD_REGNO_MODE_OK (REGNO (x), GET_MODE (x)))\n-\treturn 0;\n-      else if (REGNO (x) < FIRST_PSEUDO_REGISTER\n+      /* Hard registers are done specially in certain cases.  */  \n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+        {\n+\t  int final_regno = REGNO (x) +\n+\t\t\t    subreg_regno_offset (REGNO (x), GET_MODE (x), \n+\t\t\t\t\t\t offset, mode);\n+\n+\t  /* If the final regno is not valid for MODE, punt.  */\n+\t  /* ??? We do allow it if the current REG is not valid for\n+\t     ??? it's mode.  It is a kludge to work around how float/complex\n+\t     ??? arguments are passed on 32-bit Sparc and should be fixed.  */\n+\t  if (! HARD_REGNO_MODE_OK (final_regno, mode)\n+\t      && HARD_REGNO_MODE_OK (REGNO (x), GET_MODE (x)))\n+\t    return 0;\n+\n \t       /* integrate.c can't handle parts of a return value register. */\n-\t       && (! REG_FUNCTION_VALUE_P (x)\n+\t  if ((! REG_FUNCTION_VALUE_P (x)\n \t\t   || ! rtx_equal_function_value_matters)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n \t       && ! (CLASS_CANNOT_CHANGE_MODE_P (mode, GET_MODE (x))\n@@ -752,9 +841,9 @@ gen_lowpart_common (mode, x)\n \t       && x != arg_pointer_rtx\n #endif\n \t       && x != stack_pointer_rtx)\n-\treturn gen_rtx_REG (mode, REGNO (x) + word);\n-      else\n-\treturn gen_rtx_SUBREG (mode, x, word);\n+\t    return gen_rtx_REG (mode, final_regno);\n+\t  }\n+      return gen_rtx_SUBREG (mode, x, offset);\n     }\n   /* If X is a CONST_INT or a CONST_DOUBLE, extract the appropriate bits\n      from the low-order part of the constant.  */\n@@ -847,7 +936,7 @@ gen_lowpart_common (mode, x)\n \t   && GET_CODE (x) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n \t   && GET_MODE_BITSIZE (mode) == BITS_PER_WORD)\n-    return operand_subword (x, word, 0, GET_MODE (x));\n+    return constant_subword (x, (offset / UNITS_PER_WORD), GET_MODE (x));\n \n   /* Similarly, if this is converting a floating-point value into a\n      two-word integer, we can do this one word at a time and make an\n@@ -863,11 +952,14 @@ gen_lowpart_common (mode, x)\n \t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n \t   && GET_MODE_BITSIZE (mode) == 2 * BITS_PER_WORD)\n     {\n-      rtx lowpart\n-\t= operand_subword (x, word + WORDS_BIG_ENDIAN, 0, GET_MODE (x));\n-      rtx highpart\n-\t= operand_subword (x, word + ! WORDS_BIG_ENDIAN, 0, GET_MODE (x));\n-\n+      rtx lowpart, highpart;\n+\n+      lowpart = constant_subword (x,\n+\t\t\t\t  (offset / UNITS_PER_WORD) + WORDS_BIG_ENDIAN,\n+\t\t\t\t  GET_MODE (x));\n+      highpart = constant_subword (x,\n+\t\t\t\t   (offset / UNITS_PER_WORD) + (! WORDS_BIG_ENDIAN),\n+\t\t\t\t   GET_MODE (x));\n       if (lowpart && GET_CODE (lowpart) == CONST_INT\n \t  && highpart && GET_CODE (highpart) == CONST_INT)\n \treturn immed_double_const (INTVAL (lowpart), INTVAL (highpart), mode);\n@@ -1021,7 +1113,7 @@ gen_imagpart (mode, x)\n     return XEXP (x, 1);\n   else if (WORDS_BIG_ENDIAN)\n     return gen_lowpart (mode, x);\n-  else if (!WORDS_BIG_ENDIAN\n+  else if (! WORDS_BIG_ENDIAN\n \t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n \t   && REG_P (x)\n \t   && REGNO (x) < FIRST_PSEUDO_REGISTER)\n@@ -1043,7 +1135,7 @@ subreg_realpart_p (x)\n   if (GET_CODE (x) != SUBREG)\n     abort ();\n \n-  return ((unsigned int) SUBREG_WORD (x) * UNITS_PER_WORD\n+  return ((unsigned int) SUBREG_BYTE (x)\n \t  < GET_MODE_UNIT_SIZE (GET_MODE (SUBREG_REG (x))));\n }\n \f\n@@ -1101,10 +1193,13 @@ gen_highpart (mode, x)\n      enum machine_mode mode;\n      register rtx x;\n {\n+  unsigned int msize = GET_MODE_SIZE (mode);\n+  unsigned int xsize = GET_MODE_SIZE (GET_MODE (x));\n+\n   /* This case loses if X is a subreg.  To catch bugs early,\n      complain if an invalid MODE is used even in other cases.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && GET_MODE_SIZE (mode) != GET_MODE_UNIT_SIZE (GET_MODE (x)))\n+  if (msize > UNITS_PER_WORD\n+      && msize != GET_MODE_UNIT_SIZE (GET_MODE (x)))\n     abort ();\n   if (GET_CODE (x) == CONST_DOUBLE\n #if !(TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT || defined (REAL_IS_NOT_DOUBLE))\n@@ -1121,15 +1216,14 @@ gen_highpart (mode, x)\n   else if (GET_CODE (x) == MEM)\n     {\n       register int offset = 0;\n+\n       if (! WORDS_BIG_ENDIAN)\n-\toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n-\t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\toffset = (MAX (xsize, UNITS_PER_WORD)\n+\t\t  - MAX (msize, UNITS_PER_WORD));\n \n       if (! BYTES_BIG_ENDIAN\n-\t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-\toffset -= (GET_MODE_SIZE (mode)\n-\t\t   - MIN (UNITS_PER_WORD,\n-\t\t\t  GET_MODE_SIZE (GET_MODE (x))));\n+\t  && msize < UNITS_PER_WORD)\n+\toffset -= (msize - MIN (UNITS_PER_WORD, xsize));\n \n       return change_address (x, mode, plus_constant (XEXP (x, 0), offset));\n     }\n@@ -1138,46 +1232,47 @@ gen_highpart (mode, x)\n       /* The only time this should occur is when we are looking at a\n \t multi-word item with a SUBREG whose mode is the same as that of the\n \t item.  It isn't clear what we would do if it wasn't.  */\n-      if (SUBREG_WORD (x) != 0)\n+      if (SUBREG_BYTE (x) != 0)\n \tabort ();\n       return gen_highpart (mode, SUBREG_REG (x));\n     }\n   else if (GET_CODE (x) == REG)\n     {\n-      int word;\n-\n-      /* Let the backend decide how many registers to skip.  This is needed\n-         in particular for sparc64 where fp regs are smaller than a word.  */\n-      /* ??? Note that subregs are now ambiguous, in that those against\n-\t pseudos are sized by the word size, while those against hard\n-\t regs are sized by the underlying register size.  Better would be\n-\t to always interpret the subreg offset parameter as bytes or bits.  */\n+      int offset = 0;\n \n       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n \tabort ();\n-      else if (WORDS_BIG_ENDIAN)\n-\tword = 0;\n-      else if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\tword = (HARD_REGNO_NREGS (REGNO (x), GET_MODE (x))\n-\t\t- HARD_REGNO_NREGS (REGNO (x), mode));\n-      else\n-\tword = ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n-\t\t/ UNITS_PER_WORD);\n-\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER\n-\t  /* integrate.c can't handle parts of a return value register.  */\n-\t  && (! REG_FUNCTION_VALUE_P (x)\n-\t      || ! rtx_equal_function_value_matters)\n+\n+      if ((! WORDS_BIG_ENDIAN || ! BYTES_BIG_ENDIAN)\n+\t  && xsize > msize)\n+\t{\n+\t  int difference = xsize - msize;\n+\n+\t  if (! WORDS_BIG_ENDIAN)\n+\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t  if (! BYTES_BIG_ENDIAN)\n+\t    offset += difference % UNITS_PER_WORD;\n+\t}\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int final_regno = REGNO (x) +\n+\t    subreg_regno_offset (REGNO (x), GET_MODE (x), offset, mode);\n+\n+\t  /* integrate.c can't handle parts of a return value register.\n+\t     ??? Then integrate.c should be fixed!\n+\t     ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n+\t  if ((! REG_FUNCTION_VALUE_P (x)\n+\t       || ! rtx_equal_function_value_matters)\n \t  /* We want to keep the stack, frame, and arg pointers special.  */\n-\t  && x != frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t  && x != arg_pointer_rtx\n+\t      && x != frame_pointer_rtx\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\t\n+\t      && x != arg_pointer_rtx\n #endif\n-\t  && x != stack_pointer_rtx)\n-\treturn gen_rtx_REG (mode, REGNO (x) + word);\n-      else\n-\treturn gen_rtx_SUBREG (mode, x, word);\n+\t      && x != stack_pointer_rtx)\n+\t    return gen_rtx_REG (mode, final_regno);\n+\t}\n+      /* Just generate a normal SUBREG.  */\n+      return gen_rtx_SUBREG (mode, x, offset); \n     }\n   else\n     abort ();\n@@ -1191,154 +1286,44 @@ int\n subreg_lowpart_p (x)\n      rtx x;\n {\n+  unsigned int offset = 0;\n+  int difference = (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t    - GET_MODE_SIZE (GET_MODE (x)));\n+\n   if (GET_CODE (x) != SUBREG)\n     return 1;\n   else if (GET_MODE (SUBREG_REG (x)) == VOIDmode)\n     return 0;\n \n-  if (WORDS_BIG_ENDIAN\n-      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD)\n-    return (SUBREG_WORD (x)\n-\t    == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t\t - MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD))\n-\t\t/ UNITS_PER_WORD));\n+  if (difference > 0)\n+    {\n+      if (WORDS_BIG_ENDIAN)\n+\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset += difference % UNITS_PER_WORD;\n+    }\n \n-  return SUBREG_WORD (x) == 0;\n+  return SUBREG_BYTE (x) == offset;\n }\n \f\n-/* Return subword I of operand OP.\n-   The word number, I, is interpreted as the word number starting at the\n-   low-order address.  Word 0 is the low-order word if not WORDS_BIG_ENDIAN,\n-   otherwise it is the high-order word.\n-\n-   If we cannot extract the required word, we return zero.  Otherwise, an\n-   rtx corresponding to the requested word will be returned.\n \n-   VALIDATE_ADDRESS is nonzero if the address should be validated.  Before\n-   reload has completed, a valid address will always be returned.  After\n-   reload, if a valid address cannot be returned, we return zero.\n-\n-   If VALIDATE_ADDRESS is zero, we simply form the required address; validating\n-   it is the responsibility of the caller.\n-\n-   MODE is the mode of OP in case it is a CONST_INT.  */\n+/* Helper routine for all the constant cases of operand_subword.\n+   Some places invoke this directly.  */\n \n rtx\n-operand_subword (op, i, validate_address, mode)\n+constant_subword (op, offset, mode)\n      rtx op;\n-     unsigned int i;\n-     int validate_address;\n+     int offset;\n      enum machine_mode mode;\n {\n-  HOST_WIDE_INT val;\n   int size_ratio = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode)\n-    abort ();\n-\n-  /* If OP is narrower than a word, fail. */\n-  if (mode != BLKmode\n-      && (GET_MODE_SIZE (mode) < UNITS_PER_WORD))\n-    return 0;\n-\n-  /* If we want a word outside OP, return zero. */\n-  if (mode != BLKmode\n-      && (i + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode))\n-    return const0_rtx;\n+  HOST_WIDE_INT val;\n \n   /* If OP is already an integer word, return it.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n     return op;\n \n-  /* If OP is a REG or SUBREG, we can handle it very simply.  */\n-  if (GET_CODE (op) == REG)\n-    {\n-      /* ??? There is a potential problem with this code.  It does not\n-\t properly handle extractions of a subword from a hard register\n-\t that is larger than word_mode.  Presumably the check for\n-\t HARD_REGNO_MODE_OK catches these most of these cases.  */\n-\n-      /* If OP is a hard register, but OP + I is not a hard register,\n-\t then extracting a subword is impossible.\n-\n-\t For example, consider if OP is the last hard register and it is\n-\t larger than word_mode.  If we wanted word N (for N > 0) because a\n-\t part of that hard register was known to contain a useful value,\n-\t then OP + I would refer to a pseudo, not the hard register we\n-\t actually wanted.  */\n-      if (REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t  && REGNO (op) + i >= FIRST_PSEUDO_REGISTER)\n-\treturn 0;\n-\n-      /* If the register is not valid for MODE, return 0.  Note we\n-\t have to check both OP and OP + I since they may refer to\n-\t different parts of the register file.\n-\n-\t Consider if OP refers to the last 96bit FP register and we want\n-\t subword 3 because that subword is known to contain a value we\n-\t needed.  */\n-      if (REGNO (op) < FIRST_PSEUDO_REGISTER\n-\t  && (! HARD_REGNO_MODE_OK (REGNO (op), word_mode)\n-\t      || ! HARD_REGNO_MODE_OK (REGNO (op) + i, word_mode)))\n-\treturn 0;\n-      else if (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t       || (REG_FUNCTION_VALUE_P (op)\n-\t\t   && rtx_equal_function_value_matters)\n-\t       /* We want to keep the stack, frame, and arg pointers\n-\t\t  special.  */\n-\t       || op == frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       || op == arg_pointer_rtx\n-#endif\n-\t       || op == stack_pointer_rtx)\n-\treturn gen_rtx_SUBREG (word_mode, op, i);\n-      else\n-\treturn gen_rtx_REG (word_mode, REGNO (op) + i);\n-    }\n-  else if (GET_CODE (op) == SUBREG)\n-    return gen_rtx_SUBREG (word_mode, SUBREG_REG (op), i + SUBREG_WORD (op));\n-  else if (GET_CODE (op) == CONCAT)\n-    {\n-      unsigned int partwords\n-\t= GET_MODE_UNIT_SIZE (GET_MODE (op)) / UNITS_PER_WORD;\n-\n-      if (i < partwords)\n-\treturn operand_subword (XEXP (op, 0), i, validate_address, mode);\n-      return operand_subword (XEXP (op, 1), i - partwords,\n-\t\t\t      validate_address, mode);\n-    }\n-\n-  /* Form a new MEM at the requested address.  */\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx addr = plus_constant (XEXP (op, 0), i * UNITS_PER_WORD);\n-      rtx new;\n-\n-      if (validate_address)\n-\t{\n-\t  if (reload_completed)\n-\t    {\n-\t      if (! strict_memory_address_p (word_mode, addr))\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    addr = memory_address (word_mode, addr);\n-\t}\n-\n-      new = gen_rtx_MEM (word_mode, addr);\n-      MEM_COPY_ATTRIBUTES (new, op);\n-      return new;\n-    }\n-\n-  /* The only remaining cases are when OP is a constant.  If the host and\n-     target floating formats are the same, handling two-word floating\n-     constants are easy.  Note that REAL_VALUE_TO_TARGET_{SINGLE,DOUBLE}\n-     are defined as returning one or two 32 bit values, respectively,\n-     and not values of BITS_PER_WORD bits.  */\n #ifdef REAL_ARITHMETIC\n   /* The output is some bits, the width of the target machine's word.\n      A wider-word host can surely hold them in a CONST_INT. A narrower-word\n@@ -1365,12 +1350,12 @@ operand_subword (op, i, validate_address, mode)\n \t So we explicitly mask and sign-extend as necessary.  */\n       if (BITS_PER_WORD == 32)\n \t{\n-\t  val = k[i];\n+\t  val = k[offset];\n \t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \t  return GEN_INT (val);\n \t}\n #if HOST_BITS_PER_WIDE_INT >= 64\n-      else if (BITS_PER_WORD >= 64 && i == 0)\n+      else if (BITS_PER_WORD >= 64 && offset == 0)\n \t{\n \t  val = k[! WORDS_BIG_ENDIAN];\n \t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n@@ -1380,8 +1365,8 @@ operand_subword (op, i, validate_address, mode)\n #endif\n       else if (BITS_PER_WORD == 16)\n \t{\n-\t  val = k[i >> 1];\n-\t  if ((i & 1) == !WORDS_BIG_ENDIAN)\n+\t  val = k[offset >> 1];\n+\t  if ((offset & 1) == ! WORDS_BIG_ENDIAN)\n \t    val >>= 16;\n \t  val &= 0xffff;\n \t  return GEN_INT (val);\n@@ -1402,16 +1387,16 @@ operand_subword (op, i, validate_address, mode)\n \n       if (BITS_PER_WORD == 32)\n \t{\n-\t  val = k[i];\n+\t  val = k[offset];\n \t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \t  return GEN_INT (val);\n \t}\n #if HOST_BITS_PER_WIDE_INT >= 64\n-      else if (BITS_PER_WORD >= 64 && i <= 1)\n+      else if (BITS_PER_WORD >= 64 && offset <= 1)\n \t{\n-\t  val = k[i*2 + ! WORDS_BIG_ENDIAN];\n+\t  val = k[offset * 2 + ! WORDS_BIG_ENDIAN];\n \t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n-\t  val |= (HOST_WIDE_INT) k[i*2 + WORDS_BIG_ENDIAN] & 0xffffffff;\n+\t  val |= (HOST_WIDE_INT) k[offset * 2 + WORDS_BIG_ENDIAN] & 0xffffffff;\n \t  return GEN_INT (val);\n \t}\n #endif\n@@ -1431,10 +1416,10 @@ operand_subword (op, i, validate_address, mode)\n \t compilers don't like a conditional inside macro args, so we have two\n \t copies of the return.  */\n #ifdef HOST_WORDS_BIG_ENDIAN\n-      return GEN_INT (i == WORDS_BIG_ENDIAN\n+      return GEN_INT (offset == WORDS_BIG_ENDIAN\n \t\t      ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n #else\n-      return GEN_INT (i != WORDS_BIG_ENDIAN\n+      return GEN_INT (offset != WORDS_BIG_ENDIAN\n \t\t      ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n #endif\n     }\n@@ -1460,7 +1445,7 @@ operand_subword (op, i, validate_address, mode)\n \n       if (BITS_PER_WORD == 16)\n \t{\n-\t  if ((i & 1) == !WORDS_BIG_ENDIAN)\n+\t  if ((offset & 1) == ! WORDS_BIG_ENDIAN)\n \t    val >>= 16;\n \t  val &= 0xffff;\n \t}\n@@ -1504,7 +1489,7 @@ operand_subword (op, i, validate_address, mode)\n       \n   /* The only remaining cases that we can handle are integers.\n      Convert to proper endianness now since these cases need it.\n-     At this point, i == 0 means the low-order word.  \n+     At this point, offset == 0 means the low-order word.  \n \n      We do not want to handle the case when BITS_PER_WORD <= HOST_BITS_PER_INT\n      in general.  However, if OP is (const_int 0), we can just return\n@@ -1519,39 +1504,184 @@ operand_subword (op, i, validate_address, mode)\n     return 0;\n \n   if (WORDS_BIG_ENDIAN)\n-    i = GET_MODE_SIZE (mode) / UNITS_PER_WORD - 1 - i;\n+    offset = GET_MODE_SIZE (mode) / UNITS_PER_WORD - 1 - offset;\n \n   /* Find out which word on the host machine this value is in and get\n      it from the constant.  */\n-  val = (i / size_ratio == 0\n+  val = (offset / size_ratio == 0\n \t ? (GET_CODE (op) == CONST_INT ? INTVAL (op) : CONST_DOUBLE_LOW (op))\n \t : (GET_CODE (op) == CONST_INT\n \t    ? (INTVAL (op) < 0 ? ~0 : 0) : CONST_DOUBLE_HIGH (op)));\n \n   /* Get the value we want into the low bits of val.  */\n   if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT)\n-    val = ((val >> ((i % size_ratio) * BITS_PER_WORD)));\n+    val = ((val >> ((offset % size_ratio) * BITS_PER_WORD)));\n \n   val = trunc_int_for_mode (val, word_mode);\n \n   return GEN_INT (val);\n }\n \n+/* Return subword OFFSET of operand OP.\n+   The word number, OFFSET, is interpreted as the word number starting\n+   at the low-order address.  OFFSET 0 is the low-order word if not\n+   WORDS_BIG_ENDIAN, otherwise it is the high-order word.\n+\n+   If we cannot extract the required word, we return zero.  Otherwise,\n+   an rtx corresponding to the requested word will be returned.\n+\n+   VALIDATE_ADDRESS is nonzero if the address should be validated.  Before\n+   reload has completed, a valid address will always be returned.  After\n+   reload, if a valid address cannot be returned, we return zero.\n+\n+   If VALIDATE_ADDRESS is zero, we simply form the required address; validating\n+   it is the responsibility of the caller.\n+\n+   MODE is the mode of OP in case it is a CONST_INT.\n+\n+   ??? This is still rather broken for some cases.  The problem for the\n+   moment is that all callers of this thing provide no 'goal mode' to\n+   tell us to work with.  This exists because all callers were written\n+   in a word based SUBREG world.  */\n+\n+rtx\n+operand_subword (op, offset, validate_address, mode)\n+     rtx op;\n+     unsigned int offset;\n+     int validate_address;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    abort ();\n+\n+  /* If OP is narrower than a word, fail. */\n+  if (mode != BLKmode\n+      && (GET_MODE_SIZE (mode) < UNITS_PER_WORD))\n+    return 0;\n+\n+  /* If we want a word outside OP, return zero. */\n+  if (mode != BLKmode\n+      && (offset + 1) * UNITS_PER_WORD > GET_MODE_SIZE (mode))\n+    return const0_rtx;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG:\n+    case SUBREG:\n+    case CONCAT:\n+    case MEM:\n+      break;\n+\n+    default:\n+      /* The only remaining cases are when OP is a constant.  If the host and\n+\t target floating formats are the same, handling two-word floating\n+\t constants are easy.  Note that REAL_VALUE_TO_TARGET_{SINGLE,DOUBLE}\n+\t are defined as returning one or two 32 bit values, respectively,\n+\t and not values of BITS_PER_WORD bits.  */\n+      return constant_subword (op, offset, mode);\n+    }\n+\n+  /* If OP is already an integer word, return it.  */\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n+    return op;\n+\n+  /* If OP is a REG or SUBREG, we can handle it very simply.  */\n+  if (GET_CODE (op) == REG)\n+    {\n+      if (REGNO (op) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int final_regno = REGNO (op) +\n+\t    subreg_regno_offset (REGNO (op), GET_MODE (op),\n+\t\t\t\toffset * UNITS_PER_WORD,\n+\t\t\t\tword_mode);\n+\n+\t  /* If the register is not valid for MODE, return 0.  If we don't\n+\t     do this, there is no way to fix up the resulting REG later.  */\n+\t  if (! HARD_REGNO_MODE_OK (final_regno, word_mode))\n+\t    return 0;\n+\n+\t  /* integrate.c can't handle parts of a return value register.\n+\t     ??? Then integrate.c should be fixed!\n+\t     ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n+\t  if ((! REG_FUNCTION_VALUE_P (op)\n+\t       || ! rtx_equal_function_value_matters)\n+\t      /* ??? What about CLASS_CANNOT_CHANGE_SIZE?  */\n+\t      /* We want to keep the stack, frame, and arg pointers\n+\t\t special.  */\n+\t      && op != frame_pointer_rtx\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t      && op != arg_pointer_rtx\n+#endif\n+\t      && op != stack_pointer_rtx)\n+\t    return gen_rtx_REG (word_mode, final_regno);\n+\t}\n+\n+      /* Just return a normal SUBREG.  */\n+      return gen_rtx_SUBREG (word_mode, op,\n+\t\t\t     (offset * UNITS_PER_WORD));\n+    }\n+  else if (GET_CODE (op) == SUBREG)\n+    {\n+      int final_offset = ((offset * UNITS_PER_WORD) + SUBREG_BYTE (op));\n+\n+      /* When working with SUBREGs the rule is that the byte\n+\t offset must be a multiple of the SUBREG's mode.  */\n+      final_offset = (final_offset / GET_MODE_SIZE (word_mode));\n+      final_offset = (final_offset * GET_MODE_SIZE (word_mode));\n+      return gen_rtx_SUBREG (word_mode, SUBREG_REG (op), final_offset);\n+    }\n+  else if (GET_CODE (op) == CONCAT)\n+    {\n+      unsigned int partwords = GET_MODE_UNIT_SIZE (GET_MODE (op)) / UNITS_PER_WORD;\n+      if (offset < partwords)\n+\treturn operand_subword (XEXP (op, 0), offset, validate_address, mode);\n+      return operand_subword (XEXP (op, 1), offset - partwords,\n+\t\t\t      validate_address, mode);\n+    }\n+\n+  /* Form a new MEM at the requested address.  */\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx addr = plus_constant (XEXP (op, 0), (offset * UNITS_PER_WORD));\n+      rtx new;\n+\n+      if (validate_address)\n+\t{\n+\t  if (reload_completed)\n+\t    {\n+\t      if (! strict_memory_address_p (word_mode, addr))\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    addr = memory_address (word_mode, addr);\n+\t}\n+\n+      new = gen_rtx_MEM (word_mode, addr);\n+      MEM_COPY_ATTRIBUTES (new, op);\n+      return new;\n+    }\n+\n+  /* Unreachable... (famous last words) */\n+  abort ();\n+}\n+\n /* Similar to `operand_subword', but never return 0.  If we can't extract\n    the required subword, put OP into a register and try again.  If that fails,\n-   abort.  We always validate the address in this case.  It is not valid\n-   to call this function after reload; it is mostly meant for RTL\n-   generation. \n+   abort.  We always validate the address in this case.  \n \n    MODE is the mode of OP, in case it is CONST_INT.  */\n \n rtx\n-operand_subword_force (op, i, mode)\n+operand_subword_force (op, offset, mode)\n      rtx op;\n-     unsigned int i;\n+     unsigned int offset;\n      enum machine_mode mode;\n {\n-  rtx result = operand_subword (op, i, 1, mode);\n+  rtx result = operand_subword (op, offset, 1, mode);\n \n   if (result)\n     return result;\n@@ -1566,7 +1696,7 @@ operand_subword_force (op, i, mode)\n \top = force_reg (mode, op);\n     }\n \n-  result = operand_subword (op, i, 1, mode);\n+  result = operand_subword (op, offset, 1, mode);\n   if (result == 0)\n     abort ();\n "}, {"sha": "a7684508b5bcf730748362bea6016b72f9b049ad", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -261,7 +261,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t meaningful at a much higher level; when structures are copied\n \t between memory and regs, the higher-numbered regs\n \t always get higher addresses.  */\n-      offset += SUBREG_WORD (op0);\n+      offset += (SUBREG_BYTE (op0) / UNITS_PER_WORD);\n       /* We used to adjust BITPOS here, but now we do the whole adjustment\n \t right after the loop.  */\n       op0 = SUBREG_REG (op0);\n@@ -311,7 +311,9 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\tabort ();\n \t    }\n \t  if (GET_CODE (op0) == REG)\n-\t    op0 = gen_rtx_SUBREG (fieldmode, op0, offset);\n+\t    op0 = gen_rtx_SUBREG (fieldmode, op0,\n+\t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n+\t\t\t\t  + (offset * UNITS_PER_WORD));\n \t  else\n \t    op0 = change_address (op0, fieldmode,\n \t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n@@ -373,7 +375,10 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t}\n \n       emit_insn (GEN_FCN (icode)\n-\t\t (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n+\t\t (gen_rtx_SUBREG (fieldmode, op0,\n+\t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n+\t\t\t\t  + (offset * UNITS_PER_WORD)),\n+\t\t\t\t  value));\n \n       return value;\n     }\n@@ -447,7 +452,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\tabort ();\n \t    }\n \t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n-\t\t                op0, offset);\n+\t\t                op0, (offset * UNITS_PER_WORD));\n \t}\n       offset = 0;\n     }\n@@ -550,7 +555,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       if (GET_CODE (xop0) == SUBREG)\n \t/* We can't just change the mode, because this might clobber op0,\n \t   and we will need the original value of op0 if insv fails.  */\n-\txop0 = gen_rtx_SUBREG (maxmode, SUBREG_REG (xop0), SUBREG_WORD (xop0));\n+\txop0 = gen_rtx_SUBREG (maxmode, SUBREG_REG (xop0), SUBREG_BYTE (xop0));\n       if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n \txop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n@@ -910,8 +915,8 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n \t the current word starting from the base register.  */\n       if (GET_CODE (op0) == SUBREG)\n \t{\n-\t  word = operand_subword_force (SUBREG_REG (op0),\n-\t\t\t\t\tSUBREG_WORD (op0) + offset,\n+\t  int word_offset = (SUBREG_BYTE (op0) / UNITS_PER_WORD) + offset;\n+\t  word = operand_subword_force (SUBREG_REG (op0), word_offset,\n \t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n \t  offset = 0;\n \t}\n@@ -1008,7 +1013,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       int outer_size = GET_MODE_BITSIZE (GET_MODE (op0));\n       int inner_size = GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)));\n \n-      offset += SUBREG_WORD (op0);\n+      offset += SUBREG_BYTE (op0) / UNITS_PER_WORD;\n \n       inner_size = MIN (inner_size, BITS_PER_WORD);\n \n@@ -1104,7 +1109,9 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\tabort ();\n \t    }\n \t  if (GET_CODE (op0) == REG)\n-\t    op0 = gen_rtx_SUBREG (mode1, op0, offset);\n+\t    op0 = gen_rtx_SUBREG (mode1, op0,\n+\t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n+\t\t\t\t  + (offset * UNITS_PER_WORD));\n \t  else\n \t    op0 = change_address (op0, mode1,\n \t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n@@ -1213,7 +1220,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  if (GET_CODE (op0) != REG)\n \t    op0 = copy_to_reg (op0);\n \t  op0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n-\t\t                op0, offset);\n+\t\t                op0, (offset * UNITS_PER_WORD));\n \t}\n       offset = 0;\n     }\n@@ -1808,8 +1815,8 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n \t the current word starting from the base register.  */\n       if (GET_CODE (op0) == SUBREG)\n \t{\n-\t  word = operand_subword_force (SUBREG_REG (op0),\n-\t\t\t\t\tSUBREG_WORD (op0) + offset,\n+\t  int word_offset = (SUBREG_BYTE (op0) / UNITS_PER_WORD) + offset;\n+\t  word = operand_subword_force (SUBREG_REG (op0), word_offset,\n \t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n \t  offset = 0;\n \t}\n@@ -1928,7 +1935,7 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n         op1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n \t\t       % GET_MODE_BITSIZE (mode));\n       else if (GET_CODE (op1) == SUBREG\n-\t       && SUBREG_WORD (op1) == 0)\n+\t       && SUBREG_BYTE (op1) == 0)\n \top1 = SUBREG_REG (op1);\n     }\n #endif"}, {"sha": "7d78acd33ae16fdb6e9428c90a2451e9154fd250", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -4134,7 +4134,7 @@ store_expr (exp, target, want_value)\n       if (want_value && GET_MODE (temp) != GET_MODE (target)\n \t  && GET_MODE (temp) != VOIDmode)\n \t{\n-\t  temp = gen_rtx_SUBREG (GET_MODE (target), temp, 0);\n+\t  temp = gen_lowpart_SUBREG (GET_MODE (target), temp);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (temp)\n \t    = SUBREG_PROMOTED_UNSIGNED_P (target);\n@@ -6346,7 +6346,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      != promote_mode (type, DECL_MODE (exp), &unsignedp, 0))\n \t    abort ();\n \n-\t  temp = gen_rtx_SUBREG (mode, DECL_RTL (exp), 0);\n+\t  temp = gen_lowpart_SUBREG (mode, DECL_RTL (exp));\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t  return temp;\n@@ -6466,7 +6466,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  if (GET_CODE (temp) == REG && GET_MODE (temp) != mode)\n \t    {\n-\t      temp = gen_rtx_SUBREG (mode, SAVE_EXPR_RTL (exp), 0);\n+\t      temp = gen_lowpart_SUBREG (mode, SAVE_EXPR_RTL (exp));\n \t      SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t      SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t    }\n@@ -6489,7 +6489,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  /* Compute the signedness and make the proper SUBREG.  */\n \t  promote_mode (type, mode, &unsignedp, 0);\n-\t  temp = gen_rtx_SUBREG (mode, SAVE_EXPR_RTL (exp), 0);\n+\t  temp = gen_lowpart_SUBREG (mode, SAVE_EXPR_RTL (exp));\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t  return temp;"}, {"sha": "88519bd73bfa128a75faa3c6028df9ca3aa939cb", "filename": "gcc/final.c", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -3119,20 +3119,8 @@ alter_subreg (x)\n \n   if (GET_CODE (y) == REG)\n     {\n-      int regno;\n-      /* If the word size is larger than the size of this register,\n-\t adjust the register number to compensate.  */\n-      /* ??? Note that this just catches stragglers created by/for\n-\t integrate.  It would be better if we either caught these\n-\t earlier, or kept _all_ subregs until now and eliminate\n-\t gen_lowpart and friends.  */\n-\n-#ifdef ALTER_HARD_SUBREG\n-      regno = ALTER_HARD_SUBREG (GET_MODE (x), SUBREG_WORD (x),\n-\t\t\t\t GET_MODE (y), REGNO (y));\n-#else\n-      regno = REGNO (y) + SUBREG_WORD (x);\n-#endif\n+      int regno = subreg_hard_regno (x, 1);\n+\n       PUT_CODE (x, REG);\n       REGNO (x) = regno;\n       ORIGINAL_REGNO (x) = ORIGINAL_REGNO (y);\n@@ -3142,11 +3130,12 @@ alter_subreg (x)\n     }\n   else if (GET_CODE (y) == MEM)\n     {\n-      register int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+      register int offset = SUBREG_BYTE (x);\n+\n+      /* Catch these instead of generating incorrect code.  */\n+      if ((offset % GET_MODE_SIZE (GET_MODE (x))) != 0)\n+\tabort ();\n \n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x)))\n-\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (y))));\n       PUT_CODE (x, MEM);\n       MEM_COPY_ATTRIBUTES (x, y);\n       XEXP (x, 0) = plus_constant (XEXP (y, 0), offset);"}, {"sha": "388bd2a9d8a0535ea7541043ca5903a5512a6585", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -3088,7 +3088,7 @@ set_noop_p (set)\n \n   if (GET_CODE (src) == SUBREG && GET_CODE (dst) == SUBREG)\n     {\n-      if (SUBREG_WORD (src) != SUBREG_WORD (dst))\n+      if (SUBREG_BYTE (src) != SUBREG_BYTE (dst))\n \treturn 0;\n       src = SUBREG_REG (src);\n       dst = SUBREG_REG (dst);\n@@ -4669,12 +4669,9 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t  regno_last = regno_first = REGNO (SUBREG_REG (reg));\n \t  if (regno_first < FIRST_PSEUDO_REGISTER)\n \t    {\n-#ifdef ALTER_HARD_SUBREG\n-\t      regno_first = ALTER_HARD_SUBREG (outer_mode, SUBREG_WORD (reg),\n-\t\t\t\t\t       inner_mode, regno_first);\n-#else\n-\t      regno_first += SUBREG_WORD (reg);\n-#endif\n+\t      regno_first += subreg_regno_offset (regno_first, inner_mode,\n+\t      \t\t\t\t\t  SUBREG_BYTE (reg),\n+\t      \t\t\t\t\t  outer_mode);\n \t      regno_last = (regno_first\n \t\t\t    + HARD_REGNO_NREGS (regno_first, outer_mode) - 1);\n "}, {"sha": "c31029bc5668d2eefb685ecbd5fb0dfca9f31dd4", "filename": "gcc/function.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2221,7 +2221,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t  dest = XEXP (dest, 0);\n \n \tif (GET_CODE (src) == SUBREG)\n-\t  src = XEXP (src, 0);\n+\t  src = SUBREG_REG (src);\n \n \t/* If VAR does not appear at the top level of the SET\n \t   just scan the lower levels of the tree.  */\n@@ -2505,7 +2505,7 @@ fixup_memory_subreg (x, insn, uncritical)\n      rtx insn;\n      int uncritical;\n {\n-  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+  int offset = SUBREG_BYTE (x);\n   rtx addr = XEXP (SUBREG_REG (x), 0);\n   enum machine_mode mode = GET_MODE (x);\n   rtx result;\n@@ -2515,9 +2515,6 @@ fixup_memory_subreg (x, insn, uncritical)\n       && ! uncritical)\n     abort ();\n \n-  if (BYTES_BIG_ENDIAN)\n-    offset += (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n   addr = plus_constant (addr, offset);\n   if (!flag_force_addr && memory_address_p (mode, addr))\n     /* Shortcut if no insns need be emitted.  */\n@@ -2711,7 +2708,8 @@ optimize_bit_field (body, insn, equiv_mem)\n \t  offset /= BITS_PER_UNIT;\n \t  if (GET_CODE (XEXP (bitfield, 0)) == SUBREG)\n \t    {\n-\t      offset += SUBREG_WORD (XEXP (bitfield, 0)) * UNITS_PER_WORD;\n+\t      offset += (SUBREG_BYTE (XEXP (bitfield, 0))\n+\t\t\t / UNITS_PER_WORD) * UNITS_PER_WORD;\n \t      if (BYTES_BIG_ENDIAN)\n \t\toffset -= (MIN (UNITS_PER_WORD,\n \t\t\t\tGET_MODE_SIZE (GET_MODE (XEXP (bitfield, 0))))\n@@ -2736,7 +2734,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t\t{\n \t\t  rtx src = SET_SRC (body);\n \t\t  while (GET_CODE (src) == SUBREG\n-\t\t\t && SUBREG_WORD (src) == 0)\n+\t\t\t && SUBREG_BYTE (src) == 0)\n \t\t    src = SUBREG_REG (src);\n \t\t  if (GET_MODE (src) != GET_MODE (memref))\n \t\t    src = gen_lowpart (GET_MODE (memref), SET_SRC (body));\n@@ -2757,7 +2755,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t      rtx dest = SET_DEST (body);\n \n \t      while (GET_CODE (dest) == SUBREG\n-\t\t     && SUBREG_WORD (dest) == 0\n+\t\t     && SUBREG_BYTE (dest) == 0\n \t\t     && (GET_MODE_CLASS (GET_MODE (dest))\n \t\t\t == GET_MODE_CLASS (GET_MODE (SUBREG_REG (dest))))\n \t\t     && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n@@ -3067,7 +3065,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t       code did.  This is especially true of\n \t\t       REG_RETVAL.  */\n \n-\t\t    if (GET_CODE (z) == SUBREG && SUBREG_WORD (z) == 0)\n+\t\t    if (GET_CODE (z) == SUBREG && SUBREG_BYTE (z) == 0)\n \t\t      z = SUBREG_REG (z);\n \n \t\t    if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n@@ -3443,17 +3441,22 @@ purge_single_hard_subreg_set (pattern)\n {\n   rtx reg = SET_DEST (pattern);\n   enum machine_mode mode = GET_MODE (SET_DEST (pattern));\n-  int word = 0;\n-\t\t  \n-  while (GET_CODE (reg) == SUBREG)\n+  int offset = 0;\n+\n+  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG\n+      && REGNO (SUBREG_REG (reg)) < FIRST_PSEUDO_REGISTER)\n     {\n-      word += SUBREG_WORD (reg);\n+      offset = subreg_regno_offset (REGNO (SUBREG_REG (reg)),\n+\t\t\t\t    GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t    SUBREG_BYTE (reg),\n+\t\t\t\t    GET_MODE (reg));\n       reg = SUBREG_REG (reg);\n     }\n-\t      \n+\n+\t\t  \n   if (REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     {\n-      reg = gen_rtx_REG (mode, REGNO (reg) + word);\n+      reg = gen_rtx_REG (mode, REGNO (reg) + offset);\n       SET_DEST (pattern) = reg;\n     }\n }\n@@ -4737,6 +4740,20 @@ assign_parms (fndecl)\n \t      push_to_sequence (conversion_insns);\n \t      tempreg = convert_to_mode (nominal_mode, tempreg, unsignedp);\n \n+\t      if (GET_CODE (tempreg) == SUBREG\n+\t\t  && GET_MODE (tempreg) == nominal_mode\n+\t\t  && GET_CODE (SUBREG_REG (tempreg)) == REG\n+\t\t  && nominal_mode == passed_mode\n+\t\t  && GET_MODE (SUBREG_REG (tempreg)) == GET_MODE (entry_parm)\n+\t\t  && GET_MODE_SIZE (GET_MODE (tempreg))\n+\t\t     < GET_MODE_SIZE (GET_MODE (entry_parm)))\n+\t\t{\n+\t\t  /* The argument is already sign/zero extended, so note it\n+\t\t     into the subreg.  */\n+\t\t  SUBREG_PROMOTED_VAR_P (tempreg) = 1;\n+\t\t  SUBREG_PROMOTED_UNSIGNED_P (tempreg) = unsignedp;\n+\t\t}\n+\n \t      /* TREE_USED gets set erroneously during expand_assignment.  */\n \t      save_tree_used = TREE_USED (parm);\n \t      expand_assignment (parm,"}, {"sha": "d41e0d279751ce10fcb7c8f8ef0c30742317b394", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -208,6 +208,7 @@ special_rtx (idx)\n   return (strcmp (defs[idx].enumname, \"CONST_INT\") == 0\n \t  || strcmp (defs[idx].enumname, \"CONST_DOUBLE\") == 0\n \t  || strcmp (defs[idx].enumname, \"REG\") == 0\n+\t  || strcmp (defs[idx].enumname, \"SUBREG\") == 0\n \t  || strcmp (defs[idx].enumname, \"MEM\") == 0);\n }\n "}, {"sha": "2f757bd9ade77394e2ca378e94af03ffe9b2e1d9", "filename": "gcc/global.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1422,17 +1422,8 @@ mark_reg_store (reg, setter, data)\n {\n   register int regno;\n \n-  /* WORD is which word of a multi-register group is being stored.\n-     For the case where the store is actually into a SUBREG of REG.\n-     Except we don't use it; I believe the entire REG needs to be\n-     made live.  */\n-  int word = 0;\n-\n   if (GET_CODE (reg) == SUBREG)\n-    {\n-      word = SUBREG_WORD (reg);\n-      reg = SUBREG_REG (reg);\n-    }\n+    reg = SUBREG_REG (reg);\n \n   if (GET_CODE (reg) != REG)\n     return;\n@@ -1456,7 +1447,7 @@ mark_reg_store (reg, setter, data)\n     }\n \n   if (reg_renumber[regno] >= 0)\n-    regno = reg_renumber[regno] /* + word */;\n+    regno = reg_renumber[regno];\n \n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n@@ -1606,7 +1597,15 @@ set_preference (dest, src)\n   else if (GET_CODE (src) == SUBREG && GET_CODE (SUBREG_REG (src)) == REG)\n     {\n       src_regno = REGNO (SUBREG_REG (src));\n-      offset += SUBREG_WORD (src);\n+\n+      if (REGNO (SUBREG_REG (src)) < FIRST_PSEUDO_REGISTER)\n+\toffset += subreg_regno_offset (REGNO (SUBREG_REG (src)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (src)),\n+\t\t\t\t       SUBREG_BYTE (src),\n+\t\t\t\t       GET_MODE (src));\n+      else\n+\toffset += (SUBREG_BYTE (src)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (src)));\n     }\n   else\n     return;\n@@ -1616,7 +1615,15 @@ set_preference (dest, src)\n   else if (GET_CODE (dest) == SUBREG && GET_CODE (SUBREG_REG (dest)) == REG)\n     {\n       dest_regno = REGNO (SUBREG_REG (dest));\n-      offset -= SUBREG_WORD (dest);\n+\n+      if (REGNO (SUBREG_REG (dest)) < FIRST_PSEUDO_REGISTER)\n+\toffset -= subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (dest)),\n+\t\t\t\t       SUBREG_BYTE (dest),\n+\t\t\t\t       GET_MODE (dest));\n+      else\n+\toffset -= (SUBREG_BYTE (dest)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (dest)));\n     }\n   else\n     return;"}, {"sha": "b642643f3aec048d52360bd00fcd38c14d12ee2b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -557,10 +557,7 @@ noce_emit_move_insn (x, y)\n   inner = XEXP (outer, 0);\n   outmode = GET_MODE (outer);\n   inmode = GET_MODE (inner);\n-  bitpos = SUBREG_WORD (outer) * BITS_PER_WORD;\n-  if (BYTES_BIG_ENDIAN)\n-    bitpos += (GET_MODE_BITSIZE (inmode) - GET_MODE_BITSIZE (outmode))\n-\t      % BITS_PER_WORD;\n+  bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;\n   store_bit_field (inner, GET_MODE_BITSIZE (outmode),\n \t\t   bitpos, outmode, y, GET_MODE_BITSIZE (inmode),\n \t\t   GET_MODE_BITSIZE (inmode));"}, {"sha": "327e8fa5f2544da3ce94e01e202029156aa505cf", "filename": "gcc/integrate.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1895,23 +1895,33 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       copy = copy_rtx_and_substitute (SUBREG_REG (orig), map, for_lhs);\n       /* SUBREG is ordinary, but don't make nested SUBREGs.  */\n       if (GET_CODE (copy) == SUBREG)\n-\treturn gen_rtx_SUBREG (GET_MODE (orig), SUBREG_REG (copy),\n-\t\t\t       SUBREG_WORD (orig) + SUBREG_WORD (copy));\n+\t{\n+\t  int final_offset = SUBREG_BYTE (orig) + SUBREG_BYTE (copy);\n+\n+\t  /* When working with SUBREGs the rule is that the byte\n+\t     offset must be a multiple of the SUBREG's mode.  */\n+\t  final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (orig)));\n+\t  final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (orig)));\n+\t  return gen_rtx_SUBREG (GET_MODE (orig), SUBREG_REG (copy),\n+\t\t\t\t final_offset);\n+\t}\n       else if (GET_CODE (copy) == CONCAT)\n \t{\n \t  rtx retval = subreg_realpart_p (orig) ? XEXP (copy, 0) : XEXP (copy, 1);\n+\t  int final_offset;\n \n \t  if (GET_MODE (retval) == GET_MODE (orig))\n \t    return retval;\n-\t  else\n-\t    return gen_rtx_SUBREG (GET_MODE (orig), retval,\n-\t\t\t\t   (SUBREG_WORD (orig) %\n-\t\t\t\t    (GET_MODE_UNIT_SIZE (GET_MODE (SUBREG_REG (orig)))\n-\t\t\t\t     / (unsigned) UNITS_PER_WORD)));\n+\t  \n+\t  final_offset = SUBREG_BYTE (orig) %\n+\t  \t\t GET_MODE_UNIT_SIZE (GET_MODE (SUBREG_REG (orig)));\n+\t  final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (orig)));\n+\t  final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (orig)));\n+\t  return gen_rtx_SUBREG (GET_MODE (orig), retval, final_offset);\n \t}\n       else\n \treturn gen_rtx_SUBREG (GET_MODE (orig), copy,\n-\t\t\t       SUBREG_WORD (orig));\n+\t\t\t       SUBREG_BYTE (orig));\n \n     case ADDRESSOF:\n       copy = gen_rtx_ADDRESSOF (mode,\n@@ -2397,8 +2407,8 @@ subst_constants (loc, insn, map, memonly)\n \t  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n \t      && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n \t      && GET_MODE (SUBREG_REG (x)) != VOIDmode)\n-\t    new = operand_subword (inner, SUBREG_WORD (x), 0,\n-\t\t\t\t   GET_MODE (SUBREG_REG (x)));\n+\t    new = operand_subword (inner, SUBREG_BYTE (x) / UNITS_PER_WORD,\n+\t\t\t\t   0, GET_MODE (SUBREG_REG (x)));\n \n \t  cancel_changes (num_changes);\n \t  if (new == 0 && subreg_lowpart_p (x))\n@@ -2675,7 +2685,12 @@ mark_stores (dest, x, data)\n     regno = REGNO (dest), mode = GET_MODE (dest);\n   else if (GET_CODE (dest) == SUBREG && GET_CODE (SUBREG_REG (dest)) == REG)\n     {\n-      regno = REGNO (SUBREG_REG (dest)) + SUBREG_WORD (dest);\n+      regno = REGNO (SUBREG_REG (dest));\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tregno += subreg_regno_offset (REGNO (SUBREG_REG (dest)),\n+\t\t\t\t      GET_MODE (SUBREG_REG (dest)),\n+\t\t\t\t      SUBREG_BYTE (dest),\n+\t\t\t\t      GET_MODE (dest));\n       mode = GET_MODE (SUBREG_REG (dest));\n     }\n "}, {"sha": "5c5807394dc0838741c04ee6191ef626b2c9c487", "filename": "gcc/jump.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -3543,7 +3543,7 @@ rtx_renumbered_equal_p (x, y)\n \t\t\t\t  && GET_CODE (SUBREG_REG (y)) == REG)))\n     {\n       int reg_x = -1, reg_y = -1;\n-      int word_x = 0, word_y = 0;\n+      int byte_x = 0, byte_y = 0;\n \n       if (GET_MODE (x) != GET_MODE (y))\n \treturn 0;\n@@ -3556,15 +3556,17 @@ rtx_renumbered_equal_p (x, y)\n       if (code == SUBREG)\n \t{\n \t  reg_x = REGNO (SUBREG_REG (x));\n-\t  word_x = SUBREG_WORD (x);\n+\t  byte_x = SUBREG_BYTE (x);\n \n \t  if (reg_renumber[reg_x] >= 0)\n \t    {\n-\t      reg_x = reg_renumber[reg_x] + word_x;\n-\t      word_x = 0;\n+\t      reg_x = subreg_regno_offset (reg_renumber[reg_x],\n+\t\t\t\t\t   GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t\t   byte_x,\n+\t\t\t\t\t   GET_MODE (x));\n+\t      byte_x = 0;\n \t    }\n \t}\n-\n       else\n \t{\n \t  reg_x = REGNO (x);\n@@ -3575,23 +3577,25 @@ rtx_renumbered_equal_p (x, y)\n       if (GET_CODE (y) == SUBREG)\n \t{\n \t  reg_y = REGNO (SUBREG_REG (y));\n-\t  word_y = SUBREG_WORD (y);\n+\t  byte_y = SUBREG_BYTE (y);\n \n \t  if (reg_renumber[reg_y] >= 0)\n \t    {\n-\t      reg_y = reg_renumber[reg_y];\n-\t      word_y = 0;\n+\t      reg_y = subreg_regno_offset (reg_renumber[reg_y],\n+\t\t\t\t\t   GET_MODE (SUBREG_REG (y)),\n+\t\t\t\t\t   byte_y,\n+\t\t\t\t\t   GET_MODE (y));\n+\t      byte_y = 0;\n \t    }\n \t}\n-\n       else\n \t{\n \t  reg_y = REGNO (y);\n \t  if (reg_renumber[reg_y] >= 0)\n \t    reg_y = reg_renumber[reg_y];\n \t}\n \n-      return reg_x >= 0 && reg_x == reg_y && word_x == word_y;\n+      return reg_x >= 0 && reg_x == reg_y && byte_x == byte_y;\n     }\n \n   /* Now we have disposed of all the cases\n@@ -3722,7 +3726,9 @@ true_regnum (x)\n     {\n       int base = true_regnum (SUBREG_REG (x));\n       if (base >= 0 && base < FIRST_PSEUDO_REGISTER)\n-\treturn SUBREG_WORD (x) + base;\n+\treturn base + subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+\t\t\t\t\t   GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t\t   SUBREG_BYTE (x), GET_MODE (x));\n     }\n   return -1;\n }"}, {"sha": "c83d4f145f58930a7ca5da38302e307e55666908", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1813,25 +1813,49 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n     {\n       if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (usedreg))) > UNITS_PER_WORD)\n \tmay_save_copy = 0;\n-      offset += SUBREG_WORD (usedreg);\n+      if (REGNO (SUBREG_REG (usedreg)) < FIRST_PSEUDO_REGISTER)\n+\toffset += subreg_regno_offset (REGNO (SUBREG_REG (usedreg)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (usedreg)),\n+\t\t\t\t       SUBREG_BYTE (usedreg),\n+\t\t\t\t       GET_MODE (usedreg));\n+      else\n+\toffset += (SUBREG_BYTE (usedreg)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (usedreg)));\n       usedreg = SUBREG_REG (usedreg);\n     }\n   if (GET_CODE (usedreg) != REG)\n     return 0;\n   ureg = REGNO (usedreg);\n-  usize = REG_SIZE (usedreg);\n+  if (ureg < FIRST_PSEUDO_REGISTER)\n+    usize = HARD_REGNO_NREGS (ureg, GET_MODE (usedreg));\n+  else\n+    usize = ((GET_MODE_SIZE (GET_MODE (usedreg))\n+\t      + (REGMODE_NATURAL_SIZE (GET_MODE (usedreg)) - 1))\n+\t     / REGMODE_NATURAL_SIZE (GET_MODE (usedreg)));\n \n   while (GET_CODE (setreg) == SUBREG)\n     {\n       if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (setreg))) > UNITS_PER_WORD)\n \tmay_save_copy = 0;\n-      offset -= SUBREG_WORD (setreg);\n+      if (REGNO (SUBREG_REG (setreg)) < FIRST_PSEUDO_REGISTER)\n+\toffset -= subreg_regno_offset (REGNO (SUBREG_REG (setreg)),\n+\t\t\t\t       GET_MODE (SUBREG_REG (setreg)),\n+\t\t\t\t       SUBREG_BYTE (setreg),\n+\t\t\t\t       GET_MODE (setreg));\n+      else\n+\toffset -= (SUBREG_BYTE (setreg)\n+\t\t   / REGMODE_NATURAL_SIZE (GET_MODE (setreg)));\n       setreg = SUBREG_REG (setreg);\n     }\n   if (GET_CODE (setreg) != REG)\n     return 0;\n   sreg = REGNO (setreg);\n-  ssize = REG_SIZE (setreg);\n+  if (sreg < FIRST_PSEUDO_REGISTER)\n+    ssize = HARD_REGNO_NREGS (sreg, GET_MODE (setreg));\n+  else\n+    ssize = ((GET_MODE_SIZE (GET_MODE (setreg))\n+\t      + (REGMODE_NATURAL_SIZE (GET_MODE (setreg)) - 1))\n+\t     / REGMODE_NATURAL_SIZE (GET_MODE (setreg)));\n \n   /* If UREG is a pseudo-register that hasn't already been assigned a\n      quantity number, it means that it is not local to this block or dies\n@@ -2032,7 +2056,11 @@ reg_is_born (reg, birth)\n   register int regno;\n \n   if (GET_CODE (reg) == SUBREG)\n-    regno = REGNO (SUBREG_REG (reg)) + SUBREG_WORD (reg);\n+    {\n+      regno = REGNO (SUBREG_REG (reg));\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tregno = subreg_hard_regno (reg, 1);\n+    }\n   else\n     regno = REGNO (reg);\n "}, {"sha": "e278f985529a0ce60c25bb2fa05d3c3e4e876e91", "filename": "gcc/recog.c", "status": "modified", "additions": 99, "deletions": 51, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -517,13 +517,15 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  if (GET_CODE (XEXP (x, 0)) == SUBREG)\n \t    {\n \t      if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) <= UNITS_PER_WORD)\n-\t\tto = operand_subword (to, SUBREG_WORD (XEXP (x, 0)),\n+\t\tto = operand_subword (to, \n+\t\t\t\t      (SUBREG_BYTE (XEXP (x, 0)) \n+\t\t\t\t       / UNITS_PER_WORD),\n \t\t\t\t      0, GET_MODE (from));\n \t      else if (GET_MODE_CLASS (GET_MODE (from)) == MODE_INT\n \t\t       && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t\t\t   <= HOST_BITS_PER_WIDE_INT))\n \t\t{\n-\t\t  int i = SUBREG_WORD (XEXP (x, 0)) * BITS_PER_WORD;\n+\t\t  int i = SUBREG_BYTE (XEXP (x, 0)) * BITS_PER_UNIT;\n \t\t  HOST_WIDE_INT valh;\n \t\t  unsigned HOST_WIDE_INT vall;\n \n@@ -569,40 +571,89 @@ validate_replace_rtx_1 (loc, from, to, object)\n       break;\n \t\n     case SUBREG:\n-      /* In case we are replacing by constant, attempt to simplify it to non-SUBREG\n-         expression.  We can't do this later, since the information about inner mode\n-         may be lost.  */\n+      /* In case we are replacing by constant, attempt to simplify it to\n+\t non-SUBREG expression.  We can't do this later, since the information\n+\t about inner mode may be lost.  */\n       if (CONSTANT_P (to) && rtx_equal_p (SUBREG_REG (x), from))\n         {\n-\t  if (GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n-\t      && GET_MODE_SIZE (GET_MODE (from)) > UNITS_PER_WORD\n-\t      && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t    {\n-\t      rtx temp = operand_subword (to, SUBREG_WORD (x),\n-\t\t\t\t\t  0, GET_MODE (from));\n-\t      if (temp)\n-\t\t{\n-\t\t  validate_change (object, loc, temp, 1);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  if (subreg_lowpart_p (x))\n+\t  int offset, part;\n+\t  unsigned HOST_WIDE_INT val;\n+\n+\t  /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n+\t     since we are saying that the high bits don't matter.  */\n+\t  if (GET_MODE (to) == VOIDmode\n+\t      && (GET_MODE_SIZE (GET_MODE (x))\n+\t\t  >= GET_MODE_SIZE (GET_MODE (from))))\n \t    {\n-\t      rtx new =  gen_lowpart_if_possible (GET_MODE (x), to);\n+\t      rtx new = gen_lowpart_if_possible (GET_MODE (x), to);\n \t      if (new)\n \t\t{\n \t\t  validate_change (object, loc, new, 1);\n \t\t  return;\n \t\t}\n \t    }\n \n-\t  /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n-\t     since we are saying that the high bits don't matter.  */\n-\t  if (GET_MODE (to) == VOIDmode\n-\t      && GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (from)))\n+\t  offset = SUBREG_BYTE (x) * BITS_PER_UNIT;\n+\t  switch (GET_CODE (to))\n \t    {\n-\t      validate_change (object, loc, to, 1);\n-\t      return;\n+\t    case CONST_DOUBLE:\n+\t      if (GET_MODE (to) != VOIDmode)\n+\t\tbreak;\n+\n+\t      part = offset >= HOST_BITS_PER_WIDE_INT;\n+\t      if ((BITS_PER_WORD > HOST_BITS_PER_WIDE_INT\n+\t\t   && BYTES_BIG_ENDIAN)\n+\t\t  || (BITS_PER_WORD <= HOST_BITS_PER_WIDE_INT\n+\t\t      && WORDS_BIG_ENDIAN))\n+\t\tpart = !part;\n+\t      val = part ? CONST_DOUBLE_HIGH (to) : CONST_DOUBLE_LOW (to);\n+\t      offset %= HOST_BITS_PER_WIDE_INT;\n+\n+\t      /* FALLTHROUGH */\n+\t    case CONST_INT:\n+\t      if (GET_CODE (to) == CONST_INT)\n+\t\tval = INTVAL (to);\n+\n+\t      {\n+\t\t/* Avoid creating bogus SUBREGs */\n+\t\tenum machine_mode mode = GET_MODE (x);\n+\t\tenum machine_mode inner_mode = GET_MODE (from);\n+\n+\t\t/* We've already picked the word we want from a double, so \n+\t\t   pretend this is actually an integer.  */\n+\t\tif (GET_CODE (to) == CONST_DOUBLE)\n+\t\t  inner_mode = SImode;\n+\n+\t\tif (GET_MODE_CLASS (mode) != MODE_INT)\n+\t\t  abort ();\n+\n+\t\tif (BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n+\t\t  {\n+\t\t    if (WORDS_BIG_ENDIAN)\n+\t\t      offset = GET_MODE_BITSIZE (inner_mode)\n+\t\t\t       - GET_MODE_BITSIZE (mode) - offset;\n+\t\t    if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN\n+\t\t\t&& GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\t\t      offset = offset + BITS_PER_WORD - GET_MODE_BITSIZE (mode)\n+\t\t\t       - 2 * (offset % BITS_PER_WORD);\n+\t\t  }\n+\n+\t\tif (offset >= HOST_BITS_PER_WIDE_INT)\n+\t\t  to = ((HOST_WIDE_INT) val < 0) ? constm1_rtx : const0_rtx;\n+\t\telse\n+\t\t  {\n+\t\t    val >>= offset;\n+\t\t    if (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n+\t\t      val = trunc_int_for_mode (val, mode);\n+\t\t    to = GEN_INT (val);\n+\t\t  }\n+\n+\t\tvalidate_change (object, loc, to, 1);\n+\t\treturn;\n+\t      }\n+\n+\t    default:\n+\t      break;\n \t    }\n         }\n \n@@ -612,15 +663,26 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  && rtx_equal_p (SUBREG_REG (x), from))\n \t{\n \t  if (GET_MODE (x) == GET_MODE (SUBREG_REG (to))\n-\t      && SUBREG_WORD (x) == 0 && SUBREG_WORD (to) == 0)\n+\t      && SUBREG_BYTE (x) == 0 && SUBREG_BYTE (to) == 0)\n \t    {\n \t      validate_change (object, loc, SUBREG_REG (to), 1);\n \t      return;\n \t    }\n \n-\t  validate_change (object, loc,\n-\t\t\t   gen_rtx_SUBREG (GET_MODE (x), SUBREG_REG (to),\n-\t\t\t\t\t   SUBREG_WORD (x) + SUBREG_WORD (to)), 1);\n+\t  /* Make sure the 2 byte counts added together are an even unit\n+\t     of x's mode, and combine them if so. Otherwise we run\n+\t     into problems with something like:\n+\t\t(subreg:HI (subreg:QI (SI:55) 3) 0)\n+\t     we end up with an odd offset into a HI which is invalid.  */\n+\n+\t  if (SUBREG_BYTE (to) % GET_MODE_SIZE (GET_MODE (x)) == 0)\n+\t    validate_change (object, loc,\n+\t\t\t     gen_rtx_SUBREG (GET_MODE (x), SUBREG_REG (to),\n+\t\t\t\t\t     SUBREG_BYTE(x) + SUBREG_BYTE (to)),\n+\t\t\t     1);\n+\t  else\n+\t    validate_change (object, loc, to, 1);\t\n+\n \t  return;\n \t}\n \n@@ -636,15 +698,10 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  && ! MEM_VOLATILE_P (to)\n \t  && GET_MODE_SIZE (GET_MODE (x)) <= GET_MODE_SIZE (GET_MODE (to)))\n \t{\n-\t  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+\t  int offset = SUBREG_BYTE (x);\n \t  enum machine_mode mode = GET_MODE (x);\n \t  rtx new;\n \n-\t  if (BYTES_BIG_ENDIAN)\n-\t    offset += (MIN (UNITS_PER_WORD,\n-\t\t\t    GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n-\n \t  new = gen_rtx_MEM (mode, plus_constant (XEXP (to, 0), offset));\n \t  MEM_COPY_ATTRIBUTES (new, to);\n \t  validate_change (object, loc, new, 1);\n@@ -694,8 +751,8 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t      int offset = pos / BITS_PER_UNIT;\n \t      rtx newmem;\n \n-\t\t  /* If the bytes and bits are counted differently, we\n-\t\t     must adjust the offset.  */\n+\t      /* If the bytes and bits are counted differently, we\n+\t\t must adjust the offset.  */\n \t      if (BYTES_BIG_ENDIAN != BITS_BIG_ENDIAN)\n \t\toffset = (GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (wanted_mode)\n \t\t\t  - offset);\n@@ -1040,7 +1097,6 @@ general_operand (op, mode)\n      enum machine_mode mode;\n {\n   register enum rtx_code code = GET_CODE (op);\n-  int mode_altering_drug = 0;\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -1078,11 +1134,6 @@ general_operand (op, mode)\n \n       op = SUBREG_REG (op);\n       code = GET_CODE (op);\n-#if 0\n-      /* No longer needed, since (SUBREG (MEM...))\n-\t will load the MEM into a reload reg in the MEM's own mode.  */\n-      mode_altering_drug = 1;\n-#endif\n     }\n \n   if (code == REG)\n@@ -1113,8 +1164,6 @@ general_operand (op, mode)\n   return 0;\n \n  win:\n-  if (mode_altering_drug)\n-    return ! mode_dependent_address_p (XEXP (op, 0));\n   return 1;\n }\n \f\n@@ -1467,13 +1516,9 @@ indirect_operand (op, mode)\n   if (! reload_completed\n       && GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == MEM)\n     {\n-      register int offset = SUBREG_WORD (op) * UNITS_PER_WORD;\n+      register int offset = SUBREG_BYTE (op);\n       rtx inner = SUBREG_REG (op);\n \n-      if (BYTES_BIG_ENDIAN)\n-\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n-\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (inner))));\n-\n       if (mode != VOIDmode && GET_MODE (op) != mode)\n \treturn 0;\n \n@@ -2482,7 +2527,10 @@ constrain_operands (strict)\n \t    {\n \t      if (GET_CODE (SUBREG_REG (op)) == REG\n \t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n-\t\toffset = SUBREG_WORD (op);\n+\t\toffset = subreg_regno_offset (REGNO (SUBREG_REG (op)),\n+\t\t\t\t\t      GET_MODE (SUBREG_REG (op)),\n+\t\t\t\t\t      SUBREG_BYTE (op),\n+\t\t\t\t\t      GET_MODE (op));\n \t      op = SUBREG_REG (op);\n \t    }\n "}, {"sha": "6c2044674236073a3f699571fc136a4d6350137c", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -557,7 +557,11 @@ get_true_reg (pat)\n \t  rtx subreg;\n \t  if (FP_REG_P (subreg = SUBREG_REG (*pat)))\n \t    {\n-\t      *pat = FP_MODE_REG (REGNO (subreg) + SUBREG_WORD (*pat),\n+\t      int regno_off = subreg_regno_offset (REGNO (subreg),\n+\t\t\t\t\t\t   GET_MODE (subreg),\n+\t\t\t\t\t\t   SUBREG_BYTE (*pat),\n+\t\t\t\t\t\t   GET_MODE (*pat));\n+\t      *pat = FP_MODE_REG (REGNO (subreg) + regno_off,\n \t\t\t\t  GET_MODE (subreg));\n \t    default:\n \t      return pat;"}, {"sha": "227c662c537196a0e046e284ba56303a32a78245", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -717,7 +717,7 @@ optimize_reg_copy_3 (insn, dest, src)\n \n   /* Now walk forward making additional replacements.  We want to be able\n      to undo all the changes if a later substitution fails.  */\n-  subreg = gen_rtx_SUBREG (old_mode, src_reg, 0);\n+  subreg = gen_lowpart_SUBREG (old_mode, src_reg);\n   while (p = NEXT_INSN (p), p != insn)\n     {\n       if (! INSN_P (p))\n@@ -1168,7 +1168,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t{\n \t\t  src_subreg\n \t\t    = gen_rtx_SUBREG (GET_MODE (SUBREG_REG (dst)),\n-\t\t\t\t      src, SUBREG_WORD (dst));\n+\t\t\t\t      src, SUBREG_BYTE (dst));\n \t\t  dst = SUBREG_REG (dst);\n \t\t}\n \t      if (GET_CODE (dst) != REG"}, {"sha": "61b9a49ac02d3b1b3cd504ad812865b022dbfb19", "filename": "gcc/regs.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -24,12 +24,28 @@ Boston, MA 02111-1307, USA.  */\n \n #define REG_BYTES(R) mode_size[(int) GET_MODE (R)]\n \n-/* Get the number of consecutive hard regs required to hold the REG rtx R.\n+/* Get the number of consecutive hard regs required to hold the REG or\n+   SUBREG rtx R.\n    When something may be an explicit hard reg, REG_SIZE is the only\n-   valid way to get this value.  You cannot get it from the regno.  */\n+   valid way to get this value.  You cannot get it from the regno.\n \n+   A target may override this definition, the case where you would do\n+   this is where there are registers which are smaller than WORD_SIZE\n+   such as the SFmode registers on sparc64.  */\n+\n+#ifndef REG_SIZE\n #define REG_SIZE(R) \\\n   ((mode_size[(int) GET_MODE (R)] + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#endif\n+\n+/* When you only have the mode of a pseudo register before it has a hard\n+   register chosen for it, this reports the size of each hard register\n+   a pseudo in such a mode would get allocated to.  Like REG_SIZE, a\n+   target may override this.  */\n+\n+#ifndef REGMODE_NATURAL_SIZE\n+#define REGMODE_NATURAL_SIZE(MODE)\tUNITS_PER_WORD\n+#endif\n \n #ifndef SMALL_REGISTER_CLASSES\n #define SMALL_REGISTER_CLASSES 0"}, {"sha": "ea5bea62331a9d55f3954813817c8d5d8ac2b34f", "filename": "gcc/reload.c", "status": "modified", "additions": 119, "deletions": 46, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -791,7 +791,7 @@ reload_inner_reg_of_subreg (x, mode)\n     return 0;\n \n   /* If INNER is not ok for MODE, then INNER will need reloading.  */\n-  if (! HARD_REGNO_MODE_OK (REGNO (inner) + SUBREG_WORD (x), mode))\n+  if (! HARD_REGNO_MODE_OK (subreg_regno (x), mode))\n     return 1;\n \n   /* If the outer part is a word or smaller, INNER larger than a\n@@ -938,13 +938,12 @@ push_reload (in, out, inloc, outloc, class,\n \n      Finally, reload the inner expression if it is a register that is in\n      the class whose registers cannot be referenced in a different size\n-     and M1 is not the same size as M2.  If SUBREG_WORD is nonzero, we\n+     and M1 is not the same size as M2.  If SUBREG_BYTE is nonzero, we\n      cannot reload just the inside since we might end up with the wrong\n      register class.  But if it is inside a STRICT_LOW_PART, we have\n      no choice, so we hope we do get the right register class there.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n-      && (SUBREG_WORD (in) == 0 || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n       && (class != CLASS_CANNOT_CHANGE_MODE\n \t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (in)), inmode))\n@@ -978,17 +977,15 @@ push_reload (in, out, inloc, outloc, class,\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n-\t      && (out == 0 || SUBREG_WORD (in) == 0)\n+\t      && (out == 0 || SUBREG_BYTE (in) == 0)\n \t      && ((GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t       > UNITS_PER_WORD)\n \t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t/ UNITS_PER_WORD)\n \t\t       != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n \t\t\t\t\t    GET_MODE (SUBREG_REG (in)))))\n-\t\t  || ! HARD_REGNO_MODE_OK ((REGNO (SUBREG_REG (in))\n-\t\t\t\t\t    + SUBREG_WORD (in)),\n-\t\t\t\t\t   inmode)))\n+\t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (in), inmode)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t  || (SECONDARY_INPUT_RELOAD_CLASS (class, inmode, in) != NO_REGS\n \t      && (SECONDARY_INPUT_RELOAD_CLASS (class,\n@@ -1028,7 +1025,7 @@ push_reload (in, out, inloc, outloc, class,\n      that case.  */\n \n   /* Similar issue for (SUBREG constant ...) if it was not handled by the\n-     code above.  This can happen if SUBREG_WORD != 0.  */\n+     code above.  This can happen if SUBREG_BYTE != 0.  */\n \n   if (in != 0 && reload_inner_reg_of_subreg (in, inmode))\n     {\n@@ -1038,7 +1035,11 @@ push_reload (in, out, inloc, outloc, class,\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output before the outer reload.  */\n       push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,\n-\t\t   find_valid_class (inmode, SUBREG_WORD (in)),\n+\t\t   find_valid_class (inmode,\n+\t\t\t\t     subreg_regno_offset (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t\t\t  SUBREG_BYTE (in),\n+\t\t\t\t\t\t\t  GET_MODE (in))),\n \t\t   VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n     }\n@@ -1050,7 +1051,7 @@ push_reload (in, out, inloc, outloc, class,\n      (except in the case of STRICT_LOW_PART,\n      and in that case the constraint should label it input-output.)  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n-      && (SUBREG_WORD (out) == 0 || strict_low)\n+      && (SUBREG_BYTE (out) == 0 || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n       && (class != CLASS_CANNOT_CHANGE_MODE\n \t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (out)),\n@@ -1080,9 +1081,7 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t/ UNITS_PER_WORD)\n \t\t       != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n \t\t\t\t\t    GET_MODE (SUBREG_REG (out)))))\n-\t\t  || ! HARD_REGNO_MODE_OK ((REGNO (SUBREG_REG (out))\n-\t\t\t\t\t    + SUBREG_WORD (out)),\n-\t\t\t\t\t   outmode)))\n+\t\t  || ! HARD_REGNO_MODE_OK (subreg_regno (out), outmode)))\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  || (SECONDARY_OUTPUT_RELOAD_CLASS (class, outmode, out) != NO_REGS\n \t      && (SECONDARY_OUTPUT_RELOAD_CLASS (class,\n@@ -1129,7 +1128,11 @@ push_reload (in, out, inloc, outloc, class,\n       dont_remove_subreg = 1;\n       push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),\n \t\t   &SUBREG_REG (out),\n-\t\t   find_valid_class (outmode, SUBREG_WORD (out)),\n+\t\t   find_valid_class (outmode,\n+\t\t\t\t     subreg_regno_offset (REGNO (SUBREG_REG (out)),\n+\t\t\t\t\t\t\t  GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t\t\t  SUBREG_BYTE (out),\n+\t\t\t\t\t\t\t  GET_MODE (out))),\n \t\t   VOIDmode, VOIDmode, 0, 0,\n \t\t   opnum, RELOAD_OTHER);\n     }\n@@ -1146,16 +1149,14 @@ push_reload (in, out, inloc, outloc, class,\n   if (in != 0 && GET_CODE (in) == SUBREG && GET_CODE (SUBREG_REG (in)) == REG\n       && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n-    in = gen_rtx_REG (GET_MODE (in),\n-\t\t      REGNO (SUBREG_REG (in)) + SUBREG_WORD (in));\n+    in = gen_rtx_REG (GET_MODE (in), subreg_regno (in));\n \n   /* Similarly for OUT.  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && GET_CODE (SUBREG_REG (out)) == REG\n       && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n-    out = gen_rtx_REG (GET_MODE (out),\n-\t\t       REGNO (SUBREG_REG (out)) + SUBREG_WORD (out));\n+    out = gen_rtx_REG (GET_MODE (out), subreg_regno (out));\n \n   /* Narrow down the class of register wanted if that is\n      desirable on this machine for efficiency.  */\n@@ -1810,15 +1811,28 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \t  || GET_MODE_SIZE (inmode) > UNITS_PER_WORD))\n     return 0;\n \n+  /* Note that {in,out}_offset are needed only when 'in' or 'out'\n+     respectively refers to a hard register.  */\n+\n   /* Find the inside of any subregs.  */\n   while (GET_CODE (out) == SUBREG)\n     {\n-      out_offset = SUBREG_WORD (out);\n+      if (GET_CODE (SUBREG_REG (out)) == REG\n+\t  && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER)\n+\tout_offset += subreg_regno_offset (REGNO (SUBREG_REG (out)),\n+\t\t\t\t\t   GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t   SUBREG_BYTE (out),\n+\t\t\t\t\t   GET_MODE (out));\n       out = SUBREG_REG (out);\n     }\n   while (GET_CODE (in) == SUBREG)\n     {\n-      in_offset = SUBREG_WORD (in);\n+      if (GET_CODE (SUBREG_REG (in)) == REG\n+\t  && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER)\n+\tin_offset += subreg_regno_offset (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t  GET_MODE (SUBREG_REG (in)),\n+\t\t\t\t\t  SUBREG_BYTE (in),\n+\t\t\t\t\t  GET_MODE (in));\n       in = SUBREG_REG (in);\n     }\n \n@@ -2035,7 +2049,10 @@ operands_match_p (x, y)\n \t  i = REGNO (SUBREG_REG (x));\n \t  if (i >= FIRST_PSEUDO_REGISTER)\n \t    goto slow;\n-\t  i += SUBREG_WORD (x);\n+\t  i += subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+\t\t\t\t    GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t    SUBREG_BYTE (x),\n+\t\t\t\t    GET_MODE (x));\n \t}\n       else\n \ti = REGNO (x);\n@@ -2045,7 +2062,10 @@ operands_match_p (x, y)\n \t  j = REGNO (SUBREG_REG (y));\n \t  if (j >= FIRST_PSEUDO_REGISTER)\n \t    goto slow;\n-\t  j += SUBREG_WORD (y);\n+\t  j += subreg_regno_offset (REGNO (SUBREG_REG (y)),\n+\t\t\t\t    GET_MODE (SUBREG_REG (y)),\n+\t\t\t\t    SUBREG_BYTE (y),\n+\t\t\t\t    GET_MODE (y));\n \t}\n       else\n \tj = REGNO (y);\n@@ -2777,7 +2797,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t  while (GET_CODE (operand) == SUBREG)\n \t    {\n-\t      offset += SUBREG_WORD (operand);\n+\t      /* Offset only matters when operand is a REG and\n+\t\t it is a hard reg.  This is because it is passed\n+\t\t to reg_fits_class_p if it is a REG and all pseudos\n+\t\t return 0 from that function.  */\n+\t      if (GET_CODE (SUBREG_REG (operand)) == REG\n+\t\t  && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  offset += subreg_regno_offset (REGNO (SUBREG_REG (operand)),\n+\t\t\t\t\t\t GET_MODE (SUBREG_REG (operand)),\n+\t\t\t\t\t\t SUBREG_BYTE (operand),\n+\t\t\t\t\t\t GET_MODE (operand));\n+\t\t}\n \t      operand = SUBREG_REG (operand);\n \t      /* Force reload if this is a constant or PLUS or if there may\n \t\t be a problem accessing OPERAND in the outer mode.  */\n@@ -2828,6 +2859,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t  )\n #endif\n \t\t      )\n+\t\t  /* This following hunk of code should no longer be\n+\t\t     needed at all with SUBREG_BYTE.  If you need this\n+\t\t     code back, please explain to me why so I can\n+\t\t     fix the real problem.  -DaveM */\n+#if 0\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n \t\t     or which would handle that mode in the wrong number of\n \t\t     registers for subregging to work.  */\n@@ -2841,7 +2877,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t       != HARD_REGNO_NREGS (REGNO (operand),\n \t\t\t\t\t\t    GET_MODE (operand))))\n \t\t\t  || ! HARD_REGNO_MODE_OK (REGNO (operand) + offset,\n-\t\t\t\t\t\t   operand_mode[i]))))\n+\t\t\t\t\t\t   operand_mode[i])))\n+#endif\n+\t\t  )\n \t\tforce_reload = 1;\n \t    }\n \n@@ -3716,7 +3754,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \trtx operand = recog_data.operand[i];\n \n \twhile (GET_CODE (operand) == SUBREG)\n-\t  operand = XEXP (operand, 0);\n+\t  operand = SUBREG_REG (operand);\n \tif ((GET_CODE (operand) == MEM\n \t     || (GET_CODE (operand) == REG\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n@@ -3766,7 +3804,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    operand = *recog_data.operand_loc[i];\n \n \t    while (GET_CODE (operand) == SUBREG)\n-\t      operand = XEXP (operand, 0);\n+\t      operand = SUBREG_REG (operand);\n \t    if (GET_CODE (operand) == REG)\n \t      {\n \t\tif (modified[i] != RELOAD_WRITE)\n@@ -3789,7 +3827,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \trtx operand = recog_data.operand[i];\n \n \twhile (GET_CODE (operand) == SUBREG)\n-\t  operand = XEXP (operand, 0);\n+\t  operand = SUBREG_REG (operand);\n \tif ((GET_CODE (operand) == MEM\n \t     || (GET_CODE (operand) == REG\n \t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n@@ -4303,7 +4341,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \t  && regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0\n \t  && (tem = operand_subword (reg_equiv_constant[regno],\n-\t\t\t\t     SUBREG_WORD (x), 0,\n+\t\t\t\t     SUBREG_BYTE (x) / UNITS_PER_WORD, 0,\n \t\t\t\t     GET_MODE (SUBREG_REG (x)))) != 0)\n \t{\n \t  /* TEM is now a word sized constant for the bits from X that\n@@ -4329,7 +4367,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n \t{\n-\t  int shift = SUBREG_WORD (x) * BITS_PER_WORD;\n+\t  int shift = SUBREG_BYTE (x) * BITS_PER_UNIT;\n \t  if (WORDS_BIG_ENDIAN)\n \t    shift = (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n \t\t     - GET_MODE_BITSIZE (GET_MODE (x))\n@@ -4383,13 +4421,18 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \t the meaning of the memory access.  */\n       enum machine_mode subreg_mode = GET_MODE (SUBREG_REG (x));\n \n+      /* SUBREG_REG (x) is a MEM, so we cant take the offset, instead we \n+         calculate the register number as : \n+\t SUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode) */\n       if (is_set_dest)\n \tpush_reload (NULL_RTX, SUBREG_REG (x), NULL_PTR, &SUBREG_REG (x),\n-\t\t     find_valid_class (subreg_mode, SUBREG_WORD (x)),\n+\t\t     find_valid_class (subreg_mode, \n+\t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n \t\t     VOIDmode, subreg_mode, 0, 0, opnum, type);\n       else\n \tpush_reload (SUBREG_REG (x), NULL_RTX, &SUBREG_REG (x), NULL_PTR,\n-\t\t     find_valid_class (subreg_mode, SUBREG_WORD (x)),\n+\t\t     find_valid_class (subreg_mode,\n+\t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n \t\t     subreg_mode, VOIDmode, 0, 0, opnum, type);\n     }\n \n@@ -5075,16 +5118,26 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t    code0 = GET_CODE (op0);\n \t    if (code0 == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER)\n \t      op0 = gen_rtx_REG (word_mode,\n-\t\t\t\t REGNO (op0) + SUBREG_WORD (orig_op0));\n+\t\t\t\t (REGNO (op0) +\n+\t\t\t\t  subreg_regno_offset (REGNO (SUBREG_REG (orig_op0)),\n+\t\t\t\t\t\t       GET_MODE (SUBREG_REG (orig_op0)),\n+\t\t\t\t\t\t       SUBREG_BYTE (orig_op0),\n+\t\t\t\t\t\t       GET_MODE (orig_op0))));\n \t  }\n \n \tif (GET_CODE (op1) == SUBREG)\n \t  {\n \t    op1 = SUBREG_REG (op1);\n \t    code1 = GET_CODE (op1);\n \t    if (code1 == REG && REGNO (op1) < FIRST_PSEUDO_REGISTER)\n+\t      /* ??? Why is this given op1's mode and above for\n+\t\t ??? op0 SUBREGs we use word_mode?  */\n \t      op1 = gen_rtx_REG (GET_MODE (op1),\n-\t\t\t\t REGNO (op1) + SUBREG_WORD (orig_op1));\n+\t\t\t\t (REGNO (op1) +\n+\t\t\t\t  subreg_regno_offset (REGNO (SUBREG_REG (orig_op1)),\n+\t\t\t\t\t\t       GET_MODE (SUBREG_REG (orig_op1)),\n+\t\t\t\t\t\t       SUBREG_BYTE (orig_op1),\n+\t\t\t\t\t\t       GET_MODE (orig_op1))));\n \t  }\n \n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n@@ -5492,7 +5545,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t     needless copies if SUBREG_REG is multi-word.  */\n \t  if (REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t      int regno = subreg_regno (x);\n \n \t      if (! (context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t     : REGNO_MODE_OK_FOR_BASE_P (regno, mode)))\n@@ -5646,15 +5699,10 @@ find_reloads_subreg_address (x, force_replace, opnum, type,\n \t  if (force_replace\n \t      || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n \t    {\n-\t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+\t      int offset = SUBREG_BYTE (x);\n \t      unsigned outer_size = GET_MODE_SIZE (GET_MODE (x));\n \t      unsigned inner_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n \n-\t      if (BYTES_BIG_ENDIAN)\n-\t\t{\n-\t\t  offset += MIN (inner_size, UNITS_PER_WORD);\n-\t\t  offset -= MIN (outer_size, UNITS_PER_WORD);\n-\t\t}\n \t      XEXP (tem, 0) = plus_constant (XEXP (tem, 0), offset);\n \t      PUT_MODE (tem, GET_MODE (x));\n \n@@ -5741,8 +5789,18 @@ subst_reloads (insn)\n \t\t*r->subreg_loc = SUBREG_REG (reloadreg);\n \t      else\n \t\t{\n+\t\t  int final_offset =\n+\t\t    SUBREG_BYTE (*r->subreg_loc) + SUBREG_BYTE (reloadreg);\n+\n+\t\t  /* When working with SUBREGs the rule is that the byte\n+\t\t     offset must be a multiple of the SUBREG's mode.  */\n+\t\t  final_offset = (final_offset /\n+\t\t\t\t  GET_MODE_SIZE (GET_MODE (*r->subreg_loc)));\n+\t\t  final_offset = (final_offset *\n+\t\t\t\t  GET_MODE_SIZE (GET_MODE (*r->subreg_loc)));\n+\n \t\t  *r->where = SUBREG_REG (reloadreg);\n-\t\t  SUBREG_WORD (*r->subreg_loc) += SUBREG_WORD (reloadreg);\n+\t\t  SUBREG_BYTE (*r->subreg_loc) = final_offset;\n \t\t}\n \t    }\n \t  else\n@@ -5843,12 +5901,24 @@ find_replacement (loc)\n \n \t  if (GET_CODE (reloadreg) == REG)\n \t    return gen_rtx_REG (GET_MODE (*loc),\n-\t\t\t\tREGNO (reloadreg) + SUBREG_WORD (*loc));\n+\t\t\t\t(REGNO (reloadreg) +\n+\t\t\t\t subreg_regno_offset (REGNO (SUBREG_REG (*loc)),\n+\t\t\t\t\t\t      GET_MODE (SUBREG_REG (*loc)),\n+\t\t\t\t\t\t      SUBREG_BYTE (*loc),\n+\t\t\t\t\t\t      GET_MODE (*loc))));\n \t  else if (GET_MODE (reloadreg) == GET_MODE (*loc))\n \t    return reloadreg;\n \t  else\n-\t    return gen_rtx_SUBREG (GET_MODE (*loc), SUBREG_REG (reloadreg),\n-\t\t\t\t   SUBREG_WORD (reloadreg) + SUBREG_WORD (*loc));\n+\t    {\n+\t      int final_offset = SUBREG_BYTE (reloadreg) + SUBREG_BYTE (*loc);\n+\n+\t      /* When working with SUBREGs the rule is that the byte\n+\t\t offset must be a multiple of the SUBREG's mode.  */\n+\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (*loc)));\n+\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (*loc)));\n+\t      return gen_rtx_SUBREG (GET_MODE (*loc), SUBREG_REG (reloadreg),\n+\t\t\t\t     final_offset);\n+\t    }\n \t}\n     }\n \n@@ -5925,7 +5995,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n       if (GET_CODE (SUBREG_REG (x)) == REG\n \t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int inner_regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n \t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n@@ -6020,7 +6090,10 @@ reg_overlap_mentioned_for_reload_p (x, in)\n     {\n       regno = REGNO (SUBREG_REG (x));\n       if (regno < FIRST_PSEUDO_REGISTER)\n-\tregno += SUBREG_WORD (x);\n+\tregno += subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+\t\t\t\t      GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t      SUBREG_BYTE (x),\n+\t\t\t\t      GET_MODE (x));\n     }\n   else if (GET_CODE (x) == REG)\n     {"}, {"sha": "16cc3be5d605cbac692a59ea687b573883f850e8", "filename": "gcc/reload1.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -2509,7 +2509,7 @@ eliminate_regs (x, mem_mode, insn)\n       return x;\n \n     case SUBREG:\n-      /* Similar to above processing, but preserve SUBREG_WORD.\n+      /* Similar to above processing, but preserve SUBREG_BYTE.\n \t Convert (subreg (mem)) to (mem) if not paradoxical.\n \t Also, if we have a non-paradoxical (subreg (pseudo)) and the\n \t pseudo didn't get a hard reg, we must replace this with the\n@@ -2526,7 +2526,7 @@ eliminate_regs (x, mem_mode, insn)\n       else\n \tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n \n-      if (new != XEXP (x, 0))\n+      if (new != SUBREG_REG (x))\n \t{\n \t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n \t  int new_size = GET_MODE_SIZE (GET_MODE (new));\n@@ -2547,20 +2547,15 @@ eliminate_regs (x, mem_mode, insn)\n \t\t  || (x_size == new_size))\n \t      )\n \t    {\n-\t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+\t      int offset = SUBREG_BYTE (x);\n \t      enum machine_mode mode = GET_MODE (x);\n \n-\t      if (BYTES_BIG_ENDIAN)\n-\t\toffset += (MIN (UNITS_PER_WORD,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (new)))\n-\t\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n-\n \t      PUT_MODE (new, mode);\n \t      XEXP (new, 0) = plus_constant (XEXP (new, 0), offset);\n \t      return new;\n \t    }\n \t  else\n-\t    return gen_rtx_SUBREG (GET_MODE (x), new, SUBREG_WORD (x));\n+\t    return gen_rtx_SUBREG (GET_MODE (x), new, SUBREG_BYTE (x));\n \t}\n \n       return x;\n@@ -4088,10 +4083,14 @@ forget_old_reloads_1 (x, ignored, data)\n   unsigned int nr;\n   int offset = 0;\n \n-  /* note_stores does give us subregs of hard regs.  */\n+  /* note_stores does give us subregs of hard regs,\n+     subreg_regno_offset will abort if it is not a hard reg.  */\n   while (GET_CODE (x) == SUBREG)\n     {\n-      offset += SUBREG_WORD (x);\n+      offset += subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+\t\t\t\t     GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t     SUBREG_BYTE (x),\n+\t\t\t\t     GET_MODE (x));\n       x = SUBREG_REG (x);\n     }\n \n@@ -5401,7 +5400,7 @@ choose_reload_regs (chain)\n \n \t  if (inheritance)\n \t    {\n-\t      int word = 0;\n+\t      int byte = 0;\n \t      register int regno = -1;\n \t      enum machine_mode mode = VOIDmode;\n \n@@ -5420,10 +5419,10 @@ choose_reload_regs (chain)\n \t      else if (GET_CODE (rld[r].in_reg) == SUBREG\n \t\t       && GET_CODE (SUBREG_REG (rld[r].in_reg)) == REG)\n \t\t{\n-\t\t  word = SUBREG_WORD (rld[r].in_reg);\n+\t\t  byte = SUBREG_BYTE (rld[r].in_reg);\n \t\t  regno = REGNO (SUBREG_REG (rld[r].in_reg));\n \t\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t    regno += word;\n+\t\t    regno = subreg_regno (rld[r].in_reg);\n \t\t  mode = GET_MODE (rld[r].in_reg);\n \t\t}\n #ifdef AUTO_INC_DEC\n@@ -5444,7 +5443,7 @@ choose_reload_regs (chain)\n \t\t that can invalidate an inherited reload of part of a pseudoreg.  */\n \t      else if (GET_CODE (rld[r].in) == SUBREG\n \t\t       && GET_CODE (SUBREG_REG (rld[r].in)) == REG)\n-\t\tregno = REGNO (SUBREG_REG (rld[r].in)) + SUBREG_WORD (rld[r].in);\n+\t\tregno = subreg_regno (rld[r].in);\n #endif\n \n \t      if (regno >= 0 && reg_last_reload_reg[regno] != 0)\n@@ -5453,15 +5452,15 @@ choose_reload_regs (chain)\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n \t\t  enum machine_mode need_mode;\n \n-\t\t  i = REGNO (last_reg) + word;\n+\t\t  i = REGNO (last_reg);\n+\t\t  i += subreg_regno_offset (i, GET_MODE (last_reg), byte, mode);\n \t\t  last_class = REGNO_REG_CLASS (i);\n \n-\t\t  if (word == 0)\n+\t\t  if (byte == 0)\n \t\t    need_mode = mode;\n \t\t  else\n \t\t    need_mode\n-\t\t      = smallest_mode_for_size (GET_MODE_SIZE (mode)\n-\t\t\t\t\t\t+ word * UNITS_PER_WORD,\n+\t\t      = smallest_mode_for_size (GET_MODE_SIZE (mode) + byte,\n \t\t\t\t\t\tGET_MODE_CLASS (mode));\n \n \t\t  if (\n@@ -5631,7 +5630,7 @@ choose_reload_regs (chain)\n \t\t\t Make a new REG since this might be used in an\n \t\t\t address and not all machines support SUBREGs\n \t\t\t there.  */\n-\t\t      regno = REGNO (SUBREG_REG (equiv)) + SUBREG_WORD (equiv);\n+\t\t      regno = subreg_regno (equiv);\n \t\t      equiv = gen_rtx_REG (rld[r].mode, regno);\n \t\t    }\n \t\t  else\n@@ -6261,7 +6260,7 @@ emit_input_reload_insns (chain, rl, old, j)\n     oldequiv = SUBREG_REG (oldequiv);\n   if (GET_MODE (oldequiv) != VOIDmode\n       && mode != GET_MODE (oldequiv))\n-    oldequiv = gen_rtx_SUBREG (mode, oldequiv, 0);\n+    oldequiv = gen_lowpart_SUBREG (mode, oldequiv);\n \n   /* Switch to the right place to emit the reload insns.  */\n   switch (rl->when_needed)\n@@ -8885,7 +8884,10 @@ reload_combine_note_store (dst, set, data)\n \n   if (GET_CODE (dst) == SUBREG)\n     {\n-      regno = SUBREG_WORD (dst);\n+      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n+\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t   SUBREG_BYTE (dst),\n+\t\t\t\t   GET_MODE (dst));\n       dst = SUBREG_REG (dst);\n     }\n   if (GET_CODE (dst) != REG)\n@@ -9276,7 +9278,10 @@ move2add_note_store (dst, set, data)\n \n   if (GET_CODE (dst) == SUBREG)\n     {\n-      regno = SUBREG_WORD (dst);\n+      regno = subreg_regno_offset (REGNO (SUBREG_REG (dst)),\n+\t\t\t\t   GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t   SUBREG_BYTE (dst),\n+\t\t\t\t   GET_MODE (dst));\n       dst = SUBREG_REG (dst);\n     }\n "}, {"sha": "17f7d034d93dcff45044b39598dc25d36eb4c6eb", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -100,7 +100,7 @@ update_live_status (dest, x, data)\n     return;\n \n   if (GET_CODE (dest) == SUBREG)\n-    first_regno = REGNO (SUBREG_REG (dest)) + SUBREG_WORD (dest);\n+    first_regno = subreg_regno (dest);\n   else\n     first_regno = REGNO (dest);\n \n@@ -222,7 +222,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n \tmark_referenced_resources (SUBREG_REG (x), res, 0);\n       else\n \t{\n-\t  unsigned int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t  unsigned int regno = subreg_regno (x);\n \t  unsigned int last_regno\n \t    = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n \n@@ -780,7 +780,7 @@ mark_set_resources (x, res, in_dest, mark_type)\n \t    mark_set_resources (SUBREG_REG (x), res, in_dest, mark_type);\n \t  else\n \t    {\n-\t      unsigned int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t      unsigned int regno = subreg_regno (x);\n \t      unsigned int last_regno\n \t\t= regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n "}, {"sha": "e4f2ab037141a1e894009e29fa7f87e4b7e62107", "filename": "gcc/rtl.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -789,10 +789,17 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define CONST_DOUBLE_MEM(r) XCEXP (r, 0, CONST_DOUBLE)\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n-   SUBREG_WORD extracts the word-number.  */\n+   SUBREG_BYTE extracts the byte-number.  */\n \n #define SUBREG_REG(RTX) XCEXP(RTX, 0, SUBREG)\n-#define SUBREG_WORD(RTX) XCUINT(RTX, 1, SUBREG)\n+#define SUBREG_BYTE(RTX) XCUINT(RTX, 1, SUBREG)\n+\n+/* in rtlanal.c */\n+extern unsigned int subreg_regno_offset \tPARAMS ((unsigned int, \n+\t\t\t\t\t\t\t enum machine_mode, \n+\t\t\t\t\t\t\t unsigned int, \n+\t\t\t\t\t\t\t enum machine_mode));\n+extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* 1 if the REG contained in SUBREG_REG is already known to be\n    sign- or zero-extended from the mode of the SUBREG to the mode of\n@@ -1179,6 +1186,7 @@ extern int rtx_equal_p                  PARAMS ((rtx, rtx));\n extern rtvec gen_rtvec_v\t\tPARAMS ((int, rtx *));\n extern rtx gen_reg_rtx\t\t\tPARAMS ((enum machine_mode));\n extern rtx gen_label_rtx\t\tPARAMS ((void));\n+extern int subreg_hard_regno\t\tPARAMS ((rtx, int));\n extern rtx gen_lowpart_common\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx gen_lowpart\t\t\tPARAMS ((enum machine_mode, rtx));\n \n@@ -1191,6 +1199,8 @@ extern rtx gen_realpart\t\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx gen_imagpart\t\t\tPARAMS ((enum machine_mode, rtx));\n extern rtx operand_subword\t\tPARAMS ((rtx, unsigned int, int,\n \t\t\t\t\t\t enum machine_mode));\n+extern rtx constant_subword\t\tPARAMS ((rtx, int,\n+\t\t\t\t\t\t enum machine_mode));\n \n /* In emit-rtl.c */\n extern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n@@ -1569,8 +1579,11 @@ extern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode, rtx,\n extern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\n extern rtx gen_raw_REG PARAMS ((enum machine_mode, int));\n extern rtx gen_rtx_REG PARAMS ((enum machine_mode, int));\n+extern rtx gen_rtx_SUBREG PARAMS ((enum machine_mode, rtx, int));\n extern rtx gen_rtx_MEM PARAMS ((enum machine_mode, rtx));\n \n+extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n+\n /* We need the cast here to ensure that we get the same result both with\n    and without prototypes.  */\n #define GEN_INT(N)  gen_rtx_CONST_INT (VOIDmode, (HOST_WIDE_INT) (N))"}, {"sha": "665a40766c7e1909dcc3f84a9a641e6c08efb404", "filename": "gcc/rtl.texi", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1166,16 +1166,16 @@ This virtual register is replaced by the sum of the register given by\n @end table\n \n @findex subreg\n-@item (subreg:@var{m} @var{reg} @var{wordnum})\n+@item (subreg:@var{m} @var{reg} @var{bytenum})\n @code{subreg} expressions are used to refer to a register in a machine\n mode other than its natural one, or to refer to one register of\n-a multi-word @code{reg} that actually refers to several registers.\n+a multi-part @code{reg} that actually refers to several registers.\n \n Each pseudo-register has a natural mode.  If it is necessary to\n operate on it in a different mode---for example, to perform a fullword\n move instruction on a pseudo-register that contains a single\n byte---the pseudo-register must be enclosed in a @code{subreg}.  In\n-such a case, @var{wordnum} is zero.\n+such a case, @var{bytenum} is zero.\n \n Usually @var{m} is at least as narrow as the mode of @var{reg}, in which\n case it is restricting consideration to only the bits of @var{reg} that\n@@ -1192,7 +1192,7 @@ a multi-register value.  Machine modes such as @code{DImode} and\n @code{TImode} can indicate values longer than a word, values which\n usually require two or more consecutive registers.  To access one of the\n registers, use a @code{subreg} with mode @code{SImode} and a\n-@var{wordnum} that says which register.\n+@var{bytenum} offset that says which register.\n \n Storing in a non-paradoxical @code{subreg} has undefined results for\n bits belonging to the same word as the @code{subreg}.  This laxity makes\n@@ -1202,8 +1202,13 @@ the @code{subreg}, use @code{strict_low_part} around the @code{subreg}.\n \n @cindex @code{WORDS_BIG_ENDIAN}, effect on @code{subreg}\n The compilation parameter @code{WORDS_BIG_ENDIAN}, if set to 1, says\n-that word number zero is the most significant part; otherwise, it is\n-the least significant part.\n+that byte number zero is part of the most significant word; otherwise,\n+it is part of the least significant word.\n+\n+@cindex @code{BYTES_BIG_ENDIAN}, effect on @code{subreg}\n+The compilation parameter @code{BYTES_BIG_ENDIAN}, if set to 1, says\n+that byte number zero is the most significant byte within a word;\n+otherwise, it is the least significant byte within a word.\n \n @cindex @code{FLOAT_WORDS_BIG_ENDIAN}, (lack of) effect on @code{subreg}\n On a few targets, @code{FLOAT_WORDS_BIG_ENDIAN} disagrees with\n@@ -1239,10 +1244,10 @@ a single machine register.  The reload pass prevents @code{subreg}\n expressions such as these from being formed.\n \n @findex SUBREG_REG\n-@findex SUBREG_WORD\n+@findex SUBREG_BYTE\n The first operand of a @code{subreg} expression is customarily accessed \n with the @code{SUBREG_REG} macro and the second operand is customarily\n-accessed with the @code{SUBREG_WORD} macro.\n+accessed with the @code{SUBREG_BYTE} macro.\n \n @findex scratch\n @cindex scratch operands"}, {"sha": "36c3c9ff42f2cf9d143c2b29f5227f4fac134f71", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 80, "deletions": 4, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1083,7 +1083,7 @@ refers_to_regno_p (regno, endregno, x, loc)\n       if (GET_CODE (SUBREG_REG (x)) == REG\n \t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  unsigned int inner_regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n+\t  unsigned int inner_regno = subreg_regno (x);\n \t  unsigned int inner_endregno\n \t    = inner_regno + (inner_regno < FIRST_PSEUDO_REGISTER\n \t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n@@ -1170,7 +1170,7 @@ reg_overlap_mentioned_p (x, in)\n     case SUBREG:\n       regno = REGNO (SUBREG_REG (x));\n       if (regno < FIRST_PSEUDO_REGISTER)\n-\tregno += SUBREG_WORD (x);\n+\tregno = subreg_regno (x);\n       goto do_reg;\n \n     case REG:\n@@ -2229,18 +2229,32 @@ replace_regs (x, reg_map, nregs, replace_dest)\n \t    return map_inner;\n \t  else\n \t    {\n+\t      int final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (map_val);\n+\n+\t      /* When working with REG SUBREGs the rule is that the byte\n+\t\t offset must be a multiple of the SUBREG's mode.  */\n+\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (x)));\n+\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (x)));\n+\n \t      /* We cannot call gen_rtx here since we may be linked with\n \t\t genattrtab.c.  */\n \t      /* Let's try clobbering the incoming SUBREG and see\n \t\t if this is really safe.  */\n \t      SUBREG_REG (x) = map_inner;\n-\t      SUBREG_WORD (x) += SUBREG_WORD (map_val);\n+\t      SUBREG_BYTE (x) = final_offset;\n \t      return x;\n #if 0\n \t      rtx new = rtx_alloc (SUBREG);\n+\t      int final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (map_val);\n+\n+\t      /* When working with REG SUBREGs the rule is that the byte\n+\t\t offset must be a multiple of the SUBREG's mode.  */\n+\t      final_offset = (final_offset / GET_MODE_SIZE (GET_MODE (x)));\n+\t      final_offset = (final_offset * GET_MODE_SIZE (GET_MODE (x)));\n+\n \t      PUT_MODE (new, GET_MODE (x));\n \t      SUBREG_REG (new) = map_inner;\n-\t      SUBREG_WORD (new) = SUBREG_WORD (x) + SUBREG_WORD (map_val);\n+\t      SUBREG_BYTE (new) = final_offset;\n #endif\n \t    }\n \t}\n@@ -2613,3 +2627,65 @@ loc_mentioned_in_p (loc, in)\n     }\n   return 0;\n }\n+\n+/* This function returns the regno offset of a subreg expression.\n+   xregno - A regno of an inner hard subreg_reg (or what will become one).\n+   xmode  - The mode of xregno.\n+   offset - The byte offset.\n+   ymode  - The mode of a top level SUBREG (or what may become one).\n+   RETURN - The regno offset which would be used.  \n+   This function can be overridden by defining SUBREG_REGNO_OFFSET,\n+   taking the same parameters.  */\n+unsigned int\n+subreg_regno_offset (xregno, xmode, offset, ymode)\n+     unsigned int xregno;\n+     enum machine_mode xmode;\n+     unsigned int offset;\n+     enum machine_mode ymode;\n+{\n+  unsigned ret;\n+  int nregs_xmode, nregs_ymode;\n+  int mode_multiple, nregs_multiple;\n+  int y_offset;\n+\n+/* Check for an override, and use it instead.  */\n+#ifdef SUBREG_REGNO_OFFSET\n+  ret = SUBREG_REGNO_OFFSET (xregno, xmode, offset, ymode)\n+#else\n+  if (xregno >= FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  nregs_xmode = HARD_REGNO_NREGS (xregno, xmode);\n+  nregs_ymode = HARD_REGNO_NREGS (xregno, ymode);\n+  if (offset == 0 || nregs_xmode == nregs_ymode)\n+    return 0;\n+  \n+  /* size of ymode must not be greater than the size of xmode.  */\n+  mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n+  if (mode_multiple == 0)\n+    abort ();\n+\n+  y_offset = offset / GET_MODE_SIZE (ymode);\n+  nregs_multiple =  nregs_xmode / nregs_ymode;\n+  ret = (y_offset / (mode_multiple / nregs_multiple)) * nregs_ymode;\n+#endif\n+\n+  return ret;\n+}\n+\n+/* Return the final regno that a subreg expression refers to. */\n+unsigned int \n+subreg_regno (x)\n+     rtx x;\n+{\n+  unsigned int ret;\n+  rtx subreg = SUBREG_REG (x);\n+  int regno = REGNO (subreg);\n+\n+  ret = regno + subreg_regno_offset (regno, \n+\t\t\t\t     GET_MODE (subreg), \n+\t\t\t\t     SUBREG_BYTE (x),\n+\t\t\t\t     GET_MODE (x));\n+  return ret;\n+\n+}"}, {"sha": "4aad9f931c1ee68ccd77afad603014f9f89b8f22", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -591,7 +591,7 @@ print_value (buf, x, verbose)\n     case SUBREG:\n       print_value (t, SUBREG_REG (x), verbose);\n       cur = safe_concat (buf, cur, t);\n-      sprintf (t, \"#%d\", SUBREG_WORD (x));\n+      sprintf (t, \"#%d\", SUBREG_BYTE (x));\n       cur = safe_concat (buf, cur, t);\n       break;\n     case SCRATCH:"}, {"sha": "dfccee06f796b8a38004368914839dc756535eef", "filename": "gcc/sdbout.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -776,19 +776,15 @@ sdbout_symbol (decl, local)\n       else if (GET_CODE (value) == SUBREG)\n \t{\n \t  int offset = 0;\n+\n \t  while (GET_CODE (value) == SUBREG)\n-\t    {\n-\t      offset += SUBREG_WORD (value);\n-\t      value = SUBREG_REG (value);\n-\t    }\n+\t    value = SUBREG_REG (value);\n \t  if (GET_CODE (value) == REG)\n \t    {\n-\t      regno = REGNO (value);\n-\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t      if (REGNO (value) >= FIRST_PSEUDO_REGISTER)\n \t\treturn;\n-\t      regno += offset;\n \t    }\n-\t  alter_subreg (DECL_RTL (decl));\n+\t  regno = REGNO (alter_subreg (DECL_RTL (decl)));\n \t  value = DECL_RTL (decl);\n \t}\n       /* Don't output anything if an auto variable"}, {"sha": "e9c49dcffd41d931759673464f6b59a08f87e882", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -4166,7 +4166,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \t  if (mode == GET_MODE (x))\n \t    SET_DECL_RTL (decl_elt, x);\n \t  else\n-\t    SET_DECL_RTL (decl_elt, gen_rtx_SUBREG (mode, x, 0));\n+\t    SET_DECL_RTL (decl_elt, gen_lowpart_SUBREG (mode, x));\n \t}\n       else\n \tabort ();"}, {"sha": "1956979f1bde80830c10df98cd62da0c73a19b5e", "filename": "gcc/tm.texi", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=ddef6bc7a3c885433f0b8a611cdbb4bef0ce4bc3", "patch": "@@ -1697,17 +1697,6 @@ definition of this macro is\n     / UNITS_PER_WORD)\n @end smallexample\n \n-@findex ALTER_HARD_SUBREG\n-@item ALTER_HARD_SUBREG (@var{tgt_mode}, @var{word}, @var{src_mode}, @var{regno})\n-A C expression that returns an adjusted hard register number for \n-\n-@smallexample\n-(subreg:@var{tgt_mode} (reg:@var{src_mode} @var{regno}) @var{word})\n-@end smallexample\n-\n-This may be needed if the target machine has mixed sized big-endian\n-registers, like Sparc v9.\n-\n @findex HARD_REGNO_MODE_OK\n @item HARD_REGNO_MODE_OK (@var{regno}, @var{mode})\n A C expression that is nonzero if it is permissible to store a value\n@@ -1790,6 +1779,19 @@ allocation.\n Define this macro if the compiler should avoid copies to/from @code{CCmode}\n registers.  You should only define this macro if support for copying to/from\n @code{CCmode} is incomplete.\n+\n+@findex SUBREG_REGNO_OFFSET\n+@item SUBREG_REGNO_OFFSET\n+Define this macro if the compiler needs to handle subregs in a non-standard\n+way.  The macro returns the correct regno offset for mode @code{YMODE} given\n+a subreg of type @code{XMODE}.\n+This macro takes 4 parameters:\n+@code{XREGNO} - A regno of an inner hard subreg_reg (or what will become one).\n+@code{XMODE}  - The mode of xregno.\n+@code{OFFSET} - The byte offset.\n+@code{YMODE} - The mode of a top level SUBREG (or what may become one).\n+The default function can be found in rtlanal.c, function \n+@code{subreg_regno_offset}. Normally this does not need to be defined.\n @end table\n \n @node Leaf Functions"}]}