{"sha": "0d4d227907e64eae08255f7f993e9bd0820b9d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0ZDIyNzkwN2U2NGVhZTA4MjU1ZjdmOTkzZTliZDA4MjBiOWQ2Nw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-08-05T19:50:54Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-08-05T19:50:54Z"}, "message": "Method.java: Updated status comment.\n\n\t* java/lang/reflect/Method.java: Updated status comment.\n\tImported javadoc from Classpath and re-ordered methods.\n\t* java/lang/reflect/Constructor.java: Reindented.  Updated\n\tstatus comment.  Imported javadoc from Classpath and re-ordered\n\tmethods.\n\nFrom-SVN: r70184", "tree": {"sha": "295de247d5c4dcc7d509558f9fafd8fcca1b3951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/295de247d5c4dcc7d509558f9fafd8fcca1b3951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d4d227907e64eae08255f7f993e9bd0820b9d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4d227907e64eae08255f7f993e9bd0820b9d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4d227907e64eae08255f7f993e9bd0820b9d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4d227907e64eae08255f7f993e9bd0820b9d67/comments", "author": null, "committer": null, "parents": [{"sha": "10063dff3bda495f3d76c414a3f6b6dd846f9700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10063dff3bda495f3d76c414a3f6b6dd846f9700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10063dff3bda495f3d76c414a3f6b6dd846f9700"}], "stats": {"total": 472, "additions": 357, "deletions": 115}, "files": [{"sha": "be7d6505378e4c5bd701acd31836ea55eae8eaea", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0d4d227907e64eae08255f7f993e9bd0820b9d67", "patch": "@@ -1,3 +1,11 @@\n+2003-08-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/reflect/Method.java: Updated status comment.\n+\tImported javadoc from Classpath and re-ordered methods.\n+\t* java/lang/reflect/Constructor.java: Reindented.  Updated\n+\tstatus comment.  Imported javadoc from Classpath and re-ordered\n+\tmethods.\n+\n 2003-08-05  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GtkComponentPeer.java (postKeyEvent):"}, {"sha": "53db35a6975d3086fadb104ab3373e96ffad6abe", "filename": "libjava/java/lang/reflect/Constructor.java", "status": "modified", "additions": 172, "deletions": 64, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FConstructor.java?ref=0d4d227907e64eae08255f7f993e9bd0820b9d67", "patch": "@@ -1,6 +1,6 @@\n // Constructor.java - Represents a constructor for a class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,88 +11,196 @@\n package java.lang.reflect;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date December 12, 1998\n+ * The Constructor class represents a constructor of a class. It also allows\n+ * dynamic creation of an object, via reflection. Invocation on Constructor\n+ * objects knows how to do widening conversions, but throws\n+ * {@link IllegalArgumentException} if a narrowing conversion would be\n+ * necessary. You can query for information on this Constructor regardless\n+ * of location, but construction access may be limited by Java language\n+ * access controls. If you can't do it in the compiler, you can't normally\n+ * do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @see Member\n+ * @see Class\n+ * @see java.lang.Class#getConstructor(Object[])\n+ * @see java.lang.Class#getDeclaredConstructor(Object[])\n+ * @see java.lang.Class#getConstructors()\n+ * @see java.lang.Class#getDeclaredConstructors()\n+ * @since 1.1\n+ * @status updated to 1.4\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Incomplete: needs a private constructor, and\n- *          newInstance() needs to be written.\n- */\n-\n public final class Constructor extends AccessibleObject implements Member\n {\n-  public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof Constructor))\n-\treturn false;\n-      Constructor c = (Constructor) obj;\n-      return declaringClass == c.declaringClass && offset == c.offset;\n-    }\n+  /**\n+   * This class is uninstantiable except from native code.\n+   */\n+  private Constructor ()\n+  {\n+  }\n \n+  /**\n+   * Gets the class that declared this constructor.\n+   * @return the class that declared this member\n+   */\n   public Class getDeclaringClass ()\n-    {\n-      return declaringClass;\n-    }\n-\n-  public Class[] getExceptionTypes ()\n-    {\n-      if (exception_types == null)\n-        getType();\n-      return (Class[]) exception_types.clone();\n-    }\n-\n-  public native int getModifiers ();\n+  {\n+    return declaringClass;\n+  }\n \n+  /**\n+   * Gets the name of this constructor (the non-qualified name of the class\n+   * it was declared in).\n+   * @return the name of this constructor\n+   */\n   public String getName ()\n   {\n     return declaringClass.getName();\n   }\n \n+  /**\n+   * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>\n+   * class to interpret the values. A constructor can only have a subset of the\n+   * following modifiers: public, private, protected.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n+  public native int getModifiers ();\n+\n+  /**\n+   * Get the parameter list for this constructor, in declaration order. If the\n+   * constructor takes no parameters, returns a 0-length array (not null).\n+   *\n+   * @return a list of the types of the constructor's parameters\n+   */\n   public Class[] getParameterTypes ()\n-    {\n-      if (parameter_types == null)\n-\tgetType ();\n-      return (Class[]) parameter_types.clone();\n-    }\n+  {\n+    if (parameter_types == null)\n+      getType ();\n+    return (Class[]) parameter_types.clone();\n+  }\n \n+  /**\n+   * Get the exception types this constructor says it throws, in no particular\n+   * order. If the constructor has no throws clause, returns a 0-length array\n+   * (not null).\n+   *\n+   * @return a list of the types in the constructor's throws clause\n+   */\n+  public Class[] getExceptionTypes ()\n+  {\n+    if (exception_types == null)\n+      getType();\n+    return (Class[]) exception_types.clone();\n+  }\n+\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Constructors are semantically equivalent if they have the same\n+   * declaring class and the same parameter list.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not.\n+   */\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof Constructor))\n+      return false;\n+    Constructor c = (Constructor) obj;\n+    return declaringClass == c.declaringClass && offset == c.offset;\n+  }\n+\n+  /**\n+   * Get the hash code for the Constructor.\n+   *\n+   * @return the hash code for the object\n+   */\n   public int hashCode ()\n-    {\n-      // FIXME.\n-      return getName().hashCode() + declaringClass.getName().hashCode();\n-    }\n+  {\n+    // FIXME.\n+    return getName().hashCode() + declaringClass.getName().hashCode();\n+  }\n \n-  // Update cached values from method descriptor in class.\n-  private native void getType ();\n+  /**\n+   * Get a String representation of the Constructor. A Constructor's String\n+   * representation is \"&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)\n+   * throws &lt;exceptions&gt;\", where everything after ')' is omitted if\n+   * there are no exceptions.<br> Example:\n+   * <code>public java.io.FileInputStream(java.lang.Runnable)\n+   * throws java.io.FileNotFoundException</code>\n+   *\n+   * @return the String representation of the Constructor\n+   */\n+  public String toString ()\n+  {\n+    if (parameter_types == null)\n+      getType ();\n+    StringBuffer b = new StringBuffer ();\n+    Modifier.toString(getModifiers(), b);\n+    b.append(\" \");\n+    Method.appendClassName (b, declaringClass);\n+    b.append(\"(\");\n+    for (int i = 0; i < parameter_types.length; ++i)\n+      {\n+\tMethod.appendClassName (b, parameter_types[i]);\n+\tif (i < parameter_types.length - 1)\n+\t  b.append(\",\");\n+      }\n+    b.append(\")\");\n+    return b.toString();\n+  }\n \n+  /**\n+   * Create a new instance by invoking the constructor. Arguments are\n+   * automatically unwrapped and widened, if needed.<p>\n+   *\n+   * If this class is abstract, you will get an\n+   * <code>InstantiationException</code>. If the constructor takes 0\n+   * arguments, you may use null or a 0-length array for <code>args</code>.<p>\n+   *\n+   * If this Constructor enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not create this object in similar compiled code. If the class\n+   * is uninitialized, you trigger class initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Then, the constructor is invoked. If it completes normally, the return\n+   * value will be the new object. If it completes abruptly, the exception is\n+   * wrapped in an <code>InvocationTargetException</code>.\n+   *\n+   * @param args the arguments to the constructor\n+   * @return the newly created object\n+   * @throws IllegalAccessException if the constructor could not normally be\n+   *         called by the Java code (i.e. it is not public)\n+   * @throws IllegalArgumentException if the number of arguments is incorrect;\n+   *         or if the arguments types are wrong even with a widening\n+   *         conversion\n+   * @throws InstantiationException if the class is abstract\n+   * @throws InvocationTargetException if the constructor throws an exception\n+   * @throws ExceptionInInitializerError if construction triggered class\n+   *         initialization, which then failed\n+   */\n   public native Object newInstance (Object[] args)\n     throws InstantiationException, IllegalAccessException,\n-           IllegalArgumentException, InvocationTargetException;\n+    IllegalArgumentException, InvocationTargetException;\n \n-  public String toString ()\n-    {\n-      if (parameter_types == null)\n-\tgetType ();\n-      StringBuffer b = new StringBuffer ();\n-      Modifier.toString(getModifiers(), b);\n-      b.append(\" \");\n-      Method.appendClassName (b, declaringClass);\n-      b.append(\"(\");\n-      for (int i = 0; i < parameter_types.length; ++i)\n-\t{\n-\t  Method.appendClassName (b, parameter_types[i]);\n-\t  if (i < parameter_types.length - 1)\n-\t    b.append(\",\");\n-\t}\n-      b.append(\")\");\n-      return b.toString();\n-    }\n-\n-  // Can't create these.\n-  private Constructor ()\n-    {\n-    }\n+  // Update cached values from method descriptor in class.\n+  private native void getType ();\n \n   // Declaring class.\n   private Class declaringClass;"}, {"sha": "3e0507fcaa15b82a7303e6145e7b8145f14490bb", "filename": "libjava/java/lang/reflect/Method.java", "status": "modified", "additions": 177, "deletions": 51, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4d227907e64eae08255f7f993e9bd0820b9d67/libjava%2Fjava%2Flang%2Freflect%2FMethod.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FMethod.java?ref=0d4d227907e64eae08255f7f993e9bd0820b9d67", "patch": "@@ -1,6 +1,6 @@\n // Method.java - Represent method of class or interface.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -13,87 +13,150 @@\n import gnu.gcj.RawData;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date December 12, 1998\n+ * The Method class represents a member method of a class. It also allows\n+ * dynamic invocation, via reflection. This works for both static and\n+ * instance methods. Invocation on Method objects knows how to do\n+ * widening conversions, but throws {@link IllegalArgumentException} if\n+ * a narrowing conversion would be necessary. You can query for information\n+ * on this Method regardless of location, but invocation access may be limited\n+ * by Java language access controls. If you can't do it in the compiler, you\n+ * can't normally do it here either.<p>\n+ *\n+ * <B>Note:</B> This class returns and accepts types as Classes, even\n+ * primitive types; there are Class types defined that represent each\n+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,\n+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,\n+ * byte.class</code>, etc.  These are not to be confused with the\n+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are\n+ * real classes.<p>\n+ *\n+ * Also note that this is not a serializable class.  It is entirely feasible\n+ * to make it serializable using the Externalizable interface, but this is\n+ * on Sun, not me.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @see Member\n+ * @see Class\n+ * @see java.lang.Class#getMethod(String,Object[])\n+ * @see java.lang.Class#getDeclaredMethod(String,Object[])\n+ * @see java.lang.Class#getMethods()\n+ * @see java.lang.Class#getDeclaredMethods()\n+ * @since 1.1\n+ * @status updated to 1.4\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Complete, but not correct: access checks aren't done.\n- */\n-\n public final class Method extends AccessibleObject implements Member\n {\n-  public boolean equals (Object obj)\n+  /**\n+   * This class is uninstantiable.\n+   */\n+  private Method ()\n   {\n-    if (! (obj instanceof Method))\n-      return false;\n-    Method m = (Method) obj;\n-    return declaringClass == m.declaringClass && offset == m.offset;\n   }\n \n+  /**\n+   * Gets the class that declared this method, or the class where this method\n+   * is a non-inherited member.\n+   * @return the class that declared this member\n+   */\n   public Class getDeclaringClass ()\n   {\n     return declaringClass;\n   }\n \n-  public Class[] getExceptionTypes ()\n-  {\n-    if (exception_types == null)\n-      getType();\n-    return (Class[]) exception_types.clone();\n-  }\n+  /**\n+   * Gets the name of this method.\n+   * @return the name of this method\n+   */\n+  public native String getName ();\n \n+  /**\n+   * Gets the modifiers this method uses.  Use the <code>Modifier</code>\n+   * class to interpret the values.  A method can only have a subset of the\n+   * following modifiers: public, private, protected, abstract, static,\n+   * final, synchronized, native, and strictfp.\n+   *\n+   * @return an integer representing the modifiers to this Member\n+   * @see Modifier\n+   */\n   public native int getModifiers ();\n \n-  public native String getName ();\n-\n-  private native void getType ();\n+  /**\n+   * Gets the return type of this method.\n+   * @return the type of this method\n+   */\n+  public Class getReturnType ()\n+  {\n+    if (return_type == null)\n+      getType();\n+    return return_type;\n+  }\n \n+  /**\n+   * Get the parameter list for this method, in declaration order. If the\n+   * method takes no parameters, returns a 0-length array (not null).\n+   *\n+   * @return a list of the types of the method's parameters\n+   */\n   public Class[] getParameterTypes ()\n   {\n     if (parameter_types == null)\n       getType();\n     return (Class[]) parameter_types.clone();\n   }\n \n-  public Class getReturnType ()\n+  /**\n+   * Get the exception types this method says it throws, in no particular\n+   * order. If the method has no throws clause, returns a 0-length array\n+   * (not null).\n+   *\n+   * @return a list of the types in the method's throws clause\n+   */\n+  public Class[] getExceptionTypes ()\n   {\n-    if (return_type == null)\n+    if (exception_types == null)\n       getType();\n-    return return_type;\n+    return (Class[]) exception_types.clone();\n   }\n \n-  public int hashCode ()\n+  /**\n+   * Compare two objects to see if they are semantically equivalent.\n+   * Two Methods are semantically equivalent if they have the same declaring\n+   * class, name, and parameter list.  This ignores different exception\n+   * clauses or return types.\n+   *\n+   * @param o the object to compare to\n+   * @return <code>true</code> if they are equal; <code>false</code> if not\n+   */\n+  public boolean equals (Object obj)\n   {\n-    // FIXME.\n-    return getName().hashCode() + declaringClass.getName().hashCode();\n+    if (! (obj instanceof Method))\n+      return false;\n+    Method m = (Method) obj;\n+    return declaringClass == m.declaringClass && offset == m.offset;\n   }\n \n-  public native Object invoke (Object obj, Object[] args)\n-    throws IllegalAccessException, IllegalArgumentException,\n-    InvocationTargetException;\n-\n-  // Append a class name to a string buffer.  We try to print the\n-  // fully-qualified name, the way that a Java programmer would expect\n-  // it to be written.  Weirdly, Class has no appropriate method for\n-  // this.\n-  static void appendClassName (StringBuffer buf, Class k)\n+  /**\n+   * Get the hash code for the Method.\n+   *\n+   * @return the hash code for the object\n+   */\n+  public int hashCode ()\n   {\n-    if (k.isArray ())\n-      {\n-\tappendClassName (buf, k.getComponentType ());\n-\tbuf.append (\"[]\");\n-      }\n-    else\n-      {\n-\t// This is correct for primitive and reference types.  Really\n-\t// we'd like `Main$Inner' to be printed as `Main.Inner', I\n-\t// think, but that is a pain.\n-\tbuf.append (k.getName ());\n-      }\n+    // FIXME.\n+    return getName().hashCode() + declaringClass.getName().hashCode();\n   }\n \n+  /**\n+   * Get a String representation of the Method. A Method's String\n+   * representation is \"&lt;modifiers&gt; &lt;returntype&gt;\n+   * &lt;methodname&gt;(&lt;paramtypes&gt;) throws &lt;exceptions&gt;\", where\n+   * everything after ')' is omitted if there are no exceptions.<br> Example:\n+   * <code>public static int run(java.lang.Runnable,int)</code>\n+   *\n+   * @return the String representation of the Method\n+   */\n   public String toString ()\n   {\n     if (parameter_types == null)\n@@ -128,8 +191,71 @@ public String toString ()\n     return b.toString();\n   }\n \n-  private Method ()\n+  /**\n+   * Invoke the method. Arguments are automatically unwrapped and widened,\n+   * and the result is automatically wrapped, if needed.<p>\n+   *\n+   * If the method is static, <code>o</code> will be ignored. Otherwise,\n+   * the method uses dynamic lookup as described in JLS 15.12.4.4. You cannot\n+   * mimic the behavior of nonvirtual lookup (as in super.foo()). This means\n+   * you will get a <code>NullPointerException</code> if <code>o</code> is\n+   * null, and an <code>IllegalArgumentException</code> if it is incompatible\n+   * with the declaring class of the method. If the method takes 0 arguments,\n+   * you may use null or a 0-length array for <code>args</code>.<p>\n+   *\n+   * Next, if this Method enforces access control, your runtime context is\n+   * evaluated, and you may have an <code>IllegalAccessException</code> if\n+   * you could not acces this method in similar compiled code. If the method\n+   * is static, and its class is uninitialized, you trigger class\n+   * initialization, which may end in a\n+   * <code>ExceptionInInitializerError</code>.<p>\n+   *\n+   * Finally, the method is invoked. If it completes normally, the return value\n+   * will be null for a void method, a wrapped object for a primitive return\n+   * method, or the actual return of an Object method. If it completes\n+   * abruptly, the exception is wrapped in an\n+   * <code>InvocationTargetException</code>.\n+   *\n+   * @param o the object to invoke the method on\n+   * @param args the arguments to the method\n+   * @return the return value of the method, wrapped in the appropriate\n+   *         wrapper if it is primitive\n+   * @throws IllegalAccessException if the method could not normally be called\n+   *         by the Java code (i.e. it is not public)\n+   * @throws IllegalArgumentException if the number of arguments is incorrect;\n+   *         if the arguments types are wrong even with a widening conversion;\n+   *         or if <code>o</code> is not an instance of the class or interface\n+   *         declaring this method\n+   * @throws InvocationTargetException if the method throws an exception\n+   * @throws NullPointerException if <code>o</code> is null and this field\n+   *         requires an instance\n+   * @throws ExceptionInInitializerError if accessing a static method triggered\n+   *         class initialization, which then failed\n+   */\n+  public native Object invoke (Object obj, Object[] args)\n+    throws IllegalAccessException, IllegalArgumentException,\n+    InvocationTargetException;\n+\n+  private native void getType ();\n+\n+  // Append a class name to a string buffer.  We try to print the\n+  // fully-qualified name, the way that a Java programmer would expect\n+  // it to be written.  Weirdly, Class has no appropriate method for\n+  // this.\n+  static void appendClassName (StringBuffer buf, Class k)\n   {\n+    if (k.isArray ())\n+      {\n+\tappendClassName (buf, k.getComponentType ());\n+\tbuf.append (\"[]\");\n+      }\n+    else\n+      {\n+\t// This is correct for primitive and reference types.  Really\n+\t// we'd like `Main$Inner' to be printed as `Main.Inner', I\n+\t// think, but that is a pain.\n+\tbuf.append (k.getName ());\n+      }\n   }\n \n   // Declaring class."}]}