{"sha": "9373164a48dc470b44c1ec9431213ce8c06323e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM3MzE2NGE0OGRjNDcwYjQ0YzFlYzk0MzEyMTNjZThjMDYzMjNlNQ==", "commit": {"author": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-10-31T01:08:43Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-10-31T01:08:43Z"}, "message": "C90 prototype updates.\n\nFrom-SVN: r73113", "tree": {"sha": "ee92d17300eb95b03e9b66263bbb9e1407851aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee92d17300eb95b03e9b66263bbb9e1407851aa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9373164a48dc470b44c1ec9431213ce8c06323e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9373164a48dc470b44c1ec9431213ce8c06323e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9373164a48dc470b44c1ec9431213ce8c06323e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9373164a48dc470b44c1ec9431213ce8c06323e5/comments", "author": null, "committer": null, "parents": [{"sha": "6587cd2b21cd246a7a2986e4d7f400a5d4e25a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6587cd2b21cd246a7a2986e4d7f400a5d4e25a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6587cd2b21cd246a7a2986e4d7f400a5d4e25a4b"}], "stats": {"total": 1793, "additions": 701, "deletions": 1092}, "files": [{"sha": "822ff441dbf51fa4280e4dc6abb29710fb1455fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -1,3 +1,7 @@\n+2003-10-30 Kelley Cook <kcook@gcc.gnu.org>\n+\n+\t* value-prof.c, web.c: Update to C90.\n+\n 2003-10-30  Eric Christopher  <echristo@redhat.com>\n \n \t* function.c (purge_addressof_1): Add case for REG_RETVAL\n@@ -16,7 +20,8 @@\n \t* real.c (encode_ieee_extended): Initialize whole array.\n \t* reg-stack.c (move_for_stack_reg0: Use always XFmode.\n \t* i386-modes.def: Change definitions of TFmode and XFmode.\n-\t* i386.c (classify_argument): Rename TFmodes to XFmodes; add new TFmode code.\n+\t* i386.c (classify_argument): Rename TFmodes to XFmodes; add new TFmode\n+\tcode.\n \t(construct_container): Allow constructing of TFmode integer containers.\n \t(ix86_return_in_memory):  XFmode is not returned in memory.\n \t(init_ext_80387_constants): Always use XFmode."}, {"sha": "40e7313edfdd20b9dbf08e258019a65c76b0eedb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -1,3 +1,11 @@\n+2003-10-30  Kelley Cook  <kcook@gcc.gnu.org>\n+\n+\t* adadecode.c, adaint.c, argv.c, aux-io.c, cal.c, cio.c, cstreams.c,\n+\tctrl_c.c, cuintp.c, decl.c, errno.c, exit.c, expect.c, final.c,\n+\tgigi.h, gmem.c, gnatbl.c, init.c, misc.c, mkdir.c, raise.c, socket.c,\n+\tsysdep.c, sysdep.c, targtyps.c, tb-alvms.c, tb-alvxw.c, tracebak.c,\n+\ttrans.c, utils.c, utils2.c: Convert function prototypes to C90.\n+\n 2003-10-30  Vasiliy Fofanov  <fofanov@act-europe.fr>\n \n \t* 3vtrasym.adb: "}, {"sha": "8f685126d14ada4a5fc327a54ef84015c0b9e299", "filename": "gcc/ada/adadecode.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fadadecode.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fadadecode.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadadecode.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -41,9 +41,9 @@\n #include \"ctype.h\"\n #include \"adadecode.h\"\n \n-static void add_verbose\tPARAMS ((const char *, char *));\n-static int has_prefix\tPARAMS ((const char *, const char *));\n-static int has_suffix\tPARAMS ((const char *, const char *));\n+static void add_verbose (const char *, char *);\n+static int has_prefix (const char *, const char *);\n+static int has_suffix (const char *, const char *);\n \n /* This is a safe version of strcpy that can be used with overlapped\n    pointers. Does nothing if s2 <= s1.  */\n@@ -55,9 +55,7 @@ static int verbose_info;\n /* Add TEXT to end of ADA_NAME, putting a leading \" (\" or \", \", depending\n    on VERBOSE_INFO.  */\n \n-static void add_verbose (text, ada_name)\n-     const char *text;\n-     char *ada_name;\n+static void add_verbose (const char *text, char *ada_name)\n {\n   strcat (ada_name, verbose_info ? \", \" : \" (\");\n   strcat (ada_name, text);\n@@ -68,19 +66,15 @@ static void add_verbose (text, ada_name)\n /* Returns 1 if NAME starts with PREFIX.  */\n \n static int\n-has_prefix (name, prefix)\n-     const char *name;\n-     const char *prefix;\n+has_prefix (const char *name, const char *prefix)\n {\n   return strncmp (name, prefix, strlen (prefix)) == 0;\n }\n \n /* Returns 1 if NAME ends with SUFFIX.  */\n \n static int\n-has_suffix (name, suffix)\n-     const char *name;\n-     const char *suffix;\n+has_suffix (const char *name, const char *suffix)\n {\n   int nlen = strlen (name);\n   int slen = strlen (suffix);\n@@ -147,10 +141,7 @@ ostrcpy (char *s1, char *s2)\n   x__Oexpon               \"**\"     */\n \n void\n-__gnat_decode (coded_name, ada_name, verbose)\n-     const char *coded_name;\n-     char *ada_name;\n-     int verbose;\n+__gnat_decode (const char *coded_name, char *ada_name, int verbose)\n {\n   int lib_subprog = 0;\n   int overloaded = 0;\n@@ -322,8 +313,7 @@ __gnat_decode (coded_name, ada_name, verbose)\n }\n \n char *\n-ada_demangle (coded_name)\n-     const char *coded_name;\n+ada_demangle (const char *coded_name)\n {\n   char ada_name[2048];\n "}, {"sha": "cbaf1d7dff31f54e97f0daaeb1cac3704d870e69", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -425,7 +425,7 @@ __gnat_try_lock (char *dir, char *file)\n /* Return the maximum file name length.  */\n \n int\n-__gnat_get_maximum_file_name_length ()\n+__gnat_get_maximum_file_name_length (void)\n {\n #if defined (MSDOS)\n   return 8;\n@@ -442,7 +442,7 @@ __gnat_get_maximum_file_name_length ()\n /* Return nonzero if file names are case sensitive.  */\n \n int\n-__gnat_get_file_names_case_sensitive ()\n+__gnat_get_file_names_case_sensitive (void)\n {\n #if defined (__EMX__) || defined (MSDOS) || defined (VMS) || defined (WINNT)\n   return 0;\n@@ -452,7 +452,7 @@ __gnat_get_file_names_case_sensitive ()\n }\n \n char\n-__gnat_get_default_identifier_character_set ()\n+__gnat_get_default_identifier_character_set (void)\n {\n #if defined (__EMX__) || defined (MSDOS)\n   return 'p';\n@@ -782,7 +782,7 @@ __gnat_readdir (DIR *dirp, char *buffer)\n /* Returns 1 if readdir is thread safe, 0 otherwise.  */\n \n int\n-__gnat_readdir_is_thread_safe ()\n+__gnat_readdir_is_thread_safe (void)\n {\n #ifdef HAVE_READDIR_R\n   return 1;\n@@ -1270,7 +1270,7 @@ __gnat_set_env_value (char *name, char *value)\n    key.  */\n \n char *\n-__gnat_get_libraries_from_registry ()\n+__gnat_get_libraries_from_registry (void)\n {\n   char *result = (char *) \"\";\n \n@@ -2299,13 +2299,13 @@ __gnat_to_canonical_file_list_init\n }\n \n char *\n-__gnat_to_canonical_file_list_next ()\n+__gnat_to_canonical_file_list_next (void)\n {\n   return (char *) \"\";\n }\n \n void\n-__gnat_to_canonical_file_list_free ()\n+__gnat_to_canonical_file_list_free (void)\n {\n }\n \n@@ -2340,7 +2340,7 @@ __gnat_to_host_file_spec (char *filespec)\n }\n \n void\n-__gnat_adjust_os_resource_limits ()\n+__gnat_adjust_os_resource_limits (void)\n {\n }\n \n@@ -2458,9 +2458,8 @@ extern void __gnat_install_locks (void (*) (void), void (*) (void));\n    locking subprograms for libgcc_eh. */\n \n void\n-__gnatlib_install_locks (lock, unlock)\n-     void (*lock) (void) ATTRIBUTE_UNUSED;\n-     void (*unlock) (void) ATTRIBUTE_UNUSED;\n+__gnatlib_install_locks (void (*lock) (void) ATTRIBUTE_UNUSED,\n+                         void (*unlock) (void) ATTRIBUTE_UNUSED)\n {\n #ifdef IN_RTS\n   __gnat_install_locks (lock, unlock);"}, {"sha": "b62011c2bef721065a277906baf746b27a20ce08", "filename": "gcc/ada/argv.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fargv.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -71,28 +71,25 @@ const char **gnat_envp = (const char **) 0;\n #endif\n \n int\n-__gnat_arg_count ()\n+__gnat_arg_count (void)\n {\n   return gnat_argc;\n }\n \n int\n-__gnat_len_arg (arg_num)\n-   int arg_num;\n+__gnat_len_arg (int arg_num)\n {\n   return strlen (gnat_argv[arg_num]);\n }\n \n void\n-__gnat_fill_arg (a, i)\n-   char *a;\n-   int i;\n+__gnat_fill_arg ( char *a, int i)\n {\n   strncpy (a, gnat_argv[i], strlen(gnat_argv[i]));\n }\n \n int\n-__gnat_env_count ()\n+__gnat_env_count (void)\n {\n   int i;\n \n@@ -102,16 +99,13 @@ __gnat_env_count ()\n }\n \n int\n-__gnat_len_env (env_num)\n-   int env_num;\n+__gnat_len_env (int env_num)\n {\n   return strlen (gnat_envp[env_num]);\n }\n \n void\n-__gnat_fill_env (a, i)\n-   char *a;\n-   int i;\n+__gnat_fill_env (char *a, int i)\n {\n   strncpy (a, gnat_envp[i], strlen (gnat_envp[i]));\n }"}, {"sha": "333485d6309c5c5e02f161a12370967b3900b289", "filename": "gcc/ada/aux-io.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Faux-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Faux-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faux-io.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -43,28 +43,28 @@\n /* Function wrappers are needed to access the values from Ada which are\n    defined as C macros.  */\n \n-FILE *c_stdin         PARAMS ((void));\n-FILE *c_stdout        PARAMS ((void));\n-FILE *c_stderr        PARAMS ((void));\n-int seek_set_function PARAMS ((void));\n-int seek_end_function PARAMS ((void));\n-void *null_function   PARAMS ((void));\n-int c_fileno          PARAMS ((FILE *));\n+FILE *c_stdin (void);\n+FILE *c_stdout (void);\n+FILE *c_stderr (void);\n+int seek_set_function (void);\n+int seek_end_function (void);\n+void *null_function (void);\n+int c_fileno (FILE *);\n \n FILE *\n-c_stdin () \n+c_stdin (void) \n { \n   return stdin; \n }\n \n FILE *\n-c_stdout () \n+c_stdout (void) \n { \n   return stdout;\n }\n \n FILE *\n-c_stderr () \n+c_stderr (void) \n { \n   return stderr;\n }\n@@ -76,25 +76,24 @@ c_stderr ()\n #endif\n \n int   \n-seek_set_function ()  \n+seek_set_function (void)  \n { \n   return SEEK_SET; \n }\n \n int   \n-seek_end_function ()  \n+seek_end_function (void)  \n { \n   return SEEK_END; \n }\n \n-void *null_function ()  \n+void *null_function (void)  \n { \n   return NULL;     \n }\n \n int \n-c_fileno (s) \n-     FILE *s;\n+c_fileno (FILE *s) \n { \n   return fileno (s); \n }"}, {"sha": "7f136d6ff1244eb2ccf0ae8c8bebe0f3c43389e6", "filename": "gcc/ada/cal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcal.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -94,7 +94,7 @@ __gnat_duration_to_timeval (long sec, long usec, struct timeval *t)\n    what time_t is on the target.  */\n \n long\n-gnat_time ()\n+gnat_time (void)\n {\n   return time (0);\n }"}, {"sha": "8e4c7cba596b412ee29ebcb5e2fb35fb9b85b44d", "filename": "gcc/ada/cio.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcio.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -52,7 +52,7 @@\n #endif\n \n int\n-get_char ()\n+get_char (void)\n {\n #ifdef VMS\n   return decc$getchar();\n@@ -62,7 +62,7 @@ get_char ()\n }\n \n int\n-get_int ()\n+get_int (void)\n {\n   int x;\n \n@@ -71,40 +71,35 @@ get_int ()\n }\n \n void\n-put_int (x)\n-     int x;\n+put_int (int x)\n {\n    /* Use fprintf rather than printf, since the latter is unbuffered\n       on vxworks */\n    fprintf (stdout, \"%d\", x);\n }\n \n void\n-put_int_stderr (x)\n-   int x;\n+put_int_stderr (int x)\n {\n   fprintf (stderr, \"%d\", x);\n }\n \n void\n-put_char (c)\n-     int c;\n+put_char (int c)\n {\n   putchar (c);\n }\n \n void\n-put_char_stderr (c)\n-     int c;\n+put_char_stderr (int c)\n {\n   fputc (c, stderr);\n }\n \n #ifdef __vxworks\n \n char *\n-mktemp (template)\n-     char *template;\n+mktemp (char *template)\n {\n   return tmpnam (NULL);\n }"}, {"sha": "6db356b50a6ab163f11a6f0ce4727505e45910dd", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -76,29 +76,25 @@\n #endif\n \n int\n-__gnat_feof (stream)\n-     FILE *stream;\n+__gnat_feof (FILE *stream)\n {\n   return (feof (stream));\n }\n \n int\n-__gnat_ferror (stream)\n-     FILE *stream;\n+__gnat_ferror (FILE *stream)\n {\n    return (ferror (stream));\n }\n \n int\n-__gnat_fileno (stream)\n-     FILE *stream;\n+__gnat_fileno (FILE *stream)\n {\n    return (fileno (stream));\n }\n \n int\n-__gnat_is_regular_file_fd (fd)\n-     int fd;\n+__gnat_is_regular_file_fd (int fd)\n {\n   int ret;\n   struct stat statbuf;"}, {"sha": "20dd8811007c4e00cdb47cd8ad311c9486b18011", "filename": "gcc/ada/ctrl_c.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fctrl_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fctrl_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fctrl_c.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -132,7 +132,7 @@ __gnat_install_int_handler (void (*proc) (void))\n }\n \n void\n-__gnat_uninstall_int_handler ()\n+__gnat_uninstall_int_handler (void)\n {\n   if (sigint_intercepted != NULL)\n     SetConsoleCtrlHandler (__gnat_int_handler, FALSE);\n@@ -150,7 +150,7 @@ __gnat_install_int_handler (void (*proc) (void) __attribute__ ((unused)))\n }\n \n void\n-__gnat_uninstall_int_handler ()\n+__gnat_uninstall_int_handler (void)\n {\n }\n #endif"}, {"sha": "2c8967af8bfd50bcb1d5b93305c6667a560e1c80", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -57,9 +57,7 @@\n    resulting node.  */\n \n tree\n-UI_To_gnu (Input, type)\n-     Uint Input;\n-     tree type;\n+UI_To_gnu (Uint Input, tree type)\n {\n   tree gnu_ret;\n "}, {"sha": "028443fd91bc96175cf6d149a3c6a5f468e0abfe", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 94, "deletions": 157, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -82,42 +82,34 @@ static struct incomplete\n   Entity_Id full_type;\n } *defer_incomplete_list = 0;\n \n-static tree substitution_list\t\tPARAMS ((Entity_Id, Entity_Id,\n-\t\t\t\t\t\t tree, int));\n-static int allocatable_size_p\t\tPARAMS ((tree, int));\n-static struct attrib *build_attr_list\tPARAMS ((Entity_Id));\n-static tree elaborate_expression\tPARAMS ((Node_Id, Entity_Id, tree,\n-\t\t\t\t\t\t int, int, int));\n-static int is_variable_size\t\tPARAMS ((tree));\n-static tree elaborate_expression_1\tPARAMS ((Node_Id, Entity_Id, tree,\n-\t\t\t\t\t\t tree, int, int));\n-static tree make_packable_type\t\tPARAMS ((tree));\n-static tree maybe_pad_type\t\tPARAMS ((tree, tree, unsigned int,\n-\t\t\t\t\t\t Entity_Id, const char *, int,\n-\t\t\t\t\t\t int, int));\n-static tree gnat_to_gnu_field\t\tPARAMS ((Entity_Id, tree, int, int));\n-static void components_to_record\tPARAMS ((tree, Node_Id, tree, int,\n-\t\t\t\t\t\t int, tree *, int, int));\n-static int compare_field_bitpos\t\tPARAMS ((const PTR, const PTR));\n-static Uint annotate_value\t\tPARAMS ((tree));\n-static void annotate_rep\t\tPARAMS ((Entity_Id, tree));\n-static tree compute_field_positions\tPARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t unsigned int));\n-static tree validate_size\t\tPARAMS ((Uint, tree, Entity_Id,\n-\t\t\t\t\t\t enum tree_code, int, int));\n-static void set_rm_size\t\t\tPARAMS ((Uint, tree, Entity_Id));\n-static tree make_type_from_size\t\tPARAMS ((tree, tree, int));\n-static unsigned int validate_alignment\tPARAMS ((Uint, Entity_Id,\n-\t\t\t\t\t\t unsigned int));\n-static void check_ok_for_atomic\t\tPARAMS ((tree, Entity_Id, int));\n+static tree substitution_list (Entity_Id, Entity_Id, tree, int);\n+static int allocatable_size_p (tree, int);\n+static struct attrib *build_attr_list (Entity_Id);\n+static tree elaborate_expression (Node_Id, Entity_Id, tree, int, int, int);\n+static int is_variable_size (tree);\n+static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree, int, int);\n+static tree make_packable_type (tree);\n+static tree maybe_pad_type (tree, tree, unsigned int, Entity_Id, const char *,\n+                            int, int, int);\n+static tree gnat_to_gnu_field (Entity_Id, tree, int, int);\n+static void components_to_record (tree, Node_Id, tree, int, int, tree *,\n+                                  int, int);\n+static int compare_field_bitpos (const PTR, const PTR);\n+static Uint annotate_value (tree);\n+static void annotate_rep (Entity_Id, tree);\n+static tree compute_field_positions (tree, tree, tree, tree, unsigned int);\n+static tree validate_size (Uint, tree, Entity_Id, enum tree_code, int, int);\n+static void set_rm_size (Uint, tree, Entity_Id);\n+static tree make_type_from_size (tree, tree, int);\n+static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n+static void check_ok_for_atomic (tree, Entity_Id, int);\n \f\n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n    refer to an Ada type.  */\n \n tree\n-gnat_to_gnu_type (gnat_entity)\n-     Entity_Id gnat_entity;\n+gnat_to_gnu_type (Entity_Id gnat_entity)\n {\n   tree gnu_decl;\n \n@@ -146,10 +138,7 @@ gnat_to_gnu_type (gnat_entity)\n    the code.  */\n \n tree\n-gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n-     Entity_Id gnat_entity;\n-     tree gnu_expr;\n-     int definition;\n+gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n {\n   tree gnu_entity_id;\n   tree gnu_type = 0;\n@@ -4037,8 +4026,7 @@ gnat_to_gnu_entity (gnat_entity, gnu_expr, definition)\n    be elaborated at the point of its definition, but do nothing else.  */\n \n void\n-elaborate_entity (gnat_entity)\n-     Entity_Id gnat_entity;\n+elaborate_entity (Entity_Id gnat_entity)\n {\n   switch (Ekind (gnat_entity))\n     {\n@@ -4109,8 +4097,7 @@ elaborate_entity (gnat_entity)\n    any entities on its entity chain similarly.  */\n \n void\n-mark_out_of_scope (gnat_entity)\n-     Entity_Id gnat_entity;\n+mark_out_of_scope (Entity_Id gnat_entity)\n {\n   Entity_Id gnat_sub_entity;\n   unsigned int kind = Ekind (gnat_entity);\n@@ -4153,11 +4140,10 @@ mark_out_of_scope (gnat_entity)\n    DEFINITION is as in gnat_to_gnu_entity.  */\n \n static tree\n-substitution_list (gnat_subtype, gnat_type, gnu_list, definition)\n-     Entity_Id gnat_subtype;\n-     Entity_Id gnat_type;\n-     tree gnu_list;\n-     int definition;\n+substitution_list (Entity_Id gnat_subtype,\n+                   Entity_Id gnat_type,\n+                   tree gnu_list,\n+                   int definition)\n {\n   Entity_Id gnat_discrim;\n   Node_Id gnat_value;\n@@ -4191,7 +4177,7 @@ static GTY((length (\"max_gnat_nodes\"))) tree * dummy_node_table;\n /* Initialize the above table.  */\n \n void\n-init_dummy_type ()\n+init_dummy_type (void)\n {\n   Node_Id gnat_node;\n \n@@ -4206,8 +4192,7 @@ init_dummy_type ()\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n \n tree\n-make_dummy_type (gnat_type)\n-     Entity_Id gnat_type;\n+make_dummy_type (Entity_Id gnat_type)\n {\n   Entity_Id gnat_underlying;\n   tree gnu_type;\n@@ -4253,9 +4238,7 @@ make_dummy_type (gnat_type)\n    done with a static allocation.  */\n \n static int\n-allocatable_size_p (gnu_size, static_p)\n-     tree gnu_size;\n-     int static_p;\n+allocatable_size_p (tree gnu_size, int static_p)\n {\n   HOST_WIDE_INT our_size;\n \n@@ -4279,8 +4262,7 @@ allocatable_size_p (gnu_size, static_p)\n /* Return a list of attributes for GNAT_ENTITY, if any.  */\n \n static struct attrib *\n-build_attr_list (gnat_entity)\n-     Entity_Id gnat_entity;\n+build_attr_list (Entity_Id gnat_entity)\n {\n   struct attrib *attr_list = 0;\n   Node_Id gnat_temp;\n@@ -4352,8 +4334,7 @@ build_attr_list (gnat_entity)\n /* Get the unpadded version of a GNAT type.  */\n \n tree\n-get_unpadded_type (gnat_entity)\n-     Entity_Id gnat_entity;\n+get_unpadded_type (Entity_Id gnat_entity)\n {\n   tree type = gnat_to_gnu_type (gnat_entity);\n \n@@ -4366,9 +4347,7 @@ get_unpadded_type (gnat_entity)\n /* Called when we need to protect a variable object using a save_expr.  */\n \n tree\n-maybe_variable (gnu_operand, gnat_node)\n-     tree gnu_operand;\n-     Node_Id gnat_node;\n+maybe_variable (tree gnu_operand, Node_Id gnat_node)\n {\n   if (TREE_CONSTANT (gnu_operand) || TREE_READONLY (gnu_operand)\n       || TREE_CODE (gnu_operand) == SAVE_EXPR\n@@ -4397,14 +4376,12 @@ maybe_variable (gnu_operand, gnat_node)\n    purposes even if it isn't needed for code generation.  */\n \n static tree\n-elaborate_expression (gnat_expr, gnat_entity, gnu_name, definition,\n-\t\t      need_value, need_debug)\n-     Node_Id gnat_expr;\n-     Entity_Id gnat_entity;\n-     tree gnu_name;\n-     int definition;\n-     int need_value;\n-     int need_debug;\n+elaborate_expression (Node_Id gnat_expr,\n+                      Entity_Id gnat_entity,\n+                      tree gnu_name,\n+                      int definition,\n+                      int need_value,\n+                      int need_debug)\n {\n   tree gnu_expr;\n \n@@ -4439,14 +4416,12 @@ elaborate_expression (gnat_expr, gnat_entity, gnu_name, definition,\n /* Similar, but take a GNU expression.  */\n \n static tree\n-elaborate_expression_1 (gnat_expr, gnat_entity, gnu_expr, gnu_name, definition,\n-\t\t\tneed_debug)\n-     Node_Id gnat_expr;\n-     Entity_Id gnat_entity;\n-     tree gnu_expr;\n-     tree gnu_name;\n-     int definition;\n-     int need_debug;\n+elaborate_expression_1 (Node_Id gnat_expr,\n+                        Entity_Id gnat_entity,\n+                        tree gnu_expr,\n+                        tree gnu_name,\n+                        int definition,\n+                        int need_debug)\n {\n   tree gnu_decl = 0;\n   /* Strip any conversions to see if the expression is a readonly variable.\n@@ -4514,10 +4489,7 @@ elaborate_expression_1 (gnat_expr, gnat_entity, gnu_expr, gnu_name, definition,\n    position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n \n tree\n-make_aligning_type (type, align, size)\n-     tree type;\n-     int align;\n-     tree size;\n+make_aligning_type (tree type, int align, tree size)\n {\n   tree record_type = make_node (RECORD_TYPE);\n   tree place = build (PLACEHOLDER_EXPR, record_type);\n@@ -4568,8 +4540,7 @@ make_aligning_type (type, align, size)\n    return the new type.  If not, return the original type.  */\n \n static tree\n-make_packable_type (type)\n-     tree type;\n+make_packable_type (tree type)\n {\n   tree new_type = make_node (TREE_CODE (type));\n   tree field_list = NULL_TREE;\n@@ -4645,16 +4616,14 @@ make_packable_type (type)\n    type.  */\n \n static tree\n-maybe_pad_type (type, size, align, gnat_entity, name_trailer,\n-\t\tis_user_type, definition, same_rm_size)\n-     tree type;\n-     tree size;\n-     unsigned int align;\n-     Entity_Id gnat_entity;\n-     const char *name_trailer;\n-     int is_user_type;\n-     int definition;\n-     int same_rm_size;\n+maybe_pad_type (tree type,\n+                tree size,\n+                unsigned int align,\n+                Entity_Id gnat_entity,\n+                const char *name_trailer,\n+                int is_user_type,\n+                int definition,\n+                int same_rm_size)\n {\n   tree orig_size = TYPE_SIZE (type);\n   tree record;\n@@ -4830,9 +4799,7 @@ maybe_pad_type (type, size, align, gnat_entity, name_trailer,\n    the value passed against the list of choices.  */\n \n tree\n-choices_to_gnu (operand, choices)\n-     tree operand;\n-     Node_Id choices;\n+choices_to_gnu (tree operand, Node_Id choices)\n {\n   Node_Id choice;\n   Node_Id gnat_temp;\n@@ -4924,11 +4891,10 @@ choices_to_gnu (operand, choices)\n    DEFINITION is nonzero if this field is for a record being defined.  */\n \n static tree\n-gnat_to_gnu_field (gnat_field, gnu_record_type, packed, definition)\n-     Entity_Id gnat_field;\n-     tree gnu_record_type;\n-     int packed;\n-     int definition;\n+gnat_to_gnu_field (Entity_Id gnat_field,\n+                   tree gnu_record_type,\n+                   int packed,\n+                   int definition)\n {\n   tree gnu_field_id = get_entity_name (gnat_field);\n   tree gnu_field_type = gnat_to_gnu_type (Etype (gnat_field));\n@@ -5173,8 +5139,7 @@ gnat_to_gnu_field (gnat_field, gnu_record_type, packed, definition)\n    of variable size or is a record that has a field such a field.  */\n \n static int\n-is_variable_size (type)\n-     tree type;\n+is_variable_size (tree type)\n {\n   tree field;\n \n@@ -5229,16 +5194,14 @@ is_variable_size (type)\n    fields of the record and then the record type is finished.  */\n \n static void\n-components_to_record (gnu_record_type, component_list, gnu_field_list, packed,\n-\t\t      definition, p_gnu_rep_list, cancel_alignment, all_rep)\n-     tree gnu_record_type;\n-     Node_Id component_list;\n-     tree gnu_field_list;\n-     int packed;\n-     int definition;\n-     tree *p_gnu_rep_list;\n-     int cancel_alignment;\n-     int all_rep;\n+components_to_record (tree gnu_record_type,\n+                      Node_Id component_list,\n+                      tree gnu_field_list,\n+                      int packed,\n+                      int definition,\n+                      tree *p_gnu_rep_list,\n+                      int cancel_alignment,\n+                      int all_rep)\n {\n   Node_Id component_decl;\n   Entity_Id gnat_field;\n@@ -5502,9 +5465,7 @@ components_to_record (gnu_record_type, component_list, gnu_field_list, packed,\n    bit positions and ordinals of the two fields.  */\n \n static int\n-compare_field_bitpos (rt1, rt2)\n-     const PTR rt1;\n-     const PTR rt2;\n+compare_field_bitpos (const PTR rt1, const PTR rt2)\n {\n   tree *t1 = (tree *) rt1;\n   tree *t2 = (tree *) rt2;\n@@ -5524,8 +5485,7 @@ compare_field_bitpos (rt1, rt2)\n    in the GNAT tree.  */\n \n static Uint\n-annotate_value (gnu_size)\n-     tree gnu_size;\n+annotate_value (tree gnu_size)\n {\n   int len = TREE_CODE_LENGTH (TREE_CODE (gnu_size));\n   TCode tcode;\n@@ -5663,9 +5623,7 @@ annotate_value (gnu_size)\n    used by Gigi.  */\n \n static void\n-annotate_rep (gnat_entity, gnu_type)\n-     Entity_Id gnat_entity;\n-     tree gnu_type;\n+annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n {\n   tree gnu_list;\n   tree gnu_entry;\n@@ -5743,12 +5701,11 @@ annotate_rep (gnat_entity, gnu_type)\n    so far.  */\n \n static tree\n-compute_field_positions (gnu_type, gnu_list, gnu_pos, gnu_bitpos, offset_align)\n-     tree gnu_type;\n-     tree gnu_list;\n-     tree gnu_pos;\n-     tree gnu_bitpos;\n-     unsigned int offset_align;\n+compute_field_positions (tree gnu_type,\n+                         tree gnu_list,\n+                         tree gnu_pos,\n+                         tree gnu_bitpos,\n+                         unsigned int offset_align)\n {\n   tree gnu_field;\n   tree gnu_result = gnu_list;\n@@ -5792,13 +5749,12 @@ compute_field_positions (gnu_type, gnu_list, gnu_pos, gnu_bitpos, offset_align)\n    it means that a size of zero should be treated as an unspecified size.  */\n \n static tree\n-validate_size (uint_size, gnu_type, gnat_object, kind, component_p, zero_ok)\n-     Uint uint_size;\n-     tree gnu_type;\n-     Entity_Id gnat_object;\n-     enum tree_code kind;\n-     int component_p;\n-     int zero_ok;\n+validate_size (Uint uint_size,\n+               tree gnu_type,\n+               Entity_Id gnat_object,\n+               enum tree_code kind,\n+               int component_p,\n+               int zero_ok)\n {\n   Node_Id gnat_error_node;\n   tree type_size\n@@ -5911,10 +5867,7 @@ validate_size (uint_size, gnu_type, gnat_object, kind, component_p, zero_ok)\n    routine is only called for types.  */\n \n static void\n-set_rm_size (uint_size, gnu_type, gnat_entity)\n-     Uint uint_size;\n-     tree gnu_type;\n-     Entity_Id gnat_entity;\n+set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n {\n   /* Only give an error if a Value_Size clause was explicitly given.\n      Otherwise, we'd be duplicating an error on the Size clause.  */\n@@ -5988,10 +5941,7 @@ set_rm_size (uint_size, gnu_type, gnat_entity)\n    we are making a biased type.  */\n \n static tree\n-make_type_from_size (type, size_tree, biased_p)\n-     tree type;\n-     tree size_tree;\n-     int biased_p;\n+make_type_from_size (tree type, tree size_tree, int biased_p)\n {\n   tree new_type;\n   unsigned HOST_WIDE_INT size;\n@@ -6061,10 +6011,7 @@ make_type_from_size (type, size_tree, biased_p)\n    valid, return it.  Otherwise, give an error and return ALIGN.  */\n \n static unsigned int\n-validate_alignment (alignment, gnat_entity, align)\n-     Uint alignment;\n-     Entity_Id gnat_entity;\n-     unsigned int align;\n+validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n {\n   Node_Id gnat_error_node = gnat_entity;\n   unsigned int new_align;\n@@ -6109,10 +6056,7 @@ validate_alignment (alignment, gnat_entity, align)\n    if we require atomic components.  */\n \n static void\n-check_ok_for_atomic (object, gnat_entity, comp_p)\n-     tree object;\n-     Entity_Id gnat_entity;\n-     int comp_p;\n+check_ok_for_atomic (tree object, Entity_Id gnat_entity, int comp_p)\n {\n   Node_Id gnat_error_point = gnat_entity;\n   Node_Id gnat_node;\n@@ -6188,8 +6132,7 @@ check_ok_for_atomic (object, gnat_entity, comp_p)\n    changed.  */\n \n tree\n-gnat_substitute_in_type (t, f, r)\n-     tree t, f, r;\n+gnat_substitute_in_type (tree t, tree f, tree r)\n {\n   tree new = t;\n   tree tem;\n@@ -6410,8 +6353,7 @@ gnat_substitute_in_type (t, f, r)\n    needed to represent the object.  */\n \n tree\n-rm_size (gnu_type)\n-     tree gnu_type;\n+rm_size (tree gnu_type)\n {\n   /* For integer types, this is the precision.  For record types, we store\n      the size explicitly.  For other types, this is just the size.  */\n@@ -6440,9 +6382,7 @@ rm_size (gnu_type)\n    and the specified suffix.  */\n \n tree\n-create_concat_name (gnat_entity, suffix)\n-     Entity_Id gnat_entity;\n-     const char *suffix;\n+create_concat_name (Entity_Id gnat_entity, const char *suffix)\n {\n   const char *str = (suffix == 0 ? \"\" : suffix);\n   String_Template temp = {1, strlen (str)};\n@@ -6480,8 +6420,7 @@ create_concat_name (gnat_entity, suffix)\n    Otherwise, return the name.  */\n \n tree\n-get_entity_name (gnat_entity)\n-     Entity_Id gnat_entity;\n+get_entity_name (Entity_Id gnat_entity)\n {\n   Get_Encoded_Name (gnat_entity);\n   return get_identifier (Name_Buffer);\n@@ -6492,9 +6431,7 @@ get_entity_name (gnat_entity)\n    the name in GNU_ID and SUFFIX.  */\n \n tree\n-concat_id_with_name (gnu_id, suffix)\n-     tree gnu_id;\n-     const char *suffix;\n+concat_id_with_name (tree gnu_id, const char *suffix)\n {\n   int len = IDENTIFIER_LENGTH (gnu_id);\n "}, {"sha": "112e7be2d29120ee92535b62d60511a97a585c31", "filename": "gcc/ada/errno.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrno.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -42,14 +42,13 @@\n \n #include <errno.h>\n int\n-__get_errno()\n+__get_errno(void)\n {\n   return errno;\n }\n \n void\n-__set_errno(err)\n-     int err;\n+__set_errno(int err)\n {\n   errno = err;\n }"}, {"sha": "72ce28e840549df6f0492f8e6043c37c71f0da5f", "filename": "gcc/ada/exit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexit.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -50,8 +50,7 @@\n int gnat_exit_status = 0;\n \n void\n-__gnat_set_exit_status (i)\n-     int i;\n+__gnat_set_exit_status (int i)\n {\n   gnat_exit_status = i;\n }"}, {"sha": "54952268517a9d27ae8d815310065cc90ed7c49a", "filename": "gcc/ada/expect.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fexpect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fexpect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpect.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -72,7 +72,7 @@ __gnat_kill (int pid, int sig)\n }\n \n int\n-__gnat_expect_fork ()\n+__gnat_expect_fork (void)\n {\n   return 0;\n }\n@@ -159,7 +159,7 @@ __gnat_pipe (int *fd)\n }\n \n int\n-__gnat_expect_fork ()\n+__gnat_expect_fork (void)\n {\n   return -1;\n }\n@@ -299,7 +299,7 @@ __gnat_pipe (int *fd)\n }\n \n int\n-__gnat_expect_fork ()\n+__gnat_expect_fork (void)\n {\n   return fork ();\n }\n@@ -406,7 +406,7 @@ __gnat_pipe (int *fd)\n }\n \n int\n-__gnat_expect_fork ()\n+__gnat_expect_fork (void)\n {\n   return -1;\n }"}, {"sha": "c17c6769b52a9bb62b801a38a7816ddf9a2bc823", "filename": "gcc/ada/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffinal.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -38,6 +38,6 @@ extern void __gnat_finalize (void);\n    where finalization is required. */\n \n void\n-__gnat_finalize ()\n+__gnat_finalize (void)\n {\n }"}, {"sha": "002f78f77be773189bb4d06beb009c63af80bb3d", "filename": "gcc/ada/gmem.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fgmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fgmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgmem.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -75,7 +75,7 @@ convert_addresses (char *addrs[], int n_addr, void *buf, int *len);\n */\n \n static void\n-gmem_read_backtrace ()\n+gmem_read_backtrace (void)\n {\n   fread (&cur_tb_len, sizeof (int), 1, gmemfile);\n   fread (tracebk, sizeof (char *), cur_tb_len, gmemfile);\n@@ -120,8 +120,7 @@ void __gnat_gmem_a2l_initialize (char *exename)\n    write an alloc/free information in buf to be processed by gnatmem */\n \n void\n-__gnat_gmem_read_next (buf)\n-     struct struct_storage_elmt *buf;\n+__gnat_gmem_read_next (struct struct_storage_elmt *buf)\n {\n   void *addr;\n   size_t size;"}, {"sha": "de75b3374b0e903efa1f6db5321f90d845800b8f", "filename": "gcc/ada/gnatbl.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fgnatbl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fgnatbl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbl.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -72,12 +72,11 @@ char *gcc_B_arg = 0;\n \n static int linkonly = 0;\n \n-static void addarg\t\tPARAMS ((char *));\n-static void process_args\tPARAMS ((int *, char *[]));\n+static void addarg (char *);\n+static void process_args (int *, char *[]);\n \f\n static void\n-addarg (str)\n-     char *str;\n+addarg (char *str)\n {\n   int i;\n \n@@ -100,9 +99,7 @@ addarg (str)\n }\n \n static void\n-process_args (p_argc, argv)\n-     int *p_argc;\n-     char *argv[];\n+process_args (int *p_argc, char *argv[])\n {\n   int i, j;\n \n@@ -199,12 +196,10 @@ process_args (p_argc, argv)\n       }\n     }\n }\n-extern int main PARAMS ((int, char **));\n+extern int main (int, char **);\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   int i, j;\n   int done_an_ali = 0;"}, {"sha": "ac9abca545b49625ad44a76166e1fee84f0587b2", "filename": "gcc/ada/init.c", "status": "modified", "additions": 91, "deletions": 129, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -71,28 +71,28 @@ extern struct Exception_Data tasking_error;\n extern struct Exception_Data _abort_signal;\n \n #define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) PARAMS ((void));\n+extern void (*Lock_Task) (void);\n \n #define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) PARAMS ((void));\n+extern void (*Unlock_Task) (void);\n \n #define Get_Machine_State_Addr \\\n                       system__soft_links__get_machine_state_addr\n-extern struct Machine_State *(*Get_Machine_State_Addr) PARAMS ((void));\n+extern struct Machine_State *(*Get_Machine_State_Addr) (void);\n \n #define Check_Abort_Status     \\\n                       system__soft_links__check_abort_status\n-extern int    (*Check_Abort_Status) PARAMS ((void));\n+extern int    (*Check_Abort_Status) (void);\n \n #define Raise_From_Signal_Handler \\\n                       ada__exceptions__raise_from_signal_handler\n-extern void   Raise_From_Signal_Handler PARAMS ((struct Exception_Data *,\n-\t\t\t\t\t\tconst char *));\n+extern void   Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n \n #define Propagate_Signal_Exception \\\n                       __gnat_propagate_sig_exc\n-extern void   Propagate_Signal_Exception\n-\tPARAMS ((struct Machine_State *, struct Exception_Data *, const char *));\n+extern void   Propagate_Signal_Exception (struct Machine_State *, \n+                                          struct Exception_Data *,\n+                                          const char *);\n \n /* Copies of global values computed by the binder */\n int   __gl_main_priority            = -1;\n@@ -134,8 +134,7 @@ char __gnat_get_interrupt_state (int);\n        's'   Interrupt_State pragma set state to System */\n \n char\n-__gnat_get_interrupt_state (intrup)\n-     int intrup;\n+__gnat_get_interrupt_state (int intrup)\n {\n   if (intrup >= __gl_num_interrupt_states)\n     return 'n';\n@@ -156,30 +155,18 @@ __gnat_get_interrupt_state (intrup)\n    boundaries like this are not handled correctly in all systems.  */\n \n void\n-__gnat_set_globals (main_priority,\n-                    time_slice_val,\n-                    wc_encoding,\n-                    locking_policy,\n-\t\t    queuing_policy,\n-\t\t    task_dispatching_policy,\n-\t\t    restrictions,\n-                    interrupt_states,\n-                    num_interrupt_states,\n-\t\t    unreserve_all_interrupts,\n-\t\t    exception_tracebacks,\n-\t\t    zero_cost_exceptions)\n-     int main_priority;\n-     int time_slice_val;\n-     char wc_encoding;\n-     char locking_policy;\n-     char queuing_policy;\n-     char task_dispatching_policy;\n-     char *restrictions;\n-     char *interrupt_states;\n-     int num_interrupt_states;\n-     int unreserve_all_interrupts;\n-     int exception_tracebacks;\n-     int zero_cost_exceptions;\n+__gnat_set_globals (int main_priority,\n+                    int time_slice_val,\n+                    char wc_encoding,\n+                    char locking_policy,\n+                    char queuing_policy,\n+                    char task_dispatching_policy,\n+                    char *restrictions,\n+                    char *interrupt_states,\n+                    int num_interrupt_states,\n+                    int unreserve_all_interrupts,\n+                    int exception_tracebacks,\n+                    int zero_cost_exceptions)\n {\n   static int already_called = 0;\n \n@@ -288,22 +275,20 @@ __gnat_set_globals (main_priority,\n \n #ifndef _AIXVERSION_430\n \n-extern int nanosleep PARAMS ((struct timestruc_t *, struct timestruc_t *));\n+extern int nanosleep (struct timestruc_t *, struct timestruc_t *);\n \n int\n-nanosleep (Rqtp, Rmtp)\n-     struct timestruc_t *Rqtp, *Rmtp;\n+nanosleep (struct timestruc_t *Rqtp, struct timestruc_t *Rmtp)\n {\n   return nsleep (Rqtp, Rmtp);\n }\n \n #endif /* _AIXVERSION_430 */\n \n-static void __gnat_error_handler PARAMS ((int));\n+static void __gnat_error_handler (int);\n \n static void\n-__gnat_error_handler (sig)\n-     int sig;\n+__gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -335,7 +320,7 @@ __gnat_error_handler (sig)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -363,7 +348,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -380,20 +365,16 @@ __gnat_initialize ()\n #include <signal.h>\n #include <sys/siginfo.h>\n \n-static void __gnat_error_handler PARAMS ((int, siginfo_t *,\n-\t\t\t\t\t  struct sigcontext *));\n-extern char *__gnat_get_code_loc PARAMS ((struct sigcontext *));\n-extern void __gnat_enter_handler PARAMS ((struct sigcontext *, char *));\n-extern size_t __gnat_machine_state_length PARAMS ((void));\n+static void __gnat_error_handler (int, siginfo_t *, struct sigcontext *);\n+extern char *__gnat_get_code_loc (struct sigcontext *);\n+extern void __gnat_enter_handler (struct sigcontext *, char *);\n+extern size_t __gnat_machine_state_length (void);\n \n-extern long exc_lookup_gp PARAMS ((char *));\n-extern void exc_resume PARAMS ((struct sigcontext *));\n+extern long exc_lookup_gp (char *);\n+extern void exc_resume (struct sigcontext *);\n \n static void\n-__gnat_error_handler (sig, sip, context)\n-     int sig;\n-     siginfo_t *sip;\n-     struct sigcontext *context;\n+__gnat_error_handler (int sig, siginfo_t *sip, struct sigcontext *context)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n@@ -463,15 +444,15 @@ __gnat_error_handler (sig, sip, context)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions. Make sure that the handler isn't interrupted by another\n      signal that might cause a scheduling event! */\n \n-  act.sa_handler = (void (*) PARAMS ((int))) __gnat_error_handler;\n+  act.sa_handler = (void (*) (int)) __gnat_error_handler;\n   act.sa_flags = SA_ONSTACK | SA_RESTART | SA_NODEFER | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n@@ -491,7 +472,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -500,24 +481,21 @@ __gnat_initialize ()\n #define SC_GP 29\n \n char *\n-__gnat_get_code_loc (context)\n-     struct sigcontext *context;\n+__gnat_get_code_loc (struct sigcontext *context)\n {\n   return (char *) context->sc_pc;\n }\n \n void\n-__gnat_enter_handler (context, pc)\n-     struct sigcontext *context;\n-     char *pc;\n+__gnat_enter_handler ( struct sigcontext *context, char *pc)\n {\n   context->sc_pc = (long) pc;\n   context->sc_regs[SC_GP] = exc_lookup_gp (pc);\n   exc_resume (context);\n }\n \n size_t\n-__gnat_machine_state_length ()\n+__gnat_machine_state_length (void)\n {\n   return sizeof (struct sigcontext);\n }\n@@ -530,11 +508,10 @@ __gnat_machine_state_length ()\n \n #include <signal.h>\n \n-static void __gnat_error_handler PARAMS ((int));\n+static void __gnat_error_handler (int);\n \n static void\n-__gnat_error_handler (sig)\n-     int sig;\n+__gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n   char *msg;\n@@ -566,7 +543,7 @@ __gnat_error_handler (sig)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -609,7 +586,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -639,11 +616,10 @@ struct Machine_State\n   unsigned long edi;\n };\n \n-static void __gnat_error_handler PARAMS ((int));\n+static void __gnat_error_handler (int);\n \n static void\n-__gnat_error_handler (sig)\n-     int sig;\n+__gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -731,7 +707,7 @@ __gnat_error_handler (sig)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -759,7 +735,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -770,13 +746,12 @@ __gnat_initialize ()\n #elif defined (__MINGW32__)\n #include <windows.h>\n \n-static LONG WINAPI __gnat_error_handler PARAMS ((PEXCEPTION_POINTERS));\n+static LONG WINAPI __gnat_error_handler (PEXCEPTION_POINTERS);\n \n /* __gnat_initialize (mingw32).  */\n \n static LONG WINAPI\n-__gnat_error_handler (info)\n-     PEXCEPTION_POINTERS info;\n+__gnat_error_handler (PEXCEPTION_POINTERS info)\n {\n   static int recurse;\n   struct Exception_Data *exception;\n@@ -891,14 +866,14 @@ __gnat_error_handler (info)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   SetUnhandledExceptionFilter (__gnat_error_handler);\n   __gnat_handler_installed = 1;\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n \n    /* Initialize floating-point coprocessor. This call is needed because\n@@ -921,11 +896,10 @@ __gnat_initialize ()\n \n #include <signal.h>\n \n-static void __gnat_error_handler PARAMS ((int));\n+static void __gnat_error_handler (int);\n \n static void\n-__gnat_error_handler (sig)\n-     int sig;\n+__gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n   char *msg;\n@@ -956,7 +930,7 @@ __gnat_error_handler (sig)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -982,7 +956,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n    __gnat_init_float ();\n }\n@@ -994,7 +968,7 @@ __gnat_initialize ()\n #elif defined (__Lynx__)\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n    __gnat_init_float ();\n }\n@@ -1004,7 +978,7 @@ __gnat_initialize ()\n /*********************************/\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   __gnat_handler_installed = 1;\n }\n@@ -1016,7 +990,7 @@ __gnat_install_handler ()\n #elif defined (__EMX__) /* OS/2 dependent initialization */\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -1025,7 +999,7 @@ __gnat_initialize ()\n /*********************************/\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   __gnat_handler_installed = 1;\n }\n@@ -1052,13 +1026,10 @@ struct Machine_State\n   sigcontext_t context;\n };\n \n-static void __gnat_error_handler PARAMS ((int, int, sigcontext_t *));\n+static void __gnat_error_handler (int, int, sigcontext_t *);\n \n static void\n-__gnat_error_handler (sig, code, sc)\n-     int sig;\n-     int code;\n-     sigcontext_t *sc;\n+__gnat_error_handler (int sig, int code, sigcontext_t *sc)\n {\n   struct Machine_State  *mstate;\n   struct Exception_Data *exception;\n@@ -1138,7 +1109,7 @@ __gnat_error_handler (sig, code, sc)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -1169,7 +1140,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -1182,12 +1153,10 @@ __gnat_initialize ()\n #include <signal.h>\n #include <siginfo.h>\n \n-static void __gnat_error_handler PARAMS ((int, siginfo_t *));\n+static void __gnat_error_handler (int, siginfo_t *);\n \n static void\n-__gnat_error_handler (sig, sip)\n-     int sig;\n-     siginfo_t *sip;\n+__gnat_error_handler (int sig, siginfo_t *sip)\n {\n   struct Exception_Data *exception;\n   static int recurse = 0;\n@@ -1253,7 +1222,7 @@ __gnat_error_handler (sig, sip)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -1279,7 +1248,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -1291,7 +1260,7 @@ __gnat_initialize ()\n \n /* The prehandler actually gets control first on a condition. It swaps the\n    stack pointer and calls the handler (__gnat_error_handler). */\n-extern long __gnat_error_prehandler ();\n+extern long __gnat_error_prehandler (void);\n \n extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n \n@@ -1329,12 +1298,10 @@ extern struct Exception_Data *Coded_Exception (int);\n \n struct descriptor_s {unsigned short len, mbz; char *adr; };\n \n-long __gnat_error_handler PARAMS ((int *, void *));\n+long __gnat_error_handler (int *, void *);\n \n long\n-__gnat_error_handler (sigargs, mechargs)\n-     int *sigargs;\n-     void *mechargs;\n+__gnat_error_handler (int *sigargs, void *mechargs)\n {\n   struct Exception_Data *exception = 0;\n   char *msg = \"\";\n@@ -1470,7 +1437,7 @@ __gnat_error_handler (sigargs, mechargs)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   long prvhnd;\n   char *c;\n@@ -1485,7 +1452,7 @@ __gnat_install_handler ()\n }\n \n void\n-__gnat_initialize()\n+__gnat_initialize(void)\n {\n }\n \n@@ -1508,28 +1475,24 @@ static void __gnat_error_handler (int, int, struct sigcontext *);\n /* getpid is used by s-parint.adb, but is not defined by VxWorks, except\n    on Alpha VxWorks */\n \n-extern long getpid PARAMS ((void));\n+extern long getpid (void);\n \n long\n-getpid ()\n+getpid (void)\n {\n   return taskIdSelf ();\n }\n #endif\n \n /* This is needed by the GNAT run time to handle Vxworks interrupts */\n int\n-__gnat_inum_to_ivec (num)\n-     int num;\n+__gnat_inum_to_ivec (int num)\n {\n   return INUM_TO_IVEC (num);\n }\n \n static void\n-__gnat_error_handler (sig, code, sc)\n-     int sig;\n-     int code;\n-     struct sigcontext *sc;\n+__gnat_error_handler (int sig, int code, struct sigcontext *sc)\n {\n   struct Exception_Data *exception;\n   sigset_t mask;\n@@ -1576,7 +1539,7 @@ __gnat_error_handler (sig, code, sc)\n }\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   struct sigaction act;\n \n@@ -1601,7 +1564,7 @@ __gnat_install_handler ()\n #define HAVE_GNAT_INIT_FLOAT\n \n void\n-__gnat_init_float ()\n+__gnat_init_float (void)\n {\n   /* Disable overflow/underflow exceptions on the PPC processor, this is needed\n      to get correct Ada semantic.  */\n@@ -1631,7 +1594,7 @@ __gnat_init_float ()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n   __gnat_init_float ();\n \n@@ -1661,8 +1624,7 @@ __gnat_initialize ()\n #include <unistd.h>\n \n static void\n-__gnat_error_handler (sig)\n-  int sig;\n+__gnat_error_handler (int sig)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -1694,7 +1656,7 @@ __gnat_error_handler (sig)\n }\n \n void\n-__gnat_install_handler()\n+__gnat_install_handler(void)\n {\n   struct sigaction act;\n \n@@ -1714,7 +1676,7 @@ __gnat_install_handler()\n }\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n   __gnat_install_handler ();\n   __gnat_init_float ();\n@@ -1726,12 +1688,12 @@ __gnat_initialize ()\n \n #elif defined(__rtems__)\n \n-extern void __gnat_install_handler ();\n+extern void __gnat_install_handler (void);\n \n /* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n    __gnat_install_handler ();\n }\n@@ -1742,12 +1704,12 @@ __gnat_initialize ()\n \n #elif defined(__rtems__)\n \n-extern void __gnat_install_handler ();\n+extern void __gnat_install_handler (void);\n \n /* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n    __gnat_install_handler ();\n }\n@@ -1762,7 +1724,7 @@ __gnat_initialize ()\n /***************************************/\n \n void\n-__gnat_initialize ()\n+__gnat_initialize (void)\n {\n }\n \n@@ -1771,7 +1733,7 @@ __gnat_initialize ()\n /********************************************/\n \n void\n-__gnat_install_handler ()\n+__gnat_install_handler (void)\n {\n   __gnat_handler_installed = 1;\n }\n@@ -1792,7 +1754,7 @@ __gnat_install_handler ()\n #define HAVE_GNAT_INIT_FLOAT\n \n void\n-__gnat_init_float ()\n+__gnat_init_float (void)\n {\n #if defined (__i386__) || defined (i386)\n \n@@ -1809,7 +1771,7 @@ __gnat_init_float ()\n \n /* All targets without a specific __gnat_init_float will use an empty one */\n void\n-__gnat_init_float ()\n+__gnat_init_float (void)\n {\n }\n #endif"}, {"sha": "d2af6f2137cb3b59e3ef652254b7576d792d3ab0", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -359,7 +359,7 @@ gnat_tree_size (enum tree_code code)\n /* Perform all the initialization steps that are language-specific.  */\n \n static bool\n-gnat_init ()\n+gnat_init (void)\n {\n   /* Performs whatever initialization steps needed by the language-dependent\n      lexical analyzer.  */\n@@ -396,7 +396,7 @@ gnat_finish_incomplete_decl (tree dont_care ATTRIBUTE_UNUSED)\n    objects.  */\n \n void\n-gnat_compute_largest_alignment ()\n+gnat_compute_largest_alignment (void)\n {\n   enum machine_mode mode;\n \n@@ -413,7 +413,7 @@ gnat_compute_largest_alignment ()\n    various language dependent hooks.  */\n \n void\n-gnat_init_gcc_eh ()\n+gnat_init_gcc_eh (void)\n {\n   /* We shouldn't do anything if the No_Exceptions_Handler pragma is set,\n      though. This could for instance lead to the emission of tables with"}, {"sha": "ce08d9a060166725e197e5c8376af5e87ec9d2c5", "filename": "gcc/ada/mkdir.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fmkdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fmkdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmkdir.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -48,8 +48,7 @@\n /*  This function provides a portable binding to the mkdir function.  */\n \n int\n-__gnat_mkdir (dir_name)\n-     char *dir_name;\n+__gnat_mkdir (char *dir_name)\n {\n #if defined (_WIN32) || defined (__vxworks)\n   return mkdir (dir_name);"}, {"sha": "6a399dc3a1412f9c1a34607661e571d24ba5e437", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -58,9 +58,7 @@ typedef char bool;\n /*  We have not yet figured out how to import this directly */\n \n void\n-_gnat_builtin_longjmp (ptr, flag)\n-     void *ptr;\n-     int flag ATTRIBUTE_UNUSED;\n+_gnat_builtin_longjmp (void *ptr, int flag ATTRIBUTE_UNUSED)\n {\n    __builtin_longjmp (ptr, 1);\n }\n@@ -72,7 +70,7 @@ _gnat_builtin_longjmp (ptr, flag)\n    performs any system dependent cleanup required.  */\n \n void\n-__gnat_unhandled_terminate ()\n+__gnat_unhandled_terminate (void)\n {\n   /* Special termination handling for VMS */\n \n@@ -108,10 +106,10 @@ typedef struct _Unwind_Context _Unwind_Context;\n typedef struct _Unwind_Exception _Unwind_Exception;\n \n _Unwind_Reason_Code\n-__gnat_Unwind_RaiseException PARAMS ((_Unwind_Exception *));\n+__gnat_Unwind_RaiseException (_Unwind_Exception *);\n \n _Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind PARAMS ((_Unwind_Exception *, void *, void *));\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n \n \n #ifdef IN_RTS   /* For eh personality routine */\n@@ -540,9 +538,7 @@ typedef struct\n } region_descriptor;\n \n static void\n-db_region_for (region, uw_context)\n-     region_descriptor *region;\n-     _Unwind_Context *uw_context;\n+db_region_for (region_descriptor *region, _Unwind_Context *uw_context)\n {\n   _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n \n@@ -563,9 +559,7 @@ db_region_for (region, uw_context)\n    ttype table.  */\n \n static const _Unwind_Ptr\n-get_ttype_entry_for (region, filter)\n-     region_descriptor *region;\n-     long filter;\n+get_ttype_entry_for (region_descriptor *region, long filter)\n {\n   _Unwind_Ptr ttype_entry;\n \n@@ -580,9 +574,8 @@ get_ttype_entry_for (region, filter)\n /* Fill out the REGION descriptor for the provided UW_CONTEXT.  */\n \n static void\n-get_region_description_for (uw_context, region)\n-     _Unwind_Context *uw_context;\n-     region_descriptor *region;\n+get_region_description_for (_Unwind_Context *uw_context,\n+                            region_descriptor *region)\n {\n   const unsigned char * p;\n   _Unwind_Word tmp;\n@@ -674,9 +667,7 @@ typedef struct\n \n \n static void\n-db_action_for (action, uw_context)\n-     action_descriptor *action;\n-     _Unwind_Context *uw_context;\n+db_action_for (action_descriptor *action, _Unwind_Context *uw_context)\n {\n   _Unwind_Ptr ip = _Unwind_GetIP (uw_context) - 1;\n \n@@ -725,10 +716,9 @@ db_action_for (action, uw_context)\n #define __builtin_eh_return_data_regno(x) x\n \n static void\n-get_call_site_action_for (uw_context, region, action)\n-     _Unwind_Context *uw_context;\n-     region_descriptor *region;\n-     action_descriptor *action;\n+get_call_site_action_for (_Unwind_Context *uw_context,\n+                          region_descriptor *region,\n+                          action_descriptor *action)\n {\n   _Unwind_Ptr call_site\n     = _Unwind_GetIP (uw_context) - 1;\n@@ -786,10 +776,9 @@ get_call_site_action_for (uw_context, region, action)\n /* ! __USING_SJLJ_EXCEPTIONS__ */\n \n static void\n-get_call_site_action_for (uw_context, region, action)\n-     _Unwind_Context *uw_context;\n-     region_descriptor *region;\n-     action_descriptor *action;\n+get_call_site_action_for (_Unwind_Context *uw_context,\n+                          region_descriptor *region,\n+                          action_descriptor *action)\n {\n   _Unwind_Ptr ip\n     = _Unwind_GetIP (uw_context) - 1;\n@@ -861,11 +850,10 @@ get_call_site_action_for (uw_context, region, action)\n    UW_CONTEXT in REGION.  */\n \n static void\n-get_action_description_for (uw_context, uw_exception, region, action)\n-     _Unwind_Context *uw_context;\n-     _Unwind_Exception *uw_exception;\n-     region_descriptor *region;\n-     action_descriptor *action;\n+get_action_description_for (_Unwind_Context *uw_context,\n+                            _Unwind_Exception *uw_exception,\n+                            region_descriptor *regionr,\n+                            action_descriptor *actionr)\n {\n   _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n \n@@ -950,11 +938,10 @@ get_action_description_for (uw_context, uw_exception, region, action)\n    occured.  */\n \n static void\n-setup_to_install (uw_context, uw_exception, uw_landing_pad, uw_filter)\n-     _Unwind_Context *uw_context;\n-     _Unwind_Exception *uw_exception;\n-     int uw_filter;\n-     _Unwind_Ptr uw_landing_pad;\n+setup_to_install (_Unwind_Context *uw_context,\n+                  _Unwind_Exception *uw_exception,\n+                  int uw_filter,\n+                  _Unwind_Ptr uw_landing_pad)\n {\n #ifndef EH_RETURN_DATA_REGNO\n   /* We should not be called if the appropriate underlying support is not\n@@ -981,20 +968,18 @@ setup_to_install (uw_context, uw_exception, uw_landing_pad, uw_filter)\n /* The following is defined from a-except.adb. Its purpose is to enable\n    automatic backtraces upon exception raise, as provided through the\n    GNAT.Traceback facilities.  */\n-extern void __gnat_notify_handled_exception PARAMS ((void));\n-extern void __gnat_notify_unhandled_exception PARAMS ((void));\n+extern void __gnat_notify_handled_exception (void);\n+extern void __gnat_notify_unhandled_exception (void);\n \n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */\n \n _Unwind_Reason_Code\n-__gnat_eh_personality (uw_version, uw_phases,\n-\t\t       uw_exception_class, uw_exception, uw_context)\n-     int uw_version;\n-     _Unwind_Action uw_phases;\n-     _Unwind_Exception_Class uw_exception_class;\n-     _Unwind_Exception *uw_exception;\n-     _Unwind_Context *uw_context;\n+__gnat_eh_personality (int uw_version,\n+                       _Unwind_Action uw_phases,\n+                       _Unwind_Exception_Class uw_exception_class,\n+                       _Unwind_Exception *uw_exception,\n+                       _Unwind_Context *uw_context)\n {\n   _GNAT_Exception * gnat_exception = (_GNAT_Exception *) uw_exception;\n \n@@ -1075,8 +1060,7 @@ __gnat_eh_personality (uw_version, uw_phases,\n #undef _Unwind_RaiseException\n \n _Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (e)\n-     _Unwind_Exception *e;\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n {\n   return _Unwind_SjLj_RaiseException (e);\n }\n@@ -1085,10 +1069,9 @@ __gnat_Unwind_RaiseException (e)\n #undef _Unwind_ForcedUnwind\n \n _Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (e, handler, argument)\n-     _Unwind_Exception *e;\n-     void * handler;\n-     void * argument;\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n+                            void * handler,\n+                            void * argument)\n {\n   return _Unwind_SjLj_ForcedUnwind (e, handler, argument);\n }\n@@ -1097,17 +1080,15 @@ __gnat_Unwind_ForcedUnwind (e, handler, argument)\n #else /* __USING_SJLJ_EXCEPTIONS__ */\n \n _Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (e)\n-     _Unwind_Exception *e;\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e)\n {\n   return _Unwind_RaiseException (e);\n }\n \n _Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (e, handler, argument)\n-     _Unwind_Exception *e;\n-     void * handler;\n-     void * argument;\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n+                            void * handler,\n+                            void * argument)\n {\n   return _Unwind_ForcedUnwind (e, handler, argument);\n }\n@@ -1127,18 +1108,16 @@ __gnat_Unwind_ForcedUnwind (e, handler, argument)\n    functions never to be called.  */\n \n _Unwind_Reason_Code\n-__gnat_Unwind_RaiseException (e)\n-     _Unwind_Exception *e ATTRIBUTE_UNUSED;\n+__gnat_Unwind_RaiseException (_Unwind_Exception *e ATTRIBUTE_UNUSED)\n {\n   abort ();\n }\n \n \n _Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (e, handler, argument)\n-     _Unwind_Exception *e ATTRIBUTE_UNUSED;\n-     void * handler ATTRIBUTE_UNUSED;\n-     void * argument ATTRIBUTE_UNUSED;\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *e ATTRIBUTE_UNUSED,\n+                            void * handler ATTRIBUTE_UNUSED,\n+                            void * argument ATTRIBUTE_UNUSED)\n {\n   abort ();\n }"}, {"sha": "89b8163fada68e02e282eb2acc2e9a40477e523f", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -66,19 +66,18 @@\n \n #include \"raise.h\"\n \n-extern void __gnat_free_socket_set\tPARAMS ((fd_set *));\n-extern void __gnat_last_socket_in_set\tPARAMS ((fd_set *, int *));\n-extern void __gnat_get_socket_from_set\tPARAMS ((fd_set *, int *, int *));\n-extern void __gnat_insert_socket_in_set\tPARAMS ((fd_set *, int));\n-extern int __gnat_is_socket_in_set\tPARAMS ((fd_set *, int));\n-extern fd_set *__gnat_new_socket_set\tPARAMS ((fd_set *));\n-extern void __gnat_remove_socket_from_set PARAMS ((fd_set *, int));\n+extern void __gnat_free_socket_set (fd_set *);\n+extern void __gnat_last_socket_in_set (fd_set *, int *);\n+extern void __gnat_get_socket_from_set (fd_set *, int *, int *);\n+extern void __gnat_insert_socket_in_set (fd_set *, int);\n+extern int __gnat_is_socket_in_set (fd_set *, int);\n+extern fd_set *__gnat_new_socket_set (fd_set *);\n+extern void __gnat_remove_socket_from_set (fd_set *, int);\n \f\n /* Free socket set. */\n \n void\n-__gnat_free_socket_set (set)\n-     fd_set *set;\n+__gnat_free_socket_set (fd_set *set)\n {\n   __gnat_free (set);\n }\n@@ -89,9 +88,7 @@ __gnat_free_socket_set (set)\n    actual largest socket in the socket set. */\n \n void\n-__gnat_last_socket_in_set (set, last)\n-     fd_set *set;\n-     int *last;\n+__gnat_last_socket_in_set (fd_set *set, int *last)\n {\n   int s;\n   int l;\n@@ -122,10 +119,7 @@ __gnat_last_socket_in_set (set, last)\n    socket in the socket set. */\n \n void\n-__gnat_get_socket_from_set (set, last, socket)\n-     fd_set *set;\n-     int *last;\n-     int *socket;\n+__gnat_get_socket_from_set (fd_set *set, int *last, int *socket)\n {\n   *socket = *last;\n   FD_CLR (*socket, set);\n@@ -135,28 +129,23 @@ __gnat_get_socket_from_set (set, last, socket)\n /* Insert SOCKET in the socket set SET. */\n \n void\n-__gnat_insert_socket_in_set (set, socket)\n-     fd_set *set;\n-     int socket;\n+__gnat_insert_socket_in_set (fd_set *set, int socket)\n {\n   FD_SET (socket, set);\n }\n \n /* Check whether a given SOCKET is in the socket set SET. */\n \n int\n-__gnat_is_socket_in_set (set, socket)\n-     fd_set *set;\n-     int socket;\n+__gnat_is_socket_in_set (fd_set *set, int socket)\n {\n   return FD_ISSET (socket, set);\n }\n \n /* Allocate a new socket set and set it as empty.  */\n \n fd_set *\n-__gnat_new_socket_set (set)\n-     fd_set *set;\n+__gnat_new_socket_set (fd_set *set)\n {\n   fd_set *new;\n \n@@ -173,9 +162,7 @@ __gnat_new_socket_set (set)\n /* Remove SOCKET from the socket set SET. */\n \n void\n-__gnat_remove_socket_from_set (set, socket)\n-     fd_set *set;\n-     int socket;\n+__gnat_remove_socket_from_set (fd_set *set, int socket)\n {\n   FD_CLR (socket, set);\n }"}, {"sha": "be71095901585a11f54708d66221ba7eeee7f832", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 42, "deletions": 64, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -157,15 +157,13 @@ static const char *mode_append_binary_plus = \"a+b\";\n const char __gnat_text_translation_required = 1;\n \n void\n-__gnat_set_binary_mode (handle)\n-     int handle;\n+__gnat_set_binary_mode (int handle)\n {\n   _setmode (handle, O_BINARY);\n }\n \n void\n-__gnat_set_text_mode (handle)\n-     int handle;\n+__gnat_set_text_mode (int handle)\n {\n   _setmode (handle, O_TEXT);\n }\n@@ -178,8 +176,7 @@ __gnat_set_text_mode (handle)\n    \"console\".  */\n \n char *\n-__gnat_ttyname (filedes)\n-     int filedes;\n+__gnat_ttyname (int filedes)\n {\n   if (isatty (filedes))\n     return \"console\";\n@@ -206,22 +203,22 @@ __gnat_ttyname (filedes)\n    Calling FlushConsoleInputBuffer just after getch() fix the bug under\n    95/98. */\n \n-static void winflush_init PARAMS ((void));\n+static void winflush_init (void);\n \n-static void winflush_95 PARAMS ((void));\n+static void winflush_95 (void);\n \n-static void winflush_nt PARAMS ((void));\n+static void winflush_nt (void);\n \n /* winflusfunction is set first to the winflushinit function which will check\n    the OS version 95/98 or NT/2000 */\n \n-static void (*winflush_function) PARAMS ((void)) = winflush_init;\n+static void (*winflush_function) (void) = winflush_init;\n \n /* This function does the runtime check of the OS version and then sets\n    winflush_function to the appropriate function and then call it. */\n \n static void\n-winflush_init ()\n+winflush_init (void)\n {\n   DWORD dwVersion = GetVersion();\n \n@@ -234,12 +231,12 @@ winflush_init ()\n \n }\n \n-static void winflush_95 ()\n+static void winflush_95 (void)\n {\n   FlushConsoleInputBuffer (GetStdHandle (STD_INPUT_HANDLE));\n }\n \n-static void winflush_nt ()\n+static void winflush_nt (void)\n {\n   /* Does nothing as there is no problem under NT.  */\n }\n@@ -264,22 +261,19 @@ const char __gnat_text_translation_required = 0;\n /* These functions do nothing in non-DOS systems. */\n \n void\n-__gnat_set_binary_mode (handle)\n-     int handle ATTRIBUTE_UNUSED;\n+__gnat_set_binary_mode (int handle ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-__gnat_set_text_mode (handle)\n-     int handle ATTRIBUTE_UNUSED;\n+__gnat_set_text_mode (int handle ATTRIBUTE_UNUSED)\n {\n }\n char *\n-__gnat_ttyname (filedes)\n-     int filedes;\n+__gnat_ttyname (int filedes)\n {\n #ifndef __vxworks\n-  extern char *ttyname PARAMS ((int));\n+  extern char *ttyname (int);\n \n   return ttyname (filedes);\n \n@@ -315,18 +309,14 @@ static int initted = 0;\n /* Implements the common processing for getc_immediate and\n    getc_immediate_nowait. */\n \n-extern void getc_immediate\t\tPARAMS ((FILE *, int *, int *));\n-extern void getc_immediate_nowait\tPARAMS ((FILE *, int *, int *, int *));\n-extern void getc_immediate_common\tPARAMS ((FILE *, int *, int *,\n-\t\t\t\t\t\t int *, int));\n+extern void getc_immediate (FILE *, int *, int *);\n+extern void getc_immediate_nowait (FILE *, int *, int *, int *);\n+extern void getc_immediate_common (FILE *, int *, int *, int *, int);\n \n /* Called by Get_Immediate (Foo); */\n \n void\n-getc_immediate (stream, ch, end_of_file)\n-     FILE *stream;\n-     int *ch;\n-     int *end_of_file;\n+getc_immediate (FILE *stream, int *ch, int *end_of_file)\n {\n   int avail;\n \n@@ -336,24 +326,19 @@ getc_immediate (stream, ch, end_of_file)\n /* Called by Get_Immediate (Foo, Available); */\n \n void\n-getc_immediate_nowait (stream, ch, end_of_file, avail)\n-     FILE *stream;\n-     int *ch;\n-     int *end_of_file;\n-     int *avail;\n+getc_immediate_nowait (FILE *stream, int *ch, int *end_of_file, int *avail)\n {\n   getc_immediate_common (stream, ch, end_of_file, avail, 0);\n }\n \n /* Called by getc_immediate () and getc_immediate_nowait () */\n \n void\n-getc_immediate_common (stream, ch, end_of_file, avail, waiting)\n-     FILE *stream;\n-     int *ch;\n-     int *end_of_file;\n-     int *avail;\n-     int waiting;\n+getc_immediate_common (FILE *stream,\n+                       int *ch,\n+                       int *end_of_file,\n+                       int *avail,\n+                       int waiting)\n {\n #if defined (linux) || defined (sun) || defined (sgi) || defined (__EMX__) \\\n     || (defined (__osf__) && ! defined (__alpha_vxworks)) \\\n@@ -614,31 +599,31 @@ getc_immediate_common (stream, ch, end_of_file, avail, waiting)\n    will want to import these).  We use the same names as the routines used\n    by AdaMagic for compatibility.  */\n \n-char *rts_get_hInstance     PARAMS ((void));\n-char *rts_get_hPrevInstance PARAMS ((void));\n-char *rts_get_lpCommandLine PARAMS ((void));\n-int   rts_get_nShowCmd      PARAMS ((void));\n+char *rts_get_hInstance (void);\n+char *rts_get_hPrevInstance (void);\n+char *rts_get_lpCommandLine (void);\n+int   rts_get_nShowCmd (void);\n \n char *\n-rts_get_hInstance ()\n+rts_get_hInstance (void)\n {\n   return (char *)GetModuleHandleA (0);\n }\n \n char *\n-rts_get_hPrevInstance ()\n+rts_get_hPrevInstance (void)\n {\n   return 0;\n }\n \n char *\n-rts_get_lpCommandLine ()\n+rts_get_lpCommandLine (void)\n {\n   return GetCommandLineA ();\n }\n \n int\n-rts_get_nShowCmd ()\n+rts_get_nShowCmd (void)\n {\n   return 1;\n }\n@@ -650,10 +635,10 @@ rts_get_nShowCmd ()\n \n #include <time.h>\n \n-extern long get_gmtoff PARAMS ((void));\n+extern long get_gmtoff (void);\n \n long\n-get_gmtoff ()\n+get_gmtoff (void)\n {\n   time_t t;\n   struct tm *ts;\n@@ -668,22 +653,19 @@ get_gmtoff ()\n \n #if defined (_AIX) || defined (__EMX__)\n #define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) PARAMS ((void));\n+extern void (*Lock_Task) (void);\n \n #define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) PARAMS ((void));\n+extern void (*Unlock_Task) (void);\n \n /* Provide reentrant version of localtime on Aix and OS/2. Note that AiX does\n    provide localtime_r, but in the library libc_r which doesn't get included\n    systematically, so we can't use it. */\n \n-extern struct tm *__gnat_localtime_r PARAMS ((const time_t *,\n-\t\t\t\t\t      struct tm *));\n+extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n \n struct tm *\n-__gnat_localtime_r (timer, tp)\n-     const time_t *timer;\n-     struct tm *tp;\n+__gnat_localtime_r (const time_t *timer, struct tm *tp)\n {\n   struct tm *tmp;\n \n@@ -703,12 +685,10 @@ __gnat_localtime_r (timer, tp)\n    spec is required. Only use when ___THREADS_POSIX4ad4__ is defined,\n    the Lynx convention when building against the legacy API. */\n \n-extern struct tm *__gnat_localtime_r PARAMS ((const time_t *, struct tm *));\n+extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n \n struct tm *\n-__gnat_localtime_r (timer, tp)\n-     const time_t *timer;\n-     struct tm *tp;\n+__gnat_localtime_r (const time_t *timer, struct tm *tp)\n {\n   localtime_r (tp, timer);\n   return NULL;\n@@ -723,12 +703,10 @@ __gnat_localtime_r (timer, tp)\n \n /* All other targets provide a standard localtime_r */\n \n-extern struct tm *__gnat_localtime_r PARAMS ((const time_t *, struct tm *));\n+extern struct tm *__gnat_localtime_r (const time_t *, struct tm *);\n \n struct tm *\n-__gnat_localtime_r (timer, tp)\n-     const time_t *timer;\n-     struct tm *tp;\n+__gnat_localtime_r (const time_t *timer, struct tm *tp)\n {\n   return (struct tm *) localtime_r (timer, tp);\n }"}, {"sha": "1ffaf0e90958b26192545cd5e213534f51791548", "filename": "gcc/ada/targtyps.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -69,86 +69,86 @@\n    to determine the sizes that are used for various C types. */\n \n Pos\n-get_target_bits_per_unit ()\n+get_target_bits_per_unit (void)\n {\n   return BITS_PER_UNIT;\n }\n \n Pos\n-get_target_bits_per_word ()\n+get_target_bits_per_word (void)\n {\n   return BITS_PER_WORD;\n }\n \n Pos\n-get_target_char_size ()\n+get_target_char_size (void)\n {\n   return CHAR_TYPE_SIZE;\n }\n \n Pos\n-get_target_wchar_t_size ()\n+get_target_wchar_t_size (void)\n {\n   /* We never want wide chacters less than \"short\" in Ada.  */\n   return MAX (SHORT_TYPE_SIZE, WCHAR_TYPE_SIZE);\n }\n \n Pos\n-get_target_short_size ()\n+get_target_short_size (void)\n {\n   return SHORT_TYPE_SIZE;\n }\n \n Pos\n-get_target_int_size ()\n+get_target_int_size (void)\n {\n   return INT_TYPE_SIZE;\n }\n \n Pos\n-get_target_long_size ()\n+get_target_long_size (void)\n {\n   return ADA_LONG_TYPE_SIZE;\n }\n \n Pos\n-get_target_long_long_size ()\n+get_target_long_long_size (void)\n {\n   return LONG_LONG_TYPE_SIZE;\n }\n \n Pos\n-get_target_float_size ()\n+get_target_float_size (void)\n {\n   return FLOAT_TYPE_SIZE;\n }\n \n Pos\n-get_target_double_size ()\n+get_target_double_size (void)\n {\n   return DOUBLE_TYPE_SIZE;\n }\n \n Pos\n-get_target_long_double_size ()\n+get_target_long_double_size (void)\n {\n   return WIDEST_HARDWARE_FP_SIZE;\n }\n \n Pos\n-get_target_pointer_size ()\n+get_target_pointer_size (void)\n {\n   return POINTER_SIZE;\n }\n \n Pos\n-get_target_maximum_alignment ()\n+get_target_maximum_alignment (void)\n {\n   return BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n }\n \n Boolean\n-get_target_no_dollar_in_label ()\n+get_target_no_dollar_in_label (void)\n {\n #ifdef NO_DOLLAR_IN_LABEL\n   return 1;\n@@ -162,31 +162,31 @@ get_target_no_dollar_in_label ()\n #endif\n \n Nat\n-get_float_words_be ()\n+get_float_words_be (void)\n {\n   return FLOAT_WORDS_BIG_ENDIAN;\n }\n \n Nat\n-get_words_be ()\n+get_words_be (void)\n {\n   return WORDS_BIG_ENDIAN;\n }\n \n Nat\n-get_bytes_be ()\n+get_bytes_be (void)\n {\n   return BYTES_BIG_ENDIAN;\n }\n \n Nat\n-get_bits_be ()\n+get_bits_be (void)\n {\n   return BITS_BIG_ENDIAN;\n }\n \n Nat\n-get_strict_alignment ()\n+get_strict_alignment (void)\n {\n   return STRICT_ALIGNMENT;\n }"}, {"sha": "80cacbc3a7ed089e217c16ec4e86af1851346794", "filename": "gcc/ada/tb-alvms.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftb-alvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftb-alvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvms.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -207,12 +207,11 @@ typedef struct {\n  ********************/\n \n int\n-__gnat_backtrace (array, size, exclude_min, exclude_max, skip_frames)\n-     void **array;\n-     int size;\n-     void *exclude_min;\n-     void *exclude_max;\n-     int skip_frames;\n+__gnat_backtrace (void **array,\n+                  int size,\n+                  void *exclude_min,\n+                  void *exclude_max,\n+                  int skip_frames)\n {\n   int cnt;\n "}, {"sha": "b86091f7742959dddf52b4f64b8b82c63077c8d3", "filename": "gcc/ada/tb-alvxw.c", "status": "modified", "additions": 34, "deletions": 58, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftb-alvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftb-alvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftb-alvxw.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -39,7 +39,7 @@\n #include <limits.h>\n #include <string.h>\n \n-extern void kerTaskEntry();\n+extern void kerTaskEntry(void);\n \n /* We still use a number of macros similar to the ones for the generic\n    __gnat_backtrace implementation.  */\n@@ -259,8 +259,7 @@ struct alloc_chain\n struct alloc_chain *trace_alloc_chain;\n \n static void *\n-trace_alloc (n)\n-     unsigned int n;\n+trace_alloc (unsigned int n)\n {\n   struct alloc_chain * result = malloc (n + sizeof(struct alloc_chain));\n \n@@ -270,7 +269,7 @@ trace_alloc (n)\n }\n \n static void\n-free_trace_alloc ()\n+free_trace_alloc (void)\n {\n   while (trace_alloc_chain != 0)\n     {\n@@ -285,9 +284,7 @@ free_trace_alloc ()\n    otherwise. */\n \n static int\n-read_memory_safe4 (addr, dest)\n-     CORE_ADDR addr;\n-     unsigned int *dest;\n+read_memory_safe4 (CORE_ADDR addr, unsigned int *dest)\n {\n   *dest = *((unsigned int*) addr);\n   return 0;\n@@ -297,17 +294,14 @@ read_memory_safe4 (addr, dest)\n    otherwise. */\n \n static int\n-read_memory_safe8 (addr, dest)\n-     CORE_ADDR addr;\n-     CORE_ADDR *dest;\n+read_memory_safe8 (CORE_ADDR addr, CORE_ADDR *dest)\n {\n   *dest = *((CORE_ADDR*) addr);\n   return 0;\n }\n \n static CORE_ADDR\n-read_register (regno)\n-     int regno;\n+read_register (int regno)\n {\n   if (regno >= 0 && regno < 31)\n     return theRegisters[regno];\n@@ -316,23 +310,20 @@ read_register (regno)\n }\n \n static void\n-frame_saved_regs_zalloc (fi)\n-     struct frame_info *fi;\n+frame_saved_regs_zalloc (struct frame_info *fi)\n {\n   fi->saved_regs = (CORE_ADDR *) trace_alloc (SIZEOF_FRAME_SAVED_REGS);\n   memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);\n }\n \n static void *\n-frame_obstack_alloc (size)\n-     unsigned long size;\n+frame_obstack_alloc (unsigned long size)\n {\n   return (void *) trace_alloc (size);\n }\n \n static int\n-inside_entry_file (addr)\n-     CORE_ADDR addr;\n+inside_entry_file (CORE_ADDR addr)\n {\n   if (addr == 0)\n     return 1;\n@@ -341,8 +332,7 @@ inside_entry_file (addr)\n }\n \n static CORE_ADDR\n-alpha_saved_pc_after_call (frame)\n-     struct frame_info *frame;\n+alpha_saved_pc_after_call (struct frame_info *frame)\n {\n   CORE_ADDR pc = frame->pc;\n   alpha_extra_func_info_t proc_desc;\n@@ -358,8 +348,7 @@ alpha_saved_pc_after_call (frame)\n    NULL).  */\n \n static void\n-alpha_find_saved_regs (frame)\n-     struct frame_info *frame;\n+alpha_find_saved_regs (struct frame_info *frame)\n {\n   int ireg;\n   CORE_ADDR reg_position;\n@@ -430,9 +419,7 @@ alpha_find_saved_regs (frame)\n }\n \n static CORE_ADDR\n-read_next_frame_reg (fi, regno)\n-     struct frame_info *fi;\n-     int regno;\n+read_next_frame_reg (struct frame_info *fi, int regno)\n {\n   CORE_ADDR result;\n   for (; fi; fi = fi->next)\n@@ -460,8 +447,7 @@ read_next_frame_reg (fi, regno)\n }\n \n static CORE_ADDR\n-alpha_frame_saved_pc (frame)\n-     struct frame_info *frame;\n+alpha_frame_saved_pc (struct frame_info *frame)\n {\n   return read_next_frame_reg (frame, frame->pc_reg);\n }\n@@ -472,8 +458,7 @@ static struct alpha_extra_func_info temp_proc_desc;\n    $zero,($ra),1\" on alpha. */\n \n static int\n-alpha_about_to_return (pc)\n-     CORE_ADDR pc;\n+alpha_about_to_return (CORE_ADDR pc)\n {\n   int inst;\n \n@@ -485,8 +470,7 @@ alpha_about_to_return (pc)\n    containing address PC.   Returns 0 if none detected. */\n \n static CORE_ADDR\n-heuristic_proc_start (pc)\n-     CORE_ADDR pc;\n+heuristic_proc_start (CORE_ADDR pc)\n {\n   CORE_ADDR start_pc = pc;\n   CORE_ADDR fence = start_pc - heuristic_fence_post;\n@@ -512,11 +496,10 @@ heuristic_proc_start (pc)\n }\n \n static alpha_extra_func_info_t\n-heuristic_proc_desc (start_pc, limit_pc, next_frame, saved_regs_p)\n-     CORE_ADDR start_pc;\n-     CORE_ADDR limit_pc;\n-     struct frame_info *next_frame;\n-     struct frame_saved_regs *saved_regs_p;\n+heuristic_proc_desc (CORE_ADDR start_pc,\n+                     CORE_ADDR limit_pc,\n+                     struct frame_info *next_frame,\n+                     struct frame_saved_regs *saved_regs_p)\n {\n   CORE_ADDR sp = read_next_frame_reg (next_frame, SP_REGNUM);\n   CORE_ADDR cur_pc;\n@@ -641,10 +624,9 @@ heuristic_proc_desc (start_pc, limit_pc, next_frame, saved_regs_p)\n }\n \n static alpha_extra_func_info_t\n-find_proc_desc (pc, next_frame, saved_regs)\n-     CORE_ADDR pc;\n-     struct frame_info *next_frame;\n-     struct frame_saved_regs *saved_regs;\n+find_proc_desc (CORE_ADDR pc,\n+                struct frame_info *next_frame,\n+                struct frame_saved_regs *saved_regs)\n {\n   CORE_ADDR startaddr;\n \n@@ -660,8 +642,7 @@ find_proc_desc (pc, next_frame, saved_regs)\n }\n \n static CORE_ADDR\n-alpha_frame_chain (frame)\n-     struct frame_info *frame;\n+alpha_frame_chain (struct frame_info *frame)\n {\n   alpha_extra_func_info_t proc_desc;\n   CORE_ADDR saved_pc = FRAME_SAVED_PC (frame);\n@@ -685,8 +666,7 @@ alpha_frame_chain (frame)\n }\n \n static void\n-init_extra_frame_info (frame)\n-     struct frame_info *frame;\n+init_extra_frame_info (struct frame_info *frame)\n {\n   struct frame_saved_regs temp_saved_regs;\n   alpha_extra_func_info_t proc_desc =\n@@ -729,9 +709,7 @@ init_extra_frame_info (frame)\n    Always returns a non-NULL value.  */\n \n static struct frame_info *\n-create_new_frame (addr, pc)\n-     CORE_ADDR addr;\n-     CORE_ADDR pc;\n+create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n {\n   struct frame_info *fi;\n \n@@ -754,19 +732,19 @@ create_new_frame (addr, pc)\n static CORE_ADDR current_pc;\n \n static void\n-set_current_pc ()\n+set_current_pc (void)\n {\n   current_pc = (CORE_ADDR) __builtin_return_address (0);\n }\n \n static CORE_ADDR\n-read_pc ()\n+read_pc (void)\n {\n   return current_pc;\n }\n \n static struct frame_info *\n-get_current_frame ()\n+get_current_frame (void)\n {\n   return create_new_frame (0, read_pc ());\n }\n@@ -775,8 +753,7 @@ get_current_frame ()\n    If FI is the original frame (it has no caller), return 0.  */\n \n static struct frame_info *\n-get_prev_frame (next_frame)\n-     struct frame_info *next_frame;\n+get_prev_frame (struct frame_info *next_frame)\n {\n   CORE_ADDR address = 0;\n   struct frame_info *prev;\n@@ -897,12 +874,11 @@ get_prev_frame (next_frame)\n     \"stq $\" #regno \", \" #disp \"(%0)\\n\"\n \n int\n-__gnat_backtrace (array, size, exclude_min, exclude_max, skip_frames)\n-     void **array;\n-     int size;\n-     void *exclude_min;\n-     void *exclude_max;\n-     int skip_frames;\n+__gnat_backtrace (void **array,\n+                  int size,\n+                  void *exclude_min,\n+                  void *exclude_max,\n+                  int skip_frames)\n {\n   struct frame_info* top;\n   struct frame_info* current;"}, {"sha": "59ed396d26630781d88583c9fb2214e72f356a94", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -58,7 +58,7 @@\n #include \"system.h\"\n #endif\n \n-extern int __gnat_backtrace PARAMS ((void **, int, void *, void *, int));\n+extern int __gnat_backtrace (void **, int, void *, void *, int);\n \n /* The point is to provide an implementation of the __gnat_bactrace function\n    above, called by the default implementation of the System.Traceback\n@@ -77,10 +77,10 @@ extern int __gnat_backtrace PARAMS ((void **, int, void *, void *, int));\n    function is still referenced by the default System.Traceback.  */\n \n #define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) PARAMS ((void));\n+extern void (*Lock_Task) (void);\n \n #define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) PARAMS ((void));\n+extern void (*Unlock_Task) (void);\n \n /*-------------------------------------*\n  *-- Target specific implementations --*\n@@ -339,12 +339,11 @@ static void forced_callee () {}\n #endif\n \n int\n-__gnat_backtrace (array, size, exclude_min, exclude_max, skip_frames)\n-     void **array;\n-     int size;\n-     void *exclude_min;\n-     void *exclude_max;\n-     int skip_frames;\n+__gnat_backtrace (void **array,\n+                  int size,\n+                  void *exclude_min,\n+                  void *exclude_max,\n+                  int skip_frames)\n {\n   struct layout *current;\n   void *top_frame;"}, {"sha": "8f52bab478f7d19378f0db493238f09268b2693d", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 83, "deletions": 138, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -103,24 +103,22 @@ Node_Id error_gnat_node;\n    a return in some functions.  See processing for N_Subprogram_Body.  */\n static GTY(()) tree gnu_return_label_stack;\n \n-static tree tree_transform\t\tPARAMS((Node_Id));\n-static void elaborate_all_entities\tPARAMS((Node_Id));\n-static void process_freeze_entity\tPARAMS((Node_Id));\n-static void process_inlined_subprograms\tPARAMS((Node_Id));\n-static void process_decls\t\tPARAMS((List_Id, List_Id, Node_Id,\n-\t\t\t\t\t\tint, int));\n-static tree emit_range_check\t\tPARAMS((tree, Node_Id));\n-static tree emit_index_check\t\tPARAMS((tree, tree, tree, tree));\n-static tree emit_check\t\t\tPARAMS((tree, tree, int));\n-static tree convert_with_check\t\tPARAMS((Entity_Id, tree,\n-\t\t\t\t\t\tint, int, int));\n-static int addressable_p\t\tPARAMS((tree));\n-static tree assoc_to_constructor\tPARAMS((Node_Id, tree));\n-static tree extract_values\t\tPARAMS((tree, tree));\n-static tree pos_to_constructor\t\tPARAMS((Node_Id, tree, Entity_Id));\n-static tree maybe_implicit_deref\tPARAMS((tree));\n-static tree gnat_stabilize_reference_1\tPARAMS((tree, int));\n-static int build_unit_elab\t\tPARAMS((Entity_Id, int, tree));\n+static tree tree_transform (Node_Id);\n+static void elaborate_all_entities (Node_Id);\n+static void process_freeze_entity (Node_Id);\n+static void process_inlined_subprograms (Node_Id);\n+static void process_decls (List_Id, List_Id, Node_Id, int, int);\n+static tree emit_range_check (tree, Node_Id);\n+static tree emit_index_check (tree, tree, tree, tree);\n+static tree emit_check (tree, tree, int);\n+static tree convert_with_check (Entity_Id, tree, int, int, int);\n+static int addressable_p (tree);\n+static tree assoc_to_constructor (Node_Id, tree);\n+static tree extract_values (tree, tree);\n+static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n+static tree maybe_implicit_deref (tree);\n+static tree gnat_stabilize_reference_1 (tree, int);\n+static int build_unit_elab (Entity_Id, int, tree);\n \n /* Constants for +0.5 and -0.5 for float-to-integer rounding.  */\n static REAL_VALUE_TYPE dconstp5;\n@@ -130,27 +128,23 @@ static REAL_VALUE_TYPE dconstmp5;\n    structures and then generates code.  */\n \n void\n-gigi (gnat_root, max_gnat_node, number_name, nodes_ptr, next_node_ptr,\n-      prev_node_ptr, elists_ptr, elmts_ptr, strings_ptr, string_chars_ptr,\n-      list_headers_ptr, number_units, file_info_ptr, standard_integer,\n-      standard_long_long_float, standard_exception_type, gigi_operating_mode)\n-     Node_Id gnat_root;\n-     int max_gnat_node;\n-     int number_name;\n-     struct Node *nodes_ptr;\n-     Node_Id *next_node_ptr;\n-     Node_Id *prev_node_ptr;\n-     struct Elist_Header *elists_ptr;\n-     struct Elmt_Item *elmts_ptr;\n-     struct String_Entry *strings_ptr;\n-     Char_Code *string_chars_ptr;\n-     struct List_Header *list_headers_ptr;\n-     Int number_units ATTRIBUTE_UNUSED;\n-     char *file_info_ptr ATTRIBUTE_UNUSED;\n-     Entity_Id standard_integer;\n-     Entity_Id standard_long_long_float;\n-     Entity_Id standard_exception_type;\n-     Int gigi_operating_mode;\n+gigi (Node_Id gnat_root,\n+      int max_gnat_node,\n+      int number_name,\n+      struct Node *nodes_ptr,\n+      Node_Id *next_node_ptr,\n+      Node_Id *prev_node_ptr,\n+      struct Elist_Header *elists_ptr,\n+      struct Elmt_Item *elmts_ptr,\n+      struct String_Entry *strings_ptr,\n+      Char_Code *string_chars_ptr,\n+      struct List_Header *list_headers_ptr,\n+      Int number_units ATTRIBUTE_UNUSED,\n+      char *file_info_ptr ATTRIBUTE_UNUSED,\n+      Entity_Id standard_integer,\n+      Entity_Id standard_long_long_float,\n+      Entity_Id standard_exception_type,\n+      Int gigi_operating_mode)\n {\n   tree gnu_standard_long_long_float;\n   tree gnu_standard_exception_type;\n@@ -233,8 +227,7 @@ gigi (gnat_root, max_gnat_node, number_name, nodes_ptr, next_node_ptr,\n    part of the tree.  */\n \n void\n-gnat_to_code (gnat_node)\n-     Node_Id gnat_node;\n+gnat_to_code (Node_Id gnat_node)\n {\n   tree gnu_root;\n \n@@ -259,8 +252,7 @@ gnat_to_code (gnat_node)\n    code.  */\n \n tree\n-gnat_to_gnu (gnat_node)\n-     Node_Id gnat_node;\n+gnat_to_gnu (Node_Id gnat_node)\n {\n   tree gnu_root;\n \n@@ -286,8 +278,7 @@ gnat_to_gnu (gnat_node)\n    in the above two routines for most purposes.  */\n \n static tree\n-tree_transform (gnat_node)\n-     Node_Id gnat_node;\n+tree_transform (Node_Id gnat_node)\n {\n   tree gnu_result = error_mark_node; /* Default to no value. */\n   tree gnu_result_type = void_type_node;\n@@ -4156,8 +4147,7 @@ tree_transform (gnat_node)\n /* GNU_STMT is a statement.  We generate code for that statement.  */\n \n void\n-gnat_expand_stmt (gnu_stmt)\n-     tree gnu_stmt;\n+gnat_expand_stmt (tree gnu_stmt)\n {\n   set_lineno_from_sloc (TREE_SLOC (gnu_stmt), 1);\n \n@@ -4193,8 +4183,7 @@ gnat_expand_stmt (gnu_stmt)\n    information for types in withed units, for ASIS use  */\n \n static void\n-elaborate_all_entities (gnat_node)\n-     Node_Id gnat_node;\n+elaborate_all_entities (Node_Id gnat_node)\n {\n   Entity_Id gnat_with_clause, gnat_entity;\n \n@@ -4260,8 +4249,7 @@ elaborate_all_entities (gnat_node)\n /* Do the processing of N_Freeze_Entity, GNAT_NODE.  */\n \n static void\n-process_freeze_entity (gnat_node)\n-     Node_Id gnat_node;\n+process_freeze_entity (Node_Id gnat_node)\n {\n   Entity_Id gnat_entity = Entity (gnat_node);\n   tree gnu_old;\n@@ -4369,8 +4357,7 @@ process_freeze_entity (gnat_node)\n    N_Compilation_Unit.  */\n \n static void\n-process_inlined_subprograms (gnat_node)\n-     Node_Id gnat_node;\n+process_inlined_subprograms (Node_Id gnat_node)\n {\n   Entity_Id gnat_entity;\n   Node_Id gnat_body;\n@@ -4416,10 +4403,11 @@ process_inlined_subprograms (gnat_node)\n    correspond to the public and private parts of a package.  */\n \n static void\n-process_decls (gnat_decls, gnat_decls2, gnat_end_list, pass1p, pass2p)\n-     List_Id gnat_decls, gnat_decls2;\n-     Node_Id gnat_end_list;\n-     int pass1p, pass2p;\n+process_decls (List_Id gnat_decls,\n+               List_Id gnat_decls2,\n+               Node_Id gnat_end_list,\n+               int pass1p, \n+               int pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -4536,9 +4524,7 @@ process_decls (gnat_decls, gnat_decls2, gnat_end_list, pass1p, pass2p)\n    which we have to check. */\n \n static tree\n-emit_range_check (gnu_expr, gnat_range_type)\n-     tree gnu_expr;\n-     Entity_Id gnat_range_type;\n+emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n {\n   tree gnu_range_type = get_unpadded_type (gnat_range_type);\n   tree gnu_low  = TYPE_MIN_VALUE (gnu_range_type);\n@@ -4588,11 +4574,10 @@ emit_range_check (gnu_expr, gnat_range_type)\n    subprograms having unconstrained array formal parameters */\n \n static tree\n-emit_index_check (gnu_array_object, gnu_expr, gnu_low, gnu_high)\n-     tree gnu_array_object;\n-     tree gnu_expr;\n-     tree gnu_low;\n-     tree gnu_high;\n+emit_index_check (tree gnu_array_object,\n+                  tree gnu_expr,\n+                  tree gnu_low,\n+                  tree gnu_high)\n {\n   tree gnu_expr_check;\n \n@@ -4635,10 +4620,7 @@ emit_index_check (gnu_array_object, gnu_expr, gnu_low, gnu_high)\n    why the exception was raised.  */\n \n static tree\n-emit_check (gnu_cond, gnu_expr, reason)\n-     tree gnu_cond;\n-     tree gnu_expr;\n-     int reason;\n+emit_check (tree gnu_cond, tree gnu_expr, int reason)\n {\n   tree gnu_call;\n   tree gnu_result;\n@@ -4676,12 +4658,11 @@ emit_check (gnu_cond, gnu_expr, reason)\n    truncation; otherwise round.  */\n \n static tree\n-convert_with_check (gnat_type, gnu_expr, overflow_p, range_p, truncate_p)\n-     Entity_Id gnat_type;\n-     tree gnu_expr;\n-     int overflow_p;\n-     int range_p;\n-     int truncate_p;\n+convert_with_check (Entity_Id gnat_type,\n+                    tree gnu_expr,\n+                    int overflow_p,\n+                    int range_p,\n+                    int truncate_p)\n {\n   tree gnu_type = get_unpadded_type (gnat_type);\n   tree gnu_in_type = TREE_TYPE (gnu_expr);\n@@ -4820,8 +4801,7 @@ convert_with_check (gnat_type, gnu_expr, overflow_p, range_p, truncate_p)\n    cases.  */\n \n static int\n-addressable_p (gnu_expr)\n-     tree gnu_expr;\n+addressable_p (tree gnu_expr)\n {\n   switch (TREE_CODE (gnu_expr))\n     {\n@@ -4883,8 +4863,7 @@ addressable_p (gnu_expr)\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n \n void\n-process_type (gnat_entity)\n-     Entity_Id gnat_entity;\n+process_type (Entity_Id gnat_entity)\n {\n   tree gnu_old\n     = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : 0;\n@@ -4979,9 +4958,7 @@ process_type (gnat_entity)\n    Return a CONSTRUCTOR to build the record.  */\n \n static tree\n-assoc_to_constructor (gnat_assoc, gnu_type)\n-     Node_Id gnat_assoc;\n-     tree gnu_type;\n+assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n {\n   tree gnu_field, gnu_list, gnu_result;\n \n@@ -5030,10 +5007,9 @@ assoc_to_constructor (gnat_assoc, gnu_type)\n    of the array component. It is needed for range checking. */\n \n static tree\n-pos_to_constructor (gnat_expr, gnu_array_type, gnat_component_type)\n-     Node_Id gnat_expr;\n-     tree gnu_array_type;\n-     Entity_Id gnat_component_type;\n+pos_to_constructor (Node_Id gnat_expr,\n+                    tree gnu_array_type,\n+                    Entity_Id gnat_component_type)\n {\n   tree gnu_expr;\n   tree gnu_expr_list = NULL_TREE;\n@@ -5074,9 +5050,7 @@ pos_to_constructor (gnat_expr, gnu_array_type, gnat_component_type)\n    record, make a recursive call to fill it in as well.  */\n \n static tree\n-extract_values (values, record_type)\n-     tree values;\n-     tree record_type;\n+extract_values (tree values, tree record_type)\n {\n   tree result = NULL_TREE;\n   tree field, tem;\n@@ -5123,8 +5097,7 @@ extract_values (values, record_type)\n    an access object and perform the required dereferences.  */\n \n static tree\n-maybe_implicit_deref (exp)\n-     tree exp;\n+maybe_implicit_deref (tree exp)\n {\n   /* If the type is a pointer, dereference it.  */\n \n@@ -5142,8 +5115,7 @@ maybe_implicit_deref (exp)\n /* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n \n tree\n-protect_multiple_eval (exp)\n-     tree exp;\n+protect_multiple_eval (tree exp)\n {\n   tree type = TREE_TYPE (exp);\n \n@@ -5182,9 +5154,7 @@ protect_multiple_eval (exp)\n    whether to force evaluation of everything.  */\n \n tree\n-gnat_stabilize_reference (ref, force)\n-     tree ref;\n-     int force;\n+gnat_stabilize_reference (tree ref, int force)\n {\n   register tree type = TREE_TYPE (ref);\n   register enum tree_code code = TREE_CODE (ref);\n@@ -5280,9 +5250,7 @@ gnat_stabilize_reference (ref, force)\n    arg to force a SAVE_EXPR for everything.  */\n \n static tree\n-gnat_stabilize_reference_1 (e, force)\n-     tree e;\n-     int force;\n+gnat_stabilize_reference_1 (tree e, int force)\n {\n   register enum tree_code code = TREE_CODE (e);\n   register tree type = TREE_TYPE (e);\n@@ -5345,10 +5313,7 @@ gnat_stabilize_reference_1 (e, force)\n    Return 1 if we didn't need an elaboration function, zero otherwise.  */\n \n static int\n-build_unit_elab (gnat_unit, body_p, gnu_elab_list)\n-     Entity_Id gnat_unit;\n-     int body_p;\n-     tree gnu_elab_list;\n+build_unit_elab (Entity_Id gnat_unit, int body_p, tree gnu_elab_list)\n {\n   tree gnu_decl;\n   rtx insn;\n@@ -5429,16 +5394,14 @@ build_unit_elab (gnat_unit, body_p, gnu_elab_list)\n   return result;\n }\n \f\n-extern char *__gnat_to_canonical_file_spec PARAMS ((char *));\n+extern char *__gnat_to_canonical_file_spec (char *);\n \n /* Determine the input_filename and the input_line from the source location\n    (Sloc) of GNAT_NODE node.  Set the global variable input_filename and\n    input_line.  If WRITE_NOTE_P is true, emit a line number note.  */\n \n void\n-set_lineno (gnat_node, write_note_p)\n-     Node_Id gnat_node;\n-     int write_note_p;\n+set_lineno (Node_Id gnat_node, int write_note_p)\n {\n   Source_Ptr source_location = Sloc (gnat_node);\n \n@@ -5448,9 +5411,7 @@ set_lineno (gnat_node, write_note_p)\n /* Likewise, but passed a Sloc.  */\n \n void\n-set_lineno_from_sloc (source_location, write_note_p)\n-     Source_Ptr source_location;\n-     int write_note_p;\n+set_lineno_from_sloc (Source_Ptr source_location, int write_note_p)\n {\n   /* If node not from source code, ignore.  */\n   if (source_location < 0)\n@@ -5486,9 +5447,7 @@ set_lineno_from_sloc (source_location, write_note_p)\n    \"&\" substitution.  */\n \n void\n-post_error (msg, node)\n-     const char *msg;\n-     Node_Id node;\n+post_error (const char *msg, Node_Id node)\n {\n   String_Template temp;\n   Fat_Pointer fp;\n@@ -5503,10 +5462,7 @@ post_error (msg, node)\n    is the node to use for the \"&\" substitution.  */\n \n void\n-post_error_ne (msg, node, ent)\n-     const char *msg;\n-     Node_Id node;\n-     Entity_Id ent;\n+post_error_ne (const char *msg, Node_Id node, Entity_Id ent)\n {\n   String_Template temp;\n   Fat_Pointer fp;\n@@ -5521,11 +5477,7 @@ post_error_ne (msg, node, ent)\n    to use for the \"&\" substitution, and N is the number to use for the ^.  */\n \n void\n-post_error_ne_num (msg, node, ent, n)\n-     const char *msg;\n-     Node_Id node;\n-     Entity_Id ent;\n-     int n;\n+post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent, int n)\n {\n   String_Template temp;\n   Fat_Pointer fp;\n@@ -5545,11 +5497,7 @@ post_error_ne_num (msg, node, ent, n)\n    and the text inside square brackets will be output instead.  */\n \n void\n-post_error_ne_tree (msg, node, ent, t)\n-     const char *msg;\n-     Node_Id node;\n-     Entity_Id ent;\n-     tree t;\n+post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent, tree t)\n {\n   char *newmsg = alloca (strlen (msg) + 1);\n   String_Template temp = {1, 0};\n@@ -5597,12 +5545,11 @@ post_error_ne_tree (msg, node, ent, t)\n    integer to write in the message.  */\n \n void\n-post_error_ne_tree_2 (msg, node, ent, t, num)\n-     const char *msg;\n-     Node_Id node;\n-     Entity_Id ent;\n-     tree t;\n-     int num;\n+post_error_ne_tree_2 (const char *msg,\n+                      Node_Id node,\n+                      Entity_Id ent,\n+                      tree t,\n+                      int num)\n {\n   Error_Msg_Uint_2 = UI_From_Int (num);\n   post_error_ne_tree (msg, node, ent, t);\n@@ -5611,8 +5558,7 @@ post_error_ne_tree_2 (msg, node, ent, t, num)\n /* Set the node for a second '&' in the error message.  */\n \n void\n-set_second_error_entity (e)\n-     Entity_Id e;\n+set_second_error_entity (Entity_Id e)\n {\n   Error_Msg_Node_2 = e;\n }\n@@ -5621,8 +5567,7 @@ set_second_error_entity (e)\n    as the relevant node that provides the location info for the error */\n \n void\n-gigi_abort (code)\n-     int code;\n+gigi_abort (int code)\n {\n   String_Template temp = {1, 10};\n   Fat_Pointer fp;\n@@ -5637,7 +5582,7 @@ gigi_abort (code)\n    binary and unary operations.  */\n \n void\n-init_code_table ()\n+init_code_table (void)\n {\n   gnu_codes[N_And_Then] = TRUTH_ANDIF_EXPR;\n   gnu_codes[N_Or_Else] = TRUTH_ORIF_EXPR;"}, {"sha": "85a159b6d1e56ee4dd62f6c4c88c33a2423347a8", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 111, "deletions": 193, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -144,22 +144,21 @@ struct language_function GTY(())\n   int unused;\n };\n \n-static tree merge_sizes\t\t\tPARAMS ((tree, tree, tree, int, int));\n-static tree compute_related_constant\tPARAMS ((tree, tree));\n-static tree split_plus\t\t\tPARAMS ((tree, tree *));\n-static int value_zerop\t\t\tPARAMS ((tree));\n-static tree float_type_for_size\t\tPARAMS ((int, enum machine_mode));\n-static tree convert_to_fat_pointer\tPARAMS ((tree, tree));\n-static tree convert_to_thin_pointer\tPARAMS ((tree, tree));\n-static tree make_descriptor_field\tPARAMS ((const char *,tree, tree,\n-\t\t\t\t\t\t tree));\n-static int value_factor_p\t\tPARAMS ((tree, int));\n-static int potential_alignment_gap\tPARAMS ((tree, tree, tree));\n+static tree merge_sizes (tree, tree, tree, int, int);\n+static tree compute_related_constant (tree, tree);\n+static tree split_plus (tree, tree *);\n+static int value_zerop (tree);\n+static tree float_type_for_size (int, enum machine_mode);\n+static tree convert_to_fat_pointer (tree, tree);\n+static tree convert_to_thin_pointer (tree, tree);\n+static tree make_descriptor_field (const char *,tree, tree, tree);\n+static int value_factor_p (tree, int);\n+static int potential_alignment_gap (tree, tree, tree);\n \f\n /* Initialize the association of GNAT nodes to GCC trees.  */\n \n void\n-init_gnat_to_gnu ()\n+init_gnat_to_gnu (void)\n {\n   associate_gnat_to_gnu\n     = (tree *) ggc_alloc_cleared (max_gnat_nodes * sizeof (tree));\n@@ -174,10 +173,7 @@ init_gnat_to_gnu ()\n    If GNU_DECL is zero, a previous association is to be reset.  */\n \n void\n-save_gnu_tree (gnat_entity, gnu_decl, no_check)\n-     Entity_Id gnat_entity;\n-     tree gnu_decl;\n-     int no_check;\n+save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl, int no_check)\n {\n   /* Check that GNAT_ENTITY is not already defined and that it is being set\n      to something which is a decl.  Raise gigi 401 if not.  Usually, this\n@@ -199,8 +195,7 @@ save_gnu_tree (gnat_entity, gnu_decl, no_check)\n    be elaborated only once, GNAT_ENTITY is really not an entity.  */\n \n tree\n-get_gnu_tree (gnat_entity)\n-     Entity_Id gnat_entity;\n+get_gnu_tree (Entity_Id gnat_entity)\n {\n   if (! associate_gnat_to_gnu[gnat_entity - First_Node_Id])\n     gigi_abort (402);\n@@ -211,8 +206,7 @@ get_gnu_tree (gnat_entity)\n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n \n int\n-present_gnu_tree (gnat_entity)\n-     Entity_Id gnat_entity;\n+present_gnu_tree (Entity_Id gnat_entity)\n {\n   return (associate_gnat_to_gnu[gnat_entity - First_Node_Id] != NULL_TREE);\n }\n@@ -221,7 +215,7 @@ present_gnu_tree (gnat_entity)\n /* Return non-zero if we are currently in the global binding level.  */\n \n int\n-global_bindings_p ()\n+global_bindings_p (void)\n {\n   return (force_global != 0 || current_binding_level == global_binding_level\n \t  ? -1 : 0);\n@@ -231,15 +225,15 @@ global_bindings_p ()\n    is in reverse order (it has to be so for back-end compatibility).  */\n \n tree\n-getdecls ()\n+getdecls (void)\n {\n   return current_binding_level->names;\n }\n \n /* Nonzero if the current level needs to have a BLOCK made.  */\n \n int\n-kept_level_p ()\n+kept_level_p (void)\n {\n   return (current_binding_level->names != 0);\n }\n@@ -248,8 +242,7 @@ kept_level_p ()\n    specified for back-end compatibility.  */\n \n void\n-pushlevel (ignore)\n-     int ignore ATTRIBUTE_UNUSED;\n+pushlevel (int ignore ATTRIBUTE_UNUSED)\n {\n   struct binding_level *newlevel = NULL;\n \n@@ -287,10 +280,7 @@ pushlevel (ignore)\n    them into the BLOCK.  */\n \n tree\n-poplevel (keep, reverse, functionbody)\n-     int keep;\n-     int reverse;\n-     int functionbody;\n+poplevel (int keep, int reverse, int functionbody)\n {\n   /* Points to a GCC BLOCK tree node. This is the BLOCK node construted for the\n      binding level that we are about to exit and which is returned by this\n@@ -396,8 +386,7 @@ poplevel (keep, reverse, functionbody)\n    to handle the BLOCK node inside the BIND_EXPR.  */\n \n void\n-insert_block (block)\n-     tree block;\n+insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n   current_binding_level->blocks\n@@ -408,8 +397,7 @@ insert_block (block)\n    (the one we are currently in).  */\n \n void\n-set_block (block)\n-     tree block;\n+set_block (tree block)\n {\n   current_binding_level->this_block = block;\n   current_binding_level->names = chainon (current_binding_level->names,\n@@ -422,8 +410,7 @@ set_block (block)\n    Returns the ..._DECL node. */\n \n tree\n-pushdecl (decl)\n-     tree decl;\n+pushdecl (tree decl)\n {\n   struct binding_level *b;\n \n@@ -478,7 +465,7 @@ pushdecl (decl)\n    front end has been run.  */\n \n void\n-gnat_init_decl_processing ()\n+gnat_init_decl_processing (void)\n {\n   input_line = 0;\n \n@@ -516,8 +503,7 @@ gnat_init_decl_processing ()\n    in the gcc back-end and initialize the global binding level.  */\n \n void\n-init_gigi_decls (long_long_float_type, exception_type)\n-     tree long_long_float_type, exception_type;\n+init_gigi_decls (tree long_long_float_type, tree exception_type)\n {\n   tree endlink, decl;\n   unsigned int i;\n@@ -708,11 +694,10 @@ init_gigi_decls (long_long_float_type, exception_type)\n    on this type; it will be done later. */\n \n void\n-finish_record_type (record_type, fieldlist, has_rep, defer_debug)\n-     tree record_type;\n-     tree fieldlist;\n-     int has_rep;\n-     int defer_debug;\n+finish_record_type (tree record_type,\n+                    tree fieldlist,\n+                    int has_rep,\n+                    int defer_debug)\n {\n   enum tree_code code = TREE_CODE (record_type);\n   tree ada_size = bitsize_zero_node;\n@@ -1030,11 +1015,11 @@ finish_record_type (record_type, fieldlist, has_rep, defer_debug)\n    We return an expression for the size.  */\n \n static tree\n-merge_sizes (last_size, first_bit, size, special, has_rep)\n-     tree last_size;\n-     tree first_bit, size;\n-     int special;\n-     int has_rep;\n+merge_sizes (tree last_size,\n+             tree first_bit,\n+             tree size,\n+             int special,\n+             int has_rep)\n {\n   tree type = TREE_TYPE (last_size);\n   tree new;\n@@ -1070,8 +1055,7 @@ merge_sizes (last_size, first_bit, size, special, has_rep)\n    related by the addition of a constant.  Return that constant if so.  */\n \n static tree\n-compute_related_constant (op0, op1)\n-     tree op0, op1;\n+compute_related_constant (tree op0, tree op1)\n {\n   tree op0_var, op1_var;\n   tree op0_con = split_plus (op0, &op0_var);\n@@ -1092,9 +1076,7 @@ compute_related_constant (op0, op1)\n    bitsizetype.  */\n \n static tree\n-split_plus (in, pvar)\n-     tree in;\n-     tree *pvar;\n+split_plus (tree in, tree *pvar)\n {\n   /* Strip NOPS in order to ease the tree traversal and maximize the\n      potential for constant or plus/minus discovery. We need to be careful\n@@ -1137,12 +1119,12 @@ split_plus (in, pvar)\n    depressed stack pointer.  */\n \n tree\n-create_subprog_type (return_type, param_decl_list, cico_list,\n-\t\t     returns_unconstrained, returns_by_ref, returns_with_dsp)\n-     tree return_type;\n-     tree param_decl_list;\n-     tree cico_list;\n-     int returns_unconstrained, returns_by_ref, returns_with_dsp;\n+create_subprog_type (tree return_type,\n+                     tree param_decl_list,\n+                     tree cico_list,\n+                     int returns_unconstrained,\n+                     int returns_by_ref,\n+                     int returns_with_dsp)\n {\n   /* A chain of TREE_LIST nodes whose TREE_VALUEs are the data type nodes of\n      the subprogram formal parameters. This list is generated by traversing the\n@@ -1186,8 +1168,7 @@ create_subprog_type (return_type, param_decl_list, cico_list,\n /* Return a copy of TYPE but safe to modify in any way.  */\n \n tree\n-copy_type (type)\n-     tree type;\n+copy_type (tree type)\n {\n   tree new = copy_node (type);\n \n@@ -1207,9 +1188,7 @@ copy_type (type)\n    TYPE_INDEX_TYPE is INDEX.  */\n \n tree\n-create_index_type (min, max, index)\n-     tree min, max;\n-     tree index;\n+create_index_type (tree min, tree max, tree index)\n {\n   /* First build a type for the desired range.  */\n   tree type = build_index_2_type (min, max);\n@@ -1235,12 +1214,11 @@ create_index_type (min, max, index)\n    information about this type.  */\n \n tree\n-create_type_decl (type_name, type, attr_list, artificial_p, debug_info_p)\n-     tree type_name;\n-     tree type;\n-     struct attrib *attr_list;\n-     int artificial_p;\n-     int debug_info_p;\n+create_type_decl (tree type_name,\n+                  tree type,\n+                  struct attrib *attr_list,\n+                  int artificial_p,\n+                  int debug_info_p)\n {\n   tree type_decl = build_decl (TYPE_DECL, type_name, type);\n   enum tree_code code = TREE_CODE (type);\n@@ -1282,17 +1260,15 @@ create_type_decl (type_name, type, attr_list, artificial_p, debug_info_p)\n    it indicates whether to always allocate storage to the variable.   */\n \n tree\n-create_var_decl (var_name, asm_name, type, var_init, const_flag, public_flag,\n-\t\t extern_flag, static_flag, attr_list)\n-     tree var_name;\n-     tree asm_name;\n-     tree type;\n-     tree var_init;\n-     int const_flag;\n-     int public_flag;\n-     int extern_flag;\n-     int static_flag;\n-     struct attrib *attr_list;\n+create_var_decl (tree var_name,\n+                 tree asm_name,\n+                 tree type,\n+                 tree var_init,\n+                 int const_flag,\n+                 int public_flag,\n+                 int extern_flag,\n+                 int static_flag,\n+                 struct attrib *attr_list)\n {\n   int init_const\n     = (var_init == 0\n@@ -1397,14 +1373,13 @@ create_var_decl (var_name, asm_name, type, var_init, const_flag, public_flag,\n    the address of this field for aliasing purposes.  */\n \n tree\n-create_field_decl (field_name, field_type, record_type, packed, size, pos,\n-\t\t   addressable)\n-     tree field_name;\n-     tree field_type;\n-     tree record_type;\n-     int packed;\n-     tree size, pos;\n-     int addressable;\n+create_field_decl (tree field_name,\n+                   tree field_type,\n+                   tree record_type,\n+                   int packed,\n+                   tree size,\n+                   tree pos,\n+                   int addressable)\n {\n   tree field_decl = build_decl (FIELD_DECL, field_name, field_type);\n \n@@ -1515,8 +1490,7 @@ create_field_decl (field_name, field_type, record_type, packed, size, pos,\n    effects, has the value of zero.  */\n \n static int\n-value_zerop (exp)\n-     tree exp;\n+value_zerop (tree exp)\n {\n   if (TREE_CODE (exp) == COMPOUND_EXPR)\n     return value_zerop (TREE_OPERAND (exp, 1));\n@@ -1530,10 +1504,7 @@ value_zerop (exp)\n    parameter). */\n \n tree\n-create_param_decl (param_name, param_type, readonly)\n-     tree param_name;\n-     tree param_type;\n-     int readonly;\n+create_param_decl (tree param_name, tree param_type, int readonly)\n {\n   tree param_decl = build_decl (PARM_DECL, param_name, param_type);\n \n@@ -1570,9 +1541,7 @@ create_param_decl (param_name, param_type, readonly)\n /* Given a DECL and ATTR_LIST, process the listed attributes.  */\n \n void\n-process_attributes (decl, attr_list)\n-     tree decl;\n-     struct attrib *attr_list;\n+process_attributes (tree decl, struct attrib *attr_list)\n {\n   for (; attr_list; attr_list = attr_list->next)\n     switch (attr_list->type)\n@@ -1613,9 +1582,7 @@ process_attributes (decl, attr_list)\n /* Add some pending elaborations on the list.  */\n \n void\n-add_pending_elaborations (var_decl, var_init)\n-     tree var_decl;\n-     tree var_init;\n+add_pending_elaborations (tree var_decl, tree var_init)\n {\n   if (var_init != 0)\n     Check_Elaboration_Code_Allowed (error_gnat_node);\n@@ -1627,7 +1594,7 @@ add_pending_elaborations (var_decl, var_init)\n /* Obtain any pending elaborations and clear the old list.  */\n \n tree\n-get_pending_elaborations ()\n+get_pending_elaborations (void)\n {\n   /* Each thing added to the list went on the end; we want it on the\n      beginning.  */\n@@ -1641,9 +1608,7 @@ get_pending_elaborations ()\n    of 2. */\n \n static int\n-value_factor_p (value, factor)\n-     tree value;\n-     int  factor;\n+value_factor_p (tree value, int factor)\n {\n   if (host_integerp (value, 1))\n     return tree_low_cst (value, 1) % factor == 0;\n@@ -1662,10 +1627,7 @@ value_factor_p (value, factor)\n    position of CURR_FIELD. It is ignored if null. */\n \n static int\n-potential_alignment_gap (prev_field, curr_field, offset)\n-     tree prev_field;\n-     tree curr_field;\n-     tree offset;\n+potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n {\n   /* If this is the first field of the record, there cannot be any gap */\n   if (!prev_field)\n@@ -1707,7 +1669,7 @@ potential_alignment_gap (prev_field, curr_field, offset)\n /* Return nonzero if there are pending elaborations.  */\n \n int\n-pending_elaborations_p ()\n+pending_elaborations_p (void)\n {\n   return TREE_CHAIN (pending_elaborations) != 0;\n }\n@@ -1716,7 +1678,7 @@ pending_elaborations_p ()\n    one.  */\n \n void\n-push_pending_elaborations ()\n+push_pending_elaborations (void)\n {\n   struct e_stack *p = (struct e_stack *) ggc_alloc (sizeof (struct e_stack));\n \n@@ -1729,7 +1691,7 @@ push_pending_elaborations ()\n /* Pop the stack of pending elaborations.  */\n \n void\n-pop_pending_elaborations ()\n+pop_pending_elaborations (void)\n {\n   struct e_stack *p = elist_stack;\n \n@@ -1741,7 +1703,7 @@ pop_pending_elaborations ()\n    elaborations after that point.  */\n \n tree\n-get_elaboration_location ()\n+get_elaboration_location (void)\n {\n   return tree_last (pending_elaborations);\n }\n@@ -1750,8 +1712,7 @@ get_elaboration_location ()\n    list.  */\n \n void\n-insert_elaboration_list (elab)\n-     tree elab;\n+insert_elaboration_list (tree elab)\n {\n   tree next = TREE_CHAIN (elab);\n \n@@ -1766,8 +1727,7 @@ insert_elaboration_list (elab)\n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n \n tree\n-create_label_decl (label_name)\n-     tree label_name;\n+create_label_decl (tree label_name)\n {\n   tree label_decl = build_decl (LABEL_DECL, label_name, void_type_node);\n \n@@ -1787,16 +1747,14 @@ create_label_decl (label_name)\n    appropriate fields in the FUNCTION_DECL.  */\n \n tree\n-create_subprog_decl (subprog_name, asm_name, subprog_type, param_decl_list,\n-\t\t     inline_flag, public_flag, extern_flag, attr_list)\n-     tree subprog_name;\n-     tree asm_name;\n-     tree subprog_type;\n-     tree param_decl_list;\n-     int inline_flag;\n-     int public_flag;\n-     int extern_flag;\n-     struct attrib *attr_list;\n+create_subprog_decl (tree subprog_name,\n+                     tree asm_name,\n+                     tree subprog_type,\n+                     tree param_decl_list,\n+                     int inline_flag,\n+                     int public_flag,\n+                     int extern_flag,\n+                     struct attrib *attr_list)\n {\n   tree return_type  = TREE_TYPE (subprog_type);\n   tree subprog_decl = build_decl (FUNCTION_DECL, subprog_name, subprog_type);\n@@ -1842,8 +1800,7 @@ static int function_nesting_depth;\n    appearing in the subprogram.  */\n \n void\n-begin_subprog_body (subprog_decl)\n-     tree subprog_decl;\n+begin_subprog_body (tree subprog_decl)\n {\n   tree param_decl_list;\n   tree param_decl;\n@@ -1905,7 +1862,7 @@ begin_subprog_body (subprog_decl)\n    to assembler language output.  */\n \n void\n-end_subprog_body ()\n+end_subprog_body (void)\n {\n   tree decl;\n   tree cico_list;\n@@ -1979,13 +1936,12 @@ end_subprog_body ()\n    ATTRS is nonzero, use that for the function attribute list.  */\n \n tree\n-builtin_function (name, type, function_code, class, library_name, attrs)\n-     const char *name;\n-     tree type;\n-     int function_code;\n-     enum built_in_class class;\n-     const char *library_name;\n-     tree attrs;\n+builtin_function (const char *name,\n+                  tree type,\n+                  int function_code,\n+                  enum built_in_class class,\n+                  const char *library_name,\n+                  tree attrs)\n {\n   tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n \n@@ -2007,9 +1963,7 @@ builtin_function (name, type, function_code, class, library_name, attrs)\n    it is a signed type.  */\n \n tree\n-gnat_type_for_size (precision, unsignedp)\n-     unsigned precision;\n-     int unsignedp;\n+gnat_type_for_size (unsigned precision, int unsignedp)\n {\n   tree t;\n   char type_name[20];\n@@ -2038,9 +1992,7 @@ gnat_type_for_size (precision, unsignedp)\n /* Likewise for floating-point types.  */\n \n static tree\n-float_type_for_size (precision, mode)\n-     int precision;\n-     enum machine_mode mode;\n+float_type_for_size (int precision, enum machine_mode mode)\n {\n   tree t;\n   char type_name[20];\n@@ -2068,9 +2020,7 @@ float_type_for_size (precision, mode)\n    an unsigned type; otherwise a signed type is returned.  */\n \n tree\n-gnat_type_for_mode (mode, unsignedp)\n-     enum machine_mode mode;\n-     int unsignedp;\n+gnat_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n     return float_type_for_size (GET_MODE_BITSIZE (mode), mode);\n@@ -2081,8 +2031,7 @@ gnat_type_for_mode (mode, unsignedp)\n /* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n \n tree\n-gnat_unsigned_type (type_node)\n-     tree type_node;\n+gnat_unsigned_type (tree type_node)\n {\n   tree type = gnat_type_for_size (TYPE_PRECISION (type_node), 1);\n \n@@ -2105,8 +2054,7 @@ gnat_unsigned_type (type_node)\n /* Return the signed version of a TYPE_NODE, a scalar type.  */\n \n tree\n-gnat_signed_type (type_node)\n-     tree type_node;\n+gnat_signed_type (tree type_node)\n {\n   tree type = gnat_type_for_size (TYPE_PRECISION (type_node), 0);\n \n@@ -2130,9 +2078,7 @@ gnat_signed_type (type_node)\n    UNSIGNEDP.  */\n \n tree\n-gnat_signed_or_unsigned_type (unsignedp, type)\n-     int unsignedp;\n-     tree type;\n+gnat_signed_or_unsigned_type (int unsignedp, tree type)\n {\n   if (! INTEGRAL_TYPE_P (type) || TREE_UNSIGNED (type) == unsignedp)\n     return type;\n@@ -2145,9 +2091,7 @@ gnat_signed_or_unsigned_type (unsignedp, type)\n    minimum (if ! MAX_P) possible value of the discriminant.  */\n \n tree\n-max_size (exp, max_p)\n-     tree exp;\n-     int max_p;\n+max_size (tree exp, int max_p)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree type = TREE_TYPE (exp);\n@@ -2246,10 +2190,7 @@ max_size (exp, max_p)\n    Return a constructor for the template.  */\n \n tree\n-build_template (template_type, array_type, expr)\n-     tree template_type;\n-     tree array_type;\n-     tree expr;\n+build_template (tree template_type, tree array_type, tree expr)\n {\n   tree template_elts = NULL_TREE;\n   tree bound_list = NULL_TREE;\n@@ -2318,10 +2259,7 @@ build_template (template_type, array_type, expr)\n    an object of that type and also for the name.  */\n \n tree\n-build_vms_descriptor (type, mech, gnat_entity)\n-     tree type;\n-     Mechanism_Type mech;\n-     Entity_Id gnat_entity;\n+build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n {\n   tree record_type = make_node (RECORD_TYPE);\n   tree field_list = 0;\n@@ -2606,11 +2544,7 @@ build_vms_descriptor (type, mech, gnat_entity)\n /* Utility routine for above code to make a field.  */\n \n static tree\n-make_descriptor_field (name, type, rec_type, initial)\n-     const char *name;\n-     tree type;\n-     tree rec_type;\n-     tree initial;\n+make_descriptor_field (const char *name, tree type, tree rec_type, tree initial)\n {\n   tree field\n     = create_field_decl (get_identifier (name), type, rec_type, 0, 0, 0, 0);\n@@ -2627,10 +2561,7 @@ make_descriptor_field (name, type, rec_type, initial)\n    as the name of the record.  */\n \n tree\n-build_unc_object_type (template_type, object_type, name)\n-     tree template_type;\n-     tree object_type;\n-     tree name;\n+build_unc_object_type (tree template_type, tree object_type, tree name)\n {\n   tree type = make_node (RECORD_TYPE);\n   tree template_field = create_field_decl (get_identifier (\"BOUNDS\"),\n@@ -2653,9 +2584,7 @@ build_unc_object_type (template_type, object_type, name)\n    if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n \n void\n-update_pointer_to (old_type, new_type)\n-     tree old_type;\n-     tree new_type;\n+update_pointer_to (tree old_type, tree new_type)\n {\n   tree ptr = TYPE_POINTER_TO (old_type);\n   tree ref = TYPE_REFERENCE_TO (old_type);\n@@ -2792,9 +2721,7 @@ update_pointer_to (old_type, new_type)\n    pointer.  This involves making or finding a template.  */\n \n static tree\n-convert_to_fat_pointer (type, expr)\n-     tree type;\n-     tree expr;\n+convert_to_fat_pointer (tree type, tree expr)\n {\n   tree template_type = TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (type))));\n   tree template, template_addr;\n@@ -2861,9 +2788,7 @@ convert_to_fat_pointer (type, expr)\n    is not already a fat pointer.  */\n \n static tree\n-convert_to_thin_pointer (type, expr)\n-     tree type;\n-     tree expr;\n+convert_to_thin_pointer (tree type, tree expr)\n {\n   if (! TYPE_FAT_POINTER_P (TREE_TYPE (expr)))\n     expr\n@@ -2886,8 +2811,7 @@ convert_to_thin_pointer (type, expr)\n    not permitted by the language being compiled.  */\n \n tree\n-convert (type, expr)\n-     tree type, expr;\n+convert (tree type, tree expr)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree etype = TREE_TYPE (expr);\n@@ -3229,9 +3153,7 @@ convert (type, expr)\n    the address is not bit-aligned.  */\n \n tree\n-remove_conversions (exp, true_address)\n-     tree exp;\n-     int true_address;\n+remove_conversions (tree exp, int true_address)\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -3264,8 +3186,7 @@ remove_conversions (exp, true_address)\n    likewise return an expression pointing to the underlying array.  */\n \n tree\n-maybe_unconstrained_array (exp)\n-     tree exp;\n+maybe_unconstrained_array (tree exp)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree new;\n@@ -3327,10 +3248,7 @@ maybe_unconstrained_array (exp)\n    If NOTRUNC_P is set, truncation operations should be suppressed.  */\n \n tree\n-unchecked_convert (type, expr, notrunc_p)\n-     tree type;\n-     tree expr;\n-     int notrunc_p;\n+unchecked_convert (tree type, tree expr, int notrunc_p)\n {\n   tree etype = TREE_TYPE (expr);\n "}, {"sha": "736e8b7a526370d6262293ca46e56cf10179b137", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 54, "deletions": 85, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -44,13 +44,12 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-static tree find_common_type\t\tPARAMS ((tree, tree));\n-static int contains_save_expr_p\t\tPARAMS ((tree));\n-static tree contains_null_expr\t\tPARAMS ((tree));\n-static tree compare_arrays\t\tPARAMS ((tree, tree, tree));\n-static tree nonbinary_modular_operation\tPARAMS ((enum tree_code, tree,\n-\t\t\t\t\t\ttree, tree));\n-static tree build_simple_component_ref\tPARAMS ((tree, tree, tree, int));\n+static tree find_common_type (tree, tree);\n+static int contains_save_expr_p (tree);\n+static tree contains_null_expr (tree);\n+static tree compare_arrays (tree, tree, tree);\n+static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n+static tree build_simple_component_ref (tree, tree, tree, int);\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n@@ -68,8 +67,7 @@ static tree build_simple_component_ref\tPARAMS ((tree, tree, tree, int));\n    the only possible operands will be things of Boolean type.  */\n \n tree\n-gnat_truthvalue_conversion (expr)\n-     tree expr;\n+gnat_truthvalue_conversion (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n \n@@ -106,8 +104,7 @@ gnat_truthvalue_conversion (expr)\n /* Return the base type of TYPE.  */\n \n tree\n-get_base_type (type)\n-     tree type;\n+get_base_type (tree type)\n {\n   if (TREE_CODE (type) == RECORD_TYPE\n       && TYPE_LEFT_JUSTIFIED_MODULAR_P (type))\n@@ -123,8 +120,7 @@ get_base_type (type)\n \n /* Likewise, but only return types known to the Ada source.  */\n tree\n-get_ada_base_type (type)\n-     tree type;\n+get_ada_base_type (tree type)\n {\n   while (TREE_TYPE (type) != 0\n \t && (TREE_CODE (type) == INTEGER_TYPE\n@@ -140,8 +136,7 @@ get_ada_base_type (type)\n    in bits.  If we don't know anything about the alignment, return 0.  */\n \n unsigned int\n-known_alignment (exp)\n-     tree exp;\n+known_alignment (tree exp)\n {\n   unsigned int this_alignment;\n   unsigned int lhs, rhs;\n@@ -221,8 +216,7 @@ known_alignment (exp)\n    Otherwise return zero.  */\n \n static tree\n-find_common_type (t1, t2)\n-     tree t1, t2;\n+find_common_type (tree t1, tree t2)\n {\n   /* If either type is non-BLKmode, use it.  Note that we know that we will\n      not have any alignment problems since if we did the non-BLKmode\n@@ -251,8 +245,7 @@ find_common_type (t1, t2)\n    of some very general solution.  */\n \n static int\n-contains_save_expr_p (exp)\n-     tree exp;\n+contains_save_expr_p (tree exp)\n {\n   switch (TREE_CODE (exp))\n     {\n@@ -283,8 +276,7 @@ contains_save_expr_p (exp)\n    that are known to raise Constraint_Error.  */\n \n static tree\n-contains_null_expr (exp)\n-     tree exp;\n+contains_null_expr (tree exp)\n {\n   tree tem;\n \n@@ -339,9 +331,7 @@ contains_null_expr (exp)\n    length tests in as efficient a manner as possible.  */\n \n static tree\n-compare_arrays (result_type, a1, a2)\n-     tree a1, a2;\n-     tree result_type;\n+compare_arrays (tree result_type, tree a1, tree a2)\n {\n   tree t1 = TREE_TYPE (a1);\n   tree t2 = TREE_TYPE (a2);\n@@ -501,10 +491,10 @@ compare_arrays (result_type, a1, a2)\n    modulus.  */\n \n static tree\n-nonbinary_modular_operation (op_code, type, lhs, rhs)\n-     enum tree_code op_code;\n-     tree type;\n-     tree lhs, rhs;\n+nonbinary_modular_operation (enum tree_code op_code, \n+                             tree type,\n+                             tree lhs,\n+                             tree rhs)\n {\n   tree modulus = TYPE_MODULUS (type);\n   unsigned int needed_precision = tree_floor_log2 (modulus) + 1;\n@@ -601,11 +591,10 @@ nonbinary_modular_operation (op_code, type, lhs, rhs)\n    have to do here is validate the work done by SEM and handle subtypes.  */\n \n tree\n-build_binary_op (op_code, result_type, left_operand, right_operand)\n-     enum tree_code op_code;\n-     tree result_type;\n-     tree left_operand;\n-     tree right_operand;\n+build_binary_op (enum tree_code op_code, \n+                 tree result_type, \n+                 tree left_operand,\n+                 tree right_operand)\n {\n   tree left_type  = TREE_TYPE (left_operand);\n   tree right_type = TREE_TYPE (right_operand);\n@@ -1094,10 +1083,7 @@ build_binary_op (op_code, result_type, left_operand, right_operand)\n /* Similar, but for unary operations.  */\n \n tree\n-build_unary_op (op_code, result_type, operand)\n-     enum tree_code op_code;\n-     tree result_type;\n-     tree operand;\n+build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n {\n   tree type = TREE_TYPE (operand);\n   tree base_type = get_base_type (type);\n@@ -1415,11 +1401,10 @@ build_unary_op (op_code, result_type, operand)\n /* Similar, but for COND_EXPR.  */\n \n tree\n-build_cond_expr (result_type, condition_operand, true_operand, false_operand)\n-     tree result_type;\n-     tree condition_operand;\n-     tree true_operand;\n-     tree false_operand;\n+build_cond_expr (tree result_type,\n+                 tree condition_operand,\n+                 tree true_operand,\n+                 tree false_operand)\n {\n   tree result;\n   int addr_p = 0;\n@@ -1470,9 +1455,7 @@ build_cond_expr (result_type, condition_operand, true_operand, false_operand)\n    the CALL_EXPR.  */\n \n tree\n-build_call_1_expr (fundecl, arg)\n-     tree fundecl;\n-     tree arg;\n+build_call_1_expr (tree fundecl, tree arg)\n {\n   tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n \t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n@@ -1488,9 +1471,7 @@ build_call_1_expr (fundecl, arg)\n    the CALL_EXPR.  */\n \n tree\n-build_call_2_expr (fundecl, arg1, arg2)\n-     tree fundecl;\n-     tree arg1, arg2;\n+build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n {\n   tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n \t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n@@ -1507,8 +1488,7 @@ build_call_2_expr (fundecl, arg1, arg2)\n /* Likewise to call FUNDECL with no arguments.  */\n \n tree\n-build_call_0_expr (fundecl)\n-     tree fundecl;\n+build_call_0_expr (tree fundecl)\n {\n   tree call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fundecl)),\n \t\t     build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n@@ -1523,8 +1503,7 @@ build_call_0_expr (fundecl)\n    name, if requested.  MSG says which exception function to call.  */\n \n tree\n-build_call_raise (msg)\n-     int msg;\n+build_call_raise (int msg)\n {\n   tree fndecl = gnat_raise_decls[msg];\n   const char *str = discard_file_names ? \"\" : ref_filename;\n@@ -1545,9 +1524,7 @@ build_call_raise (msg)\n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n \n tree\n-gnat_build_constructor (type, list)\n-     tree type;\n-     tree list;\n+gnat_build_constructor (tree type, tree list)\n {\n   tree elmt;\n   int allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n@@ -1616,11 +1593,10 @@ gnat_build_constructor (type, list)\n    actual record and know how to look for fields in variant parts.  */\n \n static tree\n-build_simple_component_ref (record_variable, component, field, no_fold_p)\n-     tree record_variable;\n-     tree component;\n-     tree field;\n-     int no_fold_p;\n+build_simple_component_ref (tree record_variable,\n+                            tree component,\n+                            tree field,\n+                            int no_fold_p)\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n   tree ref;\n@@ -1707,11 +1683,10 @@ build_simple_component_ref (record_variable, component, field, no_fold_p)\n    reference could not be found.  */\n \n tree\n-build_component_ref (record_variable, component, field, no_fold_p)\n-     tree record_variable;\n-     tree component;\n-     tree field;\n-     int no_fold_p;\n+build_component_ref (tree record_variable,\n+                     tree component,\n+                     tree field,\n+                     int no_fold_p)\n {\n   tree ref = build_simple_component_ref (record_variable, component, field,\n \t\t\t\t\t no_fold_p);\n@@ -1741,14 +1716,12 @@ build_component_ref (record_variable, component, field, no_fold_p)\n    object dynamically on the stack frame.  */\n \n tree\n-build_call_alloc_dealloc\n-  (gnu_obj, gnu_size, align, gnat_proc, gnat_pool, gnat_node)\n-     tree gnu_obj;\n-     tree gnu_size;\n-     int align;\n-     Entity_Id gnat_proc;\n-     Entity_Id gnat_pool;\n-     Node_Id gnat_node;\n+build_call_alloc_dealloc (tree gnu_obj,\n+                          tree gnu_size,\n+                          int align,\n+                          Entity_Id gnat_proc,\n+                          Entity_Id gnat_pool,\n+                          Node_Id gnat_node)\n {\n   tree gnu_align = size_int (align / BITS_PER_UNIT);\n \n@@ -1865,13 +1838,12 @@ build_call_alloc_dealloc\n    the storage pool to use.  */\n \n tree\n-build_allocator (type, init, result_type, gnat_proc, gnat_pool, gnat_node)\n-     tree type;\n-     tree init;\n-     tree result_type;\n-     Entity_Id gnat_proc;\n-     Entity_Id gnat_pool;\n-     Node_Id gnat_node;\n+build_allocator (tree type,\n+                 tree init,\n+                 tree result_type,\n+                 Entity_Id gnat_proc,\n+                 Entity_Id gnat_pool,\n+                 Node_Id gnat_node)\n {\n   tree size = TYPE_SIZE_UNIT (type);\n   tree result;\n@@ -2030,9 +2002,7 @@ build_allocator (type, init, result_type, gnat_proc, gnat_pool, gnat_node)\n    GNAT_FORMAL is how we find the descriptor record.  */\n \n tree\n-fill_vms_descriptor (expr, gnat_formal)\n-     tree expr;\n-     Entity_Id gnat_formal;\n+fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n {\n   tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n   tree field;\n@@ -2059,8 +2029,7 @@ fill_vms_descriptor (expr, gnat_formal)\n    should not be allocated in a register.  Returns true if successful.  */\n \n bool\n-gnat_mark_addressable (expr_node)\n-     tree expr_node;\n+gnat_mark_addressable (tree expr_node)\n {\n   while (1)\n     switch (TREE_CODE (expr_node))"}, {"sha": "0cc3fe3128eea7d1edf33b63284640d1098a32cc", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -314,7 +314,7 @@ find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n    we would have to be very careful here.  */\n \n bool\n-value_profile_transformations ()\n+value_profile_transformations (void)\n {\n   rtx insn, next;\n   int changed = false;"}, {"sha": "955d4733e3eb89d329c04dde6c257b728367d198", "filename": "gcc/web.c", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9373164a48dc470b44c1ec9431213ce8c06323e5/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=9373164a48dc470b44c1ec9431213ce8c06323e5", "patch": "@@ -66,22 +66,18 @@ struct web_entry\n   rtx reg;\n };\n \n-static struct web_entry *unionfind_root PARAMS ((struct web_entry *));\n-static void unionfind_union\t\tPARAMS ((struct web_entry *,\n-\t\t\t\t\t\t struct web_entry *));\n-static void union_defs\t\t\tPARAMS ((struct df *, struct ref *,\n-\t\t\t\t\t\t struct web_entry *,\n-\t\t\t\t\t\t struct web_entry *));\n-static rtx entry_register\t\tPARAMS ((struct web_entry *,\n-\t\t\t\t\t\t struct ref *, char *, char *));\n-static void replace_ref\t\t\tPARAMS ((struct ref *, rtx));\n-static int mark_addressof\t\tPARAMS ((rtx *, void *));\n+static struct web_entry *unionfind_root (struct web_entry *);\n+static void unionfind_union (struct web_entry *, struct web_entry *);\n+static void union_defs (struct df *, struct ref *, struct web_entry *, \n+                        struct web_entry *);\n+static rtx entry_register (struct web_entry *, struct ref *, char *, char *);\n+static void replace_ref (struct ref *, rtx);\n+static int mark_addressof (rtx *, void *);\n \n /* Find the root of unionfind tree (the representative of set).  */\n \n static struct web_entry *\n-unionfind_root (element)\n-     struct web_entry *element;\n+unionfind_root (struct web_entry *element)\n {\n   struct web_entry *element1 = element, *element2;\n \n@@ -99,8 +95,7 @@ unionfind_root (element)\n /* Union sets.  */\n \n static void\n-unionfind_union (first, second)\n-     struct web_entry *first, *second;\n+unionfind_union (struct web_entry *first, struct web_entry *second)\n {\n   first = unionfind_root (first);\n   second = unionfind_root (second);\n@@ -113,11 +108,8 @@ unionfind_union (first, second)\n    register, union them.  */\n \n static void\n-union_defs (df, use, def_entry, use_entry)\n-     struct df *df;\n-     struct ref *use;\n-     struct web_entry *def_entry;\n-     struct web_entry *use_entry;\n+union_defs (struct df *df, struct ref *use, struct web_entry *def_entry,\n+            struct web_entry *use_entry)\n {\n   rtx insn = DF_REF_INSN (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n@@ -179,11 +171,8 @@ union_defs (df, use, def_entry, use_entry)\n /* Find the corresponding register for the given entry.  */\n \n static rtx\n-entry_register (entry, ref, used, use_addressof)\n-     struct web_entry *entry;\n-     struct ref *ref;\n-     char *used;\n-     char *use_addressof;\n+entry_register (struct web_entry *entry, struct ref *ref, char *used, \n+                char *use_addressof)\n {\n   struct web_entry *root;\n   rtx reg, newreg;\n@@ -235,9 +224,7 @@ entry_register (entry, ref, used, use_addressof)\n /* Replace the reference by REG.  */\n \n static void\n-replace_ref (ref, reg)\n-   struct ref *ref;\n-   rtx reg;\n+replace_ref (struct ref *ref, rtx reg)\n {\n   rtx oldreg = DF_REF_REAL_REG (ref);\n   rtx *loc = DF_REF_REAL_LOC (ref);\n@@ -253,9 +240,7 @@ replace_ref (ref, reg)\n /* Mark each pseudo whose address is taken.  */\n \n static int\n-mark_addressof (rtl, data)\n-     rtx *rtl;\n-     void *data;\n+mark_addressof (rtx *rtl, void *data)\n {\n   if (!*rtl)\n     return 0;\n@@ -268,7 +253,7 @@ mark_addressof (rtl, data)\n /* Main entry point.  */\n \n void\n-web_main ()\n+web_main (void)\n {\n   struct df *df;\n   struct web_entry *def_entry;"}]}