{"sha": "081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxYTUyZWQ1MjIxYjlmZTAyODBmODBiMzY0NmM2MTE4ZWIzZWQxYw==", "commit": {"author": {"name": "Nicolas Setton", "email": "setton@adacore.com", "date": "2008-06-06T21:36:28Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@gcc.gnu.org", "date": "2008-06-06T21:36:28Z"}, "message": "ada-tree.h (DECL_PARALLEL_TYPE): New language specific attribute...\n\n2008-06-06  Nicolas Setton  <setton@adacore.com>\n            Olivier Hainque  <hainque@adacore.com>\n\n        * ada-tree.h (DECL_PARALLEL_TYPE): New language specific\n        attribute, parallel descriptive type attached to another type\n        for debug info generation purposes.\n        * utils.c (add_parallel_type): New function, register parallel\n        type to be attached to a type.\n        (get_parallel_type): New function, fetch a registered parallel\n        type, if any.\n        (rest_of_record_type_compilation): Register the parallel type we\n        make for variable size records.\n        * gigi.h (add_parallel_type, get_parallel_type): Declare.\n        * decl.c (gnat_to_gnu_entity, maybe_pad_type): Register the\n        parallel debug types we make.\n        * trans.c (extract_encoding, decode_name): New functions.\n        (gigi): If the DWARF attribute extensions are available, setup\n        to use them.\n        * lang.opt: Register language specific processing request\n        for -gdwarf+.\n        * misc.c (gnat_dwarf_extensions): New global variable.  How much\n        do we want of our DWARF extensions. 0 by default.\n        (gnat_handle_option) <OPT_gdwarf_>: Increment gnat_dwarf_extensions.\n        (gnat_post_options): Map gnat_dwarf_extensions to the common\n        use_gnu_debug_info_extensions for later processing.\n\n\nCo-Authored-By: Olivier Hainque <hainque@adacore.com>\n\nFrom-SVN: r136506", "tree": {"sha": "92a62fd35271bf3f29e34745397c5bfee0abfb25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92a62fd35271bf3f29e34745397c5bfee0abfb25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/comments", "author": {"login": "setton", "id": 96973, "node_id": "MDQ6VXNlcjk2OTcz", "avatar_url": "https://avatars.githubusercontent.com/u/96973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/setton", "html_url": "https://github.com/setton", "followers_url": "https://api.github.com/users/setton/followers", "following_url": "https://api.github.com/users/setton/following{/other_user}", "gists_url": "https://api.github.com/users/setton/gists{/gist_id}", "starred_url": "https://api.github.com/users/setton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/setton/subscriptions", "organizations_url": "https://api.github.com/users/setton/orgs", "repos_url": "https://api.github.com/users/setton/repos", "events_url": "https://api.github.com/users/setton/events{/privacy}", "received_events_url": "https://api.github.com/users/setton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e919209b4eb54e6f731510475c4b8ed64c23140e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e919209b4eb54e6f731510475c4b8ed64c23140e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e919209b4eb54e6f731510475c4b8ed64c23140e"}], "stats": {"total": 141, "additions": 141, "deletions": 0}, "files": [{"sha": "6d49b29b5f850b6b97af8e2fbba55fc475869170", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -1,3 +1,29 @@\n+2008-06-06  Nicolas Setton  <setton@adacore.com>\n+\t    Olivier Hainque  <hainque@adacore.com>\n+\n+\t* ada-tree.h (DECL_PARALLEL_TYPE): New language specific\n+\tattribute, parallel descriptive type attached to another\n+\ttype for debug info generation purposes.\n+\t* utils.c (add_parallel_type): New function, register\n+\tparallel type to be attached to a type.\n+\t(get_parallel_type): New function, fetch a registered\n+\tparallel type, if any.\n+\t(rest_of_record_type_compilation): Register the parallel\n+\ttype we\tmake for variable size records.\n+\t* gigi.h (add_parallel_type, get_parallel_type): Declare.\n+\t* decl.c (gnat_to_gnu_entity, maybe_pad_type): Register\tthe\n+\tparallel debug types we make.\n+\t* trans.c (extract_encoding, decode_name): New functions.\n+\t(gigi): If the DWARF attribute extensions are available, setup\n+\tto use them.\n+\t* lang.opt: Register language specific processing request\n+\tfor -gdwarf+.\n+\t* misc.c (gnat_dwarf_extensions): New global variable. How much\n+\tdo we want of our DWARF extensions. 0 by default.\n+\t(gnat_handle_option) <OPT_gdwarf_>: Increment gnat_dwarf_extensions.\n+\t(gnat_post_options): Map gnat_dwarf_extensions to the\n+\tcommonuse_gnu_debug_info_extensions for later processing.\n+\t\n 2008-06-06 Uros Bizjak <ubizjak@gmail.com>\n \n \tPR rtl-optimization/36438"}, {"sha": "3d585b5b788e756b5f0f446a9ba560142d07b178", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -290,6 +290,12 @@ struct lang_type GTY(()) {tree t; };\n #define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n \n+/* In a TYPE_DECL, points to the parallel type if any, otherwise 0.  */\n+#define DECL_PARALLEL_TYPE(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))\n+#define SET_DECL_PARALLEL_TYPE(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE), X)\n+\n /* In a FUNCTION_DECL, points to the stub associated with the function\n    if any, otherwise 0.  */\n #define DECL_FUNCTION_STUB(NODE) \\"}, {"sha": "01827b4756142915490b820ab05e54366fde16da", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -2376,6 +2376,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      finish_record_type (gnu_bound_rec_type, gnu_field_list,\n \t\t\t\t  0, false);\n+\n+\t      TYPE_STUB_DECL (gnu_type)\n+\t\t= build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n+\n+\t      add_parallel_type\n+\t\t(TYPE_STUB_DECL (gnu_type), gnu_bound_rec_type);\n \t    }\n \n \t  TYPE_CONVENTION_FORTRAN_P (gnu_type)\n@@ -3106,6 +3112,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t\t 0, NULL_TREE,\n \t\t\t\t\t\t\t NULL_TREE, 0),\n \t\t\t\t      0, false);\n+\n+\t\t  add_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t\t\t     gnu_subtype_marker);\n \t\t}\n \n \t      /* Now we can finalize it.  */\n@@ -5767,6 +5776,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t\t\t     0),\n \t\t\t  0, false);\n \n+      add_parallel_type (TYPE_STUB_DECL (record), marker);\n+\n       if (size && TREE_CODE (size) != INTEGER_CST && definition)\n \tcreate_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n \t\t\t bitsizetype, TYPE_SIZE (record), false, false, false,"}, {"sha": "86ff090fdb011a7baa88c05b61240a458fac4ece", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -535,6 +535,12 @@ extern void finish_record_type (tree record_type, tree fieldlist,\n    so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n extern void rest_of_record_type_compilation (tree record_type);\n \n+/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n+extern void add_parallel_type (tree decl, tree parallel_type);\n+\n+/* Return the parallel type associated to a type, if any.  */\n+extern tree get_parallel_type (tree type);\n+\n /* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n    subprogram. If it is void_type_node, then we are dealing with a procedure,\n    otherwise we are dealing with a function. PARAM_DECL_LIST is a list of"}, {"sha": "d10fc3ac08748776065f68d0b92e8805b43c70ee", "filename": "gcc/ada/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang.opt?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -83,6 +83,10 @@ fRTS=\n Ada Joined RejectNegative\n ; Selects the runtime\n \n+gdwarf+\n+Ada\n+; Explicit request for dwarf debug info with GNAT specific extensions.\n+\n gant\n Ada Joined Undocumented\n ; Catches typos"}, {"sha": "9ee90dd0c9db2cbc1ddf6248c294edfe1839799b", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -199,6 +199,13 @@ const char *const tree_code_name[] = {\n };\n #undef DEFTREECODE\n \n+/* How much we want of our DWARF extensions.  Some of our dwarf+ extensions\n+   are incompatible with regular GDB versions, so we must make sure to only\n+   produce them on explicit request.  This is eventually reflected into the\n+   use_gnu_debug_info_extensions common flag for later processing.  */\n+\n+static int gnat_dwarf_extensions = 0;\n+\n /* Command-line argc and argv.\n    These variables are global, since they are imported and used in\n    back_end.adb  */\n@@ -334,6 +341,10 @@ gnat_handle_option (size_t scode, const char *arg, int value)\n       gnat_argc++;\n       break;\n \n+    case OPT_gdwarf_:\n+      gnat_dwarf_extensions ++;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -383,6 +394,11 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n   else\n     flag_eliminate_unused_debug_types = 0;\n \n+  /* Reflect the explicit request of DWARF extensions into the common\n+     flag for use by later passes.  */\n+  if (write_symbols == DWARF2_DEBUG)\n+    use_gnu_debug_info_extensions = gnat_dwarf_extensions > 0;\n+\n   return false;\n }\n "}, {"sha": "fd69b3eb7aa410842bc2861b3be910030f8b75bc", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -56,6 +56,10 @@\n #include \"einfo.h\"\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n+#include \"adadecode.h\"\n+\n+#include \"dwarf2.h\"\n+#include \"dwarf2out.h\"\n \n /* We should avoid allocating more than ALLOCA_THRESHOLD bytes via alloca,\n    for fear of running out of stack space.  If we need more, we use xmalloc\n@@ -211,6 +215,11 @@ static tree gnat_stabilize_reference (tree, bool);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void set_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, int);\n+\n+/* Hooks for debug info back-ends, only supported and used in a restricted set\n+   of configurations.  */\n+static const char *extract_encoding (const char *) ATTRIBUTE_UNUSED;\n+static const char *decode_name (const char *) ATTRIBUTE_UNUSED;\n \f\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n@@ -282,6 +291,18 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       TYPE_SIZE_UNIT (void_type_node) = size_zero_node;\n     }\n \n+  /* If the GNU type extensions to DWARF are available, setup the hooks.  */\n+#if defined (DWARF2_DEBUGGING_INFO) && defined (DWARF2_GNU_TYPE_EXTENSIONS)\n+  /* We condition the name demangling and the generation of type encoding\n+     strings on -gdwarf+ and always set descriptive types on.  */\n+  if (use_gnu_debug_info_extensions)\n+    {\n+      dwarf2out_set_type_encoding_func (extract_encoding);\n+      dwarf2out_set_demangle_name_func (decode_name);\n+    }\n+  dwarf2out_set_descriptive_type_func (get_parallel_type);\n+#endif\n+\n   /* Enable GNAT stack checking method if needed */\n   if (!Stack_Check_Probes_On_Target)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n@@ -6895,6 +6916,31 @@ set_expr_location_from_node (tree node, Node_Id gnat_node)\n   set_expr_location (node, locus);\n }\n \f\n+/* Return a colon-separated list of encodings contained in encoded Ada\n+   name.  */\n+\n+static const char *\n+extract_encoding (const char *name)\n+{\n+  char *encoding = ggc_alloc (strlen (name));\n+  \n+  get_encoding (name, encoding);\n+  \n+  return encoding;\n+}\n+\n+/* Extract the Ada name from an encoded name.  */\n+\n+static const char *\n+decode_name (const char *name)\n+{\n+  char *decoded = ggc_alloc (strlen (name) * 2 + 60);\n+  \n+  __gnat_decode (name, decoded, 0);\n+  \n+  return decoded;\n+}\n+\f\n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    \"&\" substitution.  */"}, {"sha": "ef49d10b9f1fc33f50a90bebc2eca7f09ac55ffa", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081a52ed5221b9fe0280f80b3646c6118eb3ed1c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=081a52ed5221b9fe0280f80b3646c6118eb3ed1c", "patch": "@@ -1059,6 +1059,8 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_SIZE_UNIT (new_record_type)\n \t= size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n \n+      add_parallel_type (TYPE_STUB_DECL (record_type), new_record_type);\n+\n       /* Now scan all the fields, replacing each field with a new\n \t field corresponding to the new encoding.  */\n       for (old_field = TYPE_FIELDS (record_type); old_field;\n@@ -1201,6 +1203,30 @@ rest_of_record_type_compilation (tree record_type)\n   rest_of_type_decl_compilation (TYPE_STUB_DECL (record_type));\n }\n \n+/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n+\n+void\n+add_parallel_type (tree decl, tree parallel_type)\n+{\n+  tree d = decl;\n+\n+  while (DECL_PARALLEL_TYPE (d))\n+    d = TYPE_STUB_DECL (DECL_PARALLEL_TYPE (d));\n+\n+  SET_DECL_PARALLEL_TYPE (d, parallel_type);\n+}\n+\n+/* Return the parallel type associated to a type, if any.  */\n+\n+tree\n+get_parallel_type (tree type)\n+{\n+  if (TYPE_STUB_DECL (type))\n+    return DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type));\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n    with FIRST_BIT and SIZE that describe a field.  SPECIAL is nonzero\n    if this represents a QUAL_UNION_TYPE in which case we must look for"}]}