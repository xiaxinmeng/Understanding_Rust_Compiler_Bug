{"sha": "a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBmNmE4Y2I0MTRiNjg3ZjIyYzkwMTFhODk0ZDVlOGUzOThjNGJlMA==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2020-01-21T12:53:38Z"}, "committer": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2020-02-10T04:31:09Z"}, "message": "Generalized value pass-through for self-recusive function (PR ipa/93203)\n\nBesides simple pass-through (aggregate) jump function, arithmetic (aggregate)\njump function could also bring same (aggregate) value as parameter passed-in\nfor self-feeding recursive call.  For example,\n\n      f1 (int i)    /*  normal jump function */\n         {\n            f1 (i & 1);\n         }\n\nSuppose i is 0, recursive propagation via (i & 1) also gets 0, which\ncan be seen as a simple pass-through of i.\n\n      f2 (int *p)  /* aggregate jump function */\n         {\n            int t = *p & 1;\n            f2 (&t);\n         }\nLikewise, if *p is 0, (*p & 1) is also 0, and &t is an aggregate simple\npass-through of p.\n\n2020-02-10  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/93203\n        * ipa-cp.c (ipcp_lattice::add_value): Add source with same call edge\n        but different source value.\n        (adjust_callers_for_value_intersection): New function.\n        (gather_edges_for_value): Adjust order of callers to let a\n        non-self-recursive caller be the first element.\n        (self_recursive_pass_through_p): Add a new parameter \"simple\", and\n        check generalized self-recursive pass-through jump function.\n        (self_recursive_agg_pass_through_p): Likewise.\n        (find_more_scalar_values_for_callers_subset): Compute value from\n        pass-through jump function for self-recursive.\n        (intersect_with_plats): Cleanup previous implementation code for value\n        itersection with self-recursive call edge.\n        (intersect_with_agg_replacements): Likewise.\n        (intersect_aggregates_with_edge): Deduce value from pass-through jump\n        function for self-recursive call edge.  Cleanup previous implementation\n        code for value intersection with self-recursive call edge.\n        (decide_whether_version_node): Remove dead callers and adjust order\n        to let a non-self-recursive caller be the first element.\n\n        PR ipa/93203\n        * g++.dg/ipa/pr93203.C: New test.", "tree": {"sha": "02bdac0426a20aabff5f849b5ead4570e26b7652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02bdac0426a20aabff5f849b5ead4570e26b7652"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04c3a1f2c6e9813bf13e573924dce94e22c72c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c3a1f2c6e9813bf13e573924dce94e22c72c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c3a1f2c6e9813bf13e573924dce94e22c72c85"}], "stats": {"total": 318, "additions": 243, "deletions": 75}, "files": [{"sha": "fa3cbb895e999736e07116ee34e6749e2831ca21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "patch": "@@ -1,3 +1,25 @@\n+2020-02-10  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/93203\n+\t* ipa-cp.c (ipcp_lattice::add_value): Add source with same call edge\n+\tbut different source value.\n+\t(adjust_callers_for_value_intersection): New function.\n+\t(gather_edges_for_value): Adjust order of callers to let a\n+\tnon-self-recursive caller be the first element.\n+\t(self_recursive_pass_through_p): Add a new parameter \"simple\", and\n+\tcheck generalized self-recursive pass-through jump function.\n+\t(self_recursive_agg_pass_through_p): Likewise.\n+\t(find_more_scalar_values_for_callers_subset): Compute value from\n+\tpass-through jump function for self-recursive.\n+\t(intersect_with_plats): Cleanup previous implementation code for value\n+\titersection with self-recursive call edge.\n+\t(intersect_with_agg_replacements): Likewise.\n+\t(intersect_aggregates_with_edge): Deduce value from pass-through jump\n+\tfunction for self-recursive call edge.  Cleanup previous implementation\n+\tcode for value intersection with self-recursive call edge.\n+\t(decide_whether_version_node): Remove dead callers and adjust order\n+\tto let a non-self-recursive caller be the first element.\n+\n 2020-02-09  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* recog.c: Move pass_split_before_sched2 code in front of"}, {"sha": "4f5b72e6994c6824edb14cb493b7ef0fdf5af9c2", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 120, "deletions": 74, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "patch": "@@ -1850,7 +1850,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \t  {\n \t    ipcp_value_source<valtype> *s;\n \t    for (s = val->sources; s; s = s->next)\n-\t      if (s->cs == cs)\n+\t      if (s->cs == cs && s->val == src_val)\n \t\tbreak;\n \t    if (s)\n \t      return false;\n@@ -4204,6 +4204,33 @@ get_info_about_necessary_edges (ipcp_value<valtype> *val, cgraph_node *dest,\n   return hot;\n }\n \n+/* Given a NODE, and a set of its CALLERS, try to adjust order of the callers\n+   to let a non-self-recursive caller be the first element.  Thus, we can\n+   simplify intersecting operations on values that arrive from all of these\n+   callers, especially when there exists self-recursive call.  Return true if\n+   this kind of adjustment is possible.  */\n+\n+static bool\n+adjust_callers_for_value_intersection (vec<cgraph_edge *> callers,\n+\t\t\t\t       cgraph_node *node)\n+{\n+  for (unsigned i = 0; i < callers.length (); i++)\n+    {\n+      cgraph_edge *cs = callers[i];\n+\n+      if (cs->caller != node)\n+\t{\n+\t  if (i > 0)\n+\t    {\n+\t      callers[i] = callers[0];\n+\t      callers[0] = cs;\n+\t    }\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Return a vector of incoming edges that do bring value VAL to node DEST.  It\n    is assumed their number is known and equal to CALLER_COUNT.  */\n \n@@ -4227,6 +4254,9 @@ gather_edges_for_value (ipcp_value<valtype> *val, cgraph_node *dest,\n \t}\n     }\n \n+  if (caller_count > 1)\n+    adjust_callers_for_value_intersection (ret, dest);\n+\n   return ret;\n }\n \n@@ -4238,7 +4268,6 @@ get_replacement_map (class ipa_node_params *info, tree value, int parm_num)\n {\n   struct ipa_replace_map *replace_map;\n \n-\n   replace_map = ggc_alloc<ipa_replace_map> ();\n   if (dump_file)\n     {\n@@ -4589,36 +4618,40 @@ create_specialized_node (struct cgraph_node *node,\n }\n \n /* Return true, if JFUNC, which describes a i-th parameter of call CS, is a\n-   simple no-operation pass-through function to itself.  */\n+   pass-through function to itself.  When SIMPLE is true, further check if\n+   JFUNC is a simple no-operation pass-through.  */\n \n static bool\n-self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i)\n+self_recursive_pass_through_p (cgraph_edge *cs, ipa_jump_func *jfunc, int i,\n+\t\t\t       bool simple = true)\n {\n   enum availability availability;\n   if (cs->caller == cs->callee->function_symbol (&availability)\n       && availability > AVAIL_INTERPOSABLE\n       && jfunc->type == IPA_JF_PASS_THROUGH\n-      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR\n+      && (!simple || ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n       && ipa_get_jf_pass_through_formal_id (jfunc) == i)\n     return true;\n   return false;\n }\n \n /* Return true, if JFUNC, which describes a part of an aggregate represented\n-   or pointed to by the i-th parameter of call CS, is a simple no-operation\n-   pass-through function to itself.  */\n+   or pointed to by the i-th parameter of call CS, is a pass-through function\n+   to itself.  When SIMPLE is true, further check if JFUNC is a simple\n+   no-operation pass-through.  */\n \n static bool\n self_recursive_agg_pass_through_p (cgraph_edge *cs, ipa_agg_jf_item *jfunc,\n-\t\t\t\t   int i)\n+\t\t\t\t   int i, bool simple = true)\n {\n   enum availability availability;\n   if (cs->caller == cs->callee->function_symbol (&availability)\n       && availability > AVAIL_INTERPOSABLE\n       && jfunc->jftype == IPA_JF_LOAD_AGG\n       && jfunc->offset == jfunc->value.load_agg.offset\n-      && jfunc->value.pass_through.operation == NOP_EXPR\n-      && jfunc->value.pass_through.formal_id == i)\n+      && (!simple || jfunc->value.pass_through.operation == NOP_EXPR)\n+      && jfunc->value.pass_through.formal_id == i\n+      && useless_type_conversion_p (jfunc->value.load_agg.type, jfunc->type))\n     return true;\n   return false;\n }\n@@ -4650,9 +4683,6 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t  struct ipa_jump_func *jump_func;\n \t  tree t;\n \n-\t  if (IPA_NODE_REF (cs->caller) && IPA_NODE_REF (cs->caller)->node_dead)\n-\t    continue;\n-\n \t  if (!IPA_EDGE_REF (cs)\n \t      || i >= ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n \t      || (i == 0\n@@ -4662,10 +4692,30 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n \t      break;\n \t    }\n \t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n-\t  if (self_recursive_pass_through_p (cs, jump_func, i))\n-\t    continue;\n \n-\t  t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func, type);\n+\t  /* Besides simple pass-through jump function, arithmetic jump\n+\t     function could also introduce argument-direct-pass-through for\n+\t     self-feeding recursive call.  For example,\n+\n+\t        fn (int i)\n+\t        {\n+\t          fn (i & 1);\n+\t        }\n+\n+\t     Given that i is 0, recursive propagation via (i & 1) also gets\n+\t     0.  */\n+\t  if (self_recursive_pass_through_p (cs, jump_func, i, false))\n+\t    {\n+\t      gcc_assert (newval);\n+\t      t = ipa_get_jf_arith_result (\n+\t\t\t\tipa_get_jf_pass_through_operation (jump_func),\n+\t\t\t\tnewval,\n+\t\t\t\tipa_get_jf_pass_through_operand (jump_func),\n+\t\t\t\ttype);\n+\t    }\n+\t  else\n+\t    t = ipa_value_from_jfunc (IPA_NODE_REF (cs->caller), jump_func,\n+\t\t\t\t      type);\n \t  if (!t\n \t      || (newval\n \t\t  && !values_equal_for_ipcp_p (t, newval))\n@@ -4814,19 +4864,12 @@ intersect_with_plats (class ipcp_param_lattices *plats,\n \t    break;\n \t  if (aglat->offset - offset == item->offset)\n \t    {\n-\t      gcc_checking_assert (item->value);\n \t      if (aglat->is_single_const ())\n \t\t{\n \t\t  tree value = aglat->values->value;\n \n \t\t  if (values_equal_for_ipcp_p (item->value, value))\n \t\t    found = true;\n-\t\t  else if (item->value == error_mark_node)\n-\t\t    {\n-\t\t      /* Replace unknown place holder value with real one.  */\n-\t\t      item->value = value;\n-\t\t      found = true;\n-\t\t    }\n \t\t}\n \t      break;\n \t    }\n@@ -4895,12 +4938,6 @@ intersect_with_agg_replacements (struct cgraph_node *node, int index,\n \t    {\n \t      if (values_equal_for_ipcp_p (item->value, av->value))\n \t\tfound = true;\n-\t      else if (item->value == error_mark_node)\n-\t\t{\n-\t\t  /* Replace place holder value with real one.  */\n-\t\t  item->value = av->value;\n-\t\t  found = true;\n-\t\t}\n \t      break;\n \t    }\n \t}\n@@ -5005,31 +5042,16 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \tfor (unsigned i = 0; i < jfunc->agg.items->length (); i++)\n \t  {\n \t    struct ipa_agg_jf_item *agg_item = &(*jfunc->agg.items)[i];\n-\t    struct ipa_agg_value agg_value;\n-\n-\t    if (self_recursive_agg_pass_through_p (cs, agg_item, index))\n-\t      {\n-\t\t/* For a self-recursive call, if aggregate jump function is a\n-\t\t   simple pass-through, the exact value that it stands for is\n-\t\t   not known at this point, which must comes from other call\n-\t\t   sites.  But we still need to add a place holder in value\n-\t\t   sets to indicate it, here we use error_mark_node to\n-\t\t   represent the special unknown value, which will be replaced\n-\t\t   with real one during later intersecting operations.  */\n-\t\tagg_value.value = error_mark_node;\n-\t      }\n-\t    else\n+\t    tree value = ipa_agg_value_from_node (caller_info, cs->caller,\n+\t\t\t\t\t\t  agg_item);\n+\t    if (value)\n \t      {\n-\t\ttree value = ipa_agg_value_from_node (caller_info, cs->caller,\n-\t\t\t\t\t\t      agg_item);\n-\t\tif (!value)\n-\t\t  continue;\n+\t\tstruct ipa_agg_value agg_value;\n \n \t\tagg_value.value = value;\n+\t\tagg_value.offset = agg_item->offset;\n+\t\tinter.safe_push (agg_value);\n \t      }\n-\n-\t    agg_value.offset = agg_item->offset;\n-\t    inter.safe_push (agg_value);\n \t  }\n       else\n \tFOR_EACH_VEC_ELT (inter, k, item)\n@@ -5050,25 +5072,32 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n \t\t  {\n \t\t    tree value;\n \n-\t\t    if (self_recursive_agg_pass_through_p (cs, ti, index))\n-\t\t      {\n-\t\t\t/* A simple aggregate pass-through in self-recursive\n-\t\t\t   call should lead to same value.  */\n-\t\t\tfound = true;\n-\t\t      }\n-\t\t    else if ((value = ipa_agg_value_from_node (caller_info,\n-\t\t\t\t\t\t\t     cs->caller, ti)))\n-\t\t      {\n-\t\t\tif (values_equal_for_ipcp_p (item->value, value))\n-\t\t\t  found = true;\n-\t\t\telse if (item->value == error_mark_node)\n-\t\t\t  {\n-\t\t\t    /* Replace unknown place holder value with real\n-\t\t\t       one.  */\n-\t\t\t    item->value = value;\n-\t\t\t    found = true;\n-\t\t\t  }\n-\t\t      }\n+\t\t    /* Besides simple pass-through aggregate jump function,\n+\t\t       arithmetic aggregate jump function could also bring\n+\t\t       same aggregate value as parameter passed-in for\n+\t\t       self-feeding recursive call.  For example,\n+\n+\t\t         fn (int *i)\n+\t\t           {\n+\t\t             int j = *i & 1;\n+\t\t             fn (&j);\n+\t\t           }\n+\n+\t\t       Given that *i is 0, recursive propagation via (*i & 1)\n+\t\t       also gets 0.  */\n+\t\t    if (self_recursive_agg_pass_through_p (cs, ti, index,\n+\t\t\t\t\t\t\t   false))\n+\t\t      value = ipa_get_jf_arith_result (\n+\t\t\t\t\tti->value.pass_through.operation,\n+\t\t\t\t\titem->value,\n+\t\t\t\t\tti->value.pass_through.operand,\n+\t\t\t\t\tti->type);\n+\t\t    else\n+\t\t      value = ipa_agg_value_from_node (caller_info,\n+\t\t\t\t\t\t       cs->caller, ti);\n+\n+\t\t    if (value && values_equal_for_ipcp_p (item->value, value))\n+\t\t      found = true;\n \t\t    break;\n \t\t  }\n \t\tl++;\n@@ -5144,9 +5173,6 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n \t  if (!item->value)\n \t    continue;\n \n-\t  /* All values must be real values, not unknown place holders.  */\n-\t  gcc_assert (item->value != error_mark_node);\n-\n \t  v = ggc_alloc<ipa_agg_replacement_value> ();\n \t  v->index = i;\n \t  v->offset = item->offset;\n@@ -5542,13 +5568,33 @@ decide_whether_version_node (struct cgraph_node *node)\n   if (info->do_clone_for_all_contexts)\n     {\n       struct cgraph_node *clone;\n-      vec<cgraph_edge *> callers;\n+      vec<cgraph_edge *> callers = node->collect_callers ();\n+\n+      for (int i = callers.length () - 1; i >= 0; i--)\n+\t{\n+\t  cgraph_edge *cs = callers[i];\n+\t  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n+\n+\t  if (caller_info && caller_info->node_dead)\n+\t    callers.unordered_remove (i);\n+\t}\n+\n+      if (!adjust_callers_for_value_intersection (callers, node))\n+\t{\n+\t  /* If node is not called by anyone, or all its caller edges are\n+\t     self-recursive, the node is not really be in use, no need to\n+\t     do cloning.  */\n+\t  callers.release ();\n+\t  known_csts.release ();\n+\t  known_contexts.release ();\n+\t  info->do_clone_for_all_contexts = false;\n+\t  return ret;\n+\t}\n \n       if (dump_file)\n \tfprintf (dump_file, \" - Creating a specialized node of %s \"\n \t\t \"for all known contexts.\\n\", node->dump_name ());\n \n-      callers = node->collect_callers ();\n       find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n       find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n       ipa_agg_replacement_value *aggvals"}, {"sha": "fddd0159d7b84dd43d5ceeae895ad6f30bbccc7d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "patch": "@@ -1,3 +1,8 @@\n+2020-02-10  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/93203\n+\t* g++.dg/ipa/pr93203.C: New test.\n+\n 2020-02-09  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/pr91333.c (dg-do): Fix target selector."}, {"sha": "b4cd69001b5c2c4bd7c042262d3c9bbbfe577514", "filename": "gcc/testsuite/g++.dg/ipa/pr93203.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr93203.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr93203.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr93203.C?ref=a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "patch": "@@ -0,0 +1,95 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -w -std=gnu++11\" } */\n+\n+class a {\n+public:\n+  a(char *);\n+};\n+class ad {\n+public:\n+  ad(a *);\n+};\n+class b {};\n+using ah = class ak {\n+  using al = char;\n+\n+public:\n+  ak(b) : ak(0) {}\n+  ak an() { return ap & 1; }\n+  al ap;\n+  ak(al af) : ap(af) {}\n+};\n+struct at {\n+  ah au;\n+  int av;\n+  char aw;\n+  char ax;\n+};\n+class az {\n+public:\n+  struct ba {\n+    void bb(ak am) {\n+      ak bc = am.an();\n+      bb(bc);\n+    }\n+  };\n+  void bd(ak am) { be.bb(am); }\n+  ba be;\n+};\n+class bg {\n+public:\n+  int bh;\n+  at bi;\n+};\n+int bj;\n+int *bk;\n+int c;\n+class bl {\n+  bool bm();\n+  bg bn;\n+  az bo;\n+  int e;\n+  int bq;\n+};\n+class bs {\n+public:\n+  bs(int *, ah *, char *, char *, int);\n+};\n+template < typename bt > class bu : bs {\n+  using bv = typename bt::bv;\n+\n+public:\n+  template < typename... bx >\n+  bu(a *by, int *bz, at body, bx...)\n+      : bs(bz, &body.au, &body.aw, &body.ax, body.av), ca(bx()...), cb(by),\n+        cc(by), cd(by), ce(by) {}\n+  void cf() {\n+    auto cg = ch();\n+    auto ci = *cj();\n+    ca.ck(this, cg, &ci);\n+  }\n+  bt ca;\n+  ad cb;\n+  ad cc;\n+  ad cd;\n+  ad ce;\n+  bv *cj();\n+  bv ch();\n+};\n+class cl {\n+public:\n+  using bv = struct {};\n+  cl(az *, int, int, int, int, a *, int, int **);\n+  void ck(bs *, bv, bv *) {\n+    b d;\n+    ak ci(d);\n+    bo.bd(ci);\n+  }\n+  az bo;\n+};\n+bool bl::bm() {\n+  a by(\"\");\n+  bu< cl > cn(&by, &bj, bn.bi, &bo, c, bn.bh, e, 0, &by, bq, &bk);\n+  cn.cf();\n+}\n+"}, {"sha": "baa9c97ffb0bb64cc7f1ff040eeb7745cb4ffa8a", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0f6a8cb414b687f22c9011a894d5e8e398c4be0/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-1.c?ref=a0f6a8cb414b687f22c9011a894d5e8e398c4be0", "patch": "@@ -45,7 +45,7 @@ main (int argc, char *argv[])\n }\n \n \n-/* { dg-final { scan-ipa-dump \"Creating a specialized node of f.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of f\" \"cp\" } } */\n /* { dg-final { scan-ipa-dump \"replacing param .0 a with const 7\" \"cp\"  } } */\n \n "}]}