{"sha": "ced3f397be6d68ba9a838ee7e3f27c456238501a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkM2YzOTdiZTZkNjhiYTlhODM4ZWU3ZTNmMjdjNDU2MjM4NTAxYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-08T07:47:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-08T07:47:45Z"}, "message": "dbxout.c (dbxout_type, [...]): Use gcc_assert and gcc_unreachable.\n\n\t* dbxout.c (dbxout_type, dbxout_type_name, dbxout_symbol): Use\n\tgcc_assert and gcc_unreachable.\n\t* ddg.c (create_ddg_dependence, add_deps_for_def,\n\tadd_deps_for_use, create_ddg, add_edge_to_ddg): Likewise.\n\t* df.c (df_ref_unlink, df_ref_record, df_uses_record,\n\tdf_reg_def_chain_create, df_reg_use_chain_create, df_analyze,\n\tdf_insn_delete, df_refs_reg_replace, df_ref_reg_replace,\n\tdf_insns_modify, df_pattern_emit_before, df_bb_reg_live_start_p,\n\tdf_bb_reg_live_end_p, df_bb_regs_lives_compare,\n\tdf_bb_single_def_use_insn_find, dataflow_set_a_op_b,\n\tdataflow_set_copy, hybrid_search, diagnostic.c,\n\tdiagnostic_build_prefix, diagnostic_count_diagnostic): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* dominance.c (calc_dfs_tree_nonrec, calc_dfs_tree,\n\tcompute_dom_fast_query, calculate_dominance_info,\n\tfree_dominance_info, get_immediate_dominator,\n\tset_immediate_dominator, get_dominated_by,\n\tredirect_immediate_dominators, nearest_common_dominator,\n\tdominated_by_p, verify_dominators, recount_dominator,\n\titerate_fix_dominators, add_to_dominance_info,\n\tdelete_from_dominance_info): Likewise.\n\t* dwarf2asm.c (size_of_encoded_value, eh_data_format_name,\n\tdw2_asm_output_delta_uleb128, dw2_asm_output_delta_sleb128,\n\tdw2_force_const_mem, dw2_asm_output_encoded_addr_rtx): Likewise.\n\t* dwarf2out.c (expand_builtin_init_dwarf_reg_sizes, reg_save,\n\tinitial_return_save, stack_adjust_offset, dwarf2out_stack_adjust,\n\tflush_queued_reg_saves, dwarf2out_frame_debug_expr,\n\tdwarf2out_frame_debug, dw_cfi_oprnd1_desc, output_cfi,\n\toutput_call_frame_info, output_loc_operands, build_cfa_loc,\n\tdecl_ultimate_origin, AT_flag, AT_int, AT_unsigned, AT_string,\n\tAT_string_form, add_AT_specification, AT_ref, set_AT_ref_external,\n\tAT_loc, AT_loc_list, AT_addr, AT_lbl, add_child_die,\n\tsplice_child_die, attr_checksum, same_dw_val_p,\n\tbreak_out_includes, build_abbrev_table, size_of_die, mark_dies,\n\tunmark_dies, value_format, output_loc_list, output_die,\n\toutput_pubnames, output_aranges, base_type_die, is_base_type,\n\tmodified_type_die, dbx_reg_number, multiple_reg_loc_descriptor,\n\tmem_loc_descriptor, loc_descriptor, loc_descriptor_from_tree_1,\n\tfield_byte_offset, add_data_member_location_attribute,\n\tadd_const_value_attribute, rtl_for_decl_location,\n\tadd_location_or_const_value_attribute, add_byte_size_attribute,\n\tadd_bit_offset_attribute, add_bit_size_attribute,\n\tadd_abstract_origin_attribute, pop_decl_scope, scope_die_for,\n\tdecl_start_label, gen_formal_parameter_die,\n\tgen_type_die_for_member, gen_subprogram_die, gen_label_die,\n\tgen_typedef_die, gen_type_die, gen_tagged_type_instantiation_die,\n\tforce_decl_die, force_type_die, gen_decl_die,\n\tdwarf2out_imported_module_or_decl, prune_unused_types_prune,\n\tdwarf2out_finish): Likewise.\n\nFrom-SVN: r87176", "tree": {"sha": "badd4a59c4d7d42a6830a798ebfe95eb02d81f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/badd4a59c4d7d42a6830a798ebfe95eb02d81f64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ced3f397be6d68ba9a838ee7e3f27c456238501a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced3f397be6d68ba9a838ee7e3f27c456238501a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced3f397be6d68ba9a838ee7e3f27c456238501a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced3f397be6d68ba9a838ee7e3f27c456238501a/comments", "author": null, "committer": null, "parents": [{"sha": "faaaf610bf35048621bd44bb365a79e6ab4f8653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faaaf610bf35048621bd44bb365a79e6ab4f8653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faaaf610bf35048621bd44bb365a79e6ab4f8653"}], "stats": {"total": 935, "additions": 426, "deletions": 509}, "files": [{"sha": "c9de7f7ce871478ff427c41ce9487528415401dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -1,3 +1,55 @@\n+2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* dbxout.c (dbxout_type, dbxout_type_name, dbxout_symbol): Use\n+\tgcc_assert and gcc_unreachable.\n+\t* ddg.c (create_ddg_dependence, add_deps_for_def,\n+\tadd_deps_for_use, create_ddg, add_edge_to_ddg): Likewise.\n+\t* df.c (df_ref_unlink, df_ref_record, df_uses_record,\n+\tdf_reg_def_chain_create, df_reg_use_chain_create, df_analyze,\n+\tdf_insn_delete, df_refs_reg_replace, df_ref_reg_replace,\n+\tdf_insns_modify, df_pattern_emit_before, df_bb_reg_live_start_p,\n+\tdf_bb_reg_live_end_p, df_bb_regs_lives_compare,\n+\tdf_bb_single_def_use_insn_find, dataflow_set_a_op_b,\n+\tdataflow_set_copy, hybrid_search, diagnostic.c,\n+\tdiagnostic_build_prefix, diagnostic_count_diagnostic): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* dominance.c (calc_dfs_tree_nonrec, calc_dfs_tree,\n+\tcompute_dom_fast_query, calculate_dominance_info,\n+\tfree_dominance_info, get_immediate_dominator,\n+\tset_immediate_dominator, get_dominated_by,\n+\tredirect_immediate_dominators, nearest_common_dominator,\n+\tdominated_by_p, verify_dominators, recount_dominator,\n+\titerate_fix_dominators, add_to_dominance_info,\n+\tdelete_from_dominance_info): Likewise.\n+\t* dwarf2asm.c (size_of_encoded_value, eh_data_format_name,\n+\tdw2_asm_output_delta_uleb128, dw2_asm_output_delta_sleb128,\n+\tdw2_force_const_mem, dw2_asm_output_encoded_addr_rtx): Likewise.\n+\t* dwarf2out.c (expand_builtin_init_dwarf_reg_sizes, reg_save,\n+\tinitial_return_save, stack_adjust_offset, dwarf2out_stack_adjust,\n+\tflush_queued_reg_saves, dwarf2out_frame_debug_expr,\n+\tdwarf2out_frame_debug, dw_cfi_oprnd1_desc, output_cfi,\n+\toutput_call_frame_info, output_loc_operands, build_cfa_loc,\n+\tdecl_ultimate_origin, AT_flag, AT_int, AT_unsigned, AT_string,\n+\tAT_string_form, add_AT_specification, AT_ref, set_AT_ref_external,\n+\tAT_loc, AT_loc_list, AT_addr, AT_lbl, add_child_die,\n+\tsplice_child_die, attr_checksum, same_dw_val_p,\n+\tbreak_out_includes, build_abbrev_table, size_of_die, mark_dies,\n+\tunmark_dies, value_format, output_loc_list, output_die,\n+\toutput_pubnames, output_aranges, base_type_die, is_base_type,\n+\tmodified_type_die, dbx_reg_number, multiple_reg_loc_descriptor,\n+\tmem_loc_descriptor, loc_descriptor, loc_descriptor_from_tree_1,\n+\tfield_byte_offset, add_data_member_location_attribute,\n+\tadd_const_value_attribute, rtl_for_decl_location,\n+\tadd_location_or_const_value_attribute, add_byte_size_attribute,\n+\tadd_bit_offset_attribute, add_bit_size_attribute,\n+\tadd_abstract_origin_attribute, pop_decl_scope, scope_die_for,\n+\tdecl_start_label, gen_formal_parameter_die,\n+\tgen_type_die_for_member, gen_subprogram_die, gen_label_die,\n+\tgen_typedef_die, gen_type_die, gen_tagged_type_instantiation_die,\n+\tforce_decl_die, force_type_die, gen_decl_die,\n+\tdwarf2out_imported_module_or_decl, prune_unused_types_prune,\n+\tdwarf2out_finish): Likewise.\n+\n 2004-09-08  Andreas Tobler  <toa@pop.agri.ch>\n \n \t* Makefile.in (builtins.o): Depend on tree-mudflap.h.\n@@ -6014,7 +6066,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "110ed6b35437cb5a9e14cac8b7133d9e45a7cbb3", "filename": "gcc/dbxout.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -1683,8 +1683,7 @@ dbxout_type (tree type, int full)\n \t    /* We shouldn't be outputting a reference to a type before its\n \t       definition unless the type has a tag name.\n \t       A typedef name without a tag name should be impossible.  */\n-\t    if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE)\n-\t      abort ();\n+\t    gcc_assert (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE);\n #endif\n \t    if (TYPE_NAME (type) != 0)\n \t      dbxout_type_name (type);\n@@ -1919,7 +1918,7 @@ dbxout_type (tree type, int full)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2040,19 +2039,19 @@ print_wide_int (HOST_WIDE_INT c)\n static void\n dbxout_type_name (tree type)\n {\n-  tree t;\n-  if (TYPE_NAME (type) == 0)\n-    abort ();\n-  if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-    {\n-      t = TYPE_NAME (type);\n-    }\n-  else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+  tree t = TYPE_NAME (type);\n+  \n+  gcc_assert (t);\n+  switch (TREE_CODE (t))\n     {\n-      t = DECL_NAME (TYPE_NAME (type));\n+    case IDENTIFIER_NODE:\n+      break;\n+    case TYPE_DECL:\n+      t = DECL_NAME (t);\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   fprintf (asmfile, \"%s\", IDENTIFIER_POINTER (t));\n   CHARS (IDENTIFIER_LENGTH (t));\n@@ -2386,7 +2385,7 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n     case PARM_DECL:\n       /* Parm decls go in their own separate chains\n \t and are output by dbxout_reg_parms and dbxout_parms.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case RESULT_DECL:\n       /* Named return value, treat like a VAR_DECL.  */"}, {"sha": "3cd9c6b78f544140867a61d991af3b90714f36b1", "filename": "gcc/ddg.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -164,8 +164,7 @@ create_ddg_dependence (ddg_ptr g, ddg_node_ptr src_node,\n   if (interloop)\n      distance = 1;\n \n-  if (!link)\n-    abort ();\n+  gcc_assert (link);\n \n   /* Note: REG_DEP_ANTI applies to MEM ANTI_DEP as well!!  */\n   if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n@@ -240,8 +239,7 @@ add_deps_for_def (ddg_ptr g, struct df *df, struct ref *rd)\n \t  rtx use_insn = DF_REF_INSN (r_use->ref);\n \t  ddg_node_ptr dest_node = get_node_of_insn (g, use_insn);\n \n-\t  if (!src_node || !dest_node)\n-\t    abort ();\n+\t  gcc_assert (src_node && dest_node);\n \n \t  /* Any such upwards exposed use appears before the rd def.  */\n \t  use_before_def = true;\n@@ -296,8 +294,7 @@ add_deps_for_use (ddg_ptr g, struct df *df, struct ref *use)\n   use_node = get_node_of_insn (g, use->insn);\n   def_node = get_node_of_insn (g, first_def->insn);\n \n-  if (!use_node || !def_node)\n-    abort ();\n+  gcc_assert (use_node && def_node);\n \n   /* Make sure there are no defs after USE.  */\n   for (i = use_node->cuid + 1; i < g->num_nodes; i++)\n@@ -484,10 +481,8 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n \t}\n       if (JUMP_P (insn))\n \t{\n-\t  if (g->closing_branch)\n-\t    abort (); /* Found two branches in DDG.  */\n-\t  else\n-\t    g->closing_branch = &g->nodes[i];\n+\t  gcc_assert (!g->closing_branch);\n+\t  g->closing_branch = &g->nodes[i];\n \t}\n       else if (GET_CODE (PATTERN (insn)) == USE)\n \t{\n@@ -505,9 +500,10 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n       g->nodes[i++].insn = insn;\n       first_note = NULL_RTX;\n     }\n-\n-  if (!g->closing_branch)\n-    abort ();  /* Found no branch in DDG.  */\n+  \n+  /* We must have found a branch in DDG.  */\n+  gcc_assert (g->closing_branch);\n+  \n \n   /* Build the data dependency graph.  */\n   build_intra_loop_deps (g);\n@@ -646,8 +642,8 @@ add_edge_to_ddg (ddg_ptr g ATTRIBUTE_UNUSED, ddg_edge_ptr e)\n   ddg_node_ptr src = e->src;\n   ddg_node_ptr dest = e->dest;\n \n-  if (!src->successors || !dest->predecessors)\n-    abort (); /* Should have allocated the sbitmaps.  */\n+  /* Should have allocated the sbitmaps.  */\n+  gcc_assert (src->successors && dest->predecessors);\n \n   SET_BIT (src->successors, dest->cuid);\n   SET_BIT (dest->predecessors, src->cuid);"}, {"sha": "f4173c6ac8170dcd8d54c795c2eebee60caa5920", "filename": "gcc/df.c", "status": "modified", "additions": 35, "deletions": 61, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -648,8 +648,8 @@ df_ref_unlink (struct df_link **phead, struct ref *ref)\n \t  /* Only a single ref.  It must be the one we want.\n \t     If not, the def-use and use-def chains are likely to\n \t     be inconsistent.  */\n-\t  if (link->ref != ref)\n-\t    abort ();\n+\t  gcc_assert (link->ref == ref);\n+\t  \n \t  /* Now have an empty chain.  */\n \t  *phead = NULL;\n \t}\n@@ -808,8 +808,7 @@ df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n {\n   unsigned int regno;\n \n-  if (!REG_P (reg) && GET_CODE (reg) != SUBREG)\n-    abort ();\n+  gcc_assert (REG_P (reg) || GET_CODE (reg) == SUBREG);\n \n   /* For the reg allocator we are interested in some SUBREG rtx's, but not\n      all.  Notably only those representing a word extraction from a multi-word\n@@ -1040,10 +1039,10 @@ df_uses_record (struct df *df, rtx *loc, enum df_ref_type ref_type,\n \t\t\t      bb, insn, 0);\n \t      break;\n \t    case STRICT_LOW_PART:\n-\t      /* A strict_low_part uses the whole REG and not just the SUBREG.  */\n+\t      /* A strict_low_part uses the whole REG and not just the\n+\t\t SUBREG.  */\n \t      dst = XEXP (dst, 0);\n-\t      if (GET_CODE (dst) != SUBREG)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (dst) == SUBREG);\n \t      df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n \t\t\t     insn, DF_REF_READ_WRITE);\n \t      break;\n@@ -1056,7 +1055,7 @@ df_uses_record (struct df *df, rtx *loc, enum df_ref_type ref_type,\n \t      dst = XEXP (dst, 0);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t  }\n \treturn;\n       }\n@@ -1311,8 +1310,7 @@ df_reg_def_chain_create (struct df *df, bitmap blocks, bool redo)\n     {\n #ifdef ENABLE_CHECKING\n       for (regno = 0; regno < df->n_regs; regno++)\n-\tif (df->regs[regno].defs)\n-\t  abort ();\n+\tgcc_assert (!df->regs[regno].defs);\n #endif\n \n       /* Pretend that all defs are new.  */\n@@ -1393,8 +1391,7 @@ df_reg_use_chain_create (struct df *df, bitmap blocks, bool redo)\n     {\n #ifdef ENABLE_CHECKING\n       for (regno = 0; regno < df->n_regs; regno++)\n-\tif (df->regs[regno].uses)\n-\t  abort ();\n+\tgcc_assert (!df->regs[regno].uses);\n #endif\n \n       /* Pretend that all uses are new.  */\n@@ -2298,8 +2295,7 @@ df_analyze (struct df *df, bitmap blocks, int flags)\n \n   /* We could deal with additional basic blocks being created by\n      rescanning everything again.  */\n-  if (df->n_bbs && df->n_bbs != (unsigned int) last_basic_block)\n-    abort ();\n+  gcc_assert (!df->n_bbs || df->n_bbs == (unsigned int) last_basic_block);\n \n   update = df_modified_p (df, blocks);\n   if (update || (flags != df->flags))\n@@ -2321,8 +2317,7 @@ df_analyze (struct df *df, bitmap blocks, int flags)\n \t  if (blocks == (bitmap) -1)\n \t    blocks = df->bbs_modified;\n \n-\t  if (! df->n_bbs)\n-\t    abort ();\n+\t  gcc_assert (df->n_bbs);\n \n \t  df_analyze_1 (df, blocks, flags, 1);\n \t  bitmap_zero (df->bbs_modified);\n@@ -2631,8 +2626,7 @@ df_insn_delete (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n      handle the JUMP_LABEL?  */\n \n   /* We should not be deleting the NOTE_INSN_BASIC_BLOCK or label.  */\n-  if (insn == BB_HEAD (bb))\n-    abort ();\n+  gcc_assert (insn != BB_HEAD (bb));\n \n   /* Delete the insn.  */\n   delete_insn (insn);\n@@ -2796,24 +2790,17 @@ df_refs_reg_replace (struct df *df, bitmap blocks, struct df_link *chain, rtx ol\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      if (bitmap_bit_p (blocks, DF_REF_BBNO (ref)))\n-\t{\n-\t  df_ref_reg_replace (df, ref, oldreg, newreg);\n+      gcc_assert (bitmap_bit_p (blocks, DF_REF_BBNO (ref)));\n+      \n+      df_ref_reg_replace (df, ref, oldreg, newreg);\n \n-\t  /* Replace occurrences of the reg within the REG_NOTES.  */\n-\t  if ((! link->next || DF_REF_INSN (ref)\n-\t      != DF_REF_INSN (link->next->ref))\n-\t      && REG_NOTES (insn))\n-\t    {\n-\t      args.insn = insn;\n-\t      for_each_rtx (&REG_NOTES (insn), df_rtx_reg_replace, &args);\n-\t    }\n-\t}\n-      else\n+      /* Replace occurrences of the reg within the REG_NOTES.  */\n+      if ((! link->next || DF_REF_INSN (ref)\n+\t   != DF_REF_INSN (link->next->ref))\n+\t  && REG_NOTES (insn))\n \t{\n-\t  /* Temporary check to ensure that we have a grip on which\n-\t     regs should be replaced.  */\n-\t  abort ();\n+\t  args.insn = insn;\n+\t  for_each_rtx (&REG_NOTES (insn), df_rtx_reg_replace, &args);\n \t}\n     }\n }\n@@ -2844,8 +2831,7 @@ df_ref_reg_replace (struct df *df, struct ref *ref, rtx oldreg, rtx newreg)\n   if (! INSN_P (DF_REF_INSN (ref)))\n     return 0;\n \n-  if (oldreg && oldreg != DF_REF_REG (ref))\n-    abort ();\n+  gcc_assert (!oldreg || oldreg == DF_REF_REG (ref));\n \n   if (! validate_change (DF_REF_INSN (ref), DF_REF_LOC (ref), newreg, 1))\n     return 0;\n@@ -2911,10 +2897,8 @@ df_insns_modify (struct df *df, basic_block bb, rtx first_insn, rtx last_insn)\n       /* A non-const call should not have slipped through the net.  If\n \t it does, we need to create a new basic block.  Ouch.  The\n \t same applies for a label.  */\n-      if ((CALL_P (insn)\n-\t   && ! CONST_OR_PURE_CALL_P (insn))\n-\t  || LABEL_P (insn))\n-\tabort ();\n+      gcc_assert ((!CALL_P (insn) || CONST_OR_PURE_CALL_P (insn))\n+\t\t  && !LABEL_P (insn));\n \n       uid = INSN_UID (insn);\n \n@@ -2937,8 +2921,7 @@ df_pattern_emit_before (struct df *df, rtx pattern, basic_block bb, rtx insn)\n   rtx prev_insn = PREV_INSN (insn);\n \n   /* We should not be inserting before the start of the block.  */\n-  if (insn == BB_HEAD (bb))\n-    abort ();\n+  gcc_assert (insn != BB_HEAD (bb));\n   ret_insn = emit_insn_before (pattern, insn);\n   if (ret_insn == insn)\n     return ret_insn;\n@@ -3196,10 +3179,7 @@ df_bb_reg_live_start_p (struct df *df, basic_block bb, rtx reg)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n-#ifdef ENABLE_CHECKING\n-  if (! bb_info->lr_in)\n-    abort ();\n-#endif\n+  gcc_assert (bb_info->lr_in);\n \n   return bitmap_bit_p (bb_info->lr_in, REGNO (reg));\n }\n@@ -3211,10 +3191,7 @@ df_bb_reg_live_end_p (struct df *df, basic_block bb, rtx reg)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n-#ifdef ENABLE_CHECKING\n-  if (! bb_info->lr_in)\n-    abort ();\n-#endif\n+  gcc_assert (bb_info->lr_in);\n \n   return bitmap_bit_p (bb_info->lr_out, REGNO (reg));\n }\n@@ -3234,9 +3211,8 @@ df_bb_regs_lives_compare (struct df *df, basic_block bb, rtx reg1, rtx reg2)\n \n \n   /* The regs must be local to BB.  */\n-  if (df_regno_bb (df, regno1) != bb\n-      || df_regno_bb (df, regno2) != bb)\n-    abort ();\n+  gcc_assert (df_regno_bb (df, regno1) == bb\n+\t      && df_regno_bb (df, regno2) == bb);\n \n   def2 = df_bb_regno_first_def_find (df, bb, regno2);\n   use1 = df_bb_regno_last_use_find (df, bb, regno1);\n@@ -3380,8 +3356,7 @@ df_bb_single_def_use_insn_find (struct df *df, basic_block bb, rtx insn, rtx reg\n \n   def = df_bb_insn_regno_first_def_find (df, bb, insn, REGNO (reg));\n \n-  if (! def)\n-    abort ();\n+  gcc_assert (def);\n \n   du_link = DF_REF_CHAIN (def);\n \n@@ -3761,7 +3736,7 @@ dataflow_set_a_op_b (enum set_representation repr,\n \t  break;\n \n     \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n@@ -3777,12 +3752,12 @@ dataflow_set_a_op_b (enum set_representation repr,\n \t  break;\n \n     \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3800,7 +3775,7 @@ dataflow_set_copy (enum set_representation repr, void *dest, void *src)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3816,8 +3791,7 @@ hybrid_search (basic_block bb, struct dataflow *dataflow,\n   edge e;\n \n   SET_BIT (visited, bb->index);\n-  if (!TEST_BIT (pending, bb->index))\n-    abort ();\n+  gcc_assert (TEST_BIT (pending, bb->index));\n   RESET_BIT (pending, i);\n \n #define HS(E_ANTI, E_ANTI_NEXT, E_ANTI_BB, E_ANTI_START_BB, IN_SET,\t\\"}, {"sha": "d6b6ea724a2e7606d70e6560ff5fa1adb80ea600", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -174,8 +174,7 @@ diagnostic_build_prefix (diagnostic_info *diagnostic)\n     \"must-not-happen\"\n   };\n   expanded_location s = expand_location (diagnostic->location);\n-  if (diagnostic->kind >= DK_LAST_DIAGNOSTIC_KIND)\n-    abort();\n+  gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);\n \n   return s.file\n     ? build_message_string (\"%s:%d: %s\",\n@@ -194,8 +193,7 @@ diagnostic_count_diagnostic (diagnostic_context *context,\n   switch (kind)\n     {\n     default:\n-      abort();\n-      break;\n+      gcc_unreachable ();\n \n     case DK_ICE:\n #ifndef ENABLE_CHECKING"}, {"sha": "50fc093f72f61a8197e95a369d90e3183bdf163e", "filename": "gcc/dojump.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -265,7 +265,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     case COMPOUND_EXPR:\n     case COND_EXPR:\n       /* Lowered by gimplify.c.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -301,10 +301,12 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       {\n         tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \n-        if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_FLOAT\n-            || GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_INT)\n-\t  abort ();\n-        else if (integer_zerop (TREE_OPERAND (exp, 1)))\n+        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_FLOAT);\n+\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_INT);\n+\t\n+        if (integer_zerop (TREE_OPERAND (exp, 1)))\n           do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n                  && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n@@ -318,10 +320,12 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       {\n         tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \n-        if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_FLOAT\n-            || GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_INT)\n-\t  abort ();\n-        else if (integer_zerop (TREE_OPERAND (exp, 1)))\n+        gcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_FLOAT);\n+\tgcc_assert (GET_MODE_CLASS (TYPE_MODE (inner_type))\n+\t\t    != MODE_COMPLEX_INT);\n+\t\n+        if (integer_zerop (TREE_OPERAND (exp, 1)))\n           do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n         else if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n            && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n@@ -511,8 +515,10 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n                && ! can_compare_p (NE, GET_MODE (temp), ccp_jump))\n         /* Note swapping the labels gives us not-equal.  */\n         do_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n-      else if (GET_MODE (temp) != VOIDmode)\n+      else\n \t{\n+\t  gcc_assert (GET_MODE (temp) != VOIDmode);\n+\t  \n \t  /* The RTL optimizers prefer comparisons against pseudos.  */\n \t  if (GET_CODE (temp) == SUBREG)\n \t    {\n@@ -528,8 +534,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t\t\t\t   GET_MODE (temp), NULL_RTX,\n \t\t\t\t   if_false_label, if_true_label);\n \t}\n-      else\n-        abort ();\n     }\n }\n \f"}, {"sha": "5d7f824d1d60efddb7b6f658dc31552fef7a13ec", "filename": "gcc/dominance.c", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -271,8 +271,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb,\n \t      e_next = bn->succ;\n \t    }\n \n-\t  if (bn == en_block)\n-\t    abort ();\n+\t  gcc_assert (bn != en_block);\n \n \t  /* Fill the DFS tree info calculatable _before_ recursing.  */\n \t  if (bb != en_block)\n@@ -375,8 +374,7 @@ calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n   di->nodes = di->dfsnum - 1;\n \n   /* This aborts e.g. when there is _no_ path from ENTRY to EXIT at all.  */\n-  if (di->nodes != (unsigned int) n_basic_blocks + 1)\n-    abort ();\n+  gcc_assert (di->nodes == (unsigned int) n_basic_blocks + 1);\n }\n \n /* Compress the path from V to the root of its set and update path_min at the\n@@ -597,8 +595,7 @@ compute_dom_fast_query (enum cdi_direction dir)\n   int num = 0;\n   basic_block bb;\n \n-  if (dom_computed[dir] < DOM_NO_FAST_QUERY)\n-    abort ();\n+  gcc_assert (dom_computed[dir] >= DOM_NO_FAST_QUERY);\n \n   if (dom_computed[dir] == DOM_OK)\n     return;\n@@ -629,8 +626,7 @@ calculate_dominance_info (enum cdi_direction dir)\n       if (dom_computed[dir] != DOM_NONE)\n \tfree_dominance_info (dir);\n \n-      if (n_bbs_in_dom_tree[dir])\n-\tabort ();\n+      gcc_assert (!n_bbs_in_dom_tree[dir]);\n \n       FOR_ALL_BB (b)\n \t{\n@@ -672,8 +668,7 @@ free_dominance_info (enum cdi_direction dir)\n     }\n \n   /* If there are any nodes left, something is wrong.  */\n-  if (n_bbs_in_dom_tree[dir])\n-    abort ();\n+  gcc_assert (!n_bbs_in_dom_tree[dir]);\n \n   dom_computed[dir] = DOM_NONE;\n }\n@@ -684,8 +679,7 @@ get_immediate_dominator (enum cdi_direction dir, basic_block bb)\n {\n   struct et_node *node = bb->dom[dir];\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (!node->father)\n     return NULL;\n@@ -701,8 +695,7 @@ set_immediate_dominator (enum cdi_direction dir, basic_block bb,\n {\n   struct et_node *node = bb->dom[dir];\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (node->father)\n     {\n@@ -726,8 +719,7 @@ get_dominated_by (enum cdi_direction dir, basic_block bb, basic_block **bbs)\n   int n;\n   struct et_node *node = bb->dom[dir], *son = node->son, *ason;\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (!son)\n     {\n@@ -753,8 +745,7 @@ redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n {\n   struct et_node *bb_node = bb->dom[dir], *to_node = to->dom[dir], *son;\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (!bb_node->son)\n     return;\n@@ -775,8 +766,7 @@ redirect_immediate_dominators (enum cdi_direction dir, basic_block bb,\n basic_block\n nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n {\n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (!bb1)\n     return bb2;\n@@ -792,8 +782,7 @@ dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n { \n   struct et_node *n1 = bb1->dom[dir], *n2 = bb2->dom[dir];\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (dom_computed[dir] == DOM_OK)\n     return (n1->dfs_num_in >= n2->dfs_num_in\n@@ -809,8 +798,7 @@ verify_dominators (enum cdi_direction dir)\n   int err = 0;\n   basic_block bb;\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -838,8 +826,7 @@ verify_dominators (enum cdi_direction dir)\n \t}\n     }\n \n-  if (err)\n-    abort ();\n+  gcc_assert (!err);\n }\n \n /* Determine immediate dominator (or postdominator, according to DIR) of BB,\n@@ -853,8 +840,7 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n   basic_block dom_bb = NULL;\n   edge e;\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   if (dir == CDI_DOMINATORS)\n     {\n@@ -889,8 +875,7 @@ iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n   int i, changed = 1;\n   basic_block old_dom, new_dom;\n \n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   for (i = 0; i < n; i++)\n     set_immediate_dominator (dir, bbs[i], NULL);\n@@ -911,18 +896,14 @@ iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n     }\n \n   for (i = 0; i < n; i++)\n-    if (!get_immediate_dominator (dir, bbs[i]))\n-      abort ();\n+    gcc_assert (get_immediate_dominator (dir, bbs[i]));\n }\n \n void\n add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n-  if (!dom_computed[dir])\n-    abort ();\n-\n-  if (bb->dom[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n+  gcc_assert (!bb->dom[dir]);\n \n   n_bbs_in_dom_tree[dir]++;\n   \n@@ -935,8 +916,7 @@ add_to_dominance_info (enum cdi_direction dir, basic_block bb)\n void\n delete_from_dominance_info (enum cdi_direction dir, basic_block bb)\n {\n-  if (!dom_computed[dir])\n-    abort ();\n+  gcc_assert (dom_computed[dir]);\n \n   et_free_tree (bb->dom[dir]);\n   bb->dom[dir] = NULL;"}, {"sha": "6d2c3cb87e6cbcac0a17835156058c1e97313008", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -333,8 +333,9 @@ size_of_encoded_value (int encoding)\n       return 4;\n     case DW_EH_PE_udata8:\n       return 8;\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Yield a name for a given pointer encoding.  */\n@@ -486,12 +487,12 @@ eh_data_format_name (int format)\n #if HAVE_DESIGNATED_INITIALIZERS\n   };\n \n-  if (format < 0 || format > 0xff || format_names[format] == NULL)\n-    abort ();\n+  gcc_assert (format >= 0 && format < 0x100 && format_names[format]);\n+  \n   return format_names[format];\n #else\n   }\n-  abort ();\n+  gcc_unreachable ();\n #endif\n }\n \n@@ -635,7 +636,7 @@ dw2_asm_output_delta_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n   fputc ('-', asm_out_file);\n   assemble_name (asm_out_file, lab2);\n #else\n-  abort ();\n+  gcc_unreachable ();\n #endif\n \n   if (flag_debug_asm && comment)\n@@ -663,7 +664,7 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n   fputc ('-', asm_out_file);\n   assemble_name (asm_out_file, lab2);\n #else\n-  abort ();\n+  gcc_unreachable ();\n #endif\n \n   if (flag_debug_asm && comment)\n@@ -704,8 +705,7 @@ dw2_force_const_mem (rtx x)\n   if (! indirect_pool)\n     indirect_pool = splay_tree_new_ggc (splay_tree_compare_pointers);\n \n-  if (GET_CODE (x) != SYMBOL_REF)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n   str = targetm.strip_name_encoding (XSTR (x, 0));\n   node = splay_tree_lookup (indirect_pool, (splay_tree_key) str);\n@@ -836,8 +836,7 @@ dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr,\n \t  break;\n \n \tcase DW_EH_PE_pcrel:\n-\t  if (GET_CODE (addr) != SYMBOL_REF)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (addr) == SYMBOL_REF);\n #ifdef ASM_OUTPUT_DWARF_PCREL\n \t  ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, XSTR (addr, 0));\n #else\n@@ -848,7 +847,7 @@ dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr,\n \tdefault:\n \t  /* Other encodings should have been handled by\n \t     ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n #ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX"}, {"sha": "8b60c26c17ad037545cecbd9bcbb8ce588096342", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 266, "deletions": 351, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced3f397be6d68ba9a838ee7e3f27c456238501a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ced3f397be6d68ba9a838ee7e3f27c456238501a", "patch": "@@ -489,8 +489,7 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n       }\n \n #ifdef DWARF_ALT_FRAME_RETURN_COLUMN\n-  if (! wrote_return_column)\n-    abort ();\n+  gcc_assert (wrote_return_column);\n   i = DWARF_ALT_FRAME_RETURN_COLUMN;\n   wrote_return_column = false;\n #else\n@@ -829,8 +828,7 @@ reg_save (const char *label, unsigned int reg, unsigned int sreg, HOST_WIDE_INT\n \t   description.  */\n \tHOST_WIDE_INT check_offset = offset / DWARF_CIE_DATA_ALIGNMENT;\n \n-\tif (check_offset * DWARF_CIE_DATA_ALIGNMENT != offset)\n-\t  abort ();\n+\tgcc_assert (check_offset * DWARF_CIE_DATA_ALIGNMENT == offset);\n       }\n #endif\n       offset /= DWARF_CIE_DATA_ALIGNMENT;\n@@ -934,25 +932,22 @@ initial_return_save (rtx rtl)\n       switch (GET_CODE (rtl))\n \t{\n \tcase REG:\n-\t  if (REGNO (rtl) != STACK_POINTER_REGNUM)\n-\t    abort ();\n+\t  gcc_assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n \t  offset = 0;\n \t  break;\n \n \tcase PLUS:\n-\t  if (REGNO (XEXP (rtl, 0)) != STACK_POINTER_REGNUM)\n-\t    abort ();\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n \t  offset = INTVAL (XEXP (rtl, 1));\n \t  break;\n \n \tcase MINUS:\n-\t  if (REGNO (XEXP (rtl, 0)) != STACK_POINTER_REGNUM)\n-\t    abort ();\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n \t  offset = -INTVAL (XEXP (rtl, 1));\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       break;\n@@ -961,13 +956,12 @@ initial_return_save (rtx rtl)\n       /* The return address is at some offset from any value we can\n \t actually load.  For instance, on the SPARC it is in %i7+8. Just\n \t ignore the offset for now; it doesn't matter for unwinding frames.  */\n-      if (GET_CODE (XEXP (rtl, 1)) != CONST_INT)\n-\tabort ();\n+      gcc_assert (GET_CODE (XEXP (rtl, 1)) == CONST_INT);\n       initial_return_save (XEXP (rtl, 0));\n       return;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (reg != DWARF_FRAME_RETURN_COLUMN)\n@@ -1012,9 +1006,8 @@ stack_adjust_offset (rtx pattern)\n \t    {\n \t      rtx val = XEXP (XEXP (src, 1), 1);\n \t      /* We handle only adjustments by constant amount.  */\n-\t      if (GET_CODE (XEXP (src, 1)) != PLUS ||\n-\t\t  GET_CODE (val) != CONST_INT)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (XEXP (src, 1)) == PLUS\n+\t\t\t  && GET_CODE (val) == CONST_INT);\n \t      offset = -INTVAL (val);\n \t      break;\n \t    }\n@@ -1074,8 +1067,7 @@ dwarf2out_stack_adjust (rtx insn)\n \tinsn = XVECEXP (insn, 0, 0);\n       if (GET_CODE (insn) == SET)\n \tinsn = SET_SRC (insn);\n-      if (GET_CODE (insn) != CALL)\n-\tabort ();\n+      gcc_assert (GET_CODE (insn) == CALL);\n \n       dwarf2out_args_size (\"\", INTVAL (XEXP (insn, 1)));\n       return;\n@@ -1208,8 +1200,7 @@ flush_queued_reg_saves (void)\n \t  break;\n       if (q->saved_reg && i == num_regs_saved_in_regs)\n \t{\n-\t  if (i == ARRAY_SIZE (regs_saved_in_regs))\n-\t    abort ();\n+\t  gcc_assert (i != ARRAY_SIZE (regs_saved_in_regs));\n \t  num_regs_saved_in_regs++;\n \t}\n       if (i != num_regs_saved_in_regs)\n@@ -1466,8 +1457,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n       return;\n     }\n \n-  if (GET_CODE (expr) != SET)\n-    abort ();\n+  gcc_assert (GET_CODE (expr) == SET);\n \n   src = SET_SRC (expr);\n   dest = SET_DEST (expr);\n@@ -1500,14 +1490,13 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      cfa_temp.reg = cfa.reg;\n \t      cfa_temp.offset = cfa.offset;\n \t    }\n-\t  else if (call_used_regs [REGNO (dest)] \n-\t\t   && ! fixed_regs [REGNO (dest)])\n+\t  else\n \t    {\n \t      /* Saving a register in a register.  */\n+\t      gcc_assert (call_used_regs [REGNO (dest)]\n+\t\t\t  && !fixed_regs [REGNO (dest)]);\n \t      queue_reg_save (label, src, dest, 0);\n \t    }\n-\t  else\n-\t    abort ();\n \t  break;\n \n \tcase PLUS:\n@@ -1523,26 +1512,25 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  break;\n \t\tcase REG:\n-\t\t  if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp.reg)\n-\t\t    abort ();\n+\t\t  gcc_assert ((unsigned) REGNO (XEXP (src, 1))\n+\t\t\t      == cfa_temp.reg);\n \t\t  offset = cfa_temp.offset;\n \t\t  break;\n \t\tdefault:\n-\t\t  abort ();\n+\t\t  gcc_unreachable ();\n \t\t}\n \n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n \t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  if (cfa.reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-\t\t    abort ();\n+\t\t  gcc_assert (cfa.reg == (unsigned) HARD_FRAME_POINTER_REGNUM);\n \t\t  cfa.reg = STACK_POINTER_REGNUM;\n \t\t}\n \t      else if (GET_CODE (src) == LO_SUM)\n \t\t/* Assume we've set the source reg of the LO_SUM from sp.  */\n \t\t;\n-\t      else if (XEXP (src, 0) != stack_pointer_rtx)\n-\t\tabort ();\n+\t      else\n+\t\tgcc_assert (XEXP (src, 0) == stack_pointer_rtx);\n \n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n@@ -1556,26 +1544,20 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      /* Rule 3 */\n \t      /* Either setting the FP from an offset of the SP,\n \t\t or adjusting the FP */\n-\t      if (! frame_pointer_needed)\n-\t\tabort ();\n+\t      gcc_assert (frame_pointer_needed);\n \n-\t      if (REG_P (XEXP (src, 0))\n-\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n-\t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t\t{\n-\t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  if (GET_CODE (src) != MINUS)\n-\t\t    offset = -offset;\n-\t\t  cfa.offset += offset;\n-\t\t  cfa.reg = HARD_FRAME_POINTER_REGNUM;\n-\t\t}\n-\t      else\n-\t\tabort ();\n+\t      gcc_assert (REG_P (XEXP (src, 0))\n+\t\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa.reg\n+\t\t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT);\n+\t      offset = INTVAL (XEXP (src, 1));\n+\t      if (GET_CODE (src) != MINUS)\n+\t\toffset = -offset;\n+\t      cfa.offset += offset;\n+\t      cfa.reg = HARD_FRAME_POINTER_REGNUM;\n \t    }\n \t  else\n \t    {\n-\t      if (GET_CODE (src) == MINUS)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (src) != MINUS);\n \n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n@@ -1599,8 +1581,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t{\n \t\t  /* Setting a scratch register that we will use instead\n \t\t     of SP for saving registers to the stack.  */\n-\t\t  if (cfa.reg != STACK_POINTER_REGNUM)\n-\t\t    abort ();\n+\t\t  gcc_assert (cfa.reg == STACK_POINTER_REGNUM);\n \t\t  cfa_store.reg = REGNO (dest);\n \t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n \t\t}\n@@ -1613,7 +1594,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t  cfa_temp.offset = INTVAL (XEXP (src, 1));\n \t\t}\n \t      else\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t    }\n \t  break;\n \n@@ -1625,10 +1606,9 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t  /* Rule 7 */\n \tcase IOR:\n-\t  if (!REG_P (XEXP (src, 0))\n-\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp.reg\n-\t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n-\t    abort ();\n+\t  gcc_assert (REG_P (XEXP (src, 0))\n+\t\t      && (unsigned) REGNO (XEXP (src, 0)) == cfa_temp.reg\n+\t\t      && GET_CODE (XEXP (src, 1)) == CONST_INT);\n \n \t  if ((unsigned) REGNO (dest) != cfa_temp.reg)\n \t    cfa_temp.reg = REGNO (dest);\n@@ -1642,15 +1622,14 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       def_cfa_1 (label, &cfa);\n       break;\n \n     case MEM:\n-      if (!REG_P (src))\n-\tabort ();\n+      gcc_assert (REG_P (src));\n \n       /* Saving a register to the stack.  Make sure dest is relative to the\n \t CFA register.  */\n@@ -1660,13 +1639,12 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  /* With a push.  */\n \tcase PRE_MODIFY:\n \t  /* We can't handle variable size modifications.  */\n-\t  if (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1)) != CONST_INT)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n+\t\t      == CONST_INT);\n \t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n \n-\t  if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n-\t      || cfa_store.reg != STACK_POINTER_REGNUM)\n-\t    abort ();\n+\t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n+\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n \n \t  cfa_store.offset += offset;\n \t  if (cfa.reg == STACK_POINTER_REGNUM)\n@@ -1682,9 +1660,8 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n \t    offset = -offset;\n \n-\t  if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n-\t      || cfa_store.reg != STACK_POINTER_REGNUM)\n-\t    abort ();\n+\t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n+\t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n \n \t  cfa_store.offset += offset;\n \t  if (cfa.reg == STACK_POINTER_REGNUM)\n@@ -1698,41 +1675,52 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tcase PLUS:\n \tcase MINUS:\n \tcase LO_SUM:\n-\t  if (GET_CODE (XEXP (XEXP (dest, 0), 1)) != CONST_INT)\n-\t    abort ();\n-\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n-\t  if (GET_CODE (XEXP (dest, 0)) == MINUS)\n-\t    offset = -offset;\n-\n-\t  if (cfa_store.reg == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n-\t    offset -= cfa_store.offset;\n-\t  else if (cfa_temp.reg == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n-\t    offset -= cfa_temp.offset;\n-\t  else\n-\t    abort ();\n+\t  {\n+\t    int regno;\n+\t    \n+\t    gcc_assert (GET_CODE (XEXP (XEXP (dest, 0), 1)) == CONST_INT);\n+\t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n+\t      offset = -offset;\n+\n+\t    regno = REGNO (XEXP (XEXP (dest, 0), 0));\n+\t    \n+\t    if (cfa_store.reg == (unsigned) regno)\n+\t      offset -= cfa_store.offset;\n+\t    else\n+\t      {\n+\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\toffset -= cfa_temp.offset;\n+\t      }\n+\t  }\n \t  break;\n \n \t  /* Rule 13 */\n \t  /* Without an offset.  */\n \tcase REG:\n-\t  if (cfa_store.reg == (unsigned) REGNO (XEXP (dest, 0)))\n-\t    offset = -cfa_store.offset;\n-\t  else if (cfa_temp.reg == (unsigned) REGNO (XEXP (dest, 0)))\n-\t    offset = -cfa_temp.offset;\n-\t  else\n-\t    abort ();\n+\t  {\n+\t    int regno = REGNO (XEXP (dest, 0));\n+\t    \n+\t    if (cfa_store.reg == (unsigned) regno)\n+\t      offset = -cfa_store.offset;\n+\t    else\n+\t      {\n+\t\tgcc_assert (cfa_temp.reg == (unsigned) regno);\n+\t\toffset = -cfa_temp.offset;\n+\t      }\n+\t  }\n \t  break;\n \n \t  /* Rule 14 */\n \tcase POST_INC:\n-\t  if (cfa_temp.reg != (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)))\n-\t    abort ();\n+\t  gcc_assert (cfa_temp.reg\n+\t\t      == (unsigned) REGNO (XEXP (XEXP (dest, 0), 0)));\n \t  offset = -cfa_temp.offset;\n \t  cfa_temp.offset -= GET_MODE_SIZE (GET_MODE (dest));\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (REGNO (src) != STACK_POINTER_REGNUM\n@@ -1758,8 +1746,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t      if (!REG_P (x))\n \t\tx = XEXP (x, 0);\n-\t      if (!REG_P (x))\n-\t\tabort ();\n+\t      gcc_assert (REG_P (x));\n \n \t      cfa.reg = REGNO (x);\n \t      cfa.base_offset = offset;\n@@ -1774,7 +1761,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1797,8 +1784,8 @@ dwarf2out_frame_debug (rtx insn)\n \n       /* Set up state for generating call frame debug info.  */\n       lookup_cfa (&cfa);\n-      if (cfa.reg != (unsigned long) DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM))\n-\tabort ();\n+      gcc_assert (cfa.reg\n+\t\t  == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n \n       cfa.reg = STACK_POINTER_REGNUM;\n       cfa_store = cfa;\n@@ -1879,7 +1866,7 @@ dw_cfi_oprnd1_desc (enum dwarf_call_frame_info cfi)\n       return dw_cfi_oprnd_loc;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2030,7 +2017,7 @@ output_cfi (dw_cfi_ref cfi, dw_fde_ref fde, int for_eh)\n \n \tcase DW_CFA_GNU_negative_offset_extended:\n \t  /* Obsoleted by DW_CFA_offset_extended_sf.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \n \tdefault:\n \t  break;\n@@ -2185,8 +2172,7 @@ output_call_frame_info (int for_eh)\n \n \t  /* Augmentations should be small, so there's scarce need to\n \t     iterate for a solution.  Die if we exceed one uleb128 byte.  */\n-\t  if (size_of_uleb128 (augmentation_size) != 1)\n-\t    abort ();\n+\t  gcc_assert (size_of_uleb128 (augmentation_size) == 1);\n \t}\n     }\n \n@@ -2289,8 +2275,7 @@ output_call_frame_info (int for_eh)\n \t\t  int pad = -offset & (PTR_SIZE - 1);\n \n \t\t  size += pad;\n-\t\t  if (size_of_uleb128 (size) != 1)\n-\t\t    abort ();\n+\t\t  gcc_assert (size_of_uleb128 (size) == 1);\n \t\t}\n \n \t      dw2_asm_output_data_uleb128 (size, \"Augmentation size\");\n@@ -3089,19 +3074,16 @@ output_loc_operands (dw_loc_descr_ref loc)\n       break;\n     case DW_OP_const8u:\n     case DW_OP_const8s:\n-      if (HOST_BITS_PER_LONG < 64)\n-\tabort ();\n+      gcc_assert (HOST_BITS_PER_LONG >= 64);\n       dw2_asm_output_data (8, val1->v.val_int, NULL);\n       break;\n     case DW_OP_skip:\n     case DW_OP_bra:\n       {\n \tint offset;\n \n-\tif (val1->val_class == dw_val_class_loc)\n-\t  offset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n-\telse\n-\t  abort ();\n+\tgcc_assert (val1->val_class == dw_val_class_loc);\n+\toffset = val1->v.val_loc->dw_loc_addr - (loc->dw_loc_addr + 3);\n \n \tdw2_asm_output_data (2, offset, NULL);\n       }\n@@ -3120,7 +3102,7 @@ output_loc_operands (dw_loc_descr_ref loc)\n \t aligned properly like we do for the main unwind info, so\n \t don't support emitting things larger than a byte if we're\n \t only doing unwinding.  */\n-      abort ();\n+      gcc_unreachable ();\n #endif\n     case DW_OP_const1u:\n     case DW_OP_const1s:\n@@ -3196,7 +3178,7 @@ output_loc_operands (dw_loc_descr_ref loc)\n \t\t\t       val1->v.val_addr);\n       fputc ('\\n', asm_out_file);\n #else\n-      abort ();\n+      gcc_unreachable ();\n #endif\n       break;\n \n@@ -3248,8 +3230,7 @@ build_cfa_loc (dw_cfa_location *cfa)\n {\n   struct dw_loc_descr_struct *head, *tmp;\n \n-  if (cfa->indirect == 0)\n-    abort ();\n+  gcc_assert (cfa->indirect);\n \n   if (cfa->base_offset)\n     {\n@@ -4585,12 +4566,9 @@ decl_ultimate_origin (tree decl)\n   if (DECL_ABSTRACT (decl) && DECL_ABSTRACT_ORIGIN (decl) == decl)\n     return NULL_TREE;\n \n-#ifdef ENABLE_CHECKING\n-  if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n-    /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n-       most distant ancestor, this should never happen.  */\n-    abort ();\n-#endif\n+  /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n+     most distant ancestor, this should never happen.  */\n+  gcc_assert (!DECL_FROM_INLINE (DECL_ORIGIN (decl)));\n \n   return DECL_ABSTRACT_ORIGIN (decl);\n }\n@@ -4688,10 +4666,8 @@ add_AT_flag (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int flag)\n static inline unsigned\n AT_flag (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_flag)\n-    return a->dw_attr_val.v.val_flag;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_flag);\n+  return a->dw_attr_val.v.val_flag;\n }\n \n /* Add a signed integer attribute value to a DIE.  */\n@@ -4711,10 +4687,8 @@ add_AT_int (dw_die_ref die, enum dwarf_attribute attr_kind, HOST_WIDE_INT int_va\n static inline HOST_WIDE_INT\n AT_int (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_const)\n-    return a->dw_attr_val.v.val_int;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_const);\n+  return a->dw_attr_val.v.val_int;\n }\n \n /* Add an unsigned integer attribute value to a DIE.  */\n@@ -4735,10 +4709,8 @@ add_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind,\n static inline unsigned HOST_WIDE_INT\n AT_unsigned (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_unsigned_const)\n-    return a->dw_attr_val.v.val_unsigned;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_unsigned_const);\n+  return a->dw_attr_val.v.val_unsigned;\n }\n \n /* Add an unsigned double integer attribute value to a DIE.  */\n@@ -4820,10 +4792,8 @@ add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)\n static inline const char *\n AT_string (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_str)\n-    return a->dw_attr_val.v.val_str->str;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_str);\n+  return a->dw_attr_val.v.val_str->str;\n }\n \n /* Find out whether a string should be output inline in DIE\n@@ -4832,38 +4802,35 @@ AT_string (dw_attr_ref a)\n static int\n AT_string_form (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_str)\n-    {\n-      struct indirect_string_node *node;\n-      unsigned int len;\n-      char label[32];\n-\n-      node = a->dw_attr_val.v.val_str;\n-      if (node->form)\n-\treturn node->form;\n-\n-      len = strlen (node->str) + 1;\n+  struct indirect_string_node *node;\n+  unsigned int len;\n+  char label[32];\n \n-      /* If the string is shorter or equal to the size of the reference, it is\n-\t always better to put it inline.  */\n-      if (len <= DWARF_OFFSET_SIZE || node->refcount == 0)\n-\treturn node->form = DW_FORM_string;\n+  gcc_assert (a && AT_class (a) == dw_val_class_str);\n+  \n+  node = a->dw_attr_val.v.val_str;\n+  if (node->form)\n+    return node->form;\n+  \n+  len = strlen (node->str) + 1;\n \n-      /* If we cannot expect the linker to merge strings in .debug_str\n-\t section, only put it into .debug_str if it is worth even in this\n-\t single module.  */\n-      if ((DEBUG_STR_SECTION_FLAGS & SECTION_MERGE) == 0\n-\t  && (len - DWARF_OFFSET_SIZE) * node->refcount <= len)\n-\treturn node->form = DW_FORM_string;\n+  /* If the string is shorter or equal to the size of the reference, it is\n+     always better to put it inline.  */\n+  if (len <= DWARF_OFFSET_SIZE || node->refcount == 0)\n+    return node->form = DW_FORM_string;\n \n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n-      ++dw2_string_counter;\n-      node->label = xstrdup (label);\n+  /* If we cannot expect the linker to merge strings in .debug_str\n+     section, only put it into .debug_str if it is worth even in this\n+     single module.  */\n+  if ((DEBUG_STR_SECTION_FLAGS & SECTION_MERGE) == 0\n+      && (len - DWARF_OFFSET_SIZE) * node->refcount <= len)\n+    return node->form = DW_FORM_string;\n \n-      return node->form = DW_FORM_strp;\n-    }\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n+  ++dw2_string_counter;\n+  node->label = xstrdup (label);\n \n-  abort ();\n+  return node->form = DW_FORM_strp;\n }\n \n /* Add a DIE reference attribute value to a DIE.  */\n@@ -4888,18 +4855,15 @@ static inline void\n add_AT_specification (dw_die_ref die, dw_die_ref targ_die)\n {\n   add_AT_die_ref (die, DW_AT_specification, targ_die);\n-  if (targ_die->die_definition)\n-    abort ();\n+  gcc_assert (!targ_die->die_definition);\n   targ_die->die_definition = die;\n }\n \n static inline dw_die_ref\n AT_ref (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_die_ref)\n-    return a->dw_attr_val.v.val_die_ref.die;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_die_ref);\n+  return a->dw_attr_val.v.val_die_ref.die;\n }\n \n static inline int\n@@ -4914,10 +4878,8 @@ AT_ref_external (dw_attr_ref a)\n static inline void\n set_AT_ref_external (dw_attr_ref a, int i)\n {\n-  if (a && AT_class (a) == dw_val_class_die_ref)\n-    a->dw_attr_val.v.val_die_ref.external = i;\n-  else\n-    abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_die_ref);\n+  a->dw_attr_val.v.val_die_ref.external = i;\n }\n \n /* Add an FDE reference attribute value to a DIE.  */\n@@ -4951,10 +4913,8 @@ add_AT_loc (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_descr_ref loc\n static inline dw_loc_descr_ref\n AT_loc (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_loc)\n-    return a->dw_attr_val.v.val_loc;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_loc);\n+  return a->dw_attr_val.v.val_loc;\n }\n \n static inline void\n@@ -4973,10 +4933,8 @@ add_AT_loc_list (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_list_ref\n static inline dw_loc_list_ref\n AT_loc_list (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_loc_list)\n-    return a->dw_attr_val.v.val_loc_list;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_loc_list);\n+  return a->dw_attr_val.v.val_loc_list;\n }\n \n /* Add an address constant attribute value to a DIE.  */\n@@ -4996,10 +4954,8 @@ add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr)\n static inline rtx\n AT_addr (dw_attr_ref a)\n {\n-  if (a && AT_class (a) == dw_val_class_addr)\n-    return a->dw_attr_val.v.val_addr;\n-\n-  abort ();\n+  gcc_assert (a && AT_class (a) == dw_val_class_addr);\n+  return a->dw_attr_val.v.val_addr;\n }\n \n /* Add a label identifier attribute value to a DIE.  */\n@@ -5063,11 +5019,9 @@ add_AT_range_list (dw_die_ref die, enum dwarf_attribute attr_kind,\n static inline const char *\n AT_lbl (dw_attr_ref a)\n {\n-  if (a && (AT_class (a) == dw_val_class_lbl_id\n-\t    || AT_class (a) == dw_val_class_lbl_offset))\n-    return a->dw_attr_val.v.val_lbl_id;\n-\n-  abort ();\n+  gcc_assert (a && (AT_class (a) == dw_val_class_lbl_id\n+\t\t    || AT_class (a) == dw_val_class_lbl_offset));\n+  return a->dw_attr_val.v.val_lbl_id;\n }\n \n /* Get the attribute of type attr_kind.  */\n@@ -5317,8 +5271,7 @@ add_child_die (dw_die_ref die, dw_die_ref child_die)\n {\n   if (die != NULL && child_die != NULL)\n     {\n-      if (die == child_die)\n-\tabort ();\n+      gcc_assert (die != child_die);\n \n       child_die->die_parent = die;\n       child_die->die_sib = die->die_child;\n@@ -5344,9 +5297,9 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n \tchild = tmp;\n     }\n \n-  if (child->die_parent != parent\n-      && child->die_parent != get_AT_ref (parent, DW_AT_specification))\n-    abort ();\n+  gcc_assert (child->die_parent == parent\n+\t      || (child->die_parent\n+\t\t  == get_AT_ref (parent, DW_AT_specification)));\n \n   for (p = &(child->die_parent->die_child); *p; p = &((*p)->die_sib))\n     if (*p == child)\n@@ -5778,15 +5731,8 @@ attr_checksum (dw_attr_ref at, struct md5_ctx *ctx, int *mark)\n \n     case dw_val_class_addr:\n       r = AT_addr (at);\n-      switch (GET_CODE (r))\n-\t{\n-\tcase SYMBOL_REF:\n-\t  CHECKSUM_STRING (XSTR (r, 0));\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      gcc_assert (GET_CODE (r) == SYMBOL_REF);\n+      CHECKSUM_STRING (XSTR (r, 0));\n       break;\n \n     case dw_val_class_offset:\n@@ -5886,14 +5832,8 @@ same_dw_val_p (dw_val_node *v1, dw_val_node *v2, int *mark)\n       r2 = v2->v.val_addr;\n       if (GET_CODE (r1) != GET_CODE (r2))\n \treturn 0;\n-      switch (GET_CODE (r1))\n-\t{\n-\tcase SYMBOL_REF:\n-\t  return !strcmp (XSTR (r1, 0), XSTR (r2, 0));\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      gcc_assert (GET_CODE (r1) == SYMBOL_REF);\n+      return !strcmp (XSTR (r1, 0), XSTR (r2, 0));\n \n     case dw_val_class_offset:\n       return v1->v.val_offset == v2->v.val_offset;\n@@ -6269,8 +6209,7 @@ break_out_includes (dw_die_ref die)\n #if 0\n   /* We can only use this in debugging, since the frontend doesn't check\n      to make sure that we leave every include file we enter.  */\n-  if (unit != NULL)\n-    abort ();\n+  gcc_assert (!unit);\n #endif\n \n   assign_symbol_names (die);\n@@ -6351,8 +6290,7 @@ build_abbrev_table (dw_die_ref die)\n     if (AT_class (d_attr) == dw_val_class_die_ref\n \t&& AT_ref (d_attr)->die_mark == 0)\n       {\n-\tif (AT_ref (d_attr)->die_symbol == 0)\n-\t  abort ();\n+\tgcc_assert (AT_ref (d_attr)->die_symbol);\n \n \tset_AT_ref_external (d_attr, 1);\n       }\n@@ -6497,7 +6435,7 @@ size_of_die (dw_die_ref die)\n \t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -6535,8 +6473,7 @@ mark_dies (dw_die_ref die)\n {\n   dw_die_ref c;\n \n-  if (die->die_mark)\n-    abort ();\n+  gcc_assert (!die->die_mark);\n \n   die->die_mark = 1;\n   for (c = die->die_child; c; c = c->die_sib)\n@@ -6550,8 +6487,7 @@ unmark_dies (dw_die_ref die)\n {\n   dw_die_ref c;\n \n-  if (!die->die_mark)\n-    abort ();\n+  gcc_assert (die->die_mark);\n \n   die->die_mark = 0;\n   for (c = die->die_child; c; c = c->die_sib)\n@@ -6627,11 +6563,15 @@ value_format (dw_attr_ref a)\n       return DW_FORM_addr;\n     case dw_val_class_range_list:\n     case dw_val_class_offset:\n-      if (DWARF_OFFSET_SIZE == 4)\n-\treturn DW_FORM_data4;\n-      if (DWARF_OFFSET_SIZE == 8)\n-\treturn DW_FORM_data8;\n-      abort ();\n+      switch (DWARF_OFFSET_SIZE)\n+\t{\n+\tcase 4:\n+\t  return DW_FORM_data4;\n+\tcase 8:\n+\t  return DW_FORM_data8;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     case dw_val_class_loc_list:\n       /* FIXME: Could be DW_FORM_data8, with a > 32 bit size\n \t .debug_loc section */\n@@ -6644,7 +6584,7 @@ value_format (dw_attr_ref a)\n \tcase 2:\n \t  return DW_FORM_block2;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     case dw_val_class_const:\n       return DW_FORM_sdata;\n@@ -6660,7 +6600,7 @@ value_format (dw_attr_ref a)\n \tcase 8:\n \t  return DW_FORM_data8;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     case dw_val_class_long_long:\n       return DW_FORM_block1;\n@@ -6683,7 +6623,7 @@ value_format (dw_attr_ref a)\n       return AT_string_form (a);\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -6826,8 +6766,7 @@ output_loc_list (dw_loc_list_ref list_head)\n       size = size_of_locs (curr->expr);\n \n       /* Output the block length for this list of location operations.  */\n-      if (size > 0xffff)\n-\tabort ();\n+      gcc_assert (size <= 0xffff);\n       dw2_asm_output_data (2, size, \"%s\", \"Location expression size\");\n \n       output_loc_sequence (curr->expr);\n@@ -6962,8 +6901,7 @@ output_die (dw_die_ref die)\n \t  {\n \t    char *sym = AT_loc_list (a)->ll_symbol;\n \n-\t    if (sym == 0)\n-\t      abort ();\n+\t    gcc_assert (sym);\n \t    dw2_asm_output_offset (DWARF_OFFSET_SIZE, sym, \"%s\", name);\n \t  }\n \t  break;\n@@ -6973,15 +6911,15 @@ output_die (dw_die_ref die)\n \t    {\n \t      char *sym = AT_ref (a)->die_symbol;\n \n-\t      if (sym == 0)\n-\t\tabort ();\n+\t      gcc_assert (sym);\n \t      dw2_asm_output_offset (DWARF2_ADDR_SIZE, sym, \"%s\", name);\n \t    }\n-\t  else if (AT_ref (a)->die_offset == 0)\n-\t    abort ();\n \t  else\n-\t    dw2_asm_output_data (DWARF_OFFSET_SIZE, AT_ref (a)->die_offset,\n-\t\t\t\t \"%s\", name);\n+\t    {\n+\t      gcc_assert (AT_ref (a)->die_offset);\n+\t      dw2_asm_output_data (DWARF_OFFSET_SIZE, AT_ref (a)->die_offset,\n+\t\t\t\t   \"%s\", name);\n+\t    }\n \t  break;\n \n \tcase dw_val_class_fde_ref:\n@@ -7012,7 +6950,7 @@ output_die (dw_die_ref die)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -7155,8 +7093,7 @@ output_pubnames (void)\n       pubname_ref pub = &pubname_table[i];\n \n       /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n-      if (pub->die->die_mark == 0)\n-\tabort ();\n+      gcc_assert (pub->die->die_mark);\n \n       dw2_asm_output_data (DWARF_OFFSET_SIZE, pub->die->die_offset,\n \t\t\t   \"DIE offset\");\n@@ -7229,8 +7166,7 @@ output_aranges (void)\n       dw_die_ref die = arange_table[i];\n \n       /* We shouldn't see aranges for DIEs outside of the main CU.  */\n-      if (die->die_mark == 0)\n-\tabort ();\n+      gcc_assert (die->die_mark);\n \n       if (die->die_tag == DW_TAG_subprogram)\n \t{\n@@ -7247,12 +7183,10 @@ output_aranges (void)\n \t  dw_attr_ref a = get_AT (die, DW_AT_location);\n \t  dw_loc_descr_ref loc;\n \n-\t  if (! a || AT_class (a) != dw_val_class_loc)\n-\t    abort ();\n+\t  gcc_assert (a && AT_class (a) == dw_val_class_loc);\n \n \t  loc = AT_loc (a);\n-\t  if (loc->dw_loc_opc != DW_OP_addr)\n-\t    abort ();\n+\t  gcc_assert (loc->dw_loc_opc == DW_OP_addr);\n \n \t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE,\n \t\t\t\t   loc->dw_loc_oprnd1.v.val_addr, \"Address\");\n@@ -8007,7 +7941,7 @@ base_type_die (tree type)\n \n     default:\n       /* No other TREE_CODEs are Dwarf fundamental types.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);\n@@ -8085,7 +8019,7 @@ is_base_type (tree type)\n       return 0;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return 0;\n@@ -8323,8 +8257,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t    /* Vectors have the debugging information in the type,\n \t       not the main variant.  */\n \t    mod_type_die = lookup_type_die (type);\n-\t  if (mod_type_die == NULL)\n-\t    abort ();\n+\t  gcc_assert (mod_type_die);\n \t}\n \n       /* We want to equate the qualified type to the die below.  */\n@@ -8365,8 +8298,7 @@ dbx_reg_number (rtx rtl)\n {\n   unsigned regno = REGNO (rtl);\n \n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n \n   return DBX_REGISTER_NUMBER (regno);\n }\n@@ -8438,8 +8370,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n \n   /* Now onto stupid register sets in non contiguous locations.  */\n \n-  if (GET_CODE (regs) != PARALLEL)\n-    abort ();\n+  gcc_assert (GET_CODE (regs) == PARALLEL);\n \n   size = GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0)));\n   loc_result = NULL;\n@@ -8734,7 +8665,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode, bool can_use_fbreg)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return mem_loc_result;\n@@ -8844,7 +8775,7 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return loc_result;\n@@ -9247,7 +9178,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n #ifdef ENABLE_CHECKING\n       /* Otherwise this is a generic code; we should just lists all of\n \t these explicitly.  Aborting means we forgot one.  */\n-      abort ();\n+      gcc_unreachable ();\n #else\n       /* In a release build, we want to degrade gracefully: better to\n \t generate incomplete debugging information than to crash.  */\n@@ -9350,8 +9281,8 @@ field_byte_offset (tree decl)\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n-  else if (TREE_CODE (decl) != FIELD_DECL)\n-    abort ();\n+  \n+  gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n   type = field_type (decl);\n   field_size_tree = DECL_SIZE (decl);\n@@ -9513,8 +9444,7 @@ add_data_member_location_attribute (dw_die_ref die, tree decl)\n \n \t  /* Calculate the address of the offset.  */\n \t  offset = tree_low_cst (BINFO_VPTR_FIELD (decl), 0);\n-\t  if (offset >= 0)\n-\t    abort ();\n+\t  gcc_assert (offset < 0);\n \n \t  tmp = int_loc_descriptor (-offset);\n \t  add_loc_descr (&loc_descr, tmp);\n@@ -9649,8 +9579,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \telse\n \t  {\n \t    /* ??? We really should be using HOST_WIDE_INT throughout.  */\n-\t    if (HOST_BITS_PER_LONG != HOST_BITS_PER_WIDE_INT)\n-\t      abort ();\n+\t    gcc_assert (HOST_BITS_PER_LONG == HOST_BITS_PER_WIDE_INT);\n \n \t    add_AT_long_long (die, DW_AT_const_value,\n \t\t\t      CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n@@ -9667,32 +9596,38 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tunsigned int i;\n \tunsigned char *p;\n \n-\tif (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\tswitch (GET_MODE_CLASS (mode))\n \t  {\n+\t  case MODE_VECTOR_INT:\n \t    for (i = 0, p = array; i < length; i++, p += elt_size)\n \t      {\n \t\trtx elt = CONST_VECTOR_ELT (rtl, i);\n \t\tHOST_WIDE_INT lo, hi;\n-\t\tif (GET_CODE (elt) == CONST_INT)\n+\t\t\n+\t\tswitch (GET_CODE (elt))\n \t\t  {\n+\t\t  case CONST_INT:\n \t\t    lo = INTVAL (elt);\n \t\t    hi = -(lo < 0);\n-\t\t  }\n-\t\telse if (GET_CODE (elt) == CONST_DOUBLE)\n-\t\t  {\n+\t\t    break;\n+\t\t    \n+\t\t  case CONST_DOUBLE:\n \t\t    lo = CONST_DOUBLE_LOW (elt);\n \t\t    hi = CONST_DOUBLE_HIGH (elt);\n+\t\t    break;\n+\t\t    \n+\t\t  default:\n+\t\t    gcc_unreachable ();\n \t\t  }\n-\t\telse\n-\t\t  abort ();\n-\n+\t\t\n \t\tif (elt_size <= sizeof (HOST_WIDE_INT))\n \t\t  insert_int (lo, elt_size, p);\n-\t\telse if (elt_size == 2 * sizeof (HOST_WIDE_INT))\n+\t\telse\n \t\t  {\n \t\t    unsigned char *p0 = p;\n \t\t    unsigned char *p1 = p + sizeof (HOST_WIDE_INT);\n-\n+\t\t    \n+\t\t    gcc_assert (elt_size == 2 * sizeof (HOST_WIDE_INT));\n \t\t    if (WORDS_BIG_ENDIAN)\n \t\t      {\n \t\t\tp0 = p1;\n@@ -9701,20 +9636,20 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t\t    insert_int (lo, sizeof (HOST_WIDE_INT), p0);\n \t\t    insert_int (hi, sizeof (HOST_WIDE_INT), p1);\n \t\t  }\n-\t\telse\n-\t\t  abort ();\n \t      }\n-\t  }\n-\telse if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-\t  {\n+\t    break;\n+\n+\t  case MODE_VECTOR_FLOAT:\n \t    for (i = 0, p = array; i < length; i++, p += elt_size)\n \t      {\n \t\trtx elt = CONST_VECTOR_ELT (rtl, i);\n \t\tinsert_float (elt, p);\n \t      }\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n \t  }\n-\telse\n-\t  abort ();\n \n \tadd_AT_vec (die, DW_AT_const_value, length, elt_size, array);\n       }\n@@ -9747,7 +9682,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \n     default:\n       /* No other kinds of rtx should be possible here.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n }\n@@ -9963,8 +9898,7 @@ rtl_for_decl_location (tree decl)\n \t  rtl = expand_expr (DECL_INITIAL (decl), NULL_RTX, VOIDmode,\n \t\t\t     EXPAND_INITIALIZER);\n \t  /* If expand_expr returns a MEM, it wasn't immediate.  */\n-\t  if (rtl && MEM_P (rtl))\n-\t    abort ();\n+\t  gcc_assert (!rtl || !MEM_P (rtl));\n \t}\n     }\n \n@@ -10001,9 +9935,9 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n-  else if (TREE_CODE (decl) != VAR_DECL && TREE_CODE (decl) != PARM_DECL\n-\t   && TREE_CODE (decl) != RESULT_DECL)\n-    abort ();\n+\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL);\n \n   /* See if we possibly have multiple locations for this variable.  */\n   loc_list = lookup_decl_loc (decl);\n@@ -10344,7 +10278,7 @@ add_byte_size_attribute (dw_die_ref die, tree tree_node)\n       size = simple_type_size_in_bits (field_type (tree_node)) / BITS_PER_UNIT;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Note that `size' might be -1 when we get to this point.  If it is, that\n@@ -10381,9 +10315,7 @@ add_bit_offset_attribute (dw_die_ref die, tree decl)\n   HOST_WIDE_INT unsigned bit_offset;\n \n   /* Must be a field and a bit field.  */\n-  if (!type\n-      || TREE_CODE (decl) != FIELD_DECL)\n-    abort ();\n+  gcc_assert (type && TREE_CODE (decl) == FIELD_DECL);\n \n   /* We can't yet handle bit-fields whose offsets are variable, so if we\n      encounter such things, just return without generating any attribute\n@@ -10423,9 +10355,8 @@ static inline void\n add_bit_size_attribute (dw_die_ref die, tree decl)\n {\n   /* Must be a field and a bit field.  */\n-  if (TREE_CODE (decl) != FIELD_DECL\n-      || ! DECL_BIT_FIELD_TYPE (decl))\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) == FIELD_DECL\n+\t      && DECL_BIT_FIELD_TYPE (decl));\n \n   if (host_integerp (DECL_SIZE (decl), 1))\n     add_AT_unsigned (die, DW_AT_bit_size, tree_low_cst (DECL_SIZE (decl), 1));\n@@ -10474,8 +10405,7 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n   else if (TYPE_P (origin))\n     origin_die = lookup_type_die (origin);\n \n-  if (origin_die == NULL)\n-    abort ();\n+  gcc_assert (origin_die);\n \n   add_AT_die_ref (die, DW_AT_abstract_origin, origin_die);\n }\n@@ -10562,8 +10492,7 @@ push_decl_scope (tree scope)\n static inline void\n pop_decl_scope (void)\n {\n-  if (VARRAY_ACTIVE_SIZE (decl_scope_table) <= 0)\n-    abort ();\n+  gcc_assert (VARRAY_ACTIVE_SIZE (decl_scope_table) > 0);\n \n   VARRAY_POP (decl_scope_table);\n }\n@@ -10582,8 +10511,7 @@ scope_die_for (tree t, dw_die_ref context_die)\n   int i;\n \n   /* Non-types always go in the current scope.  */\n-  if (! TYPE_P (t))\n-    abort ();\n+  gcc_assert (TYPE_P (t));\n \n   containing_scope = TYPE_CONTEXT (t);\n \n@@ -10615,9 +10543,8 @@ scope_die_for (tree t, dw_die_ref context_die)\n \n       if (i < 0)\n \t{\n-\t  if (debug_info_level > DINFO_LEVEL_TERSE\n-\t      && !TREE_ASM_WRITTEN (containing_scope))\n-\t    abort ();\n+\t  gcc_assert (debug_info_level <= DINFO_LEVEL_TERSE\n+\t\t      || TREE_ASM_WRITTEN (containing_scope));\n \n \t  /* If none of the current dies are suitable, we get file scope.  */\n \t  scope_die = comp_unit_die;\n@@ -10744,12 +10671,10 @@ decl_start_label (tree decl)\n   const char *fnname;\n \n   x = DECL_RTL (decl);\n-  if (!MEM_P (x))\n-    abort ();\n+  gcc_assert (MEM_P (x));\n \n   x = XEXP (x, 0);\n-  if (GET_CODE (x) != SYMBOL_REF)\n-    abort ();\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n \n   fnname = XSTR (x, 0);\n   return fnname;\n@@ -11018,7 +10943,7 @@ gen_formal_parameter_die (tree node, dw_die_ref context_die)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return parm_die;\n@@ -11107,8 +11032,7 @@ gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)\n   if (TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))\n       && ! lookup_decl_die (member))\n     {\n-      if (decl_ultimate_origin (member))\n-\tabort ();\n+      gcc_assert (!decl_ultimate_origin (member));\n \n       push_decl_scope (type);\n       if (TREE_CODE (member) == FUNCTION_DECL)\n@@ -11187,14 +11111,12 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n   if (origin && declaration && class_or_namespace_scope_p (context_die))\n     {\n       origin = NULL;\n-      if (old_die)\n-\tabort ();\n+      gcc_assert (!old_die);\n     }\n \n   if (origin != NULL)\n     {\n-      if (declaration && ! local_scope_p (context_die))\n-\tabort ();\n+      gcc_assert (!declaration || local_scope_p (context_die));\n \n       /* Fixup die_parent for the abstract instance of a nested\n \t inline function.  */\n@@ -11220,9 +11142,8 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t     we should detect this case and ignore it.  For now, if we have\n \t     already reported an error, any error at all, then assume that\n \t     we got here because of an input error, not a dwarf2 bug.  */\n-\t  if (errorcount)\n-\t    return;\n-\t  abort ();\n+\t  gcc_assert (errorcount);\n+\t  return;\n \t}\n \n       /* If the definition comes from the same place as the declaration,\n@@ -11563,8 +11484,7 @@ gen_label_die (tree decl, dw_die_ref context_die)\n \t     represent source-level labels which were explicitly declared by\n \t     the user.  This really shouldn't be happening though, so catch\n \t     it if it ever does happen.  */\n-\t  if (INSN_DELETED_P (insn))\n-\t    abort ();\n+\t  gcc_assert (!INSN_DELETED_P (insn));\n \n \t  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (insn));\n \t  add_AT_lbl_id (lbl_die, DW_AT_low_pc, label);\n@@ -12022,10 +11942,8 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n \t{\n \t  type = DECL_ORIGINAL_TYPE (decl);\n \n-\t  if (type == TREE_TYPE (decl))\n-\t    abort ();\n-\t  else\n-\t    equate_type_number_to_die (TREE_TYPE (decl), type_die);\n+\t  gcc_assert (type != TREE_TYPE (decl));\n+\t  equate_type_number_to_die (TREE_TYPE (decl), type_die);\n \t}\n       else\n \ttype = TREE_TYPE (decl);\n@@ -12055,8 +11973,7 @@ gen_type_die (tree type, dw_die_ref context_die)\n \treturn;\n \n       /* Prevent broken recursion; we can't hand off to the same type.  */\n-      if (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) == type)\n-\tabort ();\n+      gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);\n \n       TREE_ASM_WRITTEN (type) = 1;\n       gen_decl_die (TYPE_NAME (type), context_die);\n@@ -12113,7 +12030,8 @@ gen_type_die (tree type, dw_die_ref context_die)\n \n     case FILE_TYPE:\n       gen_type_die (TREE_TYPE (type), context_die);\n-      abort ();\t\t\t/* No way to represent these in Dwarf yet!  */\n+      /* No way to represent these in Dwarf yet!  */\n+      gcc_unreachable ();\n       break;\n \n     case FUNCTION_TYPE:\n@@ -12199,7 +12117,7 @@ gen_type_die (tree type, dw_die_ref context_die)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   TREE_ASM_WRITTEN (type) = 1;\n@@ -12217,8 +12135,7 @@ gen_tagged_type_instantiation_die (tree type, dw_die_ref context_die)\n      this type (i.e. without any const or volatile qualifiers) so make sure\n      that we have the main variant (i.e. the unqualified version) of this\n      type now.  */\n-  if (type != type_main_variant (type))\n-    abort ();\n+  gcc_assert (type == type_main_variant (type));\n \n   /* Do not check TREE_ASM_WRITTEN (type) as it may not be set if this is\n      an instance of an unresolved type.  */\n@@ -12242,7 +12159,7 @@ gen_tagged_type_instantiation_die (tree type, dw_die_ref context_die)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -12453,15 +12370,14 @@ force_decl_die (tree decl)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n   \n       /* See if we can find the die for this deci now.\n \t If not then abort.  */\n       if (!decl_die)\n \tdecl_die = lookup_decl_die (decl);\n-      if (!decl_die)\n-\tabort ();\n+      gcc_assert (decl_die);\n     }\n   \n   return decl_die;\n@@ -12488,8 +12404,7 @@ force_type_die (tree type)\n \n       gen_type_die (type, context_die);\n       type_die = lookup_type_die (type);\n-      if (!type_die)\n-\tabort();\n+      gcc_assert (type_die);\n     }\n   return type_die;\n }\n@@ -12726,10 +12641,9 @@ gen_decl_die (tree decl, dw_die_ref context_die)\n       break;\n \n     default:\n-      if ((int)TREE_CODE (decl) > NUM_TREE_CODES)\n-\t/* Probably some frontend-internal decl.  Assume we don't care.  */\n-\tbreak;\n-      abort ();\n+      /* Probably some frontend-internal decl.  Assume we don't care.  */\n+      gcc_assert ((int)TREE_CODE (decl) > NUM_TREE_CODES);\n+      break;\n     }\n }\n \f\n@@ -12791,8 +12705,7 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n     return;\n \n-  if (!decl)\n-    abort ();\n+  gcc_assert (decl);\n \n   /* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.\n      We need decl DIE for reference and scope die. First, get DIE for the decl \n@@ -13523,8 +13436,8 @@ static void\n prune_unused_types_prune (dw_die_ref die)\n {\n   dw_die_ref c, p, n;\n-  if (!die->die_mark)\n-    abort();\n+  \n+  gcc_assert (die->die_mark);\n \n   p = NULL;\n   for (c = die->die_child; c; c = n)\n@@ -13623,7 +13536,6 @@ dwarf2out_finish (const char *filename)\n       if (die->die_parent == NULL)\n \t{\n \t  dw_die_ref origin = get_AT_ref (die, DW_AT_abstract_origin);\n-\t  tree context;\n \n \t  if (origin)\n \t    add_child_die (origin->die_parent, die);\n@@ -13632,25 +13544,28 @@ dwarf2out_finish (const char *filename)\n \t  else if (errorcount > 0 || sorrycount > 0)\n \t    /* It's OK to be confused by errors in the input.  */\n \t    add_child_die (comp_unit_die, die);\n-\t  else if (node->created_for\n-\t\t   && ((DECL_P (node->created_for)\n-\t\t\t&& (context = DECL_CONTEXT (node->created_for)))\n-\t\t       || (TYPE_P (node->created_for)\n-\t\t\t   && (context = TYPE_CONTEXT (node->created_for))))\n-\t\t   && TREE_CODE (context) == FUNCTION_DECL)\n+\t  else\n \t    {\n \t      /* In certain situations, the lexical block containing a\n \t\t nested function can be optimized away, which results\n \t\t in the nested function die being orphaned.  Likewise\n \t\t with the return type of that nested function.  Force\n \t\t this to be a child of the containing function.  */\n+\t      tree context = NULL_TREE;\n+\n+\t      gcc_assert (node->created_for);\n+\n+\t      if (DECL_P (node->created_for))\n+\t\tcontext = DECL_CONTEXT (node->created_for);\n+\t      else if (TYPE_P (node->created_for))\n+\t\tcontext = TYPE_CONTEXT (node->created_for);\n+\t\t\n+\t      gcc_assert (context && TREE_CODE (context) == FUNCTION_DECL);\n+\t      \n \t      origin = lookup_decl_die (context);\n-\t      if (! origin)\n-\t\tabort ();\n+\t      gcc_assert (origin);\n \t      add_child_die (origin, die);\n \t    }\n-\t  else\n-\t    abort ();\n \t}\n     }\n "}]}