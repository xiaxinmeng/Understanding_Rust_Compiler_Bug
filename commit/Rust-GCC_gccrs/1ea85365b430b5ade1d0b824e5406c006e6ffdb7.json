{"sha": "1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVhODUzNjViNDMwYjVhZGUxZDBiODI0ZTU0MDZjMDA2ZTZmZmRiNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-08-21T10:29:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-08-21T10:29:00Z"}, "message": "re PR go/78628 (GO fails to build a translation unit decl)\n\n2017-08-21  Richard Biener  <rguenther@suse.de>\n\n\tinclude/\n\t* simple-object.h (simple_object_copy_lto_debug_sections): New\n\tfunction.\n\n\tlibiberty/\n\t* simple-object-common.h (struct simple_object_functions): Add\n\tcopy_lto_debug_sections hook.\n\t* simple-object.c: Include fcntl.h.\n\t(handle_lto_debug_sections): New helper function.\n\t(simple_object_copy_lto_debug_sections): New function copying\n\tearly LTO debug sections to regular debug sections in a new file.\n\t(simple_object_start_write): Handle NULL segment_name.\n\t* simple-object-coff.c (simple_object_coff_functions): Adjust\n\tfor not implemented copy_lto_debug_sections hook.\n\t* simple-object-mach-o.c (simple_object_mach_o_functions): Likewise.\n\t* simple-object-xcoff.c (simple_object_xcoff_functions): Likewise.\n\t* simple-object-elf.c (SHT_NULL, SHT_SYMTAB, SHT_RELA, SHT_REL,\n\tSHT_GROUP): Add various sectopn header types.\n\t(SHF_EXCLUDE): Add flag.\n\t(Elf32_External_Sym, Elf64_External_Sym): Add symbol struct.\n\t(ELF_ST_BIND, ELF_ST_TYPE, ELF_ST_INFO): Add accessors.\n\t(STT_OBJECT, STT_FUNC, STT_TLS, STT_GNU_IFUNC): Add Symbol types.\n\t(STV_DEFAULT): Add symbol visibility.\n\t(SHN_COMMON): Add special section index name.\n\t(struct simple_object_elf_write): New.\n\t(simple_object_elf_start_write): Adjust for new private data.\n\t(simple_object_elf_write_shdr): Pass in values for all fields\n\twe write.\n\t(simple_object_elf_write_to_file): Adjust.  Copy from recorded\n\tsection headers if requested.\n\t(simple_object_elf_release_write): Release private data.\n\t(simple_object_elf_copy_lto_debug_sections): Copy and rename sections\n\tas denoted by PFN and all their dependences, symbols and relocations\n\tto the empty destination file.\n\t(simple_object_elf_functions): Adjust for copy_lto_debug_sections hook.\n\n        gcc/\n        * debug.h (struct gcc_debug_hooks): Add die_ref_for_decl and\n        register_external_die hooks.\n        (debug_false_tree_charstarstar_uhwistar): Declare.\n        (debug_nothing_tree_charstar_uhwi): Likewise.\n        * debug.c (do_nothing_debug_hooks): Adjust.\n        (debug_false_tree_charstarstar_uhwistar): New do nothing.\n        (debug_nothing_tree_charstar_uhwi): Likewise.\n        * dbxout.c (dbx_debug_hooks): Adjust.\n        (xcoff_debug_hooks): Likewise.\n        * sdbout.c (sdb_debug_hooks): Likewise.\n        * vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n        * dwarf2out.c (macinfo_label_base): New global.\n\t(dwarf2out_register_external_die): New function for the\n\tregister_external_die hook.\n        (dwarf2out_die_ref_for_decl): Likewise for die_ref_for_decl.\n        (dwarf2_debug_hooks): Use them.\n        (dwarf2_lineno_debug_hooks): Adjust.\n        (struct die_struct): Add with_offset flag.\n        (DEBUG_LTO_DWO_INFO_SECTION, DEBUG_LTO_INFO_SECTION,\n        DEBUG_LTO_DWO_ABBREV_SECTION, DEBUG_LTO_ABBREV_SECTION,\n        DEBUG_LTO_DWO_MACINFO_SECTION, DEBUG_LTO_MACINFO_SECTION,\n        DEBUG_LTO_DWO_MACRO_SECTION, DEBUG_LTO_MACRO_SECTION,\n        DEBUG_LTO_LINE_SECTION, DEBUG_LTO_DWO_STR_OFFSETS_SECTION,\n        DEBUG_LTO_STR_DWO_SECTION, DEBUG_STR_LTO_SECTION): New macros\n        defining section names for the early LTO debug variants.\n\t(reset_indirect_string): New helper.\n        (add_AT_external_die_ref): Helper for dwarf2out_register_external_die.\n        (print_dw_val): Add support for offsetted symbol references.\n\t(get_ultimate_context): Split out from is_cxx.\n\t(is_cxx): Use get_ultimate_context.\n\t(is_fortran): Add decl overload.\n        (compute_comp_unit_symbol): Split out worker from\n\tcompute_section_prefix.\n        (compute_section_prefix): Call compute_comp_unit_symbol and\n\tset comdat_type_p here.\n        (output_die): Skip DIE symbol output for the LTO added one.\n        Handle DIE symbol references with offset.\n        (output_comp_unit): Guard section name mangling properly.\n        For LTO debug sections emit a symbol at the section beginning\n        which we use to refer to its DIEs.\n        (add_abstract_origin_attribute): For DIEs registered via\n        dwarf2out_register_external_die directly refer to the early\n        DIE rather than indirectly through the shadow one we created.\n\tRemove obsolete call to dwarf2out_abstract_function for\n\tnon-function/block origins.\n        (gen_array_type_die): When generating early LTO debug do\n        not emit DW_AT_string_length.\n        (gen_formal_parameter_die): Do not re-create DIEs for PARM_DECLs\n        late when in LTO.  As suggested place a gcc_unreachable for\n\tthe DECL_ABSTRACT_P case.\n        (gen_subprogram_die): Avoid another specification DIE\n        for early built declarations/definitions for the late LTO case.\n        (gen_variable_die): Add type references for late duplicated VLA dies\n        when in late LTO.\n        (gen_inlined_subroutine_die): Do not call dwarf2out_abstract_function,\n        we have the abstract instance already.\n        (process_scope_var): Adjust decl DIE contexts in LTO which\n        first puts them in limbo.\n        (gen_decl_die): Do not generate type DIEs late apart from\n        types for VLAs or for decls we do not yet have a DIE.  Do not\n\tcall dwarf2out_abstract_function late.\n        (dwarf2out_early_global_decl): Make sure to create DIEs\n        for abstract instances of a decl first.\n        (dwarf2out_late_global_decl): Adjust comment.\n        (output_macinfo_op): With multiple macro sections use\n\tmacinfo_label_base to distinguish labels.\n        (output_macinfo): Likewise.  Update macinfo_label_base.\n\tPass in the line info label.\n\t(note_variable_value_in_expr): When generating LTO resolve\n\tall variable values here by generating DIEs as needed.\n        (init_sections_and_labels): Add early LTO debug flag parameter\n        and generate different sections and names if set.  Add generation\n        counter for the labels so we can have multiple of them.\n        (reset_dies): Helper to allow DIEs to be output multiple times.\n        (dwarf2out_finish): When outputting DIEs to the fat part of an\n\tLTO object first reset DIEs.\n        (dwarf2out_early_finish): Output early DIEs when generating LTO.\n\t(modified_type_die): Check for decl_ultimate_origin being self\n\tbefore recursing.\n\t(gen_type_die_with_usage): Likewise.\n\t(gen_typedef_die): Allow decl_ultimate_origin being self.\n        (set_decl_abstract_flags): Remove.\n        (set_block_abstract_flags): Likewise.\n        (dwarf2out_abstract_function): Treat the early generated DIEs\n        as the abstract copy and only add DW_AT_inline and\n        DW_AT_artificial here and call set_decl_origin_self.\n\tIf the DIE has an abstract origin don't do anything.\n\t* tree.c (free_lang_data): Build a dummy TRANSLATION_UNIT_DECL\n\tif we have none yet (Go fails to build one, PR78628).\n\t(variably_modified_type_p): Prevent endless recursion for Ada\n\tcyclic pointer types.\n        * lto-streamer-in.c: Include debug.h.\n        (dref_queue): New global.\n        (lto_read_tree_1): Stream in DIE references.\n        (lto_input_tree): Register DIE references.\n\t(input_function): Stream DECL_DEBUG_ARGS.\n        * lto-streamer-out.c: Include debug.h.\n        (lto_write_tree_1): Output DIE references.\n        (DFS::DFS_write_tree_body): Follow DECL_ABSTRACT_ORIGIN.\n\tForce a TRANSLATION_UNIT_DECL DECL_CONTEXT for file-scope decls.\n\t(output_function): Stream DECL_DEBUG_ARGS.\n        * tree-streamer-in.c (lto_input_ts_decl_common_tree_pointers):\n        Stream DECL_ABSTRACT_ORIGIN.\n        * tree-streamer-out.c (write_ts_decl_common_tree_pointers): Likewise.\n\t(write_ts_decl_minimal_tree_pointers): Force a TRANSLATION_UNIT_DECL\n\tDECL_CONTEXT for file-scope decls.\n        * lto-streamer.h (struct dref_entry): Declare.\n        (dref_queue): Likewise.\n\t* cfgexpand.c (pass_expand::execute): Do not call the\n\toutlining_inline_function hook here.\n        * lto-wrapper.c (debug_obj): New global.\n        (tool_cleanup): Unlink it if required.\n        (debug_objcopy): New function.\n        (run_gcc): Handle early debug sections in the IL files by\n        extracting them to separate files, partially linkin them and\n        feeding the result back as result to the linker.\n\n        * config/darwin.h (DEBUG_LTO_INFO_SECTION, DEBUG_LTO_ABBREV_SECTION,\n        DEBUG_LTO_MACINFO_SECTION, DEBUG_LTO_LINE_SECTION,\n        DEBUG_STR_LTO_SECTION, DEBUG_LTO_MACRO_SECTION): Put early debug\n        sections into a separate segment.\n        * config/darwin.c (darwin_asm_named_section): Handle __GNU_DWARF_LTO\n        segments.\n        (darwin_asm_dwarf_section): Likewise.\n        (darwin_asm_output_dwarf_offset): Likewise.\n\n\t* config/i386/i386.c (make_resolver_func): Set DECL_IGNORED_P.\n\n        lto/\n        * lto.c (unify_scc): Truncate DIE reference queue for dropped SCCs.\n        (lto_read_decls): Process TRANSLATION_UNIT_DECLs.  Remove\n        TYPE_DECL debug processing, register DIE references from\n        prevailing SCCs with the debug machinery.\n        (lto_section_with_id): Handle LTO debug sections.\n\n\tlibstdc++/\n\t* testsuite/libstdc++-prettyprinters/prettyprinters.exp: Run all\n\ttests with -flto as well if supported.\n\n        testsuite/\n\t* c-c++-common/asan/global-overflow-1.c: Adjust diagnostic location\n\tregex to handle the LTO case.\n\t* c-c++-common/asan/heap-overflow-1.c: Likewise.\n\t* c-c++-common/asan/misalign-1.c: Likewise.\n\t* c-c++-common/asan/misalign-2.c: Likewise.\n\t* c-c++-common/asan/null-deref-1.c: Likewise.\n\t* c-c++-common/asan/stack-overflow-1.c: Likewise.\n\t* c-c++-common/asan/strncpy-overflow-1.c: Likewise.\n\t* c-c++-common/asan/use-after-free-1.c: Likewise.\n\t* c-c++-common/asan/alloca_big_alignment.c: Likewise.\n\t* c-c++-common/asan/alloca_detect_custom_size.c: Likewise.\n\t* c-c++-common/asan/alloca_overflow_partial.c: Likewise.\n\t* c-c++-common/asan/alloca_overflow_right.c: Likewise.\n\t* c-c++-common/asan/alloca_underflow_left.c: Likewise.\n\t* g++.dg/asan/large-func-test-1.C: Likewise.\n\t* gfortran.dg/save_6.f90: Add -flto -g variant of save_5.f90.\n\nFrom-SVN: r251220", "tree": {"sha": "3f66db94dd051305b43f1de3bf2077e236deb8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f66db94dd051305b43f1de3bf2077e236deb8a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f33a5d9acbed950bf446849e9d6968cf22cb9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f33a5d9acbed950bf446849e9d6968cf22cb9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f33a5d9acbed950bf446849e9d6968cf22cb9a2"}], "stats": {"total": 2510, "additions": 2106, "deletions": 404}, "files": [{"sha": "3c3e9ffb3a200d447feb28df535973bf090c878f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,131 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+        * debug.h (struct gcc_debug_hooks): Add die_ref_for_decl and\n+        register_external_die hooks.\n+        (debug_false_tree_charstarstar_uhwistar): Declare.\n+        (debug_nothing_tree_charstar_uhwi): Likewise.\n+        * debug.c (do_nothing_debug_hooks): Adjust.\n+        (debug_false_tree_charstarstar_uhwistar): New do nothing.\n+        (debug_nothing_tree_charstar_uhwi): Likewise.\n+        * dbxout.c (dbx_debug_hooks): Adjust.\n+        (xcoff_debug_hooks): Likewise.\n+        * sdbout.c (sdb_debug_hooks): Likewise.\n+        * vmsdbgout.c (vmsdbg_debug_hooks): Likewise.\n+        * dwarf2out.c (macinfo_label_base): New global.\n+\t(dwarf2out_register_external_die): New function for the\n+\tregister_external_die hook.\n+        (dwarf2out_die_ref_for_decl): Likewise for die_ref_for_decl.\n+        (dwarf2_debug_hooks): Use them.\n+        (dwarf2_lineno_debug_hooks): Adjust.\n+        (struct die_struct): Add with_offset flag.\n+        (DEBUG_LTO_DWO_INFO_SECTION, DEBUG_LTO_INFO_SECTION,\n+        DEBUG_LTO_DWO_ABBREV_SECTION, DEBUG_LTO_ABBREV_SECTION,\n+        DEBUG_LTO_DWO_MACINFO_SECTION, DEBUG_LTO_MACINFO_SECTION,\n+        DEBUG_LTO_DWO_MACRO_SECTION, DEBUG_LTO_MACRO_SECTION,\n+        DEBUG_LTO_LINE_SECTION, DEBUG_LTO_DWO_STR_OFFSETS_SECTION,\n+        DEBUG_LTO_STR_DWO_SECTION, DEBUG_STR_LTO_SECTION): New macros\n+        defining section names for the early LTO debug variants.\n+\t(reset_indirect_string): New helper.\n+        (add_AT_external_die_ref): Helper for dwarf2out_register_external_die.\n+        (print_dw_val): Add support for offsetted symbol references.\n+\t(get_ultimate_context): Split out from is_cxx.\n+\t(is_cxx): Use get_ultimate_context.\n+\t(is_fortran): Add decl overload.\n+        (compute_comp_unit_symbol): Split out worker from\n+\tcompute_section_prefix.\n+        (compute_section_prefix): Call compute_comp_unit_symbol and\n+\tset comdat_type_p here.\n+        (output_die): Skip DIE symbol output for the LTO added one.\n+        Handle DIE symbol references with offset.\n+        (output_comp_unit): Guard section name mangling properly.\n+        For LTO debug sections emit a symbol at the section beginning\n+        which we use to refer to its DIEs.\n+        (add_abstract_origin_attribute): For DIEs registered via\n+        dwarf2out_register_external_die directly refer to the early\n+        DIE rather than indirectly through the shadow one we created.\n+\tRemove obsolete call to dwarf2out_abstract_function for\n+\tnon-function/block origins.\n+        (gen_array_type_die): When generating early LTO debug do\n+        not emit DW_AT_string_length.\n+        (gen_formal_parameter_die): Do not re-create DIEs for PARM_DECLs\n+        late when in LTO.  As suggested place a gcc_unreachable for\n+\tthe DECL_ABSTRACT_P case.\n+        (gen_subprogram_die): Avoid another specification DIE\n+        for early built declarations/definitions for the late LTO case.\n+        (gen_variable_die): Add type references for late duplicated VLA dies\n+        when in late LTO.\n+        (gen_inlined_subroutine_die): Do not call dwarf2out_abstract_function,\n+        we have the abstract instance already.\n+        (process_scope_var): Adjust decl DIE contexts in LTO which\n+        first puts them in limbo.\n+        (gen_decl_die): Do not generate type DIEs late apart from\n+        types for VLAs or for decls we do not yet have a DIE.  Do not\n+\tcall dwarf2out_abstract_function late.\n+        (dwarf2out_early_global_decl): Make sure to create DIEs\n+        for abstract instances of a decl first.\n+        (dwarf2out_late_global_decl): Adjust comment.\n+        (output_macinfo_op): With multiple macro sections use\n+\tmacinfo_label_base to distinguish labels.\n+        (output_macinfo): Likewise.  Update macinfo_label_base.\n+\tPass in the line info label.\n+\t(note_variable_value_in_expr): When generating LTO resolve\n+\tall variable values here by generating DIEs as needed.\n+        (init_sections_and_labels): Add early LTO debug flag parameter\n+        and generate different sections and names if set.  Add generation\n+        counter for the labels so we can have multiple of them.\n+        (reset_dies): Helper to allow DIEs to be output multiple times.\n+        (dwarf2out_finish): When outputting DIEs to the fat part of an\n+\tLTO object first reset DIEs.\n+        (dwarf2out_early_finish): Output early DIEs when generating LTO.\n+\t(modified_type_die): Check for decl_ultimate_origin being self\n+\tbefore recursing.\n+\t(gen_type_die_with_usage): Likewise.\n+\t(gen_typedef_die): Allow decl_ultimate_origin being self.\n+        (set_decl_abstract_flags): Remove.\n+        (set_block_abstract_flags): Likewise.\n+        (dwarf2out_abstract_function): Treat the early generated DIEs\n+        as the abstract copy and only add DW_AT_inline and\n+        DW_AT_artificial here and call set_decl_origin_self.\n+\tIf the DIE has an abstract origin don't do anything.\n+\t* tree.c (free_lang_data): Build a dummy TRANSLATION_UNIT_DECL\n+\tif we have none yet (Go fails to build one, PR78628).\n+\t(variably_modified_type_p): Prevent endless recursion for Ada\n+\tcyclic pointer types.\n+        * lto-streamer-in.c: Include debug.h.\n+        (dref_queue): New global.\n+        (lto_read_tree_1): Stream in DIE references.\n+        (lto_input_tree): Register DIE references.\n+\t(input_function): Stream DECL_DEBUG_ARGS.\n+        * lto-streamer-out.c: Include debug.h.\n+        (lto_write_tree_1): Output DIE references.\n+        (DFS::DFS_write_tree_body): Follow DECL_ABSTRACT_ORIGIN.\n+\tForce a TRANSLATION_UNIT_DECL DECL_CONTEXT for file-scope decls.\n+\t(output_function): Stream DECL_DEBUG_ARGS.\n+        * tree-streamer-in.c (lto_input_ts_decl_common_tree_pointers):\n+        Stream DECL_ABSTRACT_ORIGIN.\n+        * tree-streamer-out.c (write_ts_decl_common_tree_pointers): Likewise.\n+\t(write_ts_decl_minimal_tree_pointers): Force a TRANSLATION_UNIT_DECL\n+\tDECL_CONTEXT for file-scope decls.\n+        * lto-streamer.h (struct dref_entry): Declare.\n+        (dref_queue): Likewise.\n+\t* cfgexpand.c (pass_expand::execute): Do not call the\n+\toutlining_inline_function hook here.\n+        * lto-wrapper.c (debug_obj): New global.\n+        (tool_cleanup): Unlink it if required.\n+        (debug_objcopy): New function.\n+        (run_gcc): Handle early debug sections in the IL files by\n+        extracting them to separate files, partially linkin them and\n+        feeding the result back as result to the linker.\n+        * config/darwin.h (DEBUG_LTO_INFO_SECTION, DEBUG_LTO_ABBREV_SECTION,\n+        DEBUG_LTO_MACINFO_SECTION, DEBUG_LTO_LINE_SECTION,\n+        DEBUG_STR_LTO_SECTION, DEBUG_LTO_MACRO_SECTION): Put early debug\n+        sections into a separate segment.\n+        * config/darwin.c (darwin_asm_named_section): Handle __GNU_DWARF_LTO\n+        segments.\n+        (darwin_asm_dwarf_section): Likewise.\n+        (darwin_asm_output_dwarf_offset): Likewise.\n+\t* config/i386/i386.c (make_resolver_func): Set DECL_IGNORED_P.\n+\n 2017-08-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "573f0c751adfc941d078249138c803e0c97d7e33", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -6529,12 +6529,6 @@ pass_expand::execute (function *fun)\n \t  TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n     }\n \n-  /* We are now committed to emitting code for this function.  Do any\n-     preparation, such as emitting abstract debug info for the inline\n-     before it gets mangled by optimization.  */\n-  if (cgraph_function_possibly_inlined_p (current_function_decl))\n-    (*debug_hooks->outlining_inline_function) (current_function_decl);\n-\n   TREE_ASM_WRITTEN (current_function_decl) = 1;\n \n   /* After expanding, the return labels are no longer needed. */"}, {"sha": "b6dad70df0ab5a2a54e32cb69907b3d9ebcf4d4e", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1960,7 +1960,8 @@ darwin_asm_lto_end (void)\n }\n \n static void\n-darwin_asm_dwarf_section (const char *name, unsigned int flags, tree decl);\n+darwin_asm_dwarf_section (const char *name, unsigned int flags,\n+\t\t\t  tree decl, bool is_for_lto);\n \n /*  Called for the TARGET_ASM_NAMED_SECTION hook.  */\n \n@@ -2002,7 +2003,9 @@ darwin_asm_named_section (const char *name,\n       vec_safe_push (lto_section_names, e);\n    }\n   else if (strncmp (name, \"__DWARF,\", 8) == 0)\n-    darwin_asm_dwarf_section (name, flags, decl);\n+    darwin_asm_dwarf_section (name, flags, decl, false);\n+  else if (strncmp (name, \"__GNU_DWARF_LTO,\", 16) == 0)\n+    darwin_asm_dwarf_section (name, flags, decl, true);\n   else\n     fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n }\n@@ -2784,19 +2787,37 @@ static GTY (()) vec<dwarf_sect_used_entry, va_gc> *dwarf_sect_names_table;\n \n static void\n darwin_asm_dwarf_section (const char *name, unsigned int flags,\n-\t\t\t  tree ARG_UNUSED (decl))\n+\t\t\t  tree ARG_UNUSED (decl), bool is_for_lto)\n {\n   unsigned i;\n-  int namelen;\n-  const char * sname;\n+  int namelen, extra = 0;\n+  const char *sect, *lto_add = \"\";\n+  char sname[64];\n   dwarf_sect_used_entry *ref;\n   bool found = false;\n-  gcc_assert ((flags & (SECTION_DEBUG | SECTION_NAMED))\n-\t\t    == (SECTION_DEBUG | SECTION_NAMED));\n-  /* We know that the name starts with __DWARF,  */\n-  sname = name + 8;\n-  namelen = strchr (sname, ',') - sname;\n-  gcc_assert (namelen);\n+\n+  gcc_checking_assert ((flags & (SECTION_DEBUG | SECTION_NAMED))\n+\t\t\t== (SECTION_DEBUG | SECTION_NAMED));\n+\n+  /* We know that the name starts with __DWARF, or __GNU_DAWRF_LTO  */\n+  sect = strchr (name, ',') + 1;\n+  namelen = strchr (sect, ',') - sect;\n+  gcc_checking_assert (namelen);\n+\n+  /* The section switch is output as written...  */\n+  fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n+\n+  /* ... but the string we keep to make section start labels needs\n+     adjustment for lto cases.  */\n+  if (is_for_lto)\n+    {\n+      lto_add = \"_lto\";\n+      extra = 4;\n+    }\n+\n+  snprintf (sname, 64, \"%.*s%.*s\", namelen, sect, extra, lto_add);\n+  namelen += extra;\n+\n   if (dwarf_sect_names_table == NULL)\n     vec_alloc (dwarf_sect_names_table, 16);\n   else\n@@ -2814,7 +2835,6 @@ darwin_asm_dwarf_section (const char *name, unsigned int flags,\n \t  }\n       }\n \n-  fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n   if (!found)\n     {\n       dwarf_sect_used_entry e;\n@@ -2867,14 +2887,24 @@ darwin_asm_output_dwarf_offset (FILE *file, int size, const char * lab,\n \t\t\t\tHOST_WIDE_INT offset, section *base)\n {\n   char sname[64];\n-  int namelen;\n+  int namelen, extra = 0;\n+  bool is_for_lto;\n+  const char *lto_add = \"\";\n \n-  gcc_assert (base->common.flags & SECTION_NAMED);\n-  gcc_assert (strncmp (base->named.name, \"__DWARF,\", 8) == 0);\n-  gcc_assert (strchr (base->named.name + 8, ','));\n+  gcc_checking_assert (base->common.flags & SECTION_NAMED);\n+  is_for_lto = strncmp (base->named.name, \"__GNU_DWARF_LTO,\", 16) == 0;\n+  gcc_checking_assert (is_for_lto\n+\t\t       || strncmp (base->named.name, \"__DWARF,\", 8) == 0);\n+  const char *name = strchr (base->named.name, ',') + 1;\n+  gcc_checking_assert (name);\n \n-  namelen = strchr (base->named.name + 8, ',') - (base->named.name + 8);\n-  sprintf (sname, \"*Lsection%.*s\", namelen, base->named.name + 8);\n+  namelen = strchr (name, ',') - (name);\n+  if (is_for_lto)\n+    {\n+      lto_add = \"_lto\";\n+      extra = 4;\n+    }\n+  snprintf (sname, 64, \"*Lsection%.*s%.*s\", namelen, name, extra, lto_add);\n   darwin_asm_output_dwarf_delta (file, size, lab, sname, offset);\n }\n "}, {"sha": "6cec8deb8cdb0661c99e4ce251ba83f9818689a4", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -445,7 +445,14 @@ extern GTY(()) int darwin_ms_struct;\n #define DEBUG_PUBTYPES_SECTION\t\"__DWARF,__debug_pubtypes,regular,debug\"\n #define DEBUG_STR_SECTION\t\"__DWARF,__debug_str,regular,debug\"\n #define DEBUG_RANGES_SECTION\t\"__DWARF,__debug_ranges,regular,debug\"\n-#define DEBUG_MACRO_SECTION    \"__DWARF,__debug_macro,regular,debug\"\n+#define DEBUG_MACRO_SECTION     \"__DWARF,__debug_macro,regular,debug\"\n+\n+#define DEBUG_LTO_INFO_SECTION\t  \"__GNU_DWARF_LTO,__debug_info,regular,debug\"\n+#define DEBUG_LTO_ABBREV_SECTION  \"__GNU_DWARF_LTO,__debug_abbrev,regular,debug\"\n+#define DEBUG_LTO_MACINFO_SECTION \"__GNU_DWARF_LTO,__debug_macinfo,regular,debug\"\n+#define DEBUG_LTO_LINE_SECTION\t  \"__GNU_DWARF_LTO,__debug_line,regular,debug\"\n+#define DEBUG_LTO_STR_SECTION\t  \"__GNU_DWARF_LTO,__debug_str,regular,debug\"\n+#define DEBUG_LTO_MACRO_SECTION   \"__GNU_DWARF_LTO,__debug_macro,regular,debug\"\n \n #define TARGET_WANT_DEBUG_PUB_SECTIONS true\n "}, {"sha": "e67f6412acdcb58c126b7e6451942e832d23baca", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -33984,7 +33984,7 @@ make_resolver_func (const tree default_decl,\n   DECL_NAME (decl) = decl_name;\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IGNORED_P (decl) = 0;\n+  DECL_IGNORED_P (decl) = 1;\n   TREE_PUBLIC (decl) = 0;\n   DECL_UNINLINABLE (decl) = 1;\n "}, {"sha": "ea7c97ccb31852e1a997187ff39a61db8ef867e3", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -372,6 +372,8 @@ const struct gcc_debug_hooks dbx_debug_hooks =\n   dbxout_late_global_decl,\t\t /* late_global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx_code_label,\t         /* label */\n@@ -412,6 +414,8 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n   dbxout_late_global_decl,\t\t /* late_global_decl */\n   dbxout_type_decl,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx_code_label,\t         /* label */"}, {"sha": "4db94c3e675d29e7d8c97c8397e4c0dcd7c49a84", "filename": "gcc/debug.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -48,6 +48,8 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n   debug_nothing_tree,\t         \t /* late_global_decl */\n   debug_nothing_tree_int,\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx_code_label,\t         /* label */\n@@ -147,3 +149,16 @@ debug_nothing_tree_int (tree decl ATTRIBUTE_UNUSED,\n \t\t\tint local ATTRIBUTE_UNUSED)\n {\n }\n+\n+bool\n+debug_false_tree_charstarstar_uhwistar (tree, const char **,\n+\t\t\t\t\tunsigned HOST_WIDE_INT *)\n+{\n+  return false;\n+}\n+\n+void\n+debug_nothing_tree_charstar_uhwi (tree, const char *,\n+\t\t\t\t  unsigned HOST_WIDE_INT)\n+{\n+}"}, {"sha": "915420baded59dec8cd83f0ecb4a95486769e6ef", "filename": "gcc/debug.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -148,6 +148,14 @@ struct gcc_debug_hooks\n \t\t\t\t    tree context, bool child,\n \t\t\t\t    bool implicit);\n \n+  /* Return true if a DIE for the tree is available and return a symbol\n+     and offset that can be used to refer to it externally.  */\n+  bool (* die_ref_for_decl) (tree, const char **, unsigned HOST_WIDE_INT *);\n+\n+  /* Early debug information for the tree is available at symbol plus\n+     offset externally.  */\n+  void (* register_external_die) (tree, const char *, unsigned HOST_WIDE_INT);\n+\n   /* DECL is an inline function, whose body is present, but which is\n      not being output at this point.  */\n   void (* deferred_inline_function) (tree decl);\n@@ -212,6 +220,10 @@ extern void debug_nothing_tree_tree_tree_bool_bool (tree, tree, tree,\n extern bool debug_true_const_tree (const_tree);\n extern void debug_nothing_rtx_insn (rtx_insn *);\n extern void debug_nothing_rtx_code_label (rtx_code_label *);\n+extern bool debug_false_tree_charstarstar_uhwistar (tree, const char **,\n+\t\t\t\t\t\t    unsigned HOST_WIDE_INT *);\n+extern void debug_nothing_tree_charstar_uhwi (tree, const char *,\n+\t\t\t\t\t      unsigned HOST_WIDE_INT);\n \n /* Hooks for various debug formats.  */\n extern const struct gcc_debug_hooks do_nothing_debug_hooks;"}, {"sha": "764fd36bc8260e47e2f8e755dfaf69da667a9ec7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 865, "deletions": 308, "changes": 1173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -164,6 +164,7 @@ static GTY(()) section *debug_aranges_section;\n static GTY(()) section *debug_addr_section;\n static GTY(()) section *debug_macinfo_section;\n static const char *debug_macinfo_section_name;\n+static unsigned macinfo_label_base = 1;\n static GTY(()) section *debug_line_section;\n static GTY(()) section *debug_skeleton_line_section;\n static GTY(()) section *debug_loc_section;\n@@ -2692,6 +2693,10 @@ static void dwarf2out_begin_function (tree);\n static void dwarf2out_end_function (unsigned int);\n static void dwarf2out_register_main_translation_unit (tree unit);\n static void dwarf2out_set_name (tree, tree);\n+static void dwarf2out_register_external_die (tree decl, const char *sym,\n+\t\t\t\t\t     unsigned HOST_WIDE_INT off);\n+static bool dwarf2out_die_ref_for_decl (tree decl, const char **sym,\n+\t\t\t\t\tunsigned HOST_WIDE_INT *off);\n \n /* The debug hooks structure.  */\n \n@@ -2726,6 +2731,8 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =\n   dwarf2out_late_global_decl,\n   dwarf2out_type_decl,\t\t/* type_decl */\n   dwarf2out_imported_module_or_decl,\n+  dwarf2out_die_ref_for_decl,\n+  dwarf2out_register_external_die,\n   debug_nothing_tree,\t\t/* deferred_inline_function */\n   /* The DWARF 2 backend tries to reduce debugging bloat by not\n      emitting the abstract description of inline functions until\n@@ -2767,6 +2774,8 @@ const struct gcc_debug_hooks dwarf2_lineno_debug_hooks =\n   debug_nothing_tree,\t\t         /* late_global_decl */\n   debug_nothing_tree_int,\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   debug_nothing_rtx_code_label,\t         /* label */\n@@ -2895,6 +2904,9 @@ typedef struct GTY((chain_circular (\"%h.die_sib\"), for_user)) die_struct {\n   /* Die is used and must not be pruned as unused.  */\n   BOOL_BITFIELD die_perennial_p : 1;\n   BOOL_BITFIELD comdat_type_p : 1; /* DIE has a type signature */\n+  /* For an external ref to die_symbol if die_offset contains an extra\n+     offset to that symbol.  */\n+  BOOL_BITFIELD with_offset : 1;\n   /* Whether this DIE was removed from the DIE tree, for example via\n      prune_unused_types.  We don't consider those present from the\n      DIE lookup routines.  */\n@@ -3698,12 +3710,24 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_DWO_INFO_SECTION\n #define DEBUG_DWO_INFO_SECTION \".debug_info.dwo\"\n #endif\n+#ifndef DEBUG_LTO_DWO_INFO_SECTION\n+#define DEBUG_LTO_DWO_INFO_SECTION \".gnu.debuglto_.debug_info.dwo\"\n+#endif\n+#ifndef DEBUG_LTO_INFO_SECTION\n+#define DEBUG_LTO_INFO_SECTION\t\".gnu.debuglto_.debug_info\"\n+#endif\n #ifndef DEBUG_ABBREV_SECTION\n #define DEBUG_ABBREV_SECTION\t\".debug_abbrev\"\n #endif\n #ifndef DEBUG_DWO_ABBREV_SECTION\n #define DEBUG_DWO_ABBREV_SECTION \".debug_abbrev.dwo\"\n #endif\n+#ifndef DEBUG_LTO_DWO_ABBREV_SECTION\n+#define DEBUG_LTO_DWO_ABBREV_SECTION \".gnu.debuglto_.debug_abbrev.dwo\"\n+#endif\n+#ifndef DEBUG_LTO_ABBREV_SECTION\n+#define DEBUG_LTO_ABBREV_SECTION \".gnu.debuglto_.debug_abbrev\"\n+#endif\n #ifndef DEBUG_ARANGES_SECTION\n #define DEBUG_ARANGES_SECTION\t\".debug_aranges\"\n #endif\n@@ -3716,18 +3740,33 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_DWO_MACINFO_SECTION\n #define DEBUG_DWO_MACINFO_SECTION      \".debug_macinfo.dwo\"\n #endif\n+#ifndef DEBUG_LTO_DWO_MACINFO_SECTION\n+#define DEBUG_LTO_DWO_MACINFO_SECTION  \".gnu.debuglto_.debug_macinfo.dwo\"\n+#endif\n+#ifndef DEBUG_LTO_MACINFO_SECTION\n+#define DEBUG_LTO_MACINFO_SECTION      \".gnu.debuglto_.debug_macinfo\"\n+#endif\n #ifndef DEBUG_DWO_MACRO_SECTION\n #define DEBUG_DWO_MACRO_SECTION        \".debug_macro.dwo\"\n #endif\n #ifndef DEBUG_MACRO_SECTION\n #define DEBUG_MACRO_SECTION\t\".debug_macro\"\n #endif\n+#ifndef DEBUG_LTO_DWO_MACRO_SECTION\n+#define DEBUG_LTO_DWO_MACRO_SECTION    \".gnu.debuglto_.debug_macro.dwo\"\n+#endif\n+#ifndef DEBUG_LTO_MACRO_SECTION\n+#define DEBUG_LTO_MACRO_SECTION \".gnu.debuglto_.debug_macro\"\n+#endif\n #ifndef DEBUG_LINE_SECTION\n #define DEBUG_LINE_SECTION\t\".debug_line\"\n #endif\n #ifndef DEBUG_DWO_LINE_SECTION\n #define DEBUG_DWO_LINE_SECTION \".debug_line.dwo\"\n #endif\n+#ifndef DEBUG_LTO_LINE_SECTION\n+#define DEBUG_LTO_LINE_SECTION \".gnu.debuglto_.debug_line.dwo\"\n+#endif\n #ifndef DEBUG_LOC_SECTION\n #define DEBUG_LOC_SECTION\t\".debug_loc\"\n #endif\n@@ -3756,12 +3795,21 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #ifndef DEBUG_DWO_STR_OFFSETS_SECTION\n #define DEBUG_DWO_STR_OFFSETS_SECTION \".debug_str_offsets.dwo\"\n #endif\n+#ifndef DEBUG_LTO_DWO_STR_OFFSETS_SECTION\n+#define DEBUG_LTO_DWO_STR_OFFSETS_SECTION \".gnu.debuglto_.debug_str_offsets.dwo\"\n+#endif\n #ifndef DEBUG_STR_DWO_SECTION\n #define DEBUG_STR_DWO_SECTION   \".debug_str.dwo\"\n #endif\n+#ifndef DEBUG_LTO_STR_DWO_SECTION\n+#define DEBUG_LTO_STR_DWO_SECTION \".gnu.debuglto_.debug_str.dwo\"\n+#endif\n #ifndef DEBUG_STR_SECTION\n #define DEBUG_STR_SECTION  \".debug_str\"\n #endif\n+#ifndef DEBUG_LTO_STR_SECTION\n+#define DEBUG_LTO_STR_SECTION \".gnu.debuglto_.debug_str\"\n+#endif\n #ifndef DEBUG_RANGES_SECTION\n #define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n #endif\n@@ -3786,6 +3834,10 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n /* Section flags for .debug_str.dwo section.  */\n #define DEBUG_STR_DWO_SECTION_FLAGS (SECTION_DEBUG | SECTION_EXCLUDE)\n \n+/* Attribute used to refer to the macro section.  */\n+#define DEBUG_MACRO_ATTRIBUTE (dwarf_version >= 5 ? DW_AT_macros \\\n+\t\t   : dwarf_strict ? DW_AT_macro_info : DW_AT_GNU_macros)\n+\n /* Labels we insert at beginning sections we can reference instead of\n    the section names themselves.  */\n \n@@ -4374,6 +4426,24 @@ set_indirect_string (struct indirect_string_node *node)\n     }\n }\n \n+/* A helper function for dwarf2out_finish, called to reset indirect\n+   string decisions done for early LTO dwarf output before fat object\n+   dwarf output.  */\n+\n+int\n+reset_indirect_string (indirect_string_node **h, void *)\n+{\n+  struct indirect_string_node *node = *h;\n+  if (node->form == DW_FORM_strp || node->form == DW_FORM_GNU_str_index)\n+    {\n+      free (node->label);\n+      node->label = NULL;\n+      node->form = (dwarf_form) 0;\n+      node->index = 0;\n+    }\n+  return 1;\n+}\n+\n /* Find out whether a string should be output inline in DIE\n    or out-of-line in .debug_str section.  */\n \n@@ -5019,6 +5089,21 @@ get_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind)\n   return a ? AT_file (a) : NULL;\n }\n \n+/* Returns the ultimate TRANSLATION_UNIT_DECL context of DECL or NULL.  */\n+\n+static const_tree\n+get_ultimate_context (const_tree decl)\n+{\n+  while (decl && TREE_CODE (decl) != TRANSLATION_UNIT_DECL)\n+    {\n+      if (TREE_CODE (decl) == BLOCK)\n+\tdecl = BLOCK_SUPERCONTEXT (decl);\n+      else\n+\tdecl = get_containing_scope (decl);\n+    }\n+  return decl;\n+}\n+\n /* Return TRUE if the language is C++.  */\n \n static inline bool\n@@ -5037,14 +5122,7 @@ is_cxx (const_tree decl)\n {\n   if (in_lto_p)\n     {\n-      const_tree context = decl;\n-      while (context && TREE_CODE (context) != TRANSLATION_UNIT_DECL)\n-\t{\n-\t  if (TREE_CODE (context) == BLOCK)\n-\t    context = BLOCK_SUPERCONTEXT (context);\n-\t  else\n-\t    context = get_containing_scope (context);\n-\t}\n+      const_tree context = get_ultimate_context (decl);\n       if (context && TRANSLATION_UNIT_LANGUAGE (context))\n \treturn strncmp (TRANSLATION_UNIT_LANGUAGE (context), \"GNU C++\", 7) == 0;\n     }\n@@ -5065,6 +5143,21 @@ is_fortran (void)\n \t  || lang == DW_LANG_Fortran08);\n }\n \n+static inline bool\n+is_fortran (const_tree decl)\n+{\n+  if (in_lto_p)\n+    {\n+      const_tree context = get_ultimate_context (decl);\n+      if (context && TRANSLATION_UNIT_LANGUAGE (context))\n+\treturn (strncmp (TRANSLATION_UNIT_LANGUAGE (context),\n+\t\t\t \"GNU Fortran\", 11) == 0\n+\t\t|| strcmp (TRANSLATION_UNIT_LANGUAGE (context),\n+\t\t\t   \"GNU F77\") == 0);\n+    }\n+  return is_fortran ();\n+}\n+\n /* Return TRUE if the language is Ada.  */\n \n static inline bool\n@@ -5409,6 +5502,184 @@ lookup_decl_die (tree decl)\n   return *die;\n }\n \n+\n+/* For DECL which might have early dwarf output query a SYMBOL + OFFSET\n+   style reference.  Return true if we found one refering to a DIE for\n+   DECL, otherwise return false.  */\n+\n+static bool\n+dwarf2out_die_ref_for_decl (tree decl, const char **sym,\n+\t\t\t    unsigned HOST_WIDE_INT *off)\n+{\n+  dw_die_ref die;\n+\n+  if (flag_wpa && !decl_die_table)\n+    return false;\n+\n+  if (TREE_CODE (decl) == BLOCK)\n+    die = BLOCK_DIE (decl);\n+  else\n+    die = lookup_decl_die (decl);\n+  if (!die)\n+    return false;\n+\n+  /* During WPA stage we currently use DIEs to store the\n+     decl <-> label + offset map.  That's quite inefficient but it\n+     works for now.  */\n+  if (flag_wpa)\n+    {\n+      dw_die_ref ref = get_AT_ref (die, DW_AT_abstract_origin);\n+      if (!ref)\n+\t{\n+\t  gcc_assert (die == comp_unit_die ());\n+\t  return false;\n+\t}\n+      *off = ref->die_offset;\n+      *sym = ref->die_id.die_symbol;\n+      return true;\n+    }\n+\n+  /* Similar to get_ref_die_offset_label, but using the \"correct\"\n+     label.  */\n+  *off = die->die_offset;\n+  while (die->die_parent)\n+    die = die->die_parent;\n+  /* For the containing CU DIE we compute a die_symbol in\n+     compute_section_prefix.  */\n+  gcc_assert (die->die_tag == DW_TAG_compile_unit\n+\t      && die->die_id.die_symbol != NULL);\n+  *sym = die->die_id.die_symbol;\n+  return true;\n+}\n+\n+/* Add a reference of kind ATTR_KIND to a DIE at SYMBOL + OFFSET to DIE.  */\n+\n+static void\n+add_AT_external_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind,\n+\t\t\t const char *symbol, HOST_WIDE_INT offset)\n+{\n+  /* Create a fake DIE that contains the reference.  Don't use\n+     new_die because we don't want to end up in the limbo list.  */\n+  dw_die_ref ref = ggc_cleared_alloc<die_node> ();\n+  ref->die_tag = die->die_tag;\n+  ref->die_id.die_symbol = IDENTIFIER_POINTER (get_identifier (symbol));\n+  ref->die_offset = offset;\n+  ref->with_offset = 1;\n+  add_AT_die_ref (die, attr_kind, ref);\n+}\n+\n+/* Create a DIE for DECL if required and add a reference to a DIE\n+   at SYMBOL + OFFSET which contains attributes dumped early.  */\n+\n+static void\n+dwarf2out_register_external_die (tree decl, const char *sym,\n+\t\t\t\t unsigned HOST_WIDE_INT off)\n+{\n+  if (debug_info_level == DINFO_LEVEL_NONE)\n+    return;\n+\n+  if (flag_wpa && !decl_die_table)\n+    decl_die_table = hash_table<decl_die_hasher>::create_ggc (1000);\n+\n+  dw_die_ref die\n+    = TREE_CODE (decl) == BLOCK ? BLOCK_DIE (decl) : lookup_decl_die (decl);\n+  gcc_assert (!die);\n+\n+  tree ctx;\n+  dw_die_ref parent = NULL;\n+  /* Need to lookup a DIE for the decls context - the containing\n+     function or translation unit.  */\n+  if (TREE_CODE (decl) == BLOCK)\n+    {\n+      ctx = BLOCK_SUPERCONTEXT (decl);\n+      /* ???  We do not output DIEs for all scopes thus skip as\n+\t many DIEs as needed.  */\n+      while (TREE_CODE (ctx) == BLOCK\n+\t     && !BLOCK_DIE (ctx))\n+\tctx = BLOCK_SUPERCONTEXT (ctx);\n+    }\n+  else\n+    ctx = DECL_CONTEXT (decl);\n+  while (ctx && TYPE_P (ctx))\n+    ctx = TYPE_CONTEXT (ctx);\n+  if (ctx)\n+    {\n+      if (TREE_CODE (ctx) == BLOCK)\n+\tparent = BLOCK_DIE (ctx);\n+      else if (TREE_CODE (ctx) == TRANSLATION_UNIT_DECL\n+\t       /* Keep the 1:1 association during WPA.  */\n+\t       && !flag_wpa)\n+\t/* Otherwise all late annotations go to the main CU which\n+\t   imports the original CUs.  */\n+\tparent = comp_unit_die ();\n+      else if (TREE_CODE (ctx) == FUNCTION_DECL\n+\t       && TREE_CODE (decl) != PARM_DECL\n+\t       && TREE_CODE (decl) != BLOCK)\n+\t/* Leave function local entities parent determination to when\n+\t   we process scope vars.  */\n+\t;\n+      else\n+\tparent = lookup_decl_die (ctx);\n+    }\n+  else\n+    /* In some cases the FEs fail to set DECL_CONTEXT properly.\n+       Handle this case gracefully by globalizing stuff.  */\n+    parent = comp_unit_die ();\n+  /* Create a DIE \"stub\".  */\n+  switch (TREE_CODE (decl))\n+    {\n+    case TRANSLATION_UNIT_DECL:\n+      if (! flag_wpa)\n+\t{\n+\t  die = comp_unit_die ();\n+\t  dw_die_ref import = new_die (DW_TAG_imported_unit, die, NULL_TREE);\n+\t  add_AT_external_die_ref (import, DW_AT_import, sym, off);\n+\t  /* We re-target all CU decls to the LTRANS CU DIE, so no need\n+\t     to create a DIE for the original CUs.  */\n+\t  return;\n+\t}\n+      /* Keep the 1:1 association during WPA.  */\n+      die = new_die (DW_TAG_compile_unit, NULL, decl);\n+      break;\n+    case NAMESPACE_DECL:\n+      if (is_fortran (decl))\n+\tdie = new_die (DW_TAG_module, parent, decl);\n+      else\n+\tdie = new_die (DW_TAG_namespace, parent, decl);\n+      break;\n+    case FUNCTION_DECL:\n+      die = new_die (DW_TAG_subprogram, parent, decl);\n+      break;\n+    case VAR_DECL:\n+      die = new_die (DW_TAG_variable, parent, decl);\n+      break;\n+    case RESULT_DECL:\n+      die = new_die (DW_TAG_variable, parent, decl);\n+      break;\n+    case PARM_DECL:\n+      die = new_die (DW_TAG_formal_parameter, parent, decl);\n+      break;\n+    case CONST_DECL:\n+      die = new_die (DW_TAG_constant, parent, decl);\n+      break;\n+    case LABEL_DECL:\n+      die = new_die (DW_TAG_label, parent, decl);\n+      break;\n+    case BLOCK:\n+      die = new_die (DW_TAG_lexical_block, parent, decl);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (TREE_CODE (decl) == BLOCK)\n+    BLOCK_DIE (decl) = die;\n+  else\n+    equate_decl_number_to_die (decl, die);\n+\n+  /* Add a reference to the DIE providing early debug at $sym + off.  */\n+  add_AT_external_die_ref (die, DW_AT_abstract_origin, sym, off);\n+}\n+\n /* Returns a hash value for X (which really is a var_loc_list).  */\n \n inline hashval_t\n@@ -5896,7 +6167,11 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n \t\t\t       die->die_id.die_type_node->signature);\n \t    }\n \t  else if (die->die_id.die_symbol)\n-\t    fprintf (outfile, \"die -> label: %s\", die->die_id.die_symbol);\n+\t    {\n+\t      fprintf (outfile, \"die -> label: %s\", die->die_id.die_symbol);\n+\t      if (die->with_offset)\n+\t\tfprintf (outfile, \" + %ld\", die->die_offset);\n+\t    }\n \t  else\n \t    fprintf (outfile, \"die -> %ld\", die->die_offset);\n \t  fprintf (outfile, \" (%p)\", (void *) die);\n@@ -7209,10 +7484,10 @@ static const char *comdat_symbol_id;\n static unsigned int comdat_symbol_number;\n \n /* Calculate the MD5 checksum of the compilation unit DIE UNIT_DIE and its\n-   children, and set comdat_symbol_id accordingly.  */\n+   children, and set die_symbol.  */\n \n static void\n-compute_section_prefix (dw_die_ref unit_die)\n+compute_comp_unit_symbol (dw_die_ref unit_die)\n {\n   const char *die_name = get_AT_string (unit_die, DW_AT_name);\n   const char *base = die_name ? lbasename (die_name) : \"anonymous\";\n@@ -7231,7 +7506,11 @@ compute_section_prefix (dw_die_ref unit_die)\n   unmark_all_dies (unit_die);\n   md5_finish_ctx (&ctx, checksum);\n \n-  sprintf (name, \"%s.\", base);\n+  /* When we this for comp_unit_die () we have a DW_AT_name that might\n+     not start with a letter but with anything valid for filenames and\n+     clean_symbol_name doesn't fix that up.  Prepend 'g' if the first\n+     character is not a letter.  */\n+  sprintf (name, \"%s%s.\", ISALPHA (*base) ? \"\" : \"g\", base);\n   clean_symbol_name (name);\n \n   p = name + strlen (name);\n@@ -7241,7 +7520,15 @@ compute_section_prefix (dw_die_ref unit_die)\n       p += 2;\n     }\n \n-  comdat_symbol_id = unit_die->die_id.die_symbol = xstrdup (name);\n+  unit_die->die_id.die_symbol = xstrdup (name);\n+}\n+\n+static void\n+compute_section_prefix (dw_die_ref unit_die)\n+{\n+  compute_comp_unit_symbol (unit_die);\n+  unit_die->comdat_type_p = true;\n+  comdat_symbol_id = unit_die->die_id.die_symbol;\n   comdat_symbol_number = 0;\n }\n \n@@ -9967,7 +10254,11 @@ output_die (dw_die_ref die)\n \n   /* If someone in another CU might refer to us, set up a symbol for\n      them to point to.  */\n-  if (! die->comdat_type_p && die->die_id.die_symbol)\n+  if (! die->comdat_type_p && die->die_id.die_symbol\n+      /* Don't output the symbol twice.  For LTO we want the label\n+         on the section beginning, not on the actual DIE.  */\n+      && (!flag_generate_lto\n+\t  || die->die_tag != DW_TAG_compile_unit))\n     output_die_symbol (die);\n \n   dw2_asm_output_data_uleb128 (die->die_abbrev, \"(DIE (%#lx) %s)\",\n@@ -10160,8 +10451,20 @@ output_die (dw_die_ref die)\n \t\t    size = DWARF2_ADDR_SIZE;\n \t\t  else\n \t\t    size = DWARF_OFFSET_SIZE;\n-\t\t  dw2_asm_output_offset (size, sym, debug_info_section, \"%s\",\n-\t\t\t\t\t name);\n+\t\t  /* ???  We cannot unconditionally output die_offset if\n+\t\t     non-zero - at least -feliminate-dwarf2-dups will\n+\t\t     create references to those DIEs via symbols.  And we\n+\t\t     do not clear its DIE offset after outputting it\n+\t\t     (and the label refers to the actual DIEs, not the\n+\t\t     DWARF CU unit header which is when using label + offset\n+\t\t     would be the correct thing to do).\n+\t\t     ???  This is the reason for the with_offset flag.  */\n+\t\t  if (AT_ref (a)->with_offset)\n+\t\t    dw2_asm_output_offset (size, sym, AT_ref (a)->die_offset,\n+\t\t\t\t\t   debug_info_section, \"%s\", name);\n+\t\t  else\n+\t\t    dw2_asm_output_offset (size, sym, debug_info_section, \"%s\",\n+\t\t\t\t\t   name);\n \t\t}\n \t    }\n \t  else\n@@ -10387,7 +10690,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty,\n   calc_die_sizes (die);\n \n   oldsym = die->die_id.die_symbol;\n-  if (oldsym)\n+  if (oldsym && die->comdat_type_p)\n     {\n       tmp = XALLOCAVEC (char, strlen (oldsym) + 24);\n \n@@ -10403,6 +10706,29 @@ output_comp_unit (dw_die_ref die, int output_if_empty,\n       info_section_emitted = true;\n     }\n \n+  /* For LTO cross unit DIE refs we want a symbol on the start of the\n+     debuginfo section, not on the CU DIE.  */\n+  if (flag_generate_lto && oldsym)\n+    {\n+      /* ???  No way to get visibility assembled without a decl.  */\n+      tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t      get_identifier (oldsym), char_type_node);\n+      TREE_PUBLIC (decl) = true;\n+      TREE_STATIC (decl) = true;\n+      DECL_ARTIFICIAL (decl) = true;\n+      DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n+      DECL_VISIBILITY_SPECIFIED (decl) = true;\n+      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);\n+#ifdef ASM_WEAKEN_LABEL\n+      /* We prefer a .weak because that handles duplicates from duplicate\n+         archive members in a graceful way.  */\n+      ASM_WEAKEN_LABEL (asm_out_file, oldsym);\n+#else\n+      targetm.asm_out.globalize_label (asm_out_file, oldsym);\n+#endif\n+      ASM_OUTPUT_LABEL (asm_out_file, oldsym);\n+    }\n+\n   /* Output debugging information.  */\n   output_compilation_unit_header (dwo_id\n \t\t\t\t  ? DW_UT_split_compile : DW_UT_compile);\n@@ -12511,7 +12837,7 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \t  /* Typedef variants that have an abstract origin don't get their own\n \t     type DIE (see gen_typedef_die), so fall back on the ultimate\n \t     abstract origin instead.  */\n-\t  if (origin != NULL)\n+\t  if (origin != NULL && origin != name)\n \t    return modified_type_die (TREE_TYPE (origin), cv_quals, reverse,\n \t\t\t\t      context_die);\n \n@@ -14528,6 +14854,9 @@ parameter_ref_descriptor (rtx rtl)\n   if (dwarf_strict)\n     return NULL;\n   gcc_assert (TREE_CODE (DEBUG_PARAMETER_REF_DECL (rtl)) == PARM_DECL);\n+  /* With LTO during LTRANS we get the late DIE that refers to the early\n+     DIE, thus we add another indirection here.  This seems to confuse\n+     gdb enough to make gcc.dg/guality/pr68860-1.c FAIL with LTO.  */\n   ref = lookup_decl_die (DEBUG_PARAMETER_REF_DECL (rtl));\n   ret = new_loc_descr (DW_OP_GNU_parameter_ref, 0, 0);\n   if (ref)\n@@ -20199,27 +20528,19 @@ add_abstract_origin_attribute (dw_die_ref die, tree origin)\n {\n   dw_die_ref origin_die = NULL;\n \n-  if (TREE_CODE (origin) != FUNCTION_DECL\n-      && TREE_CODE (origin) != BLOCK)\n+  if (DECL_P (origin))\n     {\n-      /* We may have gotten separated from the block for the inlined\n-\t function, if we're in an exception handler or some such; make\n-\t sure that the abstract function has been written out.\n-\n-\t Doing this for nested functions is wrong, however; functions are\n-\t distinct units, and our context might not even be inline.  */\n-      tree fn = origin;\n-\n-      if (TYPE_P (fn))\n-\tfn = TYPE_STUB_DECL (fn);\n-\n-      fn = decl_function_context (fn);\n-      if (fn)\n-\tdwarf2out_abstract_function (fn);\n+      dw_die_ref c;\n+      origin_die = lookup_decl_die (origin);\n+      /* \"Unwrap\" the decls DIE which we put in the imported unit context.\n+         We are looking for the abstract copy here.  */\n+      if (in_lto_p\n+\t  && origin_die\n+\t  && (c = get_AT_ref (origin_die, DW_AT_abstract_origin))\n+\t  /* ???  Identify this better.  */\n+\t  && c->with_offset)\n+\torigin_die = c;\n     }\n-\n-  if (DECL_P (origin))\n-    origin_die = lookup_decl_die (origin);\n   else if (TYPE_P (origin))\n     origin_die = lookup_type_die (origin);\n   else if (TREE_CODE (origin) == BLOCK)\n@@ -20778,7 +21099,10 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n       size = int_size_in_bytes (type);\n       if (size >= 0)\n \tadd_AT_unsigned (array_die, DW_AT_byte_size, size);\n-      else if (TYPE_DOMAIN (type) != NULL_TREE\n+      /* ???  We can't annotate types late, but for LTO we may not\n+\t generate a location early either (gfortran.dg/save_6.f90).  */\n+      else if (! (early_dwarf && flag_generate_lto)\n+\t       && TYPE_DOMAIN (type) != NULL_TREE\n \t       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE)\n \t{\n \t  tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n@@ -21188,8 +21512,11 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n       parm_die = lookup_decl_die (node);\n \n       /* If the contexts differ, we may not be talking about the same\n-\t thing.  */\n-      if (parm_die && parm_die->die_parent != context_die)\n+\t thing.\n+\t ???  When in LTO the DIE parent is the \"abstract\" copy and the\n+\t context_die is the specification \"copy\".  But this whole block\n+\t should eventually be no longer needed.  */\n+      if (parm_die && parm_die->die_parent != context_die && !in_lto_p)\n \t{\n \t  if (!DECL_ABSTRACT_P (node))\n \t    {\n@@ -21199,18 +21526,7 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n \t      parm_die = NULL;\n \t    }\n \t  else\n-\t    {\n-\t      /* FIXME: Reuse DIE even with a differing context.\n-\n-\t\t This can happen when calling\n-\t\t dwarf2out_abstract_function to build debug info for\n-\t\t the abstract instance of a function for which we have\n-\t\t already generated a DIE in\n-\t\t dwarf2out_early_global_decl.\n-\n-\t         Once we remove dwarf2out_abstract_function, we should\n-\t         have a call to gcc_unreachable here.  */\n-\t    }\n+\t    gcc_unreachable ();\n \t}\n \n       if (parm_die && parm_die->die_parent == NULL)\n@@ -21465,7 +21781,6 @@ gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)\n /* Forward declare these functions, because they are mutually recursive\n   with their set_block_* pairing functions.  */\n static void set_decl_origin_self (tree);\n-static void set_decl_abstract_flags (tree, vec<tree> &);\n \n /* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so\n@@ -21538,151 +21853,48 @@ set_decl_origin_self (tree decl)\n     }\n }\n \f\n-/* Given a pointer to some BLOCK node, set the BLOCK_ABSTRACT flag to 1\n-   and if it wasn't 1 before, push it to abstract_vec vector.\n-   For all local decls and all local sub-blocks (recursively) do it\n-   too.  */\n-\n-static void\n-set_block_abstract_flags (tree stmt, vec<tree> &abstract_vec)\n-{\n-  tree local_decl;\n-  tree subblock;\n-  unsigned int i;\n-\n-  if (!BLOCK_ABSTRACT (stmt))\n-    {\n-      abstract_vec.safe_push (stmt);\n-      BLOCK_ABSTRACT (stmt) = 1;\n-    }\n-\n-  for (local_decl = BLOCK_VARS (stmt);\n-       local_decl != NULL_TREE;\n-       local_decl = DECL_CHAIN (local_decl))\n-    if (! DECL_EXTERNAL (local_decl))\n-      set_decl_abstract_flags (local_decl, abstract_vec);\n-\n-  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n-    {\n-      local_decl = BLOCK_NONLOCALIZED_VAR (stmt, i);\n-      if ((VAR_P (local_decl) && !TREE_STATIC (local_decl))\n-\t  || TREE_CODE (local_decl) == PARM_DECL)\n-\tset_decl_abstract_flags (local_decl, abstract_vec);\n-    }\n-\n-  for (subblock = BLOCK_SUBBLOCKS (stmt);\n-       subblock != NULL_TREE;\n-       subblock = BLOCK_CHAIN (subblock))\n-    set_block_abstract_flags (subblock, abstract_vec);\n-}\n-\n-/* Given a pointer to some ..._DECL node, set DECL_ABSTRACT_P flag on it\n-   to 1 and if it wasn't 1 before, push to abstract_vec vector.\n-   In the case where the decl is a FUNCTION_DECL also set the abstract\n-   flags for all of the parameters, local vars, local\n-   blocks and sub-blocks (recursively).  */\n-\n-static void\n-set_decl_abstract_flags (tree decl, vec<tree> &abstract_vec)\n-{\n-  if (!DECL_ABSTRACT_P (decl))\n-    {\n-      abstract_vec.safe_push (decl);\n-      DECL_ABSTRACT_P (decl) = 1;\n-    }\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      tree arg;\n-\n-      for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n-\tif (!DECL_ABSTRACT_P (arg))\n-\t  {\n-\t    abstract_vec.safe_push (arg);\n-\t    DECL_ABSTRACT_P (arg) = 1;\n-\t  }\n-      if (DECL_INITIAL (decl) != NULL_TREE\n-\t  && DECL_INITIAL (decl) != error_mark_node)\n-\tset_block_abstract_flags (DECL_INITIAL (decl), abstract_vec);\n-    }\n-}\n-\n-/* Generate the DWARF2 info for the \"abstract\" instance of a function which we\n-   may later generate inlined and/or out-of-line instances of.\n-\n-   FIXME: In the early-dwarf world, this function, and most of the\n-          DECL_ABSTRACT code should be obsoleted.  The early DIE _is_\n-          the abstract instance.  All we would need to do is annotate\n-          the early DIE with the appropriate DW_AT_inline in late\n-          dwarf (perhaps in gen_inlined_subroutine_die).\n-\n-\t  However, we can't do this yet, because LTO streaming of DIEs\n-\t  has not been implemented yet.  */\n+/* Mark the early DIE for DECL as the abstract instance.  */\n \n static void\n dwarf2out_abstract_function (tree decl)\n {\n   dw_die_ref old_die;\n-  tree save_fn;\n-  tree context;\n-  hash_table<decl_loc_hasher> *old_decl_loc_table;\n-  hash_table<dw_loc_list_hasher> *old_cached_dw_loc_list_table;\n-  int old_call_site_count, old_tail_call_site_count;\n-  struct call_arg_loc_node *old_call_arg_locations;\n \n   /* Make sure we have the actual abstract inline, not a clone.  */\n   decl = DECL_ORIGIN (decl);\n \n+  if (DECL_IGNORED_P (decl))\n+    return;\n+\n   old_die = lookup_decl_die (decl);\n-  if (old_die && get_AT (old_die, DW_AT_inline))\n+  /* With early debug we always have an old DIE.  */\n+  gcc_assert (old_die != NULL);\n+  if (get_AT (old_die, DW_AT_inline)\n+      || get_AT (old_die, DW_AT_abstract_origin))\n     /* We've already generated the abstract instance.  */\n     return;\n \n-  /* We can be called while recursively when seeing block defining inlined subroutine\n-     DIE.  Be sure to not clobber the outer location table nor use it or we would\n-     get locations in abstract instantces.  */\n-  old_decl_loc_table = decl_loc_table;\n-  decl_loc_table = NULL;\n-  old_cached_dw_loc_list_table = cached_dw_loc_list_table;\n-  cached_dw_loc_list_table = NULL;\n-  old_call_arg_locations = call_arg_locations;\n-  call_arg_locations = NULL;\n-  old_call_site_count = call_site_count;\n-  call_site_count = -1;\n-  old_tail_call_site_count = tail_call_site_count;\n-  tail_call_site_count = -1;\n-\n-  /* Be sure we've emitted the in-class declaration DIE (if any) first, so\n-     we don't get confused by DECL_ABSTRACT_P.  */\n-  if (debug_info_level > DINFO_LEVEL_TERSE)\n+  /* Go ahead and put DW_AT_inline on the DIE.  */\n+  if (DECL_DECLARED_INLINE_P (decl))\n+    {\n+      if (cgraph_function_possibly_inlined_p (decl))\n+\tadd_AT_unsigned (old_die, DW_AT_inline, DW_INL_declared_inlined);\n+      else\n+\tadd_AT_unsigned (old_die, DW_AT_inline, DW_INL_declared_not_inlined);\n+    }\n+  else\n     {\n-      context = decl_class_context (decl);\n-      if (context)\n-\tgen_type_die_for_member\n-\t  (context, decl, decl_function_context (decl) ? NULL : comp_unit_die ());\n+      if (cgraph_function_possibly_inlined_p (decl))\n+\tadd_AT_unsigned (old_die, DW_AT_inline, DW_INL_inlined);\n+      else\n+\tadd_AT_unsigned (old_die, DW_AT_inline, DW_INL_not_inlined);\n     }\n \n-  /* Pretend we've just finished compiling this function.  */\n-  save_fn = current_function_decl;\n-  current_function_decl = decl;\n+  if (DECL_DECLARED_INLINE_P (decl)\n+      && lookup_attribute (\"artificial\", DECL_ATTRIBUTES (decl)))\n+    add_AT_flag (old_die, DW_AT_artificial, 1);\n \n-  auto_vec<tree, 64> abstract_vec;\n-  set_decl_abstract_flags (decl, abstract_vec);\n-  dwarf2out_decl (decl);\n-  unsigned int i;\n-  tree t;\n-  FOR_EACH_VEC_ELT (abstract_vec, i, t)\n-    if (TREE_CODE (t) == BLOCK)\n-      BLOCK_ABSTRACT (t) = 0;\n-    else\n-      DECL_ABSTRACT_P (t) = 0;\n-\n-  current_function_decl = save_fn;\n-  decl_loc_table = old_decl_loc_table;\n-  cached_dw_loc_list_table = old_cached_dw_loc_list_table;\n-  call_arg_locations = old_call_arg_locations;\n-  call_site_count = old_call_site_count;\n-  tail_call_site_count = old_tail_call_site_count;\n+  set_decl_origin_self (decl);\n }\n \n /* Helper function of premark_used_types() which gets called through\n@@ -21894,7 +22106,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       && debug_info_level > DINFO_LEVEL_TERSE)\n     old_die = force_decl_die (decl);\n \n-  /* An inlined instance, tag a new DIE with DW_AT_abstract_origin.  */\n+  /* A concrete instance, tag a new DIE with DW_AT_abstract_origin.  */\n   if (origin != NULL)\n     {\n       gcc_assert (!declaration || local_scope_p (context_die));\n@@ -21973,6 +22185,10 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t       && old_die->die_parent->die_tag == DW_TAG_module)\n \t   || context_die == NULL)\n \t   && (DECL_ARTIFICIAL (decl)\n+\t       /* The location attributes may be in the abstract origin\n+\t\t  which in the case of LTO might be not available to\n+\t\t  look at.  */\n+\t       || get_AT (old_die, DW_AT_abstract_origin)\n \t       || (get_AT_file (old_die, DW_AT_decl_file) == file_index\n \t\t   && (get_AT_unsigned (old_die, DW_AT_decl_line)\n \t\t       == (unsigned) s.line)\n@@ -22839,6 +23055,24 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t  /* If a DIE was dumped early, it still needs location info.\n \t     Skip to where we fill the location bits.  */\n \t  var_die = old_die;\n+\n+\t  /* ???  In LTRANS we cannot annotate early created variably\n+\t     modified type DIEs without copying them and adjusting all\n+\t     references to them.  Thus we dumped them again, also add a\n+\t     reference to them.  */\n+\t  tree type = TREE_TYPE (decl_or_origin);\n+\t  if (in_lto_p\n+\t      && variably_modified_type_p\n+\t\t   (type, decl_function_context (decl_or_origin)))\n+\t    {\n+\t      if (decl_by_reference_p (decl_or_origin))\n+\t\tadd_type_attribute (var_die, TREE_TYPE (type),\n+\t\t\t\t    TYPE_UNQUALIFIED, false, context_die);\n+\t      else\n+\t\tadd_type_attribute (var_die, type, decl_quals (decl_or_origin),\n+\t\t\t\t    false, context_die);\n+\t    }\n+\n \t  goto gen_variable_die_location;\n \t}\n     }\n@@ -23239,12 +23473,6 @@ gen_inlined_subroutine_die (tree stmt, dw_die_ref context_die)\n   gcc_checking_assert (DECL_ABSTRACT_P (decl)\n \t\t       || cgraph_function_possibly_inlined_p (decl));\n \n-  /* Emit info for the abstract instance first, if we haven't yet.  We\n-     must emit this even if the block is abstract, otherwise when we\n-     emit the block below (or elsewhere), we may end up trying to emit\n-     a die whose origin die hasn't been emitted, and crashing.  */\n-  dwarf2out_abstract_function (decl);\n-\n   if (! BLOCK_ABSTRACT (stmt))\n     {\n       dw_die_ref subr_die\n@@ -24317,7 +24545,8 @@ gen_typedef_die (tree decl, dw_die_ref context_die)\n   /* As we avoid creating DIEs for local typedefs (see decl_ultimate_origin\n      checks in process_scope_var and modified_type_die), this should be called\n      only for original types.  */\n-  gcc_assert (decl_ultimate_origin (decl) == NULL);\n+  gcc_assert (decl_ultimate_origin (decl) == NULL\n+\t      || decl_ultimate_origin (decl) == decl);\n \n   TREE_ASM_WRITTEN (decl) = 1;\n   type_die = new_die (DW_TAG_typedef, context_die, decl);\n@@ -24492,7 +24721,7 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n \n       tree name = TYPE_NAME (type);\n       tree origin = decl_ultimate_origin (name);\n-      if (origin != NULL)\n+      if (origin != NULL && origin != name)\n \t{\n \t  gen_decl_die (origin, NULL, NULL, context_die);\n \t  return;\n@@ -24850,7 +25079,22 @@ process_scope_var (tree stmt, tree decl, tree origin, dw_die_ref context_die)\n \t\t\t\t\t     stmt, context_die);\n     }\n   else\n-    gen_decl_die (decl, origin, NULL, context_die);\n+    {\n+      if (decl && DECL_P (decl))\n+\t{\n+\t  die = lookup_decl_die (decl);\n+\n+\t  /* Early created DIEs do not have a parent as the decls refer\n+\t     to the function as DECL_CONTEXT rather than the BLOCK.  */\n+\t  if (die && die->die_parent == NULL)\n+\t    {\n+\t      gcc_assert (in_lto_p);\n+\t      add_child_die (context_die, die);\n+\t    }\n+\t}\n+\n+      gen_decl_die (decl, origin, NULL, context_die);\n+    }\n }\n \n /* Generate all of the decls declared within a given scope and (recursively)\n@@ -25261,25 +25505,27 @@ gen_decl_die (tree decl, tree origin, struct vlr_context *ctx,\n \t/* This is only a declaration.  */;\n #endif\n \n+      /* We should have abstract copies already and should not generate\n+\t stray type DIEs in late LTO dumping.  */\n+      if (! early_dwarf)\n+\t;\n+\n       /* If we're emitting a clone, emit info for the abstract instance.  */\n-      if (origin || DECL_ORIGIN (decl) != decl)\n+      else if (origin || DECL_ORIGIN (decl) != decl)\n \tdwarf2out_abstract_function (origin\n \t\t\t\t     ? DECL_ORIGIN (origin)\n \t\t\t\t     : DECL_ABSTRACT_ORIGIN (decl));\n \n-      /* If we're emitting an out-of-line copy of an inline function,\n-\t emit info for the abstract instance and set up to refer to it.  */\n+      /* If we're emitting a possibly inlined function emit it as\n+         abstract instance.  */\n       else if (cgraph_function_possibly_inlined_p (decl)\n \t       && ! DECL_ABSTRACT_P (decl)\n \t       && ! class_or_namespace_scope_p (context_die)\n \t       /* dwarf2out_abstract_function won't emit a die if this is just\n \t\t  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in\n \t\t  that case, because that works only if we have a die.  */\n \t       && DECL_INITIAL (decl) != NULL_TREE)\n-\t{\n-\t  dwarf2out_abstract_function (decl);\n-\t  set_decl_origin_self (decl);\n-\t}\n+\tdwarf2out_abstract_function (decl);\n \n       /* Otherwise we're emitting the primary DIE for this decl.  */\n       else if (debug_info_level > DINFO_LEVEL_TERSE)\n@@ -25349,20 +25595,36 @@ gen_decl_die (tree decl, tree origin, struct vlr_context *ctx,\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n-      /* Output any DIEs that are needed to specify the type of this data\n-\t object.  */\n-      if (decl_by_reference_p (decl_or_origin))\n-\tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n-      else\n-\tgen_type_die (TREE_TYPE (decl_or_origin), context_die);\n+      /* Avoid generating stray type DIEs during late dwarf dumping.\n+         All types have been dumped early.  */\n+      if (early_dwarf\n+\t  /* ???  But in LTRANS we cannot annotate early created variably\n+\t     modified type DIEs without copying them and adjusting all\n+\t     references to them.  Dump them again as happens for inlining\n+\t     which copies both the decl and the types.  */\n+\t  /* ???  And even non-LTO needs to re-visit type DIEs to fill\n+\t     in VLA bound information for example.  */\n+\t  || (decl && variably_modified_type_p (TREE_TYPE (decl),\n+\t\t\t\t\t\tcurrent_function_decl)))\n+\t{\n+\t  /* Output any DIEs that are needed to specify the type of this data\n+\t     object.  */\n+\t  if (decl_by_reference_p (decl_or_origin))\n+\t    gen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n+\t  else\n+\t    gen_type_die (TREE_TYPE (decl_or_origin), context_die);\n+\t}\n \n-      /* And its containing type.  */\n-      class_origin = decl_class_context (decl_or_origin);\n-      if (class_origin != NULL_TREE)\n-\tgen_type_die_for_member (class_origin, decl_or_origin, context_die);\n+      if (early_dwarf)\n+\t{\n+\t  /* And its containing type.  */\n+\t  class_origin = decl_class_context (decl_or_origin);\n+\t  if (class_origin != NULL_TREE)\n+\t    gen_type_die_for_member (class_origin, decl_or_origin, context_die);\n \n-      /* And its containing namespace.  */\n-      context_die = declare_in_namespace (decl_or_origin, context_die);\n+\t  /* And its containing namespace.  */\n+\t  context_die = declare_in_namespace (decl_or_origin, context_die);\n+\t}\n \n       /* Now output the DIE to represent the data object itself.  This gets\n \t complicated because of the possibility that the VAR_DECL really\n@@ -25392,10 +25654,23 @@ gen_decl_die (tree decl, tree origin, struct vlr_context *ctx,\n       break;\n \n     case PARM_DECL:\n-      if (DECL_BY_REFERENCE (decl_or_origin))\n-\tgen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n-      else\n-\tgen_type_die (TREE_TYPE (decl_or_origin), context_die);\n+      /* Avoid generating stray type DIEs during late dwarf dumping.\n+         All types have been dumped early.  */\n+      if (early_dwarf\n+\t  /* ???  But in LTRANS we cannot annotate early created variably\n+\t     modified type DIEs without copying them and adjusting all\n+\t     references to them.  Dump them again as happens for inlining\n+\t     which copies both the decl and the types.  */\n+\t  /* ???  And even non-LTO needs to re-visit type DIEs to fill\n+\t     in VLA bound information for example.  */\n+\t  || (decl && variably_modified_type_p (TREE_TYPE (decl),\n+\t\t\t\t\t\tcurrent_function_decl)))\n+\t{\n+\t  if (DECL_BY_REFERENCE (decl_or_origin))\n+\t    gen_type_die (TREE_TYPE (TREE_TYPE (decl_or_origin)), context_die);\n+\t  else\n+\t    gen_type_die (TREE_TYPE (decl_or_origin), context_die);\n+\t}\n       return gen_formal_parameter_die (decl, origin,\n \t\t\t\t       true /* Emit name attribute.  */,\n \t\t\t\t       context_die);\n@@ -25467,6 +25742,16 @@ dwarf2out_early_global_decl (tree decl)\n \t      dwarf2out_decl (context);\n \t    }\n \n+\t  /* Emit an abstract origin of a function first.  This happens\n+\t     with C++ constructor clones for example and makes\n+\t     dwarf2out_abstract_function happy which requires the early\n+\t     DIE of the abstract instance to be present.  */\n+\t  if (DECL_ABSTRACT_ORIGIN (decl))\n+\t    {\n+\t      current_function_decl = DECL_ABSTRACT_ORIGIN (decl);\n+\t      dwarf2out_decl (DECL_ABSTRACT_ORIGIN (decl));\n+\t    }\n+\n \t  current_function_decl = decl;\n \t}\n       dwarf2out_decl (decl);\n@@ -25488,7 +25773,9 @@ dwarf2out_late_global_decl (tree decl)\n     {\n       dw_die_ref die = lookup_decl_die (decl);\n \n-      /* We have to generate early debug late for LTO.  */\n+      /* We may have to generate early debug late for LTO in case debug\n+         was not enabled at compile-time or the target doesn't support\n+\t the LTO early debug scheme.  */\n       if (! die && in_lto_p)\n \t{\n \t  dwarf2out_decl (decl);\n@@ -26842,7 +27129,8 @@ output_macinfo_op (macinfo_entry *ref)\n     case DW_MACRO_import:\n       dw2_asm_output_data (1, ref->code, \"Import\");\n       ASM_GENERATE_INTERNAL_LABEL (label,\n-\t\t\t\t   DEBUG_MACRO_SECTION_LABEL, ref->lineno);\n+\t\t\t\t   DEBUG_MACRO_SECTION_LABEL,\n+\t\t\t\t   ref->lineno + macinfo_label_base);\n       dw2_asm_output_offset (DWARF_OFFSET_SIZE, label, NULL, NULL);\n       break;\n     default:\n@@ -27016,7 +27304,7 @@ save_macinfo_strings (void)\n /* Output macinfo section(s).  */\n \n static void\n-output_macinfo (void)\n+output_macinfo (const char *debug_line_label, bool early_lto_debug)\n {\n   unsigned i;\n   unsigned long length = vec_safe_length (macinfo_table);\n@@ -27036,7 +27324,7 @@ output_macinfo (void)\n \n   /* AIX Assembler inserts the length, so adjust the reference to match the\n      offset expected by debuggers.  */\n-  strcpy (dl_section_ref, debug_line_section_label);\n+  strcpy (dl_section_ref, debug_line_label);\n   if (XCOFF_DEBUGGING_INFO)\n     strcat (dl_section_ref, DWARF_INITIAL_LENGTH_SIZE_STR);\n \n@@ -27049,9 +27337,7 @@ output_macinfo (void)\n \tdw2_asm_output_data (1, 3, \"Flags: 64-bit, lineptr present\");\n       else\n \tdw2_asm_output_data (1, 2, \"Flags: 32-bit, lineptr present\");\n-      dw2_asm_output_offset (DWARF_OFFSET_SIZE,\n-                             (!dwarf_split_debug_info ? dl_section_ref\n-                              : debug_skeleton_line_section_label),\n+      dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_line_label,\n                              debug_line_section, NULL);\n     }\n \n@@ -27105,6 +27391,10 @@ output_macinfo (void)\n   if (!macinfo_htab)\n     return;\n \n+  /* Save the number of transparent includes so we can adjust the\n+     label number for the fat LTO object DWARF.  */\n+  unsigned macinfo_label_base_adj = macinfo_htab->elements ();\n+\n   delete macinfo_htab;\n   macinfo_htab = NULL;\n \n@@ -27124,11 +27414,13 @@ output_macinfo (void)\n \t  dw2_asm_output_data (1, 0, \"End compilation unit\");\n \t  targetm.asm_out.named_section (debug_macinfo_section_name,\n \t\t\t\t\t SECTION_DEBUG\n-\t\t\t\t\t | SECTION_LINKONCE,\n+\t\t\t\t\t | SECTION_LINKONCE\n+\t\t\t\t\t | (early_lto_debug\n+\t\t\t\t\t    ? SECTION_EXCLUDE : 0),\n \t\t\t\t\t comdat_key);\n \t  ASM_GENERATE_INTERNAL_LABEL (label,\n \t\t\t\t       DEBUG_MACRO_SECTION_LABEL,\n-\t\t\t\t       ref->lineno);\n+\t\t\t\t       ref->lineno + macinfo_label_base);\n \t  ASM_OUTPUT_LABEL (asm_out_file, label);\n \t  ref->code = 0;\n \t  ref->info = NULL;\n@@ -27149,109 +27441,192 @@ output_macinfo (void)\n       default:\n \tgcc_unreachable ();\n       }\n+\n+  macinfo_label_base += macinfo_label_base_adj;\n }\n \n-/* Initialize the various sections and labels for dwarf output.  */\n+/* Initialize the various sections and labels for dwarf output and prefix\n+   them with PREFIX if non-NULL.  */\n \n static void\n-init_sections_and_labels (void)\n+init_sections_and_labels (bool early_lto_debug)\n {\n-  if (!dwarf_split_debug_info)\n+  /* As we may get called multiple times have a generation count for labels.  */\n+  static unsigned generation = 0;\n+\n+  if (early_lto_debug)\n     {\n-      debug_info_section = get_section (DEBUG_INFO_SECTION,\n-                                        SECTION_DEBUG, NULL);\n-      debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n-                                          SECTION_DEBUG, NULL);\n-      debug_loc_section = get_section (dwarf_version >= 5\n-\t\t\t\t       ? DEBUG_LOCLISTS_SECTION\n-\t\t\t\t       : DEBUG_LOC_SECTION,\n-                                       SECTION_DEBUG, NULL);\n-      debug_macinfo_section_name\n-\t= (dwarf_strict && dwarf_version < 5)\n-\t  ? DEBUG_MACINFO_SECTION : DEBUG_MACRO_SECTION;\n-      debug_macinfo_section = get_section (debug_macinfo_section_name,\n-\t\t\t\t\t   SECTION_DEBUG, NULL);\n+      if (!dwarf_split_debug_info)\n+\t{\n+\t  debug_info_section = get_section (DEBUG_LTO_INFO_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t    NULL);\n+\t  debug_abbrev_section = get_section (DEBUG_LTO_ABBREV_SECTION,\n+\t\t\t\t\t      SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t      NULL);\n+\t  debug_macinfo_section_name = ((dwarf_strict && dwarf_version < 5)\n+\t\t\t\t\t? DEBUG_LTO_MACINFO_SECTION\n+\t\t\t\t\t: DEBUG_LTO_MACRO_SECTION);\n+\t  debug_macinfo_section = get_section (debug_macinfo_section_name,\n+\t\t\t\t\t       SECTION_DEBUG\n+\t\t\t\t\t       | SECTION_EXCLUDE, NULL);\n+\t  /* For macro info we have to refer to a debug_line section, so similar\n+\t     to split-dwarf emit a skeleton one for early debug.  */\n+\t  debug_skeleton_line_section\n+\t    = get_section (DEBUG_LTO_LINE_SECTION,\n+\t\t\t   SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,\n+\t\t\t\t       DEBUG_SKELETON_LINE_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\t}\n+      else\n+\t{\n+\t  /* ???  Which of the following do we need early?  */\n+\t  debug_info_section = get_section (DEBUG_LTO_DWO_INFO_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t    NULL);\n+\t  debug_abbrev_section = get_section (DEBUG_LTO_DWO_ABBREV_SECTION,\n+\t\t\t\t\t      SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t      NULL);\n+\t  debug_skeleton_info_section = get_section (DEBUG_LTO_INFO_SECTION,\n+\t\t\t\t\t\t     SECTION_DEBUG\n+\t\t\t\t\t\t     | SECTION_EXCLUDE, NULL);\n+\t  debug_skeleton_abbrev_section = get_section (DEBUG_LTO_ABBREV_SECTION,\n+\t\t\t\t\t\t       SECTION_DEBUG\n+\t\t\t\t\t\t       | SECTION_EXCLUDE, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,\n+\t\t\t\t       DEBUG_SKELETON_ABBREV_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\n+\t  /* Somewhat confusing detail: The skeleton_[abbrev|info] sections stay in\n+\t     the main .o, but the skeleton_line goes into the split off dwo.  */\n+\t  debug_skeleton_line_section\n+\t    = get_section (DEBUG_LTO_LINE_SECTION,\n+\t\t\t   SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,\n+\t\t\t\t       DEBUG_SKELETON_LINE_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\t  debug_str_offsets_section\n+\t    = get_section (DEBUG_LTO_DWO_STR_OFFSETS_SECTION,\n+\t\t\t   SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t   NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,\n+\t\t\t\t       DEBUG_SKELETON_INFO_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\t  debug_str_dwo_section = get_section (DEBUG_LTO_STR_DWO_SECTION,\n+\t\t\t\t\t       DEBUG_STR_DWO_SECTION_FLAGS, NULL);\n+\t  debug_macinfo_section_name\n+\t    = (dwarf_strict\n+\t       ? DEBUG_LTO_DWO_MACINFO_SECTION : DEBUG_LTO_DWO_MACRO_SECTION);\n+\t  debug_macinfo_section = get_section (debug_macinfo_section_name,\n+\t\t\t\t\t       SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t       NULL);\n+\t}\n+      debug_str_section = get_section (DEBUG_LTO_STR_SECTION,\n+\t\t\t\t       DEBUG_STR_SECTION_FLAGS\n+\t\t\t\t       | SECTION_EXCLUDE, NULL);\n     }\n   else\n     {\n-      debug_info_section = get_section (DEBUG_DWO_INFO_SECTION,\n-                                        SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n-      debug_abbrev_section = get_section (DEBUG_DWO_ABBREV_SECTION,\n-                                          SECTION_DEBUG | SECTION_EXCLUDE,\n-                                          NULL);\n-      debug_addr_section = get_section (DEBUG_ADDR_SECTION,\n-                                        SECTION_DEBUG, NULL);\n-      debug_skeleton_info_section = get_section (DEBUG_INFO_SECTION,\n-                                                 SECTION_DEBUG, NULL);\n-      debug_skeleton_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n-                                                   SECTION_DEBUG, NULL);\n-      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,\n-                                  DEBUG_SKELETON_ABBREV_SECTION_LABEL, 0);\n-\n-      /* Somewhat confusing detail: The skeleton_[abbrev|info] sections stay in\n-         the main .o, but the skeleton_line goes into the split off dwo.  */\n-      debug_skeleton_line_section\n-        = get_section (DEBUG_DWO_LINE_SECTION,\n-\t\t       SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n-      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,\n-                                   DEBUG_SKELETON_LINE_SECTION_LABEL, 0);\n-      debug_str_offsets_section = get_section (DEBUG_DWO_STR_OFFSETS_SECTION,\n-                                               SECTION_DEBUG | SECTION_EXCLUDE,\n-                                               NULL);\n-      ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,\n-                                   DEBUG_SKELETON_INFO_SECTION_LABEL, 0);\n-      debug_loc_section = get_section (dwarf_version >= 5\n-\t\t\t\t       ? DEBUG_DWO_LOCLISTS_SECTION\n-\t\t\t\t       : DEBUG_DWO_LOC_SECTION,\n-                                       SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n-      debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,\n-                                           DEBUG_STR_DWO_SECTION_FLAGS, NULL);\n-      debug_macinfo_section_name\n-\t= (dwarf_strict && dwarf_version < 5)\n-\t  ? DEBUG_DWO_MACINFO_SECTION : DEBUG_DWO_MACRO_SECTION;\n-      debug_macinfo_section = get_section (debug_macinfo_section_name,\n+      if (!dwarf_split_debug_info)\n+\t{\n+\t  debug_info_section = get_section (DEBUG_INFO_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG, NULL);\n+\t  debug_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n+\t\t\t\t\t      SECTION_DEBUG, NULL);\n+\t  debug_loc_section = get_section (DEBUG_LOC_SECTION,\n+\t\t\t\t\t   SECTION_DEBUG, NULL);\n+\t  debug_macinfo_section_name\n+\t      = dwarf_strict ? DEBUG_MACINFO_SECTION : DEBUG_MACRO_SECTION;\n+\t  debug_macinfo_section = get_section (debug_macinfo_section_name,\n+\t\t\t\t\t       SECTION_DEBUG, NULL);\n+\t}\n+      else\n+\t{\n+\t  debug_info_section = get_section (DEBUG_DWO_INFO_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t    NULL);\n+\t  debug_abbrev_section = get_section (DEBUG_DWO_ABBREV_SECTION,\n+\t\t\t\t\t      SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t      NULL);\n+\t  debug_addr_section = get_section (DEBUG_ADDR_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG, NULL);\n+\t  debug_skeleton_info_section = get_section (DEBUG_INFO_SECTION,\n+\t\t\t\t\t\t     SECTION_DEBUG, NULL);\n+\t  debug_skeleton_abbrev_section = get_section (DEBUG_ABBREV_SECTION,\n+\t\t\t\t\t\t       SECTION_DEBUG, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_abbrev_section_label,\n+\t\t\t\t       DEBUG_SKELETON_ABBREV_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\n+\t  /* Somewhat confusing detail: The skeleton_[abbrev|info] sections\n+\t     stay in the main .o, but the skeleton_line goes into the\n+\t     split off dwo.  */\n+\t  debug_skeleton_line_section\n+\t      = get_section (DEBUG_DWO_LINE_SECTION,\n+\t\t\t     SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_line_section_label,\n+\t\t\t\t       DEBUG_SKELETON_LINE_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\t  debug_str_offsets_section\n+\t    = get_section (DEBUG_DWO_STR_OFFSETS_SECTION,\n+\t\t\t   SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+\t  ASM_GENERATE_INTERNAL_LABEL (debug_skeleton_info_section_label,\n+\t\t\t\t       DEBUG_SKELETON_INFO_SECTION_LABEL,\n+\t\t\t\t       generation);\n+\t  debug_loc_section = get_section (DEBUG_DWO_LOC_SECTION,\n \t\t\t\t\t   SECTION_DEBUG | SECTION_EXCLUDE,\n \t\t\t\t\t   NULL);\n-    }\n-  debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n-\t\t\t\t       SECTION_DEBUG, NULL);\n-  debug_line_section = get_section (DEBUG_LINE_SECTION,\n-\t\t\t\t    SECTION_DEBUG, NULL);\n-  debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,\n-\t\t\t\t\tSECTION_DEBUG, NULL);\n-  debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n+\t  debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,\n+\t\t\t\t\t       DEBUG_STR_DWO_SECTION_FLAGS,\n+\t\t\t\t\t       NULL);\n+\t  debug_macinfo_section_name\n+\t    = (dwarf_strict && dwarf_version < 5)\n+\t      ? DEBUG_DWO_MACINFO_SECTION : DEBUG_DWO_MACRO_SECTION;\n+\t  debug_macinfo_section = get_section (debug_macinfo_section_name,\n+\t\t\t\t\t       SECTION_DEBUG | SECTION_EXCLUDE,\n+\t\t\t\t\t       NULL);\n+\t}\n+      debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n+\t\t\t\t\t   SECTION_DEBUG, NULL);\n+      debug_line_section = get_section (DEBUG_LINE_SECTION,\n \t\t\t\t\tSECTION_DEBUG, NULL);\n-  debug_str_section = get_section (DEBUG_STR_SECTION,\n-\t\t\t\t   DEBUG_STR_SECTION_FLAGS, NULL);\n-  if (!dwarf_split_debug_info && !DWARF2_ASM_LINE_DEBUG_INFO)\n-    debug_line_str_section = get_section (DEBUG_LINE_STR_SECTION,\n-\t\t\t\t\t  DEBUG_STR_SECTION_FLAGS, NULL);\n-\n-  debug_ranges_section = get_section (dwarf_version >= 5\n-\t\t\t\t      ? DEBUG_RNGLISTS_SECTION\n-\t\t\t\t      : DEBUG_RANGES_SECTION,\n-\t\t\t\t      SECTION_DEBUG, NULL);\n-  debug_frame_section = get_section (DEBUG_FRAME_SECTION,\n-\t\t\t\t     SECTION_DEBUG, NULL);\n+      debug_pubnames_section = get_section (DEBUG_PUBNAMES_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG, NULL);\n+      debug_pubtypes_section = get_section (DEBUG_PUBTYPES_SECTION,\n+\t\t\t\t\t    SECTION_DEBUG, NULL);\n+      debug_str_section = get_section (DEBUG_STR_SECTION,\n+\t\t\t\t       DEBUG_STR_SECTION_FLAGS, NULL);\n+      debug_ranges_section = get_section (dwarf_version >= 5\n+\t\t\t\t\t  ? DEBUG_RNGLISTS_SECTION\n+\t\t\t\t\t  : DEBUG_RANGES_SECTION,\n+\t\t\t\t\t  SECTION_DEBUG, NULL);\n+      debug_frame_section = get_section (DEBUG_FRAME_SECTION,\n+\t\t\t\t\t SECTION_DEBUG, NULL);\n+    }\n \n   ASM_GENERATE_INTERNAL_LABEL (abbrev_section_label,\n-\t\t\t       DEBUG_ABBREV_SECTION_LABEL, 0);\n+\t\t\t       DEBUG_ABBREV_SECTION_LABEL, generation);\n   ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label,\n-\t\t\t       DEBUG_INFO_SECTION_LABEL, 0);\n+\t\t\t       DEBUG_INFO_SECTION_LABEL, generation);\n+  info_section_emitted = false;\n   ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,\n-\t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n+\t\t\t       DEBUG_LINE_SECTION_LABEL, generation);\n   ASM_GENERATE_INTERNAL_LABEL (ranges_section_label,\n-\t\t\t       DEBUG_RANGES_SECTION_LABEL, 0);\n+\t\t\t       DEBUG_RANGES_SECTION_LABEL, generation);\n   if (dwarf_version >= 5 && dwarf_split_debug_info)\n     ASM_GENERATE_INTERNAL_LABEL (ranges_base_label,\n-\t\t\t\t DEBUG_RANGES_SECTION_LABEL, 1);\n+\t\t\t\t DEBUG_RANGES_SECTION_LABEL, 2 + generation);\n   ASM_GENERATE_INTERNAL_LABEL (debug_addr_section_label,\n-                               DEBUG_ADDR_SECTION_LABEL, 0);\n+                               DEBUG_ADDR_SECTION_LABEL, generation);\n   ASM_GENERATE_INTERNAL_LABEL (macinfo_section_label,\n \t\t\t       (dwarf_strict && dwarf_version < 5)\n \t\t\t       ? DEBUG_MACINFO_SECTION_LABEL\n-\t\t\t       : DEBUG_MACRO_SECTION_LABEL, 0);\n-  ASM_GENERATE_INTERNAL_LABEL (loc_section_label, DEBUG_LOC_SECTION_LABEL, 0);\n+\t\t\t       : DEBUG_MACRO_SECTION_LABEL, generation);\n+  ASM_GENERATE_INTERNAL_LABEL (loc_section_label, DEBUG_LOC_SECTION_LABEL,\n+\t\t\t       generation);\n+\n+  ++generation;\n }\n \n /* Set up for Dwarf output at the start of compilation.  */\n@@ -29598,6 +29973,22 @@ flush_limbo_die_list (void)\n     }\n }\n \n+/* Reset DIEs so we can output them again.  */\n+\n+static void\n+reset_dies (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+\n+  /* Remove stuff we re-generate.  */\n+  die->die_mark = 0;\n+  die->die_offset = 0;\n+  die->die_abbrev = 0;\n+  remove_AT (die, DW_AT_sibling);\n+\n+  FOR_EACH_CHILD (die, c, reset_dies (c));\n+}\n+\n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n \n@@ -29625,6 +30016,46 @@ dwarf2out_finish (const char *)\n \n   gen_remaining_tmpl_value_param_die_attribute ();\n \n+  if (flag_generate_lto)\n+    {\n+      gcc_assert (flag_fat_lto_objects);\n+\n+      /* Prune stuff so that dwarf2out_finish runs successfully\n+\t for the fat part of the object.  */\n+      reset_dies (comp_unit_die ());\n+      for (limbo_die_node *node = cu_die_list; node; node = node->next)\n+\treset_dies (node->die);\n+\n+      hash_table<comdat_type_hasher> comdat_type_table (100);\n+      for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n+\t{\n+\t  comdat_type_node **slot\n+\t      = comdat_type_table.find_slot (ctnode, INSERT);\n+\n+\t  /* Don't reset types twice.  */\n+\t  if (*slot != HTAB_EMPTY_ENTRY)\n+\t    continue;\n+\n+\t  /* Add a pointer to the line table for the main compilation unit\n+\t     so that the debugger can make sense of DW_AT_decl_file\n+\t     attributes.  */\n+\t  if (debug_info_level >= DINFO_LEVEL_TERSE)\n+\t    reset_dies (ctnode->root_die);\n+\n+\t  *slot = ctnode;\n+\t}\n+\n+      /* Reset die CU symbol so we don't output it twice.  */\n+      comp_unit_die ()->die_id.die_symbol = NULL;\n+\n+      /* Remove DW_AT_macro from the early output.  */\n+      if (have_macinfo)\n+\tremove_AT (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE);\n+\n+      /* Remove indirect string decisions.  */\n+      debug_str_hash->traverse<void *, reset_indirect_string> (NULL);\n+    }\n+\n #if ENABLE_ASSERT_CHECKING\n   {\n     dw_die_ref die = comp_unit_die (), c;\n@@ -29635,7 +30066,7 @@ dwarf2out_finish (const char *)\n   move_marked_base_types ();\n \n   /* Initialize sections and labels used for actual assembler output.  */\n-  init_sections_and_labels ();\n+  init_sections_and_labels (false);\n \n   /* Traverse the DIE's and add sibling attributes to those DIE's that\n      have children.  */\n@@ -29736,9 +30167,7 @@ dwarf2out_finish (const char *)\n \t\t    dl_section_ref);\n \n   if (have_macinfo)\n-    add_AT_macptr (comp_unit_die (),\n-\t\t   dwarf_version >= 5 ? DW_AT_macros\n-\t\t   : dwarf_strict ? DW_AT_macro_info : DW_AT_GNU_macros,\n+    add_AT_macptr (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE,\n \t\t   macinfo_section_label);\n \n   if (dwarf_split_debug_info)\n@@ -29943,7 +30372,8 @@ dwarf2out_finish (const char *)\n     {\n       switch_to_section (debug_macinfo_section);\n       ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);\n-      output_macinfo ();\n+      output_macinfo (!dwarf_split_debug_info ? debug_line_section_label\n+\t\t      : debug_skeleton_line_section_label, false);\n       dw2_asm_output_data (1, 0, \"End compilation unit\");\n     }\n \n@@ -30164,6 +30594,20 @@ note_variable_value_in_expr (dw_die_ref die, dw_loc_descr_ref loc)\n       {\n \ttree decl = loc->dw_loc_oprnd1.v.val_decl_ref;\n \tdw_die_ref ref = lookup_decl_die (decl);\n+\tif (! ref && flag_generate_lto)\n+\t  {\n+\t    /* ???  This is somewhat a hack because we do not create DIEs\n+\t       for variables not in BLOCK trees early but when generating\n+\t       early LTO output we need the dw_val_class_decl_ref to be\n+\t       fully resolved.  For fat LTO objects we'd also like to\n+\t       undo this after LTO dwarf output.  */\n+\t    gcc_assert (DECL_CONTEXT (decl));\n+\t    dw_die_ref ctx = lookup_decl_die (DECL_CONTEXT (decl));\n+\t    gcc_assert (ctx != NULL);\n+\t    gen_decl_die (decl, NULL_TREE, NULL, ctx);\n+\t    ref = lookup_decl_die (decl);\n+\t    gcc_assert (ref != NULL);\n+\t  }\n \tif (ref)\n \t  {\n \t    loc->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n@@ -30374,6 +30818,119 @@ dwarf2out_early_finish (const char *filename)\n \n   /* The early debug phase is now finished.  */\n   early_dwarf_finished = true;\n+\n+  /* Do not generate DWARF assembler now when not producing LTO bytecode.  */\n+  if (!flag_generate_lto)\n+    return;\n+\n+  /* Now as we are going to output for LTO initialize sections and labels\n+     to the LTO variants.  We don't need a random-seed postfix as other\n+     LTO sections as linking the LTO debug sections into one in a partial\n+     link is fine.  */\n+  init_sections_and_labels (true);\n+\n+  /* The output below is modeled after dwarf2out_finish with all\n+     location related output removed and some LTO specific changes.\n+     Some refactoring might make both smaller and easier to match up.  */\n+\n+  /* Traverse the DIE's and add add sibling attributes to those DIE's\n+     that have children.  */\n+  add_sibling_attributes (comp_unit_die ());\n+  for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n+    add_sibling_attributes (node->die);\n+  for (comdat_type_node *ctnode = comdat_type_list;\n+       ctnode != NULL; ctnode = ctnode->next)\n+    add_sibling_attributes (ctnode->root_die);\n+\n+  if (have_macinfo)\n+    add_AT_macptr (comp_unit_die (), DEBUG_MACRO_ATTRIBUTE,\n+\t\t   macinfo_section_label);\n+\n+  save_macinfo_strings ();\n+\n+  /* Output all of the compilation units.  We put the main one last so that\n+     the offsets are available to output_pubnames.  */\n+  for (limbo_die_node *node = limbo_die_list; node; node = node->next)\n+    output_comp_unit (node->die, 0, NULL);\n+\n+  hash_table<comdat_type_hasher> comdat_type_table (100);\n+  for (comdat_type_node *ctnode = comdat_type_list;\n+       ctnode != NULL; ctnode = ctnode->next)\n+    {\n+      comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);\n+\n+      /* Don't output duplicate types.  */\n+      if (*slot != HTAB_EMPTY_ENTRY)\n+        continue;\n+\n+      /* Add a pointer to the line table for the main compilation unit\n+         so that the debugger can make sense of DW_AT_decl_file\n+         attributes.  */\n+      if (debug_info_level >= DINFO_LEVEL_TERSE)\n+        add_AT_lineptr (ctnode->root_die, DW_AT_stmt_list,\n+                        (!dwarf_split_debug_info\n+                         ? debug_line_section_label\n+                         : debug_skeleton_line_section_label));\n+\n+      output_comdat_type_unit (ctnode);\n+      *slot = ctnode;\n+    }\n+\n+  /* The AT_pubnames attribute needs to go in all skeleton dies, including\n+     both the main_cu and all skeleton TUs.  Making this call unconditional\n+     would end up either adding a second copy of the AT_pubnames attribute, or\n+     requiring a special case in add_top_level_skeleton_die_attrs.  */\n+  if (!dwarf_split_debug_info)\n+    add_AT_pubnames (comp_unit_die ());\n+\n+  /* Stick a unique symbol to the main debuginfo section.  */\n+  compute_comp_unit_symbol (comp_unit_die ());\n+\n+  /* Output the main compilation unit.  We always need it if only for\n+     the CU symbol.  */\n+  output_comp_unit (comp_unit_die (), true, NULL);\n+\n+  /* Output the abbreviation table.  */\n+  if (vec_safe_length (abbrev_die_table) != 1)\n+    {\n+      switch_to_section (debug_abbrev_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n+      output_abbrev_section ();\n+    }\n+\n+  /* Have to end the macro section.  */\n+  if (have_macinfo)\n+    {\n+      /* We have to save macinfo state if we need to output it again\n+\t for the FAT part of the object.  */\n+      vec<macinfo_entry, va_gc> *saved_macinfo_table = macinfo_table;\n+      if (flag_fat_lto_objects)\n+\tmacinfo_table = macinfo_table->copy ();\n+\n+      switch_to_section (debug_macinfo_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, macinfo_section_label);\n+      output_macinfo (debug_skeleton_line_section_label, true);\n+      dw2_asm_output_data (1, 0, \"End compilation unit\");\n+\n+      /* Emit a skeleton debug_line section.  */\n+      switch_to_section (debug_skeleton_line_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_line_section_label);\n+      output_line_info (true);\n+\n+      if (flag_fat_lto_objects)\n+\t{\n+\t  vec_free (macinfo_table);\n+\t  macinfo_table = saved_macinfo_table;\n+\t}\n+    }\n+\n+\n+  /* If we emitted any indirect strings, output the string table too.  */\n+  if (debug_str_hash || skeleton_debug_str_hash)\n+    output_indirect_strings ();\n+\n+  /* Switch back to the text section.  */\n+  switch_to_section (text_section);\n }\n \n /* Reset all state within dwarf2out.c so that we can rerun the compiler"}, {"sha": "ee85efc9754b0cd76dea6439eddc2d095ae5bc0b", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"cgraph.h\"\n #include \"cfgloop.h\"\n+#include \"debug.h\"\n \n \n struct freeing_string_slot_hasher : string_slot_hasher\n@@ -1038,6 +1039,16 @@ input_function (tree fn_decl, struct data_in *data_in,\n   DECL_RESULT (fn_decl) = stream_read_tree (ib, data_in);\n   DECL_ARGUMENTS (fn_decl) = streamer_read_chain (ib, data_in);\n \n+  /* Read debug args if available.  */\n+  unsigned n_debugargs = streamer_read_uhwi (ib);\n+  if (n_debugargs)\n+    {\n+      vec<tree, va_gc> **debugargs = decl_debug_args_insert (fn_decl);\n+      vec_safe_grow (*debugargs, n_debugargs);\n+      for (unsigned i = 0; i < n_debugargs; ++i)\n+\t(**debugargs)[i] = stream_read_tree (ib, data_in);\n+    }\n+\n   /* Read the tree of lexical scopes for the function.  */\n   DECL_INITIAL (fn_decl) = stream_read_tree (ib, data_in);\n   unsigned block_leaf_count = streamer_read_uhwi (ib);\n@@ -1322,6 +1333,10 @@ lto_input_variable_constructor (struct lto_file_decl_data *file_data,\n }\n \n \n+/* Queue of acummulated decl -> DIE mappings.  Similar to locations those\n+   are only applied to prevailing tree nodes during tree merging.  */\n+vec<dref_entry> dref_queue;\n+\n /* Read the physical representation of a tree node EXPR from\n    input block IB using the per-file context in DATA_IN.  */\n \n@@ -1341,6 +1356,23 @@ lto_read_tree_1 (struct lto_input_block *ib, struct data_in *data_in, tree expr)\n       && TREE_CODE (expr) != FUNCTION_DECL\n       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n     DECL_INITIAL (expr) = stream_read_tree (ib, data_in);\n+\n+  /* Stream references to early generated DIEs.  Keep in sync with the\n+     trees handled in dwarf2out_register_external_die.  */\n+  if ((DECL_P (expr)\n+       && TREE_CODE (expr) != FIELD_DECL\n+       && TREE_CODE (expr) != DEBUG_EXPR_DECL\n+       && TREE_CODE (expr) != TYPE_DECL)\n+      || TREE_CODE (expr) == BLOCK)\n+    {\n+      const char *str = streamer_read_string (data_in, ib);\n+      if (str)\n+\t{\n+\t  unsigned HOST_WIDE_INT off = streamer_read_uhwi (ib);\n+\t  dref_entry e = { expr, str, off };\n+\t  dref_queue.safe_push (e);\n+\t}\n+    }\n }\n \n /* Read the physical representation of a tree node with tag TAG from\n@@ -1486,6 +1518,13 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n     {\n       unsigned len, entry_len;\n       lto_input_scc (ib, data_in, &len, &entry_len);\n+\n+      /* Register DECLs with the debuginfo machinery.  */\n+      while (!dref_queue.is_empty ())\n+\t{\n+\t  dref_entry e = dref_queue.pop ();\n+\t  debug_hooks->register_external_die (e.decl, e.sym, e.off);\n+\t}\n     }\n   return lto_input_tree_1 (ib, data_in, tag, 0);\n }"}, {"sha": "944502be3f8aef9408c81cbf7beb48f738c7fa1d", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"builtins.h\"\n #include \"gomp-constants.h\"\n+#include \"debug.h\"\n \n \n static void lto_write_tree (struct output_block*, tree, bool);\n@@ -406,6 +407,26 @@ lto_write_tree_1 (struct output_block *ob, tree expr, bool ref_p)\n \t\t\t (ob->decl_state->symtab_node_encoder, expr);\n       stream_write_tree (ob, initial, ref_p);\n     }\n+\n+  /* Stream references to early generated DIEs.  Keep in sync with the\n+     trees handled in dwarf2out_die_ref_for_decl.  */\n+  if ((DECL_P (expr)\n+       && TREE_CODE (expr) != FIELD_DECL\n+       && TREE_CODE (expr) != DEBUG_EXPR_DECL\n+       && TREE_CODE (expr) != TYPE_DECL)\n+      || TREE_CODE (expr) == BLOCK)\n+    {\n+      const char *sym;\n+      unsigned HOST_WIDE_INT off;\n+      if (debug_info_level > DINFO_LEVEL_NONE\n+\t  && debug_hooks->die_ref_for_decl (expr, &sym, &off))\n+\t{\n+\t  streamer_write_string (ob, ob->main_stream, sym, true);\n+\t  streamer_write_uhwi (ob, off);\n+\t}\n+      else\n+\tstreamer_write_string (ob, ob->main_stream, NULL, true);\n+    }\n }\n \n /* Write a physical representation of tree node EXPR to output block\n@@ -745,7 +766,11 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \t;\n       else\n \tDFS_follow_tree_edge (DECL_NAME (expr));\n-      DFS_follow_tree_edge (DECL_CONTEXT (expr));\n+      if (TREE_CODE (expr) != TRANSLATION_UNIT_DECL\n+\t  && ! DECL_CONTEXT (expr))\n+\tDFS_follow_tree_edge ((*all_translation_units)[0]);\n+      else\n+\tDFS_follow_tree_edge (DECL_CONTEXT (expr));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n@@ -765,6 +790,7 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \t declarations which should be eliminated by decl merging. Be sure none\n \t leaks to this point.  */\n       gcc_assert (DECL_ABSTRACT_ORIGIN (expr) != error_mark_node);\n+      DFS_follow_tree_edge (DECL_ABSTRACT_ORIGIN (expr));\n \n       if ((VAR_P (expr)\n \t   || TREE_CODE (expr) == PARM_DECL)\n@@ -2057,6 +2083,17 @@ output_function (struct cgraph_node *node)\n   stream_write_tree (ob, DECL_RESULT (function), true);\n   streamer_write_chain (ob, DECL_ARGUMENTS (function), true);\n \n+  /* Output debug args if available. */\n+  vec<tree, va_gc> **debugargs = decl_debug_args_lookup (function);\n+  if (! debugargs)\n+    streamer_write_uhwi (ob, 0);\n+  else\n+    {\n+      streamer_write_uhwi (ob, (*debugargs)->length ());\n+      for (unsigned i = 0; i < (*debugargs)->length (); ++i)\n+\tstream_write_tree (ob, (**debugargs)[i], true);\n+    }\n+\n   /* Output DECL_INITIAL for the function, which contains the tree of\n      lexical scopes.  */\n   stream_write_tree (ob, DECL_INITIAL (function), true);"}, {"sha": "cd33df8f392829f9e0c7eb761d75fd90adcde860", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1212,4 +1212,14 @@ DEFINE_DECL_STREAM_FUNCS (TYPE_DECL, type_decl)\n DEFINE_DECL_STREAM_FUNCS (NAMESPACE_DECL, namespace_decl)\n DEFINE_DECL_STREAM_FUNCS (LABEL_DECL, label_decl)\n \n+/* Entry for the delayed registering of decl -> DIE references.  */\n+struct dref_entry {\n+    tree decl;\n+    const char *sym;\n+    unsigned HOST_WIDE_INT off;\n+};\n+\n+extern vec<dref_entry> dref_queue;\n+\n+\n #endif /* GCC_LTO_STREAMER_H  */"}, {"sha": "841362a91e2ab23e62d07ab4cc3cf569a3a482c2", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 175, "deletions": 4, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -70,6 +70,7 @@ static char **output_names;\n static char **offload_names;\n static char *offload_objects_file_name;\n static char *makefile;\n+static char *debug_obj;\n \n const char tool_name[] = \"lto-wrapper\";\n \n@@ -88,6 +89,8 @@ tool_cleanup (bool)\n     maybe_unlink (offload_objects_file_name);\n   if (makefile)\n     maybe_unlink (makefile);\n+  if (debug_obj)\n+    maybe_unlink (debug_obj);\n   for (i = 0; i < nr; ++i)\n     {\n       maybe_unlink (input_names[i]);\n@@ -960,6 +963,67 @@ find_and_merge_options (int fd, off_t file_offset, const char *prefix,\n   return true;\n }\n \n+/* Copy early debug info sections from INFILE to a new file whose name\n+   is returned.  Return NULL on error.  */\n+\n+const char *\n+debug_objcopy (const char *infile)\n+{\n+  const char *outfile;\n+  const char *errmsg;\n+  int err;\n+\n+  const char *p;\n+  off_t inoff = 0;\n+  long loffset;\n+  int consumed;\n+  if ((p = strrchr (infile, '@'))\n+      && p != infile\n+      && sscanf (p, \"@%li%n\", &loffset, &consumed) >= 1\n+      && strlen (p) == (unsigned int) consumed)\n+    {\n+      char *fname = xstrdup (infile);\n+      fname[p - infile] = '\\0';\n+      infile = fname;\n+      inoff = (off_t) loffset;\n+    }\n+  int infd = open (infile, O_RDONLY);\n+  if (infd == -1)\n+    return NULL;\n+  simple_object_read *inobj = simple_object_start_read (infd, inoff,\n+\t\t\t\t\t\t\t\"__GNU_LTO\",\n+\t\t\t\t\t\t\t&errmsg, &err);\n+  if (!inobj)\n+    return NULL;\n+\n+  off_t off, len;\n+  if (simple_object_find_section (inobj, \".gnu.debuglto_.debug_info\",\n+\t\t\t\t  &off, &len, &errmsg, &err) != 1)\n+    {\n+      if (errmsg)\n+\tfatal_error (0, \"%s: %s\\n\", errmsg, xstrerror (err));\n+\n+      simple_object_release_read (inobj);\n+      close (infd);\n+      return NULL;\n+    }\n+\n+  outfile = make_temp_file (\"debugobjtem\");\n+  errmsg = simple_object_copy_lto_debug_sections (inobj, outfile, &err);\n+  if (errmsg)\n+    {\n+      unlink_if_ordinary (outfile);\n+      fatal_error (0, \"%s: %s\\n\", errmsg, xstrerror (err));\n+    }\n+\n+  simple_object_release_read (inobj);\n+  close (infd);\n+\n+  return outfile;\n+}\n+\n+\n+\n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n static void\n@@ -984,8 +1048,10 @@ run_gcc (unsigned argc, char *argv[])\n   int new_head_argc;\n   bool have_lto = false;\n   bool have_offload = false;\n-  unsigned lto_argc = 0;\n-  char **lto_argv;\n+  unsigned lto_argc = 0, ltoobj_argc = 0;\n+  char **lto_argv, **ltoobj_argv;\n+  bool skip_debug = false;\n+  unsigned n_debugobj;\n \n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n@@ -1004,6 +1070,7 @@ run_gcc (unsigned argc, char *argv[])\n   /* Allocate array for input object files with LTO IL,\n      and for possible preceding arguments.  */\n   lto_argv = XNEWVEC (char *, argc);\n+  ltoobj_argv = XNEWVEC (char *, argc);\n \n   /* Look at saved options in the IL files.  */\n   for (i = 1; i < argc; ++i)\n@@ -1046,7 +1113,7 @@ run_gcc (unsigned argc, char *argv[])\n \t\t\t\t  collect_gcc))\n \t{\n \t  have_lto = true;\n-\t  lto_argv[lto_argc++] = argv[i];\n+\t  ltoobj_argv[ltoobj_argc++] = argv[i];\n \t}\n       close (fd);\n     }\n@@ -1107,6 +1174,17 @@ run_gcc (unsigned argc, char *argv[])\n \t}\n     }\n \n+  /* Output lto-wrapper invocation command.  */\n+  if (verbose)\n+    {\n+      for (i = 0; i < argc; ++i)\n+\t{\n+\t  fputs (argv[i], stderr);\n+\t  fputc (' ', stderr);\n+\t}\n+      fputc ('\\n', stderr);\n+    }\n+\n   if (no_partition)\n     {\n       lto_mode = LTO_MODE_LTO;\n@@ -1296,18 +1374,105 @@ run_gcc (unsigned argc, char *argv[])\n         obstack_ptr_grow (&argv_obstack, \"-fwpa\");\n     }\n \n-  /* Append the input objects and possible preceding arguments.  */\n+  /* Append input arguments.  */\n   for (i = 0; i < lto_argc; ++i)\n     obstack_ptr_grow (&argv_obstack, lto_argv[i]);\n+  /* Append the input objects.  */\n+  for (i = 0; i < ltoobj_argc; ++i)\n+    obstack_ptr_grow (&argv_obstack, ltoobj_argv[i]);\n   obstack_ptr_grow (&argv_obstack, NULL);\n \n   new_argv = XOBFINISH (&argv_obstack, const char **);\n   argv_ptr = &new_argv[new_head_argc];\n   fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true);\n \n+  /* Handle early generated debug information.  At compile-time\n+     we output early DWARF debug info into .gnu.debuglto_ prefixed\n+     sections.  LTRANS object DWARF debug info refers to that.\n+     So we need to transfer the .gnu.debuglto_ sections to the final\n+     link.  Ideally the linker plugin interface would allow us to\n+     not claim those sections and instruct the linker to keep\n+     them, renaming them in the process.  For now we extract and\n+     rename those sections via a simple-object interface to produce\n+     regular objects containing only the early debug info.  We\n+     then partially link those to a single early debug info object\n+     and pass that as additional output back to the linker plugin.  */\n+\n+  /* Prepare the partial link to gather the compile-time generated\n+     debug-info into a single input for the final link.  */\n+  debug_obj = make_temp_file (\"debugobj\");\n+  obstack_ptr_grow (&argv_obstack, collect_gcc);\n+  for (i = 1; i < decoded_options_count; ++i)\n+    {\n+      /* Retain linker choice and -B.  */\n+      if (decoded_options[i].opt_index == OPT_B\n+\t  || decoded_options[i].opt_index == OPT_fuse_ld_bfd\n+\t  || decoded_options[i].opt_index == OPT_fuse_ld_gold)\n+\tappend_linker_options (&argv_obstack, &decoded_options[i-1], 2);\n+      /* Retain all target options, this preserves -m32 for example.  */\n+      if (cl_options[decoded_options[i].opt_index].flags & CL_TARGET)\n+\tappend_linker_options (&argv_obstack, &decoded_options[i-1], 2);\n+      /* Recognize -g0.  */\n+      if (decoded_options[i].opt_index == OPT_g\n+\t  && strcmp (decoded_options[i].arg, \"0\") == 0)\n+\tskip_debug = true;\n+    }\n+  obstack_ptr_grow (&argv_obstack, \"-r\");\n+  obstack_ptr_grow (&argv_obstack, \"-nostdlib\");\n+  obstack_ptr_grow (&argv_obstack, \"-o\");\n+  obstack_ptr_grow (&argv_obstack, debug_obj);\n+\n+  /* Copy the early generated debug info from the objects to temporary\n+     files and append those to the partial link commandline.  */\n+  n_debugobj = 0;\n+  if (! skip_debug)\n+    for (i = 0; i < ltoobj_argc; ++i)\n+      {\n+\tconst char *tem;\n+\tif ((tem = debug_objcopy (ltoobj_argv[i])))\n+\t  {\n+\t    obstack_ptr_grow (&argv_obstack, tem);\n+\t    n_debugobj++;\n+\t  }\n+      }\n+\n+  /* Link them all into a single object.  Ideally this would reduce\n+     disk space usage mainly due to .debug_str merging but unfortunately\n+     GNU ld doesn't perform this with -r.  */\n+  if (n_debugobj)\n+    {\n+      obstack_ptr_grow (&argv_obstack, NULL);\n+      const char **debug_link_argv = XOBFINISH (&argv_obstack, const char **);\n+      fork_execute (debug_link_argv[0],\n+\t\t    CONST_CAST (char **, debug_link_argv), false);\n+\n+      /* And dispose the temporaries.  */\n+      for (i = 0; debug_link_argv[i]; ++i)\n+\t;\n+      for (--i; i > 0; --i)\n+\t{\n+\t  if (strcmp (debug_link_argv[i], debug_obj) == 0)\n+\t    break;\n+\t  maybe_unlink (debug_link_argv[i]);\n+\t}\n+    }\n+  else\n+    {\n+      unlink_if_ordinary (debug_obj);\n+      free (debug_obj);\n+      debug_obj = NULL;\n+      skip_debug = true;\n+    }\n+\n   if (lto_mode == LTO_MODE_LTO)\n     {\n       printf (\"%s\\n\", flto_out);\n+      if (!skip_debug)\n+\t{\n+\t  printf (\"%s\\n\", debug_obj);\n+\t  free (debug_obj);\n+\t  debug_obj = NULL;\n+\t}\n       free (flto_out);\n       flto_out = NULL;\n     }\n@@ -1456,6 +1621,12 @@ run_gcc (unsigned argc, char *argv[])\n \t  for (i = 0; i < nr; ++i)\n \t    maybe_unlink (input_names[i]);\n \t}\n+      if (!skip_debug)\n+\t{\n+\t  printf (\"%s\\n\", debug_obj);\n+\t  free (debug_obj);\n+\t  debug_obj = NULL;\n+\t}\n       for (i = 0; i < nr; ++i)\n \t{\n \t  fputs (output_names[i], stdout);"}, {"sha": "6171530e24149a605a33c662c95c2c628f072652", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,11 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+        * lto.c (unify_scc): Truncate DIE reference queue for dropped SCCs.\n+        (lto_read_decls): Process TRANSLATION_UNIT_DECLs.  Remove\n+        TYPE_DECL debug processing, register DIE references from\n+        prevailing SCCs with the debug machinery.\n+        (lto_section_with_id): Handle LTO debug sections.\n+\n 2017-08-16  Nathan Sidwell  <nathan@acm.org>\n \n \t* lto.c (mentions_vars_p_type): Use TYPE_LANG_SLOT_1."}, {"sha": "182607b6fa4b52a4962e43e06acd98325baafa7e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1633,6 +1633,9 @@ unify_scc (struct data_in *data_in, unsigned from,\n \t      free_node (scc->entries[i]);\n \t    }\n \n+\t  /* Drop DIE references.  */\n+\t  dref_queue.truncate (0);\n+\n \t  break;\n \t}\n \n@@ -1708,8 +1711,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t\t\t\t\t     from);\n \t  if (len == 1\n \t      && (TREE_CODE (first) == IDENTIFIER_NODE\n-\t\t  || TREE_CODE (first) == INTEGER_CST\n-\t\t  || TREE_CODE (first) == TRANSLATION_UNIT_DECL))\n+\t\t  || TREE_CODE (first) == INTEGER_CST))\n \t    continue;\n \n \t  /* Try to unify the SCC with already existing ones.  */\n@@ -1748,16 +1750,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t      if (TREE_CODE (t) == INTEGER_CST\n \t\t  && !TREE_OVERFLOW (t))\n \t\tcache_integer_cst (t);\n-\t      /* Register TYPE_DECLs with the debuginfo machinery.  */\n-\t      if (!flag_wpa\n-\t\t  && TREE_CODE (t) == TYPE_DECL)\n-\t\t{\n-\t\t  /* Dwarf2out needs location information.\n-\t\t     TODO: Moving this out of the streamer loop may noticealy\n-\t\t     improve ltrans linemap memory use.  */\n-\t\t  data_in->location_cache.apply_location_cache ();\n-\t\t  debug_hooks->type_decl (t, !DECL_FILE_SCOPE_P (t));\n-\t\t}\n \t      if (!flag_ltrans)\n \t\t{\n \t\t  /* Register variables and functions with the\n@@ -1773,6 +1765,14 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t    vec_safe_push (tree_with_vars, t);\n \t\t}\n \t    }\n+\n+\t  /* Register DECLs with the debuginfo machinery.  */\n+\t  while (!dref_queue.is_empty ())\n+\t    {\n+\t      dref_entry e = dref_queue.pop ();\n+\t      debug_hooks->register_external_die (e.decl, e.sym, e.off);\n+\t    }\n+\n \t  if (seen_type)\n \t    num_type_scc_trees += len;\n \t}\n@@ -1952,7 +1952,12 @@ lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n   if (strncmp (name, section_name_prefix, strlen (section_name_prefix)))\n     return 0;\n   s = strrchr (name, '.');\n-  return s && sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n+  if (!s)\n+    return 0;\n+  /* If the section is not suffixed with an ID return.  */\n+  if ((size_t)(s - name) == strlen (section_name_prefix))\n+    return 0;\n+  return sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n }\n \n /* Create file_data of each sub file id */"}, {"sha": "8fcb97712172def20d28435e0df0501f7b738c71", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -302,6 +302,8 @@ const struct gcc_debug_hooks sdb_debug_hooks =\n   sdbout_late_global_decl,\t\t /* late_global_decl */\n   sdbout_symbol,\t\t\t /* type_decl */\n   debug_nothing_tree_tree_tree_bool_bool,/* imported_module_or_decl */\n+  debug_false_tree_charstarstar_uhwistar,/* die_ref_for_decl */\n+  debug_nothing_tree_charstar_uhwi,      /* register_external_die */\n   debug_nothing_tree,\t\t         /* deferred_inline_function */\n   debug_nothing_tree,\t\t         /* outlining_inline_function */\n   sdbout_label,\t\t\t         /* label */"}, {"sha": "731c812826a626ea9f8bff049f62f0298ab25424", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,22 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* c-c++-common/asan/global-overflow-1.c: Adjust diagnostic location\n+\tregex to handle the LTO case.\n+\t* c-c++-common/asan/heap-overflow-1.c: Likewise.\n+\t* c-c++-common/asan/misalign-1.c: Likewise.\n+\t* c-c++-common/asan/misalign-2.c: Likewise.\n+\t* c-c++-common/asan/null-deref-1.c: Likewise.\n+\t* c-c++-common/asan/stack-overflow-1.c: Likewise.\n+\t* c-c++-common/asan/strncpy-overflow-1.c: Likewise.\n+\t* c-c++-common/asan/use-after-free-1.c: Likewise.\n+\t* c-c++-common/asan/alloca_big_alignment.c: Likewise.\n+\t* c-c++-common/asan/alloca_detect_custom_size.c: Likewise.\n+\t* c-c++-common/asan/alloca_overflow_partial.c: Likewise.\n+\t* c-c++-common/asan/alloca_overflow_right.c: Likewise.\n+\t* c-c++-common/asan/alloca_underflow_left.c: Likewise.\n+\t* g++.dg/asan/large-func-test-1.C: Likewise.\n+\t* gfortran.dg/save_6.f90: Add -flto -g variant of save_5.f90.\n+\n 2017-08-21  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/81884"}, {"sha": "9cad57e8531a46fd72e92b5ca757726881b5f6ab", "filename": "gcc/testsuite/c-c++-common/asan/alloca_big_alignment.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -17,6 +17,6 @@ int main() {\n }\n \n /* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_big_alignment.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_big_alignment.c:11|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r\\]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in foo.*alloca_big_alignment.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "830bad93cf038b59b47b67d3196ad38ab9906ec5", "filename": "gcc/testsuite/c-c++-common/asan/alloca_detect_custom_size.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -22,6 +22,6 @@ int main(int argc, char **argv) {\n }\n \n /* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_detect_custom_size.c:16|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_detect_custom_size.c:16|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in foo.*alloca_detect_custom_size.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "52282411bf5e2fd8bbd711ab81ab1bbb2354b8e3", "filename": "gcc/testsuite/c-c++-common/asan/alloca_overflow_partial.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -17,6 +17,6 @@ int main(int argc, char **argv) {\n }\n \n /* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_partial.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_partial.c:11|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in foo.*alloca_overflow_partial.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "4c4355bc59bd9299332ea56c68359a6bb621a18a", "filename": "gcc/testsuite/c-c++-common/asan/alloca_overflow_right.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -17,6 +17,6 @@ int main(int argc, char **argv) {\n }\n \n /* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_right.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_right.c:11|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in foo.*alloca_overflow_right.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "030098012145d4a6e8a4892aed2b8a99b431ecdc", "filename": "gcc/testsuite/c-c++-common/asan/alloca_underflow_left.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -17,6 +17,6 @@ int main(int argc, char **argv) {\n }\n \n /* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_underflow_left.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_underflow_left.c:11|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in foo.*alloca_underflow_left.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "1092a3166816b1d6731bb1cf14828be1880f2b3f", "filename": "gcc/testsuite/c-c++-common/asan/global-overflow-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fglobal-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fglobal-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fglobal-overflow-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -23,6 +23,6 @@ int main() {\n }\n \n /* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+ thread T0.*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*global-overflow-1.c:20|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r).*\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*global-overflow-1.c:20|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r).*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ is located 0 bytes to the right of global variable\" } */\n /* { dg-output \".*YYY\\[^\\n\\r]* of size 10\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "7ef048e636f7d2578dd3f5c6019a4fbdab9afa33", "filename": "gcc/testsuite/c-c++-common/asan/heap-overflow-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fheap-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fheap-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fheap-overflow-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -24,8 +24,8 @@ int main(int argc, char **argv) {\n }\n \n /* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+ thread T0.*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*heap-overflow-1.c:21|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*heap-overflow-1.c:21|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 0 bytes to the right of 10-byte region\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*allocated by thread T0 here:\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*(interceptor_|wrap_|)malloc|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*heap-overflow-1.c:19|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*heap-overflow-1.c:19|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "5cd605ac045407cdaf69814aa04c78ff7158a91d", "filename": "gcc/testsuite/c-c++-common/asan/misalign-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -39,5 +39,5 @@ main ()\n /* { dg-output \"ERROR: AddressSanitizer:\\[^\\n\\r]*on address\\[^\\n\\r]*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ at pc 0x\\[0-9a-f\\]+ bp 0x\\[0-9a-f\\]+ sp 0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*READ of size 4 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*misalign-1.c:1\\[01]|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*misalign-1.c:3\\[45]|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*misalign-1.c:1\\[01]|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*misalign-1.c:3\\[45]|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "a6ed49bac0537b6a10004582dd5fe7f3f0a42cd0", "filename": "gcc/testsuite/c-c++-common/asan/misalign-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmisalign-2.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -39,5 +39,5 @@ main ()\n /* { dg-output \"ERROR: AddressSanitizer:\\[^\\n\\r]*on address\\[^\\n\\r]*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ at pc 0x\\[0-9a-f\\]+ bp 0x\\[0-9a-f\\]+ sp 0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*READ of size 4 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*baz(\\[^\\n\\r]*misalign-2.c:2\\[23]|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*misalign-2.c:3\\[45]|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*baz(\\[^\\n\\r]*misalign-2.c:2\\[23]|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*misalign-2.c:3\\[45]|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "bae016d6419c38fca9d056e44d39973d06c6c813", "filename": "gcc/testsuite/c-c++-common/asan/null-deref-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -18,5 +18,5 @@ int main()\n \n /* { dg-output \"ERROR: AddressSanitizer:? SEGV on unknown address\\[^\\n\\r]*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ \\[^\\n\\r]*pc 0x\\[0-9a-f\\]+.*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in \\[^\\n\\r]*NullDeref\\[^\\n\\r]* (\\[^\\n\\r]*null-deref-1.c:10|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*null-deref-1.c:15|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in \\[^\\n\\r]*NullDeref\\[^\\n\\r]* (\\[^\\n\\r]*null-deref-1.c:10|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*null-deref-1.c:15|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "7eab79c65140b3710b205d51e47d1236a3acf2a5", "filename": "gcc/testsuite/c-c++-common/asan/stack-overflow-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstack-overflow-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -18,6 +18,6 @@ int main() {\n }\n \n /* { dg-output \"READ of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*stack-overflow-1.c:16|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*stack-overflow-1.c:16|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n /* { dg-output \"\\[^\\n\\r]*in main.*stack-overflow-1.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "a9c9b1828880340e26d2cdeba291cdf9f581fec1", "filename": "gcc/testsuite/c-c++-common/asan/strncpy-overflow-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fstrncpy-overflow-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -14,8 +14,8 @@ int main(int argc, char **argv) {\n \n /* { dg-output \"WRITE of size \\[0-9\\]* at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*(interceptor_|wrap_|)strncpy|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*strncpy-overflow-1.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*strncpy-overflow-1.c:11|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 0 bytes to the right of 9-byte region\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*allocated by thread T0 here:\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*(interceptor_|wrap_|)malloc|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*strncpy-overflow-1.c:10|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*strncpy-overflow-1.c:10|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "4894db2450ffbbfbc68b142ab5b909bfe402b2d4", "filename": "gcc/testsuite/c-c++-common/asan/use-after-free-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fuse-after-free-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fuse-after-free-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fuse-after-free-1.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -12,11 +12,11 @@ int main() {\n /* { dg-output \"ERROR: AddressSanitizer:? heap-use-after-free on address\\[^\\n\\r]*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ at pc 0x\\[0-9a-f\\]+ bp 0x\\[0-9a-f\\]+ sp 0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*READ of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:9|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:9|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 5 bytes inside of 10-byte region .0x\\[0-9a-f\\]+,0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*freed by thread T0 here:\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*(interceptor_|wrap_|)free|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:8|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:8|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"\\[^\\n\\r]*previously allocated by thread T0 here:\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*(interceptor_|wrap_|)malloc|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:7|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #1 0x\\[0-9a-f\\]+ +(in _*main (\\[^\\n\\r]*use-after-free-1.c:7|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "b42c09e3b0d949544285183b4e536d1f9a0bfdeb", "filename": "gcc/testsuite/g++.dg/asan/large-func-test-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Flarge-func-test-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Flarge-func-test-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Flarge-func-test-1.C?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -38,7 +38,7 @@ int main() {\n // { dg-output \"ERROR: AddressSanitizer:? heap-buffer-overflow on address\\[^\\n\\r]*\" }\n // { dg-output \"0x\\[0-9a-f\\]+ at pc 0x\\[0-9a-f\\]+ bp 0x\\[0-9a-f\\]+ sp 0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n // { dg-output \"\\[^\\n\\r]*READ of size 4 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n-// { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in \\[^\\n\\r]*LargeFunction\\[^\\n\\r]*(large-func-test-1.C:18|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in \\[^\\n\\r]*LargeFunction\\[^\\n\\r]*(large-func-test-1.C:18|\\[^\\n\\r]*:0|\\[^\\n\\r]*\\\\+0x\\[0-9a-z\\]*)|\\[(\\]).*(\\n|\\r\\n|\\r)\" }\n // { dg-output \"\\[^\\n\\r]*0x\\[0-9a-f\\]+ is located 44 bytes to the right of 400-byte region.*(\\n|\\r\\n|\\r)\" }\n // { dg-output \"\\[^\\n\\r]*allocated by thread T0 here:\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }\n // { dg-output \"    #0( 0x\\[0-9a-f\\]+ +(in _*(interceptor_|)malloc|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" }"}, {"sha": "0dcec29d5f72867e7c00c116b4c071c3d40ff623", "filename": "gcc/testsuite/gfortran.dg/save_6.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fgfortran.dg%2Fsave_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftestsuite%2Fgfortran.dg%2Fsave_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsave_6.f90?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+! { dg-require-effective-target lto }\n+! { dg-options \"-fno-automatic -flto -g\" }\n+!\n+! PR fortran/55733\n+!\n+! Check that -fno-automatic makes the local variable SAVEd\n+! Check that -flto -g works\n+!\n+\n+! Scalar allocatable\n+subroutine foo(i)\n+  integer :: i\n+  integer, allocatable :: j\n+  if (i == 1) j = 42\n+  if (.not. allocated (j)) call abort ()\n+  if (j /= 42) call abort ()\n+end\n+\n+! Deferred-length string scalar\n+subroutine bar()\n+  logical, save :: first = .true.\n+  character(len=:), allocatable :: str\n+  if (first) then\n+    first = .false.\n+    if (allocated (str)) call abort ()\n+    str = \"ABCDEF\"\n+  end if\n+  if (.not. allocated (str)) call abort ()\n+  if (len (str) /= 6) call abort ()\n+  if (str(1:6) /= \"ABCDEF\") call abort ()\n+end subroutine bar\n+\n+! Deferred-length string array\n+subroutine bar_array()\n+  logical, save :: first = .true.\n+  character(len=:), allocatable :: str\n+  if (first) then\n+    first = .false.\n+    if (allocated (str)) call abort ()\n+    str = \"ABCDEF\"\n+  end if\n+  if (.not. allocated (str)) call abort ()\n+  if (len (str) /= 6) call abort ()\n+  if (str(1:6) /= \"ABCDEF\") call abort ()\n+end subroutine bar_array\n+\n+call foo(1)\n+call foo(2)\n+call bar()\n+call bar_array()\n+call bar()\n+call bar_array()\n+end"}, {"sha": "8d47547967e8ce4301a4b3cae77b30ef815c9982", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -691,10 +691,7 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n   DECL_SIZE (expr) = stream_read_tree (ib, data_in);\n   DECL_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n   DECL_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n-\n-  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n+  DECL_ABSTRACT_ORIGIN (expr) = stream_read_tree (ib, data_in);\n \n   if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))"}, {"sha": "7f52d455f5e4ea7d24ed761feb5ed8a829796119", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -566,7 +566,11 @@ write_ts_decl_minimal_tree_pointers (struct output_block *ob, tree expr,\n     stream_write_tree (ob, NULL_TREE, ref_p);\n   else\n     stream_write_tree (ob, DECL_NAME (expr), ref_p);\n-  stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n+  if (TREE_CODE (expr) != TRANSLATION_UNIT_DECL\n+      && ! DECL_CONTEXT (expr))\n+    stream_write_tree (ob, (*all_translation_units)[0], ref_p);\n+  else\n+    stream_write_tree (ob, DECL_CONTEXT (expr), ref_p);\n }\n \n \n@@ -585,10 +589,7 @@ write_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n      special handling in LTO, it must be handled by streamer hooks.  */\n \n   stream_write_tree (ob, DECL_ATTRIBUTES (expr), ref_p);\n-\n-  /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n-     for early inlining so drop it on the floor instead of ICEing in\n-     dwarf2out.c.  */\n+  stream_write_tree (ob, DECL_ABSTRACT_ORIGIN (expr), ref_p);\n \n   if ((VAR_P (expr) || TREE_CODE (expr) == PARM_DECL)\n       && DECL_HAS_VALUE_EXPR_P (expr))"}, {"sha": "07523a69956b093be67548e7be981b436b564809", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -5662,6 +5662,10 @@ free_lang_data (void)\n       || (!flag_generate_lto && !flag_generate_offload))\n     return 0;\n \n+  /* Provide a dummy TRANSLATION_UNIT_DECL if the FE failed to provide one.  */\n+  if (vec_safe_is_empty (all_translation_units))\n+    build_translation_unit_decl (NULL_TREE);\n+\n   /* Allocate and assign alias sets to the standard integer types\n      while the slots are still in the way the frontends generated them.  */\n   for (i = 0; i < itk_none; ++i)\n@@ -8598,8 +8602,16 @@ variably_modified_type_p (tree type, tree fn)\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case VECTOR_TYPE:\n+      /* Ada can have pointer types refering to themselves indirectly.  */\n+      if (TREE_VISITED (type))\n+\treturn false;\n+      TREE_VISITED (type) = true;\n       if (variably_modified_type_p (TREE_TYPE (type), fn))\n-\treturn true;\n+\t{\n+\t  TREE_VISITED (type) = false;\n+\t  return true;\n+\t}\n+      TREE_VISITED (type) = false;\n       break;\n \n     case FUNCTION_TYPE:"}, {"sha": "580dd2840162ae7c599e4ea9a17d59bef9bda46c", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -198,6 +198,8 @@ const struct gcc_debug_hooks vmsdbg_debug_hooks\n    vmsdbgout_late_global_decl,\n    vmsdbgout_type_decl,\t\t  /* type_decl */\n    debug_nothing_tree_tree_tree_bool_bool, /* imported_module_or_decl */\n+   debug_false_tree_charstarstar_uhwistar, /* die_ref_for_decl */\n+   debug_nothing_tree_charstar_uhwi, /* register_external_die */\n    debug_nothing_tree,\t\t  /* deferred_inline_function */\n    vmsdbgout_abstract_function,\n    debug_nothing_rtx_code_label,  /* label */"}, {"sha": "2171290e4b80ab6b1bf3a1d1df120f6bc13c1f41", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,8 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* simple-object.h (simple_object_copy_lto_debug_sections): New\n+\tfunction.\n+\n 2017-07-02  Jan Kratochvil  <jan.kratochvil@redhat.com>\n \n \t* dwarf2.def (DW_IDX_compile_unit, DW_IDX_type_unit, DW_IDX_die_offset)"}, {"sha": "f1bf88ba998520d98ca32ccbd37133bb4774b6d1", "filename": "include/simple-object.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/include%2Fsimple-object.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/include%2Fsimple-object.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsimple-object.h?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -197,6 +197,14 @@ simple_object_write_to_file (simple_object_write *simple_object,\n extern void\n simple_object_release_write (simple_object_write *);\n \n+/* Copy LTO debug sections from SRC_OBJECT to DEST.\n+   If an error occurs, return the errno value in ERR and an error string.  */\n+\n+extern const char *\n+simple_object_copy_lto_debug_sections (simple_object_read *src_object,\n+\t\t\t\t       const char *dest,\n+\t\t\t\t       int *err);\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "48ee098f3d70670984a88486fa41f0ded4f882a2", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,36 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* simple-object-common.h (struct simple_object_functions): Add\n+\tcopy_lto_debug_sections hook.\n+\t* simple-object.c: Include fcntl.h.\n+\t(handle_lto_debug_sections): New helper function.\n+\t(simple_object_copy_lto_debug_sections): New function copying\n+\tearly LTO debug sections to regular debug sections in a new file.\n+\t(simple_object_start_write): Handle NULL segment_name.\n+\t* simple-object-coff.c (simple_object_coff_functions): Adjust\n+\tfor not implemented copy_lto_debug_sections hook.\n+\t* simple-object-mach-o.c (simple_object_mach_o_functions): Likewise.\n+\t* simple-object-xcoff.c (simple_object_xcoff_functions): Likewise.\n+\t* simple-object-elf.c (SHT_NULL, SHT_SYMTAB, SHT_RELA, SHT_REL,\n+\tSHT_GROUP): Add various sectopn header types.\n+\t(SHF_EXCLUDE): Add flag.\n+\t(Elf32_External_Sym, Elf64_External_Sym): Add symbol struct.\n+\t(ELF_ST_BIND, ELF_ST_TYPE, ELF_ST_INFO): Add accessors.\n+\t(STT_OBJECT, STT_FUNC, STT_TLS, STT_GNU_IFUNC): Add Symbol types.\n+\t(STV_DEFAULT): Add symbol visibility.\n+\t(SHN_COMMON): Add special section index name.\n+\t(struct simple_object_elf_write): New.\n+\t(simple_object_elf_start_write): Adjust for new private data.\n+\t(simple_object_elf_write_shdr): Pass in values for all fields\n+\twe write.\n+\t(simple_object_elf_write_to_file): Adjust.  Copy from recorded\n+\tsection headers if requested.\n+\t(simple_object_elf_release_write): Release private data.\n+\t(simple_object_elf_copy_lto_debug_sections): Copy and rename sections\n+\tas denoted by PFN and all their dependences, symbols and relocations\n+\tto the empty destination file.\n+\t(simple_object_elf_functions): Adjust for copy_lto_debug_sections hook.\n+\n 2017-07-02  Jan Kratochvil  <jan.kratochvil@redhat.com>\n \n \t* dwarfnames.c (DW_FIRST_IDX, DW_END_IDX, DW_IDX, DW_IDX_DUP): New."}, {"sha": "54d430dad9b65c73e0d13a9cc2f3cc098498d81d", "filename": "libiberty/simple-object-coff.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-coff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-coff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-coff.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -800,5 +800,6 @@ const struct simple_object_functions simple_object_coff_functions =\n   simple_object_coff_release_attributes,\n   simple_object_coff_start_write,\n   simple_object_coff_write_to_file,\n-  simple_object_coff_release_write\n+  simple_object_coff_release_write,\n+  NULL\n };"}, {"sha": "733bdd0e7b6341dcdc666fd9b7b9b37ab6bfe39e", "filename": "libiberty/simple-object-common.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-common.h?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -141,6 +141,12 @@ struct simple_object_functions\n \n   /* Release the private data for an simple_object_write.  */\n   void (*release_write) (void *);\n+\n+  /* Copy LTO debug sections.  */\n+  const char *(*copy_lto_debug_sections) (simple_object_read *sobj,\n+\t\t\t\t\t  simple_object_write *dobj,\n+\t\t\t\t\t  int (*pfn) (const char **),\n+\t\t\t\t\t  int *err);\n };\n \n /* The known object file formats.  */"}, {"sha": "56336264ce92181dd217680c6e865e44c84291fc", "filename": "libiberty/simple-object-elf.c", "status": "modified", "additions": 465, "deletions": 17, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-elf.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -122,9 +122,12 @@ typedef struct {\n \n /* Special section index values.  */\n \n+#define SHN_UNDEF\t0\t\t/* Undefined section */\n #define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n+#define SHN_COMMON\t0xFFF2\t/* Associated symbol is in common */\n #define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n \n+\n /* 32-bit ELF program header.  */\n \n typedef struct {\n@@ -183,8 +186,57 @@ typedef struct {\n \n /* Values for sh_type field.  */\n \n+#define SHT_NULL\t0\t\t/* Section header table entry unused */\n #define SHT_PROGBITS\t1\t\t/* Program data */\n+#define SHT_SYMTAB\t2\t\t/* Link editing symbol table */\n #define SHT_STRTAB\t3\t\t/* A string table */\n+#define SHT_RELA\t4\t\t/* Relocation entries with addends */\n+#define SHT_REL\t\t9\t\t/* Relocation entries, no addends */\n+#define SHT_GROUP\t17\t\t/* Section contains a section group */\n+\n+/* Values for sh_flags field.  */\n+\n+#define SHF_EXCLUDE\t0x80000000\t/* Link editor is to exclude this\n+\t\t\t\t\t   section from executable and\n+\t\t\t\t\t   shared library that it builds\n+\t\t\t\t\t   when those objects are not to be\n+\t\t\t\t\t   further relocated.  */\n+/* Symbol table entry.  */\n+\n+typedef struct\n+{\n+  unsigned char st_name[4];                /* Symbol name (string tbl index) */\n+  unsigned char st_value[4];               /* Symbol value */\n+  unsigned char st_size[4];                /* Symbol size */\n+  unsigned char st_info;                /* Symbol type and binding */\n+  unsigned char st_other;               /* Symbol visibility */\n+  unsigned char st_shndx[2];               /* Section index */\n+} Elf32_External_Sym;\n+\n+typedef struct\n+{\n+  unsigned char st_name[4];                /* Symbol name (string tbl index) */\n+  unsigned char st_info;                /* Symbol type and binding */\n+  unsigned char st_other;               /* Symbol visibility */\n+  unsigned char st_shndx[2];               /* Section index */\n+  unsigned char st_value[8];               /* Symbol value */\n+  unsigned char st_size[8];                /* Symbol size */\n+} Elf64_External_Sym;\n+\n+#define ELF_ST_BIND(val)              (((unsigned char) (val)) >> 4)\n+#define ELF_ST_TYPE(val)              ((val) & 0xf)\n+#define ELF_ST_INFO(bind, type)       (((bind) << 4) + ((type) & 0xf))\n+\n+#define STT_NOTYPE\t0\t/* Symbol type is unspecified */\n+#define STT_OBJECT\t1\t/* Symbol is a data object */\n+#define STT_FUNC\t2\t/* Symbol is a code object */\n+#define STT_TLS\t\t6\t/* Thread local data object */\n+#define STT_GNU_IFUNC\t10\t/* Symbol is an indirect code object */\n+\n+#define STB_LOCAL\t0\t/* Local symbol */\n+#define STB_GLOBAL\t1\t/* Global symbol */\n+\n+#define STV_DEFAULT\t0\t/* Visibility is specified by binding type */\n \n /* Functions to fetch and store different ELF types, depending on the\n    endianness and size.  */\n@@ -348,6 +400,14 @@ struct simple_object_elf_attributes\n   unsigned int flags;\n };\n \n+/* Private data for an simple_object_write.  */\n+\n+struct simple_object_elf_write\n+{\n+  struct simple_object_elf_attributes attrs;\n+  unsigned char *shdrs;\n+};\n+\n /* See if we have an ELF file.  */\n \n static void *\n@@ -675,12 +735,13 @@ simple_object_elf_start_write (void *attributes_data,\n {\n   struct simple_object_elf_attributes *attrs =\n     (struct simple_object_elf_attributes *) attributes_data;\n-  struct simple_object_elf_attributes *ret;\n+  struct simple_object_elf_write *ret;\n \n   /* We're just going to record the attributes, but we need to make a\n      copy because the user may delete them.  */\n-  ret = XNEW (struct simple_object_elf_attributes);\n-  *ret = *attrs;\n+  ret = XNEW (struct simple_object_elf_write);\n+  ret->attrs = *attrs;\n+  ret->shdrs = NULL;\n   return ret;\n }\n \n@@ -766,8 +827,11 @@ static int\n simple_object_elf_write_shdr (simple_object_write *sobj, int descriptor,\n \t\t\t      off_t offset, unsigned int sh_name,\n \t\t\t      unsigned int sh_type, unsigned int sh_flags,\n+\t\t\t      off_t sh_addr,\n \t\t\t      unsigned int sh_offset, unsigned int sh_size,\n-\t\t\t      unsigned int sh_link, unsigned int sh_addralign,\n+\t\t\t      unsigned int sh_link, unsigned int sh_info,\n+\t\t\t      unsigned int sh_addralign,\n+\t\t\t      unsigned int sh_entsize,\n \t\t\t      const char **errmsg, int *err)\n {\n   struct simple_object_elf_attributes *attrs =\n@@ -788,12 +852,13 @@ simple_object_elf_write_shdr (simple_object_write *sobj, int descriptor,\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_name, Elf_Word, sh_name);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_type, Elf_Word, sh_type);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_flags, Elf_Addr, sh_flags);\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_addr, Elf_Addr, sh_addr);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_offset, Elf_Addr, sh_offset);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_size, Elf_Addr, sh_size);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_link, Elf_Word, sh_link);\n-  /* sh_info left as zero.  */\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_info, Elf_Word, sh_info);\n   ELF_SET_FIELD (fns, cl, Shdr, buf, sh_addralign, Elf_Addr, sh_addralign);\n-  /* sh_entsize left as zero.  */\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_entsize, Elf_Word, sh_entsize);\n \n   return simple_object_internal_write (descriptor, offset, buf, shdr_size,\n \t\t\t\t       errmsg, err);\n@@ -811,8 +876,9 @@ static const char *\n simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n \t\t\t\t int *err)\n {\n-  struct simple_object_elf_attributes *attrs =\n-    (struct simple_object_elf_attributes *) sobj->data;\n+  struct simple_object_elf_write *eow =\n+    (struct simple_object_elf_write *) sobj->data;\n+  struct simple_object_elf_attributes *attrs = &eow->attrs;\n   unsigned char cl;\n   size_t ehdr_size;\n   size_t shdr_size;\n@@ -825,6 +891,7 @@ simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n   unsigned int first_sh_link;\n   size_t sh_name;\n   unsigned char zero;\n+  unsigned secnum;\n \n   if (!simple_object_elf_write_ehdr (sobj, descriptor, &errmsg, err))\n     return errmsg;\n@@ -862,21 +929,54 @@ simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n   else\n     first_sh_link = shnum - 1;\n   if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n-\t\t\t\t     0, 0, 0, 0, first_sh_size, first_sh_link,\n-\t\t\t\t     0, &errmsg, err))\n+\t\t\t\t     0, 0, 0, 0, 0, first_sh_size, first_sh_link,\n+\t\t\t\t     0, 0, 0, &errmsg, err))\n     return errmsg;\n \n   shdr_offset += shdr_size;\n \n   sh_name = 1;\n+  secnum = 0;\n   for (section = sobj->sections; section != NULL; section = section->next)\n     {\n       size_t mask;\n       size_t new_sh_offset;\n       size_t sh_size;\n       struct simple_object_write_section_buffer *buffer;\n+      unsigned int sh_type = SHT_PROGBITS;\n+      unsigned int sh_flags = 0;\n+      off_t sh_addr = 0;\n+      unsigned int sh_link = 0;\n+      unsigned int sh_info = 0;\n+      unsigned int sh_addralign = 1U << section->align;\n+      unsigned int sh_entsize = 0;\n+      if (eow->shdrs)\n+\t{\n+\t  sh_type = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t     eow->shdrs + secnum * shdr_size,\n+\t\t\t\t     sh_type, Elf_Word);\n+\t  sh_flags = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t      eow->shdrs + secnum * shdr_size,\n+\t\t\t\t      sh_flags, Elf_Addr);\n+\t  sh_addr = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t     eow->shdrs + secnum * shdr_size,\n+\t\t\t\t     sh_addr, Elf_Addr);\n+\t  sh_link = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t     eow->shdrs + secnum * shdr_size,\n+\t\t\t\t     sh_link, Elf_Word);\n+\t  sh_info = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t     eow->shdrs + secnum * shdr_size,\n+\t\t\t\t     sh_info, Elf_Word);\n+\t  sh_addralign = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t\t  eow->shdrs + secnum * shdr_size,\n+\t\t\t\t\t  sh_addralign, Elf_Addr);\n+\t  sh_entsize = ELF_FETCH_FIELD (attrs->type_functions, attrs->ei_class, Shdr,\n+\t\t\t\t\teow->shdrs + secnum * shdr_size,\n+\t\t\t\t\tsh_entsize, Elf_Word);\n+\t  secnum++;\n+\t}\n \n-      mask = (1U << section->align) - 1;\n+      mask = sh_addralign - 1;\n       new_sh_offset = sh_offset + mask;\n       new_sh_offset &= ~ mask;\n       while (new_sh_offset > sh_offset)\n@@ -906,8 +1006,10 @@ simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n \t}\n \n       if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n-\t\t\t\t\t sh_name, SHT_PROGBITS, 0, sh_offset,\n-\t\t\t\t\t sh_size, 0, 1U << section->align,\n+\t\t\t\t\t sh_name, sh_type, sh_flags,\n+\t\t\t\t\t sh_addr, sh_offset,\n+\t\t\t\t\t sh_size, sh_link, sh_info,\n+\t\t\t\t\t sh_addralign, sh_entsize,\n \t\t\t\t\t &errmsg, err))\n \treturn errmsg;\n \n@@ -917,9 +1019,9 @@ simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n     }\n \n   if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n-\t\t\t\t     sh_name, SHT_STRTAB, 0, sh_offset,\n-\t\t\t\t     sh_name + strlen (\".shstrtab\") + 1, 0,\n-\t\t\t\t     1, &errmsg, err))\n+\t\t\t\t     sh_name, SHT_STRTAB, 0, 0, sh_offset,\n+\t\t\t\t     sh_name + strlen (\".shstrtab\") + 1, 0, 0,\n+\t\t\t\t     1, 0, &errmsg, err))\n     return errmsg;\n \n   /* .shstrtab has a leading zero byte.  */\n@@ -954,9 +1056,354 @@ simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n static void\n simple_object_elf_release_write (void *data)\n {\n+  struct simple_object_elf_write *eow = (struct simple_object_elf_write *) data;\n+  if (eow->shdrs)\n+    XDELETE (eow->shdrs);\n   XDELETE (data);\n }\n \n+/* Copy all sections in an ELF file.  */\n+\n+static const char *\n+simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n+\t\t\t\t\t   simple_object_write *dobj,\n+\t\t\t\t\t   int (*pfn) (const char **),\n+\t\t\t\t\t   int *err)\n+{\n+  struct simple_object_elf_read *eor =\n+    (struct simple_object_elf_read *) sobj->data;\n+  const struct elf_type_functions *type_functions = eor->type_functions;\n+  struct simple_object_elf_write *eow =\n+    (struct simple_object_elf_write *) dobj->data;\n+  unsigned char ei_class = eor->ei_class;\n+  size_t shdr_size;\n+  unsigned int shnum;\n+  unsigned char *shdrs;\n+  const char *errmsg;\n+  unsigned char *shstrhdr;\n+  size_t name_size;\n+  off_t shstroff;\n+  unsigned char *names;\n+  unsigned int i;\n+  int *pfnret;\n+  const char **pfnname;\n+\n+  shdr_size = (ei_class == ELFCLASS32\n+\t       ? sizeof (Elf32_External_Shdr)\n+\t       : sizeof (Elf64_External_Shdr));\n+\n+  /* Read the section headers.  We skip section 0, which is not a\n+     useful section.  */\n+\n+  shnum = eor->shnum;\n+  shdrs = XNEWVEC (unsigned char, shdr_size * (shnum - 1));\n+\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + eor->shoff + shdr_size,\n+\t\t\t\t    shdrs,\n+\t\t\t\t    shdr_size * (shnum - 1),\n+\t\t\t\t    &errmsg, err))\n+    {\n+      XDELETEVEC (shdrs);\n+      return errmsg;\n+    }\n+\n+  /* Read the section names.  */\n+\n+  shstrhdr = shdrs + (eor->shstrndx - 1) * shdr_size;\n+  name_size = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t       shstrhdr, sh_size, Elf_Addr);\n+  shstroff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t      shstrhdr, sh_offset, Elf_Addr);\n+  names = XNEWVEC (unsigned char, name_size);\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + shstroff,\n+\t\t\t\t    names, name_size, &errmsg, err))\n+    {\n+      XDELETEVEC (names);\n+      XDELETEVEC (shdrs);\n+      return errmsg;\n+    }\n+\n+  eow->shdrs = XNEWVEC (unsigned char, shdr_size * (shnum - 1));\n+  pfnret = XNEWVEC (int, shnum);\n+  pfnname = XNEWVEC (const char *, shnum);\n+\n+  /* First perform the callbacks to know which sections to preserve and\n+     what name to use for those.  */\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      unsigned char *shdr;\n+      unsigned int sh_name;\n+      const char *name;\n+      int ret;\n+\n+      shdr = shdrs + (i - 1) * shdr_size;\n+      sh_name = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_name, Elf_Word);\n+      if (sh_name >= name_size)\n+\t{\n+\t  *err = 0;\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  return \"ELF section name out of range\";\n+\t}\n+\n+      name = (const char *) names + sh_name;\n+\n+      ret = (*pfn) (&name);\n+      pfnret[i - 1] = ret == 1 ? 0 : -1;\n+      pfnname[i - 1] = name;\n+    }\n+\n+  /* Mark sections as preserved that are required by to be preserved\n+     sections.  */\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      unsigned char *shdr;\n+      unsigned int sh_type, sh_info, sh_link;\n+      off_t offset;\n+      off_t length;\n+\n+      shdr = shdrs + (i - 1) * shdr_size;\n+      sh_type = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_type, Elf_Word);\n+      sh_info = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_info, Elf_Word);\n+      sh_link = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_link, Elf_Word);\n+      if (sh_type == SHT_GROUP)\n+\t{\n+\t  /* Mark groups containing copied sections.  */\n+\t  unsigned entsize = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t      shdr, sh_entsize, Elf_Addr);\n+\t  unsigned char *ent, *buf;\n+\t  int keep = 0;\n+\t  offset = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t    shdr, sh_offset, Elf_Addr);\n+\t  length = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t    shdr, sh_size, Elf_Addr);\n+\t  buf = XNEWVEC (unsigned char, length);\n+\t  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\t    sobj->offset + offset, buf,\n+\t\t\t\t\t    (size_t) length, &errmsg, err))\n+\t    {\n+\t      XDELETEVEC (buf);\n+\t      XDELETEVEC (names);\n+\t      XDELETEVEC (shdrs);\n+\t      return errmsg;\n+\t    }\n+\t  for (ent = buf + entsize; ent < buf + length; ent += entsize)\n+\t    {\n+\t      unsigned sec = type_functions->fetch_Elf_Word (ent);\n+\t      if (pfnret[sec - 1] == 0)\n+\t\tkeep = 1;\n+\t    }\n+\t  if (keep)\n+\t    {\n+\t      pfnret[sh_link - 1] = 0;\n+\t      pfnret[i - 1] = 0;\n+\t    }\n+\t}\n+      if (sh_type == SHT_RELA\n+\t  || sh_type == SHT_REL)\n+\t{\n+\t  /* Mark relocation sections and symtab of copied sections.  */\n+\t  if (pfnret[sh_info - 1] == 0)\n+\t    {\n+\t      pfnret[sh_link - 1] = 0;\n+\t      pfnret[i - 1] = 0;\n+\t    }\n+\t}\n+      if (sh_type == SHT_SYMTAB)\n+\t{\n+\t  /* Mark strings sections of copied symtabs.  */\n+\t  if (pfnret[i - 1] == 0)\n+\t    pfnret[sh_link - 1] = 0;\n+\t}\n+    }\n+\n+  /* Then perform the actual copying.  */\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      unsigned char *shdr;\n+      unsigned int sh_name, sh_type;\n+      const char *name;\n+      off_t offset;\n+      off_t length;\n+      int ret;\n+      const char *errmsg;\n+      simple_object_write_section *dest;\n+      off_t flags;\n+      unsigned char *buf;\n+\n+      shdr = shdrs + (i - 1) * shdr_size;\n+      sh_name = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_name, Elf_Word);\n+      if (sh_name >= name_size)\n+\t{\n+\t  *err = 0;\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  return \"ELF section name out of range\";\n+\t}\n+\n+      name = (const char *) names + sh_name;\n+      offset = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\tshdr, sh_offset, Elf_Addr);\n+      length = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\tshdr, sh_size, Elf_Addr);\n+      sh_type = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_type, Elf_Word);\n+\n+      ret = pfnret[i - 1];\n+      name = ret == 0 ? pfnname[i - 1] : \"\";\n+\n+      dest = simple_object_write_create_section (dobj, name, 0, &errmsg, err);\n+      if (dest == NULL)\n+\t{\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  return errmsg;\n+\t}\n+\n+      /* Record the SHDR of the source.  */\n+      memcpy (eow->shdrs + (i - 1) * shdr_size, shdr, shdr_size);\n+      shdr = eow->shdrs + (i - 1) * shdr_size;\n+\n+      /* Copy the data.\n+\t ???  This is quite wasteful and ideally would be delayed until\n+\t write_to_file ().  Thus it questions the interfacing\n+\t which eventually should contain destination creation plus\n+\t writing.  */\n+      /* Keep empty sections for sections we should discard.  This avoids\n+         the need to rewrite section indices in symtab and relocation\n+\t sections.  */\n+      if (ret == 0)\n+\t{\n+\t  buf = XNEWVEC (unsigned char, length);\n+\t  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\t    sobj->offset + offset, buf,\n+\t\t\t\t\t    (size_t) length, &errmsg, err))\n+\t    {\n+\t      XDELETEVEC (buf);\n+\t      XDELETEVEC (names);\n+\t      XDELETEVEC (shdrs);\n+\t      return errmsg;\n+\t    }\n+\n+\t  /* If we are processing .symtab purge __gnu_lto_v1 and\n+\t     __gnu_lto_slim symbols from it.  */\n+\t  if (sh_type == SHT_SYMTAB)\n+\t    {\n+\t      unsigned entsize = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t\t  shdr, sh_entsize, Elf_Addr);\n+\t      unsigned strtab = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t\t shdr, sh_link, Elf_Word);\n+\t      unsigned char *strshdr = shdrs + (strtab - 1) * shdr_size;\n+\t      off_t stroff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t      strshdr, sh_offset, Elf_Addr);\n+\t      size_t strsz = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t      strshdr, sh_size, Elf_Addr);\n+\t      char *strings = XNEWVEC (char, strsz);\n+\t      unsigned char *ent;\n+\t      simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\t   sobj->offset + stroff,\n+\t\t\t\t\t   (unsigned char *)strings,\n+\t\t\t\t\t   strsz, &errmsg, err);\n+\t      for (ent = buf; ent < buf + length; ent += entsize)\n+\t\t{\n+\t\t  unsigned st_shndx = ELF_FETCH_FIELD (type_functions, ei_class,\n+\t\t\t\t\t\t       Sym, ent,\n+\t\t\t\t\t\t       st_shndx, Elf_Half);\n+\t\t  unsigned char *st_info;\n+\t\t  unsigned char *st_other;\n+\t\t  int discard = 0;\n+\t\t  if (ei_class == ELFCLASS32)\n+\t\t    {\n+\t\t      st_info = &((Elf32_External_Sym *)ent)->st_info;\n+\t\t      st_other = &((Elf32_External_Sym *)ent)->st_other;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      st_info = &((Elf64_External_Sym *)ent)->st_info;\n+\t\t      st_other = &((Elf64_External_Sym *)ent)->st_other;\n+\t\t    }\n+\t\t  /* Eliminate all COMMONs - this includes __gnu_lto_v1\n+\t\t     and __gnu_lto_slim which otherwise cause endless\n+\t\t     LTO plugin invocation.  */\n+\t\t  if (st_shndx == SHN_COMMON)\n+\t\t    /* Setting st_name to \"\" seems to work to purge\n+\t\t       COMMON symbols (in addition to setting their\n+\t\t       size to zero).  */\n+\t\t    discard = 1;\n+\t\t  /* We also need to remove symbols refering to sections\n+\t\t     we'll eventually remove as with fat LTO objects\n+\t\t     we otherwise get duplicate symbols at final link\n+\t\t     (with GNU ld, gold is fine and ignores symbols in\n+\t\t     sections marked as EXCLUDE).  ld/20513  */\n+\t\t  else if (st_shndx != SHN_UNDEF\n+\t\t\t   && st_shndx < shnum\n+\t\t\t   && pfnret[st_shndx - 1] == -1)\n+\t\t    discard = 1;\n+\n+\t\t  if (discard)\n+\t\t    {\n+\t\t      /* Make discarded symbols undefined and unnamed.  */\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_name, Elf_Word, 0);\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_value, Elf_Addr, 0);\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_size, Elf_Word, 0);\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_shndx, Elf_Half, SHN_UNDEF);\n+\t\t      *st_info = ELF_ST_INFO (ELF_ST_BIND (*st_info),\n+\t\t\t\t\t      STT_NOTYPE);\n+\t\t      *st_other = STV_DEFAULT;\n+\t\t    }\n+\t\t}\n+\t      XDELETEVEC (strings);\n+\t    }\n+\n+\t  errmsg = simple_object_write_add_data (dobj, dest,\n+\t\t\t\t\t\t buf, length, 1, err);\n+\t  XDELETEVEC (buf);\n+\t  if (errmsg)\n+\t    {\n+\t      XDELETEVEC (names);\n+\t      XDELETEVEC (shdrs);\n+\t      return errmsg;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* For deleted sections mark the section header table entry as\n+\t     unused.  That allows the link editor to remove it in a partial\n+\t     link.  */\n+\t  ELF_SET_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t shdr, sh_type, Elf_Addr, SHT_NULL);\n+\t}\n+\n+      flags = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t       shdr, sh_flags, Elf_Addr);\n+      if (ret == 0)\n+\tflags &= ~SHF_EXCLUDE;\n+      else if (ret == -1)\n+\tflags |= SHF_EXCLUDE;\n+      ELF_SET_FIELD (type_functions, ei_class, Shdr,\n+\t\t     shdr, sh_flags, Elf_Addr, flags);\n+    }\n+\n+  XDELETEVEC (names);\n+  XDELETEVEC (shdrs);\n+  XDELETEVEC (pfnret);\n+  XDELETEVEC (pfnname);\n+\n+  return NULL;\n+}\n+\n+\n /* The ELF functions.  */\n \n const struct simple_object_functions simple_object_elf_functions =\n@@ -969,5 +1416,6 @@ const struct simple_object_functions simple_object_elf_functions =\n   simple_object_elf_release_attributes,\n   simple_object_elf_start_write,\n   simple_object_elf_write_to_file,\n-  simple_object_elf_release_write\n+  simple_object_elf_release_write,\n+  simple_object_elf_copy_lto_debug_sections\n };"}, {"sha": "b90fca88b2368d27191be5618e312bda645033a9", "filename": "libiberty/simple-object-mach-o.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-mach-o.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-mach-o.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-mach-o.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1374,5 +1374,6 @@ const struct simple_object_functions simple_object_mach_o_functions =\n   simple_object_mach_o_release_attributes,\n   simple_object_mach_o_start_write,\n   simple_object_mach_o_write_to_file,\n-  simple_object_mach_o_release_write\n+  simple_object_mach_o_release_write,\n+  NULL\n };"}, {"sha": "2adebe37107f68180a9ca649377513786ecd1694", "filename": "libiberty/simple-object-xcoff.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-xcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object-xcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-xcoff.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1006,5 +1006,6 @@ const struct simple_object_functions simple_object_xcoff_functions =\n   simple_object_xcoff_release_attributes,\n   simple_object_xcoff_start_write,\n   simple_object_xcoff_write_to_file,\n-  simple_object_xcoff_release_write\n+  simple_object_xcoff_release_write,\n+  NULL\n };"}, {"sha": "553e90f50480bc8af2b3cb95d2338630bac117e2", "filename": "libiberty/simple-object.c", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libiberty%2Fsimple-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.c?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"simple-object.h\"\n \n #include <errno.h>\n+#include <fcntl.h>\n \n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n@@ -249,6 +250,86 @@ simple_object_find_section (simple_object_read *sobj, const char *name,\n   return 1;\n }\n \n+/* Callback to identify and rename LTO debug sections by name.\n+   Returns 1 if NAME is a LTO debug section, 0 if not.  */\n+\n+static int\n+handle_lto_debug_sections (const char **name)\n+{\n+  /* ???  So we can't use .gnu.lto_ prefixed sections as the assembler\n+     complains about bogus section flags.  Which means we need to arrange\n+     for that to be fixed or .gnu.debuglto_ marked as SHF_EXCLUDE (to make\n+     fat lto object tooling work for the fat part).  */\n+  /* ???  For now this handles both .gnu.lto_ and .gnu.debuglto_ prefixed\n+     sections.  */\n+  /* Copy LTO debug sections and rename them to their non-LTO name.  */\n+  if (strncmp (*name, \".gnu.debuglto_\", sizeof (\".gnu.debuglto_\") - 1) == 0)\n+    {\n+      *name = *name + sizeof (\".gnu.debuglto_\") - 1;\n+      return 1;\n+    }\n+  else if (strncmp (*name, \".gnu.lto_.debug_\", sizeof (\".gnu.lto_.debug_\") -1) == 0)\n+    {\n+      *name = *name + sizeof (\".gnu.lto_\") - 1;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Copy LTO debug sections.  */\n+\n+const char *\n+simple_object_copy_lto_debug_sections (simple_object_read *sobj,\n+\t\t\t\t       const char *dest, int *err)\n+{\n+  const char *errmsg;\n+  simple_object_write *dest_sobj;\n+  simple_object_attributes *attrs;\n+  int outfd;\n+\n+  if (! sobj->functions->copy_lto_debug_sections)\n+    {\n+      *err = EINVAL;\n+      return \"simple_object_copy_lto_debug_sections not implemented\";\n+    }\n+\n+  attrs = simple_object_fetch_attributes (sobj, &errmsg, err);\n+  if (! attrs)\n+    return errmsg;\n+  dest_sobj = simple_object_start_write (attrs, NULL, &errmsg, err);\n+  simple_object_release_attributes (attrs);\n+  if (! dest_sobj)\n+    return errmsg;\n+\n+  errmsg = sobj->functions->copy_lto_debug_sections (sobj, dest_sobj,\n+\t\t\t\t\t\t     handle_lto_debug_sections,\n+\t\t\t\t\t\t     err);\n+  if (errmsg)\n+    {\n+      simple_object_release_write (dest_sobj);\n+      return errmsg;\n+    }\n+\n+  outfd = creat (dest, 00777);\n+  if (outfd == -1)\n+    {\n+      *err = errno;\n+      simple_object_release_write (dest_sobj);\n+      return \"open failed\";\n+    }\n+\n+  errmsg = simple_object_write_to_file (dest_sobj, outfd, err);\n+  close (outfd);\n+  if (errmsg)\n+    {\n+      simple_object_release_write (dest_sobj);\n+      return errmsg;\n+    }\n+\n+  simple_object_release_write (dest_sobj);\n+  return NULL;\n+}\n+\n /* Fetch attributes.  */\n \n simple_object_attributes *\n@@ -315,7 +396,7 @@ simple_object_start_write (simple_object_attributes *attrs,\n     return NULL;\n   ret = XNEW (simple_object_write);\n   ret->functions = attrs->functions;\n-  ret->segment_name = xstrdup (segment_name);\n+  ret->segment_name = segment_name ? xstrdup (segment_name) : NULL;\n   ret->sections = NULL;\n   ret->last_section = NULL;\n   ret->data = data;"}, {"sha": "9f5bfa0db6eb8d2ef1963b4f6504c4af28af7126", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -1,3 +1,8 @@\n+2017-08-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* testsuite/libstdc++-prettyprinters/prettyprinters.exp: Run all\n+\ttests with -flto as well if supported.\n+\n 2017-08-20  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81854"}, {"sha": "5232e983ab45777bc1d5a08fe3c531586a18e2ae", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/prettyprinters.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fprettyprinters.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ea85365b430b5ade1d0b824e5406c006e6ffdb7/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fprettyprinters.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2Fprettyprinters.exp?ref=1ea85365b430b5ade1d0b824e5406c006e6ffdb7", "patch": "@@ -15,6 +15,7 @@\n # <http://www.gnu.org/licenses/>.\n \n load_lib gdb-test.exp\n+load_lib target-supports.exp\n \n dg-init\n v3-build_support\n@@ -46,6 +47,14 @@ global PCH_CXXFLAGS\n gdb-dg-runtest [lsort [glob $srcdir/$subdir/*.cc]] \\\n   \"\" \"$DEFAULT_CXXFLAGS $PCH_CXXFLAGS\"\n \n+if { [check_effective_target_lto] } {\n+  append cxxflags \" -flto\"\n+  # work around sourceware.org 20882\n+  regsub {^(.*)-Wl,--gc-sections(.*)$} $cxxldflags {\\1\\2} cxxldflags\n+  gdb-dg-runtest [lsort [glob $srcdir/$subdir/*.cc]] \\\n+    \"\" \"$DEFAULT_CXXFLAGS -flto $PCH_CXXFLAGS\"\n+}\n+\n if [info exists guality_gdb_name] {\n     unsetenv GUALITY_GDB_NAME\n }"}]}