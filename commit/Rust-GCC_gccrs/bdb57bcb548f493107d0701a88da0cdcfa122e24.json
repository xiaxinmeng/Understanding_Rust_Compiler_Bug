{"sha": "bdb57bcb548f493107d0701a88da0cdcfa122e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiNTdiY2I1NDhmNDkzMTA3ZDA3MDFhODhkYTBjZGNmYTEyMmUyNA==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2018-09-06T07:38:42Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-09-06T07:38:42Z"}, "message": "S/390: Prohibit SYMBOL_REF in UNSPECV_CAS\n\nInhibit constant propagation inlining SYMBOL_REF loads into\nUNSPECV_CAS.  Even though reload can later undo it, the resulting\ncode will be less efficient.\n\ngcc/ChangeLog:\n\n2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR target/80080\n\t* config/s390/predicates.md: Add nonsym_memory_operand.\n\t* config/s390/s390.c (s390_legitimize_cs_operand): If operand\n\tcontains a SYMBOL_REF, load it into an intermediate pseudo.\n\t(s390_emit_compare_and_swap): Legitimize operand.\n\t* config/s390/s390.md: Use the new nonsym_memory_operand\n\twith UNSPECV_CAS patterns.\n\ngcc/testsuite/ChangeLog:\n\n2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR target/80080\n\t* gcc.target/s390/pr80080-3.c: New test.\n\t* gcc.target/s390/s390.exp: Make sure the new test passes\n\ton all optimization levels.\n\nFrom-SVN: r264143", "tree": {"sha": "00482d32624436f3e7a7d7285ed9b6bb98de6bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00482d32624436f3e7a7d7285ed9b6bb98de6bf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb57bcb548f493107d0701a88da0cdcfa122e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb57bcb548f493107d0701a88da0cdcfa122e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb57bcb548f493107d0701a88da0cdcfa122e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb57bcb548f493107d0701a88da0cdcfa122e24/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d7252499463a4fe2c073d8a28c6c0c966e20755f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7252499463a4fe2c073d8a28c6c0c966e20755f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7252499463a4fe2c073d8a28c6c0c966e20755f"}], "stats": {"total": 70, "additions": 67, "deletions": 3}, "files": [{"sha": "0191555aa9033f9542738877c6041079bf51b4b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -1,3 +1,13 @@\n+2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR target/80080\n+\t* config/s390/predicates.md: Add nonsym_memory_operand.\n+\t* config/s390/s390.c (s390_legitimize_cs_operand): If operand\n+\tcontains a SYMBOL_REF, load it into an intermediate pseudo.\n+\t(s390_emit_compare_and_swap): Legitimize operand.\n+\t* config/s390/s390.md: Use the new nonsym_memory_operand\n+\twith UNSPECV_CAS patterns.\n+\n 2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/80080"}, {"sha": "98a824e77b7742096ea24ca3844d9c881984c196", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -534,3 +534,15 @@\n   unsigned HOST_WIDE_INT val = INTVAL (op);\n   return val <= 128 && val % 8 == 0;\n })\n+\n+;; Certain operations (e.g. CS) cannot access SYMBOL_REF directly, it needs to\n+;; be loaded into some register first.  In theory, if we put a SYMBOL_REF into\n+;; a corresponding insn anyway, reload will generate a load for it, but, when\n+;; coupled with constant propagation, this will lead to an inefficient code\n+;; (see PR 80080).\n+\n+(define_predicate \"nonsym_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  return memory_operand (op, mode) && !contains_symbol_ref_p (op);\n+})"}, {"sha": "541b032ac639df2043221793e3f497af660d82e5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -1825,6 +1825,21 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n   return gen_rtx_fmt_ee (code, VOIDmode, cc, const0_rtx);\n }\n \n+/* If MEM is not a legitimate compare-and-swap memory operand, return a new\n+   MEM, whose address is a pseudo containing the original MEM's address.  */\n+\n+static rtx\n+s390_legitimize_cs_operand (rtx mem)\n+{\n+  rtx tmp;\n+\n+  if (!contains_symbol_ref_p (mem))\n+    return mem;\n+  tmp = gen_reg_rtx (Pmode);\n+  emit_move_insn (tmp, copy_rtx (XEXP (mem, 0)));\n+  return change_address (mem, VOIDmode, tmp);\n+}\n+\n /* Emit a SImode compare and swap instruction setting MEM to NEW_RTX if OLD\n    matches CMP.\n    Return the correct condition RTL to be placed in the IF_THEN_ELSE of the\n@@ -1836,6 +1851,7 @@ s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n {\n   rtx cc;\n \n+  mem = s390_legitimize_cs_operand (mem);\n   cc = gen_rtx_REG (ccmode, CC_REGNUM);\n   switch (GET_MODE (mem))\n     {"}, {"sha": "ddf8608b2a2e6b2dce93feb341288f9ed1cf7dcf", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -10338,7 +10338,7 @@\n ; cdsg, csg\n (define_insn \"*atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:TDI 0 \"register_operand\" \"=r\")\n-\t(match_operand:TDI 1 \"memory_operand\" \"+S\"))\n+\t(match_operand:TDI 1 \"nonsym_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:TDI\n \t  [(match_dup 1)\n@@ -10356,7 +10356,7 @@\n ; cds, cdsy\n (define_insn \"*atomic_compare_and_swapdi_2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:DI 1 \"memory_operand\" \"+Q,S\"))\n+\t(match_operand:DI 1 \"nonsym_memory_operand\" \"+Q,S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:DI\n \t  [(match_dup 1)\n@@ -10377,7 +10377,7 @@\n ; cs, csy\n (define_insn \"*atomic_compare_and_swapsi_3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+Q,S\"))\n+\t(match_operand:SI 1 \"nonsym_memory_operand\" \"+Q,S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI\n \t  [(match_dup 1)"}, {"sha": "677cfcf32fb5a9cc5f05d02c9973fe49f625b9b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -1,3 +1,10 @@\n+2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR target/80080\n+\t* gcc.target/s390/pr80080-3.c: New test.\n+\t* gcc.target/s390/s390.exp: Make sure the new test passes\n+\ton all optimization levels.\n+\n 2018-09-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/86982, -Wreturn-local-addr and std::move and std::forward."}, {"sha": "9068b8d30c2f0305f4738dc94972d6e4e3523860", "filename": "gcc/testsuite/gcc.target/s390/pr80080-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr80080-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr80080-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr80080-3.c?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=z10\" } */\n+\n+extern int foo3_mem;\n+int foo3 (void)\n+{\n+  return __atomic_exchange_n (&foo3_mem, 5, __ATOMIC_ACQUIRE);\n+}\n+\n+/* { dg-final { scan-assembler \"\\n\\(\\\\.L\\\\d+):\\n\\tcs\\t.*\\n\\tjne\\t\\\\1\\n\" } } */"}, {"sha": "a9c428d65ced8c9b7b8b8986f9de9c30964181ee", "filename": "gcc/testsuite/gcc.target/s390/s390.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb57bcb548f493107d0701a88da0cdcfa122e24/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fs390.exp?ref=bdb57bcb548f493107d0701a88da0cdcfa122e24", "patch": "@@ -252,5 +252,14 @@ set-torture-options $MD_TEST_OPTS\n gcc-dg-runtest [lsort [glob -nocomplain $md_tests]] \"\" \"$DEFAULT_CFLAGS\"\n torture-finish\n \n+# Tests that should pass on all optimization levels.\n+foreach t [list $srcdir/$subdir/pr80080-3.c] {\n+\ttorture-init\n+\tset-torture-options [list -O1 -O2 -O3 -O0 -Os -Ofast -Og]\n+\tgcc-dg-runtest [list $t] \\\n+\t\t\"\" $DEFAULT_CFLAGS\n+\ttorture-finish\n+}\n+\n # All done.\n dg-finish"}]}