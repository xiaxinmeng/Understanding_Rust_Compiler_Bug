{"sha": "87ff9c8e4bb514b8298fcd6431339197de456c0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdmZjljOGU0YmI1MTRiODI5OGZjZDY0MzEzMzkxOTdkZTQ1NmMwYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-05T02:41:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-05T02:41:35Z"}, "message": "Makefile.in (tree.o): Depend on ggc.h.\n\n\t* Makefile.in (tree.o): Depend on ggc.h.\n\t(varasm.o): Likewise.\n\t(function.o): Likewise.\n\t(stmt.o): Likewise.\n\t(except.o): Likewise.\n\t(optabs.o): Likewise.\n\t(emit-rtl.o): Likewise.\n\t* emit-rtl.c: Include ggc.h.\n\t(sequence_element_free_list): Remove, and all references.\n\t(mark_sequence): New functions.\n\t(mark_emit_state): New function.\n\t* except.c: Include ggc.h.\n\t(mark_eh_node, mark_eh_stack, mark_eh_queue): New functions.\n\t(mark_tree_label_node): New functions.\n\t(mark_eh_state): New function.\n\t* function.c: Include ggc.h.\n\t(mark_temp_slot, mark_function_chain): New functions.\n\t(mark_function_state): New function.\n\t(init_function_once): New function.\n\t* function.h (init_function_once): New function.\n\t* ggc-callbacks.c (lang_mark_false_label_stack): New function.\n\t* ggc.h (label_node): Declare.\n\t(eh_status, emit_status, stmt_status, varasm_status): Likewise.\n\t(lang_mark_false_label_stack): New function.\n\t(mark_temp_slot): Remove declaration.\n\t(mark_function_chain): Likewise.\n\t(mark_eh_state): Adjust prototype.\n\t(mark_stmt_state, mark_emit_state, mark_varasm_state, mark_optab):\n\tLikewise.\n\t* optabs.c: Include ggc.h.\n\t(mark_optab): New function.\n\t(init_optabs): Add gc roots.\n\t* stmt.c: Include ggc.h.\n\t(mark_cond_nesting, mark_loop_nesting): New functions.\n\t(mark_block_nesting, mark_case_nesting, mark_goto_fixup): Likewise.\n\t(mark_stmt_state): New function.\n\t* toplev.c (compile_file): Call init_function_once.\n\t* tree.c: Include ggc.h.\n\t(type_hash): Move declaration earlier in file.\n\t(TYPE_HASH_SIZE, type_hash_table): Likewise.\n\t(init_obstacks): Add gc roots.\n\t(mark_type_hash): New function.\n\t* varasm.c: Include ggc.h.\n\t(mark_pool_constant): New function.\n\t(mark_varasm_state): New function.\n\nCo-Authored-By: Bernd Schmidt <bernds@cygnus.co.uk>\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r29119", "tree": {"sha": "e5cebe68f9343bcd10b7be75a8d15ab8791ec212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5cebe68f9343bcd10b7be75a8d15ab8791ec212"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ff9c8e4bb514b8298fcd6431339197de456c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ff9c8e4bb514b8298fcd6431339197de456c0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ff9c8e4bb514b8298fcd6431339197de456c0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ff9c8e4bb514b8298fcd6431339197de456c0a/comments", "author": null, "committer": null, "parents": [{"sha": "6621f41de9e59ab84880d506f7de8b6ca6eccecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6621f41de9e59ab84880d506f7de8b6ca6eccecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6621f41de9e59ab84880d506f7de8b6ca6eccecb"}], "stats": {"total": 579, "additions": 544, "deletions": 35}, "files": [{"sha": "f9b2e2579fcb0640e972bd1419651717e8859c1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -1,3 +1,53 @@\n+Sat Sep  4 19:26:25 1999  Richard Henderson  <rth@cygnus.com>\n+\t                  Bernd Schmidt <bernds@cygnus.co.uk>\n+\t\t\t  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (tree.o): Depend on ggc.h.\n+\t(varasm.o): Likewise.\n+\t(function.o): Likewise.\n+\t(stmt.o): Likewise.\n+\t(except.o): Likewise.\n+\t(optabs.o): Likewise.\n+\t(emit-rtl.o): Likewise.\n+\t* emit-rtl.c: Include ggc.h.\n+\t(sequence_element_free_list): Remove, and all references.\n+\t(mark_sequence): New functions.\n+\t(mark_emit_state): New function.\n+\t* except.c: Include ggc.h.\n+\t(mark_eh_node, mark_eh_stack, mark_eh_queue): New functions.\n+\t(mark_tree_label_node): New functions.\n+\t(mark_eh_state): New function.\n+\t* function.c: Include ggc.h.\n+\t(mark_temp_slot, mark_function_chain): New functions.\n+\t(mark_function_state): New function.\n+\t(init_function_once): New function.\n+\t* function.h (init_function_once): New function.\n+\t* ggc-callbacks.c (lang_mark_false_label_stack): New function.\n+\t* ggc.h (label_node): Declare.\n+\t(eh_status, emit_status, stmt_status, varasm_status): Likewise.\n+\t(lang_mark_false_label_stack): New function.\n+\t(mark_temp_slot): Remove declaration.\n+\t(mark_function_chain): Likewise.\n+\t(mark_eh_state): Adjust prototype.\n+\t(mark_stmt_state, mark_emit_state, mark_varasm_state, mark_optab):\n+\tLikewise.\n+\t* optabs.c: Include ggc.h.\n+\t(mark_optab): New function.\n+\t(init_optabs): Add gc roots.\n+\t* stmt.c: Include ggc.h.\n+\t(mark_cond_nesting, mark_loop_nesting): New functions.\n+\t(mark_block_nesting, mark_case_nesting, mark_goto_fixup): Likewise.\n+\t(mark_stmt_state): New function.\n+\t* toplev.c (compile_file): Call init_function_once.\n+\t* tree.c: Include ggc.h.\n+\t(type_hash): Move declaration earlier in file.\n+\t(TYPE_HASH_SIZE, type_hash_table): Likewise.\n+\t(init_obstacks): Add gc roots.\n+\t(mark_type_hash): New function.\n+\t* varasm.c: Include ggc.h.\n+\t(mark_pool_constant): New function.\n+\t(mark_varasm_state): New function.\n+\t\n Sat Sep  4 22:28:56 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* ggc-simple.c (ggc_root, ggc_collect): Wrap prototype with PROTO."}, {"sha": "77f2b02462b8aac287327cb2ce88d3213b7a8526", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -1450,7 +1450,8 @@ prefix.o: prefix.c $(CONFIG_H) system.h Makefile prefix.h\n \n convert.o: convert.c $(CONFIG_H) $(TREE_H) flags.h convert.h toplev.h\n \n-tree.o : tree.c $(CONFIG_H) system.h $(TREE_H) flags.h function.h toplev.h\n+tree.o : tree.c $(CONFIG_H) system.h $(TREE_H) flags.h function.h toplev.h \\\n+   ggc.h\n print-tree.o : print-tree.c $(CONFIG_H) system.h $(TREE_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h\n@@ -1473,16 +1474,16 @@ errors.o : errors.c $(CONFIG_H) system.h errors.h\n \n varasm.o : varasm.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h \\\n    function.h defaults.h $(EXPR_H) hard-reg-set.h $(REGS_H) \\\n-   xcoffout.h output.h c-pragma.h toplev.h dbxout.h sdbout.h\n+   xcoffout.h output.h c-pragma.h toplev.h dbxout.h sdbout.h ggc.h\n function.o : function.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-flags.h insn-codes.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h\n+   insn-config.h $(RECOG_H) output.h toplev.h except.h hash.h ggc.h\n stmt.o : stmt.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-flags.h insn-config.h insn-codes.h hard-reg-set.h $(EXPR_H) except.h \\\n-   loop.h $(RECOG_H) toplev.h output.h varray.h\n+   loop.h $(RECOG_H) toplev.h output.h varray.h ggc.h\n except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-flags.h $(EXPR_H) $(REGS_H) hard-reg-set.h \\\n-   insn-config.h $(RECOG_H) output.h except.h toplev.h intl.h\n+   insn-config.h $(RECOG_H) output.h except.h toplev.h intl.h ggc.h\n expr.o : expr.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h \\\n    $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h $(RECOG_H) \\\n    output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h\n@@ -1499,7 +1500,7 @@ explow.o : explow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-codes.h toplev.h\n optabs.o : optabs.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h  \\\n    insn-flags.h insn-config.h insn-codes.h $(EXPR_H) $(RECOG_H) reload.h \\\n-   toplev.h\n+   toplev.h ggc.h\n dbxout.o : dbxout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h $(REGS_H) \\\n    insn-config.h reload.h gstab.h xcoffout.h defaults.h output.h dbxout.h \\\n    toplev.h\n@@ -1515,7 +1516,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf2.h \\\n xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n-   function.h $(REGS_H) insn-config.h $(RECOG_H) real.h \\\n+   function.h $(REGS_H) insn-config.h $(RECOG_H) real.h ggc.h \\\n    $(EXPR_H) $(srcdir)/../include/obstack.h hard-reg-set.h bitmap.h toplev.h\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n "}, {"sha": "a781e2da79d0b0742c93f1635f062721b2b4058f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"obstack.h\"\n #include \"bitmap.h\"\n+#include \"ggc.h\"\n \n /* Commonly used modes.  */\n \n@@ -187,6 +188,7 @@ static rtx free_insn;\n static rtx make_jump_insn_raw\t\tPROTO((rtx));\n static rtx make_call_insn_raw\t\tPROTO((rtx));\n static rtx find_line_note\t\tPROTO((rtx));\n+static void mark_sequence_stack         PROTO((struct sequence_stack *));\n \f\n rtx\n gen_rtx_CONST_INT (mode, arg)\n@@ -3467,6 +3469,41 @@ init_emit ()\n #endif\n }\n \n+/* Mark SS for GC.  */\n+\n+static void\n+mark_sequence_stack (ss)\n+     struct sequence_stack *ss;\n+{\n+  while (ss)\n+    {\n+      ggc_mark_rtx (ss->first);\n+      ggc_mark_tree (ss->sequence_rtl_expr);\n+      ss = ss->next;\n+    }\n+}\n+\n+/* Mark ES for GC.  */\n+\n+void\n+mark_emit_state (es)\n+     struct emit_status *es;\n+{\n+  rtx *r;\n+  int i;\n+\n+  if (es == 0)\n+    return;\n+\n+  for (i = es->regno_pointer_flag_length, r = es->x_regno_reg_rtx;\n+       i > 0; --i, ++r)\n+    ggc_mark_rtx (*r);\n+\n+  mark_sequence_stack (es->sequence_stack);\n+  ggc_mark_tree (es->sequence_rtl_expr);\n+  ggc_mark_rtx (es->x_first_insn);\n+}\n+\n /* Create some permanent unique rtl objects shared between all functions.\n    LINE_NUMBERS is nonzero if line numbers are to be generated.  */\n "}, {"sha": "0a7b9a944df26a381478579570ad94fc635b661a", "filename": "gcc/except.c", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -408,6 +408,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"intl.h\"\n #include \"obstack.h\"\n+#include \"ggc.h\"\n \n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */\n@@ -467,6 +468,10 @@ static void set_insn_eh_region\tPROTO((rtx *, int));\n #ifdef DONT_USE_BUILTIN_SETJMP\n static void jumpif_rtx\t\tPROTO((rtx, rtx));\n #endif\n+static void mark_eh_node        PROTO((struct eh_node *));\n+static void mark_eh_stack       PROTO((struct eh_stack *));\n+static void mark_eh_queue       PROTO((struct eh_queue *));\n+static void mark_tree_label_node PROTO ((struct label_node *));\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \f\n@@ -2333,7 +2338,76 @@ check_exception_handler_labels ()\n     }\n \n }\n-\f\n+\n+/* Mark the children of NODE for GC.  */\n+\n+static void\n+mark_eh_node (node)\n+     struct eh_node *node;\n+{\n+  while (node)\n+    {\n+      if (node->entry)\n+\t{\n+\t  ggc_mark_rtx (node->entry->outer_context);\n+\t  ggc_mark_rtx (node->entry->exception_handler_label);\n+\t  ggc_mark_tree (node->entry->finalization);\n+\t}\n+      node = node ->chain;\n+    }\n+}\n+\n+/* Mark S for GC.  */\n+\n+static void\n+mark_eh_stack (s)\n+     struct eh_stack *s;\n+{\n+  if (s)\n+    mark_eh_node (s->top);\n+}\n+\n+/* Mark Q for GC.  */\n+\n+static void\n+mark_eh_queue (q)\n+     struct eh_queue *q;\n+{\n+  if (q)\n+    mark_eh_node (q->head);\n+}\n+\n+/* Mark NODE for GC.  A label_node contains a union containing either\n+   a tree or an rtx.  This label_node will contain a tree.  */\n+\n+static void\n+mark_tree_label_node (node)\n+     struct label_node *node;\n+{\n+  while (node)\n+    {\n+      ggc_mark_tree (node->u.tlabel);\n+      node = node->chain;\n+    }\n+}\n+\n+/* Mark EH for GC.  */\n+\n+void\n+mark_eh_state (eh)\n+     struct eh_status *eh;\n+{\n+  mark_eh_stack (&eh->x_ehstack);\n+  mark_eh_queue (&eh->x_ehqueue);\n+  ggc_mark_rtx (eh->x_catch_clauses);\n+\n+  lang_mark_false_label_stack (eh->x_false_label_stack);\n+  mark_tree_label_node (eh->x_caught_return_label_stack);\n+\n+  ggc_mark_tree (eh->x_protect_list);\n+  ggc_mark_rtx (eh->ehc);\n+}\n+\n /* This group of functions initializes the exception handling data\n    structures at the start of the compilation, initializes the data\n    structures at the start of a function, and saves and restores the"}, {"sha": "b0c27256dab78494d2db3938030c48954e7eb4b4", "filename": "gcc/function.c", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -57,6 +57,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"toplev.h\"\n #include \"hash.h\"\n+#include \"ggc.h\"\n \n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n@@ -272,6 +273,9 @@ static unsigned long insns_for_mem_hash PROTO ((hash_table_key));\n static boolean insns_for_mem_comp PROTO ((hash_table_key, hash_table_key));\n static int insns_for_mem_walk   PROTO ((rtx *, void *));\n static void compute_insns_for_mem PROTO ((rtx, rtx, struct hash_table *));\n+static void mark_temp_slot PROTO ((struct temp_slot *));\n+static void mark_function_state PROTO ((struct function *));\n+static void mark_function_chain PROTO ((void *));\n \n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n@@ -5630,7 +5634,7 @@ init_function_start (subr, filename, line)\n   /* Remember this function for later.  */\n   current_function->next_global = all_functions;\n   all_functions = current_function;\n-\n+  \n   current_function_name = (*decl_printable_name) (subr, 2);\n \n   /* Nonzero if this is a nested function that uses a static chain.  */\n@@ -6637,3 +6641,116 @@ reposition_prologue_and_epilogue_notes (f)\n     }\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n+\n+/* Mark T for GC.  */\n+\n+static void\n+mark_temp_slot (t)\n+  struct temp_slot *t;\n+{\n+  while (t)\n+    {\n+      ggc_mark_rtx (t->slot);\n+      ggc_mark_rtx (t->address);\n+      ggc_mark_tree (t->rtl_expr);\n+\n+      t = t->next;\n+    }\n+}\n+\n+/* Mark P for GC.  */\n+\n+static void\n+mark_function_state (p)\n+     struct function *p;\n+{\n+  int i;\n+  rtx *r;\n+\n+  if (p == 0)\n+    return;\n+\n+  ggc_mark_rtx (p->arg_offset_rtx);\n+\n+  for (i = p->x_max_parm_reg, r = p->x_parm_reg_stack_loc;\n+       i > 0; --i, ++r)\n+    ggc_mark_rtx (*r);\n+\n+  ggc_mark_rtx (p->return_rtx);\n+  ggc_mark_rtx (p->x_cleanup_label);\n+  ggc_mark_rtx (p->x_return_label);\n+  ggc_mark_rtx (p->x_save_expr_regs);\n+  ggc_mark_rtx (p->x_stack_slot_list);\n+  ggc_mark_rtx (p->x_parm_birth_insn);\n+  ggc_mark_rtx (p->x_tail_recursion_label);\n+  ggc_mark_rtx (p->x_tail_recursion_reentry);\n+  ggc_mark_rtx (p->internal_arg_pointer);\n+  ggc_mark_rtx (p->x_arg_pointer_save_area);\n+  ggc_mark_tree (p->x_rtl_expr_chain);\n+  ggc_mark_rtx (p->x_last_parm_insn);\n+  ggc_mark_tree (p->x_context_display);\n+  ggc_mark_tree (p->x_trampoline_list);\n+  ggc_mark_rtx (p->epilogue_delay_list);\n+\n+  mark_temp_slot (p->x_temp_slots);\n+\n+  {\n+    struct var_refs_queue *q = p->fixup_var_refs_queue;\n+    while (q)\n+      {\n+\tggc_mark_rtx (q->modified);\n+\tq = q->next;\n+      }\n+  }\n+\n+  ggc_mark_rtx (p->x_nonlocal_goto_handler_slots);\n+  ggc_mark_rtx (p->x_nonlocal_goto_stack_level);\n+  ggc_mark_tree (p->x_nonlocal_labels);\n+}\n+\n+/* Mark the function chain ARG (which is really a struct function **)\n+   for GC.  */\n+\n+static void\n+mark_function_chain (arg)\n+     void *arg;\n+{\n+  struct function *f = *(struct function **) arg;\n+\n+  for (; f; f = f->next_global)\n+    {\n+      if (f->can_garbage_collect)\n+\tcontinue;\n+\n+      ggc_mark_tree (f->decl);\n+\n+      mark_function_state (f);\n+      mark_stmt_state (f->stmt);\n+      mark_eh_state (f->eh);\n+      mark_emit_state (f->emit);\n+      mark_varasm_state (f->varasm);\n+\n+      ggc_mark_rtx (f->expr->x_saveregs_value);\n+      ggc_mark_rtx (f->expr->x_apply_args_value);\n+      ggc_mark_rtx (f->expr->x_forced_labels);\n+\n+      if (mark_machine_status)\n+\t(*mark_machine_status) (f);\n+      if (mark_lang_status)\n+\t(*mark_lang_status) (f);\n+\n+      if (f->original_arg_vector)\n+\tggc_mark_rtvec ((rtvec) f->original_arg_vector);\n+      if (f->original_decl_initial)\n+\tggc_mark_tree (f->original_decl_initial);\n+    }\n+}\n+\n+/* Called once, at initialization, to initialize function.c.  */\n+\n+void\n+init_function_once ()\n+{\n+  ggc_add_root (&all_functions, 1, sizeof all_functions,\n+\t\tmark_function_chain);\n+}"}, {"sha": "966b3f74e4788dc877ce0b71e93478c2f78ed81c", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -558,6 +558,9 @@ extern rtx get_first_block_beg\t\tPROTO((void));\n \n extern void init_virtual_regs\t\tPROTO((struct emit_status *));\n \n+/* Called once, at initialization, to initialize function.c.  */\n+extern void init_function_once          PROTO((void));\n+\n #ifdef rtx\n #undef rtx\n #endif"}, {"sha": "1b19579e914392e19a0b70b0f93ea583d8cde896", "filename": "gcc/ggc-callbacks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fggc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fggc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-callbacks.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -41,3 +41,12 @@ lang_cleanup_tree (t)\n      only included in compilers for languages that don't support GC.  */\n   abort ();\n }\n+\n+void\n+lang_mark_false_label_stack (l)\n+     struct label_node *l ATTRIBUTE_UNUSED;\n+{\n+  /* If this function is called, we are doing GC.  But, this file is\n+     only included in compilers for languages that don't support GC.  */\n+  abort ();\n+}"}, {"sha": "6967900cb8aa9dc14ee1d961cc329d072364bf2a", "filename": "gcc/ggc.h", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -23,6 +23,16 @@\n /* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n    an external gc library that might be linked in.  */\n \n+/* These structures are defined in various headers throughout the\n+   compiler.  However, rather than force everyone who includes this\n+   header to include all the headers in which they are declared, we\n+   just forward-declare them here.  */\n+struct label_node;\n+struct eh_status;\n+struct emit_status;\n+struct stmt_status;\n+struct varasm_status;\n+\n /* Startup */\n \n extern void init_ggc PROTO ((void));\n@@ -61,12 +71,15 @@ void lang_mark_tree PROTO ((union tree_node *));\n /* And similarly to free that data when the tree node is released.  */\n void lang_cleanup_tree PROTO ((union tree_node *));\n \n+/* The FALSE_LABEL_STACK, declared in except.h, has\n+   language-dependent semantics.  Each front-end should define this\n+   function appropriately.  */\n+void lang_mark_false_label_stack PROTO ((struct label_node *));\n+\n /* Mark functions for various structs scattered about.  */\n \n-void mark_temp_slot PROTO ((void *));\n-void mark_function_chain PROTO ((void *));\n-void mark_eh_state PROTO ((void *));\n-void mark_stmt_state PROTO ((void *));\n-void mark_emit_state PROTO ((void *));\n-void mark_varasm_state PROTO ((void *));\n+void mark_eh_state PROTO ((struct eh_status *));\n+void mark_stmt_state PROTO ((struct stmt_status *));\n+void mark_emit_state PROTO ((struct emit_status *));\n+void mark_varasm_state PROTO ((struct varasm_status *));\n void mark_optab PROTO ((void *));"}, {"sha": "d82eb2ee6fa4fee63efd79d13e2174a7dadbe47c", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"reload.h\"\n+#include \"ggc.h\"\n \n /* Each optab contains info on how this target machine\n    can perform a particular operation\n@@ -4342,6 +4343,18 @@ init_floating_libfuncs (optable, opname, suffix)\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);\n }\n \n+/* Mark ARG (which is really an OPTAB *) for GC.  */\n+\n+void\n+mark_optab (arg)\n+     void *arg;\n+{\n+  optab o = *(optab *) arg;\n+  int i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; ++i)\n+    ggc_mark_rtx (o->handlers[i].libfunc);\n+}\n \n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n@@ -4679,6 +4692,10 @@ init_optabs ()\n   /* Allow the target to add more libcalls or rename some, etc.  */\n   INIT_TARGET_OPTABS;\n #endif\n+\n+  /* Add these GC roots.  */\n+  ggc_add_root (optab_table, OTI_MAX, sizeof(optab), mark_optab);\n+  ggc_add_rtx_root (libfunc_table, LTI_MAX);\n }\n \f\n #ifdef BROKEN_LDEXP"}, {"sha": "a9f859237c262f7837c46e5c11b23fd00ba3bea0", "filename": "gcc/stmt.c", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -52,6 +52,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"machmode.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"ggc.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -425,13 +426,152 @@ static void emit_jump_if_reachable\tPROTO((rtx));\n static void emit_case_nodes\t\tPROTO((rtx, case_node_ptr, rtx, tree));\n static int add_case_node\t\tPROTO((tree, tree, tree, tree *));\n static struct case_node *case_tree2list\tPROTO((case_node *, case_node *));\n+static void mark_cond_nesting           PROTO((struct nesting *));\n+static void mark_loop_nesting           PROTO((struct nesting *));\n+static void mark_block_nesting          PROTO((struct nesting *));\n+static void mark_case_nesting           PROTO((struct nesting *));\n+static void mark_goto_fixup             PROTO((struct goto_fixup *));\n+\n \f\n void\n using_eh_for_cleanups ()\n {\n   using_eh_for_cleanups_p = 1;\n }\n \n+/* Mark N (known to be a cond-nesting) for GC.  */\n+\n+static void\n+mark_cond_nesting (n)\n+     struct nesting *n;\n+{\n+  while (n)\n+    {\n+      ggc_mark_rtx (n->exit_label);\n+      ggc_mark_rtx (n->data.cond.endif_label);\n+      ggc_mark_rtx (n->data.cond.next_label);\n+\n+      n = n->next;\n+    }\n+}\n+\n+/* Mark N (known to be a loop-nesting) for GC.  */\n+\n+static void\n+mark_loop_nesting (n)\n+     struct nesting *n;\n+{\n+\n+  while (n)\n+    {\n+      ggc_mark_rtx (n->exit_label);\n+      ggc_mark_rtx (n->data.loop.start_label);\n+      ggc_mark_rtx (n->data.loop.end_label);\n+      ggc_mark_rtx (n->data.loop.alt_end_label);\n+      ggc_mark_rtx (n->data.loop.continue_label);\n+\n+      n = n->next;\n+    }\n+}\n+\n+/* Mark N (known to be a block-nesting) for GC.  */\n+\n+static void\n+mark_block_nesting (n)\n+     struct nesting *n;\n+{\n+  while (n)\n+    {\n+      struct label_chain *l;\n+\n+      ggc_mark_rtx (n->exit_label);\n+      ggc_mark_rtx (n->data.block.stack_level);\n+      ggc_mark_rtx (n->data.block.first_insn);\n+      ggc_mark_tree (n->data.block.cleanups);\n+      ggc_mark_tree (n->data.block.outer_cleanups);\n+\n+      for (l = n->data.block.label_chain; l != NULL; l = l->next)\n+\tggc_mark_tree (l->label);\n+\n+      ggc_mark_rtx (n->data.block.last_unconditional_cleanup);\n+\n+      /* ??? cleanup_ptr never points outside the stack, does it?  */\n+\n+      n = n->next;\n+    }\n+}\n+\n+/* Mark N (known to be a case-nesting) for GC.  */\n+\n+static void\n+mark_case_nesting (n)\n+     struct nesting *n;\n+{\n+  while (n)\n+    {\n+      struct case_node *node;\n+\n+      ggc_mark_rtx (n->exit_label);\n+      ggc_mark_rtx (n->data.case_stmt.start);\n+\n+      node = n->data.case_stmt.case_list;\n+      while (node)\n+\t{\n+\t  ggc_mark_tree (node->low);\n+\t  ggc_mark_tree (node->high);\n+\t  ggc_mark_tree (node->code_label);\n+\t  node = node->right;\n+\t}\n+\n+      ggc_mark_tree (n->data.case_stmt.default_label);\n+      ggc_mark_tree (n->data.case_stmt.index_expr);\n+      ggc_mark_tree (n->data.case_stmt.nominal_type);\n+\n+      n = n->next;\n+    }\n+}\n+\n+/* Mark G for GC.  */\n+\n+static void\n+mark_goto_fixup (g)\n+     struct goto_fixup *g;\n+{\n+  while (g)\n+    {\n+      ggc_mark_rtx (g->before_jump);\n+      ggc_mark_tree (g->target);\n+      ggc_mark_tree (g->context);\n+      ggc_mark_rtx (g->target_rtl);\n+      ggc_mark_rtx (g->stack_level);\n+      ggc_mark_tree (g->cleanup_list_list);\n+\n+      g = g->next;\n+    }\n+}\n+\n+/* Mark P for GC.  */\n+\n+void\n+mark_stmt_state (p)\n+     struct stmt_status *p;\n+{\n+  if (p == 0)\n+    return;\n+\n+  mark_block_nesting (p->x_block_stack);\n+  mark_cond_nesting (p->x_cond_stack);\n+  mark_loop_nesting (p->x_loop_stack);\n+  mark_case_nesting (p->x_case_stack);\n+\n+  ggc_mark_tree (p->x_last_expr_type);\n+  /* last_epxr_value is only valid if last_expr_type is nonzero.  */\n+  if (p->x_last_expr_type)\n+    ggc_mark_rtx (p->x_last_expr_value);\n+\n+  mark_goto_fixup (p->x_goto_fixup_chain);\n+}\n+\n void\n init_stmt ()\n {"}, {"sha": "eaa013eda7833c21fea686e67cf93a748fdc2b82", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -2935,6 +2935,7 @@ compile_file (name)\n   init_loop ();\n   init_reload ();\n   init_alias_once ();\n+  init_function_once ();\n \n   /* The following initialization functions need to generate rtl, so\n      provide a dummy function context for them.  */"}, {"sha": "1d0f27377da6a24cd6b4750a956186d45a64b259", "filename": "gcc/tree.c", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"function.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -247,9 +248,30 @@ int (*lang_get_alias_set) PROTO((tree));\n    codes are made.  */\n #define TYPE_HASH(TYPE) ((unsigned long) (TYPE) & 0777777)\n \n+/* Each hash table slot is a bucket containing a chain\n+   of these structures.  */\n+\n+struct type_hash\n+{\n+  struct type_hash *next;\t/* Next structure in the bucket.  */\n+  int hashcode;\t\t\t/* Hash code of this type.  */\n+  tree type;\t\t\t/* The type recorded here.  */\n+};\n+\n+/* Now here is the hash table.  When recording a type, it is added\n+   to the slot whose index is the hash code mod the table size.\n+   Note that the hash table is used for several kinds of types\n+   (function types, array types and array index range types, for now).\n+   While all these live in the same table, they are completely independent,\n+   and the hash code is computed differently for each of these.  */\n+\n+#define TYPE_HASH_SIZE 59\n+struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n+\n static void set_type_quals PROTO((tree, int));\n static void append_random_chars PROTO((char *));\n static void build_real_from_int_cst_1 PROTO((PTR));\n+static void mark_type_hash PROTO ((void *));\n \n void gcc_obstack_init ();\n \n@@ -284,6 +306,11 @@ init_obstacks ()\n \n   /* Init the hash table of identifiers.  */\n   bzero ((char *) hash_table, sizeof hash_table);\n+\n+  ggc_add_tree_root (hash_table, MAX_HASH_TABLE);\n+  ggc_add_root (type_hash_table, TYPE_HASH_SIZE, \n+\t\tsizeof(struct type_hash *),\n+\t\tmark_type_hash);\n }\n \n void\n@@ -3587,26 +3614,6 @@ build_type_copy (type)\n /* Hashing of types so that we don't make duplicates.\n    The entry point is `type_hash_canon'.  */\n \n-/* Each hash table slot is a bucket containing a chain\n-   of these structures.  */\n-\n-struct type_hash\n-{\n-  struct type_hash *next;\t/* Next structure in the bucket.  */\n-  int hashcode;\t\t\t/* Hash code of this type.  */\n-  tree type;\t\t\t/* The type recorded here.  */\n-};\n-\n-/* Now here is the hash table.  When recording a type, it is added\n-   to the slot whose index is the hash code mod the table size.\n-   Note that the hash table is used for several kinds of types\n-   (function types, array types and array index range types, for now).\n-   While all these live in the same table, they are completely independent,\n-   and the hash code is computed differently for each of these.  */\n-\n-#define TYPE_HASH_SIZE 59\n-struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n-\n /* Compute a hash code for a list of types (chain of TREE_LIST nodes\n    with types in the TREE_VALUE slots), by adding the hash codes\n    of the individual types.  */\n@@ -3714,6 +3721,21 @@ type_hash_canon (hashcode, type)\n   return type;\n }\n \n+/* Mark ARG (which is really a struct type_hash **) for GC.  */\n+\n+static void\n+mark_type_hash (arg)\n+     void *arg;\n+{\n+  struct type_hash *t = *(struct type_hash **) arg;\n+\n+  while (t)\n+    {\n+      ggc_mark_tree (t->type);\n+      t = t->next;\n+    }\n+}\n+\n /* Compute a hash code for a list of attributes (chain of TREE_LIST nodes\n    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n    by adding the hash codes of the individual attributes.  */"}, {"sha": "33b16fe87bd1c261fc817d86499d2997e68f75b8", "filename": "gcc/varasm.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ff9c8e4bb514b8298fcd6431339197de456c0a/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=87ff9c8e4bb514b8298fcd6431339197de456c0a", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"obstack.h\"\n #include \"c-pragma.h\"\n+#include \"ggc.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\n@@ -186,6 +187,7 @@ static void asm_output_bss\t\tPROTO((FILE *, tree, char *, int, int));\n static void asm_output_aligned_bss\tPROTO((FILE *, tree, char *, int, int));\n #endif\n #endif /* BSS_SECTION_ASM_OP */\n+static void mark_pool_constant          PROTO((struct pool_constant *));\n \f\n static enum in_section { no_section, in_text, in_data, in_named\n #ifdef BSS_SECTION_ASM_OP\n@@ -3186,6 +3188,29 @@ init_varasm_status (f)\n   p->x_const_double_chain = 0;\n }\n \n+/* Mark PC for GC.  */\n+\n+static void \n+mark_pool_constant (pc)\n+     struct pool_constant *pc;\n+{\n+  while (pc)\n+    {\n+      ggc_mark_rtx (pc->constant);\n+      pc = pc->next;\n+    }\n+}\n+\n+/* Mark P for GC.  */\n+\n+void\n+mark_varasm_state (p)\n+  struct varasm_status *p;\n+{\n+  mark_pool_constant (p->x_first_pool);\n+  ggc_mark_rtx (p->x_const_double_chain);\n+}\n+\n /* Clear out all parts of our state in F that can safely be discarded\n    after the function has been compiled.  */\n void"}]}