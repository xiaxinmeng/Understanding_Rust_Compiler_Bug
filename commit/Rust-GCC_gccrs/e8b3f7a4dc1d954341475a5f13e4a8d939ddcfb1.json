{"sha": "e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThiM2Y3YTRkYzFkOTU0MzQxNDc1YTVmMTNlNGE4ZDkzOWRkY2ZiMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-03-02T07:45:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-03-02T07:45:41Z"}, "message": "re PR tree-optimization/84427 (gcc ICE at -O3 on x86_64-linux-gnu in compute_antic, at tree-ssa-pre.c:2356)\n\n2018-03-02  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/84427\n\t* tree-ssa-pre.c (bitmap_remove_expr_from_set): Remove.\n\t(bitmap_set_subtract_values): Rewrite to handle multiple\n\texprs per value.\n\t(clean): Likewise.\n\t(prune_clobbered_mems): Likewise.\n\t(phi_translate): Take edge instead of pred/phiblock.\n\t(phi_translate_1): Likewise.\n\t(phi_translate_set): Likewise.  Insert all translated\n\texprs for a value into the set, keeping possibly multiple\n\texpressions per value.\n\t(compute_antic_aux): Adjust for phi_translate changes.\n\tWhen intersecting union the expressions and prune those\n\tnot in the final value set, keeping possibly multiple\n\texpressions per value.  Do not use value-insertion\n\tfor unioning ANTIC_OUT U EXP_GEN - TMP_GEN but merge\n\tall expressions.  Add verification that the value-sets\n\tonly shrink during iteration.\n\t(compute_partial_antic_aux): Adjust for the phi_translate changes.\n\t(do_pre_regular_insertion): Likewise.\n\t(do_pre_partial_partial_insertion): Likewise.\n\n\t* gcc.dg/torture/pr84427.c: New testcase.\n\nFrom-SVN: r258124", "tree": {"sha": "36a4a124b2366597bcf98578183f83f65fff309d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36a4a124b2366597bcf98578183f83f65fff309d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ebb413bb0f3c0794e7ec109d558860f386212cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ebb413bb0f3c0794e7ec109d558860f386212cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ebb413bb0f3c0794e7ec109d558860f386212cc"}], "stats": {"total": 250, "additions": 159, "deletions": 91}, "files": [{"sha": "6200f2f4f47d83966d4f839005fb2002db7a20ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "patch": "@@ -1,3 +1,27 @@\n+2018-03-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84427\n+\t* tree-ssa-pre.c (bitmap_remove_expr_from_set): Remove.\n+\t(bitmap_set_subtract_values): Rewrite to handle multiple\n+\texprs per value.\n+\t(clean): Likewise.\n+\t(prune_clobbered_mems): Likewise.\n+\t(phi_translate): Take edge instead of pred/phiblock.\n+\t(phi_translate_1): Likewise.\n+\t(phi_translate_set): Likewise.  Insert all translated\n+\texprs for a value into the set, keeping possibly multiple\n+\texpressions per value.\n+\t(compute_antic_aux): Adjust for phi_translate changes.\n+\tWhen intersecting union the expressions and prune those\n+\tnot in the final value set, keeping possibly multiple\n+\texpressions per value.  Do not use value-insertion\n+\tfor unioning ANTIC_OUT U EXP_GEN - TMP_GEN but merge\n+\tall expressions.  Add verification that the value-sets\n+\tonly shrink during iteration.\n+\t(compute_partial_antic_aux): Adjust for the phi_translate changes.\n+\t(do_pre_regular_insertion): Likewise.\n+\t(do_pre_partial_partial_insertion): Likewise.\n+\n 2018-03-02  Richard Biener  <rguenther@suse.de>\n \n \tPR target/82005"}, {"sha": "d5aa006d8f83ba5aeab6169da2c1c94ace2b0601", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "patch": "@@ -1,3 +1,8 @@\n+2018-03-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84427\n+\t* gcc.dg/torture/pr84427.c: New testcase.\n+\n 2018-03-01  Peter Bergner  <bergner@vnet.ibm.com>\n \n \tPR target/84534"}, {"sha": "761a4b64d9a8ff7f3582e95a62a31fb9b52d46ec", "filename": "gcc/testsuite/gcc.dg/torture/pr84427.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84427.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84427.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr84427.c?ref=e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+short a, d, e;\n+unsigned char b;\n+int c, f;\n+char g, h;\n+void fn2(int, int);\n+void fn1() { fn2(e, a); }\n+void fn2(int p1, int p2)\n+{\n+l1:\n+  b = a;\n+  for (; h; h--)\n+    if (p1)\n+      g = p2 * c;\n+    else\n+      {\n+\tc = d;\n+\tif (f)\n+\t  goto l1;\n+      }\n+}"}, {"sha": "a535c325e0f33a944d817470485428437f321f54", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 108, "deletions": 91, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e8b3f7a4dc1d954341475a5f13e4a8d939ddcfb1", "patch": "@@ -696,16 +696,6 @@ sccvn_valnum_from_value_id (unsigned int val)\n   return NULL_TREE;\n }\n \n-/* Remove an expression EXPR from a bitmapped set.  */\n-\n-static void\n-bitmap_remove_expr_from_set (bitmap_set_t set, pre_expr expr)\n-{\n-  unsigned int val  = get_expr_value_id (expr);\n-  bitmap_clear_bit (&set->values, val);\n-  bitmap_clear_bit (&set->expressions, get_expression_id (expr));\n-}\n-\n /* Insert an expression EXPR into a bitmapped set.  */\n \n static void\n@@ -805,20 +795,21 @@ bitmap_set_subtract_values (bitmap_set_t a, bitmap_set_t b)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  pre_expr to_remove = NULL;\n+  unsigned to_remove = -1U;\n+  bitmap_and_compl_into (&a->values, &b->values);\n   FOR_EACH_EXPR_ID_IN_SET (a, i, bi)\n     {\n-      if (to_remove)\n+      if (to_remove != -1U)\n \t{\n-\t  bitmap_remove_expr_from_set (a, to_remove);\n-\t  to_remove = NULL;\n+\t  bitmap_clear_bit (&a->expressions, to_remove);\n+\t  to_remove = -1U;\n \t}\n       pre_expr expr = expression_for_id (i);\n-      if (bitmap_bit_p (&b->values, get_expr_value_id (expr)))\n-\tto_remove = expr;\n+      if (! bitmap_bit_p (&a->values, get_expr_value_id (expr)))\n+\tto_remove = i;\n     }\n-  if (to_remove)\n-    bitmap_remove_expr_from_set (a, to_remove);\n+  if (to_remove != -1U)\n+    bitmap_clear_bit (&a->expressions, to_remove);\n }\n \n \n@@ -1335,17 +1326,17 @@ get_representative_for (const pre_expr e, basic_block b = NULL)\n \n \n static pre_expr\n-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n-\t       basic_block pred, basic_block phiblock);\n+phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e);\n \n /* Translate EXPR using phis in PHIBLOCK, so that it has the values of\n    the phis in PRED.  Return NULL if we can't find a leader for each part\n    of the translated expression.  */\n \n static pre_expr\n-phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n-\t\t basic_block pred, basic_block phiblock)\n+phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n+  basic_block pred = e->src;\n+  basic_block phiblock = e->dest;\n   switch (expr->kind)\n     {\n     case NARY:\n@@ -1366,7 +1357,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n                 pre_expr leader, result;\n \t\tunsigned int op_val_id = VN_INFO (newnary->op[i])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-                result = phi_translate (leader, set1, set2, pred, phiblock);\n+\t\tresult = phi_translate (leader, set1, set2, e);\n \t\tif (result && result != leader)\n \t\t  /* Force a leader as well as we are simplifying this\n \t\t     expression.  */\n@@ -1397,7 +1388,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t       to be inserted and increased register pressure.\n \t\t       See PR77498 - this avoids doing predcoms work in\n \t\t       a less efficient way.  */\n-\t\t    if (find_edge (pred, phiblock)->flags & EDGE_DFS_BACK)\n+\t\t    if (e->flags & EDGE_DFS_BACK)\n \t\t      ;\n \t\t    else\n \t\t      {\n@@ -1488,7 +1479,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t  }\n \t\top_val_id = VN_INFO (op[n])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\topresult = phi_translate (leader, set1, set2, pred, phiblock);\n+\t\topresult = phi_translate (leader, set1, set2, e);\n \t\tif (opresult && opresult != leader)\n \t\t  {\n \t\t    tree name = get_representative_for (opresult);\n@@ -1616,7 +1607,6 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \tif (gimple_code (def_stmt) == GIMPLE_PHI\n \t    && gimple_bb (def_stmt) == phiblock)\n \t  {\n-\t    edge e = find_edge (pred, gimple_bb (def_stmt));\n \t    tree def = PHI_ARG_DEF (def_stmt, e->dest_idx);\n \n \t    /* Handle constant. */\n@@ -1639,8 +1629,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n /* Wrapper around phi_translate_1 providing caching functionality.  */\n \n static pre_expr\n-phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n-\t       basic_block pred, basic_block phiblock)\n+phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n   expr_pred_trans_t slot = NULL;\n   pre_expr phitrans;\n@@ -1658,15 +1647,15 @@ phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n   /* Don't add translations of NAMEs as those are cheap to translate.  */\n   if (expr->kind != NAME)\n     {\n-      if (phi_trans_add (&slot, expr, pred))\n+      if (phi_trans_add (&slot, expr, e->src))\n \treturn slot->v;\n       /* Store NULL for the value we want to return in the case of\n \t recursing.  */\n       slot->v = NULL;\n     }\n \n   /* Translate.  */\n-  phitrans = phi_translate_1 (expr, set1, set2, pred, phiblock);\n+  phitrans = phi_translate_1 (expr, set1, set2, e);\n \n   if (slot)\n     {\n@@ -1687,14 +1676,13 @@ phi_translate (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n    expressions in DEST.  */\n \n static void\n-phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n-\t\t   basic_block phiblock)\n+phi_translate_set (bitmap_set_t dest, bitmap_set_t set, edge e)\n {\n   vec<pre_expr> exprs;\n   pre_expr expr;\n   int i;\n \n-  if (gimple_seq_empty_p (phi_nodes (phiblock)))\n+  if (gimple_seq_empty_p (phi_nodes (e->dest)))\n     {\n       bitmap_set_copy (dest, set);\n       return;\n@@ -1704,18 +1692,11 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n   FOR_EACH_VEC_ELT (exprs, i, expr)\n     {\n       pre_expr translated;\n-      translated = phi_translate (expr, set, NULL, pred, phiblock);\n+      translated = phi_translate (expr, set, NULL, e);\n       if (!translated)\n \tcontinue;\n \n-      /* We might end up with multiple expressions from SET being\n-\t translated to the same value.  In this case we do not want\n-\t to retain the NARY or REFERENCE expression but prefer a NAME\n-\t which would be the leader.  */\n-      if (translated->kind == NAME)\n-\tbitmap_value_replace_in_set (dest, translated);\n-      else\n-\tbitmap_value_insert_into_set (dest, translated);\n+      bitmap_insert_into_set (dest, translated);\n     }\n   exprs.release ();\n }\n@@ -1918,7 +1899,15 @@ clean (bitmap_set_t set1, bitmap_set_t set2 = NULL)\n   FOR_EACH_VEC_ELT (exprs, i, expr)\n     {\n       if (!valid_in_sets (set1, set2, expr))\n-\tbitmap_remove_expr_from_set (set1, expr);\n+\t{\n+\t  unsigned int val  = get_expr_value_id (expr);\n+\t  bitmap_clear_bit (&set1->expressions, get_expression_id (expr));\n+\t  /* We are entered with possibly multiple expressions for a value\n+\t     so before removing a value from the set see if there's an\n+\t     expression for it left.  */\n+\t  if (! bitmap_find_leader (set1, val))\n+\t    bitmap_clear_bit (&set1->values, val);\n+\t}\n     }\n   exprs.release ();\n }\n@@ -1931,15 +1920,17 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n {\n   bitmap_iterator bi;\n   unsigned i;\n-  pre_expr to_remove = NULL;\n+  unsigned to_remove = -1U;\n+  bool any_removed = false;\n \n   FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n     {\n       /* Remove queued expr.  */\n-      if (to_remove)\n+      if (to_remove != -1U)\n \t{\n-\t  bitmap_remove_expr_from_set (set, to_remove);\n-\t  to_remove = NULL;\n+\t  bitmap_clear_bit (&set->expressions, to_remove);\n+\t  any_removed = true;\n+\t  to_remove = -1U;\n \t}\n \n       pre_expr expr = expression_for_id (i);\n@@ -1955,7 +1946,7 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \t\t\t\t\t   block, gimple_bb (def_stmt)))\n \t\t      || (gimple_bb (def_stmt) == block\n \t\t\t  && value_dies_in_block_x (expr, block))))\n-\t\tto_remove = expr;\n+\t\tto_remove = i;\n \t    }\n \t}\n       else if (expr->kind == NARY)\n@@ -1967,13 +1958,36 @@ prune_clobbered_mems (bitmap_set_t set, basic_block block)\n \t     as the available expression might be after the exit point.  */\n \t  if (BB_MAY_NOTRETURN (block)\n \t      && vn_nary_may_trap (nary))\n-\t    to_remove = expr;\n+\t    to_remove = i;\n \t}\n     }\n \n   /* Remove queued expr.  */\n-  if (to_remove)\n-    bitmap_remove_expr_from_set (set, to_remove);\n+  if (to_remove != -1U)\n+    {\n+      bitmap_clear_bit (&set->expressions, to_remove);\n+      any_removed = true;\n+    }\n+\n+  /* Above we only removed expressions, now clean the set of values\n+     which no longer have any corresponding expression.  We cannot\n+     clear the value at the time we remove an expression since there\n+     may be multiple expressions per value.\n+     If we'd queue possibly to be removed values we could use\n+     the bitmap_find_leader way to see if there's still an expression\n+     for it.  For some ratio of to be removed values and number of\n+     values/expressions in the set this might be faster than rebuilding\n+     the value-set.  */\n+  if (any_removed)\n+    {\n+      bitmap_clear (&set->values);\n+      FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n+\t{\n+\t  pre_expr expr = expression_for_id (i);\n+\t  unsigned int value_id = get_expr_value_id (expr);\n+\t  bitmap_set_bit (&set->values, value_id);\n+\t}\n+    }\n }\n \n static sbitmap has_abnormal_preds;\n@@ -1993,11 +2007,10 @@ static bool\n compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n {\n   bitmap_set_t S, old, ANTIC_OUT;\n-  bitmap_iterator bi;\n-  unsigned int bii;\n   edge e;\n   edge_iterator ei;\n \n+  bool was_visited = BB_VISITED (block);\n   bool changed = ! BB_VISITED (block);\n   BB_VISITED (block) = 1;\n   old = ANTIC_OUT = S = NULL;\n@@ -2017,26 +2030,26 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n      translate through.  */\n   else if (single_succ_p (block))\n     {\n-      basic_block succ_bb = single_succ (block);\n-      gcc_assert (BB_VISITED (succ_bb));\n-      phi_translate_set (ANTIC_OUT, ANTIC_IN (succ_bb), block, succ_bb);\n+      e = single_succ_edge (block);\n+      gcc_assert (BB_VISITED (e->dest));\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN (e->dest), e);\n     }\n   /* If we have multiple successors, we take the intersection of all of\n      them.  Note that in the case of loop exit phi nodes, we may have\n      phis to translate through.  */\n   else\n     {\n       size_t i;\n-      basic_block bprime, first = NULL;\n+      edge first = NULL;\n \n-      auto_vec<basic_block> worklist (EDGE_COUNT (block->succs));\n+      auto_vec<edge> worklist (EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n \t  if (!first\n \t      && BB_VISITED (e->dest))\n-\t    first = e->dest;\n+\t    first = e;\n \t  else if (BB_VISITED (e->dest))\n-\t    worklist.quick_push (e->dest);\n+\t    worklist.quick_push (e);\n \t  else\n \t    {\n \t      /* Unvisited successors get their ANTIC_IN replaced by the\n@@ -2053,7 +2066,7 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n          which is guaranteed by iteration order.  */\n       gcc_assert (first != NULL);\n \n-      phi_translate_set (ANTIC_OUT, ANTIC_IN (first), block, first);\n+      phi_translate_set (ANTIC_OUT, ANTIC_IN (first->dest), first);\n \n       /* If we have multiple successors we need to intersect the ANTIC_OUT\n          sets.  For values that's a simple intersection but for\n@@ -2062,31 +2075,29 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t Avoid randomness and running into cycles like for PR82129 and\n \t canonicalize the expression we choose to the one with the\n \t lowest id.  This requires we actually compute the union first.  */\n-      FOR_EACH_VEC_ELT (worklist, i, bprime)\n+      FOR_EACH_VEC_ELT (worklist, i, e)\n \t{\n-\t  if (!gimple_seq_empty_p (phi_nodes (bprime)))\n+\t  if (!gimple_seq_empty_p (phi_nodes (e->dest)))\n \t    {\n \t      bitmap_set_t tmp = bitmap_set_new ();\n-\t      phi_translate_set (tmp, ANTIC_IN (bprime), block, bprime);\n+\t      phi_translate_set (tmp, ANTIC_IN (e->dest), e);\n \t      bitmap_and_into (&ANTIC_OUT->values, &tmp->values);\n \t      bitmap_ior_into (&ANTIC_OUT->expressions, &tmp->expressions);\n \t      bitmap_set_free (tmp);\n \t    }\n \t  else\n \t    {\n-\t      bitmap_and_into (&ANTIC_OUT->values, &ANTIC_IN (bprime)->values);\n+\t      bitmap_and_into (&ANTIC_OUT->values, &ANTIC_IN (e->dest)->values);\n \t      bitmap_ior_into (&ANTIC_OUT->expressions,\n-\t\t\t       &ANTIC_IN (bprime)->expressions);\n+\t\t\t       &ANTIC_IN (e->dest)->expressions);\n \t    }\n \t}\n       if (! worklist.is_empty ())\n \t{\n-\t  /* Prune expressions not in the value set, canonicalizing to\n-\t     expression with lowest ID.  */\n+\t  /* Prune expressions not in the value set.  */\n \t  bitmap_iterator bi;\n \t  unsigned int i;\n \t  unsigned int to_clear = -1U;\n-\t  bitmap seen_value = BITMAP_ALLOC (NULL);\n \t  FOR_EACH_EXPR_ID_IN_SET (ANTIC_OUT, i, bi)\n \t    {\n \t      if (to_clear != -1U)\n@@ -2096,13 +2107,11 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \t\t}\n \t      pre_expr expr = expression_for_id (i);\n \t      unsigned int value_id = get_expr_value_id (expr);\n-\t      if (!bitmap_bit_p (&ANTIC_OUT->values, value_id)\n-\t\t  || !bitmap_set_bit (seen_value, value_id))\n+\t      if (!bitmap_bit_p (&ANTIC_OUT->values, value_id))\n \t\tto_clear = i;\n \t    }\n \t  if (to_clear != -1U)\n \t    bitmap_clear_bit (&ANTIC_OUT->expressions, to_clear);\n-\t  BITMAP_FREE (seen_value);\n \t}\n     }\n \n@@ -2119,15 +2128,26 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n \n   /* Then union in the ANTIC_OUT - TMP_GEN values,\n      to get ANTIC_OUT U EXP_GEN - TMP_GEN */\n-  FOR_EACH_EXPR_ID_IN_SET (S, bii, bi)\n-    bitmap_value_insert_into_set (ANTIC_IN (block),\n-\t\t\t\t  expression_for_id (bii));\n+  bitmap_ior_into (&ANTIC_IN (block)->values, &S->values);\n+  bitmap_ior_into (&ANTIC_IN (block)->expressions, &S->expressions);\n \n   /* clean (ANTIC_IN (block)) is defered to after the iteration converged\n      because it can cause non-convergence, see for example PR81181.  */\n \n   if (!bitmap_set_equal (old, ANTIC_IN (block)))\n-    changed = true;\n+    {\n+      changed = true;\n+      /* After the initial value set computation the value set may\n+         only shrink during the iteration.  */\n+      if (was_visited && flag_checking)\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned int i;\n+\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (&ANTIC_IN (block)->values,\n+\t\t\t\t\t  &old->values, 0, i, bi)\n+\t    gcc_unreachable ();\n+\t}\n+    }\n \n  maybe_dump_sets:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2202,45 +2222,44 @@ compute_partial_antic_aux (basic_block block,\n      VH.1 + 1 (VH.2), VH.2 + 1 (VH.3), etc), forever.  */\n   else if (single_succ_p (block))\n     {\n-      basic_block succ = single_succ (block);\n-      if (!(single_succ_edge (block)->flags & EDGE_DFS_BACK))\n-\tphi_translate_set (PA_OUT, PA_IN (succ), block, succ);\n+      e = single_succ_edge (block);\n+      if (!(e->flags & EDGE_DFS_BACK))\n+\tphi_translate_set (PA_OUT, PA_IN (e->dest), e);\n     }\n   /* If we have multiple successors, we take the union of all of\n      them.  */\n   else\n     {\n       size_t i;\n-      basic_block bprime;\n \n-      auto_vec<basic_block> worklist (EDGE_COUNT (block->succs));\n+      auto_vec<edge> worklist (EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n \t{\n \t  if (e->flags & EDGE_DFS_BACK)\n \t    continue;\n-\t  worklist.quick_push (e->dest);\n+\t  worklist.quick_push (e);\n \t}\n       if (worklist.length () > 0)\n \t{\n-\t  FOR_EACH_VEC_ELT (worklist, i, bprime)\n+\t  FOR_EACH_VEC_ELT (worklist, i, e)\n \t    {\n \t      unsigned int i;\n \t      bitmap_iterator bi;\n \n-\t      FOR_EACH_EXPR_ID_IN_SET (ANTIC_IN (bprime), i, bi)\n+\t      FOR_EACH_EXPR_ID_IN_SET (ANTIC_IN (e->dest), i, bi)\n \t\tbitmap_value_insert_into_set (PA_OUT,\n \t\t\t\t\t      expression_for_id (i));\n-\t      if (!gimple_seq_empty_p (phi_nodes (bprime)))\n+\t      if (!gimple_seq_empty_p (phi_nodes (e->dest)))\n \t\t{\n \t\t  bitmap_set_t pa_in = bitmap_set_new ();\n-\t\t  phi_translate_set (pa_in, PA_IN (bprime), block, bprime);\n+\t\t  phi_translate_set (pa_in, PA_IN (e->dest), e);\n \t\t  FOR_EACH_EXPR_ID_IN_SET (pa_in, i, bi)\n \t\t    bitmap_value_insert_into_set (PA_OUT,\n \t\t\t\t\t\t  expression_for_id (i));\n \t\t  bitmap_set_free (pa_in);\n \t\t}\n \t      else\n-\t\tFOR_EACH_EXPR_ID_IN_SET (PA_IN (bprime), i, bi)\n+\t\tFOR_EACH_EXPR_ID_IN_SET (PA_IN (e->dest), i, bi)\n \t\t  bitmap_value_insert_into_set (PA_OUT,\n \t\t\t\t\t\texpression_for_id (i));\n \t    }\n@@ -3158,8 +3177,7 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n \t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n \t      /* We are looking at ANTIC_OUT of bprime.  */\n-\t      eprime = phi_translate (expr, ANTIC_IN (block), NULL,\n-\t\t\t\t      bprime, block);\n+\t      eprime = phi_translate (expr, ANTIC_IN (block), NULL, pred);\n \n \t      /* eprime will generally only be NULL if the\n \t\t value of the expression, translated\n@@ -3315,8 +3333,7 @@ do_pre_partial_partial_insertion (basic_block block, basic_block dom)\n \t      gcc_assert (!(pred->flags & EDGE_FAKE));\n \t      bprime = pred->src;\n \t      eprime = phi_translate (expr, ANTIC_IN (block),\n-\t\t\t\t      PA_IN (block),\n-\t\t\t\t      bprime, block);\n+\t\t\t\t      PA_IN (block), pred);\n \n \t      /* eprime will generally only be NULL if the\n \t\t value of the expression, translated"}]}