{"sha": "032e83482b77e6d7fcc933640bc3fd17448d74a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMyZTgzNDgyYjc3ZTZkN2ZjYzkzMzY0MGJjM2ZkMTc0NDhkNzRhMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-23T05:55:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-23T05:55:50Z"}, "message": "read-rtl.c (map_value, [...]): New structures.\n\n\t* read-rtl.c (map_value, mapping, macro_group): New structures.\n\t(BELLWETHER_CODE): New macro.\n\t(modes, codes, bellwether_codes): New variables.\n\t(find_mode, uses_mode_macro_p, apply_mode_macro, find_code)\n\t(uses_code_macro_p, apply_code_macro, apply_macro_to_string)\n\t(apply_macro_to_rtx, uses_macro_p, add_condition_to_string)\n\t(add_condition_to_rtx, apply_macro_traverse, add_mapping)\n\t(add_map_value, initialize_macros): New functions.\n\t(def_hash, def_hash_eq_p): Generalize to anything that points to,\n\tor starts with, a char * field.\n\t(find_macro, read_mapping, check_code_macro): New functions.\n\t(read_rtx_1): New, split out from read_rtx.  Handle the new\n\tdefine_{mode,code}_{macro,attr} constructs.  Use find_macro\n\tto parse the name of a code or mode.  Use BELLWETHER_CODE to\n\textract the format and to choose a suitable code for rtx_alloc.\n\tModify recursive invocations to use read_rtx_1.\n\t(read_rtx): Call initialize_macros.  Apply code and mode macros\n\tto the rtx returned by read_rtx_1.  Cache everything after the\n\tfirst macro expansion for subsequent read_rtx calls.\n\t* doc/md.texi: Document new .md constructs.\n\t* config/mips/mips.md (GPR): New mode macro.\n\t(d, si8_di5): New mode attributes.\n\t(any_cond): New code macro.\n\t(add[sd]i3): Redefine using :GPR.\n\t(*add[sd]i3): Likewise, renaming from add[sd]i3_internal.\n\t(*add[sd]i3_sp[12], *add<mode>3_mips16): Redefine using :GPR, naming\n\tpreviously unnamed MIPS16 patterns.\n\t(*addsi3_extended): Renamed from addsi3_internal_2.  Fix overly long\n\tlines.  Don't match (plus (const_int 0) ...).\n\t(*addsi3_extended_mips16): Name previously unnamed MIPS16 pattern.\n\tUse a define_split to generate the addition.\n\t(sub[sd]i3): Redefine using :GPR.  Turn subsi3 into a define_insn.\n\t(subsi3_internal): Delete.\n\t(*subsi3_extended): Renamed from subsi3_internal_2.\n\t(bunordered, bordered, bunlt, bunge, buneq, bltgt, bunle, bungt)\n\t(beq, bne, bgt, bge, blt, ble, bgtu, bgeu, bltu, bleu): Redefine\n\tusing an any_cond template.\n\nFrom-SVN: r86404", "tree": {"sha": "955515c44f9df08d27a02dff75b1f77772daaa98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/955515c44f9df08d27a02dff75b1f77772daaa98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/032e83482b77e6d7fcc933640bc3fd17448d74a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032e83482b77e6d7fcc933640bc3fd17448d74a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032e83482b77e6d7fcc933640bc3fd17448d74a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032e83482b77e6d7fcc933640bc3fd17448d74a2/comments", "author": null, "committer": null, "parents": [{"sha": "ecce923e1073014b820367e487df93b7c81542fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecce923e1073014b820367e487df93b7c81542fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecce923e1073014b820367e487df93b7c81542fb"}], "stats": {"total": 1485, "additions": 1050, "deletions": 435}, "files": [{"sha": "25da5351e72b7011f4fffc3dee2576959d3d4a42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=032e83482b77e6d7fcc933640bc3fd17448d74a2", "patch": "@@ -1,3 +1,43 @@\n+2004-08-23  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* read-rtl.c (map_value, mapping, macro_group): New structures.\n+\t(BELLWETHER_CODE): New macro.\n+\t(modes, codes, bellwether_codes): New variables.\n+\t(find_mode, uses_mode_macro_p, apply_mode_macro, find_code)\n+\t(uses_code_macro_p, apply_code_macro, apply_macro_to_string)\n+\t(apply_macro_to_rtx, uses_macro_p, add_condition_to_string)\n+\t(add_condition_to_rtx, apply_macro_traverse, add_mapping)\n+\t(add_map_value, initialize_macros): New functions.\n+\t(def_hash, def_hash_eq_p): Generalize to anything that points to,\n+\tor starts with, a char * field.\n+\t(find_macro, read_mapping, check_code_macro): New functions.\n+\t(read_rtx_1): New, split out from read_rtx.  Handle the new\n+\tdefine_{mode,code}_{macro,attr} constructs.  Use find_macro\n+\tto parse the name of a code or mode.  Use BELLWETHER_CODE to\n+\textract the format and to choose a suitable code for rtx_alloc.\n+\tModify recursive invocations to use read_rtx_1.\n+\t(read_rtx): Call initialize_macros.  Apply code and mode macros\n+\tto the rtx returned by read_rtx_1.  Cache everything after the\n+\tfirst macro expansion for subsequent read_rtx calls.\n+\t* doc/md.texi: Document new .md constructs.\n+\t* config/mips/mips.md (GPR): New mode macro.\n+\t(d, si8_di5): New mode attributes.\n+\t(any_cond): New code macro.\n+\t(add[sd]i3): Redefine using :GPR.\n+\t(*add[sd]i3): Likewise, renaming from add[sd]i3_internal.\n+\t(*add[sd]i3_sp[12], *add<mode>3_mips16): Redefine using :GPR, naming\n+\tpreviously unnamed MIPS16 patterns.\n+\t(*addsi3_extended): Renamed from addsi3_internal_2.  Fix overly long\n+\tlines.  Don't match (plus (const_int 0) ...).\n+\t(*addsi3_extended_mips16): Name previously unnamed MIPS16 pattern.\n+\tUse a define_split to generate the addition.\n+\t(sub[sd]i3): Redefine using :GPR.  Turn subsi3 into a define_insn.\n+\t(subsi3_internal): Delete.\n+\t(*subsi3_extended): Renamed from subsi3_internal_2.\n+\t(bunordered, bordered, bunlt, bunge, buneq, bltgt, bunle, bungt)\n+\t(beq, bne, bgt, bge, blt, ble, bgtu, bgeu, bltu, bleu): Redefine\n+\tusing an any_cond template.\n+\n 2004-08-23  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* read-rtl.c (read_rtx): Tidy use of format_ptr."}, {"sha": "a1226f8d2fc03fee381c3cdaa66b32e980b85ef7", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 97, "deletions": 380, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=032e83482b77e6d7fcc933640bc3fd17448d74a2", "patch": "@@ -289,6 +289,24 @@\n (define_asm_attributes\n   [(set_attr \"type\" \"multi\")])\n \f\n+;; This mode macro allows 32-bit and 64-bit GPR patterns to be generated\n+;; from the same template.\n+(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+\n+;; In GPR templates, a string like \"<d>subu\" will expand to \"subu\" in the\n+;; 32-bit version and \"dsubu\" in the 64-bit version.\n+(define_mode_attr d [(SI \"\") (DI \"d\")])\n+\n+;; The unextended ranges of the MIPS16 addiu and daddiu instructions\n+;; are different.  Some forms of unextended addiu have an 8-bit immediate\n+;; field but the equivalent daddiu has only a 5-bit field.\n+(define_mode_attr si8_di5 [(SI \"8\") (DI \"5\")])\n+\n+;; This code macro allows all branch instructions to be generated from\n+;; a single define_expand template.\n+(define_code_macro any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n+\t\t\t     eq ne gt ge lt le gtu geu ltu leu])\n+\f\n ;; .........................\n ;;\n ;;\tBranch, call and jump delay slots\n@@ -425,69 +443,67 @@\n   [(set_attr \"type\"\t\"fadd\")\n    (set_attr \"mode\"\t\"SF\")])\n \n-(define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\")\n-\t\t (match_operand:SI 2 \"arith_operand\")))]\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(plus:GPR (match_operand:GPR 1 \"register_operand\")\n+\t\t  (match_operand:GPR 2 \"arith_operand\")))]\n   \"\")\n \n-(define_insn \"addsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"d,Q\")))]\n+(define_insn \"*add<mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n+\t(plus:GPR (match_operand:GPR 1 \"register_operand\" \"d,d\")\n+\t\t  (match_operand:GPR 2 \"arith_operand\" \"d,Q\")))]\n   \"!TARGET_MIPS16\"\n   \"@\n-    addu\\t%0,%z1,%2\n-    addiu\\t%0,%z1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")])\n+    <d>addu\\t%0,%1,%2\n+    <d>addiu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-;; For the mips16, we need to recognize stack pointer additions\n-;; explicitly, since we don't have a constraint for $sp.  These insns\n-;; will be generated by the save_restore_insns functions.\n+;; We need to recognize MIPS16 stack pointer additions explicitly, since\n+;; we don't have a constraint for $sp.  These insns will be generated by\n+;; the save_restore_insns functions.\n \n-(define_insn \"\"\n-  [(set (reg:SI 29)\n-\t(plus:SI (reg:SI 29)\n-\t\t (match_operand:SI 0 \"const_arith_operand\" \"\")))]\n+(define_insn \"*add<mode>3_sp1\"\n+  [(set (reg:GPR 29)\n+\t(plus:GPR (reg:GPR 29)\n+\t\t  (match_operand:GPR 0 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n-  \"addu\\t%$,%$,%0\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_simm8_8\")\n+  \"<d>addiu\\t%$,%$,%0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"length\") (if_then_else (match_operand 0 \"m16_simm8_8\")\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 8)))])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(plus:SI (reg:SI 29)\n-\t\t (match_operand:SI 1 \"const_arith_operand\" \"\")))]\n+(define_insn \"*add<mode>3_sp2\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(plus:GPR (reg:GPR 29)\n+\t\t  (match_operand:GPR 1 \"const_arith_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n-  \"addu\\t%0,%$,%1\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 1 \"m16_uimm8_4\")\n+  \"<d>addiu\\t%0,%$,%1\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set (attr \"length\") (if_then_else (match_operand 1 \"m16_uimm<si8_di5>_4\")\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 8)))])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"Q,O,d\")))]\n+(define_insn \"*add<mode>3_mips16\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d,d\")\n+\t(plus:GPR (match_operand:GPR 1 \"register_operand\" \"0,d,d\")\n+\t\t  (match_operand:GPR 2 \"arith_operand\" \"Q,O,d\")))]\n   \"TARGET_MIPS16\"\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \"addu\\t%0,%2\";\n-  else\n-    return \"addu\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n+  \"@\n+    <d>addiu\\t%0,%2\n+    <d>addiu\\t%0,%1,%2\n+    <d>addu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_simm8_1\")\n+\t\t[(if_then_else (match_operand 2 \"m16_simm<si8_di5>_1\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_simm4_1\")\n+\t\t (if_then_else (match_operand 2 \"m16_simm4_1\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))\n \t\t (const_int 4)])])\n@@ -560,80 +576,6 @@\n     }\n })\n \n-(define_expand \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t (match_operand:DI 2 \"arith_operand\")))]\n-  \"TARGET_64BIT\")\n-\n-(define_insn \"adddi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-\t(plus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n-\t\t (match_operand:DI 2 \"arith_operand\" \"d,Q\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\"\n-  \"@\n-    daddu\\t%0,%z1,%2\n-    daddiu\\t%0,%z1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-;; For the mips16, we need to recognize stack pointer additions\n-;; explicitly, since we don't have a constraint for $sp.  These insns\n-;; will be generated by the save_restore_insns functions.\n-\n-(define_insn \"\"\n-  [(set (reg:DI 29)\n-\t(plus:DI (reg:DI 29)\n-\t\t (match_operand:DI 0 \"const_arith_operand\" \"\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT\"\n-  \"daddu\\t%$,%$,%0\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_simm8_8\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(plus:DI (reg:DI 29)\n-\t\t (match_operand:DI 1 \"const_arith_operand\" \"\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT\"\n-  \"daddu\\t%0,%$,%1\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set (attr \"length\")\t(if_then_else (match_operand:VOID 0 \"m16_uimm5_4\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 8)))])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0,d,d\")\n-\t\t (match_operand:DI 2 \"arith_operand\" \"Q,O,d\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT\"\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \"daddu\\t%0,%2\";\n-  else\n-    return \"daddu\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_simm5_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_simm4_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (const_int 4)])])\n-\n-\n-;; On the mips16, we can sometimes split an add of a constant which is\n-;; a 4 byte instruction into two adds which are both 2 byte\n-;; instructions.  There are two cases: one where we are adding a\n-;; constant plus a register to another register, and one where we are\n-;; simply adding a constant to a register.\n-\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\")\n \t(plus:DI (match_dup 0)\n@@ -695,38 +637,33 @@\n     }\n })\n \n-(define_insn \"addsi3_internal_2\"\n+(define_insn \"*addsi3_extended\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-\t(sign_extend:DI (plus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,dJ\")\n-\t\t\t\t (match_operand:SI 2 \"arith_operand\" \"d,Q\"))))]\n+\t(sign_extend:DI\n+\t     (plus:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"d,Q\"))))]\n   \"TARGET_64BIT && !TARGET_MIPS16\"\n   \"@\n-    addu\\t%0,%z1,%2\n-    addiu\\t%0,%z1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")])\n+    addu\\t%0,%1,%2\n+    addiu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"\"\n+;; Split this insn so that the addiu splitters can have a crack at it.\n+;; Use a conservative length estimate until the split.\n+(define_insn_and_split \"*addsi3_extended_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-\t(sign_extend:DI (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n-\t\t\t\t (match_operand:SI 2 \"arith_operand\" \"Q,O,d\"))))]\n-  \"TARGET_MIPS16 && TARGET_64BIT\"\n-{\n-  if (REGNO (operands[0]) == REGNO (operands[1]))\n-    return \"addu\\t%0,%2\";\n-  else\n-    return \"addu\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(if_then_else (match_operand:VOID 2 \"m16_simm8_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_simm4_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (const_int 4)])])\n+\t(sign_extend:DI\n+\t     (plus:SI (match_operand:SI 1 \"register_operand\" \"0,d,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"Q,O,d\"))))]\n+  \"TARGET_64BIT && TARGET_MIPS16\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))]\n+  { operands[3] = gen_lowpart (SImode, operands[0]); }\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"extended_mips16\" \"yes\")])\n \f\n ;;\n ;;  ....................\n@@ -754,40 +691,24 @@\n   [(set_attr \"type\"\t\"fadd\")\n    (set_attr \"mode\"\t\"SF\")])\n \n-(define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\")\n-\t\t  (match_operand:SI 2 \"register_operand\")))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"subsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"d\")))]\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(minus:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t   (match_operand:GPR 2 \"register_operand\" \"d\")))]\n   \"\"\n-  \"subu\\t%0,%z1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t  (match_operand:DI 2 \"register_operand\" \"d\")))]\n-  \"TARGET_64BIT\"\n-  \"dsubu\\t%0,%1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")])\n+  \"<d>subu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"subsi3_internal_2\"\n+(define_insn \"*subsi3_extended\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(sign_extend:DI\n \t    (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t      (match_operand:SI 2 \"register_operand\" \"d\"))))]\n   \"TARGET_64BIT\"\n   \"subu\\t%0,%1,%2\"\n-  [(set_attr \"type\"\t\"arith\")\n-   (set_attr \"mode\"\t\"DI\")])\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n \f\n ;;\n ;;  ....................\n@@ -5810,219 +5731,15 @@ dsrl\\t%3,%3,1\\n\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"8\")])\n \n-(define_expand \"bunordered\"\n-  [(set (pc)\n-\t(if_then_else (unordered:CC (cc0)\n-\t\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNORDERED);\n-  DONE;\n-})\n-\n-(define_expand \"bordered\"\n-  [(set (pc)\n-\t(if_then_else (ordered:CC (cc0)\n-\t\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, ORDERED);\n-  DONE;\n-})\n-\n-(define_expand \"bunlt\"\n-  [(set (pc)\n-\t(if_then_else (unlt:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNLT);\n-  DONE;\n-})\n-\n-(define_expand \"bunge\"\n-  [(set (pc)\n-\t(if_then_else (unge:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNGE);\n-  DONE;\n-})\n-\n-(define_expand \"buneq\"\n-  [(set (pc)\n-\t(if_then_else (uneq:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNEQ);\n-  DONE;\n-})\n-\n-(define_expand \"bltgt\"\n-  [(set (pc)\n-\t(if_then_else (ltgt:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, LTGT);\n-  DONE;\n-})\n-\n-(define_expand \"bunle\"\n-  [(set (pc)\n-\t(if_then_else (unle:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNLE);\n-  DONE;\n-})\n-\n-(define_expand \"bungt\"\n-  [(set (pc)\n-\t(if_then_else (ungt:CC (cc0)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, UNGT);\n-  DONE;\n-})\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, EQ);\n-  DONE;\n-})\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, NE);\n-  DONE;\n-})\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, GT);\n-  DONE;\n-})\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, GE);\n-  DONE;\n-})\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, LT);\n-  DONE;\n-})\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le:CC (cc0)\n-\t\t\t     (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, LE);\n-  DONE;\n-})\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, GTU);\n-  DONE;\n-})\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, GEU);\n-  DONE;\n-})\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu:CC (cc0)\n-\t\t\t      (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-{\n-  gen_conditional_branch (operands, LTU);\n-  DONE;\n-})\n-\n-(define_expand \"bleu\"\n+(define_expand \"b<code>\"\n   [(set (pc)\n-\t(if_then_else (leu:CC (cc0)\n-\t\t\t      (const_int 0))\n+\t(if_then_else (any_cond:CC (cc0)\n+\t\t\t\t   (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\"))\n \t\t      (pc)))]\n   \"\"\n {\n-  gen_conditional_branch (operands, LEU);\n+  gen_conditional_branch (operands, <CODE>);\n   DONE;\n })\n \f"}, {"sha": "8404707db27757a0148a8d54c652a78c2d37975e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=032e83482b77e6d7fcc933640bc3fd17448d74a2", "patch": "@@ -47,6 +47,7 @@ See the next chapter for information on the C header file.\n                            predication.\n * Constant Definitions::Defining symbolic constants that can be used in the\n                         md file.\n+* Macros::              Using macros to generate patterns from a template.\n @end menu\n \n @node Overview\n@@ -6420,3 +6421,272 @@ You could write:\n The constants that are defined with a define_constant are also output\n in the insn-codes.h header file as #defines.\n @end ifset\n+@ifset INTERNALS\n+@node Macros\n+@section Macros\n+@cindex macros in @file{.md} files\n+\n+Ports often need to define similar patterns for more than one machine\n+mode or for more than one rtx code.  GCC provides some simple macro\n+facilities to make this process easier.\n+\n+@menu\n+* Mode Macros::         Generating variations of patterns for different modes.\n+* Code Macros::         Doing the same for codes.\n+@end menu\n+\n+@node Mode Macros\n+@subsection Mode Macros\n+@cindex mode macros in @file{.md} files\n+\n+Ports often need to define similar patterns for two or more different modes.\n+For example:\n+\n+@itemize @bullet\n+@item\n+If a processor has hardware support for both single and double\n+floating-point arithmetic, the @code{SFmode} patterns tend to be\n+very similar to the @code{DFmode} ones.\n+\n+@item\n+If a port uses @code{SImode} pointers in one configuration and\n+@code{DImode} pointers in another, it will usually have very similar\n+@code{SImode} and @code{DImode} patterns for manipulating pointers.\n+@end itemize\n+\n+Mode macros allow several patterns to be instantiated from one\n+@file{.md} file template.  They can be used with any type of\n+rtx-based construct, such as a @code{define_insn},\n+@code{define_split}, or @code{define_peephole2}.\n+\n+@menu\n+* Defining Mode Macros:: Defining a new mode macro.\n+* String Substitutions:: Combining mode macros with string substitutions\n+* Examples::             Examples\n+@end menu\n+\n+@node Defining Mode Macros\n+@subsubsection Defining Mode Macros\n+@findex define_mode_macro\n+\n+The syntax for defining a mode macro is:\n+\n+@smallexample\n+(define_mode_macro @var{name} [(@var{mode1} \"@var{cond1}\") ... (@var{moden} \"@var{condn}\")])\n+@end smallexample\n+\n+This allows subsequent @file{.md} file constructs to use the mode suffix\n+@code{:@var{name}}.  Every construct that does so will be expanded\n+@var{n} times, once with every use of @code{:@var{name}} replaced by\n+@code{:@var{mode1}}, once with every use replaced by @code{:@var{mode2}},\n+and so on.  In the expansion for a particular @var{modei}, every\n+C condition will also require that @var{condi} be true.\n+\n+For example:\n+\n+@smallexample\n+(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+@end smallexample\n+\n+defines a new mode suffix @code{:P}.  Every construct that uses\n+@code{:P} will be expanded twice, once with every @code{:P} replaced\n+by @code{:SI} and once with every @code{:P} replaced by @code{:DI}.\n+The @code{:SI} version will only apply if @code{Pmode == SImode} and\n+the @code{:DI} version will only apply if @code{Pmode == DImode}.\n+\n+As with other @file{.md} conditions, an empty string is treated\n+as ``always true''.  @code{(@var{mode} \"\")} can also be abbreviated\n+to @code{@var{mode}}.  For example:\n+\n+@smallexample\n+(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+@end smallexample\n+\n+means that the @code{:DI} expansion only applies if @code{TARGET_64BIT}\n+but that the @code{:SI} expansion has no such constraint.\n+\n+Macros are applied in the order they are defined.  This can be\n+significant if two macros are used in a construct that requires\n+string substitutions.  @xref{String Substitutions}.\n+\n+@node String Substitutions\n+@subsubsection String Substitution in Mode Macros\n+@findex define_mode_attr\n+\n+If an @file{.md} file construct uses mode macros, each version of the\n+construct will often need slightly different strings.  For example:\n+\n+@itemize @bullet\n+@item\n+When a @code{define_expand} defines several @code{add@var{m}3} patterns\n+(@pxref{Standard Names}), each expander will need to use the\n+appropriate mode name for @var{m}.\n+\n+@item\n+When a @code{define_insn} defines several instruction patterns,\n+each instruction will often use a different assembler mnemonic.\n+@end itemize\n+\n+GCC supports such variations through a system of ``mode attributes''.\n+There are two standard attributes: @code{mode}, which is the name of\n+the mode in lower case, and @code{MODE}, which is the same thing in\n+upper case.  You can define other attributes using:\n+\n+@smallexample\n+(define_mode_attr @var{name} [(@var{mode1} \"@var{value1}\") ... (@var{moden} \"@var{valuen}\")])\n+@end smallexample\n+\n+where @var{name} is the name of the attribute and @var{valuei}\n+is the value associated with @var{modei}.\n+\n+When GCC replaces some @var{:macro} with @var{:mode}, it will\n+scan each string in the pattern for sequences of the form\n+@code{<@var{macro}:@var{attr}>}, where @var{attr} is the name of\n+a mode attribute.  If the attribute is defined for @var{mode}, the\n+whole @code{<...>} sequence will be replaced by the appropriate\n+attribute value.\n+\n+For example, suppose an @file{.md} file has:\n+\n+@smallexample\n+(define_mode_macro P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n+(define_mode_attr load [(SI \"lw\") (DI \"ld\")])\n+@end smallexample\n+\n+If one of the patterns that uses @code{:P} contains the string\n+@code{\"<P:load>\\t%0,%1\"}, the @code{SI} version of that pattern\n+will use @code{\"lw\\t%0,%1\"} and the @code{DI} version will use\n+@code{\"ld\\t%0,%1\"}.\n+\n+The @code{@var{macro}:} prefix may be omitted, in which case the\n+substitution will be attempted for every macro expansion.\n+\n+@node Examples\n+@subsubsection Mode Macro Examples\n+\n+Here is an example from the MIPS port.  It defines the following\n+modes and attributes (among others):\n+\n+@smallexample\n+(define_mode_macro GPR [SI (DI \"TARGET_64BIT\")])\n+(define_mode_attr d [(SI \"\") (DI \"d\")])\n+@end smallexample\n+\n+and uses the following template to define both @code{subsi3}\n+and @code{subdi3}:\n+\n+@smallexample\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+        (minus:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n+                   (match_operand:GPR 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"<d>subu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+@end smallexample\n+\n+This is exactly equivalent to:\n+\n+@smallexample\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+                  (match_operand:SI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"subu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+        (minus:DI (match_operand:DI 1 \"register_operand\" \"d\")\n+                  (match_operand:DI 2 \"register_operand\" \"d\")))]\n+  \"\"\n+  \"dsubu\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"mode\" \"DI\")])\n+@end smallexample\n+\n+@node Code Macros\n+@subsection Code Macros\n+@cindex code macros in @file{.md} files\n+@findex define_code_macro\n+@findex define_code_attr\n+\n+Code macros operate in a similar way to mode macros.  @xref{Mode Macros}.\n+\n+The construct:\n+\n+@smallexample\n+(define_code_macro @var{name} [(@var{code1} \"@var{cond1}\") ... (@var{coden} \"@var{condn}\")])\n+@end smallexample\n+\n+defines a pseudo rtx code @var{name} that can be instantiated as\n+@var{codei} if condition @var{condi} is true.  Each @var{codei}\n+must have the same rtx format.  @xref{RTL Classes}.\n+\n+As with mode macros, each pattern that uses @var{name} will be\n+expanded @var{n} times, once with all uses of @var{name} replaced by\n+@var{code1}, once with all uses replaced by @var{code2}, and so on.\n+@xref{Defining Mode Macros}.\n+\n+It is possible to define attributes for codes as well as for modes.\n+There are two standard code attributes: @code{code}, the name of the\n+code in lower case, and @code{CODE}, the name of the code in upper case.\n+Other attributes are defined using:\n+\n+@smallexample\n+(define_code_attr @var{name} [(@var{code1} \"@var{value1}\") ... (@var{coden} \"@var{valuen}\")])\n+@end smallexample\n+\n+Here's an example of code macros in action, taken from the MIPS port:\n+\n+@smallexample\n+(define_code_macro any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n+                             eq ne gt ge lt le gtu geu ltu leu])\n+\n+(define_expand \"b<code>\"\n+  [(set (pc)\n+        (if_then_else (any_cond:CC (cc0)\n+                                   (const_int 0))\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"\"\n+@{\n+  gen_conditional_branch (operands, <CODE>);\n+  DONE;\n+@})\n+@end smallexample\n+\n+This is equivalent to:\n+\n+@smallexample\n+(define_expand \"bunordered\"\n+  [(set (pc)\n+        (if_then_else (unordered:CC (cc0)\n+                                    (const_int 0))\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"\"\n+@{\n+  gen_conditional_branch (operands, UNORDERED);\n+  DONE;\n+@})\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+        (if_then_else (ordered:CC (cc0)\n+                                  (const_int 0))\n+                      (label_ref (match_operand 0 \"\"))\n+                      (pc)))]\n+  \"\"\n+@{\n+  gen_conditional_branch (operands, ORDERED);\n+  DONE;\n+@})\n+\n+...\n+@end smallexample\n+\n+@end ifset"}, {"sha": "fe0c7a4044ae56efe466cd5f24b44c6a61b67353", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 643, "deletions": 55, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032e83482b77e6d7fcc933640bc3fd17448d74a2/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=032e83482b77e6d7fcc933640bc3fd17448d74a2", "patch": "@@ -30,9 +30,76 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static htab_t md_constants;\n \n+/* One element in a singly-linked list of (integer, string) pairs.  */\n+struct map_value {\n+  struct map_value *next;\n+  int number;\n+  const char *string;\n+};\n+\n+/* Maps a macro or attribute name to a list of (integer, string) pairs.\n+   The integers are mode or code values; the strings are either C conditions\n+   or attribute values.  */\n+struct mapping {\n+  /* The name of the macro or attribute.  */\n+  const char *name;\n+\n+  /* The group (modes or codes) to which the macro or attribute belongs.  */\n+  struct macro_group *group;\n+\n+  /* Gives a unique number to the attribute or macro.  Numbers are\n+     allocated consecutively, starting at 0.  */\n+  int index;\n+\n+  /* The list of (integer, string) pairs.  */\n+  struct map_value *values;\n+};\n+\n+/* A structure for abstracting the common parts of code and mode macros.  */\n+struct macro_group {\n+  /* Tables of \"mapping\" structures, one for attributes and one for macros.  */\n+  htab_t attrs, macros;\n+\n+  /* The number of \"real\" modes or codes (and by extension, the first\n+     number available for use as a macro placeholder).  */\n+  int num_builtins;\n+\n+  /* Treat the given string as the name of a standard mode or code and\n+     return its integer value.  Use the given file for error reporting.  */\n+  int (*find_builtin) (const char *, FILE *);\n+\n+  /* Return true if the given rtx uses the given mode or code.  */\n+  bool (*uses_macro_p) (rtx, int);\n+\n+  /* Make the given rtx use the given mode or code.  */\n+  void (*apply_macro) (rtx, int);\n+};\n+\n+/* If CODE is the number of a code macro, return a real rtx code that\n+   has the same format.  Return CODE otherwise.  */\n+#define BELLWETHER_CODE(CODE) \\\n+  ((CODE) < NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])\n+\n static void fatal_with_file_and_line (FILE *, const char *, ...)\n   ATTRIBUTE_PRINTF_2 ATTRIBUTE_NORETURN;\n static void fatal_expected_char (FILE *, int, int) ATTRIBUTE_NORETURN;\n+static int find_mode (const char *, FILE *);\n+static bool uses_mode_macro_p (rtx, int);\n+static void apply_mode_macro (rtx, int);\n+static int find_code (const char *, FILE *);\n+static bool uses_code_macro_p (rtx, int);\n+static void apply_code_macro (rtx, int);\n+static const char *apply_macro_to_string (const char *, struct mapping *, int);\n+static rtx apply_macro_to_rtx (rtx, struct mapping *, int);\n+static bool uses_macro_p (rtx, struct mapping *);\n+static const char *add_condition_to_string (const char *, const char *);\n+static void add_condition_to_rtx (rtx, const char *);\n+static int apply_macro_traverse (void **, void *);\n+static struct mapping *add_mapping (struct macro_group *, htab_t t,\n+\t\t\t\t    const char *, FILE *);\n+static struct map_value **add_map_value (struct map_value **,\n+\t\t\t\t\t int, const char *);\n+static void initialize_macros (void);\n static void read_name (char *, FILE *);\n static char *read_string (FILE *, int);\n static char *read_quoted_string (FILE *);\n@@ -42,6 +109,16 @@ static hashval_t def_hash (const void *);\n static int def_name_eq_p (const void *, const void *);\n static void read_constants (FILE *infile, char *tmp_char);\n static void validate_const_int (FILE *, const char *);\n+static int find_macro (struct macro_group *, const char *, FILE *);\n+static struct mapping *read_mapping (struct macro_group *, htab_t, FILE *);\n+static void check_code_macro (struct mapping *, FILE *);\n+static rtx read_rtx_1 (FILE *);\n+\n+/* The mode and code macro structures.  */\n+static struct macro_group modes, codes;\n+\n+/* Index I is the value of BELLWETHER_CODE (I + NUM_RTX_CODE).  */\n+static enum rtx_code *bellwether_codes;\n \n /* Obstack used for allocating RTL strings.  */\n static struct obstack string_obstack;\n@@ -97,6 +174,393 @@ fatal_expected_char (FILE *infile, int expected_c, int actual_c)\n \t\t\t    expected_c, actual_c);\n }\n \n+/* Implementations of the macro_group callbacks for modes.  */\n+\n+static int\n+find_mode (const char *name, FILE *infile)\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    if (strcmp (GET_MODE_NAME (i), name) == 0)\n+      return i;\n+\n+  fatal_with_file_and_line (infile, \"unknown mode `%s'\", name);\n+}\n+\n+static bool\n+uses_mode_macro_p (rtx x, int mode)\n+{\n+  return (int) GET_MODE (x) == mode;\n+}\n+\n+static void\n+apply_mode_macro (rtx x, int mode)\n+{\n+  PUT_MODE (x, mode);\n+}\n+\n+/* Implementations of the macro_group callbacks for codes.  */\n+\n+static int\n+find_code (const char *name, FILE *infile)\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (strcmp (GET_RTX_NAME (i), name) == 0)\n+      return i;\n+\n+  fatal_with_file_and_line (infile, \"unknown rtx code `%s'\", name);\n+}\n+\n+static bool\n+uses_code_macro_p (rtx x, int code)\n+{\n+  return (int) GET_CODE (x) == code;\n+}\n+\n+static void\n+apply_code_macro (rtx x, int code)\n+{\n+  PUT_CODE (x, code);\n+}\n+\n+/* Given that MACRO is being expanded as VALUE, apply the appropriate\n+   string substitutions to STRING.  Return the new string if any changes\n+   were needed, otherwise return STRING itself.  */\n+\n+static const char *\n+apply_macro_to_string (const char *string, struct mapping *macro, int value)\n+{\n+  char *base, *copy, *p, *attr, *start, *end;\n+  struct mapping *m;\n+  struct map_value *v;\n+\n+  if (string == 0)\n+    return string;\n+\n+  base = p = copy = ASTRDUP (string);\n+  while ((start = index (p, '<')) && (end = index (start, '>')))\n+    {\n+      p = start + 1;\n+\n+      /* If there's a \"macro:\" prefix, check whether the macro name matches.\n+\t Set ATTR to the start of the attribute name.  */\n+      attr = index (p, ':');\n+      if (attr == 0 || attr > end)\n+\tattr = p;\n+      else\n+\t{\n+\t  if (strncmp (p, macro->name, attr - p) != 0\n+\t      || macro->name[attr - p] != 0)\n+\t    continue;\n+\t  attr++;\n+\t}\n+\n+      /* Find the attribute specification.  */\n+      *end = 0;\n+      m = (struct mapping *) htab_find (macro->group->attrs, &attr);\n+      *end = '>';\n+      if (m == 0)\n+\tcontinue;\n+\n+      /* Find the attribute value for VALUE.  */\n+      for (v = m->values; v != 0; v = v->next)\n+\tif (v->number == value)\n+\t  break;\n+      if (v == 0)\n+\tcontinue;\n+\n+      /* Add everything between the last copied byte and the '<',\n+\t then add in the attribute value.  */\n+      obstack_grow (&string_obstack, base, start - base);\n+      obstack_grow (&string_obstack, v->string, strlen (v->string));\n+      base = end + 1;\n+    }\n+  if (base != copy)\n+    {\n+      obstack_grow (&string_obstack, base, strlen (base) + 1);\n+      return (char *) obstack_finish (&string_obstack);\n+    }\n+  return string;\n+}\n+\n+/* Return a copy of ORIGINAL in which all uses of MACRO have been\n+   replaced by VALUE.  */\n+\n+static rtx\n+apply_macro_to_rtx (rtx original, struct mapping *macro, int value)\n+{\n+  struct macro_group *group;\n+  const char *format_ptr;\n+  int i, j;\n+  rtx x;\n+  enum rtx_code bellwether_code;\n+\n+  if (original == 0)\n+    return original;\n+\n+  /* Create a shallow copy of ORIGINAL.  */\n+  bellwether_code = BELLWETHER_CODE (GET_CODE (original));\n+  x = rtx_alloc (bellwether_code);\n+  memcpy (x, original, RTX_SIZE (bellwether_code));\n+\n+  /* Change the mode or code itself.  */\n+  group = macro->group;\n+  if (group->uses_macro_p (x, macro->index + group->num_builtins))\n+    group->apply_macro (x, value);\n+\n+  /* Change each string and recursively change each rtx.  */\n+  format_ptr = GET_RTX_FORMAT (bellwether_code);\n+  for (i = 0; format_ptr[i] != 0; i++)\n+    switch (format_ptr[i])\n+      {\n+      case 'S':\n+      case 'T':\n+      case 's':\n+\tXSTR (x, i) = apply_macro_to_string (XSTR (x, i), macro, value);\n+\tbreak;\n+\n+      case 'e':\n+\tXEXP (x, i) = apply_macro_to_rtx (XEXP (x, i), macro, value);\n+\tbreak;\n+\n+      case 'V':\n+      case 'E':\n+\tif (XVEC (original, i))\n+\t  {\n+\t    XVEC (x, i) = rtvec_alloc (XVECLEN (original, i));\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      XVECEXP (x, i, j) = apply_macro_to_rtx (XVECEXP (original, i, j),\n+\t\t\t\t\t\t      macro, value);\n+\t  }\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+  return x;\n+}\n+\n+/* Return true if X (or some subexpression of X) uses macro MACRO.  */\n+\n+static bool\n+uses_macro_p (rtx x, struct mapping *macro)\n+{\n+  struct macro_group *group;\n+  const char *format_ptr;\n+  int i, j;\n+\n+  if (x == 0)\n+    return false;\n+\n+  group = macro->group;\n+  if (group->uses_macro_p (x, macro->index + group->num_builtins))\n+    return true;\n+\n+  format_ptr = GET_RTX_FORMAT (BELLWETHER_CODE (GET_CODE (x)));\n+  for (i = 0; format_ptr[i] != 0; i++)\n+    switch (format_ptr[i])\n+      {\n+      case 'e':\n+\tif (uses_macro_p (XEXP (x, i), macro))\n+\t  return true;\n+\tbreak;\n+\n+      case 'V':\n+      case 'E':\n+\tif (XVEC (x, i))\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (uses_macro_p (XVECEXP (x, i, j), macro))\n+\t      return true;\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+  return false;\n+}\n+\n+/* Return a condition that must satisfy both ORIGINAL and EXTRA.  If ORIGINAL\n+   has the form \"&& ...\" (as used in define_insn_and_splits), assume that\n+   EXTRA is already satisfied.  Empty strings are treated like \"true\".  */\n+\n+static const char *\n+add_condition_to_string (const char *original, const char *extra)\n+{\n+  char *result;\n+\n+  if (original == 0 || original[0] == 0)\n+    return extra;\n+\n+  if ((original[0] == '&' && original[1] == '&') || extra[0] == 0)\n+    return original;\n+\n+  asprintf (&result, \"(%s) && (%s)\", original, extra);\n+  return result;\n+}\n+\n+/* Like add_condition, but applied to all conditions in rtx X.  */\n+\n+static void\n+add_condition_to_rtx (rtx x, const char *extra)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case DEFINE_INSN:\n+    case DEFINE_EXPAND:\n+      XSTR (x, 2) = add_condition_to_string (XSTR (x, 2), extra);\n+      break;\n+\n+    case DEFINE_SPLIT:\n+    case DEFINE_PEEPHOLE:\n+    case DEFINE_PEEPHOLE2:\n+    case DEFINE_COND_EXEC:\n+      XSTR (x, 1) = add_condition_to_string (XSTR (x, 1), extra);\n+      break;\n+\n+    case DEFINE_INSN_AND_SPLIT:\n+      XSTR (x, 2) = add_condition_to_string (XSTR (x, 2), extra);\n+      XSTR (x, 4) = add_condition_to_string (XSTR (x, 4), extra);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* A htab_traverse callback.  Search the EXPR_LIST given by DATA\n+   for rtxes that use the macro in *SLOT.  Replace each such rtx\n+   with a list of expansions.  */\n+\n+static int\n+apply_macro_traverse (void **slot, void *data)\n+{\n+  struct mapping *macro;\n+  struct map_value *v;\n+  rtx elem, new_elem, original, x;\n+\n+  macro = (struct mapping *) *slot;\n+  for (elem = (rtx) data; elem != 0; elem = XEXP (elem, 1))\n+    if (uses_macro_p (XEXP (elem, 0), macro))\n+      {\n+\toriginal = XEXP (elem, 0);\n+\tfor (v = macro->values; v != 0; v = v->next)\n+\t  {\n+\t    x = apply_macro_to_rtx (original, macro, v->number);\n+\t    add_condition_to_rtx (x, v->string);\n+\t    if (v != macro->values)\n+\t      {\n+\t\t/* Insert a new EXPR_LIST node after ELEM and put the\n+\t\t   new expansion there.  */\n+\t\tnew_elem = rtx_alloc (EXPR_LIST);\n+\t\tXEXP (new_elem, 1) = XEXP (elem, 1);\n+\t\tXEXP (elem, 1) = new_elem;\n+\t\telem = new_elem;\n+\t      }\n+\t    XEXP (elem, 0) = x;\n+\t  }\n+    }\n+  return 1;\n+}\n+\n+/* Add a new \"mapping\" structure to hashtable TABLE.  NAME is the name\n+   of the mapping, GROUP is the group to which it belongs, and INFILE\n+   is the file that defined the mapping.  */\n+\n+static struct mapping *\n+add_mapping (struct macro_group *group, htab_t table,\n+\t     const char *name, FILE *infile)\n+{\n+  struct mapping *m;\n+  void **slot;\n+\n+  m = XNEW (struct mapping);\n+  m->name = xstrdup (name);\n+  m->group = group;\n+  m->index = htab_elements (table);\n+  m->values = 0;\n+\n+  slot = htab_find_slot (table, m, INSERT);\n+  if (*slot != 0)\n+    fatal_with_file_and_line (infile, \"`%s' already defined\", name);\n+\n+  *slot = m;\n+  return m;\n+}\n+\n+/* Add the pair (NUMBER, STRING) to a list of map_value structures.\n+   END_PTR points to the current null terminator for the list; return\n+   a pointer the new null terminator.  */\n+\n+static struct map_value **\n+add_map_value (struct map_value **end_ptr, int number, const char *string)\n+{\n+  struct map_value *value;\n+\n+  value = XNEW (struct map_value);\n+  value->next = 0;\n+  value->number = number;\n+  value->string = string;\n+\n+  *end_ptr = value;\n+  return &value->next;\n+}\n+\n+/* Do one-time initialization of the mode and code attributes.  */\n+\n+static void\n+initialize_macros (void)\n+{\n+  struct mapping *lower, *upper;\n+  struct map_value **lower_ptr, **upper_ptr;\n+  char *copy, *p;\n+  int i;\n+\n+  modes.attrs = htab_create (13, def_hash, def_name_eq_p, 0);\n+  modes.macros = htab_create (13, def_hash, def_name_eq_p, 0);\n+  modes.num_builtins = MAX_MACHINE_MODE;\n+  modes.find_builtin = find_mode;\n+  modes.uses_macro_p = uses_mode_macro_p;\n+  modes.apply_macro = apply_mode_macro;\n+\n+  codes.attrs = htab_create (13, def_hash, def_name_eq_p, 0);\n+  codes.macros = htab_create (13, def_hash, def_name_eq_p, 0);\n+  codes.num_builtins = NUM_RTX_CODE;\n+  codes.find_builtin = find_code;\n+  codes.uses_macro_p = uses_code_macro_p;\n+  codes.apply_macro = apply_code_macro;\n+\n+  lower = add_mapping (&modes, modes.attrs, \"mode\", 0);\n+  upper = add_mapping (&modes, modes.attrs, \"MODE\", 0);\n+  lower_ptr = &lower->values;\n+  upper_ptr = &upper->values;\n+  for (i = 0; i < MAX_MACHINE_MODE; i++)\n+    {\n+      copy = xstrdup (GET_MODE_NAME (i));\n+      for (p = copy; *p != 0; p++)\n+\t*p = TOLOWER (*p);\n+\n+      upper_ptr = add_map_value (upper_ptr, i, GET_MODE_NAME (i));\n+      lower_ptr = add_map_value (lower_ptr, i, copy);\n+    }\n+\n+  lower = add_mapping (&codes, codes.attrs, \"code\", 0);\n+  upper = add_mapping (&codes, codes.attrs, \"CODE\", 0);\n+  lower_ptr = &lower->values;\n+  upper_ptr = &upper->values;\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    {\n+      copy = xstrdup (GET_RTX_NAME (i));\n+      for (p = copy; *p != 0; p++)\n+\t*p = TOUPPER (*p);\n+\n+      lower_ptr = add_map_value (lower_ptr, i, GET_RTX_NAME (i));\n+      upper_ptr = add_map_value (upper_ptr, i, copy);\n+    }\n+}\n+\n /* Read chars from INFILE until a non-whitespace char\n    and return that.  Comments, both Lisp style and C style,\n    are treated as whitespace.\n@@ -398,24 +862,26 @@ atoll (const char *p)\n }\n #endif\n \n-/* Given a constant definition, return a hash code for its name.  */\n+/* Given an object that starts with a char * name field, return a hash\n+   code for its name.  */\n static hashval_t\n def_hash (const void *def)\n {\n   unsigned result, i;\n-  const char *string = ((const struct md_constant *) def)->name;\n+  const char *string = *(const char *const *) def;\n \n-  for (result = i = 0;*string++ != '\\0'; i++)\n+  for (result = i = 0; *string++ != '\\0'; i++)\n     result += ((unsigned char) *string << (i % CHAR_BIT));\n   return result;\n }\n \n-/* Given two constant definitions, return true if they have the same name.  */\n+/* Given two objects that start with char * name fields, return true if\n+   they have the same name.  */\n static int\n def_name_eq_p (const void *def1, const void *def2)\n {\n-  return ! strcmp (((const struct md_constant *) def1)->name,\n-\t\t   ((const struct md_constant *) def2)->name);\n+  return ! strcmp (*(const char *const *) def1,\n+\t\t   *(const char *const *) def2);\n }\n \n /* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable\n@@ -504,6 +970,102 @@ validate_const_int (FILE *infile, const char *string)\n     fatal_with_file_and_line (infile, \"invalid decimal constant \\\"%s\\\"\\n\", string);\n }\n \n+/* Search GROUP for a mode or code called NAME and return its numerical\n+   identifier.  INFILE is the file that contained NAME.  */\n+\n+static int\n+find_macro (struct macro_group *group, const char *name, FILE *infile)\n+{\n+  struct mapping *m;\n+\n+  m = (struct mapping *) htab_find (group->macros, &name);\n+  if (m != 0)\n+    return m->index + group->num_builtins;\n+  return group->find_builtin (name, infile);\n+}\n+\n+/* Finish reading a declaration of the form:\n+\n+       (define... <name> [<value1> ... <valuen>])\n+\n+   from INFILE, where each <valuei> is either a bare symbol name or a\n+   \"(<name> <string>)\" pair.  The \"(define...\" part has already been read.\n+\n+   Represent the declaration as a \"mapping\" structure; add it to TABLE\n+   (which belongs to GROUP) and return it.  */\n+\n+static struct mapping *\n+read_mapping (struct macro_group *group, htab_t table, FILE *infile)\n+{\n+  char tmp_char[256];\n+  struct mapping *m;\n+  struct map_value **end_ptr;\n+  const char *string;\n+  int number, c;\n+\n+  /* Read the mapping name and create a structure for it.  */\n+  read_name (tmp_char, infile);\n+  m = add_mapping (group, table, tmp_char, infile);\n+\n+  c = read_skip_spaces (infile);\n+  if (c != '[')\n+    fatal_expected_char (infile, '[', c);\n+\n+  /* Read each value.  */\n+  end_ptr = &m->values;\n+  c = read_skip_spaces (infile);\n+  do\n+    {\n+      if (c != '(')\n+\t{\n+\t  /* A bare symbol name that is implicitly paired to an\n+\t     empty string.  */\n+\t  ungetc (c, infile);\n+\t  read_name (tmp_char, infile);\n+\t  string = \"\";\n+\t}\n+      else\n+\t{\n+\t  /* A \"(name string)\" pair.  */\n+\t  read_name (tmp_char, infile);\n+\t  string = read_string (infile, false);\n+\t  c = read_skip_spaces (infile);\n+\t  if (c != ')')\n+\t    fatal_expected_char (infile, ')', c);\n+\t}\n+      number = group->find_builtin (tmp_char, infile);\n+      end_ptr = add_map_value (end_ptr, number, string);\n+      c = read_skip_spaces (infile);\n+    }\n+  while (c != ']');\n+\n+  c = read_skip_spaces (infile);\n+  if (c != ')')\n+    fatal_expected_char (infile, ')', c);\n+\n+  return m;\n+}\n+\n+/* Check newly-created code macro MACRO to see whether every code has the\n+   same format.  Initialize the macro's entry in bellwether_codes.  */\n+\n+static void\n+check_code_macro (struct mapping *macro, FILE *infile)\n+{\n+  struct map_value *v;\n+  enum rtx_code bellwether;\n+\n+  bellwether = macro->values->number;\n+  for (v = macro->values->next; v != 0; v = v->next)\n+    if (strcmp (GET_RTX_FORMAT (bellwether), GET_RTX_FORMAT (v->number)) != 0)\n+      fatal_with_file_and_line (infile, \"code macro `%s' combines \"\n+\t\t\t\t\"different rtx formats\", macro->name);\n+\n+  bellwether_codes = XRESIZEVEC (enum rtx_code, bellwether_codes,\n+\t\t\t\t macro->index + 1);\n+  bellwether_codes[macro->index] = bellwether;\n+}\n+\n /* Read an rtx in printed representation from INFILE\n    and return an actual rtx in core constructed accordingly.\n    read_rtx is not used in the compiler proper, but rather in\n@@ -512,8 +1074,42 @@ validate_const_int (FILE *infile, const char *string)\n rtx\n read_rtx (FILE *infile)\n {\n-  int i, j;\n-  RTX_CODE tmp_code;\n+  static rtx queue_head, queue_next;\n+  rtx return_rtx;\n+\n+  /* Do one-time initialization.  */\n+  if (queue_head == 0)\n+    {\n+      initialize_macros ();\n+      obstack_init (&string_obstack);\n+      queue_head = rtx_alloc (EXPR_LIST);\n+    }\n+\n+  if (queue_next == 0)\n+    {\n+      queue_next = queue_head;\n+\n+      XEXP (queue_next, 0) = read_rtx_1 (infile);\n+      XEXP (queue_next, 1) = 0;\n+\n+      htab_traverse (modes.macros, apply_macro_traverse, queue_next);\n+      htab_traverse (codes.macros, apply_macro_traverse, queue_next);\n+    }\n+\n+  return_rtx = XEXP (queue_next, 0);\n+  queue_next = XEXP (queue_next, 1);\n+\n+  return return_rtx;\n+}\n+\n+/* Subroutine of read_rtx that reads one construct from INFILE but\n+   doesn't apply any macros.  */\n+\n+static rtx\n+read_rtx_1 (FILE *infile)\n+{\n+  int i;\n+  RTX_CODE real_code, bellwether_code;\n   const char *format_ptr;\n   /* tmp_char is a buffer used for reading decimal integers\n      and names of rtx types and machine modes.\n@@ -524,60 +1120,59 @@ read_rtx (FILE *infile)\n   int tmp_int;\n   HOST_WIDE_INT tmp_wide;\n \n-  static int initialized;\n-\n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n     {\n       struct rtx_list *next;\n       rtx value;\t\t/* Value of this node.  */\n     };\n \n-  if (!initialized)\n-    {\n-      obstack_init (&string_obstack);\n-      initialized = 1;\n-    }\n-\n-again:\n+ again:\n   c = read_skip_spaces (infile); /* Should be open paren.  */\n   if (c != '(')\n     fatal_expected_char (infile, '(', c);\n \n   read_name (tmp_char, infile);\n-\n-  tmp_code = UNKNOWN;\n-  for (i = 0; i < NUM_RTX_CODE; i++)\n-    if (! strcmp (tmp_char, GET_RTX_NAME (i)))\n-      {\n-\ttmp_code = (RTX_CODE) i;\t/* get value for name */\n-\tbreak;\n-      }\n-\n-  if (tmp_code == UNKNOWN)\n+  if (strcmp (tmp_char, \"nil\") == 0)\n     {\n       /* (nil) stands for an expression that isn't there.  */\n-      if (! strcmp (tmp_char, \"nil\"))\n-\t{\n-\t  /* Discard the closeparen.  */\n-\t  c = read_skip_spaces (infile);\n-\t  if (c != ')')\n-\t    fatal_expected_char (infile, ')', c);\n-\t  return 0;\n-\t}\n-      /* (define_constants ...) has special syntax.  */\n-      else if (! strcmp (tmp_char, \"define_constants\"))\n-\t{\n-\t  read_constants (infile, tmp_char);\n-\t  goto again;\n-\t}\n-      else \n-\tfatal_with_file_and_line (infile, \"unknown rtx code `%s'\", tmp_char);\n+      c = read_skip_spaces (infile);\n+      if (c != ')')\n+\tfatal_expected_char (infile, ')', c);\n+      return 0;\n+    }\n+  if (strcmp (tmp_char, \"define_constants\") == 0)\n+    {\n+      read_constants (infile, tmp_char);\n+      goto again;\n+    }\n+  if (strcmp (tmp_char, \"define_mode_attr\") == 0)\n+    {\n+      read_mapping (&modes, modes.attrs, infile);\n+      goto again;\n+    }\n+  if (strcmp (tmp_char, \"define_mode_macro\") == 0)\n+    {\n+      read_mapping (&modes, modes.macros, infile);\n+      goto again;\n+    }\n+  if (strcmp (tmp_char, \"define_code_attr\") == 0)\n+    {\n+      read_mapping (&codes, codes.attrs, infile);\n+      goto again;\n+    }\n+  if (strcmp (tmp_char, \"define_code_macro\") == 0)\n+    {\n+      check_code_macro (read_mapping (&codes, codes.macros, infile), infile);\n+      goto again;\n     }\n+  real_code = find_macro (&codes, tmp_char, infile);\n+  bellwether_code = BELLWETHER_CODE (real_code);\n \n   /* If we end up with an insn expression then we free this space below.  */\n-  return_rtx = rtx_alloc (tmp_code);\n-  format_ptr = GET_RTX_FORMAT (GET_CODE (return_rtx));\n+  return_rtx = rtx_alloc (bellwether_code);\n+  format_ptr = GET_RTX_FORMAT (bellwether_code);\n+  PUT_CODE (return_rtx, real_code);\n \n   /* If what follows is `: mode ', read it and\n      store the mode in the rtx.  */\n@@ -586,14 +1181,7 @@ read_rtx (FILE *infile)\n   if (i == ':')\n     {\n       read_name (tmp_char, infile);\n-      for (j = 0; j < NUM_MACHINE_MODES; j++)\n-\tif (! strcmp (GET_MODE_NAME (j), tmp_char))\n-\t  break;\n-\n-      if (j == MAX_MACHINE_MODE)\n-\tfatal_with_file_and_line (infile, \"unknown mode `%s'\", tmp_char);\n-\n-      PUT_MODE (return_rtx, (enum machine_mode) j);\n+      PUT_MODE (return_rtx, find_macro (&modes, tmp_char, infile));\n     }\n   else\n     ungetc (i, infile);\n@@ -608,7 +1196,7 @@ read_rtx (FILE *infile)\n \n       case 'e':\n       case 'u':\n-\tXEXP (return_rtx, i) = read_rtx (infile);\n+\tXEXP (return_rtx, i) = read_rtx_1 (infile);\n \tbreak;\n \n       case 'V':\n@@ -640,7 +1228,7 @@ read_rtx (FILE *infile)\n \t    {\n \t      ungetc (c, infile);\n \t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_rtx (infile));\n+\t      obstack_ptr_grow (&vector_stack, read_rtx_1 (infile));\n \t    }\n \t  if (list_counter > 0)\n \t    {"}]}