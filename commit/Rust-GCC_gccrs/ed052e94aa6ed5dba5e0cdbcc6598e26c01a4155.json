{"sha": "ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQwNTJlOTRhYTZlZDVkYmE1ZTBjZGJjYzY1OThlMjZjMDFhNDE1NQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2014-09-23T18:48:50Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2014-09-23T18:48:50Z"}, "message": "Relax check against commuting XOR and ASHIFTRT in combine.c\n\ngcc/:\n\t* combine.c (simplify_shift_const_1): Allow commuting (ashiftrt (xor))\n\twhen result_mode == shift_mode.\n\ngcc/testsuite/:\n\t* gcc.dg/combine_ashiftrt_1.c: New test.\n\t* gcc.dg/combine_ashiftrt_2.c: Likewise.\n\t* gcc.target/aarch64/singleton_intrinsics_1.c: Remove scan-assembler\n\tworkarounds for cmge.\n\t* gcc.target/aarch64/simd/int_comparisons_1.c: Likewise; also check for\n\tabsence of mvn.\n\nFrom-SVN: r215531", "tree": {"sha": "47cef1bb0f85000c179234d0ef6b784b47d581b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47cef1bb0f85000c179234d0ef6b784b47d581b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/comments", "author": null, "committer": null, "parents": [{"sha": "43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b1b9edfcd5aeb8fe5ca012c81cdd8d4259de04"}], "stats": {"total": 77, "additions": 64, "deletions": 13}, "files": [{"sha": "651497d39598b61d46f74cf482aa90c1f3a72448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -1,3 +1,8 @@\n+2014-09-23  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* combine.c (simplify_shift_const_1): Allow commuting (ashiftrt (xor))\n+\twhen result_mode == shift_mode.\n+\n 2014-09-23  Kostya Serebryany  <kcc@google.com>\n \n \tUpdate to match the changed asan API."}, {"sha": "1457eabadf9f6e2c761f921eaa5380491ebaec22", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -10255,8 +10255,10 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \n \t  if (CONST_INT_P (XEXP (varop, 1))\n \t      /* We can't do this if we have (ashiftrt (xor))  and the\n-\t\t constant has its sign bit set in shift_mode.  */\n+\t\t constant has its sign bit set in shift_mode with shift_mode\n+\t\t wider than result_mode.  */\n \t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n+\t\t   && result_mode != shift_mode\n \t\t   && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t      shift_mode))\n \t      && (new_rtx = simplify_const_binary_operation\n@@ -10273,10 +10275,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \n \t  /* If we can't do that, try to simplify the shift in each arm of the\n \t     logical expression, make a new logical expression, and apply\n-\t     the inverse distributive law.  This also can't be done\n-\t     for some (ashiftrt (xor)).  */\n+\t     the inverse distributive law.  This also can't be done for\n+\t     (ashiftrt (xor)) where we've widened the shift and the constant\n+\t     changes the sign bit.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n \t     && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n+\t\t  && result_mode != shift_mode\n \t\t  && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t     shift_mode)))\n \t    {"}, {"sha": "14d65db75aa85091412b8af11446c57c98fe636a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -1,3 +1,12 @@\n+2014-09-23  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* gcc.dg/combine_ashiftrt_1.c: New test.\n+\t* gcc.dg/combine_ashiftrt_2.c: Likewise.\n+\t* gcc.target/aarch64/singleton_intrinsics_1.c: Remove scan-assembler\n+\tworkarounds for cmge.\n+\t* gcc.target/aarch64/simd/int_comparisons_1.c: Likewise; also check for\n+\tabsence of mvn.\n+\n 2014-09-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/61857"}, {"sha": "90e64fd10dc358f10ad03a90041605bc3ccb7011", "filename": "gcc/testsuite/gcc.dg/combine_ashiftrt_1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_1.c?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile {target sparc64*-*-* aarch64*-*-* x86_64-*-* powerpc64*-*-*} } */\n+/* { dg-options \"-O2 -fdump-rtl-combine-all\" } */\n+\n+typedef long long int int64_t;\n+\n+int64_t\n+foo (int64_t a)\n+{\n+  return (~a) >> 63;\n+}\n+\n+/* The combine phase will try to combine not & ashiftrt, and\n+   combine_simplify_rtx should transform (ashiftrt (not x) 63)\n+   to (not (ashiftrt x 63)) and then to (neg (ge x 0)). We look for\n+   the *attempt* to match this RTL pattern, regardless of whether an\n+   actual insn may be found on the platform.  */\n+/* { dg-final { scan-rtl-dump \"\\\\(neg:DI \\\\(ge:DI\" \"combine\" } } */\n+/* { dg-final { cleanup-rtl-dump \"combine\" } } */"}, {"sha": "fd6827caed230ea5dd2d6ec4431b11bf826531ea", "filename": "gcc/testsuite/gcc.dg/combine_ashiftrt_2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcombine_ashiftrt_2.c?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile {target arm*-*-* i?86-*-* powerpc-*-* sparc-*-*} } */\n+/* { dg-options \"-O2 -fdump-rtl-combine-all\" } */\n+\n+typedef long int32_t;\n+\n+int32_t\n+foo (int32_t a)\n+{\n+  return (~a) >> 31;\n+}\n+\n+/* The combine phase will try to combine not & ashiftrt, and\n+   combine_simplify_rtx should transform (ashiftrt (not x) 31)\n+   to (not (ashiftrt x 63)) and then to (neg (ge x 0)). We look for\n+   the *attempt* to match this RTL pattern, regardless of whether an\n+   actual insn may be found on the platform.  */\n+/* { dg-final { scan-rtl-dump \"\\\\(neg:SI \\\\(ge:SI\" \"combine\" } } */\n+/* { dg-final { cleanup-rtl-dump \"combine\" } } */"}, {"sha": "f2c55922f18c0e6840c403f419fe4a98a15e5f97", "filename": "gcc/testsuite/gcc.target/aarch64/simd/int_comparisons_1.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fint_comparisons_1.c?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -30,18 +30,16 @@\n /* Comparisons against immediate zero, on the 8 signed integer types only.  */\n \n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n-/*  For int64_t and int64x1_t, combine_simplify_rtx failure of\n-    https://gcc.gnu.org/ml/gcc/2014-06/msg00253.html\n-    prevents generation of cmge....#0, instead producing mvn + sshr.  */\n-/* { #dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\]cmge\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmgt\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmle\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmle\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?0\" 2 } } */\n /* { dg-final { scan-assembler-times \"\\[ \\t\\]cmlt\\[ \\t\\]+v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*v\\[0-9\\]+\\.\\[0-9\\]+\\[bshd\\],\\[ \\t\\]*#?0\" 7 } } */\n /* For int64_t and int64x1_t, cmlt ... #0 and sshr ... #63 are equivalent,\n-   so allow either.  cmgez issue above results in extra 2 * sshr....63.  */\n-/* { dg-final { scan-assembler-times \"\\[ \\t\\](?:cmlt|sshr)\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?(?:0|63)\" 4 } } */\n+   so allow either.  */\n+/* { dg-final { scan-assembler-times \"\\[ \\t\\](?:cmlt|sshr)\\[ \\t\\]+d\\[0-9\\]+,\\[ \\t\\]*d\\[0-9\\]+,\\[ \\t\\]*#?(?:0|63)\" 2 } } */\n \n // All should have been compiled into single insns without inverting result:\n /* { dg-final { scan-assembler-not \"\\[ \\t\\]not\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]mvn\\[ \\t\\]\" } } */"}, {"sha": "4a0934b01f9442b7f1324a1f4528d45022daf9b8", "filename": "gcc/testsuite/gcc.target/aarch64/singleton_intrinsics_1.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsingleton_intrinsics_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsingleton_intrinsics_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsingleton_intrinsics_1.c?ref=ed052e94aa6ed5dba5e0cdbcc6598e26c01a4155", "patch": "@@ -57,8 +57,7 @@ test_vcle_s64 (int64x1_t a, int64x1_t b)\n   return vcle_s64 (a, b);\n }\n \n-/* Idiom recognition will cause this testcase not to generate\n-   the expected cmge instruction, so do not check for it.  */\n+/* { dg-final { scan-assembler-times \"\\\\tcmge\\\\td\\[0-9\\]+, d\\[0-9\\]+, #?0\" 1 } } */\n \n uint64x1_t\n test_vcgez_s64 (int64x1_t a)\n@@ -236,8 +235,8 @@ test_vrshl_u64 (uint64x1_t a, int64x1_t b)\n   return vrshl_u64 (a, b);\n }\n \n-/* { dg-final { scan-assembler-times \"\\\\tsshr\\\\td\\[0-9\\]+\" 3 } } */\n-/* Idiom recognition compiles vcltz and vcgez to sshr rather than cmlt/cmge.  */\n+/* For int64x1_t, sshr...#63 is output instead of the equivalent cmlt...#0.  */\n+/* { dg-final { scan-assembler-times \"\\\\tsshr\\\\td\\[0-9\\]+\" 2 } } */\n \n int64x1_t\n test_vshr_n_s64 (int64x1_t a)"}]}