{"sha": "af232d48a7e011bf85d12634644ce80c1ad6480d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyMzJkNDhhN2UwMTFiZjg1ZDEyNjM0NjQ0Y2U4MGMxYWQ2NDgwZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-07-26T07:30:37Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-07-26T07:30:37Z"}, "message": "trans-array.c (CAF_TOKEN_FIELD): New macro constant.\n\n2011-07-26  Tobias Burnus  <burnus@net-b.de>\n\n        * trans-array.c (CAF_TOKEN_FIELD): New macro constant.\n        (gfc_conv_descriptor_token): New function.\n        * trans-array.h (gfc_conv_descriptor_token): New prototype.\n        * trans-types.c (gfc_get_array_descriptor_base): For coarrays\n        with -fcoarray=lib, append \"void *token\" to the array descriptor.\n        (gfc_array_descriptor_base_caf): New static variable.\n        * trans-expr.c (gfc_conv_procedure_call): Handle token and\n        * offset\n        when passing a descriptor coarray to a nondescriptor dummy.\n\n2011-07-26  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_lib_token_2.f90: New.\n\nFrom-SVN: r176784", "tree": {"sha": "7605607503ae92b280d32db1d07f72f9865b92a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7605607503ae92b280d32db1d07f72f9865b92a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af232d48a7e011bf85d12634644ce80c1ad6480d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af232d48a7e011bf85d12634644ce80c1ad6480d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af232d48a7e011bf85d12634644ce80c1ad6480d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af232d48a7e011bf85d12634644ce80c1ad6480d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "335d2e3964ccd360d718bbad6c9ff616acf8e65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335d2e3964ccd360d718bbad6c9ff616acf8e65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335d2e3964ccd360d718bbad6c9ff616acf8e65a"}], "stats": {"total": 226, "additions": 205, "deletions": 21}, "files": [{"sha": "9537bbfa73b550a39ef74441e783bf8eecb483f4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -1,3 +1,14 @@\n+2011-07-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-array.c (CAF_TOKEN_FIELD): New macro constant.\n+\t(gfc_conv_descriptor_token): New function.\n+\t* trans-array.h (gfc_conv_descriptor_token): New prototype.\n+\t* trans-types.c (gfc_get_array_descriptor_base): For coarrays\n+\twith -fcoarray=lib, append \"void *token\" to the array descriptor.\n+\t(gfc_array_descriptor_base_caf): New static variable.\n+\t* trans-expr.c (gfc_conv_procedure_call): Handle token and offset\n+\twhen passing a descriptor coarray to a nondescriptor dummy. \n+\n 2011-07-23  Tobias Burnus  <burnus@net-b.de>\n \n \t* resolve.c (resolve_symbol): Fix coarray var decl check."}, {"sha": "ff059a3e988c16efd6a7ecd1cc0acf6718689d08", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -129,6 +129,7 @@ gfc_array_dataptr_type (tree desc)\n #define OFFSET_FIELD 1\n #define DTYPE_FIELD 2\n #define DIMENSION_FIELD 3\n+#define CAF_TOKEN_FIELD 4\n \n #define STRIDE_SUBFIELD 0\n #define LBOUND_SUBFIELD 1\n@@ -267,6 +268,24 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n   return tmp;\n }\n \n+\n+tree\n+gfc_conv_descriptor_token (tree desc)\n+{\n+  tree type;\n+  tree field;\n+\n+  type = TREE_TYPE (desc);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), CAF_TOKEN_FIELD);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == prvoid_type_node);\n+\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n+}\n+\n+\n static tree\n gfc_conv_descriptor_stride (tree desc, tree dim)\n {\n@@ -429,6 +448,7 @@ gfc_conv_shift_descriptor_lbound (stmtblock_t* block, tree desc,\n #undef OFFSET_FIELD\n #undef DTYPE_FIELD\n #undef DIMENSION_FIELD\n+#undef CAF_TOKEN_FIELD\n #undef STRIDE_SUBFIELD\n #undef LBOUND_SUBFIELD\n #undef UBOUND_SUBFIELD"}, {"sha": "61f7042c9c007acc7a10feebbf466831dc9c30ae", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -143,6 +143,7 @@ tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_stride_get (tree, tree);\n tree gfc_conv_descriptor_lbound_get (tree, tree);\n tree gfc_conv_descriptor_ubound_get (tree, tree);\n+tree gfc_conv_descriptor_token (tree);\n \n void gfc_conv_descriptor_data_set (stmtblock_t *, tree, tree);\n void gfc_conv_descriptor_offset_set (stmtblock_t *, tree, tree);"}, {"sha": "96510c2c294984d158bd4d4e82592e4de9151622", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -3395,48 +3395,62 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (fsym && fsym->attr.codimension\n \t  && gfc_option.coarray == GFC_FCOARRAY_LIB\n \t  && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n-\t  && (e == NULL\n-\t      || GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (get_tree_for_caf_expr (e)))))\n-\t  /* FIXME: Remove the \"||\" condition when coarray descriptors have a\n-\t     \"token\" component. This condition occurs when passing an alloc\n-\t      coarray or assumed-shape dummy to an explict-shape dummy.  */\n+\t  && e == NULL)\n \t{\n \t  /* Token and offset. */\n \t  VEC_safe_push (tree, gc, stringargs, null_pointer_node);\n \t  VEC_safe_push (tree, gc, stringargs,\n \t\t\t build_int_cst (gfc_array_index_type, 0));\n-\t  gcc_assert (fsym->attr.optional || e != NULL); /* FIXME: \"||\" cond.  */\n+\t  gcc_assert (fsym->attr.optional);\n \t}\n       else if (fsym && fsym->attr.codimension\n \t       && !fsym->attr.allocatable && fsym->as->type != AS_ASSUMED_SHAPE\n \t       && gfc_option.coarray == GFC_FCOARRAY_LIB)\n \t{\n \t  tree caf_decl, caf_type;\n-\t  tree offset;\n+\t  tree offset, tmp2;\n \n-          caf_decl = get_tree_for_caf_expr (e);\n+\t  caf_decl = get_tree_for_caf_expr (e);\n \t  caf_type = TREE_TYPE (caf_decl);\n \n-\t  gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n-\t\t      && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n+\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n+\t    tmp = gfc_conv_descriptor_token (caf_decl);\n+\t  else\n+\t    {\n+\t      gcc_assert (GFC_ARRAY_TYPE_P (caf_type)\n+\t\t\t  && GFC_TYPE_ARRAY_CAF_TOKEN (caf_type) != NULL_TREE);\n+\t      tmp = GFC_TYPE_ARRAY_CAF_TOKEN (caf_type);\n+\t    }\n \t  \n-\t  VEC_safe_push (tree, gc, stringargs,\n-\t\t\t GFC_TYPE_ARRAY_CAF_TOKEN (caf_type));\n+\t  VEC_safe_push (tree, gc, stringargs, tmp);\n \n-\t  if (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) != NULL_TREE)\n+\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n+\t    offset = build_int_cst (gfc_array_index_type, 0);\n+\t  else if (GFC_TYPE_ARRAY_CAF_OFFSET (caf_type) != NULL_TREE)\n \t    offset = GFC_TYPE_ARRAY_CAF_OFFSET (caf_type);\n \t  else\n \t    offset = build_int_cst (gfc_array_index_type, 0);\n \n-\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (caf_decl))\n-\t\t      && POINTER_TYPE_P (TREE_TYPE (parmse.expr)));\n+\t  if (GFC_DESCRIPTOR_TYPE_P (caf_type))\n+\t    tmp = gfc_conv_descriptor_data_get (caf_decl);\n+\t  else\n+\t    {\n+\t      gcc_assert (POINTER_TYPE_P (caf_type));\n+\t      tmp = caf_decl;\n+\t    }\n+\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (parmse.expr)))\n+\t    tmp2 = gfc_conv_descriptor_data_get (parmse.expr);\n+\t  else\n+\t    {\n+\t      gcc_assert (POINTER_TYPE_P (TREE_TYPE (parmse.expr)));\n+\t      tmp2 = parmse.expr;\n+\t    }\n \n \t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n                                  gfc_array_index_type,\n-                                 fold_convert (gfc_array_index_type,\n-\t\t\t\t\t       parmse.expr),\n-                                 fold_convert (gfc_array_index_type,\n-\t\t\t\t\t       caf_decl));\n+                                 fold_convert (gfc_array_index_type, tmp2),\n+                                 fold_convert (gfc_array_index_type, tmp));\n \t  offset = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t    gfc_array_index_type, offset, tmp);\n "}, {"sha": "b66941f366a88d5da9bc3ecd30369f32739147eb", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -81,6 +81,7 @@ bool gfc_real16_is_float128 = false;\n static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n static GTY(()) tree gfc_array_descriptor_base[2 * GFC_MAX_DIMENSIONS];\n+static GTY(()) tree gfc_array_descriptor_base_caf[2 * GFC_MAX_DIMENSIONS];\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n    after the target has a chance to process command-line options.  */\n@@ -1623,7 +1624,13 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n   int idx = 2 * (codimen + dimen - 1) + restricted;\n \n   gcc_assert (codimen + dimen >= 1 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n-  if (gfc_array_descriptor_base[idx])\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+    {\n+      if (gfc_array_descriptor_base_caf[idx])\n+\treturn gfc_array_descriptor_base_caf[idx];\n+    }\n+  else if (gfc_array_descriptor_base[idx])\n     return gfc_array_descriptor_base[idx];\n \n   /* Build the type node.  */\n@@ -1664,11 +1671,23 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n \t\t\t\t    arraytype, &chain);\n   TREE_NO_WARNING (decl) = 1;\n \n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+    {\n+      decl = gfc_add_field_to_struct_1 (fat_type,\n+\t\t\t\t\tget_identifier (\"token\"),\n+\t\t\t\t\tprvoid_type_node, &chain);\n+      TREE_NO_WARNING (decl) = 1;\n+    }\n+\n   /* Finish off the type.  */\n   gfc_finish_type (fat_type);\n   TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (fat_type)) = 1;\n \n-  gfc_array_descriptor_base[idx] = fat_type;\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n+    gfc_array_descriptor_base_caf[idx] = fat_type;\n+  else\n+    gfc_array_descriptor_base[idx] = fat_type;\n+\n   return fat_type;\n }\n "}, {"sha": "1e351fec20e161a858b78c07a4e17d772a3639a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -1,3 +1,7 @@\n+2011-07-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lib_token_2.f90: New.\n+\n 2011-07-26  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* gcc.dg/vect/vect-70.c: Reduce the data size to fit"}, {"sha": "dd37875914813a6034f9736d4f6ddf1f0f98f4f3", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_token_2.f90", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af232d48a7e011bf85d12634644ce80c1ad6480d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_token_2.f90?ref=af232d48a7e011bf85d12634644ce80c1ad6480d", "patch": "@@ -0,0 +1,115 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib -fdump-tree-original\" }\n+!\n+! Check whether TOKEN and OFFSET are correctly propagated\n+! \n+\n+! THIS PART FAILED (ICE) DUE TO TYPE SHARING\n+\n+module matrix_data\n+   implicit none\n+   type sparse_CSR_matrix\n+      integer, allocatable :: a(:)\n+   end type sparse_CSR_matrix\n+CONTAINS\n+\n+subroutine build_CSR_matrix(CSR)\n+   type(sparse_CSR_matrix), intent(out) :: CSR\n+   integer, allocatable :: CAF_begin[:]\n+   call global_to_local_index(CAF_begin)\n+end subroutine build_CSR_matrix\n+\n+subroutine global_to_local_index(CAF_begin)\n+   integer, intent(out) :: CAF_begin[*]\n+end subroutine  global_to_local_index\n+\n+end module matrix_data\n+\n+\n+! DUMP TESTING\n+\n+program main\n+  implicit none\n+  type t\n+    integer(4) :: a, b\n+  end type t\n+  integer, allocatable :: caf[:]\n+  type(t), allocatable :: caf_dt[:]\n+\n+  allocate (caf[*])\n+  allocate (caf_dt[*])\n+\n+  caf = 42\n+  caf_dt = t (1,2)\n+  call sub (caf, caf_dt%b)\n+  print *,caf, caf_dt%b\n+  if (caf /= -99 .or. caf_dt%b /= -101) call abort ()\n+  call sub_opt ()\n+  call sub_opt (caf)\n+  if (caf /= 124) call abort ()\n+contains\n+\n+  subroutine sub (x1, x2)\n+    integer :: x1[*], x2[*]\n+    call sub2 (x1, x2)\n+  end subroutine sub\n+\n+  subroutine sub2 (y1, y2)\n+    integer :: y1[*], y2[*]\n+\n+    print *, y1, y2\n+    if (y1 /= 42 .or. y2 /= 2) call abort ()\n+    y1 = -99\n+    y2 = -101\n+  end subroutine sub2\n+\n+  subroutine sub_opt (z)\n+    integer, optional :: z[*]\n+    if (present (z)) then\n+      if (z /= -99) call abort ()\n+      z = 124\n+    end if\n+  end subroutine sub_opt\n+\n+end program main\n+\n+! SCAN TREE DUMP AND CLEANUP\n+!\n+! PROTOTYPE 1:\n+!\n+! sub (integer(kind=4) * restrict x1, integer(kind=4) * restrict x2,\n+!      void * restrict caf_token.4, integer(kind=8) caf_offset.5,\n+!      void * restrict caf_token.6, integer(kind=8) caf_offset.7)\n+!\n+! { dg-final { scan-tree-dump-times \"sub \\\\(integer.kind=4. . restrict x1, integer.kind=4. . restrict x2, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\"} }\n+!\n+! PROTOTYPE 2:\n+!\n+! sub2 (integer(kind=4) * restrict y1, integer(kind=4) * restrict y2,\n+!       void * restrict caf_token.0, integer(kind=8) caf_offset.1,\n+!       void * restrict caf_token.2, integer(kind=8) caf_offset.3)\n+!\n+! { dg-final { scan-tree-dump-times \"sub2 \\\\(integer.kind=4. . restrict y1, integer.kind=4. . restrict y2, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+, void . restrict caf_token.\\[0-9\\]+, integer.kind=.. caf_offset.\\[0-9\\]+\\\\)\" 1 \"original\"} }\n+!\n+! CALL 1\n+!\n+!  sub ((integer(kind=4) *) caf.data, &((struct t * restrict) caf_dt.data)->b,\n+!       caf.token, 0, caf_dt.token, 4);\n+!\n+! { dg-final { scan-tree-dump-times \"sub \\\\(\\[^,\\]*caf.data, &\\[^,\\]*caf_dt.data.->b, caf.token, 0, caf_dt.token, 4\\\\)\" 1 \"original\"} }\n+!\n+!  sub2 ((integer(kind=4) *) x1, (integer(kind=4) *) x2,\n+!        caf_token.4, NON_LVALUE_EXPR <caf_offset.5>,\n+!        caf_token.6, NON_LVALUE_EXPR <caf_offset.7>);\n+!\n+! { dg-final { scan-tree-dump-times \"sub2 \\\\(\\[^,\\]*x1, \\[^,\\]*x2, caf_token.\\[0-9]+, \\[^,\\]*caf_offset\\[^,\\]*, caf_token.\\[0-9\\]+, \\[^,\\]*caf_offset\\[^,\\]*\\\\)\" 1 \"original\"} }\n+!\n+! CALL 3\n+!\n+! { dg-final { scan-tree-dump-times \"sub_opt \\\\(0B, 0B, 0\\\\)\" 1 \"original\"} }\n+!\n+! CALL 4\n+!\n+! { dg-final { scan-tree-dump-times \"sub_opt \\\\(.integer.kind=4. .. caf.data, caf.token, 0\\\\)\" 1 \"original\"} }\n+!\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}