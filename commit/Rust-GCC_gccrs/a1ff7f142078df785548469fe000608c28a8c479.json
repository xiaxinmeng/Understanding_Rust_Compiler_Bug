{"sha": "a1ff7f142078df785548469fe000608c28a8c479", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFmZjdmMTQyMDc4ZGY3ODU1NDg0NjlmZTAwMDYwOGMyOGE4YzQ3OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-12-05T15:53:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-12-05T15:53:03Z"}, "message": "Use unsigned arithmetic for demoted vector plus/minus/mult (PR 88064)\n\nAs Jakub pointed out, if we narrow a plus, minus or mult operation based\non the number of bits that consumers need, we have to convert a signed\noperation to an unsigned one in order to avoid new undefined behaviour.\nThis patch does that and generalises vect_convert_input and\nvect_recog_over_widening_pattern to cope with the extra casts.\n(The changes to both functions are covered by existing tests.)\n\n2018-12-03  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/88064\n\t* tree-vect-patterns.c (vect_convert_input): Convert the result of\n\tan existing cast if it has the right width but the wrong sign.\n\tDo not test the signedness of the required result when\n\tconsidering whether to split an existing cast; instead split to\n\ta type with the same signedness as the source of the cast, then\n\tconvert it to the opposite signedness where necessary.\n\t(vect_recog_over_widening_pattern): Handle sign changes between\n\tthe final PLUS_EXPR and the RSHIFT_EXPR.\n\t(vect_recog_average_pattern): Use an unsigned operation when\n\ttruncating an addition, subtraction or multiplication.  Cast the\n\tresult back to the \"real\" signedness before promoting.\n\ngcc/testsuite/\n\tPR tree-optimization/88064\n\t* gcc.dg/vect/vect-over-widen-23.c: New test.\n\nFrom-SVN: r266829", "tree": {"sha": "7d45b3f40f7f93cfdd99b2f8c29863d603d74206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d45b3f40f7f93cfdd99b2f8c29863d603d74206"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ff7f142078df785548469fe000608c28a8c479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ff7f142078df785548469fe000608c28a8c479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ff7f142078df785548469fe000608c28a8c479", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ff7f142078df785548469fe000608c28a8c479/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1cf20b6fc16268a54fd217844af93e644fdaced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1cf20b6fc16268a54fd217844af93e644fdaced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1cf20b6fc16268a54fd217844af93e644fdaced"}], "stats": {"total": 149, "additions": 125, "deletions": 24}, "files": [{"sha": "27b53d3e1a3189ab8a97156e9d83314a9a4dec7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ff7f142078df785548469fe000608c28a8c479/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ff7f142078df785548469fe000608c28a8c479/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1ff7f142078df785548469fe000608c28a8c479", "patch": "@@ -1,3 +1,18 @@\n+2018-12-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/88064\n+\t* tree-vect-patterns.c (vect_convert_input): Convert the result of\n+\tan existing cast if it has the right width but the wrong sign.\n+\tDo not test the signedness of the required result when\n+\tconsidering whether to split an existing cast; instead split to\n+\ta type with the same signedness as the source of the cast, then\n+\tconvert it to the opposite signedness where necessary.\n+\t(vect_recog_over_widening_pattern): Handle sign changes between\n+\tthe final PLUS_EXPR and the RSHIFT_EXPR.\n+\t(vect_recog_average_pattern): Use an unsigned operation when\n+\ttruncating an addition, subtraction or multiplication.  Cast the\n+\tresult back to the \"real\" signedness before promoting.\n+\n 2018-12-05  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/86637"}, {"sha": "77dbe743406b66c8356584d9e8d3a25effcc746f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a1ff7f142078df785548469fe000608c28a8c479", "patch": "@@ -1,3 +1,8 @@\n+2018-12-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/88064\n+\t* gcc.dg/vect/vect-over-widen-23.c: New test.\n+\n 2018-12-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* lib/gcc-dg.exp (process-message): Change verbosity level of"}, {"sha": "a6c48831020679ea924f44fe15491a81b60e3b72", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-23.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-23.c?ref=a1ff7f142078df785548469fe000608c28a8c479", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-forwprop -fno-tree-vrp\" }\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#if VECTOR_BITS > 128\n+#define N (VECTOR_BITS / 2)\n+#else\n+#define N 64\n+#endif\n+\n+int a[N], b[N], c[N];\n+\n+void\n+foo ()\n+{\n+  int i;\n+  for (i = 0; i < N; i++)\n+    {\n+      long long d = a[i];\n+      long long e = b[i];\n+      d += e;\n+      c[i] = d;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {VIEW_CONVERT_EXPR<vector[^ ]* unsigned} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "b216012a5e018649519d2baaf0edf5085b07d3f9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ff7f142078df785548469fe000608c28a8c479/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=a1ff7f142078df785548469fe000608c28a8c479", "patch": "@@ -720,34 +720,60 @@ vect_convert_input (stmt_vec_info stmt_info, tree type,\n   if (TREE_CODE (unprom->op) == INTEGER_CST)\n     return wide_int_to_tree (type, wi::to_widest (unprom->op));\n \n-  /* See if we can reuse an existing result.  */\n+  tree input = unprom->op;\n   if (unprom->caster)\n     {\n       tree lhs = gimple_get_lhs (unprom->caster->stmt);\n-      if (types_compatible_p (TREE_TYPE (lhs), type))\n-\treturn lhs;\n+      tree lhs_type = TREE_TYPE (lhs);\n+\n+      /* If the result of the existing cast is the right width, use it\n+\t instead of the source of the cast.  */\n+      if (TYPE_PRECISION (lhs_type) == TYPE_PRECISION (type))\n+\tinput = lhs;\n+      /* If the precision we want is between the source and result\n+\t precisions of the existing cast, try splitting the cast into\n+\t two and tapping into a mid-way point.  */\n+      else if (TYPE_PRECISION (lhs_type) > TYPE_PRECISION (type)\n+\t       && TYPE_PRECISION (type) > TYPE_PRECISION (unprom->type))\n+\t{\n+\t  /* In order to preserve the semantics of the original cast,\n+\t     give the mid-way point the same signedness as the input value.\n+\n+\t     It would be possible to use a signed type here instead if\n+\t     TYPE is signed and UNPROM->TYPE is unsigned, but that would\n+\t     make the sign of the midtype sensitive to the order in\n+\t     which we process the statements, since the signedness of\n+\t     TYPE is the signedness required by just one of possibly\n+\t     many users.  Also, unsigned promotions are usually as cheap\n+\t     as or cheaper than signed ones, so it's better to keep an\n+\t     unsigned promotion.  */\n+\t  tree midtype = build_nonstandard_integer_type\n+\t    (TYPE_PRECISION (type), TYPE_UNSIGNED (unprom->type));\n+\t  tree vec_midtype = get_vectype_for_scalar_type (midtype);\n+\t  if (vec_midtype)\n+\t    {\n+\t      input = vect_recog_temp_ssa_var (midtype, NULL);\n+\t      gassign *new_stmt = gimple_build_assign (input, NOP_EXPR,\n+\t\t\t\t\t\t       unprom->op);\n+\t      if (!vect_split_statement (unprom->caster, input, new_stmt,\n+\t\t\t\t\t vec_midtype))\n+\t\tappend_pattern_def_seq (stmt_info, new_stmt, vec_midtype);\n+\t    }\n+\t}\n+\n+      /* See if we can reuse an existing result.  */\n+      if (types_compatible_p (type, TREE_TYPE (input)))\n+\treturn input;\n     }\n \n   /* We need a new conversion statement.  */\n   tree new_op = vect_recog_temp_ssa_var (type, NULL);\n-  gassign *new_stmt = gimple_build_assign (new_op, NOP_EXPR, unprom->op);\n-\n-  /* If the operation is the input to a vectorizable cast, try splitting\n-     that cast into two, taking the required result as a mid-way point.  */\n-  if (unprom->caster)\n-    {\n-      tree lhs = gimple_get_lhs (unprom->caster->stmt);\n-      if (TYPE_PRECISION (TREE_TYPE (lhs)) > TYPE_PRECISION (type)\n-\t  && TYPE_PRECISION (type) > TYPE_PRECISION (unprom->type)\n-\t  && (TYPE_UNSIGNED (unprom->type) || !TYPE_UNSIGNED (type))\n-\t  && vect_split_statement (unprom->caster, new_op, new_stmt, vectype))\n-\treturn new_op;\n-    }\n+  gassign *new_stmt = gimple_build_assign (new_op, NOP_EXPR, input);\n \n   /* If OP is an external value, see if we can insert the new statement\n      on an incoming edge.  */\n-  if (unprom->dt == vect_external_def)\n-    if (edge e = vect_get_external_def_edge (stmt_info->vinfo, unprom->op))\n+  if (input == unprom->op && unprom->dt == vect_external_def)\n+    if (edge e = vect_get_external_def_edge (stmt_info->vinfo, input))\n       {\n \tbasic_block new_bb = gsi_insert_on_edge_immediate (e, new_stmt);\n \tgcc_assert (!new_bb);\n@@ -1644,28 +1670,37 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n   bool unsigned_p = (last_stmt_info->operation_sign == UNSIGNED);\n   tree new_type = build_nonstandard_integer_type (new_precision, unsigned_p);\n \n+  /* If we're truncating an operation, we need to make sure that we\n+     don't introduce new undefined overflow.  The codes tested here are\n+     a subset of those accepted by vect_truncatable_operation_p.  */\n+  tree op_type = new_type;\n+  if (TYPE_OVERFLOW_UNDEFINED (new_type)\n+      && (code == PLUS_EXPR || code == MINUS_EXPR || code == MULT_EXPR))\n+    op_type = build_nonstandard_integer_type (new_precision, true);\n+\n   /* We specifically don't check here whether the target supports the\n      new operation, since it might be something that a later pattern\n      wants to rewrite anyway.  If targets have a minimum element size\n      for some optabs, we should pattern-match smaller ops to larger ops\n      where beneficial.  */\n   tree new_vectype = get_vectype_for_scalar_type (new_type);\n-  if (!new_vectype)\n+  tree op_vectype = get_vectype_for_scalar_type (op_type);\n+  if (!new_vectype || !op_vectype)\n     return NULL;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"demoting %T to %T\\n\",\n \t\t     type, new_type);\n \n-  /* Calculate the rhs operands for an operation on NEW_TYPE.  */\n+  /* Calculate the rhs operands for an operation on OP_TYPE.  */\n   tree ops[3] = {};\n   for (unsigned int i = 1; i < first_op; ++i)\n     ops[i - 1] = gimple_op (last_stmt, i);\n   vect_convert_inputs (last_stmt_info, nops, &ops[first_op - 1],\n-\t\t       new_type, &unprom[0], new_vectype);\n+\t\t       op_type, &unprom[0], op_vectype);\n \n-  /* Use the operation to produce a result of type NEW_TYPE.  */\n-  tree new_var = vect_recog_temp_ssa_var (new_type, NULL);\n+  /* Use the operation to produce a result of type OP_TYPE.  */\n+  tree new_var = vect_recog_temp_ssa_var (op_type, NULL);\n   gimple *pattern_stmt = gimple_build_assign (new_var, code,\n \t\t\t\t\t      ops[0], ops[1], ops[2]);\n   gimple_set_location (pattern_stmt, gimple_location (last_stmt));\n@@ -1674,6 +1709,13 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"created pattern stmt: %G\", pattern_stmt);\n \n+  /* Convert back to the original signedness, if OP_TYPE is different\n+     from NEW_TYPE.  */\n+  if (op_type != new_type)\n+    pattern_stmt = vect_convert_output (last_stmt_info, new_type,\n+\t\t\t\t\tpattern_stmt, op_vectype);\n+\n+  /* Promote the result to the original type.  */\n   pattern_stmt = vect_convert_output (last_stmt_info, type,\n \t\t\t\t      pattern_stmt, new_vectype);\n \n@@ -1719,8 +1761,16 @@ vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n   if (!INTEGRAL_TYPE_P (type) || target_precision >= TYPE_PRECISION (type))\n     return NULL;\n \n-  /* Get the definition of the shift input.  */\n+  /* Look through any change in sign on the shift input.  */\n   tree rshift_rhs = gimple_assign_rhs1 (last_stmt);\n+  vect_unpromoted_value unprom_plus;\n+  rshift_rhs = vect_look_through_possible_promotion (vinfo, rshift_rhs,\n+\t\t\t\t\t\t     &unprom_plus);\n+  if (!rshift_rhs\n+      || TYPE_PRECISION (TREE_TYPE (rshift_rhs)) != TYPE_PRECISION (type))\n+    return NULL;\n+\n+  /* Get the definition of the shift input.  */\n   stmt_vec_info plus_stmt_info = vect_get_internal_def (vinfo, rshift_rhs);\n   if (!plus_stmt_info)\n     return NULL;"}]}