{"sha": "194734e9e5501f9a295212b91978eee396879cda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk0NzM0ZTllNTUwMWY5YTI5NTIxMmI5MTk3OGVlZTM5Njg3OWNkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-15T09:00:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-15T09:00:30Z"}, "message": "invoke.texi (-malign-double): Re-add lost warning.\n\n\t* invoke.texi (-malign-double): Re-add lost warning.\n\n\t* i386-protos.h (x86_output_mi_thunk): Declare.\n\t* unix.h (ASM_OUTPUT_MI_THUNK): Move offline to ...\n\t* i386.c (x86_output_mi_thunk): ... here; handle 64bits.\n\n\t* dwarf2out.c (output_call_frame_info): Do not skip unwind info\n\twhen flag_asynchronous_unwind_tables is set.\n\n\t* flags.h (flag_reorder_functions): Declare.\n\t* function.c (prepare_function_start): Initialize frequnecy.\n\t* params.def (HOT_BB_COUNT_FRACTION, HOT_BB_FREQUENCY_FRACTION): New paramters.\n\t* Makefile.in (predict.o): Add dependency on target.h and params.h\n\t* defaults.h (HOT_TEXT_SECTION_NAME,\n\tUNLIKELY_EXECUTED_TEXT_SECTION_NAME): New macros.\n\t* predict.c (choose_function_section): New function.\n\t(estimate_bb_frequencies): Use it.\n\t* toplev.c (flag_reorder_functions): New global variable.\n\t(lang_independent_options): New.\n\t(parse_options_and_default_flags): Set.\n\t* varasm.c (assemble_start_function): Bypass functdion alignment\n\tfor never executed functions.\n\t* invoke.texi (-freorder-blocks, -freorder-functions): Document.\n\t(param hot-bb-count-fraction, hot-bb-frequency-fraction): New.\n\t* tm.texi (HOT_TEXT_SECTION_NAME, UNLIKELY_EXECUTED_TEXT_SECTION_NAME):\n\tDocument.\n\n\tThu Jan  3 21:52:09 CET 2002  Jan Hubicka  <jh@suse.cz>\n\n\t* predict.c: Inlude profile.h\n\t(MIN_COUNT): Rename to MIN_COUNT_FRACTION\n\t(maybe_hot_bb_p, probably_cold_bb_p, probably_never_executed_bb_p):\n\tUse the information about maximal counter in the program.\n\n\tThu Dec 20 22:14:00 CET 2001  Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h (maybe_hot_bb_p, probably_cold_bb_p,\n\tprobably_never_executed_bb_p): New functions.\n\t* cfgcleanup.c (outgoing_edges_match): Use them.\n\t* predict.c (MIN_COUNT, MIN_FREQUENCY): New macros.\n\t(maybe_hot_bb_p, probably_cold_bb_p,\n\tprobably_never_executed_bb_p): New functions.\n\n\t* function.h (function): Add new field function_frequency.\n\t* predict.c (compute_function_frequency): New function.\n\t(estimate_probability): Call it.\n\nFrom-SVN: r53478", "tree": {"sha": "6dab9b09a4ebcfb309dc527384a3d4f4607f240d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dab9b09a4ebcfb309dc527384a3d4f4607f240d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/194734e9e5501f9a295212b91978eee396879cda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194734e9e5501f9a295212b91978eee396879cda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/194734e9e5501f9a295212b91978eee396879cda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194734e9e5501f9a295212b91978eee396879cda/comments", "author": null, "committer": null, "parents": [{"sha": "61ad9a3472b5cafde230efd925bf9c8f61d6b65e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ad9a3472b5cafde230efd925bf9c8f61d6b65e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ad9a3472b5cafde230efd925bf9c8f61d6b65e"}], "stats": {"total": 557, "additions": 408, "deletions": 149}, "files": [{"sha": "f543a744a91ec9de395b9197300a237ebc1728f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -1,3 +1,52 @@\n+Wed May 15 10:38:27 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* invoke.texi (-malign-double): Re-add lost warning.\n+\n+\t* i386-protos.h (x86_output_mi_thunk): Declare.\n+\t* unix.h (ASM_OUTPUT_MI_THUNK): Move offline to ...\n+\t* i386.c (x86_output_mi_thunk): ... here; handle 64bits.\n+\n+\t* dwarf2out.c (output_call_frame_info): Do not skip unwind info\n+\twhen flag_asynchronous_unwind_tables is set.\n+\n+\t* flags.h (flag_reorder_functions): Declare.\n+\t* function.c (prepare_function_start): Initialize frequnecy.\n+\t* params.def (HOT_BB_COUNT_FRACTION, HOT_BB_FREQUENCY_FRACTION): New paramters.\n+\t* Makefile.in (predict.o): Add dependency on target.h and params.h\n+\t* defaults.h (HOT_TEXT_SECTION_NAME,\n+\tUNLIKELY_EXECUTED_TEXT_SECTION_NAME): New macros.\n+\t* predict.c (choose_function_section): New function.\n+\t(estimate_bb_frequencies): Use it.\n+\t* toplev.c (flag_reorder_functions): New global variable.\n+\t(lang_independent_options): New.\n+\t(parse_options_and_default_flags): Set.\n+\t* varasm.c (assemble_start_function): Bypass functdion alignment\n+\tfor never executed functions.\n+\t* invoke.texi (-freorder-blocks, -freorder-functions): Document.\n+\t(param hot-bb-count-fraction, hot-bb-frequency-fraction): New.\n+\t* tm.texi (HOT_TEXT_SECTION_NAME, UNLIKELY_EXECUTED_TEXT_SECTION_NAME):\n+\tDocument.\n+\n+\tThu Jan  3 21:52:09 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c: Inlude profile.h\n+\t(MIN_COUNT): Rename to MIN_COUNT_FRACTION\n+\t(maybe_hot_bb_p, probably_cold_bb_p, probably_never_executed_bb_p):\n+\tUse the information about maximal counter in the program.\n+\n+\tThu Dec 20 22:14:00 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (maybe_hot_bb_p, probably_cold_bb_p,\n+\tprobably_never_executed_bb_p): New functions.\n+\t* cfgcleanup.c (outgoing_edges_match): Use them.\n+\t* predict.c (MIN_COUNT, MIN_FREQUENCY): New macros.\n+\t(maybe_hot_bb_p, probably_cold_bb_p,\n+\tprobably_never_executed_bb_p): New functions.\n+\n+\t* function.h (function): Add new field function_frequency.\n+\t* predict.c (compute_function_frequency): New function.\n+\t(estimate_probability): Call it.\n+\n 2002-03-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/5172, optimization/5200"}, {"sha": "5791e8e238b170154f0af0026efd205c9db9120a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -1579,7 +1579,8 @@ reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H)\n    varray.h function.h $(TM_P_H)\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n-   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h\n+   $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H) real.h \\\n+   $(PARAMS_H) $(TARGET_H)\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)"}, {"sha": "5615b145f020d375c6a93be5d7c2a163dec5786b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -628,6 +628,10 @@ extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n extern void estimate_probability        PARAMS ((struct loops *));\n extern void note_prediction_to_br_prob\tPARAMS ((void));\n extern void expected_value_to_br_prob\tPARAMS ((void));\n+extern void note_prediction_to_br_prob\tPARAMS ((void));\n+extern bool maybe_hot_bb_p\t\tPARAMS ((basic_block));\n+extern bool probably_cold_bb_p\t\tPARAMS ((basic_block));\n+extern bool probably_never_executed_bb_p PARAMS ((basic_block));\n \n /* In flow.c */\n extern void init_flow                   PARAMS ((void));"}, {"sha": "fcf6944d4bb8ce117aa1f4bb03b03f0989c4c7ea", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -1211,8 +1211,8 @@ outgoing_edges_match (mode, bb1, bb2)\n \t roughly similar.  */\n       if (match\n \t  && !optimize_size\n-\t  && bb1->frequency > BB_FREQ_MAX / 1000\n-\t  && bb2->frequency > BB_FREQ_MAX / 1000)\n+\t  && maybe_hot_bb_p (bb1)\n+\t  && maybe_hot_bb_p (bb2))\n \t{\n \t  int prob2;\n "}, {"sha": "b3b168845792acf478b6e83995d33f654ee2b904", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -197,4 +197,5 @@ extern tree ix86_handle_shared_attribute PARAMS ((tree *, tree, tree, int, bool\n extern unsigned int i386_pe_section_type_flags PARAMS ((tree, const char *,\n \t\t\t\t\t\t\tint));\n extern void i386_pe_asm_named_section PARAMS ((const char *, unsigned int));\n+extern void x86_output_mi_thunk PARAMS ((FILE *, int, tree));\n #endif"}, {"sha": "8d939f2e0984b5ab05bb1b20d419d6877b196b90", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -13049,3 +13049,78 @@ x86_order_regs_for_local_alloc ()\n    while (pos < FIRST_PSEUDO_REGISTER)\n      reg_alloc_order [pos++] = 0;\n }\n+\n+void\n+x86_output_mi_thunk (file, delta, function)\n+     FILE *file;\n+     int delta;\n+     tree function;\n+{\n+  tree parm;\n+  rtx xops[3];\n+\n+  if (ix86_regparm > 0)\n+    parm = TYPE_ARG_TYPES (TREE_TYPE (function));\n+  else\n+    parm = NULL_TREE;\n+  for (; parm; parm = TREE_CHAIN (parm))\n+    if (TREE_VALUE (parm) == void_type_node)\n+      break;\n+\n+  xops[0] = GEN_INT (delta);\n+  if (TARGET_64BIT)\n+    {\n+      int n = aggregate_value_p (TREE_TYPE (TREE_TYPE (function))) != 0;\n+      xops[1] = gen_rtx_REG (DImode, x86_64_int_parameter_registers[n]);\n+      output_asm_insn (\"add{q} {%0, %1|%1, %0}\", xops);\n+      if (flag_pic)\n+\t{\n+\t  fprintf (file, \"\\tjmp *\");\n+\t  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+\t  fprintf (file, \"@GOTPCREL(%%rip)\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tjmp \");\n+\t  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+\t  fprintf (file, \"\\n\");\n+\t}\n+    }\n+  else\n+    {\n+      if (parm)\n+\txops[1] = gen_rtx_REG (SImode, 0);\n+      else if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function))))\n+\txops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 8));\n+      else\n+\txops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 4));\n+      output_asm_insn (\"add{l} {%0, %1|%1, %0}\", xops);\n+\n+      if (flag_pic)\n+\t{\n+\t  xops[0] = pic_offset_table_rtx;\n+\t  xops[1] = gen_label_rtx ();\n+\t  xops[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+\n+\t  if (ix86_regparm > 2)\n+\t    abort ();\n+\t  output_asm_insn (\"push{l}\\t%0\", xops);\n+\t  output_asm_insn (\"call\\t%P1\", xops);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (xops[1]));\n+\t  output_asm_insn (\"pop{l}\\t%0\", xops);\n+\t  output_asm_insn\n+\t    (\"add{l}\\t{%2+[.-%P1], %0|%0, OFFSET FLAT: %2+[.-%P1]}\", xops);\n+\t  xops[0] = gen_rtx_MEM (SImode, XEXP (DECL_RTL (function), 0));\n+\t  output_asm_insn\n+\t    (\"mov{l}\\t{%0@GOT(%%ebx), %%ecx|%%ecx, %0@GOT[%%ebx]}\", xops);\n+\t  asm_fprintf (file, \"\\tpop{l\\t%%ebx|\\t%%ebx}\\n\");\n+\t  asm_fprintf (file, \"\\tjmp\\t{*%%ecx|%%ecx}\\n\");\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tjmp \");\n+\t  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+\t  fprintf (file, \"\\n\");\n+\t}\n+    }\n+}"}, {"sha": "f7e38b48e9a17a53f8769dc6327aa4898d2c74c6", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -79,57 +79,5 @@ Boston, MA 02111-1307, USA.  */\n \n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n-#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t    \\\n-do {\t\t\t\t\t\t\t\t\t    \\\n-  tree parm;\t\t\t\t\t\t\t\t    \\\n-  rtx xops[3];\t\t\t\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-  if (ix86_regparm > 0)\t\t\t\t\t\t\t    \\\n-    parm = TYPE_ARG_TYPES (TREE_TYPE (function));\t\t\t    \\\n-  else\t\t\t\t\t\t\t\t\t    \\\n-    parm = NULL_TREE;\t\t\t\t\t\t\t    \\\n-  for (; parm; parm = TREE_CHAIN (parm))\t\t\t\t    \\\n-    if (TREE_VALUE (parm) == void_type_node)\t\t\t\t    \\\n-      break;\t\t\t\t\t\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-  xops[0] = GEN_INT (DELTA);\t\t\t\t\t\t    \\\n-  if (parm)\t\t\t\t\t\t\t\t    \\\n-    xops[1] = gen_rtx_REG (SImode, 0);\t\t\t\t\t    \\\n-  else if (aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION))))\t    \\\n-    xops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 8));   \\\n-  else\t\t\t\t\t\t\t\t\t    \\\n-    xops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 4));   \\\n-  output_asm_insn (\"add{l} {%0, %1|%1, %0}\", xops);\t\t\t    \\\n-\t\t\t\t\t\t\t\t\t    \\\n-  if (flag_pic && !TARGET_64BIT)\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      xops[0] = pic_offset_table_rtx;\t\t\t\t\t    \\\n-      xops[1] = gen_label_rtx ();\t\t\t\t\t    \\\n-      xops[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");        \\\n-\t\t\t\t\t\t\t\t\t    \\\n-      if (ix86_regparm > 2)\t\t\t\t\t\t    \\\n-\tabort ();\t\t\t\t\t\t\t    \\\n-      output_asm_insn (\"push{l}\\t%0\", xops);\t\t\t\t    \\\n-      output_asm_insn (\"call\\t%P1\", xops);\t\t\t\t    \\\n-      ASM_OUTPUT_INTERNAL_LABEL (FILE, \"L\", CODE_LABEL_NUMBER (xops[1]));   \\\n-      output_asm_insn (\"pop{l}\\t%0\", xops);\t\t\t\t    \\\n-      output_asm_insn (\"add{l}\\t{%2+[.-%P1], %0|%0, OFFSET FLAT: %2+[.-%P1]}\", xops); \\\n-      xops[0] = gen_rtx_MEM (SImode, XEXP (DECL_RTL (FUNCTION), 0));\t    \\\n-      output_asm_insn (\"mov{l}\\t{%0@GOT(%%ebx), %%ecx|%%ecx, %0@GOT[%%ebx]}\",\\\n-\t               xops);\t\t\t\t\t\t    \\\n-      asm_fprintf (FILE, \"\\tpop{l\\t%%ebx|\\t%%ebx}\\n\");\t\t\t    \\\n-      asm_fprintf (FILE, \"\\tjmp\\t{*%%ecx|%%ecx}\\n\");\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  else if (flag_pic && TARGET_64BIT)\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      fprintf (FILE, \"\\tjmp *\");\t\t\t\t\t    \\\n-      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t    \\\n-      fprintf (FILE, \"@GOTPCREL(%%rip)\\n\");\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-  else\t\t\t\t\t\t\t\t\t    \\\n-    {\t\t\t\t\t\t\t\t\t    \\\n-      fprintf (FILE, \"\\tjmp \");\t\t\t\t\t\t    \\\n-      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t    \\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\t    \\\n-    }\t\t\t\t\t\t\t\t\t    \\\n-} while (0)\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION) \\\n+    x86_output_mi_thunk (FILE, DELTA, FUNCTION);"}, {"sha": "12f363a33d8815375759286d98f3db4bd92a413a", "filename": "gcc/defaults.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -517,4 +517,12 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n    && !ROUND_TOWARDS_ZERO)\n #endif\n \n+#ifndef HOT_TEXT_SECTION_NAME\n+#define HOT_TEXT_SECTION_NAME \"text.hot\"\n+#endif\n+\n+#ifndef UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n+#define UNLIKELY_EXECUTED_TEXT_SECTION_NAME \"text.unlikely\"\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "1190c97965e8ef28641514bd51fad590f8070977", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -278,6 +278,7 @@ in the following sections.\n -fomit-frame-pointer  -foptimize-register-move @gol\n -foptimize-sibling-calls  -fprefetch-loop-arrays @gol\n -freduce-all-givs -fregmove  -frename-registers @gol\n+-freorder-blocks -freorder-functions @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n@@ -3712,6 +3713,23 @@ non-determinism is of paramount import.  This switch allows users to\n reduce non-determinism, possibly at the expense of inferior\n optimization.\n \n+@item -freorder-blocks\n+@opindex freorder-blocks\n+Reorder basic blocks in the compiled function in order to reduce number of\n+taken branches and improve code locality.\n+\n+@item -freorder-functions\n+@opindex freorder-functions\n+Reorder basic blocks in the compiled function in order to reduce number of\n+taken branches and improve code locality. This is implemented by using special\n+subsections @code{text.hot} for most frequently executed functions and\n+@code{text.unlikely} for unlikely executed functions.  Reordering is done by\n+the linker so object file format must support named sections and linker must\n+place them in resonable way.\n+\n+Also profile feedback must be available in to make this option effective.  See\n+@option{-fprofile-arcs} for details.\n+\n @item -fstrict-aliasing\n @opindex fstrict-aliasing\n Allows the compiler to assume the strictest aliasing rules applicable to\n@@ -3900,6 +3918,13 @@ The maximum number of instructions that a loop should have if that loop\n is unrolled, and if the loop is unrolled, it determines how many times\n the loop code is unrolled.\n \n+@item hot-bb-count-fraction\n+Select fraction of the maximal count of repetitions of basic block in program\n+given basic block needs to have to be considered hot.\n+\n+@item hot-bb-frequency-fraction\n+Select fraction of the maximal frequency of executions of basic block in\n+function given basic block needs to have to be considered hot\n @end table\n @end table\n \n@@ -7389,6 +7414,10 @@ boundary.  Aligning @code{double} variables on a two word boundary will\n produce code that runs somewhat faster on a @samp{Pentium} at the\n expense of more memory.\n \n+@strong{Warning:} if you use the @samp{-malign-double} switch,\n+structures containing the above types will be aligned differently than\n+the published application binary interface specifications for the 386.\n+\n @item -m128bit-long-double\n @opindex m128bit-long-double\n Control the size of @code{long double} type. i386 application binary interface"}, {"sha": "bbb2c5010bdec8ccc4ef132d549dba39381f7fe2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -5651,6 +5651,17 @@ Normally this is not needed, as simply defining @code{TEXT_SECTION_ASM_OP}\n is enough.  The MIPS port uses this to sort all functions after all data\n declarations.\n \n+@findex HOT_TEXT_SECTION_NAME\n+@item HOT_TEXT_SECTION_NAME\n+If defined, a C string constant for the name of the section containing most\n+frequently executed functions of the program.  If not defined, GCC will provide\n+a default definition if the target supports named sections.\n+\n+@findex UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n+@item UNLIKELY_EXECUTED_TEXT_SECTION_NAME\n+If defined, a C string constant for the name of the section containing unlikely\n+executed functions in the program.\n+\n @findex DATA_SECTION_ASM_OP\n @item DATA_SECTION_ASM_OP\n A C expression whose value is a string, including spacing, containing the"}, {"sha": "2fa9f64817e9a2a4552acb9f0be59c409c26ab72", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -1968,7 +1968,8 @@ output_call_frame_info (for_eh)\n       fde = &fde_table[i];\n \n       /* Don't emit EH unwind info for leaf functions that don't need it.  */\n-      if (for_eh && fde->nothrow && ! fde->uses_eh_lsda)\n+      if (!flag_asynchronous_unwind_tables && for_eh && fde->nothrow\n+\t  && !  fde->uses_eh_lsda)\n \tcontinue;\n \n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, FDE_LABEL, for_eh + i * 2);"}, {"sha": "efcc7716e3ecb316cfbb7566045a3f30f20ed3f5", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -204,6 +204,10 @@ extern int flag_branch_probabilities;\n \n extern int flag_reorder_blocks;\n \n+/* Nonzero if functions should be reordered.  */\n+\n+extern int flag_reorder_functions;\n+\n /* Nonzero if registers should be renamed.  */\n \n extern int flag_rename_registers;"}, {"sha": "5bd70a0560f28c313b5259acd4dec599663d1ceb", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -6320,6 +6320,10 @@ prepare_function_start ()\n \n   cfun->arc_profile = profile_arc_flag || flag_test_coverage;\n \n+  cfun->arc_profile = profile_arc_flag || flag_test_coverage;\n+\n+  cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n+\n   (*lang_hooks.function.init) (cfun);\n   if (init_machine_status)\n     (*init_machine_status) (cfun);"}, {"sha": "912f8513c53745ffa81d3d8af8749da5dd72e43c", "filename": "gcc/function.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -481,6 +481,19 @@ struct function\n \n   /* Nonzero if code to initialize arg_pointer_save_area has been emited.  */\n   unsigned int arg_pointer_save_area_init : 1;\n+\n+  /* How commonly executed the function is.  Initialized during branch\n+     probabilities pass.  */\n+  enum function_frequency {\n+    /* This function most likely won't be executed at all.\n+       (set only when profile feedback is available).  */\n+    FUNCTION_FREQUENCY_UNLIKELY_EXECUTED,\n+    /* The default value.  */\n+    FUNCTION_FREQUENCY_NORMAL,\n+    /* Optimize this function hard\n+       (set only when profile feedback is available).  */\n+    FUNCTION_FREQUENCY_HOT\n+  } function_frequency;\n };\n \n /* The function currently being compiled.  */"}, {"sha": "de55ecc5841e5798250f1043bc1538a21f24d225", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -150,6 +150,15 @@ DEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n \t \"max-unrolled-insns\",\n \t \"The maximum number of instructions to consider to unroll in a loop\",\n \t 100)\n+\n+DEFPARAM(HOT_BB_COUNT_FRACTION,\n+\t \"hot-bb-count-fraction\",\n+\t \"Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot\",\n+\t 10000)\n+DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n+\t \"hot-bb-frequency-fraction\",\n+\t \"Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot\",\n+\t 1000)\n /*\n Local variables:\n mode:c"}, {"sha": "f457817956d5612f7e47f3a40181be372a087aec", "filename": "gcc/predict.c", "status": "modified", "additions": 184, "deletions": 90, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -45,7 +45,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"predict.h\"\n+#include \"profile.h\"\n #include \"real.h\"\n+#include \"params.h\"\n+#include \"target.h\"\n \n /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE, 0.5,\n                    REAL_BB_FREQ_MAX.  */\n@@ -75,6 +78,8 @@ static void process_note_predictions\t PARAMS ((basic_block, int *, int *,\n static void process_note_prediction\t PARAMS ((basic_block, int *, int *,\n                                                   sbitmap *, int, int));\n static bool last_basic_block_p           PARAMS ((basic_block));\n+static void compute_function_frequency\t PARAMS ((void));\n+static void choose_function_section\t PARAMS ((void));\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -103,6 +108,54 @@ static const struct predictor_info predictor_info[]= {\n   {NULL, 0, 0}\n };\n #undef DEF_PREDICTOR\n+\n+/* Return true in case BB can be CPU intensive and should be optimized\n+   for maximal perofmrance.  */\n+\n+bool\n+maybe_hot_bb_p (bb)\n+     basic_block bb;\n+{\n+  if (profile_info.count_profiles_merged\n+      && flag_branch_probabilities\n+      && (bb->count\n+\t  < profile_info.max_counter_in_program\n+\t  / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n+    return false;\n+  if (bb->frequency < BB_FREQ_MAX / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION))\n+    return false;\n+  return true;\n+}\n+\n+/* Return true in case BB is cold and should be optimized for size.  */\n+\n+bool\n+probably_cold_bb_p (bb)\n+     basic_block bb;\n+{\n+  if (profile_info.count_profiles_merged\n+      && flag_branch_probabilities\n+      && (bb->count\n+\t  < profile_info.max_counter_in_program\n+\t  / PARAM_VALUE (HOT_BB_COUNT_FRACTION)))\n+    return true;\n+  if (bb->frequency < BB_FREQ_MAX / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION))\n+    return true;\n+  return false;\n+}\n+\n+/* Return true in case BB is probably never executed.  */\n+bool\n+probably_never_executed_bb_p (bb)\n+\tbasic_block bb;\n+{\n+  if (profile_info.count_profiles_merged\n+      && flag_branch_probabilities)\n+    return ((bb->count + profile_info.count_profiles_merged / 2)\n+\t    / profile_info.count_profiles_merged) == 0;\n+  return false;\n+}\n+\n /* Return true if the one of outgoing edges is already predicted by\n    PREDICTOR.  */\n \n@@ -1095,118 +1148,159 @@ estimate_bb_frequencies (loops)\n   REAL_VALUE_TYPE freq_max;\n   enum machine_mode double_mode = TYPE_MODE (double_type_node);\n \n-  REAL_VALUE_FROM_INT (real_zero, 0, 0, double_mode);\n-  REAL_VALUE_FROM_INT (real_one, 1, 0, double_mode);\n-  REAL_VALUE_FROM_INT (real_br_prob_base, REG_BR_PROB_BASE, 0, double_mode);\n-  REAL_VALUE_FROM_INT (real_bb_freq_max, BB_FREQ_MAX, 0, double_mode);\n-  REAL_VALUE_FROM_INT (real_one_half, 2, 0, double_mode);\n+  if (flag_branch_probabilities)\n+    counts_to_freqs ();\n+  else\n+    {\n+      REAL_VALUE_FROM_INT (real_zero, 0, 0, double_mode);\n+      REAL_VALUE_FROM_INT (real_one, 1, 0, double_mode);\n+      REAL_VALUE_FROM_INT (real_br_prob_base, REG_BR_PROB_BASE, 0, double_mode);\n+      REAL_VALUE_FROM_INT (real_bb_freq_max, BB_FREQ_MAX, 0, double_mode);\n+      REAL_VALUE_FROM_INT (real_one_half, 2, 0, double_mode);\n \n-  REAL_ARITHMETIC (real_one_half, RDIV_EXPR, real_one, real_one_half);\n+      REAL_ARITHMETIC (real_one_half, RDIV_EXPR, real_one, real_one_half);\n \n-  REAL_ARITHMETIC (real_almost_one, RDIV_EXPR, real_one, real_br_prob_base);\n-  REAL_ARITHMETIC (real_almost_one, MINUS_EXPR, real_one, real_almost_one);\n+      REAL_ARITHMETIC (real_almost_one, RDIV_EXPR, real_one, real_br_prob_base);\n+      REAL_ARITHMETIC (real_almost_one, MINUS_EXPR, real_one, real_almost_one);\n \n-  mark_dfs_back_edges ();\n-  if (flag_branch_probabilities)\n-    {\n-      counts_to_freqs ();\n-      return;\n-    }\n+      mark_dfs_back_edges ();\n+      /* Fill in the probability values in flowgraph based on the REG_BR_PROB\n+         notes.  */\n+      for (i = 0; i < n_basic_blocks; i++)\n+\t{\n+\t  rtx last_insn = BLOCK_END (i);\n \n-  /* Fill in the probability values in flowgraph based on the REG_BR_PROB\n-     notes.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      rtx last_insn = BLOCK_END (i);\n+\t  if (GET_CODE (last_insn) != JUMP_INSN || !any_condjump_p (last_insn)\n+\t      /* Avoid handling of conditional jumps jumping to fallthru edge.  */\n+\t      || BASIC_BLOCK (i)->succ->succ_next == NULL)\n+\t    {\n+\t      /* We can predict only conditional jumps at the moment.\n+\t         Expect each edge to be equally probable.\n+\t         ?? In the future we want to make abnormal edges improbable.  */\n+\t      int nedges = 0;\n+\t      edge e;\n \n-      if (GET_CODE (last_insn) != JUMP_INSN || !any_condjump_p (last_insn)\n-\t  /* Avoid handling of conditional jumps jumping to fallthru edge.  */\n-\t  || BASIC_BLOCK (i)->succ->succ_next == NULL)\n+\t      for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t\t{\n+\t\t  nedges++;\n+\t\t  if (e->probability != 0)\n+\t\t    break;\n+\t\t}\n+\t      if (!e)\n+\t\tfor (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t\t  e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n+\t    }\n+\t}\n+\n+      ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n+\n+      /* Set up block info for each basic block.  */\n+      alloc_aux_for_blocks (sizeof (struct block_info_def));\n+      alloc_aux_for_edges (sizeof (struct edge_info_def));\n+      for (i = -2; i < n_basic_blocks; i++)\n \t{\n-\t  /* We can predict only conditional jumps at the moment.\n-\t     Expect each edge to be equally probable.\n-\t     ?? In the future we want to make abnormal edges improbable.  */\n-\t  int nedges = 0;\n \t  edge e;\n+\t  basic_block bb;\n \n-\t  for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n+\t  if (i == -2)\n+\t    bb = ENTRY_BLOCK_PTR;\n+\t  else if (i == -1)\n+\t    bb = EXIT_BLOCK_PTR;\n+\t  else\n+\t    bb = BASIC_BLOCK (i);\n+\n+\t  BLOCK_INFO (bb)->tovisit = 0;\n+\t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n-\t      nedges++;\n-\t      if (e->probability != 0)\n-\t\tbreak;\n+\n+\t      REAL_VALUE_FROM_INT (EDGE_INFO (e)->back_edge_prob,\n+\t\t\t\t   e->probability, 0, double_mode);\n+\t      REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n+\t\t\t       RDIV_EXPR, EDGE_INFO (e)->back_edge_prob,\n+\t\t\t       real_br_prob_base);\n \t    }\n-\t  if (!e)\n-\t    for (e = BASIC_BLOCK (i)->succ; e; e = e->succ_next)\n-\t      e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n \t}\n-    }\n \n-  ENTRY_BLOCK_PTR->succ->probability = REG_BR_PROB_BASE;\n+      /* First compute probabilities locally for each loop from innermost\n+         to outermost to examine probabilities for back edges.  */\n+      estimate_loops_at_level (loops->tree_root);\n \n-  /* Set up block info for each basic block.  */\n-  alloc_aux_for_blocks (sizeof (struct block_info_def));\n-  alloc_aux_for_edges (sizeof (struct edge_info_def));\n-  for (i = -2; i < n_basic_blocks; i++)\n-    {\n-      edge e;\n-      basic_block bb;\n+      /* Now fake loop around whole function to finalize probabilities.  */\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tBLOCK_INFO (BASIC_BLOCK (i))->tovisit = 1;\n \n-      if (i == -2)\n-\tbb = ENTRY_BLOCK_PTR;\n-      else if (i == -1)\n-\tbb = EXIT_BLOCK_PTR;\n-      else\n-\tbb = BASIC_BLOCK (i);\n+      BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n+      BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n+      propagate_freq (ENTRY_BLOCK_PTR);\n \n-      BLOCK_INFO (bb)->tovisit = 0;\n-      for (e = bb->succ; e; e = e->succ_next)\n+      memcpy (&freq_max, &real_zero, sizeof (real_zero));\n+      for (i = 0; i < n_basic_blocks; i++)\n+\tif (REAL_VALUES_LESS\n+\t    (freq_max, BLOCK_INFO (BASIC_BLOCK (i))->frequency))\n+\t  memcpy (&freq_max, &BLOCK_INFO (BASIC_BLOCK (i))->frequency,\n+\t\t  sizeof (freq_max));\n+\n+      for (i = -2; i < n_basic_blocks; i++)\n \t{\n-\t\n-\t  REAL_VALUE_FROM_INT (EDGE_INFO (e)->back_edge_prob,\n-\t\t\t       e->probability, 0, double_mode);\n-\t  REAL_ARITHMETIC (EDGE_INFO (e)->back_edge_prob,\n-\t\t\t   RDIV_EXPR, EDGE_INFO (e)->back_edge_prob,\n-\t\t\t   real_br_prob_base);\n-\t}\n-    }\n+\t  basic_block bb;\n+\t  REAL_VALUE_TYPE tmp;\n \n-  /* First compute probabilities locally for each loop from innermost\n-     to outermost to examine probabilities for back edges.  */\n-  estimate_loops_at_level (loops->tree_root);\n+\t  if (i == -2)\n+\t    bb = ENTRY_BLOCK_PTR;\n+\t  else if (i == -1)\n+\t    bb = EXIT_BLOCK_PTR;\n+\t  else\n+\t    bb = BASIC_BLOCK (i);\n \n-  /* Now fake loop around whole function to finalize probabilities.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    BLOCK_INFO (BASIC_BLOCK (i))->tovisit = 1;\n+\t  REAL_ARITHMETIC (tmp, MULT_EXPR, BLOCK_INFO (bb)->frequency,\n+\t\t\t   real_bb_freq_max);\n+\t  REAL_ARITHMETIC (tmp, RDIV_EXPR, tmp, freq_max);\n+\t  REAL_ARITHMETIC (tmp, PLUS_EXPR, tmp, real_one_half);\n+\t  bb->frequency = REAL_VALUE_UNSIGNED_FIX (tmp);\n+\t}\n \n-  BLOCK_INFO (ENTRY_BLOCK_PTR)->tovisit = 1;\n-  BLOCK_INFO (EXIT_BLOCK_PTR)->tovisit = 1;\n-  propagate_freq (ENTRY_BLOCK_PTR);\n+      free_aux_for_blocks ();\n+      free_aux_for_edges ();\n+    }\n+  compute_function_frequency ();\n+  if (flag_reorder_functions)\n+    choose_function_section ();\n+}\n \n-  memcpy (&freq_max, &real_zero, sizeof (real_zero));\n+/* Decide whether function is hot, cold or unlikely executed.  */\n+static void\n+compute_function_frequency ()\n+{\n+  int i;\n+  if (!profile_info.count_profiles_merged\n+      || !flag_branch_probabilities)\n+    return;\n+  cfun->function_frequency = FUNCTION_FREQUENCY_UNLIKELY_EXECUTED;\n   for (i = 0; i < n_basic_blocks; i++)\n-    if (REAL_VALUES_LESS (freq_max, BLOCK_INFO (BASIC_BLOCK (i))->frequency))\n-      memcpy (&freq_max, &BLOCK_INFO (BASIC_BLOCK (i))->frequency,\n-\t      sizeof (freq_max));\n-\n-  for (i = -2; i < n_basic_blocks; i++)\n     {\n-      basic_block bb;\n-      REAL_VALUE_TYPE tmp;\n-\n-      if (i == -2)\n-\tbb = ENTRY_BLOCK_PTR;\n-      else if (i == -1)\n-\tbb = EXIT_BLOCK_PTR;\n-      else\n-\tbb = BASIC_BLOCK (i);\n-\n-      REAL_ARITHMETIC (tmp, MULT_EXPR, BLOCK_INFO (bb)->frequency,\n-\t\t       real_bb_freq_max);\n-      REAL_ARITHMETIC (tmp, RDIV_EXPR, tmp, freq_max);\n-      REAL_ARITHMETIC (tmp, PLUS_EXPR, tmp, real_one_half);\n-      bb->frequency = REAL_VALUE_UNSIGNED_FIX (tmp);\n+      basic_block bb = BASIC_BLOCK (i);\n+      if (maybe_hot_bb_p (bb))\n+\t{\n+\t  cfun->function_frequency = FUNCTION_FREQUENCY_HOT;\n+\t  return;\n+\t}\n+      if (!probably_never_executed_bb_p (bb))\n+\tcfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n     }\n+}\n \n-  free_aux_for_blocks ();\n-  free_aux_for_edges ();\n+/* Choose appropriate section for the function.  */\n+static void\n+choose_function_section ()\n+{\n+  if (DECL_SECTION_NAME (current_function_decl)\n+      || !targetm.have_named_sections)\n+    return;\n+  if (cfun->function_frequency == FUNCTION_FREQUENCY_HOT)\n+    DECL_SECTION_NAME (current_function_decl) =\n+      build_string (strlen (HOT_TEXT_SECTION_NAME), HOT_TEXT_SECTION_NAME);\n+  if (cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n+    DECL_SECTION_NAME (current_function_decl) =\n+      build_string (strlen (UNLIKELY_EXECUTED_TEXT_SECTION_NAME),\n+\t\t    UNLIKELY_EXECUTED_TEXT_SECTION_NAME);\n }"}, {"sha": "5f5eb4628111ab080cdab833aeaa03a8fb11f4bc", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -381,6 +381,10 @@ int flag_branch_probabilities = 0;\n \n int flag_reorder_blocks = 0;\n \n+/* Nonzero if functions should be reordered.  */\n+\n+int flag_reorder_functions = 0;\n+\n /* Nonzero if registers should be renamed.  */\n \n int flag_rename_registers = 0;\n@@ -1076,6 +1080,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Enable basic program profiling code\") },\n   {\"reorder-blocks\", &flag_reorder_blocks, 1,\n    N_(\"Reorder basic blocks to improve code placement\") },\n+  {\"reorder-functions\", &flag_reorder_functions, 1,\n+   N_(\"Reorder functions to improve code placement\") },\n   {\"rename-registers\", &flag_rename_registers, 1,\n    N_(\"Do the register renaming optimization pass\") },\n   {\"cprop-registers\", &flag_cprop_registers, 1,\n@@ -4657,6 +4663,7 @@ parse_options_and_default_flags (argc, argv)\n       flag_strict_aliasing = 1;\n       flag_delete_null_pointer_checks = 1;\n       flag_reorder_blocks = 1;\n+      flag_reorder_functions = 1;\n     }\n \n   if (optimize >= 3)"}, {"sha": "6fb663e4e886322efaa384450ecd1665990dc41a", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/194734e9e5501f9a295212b91978eee396879cda/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=194734e9e5501f9a295212b91978eee396879cda", "patch": "@@ -1197,7 +1197,8 @@ assemble_start_function (decl, fnname)\n   /* Handle a user-specified function alignment.\n      Note that we still need to align to FUNCTION_BOUNDARY, as above,\n      because ASM_OUTPUT_MAX_SKIP_ALIGN might not do any alignment at all.  */\n-  if (align_functions_log > align)\n+  if (align_functions_log > align\n+      && cfun->function_frequency != FUNCTION_FREQUENCY_UNLIKELY_EXECUTED)\n     {\n #ifdef ASM_OUTPUT_MAX_SKIP_ALIGN\n       ASM_OUTPUT_MAX_SKIP_ALIGN (asm_out_file,"}]}