{"sha": "bd8cb5e27fadcb450ea6af570fe3edf7056fcf65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4Y2I1ZTI3ZmFkY2I0NTBlYTZhZjU3MGZlM2VkZjcwNTZmY2Y2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-07T23:27:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-07T23:27:05Z"}, "message": "(VMS_fstat, VMS_stat):  New functions.\n\nFrom-SVN: r9335", "tree": {"sha": "cc305c5d48011fd6ebab2a7a38921e32e9dc88ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc305c5d48011fd6ebab2a7a38921e32e9dc88ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65/comments", "author": null, "committer": null, "parents": [{"sha": "c29a4cbc4b190e2c58bb6929a64bc62fbc438019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29a4cbc4b190e2c58bb6929a64bc62fbc438019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c29a4cbc4b190e2c58bb6929a64bc62fbc438019"}], "stats": {"total": 84, "additions": 83, "deletions": 1}, "files": [{"sha": "45b19496750950ff54a1a90f74bfbc16a96dca76", "filename": "gcc/cccp.c", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8cb5e27fadcb450ea6af570fe3edf7056fcf65/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=bd8cb5e27fadcb450ea6af570fe3edf7056fcf65", "patch": "@@ -239,6 +239,9 @@ my_bzero (b, length)\n #define fopen(fname,mode)\tVMS_fopen (fname,mode)\n #define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n #define strncat(dst,src,cnt) VMS_strncat (dst,src,cnt)\n+#define fstat(fd,stbuf)\t\tVMS_fstat (fd,stbuf)\n+#define stat(name,stbuf)\tVMS_stat (name,stbuf)\n+static int VMS_fstat (), VMS_stat ();\n static char * VMS_strncat ();\n static int VMS_read ();\n static int VMS_write ();\n@@ -10330,7 +10333,7 @@ open (fname, flags, prot)\n \n /* Avoid run-time library bug, where copying M out of N+M characters with\n    N >= 65535 results in VAXCRTL's strncat falling into an infinite loop.\n-   gcc-cpp exercises this particular bug.  */\n+   gcc-cpp exercises this particular bug.  [Fixed in V5.5-2's VAXCRTL.]  */\n \n static char *\n strncat (dst, src, cnt)\n@@ -10347,4 +10350,83 @@ strncat (dst, src, cnt)\n   if (n < 0) *d = '\\0';\n   return dst;\n }\n+\f\n+/* more VMS hackery */\n+#include <fab.h>\n+#include <nam.h>\n+\n+extern unsigned long sys$parse(), sys$search();\n+\n+/* Work around another library bug.  If a file is located via a searchlist,\n+   and if the device it's on is not the same device as the one specified\n+   in the first element of that searchlist, then both stat() and fstat()\n+   will fail to return info about it.  `errno' will be set to EVMSERR, and\n+   `vaxc$errno' will be set to SS$_NORMAL due yet another bug in stat()!\n+   We can get around this by fully parsing the filename and then passing\n+   that absolute name to stat().\n+\n+   Without this fix, we can end up failing to find header files, which is\n+   bad enough, but then compounding the problem by reporting the reason for\n+   failure as \"normal successful completion.\"  */\n+\n+static int\n+fstat (fd, statbuf)\n+     int fd;\n+     struct stat *statbuf;\n+{\n+#undef fstat\n+  int result = fstat (fd, statbuf);\n+\n+  if (result < 0)\n+    {\n+      FILE *fp;\n+      char nambuf[NAM$C_MAXRSS+1];\n+\n+      if ((fp = fdopen (fd, \"r\")) != 0 && fgetname (fp, nambuf) != 0)\n+\tresult = stat (nambuf, statbuf);\n+      /* No fclose(fp) here; that would close(fd) as well.  */\n+    }\n+\n+  return result;\n+}\n+\n+static int\n+stat (name, statbuf)\n+     const char *name;\n+     struct stat *statbuf;\n+{\n+#undef stat\n+  int result = stat (name, statbuf);\n+\n+  if (result < 0)\n+    {\n+      struct FAB fab;\n+      struct NAM nam;\n+      char exp_nam[NAM$C_MAXRSS+1],  /* expanded name buffer for sys$parse */\n+\t   res_nam[NAM$C_MAXRSS+1];  /* resultant name buffer for sys$search */\n+\n+      fab = cc$rms_fab;\n+      fab.fab$l_fna = (char *) name;\n+      fab.fab$b_fns = (unsigned char) strlen (name);\n+      fab.fab$l_nam = (void *) &nam;\n+      nam = cc$rms_nam;\n+      nam.nam$l_esa = exp_nam,  nam.nam$b_ess = sizeof exp_nam - 1;\n+      nam.nam$l_rsa = res_nam,  nam.nam$b_rss = sizeof res_nam - 1;\n+      nam.nam$b_nop = NAM$M_PWD | NAM$M_NOCONCEAL;\n+      if (sys$parse (&fab) & 1)\n+\t{\n+\t  if (sys$search (&fab) & 1)\n+\t    {\n+\t      res_nam[nam.nam$b_rsl] = '\\0';\n+\t      result = stat (res_nam, statbuf);\n+\t    }\n+\t  /* Clean up searchlist context cached by the system.  */\n+\t  nam.nam$b_nop = NAM$M_SYNCHK;\n+\t  fab.fab$l_fna = 0,  fab.fab$b_fns = 0;\n+\t  (void) sys$parse (&fab);\n+\t}\n+    }\n+\n+  return result;\n+}\n #endif /* VMS */"}]}