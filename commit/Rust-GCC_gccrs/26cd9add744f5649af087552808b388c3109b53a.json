{"sha": "26cd9add744f5649af087552808b388c3109b53a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZjZDlhZGQ3NDRmNTY0OWFmMDg3NTUyODA4YjM4OGMzMTA5YjUzYQ==", "commit": {"author": {"name": "Enkovich Ilya", "email": "ilya.enkovich@intel.com", "date": "2011-12-21T11:52:27Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2011-12-21T11:52:27Z"}, "message": "re PR target/50038 (redundant zero extensions)\n\ngcc/\n\n2011-12-21  Enkovich Ilya  <ilya.enkovich@intel.com>\n\n        PR target/50038\n        * implicit-zee.c: Delete.\n        * ree.c: New file.\n        * Makefile.in: Replace implicit-zee.c with ree.c.\n        * config/i386/i386.c (ix86_option_override_internal): Rename\n        flag_zee to flag_ree.\n        * common.opt (fzee): Ignored.\n        (free): New.\n        * passes.c (init_optimization_passes): Replace pass_implicit_zee\n        with pass_ree.\n        * tree-pass.h (pass_implicit_zee): Delete.\n        (pass_ree): New.\n        * timevar.def (TV_ZEE): Delete.\n        (TV_REE): New.\n        * doc/invoke.texi: Add -free description.\n\ngcc/testsuite/\n\n2011-12-21  Enkovich Ilya  <ilya.enkovich@intel.com>\n\n        PR target/50038\n\nFrom-SVN: r182574", "tree": {"sha": "5a0567e5d4418bbaeb05479b5f83eb010f0605fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a0567e5d4418bbaeb05479b5f83eb010f0605fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26cd9add744f5649af087552808b388c3109b53a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26cd9add744f5649af087552808b388c3109b53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26cd9add744f5649af087552808b388c3109b53a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26cd9add744f5649af087552808b388c3109b53a/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76f734d8f50612486c0eb696468582fce0128f92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f734d8f50612486c0eb696468582fce0128f92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f734d8f50612486c0eb696468582fce0128f92"}], "stats": {"total": 577, "additions": 336, "deletions": 241}, "files": [{"sha": "e8f974abb9fade872f7fd66ad75db4deb21f6375", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1,3 +1,21 @@\n+2011-12-21  Enkovich Ilya  <ilya.enkovich@intel.com>\n+\n+\tPR target/50038\n+\t* implicit-zee.c: Delete.\n+\t* ree.c: New file.\n+\t* Makefile.in: Replace implicit-zee.c with ree.c.\n+\t* config/i386/i386.c (ix86_option_override_internal): Rename\n+\tflag_zee to flag_ree.\n+\t* common.opt (fzee): Ignored.\n+\t(free): New.\n+\t* passes.c (init_optimization_passes): Replace pass_implicit_zee\n+\twith pass_ree.\n+\t* tree-pass.h (pass_implicit_zee): Delete.\n+\t(pass_ree): New.\n+\t* timevar.def (TV_ZEE): Delete.\n+\t(TV_REE): New.\n+\t* doc/invoke.texi: Add -free description.\n+\n 2011-12-21  Tristan Gingold  <gingold@adacore.com>\n \n \t* config/vms/vms-protos.h (vms_function_section): New prototype."}, {"sha": "33e156962933f3e5c3cdf87c5e52469462f3bbde", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1251,7 +1251,7 @@ OBJS = \\\n \thw-doloop.o \\\n \thwint.o \\\n \tifcvt.o \\\n-\timplicit-zee.o \\\n+\tree.o \\\n \tincpath.o \\\n \tinit-regs.o \\\n \tintegrate.o \\\n@@ -3028,7 +3028,7 @@ fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(DIAGNOSTIC_CORE_H) \\\n    insn-config.h $(RECOG_H) $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H)\n-implicit-zee.o : implicit-zee.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+ree.o : ree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h \\\n    $(DF_H) $(TIMEVAR_H) tree-pass.h $(RECOG_H) $(EXPR_H) \\\n    $(REGS_H) $(TREE_H) $(TM_P_H) insn-config.h $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "2a2c679cc13058744e34f70fbfefc084b8296c48", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1781,8 +1781,12 @@ Common Ignore\n Does nothing.  Preserved for backward compatibility.\n \n fzee\n-Common Report Var(flag_zee) Init(0)\n-Eliminate redundant zero extensions on targets that support implicit extensions.\n+Common Ignore\n+Does nothing.  Preserved for backward compatibility.\n+\n+free\n+Common Report Var(flag_ree) Init(0)\n+Turn on Redundant Extensions Elimination pass.\n \n fshow-column\n Common Report Var(flag_show_column) Init(1)"}, {"sha": "c913c13d479fbfe0836f525f721eff99d2e9a3b7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -3449,8 +3449,8 @@ ix86_option_override_internal (bool main_args_p)\n      in case they weren't overwritten by command line options.  */\n   if (TARGET_64BIT)\n     {\n-      if (optimize > 1 && !global_options_set.x_flag_zee)\n-        flag_zee = 1;\n+      if (optimize > 1 && !global_options_set.x_flag_ree)\n+\tflag_ree = 1;\n       if (optimize >= 1 && !global_options_set.x_flag_omit_frame_pointer)\n \tflag_omit_frame_pointer = !USE_X86_64_FRAME_POINTER;\n       if (flag_asynchronous_unwind_tables == 2)"}, {"sha": "99427553edccef4a50327b84cba9e90b5ad4b3aa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -385,7 +385,7 @@ Objective-C and Objective-C++ Dialects}.\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n--freciprocal-math -fregmove -frename-registers -freorder-blocks @gol\n+-freciprocal-math -free -fregmove -frename-registers -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n -frounding-math -fsched2-use-superblocks -fsched-pressure @gol\n@@ -6709,6 +6709,14 @@ Perform a number of minor optimizations that are relatively expensive.\n \n Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -free\n+@opindex free\n+Attempt to remove redundant extension instructions.  This is especially\n+helpful for the x86-64 architecture which implicitly zero-extends in 64-bit\n+registers after writing to their lower 32-bit half.\n+\n+Enabled for x86 at levels @option{-O2}, @option{-O3}.\n+\n @item -foptimize-register-move\n @itemx -fregmove\n @opindex foptimize-register-move"}, {"sha": "1125cfe76fcfdfe115a1f23523a012bfe886a9ed", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1490,7 +1490,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_postreload_cse);\n \t  NEXT_PASS (pass_gcse2);\n \t  NEXT_PASS (pass_split_after_reload);\n-\t  NEXT_PASS (pass_implicit_zee);\n+\t  NEXT_PASS (pass_ree);\n \t  NEXT_PASS (pass_compare_elim_after_reload);\n \t  NEXT_PASS (pass_branch_target_load_optimize1);\n \t  NEXT_PASS (pass_thread_prologue_and_epilogue);"}, {"sha": "ce714dcacc67c31877489a7090ed22dc15286df3", "filename": "gcc/ree.c", "status": "renamed", "additions": 271, "deletions": 231, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1,8 +1,9 @@\n-/* Redundant Zero-extension elimination for targets that implicitly\n-   zero-extend writes to the lower 32-bit portion of 64-bit registers.\n-   Copyright (C) 2010 Free Software Foundation, Inc.\n-   Contributed by Sriraman Tallam (tmsriram@google.com) and\n-                  Silvius Rus     (rus@google.com)\n+/* Redundant Extension Elimination pass for the GNU compiler.\n+  Copyright (C) 2010-2011 Free Software Foundation, Inc.\n+  Contributed by Ilya Enkovich (ilya.enkovich@intel.com)\n+\n+  Based on the Redundant Zero-extension elimination pass contributed by\n+  Sriraman Tallam (tmsriram@google.com) and Silvius Rus (rus@google.com).\n \n This file is part of GCC.\n \n@@ -23,63 +24,63 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Problem Description :\n    --------------------\n-   This pass is intended to be applicable only to targets that implicitly\n-   zero-extend 64-bit registers after writing to their lower 32-bit half.\n-   For instance, x86_64 zero-extends the upper bits of a register\n-   implicitly whenever an instruction writes to its lower 32-bit half.\n-   For example, the instruction *add edi,eax* also zero-extends the upper\n-   32-bits of rax after doing the addition.  These zero extensions come\n-   for free and GCC does not always exploit this well.  That is, it has\n-   been observed that there are plenty of cases where GCC explicitly\n-   zero-extends registers for x86_64 that are actually useless because\n-   these registers were already implicitly zero-extended in a prior\n-   instruction.  This pass tries to eliminate such useless zero extension\n-   instructions.\n+   This pass is intended to remove redundant extension instructions.\n+   Such instructions appear for different reasons.  We expect some of\n+   them due to implicit zero-extension in 64-bit registers after writing\n+   to their lower 32-bit half (e.g. for the x86-64 architecture).\n+   Another possible reason is a type cast which follows a load (for\n+   instance a register restore) and which can be combined into a single\n+   instruction, and for which earlier local passes, e.g. the combiner,\n+   weren't able to optimize.\n \n    How does this pass work  ?\n    --------------------------\n \n    This pass is run after register allocation.  Hence, all registers that\n-   this pass deals with are hard registers.  This pass first looks for a\n-   zero-extension instruction that could possibly be redundant. Such zero\n-   extension instructions show up in RTL with the pattern :\n-   (set (reg:DI x) (zero_extend:DI (reg:SI x))).\n-   where x can be any one of the 64-bit hard registers.\n+   this pass deals with are hard registers.  This pass first looks for an\n+   extension instruction that could possibly be redundant.  Such extension\n+   instructions show up in RTL with the pattern  :\n+   (set (reg:<SWI248> x) (any_extend:<SWI248> (reg:<SWI124> x))),\n+   where x can be any hard register.\n    Now, this pass tries to eliminate this instruction by merging the\n-   zero-extension with the definitions of register x. For instance, if\n+   extension with the definitions of register x.  For instance, if\n    one of the definitions of register x was  :\n    (set (reg:SI x) (plus:SI (reg:SI z1) (reg:SI z2))),\n+   followed by extension  :\n+   (set (reg:DI x) (zero_extend:DI (reg:SI x)))\n    then the combination converts this into :\n    (set (reg:DI x) (zero_extend:DI (plus:SI (reg:SI z1) (reg:SI z2)))).\n    If all the merged definitions are recognizable assembly instructions,\n-   the zero-extension is effectively eliminated.  For example, in x86_64,\n-   implicit zero-extensions are captured with appropriate patterns in the\n-   i386.md file.  Hence, these merged definition can be matched to a single\n-   assembly instruction.  The original zero-extension instruction is then\n-   deleted if all the definitions can be merged.\n+   the extension is effectively eliminated.\n+\n+   For example, for the x86-64 architecture, implicit zero-extensions\n+   are captured with appropriate patterns in the i386.md file.  Hence,\n+   these merged definition can be matched to a single assembly instruction.\n+   The original extension instruction is then deleted if all the\n+   definitions can be merged.\n \n    However, there are cases where the definition instruction cannot be\n-   merged with a zero-extend.  Examples are CALL instructions.  In such\n-   cases, the original zero extension is not redundant and this pass does\n+   merged with an extension.  Examples are CALL instructions.  In such\n+   cases, the original extension is not redundant and this pass does\n    not delete it.\n \n    Handling conditional moves :\n    ----------------------------\n \n-   Architectures like x86_64 support conditional moves whose semantics for\n-   zero-extension differ from the other instructions.  For instance, the\n+   Architectures like x86-64 support conditional moves whose semantics for\n+   extension differ from the other instructions.  For instance, the\n    instruction *cmov ebx, eax*\n    zero-extends eax onto rax only when the move from ebx to eax happens.\n-   Otherwise, eax may not be zero-extended.  Conditional moves appear as\n+   Otherwise, eax may not be zero-extended.  Consider conditional move as\n    RTL instructions of the form\n    (set (reg:SI x) (if_then_else (cond) (reg:SI y) (reg:SI z))).\n-   This pass tries to merge a zero-extension with a conditional move by\n-   actually merging the defintions of y and z with a zero-extend and then\n+   This pass tries to merge an extension with a conditional move by\n+   actually merging the defintions of y and z with an extension and then\n    converting the conditional move into :\n    (set (reg:DI x) (if_then_else (cond) (reg:DI y) (reg:DI z))).\n-   Since registers y and z are zero-extended, register x will also be\n-   zero-extended after the conditional move.  Note that this step has to\n-   be done transitively since the definition of a conditional copy can be\n+   Since registers y and z are extended, register x will also be extended\n+   after the conditional move.  Note that this step has to be done\n+   transitively since the definition of a conditional copy can be\n    another conditional copy.\n \n    Motivating Example I :\n@@ -100,7 +101,7 @@ along with GCC; see the file COPYING3.  If not see\n    }\n    **********************************************\n \n-   $ gcc -O2 -fsee bad_code.c (Turned on existing sign-extension elimination)\n+   $ gcc -O2 bad_code.c\n      ........\n      400315:       b8 4e 00 00 00          mov    $0x4e,%eax\n      40031a:       0f af f8                imul   %eax,%edi\n@@ -114,7 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n      40033a:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax\n      400341:       c3                      retq\n \n-   $ gcc -O2 -fzee bad_code.c\n+   $ gcc -O2 -free bad_code.c\n      ......\n      400315:       6b ff 4e                imul   $0x4e,%edi,%edi\n      400318:       8b 04 bd 40 19 40 00    mov    0x401940(,%rdi,4),%eax\n@@ -141,7 +142,7 @@ along with GCC; see the file COPYING3.  If not see\n      return (unsigned long long)(z);\n    }\n \n-   $ gcc -O2 -fsee bad_code.c (Turned on existing sign-extension elimination)\n+   $ gcc -O2 bad_code.c\n      ............\n      400360:       8d 14 3e                lea    (%rsi,%rdi,1),%edx\n      400363:       89 f8                   mov    %edi,%eax\n@@ -151,7 +152,7 @@ along with GCC; see the file COPYING3.  If not see\n      40036d:       89 c0                   mov    %eax,%eax  --> Useless extend\n      40036f:       c3                      retq\n \n-   $ gcc -O2 -fzee bad_code.c\n+   $ gcc -O2 -free bad_code.c\n      .............\n      400360:       89 fa                   mov    %edi,%edx\n      400362:       8d 04 3e                lea    (%rsi,%rdi,1),%eax\n@@ -161,17 +162,57 @@ along with GCC; see the file COPYING3.  If not see\n      40036c:       48 0f 42 c6             cmovb  %rsi,%rax\n      400370:       c3                      retq\n \n+  Motivating Example III :\n+  ---------------------\n+\n+  Here is an example with a type cast.\n+\n+  For this program :\n+  **********************************************\n+\n+  void test(int size, unsigned char *in, unsigned char *out)\n+  {\n+    int i;\n+    unsigned char xr, xg, xy=0;\n+\n+    for (i = 0; i < size; i++) {\n+      xr = *in++;\n+      xg = *in++;\n+      xy = (unsigned char) ((19595*xr + 38470*xg) >> 16);\n+      *out++ = xy;\n+    }\n+  }\n+\n+  $ gcc -O2 bad_code.c\n+    ............\n+    10:   0f b6 0e                movzbl (%rsi),%ecx\n+    13:   0f b6 46 01             movzbl 0x1(%rsi),%eax\n+    17:   48 83 c6 02             add    $0x2,%rsi\n+    1b:   0f b6 c9                movzbl %cl,%ecx  --> Useless extend\n+    1e:   0f b6 c0                movzbl %al,%eax  --> Useless extend\n+    21:   69 c9 8b 4c 00 00       imul   $0x4c8b,%ecx,%ecx\n+    27:   69 c0 46 96 00 00       imul   $0x9646,%eax,%eax\n+\n+   $ gcc -O2 -free bad_code.c\n+     .............\n+    10:   0f b6 0e                movzbl (%rsi),%ecx\n+    13:   0f b6 46 01             movzbl 0x1(%rsi),%eax\n+    17:   48 83 c6 02             add    $0x2,%rsi\n+    1b:   69 c9 8b 4c 00 00       imul   $0x4c8b,%ecx,%ecx\n+    21:   69 c0 46 96 00 00       imul   $0x9646,%eax,%eax\n \n    Usefulness :\n    ----------\n \n-   This pass reduces the dynamic instruction count of a compression benchmark\n-   by 2.8% and improves its run time by about 1%.  The compression benchmark\n-   had the following code sequence in a very hot region of code before ZEE\n-   optimized it :\n+   The original redundant zero-extension elimination pass reported reduction\n+   of the dynamic instruction count of a compression benchmark by 2.8% and\n+   improvement of its run time by about 1%.\n \n-   shr $0x5, %edx\n-   mov %edx, %edx --> Useless zero-extend  */\n+   The additional performance gain with the enhanced pass is mostly expected\n+   on in-order architectures where redundancy cannot be compensated by out of\n+   order execution.  Measurements showed up to 10% performance gain (reduced\n+   run time) on EEMBC 2.0 benchmarks on Atom processor with geomean performance\n+   gain 1%.  */\n \n \n #include \"config.h\"\n@@ -205,21 +246,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n \n /* This says if a register is newly created for the purpose of\n-   zero-extension.  */\n+   extension.  */\n \n enum insn_merge_code\n {\n   MERGE_NOT_ATTEMPTED = 0,\n   MERGE_SUCCESS\n };\n \n+/* This structure is used to hold data about candidate for\n+   elimination.  */\n+\n+typedef struct GTY(()) ext_cand\n+{\n+  rtx insn;\n+  const_rtx expr;\n+  enum machine_mode src_mode;\n+} ext_cand, *ext_cand_ref;\n+\n+DEF_VEC_O(ext_cand);\n+DEF_VEC_ALLOC_O(ext_cand, heap);\n+\n /* This says if a INSN UID or its definition has already been merged\n-   with a zero-extend or not.  */\n+   with a extension or not.  */\n \n static enum insn_merge_code *is_insn_merge_attempted;\n static int max_insn_uid;\n \n-/* Returns the merge code status for INSN.  */\n+/* Return the merge code status for INSN.  */\n \n static enum insn_merge_code\n get_insn_status (rtx insn)\n@@ -228,7 +282,7 @@ get_insn_status (rtx insn)\n   return is_insn_merge_attempted[INSN_UID (insn)];\n }\n \n-/* Sets the merge code status of INSN to CODE.  */\n+/* Set the merge code status of INSN to CODE.  */\n \n static void\n set_insn_status (rtx insn, enum insn_merge_code code)\n@@ -237,86 +291,78 @@ set_insn_status (rtx insn, enum insn_merge_code code)\n   is_insn_merge_attempted[INSN_UID (insn)] = code;\n }\n \n-/* Given a insn (CURR_INSN) and a pointer to the SET rtx (ORIG_SET)\n-   that needs to be modified, this code modifies the SET rtx to a\n-   new SET rtx that zero_extends the right hand expression into a DImode\n-   register (NEWREG) on the left hand side.  Note that multiple\n-   assumptions are made about the nature of the set that needs\n-   to be true for this to work and is called from merge_def_and_ze.\n+/* Given a insn (CURR_INSN), an extension candidate for removal (CAND)\n+   and a pointer to the SET rtx (ORIG_SET) that needs to be modified,\n+   this code modifies the SET rtx to a new SET rtx that extends the\n+   right hand expression into a register on the left hand side.  Note\n+   that multiple assumptions are made about the nature of the set that\n+   needs to be true for this to work and is called from merge_def_and_ext.\n \n    Original :\n-   (set (reg:SI a) (expression))\n+   (set (reg a) (expression))\n \n    Transform :\n-   (set (reg:DI a) (zero_extend (expression)))\n+   (set (reg a) (extend (expression)))\n \n    Special Cases :\n-   If the expression is a constant or another zero_extend directly\n-   assign it to the DI mode register.  */\n+   If the expression is a constant or another extend directly\n+   assign it to the register.  */\n \n static bool\n-combine_set_zero_extend (rtx curr_insn, rtx *orig_set, rtx newreg)\n+combine_set_extend (ext_cand_ref cand, rtx curr_insn, rtx *orig_set)\n {\n   rtx temp_extension, simplified_temp_extension, new_set, new_const_int;\n-  rtx orig_src;\n-  HOST_WIDE_INT val;\n-  unsigned int mask, delta_width;\n+  rtx orig_src, cand_src;\n+  rtx newreg;\n+  enum machine_mode dst_mode = GET_MODE (SET_DEST (cand->expr));\n \n   /* Change the SET rtx and validate it.  */\n   orig_src = SET_SRC (*orig_set);\n+  cand_src = SET_SRC (cand->expr);\n   new_set = NULL_RTX;\n \n-  /* The right hand side can also be VOIDmode.  These cases have to be\n-     handled differently.  */\n+  newreg = gen_rtx_REG (dst_mode, REGNO (SET_DEST (*orig_set)));\n \n-  if (GET_MODE (orig_src) != SImode)\n-    {\n-      /* Merge constants by directly moving the constant into the\n-         DImode register under some conditions.  */\n+  /* Merge constants by directly moving the constant into the\n+     register under some conditions.  */\n \n-      if (GET_CODE (orig_src) == CONST_INT\n-\t  && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (SImode))\n-        {\n-          if (INTVAL (orig_src) >= 0)\n-            new_set = gen_rtx_SET (VOIDmode, newreg, orig_src);\n-          else if (INTVAL (orig_src) < 0)\n-            {\n-              /* Zero-extending a negative SImode integer into DImode\n-                 makes it a positive integer.  Convert the given negative\n-                 integer into the appropriate integer when zero-extended.  */\n-\n-              delta_width = HOST_BITS_PER_WIDE_INT - GET_MODE_BITSIZE (SImode);\n-              mask = (~(unsigned HOST_WIDE_INT) 0) >> delta_width;\n-              val = INTVAL (orig_src);\n-              val = val & mask;\n-              new_const_int = gen_rtx_CONST_INT (VOIDmode, val);\n-              new_set = gen_rtx_SET (VOIDmode, newreg, new_const_int);\n-            }\n-          else\n-            return false;\n-        }\n+  if (GET_CODE (orig_src) == CONST_INT\n+      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (dst_mode))\n+    {\n+      if (INTVAL (orig_src) >= 0 || GET_CODE (cand_src) == SIGN_EXTEND)\n+\tnew_set = gen_rtx_SET (VOIDmode, newreg, orig_src);\n       else\n-        {\n-          /* This is mostly due to a call insn that should not be\n-             optimized.  */\n+\t{\n+\t  /* Zero-extend the negative constant by masking out the bits outside\n+\t     the source mode.  */\n+\t  enum machine_mode src_mode = GET_MODE (SET_DEST (*orig_set));\n+\t  new_const_int\n+\t    = GEN_INT (INTVAL (orig_src) & GET_MODE_MASK (src_mode));\n+\t  new_set = gen_rtx_SET (VOIDmode, newreg, new_const_int);\n+\t}\n+    }\n+  else if (GET_MODE (orig_src) == VOIDmode)\n+    {\n+      /* This is mostly due to a call insn that should not be\n+\t optimized.  */\n \n-          return false;\n-        }\n+      return false;\n     }\n-  else if (GET_CODE (orig_src) == ZERO_EXTEND)\n+  else if (GET_CODE (orig_src) == GET_CODE (cand_src))\n     {\n-      /* Here a zero-extend is used to get to SI. Why not make it\n-         all the  way till DI.  */\n+      /* Here is a sequence of two extensions.  Try to merge them into a\n+\t single one.  */\n \n-      temp_extension = gen_rtx_ZERO_EXTEND (DImode, XEXP (orig_src, 0));\n+      temp_extension\n+\t= gen_rtx_fmt_e (GET_CODE (orig_src), dst_mode, XEXP (orig_src, 0));\n       simplified_temp_extension = simplify_rtx (temp_extension);\n       if (simplified_temp_extension)\n         temp_extension = simplified_temp_extension;\n       new_set = gen_rtx_SET (VOIDmode, newreg, temp_extension);\n     }\n   else if (GET_CODE (orig_src) == IF_THEN_ELSE)\n     {\n-      /* Only IF_THEN_ELSE of phi-type copies are combined. Otherwise,\n+      /* Only IF_THEN_ELSE of phi-type copies are combined.  Otherwise,\n          in general, IF_THEN_ELSE should not be combined.  */\n \n       return false;\n@@ -325,7 +371,8 @@ combine_set_zero_extend (rtx curr_insn, rtx *orig_set, rtx newreg)\n     {\n       /* This is the normal case we expect.  */\n \n-      temp_extension = gen_rtx_ZERO_EXTEND (DImode, orig_src);\n+      temp_extension\n+\t= gen_rtx_fmt_e (GET_CODE (cand_src), dst_mode, orig_src);\n       simplified_temp_extension = simplify_rtx (temp_extension);\n       if (simplified_temp_extension)\n         temp_extension = simplified_temp_extension;\n@@ -334,60 +381,49 @@ combine_set_zero_extend (rtx curr_insn, rtx *orig_set, rtx newreg)\n \n   gcc_assert (new_set != NULL_RTX);\n \n-  /* This change is a part of a group of changes. Hence,\n+  /* This change is a part of a group of changes.  Hence,\n      validate_change will not try to commit the change.  */\n \n   if (validate_change (curr_insn, orig_set, new_set, true))\n     {\n       if (dump_file)\n         {\n-          fprintf (dump_file, \"Merged Instruction with ZERO_EXTEND:\\n\");\n+          fprintf (dump_file, \"Merged Instruction with EXTEND:\\n\");\n           print_rtl_single (dump_file, curr_insn);\n         }\n       return true;\n     }\n   return false;\n }\n \n-/* This returns the DI mode for the SI register REG_SI.  */\n-\n-static rtx\n-get_reg_di (rtx reg_si)\n-{\n-  rtx newreg;\n-\n-  newreg = gen_rtx_REG (DImode, REGNO (reg_si));\n-  gcc_assert (newreg);\n-  return newreg;\n-}\n-\n /* Treat if_then_else insns, where the operands of both branches\n-   are registers, as copies. For instance,\n+   are registers, as copies.  For instance,\n    Original :\n    (set (reg:SI a) (if_then_else (cond) (reg:SI b) (reg:SI c)))\n    Transformed :\n    (set (reg:DI a) (if_then_else (cond) (reg:DI b) (reg:DI c)))\n    DEF_INSN is the if_then_else insn.  */\n \n static bool\n-transform_ifelse (rtx def_insn)\n+transform_ifelse (ext_cand_ref cand, rtx def_insn)\n {\n   rtx set_insn = PATTERN (def_insn);\n   rtx srcreg, dstreg, srcreg2;\n   rtx map_srcreg, map_dstreg, map_srcreg2;\n   rtx ifexpr;\n   rtx cond;\n   rtx new_set;\n+  enum machine_mode dst_mode = GET_MODE (SET_DEST (cand->expr));\n \n   gcc_assert (GET_CODE (set_insn) == SET);\n   cond = XEXP (SET_SRC (set_insn), 0);\n   dstreg = SET_DEST (set_insn);\n   srcreg = XEXP (SET_SRC (set_insn), 1);\n   srcreg2 = XEXP (SET_SRC (set_insn), 2);\n-  map_srcreg = get_reg_di (srcreg);\n-  map_srcreg2 = get_reg_di (srcreg2);\n-  map_dstreg = get_reg_di (dstreg);\n-  ifexpr = gen_rtx_IF_THEN_ELSE (DImode, cond, map_srcreg, map_srcreg2);\n+  map_srcreg = gen_rtx_REG (dst_mode, REGNO (srcreg));\n+  map_srcreg2 = gen_rtx_REG (dst_mode, REGNO (srcreg2));\n+  map_dstreg = gen_rtx_REG (dst_mode, REGNO (dstreg));\n+  ifexpr = gen_rtx_IF_THEN_ELSE (dst_mode, cond, map_srcreg, map_srcreg2);\n   new_set = gen_rtx_SET (VOIDmode, map_dstreg, ifexpr);\n \n   if (validate_change (def_insn, &PATTERN (def_insn), new_set, true))\n@@ -458,7 +494,7 @@ get_defs (rtx curr_insn, rtx which_reg, VEC (rtx,heap) **dest)\n }\n \n /* rtx function to check if this SET insn, EXPR, is a conditional copy insn :\n-   (set (reg:SI a ) (IF_THEN_ELSE (cond) (reg:SI b) (reg:SI c)))\n+   (set (reg a ) (IF_THEN_ELSE (cond) (reg b) (reg c)))\n    Called from is_insn_cond_copy.  DATA stores the two registers on each\n    side of the condition.  */\n \n@@ -469,12 +505,9 @@ is_this_a_cmove (rtx expr, void *data)\n \n   if (GET_CODE (expr) == SET\n       && GET_CODE (SET_DEST (expr)) == REG\n-      && GET_MODE (SET_DEST (expr)) == SImode\n       && GET_CODE (SET_SRC (expr))  == IF_THEN_ELSE\n       && GET_CODE (XEXP (SET_SRC (expr), 1)) == REG\n-      && GET_MODE (XEXP (SET_SRC (expr), 1)) == SImode\n-      && GET_CODE (XEXP (SET_SRC (expr), 2)) == REG\n-      && GET_MODE (XEXP (SET_SRC (expr), 2)) == SImode)\n+      && GET_CODE (XEXP (SET_SRC (expr), 2)) == REG)\n     {\n       ((rtx *)data)[0] = XEXP (SET_SRC (expr), 1);\n       ((rtx *)data)[1] = XEXP (SET_SRC (expr), 2);\n@@ -484,7 +517,7 @@ is_this_a_cmove (rtx expr, void *data)\n }\n \n /* This returns 1 if it found\n-   (SET (reg:SI REGNO (def_reg)) (if_then_else (cond) (REG:SI x1) (REG:SI x2)))\n+   (SET (reg REGNO (def_reg)) (if_then_else (cond) (REG x1) (REG x2)))\n    in the DEF_INSN pattern.  It stores the x1 and x2 in COPY_REG_1\n    and COPY_REG_2.  */\n \n@@ -515,22 +548,22 @@ is_insn_cond_copy (rtx def_insn, rtx *copy_reg_1, rtx *copy_reg_2)\n   return 0;\n }\n \n-/* Reaching Definitions of the zero-extended register could be conditional\n-   copies or regular definitions.  This function separates the two types into\n-   two lists, DEFS_LIST and COPIES_LIST.  This is necessary because, if a\n-   reaching definition is a conditional copy, combining the zero_extend with\n-   this definition is wrong.  Conditional copies are merged by transitively\n-   merging its definitions.  The defs_list is populated with all the reaching\n-   definitions of the zero-extension instruction (ZERO_EXTEND_INSN) which must\n-   be merged with a zero_extend.  The copies_list contains all the conditional\n-   moves that will later be extended into a DI mode conditonal move if all the\n-   merges are successful.  The function returns false when there is a failure\n-   in getting some definitions, like that of parameters.  It returns 1 upon\n-   success, 0 upon failure and 2 when all definitions of the ZERO_EXTEND_INSN\n-   were merged previously.  */\n+/* Reaching Definitions of the extended register could be conditional copies\n+   or regular definitions.  This function separates the two types into two\n+   lists, DEFS_LIST and COPIES_LIST.  This is necessary because, if a reaching\n+   definition is a conditional copy, combining the extend with this definition\n+   is wrong.  Conditional copies are merged by transitively merging its\n+   definitions.  The defs_list is populated with all the reaching definitions\n+   of the extension instruction (EXTEND_INSN) which must be merged with an\n+   extension.  The copies_list contains all the conditional moves that will\n+   later be extended into a wider mode conditonal move if all the merges are\n+   successful.  The function returns false when there is a failure in getting\n+   some definitions, like that of parameters.  It returns 1 upon success, 0\n+   upon failure and 2 when all definitions of the EXTEND_INSN were merged\n+   previously.  */\n \n static int\n-make_defs_and_copies_lists (rtx zero_extend_insn, rtx set_pat,\n+make_defs_and_copies_lists (rtx extend_insn, rtx set_pat,\n                             VEC (rtx,heap) **defs_list,\n                             VEC (rtx,heap) **copies_list)\n {\n@@ -547,7 +580,7 @@ make_defs_and_copies_lists (rtx zero_extend_insn, rtx set_pat,\n   work_list = VEC_alloc (rtx, heap, 8);\n \n   /* Initialize the Work List */\n-  n_worklist = get_defs (zero_extend_insn, srcreg, &work_list);\n+  n_worklist = get_defs (extend_insn, srcreg, &work_list);\n \n   if (n_worklist == 0)\n     {\n@@ -619,18 +652,19 @@ make_defs_and_copies_lists (rtx zero_extend_insn, rtx set_pat,\n   return 1;\n }\n \n-/* Merge the DEF_INSN with a zero-extend.  Calls combine_set_zero_extend\n+/* Merge the DEF_INSN with an extension.  Calls combine_set_extend\n    on the SET pattern.  */\n \n static bool\n-merge_def_and_ze (rtx def_insn)\n+merge_def_and_ext (ext_cand_ref cand, rtx def_insn)\n {\n+  enum machine_mode ext_src_mode;\n   enum rtx_code code;\n-  rtx setreg;\n   rtx *sub_rtx;\n   rtx s_expr;\n   int i;\n \n+  ext_src_mode = GET_MODE (XEXP (SET_SRC (cand->expr), 0));\n   code = GET_CODE (PATTERN (def_insn));\n   sub_rtx = NULL;\n \n@@ -662,27 +696,25 @@ merge_def_and_ze (rtx def_insn)\n   gcc_assert (sub_rtx != NULL);\n \n   if (GET_CODE (SET_DEST (*sub_rtx)) == REG\n-      && GET_MODE (SET_DEST (*sub_rtx)) == SImode)\n+      && GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode)\n     {\n-      setreg = get_reg_di (SET_DEST (*sub_rtx));\n-      return combine_set_zero_extend (def_insn, sub_rtx, setreg);\n+      return combine_set_extend (cand, def_insn, sub_rtx);\n     }\n-  else\n-    return false;\n-  return true;\n+\n+  return false;\n }\n \n /* This function goes through all reaching defs of the source\n-   of the zero extension instruction (ZERO_EXTEND_INSN) and\n-   tries to combine the zero extension with the definition\n-   instruction.  The changes are made as a group so that even\n-   if one definition cannot be merged, all reaching definitions\n-   end up not being merged. When a conditional copy is encountered,\n-   merging is attempted transitively on its definitions.  It returns\n-   true upon success and false upon failure.  */\n+   of the candidate for elimination (CAND) and tries to combine\n+   the extension with the definition instruction.  The changes\n+   are made as a group so that even if one definition cannot be\n+   merged, all reaching definitions end up not being merged.\n+   When a conditional copy is encountered, merging is attempted\n+   transitively on its definitions.  It returns true upon success\n+   and false upon failure.  */\n \n static bool\n-combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n+combine_reaching_defs (ext_cand_ref cand, rtx set_pat)\n {\n   rtx def_insn;\n   bool merge_successful = true;\n@@ -698,11 +730,11 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n   defs_list = VEC_alloc (rtx, heap, 8);\n   copies_list = VEC_alloc (rtx, heap, 8);\n \n-  outcome = make_defs_and_copies_lists (zero_extend_insn,\n+  outcome = make_defs_and_copies_lists (cand->insn,\n                                         set_pat, &defs_list, &copies_list);\n \n-  /* outcome == 2 implies that all the definitions for this zero_extend were\n-     merged while previously when handling other zero_extends.  */\n+  /* outcome == 2 implies that all the definitions for this extension were\n+     merged while previously when handling other extension.  */\n \n   if (outcome == 2)\n     {\n@@ -731,7 +763,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n       merge_code = get_insn_status (def_insn);\n       gcc_assert (merge_code == MERGE_NOT_ATTEMPTED);\n \n-      if (merge_def_and_ze (def_insn))\n+      if (merge_def_and_ext (cand, def_insn))\n         VEC_safe_push (rtx, heap, vec, def_insn);\n       else\n         {\n@@ -747,7 +779,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n     {\n       FOR_EACH_VEC_ELT (rtx, copies_list, i, def_insn)\n         {\n-          if (transform_ifelse (def_insn))\n+          if (transform_ifelse (cand, def_insn))\n             {\n               VEC_safe_push (rtx, heap, vec, def_insn);\n             }\n@@ -763,7 +795,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n     {\n       /* Commit the changes here if possible */\n       /* XXX : Now, it is an all or nothing scenario.  Even if one definition\n-         cannot be merged we totally bail.  In future, allow zero-extensions to\n+         cannot be merged we totally fail.  In future, allow extensions to\n          be partially eliminated along those paths where the definitions could\n          be merged.  */\n \n@@ -786,7 +818,7 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n         {\n           /* Changes need not be cancelled explicitly as apply_change_group\n              does it.  Print list of definitions in the dump_file for debug\n-             purposes.  This zero-extension cannot be deleted.  */\n+             purposes.  This extension cannot be deleted.  */\n \n           if (dump_file)\n             {\n@@ -810,92 +842,100 @@ combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n   return false;\n }\n \n-/* Carry information about zero-extensions while walking the RTL.  */\n+/* Carry information about extensions while walking the RTL.  */\n \n-struct zero_extend_info\n+struct extend_info\n {\n-  /* The insn where the zero-extension is.  */\n+  /* The insn where the extension is.  */\n   rtx insn;\n \n   /* The list of candidates.  */\n-  VEC (rtx, heap) *insn_list;\n+  VEC (ext_cand, heap) *insn_list;\n };\n \n-/* Add a zero-extend pattern that could be eliminated.  This is called via\n-   note_stores from find_removable_zero_extends.  */\n+static void\n+add_ext_candidate (VEC (ext_cand, heap) **exts,\n+\t\t   rtx insn, const_rtx expr)\n+{\n+  ext_cand_ref ec = VEC_safe_push (ext_cand, heap, *exts, NULL);\n+  ec->insn = insn;\n+  ec->expr = expr;\n+}\n+\n+/* Add an extension pattern that could be eliminated.  This is called via\n+   note_stores from find_removable_extensions.  */\n \n static void\n-add_removable_zero_extend (rtx x ATTRIBUTE_UNUSED, const_rtx expr, void *data)\n+add_removable_extension (rtx x ATTRIBUTE_UNUSED, const_rtx expr, void *data)\n {\n-  struct zero_extend_info *zei = (struct zero_extend_info *)data;\n+  struct extend_info *rei = (struct extend_info *)data;\n   rtx src, dest;\n \n-  /* We are looking for SET (REG:DI N) (ZERO_EXTEND (REG:SI N)).  */\n+  /* We are looking for SET (REG N) (EXTEND (REG N)).  */\n   if (GET_CODE (expr) != SET)\n     return;\n \n   src = SET_SRC (expr);\n   dest = SET_DEST (expr);\n \n   if (REG_P (dest)\n-      && GET_MODE (dest) == DImode\n-      && GET_CODE (src) == ZERO_EXTEND\n+      && (GET_CODE (src) == ZERO_EXTEND || GET_CODE (src) == SIGN_EXTEND)\n       && REG_P (XEXP (src, 0))\n-      && GET_MODE (XEXP (src, 0)) == SImode\n       && REGNO (dest) == REGNO (XEXP (src, 0)))\n     {\n-      if (get_defs (zei->insn, XEXP (src, 0), NULL))\n-\tVEC_safe_push (rtx, heap, zei->insn_list, zei->insn);\n+      if (get_defs (rei->insn, XEXP (src, 0), NULL))\n+\tadd_ext_candidate (&rei->insn_list, rei->insn, expr);\n       else if (dump_file)\n \t{\n-\t  fprintf (dump_file, \"Cannot eliminate zero-extension: \\n\");\n-\t  print_rtl_single (dump_file, zei->insn);\n+\t  fprintf (dump_file, \"Cannot eliminate extension: \\n\");\n+\t  print_rtl_single (dump_file, rei->insn);\n \t  fprintf (dump_file, \"No defs. Could be extending parameters.\\n\");\n \t}\n     }\n }\n \n-/* Traverse the instruction stream looking for zero-extends and return the\n+/* Traverse the instruction stream looking for extensions and return the\n    list of candidates.  */\n \n-static VEC (rtx,heap)*\n-find_removable_zero_extends (void)\n+static VEC (ext_cand, heap)*\n+find_removable_extensions (void)\n {\n-  struct zero_extend_info zei;\n+  struct extend_info rei;\n   basic_block bb;\n   rtx insn;\n \n-  zei.insn_list = VEC_alloc (rtx, heap, 8);\n+  rei.insn_list = VEC_alloc (ext_cand, heap, 8);\n \n   FOR_EACH_BB (bb)\n     FOR_BB_INSNS (bb, insn)\n       {\n \tif (!NONDEBUG_INSN_P (insn))\n \t  continue;\n \n-\tzei.insn = insn;\n-\tnote_stores (PATTERN (insn), add_removable_zero_extend, &zei);\n+\trei.insn = insn;\n+\tnote_stores (PATTERN (insn), add_removable_extension, &rei);\n       }\n \n-  return zei.insn_list;\n+  return rei.insn_list;\n }\n \n /* This is the main function that checks the insn stream for redundant\n-   zero extensions and tries to remove them if possible.  */\n+   extensions and tries to remove them if possible.  */\n \n static unsigned int\n-find_and_remove_ze (void)\n+find_and_remove_re (void)\n {\n+  ext_cand_ref curr_cand;\n   rtx curr_insn = NULL_RTX;\n   int i;\n   int ix;\n   long num_realized = 0;\n-  long num_ze_opportunities = 0;\n-  VEC (rtx, heap) *zeinsn_list;\n-  VEC (rtx, heap) *zeinsn_del_list;\n+  long num_re_opportunities = 0;\n+  VEC (ext_cand, heap) *reinsn_list;\n+  VEC (rtx, heap) *reinsn_del_list;\n \n   /* Construct DU chain to get all reaching definitions of each\n-     zero-extension instruction.  */\n+     extension instruction.  */\n \n   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n   df_analyze ();\n@@ -909,80 +949,80 @@ find_and_remove_ze (void)\n   for (i = 0; i < max_insn_uid; i++)\n     is_insn_merge_attempted[i] = MERGE_NOT_ATTEMPTED;\n \n-  num_ze_opportunities = num_realized = 0;\n+  num_re_opportunities = num_realized = 0;\n \n-  zeinsn_del_list = VEC_alloc (rtx, heap, 4);\n+  reinsn_del_list = VEC_alloc (rtx, heap, 4);\n \n-  zeinsn_list = find_removable_zero_extends ();\n+  reinsn_list = find_removable_extensions ();\n \n-  FOR_EACH_VEC_ELT (rtx, zeinsn_list, ix, curr_insn)\n+  FOR_EACH_VEC_ELT (ext_cand, reinsn_list, ix, curr_cand)\n     {\n-      num_ze_opportunities++;\n-      /* Try to combine the zero-extends with the definition here.  */\n+      num_re_opportunities++;\n+      /* Try to combine the extension with the definition here.  */\n \n       if (dump_file)\n         {\n-          fprintf (dump_file, \"Trying to eliminate zero extension : \\n\");\n+          fprintf (dump_file, \"Trying to eliminate extension : \\n\");\n           print_rtl_single (dump_file, curr_insn);\n         }\n \n-      if (combine_reaching_defs (curr_insn, PATTERN (curr_insn)))\n+      if (combine_reaching_defs (curr_cand, PATTERN (curr_cand->insn)))\n         {\n           if (dump_file)\n-            fprintf (dump_file, \"Eliminated the zero extension...\\n\");\n+            fprintf (dump_file, \"Eliminated the extension...\\n\");\n           num_realized++;\n-          VEC_safe_push (rtx, heap, zeinsn_del_list, curr_insn);\n+          VEC_safe_push (rtx, heap, reinsn_del_list, curr_cand->insn);\n         }\n     }\n \n-  /* Delete all useless zero extensions here in one sweep.  */\n-  FOR_EACH_VEC_ELT (rtx, zeinsn_del_list, ix, curr_insn)\n+  /* Delete all useless extensions here in one sweep.  */\n+  FOR_EACH_VEC_ELT (rtx, reinsn_del_list, ix, curr_insn)\n     delete_insn (curr_insn);\n \n   free (is_insn_merge_attempted);\n-  VEC_free (rtx, heap, zeinsn_list);\n-  VEC_free (rtx, heap, zeinsn_del_list);\n+  VEC_free (ext_cand, heap, reinsn_list);\n+  VEC_free (rtx, heap, reinsn_del_list);\n \n-  if (dump_file && num_ze_opportunities > 0)\n-    fprintf (dump_file, \"\\n %s : num_zee_opportunities = %ld\"\n-\t\t\t\" num_realized = %ld\\n\",\n-                        current_function_name (), num_ze_opportunities,\n-                        num_realized);\n+  if (dump_file && num_re_opportunities > 0)\n+    fprintf (dump_file, \"\\n %s : num_re_opportunities = %ld \"\n+                        \"num_realized = %ld \\n\",\n+                        current_function_name (),\n+                        num_re_opportunities, num_realized);\n \n   df_finish_pass (false);\n   return 0;\n }\n \n-/* Find and remove redundant zero extensions.  */\n+/* Find and remove redundant extensions.  */\n \n static unsigned int\n-rest_of_handle_zee (void)\n+rest_of_handle_ree (void)\n {\n-  timevar_push (TV_ZEE);\n-  find_and_remove_ze ();\n-  timevar_pop (TV_ZEE);\n+  timevar_push (TV_REE);\n+  find_and_remove_re ();\n+  timevar_pop (TV_REE);\n   return 0;\n }\n \n-/* Run zee pass when flag_zee is set at optimization level > 0.  */\n+/* Run REE pass when flag_ree is set at optimization level > 0.  */\n \n static bool\n-gate_handle_zee (void)\n+gate_handle_ree (void)\n {\n-  return (optimize > 0 && flag_zee);\n+  return (optimize > 0 && flag_ree);\n }\n \n-struct rtl_opt_pass pass_implicit_zee =\n+struct rtl_opt_pass pass_ree =\n {\n  {\n   RTL_PASS,\n-  \"zee\",                                /* name */\n-  gate_handle_zee,                      /* gate */\n-  rest_of_handle_zee,                   /* execute */\n+  \"ree\",                                /* name */\n+  gate_handle_ree,                      /* gate */\n+  rest_of_handle_ree,                   /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n-  TV_ZEE,                               /* tv_id */\n+  TV_REE,                               /* tv_id */\n   0,                                    /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */", "previous_filename": "gcc/implicit-zee.c"}, {"sha": "713b5609ff179b123deef9498da11582ef12654b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -1,3 +1,8 @@\n+2011-12-21  Enkovich Ilya  <ilya.enkovich@intel.com>\n+\n+\tPR target/50038\n+\t* gcc.dg/pr50038.c: New test.\n+\n 2011-12-20  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51621"}, {"sha": "4d1c8f71ffd7e5c2c935fe466bb60f19bf87615d", "filename": "gcc/testsuite/gcc.dg/pr50038.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50038.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50038.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr50038.c?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -0,0 +1,20 @@\n+/* PR target/50038 */\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-options \"-O2\" } */\n+\n+void pr50038(int len, unsigned char *in, unsigned char *out)\n+{\n+  int i;\n+  unsigned char xr, xg;\n+  unsigned char xy=0;\n+  for (i = 0; i < len; i++)\n+    {\n+      xr = *in++;\n+      xg = *in++;\n+      xy = (unsigned char) ((19595*xr + 38470*xg) >> 16);\n+\n+      *out++ = xy;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times \"movzbl\" 2 } } */"}, {"sha": "1f5ea2a81bd1ac734e89bd1289ff6e23f9696096", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -230,7 +230,7 @@ DEFTIMEVAR (TV_RELOAD\t   \t     , \"reload\")\n DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n DEFTIMEVAR (TV_SEQABSTR              , \"sequence abstraction\")\n DEFTIMEVAR (TV_GCSE_AFTER_RELOAD      , \"load CSE after reload\")\n-DEFTIMEVAR (TV_ZEE\t\t     , \"zee\")\n+DEFTIMEVAR (TV_REE\t\t     , \"ree\")\n DEFTIMEVAR (TV_THREAD_PROLOGUE_AND_EPILOGUE, \"thread pro- & epilogue\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_COMBINE_STACK_ADJUST  , \"combine stack adjustments\")"}, {"sha": "984df376e0412b9d85d6bf2cab5f178c62d7ccaf", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26cd9add744f5649af087552808b388c3109b53a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=26cd9add744f5649af087552808b388c3109b53a", "patch": "@@ -530,7 +530,7 @@ extern struct rtl_opt_pass pass_stack_ptr_mod;\n extern struct rtl_opt_pass pass_initialize_regs;\n extern struct rtl_opt_pass pass_combine;\n extern struct rtl_opt_pass pass_if_after_combine;\n-extern struct rtl_opt_pass pass_implicit_zee;\n+extern struct rtl_opt_pass pass_ree;\n extern struct rtl_opt_pass pass_partition_blocks;\n extern struct rtl_opt_pass pass_match_asm_constraints;\n extern struct rtl_opt_pass pass_regmove;"}]}