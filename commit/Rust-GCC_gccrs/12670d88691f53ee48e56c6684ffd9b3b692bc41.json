{"sha": "12670d88691f53ee48e56c6684ffd9b3b692bc41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI2NzBkODg2OTFmNTNlZTQ4ZTU2YzY2ODRmZmQ5YjNiNjkyYmM0MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-15T00:47:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-15T00:47:01Z"}, "message": "Manson: Doc +\n\nManson: Doc +\n(add_partial_entry): New routine.\n(expand_start_try_stmts): Moved from cp/except.c.\n(expand_start_all_catch): Move functionality of expand_end_try_stmts here.\n\nFrom-SVN: r12716", "tree": {"sha": "a08577f7ae6a2b08a6d8dbc8169df760cfa75e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a08577f7ae6a2b08a6d8dbc8169df760cfa75e81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12670d88691f53ee48e56c6684ffd9b3b692bc41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12670d88691f53ee48e56c6684ffd9b3b692bc41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12670d88691f53ee48e56c6684ffd9b3b692bc41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12670d88691f53ee48e56c6684ffd9b3b692bc41/comments", "author": null, "committer": null, "parents": [{"sha": "911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/911fdd58bbef52b04dbe54ae74a9755fa60b6ebc"}], "stats": {"total": 673, "additions": 479, "deletions": 194}, "files": [{"sha": "e5407e33647f0620452a921b87b0d26e403b5771", "filename": "gcc/except.c", "status": "modified", "additions": 479, "deletions": 194, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12670d88691f53ee48e56c6684ffd9b3b692bc41/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12670d88691f53ee48e56c6684ffd9b3b692bc41/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=12670d88691f53ee48e56c6684ffd9b3b692bc41", "patch": "@@ -1,4 +1,4 @@\n-/* Implements exceptiom handling.\n+/* Implements exception handling.\n    Copyright (C) 1989, 92-95, 1996 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n@@ -20,81 +20,162 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* This file contains the exception handling code for the compiler.\n-\n-   Exception handling is a mechanism by which complex flows of control\n-   can be designated.  The central concepts are the `exception region',\n-   the associated `exception handler' for that region and the concept of\n-   throwing an exception, and the context of the throw.\n-\n-   Restrictions are, the regions must be non-overlapping, they can be\n-   nested, and there can be zero or more per function.  For each\n-   region, there is one associated handler.  Regions only ever\n-   surround possible context points of throws.  Regions with no such\n-   context points can be optimized away, as they are trivial, and it\n-   is not possible for the associated handler to ever be used during a\n-   throw.\n-\n-   Semantics are, when an exception is thrown, control is transferred\n-   to a handler, and the code of the exception handler is executed.\n-   As control is transferred, the machine state (stack pointer, all\n-   callee saved registers and possibly the frame pointer) is restored.\n-\n-   The handler that is selected by a throw, is the handler associated\n-   with the smallest (most nested) region that contains the context of\n-   the throw, if such a region exists.  If no region exists, the\n-   search for a handler continues in the function that called the\n-   function that contains the current context of the throw, with the\n-   context of the throw then becoming that point in the code that\n-   contains the call instruction.\n-\n-\n-   One can add to the basic model the concepts of thrown exception\n-   type, and thrown exception value.  Semantics are as above, except a\n-   further check is done when finding a handler for the thrown\n-   exception to see if the given handler can handle the thrown\n-   exception based upon the exception object's type and possibly its\n-   value.  A common optimization is when two regions are identical,\n-   the handlers are combined into just one handler so the first check\n-   of the resulting handler is for the inner (nested) region's\n-   handler, and the second one is for the outer region's handler.  To\n-   separate these two notions of handlers, we can call the subhandlers\n-   `catch blocks', and use the name `handler' to refer to the\n-   combination of the two.  Currently, this layer of functionality is\n-   managed by the various front ends.\n-\n-\n-   To mark the start of a exception handling region,\n-   expand_eh_region_start () is called.  To mark the end, and\n-   associate a handler for the region expand_eh_region_end () is used.\n-   The front end can use this interface, if useful.  The back end\n-   creates exception regions with these routines.  Another interface\n-   the front end can use, is TARGET_EXPR.  TARGET_EXPR gives an\n-   unwind-protect style interface a la emacs.\n-\n-\n-   In this implementation, regions do not span more than one function.\n-\n-   In order to help with the task of finding the associated handler for\n-   a region, an exception table is built which associates handlers\n-   with regions.  A 3-tuple, containing a reference to the start, the\n-   end and the handler is sufficient for the exception table.\n-\n-   In order to help with the task of restoring callee saved registers\n-   and performing other associated function exit actions, function\n-   `unwinders' can be generated within those function for which a\n-   generic function unwinder called __unwind_function () cannot work.\n-   Whether the generic __unwind_function can work is machine dependent\n-   and possibly function dependent.  The macro DOESNT_NEEED_UNWINDER\n-   decides if the current function being compiled needs an unwinder or\n-   not.\n-\n-   The default is for unwinders to be used, as the default generic\n-   function unwinder only calls abort ().  The compiler-generated per\n-   function function unwinders simply modify the context of thrown\n-   exception to be that of the call site, and then arrange for control\n-   to be transferred to __throw instead of the function's caller on\n-   return, and then return.  */\n+/* An exception is an event that can be signaled from within a\n+   function. This event can then be \"caught\" or \"trapped\" by the\n+   callers of this function. This potentially allows program flow to\n+   be transferred to any arbitrary code assocated with a function call\n+   several levels up the stack.\n+\n+   The intended use for this mechanism is for signaling \"exceptional\n+   events\" in an out-of-band fashion, hence its name. The C++ language\n+   (and many other OO-styled or functional languages) practically\n+   requires such a mechanism, as otherwise it becomes very difficult\n+   or even impossible to signal failure conditions in complex\n+   situations.  The traditional C++ example is when an error occurs in\n+   the process of constructing an object; without such a mechanism, it\n+   is impossible to signal that the error occurs without adding global\n+   state variables and error checks around every object construction.\n+\n+   The act of causing this event to occur is referred to as \"throwing\n+   an exception\". (Alternate terms include \"raising an exception\" or\n+   \"signaling an exception\".) The term \"throw\" is used because control\n+   is returned to the callers of the function that is signaling the\n+   exception, and thus there is the concept of \"throwing\" the\n+   exception up the call stack.\n+\n+   It is appropriate to speak of the \"context of a throw\". This\n+   context refers to the address where the exception is thrown from,\n+   and is used to determine which exception region will handle the\n+   exception.\n+\n+   Regions of code within a function can be marked such that if it\n+   contains the context of a throw, control will be passed to a\n+   designated \"exception handler\". These areas are known as \"exception\n+   regions\".  Exception regions cannot overlap, but they can be nested\n+   to any arbitrary depth. Also, exception regions cannot cross\n+   function boundaries.\n+\n+   Each object file that is compiled with exception handling contains a\n+   static array of exception handlers named __EXCEPTION_TABLE__. Each entry\n+   contains the starting and ending addresses of the exception region,\n+   and the address of the handler designated for that region.\n+\n+   At program startup each object file invokes a function named\n+   __register_exceptions with the address of its local\n+   __EXCEPTION_TABLE__. __register_exceptions is defined in libgcc2.c,\n+   and is responsible for recording all of the exception regions into\n+   one list (which is kept in a static variable named exception_table_list).\n+\n+   The function __throw () is actually responsible for doing the\n+   throw. In the C++ frontend, __throw () is generated on a\n+   per-object-file basis for each source file compiled with\n+   -fexceptions. \n+\n+   __throw () attempts to find the appropriate exception handler for the \n+   PC value stored in __eh_pc by calling __find_first_exception_table_match\n+   (which is defined in libgcc2.c). If an appropriate handler is\n+   found, __throw jumps directly to it.\n+\n+   If a handler for the address being thrown from can't be found,\n+   __throw is responsible for unwinding the stack, determining the\n+   address of the caller of the current function (which will be used\n+   as the new context to throw from), and then searching for a handler\n+   for the new context. __throw may also call abort () if it is unable\n+   to unwind the stack, and can also call an external library function\n+   named __terminate if it reaches the top of the stack without\n+   finding an appropriate handler.\n+\n+   Note that some of the regions and handlers are implicitly\n+   generated. The handlers for these regions perform necessary\n+   cleanups (in C++ these cleanups are responsible for invoking\n+   necessary object destructors) before rethrowing the exception to\n+   the outer exception region.\n+\n+   Internal implementation details:\n+\n+   The start of an exception region is indicated by calling\n+   expand_eh_region_start (). expand_eh_region_end (handler) is\n+   subsequently invoked to end the region and to associate a handler\n+   with the region. This is used to create a region that has an\n+   associated cleanup routine for performing tasks like object\n+   destruction.\n+\n+   To associate a user-defined handler with a block of statements, the\n+   function expand_start_try_stmts () is used to mark the start of the\n+   block of statements with which the handler is to be associated\n+   (which is usually known as a \"try block\"). All statements that\n+   appear afterwards will be associated with the try block.\n+\n+   A call to expand_start_all_catch () will mark the end of the try\n+   block, and also marks the start of the \"catch block\" associated\n+   with the try block. This catch block will only be invoked if an\n+   exception is thrown through the try block. The instructions for the\n+   catch block are kept as a separate sequence, and will be emitted at\n+   the end of the function along with the handlers specified via\n+   expand_eh_region_end (). The end of the catch block is marked with\n+   expand_end_all_catch ().\n+\n+   Any data associated with the exception must currently be handled by\n+   some external mechanism maintained in the frontend.  For example,\n+   the C++ exception mechanism passes an arbitrary value along with\n+   the exception, and this is handled in the C++ frontend by using a\n+   global variable to hold the value.\n+\n+   Internally-generated exception regions are marked by calling\n+   expand_eh_region_start () to mark the start of the region, and\n+   expand_eh_region_end () is used to both designate the end of the\n+   region and to associate a handler/cleanup with the region. These\n+   functions generate the appropriate RTL sequences to mark the start\n+   and end of the exception regions and ensure that an appropriate\n+   exception region entry will be added to the exception region table.\n+   expand_eh_region_end () also queues the provided handler to be\n+   emitted at the end of the current function.\n+\n+   TARGET_EXPRs can also be used to designate exception regions. A\n+   TARGET_EXPR gives an unwind-protect style interface commonly used\n+   in functional languages such as LISP. The associated expression is\n+   evaluated, and if it (or any of the functions that it calls) throws\n+   an exception it is caught by the associated cleanup. The backend\n+   also takes care of the details of associating an exception table\n+   entry with the expression and generating the necessary code.\n+\n+   The generated RTL for an exception region includes\n+   NOTE_INSN_EH_REGION_BEG and NOTE_INSN_EH_REGION_END notes that mark\n+   the start and end of the exception region. A unique label is also\n+   generated at the start of the exception region.\n+\n+   In the current implementation, an exception can only be thrown from\n+   a function call (since the mechanism used to actually throw an\n+   exception involves calling __throw).  If an exception region is\n+   created but no function calls occur within that region, the region\n+   can be safely optimized away since no exceptions can ever be caught\n+   in that region.\n+\n+   Unwinding the stack:\n+\n+   The details of unwinding the stack to the next frame can be rather\n+   complex. While in many cases a generic __unwind_function () routine\n+   can be used by the generated exception handling code to do this, it\n+   is often necessary to generate inline code to do the unwinding.\n+\n+   Whether or not these inlined unwinders are necessary is\n+   target-specific.\n+\n+   By default, if the target-specific backend doesn't supply a\n+   definition for __unwind_function (), inlined unwinders will be used\n+   instead. The main tradeoff here is in text space utilization.\n+   Obviously, if inline unwinders have to be generated repeatedly,\n+   this uses more space than if a single routine is used.\n+\n+   The backend macro DOESNT_NEED_UNWINDER is used to conditionalize\n+   whether or not per-function unwinders are needed. If DOESNT_NEED_UNWINDER\n+   is defined and has a non-zero value, a per-function unwinder is\n+   not emitted for the current function.\n+\n+   On some platforms it is possible that neither __unwind_function ()\n+   nor inlined unwinders are available. For these platforms it is not\n+   possible to throw through a function call, and abort () will be\n+   invoked instead of performing the throw. */\n \n \n #include \"config.h\"\n@@ -112,56 +193,67 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"output.h\"\n+#include \"assert.h\"\n \n-/* List of labels use for exception handlers.  Created by\n+/* A list of labels used for exception handlers.  Created by\n    find_exception_handler_labels for the optimization passes.  */\n \n rtx exception_handler_labels;\n \n-/* Nonzero means that throw was used.  Used for now, because __throw\n-   is emitted statically in each file.  */\n+/* Nonzero means that __throw was invoked. \n+\n+   This is used by the C++ frontend to know if code needs to be emitted\n+   for __throw or not.  */\n \n int throw_used;\n \n /* A stack used for keeping track of the currectly active exception\n-   handling region.  As exceptions regions are started, an entry\n+   handling region.  As each exception region is started, an entry\n    describing the region is pushed onto this stack.  The current\n    region can be found by looking at the top of the stack, and as we\n-   end regions, entries are poped.  */\n+   exit regions, the corresponding entries are popped. \n+\n+   Entries cannot overlap; they must be nested. So there is only one\n+   entry at most that corresponds to the current instruction, and that\n+   is the entry on the top of the stack.  */\n \n struct eh_stack ehstack;\n \n-/* A queue used for tracking which exception regions have closed, but\n-   whose handlers have not yet been expanded.  As we end regions, we\n-   enqueue the entry onto this queue.  Entries are dequeue from the\n-   queue during expand_leftover_cleanups and expand_start_all_catch,\n-   and the handlers for regions are expanded in groups in an effort to\n-   group all the handlers together in the same region of program space\n-   to improve page performance.  We should redo things, so that we\n-   either take RTL for the handler, or we expand the handler expressed\n-   as a tree immediately at region end time.  */\n+/* A queue used for tracking which exception regions have closed but\n+   whose handlers have not yet been expanded. Regions are emitted in\n+   groups in an attempt to improve paging performance.\n+\n+   As we exit a region, we enqueue a new entry. The entries are then\n+   dequeued during expand_leftover_cleanups () and expand_start_all_catch (),\n+\n+   We should redo things so that we either take RTL for the handler,\n+   or we expand the handler expressed as a tree immediately at region\n+   end time.  */\n \n struct eh_queue ehqueue;\n \n-/* Insns for the catch clauses.  */\n+/* Insns for all of the exception handlers for the current function.\n+   They are currently emitted by the frontend code. */\n \n rtx catch_clauses;\n \n-/* A list of actions for handlers for regions that are not yet\n-   closed.  */\n+/* A TREE_CHAINed list of handlers for regions that are not yet\n+   closed. The TREE_VALUE of each entry contains the handler for the\n+   corresponding entry on the ehstack. */\n \n-tree protect_list;\n+static tree protect_list;\n \n /* Stacks to keep track of various labels.  */\n \n-/* Keeps track of the label to resume to, should one want to resume\n-   the normal control flow out of a handler.  Also used to rethrow\n-   exceptions caught in handlers, as if they were physically emitted\n-   inline.  */\n+/* Keeps track of the label to resume to should one want to resume\n+   normal control flow out of a handler (instead of, say, returning to\n+   the caller of the current function or exiting the program).  Also\n+   used as the context of a throw to rethrow an exception to the outer\n+   exception region. */\n \n struct label_node *caught_return_label_stack = NULL;\n \n-/* A spare data area for the front end's own use.  */\n+/* A random data area for the front end's own use.  */\n \n struct label_node *false_label_stack = NULL;\n \n@@ -226,7 +318,7 @@ top_label_entry (stack)\n   return (*stack)->u.tlabel;\n }\n \n-/* Copy an entry.  */\n+/* Make a copy of ENTRY using xmalloc to allocate the space.  */\n \n static struct eh_entry *\n copy_eh_entry (entry)\n@@ -240,7 +332,8 @@ copy_eh_entry (entry)\n   return newentry;\n }\n \n-/* Push an entry onto the given STACK.  */\n+/* Push a new eh_node entry onto STACK, and return the start label for\n+   the entry. */\n \n static rtx\n push_eh_entry (stack)\n@@ -324,7 +417,10 @@ dequeue_eh_entry (queue)\n \f\n /* Routine to see if exception exception handling is turned on.\n    DO_WARN is non-zero if we want to inform the user that exception\n-   handling is turned off.  */\n+   handling is turned off. \n+\n+   This is used to ensure that -fexceptions has been specified if the\n+   compiler tries to use any exception-specific functions. */\n \n int\n doing_eh (do_warn)\n@@ -343,9 +439,8 @@ doing_eh (do_warn)\n   return 1;\n }\n \n-/* Given the return address in ADDR, compute the new pc to throw.\n-   This has to work for the current frame of the current function, and\n-   the one above it in the case of throw.  */\n+/* Given a return address in ADDR, determine the address we should use\n+   to find the corresponding EH region. */\n \n rtx\n eh_outer_context (addr)\n@@ -359,17 +454,36 @@ eh_outer_context (addr)\n \t\t\t       addr, MASK_RETURN_ADDR)));\n #endif\n \n-  /* Then subtract out enough to get into the prior region.  If this\n-     is defined, assume we don't need to subtract anything, as it is\n-     already within the region.  */\n+  /* Then subtract out enough to get into the appropriate region.  If\n+     this is defined, assume we don't need to subtract anything as it\n+     is already within the correct region.  */\n #if ! defined (RETURN_ADDR_OFFSET)\n   addr = plus_constant (addr, -1);\n #endif\n \n   return addr;\n }\n \n-/* Output a note marking the start of an exception handling region.  */\n+/* Start a new exception region and push the HANDLER for the region\n+   onto protect_list. All of the regions created with add_partial_entry\n+   will be ended when end_protect_partials () is invoked. */\n+\n+void\n+add_partial_entry (handler)\n+     tree handler;\n+{\n+  expand_eh_region_start ();\n+\n+  /* Make sure the entry is on the correct obstack. */\n+  push_obstacks_nochange ();\n+  resume_temporary_allocation ();\n+  protect_list = tree_cons (NULL_TREE, handler, protect_list);\n+  pop_obstacks ();\n+}\n+\n+/* Output a note marking the start of an exception handling region.\n+   All instructions emitted after this point are considered to be part\n+   of the region until expand_eh_region_end () is invoked. */\n \n void\n expand_eh_region_start ()\n@@ -391,8 +505,14 @@ expand_eh_region_start ()\n     = CODE_LABEL_NUMBER (ehstack.top->entry->exception_handler_label);\n }\n \n-/* Output a note marking the end of an exception handling region.\n-   HANDLER is the the handler for the exception region.  */\n+/* Output a note marking the end of the exception handling region on\n+   the top of ehstack.\n+\n+   HANDLER is either the cleanup for the exception region, or if we're\n+   marking the end of a try block, HANDLER is integer_zero_node.\n+\n+   HANDLER will be transformed to rtl when expand_leftover_cleanups ()\n+   is invoked. */\n \n void\n expand_eh_region_end (handler)\n@@ -410,27 +530,33 @@ expand_eh_region_end (handler)\n   note = emit_note (NULL_PTR, NOTE_INSN_EH_REGION_END);\n   NOTE_BLOCK_NUMBER (note) = CODE_LABEL_NUMBER (entry->exception_handler_label);\n \n+  /* Emit a label marking the end of this exception region. */\n   emit_label (entry->end_label);\n \n   /* Put in something that takes up space, as otherwise the end\n-     address for the EH region could have the exact same address as\n-     the outer region, causing us to miss the fact that resuming\n-     exception handling with this PC value would be inside the outer\n-     region.  */\n+     address for this EH region could have the exact same address as\n+     its outer region. This would cause us to miss the fact that\n+     resuming exception handling with this PC value would be inside\n+     the outer region.  */\n   emit_insn (gen_nop ());\n \n   entry->finalization = handler;\n \n   enqueue_eh_entry (&ehqueue, entry);\n \n-\n #if 0\n-  /* Makebe do this to prevent jumping in and so on...  */\n+  /* Maybe do this to prevent jumping in and so on...  */\n   poplevel (1, 0, 0);\n #endif\n }\n \n-/* Emit a call to __throw and note that we threw something.  */\n+/* Emit a call to __throw and note that we threw something, so we know\n+   we need to generate the necessary code for __throw.  \n+\n+   Before invoking throw, the __eh_pc variable must have been set up\n+   to contain the PC being thrown from. This address is used by\n+   __throw () to determine which exception region (if any) is\n+   responsible for handling the exception. */\n \n static void\n emit_throw ()\n@@ -445,9 +571,10 @@ emit_throw ()\n   emit_barrier ();\n }\n \n-/* An internal throw with an indirect CONTEXT we want to throw from.  */\n+/* An internal throw with an indirect CONTEXT we want to throw from.\n+   CONTEXT evaluates to the context of the throw. */\n \n-void\n+static void\n expand_internal_throw_indirect (context)\n      rtx context;\n {\n@@ -456,8 +583,9 @@ expand_internal_throw_indirect (context)\n   emit_throw ();\n }\n \n-/* An internal throw with a direct CONTEXT we want to throw from.  The\n-   context should be a label.  */\n+/* An internal throw with a direct CONTEXT we want to throw from.\n+   CONTEXT must be a label; its address will be used as the context of\n+   the throw. */\n \n void\n expand_internal_throw (context)\n@@ -467,7 +595,7 @@ expand_internal_throw (context)\n }\n \n /* Called from expand_exception_blocks and expand_end_catch_block to\n-   expand any pending handlers.  */\n+   emit any pending handlers/cleanups queued from expand_eh_region_end (). */\n \n void\n expand_leftover_cleanups ()\n@@ -478,31 +606,46 @@ expand_leftover_cleanups ()\n     {\n       rtx prev;\n \n+      /* A leftover try block. Shouldn't be one here.  */\n+      if (entry->finalization == integer_zero_node)\n+\tabort ();\n+\n+      /* Output the label for the start of the exception handler. */\n       emit_label (entry->exception_handler_label);\n \n+      /* And now generate the insns for the handler. */\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n       prev = get_last_insn ();\n       if (! (prev && GET_CODE (prev) == BARRIER))\n \t{\n \t  /* The below can be optimized away, and we could just fall into the\n \t     next EH handler, if we are certain they are nested.  */\n-\t  /* Code to throw out to outer context, if we fall off end of the\n-\t     handler.  */\n+\t  /* Emit code to throw to the outer context if we fall off\n+\t     the end of the handler.  */\n \t  expand_internal_throw (entry->end_label);\n \t}\n \n-      /* leftover try block, opps.  */\n-      if (entry->finalization == integer_zero_node)\n-\tabort ();\n-\n       free (entry);\n     }\n }\n \n-/* Generate RTL for the start of all the catch blocks.  Used for\n-   arranging for the exception handling code to be placed farther out\n-   of line than normal.  */\n+/* Called at the start of a block of try statements. */\n+void\n+expand_start_try_stmts ()\n+{\n+  if (! doing_eh (1))\n+    return;\n+\n+  expand_eh_region_start ();\n+}\n+\n+/* Generate RTL for the start of a group of catch clauses. \n+\n+   It is responsible for starting a new instruction sequence for the\n+   instructions in the catch block, and expanding the handlers for the\n+   internally-generated exception regions nested within the try block\n+   corresponding to this catch block. */\n \n void\n expand_start_all_catch ()\n@@ -513,11 +656,14 @@ expand_start_all_catch ()\n   if (! doing_eh (1))\n     return;\n \n+  /* End the try block. */\n+  expand_eh_region_end (integer_zero_node);\n+\n   emit_line_note (input_filename, lineno);\n   label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-  /* The label for the exception handling block we will save.  This is\n-     Lresume, in the documention.  */\n+  /* The label for the exception handling block that we will save.\n+     This is Lresume in the documention.  */\n   expand_label (label);\n   \n   /* Put in something that takes up space, as otherwise the end\n@@ -527,10 +673,12 @@ expand_start_all_catch ()\n      region.  */\n   emit_insn (gen_nop ());\n \n+  /* Push the label that points to where normal flow is resumed onto\n+     the top of the label stack. */\n   push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n \n   /* Start a new sequence for all the catch blocks.  We will add this\n-     to the gloabl sequence catch_clauses, when we have completed all\n+     to the global sequence catch_clauses when we have completed all\n      the handlers in this handler-seq.  */\n   start_sequence ();\n \n@@ -539,29 +687,48 @@ expand_start_all_catch ()\n       rtx prev;\n \n       entry = dequeue_eh_entry (&ehqueue);\n+      /* Emit the label for the exception handler for this region, and\n+\t expand the code for the handler. \n+\n+\t Note that a catch region is handled as a side-effect here;\n+\t for a try block, entry->finalization will contain\n+\t integer_zero_node, so no code will be generated in the\n+\t expand_expr call below. But, the label for the handler will\n+\t still be emitted, so any code emitted after this point will\n+\t end up being the handler. */\n       emit_label (entry->exception_handler_label);\n-\n       expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n \n-      /* When we get down to the matching entry, stop.  */\n+      /* When we get down to the matching entry for this try block, stop.  */\n       if (entry->finalization == integer_zero_node)\n-\tbreak;\n+\t{\n+\t  /* Don't forget to free this entry. */\n+\t  free (entry);\n+\t  break;\n+\t}\n \n       prev = get_last_insn ();\n-      if (! (prev && GET_CODE (prev) == BARRIER))\n+      if (prev == NULL || GET_CODE (prev) != BARRIER)\n \t{\n-\t  /* The below can be optimized away, and we could just fall into the\n-\t     next EH handler, if we are certain they are nested.  */\n-\t  /* Code to throw out to outer context, if we fall off end of the\n-\t     handler.  */\n+\t  /* Code to throw out to outer context when we fall off end\n+\t     of the handler. We can't do this here for catch blocks,\n+\t     so it's done in expand_end_all_catch () instead.\n+\n+\t     The below can be optimized away (and we could just fall\n+\t     into the next EH handler) if we are certain they are\n+\t     nested.  */\n+\n \t  expand_internal_throw (entry->end_label);\n \t}\n-\n       free (entry);\n     }\n }\n \n-/* Generate RTL for the end of all the catch blocks.  */\n+/* Finish up the catch block.  At this point all the insns for the\n+   catch clauses have already been generated, so we only have to add\n+   them to the catch_clauses list. We also want to make sure that if\n+   we fall off the end of the catch clauses that we rethrow to the\n+   outer EH region. */\n \n void\n expand_end_all_catch ()\n@@ -572,8 +739,15 @@ expand_end_all_catch ()\n     return;\n \n   /* Code to throw out to outer context, if we fall off end of catch\n-     handlers.  This is rethrow (Lresume, same id, same obj); in the\n-     documentation.  */\n+     handlers.  This is rethrow (Lresume, same id, same obj) in the\n+     documentation. We use Lresume because we know that it will throw\n+     to the correct context.\n+\n+     In other words, if the catch handler doesn't exit or return, we\n+     do a \"throw\" (using the address of Lresume as the point being\n+     thrown from) so that the outer EH region can then try to process\n+     the exception. */\n+\n   expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n \n   /* Now we have the complete catch sequence.  */\n@@ -593,8 +767,8 @@ expand_end_all_catch ()\n   /* Here we fall through into the continuation code.  */\n }\n \n-/* End all the pending exception regions from protect_list that have\n-   been started, but not yet completed.  */\n+/* End all the pending exception regions on protect_list. The handlers\n+   will be emitted when expand_leftover_cleanups () is invoked. */\n \n void\n end_protect_partials ()\n@@ -607,15 +781,24 @@ end_protect_partials ()\n }\n \f\n /* The exception table that we build that is used for looking up and\n-   dispatching exceptions, it's size, and it's maximum size before we\n-   have to extend it.  */\n+   dispatching exceptions, the current number of entries, and its\n+   maximum size before we have to extend it. \n+\n+   The number in eh_table is the code label number of the exception\n+   handler for the region. This is added by add_eh_table_entry () and\n+   used by output_exception_table_entry (). */\n+\n static int *eh_table;\n static int eh_table_size;\n static int eh_table_max_size;\n \n /* Note the need for an exception table entry for region N.  If we\n-   don't need to output an explicit exception table, avoid all the\n-   extra work.  Called during final_scan_insn time.  */\n+   don't need to output an explicit exception table, avoid all of the\n+   extra work.\n+\n+   Called from final_scan_insn when a NOTE_INSN_EH_REGION_BEG is seen.\n+   N is the NOTE_BLOCK_NUMBER of the note, which comes from the code\n+   label number of the exception handler for the region. */\n \n void\n add_eh_table_entry (n)\n@@ -646,9 +829,10 @@ add_eh_table_entry (n)\n #endif\n }\n \n-/* Conditional to test to see if we need to output an exception table.\n-   Note, on some platforms, we don't have to output a table\n-   explicitly.  This routine doesn't mean we don't have one.  */\n+/* Return a non-zero value if we need to output an exception table.\n+\n+   On some platforms, we don't have to output a table explicitly.\n+   This routine doesn't mean we don't have one.  */\n \n int\n exception_table_p ()\n@@ -659,7 +843,11 @@ exception_table_p ()\n   return 0;\n }\n \n-/* Output an entry N for the exception table to the specified FILE.  */\n+/* Output the entry of the exception table corresponding to to the\n+   exception region numbered N to file FILE. \n+\n+   N is the code label number corresponding to the handler of the\n+   region. */\n \n static void\n output_exception_table_entry (file, n)\n@@ -684,7 +872,7 @@ output_exception_table_entry (file, n)\n   putc ('\\n', file);\t\t/* blank line */\n }\n \n-/* Output the exception table if we have one and need one.  */\n+/* Output the exception table if we have and need one. */\n \n void\n output_exception_table ()\n@@ -731,8 +919,12 @@ register_exception_table ()\n \t\t     Pmode);\n }\n \f\n-/* Emit the RTL for the start of the per function unwinder for the\n-   current function.  */\n+/* Emit the RTL for the start of the per-function unwinder for the\n+   current function. See emit_unwinder () for further information.\n+\n+   DOESNT_NEED_UNWINDER is a target-specific macro that determines if\n+   the current function actually needs a per-function unwinder or not.\n+   By default, all functions need one. */\n \n void\n start_eh_unwinder ()\n@@ -745,7 +937,7 @@ start_eh_unwinder ()\n   expand_eh_region_start ();\n }\n \n-/* Emit the RTL for the end of the per function unwinder for the\n+/* Emit insns for the end of the per-function unwinder for the\n    current function.  */\n \n void\n@@ -770,14 +962,19 @@ end_eh_unwinder ()\n   TREE_SIDE_EFFECTS (expr) = 1;\n   start_sequence_for_rtl_expr (expr);\n \n+  /* ret_val will contain the address of the code where the call\n+     to the current function occurred. */\n   ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n \t\t\t\t\t0, hard_frame_pointer_rtx);\n   return_val_rtx = copy_to_reg (ret_val);\n \n+  /* Get the address we need to use to determine what exception\n+     handler should be invoked, and store it in __eh_pc. */\n   return_val_rtx = eh_outer_context (return_val_rtx);\n-\n   emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n   \n+  /* Either set things up so we do a return directly to __throw, or\n+     we return here instead. */\n #ifdef JUMP_TO_THROW\n   emit_move_insn (ret_val, throw_libfunc);\n #else\n@@ -810,30 +1007,77 @@ end_eh_unwinder ()\n   emit_label (end);\n }\n \n-/* Emit the RTL for the per function unwinder for the current\n-   function, if needed.  Called after all the code that needs unwind\n-   protection is output.  */\n+/* If necessary, emit insns for the per function unwinder for the\n+   current function.  Called after all the code that needs unwind\n+   protection is output.  \n+\n+   The unwinder takes care of catching any exceptions that have not\n+   been previously caught within the function, unwinding the stack to\n+   the next frame, and rethrowing using the address of the current\n+   function's caller as the context of the throw.\n+\n+   On some platforms __throw can do this by itself (or with the help\n+   of __unwind_function) so the per-function unwinder is\n+   unnecessary.\n+  \n+   We cannot place the unwinder into the function until after we know\n+   we are done inlining, as we don't want to have more than one\n+   unwinder per non-inlined function.  */\n \n void\n emit_unwinder ()\n {\n-  rtx insns;\n+  rtx insns, insn;\n \n   start_sequence ();\n   start_eh_unwinder ();\n   insns = get_insns ();\n   end_sequence ();\n \n+  /* We place the start of the exception region associated with the\n+     per function unwinder at the top of the function.  */\n   if (insns)\n     emit_insns_after (insns, get_insns ());\n \n+  start_sequence ();\n   end_eh_unwinder ();\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  /* And we place the end of the exception region before the USE and\n+     CLOBBER insns that may come at the end of the function.  */\n+  if (insns == 0)\n+    return;\n+\n+  insn = get_last_insn ();\n+  while (GET_CODE (insn) == NOTE\n+\t || (GET_CODE (insn) == INSN\n+\t     && (GET_CODE (PATTERN (insn)) == USE\n+\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n+    insn = PREV_INSN (insn);\n+\n+  if (GET_CODE (insn) == CODE_LABEL\n+      && GET_CODE (PREV_INSN (insn)) == BARRIER)\n+    {\n+      insn = PREV_INSN (insn);\n+    }\n+  else\n+    {\n+      rtx label = gen_label_rtx ();\n+      emit_label_after (label, insn);\n+      insn = emit_jump_insn_after (gen_jump (label), insn);\n+      insn = emit_barrier_after (insn);\n+    }\n+    \n+  emit_insns_after (insns, insn);\n }\n \n-/* Scan the current insns and build a list of handler labels.  Called\n-   after the last exception handling region is added to the current\n-   function (when the rtl is almost all built for the current\n-   function) and before the jump optimization pass.  */\n+/* Scan the current insns and build a list of handler labels. The\n+   resulting list is placed in the global variable exception_handler_labels.\n+\n+   It is called after the last exception handling region is added to\n+   the current function (when the rtl is almost all built for the\n+   current function) and before the jump optimization pass.  */\n \n void\n find_exception_handler_labels ()\n@@ -849,9 +1093,11 @@ find_exception_handler_labels ()\n   if (! doing_eh (0))\n     return;\n \n-  /* First we generate a handy reference to each label.  */\n+  /* Generate a handy reference to each label.  */\n \n   labels = (rtx *) alloca ((max_labelno - min_labelno) * sizeof (rtx));\n+\n+  /* Eeeeeeew. */\n   labels -= min_labelno;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -862,7 +1108,8 @@ find_exception_handler_labels ()\n \t  labels[CODE_LABEL_NUMBER (insn)] = insn;\n     }\n \n-  /* Then for each start of a region, we add its label to the list.  */\n+  /* For each start of a region, add its label to the list.  */\n+\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE\n@@ -889,10 +1136,11 @@ find_exception_handler_labels ()\n     }\n }\n \n-/* Do some sanity checking on the exception_handler_labels list.  Can\n-   be called after find_exception_handler_labels is called to build\n-   the list of exception handlers for the current function, and before\n-   we finish processing the current function.  */\n+/* Perform sanity checking on the exception_handler_labels list.\n+\n+   Can be called after find_exception_handler_labels is called to\n+   build the list of exception handlers for the current function and\n+   before we finish processing the current function.  */\n \n void\n check_exception_handler_labels ()\n@@ -903,6 +1151,10 @@ check_exception_handler_labels ()\n   if (! doing_eh (0))\n     return;\n \n+  /* Ensure that the CODE_LABEL_NUMBER for the CODE_LABEL entry point\n+     in each handler corresponds to the CODE_LABEL_NUMBER of the\n+     handler. */\n+\n   for (handler = exception_handler_labels;\n        handler;\n        handler = XEXP (handler, 1))\n@@ -926,8 +1178,8 @@ check_exception_handler_labels ()\n \t\t CODE_LABEL_NUMBER (XEXP (handler, 0)));\n     }\n \n-  /* Now go through, and make sure that for each region we have, that we\n-     have the corresponding label.  */\n+  /* Now go through and make sure that for each region there is a\n+     corresponding label.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE\n@@ -951,7 +1203,7 @@ check_exception_handler_labels ()\n \f\n /* This group of functions initializes the exception handling data\n    structures at the start of the compilation, initializes the data\n-   structures at the start of a function, saves and restores the\n+   structures at the start of a function, and saves and restores the\n    exception handling data structures for the start/end of a nested\n    function.  */\n \n@@ -960,6 +1212,8 @@ check_exception_handler_labels ()\n void\n init_eh ()\n {\n+  /* Generate rtl to reference the variable in which the PC of the\n+     current context is saved. */\n   tree type = build_pointer_type (make_node (VOID_TYPE));\n \n   eh_saved_pc = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), type);\n@@ -969,7 +1223,7 @@ init_eh ()\n   eh_saved_pc_rtx = DECL_RTL (eh_saved_pc);\n }\n \n-/* Initialize various EH things.  */\n+/* Initialize the per-function EH information. */\n \n void\n init_eh_for_function ()\n@@ -982,13 +1236,17 @@ init_eh_for_function ()\n   protect_list = NULL_TREE;\n }\n \n-/* Save various EH things for the current function into the save area\n-   denoted by P.  */\n+/* Save some of the per-function EH info into the save area denoted by\n+   P. \n+\n+   This is currently called from save_stmt_status (). */\n \n void\n save_eh_status (p)\n      struct function *p;\n {\n+  assert (p != NULL);\n+\n   p->ehstack = ehstack;\n   p->ehqueue = ehqueue;\n   p->catch_clauses = catch_clauses;\n@@ -999,13 +1257,16 @@ save_eh_status (p)\n   init_eh ();\n }\n \n-/* Restore various EH things for the current function from the save\n-   area denoted by P.  */\n+/* Restore the per-function EH info saved into the area denoted by P.  \n+\n+   This is currently called from restore_stmt_status. */\n \n void\n restore_eh_status (p)\n      struct function *p;\n {\n+  assert (p != NULL);\n+\n   protect_list = p->protect_list;\n   caught_return_label_stack = p->caught_return_label_stack;\n   false_label_stack = p->false_label_stack;\n@@ -1024,24 +1285,36 @@ static int\n can_throw (insn)\n      rtx insn;\n {\n-  /* The only things that can possibly throw are calls.  */\n+  /* Calls can always potentially throw exceptions. */\n   if (GET_CODE (insn) == CALL_INSN)\n     return 1;\n \n #ifdef ASYNCH_EXCEPTIONS\n   /* If we wanted asynchronous exceptions, then everything but NOTEs\n-     and CODE_LABELs could throw.  */\n+     and CODE_LABELs could throw. */\n   if (GET_CODE (insn) != NOTE && GET_CODE (insn) != CODE_LABEL)\n     return 1;\n #endif\n \n   return 0;\n }\n \n-/* Scan a region, looking for a matching end, and decide if the region\n-   can be removed.  INSN is the start of the region, N is the region\n-   number, and DELETE_OUTER is to note if anything in this region can\n-   throw.  */\n+/* Scan a exception region looking for the matching end and then\n+   remove it if possible. INSN is the start of the region, N is the\n+   region number, and DELETE_OUTER is to note if anything in this\n+   region can throw.\n+\n+   Regions are removed if they cannot possibly catch an exception.\n+   This is determined by invoking can_throw () on each insn within the\n+   region; if can_throw returns true for any of the instructions, the\n+   region can catch an exception, since there is an insn within the\n+   region that is capable of throwing an exception.\n+\n+   Returns the NOTE_INSN_EH_REGION_END corresponding to this region, or\n+   calls abort () if it can't find one.\n+\n+   Can abort if INSN is not a NOTE_INSN_EH_REGION_BEGIN, or if N doesn't\n+   correspond to the region number, or if DELETE_OUTER is NULL. */\n \n static rtx\n scan_region (insn, n, delete_outer)\n@@ -1054,6 +1327,12 @@ scan_region (insn, n, delete_outer)\n   /* Assume we can delete the region.  */\n   int delete = 1;\n \n+  assert (insn != NULL_RTX\n+\t  && GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n+\t  && NOTE_BLOCK_NUMBER (insn) == n\n+\t  && delete_outer != NULL);\n+\n   insn = NEXT_INSN (insn);\n \n   /* Look for the matching end.  */\n@@ -1080,7 +1359,7 @@ scan_region (insn, n, delete_outer)\n   if (NOTE_BLOCK_NUMBER (insn) != n)\n     abort ();\n \n-  /* If anything can throw, we can throw.  */\n+  /* If anything in this exception region can throw, we can throw.  */\n   if (! delete)\n     *delete_outer = 0;\n   else\n@@ -1129,21 +1408,27 @@ scan_region (insn, n, delete_outer)\n /* Perform various interesting optimizations for exception handling\n    code.\n \n-   We find empty exception regions, and remove them.  The jump\n-   optimization code will remove the handler if nothing else uses it.  */\n+   We look for empty exception regions and make them go (away). The\n+   jump optimization code will remove the handler if nothing else uses\n+   it. */\n \n void\n exception_optimize ()\n {\n   rtx insn, regions = NULL_RTX;\n   int n;\n \n-  /* First remove empty regions.  */\n+  /* Remove empty regions.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n \t{\n+\t  /* Since scan_region () will return the NOTE_INSN_EH_REGION_END\n+\t     insn, we will indirectly skip through all the insns\n+\t     inbetween. We are also guaranteed that the value of insn\n+\t     returned will be valid, as otherwise scan_region () won't\n+\t     return. */\n \t  insn = scan_region (insn, NOTE_BLOCK_NUMBER (insn), &n);\n \t}\n     }"}]}