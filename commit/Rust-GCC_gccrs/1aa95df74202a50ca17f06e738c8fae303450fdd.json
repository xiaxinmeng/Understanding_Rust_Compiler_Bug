{"sha": "1aa95df74202a50ca17f06e738c8fae303450fdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFhOTVkZjc0MjAyYTUwY2ExN2YwNmU3MzhjOGZhZTMwMzQ1MGZkZA==", "commit": {"author": {"name": "Ond\u0159ej B\u00edlka", "email": "neleai@seznam.cz", "date": "2013-07-21T18:18:04Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2013-07-21T18:18:04Z"}, "message": "Fix typos.\n\nFrom-SVN: r201109", "tree": {"sha": "4cf7616fe25f46e4466b597faf6d52056d8cb397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cf7616fe25f46e4466b597faf6d52056d8cb397"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1aa95df74202a50ca17f06e738c8fae303450fdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa95df74202a50ca17f06e738c8fae303450fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa95df74202a50ca17f06e738c8fae303450fdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa95df74202a50ca17f06e738c8fae303450fdd/comments", "author": {"login": "neleai", "id": 48067, "node_id": "MDQ6VXNlcjQ4MDY3", "avatar_url": "https://avatars.githubusercontent.com/u/48067?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neleai", "html_url": "https://github.com/neleai", "followers_url": "https://api.github.com/users/neleai/followers", "following_url": "https://api.github.com/users/neleai/following{/other_user}", "gists_url": "https://api.github.com/users/neleai/gists{/gist_id}", "starred_url": "https://api.github.com/users/neleai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neleai/subscriptions", "organizations_url": "https://api.github.com/users/neleai/orgs", "repos_url": "https://api.github.com/users/neleai/repos", "events_url": "https://api.github.com/users/neleai/events{/privacy}", "received_events_url": "https://api.github.com/users/neleai/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0d18c6c7d528e3acfb2506d831191c6e5c82b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d18c6c7d528e3acfb2506d831191c6e5c82b68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d18c6c7d528e3acfb2506d831191c6e5c82b68"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "fa0260175d8ae738b934c9853578ab2cd25471fd", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -1632,7 +1632,7 @@ unroll_loop_stupid (struct loop *loop)\n \t for a loop to be really simple.  We could update the counts, but the\n \t problem is that we are unable to decide which exit will be taken\n \t (not really true in case the number of iterations is constant,\n-\t but noone will do anything with this information, so we do not\n+\t but no one will do anything with this information, so we do not\n \t worry about it).  */\n       desc->simple_p = false;\n     }"}, {"sha": "5cb06453a0367f2692fb165b9ce0ed9fb1fafcc5", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -4203,7 +4203,7 @@ need_for_call_save_p (int regno)\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])));\n }\n \n-/* Global registers occuring in the current EBB.  */\n+/* Global registers occurring in the current EBB.  */\n static bitmap_head ebb_global_regs;\n \n /* Return true if we need a split for hard register REGNO or pseudo"}, {"sha": "a962e9c50032df189a2b7d378dbe2d31ddc03d01", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -2303,7 +2303,7 @@ produce_symtab (struct output_block *ob)\n \n   /* Write the symbol table.\n      First write everything defined and then all declarations.\n-     This is neccesary to handle cases where we have duplicated symbols.  */\n+     This is necessary to handle cases where we have duplicated symbols.  */\n   for (lsei = lsei_start (encoder);\n        !lsei_end_p (lsei); lsei_next (&lsei))\n     {"}, {"sha": "d6559750f92250fd8b4c9ab31a0442e2651e9e9e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -1,3 +1,7 @@\n+2013-07-21   Ond\u00c5\u0099ej B\u00c3\u00adlka  <neleai@seznam.cz>\n+\n+\t* lto-partition.c: Fix typos.\n+\n 2013-06-20  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-partition.c (lto_balanced_map): Fix -fno-toplevel-reorder"}, {"sha": "63e6ab969014839f6b6208eba784cd65467385b3", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -852,7 +852,7 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n    of the same name in partition ENCODER (or in whole compilation unit if\n    ENCODER is NULL) and if so, mangle the statics.  Always mangle all\n    conflicting statics, so we reduce changes of silently miscompiling\n-   asm statemnets refering to them by symbol name.  */\n+   asm statemnets referring to them by symbol name.  */\n \n static void\n rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n@@ -902,7 +902,7 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node node)\n \t    || lto_symtab_encoder_lookup (encoder, s) != LCC_NOT_FOUND))\n       {\n         if (privatize_symbol_name (s))\n-\t  /* Re-start from beggining since we do not know how many symbols changed a name.  */\n+\t  /* Re-start from beginning since we do not know how many symbols changed a name.  */\n \t  s = symtab_node_for_asm (name);\n         else s = s->symbol.next_sharing_asm_name;\n       }"}, {"sha": "e07c21a4e6c15b21198c0371ec1d9e1b0045c13b", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -4909,7 +4909,7 @@ expand_omp_for (struct omp_region *region)\n       FALLTHRU_EDGE (region->cont)->flags &= ~EDGE_ABNORMAL;\n     }\n   else\n-    /* If there isnt a continue then this is a degerate case where\n+    /* If there isn't a continue then this is a degerate case where\n        the introduction of abnormal edges during lowering will prevent\n        original loops from being detected.  Fix that up.  */\n     loops_state_set (LOOPS_NEED_FIXUP);"}, {"sha": "d32072be7a58321de0e2d35ce7e4b9370ab51691", "filename": "gcc/read-md.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -881,7 +881,7 @@ traverse_enum_types (htab_trav callback, void *info)\n /* Process an \"include\" directive, starting with the optional space\n    after the \"include\".  Read in the file and use HANDLE_DIRECTIVE\n    to process each unknown directive.  LINENO is the line number on\n-   which the \"include\" occured.  */\n+   which the \"include\" occurred.  */\n \n static void\n handle_include (int lineno, directive_handler_t handle_directive)\n@@ -1027,7 +1027,7 @@ parse_include (const char *arg)\n }\n \n /* The main routine for reading .md files.  Try to process all the .md\n-   files specified on the command line and return true if no error occured.\n+   files specified on the command line and return true if no error occurred.\n \n    ARGC and ARGV are the arguments to main.\n "}, {"sha": "6a607ba2a5aff6671f0afcdaba74b68ce987989d", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -1651,7 +1651,7 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n \t  /* If caller provided constraints pointer, look up\n-\t     the maching constraint.  Otherwise, our caller should have\n+\t     the matching constraint.  Otherwise, our caller should have\n \t     given us the proper matching constraint, but we can't\n \t     actually fail the check if they didn't.  Indicate that\n \t     results are inconclusive.  */"}, {"sha": "353090157dd39580d885d4fc1b50e5dbbd8870ad", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -4574,7 +4574,7 @@ attempt_change (struct mem_inc_info *mii, rtx new_addr)\n   rtx mem = *mii->mem_loc;\n   rtx new_mem;\n \n-  /* Jump thru a lot of hoops to keep the attributes up to date.  We\n+  /* Jump through a lot of hoops to keep the attributes up to date.  We\n      do not want to call one of the change address variants that take\n      an offset even though we know the offset in many cases.  These\n      assume you are changing where the address is pointing by the"}, {"sha": "d15881b609a73ab88bc8f65e5f1f2dd2eeea34da", "filename": "gcc/symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -874,7 +874,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \n   /* To determine visibility of the target, we follow ELF semantic of aliases.\n      Here alias is an alternative assembler name of a given definition. Its\n-     availablity prevails the availablity of its target (i.e. static alias of\n+     availability prevails the availability of its target (i.e. static alias of\n      weak definition is available.\n \n      Weakref is a different animal (and not part of ELF per se). It is just"}, {"sha": "142023c2504675c5cf7a566943e9097cefb0adda", "filename": "gcc/tlink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1aa95df74202a50ca17f06e738c8fae303450fdd/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=1aa95df74202a50ca17f06e738c8fae303450fdd", "patch": "@@ -768,7 +768,7 @@ scan_linker_output (const char *fname)\n \t     constructor or destructor, there can be several mangled names\n \t     that match it, so choose or unchoose all of them.  If some are\n \t     chosen and some not, leave the later ones that don't match\n-\t     alone for now; either this will cause the link to suceed, or\n+\t     alone for now; either this will cause the link to succeed, or\n \t     on the next attempt we will switch all of them the other way\n \t     and that will cause it to succeed.  */\n \t  int chosen = 0;"}]}