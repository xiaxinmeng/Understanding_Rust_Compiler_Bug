{"sha": "b8beb4d13e5c51a50507cb2be345773fa162fce7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhiZWI0ZDEzZTVjNTFhNTA1MDdjYjJiZTM0NTc3M2ZhMTYyZmNlNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-03-23T14:49:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-03-23T14:49:20Z"}, "message": "Makefile.in (IPA_TYPE_ESCAPE_H): Remove.\n\n2011-03-23  Richard Guenther  <rguenther@suse.de>\n\n\t* Makefile.in (IPA_TYPE_ESCAPE_H): Remove.\n\t(OBJS-archive): Remove ipa-struct-reorg.o and ipa-type-escape.o.\n\t(tree-ssa-alias.o): Do not depend on IPA_TYPE_ESCAPE_H.\n\t(alias.o): Likewise.\n\t(ipa-type-escape.o): Remove.\n\t(ipa-struct-reorg.o): Likewise.\n\t(GTFILES): Remove ipa-struct-reorg.c.\n\t* alias.c: Do not include ipa-type-escape.h.\n\t* tree-ssa-alias.c: Likewise.\n\t* common.opt (fipa-struct-reorg): Preserve for backward compatibility.\n\t* opts.c (finish_options): Do not reset flag_ipa_struct_reorg.\n\t* passes.c (init_optimization_passes): Remove ipa-struct-reorg\n\tand ipa-type-escape passes.\n\t* tree-pass.h (pass_ipa_type_escape): Remove.\n\t(pass_ipa_struct_reorg): Likewise.\n\t* ipa-struct-reorg.h: Remove.\n\t* ipa-struct-reorg.c: Likewise.\n\t* ipa-type-escape.h: Likewise.\n\t* ipa-type-escape.c: Likewise.\n\t* doc/invoke.texi (-fipa-struct-reorg): Remove.\n\t(--param struct-reorg-cold-struct-ratio): Likewise.\n\t* params.def (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO): Likewise.\n\t* params.h (STRUCT_REORG_COLD_STRUCT_RATIO): Likewise.\n\t* timevar.def (TV_IPA_TYPE_ESCAPE): Likewise.\n\n\t* gcc.dg/struct: Remove directory and contents.\n\nFrom-SVN: r171352", "tree": {"sha": "27710f16ee41da3dc8f723aab9670e1f23070da5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27710f16ee41da3dc8f723aab9670e1f23070da5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8beb4d13e5c51a50507cb2be345773fa162fce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8beb4d13e5c51a50507cb2be345773fa162fce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8beb4d13e5c51a50507cb2be345773fa162fce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8beb4d13e5c51a50507cb2be345773fa162fce7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "40fb503382f36106a942801ad3563821011f4609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fb503382f36106a942801ad3563821011f4609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fb503382f36106a942801ad3563821011f4609"}], "stats": {"total": 7618, "additions": 37, "deletions": 7581}, "files": [{"sha": "1748d61cbfb8ac2da96a30a265a8ca7218a48d23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -1,3 +1,30 @@\n+2011-03-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Makefile.in (IPA_TYPE_ESCAPE_H): Remove.\n+\t(OBJS-archive): Remove ipa-struct-reorg.o and ipa-type-escape.o.\n+\t(tree-ssa-alias.o): Do not depend on IPA_TYPE_ESCAPE_H.\n+\t(alias.o): Likewise.\n+\t(ipa-type-escape.o): Remove.\n+\t(ipa-struct-reorg.o): Likewise.\n+\t(GTFILES): Remove ipa-struct-reorg.c.\n+\t* alias.c: Do not include ipa-type-escape.h.\n+\t* tree-ssa-alias.c: Likewise.\n+\t* common.opt (fipa-struct-reorg): Preserve for backward compatibility.\n+\t* opts.c (finish_options): Do not reset flag_ipa_struct_reorg.\n+\t* passes.c (init_optimization_passes): Remove ipa-struct-reorg\n+\tand ipa-type-escape passes.\n+\t* tree-pass.h (pass_ipa_type_escape): Remove.\n+\t(pass_ipa_struct_reorg): Likewise.\n+\t* ipa-struct-reorg.h: Remove.\n+\t* ipa-struct-reorg.c: Likewise.\n+\t* ipa-type-escape.h: Likewise.\n+\t* ipa-type-escape.c: Likewise.\n+\t* doc/invoke.texi (-fipa-struct-reorg): Remove.\n+\t(--param struct-reorg-cold-struct-ratio): Likewise.\n+\t* params.def (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO): Likewise.\n+\t* params.h (STRUCT_REORG_COLD_STRUCT_RATIO): Likewise.\n+\t* timevar.def (TV_IPA_TYPE_ESCAPE): Likewise.\n+\n 2011-03-23  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/2084.md: Enable all insn reservations also for z9_ec"}, {"sha": "fc0948225cf09b08249136d3fa1b604b4499fe81", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -921,7 +921,6 @@ CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h double-int.h \\\n \t$(BITMAP_H) sbitmap.h\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n-IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)\n CGRAPH_H = cgraph.h $(VEC_H) $(TREE_H) $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n \tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H)\n DF_H = df.h $(BITMAP_H) $(REGSET_H) sbitmap.h $(BASIC_BLOCK_H) \\\n@@ -1467,8 +1466,6 @@ OBJS-archive = \\\n \tipa-pure-const.o \\\n \tipa-reference.o \\\n \tipa-ref.o \\\n-\tipa-struct-reorg.o \\\n-\tipa-type-escape.o \\\n \tipa-utils.o \\\n \tipa.o \\\n \tmatrix-reorg.o \\\n@@ -2612,7 +2609,7 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\\n    $(TREE_DUMP_H) $(TREE_PASS_H) $(PARAMS_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(GIMPLE_H) $(VEC_H) $(TARGET_H) \\\n-   $(IPA_TYPE_ESCAPE_H) vecprim.h pointer-set.h alloc-pool.h \\\n+   vecprim.h pointer-set.h alloc-pool.h \\\n    tree-pretty-print.h\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n@@ -3034,19 +3031,6 @@ ipa-pure-const.o : ipa-pure-const.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) $(TIMEVAR_H) \\\n    $(DIAGNOSTIC_H) $(CFGLOOP_H) $(SCEV_H) $(LTO_STREAMER_H) \\\n    gimple-pretty-print.h\n-ipa-type-escape.o : ipa-type-escape.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n-   pointer-set.h $(GGC_H) $(IPA_TYPE_ESCAPE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \\\n-   $(GIMPLE_H) $(CGRAPH_H) output.h $(FLAGS_H) $(TREE_PASS_H) \\\n-   $(TIMEVAR_H) $(DIAGNOSTIC_H) $(FUNCTION_H) tree-pretty-print.h\n-ipa-struct-reorg.o: ipa-struct-reorg.c ipa-struct-reorg.h $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(GIMPLE_H) tree-inline.h \\\n-   $(TREE_FLOW_H) langhooks.h pointer-set.h $(HASHTAB_H) $(DIAGNOSTIC_CORE_H) \\\n-   $(FLAGS_H) debug.h $(TARGET_H) $(CGRAPH_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n-   $(PARAMS_H) $(FIBHEAP_H) intl.h $(FUNCTION_H) $(BASIC_BLOCK_H) tree-iterator.h \\\n-   $(TREE_PASS_H) $(OPTS_H) $(IPA_TYPE_ESCAPE_H) $(TREE_DUMP_H) \\\n-   $(GIMPLE_H) tree-pretty-print.h gimple-pretty-print.h\n-\n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) toplev.h $(DIAGNOSTIC_CORE_H) $(GGC_H) langhooks.h $(COVERAGE_H) \\\n@@ -3303,7 +3287,7 @@ alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) $(DIAGNOSTIC_CORE_H) output.h \\\n    $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) $(FUNCTION_H) cselib.h $(TREE_H) $(TM_P_H) \\\n    langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \\\n-   $(SPLAY_TREE_H) $(IPA_TYPE_ESCAPE_H) $(DF_H) $(TREE_PASS_H) \\\n+   $(SPLAY_TREE_H) $(DF_H) $(TREE_PASS_H) \\\n    tree-ssa-alias.h pointer-set.h $(TREE_FLOW_H)\n stack-ptr-mod.o : stack-ptr-mod.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) $(TREE_PASS_H) \\\n@@ -3715,7 +3699,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \\\n-  $(srcdir)/dbxout.c $(srcdir)/ipa-struct-reorg.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n+  $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/dojump.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \\"}, {"sha": "c2a2c9d865540678f909eeaf5a08ab826f8cb5e3", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n-#include \"ipa-type-escape.h\"\n #include \"df.h\"\n #include \"tree-ssa-alias.h\"\n #include \"pointer-set.h\""}, {"sha": "88ae10137199d12d959caee8cd21045a816055ea", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -1249,9 +1249,8 @@ Perform matrix layout flattening and transposing based\n on profiling information.\n \n fipa-struct-reorg\n-Common Report Var(flag_ipa_struct_reorg)\n-Perform structure layout optimizations based\n-on profiling information.\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n fira-algorithm=\n Common Joined RejectNegative Enum(ira_algorithm) Var(flag_ira_algorithm) Init(IRA_ALGORITHM_CB)"}, {"sha": "6bb4403a18fc92ea3788492e2fbd8df6f131019a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -351,7 +351,7 @@ Objective-C and Objective-C++ Dialects}.\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n -finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg @gol\n -fipa-pta -fipa-profile -fipa-pure-const -fipa-reference @gol\n--fipa-struct-reorg -fira-algorithm=@var{algorithm} @gol\n+-fira-algorithm=@var{algorithm} @gol\n -fira-region=@var{region} @gol\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n@@ -6766,19 +6766,6 @@ Discover which static variables do not escape cannot escape the\n compilation unit.\n Enabled by default at @option{-O} and higher.\n \n-@item -fipa-struct-reorg\n-@opindex fipa-struct-reorg\n-Perform structure reorganization optimization, that change C-like structures\n-layout in order to better utilize spatial locality.  This transformation is\n-affective for programs containing arrays of structures.  Available in two\n-compilation modes: profile-based (enabled with @option{-fprofile-generate})\n-or static (which uses built-in heuristics).  It works only in whole program\n-mode, so it requires @option{-fwhole-program} to be\n-enabled.  Structures considered @samp{cold} by this transformation are not\n-affected (see @option{--param struct-reorg-cold-struct-ratio=@var{value}}).\n-\n-With this flag, the program debug info reflects a new structure layout.\n-\n @item -fipa-pta\n @opindex fipa-pta\n Perform interprocedural pointer analysis and interprocedural modification\n@@ -8216,15 +8203,6 @@ In each case, the @var{value} is an integer.  The allowable choices for\n @var{name} are given in the following table:\n \n @table @gcctabopt\n-@item struct-reorg-cold-struct-ratio\n-The threshold ratio (as a percentage) between a structure frequency\n-and the frequency of the hottest structure in the program.  This parameter\n-is used by struct-reorg optimization enabled by @option{-fipa-struct-reorg}.\n-We say that if the ratio of a structure frequency, calculated by profiling,\n-to the hottest structure frequency in the program is less than this\n-parameter, then structure reorganization is not applied to this structure.\n-The default is 10.\n-\n @item predictable-branch-outcome\n When branch is predicted to be taken with probability lower than this threshold\n (in percent), then it is considered well predictable. The default is 10."}, {"sha": "7ab321eee47e26e81087fd385f6b7effdc7d257a", "filename": "gcc/ipa-struct-reorg.c", "status": "removed", "additions": 0, "deletions": 4064, "changes": 4064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=40fb503382f36106a942801ad3563821011f4609"}, {"sha": "e6df1cf9052ab314d163dc72739beeadb78db63f", "filename": "gcc/ipa-struct-reorg.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-struct-reorg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-struct-reorg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.h?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,112 +0,0 @@\n-/* Struct-reorg optimization.\n-   Copyright (C) 2002, 2003-2007, 2008, 2009 Free Software Foundation, Inc.\n-   Contributed by Olga Golovanevsky <olga@il.ibm.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3 of the License, or\n-(at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef IPA_STRUCT_REORG_H\n-#define IPA_STRUCT_REORG_H\n-\n-/* This file contains data structures and interfaces required\n-   for struct-reorg optimizations.  */\n-\n-/* An access site of the structure field.\n-   We consider an access to be of the following form:\n-\n-   D.2166_21 = i.6_20 * 8;\n-   D.2167_22 = (struct str_t *) D.2166_21;\n-   D.2168_24 = D.2167_22 + p.5_23;\n-   D.2169_25 = D.2168_24->b;\n-*/\n-\n-struct field_access_site\n-{\n-  /* Statement in which the access site occurs.  */\n-  gimple stmt;           /* D.2169_25 = D.2168_24->b;  */\n-  tree comp_ref;         /* D.2168_24->b  */\n-  tree field_decl;       /* b */\n-  tree ref;              /* D.2168_24  */\n-  tree num;              /* i.6_20  */\n-  tree offset;           /* D2167_22  */\n-  tree base;             /* p.5_23  */\n-  gimple ref_def_stmt;   /* D.2168_24 = D.2167_22 + p.5_23;  */\n-  gimple cast_stmt;      /* D.2167_22 = (struct str_t *) D.2166_21;\n-                            This statement is not always present.  */\n-};\n-\n-/* A non-field structure access site.  */\n-struct access_site\n-{\n-  /* A statement in which the access site occurs.  */\n-  gimple stmt;\n-  /* A list of structure variables in the access site.  */\n-  VEC (tree, heap) *vars;\n-};\n-\n-/* A field of the structure.  */\n-struct field_entry\n-{\n-  /* A field index.  */\n-  int index;\n-  /* Number of times the field is accessed (according to profiling).  */\n-  gcov_type count;\n-  tree decl;\n-  /* A type of a new structure this field belongs to.  */\n-  tree field_mapping;\n-  htab_t acc_sites;\n-};\n-\n-/* This structure represents a result of the structure peeling.\n-   The original structure is decomposed into substructures, or clusters.  */\n-struct field_cluster\n-{\n-  /* A bitmap of field indices. The set bit indicates that the field\n-     corresponding to it is a part of this cluster.  */\n-  sbitmap fields_in_cluster;\n-  struct field_cluster *sibling;\n-};\n-\n-/* An information about an individual structure type (RECORD_TYPE) required\n-   by struct-reorg optimizations to perform a transformation.  */\n-struct data_structure\n-{\n-\n-  /* A main variant of the structure type.  */\n-  tree decl;\n-\n-  /* Number of fields in the structure.  */\n-  int num_fields;\n-\n-  /* A structure access count collected through profiling.  */\n-  gcov_type count;\n-\n-  /* An array of the structure fields, indexed by field ID.  */\n-  struct field_entry *fields;\n-\n-  /* Non-field accesses of the structure.  */\n-  htab_t accs;\n-\n-  /* A data structure representing a reorganization decision.  */\n-  struct field_cluster *struct_clustering;\n-\n-  /* New types to replace the original structure type.  */\n-  VEC(tree, heap) *new_types;\n-};\n-\n-typedef struct data_structure * d_str;\n-\n-#endif /* IPA_STRUCT_REORG_H */"}, {"sha": "1ecf68ef2a74cc2854dde1bf2a42bc3ad1f58395", "filename": "gcc/ipa-type-escape.c", "status": "removed", "additions": 0, "deletions": 2126, "changes": 2126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,2126 +0,0 @@\n-/* Escape analysis for types.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* This pass determines which types in the program contain only\n-   instances that are completely encapsulated by the compilation unit.\n-   Those types that are encapsulated must also pass the further\n-   requirement that there be no bad operations on any instances of\n-   those types.\n-\n-   A great deal of freedom in compilation is allowed for the instances\n-   of those types that pass these conditions.\n-*/\n-\n-/* The code in this module is called by the ipa pass manager. It\n-   should be one of the later passes since its information is used by\n-   the rest of the compilation. */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-inline.h\"\n-#include \"tree-pass.h\"\n-#include \"langhooks.h\"\n-#include \"pointer-set.h\"\n-#include \"splay-tree.h\"\n-#include \"ggc.h\"\n-#include \"ipa-utils.h\"\n-#include \"ipa-type-escape.h\"\n-#include \"gimple.h\"\n-#include \"cgraph.h\"\n-#include \"output.h\"\n-#include \"flags.h\"\n-#include \"timevar.h\"\n-#include \"diagnostic.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"langhooks.h\"\n-\n-/* Some of the aliasing is called very early, before this phase is\n-   called.  To assure that this is not a problem, we keep track of if\n-   this phase has been run.  */\n-static bool initialized = false;\n-\n-/* Scratch bitmap for avoiding work. */\n-static bitmap been_there_done_that;\n-static bitmap bitmap_tmp;\n-\n-/* There are two levels of escape that types can undergo.\n-\n-   EXPOSED_PARAMETER - some instance of the variable is\n-   passed by value into an externally visible function or some\n-   instance of the variable is passed out of an externally visible\n-   function as a return value.  In this case any of the fields of the\n-   variable that are pointer types end up having their types marked as\n-   FULL_ESCAPE.\n-\n-   FULL_ESCAPE - when bad things happen to good types. One of the\n-   following things happens to the type: (a) either an instance of the\n-   variable has its address passed to an externally visible function,\n-   (b) the address is taken and some bad cast happens to the address\n-   or (c) explicit arithmetic is done to the address.\n-*/\n-\n-enum escape_t\n-{\n-  EXPOSED_PARAMETER,\n-  FULL_ESCAPE\n-};\n-\n-/* The following two bit vectors global_types_* correspond to\n-   previous cases above.  During the analysis phase, a bit is set in\n-   one of these vectors if an operation of the offending class is\n-   discovered to happen on the associated type.  */\n-\n-static bitmap global_types_exposed_parameter;\n-static bitmap global_types_full_escape;\n-\n-/* All of the types seen in this compilation unit. */\n-static bitmap global_types_seen;\n-/* Reverse map to take a canon uid and map it to a canon type.  Uid's\n-   are never manipulated unless they are associated with a canon\n-   type.  */\n-static splay_tree uid_to_canon_type;\n-\n-/* Internal structure of type mapping code.  This maps a canon type\n-   name to its canon type.  */\n-static splay_tree all_canon_types;\n-\n-/* Map from type clones to the single canon type.  */\n-static splay_tree type_to_canon_type;\n-\n-/* A splay tree of bitmaps.  An element X in the splay tree has a bit\n-   set in its bitmap at TYPE_UID (TYPE_MAIN_VARIANT (Y)) if there was\n-   an operation in the program of the form \"&X.Y\".  */\n-static splay_tree uid_to_addressof_down_map;\n-\n-/* A splay tree of bitmaps.  An element Y in the splay tree has a bit\n-   set in its bitmap at TYPE_UID (TYPE_MAIN_VARIANT (X)) if there was\n-   an operation in the program of the form \"&X.Y\".  */\n-static splay_tree uid_to_addressof_up_map;\n-\n-/* Tree to hold the subtype maps used to mark subtypes of escaped\n-   types.  */\n-static splay_tree uid_to_subtype_map;\n-\n-/* Records tree nodes seen in cgraph_create_edges.  Simply using\n-   walk_tree_without_duplicates doesn't guarantee each node is visited\n-   once because it gets a new htab upon each recursive call from\n-   scan_for_refs.  */\n-static struct pointer_set_t *visited_nodes;\n-\n-/* Visited stmts by walk_use_def_chains function because it's called\n-   recursively.  */\n-static struct pointer_set_t *visited_stmts;\n-\n-static bitmap_obstack ipa_obstack;\n-\n-/* Static functions from this file that are used\n-   before being defined.  */\n-static unsigned int look_for_casts (tree);\n-static bool is_cast_from_non_pointer (tree, gimple, void *);\n-\n-/* Get the name of TYPE or return the string \"<UNNAMED>\".  */\n-static const char*\n-get_name_of_type (tree type)\n-{\n-  tree name = TYPE_NAME (type);\n-\n-  if (!name)\n-    /* Unnamed type, do what you like here.  */\n-    return \"<UNNAMED>\";\n-\n-  /* It will be a TYPE_DECL in the case of a typedef, otherwise, an\n-     identifier_node */\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    {\n-      /*  Each DECL has a DECL_NAME field which contains an\n-\t  IDENTIFIER_NODE.  (Some decls, most often labels, may have\n-\t  zero as the DECL_NAME).  */\n-      if (DECL_NAME (name))\n-\treturn IDENTIFIER_POINTER (DECL_NAME (name));\n-      else\n-\t/* Unnamed type, do what you like here.  */\n-\treturn \"<UNNAMED>\";\n-    }\n-  else if (TREE_CODE (name) == IDENTIFIER_NODE)\n-    return IDENTIFIER_POINTER (name);\n-  else\n-    return \"<UNNAMED>\";\n-}\n-\n-struct type_brand_s\n-{\n-  const char* name;\n-  int seq;\n-};\n-\n-/* Splay tree comparison function on type_brand_s structures.  */\n-\n-static int\n-compare_type_brand (splay_tree_key sk1, splay_tree_key sk2)\n-{\n-  struct type_brand_s * k1 = (struct type_brand_s *) sk1;\n-  struct type_brand_s * k2 = (struct type_brand_s *) sk2;\n-\n-  int value = strcmp(k1->name, k2->name);\n-  if (value == 0)\n-    return k2->seq - k1->seq;\n-  else\n-    return value;\n-}\n-\n-/* All of the \"unique_type\" code is a hack to get around the sleazy\n-   implementation used to compile more than file.  Currently gcc does\n-   not get rid of multiple instances of the same type that have been\n-   collected from different compilation units.  */\n-/* This is a trivial algorithm for removing duplicate types.  This\n-   would not work for any language that used structural equivalence as\n-   the basis of its type system.  */\n-/* Return TYPE if no type compatible with TYPE has been seen so far,\n-   otherwise return a type compatible with TYPE that has already been\n-   processed.  */\n-\n-static tree\n-discover_unique_type (tree type)\n-{\n-  struct type_brand_s * brand = XNEW (struct type_brand_s);\n-  int i = 0;\n-  splay_tree_node result;\n-\n-  brand->name = get_name_of_type (type);\n-\n-  while (1)\n-    {\n-      brand->seq = i++;\n-      result = splay_tree_lookup (all_canon_types, (splay_tree_key) brand);\n-\n-      if (result)\n-\t{\n-\t  /* Create an alias since this is just the same as\n-\t     other_type.  */\n-\t  tree other_type = (tree) result->value;\n-\t  if (types_compatible_p (type, other_type))\n-\t    {\n-\t      free (brand);\n-\t      /* Insert this new type as an alias for other_type.  */\n-\t      splay_tree_insert (type_to_canon_type,\n-\t\t\t\t (splay_tree_key) type,\n-\t\t\t\t (splay_tree_value) other_type);\n-\t      return other_type;\n-\t    }\n-\t  /* Not compatible, look for next instance with same name.  */\n-\t}\n-      else\n-\t{\n-\t  /* No more instances, create new one since this is the first\n-\t     time we saw this type.  */\n-\t  brand->seq = i++;\n-\t  /* Insert the new brand.  */\n-\t  splay_tree_insert (all_canon_types,\n-\t\t\t     (splay_tree_key) brand,\n-\t\t\t     (splay_tree_value) type);\n-\n-\t  /* Insert this new type as an alias for itself.  */\n-\t  splay_tree_insert (type_to_canon_type,\n-\t\t\t     (splay_tree_key) type,\n-\t\t\t     (splay_tree_value) type);\n-\n-\t  /* Insert the uid for reverse lookup; */\n-\t  splay_tree_insert (uid_to_canon_type,\n-\t\t\t     (splay_tree_key) TYPE_UID (type),\n-\t\t\t     (splay_tree_value) type);\n-\n-\t  bitmap_set_bit (global_types_seen, TYPE_UID (type));\n-\t  return type;\n-\t}\n-    }\n-}\n-\n-/* Return true if TYPE is one of the type classes that we are willing\n-   to analyze.  This skips the goofy types like arrays of pointers to\n-   methods. */\n-static bool\n-type_to_consider (tree type)\n-{\n-  /* Strip the *'s off.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-  while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-    type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-\n-  switch (TREE_CODE (type))\n-    {\n-    case BOOLEAN_TYPE:\n-    case COMPLEX_TYPE:\n-    case ENUMERAL_TYPE:\n-    case INTEGER_TYPE:\n-    case QUAL_UNION_TYPE:\n-    case REAL_TYPE:\n-    case FIXED_POINT_TYPE:\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case VECTOR_TYPE:\n-    case VOID_TYPE:\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Get the canon type of TYPE.  If SEE_THRU_PTRS is true, remove all\n-   the POINTER_TOs and if SEE_THRU_ARRAYS is true, remove all of the\n-   ARRAY_OFs and POINTER_TOs.  */\n-\n-static tree\n-get_canon_type (tree type, bool see_thru_ptrs, bool see_thru_arrays)\n-{\n-  splay_tree_node result;\n-  /* Strip the *'s off.  */\n-  if (!type || !type_to_consider (type))\n-    return NULL;\n-\n-  type = TYPE_MAIN_VARIANT (type);\n-  if (see_thru_arrays)\n-    while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-\n-  else if (see_thru_ptrs)\n-    while (POINTER_TYPE_P (type))\n-\ttype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-\n-  result = splay_tree_lookup (type_to_canon_type, (splay_tree_key) type);\n-\n-  if (result == NULL)\n-    return discover_unique_type (type);\n-  else return (tree) result->value;\n-}\n-\n-/* Same as GET_CANON_TYPE, except return the TYPE_ID rather than the\n-   TYPE.  */\n-\n-static int\n-get_canon_type_uid (tree type, bool see_thru_ptrs, bool see_thru_arrays)\n-{\n-  type = get_canon_type (type, see_thru_ptrs, see_thru_arrays);\n-  if (type)\n-    return TYPE_UID(type);\n-  else return 0;\n-}\n-\n-/* Return 0 if TYPE is a record or union type.  Return a positive\n-   number if TYPE is a pointer to a record or union.  The number is\n-   the number of pointer types stripped to get to the record or union\n-   type.  Return -1 if TYPE is none of the above.  */\n-\n-int\n-ipa_type_escape_star_count_of_interesting_type (tree type)\n-{\n-  int count = 0;\n-  /* Strip the *'s off.  */\n-  if (!type)\n-    return -1;\n-  type = TYPE_MAIN_VARIANT (type);\n-  while (POINTER_TYPE_P (type))\n-    {\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      count++;\n-    }\n-\n-  /* We are interested in records, and unions only.  */\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      || TREE_CODE (type) == QUAL_UNION_TYPE\n-      || TREE_CODE (type) == UNION_TYPE)\n-    return count;\n-  else\n-    return -1;\n-}\n-\n-\n-/* Return 0 if TYPE is a record or union type.  Return a positive\n-   number if TYPE is a pointer to a record or union.  The number is\n-   the number of pointer types stripped to get to the record or union\n-   type.  Return -1 if TYPE is none of the above.  */\n-\n-int\n-ipa_type_escape_star_count_of_interesting_or_array_type (tree type)\n-{\n-  int count = 0;\n-  /* Strip the *'s off.  */\n-  if (!type)\n-    return -1;\n-  type = TYPE_MAIN_VARIANT (type);\n-  while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      count++;\n-    }\n-\n-  /* We are interested in records, and unions only.  */\n-  if (TREE_CODE (type) == RECORD_TYPE\n-      || TREE_CODE (type) == QUAL_UNION_TYPE\n-      || TREE_CODE (type) == UNION_TYPE)\n-    return count;\n-  else\n-    return -1;\n-}\n-\n-\n-/* Return true if the record, or union TYPE passed in escapes this\n-   compilation unit. Note that all of the pointer-to's are removed\n-   before testing since these may not be correct.  */\n-\n-bool\n-ipa_type_escape_type_contained_p (tree type)\n-{\n-  if (!initialized)\n-    return false;\n-  return !bitmap_bit_p (global_types_full_escape,\n-\t\t\tget_canon_type_uid (type, true, false));\n-}\n-\n-/* Return true if a modification to a field of type FIELD_TYPE cannot\n-   clobber a record of RECORD_TYPE.  */\n-\n-bool\n-ipa_type_escape_field_does_not_clobber_p (tree record_type, tree field_type)\n-{\n-  splay_tree_node result;\n-  int uid;\n-\n-  if (!initialized)\n-    return false;\n-\n-  /* Strip off all of the pointer tos on the record type.  Strip the\n-     same number of pointer tos from the field type.  If the field\n-     type has fewer, it could not have been aliased. */\n-  record_type = TYPE_MAIN_VARIANT (record_type);\n-  field_type = TYPE_MAIN_VARIANT (field_type);\n-  while (POINTER_TYPE_P (record_type))\n-    {\n-      record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_type));\n-      if (POINTER_TYPE_P (field_type))\n-\tfield_type = TYPE_MAIN_VARIANT (TREE_TYPE (field_type));\n-      else\n-\t/* However, if field_type is a union, this quick test is not\n-\t   correct since one of the variants of the union may be a\n-\t   pointer to type and we cannot see across that here.  So we\n-\t   just strip the remaining pointer tos off the record type\n-\t   and fall thru to the more precise code.  */\n-\tif (TREE_CODE (field_type) == QUAL_UNION_TYPE\n-\t    || TREE_CODE (field_type) == UNION_TYPE)\n-\t  {\n-\t    while (POINTER_TYPE_P (record_type))\n-\t      record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_type));\n-\t    break;\n-\t  }\n-\telse\n-\t  return true;\n-    }\n-\n-  record_type = get_canon_type (record_type, true, true);\n-  /* The record type must be contained.  The field type may\n-     escape.  */\n-  if (!ipa_type_escape_type_contained_p (record_type))\n-    return false;\n-\n-  uid = TYPE_UID (record_type);\n-  result = splay_tree_lookup (uid_to_addressof_down_map, (splay_tree_key) uid);\n-\n-  if (result)\n-    {\n-      bitmap field_type_map = (bitmap) result->value;\n-      uid = get_canon_type_uid (field_type, true, true);\n-      /* If the bit is there, the address was taken. If not, it\n-\t wasn't.  */\n-      return !bitmap_bit_p (field_type_map, uid);\n-    }\n-  else\n-    /* No bitmap means no addresses were taken.  */\n-    return true;\n-}\n-\n-\n-/* Add TYPE to the suspect type set. Return true if the bit needed to\n-   be marked.  */\n-\n-static tree\n-mark_type (tree type, enum escape_t escape_status)\n-{\n-  bitmap map = NULL;\n-  int uid;\n-\n-  type = get_canon_type (type, true, true);\n-  if (!type)\n-    return NULL;\n-\n-  switch (escape_status)\n-    {\n-    case EXPOSED_PARAMETER:\n-      map = global_types_exposed_parameter;\n-      break;\n-    case FULL_ESCAPE:\n-      map = global_types_full_escape;\n-      break;\n-    }\n-\n-  uid = TYPE_UID (type);\n-  if (!bitmap_set_bit (map, uid))\n-    return type;\n-  else if (escape_status == FULL_ESCAPE)\n-    /* Efficiency hack. When things are bad, do not mess around\n-       with this type anymore.  */\n-    bitmap_set_bit (global_types_exposed_parameter, uid);\n-\n-  return type;\n-}\n-\n-/* Add interesting TYPE to the suspect type set. If the set is\n-   EXPOSED_PARAMETER and the TYPE is a pointer type, the set is\n-   changed to FULL_ESCAPE.  */\n-\n-static void\n-mark_interesting_type (tree type, enum escape_t escape_status)\n-{\n-  if (!type) return;\n-  if (ipa_type_escape_star_count_of_interesting_type (type) >= 0)\n-    {\n-      if ((escape_status == EXPOSED_PARAMETER)\n-\t  && POINTER_TYPE_P (type))\n-\t/* EXPOSED_PARAMETERs are only structs or unions are passed by\n-\t   value.  Anything passed by reference to an external\n-\t   function fully exposes the type.  */\n-\tmark_type (type, FULL_ESCAPE);\n-      else\n-\tmark_type (type, escape_status);\n-    }\n-}\n-\n-/* Return true if PARENT is supertype of CHILD.  Both types must be\n-   known to be structures or unions. */\n-\n-static bool\n-parent_type_p (tree parent, tree child)\n-{\n-  int i;\n-  tree binfo, base_binfo;\n-  if (TYPE_BINFO (parent))\n-    for (binfo = TYPE_BINFO (parent), i = 0;\n-\t BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-      {\n-\ttree binfotype = BINFO_TYPE (base_binfo);\n-\tif (binfotype == child)\n-\t  return true;\n-\telse if (parent_type_p (binfotype, child))\n-\t  return true;\n-      }\n-  if (TREE_CODE (parent) == UNION_TYPE\n-      || TREE_CODE (parent) == QUAL_UNION_TYPE)\n-    {\n-      tree field;\n-      /* Search all of the variants in the union to see if one of them\n-\t is the child.  */\n-      for (field = TYPE_FIELDS (parent);\n-\t   field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  tree field_type;\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\n-\t  field_type = TREE_TYPE (field);\n-\t  if (field_type == child)\n-\t    return true;\n-\t}\n-\n-      /* If we did not find it, recursively ask the variants if one of\n-\t their children is the child type.  */\n-      for (field = TYPE_FIELDS (parent);\n-\t   field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  tree field_type;\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\n-\t  field_type = TREE_TYPE (field);\n-\t  if (TREE_CODE (field_type) == RECORD_TYPE\n-\t      || TREE_CODE (field_type) == QUAL_UNION_TYPE\n-\t      || TREE_CODE (field_type) == UNION_TYPE)\n-\t    if (parent_type_p (field_type, child))\n-\t      return true;\n-\t}\n-    }\n-\n-  if (TREE_CODE (parent) == RECORD_TYPE)\n-    {\n-      tree field;\n-      for (field = TYPE_FIELDS (parent);\n-\t   field;\n-\t   field = TREE_CHAIN (field))\n-\t{\n-\t  tree field_type;\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\n-\t  field_type = TREE_TYPE (field);\n-\t  if (field_type == child)\n-\t    return true;\n-\t  /* You can only cast to the first field so if it does not\n-\t     match, quit.  */\n-\t  if (TREE_CODE (field_type) == RECORD_TYPE\n-\t      || TREE_CODE (field_type) == QUAL_UNION_TYPE\n-\t      || TREE_CODE (field_type) == UNION_TYPE)\n-\t    {\n-\t      if (parent_type_p (field_type, child))\n-\t\treturn true;\n-\t      else\n-\t\tbreak;\n-\t    }\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return the number of pointer tos for TYPE and return TYPE with all\n-   of these stripped off.  */\n-\n-static int\n-count_stars (tree* type_ptr)\n-{\n-  tree type = *type_ptr;\n-  int i = 0;\n-  type = TYPE_MAIN_VARIANT (type);\n-  while (POINTER_TYPE_P (type))\n-    {\n-      type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-      i++;\n-    }\n-\n-  *type_ptr = type;\n-  return i;\n-}\n-\n-enum cast_type {\n-  CT_UP = 0x1,\n-  CT_DOWN = 0x2,\n-  CT_SIDEWAYS = 0x4,\n-  CT_USELESS = 0x8,\n-  CT_FROM_P_BAD = 0x10,\n-  CT_FROM_NON_P = 0x20,\n-  CT_TO_NON_INTER = 0x40,\n-  CT_FROM_MALLOC = 0x80,\n-  CT_NO_CAST = 0x100\n-};\n-\n-/* Check the cast FROM_TYPE to TO_TYPE.  This function requires that\n-   the two types have already passed the\n-   ipa_type_escape_star_count_of_interesting_type test.  */\n-\n-static enum cast_type\n-check_cast_type (tree to_type, tree from_type)\n-{\n-  int to_stars = count_stars (&to_type);\n-  int from_stars = count_stars (&from_type);\n-  if (to_stars != from_stars)\n-    return CT_SIDEWAYS;\n-\n-  if (to_type == from_type)\n-    return CT_USELESS;\n-\n-  if (parent_type_p (to_type, from_type)) return CT_UP;\n-  if (parent_type_p (from_type, to_type)) return CT_DOWN;\n-  return CT_SIDEWAYS;\n-}\n-\n-/* This function returns nonzero if VAR is result of call\n-   to malloc function.  */\n-\n-static bool\n-is_malloc_result (tree var)\n-{\n-  gimple def_stmt;\n-\n-  if (!var)\n-    return false;\n-\n-  if (SSA_NAME_IS_DEFAULT_DEF (var))\n-    return false;\n-\n-  def_stmt = SSA_NAME_DEF_STMT (var);\n-\n-  if (!is_gimple_call (def_stmt))\n-    return false;\n-\n-  if (var != gimple_call_lhs (def_stmt))\n-    return false;\n-\n-  return ((gimple_call_flags (def_stmt) & ECF_MALLOC) != 0);\n-\n-}\n-\n-/* Check a cast FROM this variable, TO_TYPE.  Mark the escaping types\n-   if appropriate. Returns cast_type as detected.  */\n-\n-static enum cast_type\n-check_cast (tree to_type, tree from)\n-{\n-  tree from_type = get_canon_type (TREE_TYPE (from), false, false);\n-  bool to_interesting_type, from_interesting_type;\n-  enum cast_type cast = CT_NO_CAST;\n-\n-  to_type = get_canon_type (to_type, false, false);\n-  if (!from_type || !to_type || from_type == to_type)\n-    return cast;\n-\n-  to_interesting_type =\n-    ipa_type_escape_star_count_of_interesting_type (to_type) >= 0;\n-  from_interesting_type =\n-    ipa_type_escape_star_count_of_interesting_type (from_type) >= 0;\n-\n-  if (to_interesting_type)\n-    if (from_interesting_type)\n-      {\n-\t/* Both types are interesting. This can be one of four types\n-\t   of cast: useless, up, down, or sideways.  We do not care\n-\t   about up or useless.  Sideways casts are always bad and\n-\t   both sides get marked as escaping.  Downcasts are not\n-\t   interesting here because if type is marked as escaping, all\n-\t   of its subtypes escape.  */\n-\tcast = check_cast_type (to_type, from_type);\n-\tswitch (cast)\n-\t  {\n-\t  case CT_UP:\n-\t  case CT_USELESS:\n-\t  case CT_DOWN:\n-\t    break;\n-\n-\t  case CT_SIDEWAYS:\n-\t    mark_type (to_type, FULL_ESCAPE);\n-\t    mark_type (from_type, FULL_ESCAPE);\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-      }\n-    else\n-      {\n-\t/* This code excludes two cases from marking as escaped:\n-\n-\t1. if this is a cast of index of array of structures/unions\n-\tthat happens before accessing array element, we should not\n-\tmark it as escaped.\n-\t2. if this is a cast from the local that is a result from a\n-\tcall to malloc, do not mark the cast as bad.\n-\n-\t*/\n-\n-\tif (POINTER_TYPE_P (to_type) && !POINTER_TYPE_P (from_type))\n-\t  cast = CT_FROM_NON_P;\n-\telse if (TREE_CODE (from) == SSA_NAME\n-\t\t && is_malloc_result (from))\n-\t  cast = CT_FROM_MALLOC;\n-\telse\n-\t  {\n-\t    cast = CT_FROM_P_BAD;\n-\t    mark_type (to_type, FULL_ESCAPE);\n-\t  }\n-      }\n-  else if (from_interesting_type)\n-    {\n-      mark_type (from_type, FULL_ESCAPE);\n-      cast = CT_TO_NON_INTER;\n-    }\n-\n-  return cast;\n-}\n-\n-\n-/* Scan assignment statement S to see if there are any casts within it.  */\n-\n-static unsigned int\n-look_for_casts_stmt (gimple s)\n-{\n-  unsigned int cast = 0;\n-\n-  gcc_assert (is_gimple_assign (s));\n-\n-  if (gimple_assign_cast_p (s))\n-    {\n-      tree castfromvar = gimple_assign_rhs1 (s);\n-      cast |= check_cast (TREE_TYPE (gimple_assign_lhs (s)), castfromvar);\n-    }\n-  else\n-    {\n-      size_t i;\n-      for (i = 0; i < gimple_num_ops (s); i++)\n-\tcast |= look_for_casts (gimple_op (s, i));\n-    }\n-\n-  if (!cast)\n-    cast = CT_NO_CAST;\n-\n-  return cast;\n-}\n-\n-\n-typedef struct cast\n-{\n-  int type;\n-  gimple stmt;\n-} cast_t;\n-\n-/* This function is a callback for walk_use_def_chains function called\n-   from is_array_access_through_pointer_and_index.  */\n-\n-static bool\n-is_cast_from_non_pointer (tree var, gimple def_stmt, void *data)\n-{\n-  if (!def_stmt || !var)\n-    return false;\n-\n-  if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    return false;\n-\n-  if (SSA_NAME_IS_DEFAULT_DEF (var))\n-      return false;\n-\n-  if (is_gimple_assign (def_stmt))\n-    {\n-      use_operand_p use_p;\n-      ssa_op_iter iter;\n-      unsigned int cast = look_for_casts_stmt (def_stmt);\n-\n-      /* Check that only one cast happened, and it's of non-pointer\n-\t type.  */\n-      if ((cast & CT_FROM_NON_P) == (CT_FROM_NON_P)\n-\t  && (cast & ~(CT_FROM_NON_P)) == 0)\n-\t{\n-\t  ((cast_t *)data)->stmt = def_stmt;\n-\t  ((cast_t *)data)->type++;\n-\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n-\t    {\n-\t      walk_use_def_chains (USE_FROM_PTR (use_p),\n-\t\t\t\t   is_cast_from_non_pointer, data, false);\n-\t      if (((cast_t*)data)->type == -1)\n-\t\tbreak;\n-\t    }\n-\t}\n-      /* Check that there is no cast, or cast is not harmful. */\n-      else if ((cast & CT_NO_CAST) == (CT_NO_CAST)\n-\t  || (cast & CT_DOWN) == (CT_DOWN)\n-\t  || (cast & CT_UP) == (CT_UP)\n-\t  || (cast & CT_USELESS) == (CT_USELESS)\n-\t  || (cast & CT_FROM_MALLOC) == (CT_FROM_MALLOC))\n-\t{\n-\t  FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n-\t    {\n-\t      walk_use_def_chains (USE_FROM_PTR (use_p),\n-\t\t\t\t   is_cast_from_non_pointer, data, false);\n-\t      if (((cast_t*)data)->type == -1)\n-\t\tbreak;\n-\t    }\n-\t}\n-\t/* The cast is harmful.  */\n-\telse\n-\t  ((cast_t *)data)->type = -1;\n-    }\n-\n-  if (((cast_t*)data)->type == -1)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* When array element a_p[i] is accessed through the pointer a_p\n-   and index i, it's translated into the following sequence\n-   in gimple:\n-\n-  i.1_5 = (unsigned int) i_1;\n-  D.1605_6 = i.1_5 * 16;\n-  D.1606_7 = (struct str_t *) D.1605_6;\n-  a_p.2_8 = a_p;\n-  D.1608_9 = D.1606_7 + a_p.2_8;\n-\n-  OP0 and OP1 are of the same pointer types and stand for\n-  D.1606_7 and a_p.2_8 or vise versa.\n-\n-  This function checks that:\n-\n-  1. one of OP0 and OP1 (D.1606_7) has passed only one cast from\n-  non-pointer type (D.1606_7 = (struct str_t *) D.1605_6;).\n-\n-  2. one of OP0 and OP1 which has passed the cast from\n-  non-pointer type (D.1606_7), is actually generated by multiplication of\n-  index by size of type to which both OP0 and OP1 point to\n-  (in this case D.1605_6 = i.1_5 * 16; ).\n-\n-  3. an address of def of the var to which was made cast (D.1605_6)\n-  was not taken.(How can it happen?)\n-\n-  The following items are checked implicitly by the end of algorithm:\n-\n-  4. one of OP0 and OP1 (a_p.2_8) have never been cast\n-  (because if it was cast to pointer type, its type, that is also\n-  the type of OP0 and OP1, will be marked as escaped during\n-  analysis of casting stmt (when check_cast() is called\n-  from scan_for_refs for this stmt)).\n-\n-  5. defs of OP0 and OP1 are not passed into externally visible function\n-  (because if they are passed then their type, that is also the type of OP0\n-  and OP1, will be marked and escaped during check_call function called from\n-  scan_for_refs with call stmt).\n-\n-  In total, 1-5 guaranty that it's an access to array by pointer and index.\n-\n-*/\n-\n-bool\n-is_array_access_through_pointer_and_index (enum tree_code code, tree op0,\n-\t\t\t\t\t   tree op1, tree *base, tree *offset,\n-\t\t\t\t\t   gimple *offset_cast_stmt)\n-{\n-  tree before_cast;\n-  gimple before_cast_def_stmt;\n-  cast_t op0_cast, op1_cast;\n-\n-  *base = NULL;\n-  *offset = NULL;\n-  *offset_cast_stmt = NULL;\n-\n-  /* Check 1.  */\n-  if (code == POINTER_PLUS_EXPR)\n-    {\n-      tree op0type = TYPE_MAIN_VARIANT (TREE_TYPE (op0));\n-      tree op1type = TYPE_MAIN_VARIANT (TREE_TYPE (op1));\n-\n-      /* One of op0 and op1 is of pointer type and the other is numerical.  */\n-      if (POINTER_TYPE_P (op0type) && NUMERICAL_TYPE_CHECK (op1type))\n-\t{\n-\t  *base = op0;\n-\t  *offset = op1;\n-\t}\n-      else if (POINTER_TYPE_P (op1type) && NUMERICAL_TYPE_CHECK (op0type))\n-\t{\n-\t  *base = op1;\n-\t  *offset = op0;\n-\t}\n-      else\n-\treturn false;\n-    }\n-  else\n-    {\n-      /* Init data for walk_use_def_chains function.  */\n-      op0_cast.type = op1_cast.type = 0;\n-      op0_cast.stmt = op1_cast.stmt = NULL;\n-\n-      visited_stmts = pointer_set_create ();\n-      walk_use_def_chains (op0, is_cast_from_non_pointer,(void *)(&op0_cast),\n-\t\t\t   false);\n-      pointer_set_destroy (visited_stmts);\n-\n-      visited_stmts = pointer_set_create ();\n-      walk_use_def_chains (op1, is_cast_from_non_pointer,(void *)(&op1_cast),\n-\t\t\t   false);\n-      pointer_set_destroy (visited_stmts);\n-\n-      if (op0_cast.type == 1 && op1_cast.type == 0)\n-\t{\n-\t  *base = op1;\n-\t  *offset = op0;\n-\t  *offset_cast_stmt = op0_cast.stmt;\n-\t}\n-      else if (op0_cast.type == 0 && op1_cast.type == 1)\n-\t{\n-\t  *base = op0;\n-\t  *offset = op1;\n-\t  *offset_cast_stmt = op1_cast.stmt;\n-\t}\n-      else\n-\treturn false;\n-    }\n-\n-  /* Check 2.\n-     offset_cast_stmt is of the form:\n-     D.1606_7 = (struct str_t *) D.1605_6;  */\n-\n-  if (*offset_cast_stmt)\n-    {\n-      before_cast = SINGLE_SSA_TREE_OPERAND (*offset_cast_stmt, SSA_OP_USE);\n-      if (!before_cast)\n-\treturn false;\n-\n-      if (SSA_NAME_IS_DEFAULT_DEF (before_cast))\n-\treturn false;\n-\n-      before_cast_def_stmt = SSA_NAME_DEF_STMT (before_cast);\n-      if (!before_cast_def_stmt)\n-\treturn false;\n-    }\n-  else\n-    before_cast_def_stmt = SSA_NAME_DEF_STMT (*offset);\n-\n-  /* before_cast_def_stmt should be of the form:\n-     D.1605_6 = i.1_5 * 16; */\n-\n-  if (is_gimple_assign (before_cast_def_stmt))\n-    {\n-      /* We expect temporary here.  */\n-      if (!is_gimple_reg (gimple_assign_lhs (before_cast_def_stmt)))\n-\treturn false;\n-\n-      if (gimple_assign_rhs_code (before_cast_def_stmt) == MULT_EXPR)\n-\t{\n-\t  tree arg0 = gimple_assign_rhs1 (before_cast_def_stmt);\n-\t  tree arg1 = gimple_assign_rhs2 (before_cast_def_stmt);\n-\t  tree unit_size =\n-\t    TYPE_SIZE_UNIT (TREE_TYPE (TYPE_MAIN_VARIANT (TREE_TYPE (op0))));\n-\n-\t  if (!(CONSTANT_CLASS_P (arg0)\n-\t      && simple_cst_equal (arg0, unit_size))\n-\t      && !(CONSTANT_CLASS_P (arg1)\n-\t      && simple_cst_equal (arg1, unit_size)))\n-\t    return false;\n-\t}\n-      else\n-\treturn false;\n-    }\n-  else\n-    return false;\n-\n-  /* Check 3.\n-     check that address of D.1605_6 was not taken.\n-     FIXME: if D.1605_6 is gimple reg than it cannot be addressable.  */\n-\n-  return true;\n-}\n-\n-/* Register the parameter and return types of function FN.  The type\n-   ESCAPES if the function is visible outside of the compilation\n-   unit.  */\n-static void\n-check_function_parameter_and_return_types (tree fn, bool escapes)\n-{\n-  tree arg;\n-\n-  if (prototype_p (TREE_TYPE (fn)))\n-    {\n-      for (arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t   arg && TREE_VALUE (arg) != void_type_node;\n-\t   arg = TREE_CHAIN (arg))\n-\t{\n-\t  tree type = get_canon_type (TREE_VALUE (arg), false, false);\n-\t  if (escapes)\n-\t    mark_interesting_type (type, EXPOSED_PARAMETER);\n-\t}\n-    }\n-  else\n-    {\n-      /* FIXME - According to Geoff Keating, we should never have to\n-\t do this; the front ends should always process the arg list\n-\t from the TYPE_ARG_LIST. However, Geoff is wrong, this code\n-\t does seem to be live.  */\n-\n-      for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n-\t{\n-\t  tree type = get_canon_type (TREE_TYPE (arg), false, false);\n-\t  if (escapes)\n-\t    mark_interesting_type (type, EXPOSED_PARAMETER);\n-\t}\n-    }\n-  if (escapes)\n-    {\n-      tree type = get_canon_type (TREE_TYPE (TREE_TYPE (fn)), false, false);\n-      mark_interesting_type (type, EXPOSED_PARAMETER);\n-    }\n-}\n-\n-/* Return true if the variable T is the right kind of static variable to\n-   perform compilation unit scope escape analysis.  */\n-\n-static inline void\n-has_proper_scope_for_analysis (tree t)\n-{\n-  /* If the variable has the \"used\" attribute, treat it as if it had a\n-     been touched by the devil.  */\n-  tree type = get_canon_type (TREE_TYPE (t), false, false);\n-  if (!type) return;\n-\n-  if (DECL_PRESERVE_P (t))\n-    {\n-      mark_interesting_type (type, FULL_ESCAPE);\n-      return;\n-    }\n-\n-  /* Do not want to do anything with volatile except mark any\n-     function that uses one to be not const or pure.  */\n-  if (TREE_THIS_VOLATILE (t))\n-    return;\n-\n-  /* Do not care about a local automatic that is not static.  */\n-  if (!TREE_STATIC (t) && !DECL_EXTERNAL (t))\n-    return;\n-\n-  if (DECL_EXTERNAL (t) || TREE_PUBLIC (t))\n-    {\n-      /* If the front end set the variable to be READONLY and\n-\t constant, we can allow this variable in pure or const\n-\t functions but the scope is too large for our analysis to set\n-\t these bits ourselves.  */\n-\n-      if (TREE_READONLY (t)\n-\t  && DECL_INITIAL (t)\n-\t  && is_gimple_min_invariant (DECL_INITIAL (t)))\n-\t; /* Read of a constant, do not change the function state.  */\n-      else\n-\t{\n-\t  /* The type escapes for all public and externs. */\n-\t  mark_interesting_type (type, FULL_ESCAPE);\n-\t}\n-    }\n-}\n-\n-/* If T is a VAR_DECL for a static that we are interested in, add the\n-   uid to the bitmap.  */\n-\n-static void\n-check_operand (tree t)\n-{\n-  if (!t) return;\n-\n-  /* This is an assignment from a function, register the types as\n-     escaping.  */\n-  if (TREE_CODE (t) == FUNCTION_DECL)\n-    check_function_parameter_and_return_types (t, true);\n-\n-  else if (TREE_CODE (t) == VAR_DECL)\n-    has_proper_scope_for_analysis (t);\n-}\n-\n-/* Examine tree T for references.   */\n-\n-static void\n-check_tree (tree t)\n-{\n-  /* We want to catch here also REALPART_EXPR and IMAGEPART_EXPR,\n-     but they already included in handled_component_p.  */\n-  while (handled_component_p (t))\n-    {\n-      if (TREE_CODE (t) == ARRAY_REF)\n-\tcheck_operand (TREE_OPERAND (t, 1));\n-      t = TREE_OPERAND (t, 0);\n-    }\n-\n-  if (INDIRECT_REF_P (t))\n-/*  || TREE_CODE (t) == MEM_REF) */\n-    check_tree (TREE_OPERAND (t, 0));\n-\n-  if (SSA_VAR_P (t) || (TREE_CODE (t) == FUNCTION_DECL))\n-    {\n-      check_operand (t);\n-      if (DECL_P (t) && DECL_INITIAL (t))\n-\tcheck_tree (DECL_INITIAL (t));\n-    }\n-}\n-\n-/* Create an address_of edge FROM_TYPE.TO_TYPE.  */\n-static void\n-mark_interesting_addressof (tree to_type, tree from_type)\n-{\n-  int from_uid;\n-  int to_uid;\n-  bitmap type_map;\n-  splay_tree_node result;\n-\n-  from_type = get_canon_type (from_type, false, false);\n-  to_type = get_canon_type (to_type, false, false);\n-\n-  if (!from_type || !to_type)\n-    return;\n-\n-  from_uid = TYPE_UID (from_type);\n-  to_uid = TYPE_UID (to_type);\n-\n-  gcc_assert (ipa_type_escape_star_count_of_interesting_type (from_type) == 0);\n-\n-  /* Process the Y into X map pointer.  */\n-  result = splay_tree_lookup (uid_to_addressof_down_map,\n-\t\t\t      (splay_tree_key) from_uid);\n-\n-  if (result)\n-    type_map = (bitmap) result->value;\n-  else\n-    {\n-      type_map = BITMAP_ALLOC (&ipa_obstack);\n-      splay_tree_insert (uid_to_addressof_down_map,\n-\t\t\t from_uid,\n-\t\t\t (splay_tree_value)type_map);\n-    }\n-  bitmap_set_bit (type_map, TYPE_UID (to_type));\n-\n-  /* Process the X into Y reverse map pointer.  */\n-  result =\n-    splay_tree_lookup (uid_to_addressof_up_map, (splay_tree_key) to_uid);\n-\n-  if (result)\n-    type_map = (bitmap) result->value;\n-  else\n-    {\n-      type_map = BITMAP_ALLOC (&ipa_obstack);\n-      splay_tree_insert (uid_to_addressof_up_map,\n-\t\t\t to_uid,\n-\t\t\t (splay_tree_value)type_map);\n-    }\n-  bitmap_set_bit (type_map, TYPE_UID (from_type));\n-}\n-\n-/* Scan tree T to see if there are any addresses taken in within T.  */\n-\n-static void\n-look_for_address_of (tree t)\n-{\n-  if (TREE_CODE (t) == ADDR_EXPR)\n-    {\n-      tree x = get_base_var (t);\n-      tree cref = TREE_OPERAND (t, 0);\n-\n-      /* If we have an expression of the form \"&a.b.c.d\", mark a.b,\n-\t b.c and c.d. as having its address taken.  */\n-      tree fielddecl = NULL_TREE;\n-      while (cref!= x)\n-\t{\n-\t  if (TREE_CODE (cref) == COMPONENT_REF)\n-\t    {\n-\t      fielddecl =  TREE_OPERAND (cref, 1);\n-\t      mark_interesting_addressof (TREE_TYPE (fielddecl),\n-\t\t\t\t\t  DECL_FIELD_CONTEXT (fielddecl));\n-\t    }\n-\t  else if (TREE_CODE (cref) == ARRAY_REF)\n-\t    get_canon_type (TREE_TYPE (cref), false, false);\n-\n-\t  cref = TREE_OPERAND (cref, 0);\n-\t}\n-\n-      if (TREE_CODE (x) == VAR_DECL)\n-\thas_proper_scope_for_analysis (x);\n-    }\n-}\n-\n-\n-/* Scan tree T to see if there are any casts within it.  */\n-\n-static unsigned int\n-look_for_casts (tree t)\n-{\n-  unsigned int cast = 0;\n-\n-  if (CONVERT_EXPR_P (t) || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n-    {\n-      tree castfromvar = TREE_OPERAND (t, 0);\n-      cast = cast | check_cast (TREE_TYPE (t), castfromvar);\n-    }\n-  else\n-    while (handled_component_p (t))\n-      {\n-\tt = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (t) == VIEW_CONVERT_EXPR)\n-\t  {\n-\t    /* This may be some part of a component ref.\n-\t       IE it may be a.b.VIEW_CONVERT_EXPR<weird_type>(c).d, AFAIK.\n-\t       castfromref will give you a.b.c, not a. */\n-\t    tree castfromref = TREE_OPERAND (t, 0);\n-\t    cast = cast | check_cast (TREE_TYPE (t), castfromref);\n-\t  }\n-\telse if (TREE_CODE (t) == COMPONENT_REF)\n-\t  get_canon_type (TREE_TYPE (TREE_OPERAND (t, 1)), false, false);\n-      }\n-\n-  if (!cast)\n-    cast = CT_NO_CAST;\n-  return cast;\n-}\n-\n-/* Check to see if T is a read or address of operation on a static var\n-   we are interested in analyzing.  */\n-\n-static void\n-check_rhs_var (tree t)\n-{\n-  look_for_address_of (t);\n-  check_tree (t);\n-}\n-\n-/* Check to see if T is an assignment to a static var we are\n-   interested in analyzing.  */\n-\n-static void\n-check_lhs_var (tree t)\n-{\n-  check_tree (t);\n-}\n-\n-/* This is a scaled down version of get_asm_expr_operands from\n-   tree_ssa_operands.c.  The version there runs much later and assumes\n-   that aliasing information is already available. Here we are just\n-   trying to find if the set of inputs and outputs contain references\n-   or address of operations to local.  FN is the function being\n-   analyzed and STMT is the actual asm statement.  */\n-\n-static void\n-check_asm (gimple stmt)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n-    check_lhs_var (gimple_asm_output_op (stmt, i));\n-\n-  for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n-    check_rhs_var (gimple_asm_input_op (stmt, i));\n-\n-  /* There is no code here to check for asm memory clobbers.  The\n-     casual maintainer might think that such code would be necessary,\n-     but that appears to be wrong.  In other parts of the compiler,\n-     the asm memory clobbers are assumed to only clobber variables\n-     that are addressable.  All types with addressable instances are\n-     assumed to already escape.  So, we are protected here.  */\n-}\n-\n-\n-/* Check the parameters of function call to CALL to mark the\n-   types that pass across the function boundary.  Also check to see if\n-   this is either an indirect call, a call outside the compilation\n-   unit.  */\n-\n-static void\n-check_call (gimple call)\n-{\n-  tree callee_t = gimple_call_fndecl (call);\n-  struct cgraph_node* callee;\n-  enum availability avail = AVAIL_NOT_AVAILABLE;\n-  size_t i;\n-\n-  for (i = 0; i < gimple_call_num_args (call); i++)\n-    check_rhs_var (gimple_call_arg (call, i));\n-\n-  if (callee_t)\n-    {\n-      tree arg_type;\n-      tree last_arg_type = NULL;\n-      callee = cgraph_node(callee_t);\n-      avail = cgraph_function_body_availability (callee);\n-\n-      /* Check that there are no implicit casts in the passing of\n-\t parameters.  */\n-      if (prototype_p (TREE_TYPE (callee_t)))\n-\t{\n-\t  for (arg_type = TYPE_ARG_TYPES (TREE_TYPE (callee_t)), i = 0;\n-\t       arg_type && TREE_VALUE (arg_type) != void_type_node\n-\t       && i < gimple_call_num_args (call);\n-\t       arg_type = TREE_CHAIN (arg_type), i++)\n-\t    {\n-\t      tree operand = gimple_call_arg (call, i);\n-\t      if (operand)\n-\t\t{\n-\t\t  last_arg_type = TREE_VALUE(arg_type);\n-\t\t  check_cast (last_arg_type, operand);\n-\t\t}\n-\t      else\n-\t\t/* The code reaches here for some unfortunate\n-\t\t   builtin functions that do not have a list of\n-\t\t   argument types.  */\n-\t\tbreak;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* FIXME - According to Geoff Keating, we should never\n-\t     have to do this; the front ends should always process\n-\t     the arg list from the TYPE_ARG_LIST. */\n-\t  for (arg_type = DECL_ARGUMENTS (callee_t), i = 0;\n-\t       arg_type && i < gimple_call_num_args (call);\n-\t       arg_type = TREE_CHAIN (arg_type), i++)\n-\t    {\n-\t      tree operand = gimple_call_arg (call, i);\n-\t      if (operand)\n-\t\t{\n-\t\t  last_arg_type = TREE_TYPE (arg_type);\n-\t\t  check_cast (last_arg_type, operand);\n-\t\t}\n-\t      else\n-\t\t/* The code reaches here for some unfortunate\n-\t\t   builtin functions that do not have a list of\n-\t\t   argument types.  */\n-\t\tbreak;\n-\t    }\n-\t}\n-\n-      /* In the case where we have a var_args function, we need to\n-\t check the remaining parameters against the last argument.  */\n-      arg_type = last_arg_type;\n-      for ( ; i < gimple_call_num_args (call); i++)\n-\t{\n-\t  tree operand = gimple_call_arg (call, i);\n-\t  if (arg_type)\n-\t    check_cast (arg_type, operand);\n-\t  else\n-\t    {\n-\t      /* The code reaches here for some unfortunate\n-\t\t builtin functions that do not have a list of\n-\t\t argument types.  Most of these functions have\n-\t\t been marked as having their parameters not\n-\t\t escape, but for the rest, the type is doomed.  */\n-\t      tree type = get_canon_type (TREE_TYPE (operand), false, false);\n-\t      mark_interesting_type (type, FULL_ESCAPE);\n-\t    }\n-\t}\n-    }\n-\n-  /* The callee is either unknown (indirect call) or there is just no\n-     scannable code for it (external call) .  We look to see if there\n-     are any bits available for the callee (such as by declaration or\n-     because it is builtin) and process solely on the basis of those\n-     bits. */\n-  if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n-    {\n-      /* If this is a direct call to an external function, mark all of\n-\t the parameter and return types.  */\n-      for (i = 0; i < gimple_call_num_args (call); i++)\n-\t{\n-\t  tree operand = gimple_call_arg (call, i);\n-\t  tree type = get_canon_type (TREE_TYPE (operand), false, false);\n-\t  mark_interesting_type (type, EXPOSED_PARAMETER);\n-\t}\n-\n-      if (callee_t)\n-\t{\n-\t  tree type =\n-\t    get_canon_type (TREE_TYPE (TREE_TYPE (callee_t)), false, false);\n-\t  mark_interesting_type (type, EXPOSED_PARAMETER);\n-\t}\n-    }\n-}\n-\n-/* CODE is the operation on OP0 and OP1.  OP0 is the operand that we\n-   *know* is a pointer type.  OP1 may be a pointer type.  */\n-static bool\n-okay_pointer_operation (enum tree_code code, tree op0, tree op1)\n-{\n-  tree op0type = TYPE_MAIN_VARIANT (TREE_TYPE (op0));\n-\n-  switch (code)\n-    {\n-    case MULT_EXPR:\n-      /* Multiplication does not change alignment.  */\n-      return true;\n-      break;\n-    case MINUS_EXPR:\n-    case PLUS_EXPR:\n-    case POINTER_PLUS_EXPR:\n-      {\n-\ttree base, offset;\n-\tgimple offset_cast_stmt;\n-\n-\tif (POINTER_TYPE_P (op0type)\n-\t    && TREE_CODE (op0) == SSA_NAME\n-\t    && TREE_CODE (op1) == SSA_NAME\n-\t    && is_array_access_through_pointer_and_index (code, op0, op1,\n-\t\t\t\t\t\t\t  &base,\n-\t\t\t\t\t\t\t  &offset,\n-\t\t\t\t\t\t\t  &offset_cast_stmt))\n-\t  return true;\n-\telse\n-\t  {\n-\t    tree size_of_op0_points_to = TYPE_SIZE_UNIT (TREE_TYPE (op0type));\n-\n-\t    if (CONSTANT_CLASS_P (op1)\n-\t\t&& size_of_op0_points_to\n-\t\t&& multiple_of_p (TREE_TYPE (size_of_op0_points_to),\n-\t\t\t\t  op1, size_of_op0_points_to))\n-\t      return true;\n-\n-\t    if (CONSTANT_CLASS_P (op0)\n-\t\t&& size_of_op0_points_to\n-\t\t&& multiple_of_p (TREE_TYPE (size_of_op0_points_to),\n-\t\t\t\t  op0, size_of_op0_points_to))\n-\t      return true;\n-\t  }\n-      }\n-      break;\n-    default:\n-      return false;\n-    }\n-  return false;\n-}\n-\n-\n-\n-/* Helper for scan_for_refs.  Check the operands of an assignment to\n-   mark types that may escape.  */\n-\n-static void\n-check_assign (gimple t)\n-{\n-  /* First look on the lhs and see what variable is stored to */\n-  check_lhs_var (gimple_assign_lhs (t));\n-\n-  /* For the purposes of figuring out what the cast affects */\n-\n-  /* Next check the operands on the rhs to see if they are ok. */\n-  switch (TREE_CODE_CLASS (gimple_assign_rhs_code (t)))\n-    {\n-    case tcc_binary:\n-      {\n-\ttree op0 = gimple_assign_rhs1 (t);\n-\ttree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n-\ttree op1 = gimple_assign_rhs2 (t);\n-\ttree type1 = get_canon_type (TREE_TYPE (op1), false, false);\n-\n-\t/* If this is pointer arithmetic of any bad sort, then\n-\t    we need to mark the types as bad.  For binary\n-\t    operations, no binary operator we currently support\n-\t    is always \"safe\" in regard to what it would do to\n-\t    pointers for purposes of determining which types\n-\t    escape, except operations of the size of the type.\n-\t    It is possible that min and max under the right set\n-\t    of circumstances and if the moon is in the correct\n-\t    place could be safe, but it is hard to see how this\n-\t    is worth the effort.  */\n-\tif (type0 && POINTER_TYPE_P (type0)\n-\t    && !okay_pointer_operation (gimple_assign_rhs_code (t), op0, op1))\n-\t  mark_interesting_type (type0, FULL_ESCAPE);\n-\n-\tif (type1 && POINTER_TYPE_P (type1)\n-\t    && !okay_pointer_operation (gimple_assign_rhs_code (t), op1, op0))\n-\t  mark_interesting_type (type1, FULL_ESCAPE);\n-\n-\tlook_for_casts (op0);\n-\tlook_for_casts (op1);\n-\tcheck_rhs_var (op0);\n-\tcheck_rhs_var (op1);\n-      }\n-      break;\n-\n-    case tcc_unary:\n-      {\n-\ttree op0 = gimple_assign_rhs1 (t);\n-\ttree type0 = get_canon_type (TREE_TYPE (op0), false, false);\n-\n-\t/* For unary operations, if the operation is NEGATE or ABS on\n-\t   a pointer, this is also considered pointer arithmetic and\n-\t   thus, bad for business.  */\n-\tif (type0\n-\t    && POINTER_TYPE_P (type0)\n-\t    && (TREE_CODE (op0) == NEGATE_EXPR\n-\t      || TREE_CODE (op0) == ABS_EXPR))\n-\t  mark_interesting_type (type0, FULL_ESCAPE);\n-\n-\tcheck_rhs_var (op0);\n-\tlook_for_casts (op0);\n-      }\n-      break;\n-\n-    case tcc_reference:\n-      look_for_casts (gimple_assign_rhs1 (t));\n-      check_rhs_var (gimple_assign_rhs1 (t));\n-      break;\n-\n-    case tcc_declaration:\n-      check_rhs_var (gimple_assign_rhs1 (t));\n-      break;\n-\n-    case tcc_expression:\n-      if (gimple_assign_rhs_code (t) == ADDR_EXPR)\n-\t{\n-\t  tree rhs = gimple_assign_rhs1 (t);\n-\t  look_for_casts (TREE_OPERAND (rhs, 0));\n-\t  check_rhs_var (rhs);\n-\t}\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n-\n-/* Scan statement T for references to types and mark anything\n-   interesting.  */\n-\n-static void\n-scan_for_refs (gimple t)\n-{\n-  switch (gimple_code (t))\n-    {\n-    case GIMPLE_ASSIGN:\n-      check_assign (t);\n-      break;\n-\n-    case GIMPLE_CALL:\n-      /* If this is a call to malloc, squirrel away the result so we\n-\t do mark the resulting cast as being bad.  */\n-      check_call (t);\n-      break;\n-\n-    case GIMPLE_ASM:\n-      check_asm (t);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return;\n-}\n-\n-\n-/* The init routine for analyzing global static variable usage.  See\n-   comments at top for description.  */\n-static void\n-ipa_init (void)\n-{\n-  bitmap_obstack_initialize (&ipa_obstack);\n-  global_types_exposed_parameter = BITMAP_ALLOC (&ipa_obstack);\n-  global_types_full_escape = BITMAP_ALLOC (&ipa_obstack);\n-  global_types_seen = BITMAP_ALLOC (&ipa_obstack);\n-\n-  uid_to_canon_type = splay_tree_new (splay_tree_compare_ints, 0, 0);\n-  all_canon_types = splay_tree_new (compare_type_brand, 0, 0);\n-  type_to_canon_type = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n-  uid_to_subtype_map = splay_tree_new (splay_tree_compare_ints, 0, 0);\n-  uid_to_addressof_down_map = splay_tree_new (splay_tree_compare_ints, 0, 0);\n-  uid_to_addressof_up_map = splay_tree_new (splay_tree_compare_ints, 0, 0);\n-\n-  /* There are some shared nodes, in particular the initializers on\n-     static declarations.  We do not need to scan them more than once\n-     since all we would be interested in are the addressof\n-     operations.  */\n-  visited_nodes = pointer_set_create ();\n-  initialized = true;\n-}\n-\n-/* Check out the rhs of a static or global initialization VNODE to see\n-   if any of them contain addressof operations.  Note that some of\n-   these variables may not even be referenced in the code in this\n-   compilation unit but their right hand sides may contain references\n-   to variables defined within this unit.  */\n-\n-static void\n-analyze_variable (struct varpool_node *vnode)\n-{\n-  tree global = vnode->decl;\n-  tree type = get_canon_type (TREE_TYPE (global), false, false);\n-\n-  /* If this variable has exposure beyond the compilation unit, add\n-     its type to the global types.  */\n-\n-  if (vnode->externally_visible)\n-    mark_interesting_type (type, FULL_ESCAPE);\n-\n-  gcc_assert (TREE_CODE (global) == VAR_DECL);\n-\n-  if (DECL_INITIAL (global))\n-    check_tree (DECL_INITIAL (global));\n-}\n-\n-/* This is the main routine for finding the reference patterns for\n-   global variables within a function FN.  */\n-\n-static void\n-analyze_function (struct cgraph_node *fn)\n-{\n-  tree decl = fn->decl;\n-  check_function_parameter_and_return_types (decl,\n-\t\t\t\t\t     fn->local.externally_visible);\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n local analysis of %s\", cgraph_node_name (fn));\n-\n-  {\n-    struct function *this_cfun = DECL_STRUCT_FUNCTION (decl);\n-    basic_block this_block;\n-\n-    FOR_EACH_BB_FN (this_block, this_cfun)\n-      {\n-\tgimple_stmt_iterator gsi;\n-\tfor (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  scan_for_refs (gsi_stmt (gsi));\n-      }\n-  }\n-\n-  /* There may be const decls with interesting right hand sides.  */\n-  if (DECL_STRUCT_FUNCTION (decl))\n-    {\n-      tree var;\n-      unsigned ix;\n-\n-      FOR_EACH_LOCAL_DECL (DECL_STRUCT_FUNCTION (decl), ix, var)\n-\t{\n-\t  if (TREE_CODE (var) == VAR_DECL\n-\t      && DECL_INITIAL (var)\n-\t      && !TREE_STATIC (var))\n-\t    check_tree (DECL_INITIAL (var));\n-\t  get_canon_type (TREE_TYPE (var), false, false);\n-\t}\n-    }\n-}\n-\n-\f\n-\n-/* Convert a type_UID into a type.  */\n-static tree\n-type_for_uid (int uid)\n-{\n-  splay_tree_node result =\n-    splay_tree_lookup (uid_to_canon_type, (splay_tree_key) uid);\n-\n-  if (result)\n-    return (tree) result->value;\n-  else return NULL;\n-}\n-\n-/* Return a bitmap with the subtypes of the type for UID.  If it\n-   does not exist, return either NULL or a new bitmap depending on the\n-   value of CREATE.  */\n-\n-static bitmap\n-subtype_map_for_uid (int uid, bool create)\n-{\n-  splay_tree_node result = splay_tree_lookup (uid_to_subtype_map,\n-\t\t\t      (splay_tree_key) uid);\n-\n-  if (result)\n-    return (bitmap) result->value;\n-  else if (create)\n-    {\n-      bitmap subtype_map = BITMAP_ALLOC (&ipa_obstack);\n-      splay_tree_insert (uid_to_subtype_map,\n-\t\t\t uid,\n-\t\t\t (splay_tree_value)subtype_map);\n-      return subtype_map;\n-    }\n-  else return NULL;\n-}\n-\n-/* Mark all of the supertypes and field types of TYPE as being seen.\n-   Also accumulate the subtypes for each type so that\n-   close_types_full_escape can mark a subtype as escaping if the\n-   supertype escapes.  */\n-\n-static void\n-close_type_seen (tree type)\n-{\n-  tree field;\n-  int i, uid;\n-  tree binfo, base_binfo;\n-\n-  /* See thru all pointer tos and array ofs. */\n-  type = get_canon_type (type, true, true);\n-  if (!type)\n-    return;\n-\n-  uid = TYPE_UID (type);\n-\n-  if (!bitmap_set_bit (been_there_done_that, uid))\n-    return;\n-\n-  /* If we are doing a language with a type hierarchy, mark all of\n-     the superclasses.  */\n-  if (TYPE_BINFO (type))\n-    for (binfo = TYPE_BINFO (type), i = 0;\n-\t BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-      {\n-\ttree binfo_type = BINFO_TYPE (base_binfo);\n-\tbitmap subtype_map = subtype_map_for_uid\n-\t  (TYPE_UID (TYPE_MAIN_VARIANT (binfo_type)), true);\n-\tbitmap_set_bit (subtype_map, uid);\n-\tclose_type_seen (get_canon_type (binfo_type, true, true));\n-      }\n-\n-  /* If the field is a struct or union type, mark all of the\n-     subfields.  */\n-  for (field = TYPE_FIELDS (type);\n-       field;\n-       field = DECL_CHAIN (field))\n-    {\n-      tree field_type;\n-      if (TREE_CODE (field) != FIELD_DECL)\n-\tcontinue;\n-\n-      field_type = TREE_TYPE (field);\n-      if (ipa_type_escape_star_count_of_interesting_or_array_type (field_type) >= 0)\n-\tclose_type_seen (get_canon_type (field_type, true, true));\n-    }\n-}\n-\n-/* Take a TYPE that has been passed by value to an external function\n-   and mark all of the fields that have pointer types as escaping. For\n-   any of the non pointer types that are structures or unions,\n-   recurse.  TYPE is never a pointer type.  */\n-\n-static void\n-close_type_exposed_parameter (tree type)\n-{\n-  tree field;\n-  int uid;\n-\n-  type = get_canon_type (type, false, false);\n-  if (!type)\n-    return;\n-  uid = TYPE_UID (type);\n-  gcc_assert (!POINTER_TYPE_P (type));\n-\n-  if (!bitmap_set_bit (been_there_done_that, uid))\n-    return;\n-\n-  /* If the field is a struct or union type, mark all of the\n-     subfields.  */\n-  for (field = TYPE_FIELDS (type);\n-       field;\n-       field = TREE_CHAIN (field))\n-    {\n-      tree field_type;\n-\n-      if (TREE_CODE (field) != FIELD_DECL)\n-\tcontinue;\n-\n-      field_type = get_canon_type (TREE_TYPE (field), false, false);\n-      mark_interesting_type (field_type, EXPOSED_PARAMETER);\n-\n-      /* Only recurse for non pointer types of structures and unions.  */\n-      if (ipa_type_escape_star_count_of_interesting_type (field_type) == 0)\n-\tclose_type_exposed_parameter (field_type);\n-    }\n-}\n-\n-/* The next function handles the case where a type fully escapes.\n-   This means that not only does the type itself escape,\n-\n-   a) the type of every field recursively escapes\n-   b) the type of every subtype escapes as well as the super as well\n-   as all of the pointer to types for each field.\n-\n-   Note that pointer to types are not marked as escaping.  If the\n-   pointed to type escapes, the pointer to type also escapes.\n-\n-   Take a TYPE that has had the address taken for an instance of it\n-   and mark all of the types for its fields as having their addresses\n-   taken. */\n-\n-static void\n-close_type_full_escape (tree type)\n-{\n-  tree field;\n-  unsigned int i;\n-  int uid;\n-  tree binfo, base_binfo;\n-  bitmap_iterator bi;\n-  bitmap subtype_map;\n-  splay_tree_node address_result;\n-\n-  /* Strip off any pointer or array types.  */\n-  type = get_canon_type (type, true, true);\n-  if (!type)\n-    return;\n-  uid = TYPE_UID (type);\n-\n-  if (!bitmap_set_bit (been_there_done_that, uid))\n-    return;\n-\n-  subtype_map = subtype_map_for_uid (uid, false);\n-\n-  /* If we are doing a language with a type hierarchy, mark all of\n-     the superclasses.  */\n-  if (TYPE_BINFO (type))\n-    for (binfo = TYPE_BINFO (type), i = 0;\n-\t BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-      {\n-\ttree binfotype = BINFO_TYPE (base_binfo);\n-\tbinfotype = mark_type (binfotype, FULL_ESCAPE);\n-\tclose_type_full_escape (binfotype);\n-      }\n-\n-  /* Mark as escaped any types that have been down casted to\n-     this type. */\n-  if (subtype_map)\n-    EXECUTE_IF_SET_IN_BITMAP (subtype_map, 0, i, bi)\n-      {\n-\ttree subtype = type_for_uid (i);\n-\tsubtype = mark_type (subtype, FULL_ESCAPE);\n-\tclose_type_full_escape (subtype);\n-      }\n-\n-  /* If the field is a struct or union type, mark all of the\n-     subfields.  */\n-  for (field = TYPE_FIELDS (type);\n-       field;\n-       field = TREE_CHAIN (field))\n-    {\n-      tree field_type;\n-      if (TREE_CODE (field) != FIELD_DECL)\n-\tcontinue;\n-\n-      field_type = TREE_TYPE (field);\n-      if (ipa_type_escape_star_count_of_interesting_or_array_type (field_type) >= 0)\n-\t{\n-\t  field_type = mark_type (field_type, FULL_ESCAPE);\n-\t  close_type_full_escape (field_type);\n-\t}\n-    }\n-\n-  /* For all of the types A that contain this type B and were part of\n-     an expression like \"&...A.B...\", mark the A's as escaping.  */\n-  address_result = splay_tree_lookup (uid_to_addressof_up_map,\n-\t\t\t\t      (splay_tree_key) uid);\n-  if (address_result)\n-    {\n-      bitmap containing_classes = (bitmap) address_result->value;\n-      EXECUTE_IF_SET_IN_BITMAP (containing_classes, 0, i, bi)\n-\t{\n-\t  close_type_full_escape (type_for_uid (i));\n-\t}\n-    }\n-}\n-\n-/* Transitively close the addressof bitmap for the type with UID.\n-   This means that if we had a.b and b.c, a would have both b and c in\n-   its maps.  */\n-\n-static bitmap\n-close_addressof_down (int uid)\n-{\n-  bitmap_iterator bi;\n-  splay_tree_node result =\n-    splay_tree_lookup (uid_to_addressof_down_map, (splay_tree_key) uid);\n-  bitmap map = NULL;\n-  bitmap new_map;\n-  unsigned int i;\n-\n-  if (result)\n-    map = (bitmap) result->value;\n-  else\n-    return NULL;\n-\n-  if (!bitmap_set_bit (been_there_done_that, uid))\n-    return map;\n-\n-  /* If the type escapes, get rid of the addressof map, it will not be\n-     needed.  */\n-  if (bitmap_bit_p (global_types_full_escape, uid))\n-    {\n-      BITMAP_FREE (map);\n-      splay_tree_remove (uid_to_addressof_down_map, (splay_tree_key) uid);\n-      return NULL;\n-    }\n-\n-  /* The new_map will have all of the bits for the enclosed fields and\n-     will have the unique id version of the old map.  */\n-  new_map = BITMAP_ALLOC (&ipa_obstack);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (map, 0, i, bi)\n-    {\n-      bitmap submap = close_addressof_down (i);\n-      bitmap_set_bit (new_map, i);\n-      if (submap)\n-\tbitmap_ior_into (new_map, submap);\n-    }\n-  result->value = (splay_tree_value) new_map;\n-\n-  BITMAP_FREE (map);\n-  return new_map;\n-}\n-\n-\f\n-/* The main entry point for type escape analysis.  */\n-\n-static unsigned int\n-type_escape_execute (void)\n-{\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n-  unsigned int i;\n-  bitmap_iterator bi;\n-  splay_tree_node result;\n-\n-  ipa_init ();\n-\n-  /* Process all of the variables first.  */\n-  FOR_EACH_STATIC_VARIABLE (vnode)\n-    analyze_variable (vnode);\n-\n-  /* Process all of the functions next.\n-\n-     We do not want to process any of the clones so we check that this\n-     is a master clone.  However, we do need to process any\n-     AVAIL_OVERWRITABLE functions (these are never clones) because\n-     they may cause a type variable to escape.\n-  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && !node->clone_of)\n-      analyze_function (node);\n-\n-\n-  pointer_set_destroy (visited_nodes);\n-  visited_nodes = NULL;\n-\n-  /* Do all of the closures to discover which types escape the\n-     compilation unit.  */\n-\n-  been_there_done_that = BITMAP_ALLOC (&ipa_obstack);\n-  bitmap_tmp = BITMAP_ALLOC (&ipa_obstack);\n-\n-  /* Examine the types that we have directly seen in scanning the code\n-     and add to that any contained types or superclasses.  */\n-\n-  bitmap_copy (bitmap_tmp, global_types_seen);\n-  EXECUTE_IF_SET_IN_BITMAP (bitmap_tmp, 0, i, bi)\n-    {\n-      tree type = type_for_uid (i);\n-      /* Only look at records and unions and pointer tos.  */\n-      if (ipa_type_escape_star_count_of_interesting_or_array_type (type) >= 0)\n-\tclose_type_seen (type);\n-    }\n-  bitmap_clear (been_there_done_that);\n-\n-  /* Examine all of the types passed by value and mark any enclosed\n-     pointer types as escaping.  */\n-  bitmap_copy (bitmap_tmp, global_types_exposed_parameter);\n-  EXECUTE_IF_SET_IN_BITMAP (bitmap_tmp, 0, i, bi)\n-    {\n-      close_type_exposed_parameter (type_for_uid (i));\n-    }\n-  bitmap_clear (been_there_done_that);\n-\n-  /* Close the types for escape.  If something escapes, then any\n-     enclosed types escape as well as any subtypes.  */\n-  bitmap_copy (bitmap_tmp, global_types_full_escape);\n-  EXECUTE_IF_SET_IN_BITMAP (bitmap_tmp, 0, i, bi)\n-    {\n-      close_type_full_escape (type_for_uid (i));\n-    }\n-  bitmap_clear (been_there_done_that);\n-\n-  /* Before this pass, the uid_to_addressof_down_map for type X\n-     contained an entry for Y if there had been an operation of the\n-     form &X.Y.  This step adds all of the fields contained within Y\n-     (recursively) to X's map.  */\n-\n-  result = splay_tree_min (uid_to_addressof_down_map);\n-  while (result)\n-    {\n-      int uid = result->key;\n-      /* Close the addressof map, i.e. copy all of the transitive\n-\t substructures up to this level.  */\n-      close_addressof_down (uid);\n-      result = splay_tree_successor (uid_to_addressof_down_map, uid);\n-    }\n-\n-  /* Do not need the array types and pointer types in the persistent\n-     data structures.  */\n-  result = splay_tree_min (all_canon_types);\n-  while (result)\n-    {\n-      tree type = (tree) result->value;\n-      tree key = (tree) result->key;\n-      if (POINTER_TYPE_P (type)\n-\t  || TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  splay_tree_remove (all_canon_types, (splay_tree_key) result->key);\n-\t  splay_tree_remove (type_to_canon_type, (splay_tree_key) type);\n-\t  splay_tree_remove (uid_to_canon_type, (splay_tree_key) TYPE_UID (type));\n-\t  bitmap_clear_bit (global_types_seen, TYPE_UID (type));\n-\t}\n-      result = splay_tree_successor (all_canon_types, (splay_tree_key) key);\n-    }\n-\n-  if (dump_file)\n-    {\n-      EXECUTE_IF_SET_IN_BITMAP (global_types_seen, 0, i, bi)\n-\t{\n-\t  /* The pointer types are in the global_types_full_escape\n-\t     bitmap but not in the backwards map.  They also contain\n-\t     no useful information since they are not marked.  */\n-\t  tree type = type_for_uid (i);\n-\t  fprintf(dump_file, \"type %d \", i);\n-\t  print_generic_expr (dump_file, type, 0);\n-\t  if (bitmap_bit_p (global_types_full_escape, i))\n-\t    fprintf(dump_file, \" escaped\\n\");\n-\t  else\n-\t    fprintf(dump_file, \" contained\\n\");\n-\t}\n-    }\n-\n-  /* Get rid of uid_to_addressof_up_map and its bitmaps.  */\n-  result = splay_tree_min (uid_to_addressof_up_map);\n-  while (result)\n-    {\n-      int uid = (int)result->key;\n-      bitmap bm = (bitmap)result->value;\n-\n-      BITMAP_FREE (bm);\n-      splay_tree_remove (uid_to_addressof_up_map, (splay_tree_key) uid);\n-      result = splay_tree_successor (uid_to_addressof_up_map, uid);\n-    }\n-\n-  /* Get rid of the subtype map.  */\n-  result = splay_tree_min (uid_to_subtype_map);\n-  while (result)\n-    {\n-      bitmap b = (bitmap)result->value;\n-      BITMAP_FREE(b);\n-      splay_tree_remove (uid_to_subtype_map, result->key);\n-      result = splay_tree_min (uid_to_subtype_map);\n-    }\n-  splay_tree_delete (uid_to_subtype_map);\n-  uid_to_subtype_map = NULL;\n-\n-  BITMAP_FREE (global_types_exposed_parameter);\n-  BITMAP_FREE (been_there_done_that);\n-  BITMAP_FREE (bitmap_tmp);\n-  return 0;\n-}\n-\n-static bool\n-gate_type_escape_vars (void)\n-{\n-  return flag_ipa_struct_reorg && flag_whole_program && (optimize > 0);\n-}\n-\n-struct simple_ipa_opt_pass pass_ipa_type_escape =\n-{\n- {\n-  SIMPLE_IPA_PASS,\n-  \"type-escape-var\",\t\t\t/* name */\n-  gate_type_escape_vars,\t\t/* gate */\n-  type_escape_execute,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_IPA_TYPE_ESCAPE,\t        \t/* tv_id */\n-  0,\t                                /* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};"}, {"sha": "0cb9a248bc3f3dde40ade82e2c8a2dffe17b18d6", "filename": "gcc/ipa-type-escape.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-type-escape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Fipa-type-escape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.h?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,34 +0,0 @@\n-/* Type based alias analysis.\n-   Copyright (C) 2004, 2007, 2008 Free Software Foundation, Inc.\n-   Contributed by Kenneth Zadeck <zadeck@naturalbridge.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_IPA_TYPE_ESCAPE_H\n-#define GCC_IPA_TYPE_ESCAPE_H\n-#include \"tree.h\"\n-\n-bool   ipa_type_escape_type_contained_p (tree type);\n-bool   ipa_type_escape_field_does_not_clobber_p (tree, tree);\n-int    ipa_type_escape_star_count_of_interesting_type (tree type);\n-int    ipa_type_escape_star_count_of_interesting_or_array_type (tree type);\n-bool   is_array_access_through_pointer_and_index (enum tree_code, tree, tree,\n-\t\t\t\t\t\t  tree *, tree *, gimple *);\n-\n-\n-#endif  /* GCC_IPA_TYPE_ESCAPE_H  */\n-"}, {"sha": "2c4e7da007294773013b7f8f6f330e05f0087a23", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -777,7 +777,6 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n     {\n       /* These passes are not WHOPR compatible yet.  */\n       opts->x_flag_ipa_pta = 0;\n-      opts->x_flag_ipa_struct_reorg = 0;\n     }\n \n   if (opts->x_flag_lto)"}, {"sha": "af304a2cbd83dccba4ab23ab94f3b0b91666024a", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -39,16 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n \n    Be sure to add an entry to invoke.texi summarizing the parameter.  */\n \n-/* The threshold ratio between current and hottest structure counts.\n-   We say that if the ratio of the current structure count,\n-   calculated by profiling, to the hottest structure count\n-   in the program is less than this parameter, then structure\n-   reorganization is not applied. The default is 10%.  */\n-DEFPARAM (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO,\n-\t  \"struct-reorg-cold-struct-ratio\",\n-\t  \"The threshold ratio between current and hottest structure counts\",\n-\t  10, 0, 100)\n-\n /* When branch is predicted to be taken with probability lower than this\n    threshold (in percent), then it is considered well predictable. */\n DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,"}, {"sha": "c4c12a4f9007c0b69d31a87970cc1fb3b9413d91", "filename": "gcc/params.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -118,8 +118,6 @@ extern int default_param_value (compiler_param num);\n extern void init_param_values (int *params);\n \n /* Macros for the various parameters.  */\n-#define STRUCT_REORG_COLD_STRUCT_RATIO \\\n-  PARAM_VALUE (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO)\n #define MAX_INLINE_INSNS_SINGLE \\\n   PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)\n #define MAX_INLINE_INSNS \\"}, {"sha": "42a323981f778c98272ec6680414cfe2814003d6", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -798,9 +798,7 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n   NEXT_PASS (pass_ipa_reference);\n-  NEXT_PASS (pass_ipa_type_escape);\n   NEXT_PASS (pass_ipa_pta);\n-  NEXT_PASS (pass_ipa_struct_reorg);\n   *p = NULL;\n \n   p = &all_lto_gen_passes;"}, {"sha": "e6d799d2b06542ce559a9644658c803aa37c814c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -1,3 +1,7 @@\n+2011-03-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/struct: Remove directory and contents.\n+\n 2011-03-23  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR testsuite/48251"}, {"sha": "a18b11d15802fdc1bf01338e83d928e8a20d8cc0", "filename": "gcc/testsuite/gcc.dg/struct/struct-reorg.exp", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fstruct-reorg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fstruct-reorg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fstruct-reorg.exp?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,75 +0,0 @@\n-#   Copyright (C) 2007, 2008, 2009, 2010\n-#   Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this program; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Test the functionality of programs compiled with profile-directed structure\n-# rearrangement using -fprofile-generate followed by -fprofile-use.\n-\n-load_lib gcc-dg.exp\n-load_lib target-supports.exp\n-\n-set STRUCT_REORG_CFLAGS \"-O3 -fipa-struct-reorg -fdump-ipa-all -fwhole-program\"\n-\n-# Initialize `dg'.\n-dg-init\n-\n-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/wo_prof_*.c]] \"\" $STRUCT_REORG_CFLAGS\n-\n-dg-final\n-\n-# Some targets don't support tree profiling.\n-if { ![check_profiling_available \"\"] } {\n-    return\n-}\n-\n-# The procedures in profopt.exp need these parameters.\n-set tool gcc\n-set prof_ext \"gcda\"\n-\n-# Override the list defined in profopt.exp.\n-set PROFOPT_OPTIONS [list {}]\n-\n-if $tracelevel then {\n-    strace $tracelevel\n-}\n-\n-# Load support procs.\n-load_lib profopt.exp\n-\n-# These are globals used by profopt-execute.  The first is options\n-# needed to generate profile data, the second is options to use the\n-# profile data.\n-set common \"-O3 -fwhole-program\"\n-set profile_option [concat $common \" -fprofile-generate\"]\n-set feedback_option [concat $common \" -fprofile-use -fipa-struct-reorg -fdump-ipa-all\"]\n-\n-foreach src [lsort [glob -nocomplain $srcdir/$subdir/w_prof_*.c]] {\n-    # If we're only testing specific files and this isn't one of them, skip it.\n-    if ![runtest_file_p $runtests $src] then {\n-        continue\n-    }\n-    profopt-execute $src\n-}\n-\n-set feedback_option [concat $feedback_option \" --param struct-reorg-cold-struct-ratio=30\"]\n-\n-foreach src [lsort [glob -nocomplain $srcdir/$subdir/w_ratio_*.c]] {\n-    # If we're only testing specific files and this isn't one of them, skip it.\n-    if ![runtest_file_p $runtests $src] then {\n-        continue\n-    }\n-    profopt-execute $src\n-}"}, {"sha": "ca3643e43de7558531f08e3dfb1a232658112ab6", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_global_array.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,30 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#define N 1000\n-str_t A[N];\n-\n-int\n-main ()\n-{\n-  int i;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      A[i].a = 0;\n-    }\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].a != 0) \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "baff45d917db1f7ccd7f1105abdcf3ae6da38788", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_global_var.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,43 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-str_t *p;\n-\n-int\n-main ()\n-{\n-  int i, sum;\n-\n-  p = malloc (N * sizeof (str_t));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    p[i].b = i;\n-\n-  for (i = 0; i < N; i++)\n-    p[i].a = p[i].b + 1;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].a != p[i].b + 1)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "8953264fea19d22047a5b814eccb88de4230baa8", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_local_array.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,38 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i;\n-  str_t A[N];\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      A[i].a = 0;\n-    }\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].a != 0) \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "9a23f8d53a8bd6c1a2f2c6258e1b1595b5b65f0b", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_local_var.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,41 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i, sum;\n-\n-  str_t * p = malloc (N * sizeof (str_t));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    p[i].b = i;\n-\n-  for (i = 0; i < N; i++)\n-    p[i].a = p[i].b + 1;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].a != p[i].b + 1)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "b020239910434fbe826908ff3f83b24a09640072", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_single_str_global.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,33 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int b;\n-}str_t;\n-\n-#define N 3\n-\n-str_t str;\n-\n-int\n-main ()\n-{\n-  int i;\n-  int res = 1<<(1<<N);\n-  str.a = 2;\n-\n-  for (i = 0; i < N; i++)\n-      str.a = str.a * str.a;\n-  \n-  if (str.a != res)\n-    abort ();\n-\n-  /* POSIX ignores all but the 8 low-order bits, but other\n-     environments may not.  */\n-  return (str.a & 255);\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */\n-"}, {"sha": "e9de98c3b8a9b7736712be7453a41609a7d7c69a", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_two_strs.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,66 +0,0 @@\n-#include <stdlib.h>\n-\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t1;\n-\n-typedef struct\n-{\n-  int c;\n-  float d;\n-}str_t2;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 16000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/16)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-str_t1 *p1;\n-str_t2 *p2;\n-int num;\n-\n-void\n-foo (void)\n-{\n-  int i;\n-\n-  for (i=0; i < num; i++)\n-    p2[i].c = 2;\n-}\n-\n-int\n-main ()\n-{\n-  int i, r;\n-\n-  r = rand ();\n-  num = r > N ? N : r; \n-  p1 = malloc (num * sizeof (str_t1));\n-  p2 = malloc (num * sizeof (str_t2));\n-\n-  if (p1 == NULL || p2 == NULL)\n-    return 0;\n-\n-  for (i = 0; i < num; i++)\n-    p1[i].a = 1;\n-\n-  foo ();\n-\n-  for (i = 0; i < num; i++)\n-    if (p1[i].a != 1 || p2[i].c != 2)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */\n-"}, {"sha": "3c26e3be7b67c5f110e966aab6f4a41a495383df", "filename": "gcc/testsuite/gcc.dg/struct/w_ratio_cold_str.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,43 +0,0 @@\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int b;\n-}str_t1;\n-\n-typedef struct\n-{\n-  float a;\n-  float b;\n-}str_t2;\n-\n-#define N1 1000\n-#define N2 100\n-str_t1 A1[N1];\n-str_t2 A2[N2];\n-\n-int\n-main ()\n-{\n-  int i;\n-\n-  for (i = 0; i < N1; i++)\n-    A1[i].a = 0;\n-\n-  for (i = 0; i < N2; i++)\n-    A2[i].a = 0;\n-\n-  for (i = 0; i < N1; i++)\n-    if (A1[i].a != 0) \n-      abort ();\n-\n-  for (i = 0; i < N2; i++)\n-    if (A2[i].a != 0) \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "5d5e37b4f0e6b831bc06f4bed6e3c552adfeecac", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_array_field.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,27 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct basic\n-{\n-  int a;\n-  int b[10];\n-} type_struct;\n-\n-type_struct *str1;\n-\n-int main()\n-{\n-  int i;\n-\n-  str1 = malloc (10 * sizeof (type_struct));\n-\n-  for (i=0; i<=9; i++)\n-    str1[i].a = str1[i].b[0];\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "efb68be8bdd7da7883e1c01f594c24686c5dd689", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_array_through_pointer.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,39 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i;\n-  str_t A[N];\n-  str_t *p = A;\n-\n-  for (i = 0; i < N; i++)\n-    p[i].a = 0;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].a != 0)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "77226b449c5d7fcd22e7b6569b5e500cd47972fd", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_double_malloc.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,30 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-typedef struct test_struct\n-{\n-  int a;\n-  int b;\n-} type_struct;\n-\n-typedef type_struct **struct_pointer2;\n-\n-struct_pointer2 str1;\n-\n-int main()\n-{\n-  int i, j;\n-\n-  str1 = malloc (2 * sizeof (type_struct *));\n-\n-  for (i = 0; i <= 1; i++)\n-    str1[i] = malloc (2 * sizeof (type_struct));\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "09668face34d18c063911c1da8567dd9e60a0338", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_empty_str.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,45 +0,0 @@\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-struct S { int a; struct V *b; };\n-typedef struct { int c; } T;\n-typedef struct { int d; int e; } U;\n-\n-void * \n-fn (void *x) \n-{\n-  return x;\n-}\n-\n-int\n-foo (struct S *s)\n-{\n-  T x;\n-  \n-  T y = *(T *)fn (&x);\n-  return y.c;\n-}\n-\n-int\n-bar (struct S *s)\n-{\n-  U x;\n-  \n-  U y = *(U *)fn (&x);\n-  return y.d + s->a;\n-}\n-\n-int \n-main ()\n-{\n-  struct S s;\n-\n-  foo(&s) + bar (&s);\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "0116d819800c32fdc64a7b57eec581d48ac17d66", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_arg_to_local.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-struct str\n-{\n-  int a;\n-  float b;\n-};\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-foo (struct str * p_str)\n-{\n-  static int sum = 0;\n-\n-  sum = sum + p_str->a;\n-  return sum;\n-}\n-\n-int\n-main ()\n-{\n-  int i, sum;\n-  struct str * p = malloc (N * sizeof (struct str));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    sum = foo (p+i);\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is passed to local function...Excluded.\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "21a6a7f3a2e04a8cd6fd295fc1ad9896a73e0702", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_return.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,31 +0,0 @@\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-struct A {\n-  int d;\n-};\n-\n-struct A a;\n-\n-struct A foo ()\n-{\n-  a.d = 5;\n-  return a;\n-}\n-\n-int\n-main ()\n-{\n-  a.d = 0;\n-  foo ();\n-\n-  if (a.d != 5)\n-    abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is return type of function...Excluded\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "6da3420f6e88ac1e29a13d6ca13ecdce004badb7", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_str_init.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,33 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int b;\n-}str_t;\n-\n-#define N 2\n-\n-str_t A[2] = {{1,1},{2,2}};\n-\n-int\n-main ()\n-{\n-  int i;\n-\n-  for (i = 0; i < N; i++)\n-    A[i].b = A[i].a;\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].b != A[i].a)\n-      abort ();\n-  \n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is initialized...Excluded\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */\n-"}, {"sha": "bd03ec42f0534a905ce6ec570d1b5f796043eded", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_array.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,34 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#define N 1000\n-\n-typedef struct \n-{\n-  str_t A[N];\n-  int c;\n-}str_with_substr_t;\n-\n-str_with_substr_t a;\n-\n-int\n-main ()\n-{\n-  int i;\n-  \n-  for (i = 0; i < N; i++)\n-    a.A[i].b = 0;\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "59e0e48321a5052bb95504a794d1837944bfce43", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_pointer.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,49 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 16000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/16)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-typedef struct \n-{\n-  str_t * sub_str;\n-  int c;\n-}str_with_substr_t;\n-\n-int foo;\n-\n-int\n-main (void)\n-{\n-  int i;\n-  str_with_substr_t A[N];\n-  str_t a[N];\n-\n-  for (i=0; i < N; i++)\n-    A[i].sub_str = &(a[i]);\n-\n-  for (i=0; i < N; i++)\n-    A[i].sub_str->a = 5;\n-\n-  foo = A[56].sub_str->a;\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "a6b32ddd688c3dd28c2e05569f7edaea60d273ce", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_value.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-\n-typedef struct \n-{\n-  str_t sub_str;\n-  int c;\n-}str_with_substr_t;\n-\n-int\n-main ()\n-{\n-  int i;\n-  str_with_substr_t A[N];\n-\n-  for (i = 0; i < N; i++)\n-    A[i].sub_str.a = 5;\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].sub_str.a != 5)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "b61e26b12484dbff4654afa2f7953e10afacbc21", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_global_array.c", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,33 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#define N 1000\n-str_t A[N];\n-\n-int\n-main ()\n-{\n-  int i;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      A[i].a = 0;\n-    }\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].a != 0) \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "39351e072e2901af8898aaf0da55dc3f1a1255b4", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_global_var.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,46 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-str_t *p;\n-\n-int\n-main ()\n-{\n-  int i, sum;\n-\n-  p = malloc (N * sizeof (str_t));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    p[i].b = i;\n-\n-  for (i = 0; i < N; i++)\n-    p[i].b = p[i].a + 1;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].b != p[i].a + 1)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "18d5a734740e713be2503085bb04cbaff0d934d5", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_local_array.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,41 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i;\n-  str_t A[N];\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      A[i].a = 0;\n-    }\n-\n-  for (i = 0; i < N; i++)\n-    if (A[i].a != 0) \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "26a9dbd731430d826e4a2291a4dde887c43dfe40", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_local_var.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i, sum;\n-\n-  str_t * p = malloc (N * sizeof (str_t));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    p[i].b = i;\n-\n-  for (i = 0; i < N; i++)\n-    p[i].b = p[i].a + 1;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].b != p[i].a + 1)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "6caadcf12305ace627fcda1e117bd853cdc2a943", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_malloc_size_var.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 8000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/8)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-int\n-main ()\n-{\n-  int i, num;\n-\n-  num = rand();\n-  num = num > N ? N : num; \n-  str_t * p = malloc (num * sizeof (str_t));\n-\n-  if (p == 0)\n-    return 0;\n-\n-  for (i = 0; i < num; i++)\n-    p[i].b = i;\n-\n-  for (i = 0; i < num; i++)\n-    p[i].a = p[i].b + 1;\n-\n-  for (i = 0; i < num; i++)\n-    if (p[i].a != p[i].b + 1)\n-      abort ();\n-  \n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "8f116df4d014a08c069da6f9966d198f65ffac32", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_mult_field_peeling.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_mult_field_peeling.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_mult_field_peeling.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_mult_field_peeling.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,43 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  float b;\n-  int c;\n-  float d;\n-}str_t;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 1600\n-#define N 100\n-#else\n-#define N (STACK_SIZE/16)\n-#endif\n-#else\n-#define N 100\n-#endif\n-\n-int \n-main ()\n-{\n-  int i;\n-  str_t *p = malloc (N * sizeof (str_t));\n-  if (p == NULL)\n-    return 0;\n-  for (i = 0; i < N; i++)\n-    p[i].a = 5;\n-\n-  for (i = 0; i < N; i++)\n-    if (p[i].a != 5)      \n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* The structure str_t is erroneously peeled into 4 structures instead of 2.  */\n-/* { dg-final { scan-ipa-dump \"the number of new types is 2\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "812763d53ff846f55814a4fb388a8daa1427a426", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_single_str_global.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int b;\n-}str_t;\n-\n-#define N 3\n-\n-str_t str;\n-\n-int\n-main ()\n-{\n-  int i;\n-  int res = 1<<(1<<N);\n-  str.a = 2;\n-\n-  for (i = 0; i < N; i++)\n-    str.a = str.a * str.a;\n-  \n-  if (str.a != res)\n-    abort ();\n-\n-  /* POSIX ignores all but the 8 low-order bits, but other\n-     environments may not.  */\n-  return (str.a & 255);\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "313af1080c1d293c5c9049b769ffae064ce0a810", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_single_str_local.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int b;\n-}str_t;\n-\n-#define N 3\n-\n-int\n-main ()\n-{\n-  int i;\n-  int res = 1<<(1<<N);\n-  str_t str;\n-  \n-  str.a = 2;\n-\n-  for (i = 0; i < N; i++)\n-    str.a = str.a * str.a;\n-  \n-  if (str.a != res)\n-    abort ();\n-\n-  /* POSIX ignores all but the 8 low-order bits, but other\n-     environments may not.  */\n-  return (str.a & 255);\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "bd70dfb63756ba9b216e65c4d8dd72e677b24346", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_single_str_pointer.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_pointer.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,40 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-typedef struct\n-{\n-  int a;\n-  int *b;\n-}str_t;\n-\n-#define N 3\n-\n-str_t *p;\n-\n-int\n-main ()\n-{\n-  str_t str;\n-  int i;\n-  int res = 1 << (1 << N);\n-  p = &str;\n-  str.a = 2;\n- \n-  p->b = &(p->a);\n-\n-  for (i=0; i < N; i++)\n-    p->a = *(p->b)*(*(p->b));\n-\n-  if (p->a != res)\n-    abort ();\n-  \n-  /* POSIX ignores all but the 8 low-order bits, but other\n-     environments may not.  */\n-  return (p->a & 255);\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* The access &(p->a) is handled incorrectly in ipa-struct-reorg.c.  */\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "92da94d29239df51ebc80178c6b6fc27c270b471", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_two_strs.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fb503382f36106a942801ad3563821011f4609/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c?ref=40fb503382f36106a942801ad3563821011f4609", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run } */\n-\n-#include <stdlib.h>\n-\n-typedef struct\n-{\n-  int a;\n-  float b;\n-}str_t1;\n-\n-typedef struct\n-{\n-  int c;\n-  float d;\n-}str_t2;\n-\n-#ifdef STACK_SIZE\n-#if STACK_SIZE > 16000\n-#define N 1000\n-#else\n-#define N (STACK_SIZE/16)\n-#endif\n-#else\n-#define N 1000\n-#endif\n-\n-str_t1 *p1;\n-str_t2 *p2;\n-int num;\n-\n-void\n-foo (void)\n-{\n-  int i;\n-\n-  for (i=0; i < num; i++)\n-    p2[i].c = 2;\n-}\n-\n-int\n-main ()\n-{\n-  int i, r;\n-\n-  r = rand ();\n-  num = r > N ? N : r; \n-  p1 = malloc (num * sizeof (str_t1));\n-  p2 = malloc (num * sizeof (str_t2));\n-\n-  if (p1 == NULL || p2 == NULL)\n-    return 0;\n-\n-  for (i = 0; i < num; i++)\n-    p1[i].a = 1;\n-\n-  foo ();\n-\n-  for (i = 0; i < num; i++)\n-    if (p1[i].a != 1 || p2[i].c != 2)\n-      abort ();\n-\n-  return 0;\n-}\n-\n-/*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "cd306b83277571698cde8682a82bfefdd723568a", "filename": "gcc/timevar.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -70,7 +70,6 @@ DEFTIMEVAR (TV_WHOPR_WPA_LTRANS_EXEC , \"whopr wpa->ltrans\")\n DEFTIMEVAR (TV_IPA_REFERENCE         , \"ipa reference\")\n DEFTIMEVAR (TV_IPA_PROFILE           , \"ipa profile\")\n DEFTIMEVAR (TV_IPA_PURE_CONST        , \"ipa pure const\")\n-DEFTIMEVAR (TV_IPA_TYPE_ESCAPE       , \"ipa type escape\")\n DEFTIMEVAR (TV_IPA_PTA               , \"ipa points-to\")\n DEFTIMEVAR (TV_IPA_SRA               , \"ipa SRA\")\n DEFTIMEVAR (TV_IPA_FREE_LANG_DATA    , \"ipa free lang data\")"}, {"sha": "9520c178c967244fa07eb2cc936b8e241ad83b2a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -463,9 +463,7 @@ extern struct simple_ipa_opt_pass pass_ipa_free_lang_data;\n extern struct ipa_opt_pass_d pass_ipa_cp;\n extern struct ipa_opt_pass_d pass_ipa_reference;\n extern struct ipa_opt_pass_d pass_ipa_pure_const;\n-extern struct simple_ipa_opt_pass pass_ipa_type_escape;\n extern struct simple_ipa_opt_pass pass_ipa_pta;\n-extern struct simple_ipa_opt_pass pass_ipa_struct_reorg;\n extern struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup;\n extern struct ipa_opt_pass_d pass_ipa_lto_finish_out;\n extern struct ipa_opt_pass_d pass_ipa_profile;"}, {"sha": "f7fc7d2088152bd9d619a61c2abcbefe519fd911", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8beb4d13e5c51a50507cb2be345773fa162fce7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b8beb4d13e5c51a50507cb2be345773fa162fce7", "patch": "@@ -40,7 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"convert.h\"\n #include \"params.h\"\n-#include \"ipa-type-escape.h\"\n #include \"vec.h\"\n #include \"bitmap.h\"\n #include \"vecprim.h\""}]}