{"sha": "293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkzYTM2ZWJmMTBkODliN2JjOTk0ZTE4YTRkMDFiODRiNmViOTFiNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-16T02:33:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-10-16T02:33:42Z"}, "message": "Add support for MIPS EABI\n\nFrom-SVN: r12967", "tree": {"sha": "1e3ffde52d130ff4fe9d1f1fa17405cfa94b7185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e3ffde52d130ff4fe9d1f1fa17405cfa94b7185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/comments", "author": null, "committer": null, "parents": [{"sha": "03f0080698eaee3275b1e8c805ced10889ed7674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f0080698eaee3275b1e8c805ced10889ed7674", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f0080698eaee3275b1e8c805ced10889ed7674"}], "stats": {"total": 366, "additions": 307, "deletions": 59}, "files": [{"sha": "df6eec664c55fe4fbd71bf7f566a9c33344de0b8", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 106, "deletions": 25, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "patch": "@@ -26,11 +26,14 @@ Boston, MA 02111-1307, USA.  */\n   { \"abi=\", &mips_abi_string\t},\n \n #undef STACK_BOUNDARY\n-#define STACK_BOUNDARY (mips_abi == ABI_32 ? 64 : 128)\n+#define STACK_BOUNDARY \\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_EABI) ? 64 : 128)\n \n #undef MIPS_STACK_ALIGN\n-#define MIPS_STACK_ALIGN(LOC) \\\n-  (mips_abi == ABI_32 ? ((LOC)+7) & ~7 : ((LOC)+15) & ~15)\n+#define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_EABI)\t\t\t\\\n+   ? ((LOC) + 7) & ~7\t\t\t\t\t\t\\\n+   : ((LOC) + 15) & ~15)\n \n #undef GP_ARG_LAST\n #define GP_ARG_LAST  (mips_abi == ABI_32 ? GP_REG_FIRST + 7 : GP_REG_FIRST + 11)\n@@ -78,13 +81,16 @@ Boston, MA 02111-1307, USA.  */\n        ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n \t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n        : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n-\t  && (mips_abi == ABI_32 || GET_MODE_CLASS (MODE) == MODE_INT)))\\\n+\t  && (mips_abi == ABI_32 || mips_abi == ABI_EABI\t\t\\\n+\t      || GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n       ? downward : upward))\n \n #undef RETURN_IN_MEMORY\n-#define RETURN_IN_MEMORY(TYPE)\t\\\n+#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n   (mips_abi == ABI_32\t\t\t\t\t\t\t\\\n-   ? TYPE_MODE (TYPE) == BLKmode : int_size_in_bytes (TYPE) > 16)\n+   ? TYPE_MODE (TYPE) == BLKmode\t\t\t\t\t\\\n+   : (int_size_in_bytes (TYPE)\t\t\t\t\t\t\\\n+      > (mips_abi == ABI_EABI ? 2 * UNITS_PER_WORD : 16)))\n \n extern struct rtx_def *mips_function_value ();\n #undef FUNCTION_VALUE\n@@ -95,36 +101,111 @@ extern struct rtx_def *mips_function_value ();\n    For stdarg, we do not need to save the current argument, because it\n    is a real argument.  */\n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{ if (mips_abi != ABI_32\t\t\t\t\t\t\\\n-      && ((CUM).arg_words\t\t\t\t\t\t\\\n-\t  < (MAX_ARGS_IN_REGISTERS - ! current_function_varargs)))\t\\\n+{ int mips_off = (! current_function_varargs) && (! (CUM).last_arg_fp);\t\\\n+  int mips_fp_off = (! current_function_varargs) && ((CUM).last_arg_fp); \\\n+  if ((mips_abi != ABI_32\t\t\t\t\t\t\\\n+       && (CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\t\\\n+      || (mips_abi == ABI_EABI\t\t\t\t\t\t\\\n+\t  && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t  && (CUM).fp_arg_words < MAX_ARGS_IN_REGISTERS - mips_fp_off))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      PRETEND_SIZE\t\t\t\t\t\t\t\\\n-\t= (MAX_ARGS_IN_REGISTERS - (CUM).arg_words\t\t\t\\\n-\t   - ! current_function_varargs) * UNITS_PER_WORD;\t\t\\\n+      int mips_save_gp_regs =\t\t\t\t\t\t\\\n+        MAX_ARGS_IN_REGISTERS - (CUM).arg_words - mips_off;\t\t\\\n+      int mips_save_fp_regs =\t\t\t\t\t\t\\\n+        (mips_abi != ABI_EABI ? 0\t\t\t\t\t\\\n+\t : MAX_ARGS_IN_REGISTERS - (CUM).fp_arg_words - mips_fp_off);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (mips_save_gp_regs < 0)\t\t\t\t\t\\\n+\tmips_save_gp_regs = 0;\t\t\t\t\t\t\\\n+      if (mips_save_fp_regs < 0)\t\t\t\t\t\\\n+\tmips_save_fp_regs = 0;\t\t\t\t\t\t\\\n+      PRETEND_SIZE = ((mips_save_gp_regs * UNITS_PER_WORD)\t\t\\\n+\t\t      + (mips_save_fp_regs * UNITS_PER_FPREG));\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (! (NO_RTL))\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  rtx mem = gen_rtx (MEM, BLKmode, virtual_incoming_args_rtx);\t\\\n-\t  /* va_arg is an array access in this case, which causes it to \\\n-\t     get MEM_IN_STRUCT_P set.  We must set it here so that the\t\\\n-\t     insn scheduler won't assume that these stores can't \t\\\n-\t     possibly overlap with the va_arg loads.  */\t\t\\\n-\t  if (BYTES_BIG_ENDIAN)\t\t\t\t\t\t\\\n-\t    MEM_IN_STRUCT_P (mem) = 1;\t\t\t\t\t\\\n-\t  move_block_from_reg\t\t\t\t\t\t\\\n-\t    ((CUM).arg_words + GP_ARG_FIRST + ! current_function_varargs, \\\n-\t     mem,\t\t\t\t\t\t\t\\\n-\t     (MAX_ARGS_IN_REGISTERS - (CUM).arg_words\t\t\t\\\n-\t      - ! current_function_varargs),\t\t\t\t\\\n-\t     PRETEND_SIZE);\t\t\t\t\t\t\\\n+\t  if ((CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      rtx ptr, mem;\t\t\t\t\t\t\\\n+\t      if (mips_abi != ABI_EABI)\t\t\t\t\t\\\n+\t\tptr = virtual_incoming_args_rtx;\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tptr = plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t     - (mips_save_gp_regs\t\t\\\n+\t\t\t\t\t* UNITS_PER_WORD));\t\t\\\n+\t      mem = gen_rtx (MEM, BLKmode, ptr);\t\t\t\\\n+\t      /* va_arg is an array access in this case, which causes\t\\\n+\t\t it to get MEM_IN_STRUCT_P set.  We must set it here\t\\\n+\t\t so that the insn scheduler won't assume that these\t\\\n+\t\t stores can't possibly overlap with the va_arg loads.  */ \\\n+\t      if (mips_abi != ABI_EABI && BYTES_BIG_ENDIAN)\t\t\\\n+\t        MEM_IN_STRUCT_P (mem) = 1;\t\t\t\t\\\n+\t      move_block_from_reg\t\t\t\t\t\\\n+\t\t((CUM).arg_words + GP_ARG_FIRST + mips_off,\t\t\\\n+\t\t mem,\t\t\t\t\t\t\t\\\n+\t\t mips_save_gp_regs,\t\t\t\t\t\\\n+\t\t mips_save_gp_regs * UNITS_PER_WORD);\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  if (mips_abi == ABI_EABI\t\t\t\t\t\\\n+\t      && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n+\t      && (CUM).fp_arg_words < MAX_ARGS_IN_REGISTERS - mips_fp_off) \\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int off;\t\t\t\t\t\t\t\\\n+\t      int i;\t\t\t\t\t\t\t\\\n+\t      /* We can't use move_block_from_reg, because it will use\t\\\n+                 the wrong mode.  */\t\t\t\t\t\\\n+\t      off = (- (mips_save_gp_regs * UNITS_PER_WORD)\t\t\\\n+\t\t     - (mips_save_fp_regs * UNITS_PER_FPREG));\t\t\\\n+\t      for (i = 0; i < mips_save_fp_regs; i++)\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  rtx tem =\t\t\t\t\t\t\\\n+\t\t    gen_rtx (MEM, DFmode,\t\t\t\t\\\n+\t\t\t     plus_constant (virtual_incoming_args_rtx,\t\\\n+\t\t\t\t\t    (off\t\t\t\\\n+\t\t\t\t\t     + i * GET_MODE_SIZE (DFmode)))); \\\n+\t\t  emit_move_insn (tem,\t\t\t\t\t\\\n+\t\t\t\t  gen_rtx (REG, DFmode,\t\t\t\\\n+\t\t\t\t\t   ((CUM).fp_arg_words\t\t\\\n+\t\t\t\t\t    + FP_ARG_FIRST\t\t\\\n+\t\t\t\t\t    + i\t\t\t\t\\\n+\t\t\t\t\t    + mips_fp_off)));\t\t\\\n+\t\t  if (! TARGET_FLOAT64)\t\t\t\t\t\\\n+\t\t    ++i;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n /* ??? Should disable for mips_abi == ABI32.  */\n #define STRICT_ARGUMENT_NAMING\n \n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of the\n+   argument itself.  The pointer is passed in whatever way is appropriate\n+   for passing a pointer to that type.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (mips_abi == ABI_EABI\t\t\t\t\t\t\t\\\n+   && function_arg_pass_by_reference (&CUM, MODE, TYPE, NAMED))\n+\n+/* A C expression that indicates when it is the called function's\n+   responsibility to make a copy of arguments passed by invisible\n+   reference.  Normally, the caller makes a copy and passes the\n+   address of the copy to the routine being called.  When\n+   FUNCTION_ARG_CALLEE_COPIES is defined and is nonzero, the caller\n+   does not make a copy.  Instead, it passes a pointer to the \"live\"\n+   value.  The called function must not modify this value.  If it can\n+   be determined that the value won't be modified, it need not make a\n+   copy; otherwise a copy must be made.\n+\n+   ??? The MIPS EABI says that the caller should copy in ``K&R mode.''\n+   I don't know how to detect that here, since flag_traditional is not\n+   a back end flag.  */\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n+  (mips_abi == ABI_EABI && (NAMED)\t\t\t\t\t\\\n+   && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n+\n /* ??? Unimplemented stuff follows.  */\n \n /* ??? Add support for 16 byte/128 bit long doubles here when"}, {"sha": "29a53ac760c6e31d27713b3ce19c8322c8e541d0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "patch": "@@ -201,7 +201,7 @@ enum mips_abi_type mips_abi;\n /* Strings to hold which cpu and instruction set architecture to use.  */\n char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n-char *mips_abi_string;\t\t/* for -mabi={o32,32,n32,n64,64} */\n+char *mips_abi_string;\t\t/* for -mabi={o32,32,n32,n64,64,eabi} */\n \n /* If TRUE, we split addresses into their high and low parts in the RTL.  */\n int mips_split_addresses;\n@@ -500,7 +500,7 @@ mips_const_double_ok (op, mode)\n     return TRUE;\n \n   /* ??? li.s does not work right with SGI's Irix 6 assembler.  */\n-  if (mips_abi != ABI_32)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_EABI)\n     return FALSE;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n@@ -3031,11 +3031,17 @@ function_arg_advance (cum, mode, type, named)\n       break;\n \n     case SFmode:\n-      cum->arg_words++;\n+      if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT)\n+\tcum->fp_arg_words++;\n+      else\n+\tcum->arg_words++;\n       break;\n \n     case DFmode:\n-      cum->arg_words += (TARGET_64BIT ? 1 : 2);\n+      if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT && ! TARGET_SINGLE_FLOAT)\n+\tcum->fp_arg_words += (TARGET_64BIT ? 1 : 2);\n+      else\n+\tcum->arg_words += (TARGET_64BIT ? 1 : 2);\n       break;\n \n     case DImode:\n@@ -3065,6 +3071,7 @@ function_arg (cum, mode, type, named)\n   rtx ret;\n   int regbase = -1;\n   int bias = 0;\n+  int *arg_words = &cum->arg_words;\n   int struct_p = ((type != (tree)0)\n \t\t  && (TREE_CODE (type) == RECORD_TYPE\n \t\t      || TREE_CODE (type) == UNION_TYPE));\n@@ -3075,6 +3082,7 @@ function_arg (cum, mode, type, named)\n \t     cum->gp_reg_found, cum->arg_number, cum->arg_words, GET_MODE_NAME (mode),\n \t     type, named);\n \n+  cum->last_arg_fp = 0;\n   switch (mode)\n     {\n     case SFmode:\n@@ -3091,20 +3099,43 @@ function_arg (cum, mode, type, named)\n \t\tbias = 1;\n \t    }\n \t}\n+      else if (mips_abi == ABI_EABI && ! TARGET_SOFT_FLOAT)\n+\t{\n+\t  if (! TARGET_64BIT)\n+\t    cum->fp_arg_words += cum->fp_arg_words & 1;\n+\t  cum->last_arg_fp = 1;\n+\t  arg_words = &cum->fp_arg_words;\n+\t  regbase = FP_ARG_FIRST;\n+\t}\n       else\n \tregbase = (TARGET_SOFT_FLOAT || ! named ? GP_ARG_FIRST : FP_ARG_FIRST);\n       break;\n \n     case DFmode:\n       if (! TARGET_64BIT)\n-\tcum->arg_words += (cum->arg_words & 1);\n+\t{\n+\t  if (mips_abi == ABI_EABI\n+\t      && ! TARGET_SOFT_FLOAT\n+\t      && ! TARGET_SINGLE_FLOAT)\n+\t    cum->fp_arg_words += cum->fp_arg_words & 1;\n+\t  else\n+\t    cum->arg_words += cum->arg_words & 1;\n+\t}\n       if (mips_abi == ABI_32)\n \tregbase = ((cum->gp_reg_found\n \t\t    || TARGET_SOFT_FLOAT\n \t\t    || TARGET_SINGLE_FLOAT\n \t\t    || cum->arg_number >= 2)\n \t\t   ? GP_ARG_FIRST\n \t\t   : FP_ARG_FIRST);\n+      else if (mips_abi == ABI_EABI\n+\t       && ! TARGET_SOFT_FLOAT\n+\t       && ! TARGET_SINGLE_FLOAT)\n+\t{\n+\t  cum->last_arg_fp = 1;\n+\t  arg_words = &cum->fp_arg_words;\n+\t  regbase = FP_ARG_FIRST;\n+\t}\n       else\n \tregbase = (TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT || ! named\n \t\t   ? GP_ARG_FIRST : FP_ARG_FIRST);\n@@ -3118,9 +3149,8 @@ function_arg (cum, mode, type, named)\n       /* Drops through.  */\n     case BLKmode:\n       if (type != (tree)0 && TYPE_ALIGN (type) > BITS_PER_WORD\n-\t  && ! TARGET_64BIT)\n+\t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n \tcum->arg_words += (cum->arg_words & 1);\n-\n       regbase = GP_ARG_FIRST;\n       break;\n \n@@ -3137,7 +3167,7 @@ function_arg (cum, mode, type, named)\n       regbase = GP_ARG_FIRST;\n     }\n \n-  if (cum->arg_words >= MAX_ARGS_IN_REGISTERS)\n+  if (*arg_words >= MAX_ARGS_IN_REGISTERS)\n     {\n       if (TARGET_DEBUG_E_MODE)\n \tfprintf (stderr, \"<stack>%s\\n\", struct_p ? \", [struct]\" : \"\");\n@@ -3150,8 +3180,8 @@ function_arg (cum, mode, type, named)\n \tabort ();\n \n       if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n-\t  || ! named)\n-\tret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+\t  || mips_abi == ABI_EABI || ! named)\n+\tret = gen_rtx (REG, mode, regbase + *arg_words + bias);\n       else\n \t{\n \t  /* The Irix 6 n32/n64 ABIs say that if any 64 bit chunk of the\n@@ -3169,7 +3199,7 @@ function_arg (cum, mode, type, named)\n \t      break;\n \n \t  if (! field)\n-\t    ret = gen_rtx (REG, mode, regbase + cum->arg_words + bias);\n+\t    ret = gen_rtx (REG, mode, regbase + *arg_words + bias);\n \t  else\n \t    {\n \t      /* Now handle the special case by returning a PARALLEL\n@@ -3188,15 +3218,15 @@ function_arg (cum, mode, type, named)\n \t\t backend to allow DImode values in fp registers.  */\n \n \t      chunks = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_WORD;\n-\t      if (chunks + cum->arg_words + bias > MAX_ARGS_IN_REGISTERS)\n-\t\tchunks = MAX_ARGS_IN_REGISTERS - cum->arg_words - bias;\n+\t      if (chunks + *arg_words + bias > MAX_ARGS_IN_REGISTERS)\n+\t\tchunks = MAX_ARGS_IN_REGISTERS - *arg_words - bias;\n \n \t      /* assign_parms checks the mode of ENTRY_PARM, so we must\n \t\t use the actual mode here.  */\n \t      ret = gen_rtx (PARALLEL, mode, rtvec_alloc (chunks));\n \n \t      bitpos = 0;\n-\t      regno = regbase + cum->arg_words + bias;\n+\t      regno = regbase + *arg_words + bias;\n \t      field = TYPE_FIELDS (type);\n \t      for (i = 0; i < chunks; i++)\n \t\t{\n@@ -3227,7 +3257,7 @@ function_arg (cum, mode, type, named)\n \t}\n \n       if (TARGET_DEBUG_E_MODE)\n-\tfprintf (stderr, \"%s%s\\n\", reg_names[regbase + cum->arg_words + bias],\n+\tfprintf (stderr, \"%s%s\\n\", reg_names[regbase + *arg_words + bias],\n \t\t struct_p ? \", [struct]\" : \"\");\n \n       /* The following is a hack in order to pass 1 byte structures\n@@ -3250,11 +3280,11 @@ function_arg (cum, mode, type, named)\n \t calling convention for now.  */\n \n       if (struct_p && int_size_in_bytes (type) < UNITS_PER_WORD\n-\t  && ! TARGET_64BIT)\n+\t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n \t{\n \t  rtx amount = GEN_INT (BITS_PER_WORD\n \t\t\t\t- int_size_in_bytes (type) * BITS_PER_UNIT);\n-\t  rtx reg = gen_rtx (REG, word_mode, regbase + cum->arg_words + bias);\n+\t  rtx reg = gen_rtx (REG, word_mode, regbase + *arg_words + bias);\n \t  if (TARGET_64BIT)\n \t    cum->adjust[ cum->num_adjusts++ ] = gen_ashldi3 (reg, reg, amount);\n \t  else\n@@ -3279,7 +3309,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n   if ((mode == BLKmode\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n        || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n-      && cum->arg_words < MAX_ARGS_IN_REGISTERS)\n+      && cum->arg_words < MAX_ARGS_IN_REGISTERS\n+      && mips_abi != ABI_EABI)\n     {\n       int words;\n       if (mode == BLKmode)\n@@ -3299,7 +3330,8 @@ function_arg_partial_nregs (cum, mode, type, named)\n     }\n \n   else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS-1\n-\t   && ! TARGET_64BIT)\n+\t   && ! TARGET_64BIT\n+\t   && mips_abi != ABI_EABI)\n     {\n       if (TARGET_DEBUG_E_MODE)\n \tfprintf (stderr, \"function_arg_partial_nregs = 1\\n\");\n@@ -3402,19 +3434,21 @@ override_options ()\n   else if (! strcmp (mips_abi_string, \"64\")\n \t   || ! strcmp (mips_abi_string, \"n64\"))\n     mips_abi = ABI_64;\n+  else if (! strcmp (mips_abi_string, \"eabi\"))\n+    mips_abi = ABI_EABI;\n   else\n     error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n \n   /* A specified ISA defaults the ABI if it was not specified.  */\n-  if (mips_abi_string == 0 && mips_isa_string)\n+  if (mips_abi_string == 0 && mips_isa_string && mips_abi != ABI_EABI)\n     {\n       if (mips_isa <= 2)\n \tmips_abi = ABI_32;\n       else\n \tmips_abi = ABI_64;\n     }\n   /* A specified ABI defaults the ISA if it was not specified.  */\n-  else if (mips_isa_string == 0 && mips_abi_string)\n+  else if (mips_isa_string == 0 && mips_abi_string && mips_abi != ABI_EABI)\n     {\n       if (mips_abi == ABI_32)\n \tmips_isa = 1;\n@@ -4506,7 +4540,7 @@ mips_asm_file_start (stream)\n \n   /* Start a section, so that the first .popsection directive is guaranteed\n      to have a previously defined section to pop back to.  */\n-  if (mips_abi != ABI_32)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_EABI)\n     fprintf (stream, \"\\t.section\\t.text\\n\");\n \n   /* This code exists so that we can put all externs before all symbol\n@@ -4853,7 +4887,7 @@ compute_frame_size (size)\n      for leaf routines (total_size == extra_size) to save the gp reg.\n      The gp reg is callee saved in the 64 bit ABI, so all routines must\n      save the gp reg.  */\n-  if (total_size == extra_size && mips_abi == ABI_32)\n+  if (total_size == extra_size && (mips_abi == ABI_32 || mips_abi == ABI_EABI))\n     total_size = extra_size = 0;\n   else if (TARGET_ABICALLS)\n     {\n@@ -5857,7 +5891,8 @@ mips_function_value (valtype, func)\n   /* ??? How should we return complex float?  */\n   if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n     reg = FP_RETURN;\n-  else if (TREE_CODE (valtype) == RECORD_TYPE && mips_abi != ABI_32)\n+  else if (TREE_CODE (valtype) == RECORD_TYPE\n+\t   && mips_abi != ABI_32 && mips_abi != ABI_EABI)\n     {\n       /* A struct with only one or two floating point fields is returned in\n \t the floating point registers.  */\n@@ -5916,6 +5951,30 @@ mips_function_value (valtype, func)\n \n   return gen_rtx (REG, mode, reg);\n }\n+\n+/* The implementation of FUNCTION_ARG_PASS_BY_REFERENCE.  Return\n+   nonzero when an argument must be passed by reference.  */\n+\n+int\n+function_arg_pass_by_reference (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int size;\n+\n+  if (mips_abi != ABI_EABI)\n+    return 0;\n+\n+  /* ??? How should SCmode be handled?  */\n+  if (type == NULL_TREE || mode == DImode || mode == DFmode)\n+    return 0;\n+\n+  size = int_size_in_bytes (type);\n+  return size == -1 || size > UNITS_PER_WORD;\n+}\n+\n #endif\n \n /* This function returns the register class required for a secondary"}, {"sha": "8d2a61478571707f65d73a1aba84780b7933be70", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "patch": "@@ -82,7 +82,8 @@ enum processor_type {\n enum mips_abi_type {\n   ABI_32,\n   ABI_N32,\n-  ABI_64\n+  ABI_64,\n+  ABI_EABI\n };\n \n #ifndef MIPS_ABI_DEFAULT\n@@ -166,6 +167,7 @@ extern void\t\tfinal_prescan_insn ();\n extern struct rtx_def *\tfunction_arg ();\n extern void\t\tfunction_arg_advance ();\n extern int\t\tfunction_arg_partial_nregs ();\n+extern int\t\tfunction_arg_pass_by_reference ();\n extern void\t\tfunction_epilogue ();\n extern void\t\tfunction_prologue ();\n extern void\t\tgen_conditional_branch ();\n@@ -803,6 +805,8 @@ while (0)\n %{mgp32:-U__mips64} %{mgp64:-D__mips64} \\\n %{msingle-float:%{!msoft-float:-D__mips_single_float}} \\\n %{m4650:%{!msoft-float:-D__mips_single_float}} \\\n+%{msoft-float:-D__mips_soft_float} \\\n+%{mabi=eabi:-D__mips_eabi} \\\n %{EB:-UMIPSEL -U_MIPSEL -U__MIPSEL -U__MIPSEL__ -D_MIPSEB -D__MIPSEB -D__MIPSEB__ %{!ansi:-DMIPSEB}} \\\n %{EL:-UMIPSEB -U_MIPSEB -U__MIPSEB -U__MIPSEB__ -D_MIPSEL -D__MIPSEL -D__MIPSEL__ %{!ansi:-DMIPSEL}} \\\n %(subtarget_cpp_spec) \"\n@@ -1914,7 +1918,7 @@ extern struct mips_frame_info current_frame_info;\n \t    && ((TO) == FRAME_POINTER_REGNUM\t\t\t\t \\\n \t\t|| (TO) == STACK_POINTER_REGNUM))\t\t\t \\\n     (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n-\t\t- (mips_abi != ABI_32\t\t\t\t\t \\\n+\t\t- ((mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t \\\n \t\t   ? current_function_pretend_args_size\t\t\t \\\n \t\t   : 0));\t\t\t\t\t\t \\\n   else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t \\\n@@ -2112,6 +2116,8 @@ typedef struct mips_args {\n   int gp_reg_found;\t\t/* whether a gp register was found yet */\n   int arg_number;\t\t/* argument number */\n   int arg_words;\t\t/* # total words the arguments take */\n+  int fp_arg_words;\t\t/* # words for FP args (MIPS_EABI only) */\n+  int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n   int num_adjusts;\t\t/* number of adjustments made */\n \t\t\t\t/* Adjustments made to args pass in regs.  */\n \t\t\t\t/* ??? The size is doubled to work around a \n@@ -2507,7 +2513,7 @@ typedef struct mips_args {\n           /* ??? Reject combining an address with a register for the MIPS  \\\n \t     64 bit ABI, because the SGI assembler can not handle this.  */ \\\n \t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n-\t      && mips_abi == ABI_32\t\t\t\t\t\\\n+\t      && (mips_abi == ABI_32 || mips_abi == ABI_EABI)\t\t\\\n \t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\\\n \t      && ! mips_split_addresses\t\t\t\t\t\\\n \t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\\\n@@ -2537,7 +2543,7 @@ typedef struct mips_args {\n     || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n     || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n \t&& ! (flag_pic && pic_address_needs_scratch (X))\t\t\\\n-\t&& mips_abi == ABI_32))\t\t\t\t\t\t\\\n+\t&& (mips_abi == ABI_32 || mips_abi == ABI_EABI)))\t\t\\\n    && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n@@ -2556,7 +2562,8 @@ typedef struct mips_args {\n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\t\\\n   ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n     || mips_const_double_ok (X, GET_MODE (X)))\t\t\t\t\\\n-   && ! (GET_CODE (X) == CONST && mips_abi != ABI_32))\n+   && ! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+\t && mips_abi != ABI_32 && mips_abi != ABI_EABI))\n \n /* A C compound statement that attempts to replace X with a valid\n    memory address for an operand of mode MODE.  WIN will be a C\n@@ -2618,7 +2625,7 @@ typedef struct mips_args {\n   if (GET_CODE (xinsn) == CONST\t\t\t\t\t\t\\\n       && ((flag_pic && pic_address_needs_scratch (xinsn))\t\t\\\n \t  /* ??? SGI's Irix 6 assembler can't handle CONST.  */\t\t\\\n-\t  || mips_abi != ABI_32))\t\t\t\t\t\\\n+\t  || (mips_abi != ABI_32 && mips_abi != ABI_EABI)))\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n       rtx constant = XEXP (XEXP (xinsn, 0), 1);\t\t\t\t\\"}, {"sha": "c8c84ee9b9147a93621ea1ab2d7b5b8dc60cf099", "filename": "gcc/ginclude/va-mips.h", "status": "modified", "additions": 105, "deletions": 4, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fginclude%2Fva-mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/293a36ebf10d89b7bc994e18a4d01b84b6eb91b7/gcc%2Fginclude%2Fva-mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mips.h?ref=293a36ebf10d89b7bc994e18a4d01b84b6eb91b7", "patch": "@@ -13,7 +13,51 @@\n \n #ifndef __GNUC_VA_LIST\n #define __GNUC_VA_LIST\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+\n+typedef struct {\n+  /* Pointer to FP regs.  */\n+  char *__fp_regs;\n+  /* Number of FP regs remaining.  */\n+  int __fp_left;\n+  /* Pointer to GP regs followed by stack parameters.  */\n+  char *__gp_regs;\n+} __gnuc_va_list;\n+\n+#ifdef __mips64\n+#define __va_reg_size 8\n+#else\n+#define __va_reg_size 4\n+#endif\n+\n+enum {\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+\n typedef char * __gnuc_va_list;\n+\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n #endif /* not __GNUC_VA_LIST */\n \n /* If this is for internal libc use, don't define anything but\n@@ -43,32 +87,88 @@ typedef char * __gnuc_va_list;\n #endif\n \n #ifdef _STDARG_H\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n+  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)\t\t\\\n+\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n+\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n+\t\t\t: 0)),\t\t\t\t\t\t\\\n+   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n+   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n #define va_start(__AP, __LASTARG) \\\n   (__AP = (__gnuc_va_list) __builtin_next_arg (__LASTARG))\n-\n-#else\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+#else /* ! _STDARG_H */\n #define va_alist  __builtin_va_alist\n #ifdef __mips64\n /* This assumes that `long long int' is always a 64 bit type.  */\n #define va_dcl    long long int __builtin_va_alist; __va_ellipsis\n #else\n #define va_dcl    int __builtin_va_alist; __va_ellipsis\n #endif\n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+#define va_start(__AP)\t\t\t\t\t\t\t\\\n+  (__AP.__gp_regs = ((char *) __builtin_next_arg ()\t\t\t\\\n+\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n+\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n+\t\t\t: 8)),\t\t\t\t\t\t\\\n+   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n+   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n /* Need alternate code for _MIPS_SIM_ABI64.  */\n-#if defined(_MIPS_SIM) && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)\n+#elif defined(_MIPS_SIM) && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)\n #define va_start(__AP)\t\t\t\t\t\t\t\\\n   (__AP = (__gnuc_va_list) __builtin_next_arg ()\t\t\t\\\n    + (__builtin_args_info (2) >= 8 ? -8 : 0))\n #else\n #define va_start(__AP)  __AP = (char *) &__builtin_va_alist\n #endif\n-#endif\n+#endif /* ! _STDARG_H */\n \n #ifndef va_end\n void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n #endif\n #define va_end(__AP)\t((void)0)\n \n+#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n+\n+#ifdef __mips64\n+#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n+  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n+    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n+   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n+   : (__AP.__gp_regs += __va_reg_size) - __va_reg_size)\n+#else\n+#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n+  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n+    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n+   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n+   : (((__builtin_classify_type (* (__type *) 0) < record_type_class\t\\\n+\t&& __alignof__ (__type) > 4)\t\t\t\t\t\\\n+       ? __AP.__gp_regs = (__AP.__gp_regs + 8 - 1) & -8),\t\t\\\n+      (__AP.__gp_regs += __va_reg_size) - __va_reg_size))\n+#endif\n+\n+#ifdef __MIPSEB__\n+#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n+  ((__va_rounded_size (__type) <= __va_reg_size)\t\t\t\\\n+   ? *(__type *) (void *) (__va_next_addr (__AP, __type)\t\t\\\n+\t\t\t   + __va_reg_size\t\t\t\t\\\n+\t\t\t   - sizeof (__type))\t\t\t\t\\\n+   : (__builtin_classify_type (*(__type *) 0) >= __record_type_class\t\\\n+      ? **(__type **) (void *) (__va_next_addr (__AP, __type)\t\t\\\n+\t\t\t\t+ __va_reg_size\t\t\t\t\\\n+\t\t\t\t- sizeof (char *))\t\t\t\\\n+      : *(__type *) (void *) __va_next_addr (__AP, __type)))\n+#else\n+#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n+  (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n+   ? **(__type **) (void *) __va_next_addr (__AP, __type)\t\t\\\n+   : *(__type *) (void *) __va_next_addr (__AP, __type))\n+#endif\n+\n+#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n+\n /* We cast to void * and then to TYPE * because this avoids\n    a warning about increasing the alignment requirement.  */\n /* The __mips64 cases are reversed from the 32 bit cases, because the standard\n@@ -106,5 +206,6 @@ void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n \t\t\t\t\t + __va_rounded_size(__type))))[-1]\n #endif\n #endif\n+#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n \n #endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}