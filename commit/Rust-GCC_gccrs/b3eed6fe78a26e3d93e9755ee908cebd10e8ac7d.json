{"sha": "b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNlZWQ2ZmU3OGEyNmUzZDkzZTk3NTVlZTkwOGNlYmQxMGU4YWM3ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2010-01-21T00:01:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2010-01-21T00:01:47Z"}, "message": "re PR libstdc++/42201 ([C++0x] std::vector<std::unique_future<T>>::push_back fails)\n\n2010-01-21  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n        PR libstdc++/42201\n\t* include/std/future: Update to latest WP.\n\t* src/functexcept.cc (__throw_future_error): Use make_error_code.\n\t* testsuite/30_threads/async/any.cc: New.\n\t* testsuite/30_threads/async/async.cc: New.\n\t* testsuite/30_threads/async/sync.cc: New.\n\t* testsuite/30_threads/packaged_task/cons/alloc.cc: New.\n\t* testsuite/30_threads/packaged_task/cons/assign_neg.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/cons/copy_neg.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/get_future.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/get_future2.cc: Likewise.\n\t* testsuite/30_threads/packaged_task/members/invoke.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/invoke2.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/invoke3.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/invoke4.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/reset.cc: Adjust.\n\t* testsuite/30_threads/packaged_task/members/reset2.cc: Adjust.\n\t* testsuite/30_threads/shared_future/cons/assign_neg.cc: Remove.\n\t* testsuite/30_threads/shared_future/cons/default_neg.cc: Remove.\n\t* testsuite/30_threads/shared_future/cons/default.cc: New.\n\t* testsuite/30_threads/shared_future/cons/assign.cc: New.\n\t* testsuite/30_threads/shared_future/cons/copy.cc: Adjust.\n\t* testsuite/30_threads/shared_future/cons/move.cc: Adjust.\n\t* testsuite/30_threads/shared_future/cons/move_assign.cc: New.\n\t* testsuite/30_threads/shared_future/members/is_ready.cc: Remove.\n\t* testsuite/30_threads/shared_future/members/has_value.cc: Remove.\n\t* testsuite/30_threads/shared_future/members/has_exception.cc: Remove.\n\t* testsuite/30_threads/shared_future/members/valid.cc: New.\n\t* testsuite/30_threads/unique_future/cons/default_neg.cc: Remove.\n\t* testsuite/30_threads/unique_future/cons/default.cc: New.\n\t* testsuite/30_threads/unique_future/cons/move_assign.cc: New.\n\t* testsuite/30_threads/unique_future/cons/assign_neg.cc: Adjust.\n\t* testsuite/30_threads/unique_future/cons/copy_neg.cc: Adjust.\n\t* testsuite/30_threads/unique_future/cons/move.cc: Adjust.\n\t* testsuite/30_threads/unique_future/requirements/\n        explicit_instantiation.cc: Adjust.\n\t* testsuite/30_threads/unique_future/members/is_ready.cc: Remove.\n\t* testsuite/30_threads/unique_future/members/has_value.cc: Remove.\n\t* testsuite/30_threads/unique_future/members/has_exception.cc: Remove.\n\t* testsuite/30_threads/unique_future/members/valid.cc: New.\n\t* testsuite/30_threads/unique_future/members/get.cc: Adjust.\n\t* testsuite/30_threads/unique_future/members/get2.cc: Adjust.\n\t* testsuite/30_threads/unique_future/members/wait.cc: Adjust.\n\t* testsuite/30_threads/unique_future/members/wait_for.cc: Adjust.\n\t* testsuite/30_threads/unique_future/members/wait_until.cc: Adjust.\n\t* testsuite/30_threads/headers/future/types_std_c++0x.cc: Adjust.\n\t* testsuite/30_threads/promise/cons/alloc.cc: New.\n\t* testsuite/30_threads/promise/cons/assign_neg.cc: Adjust.\n\t* testsuite/30_threads/promise/cons/copy_neg.cc: Adjust.\n\t* testsuite/30_threads/promise/cons/move.cc: Adjust.\n\t* testsuite/30_threads/promise/cons/move_assign.cc: Adjust.\n\t* testsuite/30_threads/promise/members/get_future.cc: Adjust.\n\t* testsuite/30_threads/promise/members/set_value.cc: Adjust.\n\t* testsuite/30_threads/promise/members/set_exception.cc: Adjust.\n\t* testsuite/30_threads/promise/members/set_exception2.cc: Adjust.\n\t* testsuite/30_threads/promise/members/set_value2.cc: Adjust.\n\t* testsuite/30_threads/promise/members/set_value3.cc: Adjust.\n\t* testsuite/30_threads/promise/members/swap.cc: Adjust.\n\nFrom-SVN: r156097", "tree": {"sha": "2bf12fb4b49acb8cdc9582004db25e49a34a7fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bf12fb4b49acb8cdc9582004db25e49a34a7fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4227d4a1a58bbbff02ca7d6ea4321ad586ded9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be"}], "stats": {"total": 1685, "additions": 1136, "deletions": 549}, "files": [{"sha": "c0558f86d26d0e9be70d60d5347c7be5d233300c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -1,3 +1,64 @@\n+2010-01-21  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+        PR libstdc++/42201\n+\t* include/std/future: Update to latest WP.\n+\t* src/functexcept.cc (__throw_future_error): Use make_error_code.\n+\t* testsuite/30_threads/async/any.cc: New.\n+\t* testsuite/30_threads/async/async.cc: New.\n+\t* testsuite/30_threads/async/sync.cc: New.\n+\t* testsuite/30_threads/packaged_task/cons/alloc.cc: New.\n+\t* testsuite/30_threads/packaged_task/cons/assign_neg.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/cons/copy_neg.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/get_future.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/get_future2.cc: Likewise.\n+\t* testsuite/30_threads/packaged_task/members/invoke.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/invoke2.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/invoke3.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/invoke4.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/reset.cc: Adjust.\n+\t* testsuite/30_threads/packaged_task/members/reset2.cc: Adjust.\n+\t* testsuite/30_threads/shared_future/cons/assign_neg.cc: Remove.\n+\t* testsuite/30_threads/shared_future/cons/default_neg.cc: Remove.\n+\t* testsuite/30_threads/shared_future/cons/default.cc: New.\n+\t* testsuite/30_threads/shared_future/cons/assign.cc: New.\n+\t* testsuite/30_threads/shared_future/cons/copy.cc: Adjust.\n+\t* testsuite/30_threads/shared_future/cons/move.cc: Adjust.\n+\t* testsuite/30_threads/shared_future/cons/move_assign.cc: New.\n+\t* testsuite/30_threads/shared_future/members/is_ready.cc: Remove.\n+\t* testsuite/30_threads/shared_future/members/has_value.cc: Remove.\n+\t* testsuite/30_threads/shared_future/members/has_exception.cc: Remove.\n+\t* testsuite/30_threads/shared_future/members/valid.cc: New.\n+\t* testsuite/30_threads/unique_future/cons/default_neg.cc: Remove.\n+\t* testsuite/30_threads/unique_future/cons/default.cc: New.\n+\t* testsuite/30_threads/unique_future/cons/move_assign.cc: New.\n+\t* testsuite/30_threads/unique_future/cons/assign_neg.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/cons/copy_neg.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/cons/move.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/requirements/\n+        explicit_instantiation.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/members/is_ready.cc: Remove.\n+\t* testsuite/30_threads/unique_future/members/has_value.cc: Remove.\n+\t* testsuite/30_threads/unique_future/members/has_exception.cc: Remove.\n+\t* testsuite/30_threads/unique_future/members/valid.cc: New.\n+\t* testsuite/30_threads/unique_future/members/get.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/members/get2.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/members/wait.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/members/wait_for.cc: Adjust.\n+\t* testsuite/30_threads/unique_future/members/wait_until.cc: Adjust.\n+\t* testsuite/30_threads/headers/future/types_std_c++0x.cc: Adjust.\n+\t* testsuite/30_threads/promise/cons/alloc.cc: New.\n+\t* testsuite/30_threads/promise/cons/assign_neg.cc: Adjust.\n+\t* testsuite/30_threads/promise/cons/copy_neg.cc: Adjust.\n+\t* testsuite/30_threads/promise/cons/move.cc: Adjust.\n+\t* testsuite/30_threads/promise/cons/move_assign.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/get_future.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/set_value.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/set_exception.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/set_exception2.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/set_value2.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/set_value3.cc: Adjust.\n+\t* testsuite/30_threads/promise/members/swap.cc: Adjust.\n+\n 2010-01-20  Janis Johnson  <janis187@us.ibm.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "629d61aec22da0ea797f5460efd5569a75873df2", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 619, "deletions": 236, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -38,6 +38,7 @@\n #include <functional>\n #include <memory>\n #include <mutex>\n+#include <thread>\n #include <condition_variable>\n #include <system_error>\n #include <exception>\n@@ -56,10 +57,13 @@ namespace std\n \n   /// Error code for futures\n   enum class future_errc\n-  { broken_promise, future_already_retrieved, promise_already_satisfied };\n+  {\n+    broken_promise,\n+    future_already_retrieved,\n+    promise_already_satisfied,\n+    no_state\n+  };\n \n-  // TODO: requires concepts\n-  // concept_map ErrorCodeEnum<future_errc> { }\n   template<>\n     struct is_error_code_enum<future_errc> : public true_type { };\n \n@@ -83,8 +87,8 @@ namespace std\n     error_code \t\t\t_M_code;\n \n   public:\n-    explicit future_error(future_errc __ec)\n-    : logic_error(\"std::future_error\"), _M_code(make_error_code(__ec))\n+    explicit future_error(error_code __ec)\n+    : logic_error(\"std::future_error\"), _M_code(__ec)\n     { }\n \n     virtual ~future_error() throw();\n@@ -98,17 +102,30 @@ namespace std\n \n   // Forward declarations.\n   template<typename _Res>\n-    class unique_future;\n+    class future;\n \n   template<typename _Res>\n     class shared_future;\n \n-  template<typename> \n+  template<typename _Res>\n+    class atomic_future;\n+\n+  template<typename _Signature> \n     class packaged_task;\n \n   template<typename _Res>\n     class promise;\n \n+  enum class launch { any, async, sync };\n+\n+  template<typename _Fn, typename... _Args>\n+    future<typename _Fn::result_type>\n+    async(launch __policy, _Fn&& __fn, _Args&&... __args);\n+\n+  template<typename _Fn, typename... _Args>\n+    future<typename _Fn::result_type>\n+    async(_Fn&& __fn, _Args&&... __args);\n+\n #if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1) \\\n   && defined(_GLIBCXX_ATOMIC_BUILTINS_4)\n \n@@ -124,9 +141,7 @@ namespace std\n       _Result_base(const _Result_base&) = delete;\n       _Result_base& operator=(const _Result_base&) = delete;\n \n-      // _M_destroy() allows derived classes to control deallocation,\n-      // which will be needed when allocator support is added to promise.\n-      // See http://gcc.gnu.org/ml/libstdc++/2009-06/msg00032.html\n+      // _M_destroy() allows derived classes to control deallocation\n       virtual void _M_destroy() = 0;\n \n       struct _Deleter\n@@ -183,7 +198,6 @@ namespace std\n \tvoid* _M_addr() { return static_cast<void*>(&_M_storage); }\n     };\n \n-\n     // TODO: use template alias when available\n     /*\n       template<typename _Res>\n@@ -196,6 +210,50 @@ namespace std\n \ttypedef unique_ptr<_Res, _Result_base::_Deleter> type;\n       };\n \n+    // TODO: use when allocator_arg_t available\n+    /*\n+    /// Result_alloc.\n+    template<typename _Res, typename _Alloc>\n+      struct _Result_alloc : _Result<_Res>\n+      {\n+        typedef typename _Alloc::template rebind<_Result_alloc>::other\n+          __allocator_type;\n+\n+        explicit\n+\t_Result_alloc(const _Alloc& __a) : _Result<_Res>(), _M_alloc(__a)\n+        { }\n+\t\n+      private:\n+\tvoid _M_destroy()\n+        {\n+          __allocator_type __a(_M_alloc);\n+          __a.destroy(this);\n+          __a.deallocate(this, 1);\n+        }\n+\n+        __allocator_type _M_alloc;\n+    };\n+\n+    template<typename _Res, typename _Allocator>\n+      static typename _Ptr<_Result_alloc<_Res, _Allocator>>::type\n+      _S_allocate_result(const _Allocator& __a)\n+      {\n+        typedef _Result_alloc<_Res, _Allocator>\t__result_type;\n+        typename __result_type::__allocator_type __a2(__a);\n+        __result_type* __p = __a2.allocate(1);\n+        __try\n+        {\n+          __a2.construct(__p, __a);\n+        }\n+        __catch(...)\n+        {\n+          __a2.deallocate(__p, 1);\n+          __throw_exception_again;\n+        }\n+        return typename _Ptr<__result_type>::type(__p);\n+      }\n+    */\n+\n \n     /// Shared state between a promise and one or more associated futures.\n     class _State\n@@ -206,37 +264,21 @@ namespace std\n       mutex               \t_M_mutex;\n       condition_variable  \t_M_cond;\n       atomic_flag         \t_M_retrieved;\n+      once_flag\t\t\t_M_once;\n \n     public:\n       _State() : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT) { }\n \n       _State(const _State&) = delete;\n       _State& operator=(const _State&) = delete;\n \n-      bool\n-      is_ready()\n-      { return _M_get() != 0; }\n-\n-      bool\n-      has_exception()\n-      {\n-\t_Result_base* const __res = _M_get();\n-\treturn __res && !(__res->_M_error == 0);\n-      }\n-\n-      bool\n-      has_value()\n-      {\n-\t_Result_base* const __res = _M_get();\n-\treturn __res && (__res->_M_error == 0);\n-      }\n-\n       _Result_base&\n       wait()\n       {\n+\t_M_run_deferred();\n \tunique_lock<mutex> __lock(_M_mutex);\n \tif (!_M_ready())\n-\t  _M_cond.wait(__lock, std::bind(&_State::_M_ready, this));\n+\t  _M_cond.wait(__lock, std::bind<bool>(&_State::_M_ready, this));\n \treturn *_M_result;\n       }\n \n@@ -245,7 +287,7 @@ namespace std\n         wait_for(const chrono::duration<_Rep, _Period>& __rel)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  auto __bound = std::bind(&_State::_M_ready, this);\n+\t  auto __bound = std::bind<bool>(&_State::_M_ready, this);\n \t  return _M_ready() || _M_cond.wait_for(__lock, __rel, __bound);\n \t}\n \n@@ -254,28 +296,28 @@ namespace std\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  auto __bound = std::bind(&_State::_M_ready, this);\n+\t  auto __bound = std::bind<bool>(&_State::_M_ready, this);\n \t  return _M_ready() || _M_cond.wait_until(__lock, __abs, __bound);\n \t}\n \n       void\n-      _M_set_result(_Ptr_type __res)\n+      _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)\n       {\n-\t{\n-\t  lock_guard<mutex> __lock(_M_mutex);\n-\t  if (_M_ready())\n-\t    __throw_future_error(int(future_errc::promise_already_satisfied));\n-\t  _M_result.swap(__res);\n-\t}\n-\t_M_cond.notify_all();\n+        bool __set = __ignore_failure;\n+        // all calls to this function are serialized,\n+        // side-effects of invoking __res only happen once\n+        call_once(_M_once, mem_fn(&_State::_M_do_set), this, ref(__res),\n+            ref(__set));\n+        if (!__set)\n+          __throw_future_error(int(future_errc::promise_already_satisfied));\n       }\n \n       void\n       _M_break_promise(_Ptr_type __res)\n       {\n \tif (static_cast<bool>(__res))\n \t  {\n-\t    future_errc __ec(future_errc::broken_promise); // XXX\n+\t    error_code __ec(make_error_code(future_errc::broken_promise));\n \t    __res->_M_error = copy_exception(future_error(__ec));\n \t    {\n \t      lock_guard<mutex> __lock(_M_mutex);\n@@ -285,24 +327,122 @@ namespace std\n \t  }\n       }\n \n-      // Called when this object is passed to a unique_future.\n+      // Called when this object is passed to a future.\n       void\n       _M_set_retrieved_flag()\n       {\n \tif (_M_retrieved.test_and_set())\n \t  __throw_future_error(int(future_errc::future_already_retrieved));\n       }\n \n+      template<typename _Res, typename _Arg>\n+        struct _Setter;\n+\n+      // set lvalues\n+      template<typename _Res, typename _Arg>\n+        struct _Setter<_Res, _Arg&>\n+        {\n+          // check this is only used by promise<R>::set_value(const R&)\n+          // or promise<R>::set_value(R&)\n+          static_assert(is_same<_Res, _Arg&>::value  // promise<R&>\n+              || is_same<const _Res, _Arg>::value,  // promise<R>\n+              \"Invalid specialisation\");\n+\n+          typename promise<_Res>::_Ptr_type operator()()\n+          {\n+            _State::_S_check(_M_promise->_M_future);\n+            _M_promise->_M_storage->_M_set(_M_arg);\n+            return std::move(_M_promise->_M_storage);\n+          }\n+          promise<_Res>*    _M_promise;\n+          _Arg&             _M_arg;\n+        };\n+\n+      // set rvalues\n+      template<typename _Res>\n+        struct _Setter<_Res, _Res&&>\n+        {\n+          typename promise<_Res>::_Ptr_type operator()()\n+          {\n+            _State::_S_check(_M_promise->_M_future);\n+            _M_promise->_M_storage->_M_set(std::move(_M_arg));\n+            return std::move(_M_promise->_M_storage);\n+          }\n+          promise<_Res>*    _M_promise;\n+          _Res&             _M_arg;\n+        };\n+\n+      struct __exception_ptr_tag { };\n+\n+      // set exceptions\n+      template<typename _Res>\n+        struct _Setter<_Res, __exception_ptr_tag>\n+        {\n+          typename promise<_Res>::_Ptr_type operator()()\n+          {\n+            _State::_S_check(_M_promise->_M_future);\n+            _M_promise->_M_storage->_M_error = _M_ex;\n+            return std::move(_M_promise->_M_storage);\n+          }\n+\n+          promise<_Res>*   _M_promise;\n+          exception_ptr&    _M_ex;\n+        };\n+\n+      template<typename _Res, typename _Arg>\n+        static _Setter<_Res, _Arg&&>\n+        __setter(promise<_Res>* __prom, _Arg&& __arg)\n+        {\n+          return _Setter<_Res, _Arg&&>{ __prom, __arg };\n+        }\n+\n+      template<typename _Res>\n+        static _Setter<_Res, __exception_ptr_tag>\n+        __setter(exception_ptr& __ex, promise<_Res>* __prom)\n+        {\n+          return _Setter<_Res, __exception_ptr_tag>{ __prom, __ex };\n+        }\n+\n+      static _Setter<void, void>\n+      __setter(promise<void>* __prom);\n+\n+      template<typename _Tp>\n+        static bool\n+        _S_check(const shared_ptr<_Tp>& __p)\n+        {\n+          if (!static_cast<bool>(__p))\n+            __throw_future_error((int)future_errc::no_state);\n+        }\n+\n     private:\n-      _Result_base*\n-      _M_get()\n+      void\n+      _M_do_set(function<_Ptr_type()>& __f, bool& __set)\n       {\n-\tlock_guard<mutex> __lock(_M_mutex);\n-\treturn _M_result.get();\n+        _Ptr_type __res = __f();\n+        {\n+          lock_guard<mutex> __lock(_M_mutex);\n+          _M_result.swap(__res);\n+        }\n+        _M_cond.notify_all();\n+        __set = true;\n       }\n \n       bool _M_ready() const { return static_cast<bool>(_M_result); }\n+\n+      virtual void _M_run_deferred() { }\n     };\n+\n+    template<typename _Res>\n+      class _Deferred_state;\n+\n+    template<typename _Res>\n+      class _Async_state;\n+\n+    template<typename _Signature>\n+      class _Task_state;\n+\n+    template<typename _StateT, typename _Res = typename _StateT::_Res_type>\n+      struct _Task_setter;\n   };\n \n   inline __future_base::_Result_base::~_Result_base() = default;\n@@ -313,9 +453,13 @@ namespace std\n     {\n       _Result() : _M_value_ptr() { }\n \n+      void _M_set(_Res& __res) { _M_value_ptr = &__res; }\n+\n+      _Res& _M_get() { return *_M_value_ptr; }\n+\n+    private:\n       _Res* \t\t\t_M_value_ptr;\n       \n-    private:\n       void _M_destroy() { delete this; }\n     };\n \n@@ -328,7 +472,7 @@ namespace std\n     };\n \n \n-  /// Common implementation for unique_future and shared_future.\n+  /// Common implementation for future and shared_future.\n   template<typename _Res>\n     class __basic_future : public __future_base\n     {\n@@ -344,134 +488,190 @@ namespace std\n       __basic_future(const __basic_future&) = delete;\n       __basic_future& operator=(const __basic_future&) = delete;\n \n-      // Functions to check state and wait for ready.\n-      bool \n-      is_ready() const { return this->_M_state->is_ready(); }\n-\n-      bool \n-      has_exception() const { return this->_M_state->has_exception(); }\n-\n       bool \n-      has_value() const { return this->_M_state->has_value(); }\n+      valid() const { return static_cast<bool>(_M_state); }\n \n       void \n-      wait() const { this->_M_state->wait(); }\n+      wait() const { _M_state->wait(); }\n \n       template<typename _Rep, typename _Period>\n         bool\n         wait_for(const chrono::duration<_Rep, _Period>& __rel) const\n-        { return this->_M_state->wait_for(__rel); }\n+        { return _M_state->wait_for(__rel); }\n \n       template<typename _Clock, typename _Duration>\n         bool\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs) const\n-        { return this->_M_state->wait_until(__abs); }\n+        { return _M_state->wait_until(__abs); }\n \n     protected:\n       /// Wait for the state to be ready and rethrow any stored exception\n       __result_type\n       _M_get_result()\n       {\n-        _Result_base& __res = this->_M_state->wait();\n+        _Result_base& __res = _M_state->wait();\n         if (!(__res._M_error == 0))\n           rethrow_exception(__res._M_error);\n         return static_cast<__result_type>(__res);\n       }\n \n-      // Construction of a unique_future by promise::get_future()\n+      void _M_swap(__basic_future& __that)\n+      {\n+        _M_state.swap(__that._M_state);\n+      }\n+\n+      // Construction of a future by promise::get_future()\n       explicit\n       __basic_future(const __state_type& __state) : _M_state(__state)\n       {\n-        if (static_cast<bool>(this->_M_state))\n-          this->_M_state->_M_set_retrieved_flag();\n-        else\n-          __throw_future_error(int(future_errc::future_already_retrieved));\n+        _State::_S_check(_M_state);\n+        _M_state->_M_set_retrieved_flag();\n       }\n \n       // Copy construction from a shared_future\n       explicit\n       __basic_future(const shared_future<_Res>&);\n \n-      // Move construction from a unique_future\n+      // Move construction from a shared_future\n       explicit\n-      __basic_future(unique_future<_Res>&&);\n+      __basic_future(shared_future<_Res>&&);\n+\n+      // Move construction from a future\n+      explicit\n+      __basic_future(future<_Res>&&);\n+\n+      __basic_future() { }\n+\n+      struct _Reset\n+      {\n+        explicit _Reset(__basic_future& __fut) : _M_fut(__fut) { }\n+        ~_Reset() { _M_fut._M_state.reset(); }\n+        __basic_future& _M_fut;\n+      };\n     };\n \n \n-  /// Primary template for unique_future.\n+  /// Primary template for future.\n   template<typename _Res>\n-    class unique_future : public __basic_future<_Res>\n+    class future : public __basic_future<_Res>\n     {\n       friend class promise<_Res>;\n+      template<typename> friend class packaged_task;\n+      template<typename _Fn, typename... _Args>\n+        friend future<typename _Fn::result_type>\n+        async(launch, _Fn&&, _Args&&...);\n \n       typedef __basic_future<_Res> _Base_type;\n       typedef typename _Base_type::__state_type __state_type;\n \n       explicit\n-      unique_future(const __state_type& __state) : _Base_type(__state) { }\n+      future(const __state_type& __state) : _Base_type(__state) { }\n \n     public:\n+      future() : _Base_type() { }\n+\n       /// Move constructor\n-      unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n+      future(future&& __uf) : _Base_type(std::move(__uf)) { }\n \n       // Disable copying\n-      unique_future(const unique_future&) = delete;\n-      unique_future& operator=(const unique_future&) = delete;\n+      future(const future&) = delete;\n+      future& operator=(const future&) = delete;\n+\n+      future& operator=(future&& __fut)\n+      {\n+        future(std::move(__fut))._M_swap(*this);\n+        return *this;\n+      }\n \n       /// Retrieving the value\n-      _Res&&\n+      _Res\n       get()\n-      { return std::move(this->_M_get_result()._M_value()); }\n+      {\n+        typename _Base_type::_Reset __reset(*this);\n+        return std::move(this->_M_get_result()._M_value());\n+      }\n     };\n  \n-  /// Partial specialization for unique_future<R&>\n+  /// Partial specialization for future<R&>\n   template<typename _Res>\n-    class unique_future<_Res&> : public __basic_future<_Res&>\n+    class future<_Res&> : public __basic_future<_Res&>\n     {\n       friend class promise<_Res&>;\n+      template<typename> friend class packaged_task;\n+      template<typename _Fn, typename... _Args>\n+        friend future<typename _Fn::result_type>\n+        async(launch, _Fn&&, _Args&&...);\n \n       typedef __basic_future<_Res&> _Base_type;\n       typedef typename _Base_type::__state_type __state_type;\n \n       explicit\n-      unique_future(const __state_type& __state) : _Base_type(__state) { }\n+      future(const __state_type& __state) : _Base_type(__state) { }\n \n     public:\n+      future() : _Base_type() { }\n+\n       /// Move constructor\n-      unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n+      future(future&& __uf) : _Base_type(std::move(__uf)) { }\n \n       // Disable copying\n-      unique_future(const unique_future&) = delete;\n-      unique_future& operator=(const unique_future&) = delete;\n+      future(const future&) = delete;\n+      future& operator=(const future&) = delete;\n+\n+      future& operator=(future&& __fut)\n+      {\n+        future(std::move(__fut))._M_swap(*this);\n+        return *this;\n+      }\n \n       /// Retrieving the value\n       _Res& \n-      get() { return *this->_M_get_result()._M_value_ptr; }\n+      get()\n+      {\n+        typename _Base_type::_Reset __reset(*this);\n+        return this->_M_get_result()._M_get();\n+      }\n     };\n \n-  /// Explicit specialization for unique_future<void>\n+  /// Explicit specialization for future<void>\n   template<>\n-    class unique_future<void> : public __basic_future<void>\n+    class future<void> : public __basic_future<void>\n     {\n       friend class promise<void>;\n+      template<typename> friend class packaged_task;\n+      template<typename _Fn, typename... _Args>\n+        friend future<typename _Fn::result_type>\n+        async(launch, _Fn&&, _Args&&...);\n \n       typedef __basic_future<void> _Base_type;\n       typedef typename _Base_type::__state_type __state_type;\n \n       explicit\n-      unique_future(const __state_type& __state) : _Base_type(__state) { }\n+      future(const __state_type& __state) : _Base_type(__state) { }\n \n     public:\n+      future() : _Base_type() { }\n+\n       /// Move constructor\n-      unique_future(unique_future&& __uf) : _Base_type(std::move(__uf)) { }\n+      future(future&& __uf) : _Base_type(std::move(__uf)) { }\n \n       // Disable copying\n-      unique_future(const unique_future&) = delete;\n-      unique_future& operator=(const unique_future&) = delete;\n+      future(const future&) = delete;\n+      future& operator=(const future&) = delete;\n+\n+      future& operator=(future&& __fut)\n+      {\n+        future(std::move(__fut))._M_swap(*this);\n+        return *this;\n+      }\n \n       /// Retrieving the value\n       void \n-      get() { this->_M_get_result(); }\n+      get()\n+      {\n+        typename _Base_type::_Reset __reset(*this);\n+        this->_M_get_result();\n+      }\n     };\n \n \n@@ -482,20 +682,37 @@ namespace std\n       typedef __basic_future<_Res> _Base_type;\n \n     public:\n+      shared_future() : _Base_type() { }\n+\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n \n-      /// Construct from a unique_future rvalue\n-      shared_future(unique_future<_Res>&& __uf)\n+      /// Construct from a future rvalue\n+      shared_future(future<_Res>&& __uf)\n       : _Base_type(std::move(__uf))\n       { }\n \n-      shared_future& operator=(const shared_future&) = delete;\n+      /// Construct from a shared_future rvalue\n+      shared_future(shared_future&& __sf)\n+      : _Base_type(std::move(__sf))\n+      { }\n+\n+      shared_future& operator=(const shared_future& __sf)\n+      {\n+        shared_future(__sf)._M_swap(*this);\n+        return *this;\n+      }\n+\n+      shared_future& operator=(shared_future&& __sf)\n+      {\n+        shared_future(std::move(__sf))._M_swap(*this);\n+        return *this;\n+      }\n \n       /// Retrieving the value\n       const _Res&\n       get()\n-      { \n+      {\n \ttypename _Base_type::__result_type __r = this->_M_get_result();\n \t_Res& __rs(__r._M_value());\n \treturn __rs;\n@@ -509,19 +726,36 @@ namespace std\n       typedef __basic_future<_Res&>           _Base_type;\n \n     public:\n+      shared_future() : _Base_type() { }\n+\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n \n-      /// Construct from a unique_future rvalue\n-      shared_future(unique_future<_Res&>&& __uf)\n+      /// Construct from a future rvalue\n+      shared_future(future<_Res&>&& __uf)\n       : _Base_type(std::move(__uf))\n       { }\n \n-      shared_future& operator=(const shared_future&) = delete;\n+      /// Construct from a shared_future rvalue\n+      shared_future(shared_future&& __sf)\n+      : _Base_type(std::move(__sf))\n+      { }\n+\n+      shared_future& operator=(const shared_future& __sf)\n+      {\n+        shared_future(__sf)._M_swap(*this);\n+        return *this;\n+      }\n+\n+      shared_future& operator=(shared_future&& __sf)\n+      {\n+        shared_future(std::move(__sf))._M_swap(*this);\n+        return *this;\n+      }\n \n       /// Retrieving the value\n       _Res& \n-      get() { return *this->_M_get_result()._M_value_ptr; }\n+      get() { return this->_M_get_result()._M_get(); }\n     };\n \n   /// Explicit specialization for shared_future<void>\n@@ -531,15 +765,32 @@ namespace std\n       typedef __basic_future<void> _Base_type;\n \n     public:\n+      shared_future() : _Base_type() { }\n+\n       /// Copy constructor\n       shared_future(const shared_future& __sf) : _Base_type(__sf) { }\n \n-      /// Construct from a unique_future rvalue\n-      shared_future(unique_future<void>&& __uf)\n+      /// Construct from a future rvalue\n+      shared_future(future<void>&& __uf)\n       : _Base_type(std::move(__uf))\n       { }\n \n-      shared_future& operator=(const shared_future&) = delete;\n+      /// Construct from a shared_future rvalue\n+      shared_future(shared_future&& __sf)\n+      : _Base_type(std::move(__sf))\n+      { }\n+\n+      shared_future& operator=(const shared_future& __sf)\n+      {\n+        shared_future(__sf)._M_swap(*this);\n+        return *this;\n+      }\n+\n+      shared_future& operator=(shared_future&& __sf)\n+      {\n+        shared_future(std::move(__sf))._M_swap(*this);\n+        return *this;\n+      }\n \n       // Retrieving the value\n       void \n@@ -553,7 +804,12 @@ namespace std\n     { }\n \n   template<typename _Res>\n-    __basic_future<_Res>::__basic_future(unique_future<_Res>&& __uf)\n+    __basic_future<_Res>::__basic_future(shared_future<_Res>&& __sf)\n+    : _M_state(std::move(__sf._M_state))\n+    { }\n+\n+  template<typename _Res>\n+    __basic_future<_Res>::__basic_future(future<_Res>&& __uf)\n     : _M_state(std::move(__uf._M_state))\n     { }\n \n@@ -562,32 +818,32 @@ namespace std\n   template<typename _Res>\n     class promise\n     {\n-      template<typename> friend class packaged_task;\n-\n       typedef __future_base::_State \t\t_State;\n-      typedef __future_base::_Result<_Res>\tresult_type;\n+      typedef __future_base::_Result<_Res>\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      template<typename, typename> friend class _State::_Setter;\n       \n       shared_ptr<_State>                        _M_future;\n-      typename __future_base::_Ptr<result_type>::type\t_M_storage;\n+      _Ptr_type                                 _M_storage;\n \n     public:\n       promise()\n-      : _M_future(std::make_shared<_State>()), _M_storage(new result_type())\n+      : _M_future(std::make_shared<_State>()), _M_storage(new _Res_type())\n       { }\n \n       promise(promise&& __rhs)\n       : _M_future(std::move(__rhs._M_future)),\n       _M_storage(std::move(__rhs._M_storage))\n       { }\n \n-      // TODO: requires allocator concepts\n+      // TODO: needs allocator_arg_t\n       /*\n       template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator& __a);\n-\n-      template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator&, promise&& __rhs);\n-       */\n+        promise(allocator_arg_t, const _Allocator& __a)\n+        : _M_future(std::allocate_shared<_State>(__a)),\n+        _M_storage(__future_base::_S_allocate_result<_Res>(__a))\n+        { }\n+      */\n \n       promise(const promise&) = delete;\n \n@@ -615,69 +871,63 @@ namespace std\n       }\n \n       // Retrieving the result\n-      unique_future<_Res>\n+      future<_Res>\n       get_future()\n-      { return unique_future<_Res>(_M_future); }\n+      { return future<_Res>(_M_future); }\n \n       // Setting the result\n       void\n       set_value(const _Res& __r)\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_set(__r);\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(this, __r);\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n \n       void\n       set_value(_Res&& __r)\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_set(std::move(__r));\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(this, std::move(__r));\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n \n       void\n       set_exception(exception_ptr __p)\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_error = __p;\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(__p, this);\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n-\n-    private:\n-      bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n     };\n \n   /// Partial specialization for promise<R&>\n   template<typename _Res>\n     class promise<_Res&>\n     {\n-      template<typename> friend class packaged_task;\n       typedef __future_base::_State \t\t_State;\n- \n-      typedef __future_base::_Result<_Res&> result_type;\n+      typedef __future_base::_Result<_Res&>\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      template<typename, typename> friend class _State::_Setter;\n \n       shared_ptr<_State>                        _M_future;\n-      typename __future_base::_Ptr<result_type>::type  _M_storage;\n+      _Ptr_type                                 _M_storage;\n \n     public:\n       promise()\n-      : _M_future(std::make_shared<_State>()), _M_storage(new result_type())\n+      : _M_future(std::make_shared<_State>()), _M_storage(new _Res_type())\n       { }\n \n       promise(promise&& __rhs)\n       : _M_future(std::move(__rhs._M_future)), \n \t_M_storage(std::move(__rhs._M_storage))\n       { }\n \n-      // TODO: requires allocator concepts\n+      // TODO: needs allocator_arg_t\n       /*\n       template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator& __a);\n-\n-      template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator&, promise&& __rhs);\n-       */\n+        promise(allocator_arg_t, const _Allocator& __a)\n+        : _M_future(std::allocate_shared<_State>(__a)),\n+        _M_storage(__future_base::_S_allocate_result<_Res&>(__a))\n+        { }\n+      */\n \n       promise(const promise&) = delete;\n \n@@ -705,61 +955,58 @@ namespace std\n       }\n \n       // Retrieving the result\n-      unique_future<_Res&>\n+      future<_Res&>\n       get_future()\n-      { return unique_future<_Res&>(_M_future); }\n+      { return future<_Res&>(_M_future); }\n \n       // Setting the result\n       void\n       set_value(_Res& __r)\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_value_ptr = &__r;\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(this, __r);\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n \n       void\n       set_exception(exception_ptr __p)\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_error = __p;\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(__p, this);\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n-\n-    private:\n-      bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n     };\n \n   /// Explicit specialization for promise<void>\n   template<>\n     class promise<void>\n     {\n-      template<typename> friend class packaged_task;\n       typedef __future_base::_State \t\t_State;\n-      typedef __future_base::_Result<void>\tresult_type;\n+      typedef __future_base::_Result<void>\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      template<typename, typename> friend class _State::_Setter;\n \n-      shared_ptr<__future_base::_State>                 _M_future;\n-      typename __future_base::_Ptr<result_type>::type   _M_storage;\n+      shared_ptr<_State>                        _M_future;\n+      _Ptr_type                                 _M_storage;\n \n     public:\n       promise()\n       : _M_future(std::make_shared<_State>()),\n-\t_M_storage(new result_type())\n+\t_M_storage(new _Res_type())\n       { }\n \n       promise(promise&& __rhs)\n       : _M_future(std::move(__rhs._M_future)),\n       _M_storage(std::move(__rhs._M_storage))\n       { }\n \n-      // TODO: requires allocator concepts\n-      /*\n-      template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator& __a);\n \n+      // TODO: needs allocator_arg_t\n+      /*\n       template<typename _Allocator>\n-        promise(allocator_arg_t, const _Allocator&, promise&& __rhs);\n-       */\n+        promise(allocator_arg_t, const _Allocator& __a)\n+        : _M_future(std::allocate_shared<_State>(__a)),\n+        _M_storage(__future_base::_S_allocate_result<void>(__a))\n+        { }\n+      */\n \n       promise(const promise&) = delete;\n \n@@ -787,69 +1034,137 @@ namespace std\n       }\n \n       // Retrieving the result\n-      unique_future<void>\n+      future<void>\n       get_future()\n-      { return unique_future<void>(_M_future); }\n+      { return future<void>(_M_future); }\n \n       // Setting the result\n+      void set_value();\n+\n       void\n-      set_value()\n+      set_exception(exception_ptr __p)\n       {\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        auto __setter = _State::__setter(__p, this);\n+        _M_future->_M_set_result(std::move(__setter));\n       }\n+    };\n \n-      void\n-      set_exception(exception_ptr __p)\n+  // set void\n+  template<>\n+    struct __future_base::_State::_Setter<void, void>\n+    {\n+      promise<void>::_Ptr_type operator()()\n       {\n-        if (!_M_satisfied())\n-          _M_storage->_M_error = __p;\n-        _M_future->_M_set_result(std::move(_M_storage));\n+        _State::_S_check(_M_promise->_M_future);\n+        return std::move(_M_promise->_M_storage);\n       }\n \n-    private:\n-      bool _M_satisfied() { return !static_cast<bool>(_M_storage); }\n+      promise<void>*    _M_promise;\n     };\n \n-  // TODO: requires allocator concepts\n+  inline __future_base::_State::_Setter<void, void>\n+  __future_base::_State::__setter(promise<void>* __prom)\n+  {\n+    return _Setter<void, void>{ __prom };\n+  }\n+\n+  inline void\n+  promise<void>::set_value()\n+  {\n+    auto __setter = _State::__setter(this);\n+    _M_future->_M_set_result(std::move(__setter));\n+  }\n+\n+  // TODO: needs allocators\n   /*\n   template<typename _Res, class Alloc>\n-    concept_map UsesAllocator<promise<_Res>, Alloc>\n-    {\n-      typedef Alloc allocator_type;\n-    }\n-   */\n-  /// Primary template.\n-  template<typename _Res, typename... _ArgTypes>\n-    struct _Run_task\n+    struct uses_allocator<promise<_Res>, Alloc> : true_type  { };\n+  */\n+\n+\n+  template<typename _StateT, typename _Res>\n+    struct __future_base::_Task_setter\n     {\n-      static void\n-      _S_run(promise<_Res>& __p, function<_Res(_ArgTypes...)>& __f,\n-\t     _ArgTypes... __args)\n+      typename _StateT::_Ptr_type operator()()\n       {\n-        __p.set_value(__f(std::forward<_ArgTypes>(__args)...));\n+        __try {\n+          _M_state->_M_result->_M_set(_M_fn());\n+        } __catch(...) {\n+          _M_state->_M_result->_M_error = current_exception();\n+        }\n+        return std::move(_M_state->_M_result);\n       }\n+      _StateT*                  _M_state;\n+      std::function<_Res()>     _M_fn;\n     };\n \n-  /// Specialization used by packaged_task<void(...)>\n-  template<typename... _ArgTypes>\n-    struct _Run_task<void, _ArgTypes...>\n+  template<typename _StateT>\n+    struct __future_base::_Task_setter<_StateT, void>\n     {\n-      static void\n-      _S_run(promise<void>& __p, function<void(_ArgTypes...)>& __f,\n-\t     _ArgTypes... __args)\n+      typename _StateT::_Ptr_type operator()()\n       {\n-        __f(std::forward<_ArgTypes>(__args)...);\n-        __p.set_value();\n+        __try {\n+          _M_fn();\n+        } __catch(...) {\n+          _M_state->_M_result->_M_error = current_exception();\n+        }\n+        return std::move(_M_state->_M_result);\n       }\n+      _StateT*                  _M_state;\n+      std::function<void()>     _M_fn;\n     };\n \n+  template<typename _Res, typename... _Args>\n+    struct __future_base::_Task_state<_Res(_Args...)> : __future_base::_State\n+    {\n+      typedef _Res _Res_type;\n+\n+      _Task_state(std::function<_Res(_Args...)> __task)\n+      : _M_result(new _Result<_Res>()), _M_task(std::move(__task))\n+      { }\n+\n+      // TODO: needs allocator_arg_t\n+      /*\n+      template<typename _Func, typename _Alloc>\n+        _Task_state(_Func&& __task, const _Alloc& __a)\n+        : _M_result(_S_allocate_result<_Res>(__a))\n+        , _M_task(allocator_arg, __a, std::move(__task))\n+        { }\n+      */\n+\n+      void\n+      _M_run(_Args... __args)\n+      {\n+        // bound arguments decay so wrap lvalue references\n+        auto __bound = std::bind<_Res>(_M_task,\n+            _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+        _Task_setter<_Task_state> __setter{ this, std::move(__bound) };\n+        _M_set_result(std::move(__setter));\n+      }\n+\n+      template<typename, typename> friend class _Task_setter;\n+      typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n+      _Ptr_type _M_result;\n+      std::function<_Res(_Args...)> _M_task;\n+\n+      template<typename _Tp>\n+        static reference_wrapper<_Tp>\n+        _S_maybe_wrap_ref(_Tp& __t)\n+        { return std::ref(__t); }\n+\n+      template<typename _Tp>\n+        static typename enable_if<!is_lvalue_reference<_Tp>::value,\n+                        _Tp>::type&&\n+        _S_maybe_wrap_ref(_Tp&& __t)\n+        { return std::forward<_Tp>(__t); }\n+    };\n \n   /// packaged_task\n   template<typename _Res, typename... _ArgTypes>\n     class packaged_task<_Res(_ArgTypes...)>\n     {\n-      function<_Res(_ArgTypes...)>   _M_task;\n-      promise<_Res>                  _M_promise;\n+      typedef __future_base::_Task_state<_Res(_ArgTypes...)>  _State_type;\n+      shared_ptr<_State_type>                   _M_state;\n \n     public:\n       typedef _Res result_type;\n@@ -859,31 +1174,35 @@ namespace std\n \n       template<typename _Fn>\n         explicit\n-        packaged_task(const _Fn& __fn) : _M_task(__fn) { }\n+        packaged_task(const _Fn& __fn)\n+        : _M_state(std::make_shared<_State_type>(__fn))\n+        { }\n \n       template<typename _Fn>\n         explicit\n-        packaged_task(_Fn&& __fn) : _M_task(std::move(__fn)) { }\n+        packaged_task(_Fn&& __fn)\n+        : _M_state(std::make_shared<_State_type>(std::move(__fn)))\n+        { }\n \n       explicit\n-      packaged_task(_Res(*__fn)(_ArgTypes...)) : _M_task(__fn) { }\n+      packaged_task(_Res(*__fn)(_ArgTypes...))\n+      : _M_state(std::make_shared<_State_type>(__fn))\n+      { }\n \n-      // TODO: requires allocator concepts\n+      // TODO: needs allocator_arg_t\n       /*\n       template<typename _Fn, typename _Allocator>\n         explicit\n         packaged_task(allocator_arg_t __tag, const _Allocator& __a, _Fn __fn)\n-        : _M_task(__tag, __a, __fn), _M_promise(__tag, __a)\n-        { }\n-\n-      template<typename _Fn, typename _Allocator>\n-        explicit\n-        packaged_task(allocator_arg_t __tag, const _Allocator& __a, _Fn&& __fn)\n-        : _M_task(__tag, __a, std::move(__fn)), _M_promise(__tag, __a)\n+        : _M_state(std::allocate_shared<_State_type>(__a, std::move(__fn)))\n         { }\n-       */\n+      */\n \n-      ~packaged_task() = default;\n+      ~packaged_task()\n+      {\n+        if (static_cast<bool>(_M_state) && !_M_state.unique())\n+          _M_state->_M_break_promise(std::move(_M_state->_M_result));\n+      }\n \n       // No copy\n       packaged_task(packaged_task&) = delete;\n@@ -901,50 +1220,114 @@ namespace std\n \n       void\n       swap(packaged_task& __other)\n-      {\n-        _M_task.swap(__other._M_task);\n-        _M_promise.swap(__other._M_promise);\n-      }\n+      { _M_state.swap(__other._M_state); }\n \n-      explicit operator bool() const { return static_cast<bool>(_M_task); }\n+      explicit operator bool() const { return static_cast<bool>(_M_state); }\n \n       // Result retrieval\n-      unique_future<_Res>\n+      future<_Res>\n       get_future()\n-      {\n-        __try\n-        {\n-          return _M_promise.get_future();\n-        }\n-        __catch (const future_error& __e)\n-        {\n-          if (__e.code() == future_errc::future_already_retrieved)\n-            __throw_bad_function_call();\n-          __throw_exception_again;\n-        }\n-      }\n+      { return future<_Res>(_M_state); }\n \n       // Execution\n       void\n       operator()(_ArgTypes... __args)\n       {\n-        if (!static_cast<bool>(_M_task) || _M_promise._M_satisfied())\n-          __throw_bad_function_call();\n+        __future_base::_State::_S_check(_M_state);\n+        _M_state->_M_run(std::forward<_ArgTypes>(__args)...);\n+      }\n \n-        __try\n-        {\n-          _Run_task<_Res, _ArgTypes...>::_S_run(_M_promise, _M_task,\n-              std::forward<_ArgTypes>(__args)...);\n-        }\n-        __catch (...)\n-        {\n-          _M_promise.set_exception(current_exception());\n-        }\n+      void\n+      reset()\n+      {\n+        __future_base::_State::_S_check(_M_state);\n+        packaged_task(std::move(_M_state->_M_task)).swap(*this);\n+      }\n+    };\n+\n+  template<typename _Res>\n+    class __future_base::_Deferred_state : public __future_base::_State\n+    {\n+    public:\n+      typedef _Res _Res_type;\n+\n+      explicit\n+      _Deferred_state(std::function<_Res()>&& __fn)\n+      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn))\n+      { }\n+\n+    private:\n+      template<typename, typename> friend class _Task_setter;\n+      typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n+      _Ptr_type _M_result;\n+      std::function<_Res()> _M_fn;\n+\n+      virtual void\n+      _M_run_deferred()\n+      {\n+        _Task_setter<_Deferred_state> __setter{ this, _M_fn };\n+        // safe to call multiple times so ignore failure\n+        _M_set_result(std::move(__setter), true);\n+      }\n+    };\n+\n+  template<typename _Res>\n+    class __future_base::_Async_state : public __future_base::_State\n+    {\n+    public:\n+      typedef _Res _Res_type;\n+\n+      explicit \n+      _Async_state(std::function<_Res()>&& __fn)\n+      : _M_result(new _Result<_Res>()), _M_fn(std::move(__fn)),\n+      _M_thread(mem_fn(&_Async_state::_M_do_run), this)\n+      { }\n+\n+      ~_Async_state() { _M_thread.join(); }\n+\n+    private:\n+      void _M_do_run()\n+      {\n+        _Task_setter<_Async_state> __setter{ this, std::move(_M_fn) };\n+        _M_set_result(std::move(__setter));\n       }\n \n-      void reset() { promise<_Res>().swap(_M_promise); }\n+      template<typename, typename> friend class _Task_setter;\n+      typedef typename __future_base::_Ptr<_Result<_Res>>::type _Ptr_type;\n+      _Ptr_type _M_result;\n+      std::function<_Res()> _M_fn;\n+      thread _M_thread;\n     };\n \n+  template<typename _Fn, typename... _Args>\n+    future<typename _Fn::result_type>\n+    async(launch __policy, _Fn&& __fn, _Args&&... __args)\n+    {\n+      typedef typename _Fn::result_type result_type;\n+      std::shared_ptr<__future_base::_State> __state;\n+      if (__policy == launch::async)\n+      {\n+        typedef typename __future_base::_Async_state<result_type> _State;\n+        __state = std::make_shared<_State>(std::bind<result_type>(\n+              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n+      }\n+      else\n+      {\n+        typedef typename __future_base::_Deferred_state<result_type> _State;\n+        __state = std::make_shared<_State>(std::bind<result_type>(\n+              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));\n+      }\n+      return future<result_type>(__state);\n+    }\n+\n+  template<typename _Fn, typename... _Args>\n+    future<typename _Fn::result_type>\n+    async(_Fn&& __fn, _Args&&... __args)\n+    {\n+      return async(launch::any, std::forward<_Fn>(__fn),\n+          std::forward<_Args>(__args)...);\n+    }\n+\n #endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1\n        // && _GLIBCXX_ATOMIC_BUILTINS_4\n "}, {"sha": "c5c3e37809e6a003a54bd14885559c6c697bcac3", "filename": "libstdc++-v3/src/functexcept.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffunctexcept.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -103,7 +103,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   void\n   __throw_future_error(int __i)\n-  { throw future_error(future_errc(__i)); }\n+  { throw future_error(make_error_code(future_errc(__i))); }\n \n   void\n   __throw_bad_function_call()"}, {"sha": "40c103f960142535d01121ec27dbde052b2bd638", "filename": "libstdc++-v3/testsuite/30_threads/async/any.cc", "status": "renamed", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fany.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fany.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fany.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -6,7 +6,7 @@\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,38 +27,32 @@\n #include <future>\n #include <testsuite_hooks.h>\n \n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n-\n-  VERIFY( !f1.has_exception() );\n-\n-  p1.set_exception(std::copy_exception(1));\n+struct sum {\n+  typedef int result_type;\n+  int operator()(int i, int& j, const int& k) { return i + j + k; }\n+};\n \n-  VERIFY( f1.has_exception() );\n-}\n-\n-void test02()\n+void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  using namespace std;\n \n-  VERIFY( !f1.has_exception() );\n+  int a = 1;\n+  int b = 10;\n+  int c = 100;\n+  future<int> f1 = async(launch::any, sum(), a, ref(b), cref(c));\n+  future<int> f2 = async(sum(), a, ref(b), cref(c));\n \n-  p1.set_value(1);\n-\n-  VERIFY( !f1.has_exception() );\n+  VERIFY( f1.valid() );\n+  VERIFY( f2.valid() );\n+  int r1 = f1.get();\n+  int r2 = f2.get();\n+  VERIFY( r1 == r2 );\n }\n \n int main()\n {\n   test01();\n-  test02();\n-\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/has_exception.cc"}, {"sha": "5335dfc57a65f7bb8a0b86b5eae91867cabc9070", "filename": "libstdc++-v3/testsuite/30_threads/async/async.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fasync.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+struct work {\n+  typedef void result_type;\n+  void operator()(mutex& m, condition_variable& cv)\n+  {\n+    unique_lock<mutex> l(m);\n+    cv.notify_one();\n+  }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  mutex m;\n+  condition_variable cv;\n+  unique_lock<mutex> l(m);\n+  future<void> f1 = async(launch::async, work(), ref(m), ref(cv));\n+  cv.wait(l);\n+  f1.get();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f1d137737736e42b7595fe4efadf24c5cce1ae28", "filename": "libstdc++-v3/testsuite/30_threads/async/sync.cc", "status": "renamed", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fsync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fsync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fasync%2Fsync.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -6,7 +6,7 @@\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,18 +27,24 @@\n #include <future>\n #include <testsuite_hooks.h>\n \n+struct sum {\n+  typedef int result_type;\n+  int operator()(int i, int& j, const int& k) { return i + j + k; }\n+};\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n-\n-  VERIFY( !f1.is_ready() );\n+  using namespace std;\n \n-  p1.set_value(1);\n+  int a = 1;\n+  int b = 10;\n+  int c = 100;\n+  future<int> f1 = async(launch::sync, sum(), a, ref(b), cref(c));\n \n-  VERIFY( f1.is_ready() );\n+  VERIFY( f1.valid() );\n+  VERIFY( f1.get() == 111 );\n }\n \n int main()", "previous_filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/is_ready.cc"}, {"sha": "fe040ec2ab2aee95ff4293bcb244118b6e61868c", "filename": "libstdc++-v3/testsuite/30_threads/headers/future/types_std_c++0x.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fheaders%2Ffuture%2Ftypes_std_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fheaders%2Ffuture%2Ftypes_std_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fheaders%2Ffuture%2Ftypes_std_c%2B%2B0x.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -31,9 +31,9 @@ void test01()\n \n   typedef std::future_error error_t;\n \n-  typedef std::unique_future<int> uniq_t;\n-  typedef std::unique_future<int&> uniqr_t;\n-  typedef std::unique_future<void> uniqv_t;\n+  typedef std::future<int> uniq_t;\n+  typedef std::future<int&> uniqr_t;\n+  typedef std::future<void> uniqv_t;\n \n   typedef std::shared_future<int> shar_t;\n   typedef std::shared_future<int&> sharr_t;\n@@ -46,4 +46,6 @@ void test01()\n   typedef std::packaged_task<int> ptask_t;\n   typedef std::packaged_task<int&> ptaskr_t;\n   typedef std::packaged_task<void> ptaskv_t;\n+\n+  using std::async;\n }"}, {"sha": "2565b61b24d0847bdc5c701e78a40540841815b3", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/alloc.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Falloc.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do compile { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+int f() { return 5; }\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using std::packaged_task;\n+  using std::allocator_arg;\n+  using __gnu_test::uneq_allocator;\n+\n+  uneq_allocator<char> alloc(99);\n+\n+  packaged_task<int ()> p1(allocator_arg, alloc, f); // { dg-excess-errors \"\" }\n+  VERIFY( static_cast<bool>(p1) );\n+  p1();\n+  VERIFY( p1.get_future().get() == 5 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8b724d502da5aa199170bffe56fb7b68c488296a", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fassign_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -33,4 +33,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 32 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 890 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 1209 }"}, {"sha": "82a330fef2e4021a2fe144c9c2ee5ef05b4739c5", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2Fcopy_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -32,4 +32,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 31 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 889 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 1208 }"}, {"sha": "b44891be861c2415d3a25012fd28ac5c1e48d0eb", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/get_future.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -34,9 +34,10 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::packaged_task<int&(int&)> p1(inc);\n-  std::unique_future<int&> f1 = p1.get_future();\n+  std::future<int&> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n+  VERIFY( !f1.wait_for(std::chrono::milliseconds(1)) );\n \n   int i1 = 0;\n "}, {"sha": "5c6d67b9776c1a1e2db52c2db7b4ee503606f719", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/get_future2.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fget_future2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -42,8 +42,9 @@ void test01()\n     p1.get_future();\n     VERIFY( false );\n   }\n-  catch (std::bad_function_call&)\n+  catch (const std::future_error& e)\n   {\n+    VERIFY( e.code() == std::future_errc::future_already_retrieved );\n     test = true;\n   }\n "}, {"sha": "cce7b54e269cbf73c5a045e758ab436c6c4bfe8b", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/invoke.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -34,12 +34,12 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::packaged_task<int()> p1(zero);\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n   p1();\n \n   VERIFY( static_cast<bool>(p1) );\n-  VERIFY( f1.has_value() );\n+  VERIFY( f1.get() == 0 );\n }\n \n int main()"}, {"sha": "e29852c48347aba167d0c30e2063a3f3a7ebd4b6", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/invoke2.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -41,8 +41,9 @@ void test01()\n   {\n     p1(4);\n   }\n-  catch (std::bad_function_call&)\n+  catch (const std::future_error& e)\n   {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n     test = true;\n   }\n "}, {"sha": "7ae6106a242c9453d6e584488fd7dfd2cf7be25f", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/invoke3.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke3.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -44,8 +44,9 @@ void test01()\n   {\n     p1(i1);\n   }\n-  catch (std::bad_function_call&)\n+  catch (const std::future_error& e)\n   {\n+    VERIFY( e.code() == std::future_errc::promise_already_satisfied );\n     test = true;\n   }\n "}, {"sha": "6f0013f3005cc16555865528396784888800771d", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/invoke4.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Finvoke4.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -31,14 +31,19 @@ void thrower() { throw 0; }\n \n void test01()\n {\n-  bool test __attribute__((unused)) = true;\n+  bool test = false;\n \n   std::packaged_task<void()> p1(thrower);\n-  std::unique_future<void> f1 = p1.get_future();\n+  std::future<void> f1 = p1.get_future();\n \n   p1();\n \n-  VERIFY( f1.has_exception() );\n+  try {\n+    f1.get();\n+  } catch (int) {\n+    test = true;\n+  }\n+  VERIFY( test );\n }\n \n int main()"}, {"sha": "a126c3ace88daaeabbe1239ccd1092b16fc93f2b", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/reset.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -36,15 +36,13 @@ void test01()\n   using namespace std;\n \n   packaged_task<int()> p1(zero);\n-  unique_future<int> f1 = p1.get_future();\n+  future<int> f1 = p1.get_future();\n \n   p1.reset();\n   VERIFY( static_cast<bool>(p1) );\n \n-  unique_future<int> f2 = p1.get_future();\n-  VERIFY( !f2.is_ready() );\n+  future<int> f2 = p1.get_future();\n \n-  VERIFY( f1.has_exception() );\n   try\n   {\n     f1.get();"}, {"sha": "e38d047866221a7721f0541a1a19e5f902654115", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/reset2.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Freset2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -27,23 +27,24 @@\n #include <future>\n #include <testsuite_hooks.h>\n \n-int zero() { return 0; }\n+int iota() { static int i = 0; return i++; }\n \n void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::packaged_task<int()> p1(zero);\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::packaged_task<int()> p1(iota);\n+  std::future<int> f1 = p1.get_future();\n \n   p1();\n   p1.reset();\n \n   VERIFY( static_cast<bool>(p1) );\n-  VERIFY( f1.has_value() );\n+  VERIFY( f1.get() == 0 );\n \n-  std::unique_future<int> f2 = p1.get_future();\n-  VERIFY( !f2.is_ready() );\n+  std::future<int> f2 = p1.get_future();\n+  p1();\n+  VERIFY( f2.get() == 1 );\n }\n \n int main()"}, {"sha": "6d53f4444db62f4f1856197c149e7480a7e92254", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/alloc.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Falloc.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void test01()\n+{\n+  using std::promise;\n+  using std::allocator_arg;\n+  using __gnu_test::uneq_allocator;\n+\n+  uneq_allocator<char> alloc(99);\n+\n+  promise<int> p1(allocator_arg, alloc); // { dg-excess-errors \"\" }\n+  p1.set_value(5);\n+  VERIFY( p1.get_future().get() == 5 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "229ee3ff4bb24f45cf404612b90bcb5b3ea53d39", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fassign_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -33,4 +33,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 32 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 608 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 864 }"}, {"sha": "a40ab79b5b6866c76a2cf3192319074ebfffe051", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/copy_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fcopy_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -32,4 +32,4 @@ void test01()\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 31 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 592 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 848 }"}, {"sha": "5fc2cae44a4cc7b3d8f3ad510c0fbba453c7f0bb", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/move.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -44,7 +44,7 @@ void test01()\n   }\n   catch (std::future_error& e)\n   {\n-    VERIFY(e.code() == make_error_code(future_errc::future_already_retrieved));\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n   }\n }\n "}, {"sha": "5d96e8ffcd3ae3d803790f7dcb50976b1cf3f0d2", "filename": "libstdc++-v3/testsuite/30_threads/promise/cons/move_assign.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fcons%2Fmove_assign.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -45,7 +45,7 @@ void test01()\n   }\n   catch (future_error& e)\n   {\n-    VERIFY(e.code() == make_error_code(future_errc::future_already_retrieved));\n+    VERIFY(e.code() == make_error_code(future_errc::no_state));\n   }\n }\n "}, {"sha": "b09e302ccd4670c8d1f1c538c6e1865615617ef4", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/get_future.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fget_future.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fget_future.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fget_future.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -32,9 +32,9 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int&> p1;\n-  std::unique_future<int&> f1 = p1.get_future();\n+  std::future<int&> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   int i1 = 0;\n "}, {"sha": "4d2a1ec0247d5839bd3140d8560fba2d2c941be0", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_exception.cc", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -29,17 +29,25 @@\n \n void test01()\n {\n-  bool test __attribute__((unused)) = true;\n+  bool test = false;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   p1.set_exception(std::copy_exception(0));\n \n-  VERIFY( f1.has_exception() );\n-  VERIFY( !f1.has_value() );\n+  try\n+  {\n+    f1.get();\n+  }\n+  catch (int)\n+  {\n+    test = true;\n+  }\n+  VERIFY( test );\n+  VERIFY( !f1.valid() );\n }\n \n int main()"}, {"sha": "872a4792fd01cfe3b9a128163979af52647e4aec", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_exception2.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_exception2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -32,7 +32,7 @@ void test01()\n   bool test = false;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n   p1.set_exception(std::copy_exception(0));\n \n@@ -66,7 +66,7 @@ void test02()\n   bool test = false;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n   p1.set_value(2);\n \n@@ -82,8 +82,6 @@ void test02()\n     test = true;\n   }\n \n-  VERIFY( f1.has_value() );\n-  VERIFY( !f1.has_exception() );\n   VERIFY( test );\n }\n "}, {"sha": "9d3f8ead308f0cc0bd2a84c035f3dc79165702ca", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_value.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -33,9 +33,9 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   p1.set_value(0);\n \n@@ -50,15 +50,15 @@ void test02()\n   using __gnu_test::rvalstruct;\n \n   std::promise<rvalstruct> p1;\n-  std::unique_future<rvalstruct> f1 = p1.get_future();\n+  std::future<rvalstruct> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   p1.set_value(rvalstruct(1));\n \n   rvalstruct r1(f1.get());\n \n-  VERIFY( r1.valid );\n+  VERIFY( !f1.valid() );\n   VERIFY( r1.val == 1 );\n }\n \n@@ -68,14 +68,15 @@ void test03()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int&> p1;\n-  std::unique_future<int&> f1 = p1.get_future();\n+  std::future<int&> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   int i1 = 0;\n   p1.set_value(i1);\n   int& i2 = f1.get();\n \n+  VERIFY( !f1.valid() );\n   VERIFY( &i1 == &i2 );\n }\n \n@@ -84,14 +85,14 @@ void test04()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<void> p1;\n-  std::unique_future<void> f1 = p1.get_future();\n+  std::future<void> f1 = p1.get_future();\n \n-  VERIFY( !f1.is_ready() );\n+  VERIFY( f1.valid() );\n \n   p1.set_value();\n   f1.get();\n \n-  VERIFY( f1.is_ready() );\n+  VERIFY( !f1.valid() );\n }\n \n int main()"}, {"sha": "09c8a52fa1e56c60cd4c26cc23fcaad1451675ab", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_value2.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -32,7 +32,7 @@ void test01()\n   bool test = false;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n   p1.set_value(1);\n \n@@ -48,7 +48,7 @@ void test01()\n     test = true;\n   }\n \n-  VERIFY( f1.has_value() );\n+  VERIFY( f1.wait_for(std::chrono::milliseconds(1)) );\n   VERIFY( f1.get() == 1 );\n   VERIFY( test );\n }\n@@ -58,7 +58,7 @@ void test02()\n   bool test = false;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1 = p1.get_future();\n+  std::future<int> f1 = p1.get_future();\n \n   p1.set_value(3);\n \n@@ -74,8 +74,7 @@ void test02()\n     test = true;\n   }\n \n-  VERIFY( f1.has_value() );\n-  VERIFY( !f1.has_exception() );\n+  VERIFY( f1.wait_for(std::chrono::milliseconds(1)) );\n   VERIFY( f1.get() == 3 );\n   VERIFY( test );\n }"}, {"sha": "b94b1b6eaa5908d042e6cdfda8db3344e7ffc6c9", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/set_value3.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fset_value3.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -41,33 +41,33 @@ struct tester\n };\n \n std::promise<tester> pglobal;\n-std::unique_future<tester> fglobal = pglobal.get_future();\n+std::future<tester> fglobal = pglobal.get_future();\n \n tester::tester(int)\n {\n   bool test __attribute__((unused)) = true;\n-  VERIFY (!fglobal.is_ready());\n+  VERIFY (!fglobal.wait_for(std::chrono::milliseconds(1)));\n }\n \n tester::tester(const tester&)\n {\n   bool test __attribute__((unused)) = true;\n   // if this copy happens while a mutex is locked next line could deadlock:\n-  VERIFY (!fglobal.is_ready());\n+  VERIFY (!fglobal.wait_for(std::chrono::milliseconds(1)));\n }\n \n tester& tester::operator=(const tester&)\n {\n   bool test __attribute__((unused)) = true;\n   // if this copy happens while a mutex is locked next line could deadlock:\n-  VERIFY (!fglobal.is_ready());\n+  VERIFY (!fglobal.wait_for(std::chrono::milliseconds(1)));\n   return *this;\n }\n \n tester::~tester()\n {\n   bool test __attribute__((unused)) = true;\n-  VERIFY (fglobal.is_ready());\n+  VERIFY (fglobal.wait_for(std::chrono::milliseconds(1)));\n }\n \n void test01()\n@@ -76,7 +76,7 @@ void test01()\n \n   pglobal.set_value( tester(1) );\n \n-  VERIFY( fglobal.is_ready() );\n+  VERIFY( fglobal.wait_for(std::chrono::milliseconds(1)) );\n }\n \n int main()"}, {"sha": "b27ee2be7b5074d4091b007975af85cf94e51204", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/swap.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fswap.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -35,8 +35,8 @@ void test01()\n   std::promise<int> p2;\n   p1.set_value(1);\n   p1.swap(p2);\n-  VERIFY( !p1.get_future().is_ready() );\n-  VERIFY( p2.get_future().is_ready() );\n+  VERIFY( !p1.get_future().wait_for(std::chrono::milliseconds(1)) );\n+  VERIFY( p2.get_future().wait_for(std::chrono::milliseconds(1)) );\n }\n \n int main()"}, {"sha": "434cf187c37d72d1abdc09328e67b97efe723210", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/assign.cc", "status": "renamed", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fassign.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -1,10 +1,9 @@\n-// { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-cstdint \"\" }\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,16 +22,23 @@\n \n \n #include <future>\n+#include <testsuite_hooks.h>\n \n-extern std::shared_future<int>& get();\n+std::future<int> get() { return std::promise<int>().get_future(); }\n \n void test01()\n {\n   // assign\n-  std::shared_future<int>& p1 = get();\n-  std::shared_future<int>& p2 = get();\n+  std::shared_future<int> p1;\n+  std::shared_future<int> p2 = get();\n   p1 = p2;\n+  VERIFY( p1.valid() );\n+  VERIFY( p2.valid() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n }\n \n-// { dg-error \"used here\" \"\" { target *-*-* } 34 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 493 }", "previous_filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/assign_neg.cc"}, {"sha": "09af94edbe2004c79994547c2a37911e73eb10ce", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/copy.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fcopy.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -25,7 +25,7 @@\n #include <future>\n #include <testsuite_hooks.h>\n \n-extern std::unique_future<int>&& get();\n+extern std::future<int>&& get();\n \n void test01()\n {"}, {"sha": "c247853de3a6fe463c4b66b19185b6cc6624cc26", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/default.cc", "status": "renamed", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fdefault.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -1,10 +1,9 @@\n-// { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-cstdint \"\" }\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,23 +22,30 @@\n \n \n #include <future>\n+#include <testsuite_hooks.h>\n #include <testsuite_tr1.h>\n \n void test01()\n {\n   using std::shared_future;\n   using namespace __gnu_test;\n \n-  shared_future<int> p1;            // { dg-error \"22: error: no match\" }\n-  shared_future<int&> p2;           // { dg-error \"23: error: no match\" }\n-  shared_future<void> p3;           // { dg-error \"23: error: no match\" }\n-  shared_future<ClassType> p4;      // { dg-error \"28: error: no match\" }\n-  shared_future<AbstractClass&> p5; // { dg-error \"33: error: no match\" }\n+  bool __attribute__((unused)) test = true;\n+\n+  shared_future<int> p1;\n+  VERIFY( !p1.valid() );\n+  shared_future<int&> p2;\n+  VERIFY( !p2.valid() );\n+  shared_future<void> p3;\n+  VERIFY( !p3.valid() );\n+  shared_future<ClassType> p4;\n+  VERIFY( !p4.valid() );\n+  shared_future<AbstractClass&> p5;\n+  VERIFY( !p5.valid() );\n }\n \n int main()\n {\n   test01();\n   return 0;\n }\n-// { dg-excess-errors \"note\" }", "previous_filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/default_neg.cc"}, {"sha": "bb9b62b1dcdebb1a4a5d18948053d36cbce4a63b", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/move.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -28,9 +28,9 @@\n \n void test01()\n {\n-  // construct from rvalue unique_future\n+  // construct from rvalue future\n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::future<int> f1(p1.get_future());\n   std::shared_future<int> f2(std::move(f1));\n }\n "}, {"sha": "147604956f9919ddc897da4b262de554e4309f9e", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/cons/move_assign.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fcons%2Fmove_assign.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+std::future<int> get() { return std::promise<int>().get_future(); }\n+\n+void test01()\n+{\n+  // assign\n+  std::shared_future<int> p1;\n+  std::shared_future<int> p2 = get();\n+  p1 = std::move(p2);\n+  VERIFY( p1.valid() );\n+  VERIFY( !p2.valid() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "97d398025e529d27f53a8329db85a2a24e57969a", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/members/has_exception.cc", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_exception.cc?ref=4227d4a1a58bbbff02ca7d6ea4321ad586ded9be", "patch": "@@ -1,70 +0,0 @@\n-// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n-// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n-// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n-// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n-// { dg-require-cstdint \"\" }\n-// { dg-require-gthreads \"\" }\n-// { dg-require-atomic-builtins \"\" }\n-\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-\n-#include <future>\n-#include <testsuite_hooks.h>\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  std::promise<int> p1;\n-  std::shared_future<int> f1(p1.get_future());\n-  std::shared_future<int> f2(f1);\n-\n-  VERIFY( !f1.has_exception() );\n-  VERIFY( !f2.has_exception() );\n-\n-  p1.set_exception(std::copy_exception(1));\n-\n-  VERIFY( f1.has_exception() );\n-  VERIFY( f2.has_exception() );\n-}\n-\n-void test02()\n-{\n-  std::promise<int> p1;\n-  bool test __attribute__((unused)) = true;\n-\n-  std::shared_future<int> f1(p1.get_future());\n-  std::shared_future<int> f2(f1);\n-\n-  VERIFY( !f1.has_exception() );\n-  VERIFY( !f2.has_exception() );\n-\n-  p1.set_value(1);\n-\n-  VERIFY( !f1.has_exception() );\n-  VERIFY( !f2.has_exception() );\n-}\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-\n-  return 0;\n-}"}, {"sha": "8903c825f889c6bb8ecb6283de2020e2f2d000dd", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/members/has_value.cc", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4227d4a1a58bbbff02ca7d6ea4321ad586ded9be/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fhas_value.cc?ref=4227d4a1a58bbbff02ca7d6ea4321ad586ded9be", "patch": "@@ -1,70 +0,0 @@\n-// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n-// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n-// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n-// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n-// { dg-require-cstdint \"\" }\n-// { dg-require-gthreads \"\" }\n-// { dg-require-atomic-builtins \"\" }\n-\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-\n-#include <future>\n-#include <testsuite_hooks.h>\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  std::promise<int> p1;\n-  std::shared_future<int> f1(p1.get_future());\n-  std::shared_future<int> f2(f1);\n-\n-  VERIFY( !f1.has_value() );\n-  VERIFY( !f2.has_value() );\n-\n-  p1.set_value(1);\n-\n-  VERIFY( f1.has_value() );\n-  VERIFY( f2.has_value() );\n-}\n-\n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  std::promise<int> p1;\n-  std::shared_future<int> f1(p1.get_future());\n-  std::shared_future<int> f2(f1);\n-\n-  VERIFY( !f1.has_value() );\n-  VERIFY( !f2.has_value() );\n-\n-  p1.set_exception(std::copy_exception(1));\n-\n-  VERIFY( !f1.has_value() );\n-  VERIFY( !f2.has_value() );\n-}\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-\n-  return 0;\n-}"}, {"sha": "c70ed38ffe363c1d5f65ebebe21165b634606cce", "filename": "libstdc++-v3/testsuite/30_threads/shared_future/members/valid.cc", "status": "renamed", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fvalid.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fvalid.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_future%2Fmembers%2Fvalid.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -6,7 +6,7 @@\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,35 +31,31 @@ void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::shared_future<int> f0;\n \n-  VERIFY( !f1.has_value() );\n+  VERIFY( !f0.valid() );\n \n-  p1.set_value(1);\n+  std::promise<int> p1;\n+  std::shared_future<int> f1(p1.get_future());\n+  std::shared_future<int> f2(f1);\n \n-  VERIFY( f1.has_value() );\n-}\n+  VERIFY( f1.valid() );\n+  VERIFY( f2.valid() );\n \n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  p1.set_value(1);\n \n-  VERIFY( !f1.has_value() );\n+  VERIFY( f1.valid() );\n+  VERIFY( f2.valid() );\n \n-  p1.set_exception(std::copy_exception(1));\n+  f1 = std::move(f0);\n \n-  VERIFY( !f1.has_value() );\n+  VERIFY( !f0.valid() );\n+  VERIFY( !f1.valid() );\n+  VERIFY( f2.valid() );\n }\n \n int main()\n {\n   test01();\n-  test02();\n-\n   return 0;\n }\n-", "previous_filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/has_value.cc"}, {"sha": "ecdc27c3b8d46d039c4c0b45a935d3d2304f31cd", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/assign_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fassign_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -24,15 +24,15 @@\n \n #include <future>\n \n-extern std::unique_future<int>& get();\n+extern std::future<int>& get();\n \n void test01()\n {\n   // assign\n-  std::unique_future<int>& p1 = get();\n-  std::unique_future<int>& p2 = get();\n+  std::future<int>& p1 = get();\n+  std::future<int>& p2 = get();\n   p1 = p2;\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 34 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 419 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 578 }"}, {"sha": "c76075da120cfd079614170b7803b57649642c91", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/copy_neg.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fcopy_neg.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -24,14 +24,14 @@\n \n #include <future>\n \n-extern std::unique_future<int>& get();\n+extern std::future<int>& get();\n \n void test01()\n {\n   // copy\n-  std::unique_future<int>& p1 = get();\n-  std::unique_future<int> p2(p1);\n+  std::future<int>& p1 = get();\n+  std::future<int> p2(p1);\n }\n \n // { dg-error \"used here\" \"\" { target *-*-* } 33 }\n-// { dg-error \"deleted function\" \"\" { target *-*-* } 418 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 577 }"}, {"sha": "5f301810d473e0483997c1b2d486d882e15deff8", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/default.cc", "status": "renamed", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fdefault.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -1,10 +1,9 @@\n-// { dg-do compile }\n // { dg-options \"-std=gnu++0x\" }\n // { dg-require-cstdint \"\" }\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,23 +22,30 @@\n \n \n #include <future>\n+#include <testsuite_hooks.h>\n #include <testsuite_tr1.h>\n \n void test01()\n {\n-  using std::unique_future;\n+  using std::future;\n   using namespace __gnu_test;\n \n-  unique_future<int> p1;            // { dg-error \"22: error: no match\" }\n-  unique_future<int&> p2;           // { dg-error \"23: error: no match\" }\n-  unique_future<void> p3;           // { dg-error \"23: error: no match\" }\n-  unique_future<ClassType> p4;      // { dg-error \"28: error: no match\" }\n-  unique_future<AbstractClass&> p5; // { dg-error \"33: error: no match\" }\n+  bool __attribute__((unused)) test = true;\n+\n+  future<int> p1;\n+  VERIFY( !p1.valid() );\n+  future<int&> p2;\n+  VERIFY( !p2.valid() );\n+  future<void> p3;\n+  VERIFY( !p3.valid() );\n+  future<ClassType> p4;\n+  VERIFY( !p4.valid() );\n+  future<AbstractClass&> p5;\n+  VERIFY( !p5.valid() );\n }\n \n int main()\n {\n   test01();\n   return 0;\n }\n-// { dg-excess-errors \"note\" }", "previous_filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/default_neg.cc"}, {"sha": "26493141e1051f191f5618c7dc5d2852ddf1ed90", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/move.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -30,8 +30,8 @@ void test01()\n {\n   // move\n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n-  std::unique_future<int> f2(std::move(f1));\n+  std::future<int> f1(p1.get_future());\n+  std::future<int> f2(std::move(f1));\n }\n \n int main()"}, {"sha": "3208cf8d4eb0eb05d365e8785d79aa06f997a149", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/cons/move_assign.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fcons%2Fmove_assign.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+std::future<int> get() { return std::promise<int>().get_future(); }\n+\n+void test01()\n+{\n+  // assign\n+  std::future<int> p1;\n+  std::future<int> p2 = get();\n+  p1 = std::move(p2);\n+  VERIFY( p1.valid() );\n+  VERIFY( !p2.valid() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a0e4a4326dc95035533c164b687a8d72c98588d2", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/get.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -34,30 +34,33 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::future<int> f1(p1.get_future());\n \n   p1.set_value(value);\n   VERIFY( f1.get() == value );\n+  VERIFY( !f1.valid() );\n }\n \n void test02()\n {\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int&> p1;\n-  std::unique_future<int&> f1(p1.get_future());\n+  std::future<int&> f1(p1.get_future());\n \n   p1.set_value(value);\n   VERIFY( &f1.get() == &value );\n+  VERIFY( !f1.valid() );\n }\n \n void test03()\n {\n   std::promise<void> p1;\n-  std::unique_future<void> f1(p1.get_future());\n+  std::future<void> f1(p1.get_future());\n \n   p1.set_value();\n   f1.get();\n+  VERIFY( !f1.valid() );\n }\n \n int main()"}, {"sha": "22ca15c39681fc43db698f788619c06187de2932", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/get2.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fget2.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -35,7 +35,7 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::future<int> f1(p1.get_future());\n \n   p1.set_exception(std::copy_exception(value));\n   try\n@@ -47,14 +47,15 @@ void test01()\n   {\n     VERIFY( e == value );\n   }\n+  VERIFY( !f1.valid() );\n }\n \n void test02()\n {\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int&> p1;\n-  std::unique_future<int&> f1(p1.get_future());\n+  std::future<int&> f1(p1.get_future());\n \n   p1.set_exception(std::copy_exception(value));\n   try\n@@ -66,14 +67,15 @@ void test02()\n   {\n     VERIFY( e == value );\n   }\n+  VERIFY( !f1.valid() );\n }\n \n void test03()\n {\n   bool test __attribute__((unused)) = true;\n \n   std::promise<void> p1;\n-  std::unique_future<void> f1(p1.get_future());\n+  std::future<void> f1(p1.get_future());\n \n   p1.set_exception(std::copy_exception(value));\n   try\n@@ -85,6 +87,7 @@ void test03()\n   {\n     VERIFY( e == value );\n   }\n+  VERIFY( !f1.valid() );\n }\n \n int main()"}, {"sha": "df5b57f5dce6c5cb6b90708758e82f931beb9f80", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/valid.cc", "status": "renamed", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fvalid.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fvalid.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fvalid.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -6,7 +6,7 @@\n // { dg-require-gthreads \"\" }\n // { dg-require-atomic-builtins \"\" }\n \n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,17 +31,22 @@ void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n+  std::future<int> f0;\n+  VERIFY( !f0.valid() );\n+\n   std::promise<int> p1;\n-  std::shared_future<int> f1(p1.get_future());\n-  std::shared_future<int> f2(f1);\n+  std::future<int> f1(p1.get_future());\n \n-  VERIFY( !f1.is_ready() );\n-  VERIFY( !f2.is_ready() );\n+  VERIFY( f1.valid() );\n \n   p1.set_value(1);\n \n-  VERIFY( f1.is_ready() );\n-  VERIFY( f2.is_ready() );\n+  VERIFY( f1.valid() );\n+\n+  f1 = std::move(f0);\n+\n+  VERIFY( !f1.valid() );\n+  VERIFY( !f0.valid() );\n }\n \n int main()", "previous_filename": "libstdc++-v3/testsuite/30_threads/shared_future/members/is_ready.cc"}, {"sha": "94a431f81832f96a4deed46180ec10c9e40fb6cd", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/wait.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -31,15 +31,15 @@\n #include <testsuite_hooks.h>\n \n \n-void wait(std::unique_future<void>& f)\n+void wait(std::future<void>& f)\n {\n   f.wait();\n }\n \n void test01()\n {\n   std::promise<void> p1;\n-  std::unique_future<void> f1(p1.get_future());\n+  std::future<void> f1(p1.get_future());\n \n   std::thread t1(wait, std::ref(f1));\n "}, {"sha": "0123caad34d1c0b72c298b90f94317e0ee62b749", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/wait_for.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_for.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_for.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_for.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -33,7 +33,7 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::future<int> f1(p1.get_future());\n \n   std::chrono::milliseconds delay(100);\n "}, {"sha": "bea1e0ea707c3b22648d17c9247c676808ad8212", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/members/wait_until.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_until.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_until.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Fmembers%2Fwait_until.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -38,7 +38,7 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   std::promise<int> p1;\n-  std::unique_future<int> f1(p1.get_future());\n+  std::future<int> f1(p1.get_future());\n \n   auto when = make_time(10);\n   VERIFY( !f1.wait_until(when) );"}, {"sha": "5d761b1d3d227e4c910b5db5062cddad225ec204", "filename": "libstdc++-v3/testsuite/30_threads/unique_future/requirements/explicit_instantiation.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_future%2Frequirements%2Fexplicit_instantiation.cc?ref=b3eed6fe78a26e3d93e9755ee908cebd10e8ac7d", "patch": "@@ -26,9 +26,9 @@\n #include <testsuite_tr1.h>\n \n using namespace __gnu_test;\n-using std::unique_future;\n-template class unique_future<int>;\n-template class unique_future<int&>;\n-template class unique_future<void>;\n-template class unique_future<ClassType>;\n-template class unique_future<ClassType&>;\n+using std::future;\n+template class future<int>;\n+template class future<int&>;\n+template class future<void>;\n+template class future<ClassType>;\n+template class future<ClassType&>;"}]}