{"sha": "eff3a27644c419c425e0e1a1585abefff3695ca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmM2EyNzY0NGM0MTljNDI1ZTBlMWExNTg1YWJlZmZmMzY5NWNhNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-08-26T16:23:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-08-26T16:23:33Z"}, "message": "re PR c++/28588 (static private function)\n\n\tPR c++/28588\n\t* class.c (resolve_address_of_overloaded_function): Add\n\taccess_path parameter.  Perform access checks.\n\t(instantiate_type): Adjust call to\n\tresolve_address_of_overloaded_function.  Remove unnecessary code.\n\t* tree.c (is_overloaded_fn): Document.  Return 2 when there are\n\tacutally multiple functions.\n\t(really_overloaded_fn): Use is_overloaded_fn.\n\t* mangle.c (write_expression): Handle BASELINKs.\n\t* cp-tree.h (really_overloaded_fn): Return bool.\n\t(baselink_for_fns): Declare.\n\t* search.c (lookup_member): Check access for single static\n\tfunctions here.\n\t* pt.c (convert_nontype_argument_function): Handle BASELINKs.\n\t(tsubst_copy_and_build): Generate BASELINKs for template-ids.\n\t* semantics.c (finish_call_expr): Use baselink_for_fns.\n\t(baselink_for_fns): New function.\n\t(finish_id_expression): Use it.\n\t* parser.c (cp_parser_template_argument): Don't strip BASELINKs.\n\tPR c++/28595\n\t* pt.c (tsubst): Issue errors about attempts to create VLAs at\n\ttemplate-instantiation time.\n\tPR c++/28588\n\t* g++.dg/inherit/access6.C: New test.\n\t* g++.dg/inherit/access7.C: Likewise.\n\tPR c++/28595\n\t* g++.dg/template/array15.C: New test.\n\t* g++.dg/template/crash2.C: Tweak error markers.\n\nFrom-SVN: r116468", "tree": {"sha": "0365ed4c2d70b546d5308383eda316cb067b2b23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0365ed4c2d70b546d5308383eda316cb067b2b23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eff3a27644c419c425e0e1a1585abefff3695ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff3a27644c419c425e0e1a1585abefff3695ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff3a27644c419c425e0e1a1585abefff3695ca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff3a27644c419c425e0e1a1585abefff3695ca5/comments", "author": null, "committer": null, "parents": [{"sha": "fa1ff4eb8cb4ec1474d6ab338b6840a2140b588d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1ff4eb8cb4ec1474d6ab338b6840a2140b588d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1ff4eb8cb4ec1474d6ab338b6840a2140b588d"}], "stats": {"total": 387, "additions": 215, "deletions": 172}, "files": [{"sha": "d7c952dd8804352bad65eae25554acc110847914", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -1,3 +1,29 @@\n+2006-08-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28588\n+\t* class.c (resolve_address_of_overloaded_function): Add\n+\taccess_path parameter.  Perform access checks.\n+\t(instantiate_type): Adjust call to\n+\tresolve_address_of_overloaded_function.  Remove unnecessary code.\n+\t* tree.c (is_overloaded_fn): Document.  Return 2 when there are\n+\tacutally multiple functions.\n+\t(really_overloaded_fn): Use is_overloaded_fn.\n+\t* mangle.c (write_expression): Handle BASELINKs.\n+\t* cp-tree.h (really_overloaded_fn): Return bool.\n+\t(baselink_for_fns): Declare.\n+\t* search.c (lookup_member): Check access for single static\n+\tfunctions here.\n+\t* pt.c (convert_nontype_argument_function): Handle BASELINKs.\n+\t(tsubst_copy_and_build): Generate BASELINKs for template-ids.\n+\t* semantics.c (finish_call_expr): Use baselink_for_fns.\n+\t(baselink_for_fns): New function.\n+\t(finish_id_expression): Use it.\n+\t* parser.c (cp_parser_template_argument): Don't strip BASELINKs.\n+\n+\tPR c++/28595\n+\t* pt.c (tsubst): Issue errors about attempts to create VLAs at\n+\ttemplate-instantiation time.\n+\n 2006-08-25  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/28853"}, {"sha": "673b07fb3d00ceb869079a17322dd361be92cfe7", "filename": "gcc/cp/class.c", "status": "modified", "additions": 36, "deletions": 125, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -134,8 +134,6 @@ static int method_name_cmp (const void *, const void *);\n static int resort_method_name_cmp (const void *, const void *);\n static void add_implicitly_declared_members (tree, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n-static tree resolve_address_of_overloaded_function (tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t    bool, tree);\n static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n static tree build_vtbl_initializer (tree, tree, tree, tree, int *);\n@@ -5673,18 +5671,21 @@ pop_lang_context (void)\n \n /* Given an OVERLOAD and a TARGET_TYPE, return the function that\n    matches the TARGET_TYPE.  If there is no satisfactory match, return\n-   error_mark_node, and issue an error & warning messages under control\n-   of FLAGS.  Permit pointers to member function if FLAGS permits.  If\n-   TEMPLATE_ONLY, the name of the overloaded function was a\n-   template-id, and EXPLICIT_TARGS are the explicitly provided\n-   template arguments.  */\n+   error_mark_node, and issue an error & warning messages under\n+   control of FLAGS.  Permit pointers to member function if FLAGS\n+   permits.  If TEMPLATE_ONLY, the name of the overloaded function was\n+   a template-id, and EXPLICIT_TARGS are the explicitly provided\n+   template arguments.  If OVERLOAD is for one or more member\n+   functions, then ACCESS_PATH is the base path used to reference\n+   those member functions.  */\n \n static tree\n resolve_address_of_overloaded_function (tree target_type,\n \t\t\t\t\ttree overload,\n \t\t\t\t\ttsubst_flags_t flags,\n \t\t\t\t\tbool template_only,\n-\t\t\t\t\ttree explicit_targs)\n+\t\t\t\t\ttree explicit_targs,\n+\t\t\t\t\ttree access_path)\n {\n   /* Here's what the standard says:\n \n@@ -5935,7 +5936,17 @@ resolve_address_of_overloaded_function (tree target_type,\n      function used.  If this conversion sequence is selected, the\n      function will be marked as used at this point.  */\n   if (!(flags & tf_conv))\n-    mark_used (fn);\n+    {\n+      mark_used (fn);\n+      /* We could not check access when this expression was originally\n+\t created since we did not know at that time to which function\n+\t the expression referred.  */\n+      if (DECL_FUNCTION_MEMBER_P (fn))\n+\t{\n+\t  gcc_assert (access_path);\n+\t  perform_or_defer_access_check (access_path, fn);\n+\t}\n+    }\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n     return build_unary_op (ADDR_EXPR, fn, 0);\n@@ -5964,6 +5975,7 @@ tree\n instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n {\n   tsubst_flags_t flags_in = flags;\n+  tree access_path = NULL_TREE;\n \n   flags &= ~tf_ptrmem_ok;\n \n@@ -5994,7 +6006,10 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     }\n \n   if (TREE_CODE (rhs) == BASELINK)\n-    rhs = BASELINK_FUNCTIONS (rhs);\n+    {\n+      access_path = BASELINK_ACCESS_BINFO (rhs);\n+      rhs = BASELINK_FUNCTIONS (rhs);\n+    }\n \n   /* If we are in a template, and have a NON_DEPENDENT_EXPR, we cannot\n      deduce any type information.  */\n@@ -6005,6 +6020,13 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       return error_mark_node;\n     }\n \n+  /* There only a few kinds of expressions that may have a type\n+     dependent on overload resolution.  */\n+  gcc_assert (TREE_CODE (rhs) == ADDR_EXPR\n+\t      || TREE_CODE (rhs) == COMPONENT_REF\n+\t      || TREE_CODE (rhs) == COMPOUND_EXPR\n+\t      || really_overloaded_fn (rhs));\n+\n   /* We don't overwrite rhs if it is an overloaded function.\n      Copying it would destroy the tree link.  */\n   if (TREE_CODE (rhs) != OVERLOAD)\n@@ -6017,32 +6039,6 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n   switch (TREE_CODE (rhs))\n     {\n-    case TYPE_EXPR:\n-    case CONVERT_EXPR:\n-    case SAVE_EXPR:\n-    case CONSTRUCTOR:\n-      gcc_unreachable ();\n-\n-    case INDIRECT_REF:\n-    case ARRAY_REF:\n-      {\n-\ttree new_rhs;\n-\n-\tnew_rhs = instantiate_type (build_pointer_type (lhstype),\n-\t\t\t\t    TREE_OPERAND (rhs, 0), flags);\n-\tif (new_rhs == error_mark_node)\n-\t  return error_mark_node;\n-\n-\tTREE_TYPE (rhs) = lhstype;\n-\tTREE_OPERAND (rhs, 0) = new_rhs;\n-\treturn rhs;\n-      }\n-\n-    case NOP_EXPR:\n-      rhs = copy_node (TREE_OPERAND (rhs, 0));\n-      TREE_TYPE (rhs) = unknown_type_node;\n-      return instantiate_type (lhstype, rhs, flags);\n-\n     case COMPONENT_REF:\n       {\n \ttree member = TREE_OPERAND (rhs, 1);\n@@ -6059,7 +6055,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n     case OFFSET_REF:\n       rhs = TREE_OPERAND (rhs, 1);\n       if (BASELINK_P (rhs))\n-\treturn instantiate_type (lhstype, BASELINK_FUNCTIONS (rhs), flags_in);\n+\treturn instantiate_type (lhstype, rhs, flags_in);\n \n       /* This can happen if we are forming a pointer-to-member for a\n \t member template.  */\n@@ -6075,22 +6071,17 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \treturn\n \t  resolve_address_of_overloaded_function (lhstype, fns, flags_in,\n \t\t\t\t\t\t  /*template_only=*/true,\n-\t\t\t\t\t\t  args);\n+\t\t\t\t\t\t  args, access_path);\n       }\n \n     case OVERLOAD:\n     case FUNCTION_DECL:\n       return\n \tresolve_address_of_overloaded_function (lhstype, rhs, flags_in,\n \t\t\t\t\t\t/*template_only=*/false,\n-\t\t\t\t\t\t/*explicit_targs=*/NULL_TREE);\n+\t\t\t\t\t\t/*explicit_targs=*/NULL_TREE,\n+\t\t\t\t\t\taccess_path);\n \n-    case CALL_EXPR:\n-      /* This is too hard for now.  */\n-      gcc_unreachable ();\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n     case COMPOUND_EXPR:\n       TREE_OPERAND (rhs, 0)\n \t= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), flags);\n@@ -6104,86 +6095,6 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       TREE_TYPE (rhs) = lhstype;\n       return rhs;\n \n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case RDIV_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case FIX_ROUND_EXPR:\n-    case FIX_FLOOR_EXPR:\n-    case FIX_CEIL_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case FLOAT_EXPR:\n-    case NEGATE_EXPR:\n-    case ABS_EXPR:\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-\n-    case PREINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      if (flags & tf_error)\n-\terror (\"invalid operation on uninstantiated type\");\n-      return error_mark_node;\n-\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case LT_EXPR:\n-    case LE_EXPR:\n-    case GT_EXPR:\n-    case GE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_NOT_EXPR:\n-      if (flags & tf_error)\n-\terror (\"not enough type information\");\n-      return error_mark_node;\n-\n-    case COND_EXPR:\n-      if (type_unknown_p (TREE_OPERAND (rhs, 0)))\n-\t{\n-\t  if (flags & tf_error)\n-\t    error (\"not enough type information\");\n-\t  return error_mark_node;\n-\t}\n-      TREE_OPERAND (rhs, 1)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n-      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n-\treturn error_mark_node;\n-      TREE_OPERAND (rhs, 2)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 2), flags);\n-      if (TREE_OPERAND (rhs, 2) == error_mark_node)\n-\treturn error_mark_node;\n-\n-      TREE_TYPE (rhs) = lhstype;\n-      return rhs;\n-\n-    case MODIFY_EXPR:\n-      TREE_OPERAND (rhs, 1)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 1), flags);\n-      if (TREE_OPERAND (rhs, 1) == error_mark_node)\n-\treturn error_mark_node;\n-\n-      TREE_TYPE (rhs) = lhstype;\n-      return rhs;\n-\n     case ADDR_EXPR:\n     {\n       if (PTRMEM_OK_P (rhs))"}, {"sha": "c50836b0be0ad4467d965d38f7f2cc9e81a4ede5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -4321,6 +4321,7 @@ extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n extern bool cxx_omp_privatize_by_reference\t(tree);\n+extern tree baselink_for_fns                    (tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,\n@@ -4364,7 +4365,7 @@ extern bool decl_anon_ns_mem_p\t\t\t(tree);\n extern tree lvalue_type\t\t\t\t(tree);\n extern tree error_type\t\t\t\t(tree);\n extern int varargs_function_p\t\t\t(tree);\n-extern int really_overloaded_fn\t\t\t(tree);\n+extern bool really_overloaded_fn\t\t(tree);\n extern bool cp_tree_equal\t\t\t(tree, tree);\n extern tree no_linkage_check\t\t\t(tree, bool);\n extern void debug_binfo\t\t\t\t(tree);"}, {"sha": "74ff8543eb42f82e84e3a2d70487d772ab4c1297", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -2023,6 +2023,12 @@ write_expression (tree expr)\n       code = TREE_CODE (expr);\n     }\n \n+  if (code == BASELINK)\n+    {\n+      expr = BASELINK_FUNCTIONS (expr);\n+      code = TREE_CODE (expr);\n+    }\n+\n   /* Handle pointers-to-members by making them look like expression\n      nodes.  */\n   if (code == PTRMEM_CST)"}, {"sha": "4e62340a0e9d724e327c65c42e4ae5406940c765", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -9237,11 +9237,6 @@ cp_parser_template_argument (cp_parser* parser)\n \t      argument = TREE_OPERAND (argument, 0);\n \t    }\n \n-\t  if (TREE_CODE (argument) == BASELINK)\n-\t    /* We don't need the information about what class was used\n-\t       to name the overloaded functions.  */\n-\t    argument = BASELINK_FUNCTIONS (argument);\n-\n \t  if (TREE_CODE (argument) == VAR_DECL)\n \t    {\n \t      /* A variable without external linkage might still be a"}, {"sha": "e078149fa770fd91aa6af355bff1ed9f556ddee5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -3454,7 +3454,9 @@ convert_nontype_argument_function (tree type, tree expr)\n   fn_no_ptr = fn;\n   if (TREE_CODE (fn_no_ptr) == ADDR_EXPR)\n     fn_no_ptr = TREE_OPERAND (fn_no_ptr, 0);\n-\n+  if (TREE_CODE (fn_no_ptr) == BASELINK)\n+    fn_no_ptr = BASELINK_FUNCTIONS (fn_no_ptr);\n+ \n   /* [temp.arg.nontype]/1\n \n      A template-argument for a non-type, non-template template-parameter\n@@ -7192,6 +7194,15 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tmax = tsubst_template_arg (omax, args, complain, in_decl);\n \tmax = fold_decl_constant_value (max);\n \n+\tif (TREE_CODE (max) != INTEGER_CST \n+\t    && TREE_CODE (max) != TEMPLATE_PARM_INDEX\n+\t    && !at_function_scope_p ())\n+\t  {\n+\t    if (complain & tf_error)\n+\t      error (\"array bound is not an integer constant\");\n+\t    return error_mark_node;\n+\t  }\n+\n \t/* [temp.deduct]\n \n \t   Type deduction may fail for any of the following\n@@ -7204,7 +7215,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t     indicated by the state of complain), so that\n \t     another substitution can be found.  */\n \t  return error_mark_node;\n-\n \telse if (TREE_CODE (max) == INTEGER_CST\n \t\t && INT_CST_LT (max, integer_zero_node))\n \t  {\n@@ -8824,7 +8834,7 @@ tsubst_copy_and_build (tree t,\n \t  return build3 (COMPONENT_REF, TREE_TYPE (template),\n \t\t\t object, template, NULL_TREE);\n \telse\n-\t  return template;\n+\t  return baselink_for_fns (template);\n       }\n \n     case INDIRECT_REF:"}, {"sha": "45a5ea3d10bcb674e18cb0afebf22e760d16318c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -1253,8 +1253,26 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n   /* [class.access]\n \n      In the case of overloaded function names, access control is\n-     applied to the function selected by overloaded resolution.  */\n-  if (rval && protect && !is_overloaded_fn (rval))\n+     applied to the function selected by overloaded resolution.  \n+\n+     We cannot check here, even if RVAL is only a single non-static\n+     member function, since we do not know what the \"this\" pointer\n+     will be.  For:\n+\n+        class A { protected: void f(); };\n+        class B : public A { \n+          void g(A *p) {\n+            f(); // OK\n+            p->f(); // Not OK.\n+          }\n+        };\n+\n+    only the first call to \"f\" is valid.  However, if the function is\n+    static, we can check.  */\n+  if (rval && protect \n+      && !really_overloaded_fn (rval)\n+      && !(TREE_CODE (rval) == FUNCTION_DECL\n+\t   && DECL_NONSTATIC_MEMBER_FUNCTION_P (rval)))\n     perform_or_defer_access_check (basetype_path, rval);\n \n   if (errstr && protect)"}, {"sha": "94e6dfd312cc5cf2ddae13539997b018658bb1bf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -1774,26 +1774,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       args = build_non_dependent_args (orig_args);\n     }\n \n-  /* A reference to a member function will appear as an overloaded\n-     function (rather than a BASELINK) if an unqualified name was used\n-     to refer to it.  */\n-  if (!BASELINK_P (fn) && is_overloaded_fn (fn))\n-    {\n-      tree f = fn;\n-\n-      if (TREE_CODE (f) == TEMPLATE_ID_EXPR)\n-\tf = TREE_OPERAND (f, 0);\n-      f = get_first_fn (f);\n-      if (DECL_FUNCTION_MEMBER_P (f))\n-\t{\n-\t  tree type = currently_open_derived_class (DECL_CONTEXT (f));\n-\t  if (!type)\n-\t    type = DECL_CONTEXT (f);\n-\t  fn = build_baselink (TYPE_BINFO (type),\n-\t\t\t       TYPE_BINFO (type),\n-\t\t\t       fn, /*optype=*/NULL_TREE);\n-\t}\n-    }\n+  if (is_overloaded_fn (fn))\n+    fn = baselink_for_fns (fn);\n \n   result = NULL_TREE;\n   if (BASELINK_P (fn))\n@@ -2405,6 +2387,36 @@ qualified_name_lookup_error (tree scope, tree name, tree decl)\n     error (\"%<::%D%> has not been declared\", name);\n }\n \n+/* If FNS is a member function, a set of member functions, or a\n+   template-id referring to one or more member functions, return a\n+   BASELINK for FNS, incorporating the current access context.\n+   Otherwise, return FNS unchanged.  */\n+\n+tree\n+baselink_for_fns (tree fns)\n+{\n+  tree fn;\n+  tree cl;\n+\n+  if (BASELINK_P (fns) \n+      || processing_template_decl\n+      || error_operand_p (fns))\n+    return fns;\n+  \n+  fn = fns;\n+  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+  fn = get_first_fn (fn);\n+  if (!DECL_FUNCTION_MEMBER_P (fn))\n+    return fns;\n+\n+  cl = currently_open_derived_class (DECL_CONTEXT (fn));\n+  if (!cl)\n+    cl = DECL_CONTEXT (fn);\n+  cl = TYPE_BINFO (cl);\n+  return build_baselink (cl, cl, fns, /*optype=*/NULL_TREE);\n+}\n+\n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n    if non-NULL, is the type or namespace used to explicitly qualify\n@@ -2793,8 +2805,12 @@ finish_id_expression (tree id_expression,\n \t}\n       else if (is_overloaded_fn (decl))\n \t{\n-\t  tree first_fn = OVL_CURRENT (decl);\n+\t  tree first_fn;\n \n+\t  first_fn = decl;\n+\t  if (TREE_CODE (first_fn) == TEMPLATE_ID_EXPR)\n+\t    first_fn = TREE_OPERAND (first_fn, 0);\n+\t  first_fn = get_first_fn (first_fn);\n \t  if (TREE_CODE (first_fn) == TEMPLATE_DECL)\n \t    first_fn = DECL_TEMPLATE_RESULT (first_fn);\n \n@@ -2811,6 +2827,8 @@ finish_id_expression (tree id_expression,\n \t      return finish_class_member_access_expr (decl, id_expression,\n \t\t\t\t\t\t      /*template_p=*/false);\n \t    }\n+\n+\t  decl = baselink_for_fns (decl);\n \t}\n       else\n \t{"}, {"sha": "db7e40a9cd45376c202bbf33732623b68b90ff6e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -842,6 +842,13 @@ build_qualified_name (tree type, tree scope, tree name, bool template_p)\n   return t;\n }\n \n+/* Returns non-zero if X is an expression for a (possibly overloaded)\n+   function.  If \"f\" is a function or function template, \"f\", \"c->f\",\n+   \"c.f\", \"C::f\", and \"f<int>\" will all be considered possibly\n+   overloaded functions.  Returns 2 if the function is actually\n+   overloaded, i.e., if it is impossible to know the the type of the\n+   function without performing overload resolution.  */\n+ \n int\n is_overloaded_fn (tree x)\n {\n@@ -850,24 +857,22 @@ is_overloaded_fn (tree x)\n     x = TREE_OPERAND (x, 1);\n   if (BASELINK_P (x))\n     x = BASELINK_FUNCTIONS (x);\n-  return (TREE_CODE (x) == FUNCTION_DECL\n-\t  || TREE_CODE (x) == TEMPLATE_ID_EXPR\n-\t  || DECL_FUNCTION_TEMPLATE_P (x)\n-\t  || TREE_CODE (x) == OVERLOAD);\n+  if (TREE_CODE (x) == TEMPLATE_ID_EXPR\n+      || DECL_FUNCTION_TEMPLATE_P (OVL_CURRENT (x))\n+      || (TREE_CODE (x) == OVERLOAD && OVL_CHAIN (x)))\n+    return 2;\n+  return  (TREE_CODE (x) == FUNCTION_DECL\n+\t   || TREE_CODE (x) == OVERLOAD);\n }\n \n-int\n+/* Returns true iff X is an expression for an overloaded function\n+   whose type cannot be known without performing overload\n+   resolution.  */\n+\n+bool\n really_overloaded_fn (tree x)\n {\n-  if (TREE_CODE (x) == OFFSET_REF)\n-    x = TREE_OPERAND (x, 1);\n-  /* A baselink is also considered an overloaded function.  */\n-  if (BASELINK_P (x))\n-    x = BASELINK_FUNCTIONS (x);\n-\n-  return ((TREE_CODE (x) == OVERLOAD && OVL_CHAIN (x))\n-\t  || DECL_FUNCTION_TEMPLATE_P (OVL_CURRENT (x))\n-\t  || TREE_CODE (x) == TEMPLATE_ID_EXPR);\n+  return is_overloaded_fn (x) == 2;\n }\n \n tree"}, {"sha": "017de891864a60557eb002ced2671f41e68ebe8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -1,3 +1,13 @@\n+2006-08-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28588\n+\t* g++.dg/inherit/access6.C: New test.\n+\t* g++.dg/inherit/access7.C: Likewise.\n+\n+\tPR c++/28595\n+\t* g++.dg/template/array15.C: New test.\n+\t* g++.dg/template/crash2.C: Tweak error markers.\n+\n 2006-08-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/28683"}, {"sha": "7645c2d5e0db6752e663489197e83e6e94c8f210", "filename": "gcc/testsuite/g++.dg/inherit/access6.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess6.C?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/28588\n+\n+class Foo { \n+  static void f(); // { dg-error \"private\" }\n+  static void f(int);\n+  static void g(); // { dg-error \"private\" }\n+};\n+\n+void h()\n+{\n+  Foo foo;\n+  void (*f)();\n+  f = foo.f; // { dg-error \"context\" }\n+  f = foo.g; // { dg-error \"context\" }\n+}"}, {"sha": "4e2db1479b7501e262e9fcb4155e852567c37da1", "filename": "gcc/testsuite/g++.dg/inherit/access7.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Faccess7.C?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -0,0 +1,15 @@\n+struct B {\n+  static void f();\n+};\n+\n+template <typename T>\n+struct D : private B {\n+  void g() {\n+    f();\n+  }\n+};\n+  \n+void h() {\n+  D<int> d;\n+  d.g();\n+}"}, {"sha": "b1e047d1d0053be3e21737cb57de7633f4a1f68a", "filename": "gcc/testsuite/g++.dg/template/array15.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray15.C?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/28595\n+\n+template<int> struct A\n+{\n+  static const int i;\n+};\n+\n+template<int N> struct B\n+{\n+  char c[A<N>::i], d; // { dg-error \"constant\" }\n+};\n+\n+B<0> b;"}, {"sha": "47c95ab067fd90f1b0b8f33a106a450c061b32a1", "filename": "gcc/testsuite/g++.dg/template/crash2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff3a27644c419c425e0e1a1585abefff3695ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C?ref=eff3a27644c419c425e0e1a1585abefff3695ca5", "patch": "@@ -5,7 +5,7 @@ class A\n {\n public:\n   static const EnumType size = max; // { dg-error \"\" }\n-  int table[size];\n+  int table[size]; // { dg-error \"constant\" }\n };\n template <class EnumType>\n const EnumType A<EnumType>::size;"}]}