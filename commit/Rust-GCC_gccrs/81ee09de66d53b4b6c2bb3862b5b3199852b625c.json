{"sha": "81ee09de66d53b4b6c2bb3862b5b3199852b625c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFlZTA5ZGU2NmQ1M2I0YjZjMmJiMzg2MmI1YjMxOTk4NTJiNjI1Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2006-06-16T06:32:22Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2006-06-16T06:32:22Z"}, "message": "type_utils.hpp (numeric_traits): Add, const expression interface to std::numeric_limits::min and max functions.\n\n2006-06-15  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/ext/pb_ds/detail/type_utils.hpp (numeric_traits): Add,\n\tconst expression interface to std::numeric_limits::min and max\n\tfunctions.\n\t* include/ext/pb_ds/trie_policy.hpp (string_trie_e_access_traits):\n\tUse it.\n\n\t* include/ext/pb_ds/detail/resize_policy/\n\thash_load_check_resize_trigger_imp.hpp: Format.\n\t* include/ext/pb_ds/detail/pat_trie_/internal_node.hpp: Same.\n\nFrom-SVN: r114706", "tree": {"sha": "9f32e7c333761f77937da32e77bf5a33d0ac485d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f32e7c333761f77937da32e77bf5a33d0ac485d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ee09de66d53b4b6c2bb3862b5b3199852b625c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ee09de66d53b4b6c2bb3862b5b3199852b625c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ee09de66d53b4b6c2bb3862b5b3199852b625c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ee09de66d53b4b6c2bb3862b5b3199852b625c/comments", "author": null, "committer": null, "parents": [{"sha": "4e95268d59d17d5d58d60f2067a79a215d65db73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e95268d59d17d5d58d60f2067a79a215d65db73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e95268d59d17d5d58d60f2067a79a215d65db73"}], "stats": {"total": 652, "additions": 250, "deletions": 402}, "files": [{"sha": "e45a51a773039778296d4aa9c5ebc14965b9c8ac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=81ee09de66d53b4b6c2bb3862b5b3199852b625c", "patch": "@@ -1,3 +1,15 @@\n+2006-06-15  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/ext/pb_ds/detail/type_utils.hpp (numeric_traits): Add,\n+\tconst expression interface to std::numeric_limits::min and max\n+\tfunctions.\n+\t* include/ext/pb_ds/trie_policy.hpp (string_trie_e_access_traits):\n+\tUse it.\n+\n+\t* include/ext/pb_ds/detail/resize_policy/\n+\thash_load_check_resize_trigger_imp.hpp: Format.\n+\t* include/ext/pb_ds/detail/pat_trie_/internal_node.hpp: Same.\n+\n 2006-06-15  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/random.tcc (mersenne_twister<>::operator()()):"}, {"sha": "b8020bc367f9d1e4a37d0be5763b0bcd773ad712", "filename": "libstdc++-v3/include/ext/pb_ds/detail/pat_trie_/internal_node.hpp", "status": "modified", "additions": 153, "deletions": 282, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fpat_trie_%2Finternal_node.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fpat_trie_%2Finternal_node.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fpat_trie_%2Finternal_node.hpp?ref=81ee09de66d53b4b6c2bb3862b5b3199852b625c", "patch": "@@ -49,158 +49,97 @@\n \n #ifdef PB_DS_PAT_TRIE_DEBUG_\n #include <cassert>\n-#endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+#endif \n \n namespace pb_ds\n {\n   namespace detail\n   {\n+#define PB_DS_CLASS_T_DEC \\\n+    template<typename Type_Traits, typename E_Access_Traits,  \\\n+\t     typename Metadata, typename Allocator>\n+\n+#define PB_DS_CLASS_C_DEC \\\n+    pat_trie_internal_node<Type_Traits, E_Access_Traits, Metadata, Allocator>\n+\n+#define PB_DS_BASE_C_DEC \\\n+    pat_trie_node_base<Type_Traits, E_Access_Traits, Metadata, Allocator>\n+\n+#define PB_DS_LEAF_C_DEC \\\n+    pat_trie_leaf<Type_Traits, E_Access_Traits, Metadata, Allocator>\n \n-#define PB_DS_CLASS_T_DEC\t\t\t\t\t\t\\\n-    template<\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\tclass Type_Traits,\t\\\n-\t\t\t\t\t\tclass E_Access_Traits,\t\\\n-\t\t\t\t\t\tclass Metadata,\t\t\\\n-\t\t\t\t\t\tclass Allocator>\n-\n-#define PB_DS_CLASS_C_DEC\t\t\t\t\t\t\\\n-    pat_trie_internal_node<\t\t\t\t\t\t\\\n-\t\t\t\t\t\tType_Traits,\t\t\\\n-\t\t\t\t\t\tE_Access_Traits,\t\\\n-\t\t\t\t\t\tMetadata,\t\t\\\n-\t\t\t\t\t\tAllocator>\n-\n-#define PB_DS_BASE_C_DEC\t\t\t\t\t\\\n-    pat_trie_node_base<\t\t\t\t\t\t\\\n-\t\t\t\t\tType_Traits,\t\t\\\n-\t\t\t\t\tE_Access_Traits,\t\\\n-\t\t\t\t\tMetadata,\t\t\\\n-\t\t\t\t\tAllocator>\n-\n-#define PB_DS_LEAF_C_DEC\t\t\t\t\t\t\\\n-    pat_trie_leaf<\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\tType_Traits,\t\t\\\n-\t\t\t\t\t\tE_Access_Traits,\t\\\n-\t\t\t\t\t\tMetadata,\t\t\\\n-\t\t\t\t\t\tAllocator>\n-\n-#define PB_DS_STATIC_ASSERT(UNIQUE, E)\t\t\t\t\t\\\n-    typedef\t\t\t\t\t\t\t\t\\\n-    static_assert_dumclass<\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\tsizeof(static_assert<(bool)(E)>)> \\\n-    UNIQUE##static_assert_type\n+#define PB_DS_STATIC_ASSERT(UNIQUE, E) \\\n+    typedef static_assert_dumclass<sizeof(static_assert<(bool)(E)>)> UNIQUE##static_assert_type\n \n #ifdef PB_DS_PAT_TRIE_DEBUG_\n #define PB_DS_DBG_ASSERT(X) assert(X)\n #define PB_DS_DBG_VERIFY(X) assert(X)\n #define PB_DS_DBG_ONLY(X) X\n-#else // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+#else \n #define PB_DS_DBG_ASSERT(X)\n-#define PB_DS_DBG_VERIFY(X) {if((X)==0);}\n+#define PB_DS_DBG_VERIFY(X) { if((X)==0); }\n #define PB_DS_DBG_ONLY(X) ;\n-#endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+#endif \n \n     template<typename Type_Traits,\n-\t     class E_Access_Traits,\n-\t     class Metadata,\n-\t     class Allocator>\n+\t     typename E_Access_Traits,\n+\t     typename Metadata,\n+\t     typename Allocator>\n     struct pat_trie_internal_node : public PB_DS_BASE_C_DEC\n     {\n-    public:\n-      enum\n-\t{\n-\t  arr_size =\n-\t  E_Access_Traits::max_size + 1\n-\t};\n-\n     private:\n-      typedef typename Allocator::size_type size_type;\n+      typedef PB_DS_BASE_C_DEC \t\t\tbase_type;\n+      typedef Type_Traits \t\t\ttype_traits;\n+      typedef typename type_traits::value_type \tvalue_type;\n+      typedef typename Allocator::size_type \tsize_type;\n \n       typedef E_Access_Traits e_access_traits;\n-\n-      typedef\n-      typename Allocator::template rebind<\n-\te_access_traits>::other::const_pointer\n-      const_e_access_traits_pointer;\n-\n       typedef typename e_access_traits::const_iterator const_e_iterator;\n+      typedef typename Allocator::template rebind<e_access_traits>::other access_rebind;\n+      typedef typename access_rebind::const_pointer const_e_access_traits_pointer;\n \n-      typedef\n-      typename Allocator::template rebind<\n-\tPB_DS_BASE_C_DEC >::other::pointer\n-      node_pointer;\n-\n-      typedef\n-      typename Allocator::template rebind<\n-\tPB_DS_BASE_C_DEC >::other::const_pointer\n-      const_node_pointer;\n+      typedef typename Allocator::template rebind<base_type>::other base_rebind;\n+      typedef typename base_rebind::pointer node_pointer;\n+      typedef typename base_rebind::const_pointer const_node_pointer;\n \n       typedef PB_DS_LEAF_C_DEC leaf;\n+      typedef typename Allocator::template rebind<leaf>::other leaf_rebind;\n+      typedef typename leaf_rebind::pointer leaf_pointer;\n+      typedef typename leaf_rebind::const_pointer const_leaf_pointer;\n \n-      typedef\n-      typename Allocator::template rebind<\n-\tleaf>::other\n-      leaf_allocator;\n-\n-      typedef typename leaf_allocator::pointer leaf_pointer;\n-\n-      typedef typename leaf_allocator::const_pointer const_leaf_pointer;\n-\n-      typedef\n-      typename Allocator::template rebind<\n-\tPB_DS_CLASS_C_DEC>::other\n-      internal_node_allocator;\n-\n-      typedef\n-      typename Allocator::template rebind<\n-\tPB_DS_CLASS_C_DEC>::other::const_pointer\n-      const_internal_node_pointer;\n-\n-      typedef\n-      typename Allocator::template rebind<\n-\tPB_DS_CLASS_C_DEC>::other::pointer\n-      internal_node_pointer;\n-\n-      PB_DS_STATIC_ASSERT(min_arr_size, arr_size >= 2);\n-\n-      typedef typename Type_Traits::value_type value_type;\n+      typedef typename Allocator::template rebind<pat_trie_internal_node>::other internal_node_rebind;\n+      typedef typename internal_node_rebind::pointer internal_node_pointer;\n+      typedef typename internal_node_rebind::const_pointer const_internal_node_pointer;\n \n #ifdef PB_DS_PAT_TRIE_DEBUG_\n-      typedef\n-      typename PB_DS_BASE_C_DEC::subtree_debug_info\n-      subtree_debug_info;\n-#endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+      typedef typename base_type::subtree_debug_info subtree_debug_info;\n \n-      typedef PB_DS_BASE_C_DEC base_type;\n+      virtual subtree_debug_info\n+      assert_valid_imp(const_e_access_traits_pointer) const;\n+#endif \n \n-    private:\n       inline size_type\n-      get_pref_pos(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits) const;\n-\n-#ifdef PB_DS_PAT_TRIE_DEBUG_\n-      virtual subtree_debug_info\n-      assert_valid_imp(const_e_access_traits_pointer p_traits) const;\n-#endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+      get_pref_pos(const_e_iterator, const_e_iterator, \n+\t\t   const_e_access_traits_pointer) const;\n \n     public:\n-      typedef\n-      typename Allocator::template rebind<\n-      node_pointer>::other::pointer\n-      node_pointer_pointer;\n+      typedef typename Allocator::template rebind<node_pointer>::other node_pointer_rebind;\n+      typedef typename node_pointer_rebind::pointer node_pointer_pointer;\n+      typedef typename node_pointer_rebind::reference node_pointer_reference;\n \n-      typedef\n-      typename Allocator::template rebind<\n-\tnode_pointer>::other::reference\n-      node_pointer_reference;\n+      enum\n+\t{\n+\t  arr_size = E_Access_Traits::max_size + 1\n+\t};\n+      PB_DS_STATIC_ASSERT(min_arr_size, arr_size >= 2);\n \n #include <ext/pb_ds/detail/pat_trie_/const_child_iterator.hpp>\n #include <ext/pb_ds/detail/pat_trie_/child_iterator.hpp>\n \n-    public:\n-      pat_trie_internal_node(size_type e_ind, const const_e_iterator pref_b_it);\n+      pat_trie_internal_node(size_type, const const_e_iterator);\n \n       void\n-      update_prefixes(const_e_access_traits_pointer p_traits);\n+      update_prefixes(const_e_access_traits_pointer);\n \n       const_iterator\n       begin() const;\n@@ -215,25 +154,30 @@ namespace pb_ds\n       end();\n \n       inline node_pointer\n-      get_child_node(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits);\n+      get_child_node(const_e_iterator, const_e_iterator, \n+\t\t     const_e_access_traits_pointer);\n \n       inline const_node_pointer\n-      get_child_node(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits) const;\n+      get_child_node(const_e_iterator, const_e_iterator, \n+\t\t     const_e_access_traits_pointer) const;\n \n       inline iterator\n-      get_child_it(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits);\n+      get_child_it(const_e_iterator, const_e_iterator, \n+\t\t   const_e_access_traits_pointer);\n \n       inline node_pointer\n-      get_lower_bound_child_node(const_e_iterator b_it, const_e_iterator e_it, size_type checked_ind, const_e_access_traits_pointer p_traits);\n+      get_lower_bound_child_node(const_e_iterator, const_e_iterator, \n+\t\t\t\t size_type, const_e_access_traits_pointer);\n \n       inline node_pointer\n-      add_child(node_pointer p_nd, const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits);\n+      add_child(node_pointer, const_e_iterator, const_e_iterator, \n+\t\tconst_e_access_traits_pointer);\n \n       inline const_node_pointer\n-      get_join_child(const_node_pointer p_nd, const_e_access_traits_pointer p_traits) const;\n+      get_join_child(const_node_pointer, const_e_access_traits_pointer) const;\n \n       inline node_pointer\n-      get_join_child(node_pointer p_nd, const_e_access_traits_pointer p_traits);\n+      get_join_child(node_pointer, const_e_access_traits_pointer);\n \n       void\n       remove_child(node_pointer p_nd);\n@@ -242,7 +186,8 @@ namespace pb_ds\n       remove_child(iterator it);\n \n       void\n-      replace_child(node_pointer p_nd, const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits);\n+      replace_child(node_pointer, const_e_iterator, const_e_iterator, \n+\t\t    const_e_access_traits_pointer);\n \n       inline const_e_iterator\n       pref_b_it() const;\n@@ -254,7 +199,8 @@ namespace pb_ds\n       get_e_ind() const;\n \n       bool\n-      should_be_mine(const_e_iterator b_it, const_e_iterator e_it, size_type checked_ind, const_e_access_traits_pointer p_traits) const;\n+      should_be_mine(const_e_iterator, const_e_iterator, size_type, \n+\t\t     const_e_access_traits_pointer) const;\n \n       leaf_pointer\n       leftmost_descendant();\n@@ -271,58 +217,49 @@ namespace pb_ds\n #ifdef PB_DS_PAT_TRIE_DEBUG_\n       size_type\n       e_ind() const;\n-#endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n+#endif \n \n     private:\n-      pat_trie_internal_node(const PB_DS_CLASS_C_DEC& other);\n+      pat_trie_internal_node(const pat_trie_internal_node&);\n \n       size_type\n       get_begin_pos() const;\n \n-    private:\n       const size_type m_e_ind;\n-\n       const_e_iterator m_pref_b_it;\n       const_e_iterator m_pref_e_it;\n-\n       node_pointer m_a_p_children[arr_size];\n-\n-      static leaf_allocator s_leaf_alloc;\n-\n-      static internal_node_allocator s_internal_node_alloc;\n+      static leaf_rebind s_leaf_alloc;\n+      static internal_node_rebind s_internal_node_alloc;\n     };\n \n     PB_DS_CLASS_T_DEC\n-    typename PB_DS_CLASS_C_DEC::leaf_allocator\n+    typename PB_DS_CLASS_C_DEC::leaf_rebind\n     PB_DS_CLASS_C_DEC::s_leaf_alloc;\n \n     PB_DS_CLASS_T_DEC\n-    typename PB_DS_CLASS_C_DEC::internal_node_allocator\n+    typename PB_DS_CLASS_C_DEC::internal_node_rebind\n     PB_DS_CLASS_C_DEC::s_internal_node_alloc;\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::size_type\n     PB_DS_CLASS_C_DEC::\n-    get_pref_pos(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits) const\n+    get_pref_pos(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t const_e_access_traits_pointer p_traits) const\n     {\n       if (static_cast<size_t>(std::distance(b_it, e_it)) <= m_e_ind)\n-\treturn (0);\n-\n+\treturn 0;\n       std::advance(b_it, m_e_ind);\n-\n-      return (1 + p_traits->e_pos(*b_it));\n+      return 1 + p_traits->e_pos(*b_it);\n     }\n \n     PB_DS_CLASS_T_DEC\n     PB_DS_CLASS_C_DEC::\n     pat_trie_internal_node(size_type e_ind, const const_e_iterator pref_b_it) :\n       PB_DS_BASE_C_DEC(pat_trie_internal_node_type),\n-      m_e_ind(e_ind),\n-      m_pref_b_it(pref_b_it),\n-      m_pref_e_it(pref_b_it)\n+      m_e_ind(e_ind), m_pref_b_it(pref_b_it), m_pref_e_it(pref_b_it)\n     {\n       std::advance(m_pref_e_it, m_e_ind);\n-\n       std::fill(m_a_p_children, m_a_p_children + arr_size,\n \t\tstatic_cast<node_pointer>(NULL));\n     }\n@@ -332,22 +269,18 @@ namespace pb_ds\n     PB_DS_CLASS_C_DEC::\n     update_prefixes(const_e_access_traits_pointer p_traits)\n     {\n-      node_pointer p_first =* begin();\n-\n+      node_pointer p_first = *begin();\n       if (p_first->m_type == pat_trie_leaf_node_type)\n-\tm_pref_b_it =\n-\t  p_traits->begin(\n-\t\t\t  E_Access_Traits::extract_key(\n-\t\t\t\t\t\t       static_cast<const_leaf_pointer>(p_first)->value()));\n+\t{\n+\t  const_leaf_pointer p = static_cast<const_leaf_pointer>(p_first);\n+\t  m_pref_b_it = p_traits->begin(e_access_traits::extract_key(p->value()));\n+\t}\n       else\n \t{\n \t  PB_DS_DBG_ASSERT(p_first->m_type == pat_trie_internal_node_type);\n-\n \t  m_pref_b_it = static_cast<internal_node_pointer>(p_first)->pref_b_it();\n \t}\n-\n       m_pref_e_it = m_pref_b_it;\n-\n       std::advance(m_pref_e_it, m_e_ind);\n     }\n \n@@ -356,138 +289,124 @@ namespace pb_ds\n     PB_DS_CLASS_C_DEC::\n     begin() const\n     {\n-      return (const_iterator(\n-\t\t\t     const_cast<node_pointer_pointer>(m_a_p_children) + get_begin_pos(),\n-\t\t\t     const_cast<node_pointer_pointer>(m_a_p_children) + arr_size));\n+      typedef node_pointer_pointer pointer_type;\n+      pointer_type p = const_cast<pointer_type>(m_a_p_children);\n+      return const_iterator(p + get_begin_pos(), p + arr_size);\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::iterator\n     PB_DS_CLASS_C_DEC::\n     begin()\n     {\n-      return (iterator(\n-\t\t       m_a_p_children + get_begin_pos(),\n-\t\t       m_a_p_children + arr_size));\n+      return iterator(m_a_p_children + get_begin_pos(), \n+\t\t      m_a_p_children + arr_size);\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::const_iterator\n     PB_DS_CLASS_C_DEC::\n     end() const\n     {\n-      return (const_iterator(\n-\t\t\t     const_cast<node_pointer_pointer>(m_a_p_children) + arr_size,\n-\t\t\t     const_cast<node_pointer_pointer>(m_a_p_children) + arr_size));\n+      typedef node_pointer_pointer pointer_type;\n+      pointer_type p = const_cast<pointer_type>(m_a_p_children) + arr_size;\n+      return const_iterator(p, p);\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::iterator\n     PB_DS_CLASS_C_DEC::\n     end()\n-    {\n-      return (iterator(        m_a_p_children + arr_size, m_a_p_children + arr_size));\n-    }\n+    { return iterator(m_a_p_children + arr_size, m_a_p_children + arr_size); }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::node_pointer\n     PB_DS_CLASS_C_DEC::\n-    get_child_node(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits)\n+    get_child_node(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t   const_e_access_traits_pointer p_traits)\n     {\n-      const size_type i = get_pref_pos(        b_it, e_it, p_traits);\n-\n+      const size_type i = get_pref_pos(b_it, e_it, p_traits);\n       PB_DS_DBG_ASSERT(i < arr_size);\n-\n-      return (m_a_p_children[i]);\n+      return m_a_p_children[i];\n     }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::iterator\n     PB_DS_CLASS_C_DEC::\n-    get_child_it(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits)\n+    get_child_it(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t const_e_access_traits_pointer p_traits)\n     {\n-      const size_type i = get_pref_pos(        b_it, e_it, p_traits);\n-\n+      const size_type i = get_pref_pos(b_it, e_it, p_traits);\n       PB_DS_DBG_ASSERT(i < arr_size);\n-\n       PB_DS_DBG_ASSERT(m_a_p_children[i] != NULL);\n-\n-      return (iterator(m_a_p_children + i, m_a_p_children + i));\n+      return iterator(m_a_p_children + i, m_a_p_children + i);\n     }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::const_node_pointer\n     PB_DS_CLASS_C_DEC::\n-    get_child_node(const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits) const\n-    {\n-      return (const_cast<node_pointer>(get_child_node(b_it, e_it, p_traits)));\n-    }\n+    get_child_node(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t   const_e_access_traits_pointer p_traits) const\n+    { return const_cast<node_pointer>(get_child_node(b_it, e_it, p_traits)); }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::node_pointer\n     PB_DS_CLASS_C_DEC::\n-    get_lower_bound_child_node(const_e_iterator b_it, const_e_iterator e_it, size_type checked_ind, const_e_access_traits_pointer p_traits)\n+    get_lower_bound_child_node(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t\t       size_type checked_ind, \n+\t\t\t       const_e_access_traits_pointer p_traits)\n     {\n       if (!should_be_mine(b_it, e_it, checked_ind, p_traits))\n \t{\n \t  if (p_traits->cmp_prefixes(b_it, e_it, m_pref_b_it, m_pref_e_it, true))\n-\t    return (leftmost_descendant());\n-\n-\t  return (rightmost_descendant());\n+\t    return leftmost_descendant();\n+\t  return rightmost_descendant();\n \t}\n \n-      size_type i = get_pref_pos(        b_it, e_it, p_traits);\n-\n+      size_type i = get_pref_pos(b_it, e_it, p_traits);\n       PB_DS_DBG_ASSERT(i < arr_size);\n \n       if (m_a_p_children[i] != NULL)\n-\treturn (m_a_p_children[i]);\n+\treturn m_a_p_children[i];\n \n       while (++i < arr_size)\n \tif (m_a_p_children[i] != NULL)\n \t  {\n \t    if (m_a_p_children[i]->m_type == pat_trie_leaf_node_type)\n-\t      return (m_a_p_children[i]);\n+\t      return m_a_p_children[i];\n \n-\t    PB_DS_DBG_ASSERT(m_a_p_children[i]->m_type ==\n-\t\t\t     pat_trie_internal_node_type);\n+\t    PB_DS_DBG_ASSERT(m_a_p_children[i]->m_type == pat_trie_internal_node_type);\n \n-\t    return (static_cast<internal_node_pointer>(\n-\t\t\t\t\t\t       m_a_p_children[i])->leftmost_descendant());\n+\t    return static_cast<internal_node_pointer>(m_a_p_children[i])->leftmost_descendant();\n \t  }\n \n-      return (rightmost_descendant());\n+      return rightmost_descendant();\n     }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::node_pointer\n     PB_DS_CLASS_C_DEC::\n-    add_child(node_pointer p_nd, const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits)\n+    add_child(node_pointer p_nd, const_e_iterator b_it, const_e_iterator e_it, \n+\t      const_e_access_traits_pointer p_traits)\n     {\n-      const size_type i = get_pref_pos(        b_it, e_it, p_traits);\n-\n+      const size_type i = get_pref_pos(b_it, e_it, p_traits);\n       PB_DS_DBG_ASSERT(i < arr_size);\n-\n       if (m_a_p_children[i] == NULL)\n \t{\n \t  m_a_p_children[i] = p_nd;\n-\n \t  p_nd->m_p_parent = this;\n-\n-\t  return (p_nd);\n+\t  return p_nd;\n \t}\n-\n-      return (m_a_p_children[i]);\n+      return m_a_p_children[i];\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::const_node_pointer\n     PB_DS_CLASS_C_DEC::\n     get_join_child(const_node_pointer p_nd, const_e_access_traits_pointer p_traits) const\n     {\n-      return (const_cast<internal_node_pointer>(this)->get_join_child(\n-\t\t\t\t\t\t\t\t      const_cast<node_pointer>(p_nd),\n-\t\t\t\t\t\t\t\t      p_traits));\n+      node_pointer p = const_cast<node_pointer>(p_nd);\n+      return const_cast<internal_node_pointer>(this)->get_join_child(p, p_traits);\n     }\n \n     PB_DS_CLASS_T_DEC\n@@ -496,15 +415,12 @@ namespace pb_ds\n     get_join_child(node_pointer p_nd, const_e_access_traits_pointer p_traits)\n     {\n       size_type i;\n-\n       const_e_iterator b_it;\n       const_e_iterator e_it;\n-\n       if (p_nd->m_type == pat_trie_leaf_node_type)\n \t{\n \t  typename Type_Traits::const_key_reference r_key =\n-\t    e_access_traits::extract_key(\n-\t\t\t\t\t static_cast<const_leaf_pointer>(p_nd)->value());\n+\t    e_access_traits::extract_key(static_cast<const_leaf_pointer>(p_nd)->value());\n \n \t  b_it = p_traits->begin(r_key);\n \t  e_it = p_traits->end(r_key);\n@@ -514,12 +430,9 @@ namespace pb_ds\n \t  b_it = static_cast<internal_node_pointer>(p_nd)->pref_b_it();\n \t  e_it = static_cast<internal_node_pointer>(p_nd)->pref_e_it();\n \t}\n-\n       i = get_pref_pos(b_it, e_it, p_traits);\n-\n       PB_DS_DBG_ASSERT(i < arr_size);\n-\n-      return (m_a_p_children[i]);\n+      return m_a_p_children[i];\n     }\n \n     PB_DS_CLASS_T_DEC\n@@ -528,15 +441,12 @@ namespace pb_ds\n     remove_child(node_pointer p_nd)\n     {\n       size_type i = 0;\n-\n       for (; i < arr_size; ++i)\n \tif (m_a_p_children[i] == p_nd)\n \t  {\n \t    m_a_p_children[i] = NULL;\n-\n \t    return;\n \t  }\n-\n       PB_DS_DBG_ASSERT(i != arr_size);\n     }\n \n@@ -546,64 +456,55 @@ namespace pb_ds\n     remove_child(iterator it)\n     {\n       iterator ret = it;\n-\n       ++ret;\n-\n       * it.m_p_p_cur = NULL;\n-\n-      return (ret);\n+      return ret;\n     }\n \n     PB_DS_CLASS_T_DEC\n     void\n     PB_DS_CLASS_C_DEC::\n-    replace_child(node_pointer p_nd, const_e_iterator b_it, const_e_iterator e_it, const_e_access_traits_pointer p_traits)\n+    replace_child(node_pointer p_nd, const_e_iterator b_it, \n+\t\t  const_e_iterator e_it, \n+\t\t  const_e_access_traits_pointer p_traits)\n     {\n-      const size_type i = get_pref_pos(        b_it, e_it, p_traits);\n-\n+      const size_type i = get_pref_pos(b_it, e_it, p_traits);\n       PB_DS_DBG_ASSERT(i < arr_size);\n-\n       m_a_p_children[i] = p_nd;\n-\n       p_nd->m_p_parent = this;\n     }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::const_e_iterator\n     PB_DS_CLASS_C_DEC::\n     pref_b_it() const\n-    {\n-      return (m_pref_b_it);\n-    }\n+    { return m_pref_b_it; }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::const_e_iterator\n     PB_DS_CLASS_C_DEC::\n     pref_e_it() const\n-    {\n-      return (m_pref_e_it);\n-    }\n+    { return m_pref_e_it; }\n \n     PB_DS_CLASS_T_DEC\n     inline typename PB_DS_CLASS_C_DEC::size_type\n     PB_DS_CLASS_C_DEC::\n     get_e_ind() const\n-    {\n-      return (m_e_ind);\n-    }\n+    { return m_e_ind; }\n \n     PB_DS_CLASS_T_DEC\n     bool\n     PB_DS_CLASS_C_DEC::\n-    should_be_mine(const_e_iterator b_it, const_e_iterator e_it, size_type checked_ind, const_e_access_traits_pointer p_traits) const\n+    should_be_mine(const_e_iterator b_it, const_e_iterator e_it, \n+\t\t   size_type checked_ind, \n+\t\t   const_e_access_traits_pointer p_traits) const\n     {\n       if (m_e_ind == 0)\n-\treturn (true);\n+\treturn true;\n \n       const size_type num_es = std::distance(b_it, e_it);\n-\n       if (num_es < m_e_ind)\n-\treturn (false);\n+\treturn false;\n \n       const_e_iterator key_b_it = b_it;\n       std::advance(key_b_it, checked_ind);\n@@ -615,7 +516,8 @@ namespace pb_ds\n       const_e_iterator value_e_it = m_pref_b_it;\n       std::advance(value_e_it, m_e_ind);\n \n-      return (p_traits->equal_prefixes(            key_b_it, key_e_it, value_b_it, value_e_it));\n+      return p_traits->equal_prefixes(key_b_it, key_e_it, value_b_it, \n+\t\t\t\t      value_e_it);\n     }\n \n     PB_DS_CLASS_T_DEC\n@@ -624,21 +526,18 @@ namespace pb_ds\n     leftmost_descendant()\n     {\n       node_pointer p_pot =* begin();\n-\n       if (p_pot->m_type == pat_trie_leaf_node_type)\n \treturn (static_cast<leaf_pointer>(p_pot));\n-\n       PB_DS_DBG_ASSERT(p_pot->m_type == pat_trie_internal_node_type);\n-\n-      return (static_cast<internal_node_pointer>(p_pot)->leftmost_descendant());\n+      return static_cast<internal_node_pointer>(p_pot)->leftmost_descendant();\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::const_leaf_pointer\n     PB_DS_CLASS_C_DEC::\n     leftmost_descendant() const\n     {\n-      return (const_cast<internal_node_pointer>(this)->leftmost_descendant());\n+      return const_cast<internal_node_pointer>(this)->leftmost_descendant();\n     }\n \n     PB_DS_CLASS_T_DEC\n@@ -647,38 +546,31 @@ namespace pb_ds\n     rightmost_descendant()\n     {\n       const size_type num_children = std::distance(begin(), end());\n-\n       PB_DS_DBG_ASSERT(num_children >= 2);\n \n       iterator it = begin();\n       std::advance(it, num_children - 1);\n-\n       node_pointer p_pot =* it;\n-\n       if (p_pot->m_type == pat_trie_leaf_node_type)\n-\treturn (static_cast<leaf_pointer>(p_pot));\n-\n+\treturn static_cast<leaf_pointer>(p_pot);\n       PB_DS_DBG_ASSERT(p_pot->m_type == pat_trie_internal_node_type);\n-\n-      return (static_cast<internal_node_pointer>(p_pot)->rightmost_descendant());\n+      return static_cast<internal_node_pointer>(p_pot)->rightmost_descendant();\n     }\n \n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::const_leaf_pointer\n     PB_DS_CLASS_C_DEC::\n     rightmost_descendant() const\n     {\n-      return (const_cast<internal_node_pointer>(this)->rightmost_descendant());\n+      return const_cast<internal_node_pointer>(this)->rightmost_descendant();\n     }\n \n #ifdef PB_DS_PAT_TRIE_DEBUG_\n     PB_DS_CLASS_T_DEC\n     typename PB_DS_CLASS_C_DEC::size_type\n     PB_DS_CLASS_C_DEC::\n     e_ind() const\n-    {\n-      return (m_e_ind);\n-    }\n+    { return m_e_ind; }\n #endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n \n     PB_DS_CLASS_T_DEC\n@@ -687,11 +579,9 @@ namespace pb_ds\n     get_begin_pos() const\n     {\n       size_type i;\n-\n-      for (i = 0; i < arr_size&&  m_a_p_children[i] == NULL; ++i)\n+      for (i = 0; i < arr_size && m_a_p_children[i] == NULL; ++i)\n \t;\n-\n-      return (i);\n+      return i;\n     }\n \n #ifdef PB_DS_PAT_TRIE_DEBUG_\n@@ -701,46 +591,28 @@ namespace pb_ds\n     assert_valid_imp(const_e_access_traits_pointer p_traits) const\n     {\n       PB_DS_DBG_ASSERT(base_type::m_type == pat_trie_internal_node_type);\n-\n-      PB_DS_DBG_ASSERT(\n-\t\t       static_cast<size_type>(std::distance(pref_b_it(), pref_e_it())) ==\n-\t\t       m_e_ind);\n-\n-      PB_DS_DBG_ASSERT(\n-\t\t       std::distance(begin(), end()) >= 2);\n+      PB_DS_DBG_ASSERT(static_cast<size_type>(std::distance(pref_b_it(), pref_e_it())) == m_e_ind);\n+      PB_DS_DBG_ASSERT(std::distance(begin(), end()) >= 2);\n \n       for (typename pat_trie_internal_node::const_iterator it = begin();\n \t   it != end(); ++it)\n \t{\n \t  const_node_pointer p_nd =* it;\n-\n \t  PB_DS_DBG_ASSERT(p_nd->m_p_parent == this);\n-\n \t  subtree_debug_info child_ret = p_nd->assert_valid_imp(p_traits);\n \n-\t  PB_DS_DBG_ASSERT(\n-\t\t\t   static_cast<size_type>(std::distance(child_ret.first, child_ret.second)) >=\n-\t\t\t   m_e_ind);\n-\n+\t  PB_DS_DBG_ASSERT(static_cast<size_type>(std::distance(child_ret.first, child_ret.second)) >= m_e_ind);\n \t  PB_DS_DBG_ASSERT(should_be_mine(child_ret.first, child_ret.second, 0, p_traits));\n-\n-\t  PB_DS_DBG_ASSERT(\n-\t\t\t   get_pref_pos(child_ret.first, child_ret.second, p_traits) ==\n-\t\t\t   static_cast<size_type>(it.m_p_p_cur - m_a_p_children));\n+\t  PB_DS_DBG_ASSERT(get_pref_pos(child_ret.first, child_ret.second, p_traits) == static_cast<size_type>(it.m_p_p_cur - m_a_p_children));\n \t}\n-\n-      return (std::make_pair(pref_b_it(), pref_e_it()));\n+      return std::make_pair(pref_b_it(), pref_e_it());\n     }\n #endif // #ifdef PB_DS_PAT_TRIE_DEBUG_\n \n #undef PB_DS_CLASS_T_DEC\n-\n #undef PB_DS_CLASS_C_DEC\n-\n #undef PB_DS_BASE_C_DEC\n-\n #undef PB_DS_LEAF_C_DEC\n-\n #undef PB_DS_STATIC_ASSERT\n \n #undef PB_DS_DBG_ASSERT\n@@ -750,5 +622,4 @@ namespace pb_ds\n   } // namespace detail\n } // namespace pb_ds\n \n-#endif // #ifndef PB_DS_PAT_TRIE_NODE_BASE_HPP\n-\n+#endif"}, {"sha": "e2992866138beba6c026a1cae1f4763f1151a63c", "filename": "libstdc++-v3/include/ext/pb_ds/detail/resize_policy/hash_load_check_resize_trigger_imp.hpp", "status": "modified", "additions": 55, "deletions": 114, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Fresize_policy%2Fhash_load_check_resize_trigger_imp.hpp?ref=81ee09de66d53b4b6c2bb3862b5b3199852b625c", "patch": "@@ -44,127 +44,97 @@\n  * Contains a resize trigger implementation.\n  */\n \n-#define PB_DS_STATIC_ASSERT(UNIQUE, E)\t\t\t\t\t\\\n-  typedef detail::static_assert_dumclass<sizeof(detail::static_assert<(bool)(E)>)> \\\n-  UNIQUE##static_assert_type\n+#define PB_DS_STATIC_ASSERT(UNIQUE, E) \\\n+  typedef detail::static_assert_dumclass<sizeof(detail::static_assert<(bool)(E)>)> UNIQUE##static_assert_type\n \n PB_DS_CLASS_T_DEC\n PB_DS_CLASS_C_DEC::\n-hash_load_check_resize_trigger(float load_min, float load_max) :\n-  m_load_min(load_min),\n-  m_load_max(load_max),\n-  m_next_shrink_size(0),\n-  m_next_grow_size(0),\n-  m_resize_needed(false)\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+hash_load_check_resize_trigger(float load_min, float load_max) \n+: m_load_min(load_min), m_load_max(load_max), m_next_shrink_size(0),\n+  m_next_grow_size(0), m_resize_needed(false)\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_find_search_start()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_find_search_collision()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_find_search_end()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_insert_search_start()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_insert_search_collision()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_insert_search_end()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_erase_search_start()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_erase_search_collision()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_erase_search_end()\n-{\n-  PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+{ PB_DS_DBG_ONLY(assert_valid();) }\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_inserted(size_type num_entries)\n {\n   m_resize_needed = (num_entries >= m_next_grow_size);\n-\n   size_base::set_size(num_entries);\n-\n   PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n inline void\n PB_DS_CLASS_C_DEC::\n notify_erased(size_type num_entries)\n {\n   size_base::set_size(num_entries);\n-\n-  m_resize_needed =\n-    num_entries <= m_next_shrink_size;\n-\n+  m_resize_needed = num_entries <= m_next_shrink_size;\n   PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n inline bool\n PB_DS_CLASS_C_DEC::\n is_resize_needed() const\n {\n   PB_DS_DBG_ONLY(assert_valid();)\n-\n-    return (m_resize_needed);\n+  return m_resize_needed;\n }\n \n PB_DS_CLASS_T_DEC\n@@ -173,133 +143,111 @@ PB_DS_CLASS_C_DEC::\n is_grow_needed(size_type /*size*/, size_type num_entries) const\n {\n   PB_DS_DBG_ASSERT(m_resize_needed);\n-\n-  return (num_entries >= m_next_grow_size);\n+  return num_entries >= m_next_grow_size;\n }\n \n PB_DS_CLASS_T_DEC\n PB_DS_CLASS_C_DEC::\n-~hash_load_check_resize_trigger()\n-{ }\n+~hash_load_check_resize_trigger() { }\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n notify_resized(size_type new_size)\n {\n   m_resize_needed = false;\n-\n-  m_next_grow_size =\n-    size_type(m_load_max*  new_size - 1);\n-\n-  m_next_shrink_size =\n-    size_type(m_load_min*  new_size);\n+  m_next_grow_size = size_type(m_load_max * new_size - 1);\n+  m_next_shrink_size = size_type(m_load_min * new_size);\n \n #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n   std::cerr << \"hlcrt::notify_resized \" <<\n-    static_cast<unsigned long>(new_size) <<    \"    \" <<\n-    static_cast<unsigned long>(m_load_min) <<    \"    \" <<\n-    static_cast<unsigned long>(m_load_max) <<    \"    \" <<\n+    static_cast<unsigned long>(new_size) << \"    \" <<\n+    static_cast<unsigned long>(m_load_min) << \"    \" <<\n+    static_cast<unsigned long>(m_load_max) << \"    \" <<\n     static_cast<unsigned long>(m_next_shrink_size) << \" \" <<\n-    static_cast<unsigned long>(m_next_grow_size) <<    \"    \" << std::endl;\n-#endif // #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n+    static_cast<unsigned long>(m_next_grow_size) << \"    \" << std::endl;\n+#endif \n \n   PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n notify_externally_resized(size_type new_size)\n {\n   m_resize_needed = false;\n-\n-  size_type new_grow_size =\n-    size_type(m_load_max*  new_size - 1);\n-\n-  size_type new_shrink_size =\n-    size_type(m_load_min*  new_size );\n-\n+  size_type new_grow_size = size_type(m_load_max * new_size - 1);\n+  size_type new_shrink_size = size_type(m_load_min * new_size );\n   if (new_grow_size >= m_next_grow_size)\n     {\n       PB_DS_DBG_ASSERT(new_shrink_size > m_next_shrink_size);\n-\n       m_next_grow_size = new_grow_size;\n-\n       PB_DS_DBG_ONLY(assert_valid();)\n \n #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n \tstd::cerr << \"hlcrt::notify_externally_resized1 \" <<\n-        static_cast<unsigned long>(new_size) <<    \"    \" <<\n-        static_cast<unsigned long>(m_load_min) <<    \"    \" <<\n-        static_cast<unsigned long>(m_load_max) <<    \"    \" <<\n+        static_cast<unsigned long>(new_size) << \"    \" <<\n+        static_cast<unsigned long>(m_load_min) << \"    \" <<\n+        static_cast<unsigned long>(m_load_max) << \"    \" <<\n         static_cast<unsigned long>(m_next_shrink_size) << \" \" <<\n-        static_cast<unsigned long>(m_next_grow_size) <<    \"    \" << std::endl;\n-#endif // #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n-\n+        static_cast<unsigned long>(m_next_grow_size) << \"    \" << std::endl;\n+#endif \n       return;\n     }\n \n   PB_DS_DBG_ASSERT(new_shrink_size <= m_next_shrink_size);\n-\n   m_next_shrink_size = new_shrink_size;\n \n #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n   std::cerr << \"hlcrt::notify_externally_resized2 \" <<\n-    static_cast<unsigned long>(new_size) <<    \"    \" <<\n-    static_cast<unsigned long>(m_load_min) <<    \"    \" <<\n-    static_cast<unsigned long>(m_load_max) <<    \"    \" <<\n+    static_cast<unsigned long>(new_size) << \"    \" <<\n+    static_cast<unsigned long>(m_load_min) << \"    \" <<\n+    static_cast<unsigned long>(m_load_max) << \"    \" <<\n     static_cast<unsigned long>(m_next_shrink_size) << \" \" <<\n-    static_cast<unsigned long>(m_next_grow_size) <<    \"    \" << std::endl;\n-#endif // #ifdef PB_DS_HT_MAP_RESIZE_TRACE_\n+    static_cast<unsigned long>(m_next_grow_size) << \"    \" << std::endl;\n+#endif \n \n   PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n notify_cleared()\n {\n   PB_DS_DBG_ONLY(assert_valid();)\n-\n-    size_base::set_size(0);\n-\n+  size_base::set_size(0);\n   m_resize_needed = (0 < m_next_shrink_size);\n-\n   PB_DS_DBG_ONLY(assert_valid();)\n-    }\n+}\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n swap(PB_DS_CLASS_C_DEC& other)\n {\n   PB_DS_DBG_ONLY(assert_valid();)\n-    PB_DS_DBG_ONLY(other.assert_valid();)\n-\n-    size_base::swap(other);\n-\n+  PB_DS_DBG_ONLY(other.assert_valid();)\n+    \n+  size_base::swap(other);\n   std::swap(m_load_min, other.m_load_min);\n   std::swap(m_load_max, other.m_load_max);\n-\n   std::swap(m_resize_needed, other.m_resize_needed);\n-\n   std::swap(m_next_grow_size, other.m_next_grow_size);\n   std::swap(m_next_shrink_size, other.m_next_shrink_size);\n \n   PB_DS_DBG_ONLY(assert_valid();)\n-    PB_DS_DBG_ONLY(other.assert_valid();)\n-    }\n+  PB_DS_DBG_ONLY(other.assert_valid();)\n+}\n \n PB_DS_CLASS_T_DEC\n inline std::pair<float, float>\n PB_DS_CLASS_C_DEC::\n get_loads() const\n {\n   PB_DS_STATIC_ASSERT(access, external_load_access);\n-\n-  return (std::make_pair(m_load_min, m_load_max));\n+  return std::make_pair(m_load_min, m_load_max);\n }\n \n PB_DS_CLASS_T_DEC\n@@ -308,7 +256,6 @@ PB_DS_CLASS_C_DEC::\n set_loads(std::pair<float, float> load_pair)\n {\n   PB_DS_STATIC_ASSERT(access, external_load_access);\n-\n   const float old_load_min = m_load_min;\n   const float old_load_max = m_load_max;\n   const size_type old_next_shrink_size = m_next_shrink_size;\n@@ -319,29 +266,24 @@ set_loads(std::pair<float, float> load_pair)\n     {\n       m_load_min = load_pair.first;\n       m_load_max = load_pair.second;\n-\n-      do_resize(static_cast<size_type>(\n-\t\t\t\t       size_base::get_size() / ((m_load_min + m_load_max) / 2)));\n+      do_resize(static_cast<size_type>(size_base::get_size() / ((m_load_min + m_load_max) / 2)));\n     }\n-  catch(...)\n+  catch (...)\n     {\n       m_load_min = old_load_min;\n       m_load_max = old_load_max;\n       m_next_shrink_size = old_next_shrink_size;\n       m_next_grow_size = old_next_grow_size;\n       m_resize_needed = old_resize_needed;\n-\n       throw;\n     }\n }\n \n PB_DS_CLASS_T_DEC\n void\n PB_DS_CLASS_C_DEC::\n-do_resize(size_type /*new_size*/)\n-{\n-  abort();\n-}\n+do_resize(size_type)\n+{ abort(); }\n \n #ifdef PB_DS_HASH_POLICY_DEBUG\n PB_DS_CLASS_T_DEC\n@@ -350,10 +292,9 @@ PB_DS_CLASS_C_DEC::\n assert_valid() const\n {\n   PB_DS_DBG_ASSERT(m_load_max > m_load_min);\n-\n   PB_DS_DBG_ASSERT(m_next_grow_size >= m_next_shrink_size);\n }\n-#endif // #ifdef PB_DS_HASH_POLICY_DEBUG\n+#endif \n \n #undef PB_DS_STATIC_ASSERT\n "}, {"sha": "1e2fefa553bb0c8b7fbb3b37e6e26fbd7f875498", "filename": "libstdc++-v3/include/ext/pb_ds/detail/type_utils.hpp", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Ftype_utils.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Ftype_utils.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Fdetail%2Ftype_utils.hpp?ref=81ee09de66d53b4b6c2bb3862b5b3199852b625c", "patch": "@@ -171,6 +171,31 @@ namespace pb_ds\n     {\n       typedef B type;\n     };\n+\n+#define __glibcxx_signed(T)\t((T)(-1) < 0)\n+\n+#define __glibcxx_min(T) \\\n+  (__glibcxx_signed (T) ? (T)1 << __glibcxx_digits (T) : (T)0)\n+\n+#define __glibcxx_max(T) \\\n+  (__glibcxx_signed (T) ? ((T)1 << __glibcxx_digits (T)) - 1 : ~(T)0)\n+\n+#define __glibcxx_digits(T) \\\n+  (sizeof(T) * __CHAR_BIT__ - __glibcxx_signed (T))\n+\n+   template<typename Value>\n+   struct numeric_traits\n+   {\n+     typedef Value value_type;\n+     static const value_type min = __glibcxx_min(value_type);\n+     static const value_type max = __glibcxx_max(value_type);\n+   };\n+\n+  template<typename Value>\n+  const Value numeric_traits<Value>::min;\n+\n+  template<typename Value>\n+  const Value numeric_traits<Value>::max;\n   } // namespace detail\n } // namespace pb_ds\n "}, {"sha": "3441fd95ba0027005f27c3b1030ae49884663bac", "filename": "libstdc++-v3/include/ext/pb_ds/trie_policy.hpp", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftrie_policy.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ee09de66d53b4b6c2bb3862b5b3199852b625c/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftrie_policy.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpb_ds%2Ftrie_policy.hpp?ref=81ee09de66d53b4b6c2bb3862b5b3199852b625c", "patch": "@@ -48,7 +48,6 @@\n #define PB_DS_TRIE_POLICY_HPP\n \n #include <string>\n-#include <climits>\n #include <ext/pb_ds/detail/type_utils.hpp>\n #include <ext/pb_ds/detail/trie_policy/trie_policy_base.hpp>\n \n@@ -63,7 +62,7 @@ namespace pb_ds\n   { };\n \n #define PB_DS_STATIC_ASSERT(UNIQUE, E)\t\t\t\t\t\\\n-  typedef detail::static_assert_dumclass<sizeof(detail::static_assert<(bool)(E)>)> UNIQUE##static_assert_type\n+  typedef detail::static_assert_dumclass<sizeof(detail::static_assert<bool(E)>)> UNIQUE##_static_assert_type\n \n #define PB_DS_CLASS_T_DEC\t\t\t\t\t\t\\\n   template<typename String, typename String::value_type Min_E_Val, typename String::value_type Max_E_Val, bool Reverse, typename Allocator>\n@@ -73,8 +72,8 @@ namespace pb_ds\n \n   // Element access traits for string types.\n   template<typename String = std::string,\n-\t   typename String::value_type Min_E_Val = SCHAR_MIN,\n-\t   typename String::value_type Max_E_Val = SCHAR_MAX,\n+\t   typename String::value_type Min_E_Val = detail::numeric_traits<typename String::value_type>::min, \n+\t   typename String::value_type Max_E_Val = detail::numeric_traits<typename String::value_type>::max, \n \t   bool Reverse = false,\n \t   typename Allocator = std::allocator<char> >\n   struct string_trie_e_access_traits\n@@ -102,6 +101,7 @@ namespace pb_ds\n \tmax_e_val = Max_E_Val,\n \tmax_size = max_e_val - min_e_val + 1\n       };\n+    PB_DS_STATIC_ASSERT(min_max_size, max_size >= 2);\n \n     // Returns a const_iterator to the first element of\n     // const_key_reference agumnet.\n@@ -118,7 +118,6 @@ namespace pb_ds\n     e_pos(e_type e);\n \n   private:\n-    PB_DS_STATIC_ASSERT(min_max_size, max_size >= 2);\n \n     inline static const_iterator\n     begin_imp(const_key_reference, detail::false_type);\n@@ -132,7 +131,7 @@ namespace pb_ds\n     inline static const_iterator\n     end_imp(const_key_reference, detail::true_type);\n \n-    static detail::integral_constant<int,Reverse> s_rev_ind;\n+    static detail::integral_constant<int, Reverse> s_rev_ind;\n   };\n \n #include <ext/pb_ds/detail/trie_policy/string_trie_e_access_traits_imp.hpp>"}]}