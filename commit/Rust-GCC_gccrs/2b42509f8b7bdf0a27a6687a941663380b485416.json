{"sha": "2b42509f8b7bdf0a27a6687a941663380b485416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0MjUwOWY4YjdiZGYwYTI3YTY2ODdhOTQxNjYzMzgwYjQ4NTQxNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-08T08:24:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-08T11:34:03Z"}, "message": "Fix availability compute during VN DOM elimination\n\nThis fixes an issue with redundant store elimination in FRE/PRE\nwhich, when invoked by the DOM elimination walk, ends up using\npossibly stale availability data from the RPO walk.  It also\nfixes a missed optimization during valueization of addresses\nby making sure to use get_addr_base_and_unit_offset_1 which can\nvalueize and adjusting that to also valueize ARRAY_REFs low-bound.\n\n2020-05-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.c (rpo_avail): Change type to\n\teliminate_dom_walker *.\n\t(eliminate_with_rpo_vn): Adjust rpo_avail to make vn_valueize\n\tuse the DOM walker availability.\n\t(vn_reference_fold_indirect): Use get_addr_base_and_unit_offset_1\n\twith vn_valueize as valueization callback.\n\t(vn_reference_maybe_forwprop_address): Likewise.\n\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Also valueize\n\tarray_ref_low_bound.\n\n\t* gnat.dg/opt83.adb: New testcase.", "tree": {"sha": "a4fe62b429dae15a1ff1c0725b1af8a28d48ac40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4fe62b429dae15a1ff1c0725b1af8a28d48ac40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b42509f8b7bdf0a27a6687a941663380b485416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b42509f8b7bdf0a27a6687a941663380b485416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b42509f8b7bdf0a27a6687a941663380b485416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b42509f8b7bdf0a27a6687a941663380b485416/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1595a1cb7bfac8d5a6026d5d6f3a495be0391506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1595a1cb7bfac8d5a6026d5d6f3a495be0391506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1595a1cb7bfac8d5a6026d5d6f3a495be0391506"}], "stats": {"total": 96, "additions": 76, "deletions": 20}, "files": [{"sha": "14605950a8b577003837fafb960ef6e1ed09c72e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b42509f8b7bdf0a27a6687a941663380b485416", "patch": "@@ -1,3 +1,15 @@\n+2020-05-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.c (rpo_avail): Change type to\n+\teliminate_dom_walker *.\n+\t(eliminate_with_rpo_vn): Adjust rpo_avail to make vn_valueize\n+\tuse the DOM walker availability.\n+\t(vn_reference_fold_indirect): Use get_addr_base_and_unit_offset_1\n+\twith vn_valueize as valueization callback.\n+\t(vn_reference_maybe_forwprop_address): Likewise.\n+\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Also valueize\n+\tarray_ref_low_bound.\n+\n 2020-05-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/94786"}, {"sha": "adacf69b027e54d4158c8dd7e6932ccce0d20ddd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b42509f8b7bdf0a27a6687a941663380b485416", "patch": "@@ -1,3 +1,7 @@\n+2020-05-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gnat.dg/opt83.adb: New testcase.\n+\n 2020-05-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/94786"}, {"sha": "d71672f622ccd482eaa086bb3cb6dc5d93a692de", "filename": "gcc/testsuite/gnat.dg/opt83.adb", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftestsuite%2Fgnat.dg%2Fopt83.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftestsuite%2Fgnat.dg%2Fopt83.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt83.adb?ref=2b42509f8b7bdf0a27a6687a941663380b485416", "patch": "@@ -0,0 +1,33 @@\n+--  { dg-do compile }\n+--  { dg-options \"-O2\" }\n+\n+--  rpo fre3 used to loop indefinitely replacing _2 with _8 and back,\n+--  given MEM[(struct test__e &)_2][0]{lb: _7 sz: 16}._tag = A23s_29;\n+--  and an earlier _8 = &*_2[0]{lb: _7 sz: 16}.\n+\n+procedure Opt83 is\n+\n+   type E is tagged record\n+      I : Natural := 0;\n+   end record;\n+\n+   type A is array (Natural range <>) of aliased E;\n+\n+   F : E;\n+\n+   R : access A;\n+\n+   procedure N is\n+   begin\n+      if R = null then\n+        R := new A (0 .. 4);\n+      end if;\n+   end N;\n+\n+begin\n+\n+   N;\n+\n+   R (0) := F;\n+\n+end Opt83;"}, {"sha": "3283d113f9b5376d11c5244d86b4ad53e7fd20e2", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=2b42509f8b7bdf0a27a6687a941663380b485416", "patch": "@@ -806,23 +806,25 @@ get_addr_base_and_unit_offset_1 (tree exp, poly_int64_pod *poffset,\n \t    if (valueize\n \t\t&& TREE_CODE (index) == SSA_NAME)\n \t      index = (*valueize) (index);\n+\t    if (!poly_int_tree_p (index))\n+\t      return NULL_TREE;\n+\t    low_bound = array_ref_low_bound (exp);\n+\t    if (valueize\n+\t\t&& TREE_CODE (low_bound) == SSA_NAME)\n+\t      low_bound = (*valueize) (low_bound);\n+\t    if (!poly_int_tree_p (low_bound))\n+\t      return NULL_TREE;\n+\t    unit_size = array_ref_element_size (exp);\n+\t    if (TREE_CODE (unit_size) != INTEGER_CST)\n+\t      return NULL_TREE;\n \n \t    /* If the resulting bit-offset is constant, track it.  */\n-\t    if (poly_int_tree_p (index)\n-\t\t&& (low_bound = array_ref_low_bound (exp),\n-\t\t    poly_int_tree_p (low_bound))\n-\t\t&& (unit_size = array_ref_element_size (exp),\n-\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n-\t      {\n-\t\tpoly_offset_int woffset\n-\t\t  = wi::sext (wi::to_poly_offset (index)\n-\t\t\t      - wi::to_poly_offset (low_bound),\n-\t\t\t      TYPE_PRECISION (TREE_TYPE (index)));\n-\t\twoffset *= wi::to_offset (unit_size);\n-\t\tbyte_offset += woffset.force_shwi ();\n-\t      }\n-\t    else\n-\t      return NULL_TREE;\n+\t    poly_offset_int woffset\n+\t\t= wi::sext (wi::to_poly_offset (index)\n+\t\t\t    - wi::to_poly_offset (low_bound),\n+\t\t\t    TYPE_PRECISION (TREE_TYPE (index)));\n+\t    woffset *= wi::to_offset (unit_size);\n+\t    byte_offset += woffset.force_shwi ();\n \t  }\n \t  break;\n "}, {"sha": "39e99007c7edaef9af5394f6be83f1cdc134ec53", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b42509f8b7bdf0a27a6687a941663380b485416/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=2b42509f8b7bdf0a27a6687a941663380b485416", "patch": "@@ -1224,8 +1224,8 @@ vn_reference_fold_indirect (vec<vn_reference_op_s> *ops,\n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n      from .foo.bar to the preceding MEM_REF offset and replace the\n      address with &OBJ.  */\n-  addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (op->op0, 0),\n-\t\t\t\t\t     &addr_offset);\n+  addr_base = get_addr_base_and_unit_offset_1 (TREE_OPERAND (op->op0, 0),\n+\t\t\t\t\t       &addr_offset, vn_valueize);\n   gcc_checking_assert (addr_base && TREE_CODE (addr_base) != MEM_REF);\n   if (addr_base != TREE_OPERAND (op->op0, 0))\n     {\n@@ -1282,8 +1282,9 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n \t  poly_int64 addr_offset;\n \n \t  addr = gimple_assign_rhs1 (def_stmt);\n-\t  addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n-\t\t\t\t\t\t     &addr_offset);\n+\t  addr_base = get_addr_base_and_unit_offset_1 (TREE_OPERAND (addr, 0),\n+\t\t\t\t\t\t       &addr_offset,\n+\t\t\t\t\t\t       vn_valueize);\n \t  /* If that didn't work because the address isn't invariant propagate\n \t     the reference tree from the address operation in case the current\n \t     dereference isn't offsetted.  */\n@@ -2419,7 +2420,7 @@ class rpo_elim : public eliminate_dom_walker\n };\n \n /* Global RPO state for access from hooks.  */\n-static rpo_elim *rpo_avail;\n+static eliminate_dom_walker *rpo_avail;\n basic_block vn_context_bb;\n \n /* Return true if BASE1 and BASE2 can be adjusted so they have the\n@@ -6559,7 +6560,11 @@ eliminate_with_rpo_vn (bitmap inserted_exprs)\n {\n   eliminate_dom_walker walker (CDI_DOMINATORS, inserted_exprs);\n \n+  eliminate_dom_walker *saved_rpo_avail = rpo_avail;\n+  rpo_avail = &walker;\n   walker.walk (cfun->cfg->x_entry_block_ptr);\n+  rpo_avail = saved_rpo_avail;\n+\n   return walker.eliminate_cleanup ();\n }\n "}]}