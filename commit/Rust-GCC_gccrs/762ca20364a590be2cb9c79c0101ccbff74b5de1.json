{"sha": "762ca20364a590be2cb9c79c0101ccbff74b5de1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyY2EyMDM2NGE1OTBiZTJjYjljNzljMDEwMWNjYmZmNzRiNWRlMQ==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-23T12:06:39Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2020-11-23T12:15:51Z"}, "message": "Implement the \"persistent\" attribute\n\nThe \"persistent\" attribute is used for variables that are initialized\nby the program loader, but are not initialized by the runtime startup\ncode. \"persistent\" variables are placed in a non-volatile area of\nmemory, which allows their value to \"persist\" between processor resets.\n\ngcc/c-family/ChangeLog:\n\n\t* c-attribs.c (handle_special_var_sec_attribute): New.\n\t(handle_noinit_attribute): Remove.\n\t(attr_noinit_exclusions): Rename to...\n\t(attr_section_exclusions): ...this, and add \"persistent\" attribute\n\texclusion.\n\t(c_common_attribute_table): Add \"persistent\" attribute.\n\ngcc/ChangeLog:\n\n\t* doc/extend.texi (Common Variable Attributes): Document the\n\t\"persistent\" variable attribute.\n\t* doc/sourcebuild.texi (Effective-Target Keywords): Document\n\tthe \"persistent\" effective target keyword.\n\t* tree.h (DECL_PERSISTENT_P): Define.\n\t* varasm.c (bss_initializer_p): Return false for a\n\tDECL_PERSISTENT_P decl initialized to zero.\n\t(default_section_type_flags): Handle the \".persistent\" section.\n\t(default_elf_select_section): Likewise.\n\t(default_unique_section): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.c-torture/execute/noinit-attribute.c: Moved to...\n\t* c-c++-common/torture/attr-noinit-main.inc: ...here.\n\t* lib/target-supports.exp (check_effective_target_persistent): New.\n\t* c-c++-common/torture/attr-noinit-1.c: New test.\n\t* c-c++-common/torture/attr-noinit-2.c: New test.\n\t* c-c++-common/torture/attr-noinit-3.c: New test.\n\t* c-c++-common/torture/attr-noinit-invalid.c: New test.\n\t* c-c++-common/torture/attr-persistent-1.c: New test.\n\t* c-c++-common/torture/attr-persistent-2.c: New test.\n\t* c-c++-common/torture/attr-persistent-3.c: New test.\n\t* c-c++-common/torture/attr-persistent-invalid.c: New test.\n\t* c-c++-common/torture/attr-persistent-main.inc: New test.", "tree": {"sha": "b865ba9ae2ac517d369987c8329cd9623cb31478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b865ba9ae2ac517d369987c8329cd9623cb31478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/762ca20364a590be2cb9c79c0101ccbff74b5de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/762ca20364a590be2cb9c79c0101ccbff74b5de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/762ca20364a590be2cb9c79c0101ccbff74b5de1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/762ca20364a590be2cb9c79c0101ccbff74b5de1/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb8309d4abdcd4c8de07bd4c42e22d1e80471765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb8309d4abdcd4c8de07bd4c42e22d1e80471765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb8309d4abdcd4c8de07bd4c42e22d1e80471765"}], "stats": {"total": 372, "additions": 303, "deletions": 69}, "files": [{"sha": "6d515dca05ac8cf2fc022ec56061f09792bf0e86", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 97, "deletions": 44, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -94,10 +94,10 @@ static tree handle_constructor_attribute (tree *, tree, tree, int, bool *);\n static tree handle_destructor_attribute (tree *, tree, tree, int, bool *);\n static tree handle_mode_attribute (tree *, tree, tree, int, bool *);\n static tree handle_section_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_special_var_sec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_aligned_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_if_not_aligned_attribute (tree *, tree, tree,\n \t\t\t\t\t\t  int, bool *);\n-static tree handle_noinit_attribute (tree *, tree, tree, int, bool *);\n static tree handle_weak_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_noplt_attribute (tree *, tree, tree, int, bool *) ;\n static tree handle_alias_ifunc_attribute (bool, tree *, tree, tree, bool *);\n@@ -248,9 +248,12 @@ static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n   ATTR_EXCL (NULL, false, false, false)\n };\n \n-static const struct attribute_spec::exclusions attr_noinit_exclusions[] =\n+/* Exclusions that apply to attributes that put declarations in specific\n+   sections.  */\n+static const struct attribute_spec::exclusions attr_section_exclusions[] =\n {\n   ATTR_EXCL (\"noinit\", true, true, true),\n+  ATTR_EXCL (\"persistent\", true, true, true),\n   ATTR_EXCL (\"section\", true, true, true),\n   ATTR_EXCL (NULL, false, false, false),\n };\n@@ -339,7 +342,7 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"mode\",                   1, 1, false,  true, false, false,\n \t\t\t      handle_mode_attribute, NULL },\n   { \"section\",                1, 1, true,  false, false, false,\n-\t\t\t      handle_section_attribute, attr_noinit_exclusions },\n+\t\t\t      handle_section_attribute, attr_section_exclusions },\n   { \"aligned\",                0, 1, false, false, false, false,\n \t\t\t      handle_aligned_attribute,\n \t                      attr_aligned_exclusions },\n@@ -509,7 +512,9 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"copy\",                   1, 1, false, false, false, false,\n \t\t\t      handle_copy_attribute, NULL },\n   { \"noinit\",\t\t      0, 0, true,  false, false, false,\n-\t\t\t      handle_noinit_attribute, attr_noinit_exclusions },\n+\t\t\t      handle_special_var_sec_attribute, attr_section_exclusions },\n+  { \"persistent\",\t      0, 0, true,  false, false, false,\n+\t\t\t      handle_special_var_sec_attribute, attr_section_exclusions },\n   { \"access\",\t\t      1, 3, false, true, true, false,\n \t\t\t      handle_access_attribute, NULL },\n   /* Attributes used by Objective-C.  */\n@@ -2387,64 +2392,112 @@ handle_weak_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n-/* Handle a \"noinit\" attribute; arguments as in struct\n-   attribute_spec.handler.  Check whether the attribute is allowed\n-   here and add the attribute to the variable decl tree or otherwise\n-   issue a diagnostic.  This function checks NODE is of the expected\n-   type and issues diagnostics otherwise using NAME.  If it is not of\n-   the expected type *NO_ADD_ATTRS will be set to true.  */\n-\n+/* Handle a \"noinit\" or \"persistent\" attribute; arguments as in\n+   struct attribute_spec.handler.\n+   This generic handler is used for \"special variable sections\" that allow the\n+   section name to be set using a dedicated attribute.  Additional validation\n+   is performed for the specific properties of the section corresponding to the\n+   attribute.\n+   The \".noinit\" section *is not* loaded by the program loader, and is not\n+   initialized by the runtime startup code.\n+   The \".persistent\" section *is* loaded by the program loader, but is not\n+   initialized by the runtime startup code.  */\n static tree\n-handle_noinit_attribute (tree * node,\n-\t\t  tree   name,\n-\t\t  tree   args,\n-\t\t  int    flags ATTRIBUTE_UNUSED,\n-\t\t  bool *no_add_attrs)\n+handle_special_var_sec_attribute (tree *node, tree name, tree args,\n+\t\t\t\t  int flags, bool *no_add_attrs)\n {\n-  const char *message = NULL;\n+  tree decl = *node;\n   tree res = NULL_TREE;\n \n-  gcc_assert (DECL_P (*node));\n-  gcc_assert (args == NULL);\n+  /* First perform generic validation common to \"noinit\" and \"persistent\"\n+     attributes.  */\n+  if (!targetm_common.have_named_sections)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"section attributes are not supported for this target\");\n+      goto fail;\n+    }\n \n-  if (TREE_CODE (*node) != VAR_DECL)\n-    message = G_(\"%qE attribute only applies to variables\");\n+  if (!VAR_P (decl))\n+    {\n+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n+\t\t  \"ignoring %qE attribute not set on a variable\",\n+\t\t  name);\n+      goto fail;\n+    }\n \n-  /* Check that it's possible for the variable to have a section.  */\n-  else if ((TREE_STATIC (*node) || DECL_EXTERNAL (*node) || in_lto_p)\n-\t   && DECL_SECTION_NAME (*node))\n-    message = G_(\"%qE attribute cannot be applied to variables \"\n-\t\t \"with specific sections\");\n+  if (VAR_P (decl)\n+      && current_function_decl != NULL_TREE\n+      && !TREE_STATIC (decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute cannot be specified for local variables\",\n+\t\tname);\n+      goto fail;\n+    }\n \n-  else if (!targetm.have_switchable_bss_sections)\n-    message = G_(\"%qE attribute is specific to ELF targets\");\n+  if (VAR_P (decl)\n+      && !targetm.have_tls && targetm.emutls.tmpl_section\n+      && DECL_THREAD_LOCAL_P (decl))\n+    {\n+      error (\"section of %q+D cannot be overridden\", decl);\n+      goto fail;\n+    }\n \n-  if (message)\n+  if (!targetm.have_switchable_bss_sections)\n     {\n-      warning (OPT_Wattributes, message, name);\n-      *no_add_attrs = true;\n+      error (\"%qE attribute is specific to ELF targets\", name);\n+      goto fail;\n     }\n-  else\n+\n+  if (TREE_READONLY (decl))\n+    {\n+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n+\t\t  \"ignoring %qE attribute set on const variable\",\n+\t\t  name);\n+      goto fail;\n+    }\n+\n+  /* Now validate noinit/persistent individually.  */\n+  if (strcmp (IDENTIFIER_POINTER (name), \"noinit\") == 0)\n+    {\n+      if (DECL_INITIAL (decl))\n+\t{\n+\t  warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n+\t\t      \"ignoring %qE attribute set on initialized variable\",\n+\t\t      name);\n+\t  goto fail;\n+\t}\n+      /* If this var is thought to be common, then change this.  \"noinit\"\n+\t variables must be placed in an explicit \".noinit\" section.  */\n+      DECL_COMMON (decl) = 0;\n+    }\n+  else if (strcmp (IDENTIFIER_POINTER (name), \"persistent\") == 0)\n     {\n-      res = targetm.handle_generic_attribute (node, name, args, flags,\n-\t\t\t\t\t      no_add_attrs);\n-      /* If the back end confirms the attribute can be added then continue onto\n-\t final processing.  */\n-      if (!(*no_add_attrs))\n+      if (DECL_COMMON (decl) || DECL_INITIAL (decl) == NULL_TREE)\n \t{\n-\t  /* If this var is thought to be common, then change this.  Common\n-\t     variables are assigned to sections before the backend has a\n-\t     chance to process them.  Do this only if the attribute is\n-\t     valid.  */\n-\t  if (DECL_COMMON (*node))\n-\t    DECL_COMMON (*node) = 0;\n+\t  warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,\n+\t\t      \"ignoring %qE attribute set on uninitialized variable\",\n+\t\t      name);\n+\t  goto fail;\n \t}\n     }\n+  else\n+    gcc_unreachable ();\n+\n+  res = targetm.handle_generic_attribute (node, name, args, flags,\n+\t\t\t\t\t  no_add_attrs);\n+\n+  /* If the back end confirms the attribute can be added then continue onto\n+     final processing.  */\n+  if (!(*no_add_attrs))\n+    return res;\n \n+fail:\n+  *no_add_attrs = true;\n   return res;\n }\n \n-\n /* Handle a \"noplt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "6018347daed5d02c8c0f31ffffbadb6ed9ba21fa", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -7426,9 +7426,23 @@ The @code{weak} attribute is described in\n @cindex @code{noinit} variable attribute\n Any data with the @code{noinit} attribute will not be initialized by\n the C runtime startup code, or the program loader.  Not initializing\n-data in this way can reduce program startup times.  This attribute is\n-specific to ELF targets and relies on the linker to place such data in\n-the right location\n+data in this way can reduce program startup times.\n+\n+This attribute is specific to ELF targets and relies on the linker\n+script to place sections with the @code{.noinit} prefix in the right\n+location.\n+\n+@item persistent\n+@cindex @code{persistent} variable attribute\n+Any data with the @code{persistent} attribute will not be initialized by\n+the C runtime startup code, but will be initialized by the program\n+loader.  This enables the value of the variable to @samp{persist}\n+between processor resets.\n+\n+This attribute is specific to ELF targets and relies on the linker\n+script to place the sections with the @code{.persistent} prefix in the\n+right location.  Specifically, some type of non-volatile, writeable\n+memory is required.\n \n @item objc_nullability (@var{nullability kind}) @r{(Objective-C and Objective-C++ only)}\n @cindex @code{objc_nullability} variable attribute"}, {"sha": "852eaa2e6765c53ce52d19de610cc1df6c828fac", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -2548,6 +2548,9 @@ Target does not generate PIC by default.\n @item offload_gcn\n Target has been configured for OpenACC/OpenMP offloading on AMD GCN.\n \n+@item persistent\n+Target supports the @code{persistent} variable attribute.\n+\n @item pie_enabled\n Target generates PIE by default.\n "}, {"sha": "877e7647ac9a4843f4ccd2a6460acb8d888df5b0", "filename": "gcc/testsuite/c-c++-common/torture/attr-noinit-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-1.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target noinit } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-options \"-save-temps\" } */\n+/* { dg-final { scan-assembler \".section\\t.noinit,\\\"aw\\\"\\n\" } } */\n+\n+#include \"attr-noinit-main.inc\""}, {"sha": "befa2a0bd52263a1a36da110f83aecf2889174c9", "filename": "gcc/testsuite/c-c++-common/torture/attr-noinit-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-2.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target noinit } */\n+/* { dg-options \"-fdata-sections -save-temps\" } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-final { scan-assembler \".section\\t.noinit.var_noinit,\\\"aw\\\"\\n\" } } */\n+\n+/* Test the \"noinit\" attribute with -fdata-sections.  */\n+#include \"attr-noinit-main.inc\""}, {"sha": "519e88a59a60c37682aa4ab51546b951e1e98b0b", "filename": "gcc/testsuite/c-c++-common/torture/attr-noinit-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-3.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target noinit } */\n+/* { dg-options \"-flto -save-temps\" } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-final { scan-file attr-noinit-3.ltrans0.ltrans.s \".section\\t\\.noinit,\\\"aw\\\"\\n\" } } */\n+\n+/* Test the \"noinit\" attribute with -flto.  Specifically examine the\n+   final LTO assembly file, to ensure the \"noinit\" setting on the variable\n+   hasn't been lost.  */\n+#include \"attr-noinit-main.inc\"\n+"}, {"sha": "c3b5fffd166f11c383503ee38a5178a4d1650134", "filename": "gcc/testsuite/c-c++-common/torture/attr-noinit-invalid.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-invalid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-invalid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-invalid.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target noinit } */\n+/* { dg-options \"-Wattributes\" } */\n+\n+/* Check warning/error messages for \"noinit\" attribute misuse.  */\n+int __attribute__((noinit)) noinit_fn (void); /* { dg-warning \"ignoring 'noinit' attribute not set on a variable\" } */\n+int __attribute__((section (\"mysection\"), noinit)) noinit_section1; /* { dg-warning \"because it conflicts with attribute\" } */\n+int __attribute__((noinit, section (\"mysection\"))) noinit_section2; /* { dg-warning \"because it conflicts with attribute\" } */\n+const int __attribute__((noinit)) noinit_const; /* { dg-warning \"ignoring 'noinit' attribute set on const variable\" } */\n+/* { dg-error \"uninitialized 'const noinit_const'\" \"\" { target c++ } .-1 } */\n+int __attribute__((noinit)) noinit_init = 42; /* { dg-warning \"ignoring 'noinit' attribute set on initialized variable\" } */\n+void foo (void) { int __attribute__((noinit)) local_noinit; } /* { dg-error \"'noinit' attribute cannot be specified for local variables\" } */"}, {"sha": "92cdb9b85347c056b2bbda24106d2db72cda620b", "filename": "gcc/testsuite/c-c++-common/torture/attr-noinit-main.inc", "status": "renamed", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-main.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-main.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-noinit-main.inc?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -1,41 +1,36 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target noinit } */\n-/* { dg-options \"-Wattributes\" } */\n-/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n-\n-/* This test checks that noinit data is handled correctly.\n+/* This test checks that data marked with the \"noinit\" attribute is handled\n+   correctly.\n    If data LMA != VMA (e.g. for simulating the copy of data from ROM to RAM),\n    then var_init will always be re-initialized to 2 and this test will loop\n-   forever.  */\n+   forever, so it must be skipped for those targets.  */\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n extern void _start (void) __attribute__ ((noreturn));\n-extern void abort (void) __attribute__ ((noreturn));\n-extern void exit (int) __attribute__ ((noreturn));\n+#ifdef __cplusplus\n+}\n+#endif\n \n int var_common;\n int var_zero = 0;\n int var_one = 1;\n int __attribute__((noinit)) var_noinit;\n int var_init = 2;\n \n-int __attribute__((noinit)) func(); /* { dg-warning \"attribute only applies to variables\" } */\n-int __attribute__((section (\"mysection\"), noinit)) var_section1; /* { dg-warning \"because it conflicts with attribute\" } */\n-int __attribute__((noinit, section (\"mysection\"))) var_section2; /* { dg-warning \"because it conflicts with attribute\" } */\n-\n-\n int\n main (void)\n {\n   /* Make sure that the C startup code has correctly initialized the ordinary variables.  */\n   if (var_common != 0)\n-    abort ();\n+    __builtin_abort ();\n \n   /* Initialized variables are not re-initialized during startup, so\n      check their original values only during the first run of this\n      test.  */\n   if (var_init == 2)\n     if (var_zero != 0 || var_one != 1)\n-      abort ();\n+      __builtin_abort ();\n \n   switch (var_init)\n     {\n@@ -45,19 +40,19 @@ main (void)\n       break;\n \n     case 3:\n-      /* Second time through - make sure that d has not been reset.  */\n+      /* Second time through - make sure that var_noinit has not been reset.  */\n       if (var_noinit != 3)\n-\tabort ();\n-      exit (0);\n+\t__builtin_abort ();\n+      __builtin_exit (0);\n \n     default:\n       /* Any other value for var_init is an error.  */\n-      abort ();\n+      __builtin_abort ();\n     }\n \n   /* Simulate a processor reset by calling the C startup code.  */\n   _start ();\n \n   /* Should never reach here.  */\n-  abort ();\n+  __builtin_abort ();\n }", "previous_filename": "gcc/testsuite/gcc.c-torture/execute/noinit-attribute.c"}, {"sha": "72dc3c271928f023ce03627950f777d284051873", "filename": "gcc/testsuite/c-c++-common/torture/attr-persistent-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-1.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target persistent } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-options \"-save-temps\" } */\n+/* { dg-final { scan-assembler \".section\\t.persistent,\\\"aw\\\"\\n\" } } */\n+\n+/* Test the \"persistent\" attribute.  */\n+#include \"attr-persistent-main.inc\""}, {"sha": "a7de0d5d38ba7dd5d3e68a8853617cd59e941b72", "filename": "gcc/testsuite/c-c++-common/torture/attr-persistent-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-2.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target persistent } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-options \"-fdata-sections -save-temps\" } */\n+/* { dg-final { scan-assembler \".section\\t.persistent.var_persistent,\\\"aw\\\"\\n\" } } */\n+\n+/* Test the \"persistent\" attribute with -fdata-sections.  */\n+#include \"attr-persistent-main.inc\""}, {"sha": "3e4fd28618d966c1b59221e81d775ebde77a8570", "filename": "gcc/testsuite/c-c++-common/torture/attr-persistent-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-3.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target persistent } */\n+/* { dg-options \"-flto -save-temps\" } */\n+/* { dg-skip-if \"data LMA != VMA\" { msp430-*-* } { \"-mlarge\" } } */\n+/* { dg-final { scan-file attr-persistent-3.ltrans0.ltrans.s \".section\\t\\.persistent,\\\"aw\\\"\\n\" } } */\n+\n+/* Test the \"persistent\" attribute with -flto.  Specifically examine the\n+   final LTO assembly file, to ensure the \"persistent\" setting on the variable\n+   hasn't been lost.  */\n+#include \"attr-persistent-main.inc\""}, {"sha": "06d9f3536295527efa40193e1cd257879155e1e4", "filename": "gcc/testsuite/c-c++-common/torture/attr-persistent-invalid.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-invalid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-invalid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-invalid.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target persistent } */\n+/* { dg-options \"-Wattributes\" } */\n+\n+/* Check warning/error messages for \"persistent\" attribute misuse.  */\n+int __attribute__((persistent)) persistent_fn (void); /* { dg-warning \"ignoring 'persistent' attribute not set on a variable\" } */\n+int __attribute__((section (\"mysection\"), persistent)) persistent_section1 = 1; /* { dg-warning \"because it conflicts with attribute\" } */\n+int __attribute__((persistent, section (\"mysection\"))) persistent_section2 = 2; /* { dg-warning \"because it conflicts with attribute\" } */\n+const int __attribute__((persistent)) persistent_const = 3; /* { dg-warning \"ignoring 'persistent' attribute set on const variable\" } */\n+int __attribute__((persistent)) persistent_init; /* { dg-warning \"ignoring 'persistent' attribute set on uninitialized variable\" } */\n+void foo (void) { int __attribute__((persistent)) local_persistent = 4; } /* { dg-error \"'persistent' attribute cannot be specified for local variables\" } */"}, {"sha": "a442141e55ce3dfd4f15653e5b55bf8e8f9fdef5", "filename": "gcc/testsuite/c-c++-common/torture/attr-persistent-main.inc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-main.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-main.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fattr-persistent-main.inc?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -0,0 +1,58 @@\n+/* This test checks that data marked with the \"persistent\" attribute is handled\n+   correctly.\n+   If data LMA != VMA (e.g. for simulating the copy of data from ROM to RAM),\n+   then var_init will always be re-initialized to 2 and this test will loop\n+   forever, so it must be skipped for those targets.  */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+extern void _start (void) __attribute__ ((noreturn));\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+int var_common;\n+int var_zero = 0;\n+int var_one = 1;\n+int __attribute__((persistent)) var_persistent = 2;\n+int var_init = 2;\n+\n+int\n+main (void)\n+{\n+  /* Make sure that the C startup code has correctly initialized the ordinary variables.  */\n+  if (var_common != 0)\n+    __builtin_abort ();\n+\n+  /* Initialized variables are not re-initialized during startup, so\n+     check their original values only during the first run of this\n+     test.  */\n+  if (var_init == 2)\n+    if (var_zero != 0 || var_one != 1 || var_persistent != 2)\n+      __builtin_abort ();\n+\n+  switch (var_init)\n+    {\n+    case 2:\n+      /* First time through - change all the values.  */\n+      var_common = var_zero = var_one = var_persistent = var_init = 3;\n+      break;\n+\n+    case 3:\n+      /* Second time through - make sure that var_persistent has not been reset.  */\n+      if (var_persistent != 3)\n+\t__builtin_abort ();\n+      __builtin_exit (0);\n+\n+    default:\n+      /* Any other value for var_init is an error.  */\n+      __builtin_abort ();\n+    }\n+\n+  /* Simulate a processor reset by calling the C startup code.  */\n+  _start ();\n+\n+  /* Should never reach here.  */\n+  __builtin_abort ();\n+}"}, {"sha": "ff6bc5f4b9251d976db163fe5688542a7cf4cdf4", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -380,6 +380,18 @@ proc check_effective_target_noinit { } {\n     return 0\n }\n \n+# The \"persistent\" attribute is only supported by some targets.\n+# This proc returns 1 if it's supported, 0 if it's not.\n+\n+proc check_effective_target_persistent { } {\n+    if { [istarget arm*-*-eabi]\n+\t || [istarget msp430-*-*] } {\n+\treturn 1\n+    }\n+\n+    return 0\n+}\n+\n ###############################\n # proc check_visibility_available { what_kind }\n ###############################"}, {"sha": "078919bce5deaaa1cb10b2774f78bd672b024499", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -2669,6 +2669,13 @@ extern tree vector_element_bits_tree (const_tree);\n   (DECL_P (DECL)\t\t\\\n    && (lookup_attribute (\"noinit\", DECL_ATTRIBUTES (DECL)) != NULL_TREE))\n \n+/* Nonzero for a decl that is decorated with the \"persistent\" attribute.\n+   decls with this attribute are placed into the \".persistent\" section, so they\n+   are not initialized by the target's startup code.  */\n+#define DECL_PERSISTENT_P(DECL)\t\\\n+  (DECL_P (DECL)\t\t\\\n+   && (lookup_attribute (\"persistent\", DECL_ATTRIBUTES (DECL)) != NULL_TREE))\n+\n /* For function local variables of COMPLEX and VECTOR types,\n    indicates that the variable is not aliased, and that all\n    modifications to the variable have been adjusted so that"}, {"sha": "b92da26fb820523aa1b48408bfbb5e53caec0008", "filename": "gcc/varasm.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/762ca20364a590be2cb9c79c0101ccbff74b5de1/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=762ca20364a590be2cb9c79c0101ccbff74b5de1", "patch": "@@ -1057,7 +1057,11 @@ bss_initializer_p (const_tree decl, bool named)\n \t      || (DECL_INITIAL (decl) == error_mark_node\n \t          && !in_lto_p)\n \t      || (flag_zero_initialized_in_bss\n-\t          && initializer_zerop (DECL_INITIAL (decl)))));\n+\t\t  && initializer_zerop (DECL_INITIAL (decl))\n+\t\t  /* A decl with the \"persistent\" attribute applied and\n+\t\t     explicitly initialized to 0 should not be treated as a BSS\n+\t\t     variable.  */\n+\t\t  && !DECL_PERSISTENT_P (decl))));\n }\n \n /* Compute the alignment of variable specified by DECL.\n@@ -6680,6 +6684,9 @@ default_section_type_flags (tree decl, const char *name, int reloc)\n   if (strcmp (name, \".noinit\") == 0)\n     flags |= SECTION_WRITE | SECTION_BSS | SECTION_NOTYPE;\n \n+  if (strcmp (name, \".persistent\") == 0)\n+    flags |= SECTION_WRITE | SECTION_NOTYPE;\n+\n   /* Various sections have special ELF types that the assembler will\n      assign by default based on the name.  They are neither SHT_PROGBITS\n      nor SHT_NOBITS, so when changing sections we don't want to print a\n@@ -7023,6 +7030,11 @@ default_elf_select_section (tree decl, int reloc,\n       sname = \".sdata2\";\n       break;\n     case SECCAT_DATA:\n+      if (DECL_P (decl) && DECL_PERSISTENT_P (decl))\n+\t{\n+\t  sname = \".persistent\";\n+\t  break;\n+\t}\n       return data_section;\n     case SECCAT_DATA_REL:\n       sname = \".data.rel\";\n@@ -7093,6 +7105,11 @@ default_unique_section (tree decl, int reloc)\n       break;\n     case SECCAT_DATA:\n       prefix = one_only ? \".d\" : \".data\";\n+      if (DECL_P (decl) && DECL_PERSISTENT_P (decl))\n+\t{\n+\t  prefix = one_only ? \".p\" : \".persistent\";\n+\t  break;\n+\t}\n       break;\n     case SECCAT_DATA_REL:\n       prefix = one_only ? \".d.rel\" : \".data.rel\";"}]}