{"sha": "f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcwMmU3ZDQzZjJhZWM3MTY0MGQwZGI3ZWNmMTU0M2JhNzVmMzdjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-22T16:44:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-22T16:44:29Z"}, "message": "Let the target choose a vectorisation alignment\n\nThe vectoriser aligned vectors to TYPE_ALIGN unconditionally, although\nthere was also a hard-coded assumption that this was equal to the type\nsize.  This was inconvenient for SVE for two reasons:\n\n- When compiling for a specific power-of-2 SVE vector length, we might\n  want to align to a full vector.  However, the TYPE_ALIGN is governed\n  by the ABI alignment, which is 128 bits regardless of size.\n\n- For vector-length-agnostic code it doesn't usually make sense to align,\n  since the runtime vector length might not be a power of two.  Even for\n  power of two sizes, there's no guarantee that aligning to the previous\n  16 bytes will be an improveent.\n\nThis patch therefore adds a target hook to control the preferred\nvectoriser (as opposed to ABI) alignment.\n\n2017-09-22  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (preferred_vector_alignment): New hook.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT): New\n\thook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_preferred_vector_alignment): Declare.\n\t* targhooks.c (default_preferred_vector_alignment): New function.\n\t* tree-vectorizer.h (dataref_aux): Add a target_alignment field.\n\tExpand commentary.\n\t(DR_TARGET_ALIGNMENT): New macro.\n\t(aligned_access_p): Update commentary.\n\t(vect_known_alignment_in_bytes): New function.\n\t* tree-vect-data-refs.c (vect_calculate_required_alignment): New\n\tfunction.\n\t(vect_compute_data_ref_alignment): Set DR_TARGET_ALIGNMENT.\n\tCalculate the misalignment based on the target alignment rather than\n\tthe vector size.\n\t(vect_update_misalignment_for_peel): Use DR_TARGET_ALIGMENT\n\trather than TYPE_ALIGN / BITS_PER_UNIT to update the misalignment.\n\t(vect_enhance_data_refs_alignment): Mask the byte misalignment with\n\tthe target alignment, rather than masking the element misalignment\n\twith the number of elements in a vector.  Also use the target\n\talignment when calculating the maximum number of peels.\n\t(vect_find_same_alignment_drs): Use vect_calculate_required_alignment\n\tinstead of TYPE_ALIGN_UNIT.\n\t(vect_duplicate_ssa_name_ptr_info): Remove stmt_info parameter.\n\tMeasure DR_MISALIGNMENT relative to DR_TARGET_ALIGNMENT.\n\t(vect_create_addr_base_for_vector_ref): Update call accordingly.\n\t(vect_create_data_ref_ptr): Likewise.\n\t(vect_setup_realignment): Realign by ANDing with\n\t-DR_TARGET_MISALIGNMENT.\n\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Calculate\n\tthe number of peels based on DR_TARGET_ALIGNMENT.\n\t* tree-vect-stmts.c (get_group_load_store_type): Compare the gap\n\twith the guaranteed alignment boundary when deciding whether\n\toverrun is OK.\n\t(vectorizable_mask_load_store): Interpret DR_MISALIGNMENT\n\trelative to DR_TARGET_ALIGNMENT instead of TYPE_ALIGN_UNIT.\n\t(ensure_base_align): Remove stmt_info parameter.  Get the\n\ttarget base alignment from DR_TARGET_ALIGNMENT.\n\t(vectorizable_store): Update call accordingly.   Interpret\n\tDR_MISALIGNMENT relative to DR_TARGET_ALIGNMENT instead of\n\tTYPE_ALIGN_UNIT.\n\t(vectorizable_load): Likewise.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-outer-3a.c: Adjust dump scan for new wording\n\tof alignment message.\n\t* gcc.dg/vect/vect-outer-3a-big-array.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r253101", "tree": {"sha": "9beee33fae8a909f405a3f3bb2328cab22dde95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9beee33fae8a909f405a3f3bb2328cab22dde95c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/comments", "author": null, "committer": null, "parents": [{"sha": "b2b67217d3c0901f7c414b7f4b4a92e92678846e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2b67217d3c0901f7c414b7f4b4a92e92678846e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2b67217d3c0901f7c414b7f4b4a92e92678846e"}], "stats": {"total": 347, "additions": 242, "deletions": 105}, "files": [{"sha": "e29256106b2c42d83c9138af30b3f65df96e3eeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -1,3 +1,51 @@\n+2017-09-22  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (preferred_vector_alignment): New hook.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT): New\n+\thook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_preferred_vector_alignment): Declare.\n+\t* targhooks.c (default_preferred_vector_alignment): New function.\n+\t* tree-vectorizer.h (dataref_aux): Add a target_alignment field.\n+\tExpand commentary.\n+\t(DR_TARGET_ALIGNMENT): New macro.\n+\t(aligned_access_p): Update commentary.\n+\t(vect_known_alignment_in_bytes): New function.\n+\t* tree-vect-data-refs.c (vect_calculate_required_alignment): New\n+\tfunction.\n+\t(vect_compute_data_ref_alignment): Set DR_TARGET_ALIGNMENT.\n+\tCalculate the misalignment based on the target alignment rather than\n+\tthe vector size.\n+\t(vect_update_misalignment_for_peel): Use DR_TARGET_ALIGMENT\n+\trather than TYPE_ALIGN / BITS_PER_UNIT to update the misalignment.\n+\t(vect_enhance_data_refs_alignment): Mask the byte misalignment with\n+\tthe target alignment, rather than masking the element misalignment\n+\twith the number of elements in a vector.  Also use the target\n+\talignment when calculating the maximum number of peels.\n+\t(vect_find_same_alignment_drs): Use vect_calculate_required_alignment\n+\tinstead of TYPE_ALIGN_UNIT.\n+\t(vect_duplicate_ssa_name_ptr_info): Remove stmt_info parameter.\n+\tMeasure DR_MISALIGNMENT relative to DR_TARGET_ALIGNMENT.\n+\t(vect_create_addr_base_for_vector_ref): Update call accordingly.\n+\t(vect_create_data_ref_ptr): Likewise.\n+\t(vect_setup_realignment): Realign by ANDing with\n+\t-DR_TARGET_MISALIGNMENT.\n+\t* tree-vect-loop-manip.c (vect_gen_prolog_loop_niters): Calculate\n+\tthe number of peels based on DR_TARGET_ALIGNMENT.\n+\t* tree-vect-stmts.c (get_group_load_store_type): Compare the gap\n+\twith the guaranteed alignment boundary when deciding whether\n+\toverrun is OK.\n+\t(vectorizable_mask_load_store): Interpret DR_MISALIGNMENT\n+\trelative to DR_TARGET_ALIGNMENT instead of TYPE_ALIGN_UNIT.\n+\t(ensure_base_align): Remove stmt_info parameter.  Get the\n+\ttarget base alignment from DR_TARGET_ALIGNMENT.\n+\t(vectorizable_store): Update call accordingly.   Interpret\n+\tDR_MISALIGNMENT relative to DR_TARGET_ALIGNMENT instead of\n+\tTYPE_ALIGN_UNIT.\n+\t(vectorizable_load): Likewise.\n+\n 2017-09-22  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1f8c0f129428a4ee2a0973cfd94f6588ae661697", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -5758,6 +5758,18 @@ For vector memory operations the cost may depend on type (@var{vectype}) and\n misalignment value (@var{misalign}).\n @end deftypefn\n \n+@deftypefn {Target Hook} HOST_WIDE_INT TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT (const_tree @var{type})\n+This hook returns the preferred alignment in bits for accesses to\n+vectors of type @var{type} in vectorized code.  This might be less than\n+or greater than the ABI-defined value returned by\n+@code{TARGET_VECTOR_ALIGNMENT}.  It can be equal to the alignment of\n+a single element, in which case the vectorizer will not try to optimize\n+for alignment.\n+\n+The default hook returns @code{TYPE_ALIGN (@var{type})}, which is\n+correct for most targets.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree @var{type}, bool @var{is_packed})\n Return true if vector alignment is reachable (by peeling N iterations) for the given scalar type @var{type}.  @var{is_packed} is false if the scalar access using @var{type} is known to be naturally aligned.\n @end deftypefn"}, {"sha": "fa3ff0164bd97cc2204fda44c3d50ea4db877a80", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -4088,6 +4088,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n \n+@hook TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT\n+\n @hook TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n \n @hook TARGET_VECTORIZE_VEC_PERM_CONST_OK"}, {"sha": "9e5ddc00a4311ad65576c15f31a5f8e3b6655cb9", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -1820,6 +1820,20 @@ misalignment value (@var{misalign}).\",\n  int, (enum vect_cost_for_stmt type_of_cost, tree vectype, int misalign),\n  default_builtin_vectorization_cost)\n \n+DEFHOOK\n+(preferred_vector_alignment,\n+ \"This hook returns the preferred alignment in bits for accesses to\\n\\\n+vectors of type @var{type} in vectorized code.  This might be less than\\n\\\n+or greater than the ABI-defined value returned by\\n\\\n+@code{TARGET_VECTOR_ALIGNMENT}.  It can be equal to the alignment of\\n\\\n+a single element, in which case the vectorizer will not try to optimize\\n\\\n+for alignment.\\n\\\n+\\n\\\n+The default hook returns @code{TYPE_ALIGN (@var{type})}, which is\\n\\\n+correct for most targets.\",\n+ HOST_WIDE_INT, (const_tree type),\n+ default_preferred_vector_alignment)\n+\n /* Return true if vector alignment is reachable (by peeling N\n    iterations) for the given scalar type.  */\n DEFHOOK"}, {"sha": "171583d419efb91f64feee8bf85fa4fafa8bb7b5", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -1175,6 +1175,15 @@ default_vector_alignment (const_tree type)\n   return align;\n }\n \n+/* The default implementation of\n+   TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT.  */\n+\n+HOST_WIDE_INT\n+default_preferred_vector_alignment (const_tree type)\n+{\n+  return TYPE_ALIGN (type);\n+}\n+\n /* By default assume vectors of element TYPE require a multiple of the natural\n    alignment of TYPE.  TYPE is naturally aligned if IS_PACKED is false.  */\n bool"}, {"sha": "e577888654dcd6b9b66a770109e521e6b3ead21d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -95,6 +95,7 @@ extern tree default_builtin_reciprocal (tree);\n \n extern HOST_WIDE_INT default_vector_alignment (const_tree);\n \n+extern HOST_WIDE_INT default_preferred_vector_alignment (const_tree);\n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);\n extern bool\n default_builtin_support_vector_misalignment (machine_mode mode,"}, {"sha": "39838f595fbf0dcf8b7d3b3432265addbff22203", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -1,3 +1,11 @@\n+2017-09-22  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.dg/vect/vect-outer-3a.c: Adjust dump scan for new wording\n+\tof alignment message.\n+\t* gcc.dg/vect/vect-outer-3a-big-array.c: Likewise.\n+\n 2017-09-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81854"}, {"sha": "b84f5afa0e2cc84798509c46c63cfdb12267831d", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3a-big-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a-big-array.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -49,4 +49,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector alignment\" 1 \"vect\" } } */"}, {"sha": "d3ba837c95de678c4b4a6a9d722bcc08cb333e9a", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-3a.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-3a.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -49,4 +49,4 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail { vect_no_align && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector-size\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"step doesn't divide the vector alignment\" 1 \"vect\" } } */"}, {"sha": "3c57e5c0be07e1f3cf705957ed6b58a88f9812e9", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -775,6 +775,17 @@ vect_record_base_alignments (vec_info *vinfo)\n       }\n }\n \n+/* Return the target alignment for the vectorized form of DR.  */\n+\n+static unsigned int\n+vect_calculate_target_alignment (struct data_reference *dr)\n+{\n+  gimple *stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  return targetm.vectorize.preferred_vector_alignment (vectype);\n+}\n+\n /* Function vect_compute_data_ref_alignment\n \n    Compute the misalignment of the data reference DR.\n@@ -811,6 +822,10 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   innermost_loop_behavior *drb = vect_dr_behavior (dr);\n   bool step_preserves_misalignment_p;\n \n+  unsigned HOST_WIDE_INT vector_alignment\n+    = vect_calculate_target_alignment (dr) / BITS_PER_UNIT;\n+  DR_TARGET_ALIGNMENT (dr) = vector_alignment;\n+\n   /* No step for BB vectorization.  */\n   if (!loop)\n     {\n@@ -823,43 +838,41 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n      relative to the outer-loop (LOOP).  This is ok only if the misalignment\n      stays the same throughout the execution of the inner-loop, which is why\n      we have to check that the stride of the dataref in the inner-loop evenly\n-     divides by the vector size.  */\n+     divides by the vector alignment.  */\n   else if (nested_in_vect_loop_p (loop, stmt))\n     {\n       step_preserves_misalignment_p\n-\t= (DR_STEP_ALIGNMENT (dr)\n-\t   % GET_MODE_SIZE (TYPE_MODE (vectype))) == 0;\n+\t= (DR_STEP_ALIGNMENT (dr) % vector_alignment) == 0;\n \n       if (dump_enabled_p ())\n \t{\n \t  if (step_preserves_misalignment_p)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"inner step divides the vector-size.\\n\");\n+\t\t\t     \"inner step divides the vector alignment.\\n\");\n \t  else\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"inner step doesn't divide the vector-size.\\n\");\n+\t\t\t     \"inner step doesn't divide the vector\"\n+\t\t\t     \" alignment.\\n\");\n \t}\n     }\n \n   /* Similarly we can only use base and misalignment information relative to\n      an innermost loop if the misalignment stays the same throughout the\n      execution of the loop.  As above, this is the case if the stride of\n-     the dataref evenly divides by the vector size.  */\n+     the dataref evenly divides by the alignment.  */\n   else\n     {\n       unsigned vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       step_preserves_misalignment_p\n-\t= ((DR_STEP_ALIGNMENT (dr) * vf)\n-\t   % GET_MODE_SIZE (TYPE_MODE (vectype))) == 0;\n+\t= ((DR_STEP_ALIGNMENT (dr) * vf) % vector_alignment) == 0;\n \n       if (!step_preserves_misalignment_p && dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"step doesn't divide the vector-size.\\n\");\n+\t\t\t \"step doesn't divide the vector alignment.\\n\");\n     }\n \n   unsigned int base_alignment = drb->base_alignment;\n   unsigned int base_misalignment = drb->base_misalignment;\n-  unsigned HOST_WIDE_INT vector_alignment = TYPE_ALIGN_UNIT (vectype);\n \n   /* Calculate the maximum of the pooled base address alignment and the\n      alignment that we can compute for DR itself.  */\n@@ -1007,9 +1020,8 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n     {\n       bool negative = tree_int_cst_compare (DR_STEP (dr), size_zero_node) < 0;\n       int misal = DR_MISALIGNMENT (dr);\n-      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       misal += negative ? -npeel * dr_size : npeel * dr_size;\n-      misal &= (TYPE_ALIGN (vectype) / BITS_PER_UNIT) - 1;\n+      misal &= DR_TARGET_ALIGNMENT (dr) - 1;\n       SET_DR_MISALIGNMENT (dr, misal);\n       return;\n     }\n@@ -1657,16 +1669,17 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         {\n           if (known_alignment_for_access_p (dr))\n             {\n-              unsigned int npeel_tmp = 0;\n+\t      unsigned int npeel_tmp = 0;\n \t      bool negative = tree_int_cst_compare (DR_STEP (dr),\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n-              vectype = STMT_VINFO_VECTYPE (stmt_info);\n-              nelements = TYPE_VECTOR_SUBPARTS (vectype);\n-\t      mis = DR_MISALIGNMENT (dr) / vect_get_scalar_dr_size (dr);\n+\t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t      nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+\t      unsigned int target_align = DR_TARGET_ALIGNMENT (dr);\n+\t      unsigned int dr_size = vect_get_scalar_dr_size (dr);\n+\t      mis = (negative ? DR_MISALIGNMENT (dr) : -DR_MISALIGNMENT (dr));\n \t      if (DR_MISALIGNMENT (dr) != 0)\n-\t\tnpeel_tmp = (negative ? (mis - nelements)\n-\t\t\t     : (nelements - mis)) & (nelements - 1);\n+\t\tnpeel_tmp = (mis & (target_align - 1)) / dr_size;\n \n               /* For multiple types, it is possible that the bigger type access\n                  will have more than one peeling option.  E.g., a loop with two\n@@ -1701,7 +1714,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                 {\n                   vect_peeling_hash_insert (&peeling_htab, loop_vinfo,\n \t\t\t\t\t    dr, npeel_tmp);\n-                  npeel_tmp += nelements;\n+\t\t  npeel_tmp += target_align / dr_size;\n                 }\n \n \t      one_misalignment_known = true;\n@@ -1922,7 +1935,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       stmt = DR_STMT (dr0);\n       stmt_info = vinfo_for_stmt (stmt);\n       vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (known_alignment_for_access_p (dr0))\n         {\n@@ -1935,9 +1947,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  updating DR_MISALIGNMENT values.  The peeling factor is the\n                  vectorization factor minus the misalignment as an element\n                  count.  */\n-\t      mis = DR_MISALIGNMENT (dr0) / vect_get_scalar_dr_size (dr0);\n-              npeel = ((negative ? mis - nelements : nelements - mis)\n-\t\t       & (nelements - 1));\n+\t      mis = negative ? DR_MISALIGNMENT (dr0) : -DR_MISALIGNMENT (dr0);\n+\t      unsigned int target_align = DR_TARGET_ALIGNMENT (dr0);\n+\t      npeel = ((mis & (target_align - 1))\n+\t\t       / vect_get_scalar_dr_size (dr0));\n             }\n \n \t  /* For interleaved data access every iteration accesses all the\n@@ -1976,10 +1989,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               unsigned max_peel = npeel;\n               if (max_peel == 0)\n                 {\n-\t\t  gimple *dr_stmt = DR_STMT (dr0);\n-                  stmt_vec_info vinfo = vinfo_for_stmt (dr_stmt);\n-                  tree vtype = STMT_VINFO_VECTYPE (vinfo);\n-                  max_peel = TYPE_VECTOR_SUBPARTS (vtype) - 1;\n+\t\t  unsigned int target_align = DR_TARGET_ALIGNMENT (dr0);\n+\t\t  max_peel = target_align / vect_get_scalar_dr_size (dr0) - 1;\n                 }\n               if (max_peel > max_allowed_peel)\n                 {\n@@ -2201,8 +2212,10 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr)\n   if (diff != 0)\n     {\n       /* Get the wider of the two alignments.  */\n-      unsigned int align_a = TYPE_ALIGN_UNIT (STMT_VINFO_VECTYPE (stmtinfo_a));\n-      unsigned int align_b = TYPE_ALIGN_UNIT (STMT_VINFO_VECTYPE (stmtinfo_b));\n+      unsigned int align_a = (vect_calculate_target_alignment (dra)\n+\t\t\t      / BITS_PER_UNIT);\n+      unsigned int align_b = (vect_calculate_target_alignment (drb)\n+\t\t\t      / BITS_PER_UNIT);\n       unsigned int max_align = MAX (align_a, align_b);\n \n       /* Require the gap to be a multiple of the larger vector alignment.  */\n@@ -3995,16 +4008,15 @@ vect_get_new_ssa_name (tree type, enum vect_var_kind var_kind, const char *name)\n /* Duplicate ptr info and set alignment/misaligment on NAME from DR.  */\n \n static void\n-vect_duplicate_ssa_name_ptr_info (tree name, data_reference *dr,\n-\t\t\t\t  stmt_vec_info stmt_info)\n+vect_duplicate_ssa_name_ptr_info (tree name, data_reference *dr)\n {\n   duplicate_ssa_name_ptr_info (name, DR_PTR_INFO (dr));\n-  unsigned int align = TYPE_ALIGN_UNIT (STMT_VINFO_VECTYPE (stmt_info));\n   int misalign = DR_MISALIGNMENT (dr);\n   if (misalign == DR_MISALIGNMENT_UNKNOWN)\n     mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));\n   else\n-    set_ptr_info_alignment (SSA_NAME_PTR_INFO (name), align, misalign);\n+    set_ptr_info_alignment (SSA_NAME_PTR_INFO (name),\n+\t\t\t    DR_TARGET_ALIGNMENT (dr), misalign);\n }\n \n /* Function vect_create_addr_base_for_vector_ref.\n@@ -4109,7 +4121,7 @@ vect_create_addr_base_for_vector_ref (gimple *stmt,\n       && TREE_CODE (addr_base) == SSA_NAME\n       && !SSA_NAME_PTR_INFO (addr_base))\n     {\n-      vect_duplicate_ssa_name_ptr_info (addr_base, dr, stmt_info);\n+      vect_duplicate_ssa_name_ptr_info (addr_base, dr);\n       if (offset || byte_offset)\n \tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (addr_base));\n     }\n@@ -4368,8 +4380,8 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n \t{\n-\t  vect_duplicate_ssa_name_ptr_info (indx_before_incr, dr, stmt_info);\n-\t  vect_duplicate_ssa_name_ptr_info (indx_after_incr, dr, stmt_info);\n+\t  vect_duplicate_ssa_name_ptr_info (indx_before_incr, dr);\n+\t  vect_duplicate_ssa_name_ptr_info (indx_after_incr, dr);\n \t}\n       if (ptr_incr)\n \t*ptr_incr = incr;\n@@ -4398,8 +4410,8 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n \t{\n-\t  vect_duplicate_ssa_name_ptr_info (indx_before_incr, dr, stmt_info);\n-\t  vect_duplicate_ssa_name_ptr_info (indx_after_incr, dr, stmt_info);\n+\t  vect_duplicate_ssa_name_ptr_info (indx_before_incr, dr);\n+\t  vect_duplicate_ssa_name_ptr_info (indx_after_incr, dr);\n \t}\n       if (ptr_incr)\n \t*ptr_incr = incr;\n@@ -5003,10 +5015,10 @@ vect_setup_realignment (gimple *stmt, gimple_stmt_iterator *gsi,\n \tnew_temp = copy_ssa_name (ptr);\n       else\n \tnew_temp = make_ssa_name (TREE_TYPE (ptr));\n+      unsigned int align = DR_TARGET_ALIGNMENT (dr);\n       new_stmt = gimple_build_assign\n \t\t   (new_temp, BIT_AND_EXPR, ptr,\n-\t\t    build_int_cst (TREE_TYPE (ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\t    build_int_cst (TREE_TYPE (ptr), -(HOST_WIDE_INT) align));\n       new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n       gcc_assert (!new_bb);\n       data_ref"}, {"sha": "5787d53a83a4000da30d7415f482a2b5e581ea5a", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -956,8 +956,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n   gimple *dr_stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (dr_stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n-  int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned int target_align = DR_TARGET_ALIGNMENT (dr);\n \n   if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n@@ -978,32 +977,36 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n       tree start_addr = vect_create_addr_base_for_vector_ref (dr_stmt,\n \t\t\t\t\t\t\t      &stmts, offset);\n       tree type = unsigned_type_for (TREE_TYPE (start_addr));\n-      tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);\n-      HOST_WIDE_INT elem_size =\n-                int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n+      tree target_align_minus_1 = build_int_cst (type, target_align - 1);\n+      HOST_WIDE_INT elem_size\n+\t= int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n       tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));\n-      tree nelements_minus_1 = build_int_cst (type, nelements - 1);\n-      tree nelements_tree = build_int_cst (type, nelements);\n-      tree byte_misalign;\n-      tree elem_misalign;\n-\n-      /* Create:  byte_misalign = addr & (vectype_align - 1)  */\n-      byte_misalign =\n-\tfold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr),\n-\t\t     vectype_align_minus_1);\n-\n-      /* Create:  elem_misalign = byte_misalign / element_size  */\n-      elem_misalign =\n-\tfold_build2 (RSHIFT_EXPR, type, byte_misalign, elem_size_log);\n-\n-      /* Create:  (niters_type) (nelements - elem_misalign)&(nelements - 1)  */\n+      HOST_WIDE_INT align_in_elems = target_align / elem_size;\n+      tree align_in_elems_minus_1 = build_int_cst (type, align_in_elems - 1);\n+      tree align_in_elems_tree = build_int_cst (type, align_in_elems);\n+      tree misalign_in_bytes;\n+      tree misalign_in_elems;\n+\n+      /* Create:  misalign_in_bytes = addr & (target_align - 1).  */\n+      misalign_in_bytes\n+\t= fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr),\n+\t\t       target_align_minus_1);\n+\n+      /* Create:  misalign_in_elems = misalign_in_bytes / element_size.  */\n+      misalign_in_elems\n+\t= fold_build2 (RSHIFT_EXPR, type, misalign_in_bytes, elem_size_log);\n+\n+      /* Create:  (niters_type) ((align_in_elems - misalign_in_elems)\n+\t\t\t\t & (align_in_elems - 1)).  */\n       if (negative)\n-\titers = fold_build2 (MINUS_EXPR, type, elem_misalign, nelements_tree);\n+\titers = fold_build2 (MINUS_EXPR, type, misalign_in_elems,\n+\t\t\t     align_in_elems_tree);\n       else\n-\titers = fold_build2 (MINUS_EXPR, type, nelements_tree, elem_misalign);\n-      iters = fold_build2 (BIT_AND_EXPR, type, iters, nelements_minus_1);\n+\titers = fold_build2 (MINUS_EXPR, type, align_in_elems_tree,\n+\t\t\t     misalign_in_elems);\n+      iters = fold_build2 (BIT_AND_EXPR, type, iters, align_in_elems_minus_1);\n       iters = fold_convert (niters_type, iters);\n-      *bound = nelements - 1;\n+      *bound = align_in_elems - 1;\n     }\n \n   if (dump_enabled_p ())"}, {"sha": "29b733324d751cb9c98546327f7d808e9f217285", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -1737,6 +1737,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n   gimple *first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+  data_reference *first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n   unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n   bool single_element_p = (stmt == first_stmt\n \t\t\t   && !GROUP_NEXT_ELEMENT (stmt_info));\n@@ -1780,10 +1781,13 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t\t\t       \" non-consecutive accesses\\n\");\n \t      return false;\n \t    }\n-\t  /* If the access is aligned an overrun is fine.  */\n+\t  /* An overrun is fine if the trailing elements are smaller\n+\t     than the alignment boundary B.  Every vector access will\n+\t     be a multiple of B and so we are guaranteed to access a\n+\t     non-gap element in the same B-sized block.  */\n \t  if (overrun_p\n-\t      && aligned_access_p\n-\t\t   (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt))))\n+\t      && gap < (vect_known_alignment_in_bytes (first_dr)\n+\t\t\t/ vect_get_scalar_dr_size (first_dr)))\n \t    overrun_p = false;\n \t  if (overrun_p && !can_overrun_p)\n \t    {\n@@ -1804,14 +1808,15 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n       /* If there is a gap at the end of the group then these optimizations\n \t would access excess elements in the last iteration.  */\n       bool would_overrun_p = (gap != 0);\n-      /* If the access is aligned an overrun is fine, but only if the\n-         overrun is not inside an unused vector (if the gap is as large\n-\t or larger than a vector).  */\n+      /* An overrun is fine if the trailing elements are smaller than the\n+\t alignment boundary B.  Every vector access will be a multiple of B\n+\t and so we are guaranteed to access a non-gap element in the\n+\t same B-sized block.  */\n       if (would_overrun_p\n-\t  && gap < nunits\n-\t  && aligned_access_p\n-\t\t(STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt))))\n+\t  && gap < (vect_known_alignment_in_bytes (first_dr)\n+\t\t    / vect_get_scalar_dr_size (first_dr)))\n \twould_overrun_p = false;\n+\n       if (!STMT_VINFO_STRIDED_P (stmt_info)\n \t  && (can_overrun_p || !would_overrun_p)\n \t  && compare_step_with_zero (stmt) > 0)\n@@ -2351,7 +2356,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t\t     TYPE_SIZE_UNIT (vectype));\n \t    }\n \n-\t  align = TYPE_ALIGN_UNIT (vectype);\n+\t  align = DR_TARGET_ALIGNMENT (dr);\n \t  if (aligned_access_p (dr))\n \t    misalign = 0;\n \t  else if (DR_MISALIGNMENT (dr) == -1)\n@@ -2404,7 +2409,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t\t     TYPE_SIZE_UNIT (vectype));\n \t    }\n \n-\t  align = TYPE_ALIGN_UNIT (vectype);\n+\t  align = DR_TARGET_ALIGNMENT (dr);\n \t  if (aligned_access_p (dr))\n \t    misalign = 0;\n \t  else if (DR_MISALIGNMENT (dr) == -1)\n@@ -5553,25 +5558,25 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n-/* A helper function to ensure data reference DR's base alignment\n-   for STMT_INFO.  */\n+/* A helper function to ensure data reference DR's base alignment.  */\n \n static void\n-ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n+ensure_base_align (struct data_reference *dr)\n {\n   if (!dr->aux)\n     return;\n \n   if (DR_VECT_AUX (dr)->base_misaligned)\n     {\n-      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       tree base_decl = DR_VECT_AUX (dr)->base_decl;\n \n+      unsigned int align_base_to = DR_TARGET_ALIGNMENT (dr) * BITS_PER_UNIT;\n+\n       if (decl_in_symtab_p (base_decl))\n-\tsymtab_node::get (base_decl)->increase_alignment (TYPE_ALIGN (vectype));\n+\tsymtab_node::get (base_decl)->increase_alignment (align_base_to);\n       else\n \t{\n-          SET_DECL_ALIGN (base_decl, TYPE_ALIGN (vectype));\n+\t  SET_DECL_ALIGN (base_decl, align_base_to);\n           DECL_USER_ALIGN (base_decl) = 1;\n \t}\n       DR_VECT_AUX (dr)->base_misaligned = false;\n@@ -5775,7 +5780,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   /* Transform.  */\n \n-  ensure_base_align (stmt_info, dr);\n+  ensure_base_align (dr);\n \n   if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n@@ -6417,7 +6422,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t      dataref_offset\n \t\t\t\t      ? dataref_offset\n \t\t\t\t      : build_int_cst (ref_type, 0));\n-\t      align = TYPE_ALIGN_UNIT (vectype);\n+\t      align = DR_TARGET_ALIGNMENT (first_dr);\n \t      if (aligned_access_p (first_dr))\n \t\tmisalign = 0;\n \t      else if (DR_MISALIGNMENT (first_dr) == -1)\n@@ -6813,7 +6818,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   /* Transform.  */\n \n-  ensure_base_align (stmt_info, dr);\n+  ensure_base_align (dr);\n \n   if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n@@ -7512,7 +7517,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t     dataref_offset\n \t\t\t\t     ? dataref_offset\n \t\t\t\t     : build_int_cst (ref_type, 0));\n-\t\t    align = TYPE_ALIGN_UNIT (vectype);\n+\t\t    align = DR_TARGET_ALIGNMENT (dr);\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n \t\t\tgcc_assert (aligned_access_p (first_dr));\n@@ -7555,11 +7560,12 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t      ptr = copy_ssa_name (dataref_ptr);\n \t\t    else\n \t\t      ptr = make_ssa_name (TREE_TYPE (dataref_ptr));\n+\t\t    unsigned int align = DR_TARGET_ALIGNMENT (first_dr);\n \t\t    new_stmt = gimple_build_assign\n \t\t\t\t (ptr, BIT_AND_EXPR, dataref_ptr,\n \t\t\t\t  build_int_cst\n \t\t\t\t  (TREE_TYPE (dataref_ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\t\t\t   -(HOST_WIDE_INT) align));\n \t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t\t    data_ref\n \t\t      = build2 (MEM_REF, vectype, ptr,\n@@ -7581,8 +7587,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    new_stmt = gimple_build_assign\n \t\t\t\t (NULL_TREE, BIT_AND_EXPR, ptr,\n \t\t\t\t  build_int_cst\n-\t\t\t\t  (TREE_TYPE (ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n+\t\t\t\t  (TREE_TYPE (ptr), -(HOST_WIDE_INT) align));\n \t\t    ptr = copy_ssa_name (ptr, new_stmt);\n \t\t    gimple_assign_set_lhs (new_stmt, ptr);\n \t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -7592,20 +7597,22 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    break;\n \t\t  }\n \t\tcase dr_explicit_realign_optimized:\n-\t\t  if (TREE_CODE (dataref_ptr) == SSA_NAME)\n-\t\t    new_temp = copy_ssa_name (dataref_ptr);\n-\t\t  else\n-\t\t    new_temp = make_ssa_name (TREE_TYPE (dataref_ptr));\n-\t\t  new_stmt = gimple_build_assign\n-\t\t\t       (new_temp, BIT_AND_EXPR, dataref_ptr,\n-\t\t\t\tbuild_int_cst\n-\t\t\t\t  (TREE_TYPE (dataref_ptr),\n-\t\t\t\t   -(HOST_WIDE_INT)TYPE_ALIGN_UNIT (vectype)));\n-\t\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\t\t  data_ref\n-\t\t    = build2 (MEM_REF, vectype, new_temp,\n-\t\t\t      build_int_cst (ref_type, 0));\n-\t\t  break;\n+\t\t  {\n+\t\t    if (TREE_CODE (dataref_ptr) == SSA_NAME)\n+\t\t      new_temp = copy_ssa_name (dataref_ptr);\n+\t\t    else\n+\t\t      new_temp = make_ssa_name (TREE_TYPE (dataref_ptr));\n+\t\t    unsigned int align = DR_TARGET_ALIGNMENT (first_dr);\n+\t\t    new_stmt = gimple_build_assign\n+\t\t      (new_temp, BIT_AND_EXPR, dataref_ptr,\n+\t\t       build_int_cst (TREE_TYPE (dataref_ptr),\n+\t\t\t\t     -(HOST_WIDE_INT) align));\n+\t\t    vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t\t    data_ref\n+\t\t      = build2 (MEM_REF, vectype, new_temp,\n+\t\t\t\tbuild_int_cst (ref_type, 0));\n+\t\t    break;\n+\t\t  }\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}"}, {"sha": "06224f9f94dba55b958411f66e02cbedf2372e81", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f702e7d43f2aec71640d0db7ecf1543ba75f37c3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f702e7d43f2aec71640d0db7ecf1543ba75f37c3", "patch": "@@ -790,7 +790,11 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n struct dataref_aux {\n+  /* The misalignment in bytes of the reference, or -1 if not known.  */\n   int misalignment;\n+  /* The byte alignment that we'd ideally like the reference to have,\n+     and the value that misalignment is measured against.  */\n+  int target_alignment;\n   /* If true the alignment of base_decl needs to be increased.  */\n   bool base_misaligned;\n   tree base_decl;\n@@ -1037,7 +1041,11 @@ dr_misalignment (struct data_reference *dr)\n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n #define DR_MISALIGNMENT_UNKNOWN (-1)\n \n-/* Return TRUE if the data access is aligned, and FALSE otherwise.  */\n+/* Only defined once DR_MISALIGNMENT is defined.  */\n+#define DR_TARGET_ALIGNMENT(DR) DR_VECT_AUX (DR)->target_alignment\n+\n+/* Return true if data access DR is aligned to its target alignment\n+   (which may be less than a full vector).  */\n \n static inline bool\n aligned_access_p (struct data_reference *data_ref_info)\n@@ -1054,6 +1062,19 @@ known_alignment_for_access_p (struct data_reference *data_ref_info)\n   return (DR_MISALIGNMENT (data_ref_info) != DR_MISALIGNMENT_UNKNOWN);\n }\n \n+/* Return the minimum alignment in bytes that the vectorized version\n+   of DR is guaranteed to have.  */\n+\n+static inline unsigned int\n+vect_known_alignment_in_bytes (struct data_reference *dr)\n+{\n+  if (DR_MISALIGNMENT (dr) == DR_MISALIGNMENT_UNKNOWN)\n+    return TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr)));\n+  if (DR_MISALIGNMENT (dr) == 0)\n+    return DR_TARGET_ALIGNMENT (dr);\n+  return DR_MISALIGNMENT (dr) & -DR_MISALIGNMENT (dr);\n+}\n+\n /* Return the behavior of DR with respect to the vectorization context\n    (which for outer loop vectorization might not be the behavior recorded\n    in DR itself).  */"}]}