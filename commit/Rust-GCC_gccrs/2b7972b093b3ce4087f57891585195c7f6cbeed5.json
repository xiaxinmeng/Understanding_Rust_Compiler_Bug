{"sha": "2b7972b093b3ce4087f57891585195c7f6cbeed5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3OTcyYjA5M2IzY2U0MDg3ZjU3ODkxNTg1MTk1YzdmNmNiZWVkNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-04-28T05:58:21Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-04-28T05:58:21Z"}, "message": "update m32r port\n\nFrom-SVN: r19465", "tree": {"sha": "f579abf03a73032cbc0ea682d5503777e1313833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f579abf03a73032cbc0ea682d5503777e1313833"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b7972b093b3ce4087f57891585195c7f6cbeed5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7972b093b3ce4087f57891585195c7f6cbeed5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b7972b093b3ce4087f57891585195c7f6cbeed5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7972b093b3ce4087f57891585195c7f6cbeed5/comments", "author": null, "committer": null, "parents": [{"sha": "77be0cab5fd1181e2b7d88234753d0e2b2e3a112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77be0cab5fd1181e2b7d88234753d0e2b2e3a112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77be0cab5fd1181e2b7d88234753d0e2b2e3a112"}], "stats": {"total": 1085, "additions": 941, "deletions": 144}, "files": [{"sha": "5c1fd17e1bbaeba8be3c190821b879866537c1a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -1,3 +1,60 @@\n+Tue Apr 28 08:55:26 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* m32r.c (*_oper{and|ator}): Change enum arguments and return\n+\tvalues to int, so they can be prototyped even in files that don't\n+\tinclude rtl.h.\n+\t({small,large}_insn_p): Ditto.\n+\t(m32r_select_cc_mode): Ditto.\n+\t(gen_compare): Ditto.\n+\t(function_arg_partial_nregs): Ditto.\n+\t(m32r_setup_incoming_varargs): Ditto.\n+\t(init_reg_tables): Add prototype.\n+\t(m32r_frame_info): Add prolog_size field.\n+\t(m32r_compute_frame_size): Calculate the size of the prologue.\n+\t(m32r_first_insn_address): Return prologue size.\n+\t(m32r_output_function_prologue): Calculate frame size before\n+\tprinting out information.  Print out the prologue size.\n+\n+\t* m32r.h: Prototype all functions in m32r.c.\n+\t(FIRST_INSN_ADDRESS): Declare, returning prologue size.\n+\n+\t* m32r.md (bcc functions): Cast enum's to int.\n+\n+\t* m32r.c (conditional_move_operand): Silence a debug message.\n+\t({small,long}_insn): New predicates.\n+\t\n+\t* m32r.h (TARGET_M32R): New macro.\n+\t(PREDICATE_CODES): Rearrange somewhat, add small_insn/long_insn.\n+\t(HAIFA_P): Define as 1/0 depending on whether the Haifa scheduler\n+\twas selected.\n+\t(ISSUE_RATE): Define as 2.\n+\n+\t* m32r.md (insn_size): New attribute.\n+\t({,rev_}branch_insn): Add .s qualifier to branches believed to be\n+\tshort.\n+\t(m32r): New attribute.\n+\n+\t* configure.in (enable_haifa): Switch m32r to Haifa by default.\n+\t* configure: Regenerate.\n+\n+\t(Changes from Nick Clifton <nickc@cygnus.com>)\n+\t* m32r.h (EXTRA_CONSTRAINT): Implement 'S' constraint to perfoirm\n+\tthe equivalent of a negated 'I' constraint.\n+\t(PRESERVE_DEATH_INFO_REGNO_P): Define in order to allow peephole\n+\toptimisation to work.\n+\n+\t* m32r.md (cmp_ne_small_const_insn): Use 'S' constriant rather\n+\tthan 'I' since the value is negated.\n+\t(peephole): Add peephole optimisation to cope with optimization of\n+\tdivide and subtracts of the same operands.\n+\n+\t* m32r.c zero_and_one, emit_cond_move): Add support for MVFC.\n+\t* m32r.h: Ditto. \n+\t* m32r.md: Ditto.\n+\n+\t* m32r.h (PREDICATE_CODES): Add declaration of machine specific\n+\tpredicates.\n+\n Tue Apr 28 07:25:53 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* Makefile.in (libgcc2.ready): Revert last patch (Apr 24)."}, {"sha": "3f800578e5c834605718a8c8ac0048023f8a1ec8", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 419, "deletions": 75, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on the Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -41,8 +41,6 @@ rtx m32r_compare_op0, m32r_compare_op1;\n /* Array of valid operand punctuation characters.  */\n char m32r_punct_chars[256];\n \n-static void init_reg_tables ();\n-\n /* Selected code model.  */\n char *m32r_model_string = M32R_MODEL_DEFAULT;\n enum m32r_model m32r_model;\n@@ -51,6 +49,10 @@ enum m32r_model m32r_model;\n char *m32r_sdata_string = M32R_SDATA_DEFAULT;\n enum m32r_sdata m32r_sdata;\n \n+\n+/* Forward declaration.  */\n+static void init_reg_tables\tPROTO((void));\n+\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */\n \n void\n@@ -84,6 +86,7 @@ m32r_init ()\n     m32r_sdata = M32R_SDATA_USE;\n   else\n     error (\"bad value (%s) for -msdata switch\", m32r_sdata_string);\n+\n }\n \n /* Vectors to keep interesting information about registers where it can easily\n@@ -95,7 +98,8 @@ m32r_init ()\n    they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n    mapped into one m32r_mode_class mode.  */\n \n-enum m32r_mode_class {\n+enum m32r_mode_class\n+{\n   C_MODE,\n   S_MODE, D_MODE, T_MODE, O_MODE,\n   SF_MODE, DF_MODE, TF_MODE, OF_MODE\n@@ -113,9 +117,11 @@ enum m32r_mode_class {\n /* Modes for quad-word and smaller quantities.  */\n #define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n \n+\n /* Value is 1 if register/mode pair is acceptable on arc.  */\n \n-unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] = {\n+unsigned int m32r_hard_regno_mode_ok[FIRST_PSEUDO_REGISTER] =\n+{\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n   T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, S_MODES, S_MODES, S_MODES,\n   S_MODES, C_MODES\n@@ -412,21 +418,23 @@ m32r_init_expanders ()\n /* Acceptable arguments to the call insn.  */\n \n int\n-call_address_operand (op, mode)\n+call_address_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n-  return symbolic_operand (op, mode);\n+  return symbolic_operand (op, int_mode);\n \n-  /* Constants and values in registers are not OK, because\n-     the m32r BL instruction can only support PC relative branching.  */ \n+/* Constants and values in registers are not OK, because\n+   the m32r BL instruction can only support PC relative branching.  */ \n }\n \n int\n-call_operand (op, mode)\n+call_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+\n   if (GET_CODE (op) != MEM)\n     return 0;\n   op = XEXP (op, 0);\n@@ -436,16 +444,17 @@ call_operand (op, mode)\n /* Returns 1 if OP is a symbol reference.  */\n \n int\n-symbolic_operand (op, mode)\n+symbolic_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST :\n       return 1;\n+\n     default:\n       return 0;\n     }\n@@ -454,9 +463,9 @@ symbolic_operand (op, mode)\n /* Return 1 if OP is a reference to an object in .sdata/.sbss.  */\n \n int\n-small_data_operand (op, mode)\n+small_data_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (! TARGET_SDATA_USE)\n     return 0;\n@@ -477,9 +486,9 @@ small_data_operand (op, mode)\n /* Return 1 if OP is a symbol that can use 24 bit addressing.  */\n \n int\n-addr24_operand (op, mode)\n+addr24_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR24;\n@@ -509,24 +518,24 @@ addr24_operand (op, mode)\n /* Return 1 if OP is a symbol that needs 32 bit addressing.  */\n \n int\n-addr32_operand (op, mode)\n+addr32_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR32;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return (! addr24_operand (op)\n-\t    && ! small_data_operand (op));\n+    return (! addr24_operand (op, int_mode)\n+\t    && ! small_data_operand (op, int_mode));\n \n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n     {\n-      return (! addr24_operand (op)\n-\t      && ! small_data_operand (op));\n+      return (! addr24_operand (op, int_mode)\n+\t      && ! small_data_operand (op, int_mode));\n     }\n \n   return 0;\n@@ -535,9 +544,9 @@ addr32_operand (op, mode)\n /* Return 1 if OP is a function that can be called with the `bl' insn.  */\n \n int\n-call26_operand (op, mode)\n+call26_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) == SYMBOL_REF)\n     return ! LARGE_NAME_P (XSTR (op, 0));\n@@ -548,9 +557,9 @@ call26_operand (op, mode)\n /* Returns 1 if OP is an acceptable operand for seth/add3.  */\n \n int\n-seth_add3_operand (op, mode)\n+seth_add3_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       || GET_CODE (op) == LABEL_REF)\n@@ -570,9 +579,9 @@ seth_add3_operand (op, mode)\n    useful in comparisons.  */\n \n int\n-cmp_int16_operand (op, mode)\n+cmp_int16_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -581,10 +590,10 @@ cmp_int16_operand (op, mode)\n \n /* Return true if OP is an unsigned 16 bit immediate value.  */\n \n-static int\n-uint16_operand (op, mode)\n+int\n+uint16_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -594,10 +603,12 @@ uint16_operand (op, mode)\n /* Return true if OP is a register or signed 8 bit value.  */\n \n int\n-reg_or_int16_operand (op, mode)\n+reg_or_int16_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n@@ -608,10 +619,12 @@ reg_or_int16_operand (op, mode)\n /* Return true if OP is a register or an unsigned 16 bit value.  */\n \n int\n-reg_or_uint16_operand (op, mode)\n+reg_or_uint16_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n@@ -622,10 +635,12 @@ reg_or_uint16_operand (op, mode)\n /* Return true if OP is a register or signed 16 bit value for compares.  */\n \n int\n-reg_or_cmp_int16_operand (op, mode)\n+reg_or_cmp_int16_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+\n   if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n   if (GET_CODE (op) != CONST_INT)\n@@ -636,9 +651,9 @@ reg_or_cmp_int16_operand (op, mode)\n /* Return true if OP is a const_int requiring two instructions to load.  */\n \n int\n-two_insn_const_operand (op, mode)\n+two_insn_const_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -653,15 +668,16 @@ two_insn_const_operand (op, mode)\n    move source.  */\n \n int\n-move_src_operand (op, mode)\n+move_src_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF :\n     case CONST :\n-      return addr24_operand (op, mode);\n+      return addr24_operand (op, int_mode);\n     case CONST_INT :\n       /* ??? We allow more cse opportunities if we only allow constants\n \t loadable with one insn, and split the rest into two.  The instances\n@@ -704,10 +720,11 @@ move_src_operand (op, mode)\n    move source.  */\n \n int\n-move_double_src_operand (op, mode)\n+move_double_src_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case CONST_INT :\n@@ -722,7 +739,7 @@ move_double_src_operand (op, mode)\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a\n \t pseudo-reg and is now a stack slot.  */\n       if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn move_double_src_operand (SUBREG_REG (op), mode);\n+\treturn move_double_src_operand (SUBREG_REG (op), int_mode);\n       else\n \treturn register_operand (op, mode);\n     case MEM :\n@@ -739,10 +756,11 @@ move_double_src_operand (op, mode)\n /* Return true if OP is an acceptable argument for a move destination.  */\n \n int\n-move_dest_operand (op, mode)\n+move_dest_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n   switch (GET_CODE (op))\n     {\n     case REG :\n@@ -805,9 +823,9 @@ easy_df_const (op)\n /* Return 1 if OP is an EQ or NE comparison operator.  */\n \n int\n-eqne_comparison_operator (op, mode)\n+eqne_comparison_operator (op, int_mode)\n     rtx op;\n-    enum machine_mode mode;\n+    int int_mode;\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -819,9 +837,9 @@ eqne_comparison_operator (op, mode)\n /* Return 1 if OP is a signed comparison operator.  */\n \n int\n-signed_comparison_operator (op, mode)\n+signed_comparison_operator (op, int_mode)\n     rtx op;\n-    enum machine_mode mode;\n+    int int_mode;\n {\n   enum rtx_code code = GET_CODE (op);\n \n@@ -835,35 +853,70 @@ signed_comparison_operator (op, mode)\n    This is used in insn length calcs.  */\n \n int\n-memreg_operand (op, mode)\n+memreg_operand (op, int_mode)\n      rtx op;\n-     enum machine_mode mode;\n+     int int_mode;\n {\n   return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n }\n+\n+/* Return non-zero if the operand is an insn that is a small insn.\n+   Allow const_int 0 as well, which is a placeholder for NOP slots.  */\n+\n+int\n+small_insn_p (op, int_mode)\n+     rtx op;\n+     int int_mode;\n+{\n+  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+    return 1;\n+\n+  if (GET_RTX_CLASS (GET_CODE (op)) != 'i')\n+    return 0;\n+\n+  return get_attr_length (op) == 2;\n+}\n+\n+/* Return non-zero if the operand is an insn that is a large insn.  */\n+\n+int\n+large_insn_p (op, int_mode)\n+     rtx op;\n+     int int_mode;\n+{\n+  if (GET_RTX_CLASS (GET_CODE (op)) != 'i')\n+    return 0;\n+\n+  return get_attr_length (op) != 2;\n+}\n+\n \f\n /* Comparisons.  */\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n \n-enum machine_mode\n+int\n m32r_select_cc_mode (op, x, y)\n-     enum rtx_code op;\n+     int op;\n      rtx x, y;\n {\n-  return CCmode;\n+  return (int)CCmode;\n }\n \n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for compare [arg0 of the if_then_else].  */\n+   return the rtx for compare [arg0 of the if_then_else].\n+   If need_compare is true then the comparison insn must be generated, rather\n+   than being susummed into the following branch instruction. */\n \n rtx\n-gen_compare (code, x, y)\n-     enum rtx_code code;\n+gen_compare (int_code, x, y, need_compare)\n+     int\t   int_code;\n      rtx           x;\n      rtx           y;\n+     int           need_compare;\n {\n+  enum rtx_code     code = (enum rtx_code)int_code;\n   enum rtx_code     compare_code;\n   enum rtx_code     branch_code;\n   enum machine_mode mode      = SELECT_CC_MODE (code, x, y);\n@@ -884,7 +937,122 @@ gen_compare (code, x, y)\n     case GEU: compare_code = LTU; branch_code = EQ; break;\n     }\n \n-  if (! TARGET_OLD_COMPARE)\n+  if (need_compare)\n+    {\n+      switch (compare_code)\n+\t{\n+\tcase EQ:\n+\t  if (GET_CODE (y) == CONST_INT\n+\t      && CMP_INT16_P (INTVAL (y))\t\t/* reg equal to small const.  */\n+\t      && y != const0_rtx)\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (SImode);\t\t\n+\t      \n+\t      emit_insn (gen_cmp_ne_small_const_insn (tmp, x, y));\n+\t      x = tmp;\n+\t      y = const0_rtx;\n+\t    }\n+\t  else if (CONSTANT_P (y))\t\t\t/* reg equal to const.  */\n+\t    {\n+\t      rtx tmp = force_reg (GET_MODE (x), y);\n+\t      y = tmp;\n+\t    }\n+\n+\t  if (register_operand (y, SImode) \t\t/* reg equal to reg.  */\n+\t      || y == const0_rtx) \t   \t\t/* req equal to zero. */\n+\t    {\n+\t\temit_insn (gen_cmp_eqsi_insn (x, y));\n+\t\t\n+\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t    }\n+\t  break;\n+      \n+\tcase LT:\n+\t  if (register_operand (y, SImode)\n+\t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (SImode);\t      /* reg compared to reg. */\n+\t      \n+\t      switch (code)\n+\t\t{\n+\t\tcase LT:\n+\t\t  emit_insn (gen_cmp_ltsi_insn (x, y));\n+\t\t  code = EQ;\n+\t\t  break;\n+\t\tcase LE:\n+\t\t  if (y == const0_rtx)\n+\t\t    tmp = const1_rtx;\n+\t\t  else\n+\t\t    emit_insn (gen_cmp_ne_small_const_insn (tmp, y, const1_rtx));\n+\t\t  emit_insn (gen_cmp_ltsi_insn (x, tmp));\n+\t\t  code = EQ;\n+\t\t  break;\n+\t\tcase GT:\n+\t\t  if (GET_CODE (y) == CONST_INT)\n+\t\t    tmp = gen_rtx (PLUS, SImode, y, const1_rtx);\n+\t\t  else\n+\t\t    emit_insn (gen_cmp_ne_small_const_insn (tmp, y, const1_rtx));\n+\t\t  emit_insn (gen_cmp_ltsi_insn (x, tmp));\n+\t\t  code = NE;\n+\t\t  break;\n+\t\tcase GE:\n+\t\t  emit_insn (gen_cmp_ltsi_insn (x, y));\n+\t\t  code = NE;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort();\n+\t\t}\n+\t      \n+\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t    }\n+\t  break;\n+\t  \n+\tcase LTU:\n+\t  if (register_operand (y, SImode)\n+\t      || (GET_CODE (y) == CONST_INT && CMP_INT16_P (INTVAL (y))))\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (SImode);\t      /* reg (unsigned) compared to reg. */\n+\t      \n+\t      switch (code)\n+\t\t{\n+\t\tcase LTU:\n+\t\t  emit_insn (gen_cmp_ltusi_insn (x, y));\n+\t\t  code = EQ;\n+\t\t  break;\n+\t\tcase LEU:\n+\t\t  if (y == const0_rtx)\n+\t\t    tmp = const1_rtx;\n+\t\t  else\n+\t\t    emit_insn (gen_cmp_ne_small_const_insn (tmp, y, const1_rtx));\n+\t\t  emit_insn (gen_cmp_ltusi_insn (x, tmp));\n+\t\t  code = EQ;\n+\t\t  break;\n+\t\tcase GTU:\n+\t\t  if (GET_CODE (y) == CONST_INT)\n+\t\t    tmp = gen_rtx (PLUS, SImode, y, const1_rtx);\n+\t\t  else\n+\t\t    emit_insn (gen_cmp_ne_small_const_insn (tmp, y, const1_rtx));\n+\t\t  emit_insn (gen_cmp_ltusi_insn (x, tmp));\n+\t\t  code = NE;\n+\t\t  break;\n+\t\tcase GEU:\n+\t\t  emit_insn (gen_cmp_ltusi_insn (x, y));\n+\t\t  code = NE;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort();\n+\t\t}\n+\t      \n+\t      return gen_rtx (code, mode, cc_reg, const0_rtx);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  abort();\n+\t}\n+    }\n+  else\n+    if (! TARGET_OLD_COMPARE)\n     {\n       /* reg/reg equal comparison */\n       if (compare_code == EQ\n@@ -950,12 +1118,13 @@ gen_compare (code, x, y)\n /* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n+function_arg_partial_nregs (cum, int_mode, type, named)\n      CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n+     int int_mode;\n      tree type;\n      int named;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n   int ret;\n   int size = (((mode == BLKmode && type)\n \t       ? int_size_in_bytes (type)\n@@ -979,13 +1148,14 @@ function_arg_partial_nregs (cum, mode, type, named)\n    and mode MODE, and we rely on this fact.  */\n \n void\n-m32r_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n+m32r_setup_incoming_varargs (cum, int_mode, type, pretend_size, no_rtl)\n      CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n+     int int_mode;\n      tree type;\n      int *pretend_size;\n      int no_rtl;\n {\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n   int first_anon_arg;\n \n   if (no_rtl)\n@@ -1128,6 +1298,7 @@ struct m32r_frame_info\n   unsigned int args_size;\t/* # bytes that outgoing arguments take up */\n   unsigned int reg_size;\t/* # bytes needed to store regs */\n   unsigned int var_size;\t/* # bytes that variables take up */\n+  unsigned int prolog_size;\t/* # bytes that the prologue takes up */\n   unsigned int gmask;\t\t/* mask of saved gp registers */\n   unsigned int save_fp;\t\t/* nonzero if fp must be saved */\n   unsigned int save_lr;\t\t/* nonzero if lr (return addr) must be saved */\n@@ -1153,6 +1324,9 @@ static struct m32r_frame_info zero_frame_info;\n #define MUST_SAVE_FRAME_POINTER (regs_ever_live[FRAME_POINTER_REGNUM])\n #define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM])\n \n+#define SHORT_INSN_SIZE 2\t/* size of small instructions */\n+#define LONG_INSN_SIZE 4\t/* size of long instructions */\n+\n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.\n \n@@ -1164,7 +1338,7 @@ m32r_compute_frame_size (size)\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n-  unsigned int reg_size;\n+  unsigned int reg_size, prolog_size, frame_size;\n   unsigned int gmask;\n   enum m32r_function_type fn_type;\n   int interrupt_p;\n@@ -1175,6 +1349,7 @@ m32r_compute_frame_size (size)\n   extra_size\t= FIRST_PARM_OFFSET (0);\n   total_size\t= extra_size + pretend_size + args_size + var_size;\n   reg_size\t= 0;\n+  prolog_size\t= 0;\n   gmask\t\t= 0;\n \n   /* See if this is an interrupt handler.  Call used registers must be saved\n@@ -1204,21 +1379,64 @@ m32r_compute_frame_size (size)\n      handler will do the right thing if this changes total_size.  */\n   total_size = M32R_STACK_ALIGN (total_size);\n \n+  /* Calculate prologue size.  Obviously any changes to\n+     m32r_output_function_prologue must be mirrored here.  */\n+  if (pretend_size)\n+    prolog_size += SHORT_INSN_SIZE;\t\t/* addi sp,-pretend_size */\n+\n+  prolog_size += SHORT_INSN_SIZE * (reg_size / UNITS_PER_WORD);\t/* pushes */\n+  frame_size = total_size - (pretend_size + reg_size);\n+\n+  if (frame_size == 0)\n+    ;\t\t\t\t\t\t/* nothing to do */\n+  else if (frame_size <= 128)\n+    prolog_size += SHORT_INSN_SIZE;\t\t/* addi sp,-<frame> */\n+  else\n+    {\n+      if ((prolog_size % LONG_INSN_SIZE) != 0)\n+\tprolog_size += SHORT_INSN_SIZE;\t\t/* nop */\n+\n+      if (frame_size <= 32768)\n+\tprolog_size += LONG_INSN_SIZE;\t\t/* add3 sp,sp,-<frame> */\n+      else\n+\tprolog_size += (LONG_INSN_SIZE\t\t/* ld24 tmp,<frame>/sub sp,tmp */\n+\t\t\t+ SHORT_INSN_SIZE);\n+    }\n+\n+  if (frame_pointer_needed)\n+    prolog_size += SHORT_INSN_SIZE;\t\t/* mv fp,sp */\n+\n   /* Save computed information.  */\n   current_frame_info.total_size   = total_size;\n   current_frame_info.extra_size   = extra_size;\n   current_frame_info.pretend_size = pretend_size;\n   current_frame_info.var_size     = var_size;\n   current_frame_info.args_size    = args_size;\n   current_frame_info.reg_size\t  = reg_size;\n+  current_frame_info.prolog_size  = prolog_size;\n   current_frame_info.gmask\t  = gmask;\n   current_frame_info.initialized  = reload_completed;\n \n   /* Ok, we're done.  */\n   return total_size;\n }\n \f\n-/* Set up the stack and frame pointer (if desired) for the function.  */\n+/* When the `length' insn attribute is used, this macro specifies the\n+   value to be assigned to the address of the first insn in a\n+   function.  If not specified, 0 is used.  */\n+\n+int\n+m32r_first_insn_address ()\n+{\n+  if (! current_frame_info.initialized)\n+    m32r_compute_frame_size (get_frame_size ());\n+\n+  return current_frame_info.prolog_size;\n+}\n+\f\n+/* Set up the stack and frame pointer (if desired) for the function.\n+   Note, if this is changed, you need to mirror the changes in\n+   m32r_compute_frame_size which calculates the prolog size.  */\n \n void\n m32r_output_function_prologue (file, size)\n@@ -1239,17 +1457,19 @@ m32r_output_function_prologue (file, size)\n \t       ASM_COMMENT_START);\n     }\n \n+  total_size = (! current_frame_info.initialized\n+\t\t? m32r_compute_frame_size (size)\n+\t\t: current_frame_info.total_size);\n+\n   /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s BEGIN PROLOGUE %s vars= %d, regs= %d, args= %d, extra= %d\\n\",\n-\t   ASM_COMMENT_START, ASM_COMMENT_START,\n+  fprintf (file,\n+\t   \"\\t%s BEGIN PROLOGUE, vars= %d, regs= %d, args= %d, extra= %d, prolog= %d\\n\",\n+\t   ASM_COMMENT_START,\n \t   current_frame_info.var_size,\n \t   current_frame_info.reg_size / 4,\n \t   current_frame_info.args_size,\n-\t   current_frame_info.extra_size);\n-\n-  total_size = (! current_frame_info.initialized\n-\t\t? m32r_compute_frame_size (size)\n-\t\t: current_frame_info.total_size);\n+\t   current_frame_info.extra_size,\n+\t   current_frame_info.prolog_size);\n \n   /* These cases shouldn't happen.  Catch them now.  */\n   if (total_size == 0 && gmask)\n@@ -1767,3 +1987,127 @@ m32r_print_operand_address (file, addr)\n       break;\n     }\n }\n+\n+/* Return true if the operands are the constants 0 and 1.  */\n+int\n+zero_and_one (operand1, operand2)\n+     rtx operand1;\n+     rtx operand2;\n+{\n+  return\n+       GET_CODE (operand1) == CONST_INT\n+    && GET_CODE (operand2) == CONST_INT\n+    && (  ((INTVAL (operand1) == 0) && (INTVAL (operand2) == 1))\n+\t||((INTVAL (operand1) == 1) && (INTVAL (operand2) == 0)));\n+}\n+\n+/* Return non-zero if the operand is suitable for use in a conditional move sequence.  */\n+int\n+conditional_move_operand (operand, int_mode)\n+     rtx operand;\n+     int int_mode;\n+{\n+  enum machine_mode mode = (enum machine_mode)int_mode;\n+\n+  /* Only defined for simple integers so far... */\n+  if (mode != SImode && mode != HImode && mode != QImode)\n+    return FALSE;\n+\n+  /* At the moment we can hanndle moving registers and loading constants.  */\n+  /* To be added: Addition/subtraction/bitops/multiplication of registers.  */\n+\n+  switch (GET_CODE (operand))\n+    {\n+    case REG:\n+      return 1;\n+\n+    case CONST_INT:\n+      return INT8_P (INTVAL (operand));\n+\n+    default:\n+#if 0\n+      fprintf (stderr, \"Test for cond move op of type: %s\\n\",\n+\t       GET_RTX_NAME (GET_CODE (operand)));\n+#endif\n+      return 0;\n+    }\n+}\n+\n+/* Return true if the code is a test of the carry bit */\n+int\n+carry_compare_operand (op, int_mode)\n+     rtx op;\n+     int int_mode;\n+{\n+  rtx x;\n+\n+  if (GET_MODE (op) != CCmode && GET_MODE (op) != VOIDmode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != NE && GET_CODE (op) != EQ)\n+    return FALSE;\n+\n+  x = XEXP (op, 0);\n+  if (GET_CODE (x) != REG || REGNO (x) != CARRY_REGNUM)\n+    return FALSE;\n+\n+  x = XEXP (op, 1);\n+  if (GET_CODE (x) != CONST_INT || INTVAL (x) != 0)\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n+\n+/* Generate the correct assembler code to handle the conditional loading of a\n+   value into a register.  It is known that the operands satisfy the\n+   conditional_move_operand() function above.  The destination is operand[0].\n+   The condition is operand [1].  The 'true' value is operand [2] and the\n+   'false' value is operand [3].  */\n+char *\n+emit_cond_move (operands, insn)\n+     rtx * operands;\n+     rtx   insn;\n+{\n+  static char buffer [100];\n+\n+  buffer [0] = 0;\n+  \n+  /* Destination must be a register.  */\n+  if (GET_CODE (operands [0]) != REG)\n+    abort();\n+  if (! conditional_move_operand (operands [2], SImode))\n+    abort();\n+  if (! conditional_move_operand (operands [3], SImode))\n+    abort();\n+      \n+\n+  /* Check to see if the test is reversed.  */\n+  if (GET_CODE (operands [1]) == NE)\n+    {\n+      rtx tmp = operands [2];\n+      operands [2] = operands [3];\n+      operands [3] = tmp;\n+    }\n+\n+  /* Catch a special case where 0 or 1 is being loaded into the destination.\n+     Since we already have these values in the C bit we can use a special\n+     instruction.  */\n+  if (zero_and_one (operands [2], operands [3]))\n+    {\n+      char * dest = reg_names [REGNO (operands [0])];\n+      \n+      sprintf (buffer, \"mvfc %s, cbr\", dest);\n+\n+      /* If the true value was '0' then we need to invert the results of the move.  */\n+      if (INTVAL (operands [2]) == 0)\n+\tsprintf (buffer + strlen (buffer), \"\\n\\txor3 %s, %s, #1\",\n+\t\t dest, dest);\n+      \n+      return buffer;\n+    }\n+\n+\n+  return buffer;\n+}\n+"}, {"sha": "199f386433e392b2a22a510264be470c9b833090", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 190, "deletions": 33, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n /* Print subsidiary information on the compiler version in use.  */\n #define TARGET_VERSION fprintf (stderr, \" (m32r)\")\n \n+\n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n #undef SWITCH_TAKES_ARG\n@@ -48,17 +49,18 @@ Boston, MA 02111-1307, USA.  */\n /* __M32R__ is defined by the existing compiler so we use that.  */\n #define CPP_PREDEFINES \"-Acpu(m32r) -Amachine(m32r) -D__M32R__\"\n \n-/* Additional flags for the preprocessor.  */\n-#define CPP_SPEC \"\"\n \n #define CC1_SPEC \"%{G*}\"\n \n-#undef ASM_SPEC\n+/* Options to pass on to the assembler.  */\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"%{v}\"\n+\n #if 0 /* not supported yet */\n+#undef  ASM_SPEC\n #define ASM_SPEC \"%{v} %{mrelax:-relax}\"\n-#else\n-#define ASM_SPEC \"%{v}\"\n #endif\n+     \n \n #undef ASM_FINAL_SPEC\n \n@@ -72,9 +74,11 @@ Boston, MA 02111-1307, USA.  */\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{!shared:crt0.o%s crtsysc.o%s} crtinit.o%s\"\n \n+\n #undef ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtfini.o%s\"\n \n+     \n #undef LIB_SPEC\n \f\n /* Run-time compilation parameters selecting different hardware subsets.  */\n@@ -105,6 +109,10 @@ extern int target_flags;\n #define TARGET_OLD_COMPARE_MASK 8\n #define TARGET_OLD_COMPARE (target_flags & TARGET_OLD_COMPARE_MASK)\n \n+/* Target machine to compile for.  */\n+#define TARGET_M32R 1\n+\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -147,6 +155,8 @@ extern int target_flags;\n \n extern char *m32r_model_string;\n extern char *m32r_sdata_string;\n+\n+\n #define TARGET_OPTIONS \\\n {\t\t\t\t\t\t\\\n   { \"model=\",\t&m32r_model_string\t},\t\\\n@@ -239,10 +249,10 @@ extern enum m32r_sdata m32r_sdata;\n #define M32R_SDATA_DEFAULT \"none\"\n \n /* Define this macro as a C expression for the initializer of an array of\n-   string to tell the driver program which options are defaults for this\n+   strings to tell the driver program which options are defaults for this\n    target and thus do not need to be handled specially when using\n    `MULTILIB_OPTIONS'.  */\n-#define MULTILIB_DEFAULTS { \"mmodel=small\" }\n+#define MULTILIB_DEFAULTS { \"mmodel=small\", \"m32r\" }\n \n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n@@ -253,8 +263,6 @@ extern enum m32r_sdata m32r_sdata;\n    Don't use this macro to turn on various extra optimizations for\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n-extern void m32r_init ();\n-\n #define OVERRIDE_OPTIONS \\\n do {\t\t\t\t\\\n   /* These need to be done at start up.  It's convenient to do them here.  */ \\\n@@ -404,7 +412,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n #define FIRST_PSEUDO_REGISTER 18\n-\n+\t\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n@@ -420,13 +428,15 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    16    - arg pointer\n    17    - carry flag\n \n+   \n    By default, the extension registers are not available.  */\n \n #define FIXED_REGISTERS \\\n { 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 1,\t\\\n   1, 0 }\n \n+\n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n@@ -439,6 +449,7 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   0, 0, 0, 0, 0, 0, 1, 1,\t\\\n   1, 1 }\n \n+\n /* Zero or more C statements that may conditionally modify two variables\n    `fixed_regs' and `call_used_regs' (both of type `char []') after they\n    have been initialized from the two preceding macros.\n@@ -531,11 +542,12 @@ enum reg_class {\n #define REG_CLASS_CONTENTS \\\n { {0}, {0x20000}, {0x1ffff}, {0x3ffff} }\n \n+\n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n-extern enum reg_class m32r_regno_reg_class[];\n+extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) \\\n (m32r_regno_reg_class[REGNO])\n \n@@ -622,14 +634,20 @@ extern enum reg_class m32r_regno_reg_class[];\n    C.  If C is not defined as an extra constraint, the value returned should\n    be 0 regardless of VALUE.  */\n /* Q is for symbolic addresses loadable with ld24.\n-   R is for symbolic addresses when ld24 can't be used.  */\n+   R is for symbolic addresses when ld24 can't be used.\n+   S is for an 8 bit signed integer in the range +128 to -127 */\n+\n+#define INVERTED_SIGNED_8BIT(VAL) ((VAL) >= -127 && (VAL) <= 128)\n+\n #define EXTRA_CONSTRAINT(VALUE, C) \\\n ((C) == 'Q' \\\n  ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF) \\\n     || addr24_operand (VALUE, VOIDmode)) \\\n  : (C) == 'R' \\\n  ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF) \\\n     || addr32_operand (VALUE, VOIDmode)) \\\n+ : (C) == 'S' \\\n+ ?  ((GET_CODE (VALUE) == CONST_INT) && INVERTED_SIGNED_8BIT (INTVAL (VALUE))) \\\n  : 0)\n \f\n /* Stack layout and stack pointer usage.  */\n@@ -717,6 +735,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n #define CARRY_REGNUM 17\n #define M32R_MAX_INT_REGS 16\n \n+     \n #define GPR_P(REGNO) ((unsigned) (REGNO) < M32R_MAX_INT_REGS)\n \f\n /* Eliminating the frame and arg pointers.  */\n@@ -907,7 +926,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    compiler when this occurs, and how many of the words should go in\n    registers.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED)\n+  function_arg_partial_nregs (&CUM, (int)MODE, TYPE, NAMED)\n \n /* A C expression that indicates when an argument must be passed by\n    reference.  If nonzero for an argument, a copy of that argument is\n@@ -1218,9 +1237,8 @@ do {\t\t\t\t\t\\\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  */\n-extern enum machine_mode m32r_select_cc_mode ();\n #define SELECT_CC_MODE(OP, X, Y) \\\n-m32r_select_cc_mode (OP, X, Y)\n+((enum machine_mode)m32r_select_cc_mode ((int)OP, X, Y))\n \n /* Return non-zero if SELECT_CC_MODE will never return MODE for a\n    floating point inequality comparison.  */\n@@ -1313,6 +1331,38 @@ m32r_select_cc_mode (OP, X, Y)\n    the improvement wasn't significant and in a couple of cases caused a\n    significant de-optimization.  */\n /* #define ENABLE_REGMOVE_PASS */\n+\n+/* A C statement (sans semicolon) to update the integer variable COST based on\n+   the relationship between INSN that is dependent on DEP_INSN through the\n+   dependence LINK.  The default is to make no adjustment to COST.  This can be\n+   used for example to specify to the scheduler that an output- or\n+   anti-dependence does not incur the same cost as a data-dependence.  */\n+\n+/* #define ADJUST_COST(INSN,LINK,DEP_INSN,COST)\t\t\t\t\\\n+  (COST) = m32r_adjust_cost (INSN, LINK, DEP_INSN, COST) */\n+\n+/* A C statement (sans semicolon) to update the integer scheduling\n+   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n+   the INSN earlier, increase the priority to execute INSN later.\n+   Do not define this macro if you do not need to adjust the\n+   scheduling priorities of insns.  */\n+/* #define ADJUST_PRIORITY (INSN) */\n+\n+/* Macro to determine whether the Haifa scheduler is used.  */\n+#ifdef HAIFA\n+#define HAIFA_P 1\n+#else\n+#define HAIFA_P 0\n+#endif\n+\n+/* Indicate how many instructions can be issued at the same time.  */\n+#define ISSUE_RATE 2\n+\n+/* When the `length' insn attribute is used, this macro specifies the\n+   value to be assigned to the address of the first insn in a\n+   function.  If not specified, 0 is used.  */\n+#define FIRST_INSN_ADDRESS m32r_first_insn_address ()\n+\n \f\n /* Section selection.  */\n \n@@ -1344,7 +1394,7 @@ DTORS_SECTION_FUNCTION \\\n SDATA_SECTION_FUNCTION \\\n SBSS_SECTION_FUNCTION\n \n-#define SDATA_SECTION_FUNCTION \\\n+#define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n sdata_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1355,7 +1405,7 @@ sdata_section ()\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \n-#define SBSS_SECTION_FUNCTION \\\n+#define SBSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n sbss_section ()\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1429,7 +1479,6 @@ extern void m32r_select_section ();\n  || MEDIUM_NAME_P (SYMBOL_NAME) \\\n  || LARGE_NAME_P (SYMBOL_NAME))\n \n-extern void m32r_encode_section_info ();\n #define ENCODE_SECTION_INFO(DECL) m32r_encode_section_info (DECL)\n \n /* Decode SYM_NAME and store the real name part in VAR, sans\n@@ -1487,7 +1536,6 @@ do {\t\t\t\t\t\t\t\\\n /* Control the assembler format that we output.  */\n \n /* Output at beginning of assembler file.  */\n-extern void m32r_asm_file_start ();\n #define ASM_FILE_START(FILE) m32r_asm_file_start (FILE)\n \n /* A C string constant describing how to begin a comment in the target\n@@ -1582,7 +1630,7 @@ do {\t\t\t\t\\\n #undef ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n do {\t\t\t\t\t\t\t\\\n-  char *real_name;\t\t\t\t\t\\\n+  char * real_name;\t\t\t\t\t\\\n   STRIP_NAME_ENCODING (real_name, (NAME));\t\t\\\n   fprintf (FILE, \"%s%s\", USER_LABEL_PREFIX, real_name);\t\\\n } while (0)           \n@@ -1713,8 +1761,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    handling the required alignment of the variable.  The alignment is\n    specified as the number of bits.  */\n \n-extern void sbss_section ();\n-\n #undef ASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -1833,35 +1879,146 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n-extern int m32r_valid_machine_attribute ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n m32r_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n /* A C expression that returns zero if the attributes on TYPE1 and TYPE2 are\n    incompatible, one if they are compatible, and two if they are\n    nearly compatible (which causes a warning to be generated).  */\n-extern int m32r_comp_type_attributes ();\n #define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n m32r_comp_type_attributes (TYPE1, TYPE2)\n \n /* Give newly defined TYPE some default attributes.  */\n-extern void m32r_set_default_type_attributes ();\n #define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n m32r_set_default_type_attributes (TYPE)\n \f\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n-extern struct rtx_def *m32r_compare_op0, *m32r_compare_op1;\n-\n-/* Define the function that build the compare insn for scc and bcc.  */\n-extern struct rtx_def *gen_compare ();\n+extern struct rtx_def * m32r_compare_op0;\n+extern struct rtx_def * m32r_compare_op1;\n \n /* M32R function types.   */\n-enum m32r_function_type {\n+enum m32r_function_type\n+{\n   M32R_FUNCTION_UNKNOWN, M32R_FUNCTION_NORMAL, M32R_FUNCTION_INTERRUPT\n };\n #define M32R_INTERRUPT_P(TYPE) \\\n ((TYPE) == M32R_FUNCTION_INTERRUPT)\n-/* Compute the type of a function from its DECL.  */\n-enum m32r_function_type m32r_compute_function_type ();\n+\n+/* Define this if you have defined special-purpose predicates in the\n+   file `MACHINE.c'.  This macro is called within an initializer of an\n+   array of structures.  The first field in the structure is the name\n+   of a predicate and the second field is an array of rtl codes.  For\n+   each predicate, list all rtl codes that can be in expressions\n+   matched by the predicate.  The list should have a trailing comma.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+{ \"conditional_move_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"carry_compare_operand\",\t{ EQ, NE }},\t\t\t\t\\\n+{ \"eqne_comparison_operator\",\t{ EQ, NE }},\t\t\t\t\\\n+{ \"signed_comparison_operator\", { EQ, NE, LT, LE, GT, GE }},\t\t\\\n+{ \"move_dest_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n+{ \"move_src_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT,\t\t\\\n+\t\t\t\t  CONST_DOUBLE, LABEL_REF, CONST,\t\\\n+\t\t\t\t  SYMBOL_REF }},\t\t\t\\\n+{ \"move_double_src_operand\",\t{ REG, SUBREG, MEM, CONST_INT,\t\t\\\n+\t\t\t\t  CONST_DOUBLE }},\t\t\t\\\n+{ \"two_insn_const_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+{ \"symbolic_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n+{ \"reg_or_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"reg_or_uint16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"reg_or_cmp_int16_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"reg_or_zero_operand\",\t{ REG, SUBREG, CONST_INT }},\t\t\\\n+{ \"cmp_int16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n+{ \"call_address_operand\",\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n+{ \"small_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n+{ \"large_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\n+\n+/* Functions declared in m32r.c */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+#ifdef BUFSIZE\t\t/* stdio.h has been included, ok to use FILE * */\n+#define STDIO_PROTO(ARGS) PROTO(ARGS)\n+#else\n+#define STDIO_PROTO(ARGS) ()\n+#endif\n+\n+#ifndef TREE_CODE\n+union tree_node;\n+#define Tree union tree_node *\n+#else\n+#define Tree tree\n+#endif\n+\n+#ifndef RTX_CODE\n+struct rtx_def;\n+#define Rtx struct rtx_def *\n+#else\n+#define Rtx rtx\n+#endif\n+\n+extern void sbss_section\t\t\tPROTO((void));\n+extern void sdata_section\t\t\tPROTO((void));\n+extern void m32r_init\t\t\t\tPROTO((void));\n+extern int  m32r_valid_machine_decl_attribute\tPROTO((Tree, Tree, Tree, Tree));\n+extern int  m32r_comp_type_attributes\t\tPROTO((Tree, Tree));\n+extern void m32r_select_section\t\t\tPROTO((Tree, int));\n+extern void m32r_encode_section_info\t\tPROTO((Tree));\n+extern void m32r_init_expanders\t\t\tPROTO((void));\n+extern int  call_address_operand\t\tPROTO((Rtx, int));\n+extern int  call_operand\t\t\tPROTO((Rtx, int));\n+extern int  symbolic_operand\t\t\tPROTO((Rtx, int));\n+extern int  small_data_operand\t\t\tPROTO((Rtx, int));\n+extern int  addr24_operand\t\t\tPROTO((Rtx, int));\n+extern int  addr32_operand\t\t\tPROTO((Rtx, int));\n+extern int  call26_operand\t\t\tPROTO((Rtx, int));\n+extern int  seth_add3_operand\t\t\tPROTO((Rtx, int));\n+extern int  cmp_int16_operand\t\t\tPROTO((Rtx, int));\n+extern int  uint16_operand\t\t\tPROTO((Rtx, int));\n+extern int  reg_or_int16_operand\t\tPROTO((Rtx, int));\n+extern int  reg_or_uint16_operand\t\tPROTO((Rtx, int));\n+extern int  reg_or_cmp_nt16_operand\t\tPROTO((Rtx, int));\n+extern int  two_insn_const_operand\t\tPROTO((Rtx, int));\n+extern int  move_src_operand\t\t\tPROTO((Rtx, int));\n+extern int  move_double_src_operand\t\tPROTO((Rtx, int));\n+extern int  move_dest_operand\t\t\tPROTO((Rtx, int));\n+extern int  easy_di_const\t\t\tPROTO((Rtx));\n+extern int  easy_df_const\t\t\tPROTO((Rtx));\n+extern int  eqne_comparison_operator\t\tPROTO((Rtx, int));\n+extern int  signed_comparison_operator\t\tPROTO((Rtx, int));\n+extern int  memreg_operand\t\t\tPROTO((Rtx, int));\n+extern int  small_insn_p\t\t\tPROTO((Rtx, int));\n+extern int  large_insn_p\t\t\tPROTO((Rtx, int));\n+extern int  m32r_select_cc_mode\t\t\tPROTO((int, Rtx, Rtx));\n+extern Rtx  gen_compare\t\t\t\tPROTO((int, Rtx, Rtx, int));\n+extern int  function_arg_partial_nregs\t\tPROTO((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t       int, Tree, int));\n+extern void m32r_setup_incoming_varargs\t\tPROTO((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t       int, Tree, int *,\n+\t\t\t\t\t\t       int));\n+extern int  m32r_address_code\t\t\tPROTO((Rtx));\n+extern enum m32r_function_type m32r_compute_function_type\n+\t\t\t\t\t\tPROTO((Tree));\n+extern unsigned m32r_compute_frame_size\t\tPROTO((int));\n+extern int  m32r_first_insn_address\t\tPROTO((void));\n+extern void m32r_output_function_prologue\tSTDIO_PROTO((FILE *, int));\n+extern void m32r_output_function_epilogue\tSTDIO_PROTO((FILE *, int));\n+extern void m32r_finalize_pic\t\t\tPROTO((void));\n+extern void m32r_initialize_trampoline\t\tPROTO((Rtx, Rtx, Rtx));\n+extern void m32r_asm_file_start\t\t\tSTDIO_PROTO((FILE *));\n+extern void m32r_print_operand\t\t\tSTDIO_PROTO((FILE *, Rtx, int));\n+extern void m32r_print_operand_address\t\tSTDIO_PROTO((FILE *, Rtx));\n+extern int  zero_and_one\t\t\tPROTO((Rtx, Rtx));\n+extern int  conditional_move_operand\t\tPROTO((Rtx, int));\n+extern int  carry_compare_operand\t\tPROTO((Rtx, int));\n+extern char *emit_cond_move\t\t\tPROTO((Rtx *, Rtx));\n+\n+/* Needed by a peephole optimisation.  */\n+#define PRESERVE_DEATH_INFO_REGNO_P(regno) (regno < FIRST_PSEUDO_REGISTER)"}, {"sha": "49f71d6eddadc55bacca6c7852c79884d328f2b6", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 271, "deletions": 34, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description of the Mitsubishi M32R cpu for GNU C compiler\n-;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n \n@@ -65,11 +65,135 @@\n (define_asm_attributes\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"multi\")])\n+\n+\n+;; Whether an instruction is 16-bit or 32-bit\n+(define_attr \"insn_size\" \"short,long\"\n+  (if_then_else (eq_attr \"length\" \"2\")\n+\t\t(const_string \"short\")\n+\t\t(const_string \"long\")))\n+\n+(define_attr \"m32r\" \"no,yes\"\n+  (const (symbol_ref \"(TARGET_M32R != 0)\")))\n+\n+\n+\n \f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Function Units\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; On most RISC machines, there are instructions whose results are not\n+;; available for a specific number of cycles.  Common cases are instructions\n+;; that load data from memory.  On many machines, a pipeline stall will result\n+;; if the data is referenced too soon after the load instruction.\n+\n+;; In addition, many newer microprocessors have multiple function units,\n+;; usually one for integer and one for floating point, and often will incur\n+;; pipeline stalls when a result that is needed is not yet ready.\n+\n+;; The descriptions in this section allow the specification of how much time\n+;; must elapse between the execution of an instruction and the time when its\n+;; result is used.  It also allows specification of when the execution of an\n+;; instruction will delay execution of similar instructions due to function\n+;; unit conflicts.\n+\n+;; For the purposes of the specifications in this section, a machine is divided\n+;; into \"function units\", each of which execute a specific class of\n+;; instructions in first-in-first-out order.  Function units that accept one\n+;; instruction each cycle and allow a result to be used in the succeeding\n+;; instruction (usually via forwarding) need not be specified.  Classic RISC\n+;; microprocessors will normally have a single function unit, which we can call\n+;; `memory'.  The newer \"superscalar\" processors will often have function units\n+;; for floating point operations, usually at least a floating point adder and\n+;; multiplier.\n+\n+;; Each usage of a function units by a class of insns is specified with a\n+;; `define_function_unit' expression, which looks like this:\n+\n+;; (define_function_unit NAME MULTIPLICITY SIMULTANEITY TEST READY-DELAY\n+;;   ISSUE-DELAY [CONFLICT-LIST])\n+\n+;; NAME is a string giving the name of the function unit.\n+\n+;; MULTIPLICITY is an integer specifying the number of identical units in the\n+;; processor.  If more than one unit is specified, they will be scheduled\n+;; independently.  Only truly independent units should be counted; a pipelined\n+;; unit should be specified as a single unit.  (The only common example of a\n+;; machine that has multiple function units for a single instruction class that\n+;; are truly independent and not pipelined are the two multiply and two\n+;; increment units of the CDC 6600.)\n+\n+;; SIMULTANEITY specifies the maximum number of insns that can be executing in\n+;; each instance of the function unit simultaneously or zero if the unit is\n+;; pipelined and has no limit.\n+\n+;; All `define_function_unit' definitions referring to function unit NAME must\n+;; have the same name and values for MULTIPLICITY and SIMULTANEITY.\n+\n+;; TEST is an attribute test that selects the insns we are describing in this\n+;; definition.  Note that an insn may use more than one function unit and a\n+;; function unit may be specified in more than one `define_function_unit'.\n+\n+;; READY-DELAY is an integer that specifies the number of cycles after which\n+;; the result of the instruction can be used without introducing any stalls.\n+\n+;; ISSUE-DELAY is an integer that specifies the number of cycles after the\n+;; instruction matching the TEST expression begins using this unit until a\n+;; subsequent instruction can begin.  A cost of N indicates an N-1 cycle delay.\n+;; A subsequent instruction may also be delayed if an earlier instruction has a\n+;; longer READY-DELAY value.  This blocking effect is computed using the\n+;; SIMULTANEITY, READY-DELAY, ISSUE-DELAY, and CONFLICT-LIST terms.  For a\n+;; normal non-pipelined function unit, SIMULTANEITY is one, the unit is taken\n+;; to block for the READY-DELAY cycles of the executing insn, and smaller\n+;; values of ISSUE-DELAY are ignored.\n+\n+;; CONFLICT-LIST is an optional list giving detailed conflict costs for this\n+;; unit.  If specified, it is a list of condition test expressions to be\n+;; applied to insns chosen to execute in NAME following the particular insn\n+;; matching TEST that is already executing in NAME.  For each insn in the list,\n+;; ISSUE-DELAY specifies the conflict cost; for insns not in the list, the cost\n+;; is zero.  If not specified, CONFLICT-LIST defaults to all instructions that\n+;; use the function unit.\n+\n+;; Typical uses of this vector are where a floating point function unit can\n+;; pipeline either single- or double-precision operations, but not both, or\n+;; where a memory unit can pipeline loads, but not stores, etc.\n+\n+;; As an example, consider a classic RISC machine where the result of a load\n+;; instruction is not available for two cycles (a single \"delay\" instruction is\n+;; required) and where only one load instruction can be executed\n+;; simultaneously.  This would be specified as:\n+\n+;; (define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n+\n+;; For the case of a floating point function unit that can pipeline\n+;; either single or double precision, but not both, the following could be\n+;; specified:\n+;;\n+;; (define_function_unit \"fp\" 1 0\n+;;   (eq_attr \"type\" \"sp_fp\") 4 4\n+;;   [(eq_attr \"type\" \"dp_fp\")])\n+;;\n+;; (define_function_unit \"fp\" 1 0\n+;;   (eq_attr \"type\" \"dp_fp\") 4 4\n+;;   [(eq_attr \"type\" \"sp_fp\")])\n+\n+;; Note: The scheduler attempts to avoid function unit conflicts and uses all\n+;; the specifications in the `define_function_unit' expression.  It has\n+;; recently come to our attention that these specifications may not allow\n+;; modeling of some of the newer \"superscalar\" processors that have insns using\n+;; multiple pipelined units.  These insns will cause a potential conflict for\n+;; the second unit used during their execution and there is no way of\n+;; representing that conflict.  We welcome any examples of how function unit\n+;; conflicts work in such processors and suggestions for their representation.\n+\n ;; Function units of the M32R\n ;; Units that take one cycle do not need to be specified.\n \n-;; (define_function_unit {name} {num-units} {n-users} {test}\n+;; (define_function_unit {name} {multiplicity} {simulataneity} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \n ;; References to loaded registers should wait a cycle.\n@@ -94,6 +218,7 @@\n   (not (eq_attr \"length\" \"2\"))\n   1 0\n   [(eq_attr \"length\" \"2\")])\n+\n \f\n ;; Expand prologue as RTL\n ;; ??? Unfinished.\n@@ -915,6 +1040,7 @@\n   DONE;\n }\")\n \n+\n ;; The cmp_xxx_insn patterns set the condition bit to the result of the\n ;; comparison.  There isn't a \"compare equal\" instruction so cmp_eqsi_insn\n ;; is quite inefficient.  However, it is rarely used.\n@@ -924,10 +1050,23 @@\n \t(eq:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t       (match_operand:SI 1 \"reg_or_cmp_int16_operand\" \"r,P\")))\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n-  \"TARGET_OLD_COMPARE\"\n-  \"@\n-   mv %2,%0\\;sub %2,%1\\;cmpui %2,#1\n-   add3 %2,%0,%#%N1\\;cmpui %2,#1\"\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+         return \\\"mv %2,%0\\;sub %2,%1\\;cmpui %2,#1\\\";\n+    }\n+  else\n+    {\n+        if (INTVAL (operands [1]) == 0)\n+          return \\\"cmpui %0, #1\\\";\n+        else if (REGNO (operands [2]) == REGNO (operands [0]))\n+          return \\\"addi %0,%#%N1\\;cmpui %2,#1\\\";\n+        else\n+          return \\\"add3 %2,%0,%#%N1\\;cmpui %2,#1\\\";\n+    }\n+}\"\n   [(set_attr \"type\" \"compare,compare\")\n    (set_attr \"length\" \"8,8\")])\n \n@@ -939,31 +1078,39 @@\n   \"@\n    cmp %0,%1\n    cmpi %0,%#%1\"\n-  [(set_attr \"type\" \"compare\")])\n+  [(set_attr \"type\" \"compare,compare\")\n+   (set_attr \"length\" \"4,6\")])\n \n (define_insn \"cmp_ltusi_insn\"\n   [(set (reg:CC 17)\n \t(ltu:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t        (match_operand:SI 1 \"reg_or_uint16_operand\" \"r,K\")))]\n   \"\"\n-  \"@\n-   cmpu %0,%1\n-   cmpui %0,%#%1\"\n-  [(set_attr \"type\" \"compare\")])\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"cmpu %0,%1\\\";\n+  else\n+   return \\\"cmpui %0,%#%1\\\";\n+}\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"length\" \"4,6\")])\n \n ;; reg == small constant comparisons are best handled by putting the result\n ;; of the comparison in a tmp reg and then using beqz/bnez.\n ;; ??? The result register doesn't contain 0/STORE_FLAG_VALUE,\n ;; it contains 0/non-zero.\n \n (define_insn \"cmp_ne_small_const_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t       (match_operand:SI 2 \"cmp_int16_operand\" \"P\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ne:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n+\t       (match_operand:SI 2 \"cmp_int16_operand\" \"S,P\")))]\n   \"\"\n-  \"add3 %0,%1,%#%N2\"\n+  \"@\n+   addi %0,%#%N2\n+   add3 %0,%1,%#%N2\"\n   [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4\")])\n+   (set_attr \"length\" \"2,4\")])\n \f\n ;; These control RTL generation for conditional jump insns.\n \n@@ -975,7 +1122,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (EQ, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)EQ, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bne\"\n@@ -986,7 +1133,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (NE, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)NE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgt\"\n@@ -997,7 +1144,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (GT, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)GT, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"ble\"\n@@ -1008,7 +1155,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (LE, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)LE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bge\"\n@@ -1019,7 +1166,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (GE, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)GE, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"blt\"\n@@ -1030,7 +1177,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (LT, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)LT, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgtu\"\n@@ -1041,7 +1188,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (GTU, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)GTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bleu\"\n@@ -1052,7 +1199,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (LEU, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)LEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bgeu\"\n@@ -1063,7 +1210,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (GEU, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)GEU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n (define_expand \"bltu\"\n@@ -1074,7 +1221,7 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_compare (LTU, m32r_compare_op0, m32r_compare_op1);\n+  operands[1] = gen_compare ((int)LTU, m32r_compare_op0, m32r_compare_op1, FALSE);\n }\")\n \n ;; Now match both normal and inverted jump.\n@@ -1088,10 +1235,11 @@\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[1]) == NE)\n-    return \\\"bc %l0\\\";\n-  else\n-    return \\\"bnc %l0\\\";\n+  static char instruction[40];\n+  sprintf (instruction, \\\"%s%s %%l0\\\",\n+\t   (GET_CODE (operands[1]) == NE) ? \\\"bc\\\" : \\\"bnc\\\",\n+\t   (get_attr_length (insn) == 2) ? \\\".s\\\" : \\\"\\\");\n+  return instruction;\n }\"\n   [(set_attr \"type\" \"branch\")\n    ; We use 400/800 instead of 512,1024 to account for inaccurate insn\n@@ -1116,10 +1264,11 @@\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[1]) == EQ)\n-    return \\\"bc %l0\\\";\n-  else\n-    return \\\"bnc %l0\\\";\n+  static char instruction[40];\n+  sprintf (instruction, \\\"%s%s %%l0\\\",\n+\t   (GET_CODE (operands[1]) == EQ) ? \\\"bc\\\" : \\\"bnc\\\",\n+\t   (get_attr_length (insn) == 2) ? \\\".s\\\" : \\\"\\\");\n+  return instruction;\n }\"\n   [(set_attr \"type\" \"branch\")\n    ; We use 400/800 instead of 512,1024 to account for inaccurate insn\n@@ -1451,6 +1600,51 @@\n   \"\"\n   \"* return \\\"nop ; flush-icache\\\";\"\n   [(set_attr \"type\" \"misc\")])\n+\f\n+;; Conditional move instructions\n+;; Based on those done for the d10v\n+\n+\n+(define_expand \"movsicc\"\n+  [\n+   (set (match_operand:SI 0 \"register_operand\" \"r\")\n+\t(if_then_else:SI (match_operand 1 \"\" \"\")\n+\t\t\t (match_operand:SI 2 \"conditional_move_operand\" \"O\")\n+\t\t\t (match_operand:SI 3 \"conditional_move_operand\" \"O\")\n+        )\n+   )\n+  ]\n+  \"\"\n+  \"\n+{\n+  if (! zero_and_one (operands [2], operands [3]))\n+    FAIL;\n+\n+  /* Generate the comparision that will set the carry flag.  */\n+  operands[1] = gen_compare ((int)GET_CODE (operands[1]), m32r_compare_op0,\n+\t\t\t     m32r_compare_op1, TRUE);\n+\n+  /* See other movsicc pattern below for reason why.  */\n+  emit_insn (gen_blockage());\n+}\")\n+\n+;; Generate the conditional instructions based on how the carry flag is examined.\n+(define_insn \"*movsicc_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+\t(if_then_else:SI (match_operand 1 \"carry_compare_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"conditional_move_operand\" \"O\")\n+\t\t\t (match_operand:SI 3 \"conditional_move_operand\" \"O\")\n+        )\n+   )]\n+  \"zero_and_one (operands [2], operands[3])\"\n+  \"* return emit_cond_move (operands, insn);\"\n+  [(set_attr \"type\"   \"move\")\n+   (set_attr \"length\" \"8\")\n+  ]\n+)\n+\n+\n+\n \f\n ;; Split up troublesome insns for better scheduling.\n \f\n@@ -1467,3 +1661,46 @@\n   \"st %1,@+%0\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n+\n+;; This case is triggered by compiling this code:\n+;; \n+;; extern void sub(int *);\n+;; void main (void)\n+;; {\n+;;   int i=2,j=3,k;\n+;;   while (i < j)  sub(&k);\n+;;   i = j / k;\n+;;   sub(&i);\n+;;   i = j - k;\n+;;   sub(&i);\n+;; }\n+;;\n+;; Without the peephole the following assembler is generated for the\n+;; divide and subtract expressions:\n+;;\n+;;         div r5,r4     \n+;;         mv r4,r5      \n+;;         st r4,@(4,sp) \n+;;         bl sub\n+;; \n+;; Simialr code is produced for the subtract expression.  With this\n+;; peephole the redundant move is eliminated.\n+;;\n+;; This optimisation onbly works if PRESERVE_DEATH_INFO_REGNO_P is\n+;; defined in m32r.h\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"r\")\n+        (match_operand:SI 1 \"register_operand\" \"r\")\n+   )\n+   (set (mem:SI (plus: SI (match_operand:SI 2 \"register_operand\" \"r\")\n+                (match_operand:SI 3 \"immediate_operand\" \"J\")))\n+        (match_dup 0)\n+   )\n+  ]\n+  \"dead_or_set_p (insn, operands [0])\"\n+  \"st %1,@(%3,%2)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")\n+  ]\n+)"}, {"sha": "3d8da58c1160a8d12afd4a008a64fe6cfb97e799", "filename": "gcc/config/m32r/t-m32r", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Ft-m32r", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfig%2Fm32r%2Ft-m32r", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Ft-m32r?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -39,6 +39,7 @@ crtfini.o: $(srcdir)/config/m32r/initfini.c $(GCC_PASSES) $(CONFIG_H)\n \t  -DCRT_FINI -finhibit-size-directive -fno-inline-functions \\\n \t  -g0 -c $(srcdir)/config/m32r/initfini.c -o crtfini.o\n \n+\n # -mmodel={small,medium} requires separate libraries.\n # We don't build libraries for the large model, instead we use the medium\n # libraries.  The only difference is that the large model can handle jumps\n@@ -48,6 +49,7 @@ MULTILIB_OPTIONS = mmodel=small/mmodel=medium\n MULTILIB_DIRNAMES = small medium\n MULTILIB_MATCHES = mmodel?medium=mmodel?large\n \n+\n # Set MULTILIB_EXTRA_OPTS so shipped libraries have small data in .sdata and\n # SHN_M32R_SCOMMON.\n # This is important for objects referenced in system header files."}, {"sha": "7a4c917b0fbf681f1448b33296d750b8e9244af8", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -4580,7 +4580,7 @@ fi\n if [ x$enable_haifa = x ]\n then\n   case $target in\n-    alpha*-* | hppa1.?-* | powerpc*-* | rs6000-* | *sparc-*)\n+    alpha*-* | hppa1.?-* | powerpc*-* | rs6000-* | *sparc-* | m32r*-*)\n       enable_haifa=yes;;\n   esac\n fi"}, {"sha": "67b7fbd7f14ae6d34ef092ede96d1dfb30785b32", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b7972b093b3ce4087f57891585195c7f6cbeed5/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=2b7972b093b3ce4087f57891585195c7f6cbeed5", "patch": "@@ -2891,7 +2891,7 @@ fi\n if [[ x$enable_haifa = x ]]\n then\n   case $target in\n-    alpha*-* | hppa1.?-* | powerpc*-* | rs6000-* | *sparc-*)\n+    alpha*-* | hppa1.?-* | powerpc*-* | rs6000-* | *sparc-* | m32r*-*)\n       enable_haifa=yes;;\n   esac\n fi"}]}