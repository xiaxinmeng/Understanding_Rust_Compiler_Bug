{"sha": "9d45bec23da3e091f70ec0232302644ef98220de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ0NWJlYzIzZGEzZTA5MWY3MGVjMDIzMjMwMjY0NGVmOTgyMjBkZQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:33Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:33Z"}, "message": "8\nMerge from Cygnus internal source tree.\n\nFrom-SVN: r23020", "tree": {"sha": "2470bbab1640711395966fb0cc7eab26d1d30b1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2470bbab1640711395966fb0cc7eab26d1d30b1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d45bec23da3e091f70ec0232302644ef98220de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d45bec23da3e091f70ec0232302644ef98220de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d45bec23da3e091f70ec0232302644ef98220de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d45bec23da3e091f70ec0232302644ef98220de/comments", "author": null, "committer": null, "parents": [{"sha": "a7303141b4bac74ce70993d41945f74cdf52d237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7303141b4bac74ce70993d41945f74cdf52d237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7303141b4bac74ce70993d41945f74cdf52d237"}], "stats": {"total": 67, "additions": 55, "deletions": 12}, "files": [{"sha": "a5908042e71d3976079a45f2eacf33991e883dea", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d45bec23da3e091f70ec0232302644ef98220de/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d45bec23da3e091f70ec0232302644ef98220de/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=9d45bec23da3e091f70ec0232302644ef98220de", "patch": "@@ -176,13 +176,16 @@ java.install-info:\n \n java.mostlyclean:\n \t-rm -f java/*$(objext) $(DEMANGLER_PROG)\n+# CYGNUS LOCAL - Delete these files here instead of in realclean because they\n+# are now created in the build subdirectories.\n+\t-rm -f java/parse.c java/parse-scan.c java/parse.output java/y.tab.c\n java.clean:\n java.distclean:\n \t-rm -f java/config.status java/Makefile\n \t-rm -f java/parse.output\n java.extraclean:\n java.maintainer-clean:\n-\t-rm -f java/parse.h\n+\n \f\n # Stage hooks:\n # The main makefile has already created stage?/java."}, {"sha": "16dd2340c81d114ba0e6149a38c221ffc634be2d", "filename": "gcc/java/decl.c", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d45bec23da3e091f70ec0232302644ef98220de/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d45bec23da3e091f70ec0232302644ef98220de/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=9d45bec23da3e091f70ec0232302644ef98220de", "patch": "@@ -33,6 +33,10 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"jcf.h\"\n #include \"toplev.h\"\n \n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n /* The DECL_MAP is a mapping from (index, type) to a decl node.\n    If index < max_locals, it is the index of a local variable.\n    if index >= max_locals, then index-max_locals is a stack slot.\n@@ -340,6 +344,7 @@ tree soft_monitorenter_node;\n tree soft_monitorexit_node;\n tree soft_lookupinterfacemethod_node;\n tree soft_fmod_node;\n+tree soft_exceptioninfo_call_node;\n \n /* Build (and pushdecl) a \"promoted type\" for all standard\n    types shorter than int.  */\n@@ -447,7 +452,7 @@ init_decl_processing ()\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned long\"),\n \t\t\tunsigned_long_type_node));\n \n-  integer_type_node = int_type_node;\n+  integer_type_node = type_for_size (INT_TYPE_SIZE, 0);\n \n   integer_zero_node = build_int_2 (0, 0);\n   integer_one_node = build_int_2 (1, 0);\n@@ -593,6 +598,7 @@ init_decl_processing ()\n   PUSH_FIELD (class_type_node, field, \"interface_len\", short_type_node);\n   PUSH_FIELD (class_type_node, field, \"state\", byte_type_node);\n   PUSH_FIELD (class_type_node, field, \"final\", byte_type_node);\n+  PUSH_FIELD (class_type_node, field, \"thread\", ptr_type_node);\n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n@@ -689,7 +695,8 @@ init_decl_processing ()\n \n   t = tree_cons (NULL_TREE, int_type_node,\n \t\t tree_cons (NULL_TREE, class_ptr_type,\n-\t\t\t    build_tree_list (NULL_TREE, object_ptr_type_node)));\n+\t\t\t    build_tree_list (NULL_TREE, \n+\t\t\t\t\t     object_ptr_type_node)));\n   soft_anewarray_node\n       = builtin_function (\"_Jv_NewObjectArray\",\n \t\t\t  build_function_type (ptr_type_node, t),\n@@ -702,9 +709,11 @@ init_decl_processing ()\n \t\t\t  build_function_type (ptr_type_node, t),\n \t\t\t  NOT_BUILT_IN, NULL_PTR );\n \n-  t = build_function_type (void_type_node, NULL_TREE);\n+  t = build_function_type (void_type_node, \n+\t\t\t   build_tree_list (NULL_TREE, int_type_node));\n   soft_badarrayindex_node\n-      = builtin_function (\"_Jv_ThrowBadArrayIndex\", t, NOT_BUILT_IN, NULL_PTR );\n+      = builtin_function (\"_Jv_ThrowBadArrayIndex\", t, \n+\t\t\t  NOT_BUILT_IN, NULL_PTR);\n   TREE_THIS_VOLATILE (soft_badarrayindex_node) = 1;\n   TREE_SIDE_EFFECTS (soft_badarrayindex_node) = 1;\n \n@@ -731,14 +740,25 @@ init_decl_processing ()\n \t\t\t    build_tree_list (NULL_TREE, ptr_type_node)));\n   soft_lookupinterfacemethod_node \n     = builtin_function (\"_Jv_LookupInterfaceMethod\",\n-\t\t\tbuild_function_type(ptr_type_node, t),\n+\t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   t = tree_cons (NULL_TREE, double_type_node,\n \t\t build_tree_list (NULL_TREE, double_type_node));\n   soft_fmod_node\n     = builtin_function (\"__builtin_fmod\",\n \t\t\tbuild_function_type (double_type_node, t),\n \t\t\tBUILT_IN_FMOD, \"fmod\");\n+\n+  t = build_tree_list (NULL_TREE, void_type_node);\n+  soft_exceptioninfo_call_node\n+    = build (CALL_EXPR, \n+\t     ptr_type_node,\n+\t     build_address_of \n+\t       (builtin_function (\"_Jv_exception_info\", \n+\t\t\t\t  build_function_type (ptr_type_node, t),\n+\t\t\t\t  NOT_BUILT_IN, NULL_PTR)),\n+\t     NULL_TREE, NULL_TREE);\n+  TREE_SIDE_EFFECTS (soft_exceptioninfo_call_node) = 1;\n #if 0\n   t = tree_cons (NULL_TREE, float_type_node,\n \t\t build_tree_list (NULL_TREE, float_type_node));\n@@ -1364,7 +1384,7 @@ give_name_to_locals (jcf)\n       int signature_index = JCF_readu2 (jcf);\n       int slot = JCF_readu2 (jcf);\n       tree name = get_name_constant (jcf, name_index);\n-      tree type = promote_type (parse_signature (jcf, signature_index));\n+      tree type = parse_signature (jcf, signature_index);\n       if (slot < DECL_ARG_SLOT_COUNT (current_function_decl)\n \t  && start_pc == 0\n \t  && length == DECL_CODE_LENGTH (current_function_decl))\n@@ -1433,9 +1453,12 @@ void\n complete_start_java_method (fndecl)\n   tree fndecl;\n {\n-\n-  DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE,\n-\t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)));\n+  tree restype = TREE_TYPE (TREE_TYPE (fndecl));\n+  /* To be compatible with C_PROMOTING_INTEGER_TYPE_P in cc1/cc1plus. */\n+  if (INTEGRAL_TYPE_P (restype)\n+      && TYPE_PRECISION (restype) < TYPE_PRECISION (integer_type_node))\n+    restype = integer_type_node;\n+  DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype);\n \n   if (! flag_emit_class_files)\n     {\n@@ -1458,6 +1481,17 @@ complete_start_java_method (fndecl)\n \n #endif\n \n+  if (METHOD_STATIC (fndecl) && ! METHOD_PRIVATE (fndecl))\n+    {\n+      tree clas = DECL_CONTEXT (fndecl);\n+      tree init = build (CALL_EXPR, void_type_node,\n+\t\t\t build_address_of (soft_initclass_node),\n+\t\t\t build_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\t\t NULL_TREE);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+      expand_expr_stmt (init);\n+    }\n+\n   if (METHOD_SYNCHRONIZED (fndecl))\n     {\n       /* FIXME: surround the function body by a try/finally set.  */\n@@ -1496,12 +1530,18 @@ start_java_method (fndecl)\n        tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)\n     {\n       tree parm_name = NULL_TREE, parm_decl;\n+      tree parm_type = TREE_VALUE (tem);\n       if (i >= DECL_MAX_LOCALS(fndecl))\n \tfatal (\"function has more parameters than local slots\");\n \n-      parm_decl = build_decl (PARM_DECL, parm_name, TREE_VALUE (tem));\n+      parm_decl = build_decl (PARM_DECL, parm_name, parm_type);\n       DECL_CONTEXT (parm_decl) = fndecl;\n-      DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n+#ifdef PROMOTE_PROTOTYPES\n+      if (TYPE_PRECISION (parm_type) < TYPE_PRECISION (integer_type_node)\n+\t  && INTEGRAL_TYPE_P (parm_type))\n+\tparm_type = integer_type_node;\n+#endif\n+      DECL_ARG_TYPE (parm_decl) = parm_type;\n \n       *ptr = parm_decl;\n       ptr = &TREE_CHAIN (parm_decl);"}]}