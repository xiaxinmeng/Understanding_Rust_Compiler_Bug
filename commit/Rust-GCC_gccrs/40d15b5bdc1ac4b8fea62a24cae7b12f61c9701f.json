{"sha": "40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBkMTViNWJkYzFhYzRiOGZlYTYyYTI0Y2FlN2IxMmY2MWM5NzAxZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2012-10-10T19:59:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-10T19:59:00Z"}, "message": "elf.c: Rename all Elf typedefs to start with b_elf, and be all lower case.\n\n\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n\tlower case.\n\nFrom-SVN: r192331", "tree": {"sha": "1b6845c786a798e3c612c77589264e9e299bbde6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b6845c786a798e3c612c77589264e9e299bbde6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f/comments", "author": null, "committer": null, "parents": [{"sha": "374b86e2101f431c12262ec7ce49987818925777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374b86e2101f431c12262ec7ce49987818925777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/374b86e2101f431c12262ec7ce49987818925777"}], "stats": {"total": 127, "additions": 66, "deletions": 61}, "files": [{"sha": "5052cf436e3b610b097f322d711e63437906a823", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "patch": "@@ -1,3 +1,8 @@\n+2012-10-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n+\tlower case.\n+\n 2012-10-10  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* elf.c (elf_add_syminfo_data): Add casts to avoid warning."}, {"sha": "b396c47ef294ccc01d8aee5b7f31efad803a0651", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=40d15b5bdc1ac4b8fea62a24cae7b12f61c9701f", "patch": "@@ -105,25 +105,25 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n \n /* Basic types.  */\n \n-typedef uint16_t Elf_Half;\n-typedef uint32_t Elf_Word;\n-typedef int32_t  Elf_Sword;\n+typedef uint16_t b_elf_half;    /* Elf_Half.  */\n+typedef uint32_t b_elf_word;    /* Elf_Word.  */\n+typedef int32_t  b_elf_sword;   /* Elf_Sword.  */\n \n #if BACKTRACE_ELF_SIZE == 32\n \n-typedef uint32_t Elf_Addr;\n-typedef uint32_t Elf_Off;\n+typedef uint32_t b_elf_addr;    /* Elf_Addr.  */\n+typedef uint32_t b_elf_off;     /* Elf_Off.  */\n \n-typedef uint32_t Elf_WXword;\n+typedef uint32_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n \n #else\n \n-typedef uint64_t Elf_Addr;\n-typedef uint64_t Elf_Off;\n-typedef uint64_t Elf_Xword;\n-typedef int64_t  Elf_Sxword;\n+typedef uint64_t b_elf_addr;    /* Elf_Addr.  */\n+typedef uint64_t b_elf_off;     /* Elf_Off.  */\n+typedef uint64_t b_elf_xword;   /* Elf_Xword.  */\n+typedef int64_t  b_elf_sxword;  /* Elf_Sxword.  */\n \n-typedef uint64_t Elf_WXword;\n+typedef uint64_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n \n #endif\n \n@@ -133,20 +133,20 @@ typedef uint64_t Elf_WXword;\n \n typedef struct {\n   unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n-  Elf_Half\te_type;\t\t\t/* Identifies object file type */\n-  Elf_Half\te_machine;\t\t/* Specifies required architecture */\n-  Elf_Word\te_version;\t\t/* Identifies object file version */\n-  Elf_Addr\te_entry;\t\t/* Entry point virtual address */\n-  Elf_Off\te_phoff;\t\t/* Program header table file offset */\n-  Elf_Off\te_shoff;\t\t/* Section header table file offset */\n-  Elf_Word\te_flags;\t\t/* Processor-specific flags */\n-  Elf_Half\te_ehsize;\t\t/* ELF header size in bytes */\n-  Elf_Half\te_phentsize;\t\t/* Program header table entry size */\n-  Elf_Half\te_phnum;\t\t/* Program header table entry count */\n-  Elf_Half\te_shentsize;\t\t/* Section header table entry size */\n-  Elf_Half\te_shnum;\t\t/* Section header table entry count */\n-  Elf_Half\te_shstrndx;\t\t/* Section header string table index */\n-} Elf_Ehdr;\n+  b_elf_half\te_type;\t\t\t/* Identifies object file type */\n+  b_elf_half\te_machine;\t\t/* Specifies required architecture */\n+  b_elf_word\te_version;\t\t/* Identifies object file version */\n+  b_elf_addr\te_entry;\t\t/* Entry point virtual address */\n+  b_elf_off\te_phoff;\t\t/* Program header table file offset */\n+  b_elf_off\te_shoff;\t\t/* Section header table file offset */\n+  b_elf_word\te_flags;\t\t/* Processor-specific flags */\n+  b_elf_half\te_ehsize;\t\t/* ELF header size in bytes */\n+  b_elf_half\te_phentsize;\t\t/* Program header table entry size */\n+  b_elf_half\te_phnum;\t\t/* Program header table entry count */\n+  b_elf_half\te_shentsize;\t\t/* Section header table entry size */\n+  b_elf_half\te_shnum;\t\t/* Section header table entry count */\n+  b_elf_half\te_shstrndx;\t\t/* Section header string table index */\n+} b_elf_ehdr;  /* Elf_Ehdr.  */\n \n #define EI_MAG0 0\n #define EI_MAG1 1\n@@ -170,17 +170,17 @@ typedef struct {\n #define EV_CURRENT 1\n \n typedef struct {\n-  Elf_Word\tsh_name;\t\t/* Section name, index in string tbl */\n-  Elf_Word\tsh_type;\t\t/* Type of section */\n-  Elf_WXword\tsh_flags;\t\t/* Miscellaneous section attributes */\n-  Elf_Addr\tsh_addr;\t\t/* Section virtual addr at execution */\n-  Elf_Off\tsh_offset;\t\t/* Section file offset */\n-  Elf_WXword\tsh_size;\t\t/* Size of section in bytes */\n-  Elf_Word\tsh_link;\t\t/* Index of another section */\n-  Elf_Word\tsh_info;\t\t/* Additional section information */\n-  Elf_WXword\tsh_addralign;\t\t/* Section alignment */\n-  Elf_WXword\tsh_entsize;\t\t/* Entry size if section holds table */\n-} Elf_Shdr;\n+  b_elf_word\tsh_name;\t\t/* Section name, index in string tbl */\n+  b_elf_word\tsh_type;\t\t/* Type of section */\n+  b_elf_wxword\tsh_flags;\t\t/* Miscellaneous section attributes */\n+  b_elf_addr\tsh_addr;\t\t/* Section virtual addr at execution */\n+  b_elf_off\tsh_offset;\t\t/* Section file offset */\n+  b_elf_wxword\tsh_size;\t\t/* Size of section in bytes */\n+  b_elf_word\tsh_link;\t\t/* Index of another section */\n+  b_elf_word\tsh_info;\t\t/* Additional section information */\n+  b_elf_wxword\tsh_addralign;\t\t/* Section alignment */\n+  b_elf_wxword\tsh_entsize;\t\t/* Entry size if section holds table */\n+} b_elf_shdr;  /* Elf_Shdr.  */\n \n #define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n #define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n@@ -193,25 +193,25 @@ typedef struct {\n \n typedef struct\n {\n-  Elf_Word\tst_name;\t\t/* Symbol name, index in string tbl */\n-  Elf_Addr\tst_value;\t\t/* Symbol value */\n-  Elf_Word\tst_size;\t\t/* Symbol size */\n+  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  b_elf_addr\tst_value;\t\t/* Symbol value */\n+  b_elf_word\tst_size;\t\t/* Symbol size */\n   unsigned char\tst_info;\t\t/* Symbol binding and type */\n   unsigned char\tst_other;\t\t/* Visibility and other data */\n-  Elf_Half\tst_shndx;\t\t/* Symbol section index */\n-} Elf_Sym;\n+  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n+} b_elf_sym;  /* Elf_Sym.  */\n \n #else /* BACKTRACE_ELF_SIZE != 32 */\n \n typedef struct\n {\n-  Elf_Word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n   unsigned char\tst_info;\t\t/* Symbol binding and type */\n   unsigned char\tst_other;\t\t/* Visibility and other data */\n-  Elf_Half\tst_shndx;\t\t/* Symbol section index */\n-  Elf_Addr\tst_value;\t\t/* Symbol value */\n-  Elf_Xword\tst_size;\t\t/* Symbol size */\n-} Elf_Sym;\n+  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n+  b_elf_addr\tst_value;\t\t/* Symbol value */\n+  b_elf_xword\tst_size;\t\t/* Symbol size */\n+} b_elf_sym;  /* Elf_Sym.  */\n \n #endif /* BACKTRACE_ELF_SIZE != 32 */\n \n@@ -346,17 +346,17 @@ elf_initialize_syminfo (struct backtrace_state *state,\n \t\t\tvoid *data, struct elf_syminfo_data *sdata)\n {\n   size_t sym_count;\n-  const Elf_Sym *sym;\n+  const b_elf_sym *sym;\n   size_t elf_symbol_count;\n   size_t elf_symbol_size;\n   struct elf_symbol *elf_symbols;\n   size_t i;\n   unsigned int j;\n \n-  sym_count = symtab_size / sizeof (Elf_Sym);\n+  sym_count = symtab_size / sizeof (b_elf_sym);\n \n   /* We only care about function symbols.  Count them.  */\n-  sym = (const Elf_Sym *) symtab_data;\n+  sym = (const b_elf_sym *) symtab_data;\n   elf_symbol_count = 0;\n   for (i = 0; i < sym_count; ++i, ++sym)\n     {\n@@ -371,7 +371,7 @@ elf_initialize_syminfo (struct backtrace_state *state,\n   if (elf_symbols == NULL)\n     return 0;\n \n-  sym = (const Elf_Sym *) symtab_data;\n+  sym = (const b_elf_sym *) symtab_data;\n   j = 0;\n   for (i = 0; i < sym_count; ++i, ++sym)\n     {\n@@ -474,14 +474,14 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n \t fileline *fileline_fn, int *found_sym, int *found_dwarf)\n {\n   struct backtrace_view ehdr_view;\n-  Elf_Ehdr ehdr;\n+  b_elf_ehdr ehdr;\n   off_t shoff;\n   unsigned int shnum;\n   unsigned int shstrndx;\n   struct backtrace_view shdrs_view;\n   int shdrs_view_valid;\n-  const Elf_Shdr *shdrs;\n-  const Elf_Shdr *shstrhdr;\n+  const b_elf_shdr *shdrs;\n+  const b_elf_shdr *shstrhdr;\n   size_t shstr_size;\n   off_t shstr_off;\n   struct backtrace_view names_view;\n@@ -558,13 +558,13 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n       && shoff != 0)\n     {\n       struct backtrace_view shdr_view;\n-      const Elf_Shdr *shdr;\n+      const b_elf_shdr *shdr;\n \n       if (!backtrace_get_view (state, descriptor, shoff, sizeof shdr,\n \t\t\t       error_callback, data, &shdr_view))\n \tgoto fail;\n \n-      shdr = (const Elf_Shdr *) shdr_view.data;\n+      shdr = (const b_elf_shdr *) shdr_view.data;\n \n       if (shnum == 0)\n \tshnum = shdr->sh_size;\n@@ -596,12 +596,12 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n \n   /* Read the section headers, skipping the first one.  */\n \n-  if (!backtrace_get_view (state, descriptor, shoff + sizeof (Elf_Shdr),\n-\t\t\t   (shnum - 1) * sizeof (Elf_Shdr),\n+  if (!backtrace_get_view (state, descriptor, shoff + sizeof (b_elf_shdr),\n+\t\t\t   (shnum - 1) * sizeof (b_elf_shdr),\n \t\t\t   error_callback, data, &shdrs_view))\n     goto fail;\n   shdrs_view_valid = 1;\n-  shdrs = (const Elf_Shdr *) shdrs_view.data;\n+  shdrs = (const b_elf_shdr *) shdrs_view.data;\n \n   /* Read the section names.  */\n \n@@ -623,7 +623,7 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n   /* Look for the symbol table.  */\n   for (i = 1; i < shnum; ++i)\n     {\n-      const Elf_Shdr *shdr;\n+      const b_elf_shdr *shdr;\n       unsigned int sh_name;\n       const char *name;\n       int j;\n@@ -659,9 +659,9 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n     symtab_shndx = dynsym_shndx;\n   if (symtab_shndx != 0)\n     {\n-      const Elf_Shdr *symtab_shdr;\n+      const b_elf_shdr *symtab_shdr;\n       unsigned int strtab_shndx;\n-      const Elf_Shdr *strtab_shdr;\n+      const b_elf_shdr *strtab_shdr;\n       struct elf_syminfo_data *sdata;\n \n       symtab_shdr = &shdrs[symtab_shndx - 1];"}]}