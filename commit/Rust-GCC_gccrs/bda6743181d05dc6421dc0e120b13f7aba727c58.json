{"sha": "bda6743181d05dc6421dc0e120b13f7aba727c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRhNjc0MzE4MWQwNWRjNjQyMWRjMGUxMjBiMTNmN2FiYTcyN2M1OA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-09-12T23:53:29Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-09-12T23:53:29Z"}, "message": "c-common.c, [...]: Use %q, %< and %> for quoting in diagnostics.\n\n\t* c-common.c, c-decl.c, c-lex.c, c-objc-common.c, c-opts.c,\n\tc-parse.in, c-pragma.c, c-typeck.c: Use %q, %< and %> for quoting\n\tin diagnostics.  Use %' for English apostrophes.\n\t* c-tree.h (ATTRIBUTE_GCC_CDIAG): Define.\n\t(pedwarn_c90, pedwarn_c99): Use it.\n\t* c-decl.c (lookup_label): Quote label name in diagnostic.\n\t* c-parse.in (yyprint): Use ' instead of ` for left quote.\n\t* c-typeck.c (warn_for_assignment): Likewise.\n\ntestsuite:\n\t* g++.dg/warn/Wswitch-1.C, g++.dg/warn/Wswitch-2.C,\n\tgcc.dg/Wswitch-2.c, gcc.dg/Wswitch-enum.c, gcc.dg/Wswitch.c,\n\tgcc.dg/declspec-9.c, gcc.dg/declspec-10.c, gcc.dg/declspec-11.c,\n\tgcc.dg/m-un-2.c, gcc.dg/noreturn-1.c, gcc.dg/wtr-conversion-1.c:\n\tUpdate expected messages.\n\nFrom-SVN: r87413", "tree": {"sha": "55c81129e5904e9a77beedcea89e8ae836694907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55c81129e5904e9a77beedcea89e8ae836694907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bda6743181d05dc6421dc0e120b13f7aba727c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bda6743181d05dc6421dc0e120b13f7aba727c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bda6743181d05dc6421dc0e120b13f7aba727c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bda6743181d05dc6421dc0e120b13f7aba727c58/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "924479e8e8c53ab678eabe5cb43e10478cd5b763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924479e8e8c53ab678eabe5cb43e10478cd5b763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924479e8e8c53ab678eabe5cb43e10478cd5b763"}], "stats": {"total": 749, "additions": 395, "deletions": 354}, "files": [{"sha": "5a704a16dbe88201fccab80e5e35853da4389ad8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -1,3 +1,14 @@\n+2004-09-13  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-common.c, c-decl.c, c-lex.c, c-objc-common.c, c-opts.c,\n+\tc-parse.in, c-pragma.c, c-typeck.c: Use %q, %< and %> for quoting\n+\tin diagnostics.  Use %' for English apostrophes.\n+\t* c-tree.h (ATTRIBUTE_GCC_CDIAG): Define.\n+\t(pedwarn_c90, pedwarn_c99): Use it.\n+\t* c-decl.c (lookup_label): Quote label name in diagnostic.\n+\t* c-parse.in (yyprint): Use ' instead of ` for left quote.\n+\t* c-typeck.c (warn_for_assignment): Likewise.\n+\n 2004-09-13  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (x86_schedule): New global variable."}, {"sha": "47494106824ebed5a873a37ce2a5c64af1644422", "filename": "gcc/c-common.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -828,7 +828,7 @@ fname_decl (unsigned int rid, tree id)\n       input_location = saved_location;\n     }\n   if (!ix && !current_function_decl)\n-    pedwarn (\"%J'%D' is not defined outside of function scope\", decl, decl);\n+    pedwarn (\"%J%qD is not defined outside of function scope\", decl, decl);\n \n   return decl;\n }\n@@ -849,7 +849,7 @@ fix_string_type (tree value)\n   nchars = wide_flag ? length / wchar_bytes : length;\n \n   if (pedantic && nchars - 1 > nchars_max && !c_dialect_cxx ())\n-    pedwarn (\"string length `%d' is greater than the length `%d' ISO C%d compilers are required to support\",\n+    pedwarn (\"string length %qd is greater than the length %qd ISO C%d compilers are required to support\",\n \t     nchars - 1, nchars_max, flag_isoc99 ? 99 : 89);\n \n   e_type = wide_flag ? wchar_type_node : char_type_node;\n@@ -1135,7 +1135,7 @@ warn_for_collisions_1 (tree written, tree writer, struct tlist *list,\n \t  && DECL_NAME (list->expr))\n \t{\n \t  warned_ids = new_tlist (warned_ids, written, NULL_TREE);\n-\t  warning (\"operation on `%s' may be undefined\",\n+\t  warning (\"operation on %qs may be undefined\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (list->expr)));\n \t}\n       list = list->next;\n@@ -2229,7 +2229,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tpedwarn (\"pointer of type `void *' used in arithmetic\");\n+\tpedwarn (\"pointer of type %<void *%> used in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n@@ -2349,7 +2349,7 @@ c_common_truthvalue_conversion (tree expr)\n \t  {\n \t    /* Common Ada/Pascal programmer's mistake.  We always warn\n \t       about this since it is so bad.  */\n-\t    warning (\"the address of `%D', will always evaluate as `true'\",\n+\t    warning (\"the address of %qD, will always evaluate as %<true%>\",\n \t\t     TREE_OPERAND (expr, 0));\n \t    return truthvalue_true_node;\n \t  }\n@@ -2494,7 +2494,7 @@ c_build_qualified_type (tree type, int type_quals)\n       && (!POINTER_TYPE_P (type)\n \t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))\n     {\n-      error (\"invalid use of `restrict'\");\n+      error (\"invalid use of %<restrict%>\");\n       type_quals &= ~TYPE_QUAL_RESTRICT;\n     }\n \n@@ -2534,7 +2534,7 @@ c_apply_type_quals_to_decl (int type_quals, tree decl)\n       if (!type\n \t  || !POINTER_TYPE_P (type)\n \t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type)))\n-\terror (\"invalid use of `restrict'\");\n+\terror (\"invalid use of %<restrict%>\");\n       else if (flag_strict_aliasing && type == TREE_TYPE (decl))\n \t/* Indicate we need to make a unique alias set for this pointer.\n \t   We can't do it here because it might be pointing to an\n@@ -2749,7 +2749,7 @@ c_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n       if (op == SIZEOF_EXPR)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n-\t    pedwarn (\"invalid application of `sizeof' to a function type\");\n+\t    pedwarn (\"invalid application of %<sizeof%> to a function type\");\n \t  value = size_one_node;\n \t}\n       else\n@@ -2759,13 +2759,13 @@ c_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n     {\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (\"invalid application of `%s' to a void type\", op_name);\n+\tpedwarn (\"invalid application of %qs to a void type\", op_name);\n       value = size_one_node;\n     }\n   else if (!COMPLETE_TYPE_P (type))\n     {\n       if (complain)\n-\terror (\"invalid application of `%s' to incomplete type `%T' \",\n+\terror (\"invalid application of %qs to incomplete type %qT \",\n \t       op_name, type);\n       value = size_zero_node;\n     }\n@@ -2806,7 +2806,7 @@ c_alignof_expr (tree expr)\n   else if (TREE_CODE (expr) == COMPONENT_REF\n \t   && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n-      error (\"`__alignof' applied to a bit-field\");\n+      error (\"%<__alignof%> applied to a bit-field\");\n       t = size_one_node;\n     }\n   else if (TREE_CODE (expr) == COMPONENT_REF\n@@ -3249,7 +3249,7 @@ void\n disable_builtin_function (const char *name)\n {\n   if (strncmp (name, \"__builtin_\", strlen (\"__builtin_\")) == 0)\n-    error (\"cannot disable built-in function `%s'\", name);\n+    error (\"cannot disable built-in function %qs\", name);\n   else\n     {\n       disabled_builtin *new_disabled_builtin = XNEW (disabled_builtin);\n@@ -3657,10 +3657,10 @@ match_case_to_enum_1 (tree key, tree type, tree label)\n \t      TREE_INT_CST_HIGH (key), TREE_INT_CST_LOW (key));\n \n   if (TYPE_NAME (type) == 0)\n-    warning (\"%Jcase value `%s' not in enumerated type\",\n+    warning (\"%Jcase value %qs not in enumerated type\",\n \t     CASE_LABEL (label), buf);\n   else\n-    warning (\"%Jcase value `%s' not in enumerated type `%T'\",\n+    warning (\"%Jcase value %qs not in enumerated type %qT\",\n \t     CASE_LABEL (label), buf, type);\n }\n \n@@ -3761,7 +3761,7 @@ c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n \t    {\n \t      /* Warn if there are enumerators that don't correspond to\n \t\t case expressions.  */\n-\t      warning (\"%Henumeration value `%E' not handled in switch\",\n+\t      warning (\"%Henumeration value %qE not handled in switch\",\n \t\t       &switch_location, TREE_PURPOSE (chain));\n \t    }\n \t}\n@@ -3957,7 +3957,7 @@ handle_packed_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n      that changes what the typedef is typing.  */\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -3976,7 +3976,7 @@ handle_nocommon_attribute (tree *node, tree name,\n     DECL_COMMON (*node) = 0;\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -3994,7 +3994,7 @@ handle_common_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n     DECL_COMMON (*node) = 1;\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4021,7 +4021,7 @@ handle_noreturn_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t\t     TYPE_READONLY (TREE_TYPE (type)), 1));\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4040,7 +4040,7 @@ handle_noinline_attribute (tree *node, tree name,\n     DECL_UNINLINABLE (*node) = 1;\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4063,7 +4063,7 @@ handle_always_inline_attribute (tree *node, tree name,\n     }\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4087,7 +4087,7 @@ handle_used_attribute (tree *pnode, tree name, tree ARG_UNUSED (args),\n     }\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4113,7 +4113,7 @@ handle_unused_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \tTREE_USED (decl) = 1;\n       else\n \t{\n-\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n \t  *no_add_attrs = true;\n \t}\n     }\n@@ -4147,7 +4147,7 @@ handle_const_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4191,7 +4191,7 @@ handle_transparent_union_attribute (tree *node, tree name,\n     DECL_TRANSPARENT_UNION (decl) = 1;\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4219,7 +4219,7 @@ handle_constructor_attribute (tree *node, tree name,\n     }\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4247,7 +4247,7 @@ handle_destructor_attribute (tree *node, tree name,\n     }\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4266,7 +4266,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n   *no_add_attrs = true;\n \n   if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n-    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+    warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n   else\n     {\n       int j;\n@@ -4367,7 +4367,7 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \t     this mode for this type.  */\n \t  if (TREE_CODE (typefm) != INTEGER_TYPE)\n \t    {\n-\t      error (\"cannot use mode '%s' for enumeral types\",\n+\t      error (\"cannot use mode %qs for enumeral types\",\n \t\t     GET_MODE_NAME (mode));\n \t      return NULL_TREE;\n \t    }\n@@ -4417,7 +4417,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n \t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n \t    {\n-\t      error (\"%Jsection of '%D' conflicts with previous declaration\",\n+\t      error (\"%Jsection of %qD conflicts with previous declaration\",\n \t\t     *node, *node);\n \t      *no_add_attrs = true;\n \t    }\n@@ -4426,7 +4426,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t}\n       else\n \t{\n-\t  error (\"%Jsection attribute not allowed for '%D'\", *node, *node);\n+\t  error (\"%Jsection attribute not allowed for %qD\", *node, *node);\n \t  *no_add_attrs = true;\n \t}\n     }\n@@ -4506,7 +4506,7 @@ handle_aligned_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   else if (TREE_CODE (decl) != VAR_DECL\n \t   && TREE_CODE (decl) != FIELD_DECL)\n     {\n-      error (\"%Jalignment may not be specified for '%D'\", decl, decl);\n+      error (\"%Jalignment may not be specified for %qD\", decl, decl);\n       *no_add_attrs = true;\n     }\n   else\n@@ -4544,7 +4544,7 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n       || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n     {\n-      error (\"%J'%D' defined both normally and as an alias\", decl, decl);\n+      error (\"%J%qD defined both normally and as an alias\", decl, decl);\n       *no_add_attrs = true;\n     }\n \n@@ -4578,7 +4578,7 @@ handle_alias_attribute (tree *node, tree name, tree args,\n     }\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4602,14 +4602,14 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n     {\n       if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n        {\n-         warning (\"`%s' attribute ignored on non-class types\",\n+         warning (\"%qs attribute ignored on non-class types\",\n                   IDENTIFIER_POINTER (name));\n          return NULL_TREE;\n        }\n     }\n   else if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n@@ -4695,7 +4695,7 @@ handle_tls_model_attribute (tree *node, tree name, tree args,\n \n   if (! DECL_THREAD_LOCAL (decl))\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n   else\n@@ -4736,12 +4736,12 @@ handle_no_instrument_function_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%J'%E' attribute applies only to functions\", decl, name);\n+      error (\"%J%qE attribute applies only to functions\", decl, name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Jcan't set '%E' attribute after definition\", decl, name);\n+      error (\"%Jcan%'t set %qE attribute after definition\", decl, name);\n       *no_add_attrs = true;\n     }\n   else\n@@ -4762,7 +4762,7 @@ handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* ??? TODO: Support types.  */\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4782,12 +4782,12 @@ handle_no_limit_stack_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%J'%E' attribute applies only to functions\", decl, name);\n+      error (\"%J%qE attribute applies only to functions\", decl, name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Jcan't set '%E' attribute after definition\", decl, name);\n+      error (\"%Jcan%'t set %qE attribute after definition\", decl, name);\n       *no_add_attrs = true;\n     }\n   else\n@@ -4808,7 +4808,7 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* ??? TODO: Support types.  */\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -4863,10 +4863,10 @@ handle_deprecated_attribute (tree *node, tree name,\n \t    what = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n \t}\n       if (what)\n-\twarning (\"`%s' attribute ignored for `%s'\",\n+\twarning (\"%qs attribute ignored for %qs\",\n \t\t  IDENTIFIER_POINTER (name), what);\n       else\n-\twarning (\"`%s' attribute ignored\",\n+\twarning (\"%qs attribute ignored\",\n \t\t      IDENTIFIER_POINTER (name));\n     }\n \n@@ -4895,7 +4895,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \n   if (! host_integerp (size, 1))\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n@@ -4924,7 +4924,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n       || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n     {\n-      error (\"invalid vector type for attribute `%s'\",\n+      error (\"invalid vector type for attribute %qs\",\n \t     IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n@@ -5174,7 +5174,7 @@ handle_nothrow_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* ??? TODO: Support types.  */\n   else\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5197,7 +5197,7 @@ handle_cleanup_attribute (tree *node, tree name, tree args,\n      we'd be missing too much, since we do have attribute constructor.  */\n   if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl))\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -5236,7 +5236,7 @@ handle_warn_unused_result_attribute (tree *node, tree name,\n   /* Ignore the attribute for functions not returning any value.  */\n   if (VOID_TYPE_P (TREE_TYPE (*node)))\n     {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -5253,7 +5253,7 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n \n   if (!params)\n     {\n-      warning (\"`%s' attribute requires prototypes with named arguments\",\n+      warning (\"%qs attribute requires prototypes with named arguments\",\n                IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n@@ -5264,7 +5264,7 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n \n       if (VOID_TYPE_P (TREE_VALUE (params)))\n         {\n-\t  warning (\"`%s' attribute only applies to variadic functions\",\n+\t  warning (\"%qs attribute only applies to variadic functions\",\n \t\t   IDENTIFIER_POINTER (name));\n \t  *no_add_attrs = true;\n \t}\n@@ -5489,7 +5489,7 @@ c_parse_error (const char *msgid, enum cpp_ttype token, tree value)\n   else if (token == CPP_NAME)\n     error (\"%s before \\\"%s\\\"\", string, IDENTIFIER_POINTER (value));\n   else if (token < N_TTYPES)\n-    error (\"%s before '%s' token\", string, cpp_type2name (token));\n+    error (\"%s before %qs token\", string, cpp_type2name (token));\n   else\n     error (\"%s\", string);\n }\n@@ -5551,7 +5551,7 @@ c_warn_unused_result (tree *top_p)\n       if (lookup_attribute (\"warn_unused_result\", TYPE_ATTRIBUTES (ftype)))\n \t{\n \t  if (fdecl)\n-\t    warning (\"%Hignoring return value of `%D', \"\n+\t    warning (\"%Hignoring return value of %qD, \"\n \t\t     \"declared with attribute warn_unused_result\",\n \t\t     EXPR_LOCUS (t), fdecl);\n \t  else\n@@ -5595,7 +5595,7 @@ fold_offsetof_1 (tree expr)\n       if (DECL_C_BIT_FIELD (t))\n \t{\n \t  error (\"attempt to take address of bit-field structure \"\n-\t\t \"member `%s'\", IDENTIFIER_POINTER (DECL_NAME (t)));\n+\t\t \"member %qs\", IDENTIFIER_POINTER (DECL_NAME (t)));\n \t  return error_mark_node;\n \t}\n       off = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (t),"}, {"sha": "7d986cdf24dd8f9c5570f9af1f49caacbe430dd6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 170, "deletions": 164, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -521,7 +521,7 @@ c_finish_incomplete_decl (tree decl)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n-\t  warning (\"%Jarray '%D' assumed to have one element\", decl, decl);\n+\t  warning (\"%Jarray %qD assumed to have one element\", decl, decl);\n \n \t  complete_array_type (type, NULL_TREE, 1);\n \n@@ -718,15 +718,15 @@ pop_scope (void)\n \t  /* Warnings for unused labels, errors for undefined labels.  */\n \t  if (TREE_USED (p) && !DECL_INITIAL (p))\n \t    {\n-\t      error (\"%Jlabel `%D' used but not defined\", p, p);\n+\t      error (\"%Jlabel %qD used but not defined\", p, p);\n \t      DECL_INITIAL (p) = error_mark_node;\n \t    }\n \t  else if (!TREE_USED (p) && warn_unused_label)\n \t    {\n \t      if (DECL_INITIAL (p))\n-\t\twarning (\"%Jlabel `%D' defined but not used\", p, p);\n+\t\twarning (\"%Jlabel %qD defined but not used\", p, p);\n \t      else\n-\t\twarning (\"%Jlabel `%D' declared but not defined\", p, p);\n+\t\twarning (\"%Jlabel %qD declared but not defined\", p, p);\n \t    }\n \t  /* Labels go in BLOCK_VARS.  */\n \t  TREE_CHAIN (p) = BLOCK_VARS (block);\n@@ -771,7 +771,7 @@ pop_scope (void)\n \t\t  || (TREE_STATIC (p) && !TREE_PUBLIC (p)\n \t\t      && !TREE_THIS_VOLATILE (p)))\n \t      && scope != external_scope)\n-\t    warning (\"%Junused variable `%D'\", p, p);\n+\t    warning (\"%Junused variable %qD\", p, p);\n \n \t  if (b->inner_comp)\n \t    {\n@@ -1050,13 +1050,13 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \t agree on the number of arguments.  */\n       if (END_OF_ARGLIST (oldargtype))\n \t{\n-\t  error (\"%Jprototype for '%D' declares more arguments \"\n+\t  error (\"%Jprototype for %qD declares more arguments \"\n \t\t \"than previous old-style definition\", newdecl, newdecl);\n \t  return false;\n \t}\n       else if (END_OF_ARGLIST (newargtype))\n \t{\n-\t  error (\"%Jprototype for '%D' declares fewer arguments \"\n+\t  error (\"%Jprototype for %qD declares fewer arguments \"\n \t\t \"than previous old-style definition\", newdecl, newdecl);\n \t  return false;\n \t}\n@@ -1065,7 +1065,7 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \t for the arg.  */\n       else if (! comptypes (oldargtype, newargtype))\n \t{\n-\t  error (\"%Jprototype for '%D' declares arg %d with incompatible type\",\n+\t  error (\"%Jprototype for %qD declares arg %d with incompatible type\",\n \t\t newdecl, newdecl, i);\n \t  return false;\n \t}\n@@ -1077,7 +1077,7 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \n   /* If we get here, no errors were found, but do issue a warning\n      for this poor-style construct.  */\n-  warning (\"%Jprototype for '%D' follows non-prototype definition\",\n+  warning (\"%Jprototype for %qD follows non-prototype definition\",\n \t   newdecl, newdecl);\n   return true;\n #undef END_OF_ARGLIST\n@@ -1092,11 +1092,11 @@ locate_old_decl (tree decl, void (*diag)(const char *, ...))\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_BUILT_IN (decl))\n     ;\n   else if (DECL_INITIAL (decl))\n-    diag (N_(\"%Jprevious definition of '%D' was here\"), decl, decl);\n+    diag (N_(\"%Jprevious definition of %qD was here\"), decl, decl);\n   else if (C_DECL_IMPLICIT (decl))\n-    diag (N_(\"%Jprevious implicit declaration of '%D' was here\"), decl, decl);\n+    diag (N_(\"%Jprevious implicit declaration of %qD was here\"), decl, decl);\n   else\n-    diag (N_(\"%Jprevious declaration of '%D' was here\"), decl, decl);\n+    diag (N_(\"%Jprevious declaration of %qD was here\"), decl, decl);\n }\n \n /* Subroutine of duplicate_decls.  Compare NEWDECL to OLDDECL.\n@@ -1132,15 +1132,15 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    && DECL_BUILT_IN (olddecl)\n \t    && !C_DECL_DECLARED_BUILTIN (olddecl)))\n \t{\n-\t  error (\"%J'%D' redeclared as different kind of symbol\",\n+\t  error (\"%J%qD redeclared as different kind of symbol\",\n \t\t newdecl, newdecl);\n \t  locate_old_decl (olddecl, error);\n \t}\n       else if (TREE_PUBLIC (newdecl))\n-\twarning (\"%Jbuilt-in function '%D' declared as non-function\",\n+\twarning (\"%Jbuilt-in function %qD declared as non-function\",\n \t\t newdecl, newdecl);\n       else if (warn_shadow)\n-\twarning (\"%Jdeclaration of '%D' shadows a built-in function\",\n+\twarning (\"%Jdeclaration of %qD shadows a built-in function\",\n \t\t newdecl, newdecl);\n       return false;\n     }\n@@ -1161,7 +1161,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t      /* If types don't match for a built-in, throw away the\n \t\t built-in.  No point in calling locate_old_decl here, it\n \t\t won't print anything.  */\n-\t      warning (\"%Jconflicting types for built-in function '%D'\",\n+\t      warning (\"%Jconflicting types for built-in function %qD\",\n \t\t       newdecl, newdecl);\n \t      return false;\n \t    }\n@@ -1185,7 +1185,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t       && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t       && C_FUNCTION_IMPLICIT_INT (newdecl))\n \t{\n-\t  pedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n+\t  pedwarn (\"%Jconflicting types for %qD\", newdecl, newdecl);\n \t  /* Make sure we keep void as the return type.  */\n \t  TREE_TYPE (newdecl) = *newtypep = newtype = oldtype;\n \t  C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -1194,9 +1194,9 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       else\n \t{\n \t  if (TYPE_QUALS (newtype) != TYPE_QUALS (oldtype))\n-\t    error (\"%J conflicting type qualifiers for '%D'\", newdecl, newdecl);\n+\t    error (\"%J conflicting type qualifiers for %qD\", newdecl, newdecl);\n \t  else\n-\t    error (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n+\t    error (\"%Jconflicting types for %qD\", newdecl, newdecl);\n \t  diagnose_arglist_conflict (newdecl, olddecl, newtype, oldtype);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n@@ -1211,7 +1211,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_IN_SYSTEM_HEADER (newdecl) || DECL_IN_SYSTEM_HEADER (olddecl))\n \treturn true;  /* Allow OLDDECL to continue in use.  */\n \n-      error (\"%Jredefinition of typedef '%D'\", newdecl, newdecl);\n+      error (\"%Jredefinition of typedef %qD\", newdecl, newdecl);\n       locate_old_decl (olddecl, error);\n       return false;\n     }\n@@ -1235,7 +1235,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t  && !TYPE_ARG_TYPES (TREE_TYPE (newdecl)))))\n \t{\n \t  if (warn_shadow)\n-\t    warning (\"%Jdeclaration of '%D' shadows a built-in function\",\n+\t    warning (\"%Jdeclaration of %qD shadows a built-in function\",\n \t\t     newdecl, newdecl);\n \t  /* Discard the old built-in function.  */\n \t  return false;\n@@ -1250,7 +1250,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t\t&& DECL_EXTERNAL (newdecl)\n \t    \t\t&& same_translation_unit_p (olddecl, newdecl))))\n \t    {\n-\t      error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n+\t      error (\"%Jredefinition of %qD\", newdecl, newdecl);\n \t      locate_old_decl (olddecl, error);\n \t      return false;\n \t    }\n@@ -1285,7 +1285,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t      && !(DECL_EXTERNAL (olddecl)\n \t\t   && DECL_DECLARED_INLINE_P (olddecl)))\n \t    {\n-\t      error (\"%Jstatic declaration of '%D' follows \"\n+\t      error (\"%Jstatic declaration of %qD follows \"\n \t\t     \"non-static declaration\", newdecl, newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n@@ -1295,14 +1295,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t{\n \t  if (DECL_CONTEXT (olddecl))\n \t    {\n-\t      error (\"%Jnon-static declaration of '%D' follows \"\n+\t      error (\"%Jnon-static declaration of %qD follows \"\n \t\t     \"static declaration\", newdecl, newdecl);\n \t      locate_old_decl (olddecl, error);\n \t      return false;\n \t    }\n \t  else if (warn_traditional)\n \t    {\n-\t      warning (\"%Jnon-static declaration of '%D' follows \"\n+\t      warning (\"%Jnon-static declaration of %qD follows \"\n \t\t       \"static declaration\", newdecl, newdecl);\n \t      warned = true;\n \t    }\n@@ -1315,10 +1315,10 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_THREAD_LOCAL (newdecl) != DECL_THREAD_LOCAL (olddecl))\n \t{\n \t  if (DECL_THREAD_LOCAL (newdecl))\n-\t    error (\"%Jthread-local declaration of '%D' follows \"\n+\t    error (\"%Jthread-local declaration of %qD follows \"\n \t\t   \"non-thread-local declaration\", newdecl, newdecl);\n \t  else\n-\t    error (\"%Jnon-thread-local declaration of '%D' follows \"\n+\t    error (\"%Jnon-thread-local declaration of %qD follows \"\n \t\t   \"thread-local declaration\", newdecl, newdecl);\n \n \t  locate_old_decl (olddecl, error);\n@@ -1328,7 +1328,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       /* Multiple initialized definitions are not allowed (6.9p3,5).  */\n       if (DECL_INITIAL (newdecl) && DECL_INITIAL (olddecl))\n \t{\n-\t  error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n+\t  error (\"%Jredefinition of %qD\", newdecl, newdecl);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n@@ -1355,18 +1355,18 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t}\n \t      else if (warn_traditional)\n \t\t{\n-\t\t  warning (\"%Jnon-static declaration of '%D' follows \"\n+\t\t  warning (\"%Jnon-static declaration of %qD follows \"\n \t\t\t   \"static declaration\", newdecl, newdecl);\n \t\t  warned = true;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (TREE_PUBLIC (newdecl))\n-\t\terror (\"%Jnon-static declaration of '%D' follows \"\n+\t\terror (\"%Jnon-static declaration of %qD follows \"\n \t\t       \"static declaration\", newdecl, newdecl);\n \t      else\n-\t\terror (\"%Jstatic declaration of '%D' follows \"\n+\t\terror (\"%Jstatic declaration of %qD follows \"\n \t\t       \"non-static declaration\", newdecl, newdecl);\n \n \t      locate_old_decl (olddecl, error);\n@@ -1384,13 +1384,13 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else if (DECL_EXTERNAL (olddecl))\n \t    {\n-\t      error (\"%Jdeclaration of '%D' with no linkage follows \"\n+\t      error (\"%Jdeclaration of %qD with no linkage follows \"\n \t\t     \"extern declaration\", newdecl, newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n \t  else\n \t    {\n-\t      error (\"%Jredeclaration of '%D' with no linkage\",\n+\t      error (\"%Jredeclaration of %qD with no linkage\",\n \t\t     newdecl, newdecl);\n \t      locate_old_decl (olddecl, error);\n \t    }\n@@ -1404,7 +1404,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n   if (DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      warning (\"%Jredeclaration of '%D' with different visibility \"\n+      warning (\"%Jredeclaration of %qD with different visibility \"\n \t       \"(old visibility preserved)\", newdecl, newdecl);\n       warned = true;\n     }\n@@ -1415,14 +1415,14 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (DECL_DECLARED_INLINE_P (newdecl)\n \t  && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warning (\"%Jinline declaration of '%D' follows \"\n+\t  warning (\"%Jinline declaration of %qD follows \"\n \t\t   \"declaration with attribute noinline\", newdecl, newdecl);\n \t  warned = true;\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (\"%Jdeclaration of '%D' with attribute noinline follows \"\n+\t  warning (\"%Jdeclaration of %qD with attribute noinline follows \"\n \t\t   \"inline declaration \", newdecl, newdecl);\n \t  warned = true;\n \t}\n@@ -1437,13 +1437,13 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t{\n \t  if (TREE_USED (olddecl))\n \t    {\n-\t      warning (\"%J'%D' declared inline after being called\",\n+\t      warning (\"%J%qD declared inline after being called\",\n \t\t       olddecl, olddecl);\n \t      warned = true;\n \t    }\n \t  else if (DECL_INITIAL (olddecl))\n \t    {\n-\t      warning (\"%J'%D' declared inline after its definition\",\n+\t      warning (\"%J%qD declared inline after its definition\",\n \t\t       olddecl, olddecl);\n \t      warned = true;\n \t    }\n@@ -1463,7 +1463,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       if (TREE_CODE (newdecl) == PARM_DECL\n \t  && (!TREE_ASM_WRITTEN (olddecl) || TREE_ASM_WRITTEN (newdecl)))\n \t{\n-\t  error (\"%Jredefinition of parameter '%D'\", newdecl, newdecl);\n+\t  error (\"%Jredefinition of parameter %qD\", newdecl, newdecl);\n \t  locate_old_decl (olddecl, error);\n \t  return false;\n \t}\n@@ -1487,7 +1487,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       && !(TREE_CODE (newdecl) == PARM_DECL\n \t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl)))\n     {\n-      warning (\"%Jredundant redeclaration of '%D'\", newdecl, newdecl);\n+      warning (\"%Jredundant redeclaration of %qD\", newdecl, newdecl);\n       warned = true;\n     }\n \n@@ -1793,17 +1793,17 @@ warn_if_shadowing (tree new_decl)\n \ttree old_decl = b->decl;\n \n \tif (TREE_CODE (old_decl) == PARM_DECL)\n-\t  warning (\"%Jdeclaration of '%D' shadows a parameter\",\n+\t  warning (\"%Jdeclaration of %qD shadows a parameter\",\n \t\t   new_decl, new_decl);\n \telse if (DECL_FILE_SCOPE_P (old_decl))\n-\t  warning (\"%Jdeclaration of '%D' shadows a global declaration\",\n+\t  warning (\"%Jdeclaration of %qD shadows a global declaration\",\n \t\t   new_decl, new_decl);\n \telse if (TREE_CODE (old_decl) == FUNCTION_DECL\n \t\t && DECL_BUILT_IN (old_decl))\n-\t  warning (\"%Jdeclaration of '%D' shadows a built-in function\",\n+\t  warning (\"%Jdeclaration of %qD shadows a built-in function\",\n \t\t   new_decl, new_decl);\n \telse\n-\t  warning (\"%Jdeclaration of '%D' shadows a previous local\",\n+\t  warning (\"%Jdeclaration of %qD shadows a previous local\",\n \t\t   new_decl, new_decl);\n \n \tif (TREE_CODE (old_decl) != FUNCTION_DECL\n@@ -1962,7 +1962,7 @@ pushdecl (tree x)\n       if (warn_nested_externs\n \t  && scope != file_scope\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n-\twarning (\"nested extern declaration of '%D'\", x);\n+\twarning (\"nested extern declaration of %qD\", x);\n \n       while (b && !B_IN_EXTERNAL_SCOPE (b))\n \t{\n@@ -2051,7 +2051,7 @@ pushdecl (tree x)\n \t   && !TREE_PUBLIC (x) && !DECL_INITIAL (x))\n     {\n       if (warn_nested_externs && !DECL_IN_SYSTEM_HEADER (x))\n-\twarning (\"nested static declaration of '%D'\", x);\n+\twarning (\"nested static declaration of %qD\", x);\n \n       while (b && !B_IN_FILE_SCOPE (b))\n \tb = b->shadowed;\n@@ -2146,7 +2146,7 @@ implicit_decl_warning (tree id, tree olddecl)\n     default: gcc_unreachable ();\n     }\n \n-  diag (N_(\"implicit declaration of function '%E'\"), id);\n+  diag (N_(\"implicit declaration of function %qE\"), id);\n   if (olddecl)\n     locate_old_decl (olddecl, diag);\n }\n@@ -2261,12 +2261,12 @@ undeclared_variable (tree id)\n \n   if (current_function_decl == 0)\n     {\n-      error (\"'%E' undeclared here (not in a function)\", id);\n+      error (\"%qE undeclared here (not in a function)\", id);\n       scope = current_scope;\n     }\n   else\n     {\n-      error (\"'%E' undeclared (first use in this function)\", id);\n+      error (\"%qE undeclared (first use in this function)\", id);\n \n       if (! already)\n \t{\n@@ -2309,7 +2309,7 @@ lookup_label (tree name)\n \n   if (current_function_decl == 0)\n     {\n-      error (\"label %s referenced outside of any function\",\n+      error (\"label %qs referenced outside of any function\",\n \t     IDENTIFIER_POINTER (name));\n       return 0;\n     }\n@@ -2352,7 +2352,7 @@ declare_label (tree name)\n      at this scope */\n   if (b && B_IN_CURRENT_SCOPE (b))\n     {\n-      error (\"duplicate label declaration `%s'\", IDENTIFIER_POINTER (name));\n+      error (\"duplicate label declaration %qs\", IDENTIFIER_POINTER (name));\n       locate_old_decl (b->decl, error);\n \n       /* Just use the previous declaration.  */\n@@ -2387,7 +2387,7 @@ define_label (location_t location, tree name)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n-      error (\"%Hduplicate label `%D'\", &location, label);\n+      error (\"%Hduplicate label %qD\", &location, label);\n       locate_old_decl (label, error);\n       return 0;\n     }\n@@ -2410,7 +2410,7 @@ define_label (location_t location, tree name)\n \n   if (warn_traditional && !in_system_header && lookup_name (name))\n     warning (\"%Htraditional C lacks a separate namespace for labels, \"\n-             \"identifier `%s' conflicts\", &location,\n+             \"identifier %qs conflicts\", &location,\n \t     IDENTIFIER_POINTER (name));\n \n   /* Mark label as having been defined.  */\n@@ -2475,7 +2475,7 @@ void\n pending_xref_error (void)\n {\n   if (pending_invalid_xref != 0)\n-    error (\"%H`%s' defined as wrong kind of tag\",\n+    error (\"%H%qs defined as wrong kind of tag\",\n            &pending_invalid_xref_location,\n            IDENTIFIER_POINTER (pending_invalid_xref));\n   pending_invalid_xref = 0;\n@@ -2808,12 +2808,13 @@ build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n   if (pedantic && !flag_isoc99)\n     {\n       if (static_p || quals != NULL)\n-\tpedwarn (\"ISO C90 does not support `static' or type qualifiers in parameter array declarators\");\n+\tpedwarn (\"ISO C90 does not support %<static%> or type \"\n+\t\t \"qualifiers in parameter array declarators\");\n       if (vla_unspec_p)\n-\tpedwarn (\"ISO C90 does not support `[*]' array declarators\");\n+\tpedwarn (\"ISO C90 does not support %<[*]%> array declarators\");\n     }\n   if (vla_unspec_p)\n-    warning (\"GCC does not yet properly implement `[*]' array declarators\");\n+    warning (\"GCC does not yet properly implement %<[*]%> array declarators\");\n   return declarator;\n }\n \n@@ -2888,7 +2889,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n-    warning (\"%J'%D' is usually a function\", decl, decl);\n+    warning (\"%J%qD is usually a function\", decl, decl);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -2897,18 +2898,18 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n-\terror (\"typedef '%D' is initialized (use __typeof__ instead)\", decl);\n+\terror (\"typedef %qD is initialized (use __typeof__ instead)\", decl);\n \tinitialized = 0;\n \tbreak;\n \n       case FUNCTION_DECL:\n-\terror (\"function '%D' is initialized like a variable\", decl);\n+\terror (\"function %qD is initialized like a variable\", decl);\n \tinitialized = 0;\n \tbreak;\n \n       case PARM_DECL:\n \t/* DECL_INITIAL in a PARM_DECL is really DECL_ARG_TYPE.  */\n-\terror (\"parameter '%D' is initialized\", decl);\n+\terror (\"parameter %qD is initialized\", decl);\n \tinitialized = 0;\n \tbreak;\n \n@@ -2933,12 +2934,12 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t  }\n \telse if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n \t  {\n-\t    error (\"variable '%D' has initializer but incomplete type\", decl);\n+\t    error (\"variable %qD has initializer but incomplete type\", decl);\n \t    initialized = 0;\n \t  }\n \telse if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n \t  {\n-\t    error (\"elements of array '%D' have incomplete type\", decl);\n+\t    error (\"elements of array %qD have incomplete type\", decl);\n \t    initialized = 0;\n \t  }\n       }\n@@ -3005,7 +3006,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (\"%Jinline function '%D' given attribute noinline\", decl, decl);\n+    warning (\"%Jinline function %qD given attribute noinline\", decl, decl);\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -3069,12 +3070,12 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       type = TREE_TYPE (decl);\n \n       if (failure == 1)\n-\terror (\"%Jinitializer fails to determine size of '%D'\", decl, decl);\n+\terror (\"%Jinitializer fails to determine size of %qD\", decl, decl);\n \n       else if (failure == 2)\n \t{\n \t  if (do_default)\n-\t    error (\"%Jarray size missing in '%D'\", decl, decl);\n+\t    error (\"%Jarray size missing in %qD\", decl, decl);\n \t  /* If a `static' var's size isn't known,\n \t     make it extern as well as static, so it does not get\n \t     allocated.\n@@ -3090,7 +3091,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t warn only if the value is less than zero.  */\n       else if (pedantic && TYPE_DOMAIN (type) != 0\n \t       && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n-\terror (\"%Jzero or negative size array '%D'\", decl, decl);\n+\terror (\"%Jzero or negative size array %qD\", decl, decl);\n \n       layout_decl (decl, 0);\n     }\n@@ -3116,7 +3117,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t is an error.  */\n \t      : !DECL_EXTERNAL (decl)))\n \t {\n-\t   error (\"%Jstorage size of '%D' isn't known\", decl, decl);\n+\t   error (\"%Jstorage size of %qD isn%'t known\", decl, decl);\n \t   TREE_TYPE (decl) = error_mark_node;\n \t }\n \n@@ -3126,7 +3127,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n \t  else\n-\t    error (\"%Jstorage size of '%D' isn't constant\", decl, decl);\n+\t    error (\"%Jstorage size of %qD isn%'t constant\", decl, decl);\n \t}\n \n       if (TREE_USED (type))\n@@ -3182,7 +3183,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      && !C_DECL_REGISTER (decl)\n \t      && !TREE_STATIC (decl))\n \t    warning (\"%Jignoring asm-specifier for non-static local \"\n-\t\t     \"variable '%D'\", decl, decl);\n+\t\t     \"variable %qD\", decl, decl);\n \t  else if (C_DECL_REGISTER (decl))\n \t    change_decl_assembler_name (decl, get_identifier (asmspec));\n \t  else\n@@ -3533,20 +3534,20 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n      field widths.  */\n   if (TREE_CODE (*width) != INTEGER_CST)\n     {\n-      error (\"bit-field `%s' width not an integer constant\", name);\n+      error (\"bit-field %qs width not an integer constant\", name);\n       *width = integer_one_node;\n     }\n   else\n     {\n       constant_expression_warning (*width);\n       if (tree_int_cst_sgn (*width) < 0)\n \t{\n-\t  error (\"negative width in bit-field `%s'\", name);\n+\t  error (\"negative width in bit-field %qs\", name);\n \t  *width = integer_one_node;\n \t}\n       else if (integer_zerop (*width) && orig_name)\n \t{\n-\t  error (\"zero width for bit-field `%s'\", name);\n+\t  error (\"zero width for bit-field %qs\", name);\n \t  *width = integer_one_node;\n \t}\n     }\n@@ -3556,7 +3557,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n       && TREE_CODE (*type) != BOOLEAN_TYPE\n       && TREE_CODE (*type) != ENUMERAL_TYPE)\n     {\n-      error (\"bit-field `%s' has invalid type\", name);\n+      error (\"bit-field %qs has invalid type\", name);\n       *type = unsigned_type_node;\n     }\n \n@@ -3565,7 +3566,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n       && type_mv != integer_type_node\n       && type_mv != unsigned_type_node\n       && type_mv != boolean_type_node)\n-    pedwarn (\"type of bit-field `%s' is a GCC extension\", name);\n+    pedwarn (\"type of bit-field %qs is a GCC extension\", name);\n \n   if (type_mv == boolean_type_node)\n     max_width = CHAR_TYPE_SIZE;\n@@ -3574,7 +3575,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n \n   if (0 < compare_tree_int (*width, max_width))\n     {\n-      error (\"width of `%s' exceeds its type\", name);\n+      error (\"width of %qs exceeds its type\", name);\n       w = max_width;\n       *width = build_int_cst (NULL_TREE, w);\n     }\n@@ -3587,7 +3588,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n       if (!lt\n           || w < min_precision (lt->enum_min, TYPE_UNSIGNED (*type))\n \t  || w < min_precision (lt->enum_max, TYPE_UNSIGNED (*type)))\n-\twarning (\"`%s' is narrower than values of its type\", name);\n+\twarning (\"%qs is narrower than values of its type\", name);\n     }\n }\n \f\n@@ -3723,7 +3724,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      && funcdef_flag)\n \t    warn_about_return_type = 1;\n \t  else if (warn_implicit_int || flag_isoc99)\n-\t    pedwarn_c99 (\"type defaults to `int' in declaration of `%s'\",\n+\t    pedwarn_c99 (\"type defaults to %<int%> in declaration of %qs\",\n \t\t\t name);\n \t}\n \n@@ -3752,36 +3753,36 @@ grokdeclarator (const struct c_declarator *declarator,\n \n       if ((specbits & 1 << (int) RID_LONG)\n \t  && (specbits & 1 << (int) RID_SHORT))\n-\terror (\"both long and short specified for `%s'\", name);\n+\terror (\"both long and short specified for %qs\", name);\n       else if (((specbits & 1 << (int) RID_LONG)\n \t\t|| (specbits & 1 << (int) RID_SHORT))\n \t       && declspecs->explicit_char_p)\n-\terror (\"long or short specified with char for `%s'\", name);\n+\terror (\"long or short specified with char for %qs\", name);\n       else if (((specbits & 1 << (int) RID_LONG)\n \t\t|| (specbits & 1 << (int) RID_SHORT))\n \t       && TREE_CODE (type) == REAL_TYPE)\n \t{\n \t  static int already = 0;\n \n-\t  error (\"long or short specified with floating type for `%s'\", name);\n+\t  error (\"long or short specified with floating type for %qs\", name);\n \t  if (! already && ! pedantic)\n \t    {\n-\t      error (\"the only valid combination is `long double'\");\n+\t      error (\"the only valid combination is %<long double%>\");\n \t      already = 1;\n \t    }\n \t}\n       else if ((specbits & 1 << (int) RID_SIGNED)\n \t       && (specbits & 1 << (int) RID_UNSIGNED))\n-\terror (\"both signed and unsigned specified for `%s'\", name);\n+\terror (\"both signed and unsigned specified for %qs\", name);\n       else if (TREE_CODE (type) != INTEGER_TYPE)\n-\terror (\"long, short, signed or unsigned invalid for `%s'\", name);\n+\terror (\"long, short, signed or unsigned invalid for %qs\", name);\n       else\n \t{\n \t  ok = 1;\n \t  if (!declspecs->explicit_int_p && !defaulted_int\n \t      && !declspecs->explicit_char_p)\n \t    {\n-\t      error (\"long, short, signed or unsigned used invalidly for `%s'\",\n+\t      error (\"long, short, signed or unsigned used invalidly for %qs\",\n \t\t     name);\n \t      ok = 0;\n \t    }\n@@ -3799,7 +3800,7 @@ grokdeclarator (const struct c_declarator *declarator,\n   if ((specbits & (1 << (int) RID_COMPLEX))\n       && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n     {\n-      error (\"complex invalid for `%s'\", name);\n+      error (\"complex invalid for %qs\", name);\n       specbits &= ~(1 << (int) RID_COMPLEX);\n     }\n \n@@ -3853,7 +3854,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\t    | (1 << (int) RID_UNSIGNED))))\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support plain `complex' meaning `double complex'\");\n+\t    pedwarn (\"ISO C does not support plain %<complex%> meaning \"\n+\t\t     \"%<double complex%>\");\n \t  type = complex_double_type_node;\n \t}\n       else if (type == integer_type_node)\n@@ -3900,11 +3902,11 @@ grokdeclarator (const struct c_declarator *declarator,\n   if (pedantic && !flag_isoc99)\n     {\n       if (constp > 1)\n-\tpedwarn (\"duplicate `const'\");\n+\tpedwarn (\"duplicate %<const%>\");\n       if (restrictp > 1)\n-\tpedwarn (\"duplicate `restrict'\");\n+\tpedwarn (\"duplicate %<restrict%>\");\n       if (volatilep > 1)\n-\tpedwarn (\"duplicate `volatile'\");\n+\tpedwarn (\"duplicate %<volatile%>\");\n     }\n   if (! flag_gen_aux_info && (TYPE_QUALS (type)))\n     type = TYPE_MAIN_VARIANT (type);\n@@ -3972,14 +3974,14 @@ grokdeclarator (const struct c_declarator *declarator,\n   else if (current_scope == file_scope)\n     {\n       if (storage_class == csc_auto)\n-\terror (\"file-scope declaration of `%s' specifies `auto'\", name);\n+\terror (\"file-scope declaration of %qs specifies %<auto%>\", name);\n       if (pedantic && storage_class == csc_register)\n \tpedwarn (\"file-scope declaration of %qs specifies %<register%>\", name);\n     }\n   else\n     {\n       if (storage_class == csc_extern && funcdef_flag)\n-\terror (\"nested function `%s' declared `extern'\", name);\n+\terror (\"nested function %qs declared %<extern%>\", name);\n       else if (threadp && storage_class == csc_none)\n \t{\n \t  error (\"function-scope %qs implicitly auto and declared \"\n@@ -4065,13 +4067,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    \n \t    if (VOID_TYPE_P (type))\n \t      {\n-\t\terror (\"declaration of `%s' as array of voids\", name);\n+\t\terror (\"declaration of %qs as array of voids\", name);\n \t\ttype = error_mark_node;\n \t      }\n \t    \n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n-\t\terror (\"declaration of `%s' as array of functions\", name);\n+\t\terror (\"declaration of %qs as array of functions\", name);\n \t\ttype = error_mark_node;\n \t      }\n \t    \n@@ -4096,19 +4098,19 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\n \t\tif (! INTEGRAL_TYPE_P (TREE_TYPE (size)))\n \t\t  {\n-\t\t    error (\"size of array `%s' has non-integer type\", name);\n+\t\t    error (\"size of array %qs has non-integer type\", name);\n \t\t    size = integer_one_node;\n \t\t  }\n \t\t\n \t\tif (pedantic && integer_zerop (size))\n-\t\t  pedwarn (\"ISO C forbids zero-size array `%s'\", name);\n+\t\t  pedwarn (\"ISO C forbids zero-size array %qs\", name);\n \t\t\n \t\tif (TREE_CODE (size) == INTEGER_CST)\n \t\t  {\n \t\t    constant_expression_warning (size);\n \t\t    if (tree_int_cst_sgn (size) < 0)\n \t\t      {\n-\t\t\terror (\"size of array `%s' is negative\", name);\n+\t\t\terror (\"size of array %qs is negative\", name);\n \t\t\tsize = integer_one_node;\n \t\t      }\n \t\t  }\n@@ -4122,10 +4124,11 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    if (!flag_isoc99 && pedantic)\n \t\t      {\n \t\t\tif (TREE_CONSTANT (size))\n-\t\t\t  pedwarn (\"ISO C90 forbids array `%s' whose size can't be evaluated\",\n+\t\t\t  pedwarn (\"ISO C90 forbids array %qs whose size \"\n+\t\t\t\t   \"can%'t be evaluated\",\n \t\t\t\t   name);\n \t\t\telse\n-\t\t\t  pedwarn (\"ISO C90 forbids variable-size array `%s'\",\n+\t\t\t  pedwarn (\"ISO C90 forbids variable-size array %qs\",\n \t\t\t\t   name);\n \t\t      }\n \t\t  }\n@@ -4158,7 +4161,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       complication.  */\n \t\t    if (TREE_OVERFLOW (itype))\n \t\t      {\n-\t\t\terror (\"size of array `%s' is too large\", name);\n+\t\t\terror (\"size of array %qs is too large\", name);\n \t\t\ttype = error_mark_node;\n \t\t\tcontinue;\n \t\t      }\n@@ -4241,12 +4244,12 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    /* Warn about some types functions can't return.  */\n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n-\t\terror (\"`%s' declared as function returning a function\", name);\n+\t\terror (\"%qs declared as function returning a function\", name);\n \t\ttype = integer_type_node;\n \t      }\n \t    if (TREE_CODE (type) == ARRAY_TYPE)\n \t      {\n-\t\terror (\"`%s' declared as function returning an array\", name);\n+\t\terror (\"%qs declared as function returning an array\", name);\n \t\ttype = integer_type_node;\n \t      }\n \n@@ -4342,7 +4345,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       && COMPLETE_TYPE_P (type)\n       && TREE_OVERFLOW (TYPE_SIZE (type)))\n     {\n-      error (\"size of array `%s' is too large\", name);\n+      error (\"size of array %qs is too large\", name);\n       /* If we proceed with the array type as it is, we'll eventually\n \t crash in tree_low_cst().  */\n       type = error_mark_node;\n@@ -4412,7 +4415,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    && !(storage_class == csc_static\n \t\t\t || storage_class == csc_register)))))\n     {\n-      error (\"variable or field `%s' declared void\", name);\n+      error (\"variable or field %qs declared void\", name);\n       type = integer_type_node;\n     }\n \n@@ -4499,13 +4502,13 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    error (\"field `%s' declared as a function\", name);\n+\t    error (\"field %qs declared as a function\", name);\n \t    type = build_pointer_type (type);\n \t  }\n \telse if (TREE_CODE (type) != ERROR_MARK\n \t         && !COMPLETE_OR_UNBOUND_ARRAY_TYPE_P (type))\n \t  {\n-\t    error (\"field `%s' has incomplete type\", name);\n+\t    error (\"field %qs has incomplete type\", name);\n \t    type = error_mark_node;\n \t  }\n \t/* Move type qualifiers down to element of an array.  */\n@@ -4522,7 +4525,7 @@ grokdeclarator (const struct c_declarator *declarator,\n     else if (TREE_CODE (type) == FUNCTION_TYPE)\n       {\n \tif (storage_class == csc_register || threadp)\n-\t  error (\"invalid storage class for function `%s'\", name);\n+\t  error (\"invalid storage class for function %qs\", name);\n \telse if (current_scope != file_scope)\n \t  {\n \t    /* Function declaration not at file scope.  Storage\n@@ -4533,10 +4536,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (storage_class == csc_auto)\n \t      {\n \t\tif (pedantic)\n-\t\t  pedwarn (\"invalid storage class for function `%s'\", name);\n+\t\t  pedwarn (\"invalid storage class for function %qs\", name);\n \t      }\n \t    if (storage_class == csc_static)\n-\t      error (\"invalid storage class for function `%s'\", name);\n+\t      error (\"invalid storage class for function %qs\", name);\n \t  }\n \n \tdecl = build_decl (FUNCTION_DECL, declarator->u.id, type);\n@@ -4551,7 +4554,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t   that the function does not return.  */\n \tif ((type_quals & TYPE_QUAL_VOLATILE)\n \t    && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n-\t  warning (\"`noreturn' function returns non-void value\");\n+\t  warning (\"%<noreturn%> function returns non-void value\");\n \n \t/* Every function declaration is an external reference\n \t   (DECL_EXTERNAL) except for those which are not at file\n@@ -4579,7 +4582,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tif (MAIN_NAME_P (declarator->u.id))\n \t  {\n \t    if (declspecs->inline_p)\n-\t      warning (\"cannot inline function `main'\");\n+\t      warning (\"cannot inline function %<main%>\");\n \t  }\n \telse if (declspecs->inline_p)\n \t  {\n@@ -4636,16 +4639,16 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t&& global_decl != visible_decl\n \t\t&& TREE_CODE (global_decl) == VAR_DECL\n \t\t&& !TREE_PUBLIC (global_decl))\n-\t      error (\"variable previously declared 'static' redeclared \"\n-\t\t     \"'extern'\");\n+\t      error (\"variable previously declared %<static%> redeclared \"\n+\t\t     \"%<extern%>\");\n \t  }\n \n \tdecl = build_decl (VAR_DECL, declarator->u.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (declspecs->inline_p)\n-\t  pedwarn (\"%Jvariable '%D' declared `inline'\", decl, decl);\n+\t  pedwarn (\"%Jvariable %qD declared %<inline%>\", decl, decl);\n \n \t/* At file scope, an initialized extern declaration may follow\n \t   a static declaration.  In that case, DECL_EXTERNAL will be\n@@ -4738,7 +4741,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \n   if (warn_strict_prototypes && arg_types == 0 && !funcdef_flag\n       && !in_system_header)\n-    warning (\"function declaration isn't a prototype\");\n+    warning (\"function declaration isn%'t a prototype\");\n \n   if (arg_types == error_mark_node)\n     return 0;  /* don't set TYPE_ARG_TYPES in this case */\n@@ -4775,7 +4778,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \t      if (funcdef_flag)\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    error (\"%Jparameter %u ('%D') has incomplete type\",\n+\t\t    error (\"%Jparameter %u (%qD) has incomplete type\",\n \t\t\t   parm, parmno, parm);\n \t\t  else\n \t\t    error (\"%Jparameter %u has incomplete type\",\n@@ -4787,7 +4790,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \t      else\n \t\t{\n \t\t  if (DECL_NAME (parm))\n-\t\t    warning (\"%Jparameter %u ('%D') has incomplete type\",\n+\t\t    warning (\"%Jparameter %u (%qD) has incomplete type\",\n \t\t\t     parm, parmno, parm);\n \t\t  else\n \t\t    warning (\"%Jparameter %u has incomplete type\",\n@@ -4847,11 +4850,11 @@ get_parm_info (bool ellipsis)\n       if (TREE_THIS_VOLATILE (b->decl)\n \t  || TREE_READONLY (b->decl)\n \t  || C_DECL_REGISTER (b->decl))\n-\terror (\"'void' as only parameter may not be qualified\");\n+\terror (\"%<void%> as only parameter may not be qualified\");\n \n       /* There cannot be an ellipsis.  */\n       if (ellipsis)\n-\terror (\"'void' must be the only parameter\");\n+\terror (\"%<void%> must be the only parameter\");\n \n       arg_info->types = void_list_node;\n       return arg_info;\n@@ -4879,14 +4882,14 @@ get_parm_info (bool ellipsis)\n \n \t  /* Check for forward decls that never got their actual decl.  */\n \t  if (TREE_ASM_WRITTEN (decl))\n-\t    error (\"%Jparameter '%D' has just a forward declaration\",\n+\t    error (\"%Jparameter %qD has just a forward declaration\",\n \t\t   decl, decl);\n \t  /* Check for (..., void, ...) and issue an error.  */\n \t  else if (VOID_TYPE_P (type) && !DECL_NAME (decl))\n \t    {\n \t      if (!gave_void_only_once_err)\n \t\t{\n-\t\t  error (\"'void' must be the only parameter\");\n+\t\t  error (\"%<void%> must be the only parameter\");\n \t\t  gave_void_only_once_err = true;\n \t\t}\n \t    }\n@@ -4925,7 +4928,7 @@ get_parm_info (bool ellipsis)\n \t    {\n \t      if (b->id)\n \t\t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n-\t\twarning (\"'%s %E' declared inside parameter list\",\n+\t\twarning (\"%<%s %E%> declared inside parameter list\",\n \t\t\t keyword, b->id);\n \t      else\n \t\t/* The %s will be one of 'struct', 'union', or 'enum'.  */\n@@ -5048,9 +5051,9 @@ start_struct (enum tree_code code, tree name)\n       if (TYPE_FIELDS (ref))\n         {\n \t  if (code == UNION_TYPE)\n-\t    error (\"redefinition of `union %s'\", IDENTIFIER_POINTER (name));\n+\t    error (\"redefinition of %<union %s%>\", IDENTIFIER_POINTER (name));\n           else\n-\t    error (\"redefinition of `struct %s'\", IDENTIFIER_POINTER (name));\n+\t    error (\"redefinition of %<struct %s%>\", IDENTIFIER_POINTER (name));\n \t}\n     }\n   else\n@@ -5166,7 +5169,7 @@ detect_field_duplicates (tree fieldlist)\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n \t      if (DECL_NAME (y) == DECL_NAME (x))\n \t\t{\n-\t\t  error (\"%Jduplicate member '%D'\", x, x);\n+\t\t  error (\"%Jduplicate member %qD\", x, x);\n \t\t  DECL_NAME (x) = NULL_TREE;\n \t\t}\n \t  }\n@@ -5182,7 +5185,7 @@ detect_field_duplicates (tree fieldlist)\n \t    slot = htab_find_slot (htab, y, INSERT);\n \t    if (*slot)\n \t      {\n-\t\terror (\"%Jduplicate member '%D'\", x, x);\n+\t\terror (\"%Jduplicate member %qD\", x, x);\n \t\tDECL_NAME (x) = NULL_TREE;\n \t      }\n \t    *slot = y;\n@@ -5260,7 +5263,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n       /* Detect invalid nested redefinition.  */\n       if (TREE_TYPE (x) == t)\n-\terror (\"nested redefinition of `%s'\",\n+\terror (\"nested redefinition of %qs\",\n \t       IDENTIFIER_POINTER (TYPE_NAME (t)));\n \n       if (DECL_INITIAL (x))\n@@ -5470,7 +5473,7 @@ start_enum (tree name)\n   if (TYPE_VALUES (enumtype) != 0)\n     {\n       /* This enum is a named one that has been declared already.  */\n-      error (\"redeclaration of `enum %s'\", IDENTIFIER_POINTER (name));\n+      error (\"redeclaration of %<enum %s%>\", IDENTIFIER_POINTER (name));\n \n       /* Completely replace its old definition.\n \t The old enumerators remain defined, however.  */\n@@ -5649,7 +5652,7 @@ build_enumerator (tree name, tree value)\n \tvalue = 0;\n       else if (TREE_CODE (value) != INTEGER_CST)\n \t{\n-\t  error (\"enumerator value for '%E' is not an integer constant\", name);\n+\t  error (\"enumerator value for %qE is not an integer constant\", name);\n \t  value = 0;\n \t}\n       else\n@@ -5671,7 +5674,7 @@ build_enumerator (tree name, tree value)\n \n   if (pedantic && ! int_fits_type_p (value, integer_type_node))\n     {\n-      pedwarn (\"ISO C restricts enumerator values to range of `int'\");\n+      pedwarn (\"ISO C restricts enumerator values to range of %<int%>\");\n       /* XXX This causes -pedantic to change the meaning of the program.\n \t Remove?  -zw 2004-03-15  */\n       value = convert (integer_type_node, value);\n@@ -5741,7 +5744,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n-    warning (\"%Jinline function '%D' given attribute noinline\", decl1, decl1);\n+    warning (\"%Jinline function %qD given attribute noinline\", decl1, decl1);\n \n   announce_function (decl1);\n \n@@ -5755,7 +5758,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     }\n \n   if (warn_about_return_type)\n-    pedwarn_c99 (\"return type defaults to `int'\");\n+    pedwarn_c99 (\"return type defaults to %<int%>\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in pop_scope) with the BLOCK.  */\n@@ -5780,32 +5783,32 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   if (warn_strict_prototypes\n       && TYPE_ARG_TYPES (TREE_TYPE (decl1)) == 0\n       && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (\"function declaration isn't a prototype\");\n+    warning (\"function declaration isn%'t a prototype\");\n   /* Optionally warn of any global def with no previous prototype.  */\n   else if (warn_missing_prototypes\n \t   && TREE_PUBLIC (decl1)\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (\"%Jno previous prototype for '%D'\", decl1, decl1);\n+    warning (\"%Jno previous prototype for %qD\", decl1, decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n-    warning (\"%J'%D' was used with no prototype before its definition\",\n+    warning (\"%J%qD was used with no prototype before its definition\",\n \t     decl1, decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning (\"%Jno previous declaration for '%D'\", decl1, decl1);\n+    warning (\"%Jno previous declaration for %qD\", decl1, decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n-    warning (\"%J`%D' was used with no declaration before its definition\",\n+    warning (\"%J%qD was used with no declaration before its definition\",\n \t     decl1, decl1);\n \n   /* This is a definition, not a reference.\n@@ -5838,7 +5841,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (\"%Jreturn type of '%D' is not `int'\", decl1, decl1);\n+\tpedwarn (\"%Jreturn type of %qD is not %<int%>\", decl1, decl1);\n \n       for (args = TYPE_ARG_TYPES (TREE_TYPE (decl1)); args;\n \t   args = TREE_CHAIN (args))\n@@ -5853,7 +5856,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t    {\n \t    case 1:\n \t      if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-\t\tpedwarn (\"%Jfirst argument of '%D' should be `int'\",\n+\t\tpedwarn (\"%Jfirst argument of %qD should be %<int%>\",\n \t\t\t decl1, decl1);\n \t      break;\n \n@@ -5862,7 +5865,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Jsecond argument of '%D' should be 'char **'\",\n+\t\tpedwarn (\"%Jsecond argument of %qD should be %<char **%>\",\n                          decl1, decl1);\n \t      break;\n \n@@ -5871,8 +5874,8 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Jthird argument of '%D' should probably be \"\n-                         \"'char **'\", decl1, decl1);\n+\t\tpedwarn (\"%Jthird argument of %qD should probably be \"\n+                         \"%<char **%>\", decl1, decl1);\n \t      break;\n \t    }\n \t}\n@@ -5881,10 +5884,10 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t argument because it's only mentioned in an appendix of the\n \t standard.  */\n       if (argct > 0 && (argct < 2 || argct > 3))\n-\tpedwarn (\"%J'%D' takes only zero or two arguments\", decl1, decl1);\n+\tpedwarn (\"%J%qD takes only zero or two arguments\", decl1, decl1);\n \n       if (! TREE_PUBLIC (decl1))\n-\tpedwarn (\"%J'%D' is normally a non-static function\", decl1, decl1);\n+\tpedwarn (\"%J%qD is normally a non-static function\", decl1, decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -6014,20 +6017,20 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  decl = b->decl;\n \t  /* If we got something other than a PARM_DECL it is an error.  */\n \t  if (TREE_CODE (decl) != PARM_DECL)\n-\t    error (\"%J'%D' declared as a non-parameter\", decl, decl);\n+\t    error (\"%J%qD declared as a non-parameter\", decl, decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n \t  else if (DECL_WEAK (decl))\n \t    {\n-\t      error (\"%Jmultiple parameters named '%D'\", decl, decl);\n+\t      error (\"%Jmultiple parameters named %qD\", decl, decl);\n \t      TREE_PURPOSE (parm) = 0;\n \t      continue;\n \t    }\n \t  /* If the declaration says \"void\", complain and turn it into\n \t     an int.  */\n \t  else if (VOID_TYPE_P (TREE_TYPE (decl)))\n \t    {\n-\t      error (\"%Jparameter '%D' declared with void type\", decl, decl);\n+\t      error (\"%Jparameter %qD declared with void type\", decl, decl);\n \t      TREE_TYPE (decl) = integer_type_node;\n \t      DECL_ARG_TYPE (decl) = integer_type_node;\n \t      layout_decl (decl, 0);\n@@ -6042,9 +6045,9 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  pushdecl (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (\"%Jtype of '%D' defaults to 'int'\", decl, decl);\n+\t    pedwarn (\"%Jtype of %qD defaults to %<int%>\", decl, decl);\n \t  else if (extra_warnings)\n-\t    warning (\"%Jtype of '%D' defaults to 'int'\", decl, decl);\n+\t    warning (\"%Jtype of %qD defaults to %<int%>\", decl, decl);\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n@@ -6062,13 +6065,13 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \n       if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n-\t  error (\"%Jparameter '%D' has incomplete type\", parm, parm);\n+\t  error (\"%Jparameter %qD has incomplete type\", parm, parm);\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n       if (! DECL_WEAK (parm))\n \t{\n-\t  error (\"%Jdeclaration for parameter '%D' but no such parameter\",\n+\t  error (\"%Jdeclaration for parameter %qD but no such parameter\",\n \t\t parm, parm);\n \n \t  /* Pretend the parameter was not missing.\n@@ -6118,7 +6121,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  if (parm == 0 || type == 0\n \t      || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t    {\n-\t      error (\"number of arguments doesn't match prototype\");\n+\t      error (\"number of arguments doesn%'t match prototype\");\n \t      error (\"%Hprototype declaration\",\n \t\t     &current_function_prototype_locus);\n \t      break;\n@@ -6147,15 +6150,15 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \n \t\t  if (pedantic)\n \t\t    {\n-\t\t      pedwarn (\"promoted argument '%D' \"\n-\t\t\t       \"doesn't match prototype\", parm);\n+\t\t      pedwarn (\"promoted argument %qD \"\n+\t\t\t       \"doesn%'t match prototype\", parm);\n \t\t      pedwarn (\"%Hprototype declaration\",\n \t\t\t       &current_function_prototype_locus);\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  error (\"argument '%D' doesn't match prototype\", parm);\n+\t\t  error (\"argument %qD doesn%'t match prototype\", parm);\n \t\t  error (\"%Hprototype declaration\",\n \t\t\t &current_function_prototype_locus);\n \t\t}\n@@ -6335,7 +6338,7 @@ finish_function (void)\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n \t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n \t  if (!warn_main)\n-\t    pedwarn (\"%Jreturn type of '%D' is not `int'\", fndecl, fndecl);\n+\t    pedwarn (\"%Jreturn type of %qD is not %<int%>\", fndecl, fndecl);\n \t}\n       else\n \t{\n@@ -6449,7 +6452,7 @@ check_for_loop_decls (void)\n       /* If we get here, declarations have been used in a for loop without\n \t the C99 for loop scope.  This doesn't make much sense, so don't\n \t allow it.  */\n-      error (\"'for' loop initial declaration used outside C99 mode\");\n+      error (\"%<for%> loop initial declaration used outside C99 mode\");\n       return;\n     }\n   /* C99 subclause 6.8.5 paragraph 3:\n@@ -6478,24 +6481,27 @@ check_for_loop_decls (void)\n \t{\n \tcase VAR_DECL:\n \t  if (TREE_STATIC (decl))\n-\t    error (\"%Jdeclaration of static variable '%D' in 'for' loop \"\n+\t    error (\"%Jdeclaration of static variable %qD in %<for%> loop \"\n \t\t   \"initial declaration\", decl, decl);\n \t  else if (DECL_EXTERNAL (decl))\n-\t    error (\"%Jdeclaration of 'extern' variable '%D' in 'for' loop \"\n+\t    error (\"%Jdeclaration of %<extern%> variable %qD in %<for%> loop \"\n \t\t   \"initial declaration\", decl, decl);\n \t  break;\n \n \tcase RECORD_TYPE:\n-\t  error (\"'struct %E' declared in 'for' loop initial declaration\", id);\n+\t  error (\"%<struct %E%> declared in %<for%> loop initial declaration\",\n+\t\t id);\n \t  break;\n \tcase UNION_TYPE:\n-\t  error (\"'union %E' declared in 'for' loop initial declaration\", id);\n+\t  error (\"%<union %E%> declared in %<for%> loop initial declaration\",\n+\t\t id);\n \t  break;\n \tcase ENUMERAL_TYPE:\n-\t  error (\"'enum %E' declared in 'for' loop initial declaration\", id);\n+\t  error (\"%<enum %E%> declared in %<for%> loop initial declaration\",\n+\t\t id);\n \t  break;\n \tdefault:\n-\t  error (\"%Jdeclaration of non-variable '%D' in 'for' loop \"\n+\t  error (\"%Jdeclaration of non-variable %qD in %<for%> loop \"\n \t\t \"initial declaration\", decl, decl);\n \t}\n     }\n@@ -6968,7 +6974,7 @@ c_write_global_declarations_1 (tree globals)\n \t  && !TREE_PUBLIC (decl)\n \t  && C_DECL_USED (decl))\n \t{\n-\t  pedwarn (\"%J%<%F%> used but never defined\", decl, decl);\n+\t  pedwarn (\"%J%qF used but never defined\", decl, decl);\n \t  TREE_NO_WARNING (decl) = 1;\n \t}\n     }"}, {"sha": "d8eaddf015faa2f61f2f3288e01f687ec0720a5e", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -584,7 +584,7 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n   if (itk > itk_unsigned_long\n       && (flags & CPP_N_WIDTH) != CPP_N_LARGE\n       && ! in_system_header && ! flag_isoc99)\n-    pedwarn (\"integer constant is too large for \\\"%s\\\" type\",\n+    pedwarn (\"integer constant is too large for %qs type\",\n \t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n   value = build_int_cst_wide (type, integer.low, integer.high);\n@@ -650,7 +650,7 @@ interpret_float (const cpp_token *token, unsigned int flags)\n      ??? That's a dubious reason... is this a mandatory diagnostic or\n      isn't it?   -- zw, 2001-08-21.  */\n   if (REAL_VALUE_ISINF (real) && pedantic)\n-    warning (\"floating constant exceeds range of \\\"%s\\\"\", type_name);\n+    warning (\"floating constant exceeds range of %<%s%>\", type_name);\n \n   /* Create a node with determined type and value.  */\n   value = build_real (type, real);"}, {"sha": "d59aed10bebdca9faea4b2b93d86ea3427c31190", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -78,7 +78,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n     {\n       if (do_warning)\n-\twarning (\"%Jfunction '%F' can never be inlined because it \"\n+\twarning (\"%Jfunction %qF can never be inlined because it \"\n \t\t \"is suppressed using -fno-inline\", fn, fn);\n       goto cannot_inline;\n     }\n@@ -88,15 +88,15 @@ c_cannot_inline_tree_fn (tree *fnp)\n   if (!DECL_DECLARED_INLINE_P (fn) && !targetm.binds_local_p (fn))\n     {\n       if (do_warning)\n-\twarning (\"%Jfunction '%F' can never be inlined because it might not \"\n+\twarning (\"%Jfunction %qF can never be inlined because it might not \"\n \t\t \"be bound within this unit of translation\", fn, fn);\n       goto cannot_inline;\n     }\n \n   if (! function_attribute_inlinable_p (fn))\n     {\n       if (do_warning)\n-\twarning (\"%Jfunction '%F' can never be inlined because it uses \"\n+\twarning (\"%Jfunction %qF can never be inlined because it uses \"\n \t\t \"attributes conflicting with inlining\", fn, fn);\n       goto cannot_inline;\n     }\n@@ -111,7 +111,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n       if (t)\n \t{\n \t  if (do_warning)\n-\t    warning (\"%Jfunction '%F' can never be inlined because it has \"\n+\t    warning (\"%Jfunction %qF can never be inlined because it has \"\n \t\t     \"pending sizes\", fn, fn);\n \t  goto cannot_inline;\n \t}\n@@ -124,7 +124,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n       if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n \t{\n \t  if (do_warning)\n-\t    warning (\"%Jnested function '%F' can never be inlined because it \"\n+\t    warning (\"%Jnested function %qF can never be inlined because it \"\n \t\t     \"has possibly saved pending sizes\", fn, fn);\n \t  goto cannot_inline;\n \t}"}, {"sha": "c199c48213bc47d3d1a6e3bc213c4dc9e825dad8", "filename": "gcc/c-opts.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -144,16 +144,16 @@ c_common_missing_argument (const char *opt, size_t code)\n       return false;\n \n     case OPT_fconstant_string_class_:\n-      error (\"no class name specified with \\\"%s\\\"\", opt);\n+      error (\"no class name specified with %qs\", opt);\n       break;\n \n     case OPT_A:\n-      error (\"assertion missing after \\\"%s\\\"\", opt);\n+      error (\"assertion missing after %qs\", opt);\n       break;\n \n     case OPT_D:\n     case OPT_U:\n-      error (\"macro name missing after \\\"%s\\\"\", opt);\n+      error (\"macro name missing after %qs\", opt);\n       break;\n \n     case OPT_F:\n@@ -162,7 +162,7 @@ c_common_missing_argument (const char *opt, size_t code)\n     case OPT_isysroot:\n     case OPT_isystem:\n     case OPT_iquote:\n-      error (\"missing path after \\\"%s\\\"\", opt);\n+      error (\"missing path after %qs\", opt);\n       break;\n \n     case OPT_MF:\n@@ -171,12 +171,12 @@ c_common_missing_argument (const char *opt, size_t code)\n     case OPT_include:\n     case OPT_imacros:\n     case OPT_o:\n-      error (\"missing filename after \\\"%s\\\"\", opt);\n+      error (\"missing filename after %qs\", opt);\n       break;\n \n     case OPT_MQ:\n     case OPT_MT:\n-      error (\"missing makefile target after \\\"%s\\\"\", opt);\n+      error (\"missing makefile target after %qs\", opt);\n       break;\n     }\n \n@@ -539,7 +539,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n     case OPT_fvtable_thunks:\n     case OPT_fxref:\n     case OPT_fvtable_gc:\n-      warning (\"switch \\\"%s\\\" is no longer supported\", option->opt_text);\n+      warning (\"switch %qs is no longer supported\", option->opt_text);\n       break;\n \n     case OPT_faccess_control:"}, {"sha": "4fefa1bc09e796b71da2730cfc6ca5b4902be1b9", "filename": "gcc/c-parse.in", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -425,7 +425,7 @@ datadef:\n \t| error '}'\n \t| ';'\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"ISO C does not allow extra `;' outside of a function\"); }\n+\t\t    pedwarn (\"ISO C does not allow extra %<;%> outside of a function\"); }\n \t;\n \f\n fndef:\n@@ -541,7 +541,7 @@ unary_expr:\n \t\t  in_sizeof--;\n \t\t  if (TREE_CODE ($2.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($2.value, 1)))\n-\t\t    error (\"`sizeof' applied to a bit-field\");\n+\t\t    error (\"%<sizeof%> applied to a bit-field\");\n \t\t  $$ = c_expr_sizeof_expr ($2); }\n \t| sizeof '(' typename ')'  %prec HYPERUNARY\n \t\t{ skip_evaluation--;\n@@ -1286,7 +1286,7 @@ typespec_nonreserved_nonattr:\n \t\t  in_typeof--;\n \t\t  if (TREE_CODE ($3.value) == COMPONENT_REF\n \t\t      && DECL_C_BIT_FIELD (TREE_OPERAND ($3.value, 1)))\n-\t\t    error (\"`typeof' applied to a bit-field\");\n+\t\t    error (\"%<typeof%> applied to a bit-field\");\n \t\t  $$ = TREE_TYPE ($3.value);\n \t\t  pop_maybe_used (variably_modified_type_p ($$, NULL_TREE)); }\n \t| typeof '(' typename ')'\n@@ -1431,11 +1431,11 @@ initelt:\n \t\t    pedwarn (\"ISO C90 forbids specifying subobject to initialize\"); }\n \t| designator initval\n \t\t{ if (pedantic)\n-\t\t    pedwarn (\"obsolete use of designated initializer without `='\"); }\n+\t\t    pedwarn (\"obsolete use of designated initializer without %<=%>\"); }\n \t| identifier ':'\n \t\t{ set_init_label ($1);\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"obsolete use of designated initializer with `:'\"); }\n+\t\t    pedwarn (\"obsolete use of designated initializer with %<:%>\"); }\n \t  initval\n \t\t{}\n \t| initval\n@@ -1675,7 +1675,7 @@ structsp_nonattr:\n \t\t  /* In ISO C, enumerated types can be referred to\n \t\t     only if already defined.  */\n \t\t  if (pedantic && !COMPLETE_TYPE_P ($$))\n-\t\t    pedwarn (\"ISO C forbids forward references to `enum' types\"); }\n+\t\t    pedwarn (\"ISO C forbids forward references to %<enum%> types\"); }\n \t;\n \n maybecomma:\n@@ -2448,7 +2448,7 @@ parmlist_2:  /* empty */\n \t\t  $$->others = 0;\n \t\t  /* Suppress -Wold-style-definition for this case.  */\n \t\t  $$->types = error_mark_node;\n-\t\t  error (\"ISO C requires a named argument before `...'\");\n+\t\t  error (\"ISO C requires a named argument before %<...%>\");\n \t\t}\n \t| parms\n \t\t{ $$ = get_parm_info (/*ellipsis=*/false); }\n@@ -3480,7 +3480,7 @@ _yylex (void)\n       /* These tokens should not survive translation phase 4.  */\n     case CPP_HASH:\n     case CPP_PASTE:\n-      error (\"syntax error at '%s' token\", NAME(last_token));\n+      error (\"syntax error at %qs token\", NAME(last_token));\n       goto get_next;\n \n     default:\n@@ -3518,7 +3518,7 @@ yyprint (FILE *file, int yychar, YYSTYPE yyl)\n     case SCSPEC:\n     case STATIC:\n       if (IDENTIFIER_POINTER (t))\n-\tfprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n+\tfprintf (file, \" '%s'\", IDENTIFIER_POINTER (t));\n       break;\n \n     case CONSTANT:"}, {"sha": "0b169cf5bd1b89b6b40f94aaf1ef31d70abfe2f4", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -145,7 +145,7 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n   enum { set, push, pop } action;\n \n   if (c_lex (&x) != CPP_OPEN_PAREN)\n-    GCC_BAD (\"missing '(' after '#pragma pack' - ignored\");\n+    GCC_BAD (\"missing %<(%> after %<#pragma pack%> - ignored\");\n \n   token = c_lex (&x);\n   if (token == CPP_CLOSE_PAREN)\n@@ -158,14 +158,14 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n       align = TREE_INT_CST_LOW (x);\n       action = set;\n       if (c_lex (&x) != CPP_CLOSE_PAREN)\n-\tGCC_BAD (\"malformed '#pragma pack' - ignored\");\n+\tGCC_BAD (\"malformed %<#pragma pack%> - ignored\");\n     }\n   else if (token == CPP_NAME)\n     {\n #define GCC_BAD_ACTION do { if (action != pop) \\\n-\t  GCC_BAD (\"malformed '#pragma pack(push[, id][, <n>])' - ignored\"); \\\n+\t  GCC_BAD (\"malformed %<#pragma pack(push[, id][, <n>])%> - ignored\"); \\\n \telse \\\n-\t  GCC_BAD (\"malformed '#pragma pack(pop[, id])' - ignored\"); \\\n+\t  GCC_BAD (\"malformed %<#pragma pack(pop[, id])%> - ignored\"); \\\n \t} while (0)\n \n       const char *op = IDENTIFIER_POINTER (x);\n@@ -174,7 +174,7 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n       else if (!strcmp (op, \"pop\"))\n \taction = pop;\n       else\n-\tGCC_BAD2 (\"unknown action '%s' for '#pragma pack' - ignored\", op);\n+\tGCC_BAD2 (\"unknown action %qs for %<#pragma pack%> - ignored\", op);\n \n       while ((token = c_lex (&x)) == CPP_COMMA)\n \t{\n@@ -198,10 +198,10 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n #undef GCC_BAD_ACTION\n     }\n   else\n-    GCC_BAD (\"malformed '#pragma pack' - ignored\");\n+    GCC_BAD (\"malformed %<#pragma pack%> - ignored\");\n \n   if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of '#pragma pack'\");\n+    warning (\"junk at end of %<#pragma pack%>\");\n \n   if (flag_pack_struct)\n     GCC_BAD (\"#pragma pack has no effect with -fpack-struct - ignored\");\n@@ -257,7 +257,7 @@ apply_pragma_weak (tree decl, tree value)\n   if (SUPPORTS_WEAK && DECL_EXTERNAL (decl) && TREE_USED (decl)\n       && !DECL_WEAK (decl) /* Don't complain about a redundant #pragma.  */\n       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    warning (\"%Japplying #pragma weak '%D' after first use results \"\n+    warning (\"%Japplying #pragma weak %qD after first use results \"\n              \"in unspecified behavior\", decl, decl);\n \n   declare_weak (decl);\n@@ -578,7 +578,7 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n         {\n           if (!visidx)\n             {\n-              GCC_BAD (\"No matching push for '#pragma GCC visibility pop'\");\n+              GCC_BAD (\"No matching push for %<#pragma GCC visibility pop%>\");\n             }\n           else\n             {\n@@ -589,7 +589,7 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n       else\n         {\n           if (c_lex (&x) != CPP_OPEN_PAREN)\n-            GCC_BAD (\"missing '(' after '#pragma GCC visibility push' - ignored\");\n+            GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n           token = c_lex (&x);\n           if (token != CPP_NAME)\n             {\n@@ -618,11 +618,11 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n               visibility_options.inpragma = 1;\n             }\n           if (c_lex (&x) != CPP_CLOSE_PAREN)\n-            GCC_BAD (\"missing '(' after '#pragma GCC visibility push' - ignored\");\n+            GCC_BAD (\"missing '(' after %<#pragma GCC visibility push%> - ignored\");\n         }\n     }\n   if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of '#pragma GCC visibility'\");\n+    warning (\"junk at end of %<#pragma GCC visibility%>\");\n }\n \n #endif"}, {"sha": "f86017547919a7d6576d582769fc2545d50be7d2", "filename": "gcc/c-tree.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -413,8 +413,6 @@ extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n extern void process_init_element (struct c_expr);\n extern tree build_compound_literal (tree, tree);\n-extern void pedwarn_c90 (const char *, ...) ATTRIBUTE_PRINTF_1;\n-extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_PRINTF_1;\n extern tree c_start_case (tree);\n extern void c_finish_case (tree);\n extern tree build_asm_expr (tree, tree, tree, tree, bool);\n@@ -469,5 +467,13 @@ extern void c_write_global_declarations (void);\n    diagnostic framework extensions, you must include this file before\n    toplev.h, not after.  */\n #define GCC_DIAG_STYLE __gcc_cdiag__\n+#if GCC_VERSION >= 3005\n+#define ATTRIBUTE_GCC_CDIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m ,n))) ATTRIBUTE_NONNULL(m)\n+#else\n+#define ATTRIBUTE_GCC_CDIAG(m, n) ATTRIBUTE_NONNULL(m)\n+#endif\n+\n+extern void pedwarn_c90 (const char *, ...) ATTRIBUTE_GCC_CDIAG(1,2);\n+extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_GCC_CDIAG(1,2);\n \n #endif /* ! GCC_C_TREE_H */"}, {"sha": "dd842852cc7ae1546024ad6ecb677c94b3427d0b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -125,7 +125,7 @@ c_incomplete_type_error (tree value, tree type)\n \n   if (value != 0 && (TREE_CODE (value) == VAR_DECL\n \t\t     || TREE_CODE (value) == PARM_DECL))\n-    error (\"`%s' has an incomplete type\",\n+    error (\"%qs has an incomplete type\",\n \t   IDENTIFIER_POINTER (DECL_NAME (value)));\n   else\n     {\n@@ -169,11 +169,11 @@ c_incomplete_type_error (tree value, tree type)\n \t}\n \n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n-\terror (\"invalid use of undefined type `%s %s'\",\n+\terror (\"invalid use of undefined type %<%s %s%>\",\n \t       type_code_string, IDENTIFIER_POINTER (TYPE_NAME (type)));\n       else\n \t/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */\n-\terror (\"invalid use of incomplete typedef `%s'\",\n+\terror (\"invalid use of incomplete typedef %qs\",\n \t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n     }\n }\n@@ -964,7 +964,7 @@ function_types_compatible_p (tree f1, tree f2)\n   /* 'volatile' qualifiers on a function's return type used to mean\n      the function is noreturn.  */\n   if (TYPE_VOLATILE (ret1) != TYPE_VOLATILE (ret2))\n-    pedwarn (\"function return types not compatible due to `volatile'\");\n+    pedwarn (\"function return types not compatible due to %<volatile%>\");\n   if (TYPE_VOLATILE (ret1))\n     ret1 = build_qualified_type (TYPE_MAIN_VARIANT (ret1),\n \t\t\t\t TYPE_QUALS (ret1) & ~TYPE_QUAL_VOLATILE);\n@@ -1480,7 +1480,7 @@ build_component_ref (tree datum, tree component)\n \n       if (!field)\n \t{\n-\t  error (\"%s has no member named `%s'\",\n+\t  error (\"%s has no member named %qs\",\n \t\t code == RECORD_TYPE ? \"structure\" : \"union\",\n \t\t IDENTIFIER_POINTER (component));\n \t  return error_mark_node;\n@@ -1517,7 +1517,7 @@ build_component_ref (tree datum, tree component)\n       return ref;\n     }\n   else if (code != ERROR_MARK)\n-    error (\"request for member `%s' in something not a structure or union\",\n+    error (\"request for member %qs in something not a structure or union\",\n \t    IDENTIFIER_POINTER (component));\n \n   return error_mark_node;\n@@ -1550,7 +1550,7 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t      return error_mark_node;\n \t    }\n \t  if (VOID_TYPE_P (t) && skip_evaluation == 0)\n-\t    warning (\"dereferencing `void *' pointer\");\n+\t    warning (\"dereferencing %<void *%> pointer\");\n \n \t  /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t     so that we get the proper error message if the result is used\n@@ -1567,7 +1567,7 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t}\n     }\n   else if (TREE_CODE (pointer) != ERROR_MARK)\n-    error (\"invalid type argument of `%s'\", errorstring);\n+    error (\"invalid type argument of %qs\", errorstring);\n   return error_mark_node;\n }\n \n@@ -1605,7 +1605,7 @@ build_array_ref (tree array, tree index)\n \t must have done so deliberately.  */\n       if (warn_char_subscripts\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node)\n-\twarning (\"array subscript has type `char'\");\n+\twarning (\"array subscript has type %<char%>\");\n \n       /* Apply default promotions *after* noticing character types.  */\n       index = default_conversion (index);\n@@ -1646,7 +1646,7 @@ build_array_ref (tree array, tree index)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n-\t    pedwarn (\"ISO C forbids subscripting `register' array\");\n+\t    pedwarn (\"ISO C forbids subscripting %<register%> array\");\n \t  else if (! flag_isoc99 && ! lvalue_p (foo))\n \t    pedwarn (\"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n@@ -1681,7 +1681,7 @@ build_array_ref (tree array, tree index)\n     if (warn_char_subscripts\n \t&& TREE_CODE (TREE_TYPE (index)) == INTEGER_TYPE\n \t&& TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node)\n-      warning (\"subscript has type `char'\");\n+      warning (\"subscript has type %<char%>\");\n \n     /* Put the integer in IND to simplify error checking.  */\n     if (TREE_CODE (TREE_TYPE (ar)) == INTEGER_TYPE)\n@@ -1727,7 +1727,7 @@ build_external_ref (tree id, int fun)\n \tref = decl;\n       else if (decl != objc_ivar && !DECL_FILE_SCOPE_P (decl))\n \t{\n-\t  warning (\"local declaration of `%s' hides instance variable\",\n+\t  warning (\"local declaration of %qs hides instance variable\",\n \t\t   IDENTIFIER_POINTER (id));\n \t  ref = decl;\n \t}\n@@ -2035,7 +2035,7 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n       if (type == void_type_node)\n \t{\n \t  if (name)\n-\t    error (\"too many arguments to function `%s'\",\n+\t    error (\"too many arguments to function %qs\",\n \t\t   IDENTIFIER_POINTER (name));\n \t  else\n \t    error (\"too many arguments to function\");\n@@ -2097,7 +2097,9 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n \t\t      /* Warn if any argument is passed as `float',\n \t\t\t since without a prototype it would be `double'.  */\n \t\t      if (formal_prec == TYPE_PRECISION (float_type_node))\n-\t\t\twarn_for_assignment (\"%s as `float' rather than `double' due to prototype\", (char *) 0, name, parmnum + 1);\n+\t\t\twarn_for_assignment (\"%s as %<float%> rather than \"\n+\t\t\t\t\t     \"%<double%> due to prototype\",\n+\t\t\t\t\t     (char *) 0, name, parmnum + 1);\n \t\t    }\n \t\t  /* Detect integer changing in width or signedness.\n \t\t     These warnings are only activated with\n@@ -2174,7 +2176,7 @@ convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n       if (name)\n-\terror (\"too few arguments to function `%s'\",\n+\terror (\"too few arguments to function %qs\",\n \t       IDENTIFIER_POINTER (name));\n       else\n \terror (\"too few arguments to function\");\n@@ -2285,7 +2287,7 @@ pointer_diff (tree op0, tree op1)\n   if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n-\tpedwarn (\"pointer of type `void *' used in subtraction\");\n+\tpedwarn (\"pointer of type %<void *%> used in subtraction\");\n       if (TREE_CODE (target_type) == FUNCTION_TYPE)\n \tpedwarn (\"pointer to a function used in subtraction\");\n     }\n@@ -2406,7 +2408,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t{\n \t  code = CONJ_EXPR;\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support `~' for complex conjugation\");\n+\t    pedwarn (\"ISO C does not support %<~%> for complex conjugation\");\n \t  if (!noconvert)\n \t    arg = default_conversion (arg);\n \t}\n@@ -2483,7 +2485,8 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  tree real, imag;\n \n \t  if (pedantic)\n-\t    pedwarn (\"ISO C does not support `++' and `--' on complex types\");\n+\t    pedwarn (\"ISO C does not support %<++%> and %<--%>\"\n+\t\t     \" on complex types\");\n \n \t  arg = stabilize_reference (arg);\n \t  real = build_unary_op (REALPART_EXPR, arg, 1);\n@@ -2591,7 +2594,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       /* Anything not already handled and not a true memory reference\n \t or a non-lvalue array is an error.  */\n       else if (typecode != FUNCTION_TYPE && !flag\n-\t       && !lvalue_or_else (arg, \"invalid lvalue in unary `&'\"))\n+\t       && !lvalue_or_else (arg, \"invalid lvalue in unary %<&%>\"))\n \treturn error_mark_node;\n \n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n@@ -2613,7 +2616,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       if (TREE_CODE (arg) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t{\n-\t  error (\"attempt to take address of bit-field structure member `%D'\",\n+\t  error (\"attempt to take address of bit-field structure member %qD\",\n \t\t TREE_OPERAND (arg, 1));\n \t  return error_mark_node;\n \t}\n@@ -2706,11 +2709,11 @@ readonly_error (tree arg, const char *msgid)\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n \treadonly_error (TREE_OPERAND (arg, 0), msgid);\n       else\n-\terror (\"%s of read-only member `%s'\", _(msgid),\n+\terror (\"%s of read-only member %qs\", _(msgid),\n \t       IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (arg, 1))));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n-    error (\"%s of read-only variable `%s'\", _(msgid),\n+    error (\"%s of read-only variable %qs\", _(msgid),\n \t   IDENTIFIER_POINTER (DECL_NAME (arg)));\n   else\n     error (\"%s of read-only location\", _(msgid));\n@@ -2731,7 +2734,7 @@ c_mark_addressable (tree exp)\n       case COMPONENT_REF:\n \tif (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))\n \t  {\n-\t    error (\"cannot take address of bit-field `%s'\",\n+\t    error (\"cannot take address of bit-field %qs\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (x, 1))));\n \t    return false;\n \t  }\n@@ -2759,23 +2762,23 @@ c_mark_addressable (tree exp)\n \t  {\n \t    if (TREE_PUBLIC (x) || TREE_STATIC (x) || DECL_EXTERNAL (x))\n \t      {\n-\t\terror (\"global register variable `%s' used in nested function\",\n+\t\terror (\"global register variable %qs used in nested function\",\n \t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n \t\treturn false;\n \t      }\n-\t    pedwarn (\"register variable `%s' used in nested function\",\n+\t    pedwarn (\"register variable %qs used in nested function\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n \telse if (C_DECL_REGISTER (x))\n \t  {\n \t    if (TREE_PUBLIC (x) || TREE_STATIC (x) || DECL_EXTERNAL (x))\n \t      {\n-\t\terror (\"address of global register variable `%s' requested\",\n+\t\terror (\"address of global register variable %qs requested\",\n \t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n \t\treturn false;\n \t      }\n \n-\t    pedwarn (\"address of register variable `%s' requested\",\n+\t    pedwarn (\"address of register variable %qs requested\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n \t  }\n \n@@ -2890,14 +2893,16 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n       else if (VOID_TYPE_P (TREE_TYPE (type1)))\n \t{\n \t  if (pedantic && TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ISO C forbids conditional expr between `void *' and function pointer\");\n+\t    pedwarn (\"ISO C forbids conditional expr between \"\n+\t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type1),\n \t\t\t\t\t\t\t  TREE_TYPE (type2)));\n \t}\n       else if (VOID_TYPE_P (TREE_TYPE (type2)))\n \t{\n \t  if (pedantic && TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ISO C forbids conditional expr between `void *' and function pointer\");\n+\t    pedwarn (\"ISO C forbids conditional expr between \"\n+\t\t     \"%<void *%> and function pointer\");\n \t  result_type = build_pointer_type (qualify_type (TREE_TYPE (type2),\n \t\t\t\t\t\t\t  TREE_TYPE (type1)));\n \t}\n@@ -3552,7 +3557,8 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t      which are not ANSI null ptr constants.  */\n \t\t   && (!integer_zerop (rhs) || TREE_CODE (rhs) == NOP_EXPR)\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    warn_for_assignment (\"ISO C forbids %s between function pointer and `void *'\",\n+\t    warn_for_assignment (\"ISO C forbids %s between function \"\n+\t\t\t\t \"pointer and %<void *%>\",\n \t\t\t\t errtype, funname, parmnum);\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n@@ -3626,10 +3632,10 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t  tree selector = objc_message_selector ();\n \n \t  if (selector && parmnum > 2)\n-\t    error (\"incompatible type for argument %d of `%s'\",\n+\t    error (\"incompatible type for argument %d of %qs\",\n \t\t   parmnum - 2, IDENTIFIER_POINTER (selector));\n \t  else\n-\t    error (\"incompatible type for argument %d of `%s'\",\n+\t    error (\"incompatible type for argument %d of %qs\",\n \t\t   parmnum, IDENTIFIER_POINTER (funname));\n \t}\n       else\n@@ -3693,7 +3699,7 @@ warn_for_assignment (const char *msgid, const char *opname, tree function,\n \t  if (function)\n \t    {\n \t      /* Function name is known; supply it.  */\n-\t      const char *const argstring = _(\"passing arg of `%s'\");\n+\t      const char *const argstring = _(\"passing arg of '%s'\");\n \t      new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n \t\t\t\t   + strlen (argstring) + 1 + 1);\n \t      sprintf (new_opname, argstring,\n@@ -3710,7 +3716,7 @@ warn_for_assignment (const char *msgid, const char *opname, tree function,\n       else if (function)\n \t{\n \t  /* Function name is known; supply it.  */\n-\t  const char *const argstring = _(\"passing arg %d of `%s'\");\n+\t  const char *const argstring = _(\"passing arg %d of '%s'\");\n \t  new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n \t\t\t       + strlen (argstring) + 1 + 25 /*%d*/ + 1);\n \t  sprintf (new_opname, argstring, argnum,\n@@ -3943,7 +3949,7 @@ error_init (const char *msgid)\n   error (\"%s\", _(msgid));\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    error (\"(near initialization for `%s')\", ofwhat);\n+    error (\"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a pedantic warning for a bad initializer component.\n@@ -3958,7 +3964,7 @@ pedwarn_init (const char *msgid)\n   pedwarn (\"%s\", _(msgid));\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    pedwarn (\"(near initialization for `%s')\", ofwhat);\n+    pedwarn (\"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a warning for a bad initializer component.\n@@ -3973,7 +3979,7 @@ warning_init (const char *msgid)\n   warning (\"%s\", _(msgid));\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat)\n-    warning (\"(near initialization for `%s')\", ofwhat);\n+    warning (\"(near initialization for %qs)\", ofwhat);\n }\n \f\n /* If TYPE is an array type and EXPR is a parenthesized string\n@@ -5144,7 +5150,7 @@ set_init_label (tree fieldname)\n     }\n \n   if (tail == 0)\n-    error (\"unknown field `%s' specified in initializer\",\n+    error (\"unknown field %qs specified in initializer\",\n \t   IDENTIFIER_POINTER (fieldname));\n   else\n     {\n@@ -6313,7 +6319,7 @@ tree\n c_finish_goto_ptr (tree expr)\n {\n   if (pedantic)\n-    pedwarn (\"ISO C forbids `goto *expr;'\");\n+    pedwarn (\"ISO C forbids %<goto *expr;%>\");\n   expr = convert (ptr_type_node, expr);\n   return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n }\n@@ -6327,20 +6333,21 @@ c_finish_return (tree retval)\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n-    warning (\"function declared `noreturn' has a `return' statement\");\n+    warning (\"function declared %<noreturn%> has a %<return%> statement\");\n \n   if (!retval)\n     {\n       current_function_returns_null = 1;\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n-\tpedwarn_c99 (\"`return' with no value, in function returning non-void\");\n+\tpedwarn_c99 (\"%<return%> with no value, in \"\n+\t\t     \"function returning non-void\");\n     }\n   else if (valtype == 0 || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n       if (pedantic || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (\"`return' with a value, in function returning void\");\n+\tpedwarn (\"%<return%> with a value, in function returning void\");\n     }\n   else\n     {\n@@ -6468,7 +6475,8 @@ c_start_case (tree exp)\n \t  if (warn_traditional && !in_system_header\n \t      && (type == long_integer_type_node\n \t\t  || type == long_unsigned_type_node))\n-\t    warning (\"`long' switch expression not converted to `int' in ISO C\");\n+\t    warning (\"%<long%> switch expression not converted to \"\n+\t\t     \"%<int%> in ISO C\");\n \n \t  exp = default_conversion (exp);\n \t  type = TREE_TYPE (exp);\n@@ -6506,7 +6514,7 @@ do_case (tree low_value, tree high_value)\n   else if (low_value)\n     error (\"case label not within a switch statement\");\n   else\n-    error (\"`default' label not within a switch statement\");\n+    error (\"%<default%> label not within a switch statement\");\n \n   return label;\n }\n@@ -6570,7 +6578,7 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n     found:\n \n       if (COND_EXPR_ELSE (inner_if))\n-\t warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n+\t warning (\"%Hsuggest explicit braces to avoid ambiguous %<else%>\",\n \t\t  &if_locus);\n     }\n \n@@ -7227,13 +7235,15 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t whose value is 0 but which isn't a valid null ptr const.  */\n \t      if (pedantic && (!integer_zerop (op0) || op0 != orig_op0)\n \t\t  && TREE_CODE (tt1) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ISO C forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n+\t\t\t \" with function pointer\");\n \t    }\n \t  else if (VOID_TYPE_P (tt1))\n \t    {\n \t      if (pedantic && (!integer_zerop (op1) || op1 != orig_op1)\n \t\t  && TREE_CODE (tt0) == FUNCTION_TYPE)\n-\t\tpedwarn (\"ISO C forbids comparison of `void *' with function pointer\");\n+\t\tpedwarn (\"ISO C forbids comparison of %<void *%>\"\n+\t\t\t \" with function pointer\");\n \t    }\n \t  else\n \t    pedwarn (\"comparison of distinct pointer types lacks a cast\");"}, {"sha": "e26e4c26d73e43356fc641f359dd5215edeef5d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -1,3 +1,11 @@\n+2004-09-13  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* g++.dg/warn/Wswitch-1.C, g++.dg/warn/Wswitch-2.C,\n+\tgcc.dg/Wswitch-2.c, gcc.dg/Wswitch-enum.c, gcc.dg/Wswitch.c,\n+\tgcc.dg/declspec-9.c, gcc.dg/declspec-10.c, gcc.dg/declspec-11.c,\n+\tgcc.dg/m-un-2.c, gcc.dg/noreturn-1.c, gcc.dg/wtr-conversion-1.c:\n+\tUpdate expected messages.\n+\n 2004-09-13  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* gcc.dg/asmreg-1.c (__syscall_getdents64): Adjust signedness"}, {"sha": "9b05cd16c5deb226190b9987ac9f760a2eb8db83", "filename": "gcc/testsuite/g++.dg/warn/Wswitch-1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -19,14 +19,14 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     case 4: return 3;\n     default: break;\n     }\n-  switch (ei) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n-    { /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n+  switch (ei) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n+    { /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n     }\n   switch (ej)\n     {\n     default: break;\n     }\n-  switch (ek) /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" } */\n+  switch (ek) /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" } */\n     {\n     case e1: return 1;\n     }\n@@ -50,7 +50,7 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"case value `3' not in enumerated type `e'\" \"excess 3\" } */\n+    case 3: return 3; /* { dg-warning \"case value '3' not in enumerated type 'e'\" \"excess 3\" } */\n     }\n   switch (ep)\n     {"}, {"sha": "79ba4bdcb84802c8120a76943132a6d8fe36cb5a", "filename": "gcc/testsuite/g++.dg/warn/Wswitch-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-2.C?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -13,7 +13,7 @@ foo (enum e ei, int j)\n     case e3: return 2;\n     case e4: return 3;\n     }\t/* No warning here since e2 has the same value as e3.  */\n-  switch (ei) /* { dg-warning \"enumeration value `e4' not handled in switch\" \"enum e4\" } */\n+  switch (ei) /* { dg-warning \"enumeration value 'e4' not handled in switch\" \"enum e4\" } */\n     {\n     case e1: return 1;\n     case e2: return 2;\n@@ -22,7 +22,7 @@ foo (enum e ei, int j)\n     {\n     case e1: return 1;\n     }\t/* No warning here since switch condition was cast to int.  */\n-  switch ((enum e) j) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n+  switch ((enum e) j) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n     {\n     case e2: return 1;\n     case e4: return 2;"}, {"sha": "79ba4bdcb84802c8120a76943132a6d8fe36cb5a", "filename": "gcc/testsuite/gcc.dg/Wswitch-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-2.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -13,7 +13,7 @@ foo (enum e ei, int j)\n     case e3: return 2;\n     case e4: return 3;\n     }\t/* No warning here since e2 has the same value as e3.  */\n-  switch (ei) /* { dg-warning \"enumeration value `e4' not handled in switch\" \"enum e4\" } */\n+  switch (ei) /* { dg-warning \"enumeration value 'e4' not handled in switch\" \"enum e4\" } */\n     {\n     case e1: return 1;\n     case e2: return 2;\n@@ -22,7 +22,7 @@ foo (enum e ei, int j)\n     {\n     case e1: return 1;\n     }\t/* No warning here since switch condition was cast to int.  */\n-  switch ((enum e) j) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n+  switch ((enum e) j) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n     {\n     case e2: return 1;\n     case e4: return 2;"}, {"sha": "28c60d879ae76fa3e371d7f8f6148ccb4e13b1d4", "filename": "gcc/testsuite/gcc.dg/Wswitch-enum.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch-enum.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -19,18 +19,18 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     case 4: return 3;\n     default: break;\n     }\n-  switch (ei) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n-    { /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n+  switch (ei) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n+    { /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n     }\n-  switch (ej) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n-    { /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" { target *-*-* } 25 } */\n+  switch (ej) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n+    { /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" { target *-*-* } 25 } */\n     default: break;\n     }\n-  switch (ek) /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" } */\n+  switch (ek) /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" } */\n     {\n     case e1: return 1;\n     }\n-  switch (el) /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" } */\n+  switch (el) /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" } */\n     {\n     case e1: return 1;\n     default: break;\n@@ -50,13 +50,13 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"case value `3' not in enumerated type `enum e'\" \"excess 3\" } */\n+    case 3: return 3; /* { dg-warning \"case value '3' not in enumerated type 'enum e'\" \"excess 3\" } */\n     }\n   switch (ep)\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"case value `3' not in enumerated type `enum e'\" \"excess 3\" } */\n+    case 3: return 3; /* { dg-warning \"case value '3' not in enumerated type 'enum e'\" \"excess 3\" } */\n     default: break;\n     }\n   return 0;"}, {"sha": "686fd41614ca1bd00c48c7d68f12794411521c67", "filename": "gcc/testsuite/gcc.dg/Wswitch.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWswitch.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -19,14 +19,14 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     case 4: return 3;\n     default: break;\n     }\n-  switch (ei) /* { dg-warning \"enumeration value `e1' not handled in switch\" \"enum e1\" } */\n-    { /*{ dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n+  switch (ei) /* { dg-warning \"enumeration value 'e1' not handled in switch\" \"enum e1\" } */\n+    { /*{ dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" { target *-*-* } 22 } */\n     }\n   switch (ej)\n     {\n     default: break;\n     }\n-  switch (ek) /* { dg-warning \"enumeration value `e2' not handled in switch\" \"enum e2\" } */\n+  switch (ek) /* { dg-warning \"enumeration value 'e2' not handled in switch\" \"enum e2\" } */\n     {\n     case e1: return 1;\n     }\n@@ -50,7 +50,7 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"case value `3' not in enumerated type `enum e'\" \"excess 3\" } */\n+    case 3: return 3; /* { dg-warning \"case value '3' not in enumerated type 'enum e'\" \"excess 3\" } */\n     }\n   switch (ep)\n     {"}, {"sha": "5a76764abfba6e9ec8b3ff07e4d312102a1bcdd3", "filename": "gcc/testsuite/gcc.dg/declspec-10.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-10.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -15,31 +15,31 @@ void f5 (register int);\n void f6 (static int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n void f7 (typedef int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n \n-auto int x; /* { dg-error \"error: file-scope declaration of `x' specifies `auto'\" } */\n+auto int x; /* { dg-error \"error: file-scope declaration of 'x' specifies 'auto'\" } */\n register int y; /* { dg-warning \"warning: file-scope declaration of 'y' specifies 'register'\" } */\n \n-void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function `x' declared `extern'\" } */\n+void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function 'x' declared 'extern'\" } */\n /* { dg-warning \"warning: ISO C forbids nested functions\" \"nested\" { target *-*-* } 21 } */\n \n void\n g (void)\n {\n-  void a; /* { dg-error \"error: variable or field `a' declared void\" } */\n-  const void b; /* { dg-error \"error: variable or field `b' declared void\" } */\n-  static void c; /* { dg-error \"error: variable or field `c' declared void\" } */\n+  void a; /* { dg-error \"error: variable or field 'a' declared void\" } */\n+  const void b; /* { dg-error \"error: variable or field 'b' declared void\" } */\n+  static void c; /* { dg-error \"error: variable or field 'c' declared void\" } */\n }\n \n void p;\n const void p1;\n extern void q;\n extern const void q1;\n-static void r; /* { dg-error \"error: variable or field `r' declared void\" } */\n-static const void r1; /* { dg-error \"error: variable or field `r1' declared void\" } */\n+static void r; /* { dg-error \"error: variable or field 'r' declared void\" } */\n+static const void r1; /* { dg-error \"error: variable or field 'r1' declared void\" } */\n \n-register void f8 (void); /* { dg-error \"error: invalid storage class for function `f8'\" } */\n+register void f8 (void); /* { dg-error \"error: invalid storage class for function 'f8'\" } */\n /* { dg-warning \"warning: file-scope declaration of 'f8' specifies 'register'\" \"register function\" { target *-*-* } 39 } */\n \n void i (void) { auto void y (void) {} } /* { dg-warning \"warning: ISO C forbids nested functions\" } */\n /* { dg-warning \"warning: function definition declared 'auto'\" \"nested\" { target *-*-* } 42 } */\n \n-inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function `main'\" } */\n+inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function 'main'\" } */"}, {"sha": "2f4eaff3b25ac5450154bf4f4382d1a2b4c27aa1", "filename": "gcc/testsuite/gcc.dg/declspec-11.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-11.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -15,31 +15,31 @@ void f5 (register int);\n void f6 (static int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n void f7 (typedef int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n \n-auto int x; /* { dg-error \"error: file-scope declaration of `x' specifies `auto'\" } */\n+auto int x; /* { dg-error \"error: file-scope declaration of 'x' specifies 'auto'\" } */\n register int y; /* { dg-error \"error: file-scope declaration of 'y' specifies 'register'\" } */\n \n-void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function `x' declared `extern'\" } */\n+void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function 'x' declared 'extern'\" } */\n /* { dg-error \"error: ISO C forbids nested functions\" \"nested\" { target *-*-* } 21 } */\n \n void\n g (void)\n {\n-  void a; /* { dg-error \"error: variable or field `a' declared void\" } */\n-  const void b; /* { dg-error \"error: variable or field `b' declared void\" } */\n-  static void c; /* { dg-error \"error: variable or field `c' declared void\" } */\n+  void a; /* { dg-error \"error: variable or field 'a' declared void\" } */\n+  const void b; /* { dg-error \"error: variable or field 'b' declared void\" } */\n+  static void c; /* { dg-error \"error: variable or field 'c' declared void\" } */\n }\n \n void p;\n const void p1;\n extern void q;\n extern const void q1;\n-static void r; /* { dg-error \"error: variable or field `r' declared void\" } */\n-static const void r1; /* { dg-error \"error: variable or field `r1' declared void\" } */\n+static void r; /* { dg-error \"error: variable or field 'r' declared void\" } */\n+static const void r1; /* { dg-error \"error: variable or field 'r1' declared void\" } */\n \n-register void f8 (void); /* { dg-error \"error: invalid storage class for function `f8'\" } */\n+register void f8 (void); /* { dg-error \"error: invalid storage class for function 'f8'\" } */\n /* { dg-error \"error: file-scope declaration of 'f8' specifies 'register'\" \"register function\" { target *-*-* } 39 } */\n \n void i (void) { auto void y (void) {} } /* { dg-error \"error: ISO C forbids nested functions\" } */\n /* { dg-error \"error: function definition declared 'auto'\" \"nested\" { target *-*-* } 42 } */\n \n-inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function `main'\" } */\n+inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function 'main'\" } */"}, {"sha": "e5dd5b2b6c595aeaf509ec0d31dbd2aa5d0490b3", "filename": "gcc/testsuite/gcc.dg/declspec-9.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdeclspec-9.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -16,28 +16,28 @@ void f5 (register int);\n void f6 (static int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n void f7 (typedef int); /* { dg-error \"error: storage class specified for parameter 'type name'\" } */\n \n-auto int x; /* { dg-error \"error: file-scope declaration of `x' specifies `auto'\" } */\n+auto int x; /* { dg-error \"error: file-scope declaration of 'x' specifies 'auto'\" } */\n register int y;\n \n-void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function `x' declared `extern'\" } */\n+void h (void) { extern void x (void) {} } /* { dg-error \"error: nested function 'x' declared 'extern'\" } */\n \n void\n g (void)\n {\n-  void a; /* { dg-error \"error: variable or field `a' declared void\" } */\n-  const void b; /* { dg-error \"error: variable or field `b' declared void\" } */\n-  static void c; /* { dg-error \"error: variable or field `c' declared void\" } */\n+  void a; /* { dg-error \"error: variable or field 'a' declared void\" } */\n+  const void b; /* { dg-error \"error: variable or field 'b' declared void\" } */\n+  static void c; /* { dg-error \"error: variable or field 'c' declared void\" } */\n }\n \n void p;\n const void p1;\n extern void q;\n extern const void q1;\n-static void r; /* { dg-error \"error: variable or field `r' declared void\" } */\n-static const void r1; /* { dg-error \"error: variable or field `r1' declared void\" } */\n+static void r; /* { dg-error \"error: variable or field 'r' declared void\" } */\n+static const void r1; /* { dg-error \"error: variable or field 'r1' declared void\" } */\n \n-register void f8 (void); /* { dg-error \"error: invalid storage class for function `f8'\" } */\n+register void f8 (void); /* { dg-error \"error: invalid storage class for function 'f8'\" } */\n \n void i (void) { auto void y (void) {} }\n \n-inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function `main'\" } */\n+inline int main (void) { return 0; } /* { dg-warning \"warning: cannot inline function 'main'\" } */"}, {"sha": "d957f868405fe80dc03d2ad6e5051f8a3caeafc9", "filename": "gcc/testsuite/gcc.dg/m-un-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fm-un-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fm-un-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fm-un-2.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -16,7 +16,7 @@ struct vtable mtable = {\n   malloc,\n   free\n }; /* { dg-warning \"missing initializer\" \"warning regression\" { target *-*-* } {18} } */\n-   /* { dg-warning \"initialization for `mtable._realloc'\" \"warning regression\" { target *-*-* } {18} } */\n+   /* { dg-warning \"initialization for 'mtable._realloc'\" \"warning regression\" { target *-*-* } {18} } */\n \n /* With designated initializers, we assume you meant to leave out the\n    initialization of any blank fields.  */"}, {"sha": "952e906ce9ac767e246e6c2ccb596725f29383cf", "filename": "gcc/testsuite/gcc.dg/noreturn-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoreturn-1.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -34,7 +34,7 @@ extern void foo5(void) __attribute__ ((__noreturn__));\n void\n foo5(void)\n {\n-  return; /* { dg-warning \"`noreturn' has a `return' statement\" \"detect invalid return\" } */\n+  return; /* { dg-warning \"'noreturn' has a 'return' statement\" \"detect invalid return\" } */\n } /* { dg-warning \"function does return\" \"detect return from noreturn\" } */\n \n extern void foo6(void);"}, {"sha": "15086f245fe381c87c9b66dc284652ace6c1e642", "filename": "gcc/testsuite/gcc.dg/wtr-conversion-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bda6743181d05dc6421dc0e120b13f7aba727c58/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-conversion-1.c?ref=bda6743181d05dc6421dc0e120b13f7aba727c58", "patch": "@@ -23,8 +23,8 @@ testfunc1 ()\n   foo_i (cd); /* { dg-warning \"as integer rather than complex\" \"prototype conversion warning\" } */\n \n   foo_f (i); /* { dg-warning \"as floating rather than integer\" \"prototype conversion warning\" } */\n-  foo_f (f); /* { dg-warning \"as `float' rather than `double'\" \"prototype conversion warning\" } */\n-  foo_f (ld); /* { dg-warning \"as `float' rather than `double'\" \"prototype conversion warning\" } */\n+  foo_f (f); /* { dg-warning \"as 'float' rather than 'double'\" \"prototype conversion warning\" } */\n+  foo_f (ld); /* { dg-warning \"as 'float' rather than 'double'\" \"prototype conversion warning\" } */\n   foo_f (cd); /* { dg-warning \"as floating rather than complex\" \"prototype conversion warning\" } */\n \n   foo_ld (i); /* { dg-warning \"as floating rather than integer\" \"prototype conversion warning\" } */"}]}