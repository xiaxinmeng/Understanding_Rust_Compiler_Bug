{"sha": "7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U5ODYyNGM1ZWVmY2Q3N2I5MGFkMWViYmJjMDZhYjE3YjAwNWEzMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-07-26T10:27:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-07-26T10:27:50Z"}, "message": "configure.ac: Add types checking to stage1 checking flags.\n\n2007-07-26  Richard Guenther  <rguenther@suse.de>\n\n\ttoplev/\n\t* configure.ac: Add types checking to stage1 checking flags.\n\t* configure: Regenerate.\n\n        gcc/\n\t* tree-cfg.c (verify_gimple_unary_expr, verify_gimple_binary_expr,\n\tverify_gimple_min_lval, verify_gimple_reference, verify_gimple_expr,\n\tverify_gimple_modify_stmt, verify_gimple_stmt, verify_gimple_1,\n\tverify_gimple): New functions.\n\t* tree-flow.h (verify_gimple): Declare.\n\t(verify_gimple_1): Declare.\n\t* gimplify.c (cpt_same_type): Remove.\n\t(gimplify_addr_expr): Remove checking code.\n\t(check_pointer_types_r): Remove.\n\t(gimplify_body): Call verify_gimple_1 instead of check_pointer_types_r.\n\tOnly verify if there were no errors.\n\t* configure.ac: Add types checking flag.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\nFrom-SVN: r126951", "tree": {"sha": "d94c1fef3d48e52ac95d22884ff2b915e9ee622d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d94c1fef3d48e52ac95d22884ff2b915e9ee622d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ee0208eccd3d707d8accf2626cbe934faa7cecd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee0208eccd3d707d8accf2626cbe934faa7cecd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee0208eccd3d707d8accf2626cbe934faa7cecd"}], "stats": {"total": 868, "additions": 758, "deletions": 110}, "files": [{"sha": "94ab187effc845535b5b346a3f44b9cc7d60c008", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -1,3 +1,8 @@\n+2007-07-26  Richard Guenther  <rguenther@suse.de>\n+\n+\t* configure.ac: Add types checking to stage1 checking flags.\n+\t* configure: Regenerate.\n+\n 2007-07-17  Nick Clifton  <nickc@redhat.com>\n \n \t* COPYING3: New file.  Contains version 3 of the GNU General"}, {"sha": "df7479320e40d4fbc1b90caa39fbbcfe2dda1841", "filename": "configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -11967,9 +11967,9 @@ if test \"${enable_stage1_checking+set}\" = set; then\n   stage1_checking=--enable-checking=${enable_stage1_checking}\n else\n   if test \"x$enable_checking\" = xno; then\n-  stage1_checking=--enable-checking\n+  stage1_checking=--enable-checking=yes,types\n else\n-  stage1_checking=--enable-checking${enable_checking+=}$enable_checking\n+  stage1_checking=--enable-checking=types${enable_checking+,}$enable_checking\n fi\n fi;\n "}, {"sha": "2500cc6f35111603315c4a7b2dd5593b8db64275", "filename": "configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -2593,9 +2593,9 @@ AC_ARG_ENABLE(stage1-checking,\n                           of the compiler],\n [stage1_checking=--enable-checking=${enable_stage1_checking}],\n [if test \"x$enable_checking\" = xno; then\n-  stage1_checking=--enable-checking\n+  stage1_checking=--enable-checking=yes,types\n else\n-  stage1_checking=--enable-checking${enable_checking+=}$enable_checking\n+  stage1_checking=--enable-checking=types${enable_checking+,}$enable_checking\n fi])\n AC_SUBST(stage1_checking)\n "}, {"sha": "aba1bb54c5bfe94a489af9d3867482febcebe516", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -121,6 +121,12 @@\n #endif\n \n \n+/* Define if you want all gimple types to be verified after gimplifiation. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_TYPES_CHECKING\n+#endif\n+\n+\n /* Define if you want to run subprograms and generated programs through\n    valgrind (a memory checker). This is extremely expensive. */\n #ifndef USED_FOR_TARGET"}, {"sha": "376a3e394c453c9c3ac4ff43c3d877f307d9d327", "filename": "gcc/configure", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -868,7 +868,7 @@ Optional Features:\n \t\t\t  enable only specific categories of checks.\n \t\t\t  Categories are: yes,no,all,none,release.\n \t\t\t  Flags are: assert,df,fold,gc,gcac,misc,\n-\t\t\t  rtlflag,rtl,runtime,tree,valgrind.\n+\t\t\t  rtlflag,rtl,runtime,tree,valgrind,types.\n   --enable-mapped-location   location_t is fileline integer cookie\n   --enable-coverage=LEVEL\n \t\t\t  enable compiler's code coverage collection.\n@@ -6429,22 +6429,26 @@ do\n \t\t\tac_fold_checking= ; ac_gc_checking=1 ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \tno|none)\tac_assert_checking= ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking= ;\n-\t\t\tac_tree_checking= ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \tall)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking=1 ;\n \t\t\tac_fold_checking=1 ; ac_gc_checking=1 ;\n \t\t\tac_gc_always_collect=1 ; ac_rtl_checking=1 ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking=1 ;;\n \trelease)\tac_assert_checking=1 ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking= ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \t# these enable particular checks\n \tassert) \tac_assert_checking=1 ;;\n \tdf)\t \tac_df_checking=1 ;;\n@@ -6456,6 +6460,7 @@ do\n \trtlflag)\tac_rtlflag_checking=1 ;;\n \truntime)\tac_runtime_checking=1 ;;\n \ttree)\t\tac_tree_checking=1 ;;\n+\ttypes)\t\tac_types_checking=1 ;;\n \tvalgrind)\tac_valgrind_checking=1 ;;\n \t*)\t{ { echo \"$as_me:$LINENO: error: unknown check category $check\" >&5\n echo \"$as_me: error: unknown check category $check\" >&2;}\n@@ -6504,6 +6509,13 @@ _ACEOF\n \n   TREEBROWSER=tree-browser.o\n fi\n+if test x$ac_types_checking != x ; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define ENABLE_TYPES_CHECKING 1\n+_ACEOF\n+\n+fi\n \n if test x$ac_rtl_checking != x ; then\n "}, {"sha": "b50bba56fb1177fac2dd496636fa3cc2dfc0dea8", "filename": "gcc/configure.ac", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -346,7 +346,7 @@ AC_ARG_ENABLE(checking,\n \t\t\t  enable only specific categories of checks.\n \t\t\t  Categories are: yes,no,all,none,release.\n \t\t\t  Flags are: assert,df,fold,gc,gcac,misc,\n-\t\t\t  rtlflag,rtl,runtime,tree,valgrind.],\n+\t\t\t  rtlflag,rtl,runtime,tree,valgrind,types.],\n [ac_checking_flags=\"${enableval}\"],[\n # Determine the default checks.\n if test x$is_release = x ; then\n@@ -363,22 +363,26 @@ do\n \t\t\tac_fold_checking= ; ac_gc_checking=1 ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \tno|none)\tac_assert_checking= ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking= ;\n-\t\t\tac_tree_checking= ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \tall)\t\tac_assert_checking=1 ; ac_checking=1 ; ac_df_checking=1 ;\n \t\t\tac_fold_checking=1 ; ac_gc_checking=1 ;\n \t\t\tac_gc_always_collect=1 ; ac_rtl_checking=1 ;\n \t\t\tac_rtlflag_checking=1 ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking=1 ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking=1 ;;\n \trelease)\tac_assert_checking=1 ; ac_checking= ; ac_df_checking= ;\n \t\t\tac_fold_checking= ; ac_gc_checking= ;\n \t\t\tac_gc_always_collect= ; ac_rtl_checking= ;\n \t\t\tac_rtlflag_checking= ; ac_runtime_checking=1 ;\n-\t\t\tac_tree_checking= ; ac_valgrind_checking= ;;\n+\t\t\tac_tree_checking= ; ac_valgrind_checking= ;\n+\t\t\tac_types_checking= ;;\n \t# these enable particular checks\n \tassert) \tac_assert_checking=1 ;;\n \tdf)\t \tac_df_checking=1 ;;\n@@ -390,6 +394,7 @@ do\n \trtlflag)\tac_rtlflag_checking=1 ;;\n \truntime)\tac_runtime_checking=1 ;;\n \ttree)\t\tac_tree_checking=1 ;;\n+\ttypes)\t\tac_types_checking=1 ;;\n \tvalgrind)\tac_valgrind_checking=1 ;;\n \t*)\tAC_MSG_ERROR(unknown check category $check) ;;\n \tesac\n@@ -426,6 +431,12 @@ if test x$ac_tree_checking != x ; then\n    ])\n   TREEBROWSER=tree-browser.o\n fi\n+if test x$ac_types_checking != x ; then\n+  AC_DEFINE(ENABLE_TYPES_CHECKING, 1,\n+[Define if you want all gimple types to be verified after gimplifiation.\n+   This is cheap.\n+   ])\n+fi\n AC_SUBST(TREEBROWSER)\n if test x$ac_rtl_checking != x ; then\n   AC_DEFINE(ENABLE_RTL_CHECKING, 1,"}, {"sha": "fdf34d18ea89fcfba8bb6f29ba8288ccd8e11630", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 96, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -112,9 +112,6 @@ typedef struct gimple_temp_hash_elt\n \n /* Forward declarations.  */\n static enum gimplify_status gimplify_compound_expr (tree *, tree *, bool);\n-#ifdef ENABLE_CHECKING\n-static bool cpt_same_type (tree a, tree b);\n-#endif\n \n /* Mark X addressable.  Unlike the langhook we expect X to be in gimple\n    form and we don't do any syntax checking.  */\n@@ -3985,19 +3982,7 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \ttree t_op00 = TREE_TYPE (op00);\n \n         if (!useless_type_conversion_p (t_expr, t_op00))\n-\t  {\n-#ifdef ENABLE_CHECKING\n-\t    tree t_op0 = TREE_TYPE (op0);\n-\t    gcc_assert (POINTER_TYPE_P (t_expr)\n-\t\t\t&& (cpt_same_type (TREE_TYPE (t_expr), t_op0)\n-\t\t\t    || (TREE_CODE (t_op0) == ARRAY_TYPE\n-\t\t\t\t&& cpt_same_type (TREE_TYPE (t_expr),\n-\t\t\t\t\t\t  TREE_TYPE (t_op0))))\n-\t\t\t&& POINTER_TYPE_P (t_op00)\n-\t\t\t&& cpt_same_type (t_op0, TREE_TYPE (t_op00)));\n-#endif\n-\t    op00 = fold_convert (TREE_TYPE (expr), op00);\n-\t  }\n+\t  op00 = fold_convert (TREE_TYPE (expr), op00);\n         *expr_p = op00;\n         ret = GS_OK;\n       }\n@@ -6393,84 +6378,6 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n     }\n }\n \f\n-#ifdef ENABLE_CHECKING\n-/* Compare types A and B for a \"close enough\" match.  */\n-\n-static bool\n-cpt_same_type (tree a, tree b)\n-{\n-  if (useless_type_conversion_p (a, b))\n-    return true;\n-\n-  /* ??? The C++ FE decomposes METHOD_TYPES to FUNCTION_TYPES and doesn't\n-     link them together.  This routine is intended to catch type errors\n-     that will affect the optimizers, and the optimizers don't add new\n-     dereferences of function pointers, so ignore it.  */\n-  if ((TREE_CODE (a) == FUNCTION_TYPE || TREE_CODE (a) == METHOD_TYPE)\n-      && (TREE_CODE (b) == FUNCTION_TYPE || TREE_CODE (b) == METHOD_TYPE))\n-    return true;\n-\n-  /* ??? The C FE pushes type qualifiers after the fact into the type of\n-     the element from the type of the array.  See build_unary_op's handling\n-     of ADDR_EXPR.  This seems wrong -- if we were going to do this, we\n-     should have done it when creating the variable in the first place.\n-     Alternately, why aren't the two array types made variants?  */\n-  if (TREE_CODE (a) == ARRAY_TYPE && TREE_CODE (b) == ARRAY_TYPE)\n-    return cpt_same_type (TREE_TYPE (a), TREE_TYPE (b));\n-\n-  /* And because of those, we have to recurse down through pointers.  */\n-  if (POINTER_TYPE_P (a) && POINTER_TYPE_P (b))\n-    return cpt_same_type (TREE_TYPE (a), TREE_TYPE (b));\n-\n-  return false;\n-}\n-\n-/* Check for some cases of the front end missing cast expressions.\n-   The type of a dereference should correspond to the pointer type;\n-   similarly the type of an address should match its object.  */\n-\n-static tree\n-check_pointer_types_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t       void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-  tree ptype, otype, dtype;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case INDIRECT_REF:\n-    case ARRAY_REF:\n-      otype = TREE_TYPE (t);\n-      ptype = TREE_TYPE (TREE_OPERAND (t, 0));\n-      dtype = TREE_TYPE (ptype);\n-      gcc_assert (cpt_same_type (otype, dtype));\n-      break;\n-\n-    case ADDR_EXPR:\n-      ptype = TREE_TYPE (t);\n-      otype = TREE_TYPE (TREE_OPERAND (t, 0));\n-      dtype = TREE_TYPE (ptype);\n-      if (!cpt_same_type (dtype, otype))\n-\t{\n-\t  /* &array is allowed to produce a pointer to the element, rather than\n-\t     a pointer to the array type.  We must allow this in order to\n-\t     properly represent assigning the address of an array in C into\n-\t     pointer to the element type.  */\n-\t  gcc_assert (TREE_CODE (otype) == ARRAY_TYPE\n-\t\t      && POINTER_TYPE_P (ptype)\n-\t\t      && cpt_same_type (dtype, TREE_TYPE (otype)));\n-\t  break;\n-\t}\n-      break;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-\n-\n-  return NULL_TREE;\n-}\n-#endif\n \n /* Gimplify the body of statements pointed to by BODY_P.  FNDECL is the\n    function decl containing BODY.  */\n@@ -6539,8 +6446,9 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n   pop_gimplify_context (body);\n   gcc_assert (gimplify_ctxp == NULL);\n \n-#ifdef ENABLE_CHECKING\n-  walk_tree (body_p, check_pointer_types_r, NULL, NULL);\n+#ifdef ENABLE_TYPES_CHECKING\n+  if (!errorcount && !sorrycount)\n+    verify_gimple_1 (BIND_EXPR_BODY (*body_p));\n #endif\n \n   timevar_pop (TV_TREE_GIMPLIFY);"}, {"sha": "26a5ac9c06f03d40a4835dd4a0e16613b880c500", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 704, "deletions": 0, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -3345,6 +3345,710 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n #undef CHECK_OP\n }\n \n+/* Verifies if EXPR is a valid GIMPLE unary expression.  Returns true\n+   if there is an error, otherwise false.  */\n+\n+static bool\n+verify_gimple_unary_expr (tree expr)\n+{\n+  tree op = TREE_OPERAND (expr, 0);\n+  tree type = TREE_TYPE (expr);\n+\n+  if (!is_gimple_val (op))\n+    {\n+      error (\"invalid operand in unary expression\");\n+      return true;\n+    }\n+\n+  /* For general unary expressions we have the operations type\n+     as the effective type the operation is carried out on.  So all\n+     we need to require is that the operand is trivially convertible\n+     to that type.  */\n+  if (!useless_type_conversion_p (type, TREE_TYPE (op)))\n+    {\n+      error (\"type mismatch in unary expression\");\n+      debug_generic_expr (type);\n+      debug_generic_expr (TREE_TYPE (op));\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verifies if EXPR is a valid GIMPLE binary expression.  Returns true\n+   if there is an error, otherwise false.  */\n+\n+static bool\n+verify_gimple_binary_expr (tree expr)\n+{\n+  tree op0 = TREE_OPERAND (expr, 0);\n+  tree op1 = TREE_OPERAND (expr, 1);\n+  tree type = TREE_TYPE (expr);\n+\n+  if (!is_gimple_val (op0) || !is_gimple_val (op1))\n+    {\n+      error (\"invalid operands in binary expression\");\n+      return true;\n+    }\n+\n+  /* For general binary expressions we have the operations type\n+     as the effective type the operation is carried out on.  So all\n+     we need to require is that both operands are trivially convertible\n+     to that type.  */\n+  if (!useless_type_conversion_p (type, TREE_TYPE (op0))\n+      || !useless_type_conversion_p (type, TREE_TYPE (op1)))\n+    {\n+      error (\"type mismatch in binary expression\");\n+      debug_generic_stmt (type);\n+      debug_generic_stmt (TREE_TYPE (op0));\n+      debug_generic_stmt (TREE_TYPE (op1));\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify if EXPR is either a GIMPLE ID or a GIMPLE indirect reference.\n+   Returns true if there is an error, otherwise false.  */\n+\n+static bool\n+verify_gimple_min_lval (tree expr)\n+{\n+  tree op;\n+\n+  if (is_gimple_id (expr))\n+    return false;\n+\n+  if (TREE_CODE (expr) != INDIRECT_REF\n+      && TREE_CODE (expr) != ALIGN_INDIRECT_REF\n+      && TREE_CODE (expr) != MISALIGNED_INDIRECT_REF)\n+    {\n+      error (\"invalid expression for min lvalue\");\n+      return true;\n+    }\n+\n+  op = TREE_OPERAND (expr, 0);\n+  if (!is_gimple_val (op))\n+    {\n+      error (\"invalid operand in indirect reference\");\n+      debug_generic_stmt (op);\n+      return true;\n+    }\n+  if (!useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t  TREE_TYPE (TREE_TYPE (op))))\n+    {\n+      error (\"type mismatch in indirect reference\");\n+      debug_generic_stmt (TREE_TYPE (expr));\n+      debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify if EXPR is a valid GIMPLE reference expression.  Returns true\n+   if there is an error, otherwise false.  */\n+\n+static bool\n+verify_gimple_reference (tree expr)\n+{\n+  while (handled_component_p (expr))\n+    {\n+      tree op = TREE_OPERAND (expr, 0);\n+\n+      if (TREE_CODE (expr) == ARRAY_REF\n+\t  || TREE_CODE (expr) == ARRAY_RANGE_REF)\n+\t{\n+\t  if (!is_gimple_val (TREE_OPERAND (expr, 1))\n+\t      || (TREE_OPERAND (expr, 2)\n+\t\t  && !is_gimple_val (TREE_OPERAND (expr, 2)))\n+\t      || (TREE_OPERAND (expr, 3)\n+\t\t  && !is_gimple_val (TREE_OPERAND (expr, 3))))\n+\t    {\n+\t      error (\"invalid operands to array reference\");\n+\t      debug_generic_stmt (expr);\n+\t      return true;\n+\t    }\n+\t}\n+\n+      /* Verify if the reference array element types are compatible.  */\n+      if (TREE_CODE (expr) == ARRAY_REF\n+\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (op))))\n+\t{\n+\t  error (\"type mismatch in array reference\");\n+\t  debug_generic_stmt (TREE_TYPE (expr));\n+\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n+\t  return true;\n+\t}\n+      if (TREE_CODE (expr) == ARRAY_RANGE_REF\n+\t  && !useless_type_conversion_p (TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (op))))\n+\t{\n+\t  error (\"type mismatch in array range reference\");\n+\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (expr)));\n+\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n+\t  return true;\n+\t}\n+\n+      if ((TREE_CODE (expr) == REALPART_EXPR\n+\t   || TREE_CODE (expr) == IMAGPART_EXPR)\n+\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (op))))\n+\t{\n+\t  error (\"type mismatch in real/imagpart reference\");\n+\t  debug_generic_stmt (TREE_TYPE (expr));\n+\t  debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (expr) == COMPONENT_REF\n+\t  && !useless_type_conversion_p (TREE_TYPE (expr),\n+\t\t\t\t\t TREE_TYPE (TREE_OPERAND (expr, 1))))\n+\t{\n+\t  error (\"type mismatch in component reference\");\n+\t  debug_generic_stmt (TREE_TYPE (expr));\n+\t  debug_generic_stmt (TREE_TYPE (TREE_OPERAND (expr, 1)));\n+\t  return true;\n+\t}\n+\n+      /* For VIEW_CONVERT_EXPRs which are allowed here, too, there\n+\t is nothing to verify.  Gross mismatches at most invoke\n+\t undefined behavior.  */\n+\n+      expr = op;\n+    }\n+\n+  return verify_gimple_min_lval (expr);\n+}\n+\n+/* Verify the GIMPLE expression EXPR.  Returns true if there is an\n+   error, otherwise false.  */\n+\n+static bool\n+verify_gimple_expr (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  if (is_gimple_val (expr))\n+    return false;\n+\n+  /* Special codes we cannot handle via their class.  */\n+  switch (TREE_CODE (expr))\n+    {\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expr, 0);\n+\tif (!is_gimple_val (op))\n+\t  {\n+\t    error (\"invalid operand in conversion\");\n+\t    return true;\n+\t  }\n+\n+\t/* Allow conversions between integral types.  */\n+        if (INTEGRAL_TYPE_P (type) == INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+\t  return false;\n+\n+\t/* Allow conversions between integral types and pointers only if\n+\t   there is no sign or zero extension involved.  */\n+\tif (((POINTER_TYPE_P (type) && INTEGRAL_TYPE_P (TREE_TYPE (op)))\n+\t     || (POINTER_TYPE_P (TREE_TYPE (op)) && INTEGRAL_TYPE_P (type)))\n+\t    && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op)))\n+\t  return false;\n+\n+\t/* Allow conversion from integer to offset type and vice versa.  */\n+\tif ((TREE_CODE (type) == OFFSET_TYPE\n+\t     && TREE_CODE (TREE_TYPE (op)) == INTEGER_TYPE)\n+\t    || (TREE_CODE (type) == INTEGER_TYPE\n+\t\t&& TREE_CODE (TREE_TYPE (op)) == OFFSET_TYPE))\n+\t  return false;\n+\n+\t/* Otherwise assert we are converting between types of the\n+\t   same kind.  */\n+\tif (TREE_CODE (type) != TREE_CODE (TREE_TYPE (op)))\n+\t  {\n+\t    error (\"invalid types in nop conversion\");\n+\t    debug_generic_expr (type);\n+\t    debug_generic_expr (TREE_TYPE (op));\n+\t    return true;\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case FLOAT_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expr, 0);\n+\tif (!is_gimple_val (op))\n+\t  {\n+\t    error (\"invalid operand in int to float conversion\");\n+\t    return true;\n+\t  }\n+\tif (!INTEGRAL_TYPE_P (TREE_TYPE (op))\n+\t    || !SCALAR_FLOAT_TYPE_P (type))\n+\t  {\n+\t    error (\"invalid types in conversion to floating point\");\n+\t    debug_generic_expr (type);\n+\t    debug_generic_expr (TREE_TYPE (op));\n+\t    return true;\n+\t  }\n+        return false;\n+      }\n+\n+    case FIX_TRUNC_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expr, 0);\n+\tif (!is_gimple_val (op))\n+\t  {\n+\t    error (\"invalid operand in float to int conversion\");\n+\t    return true;\n+\t  }\n+\tif (!INTEGRAL_TYPE_P (type)\n+\t    || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (op)))\n+\t  {\n+\t    error (\"invalid types in conversion to integer\");\n+\t    debug_generic_expr (type);\n+\t    debug_generic_expr (TREE_TYPE (op));\n+\t    return true;\n+\t  }\n+        return false;\n+      }\n+\n+    case COMPLEX_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\tif (!is_gimple_val (op0) || !is_gimple_val (op1))\n+\t  {\n+\t    error (\"invalid operands in complex expression\");\n+\t    return true;\n+\t  }\n+\tif (!TREE_CODE (type) == COMPLEX_TYPE\n+\t    || !(TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n+\t         || SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0)))\n+\t    || !(TREE_CODE (TREE_TYPE (op1)) == INTEGER_TYPE\n+\t         || SCALAR_FLOAT_TYPE_P (TREE_TYPE (op1)))\n+\t    || !useless_type_conversion_p (TREE_TYPE (type),\n+\t\t\t\t\t   TREE_TYPE (op0))\n+\t    || !useless_type_conversion_p (TREE_TYPE (type),\n+\t\t\t\t\t   TREE_TYPE (op1)))\n+\t  {\n+\t    error (\"type mismatch in complex expression\");\n+\t    debug_generic_stmt (TREE_TYPE (expr));\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+\n+    case CONSTRUCTOR:\n+      {\n+\t/* This is used like COMPLEX_EXPR but for vectors.  */\n+\tif (TREE_CODE (type) != VECTOR_TYPE)\n+\t  {\n+\t    error (\"constructor not allowed for non-vector types\");\n+\t    debug_generic_stmt (type);\n+\t    return true;\n+\t  }\n+\t/* FIXME: verify constructor arguments.  */\n+\treturn false;\n+      }\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\tif (!is_gimple_val (op0) || !is_gimple_val (op1))\n+\t  {\n+\t    error (\"invalid operands in shift expression\");\n+\t    return true;\n+\t  }\n+\tif (!TREE_CODE (TREE_TYPE (op1)) == INTEGER_TYPE\n+\t    || !useless_type_conversion_p (type, TREE_TYPE (op0)))\n+\t  {\n+\t    error (\"type mismatch in shift expression\");\n+\t    debug_generic_stmt (TREE_TYPE (expr));\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\tif (POINTER_TYPE_P (type)\n+\t    || POINTER_TYPE_P (TREE_TYPE (op0))\n+\t    || POINTER_TYPE_P (TREE_TYPE (op1)))\n+\t  {\n+\t    error (\"invalid (pointer) operands to plus/minus\");\n+\t    return true;\n+\t  }\n+\t/* Continue with generic binary expression handling.  */\n+\tbreak;\n+      }\n+\n+    case POINTER_PLUS_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+      \tif (!is_gimple_val (op0) || !is_gimple_val (op1))\n+\t  {\n+\t    error (\"invalid operands in pointer plus expression\");\n+\t    return true;\n+\t  }\n+\tif (!POINTER_TYPE_P (TREE_TYPE (op0))\n+\t    || TREE_CODE (TREE_TYPE (op1)) != INTEGER_TYPE\n+\t    || !useless_type_conversion_p (type, TREE_TYPE (op0))\n+\t    || !useless_type_conversion_p (sizetype, TREE_TYPE (op1)))\n+\t  {\n+\t    error (\"type mismatch in pointer plus expression\");\n+\t    debug_generic_stmt (type);\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    return true;\n+\t  }\n+\treturn false;\n+      }\n+\n+    case COND_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\ttree op2 = TREE_OPERAND (expr, 2);\n+\tif ((!is_gimple_val (op1)\n+\t     && TREE_CODE (TREE_TYPE (op1)) != VOID_TYPE)\n+\t    || (!is_gimple_val (op2)\n+\t\t&& TREE_CODE (TREE_TYPE (op2)) != VOID_TYPE))\n+\t  {\n+\t    error (\"invalid operands in conditional expression\");\n+\t    return true;\n+\t  }\n+\tif (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t    || (TREE_CODE (TREE_TYPE (op1)) != VOID_TYPE\n+\t        && !useless_type_conversion_p (type, TREE_TYPE (op1)))\n+\t    || (TREE_CODE (TREE_TYPE (op2)) != VOID_TYPE\n+\t        && !useless_type_conversion_p (type, TREE_TYPE (op2))))\n+\t  {\n+\t    error (\"type mismatch in conditional expression\");\n+\t    debug_generic_stmt (type);\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    debug_generic_stmt (TREE_TYPE (op2));\n+\t    return true;\n+\t  }\n+\treturn verify_gimple_expr (op0);\n+      }\n+\n+    case ADDR_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expr, 0);\n+\ttree ptr_type;\n+\tif (!is_gimple_addressable (op))\n+\t  {\n+\t    error (\"invalid operand in unary expression\");\n+\t    return true;\n+\t  }\n+\tptr_type = build_pointer_type (TREE_TYPE (op));\n+\tif (!useless_type_conversion_p (type, ptr_type)\n+\t    /* FIXME: a longstanding wart, &a == &a[0].  */\n+\t    && (TREE_CODE (TREE_TYPE (op)) != ARRAY_TYPE\n+\t\t|| !useless_type_conversion_p (type,\n+\t\t\tbuild_pointer_type (TREE_TYPE (TREE_TYPE (op))))))\n+\t  {\n+\t    error (\"type mismatch in address expression\");\n+\t    debug_generic_stmt (TREE_TYPE (expr));\n+\t    debug_generic_stmt (ptr_type);\n+\t    return true;\n+\t  }\n+\n+\treturn verify_gimple_reference (op);\n+      }\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\n+      \tif (!is_gimple_val (op0) || !is_gimple_val (op1))\n+\t  {\n+\t    error (\"invalid operands in truth expression\");\n+\t    return true;\n+\t  }\n+\n+\t/* We allow any kind of integral typed argument and result.  */\n+\tif (!INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t    || !INTEGRAL_TYPE_P (TREE_TYPE (op1))\n+\t    || !INTEGRAL_TYPE_P (type))\n+\t  {\n+\t    error (\"type mismatch in binary truth expression\");\n+\t    debug_generic_stmt (type);\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    return true;\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case TRUTH_NOT_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (expr, 0);\n+\n+\tif (!is_gimple_val (op))\n+\t  {\n+\t    error (\"invalid operand in unary not\");\n+\t    return true;\n+\t  }\n+\n+\t/* For TRUTH_NOT_EXPR we can have any kind of integral\n+\t   typed arguments and results.  */\n+\tif (!INTEGRAL_TYPE_P (TREE_TYPE (op))\n+\t    || !INTEGRAL_TYPE_P (type))\n+\t  {\n+\t    error (\"type mismatch in not expression\");\n+\t    debug_generic_expr (TREE_TYPE (expr));\n+\t    debug_generic_expr (TREE_TYPE (op));\n+\t    return true;\n+\t  }\n+\n+\treturn false;\n+      }\n+\n+    case CALL_EXPR:\n+      /* FIXME.  The C frontend passes unpromoted arguments in case it\n+\t didn't see a function declaration before the call.  */\n+      return false;\n+\n+    default:;\n+    }\n+\n+  /* Generic handling via classes.  */\n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case tcc_unary:\n+      return verify_gimple_unary_expr (expr);\n+\n+    case tcc_binary:\n+      return verify_gimple_binary_expr (expr);\n+\n+    case tcc_reference:\n+      return verify_gimple_reference (expr);\n+\n+    case tcc_comparison:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n+\tif (!is_gimple_val (op0) || !is_gimple_val (op1))\n+\t  {\n+\t    error (\"invalid operands in comparison expression\");\n+\t    return true;\n+\t  }\n+\t/* For comparisons we do not have the operations type as the\n+\t   effective type the comparison is carried out in.  Instead\n+\t   we require that either the first operand is trivially\n+\t   convertible into the second, or the other way around.\n+\t   The resulting type of a comparison may be any integral type.\n+\t   Because we special-case pointers to void we allow\n+\t   comparisons of pointers with the same mode as well.  */\n+\tif ((!useless_type_conversion_p (TREE_TYPE (op0), TREE_TYPE (op1))\n+\t     && !useless_type_conversion_p (TREE_TYPE (op1), TREE_TYPE (op0))\n+\t     && (!POINTER_TYPE_P (TREE_TYPE (op0))\n+\t\t || !POINTER_TYPE_P (TREE_TYPE (op1))\n+\t\t || TYPE_MODE (TREE_TYPE (op0)) != TYPE_MODE (TREE_TYPE (op1))))\n+\t    || !INTEGRAL_TYPE_P (type))\n+\t  {\n+\t    error (\"type mismatch in comparison expression\");\n+\t    debug_generic_stmt (TREE_TYPE (expr));\n+\t    debug_generic_stmt (TREE_TYPE (op0));\n+\t    debug_generic_stmt (TREE_TYPE (op1));\n+\t    return true;\n+\t  }\n+        break;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n+/* Verify the GIMPLE assignment statement STMT.  Returns true if there\n+   is an error, otherwise false.  */\n+\n+static bool\n+verify_gimple_modify_stmt (tree stmt)\n+{\n+  tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+  gcc_assert (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT);\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t  TREE_TYPE (rhs)))\n+    {\n+      error (\"non-trivial conversion at assignment\");\n+      debug_generic_expr (TREE_TYPE (lhs));\n+      debug_generic_expr (TREE_TYPE (rhs));\n+      return true;\n+    }\n+\n+  /* Loads/stores from/to a variable are ok.  */\n+  if ((is_gimple_val (lhs)\n+       && is_gimple_variable (rhs))\n+      || (is_gimple_val (rhs)\n+\t  && is_gimple_variable (lhs)))\n+    return false;\n+\n+  /* Aggregate copies are ok.  */\n+  if (!is_gimple_reg_type (TREE_TYPE (lhs))\n+      && !is_gimple_reg_type (TREE_TYPE (rhs)))\n+    return false;\n+\n+  /* We might get 'loads' from a parameter which is not a gimple value.  */\n+  if (TREE_CODE (rhs) == PARM_DECL)\n+    return verify_gimple_expr (lhs);\n+\n+  if (!is_gimple_variable (lhs)\n+      && verify_gimple_expr (lhs))\n+    return true;\n+\n+  if (!is_gimple_variable (rhs)\n+      && verify_gimple_expr (rhs))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Verify the GIMPLE statement STMT.  Returns true if there is an\n+   error, otherwise false.  */\n+\n+static bool\n+verify_gimple_stmt (tree stmt)\n+{\n+  if (!is_gimple_stmt (stmt))\n+    {\n+      error (\"is not a valid GIMPLE statement\");\n+      return true;\n+    }\n+\n+  if (OMP_DIRECTIVE_P (stmt))\n+    {\n+      /* OpenMP directives are validated by the FE and never operated\n+\t on by the optimizers.  Furthermore, OMP_FOR may contain\n+\t non-gimple expressions when the main index variable has had\n+\t its address taken.  This does not affect the loop itself\n+\t because the header of an OMP_FOR is merely used to determine\n+\t how to setup the parallel iteration.  */\n+      return false;\n+    }\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case GIMPLE_MODIFY_STMT:\n+      return verify_gimple_modify_stmt (stmt);\n+\n+    case GOTO_EXPR:\n+    case LABEL_EXPR:\n+      return false;\n+\n+    case SWITCH_EXPR:\n+      if (!is_gimple_val (TREE_OPERAND (stmt, 0)))\n+\t{\n+\t  error (\"invalid operand to switch statement\");\n+\t  debug_generic_expr (TREE_OPERAND (stmt, 0));\n+\t}\n+      return false;\n+\n+    case RETURN_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (stmt, 0);\n+\n+\tif (TREE_CODE (TREE_TYPE (stmt)) != VOID_TYPE)\n+\t  {\n+\t    error (\"type error in return expression\");\n+\t    return true;\n+\t  }\n+\n+\tif (op == NULL_TREE\n+\t    || TREE_CODE (op) == RESULT_DECL)\n+\t  return false;\n+\n+\treturn verify_gimple_modify_stmt (op);\n+      }\n+\n+    case CALL_EXPR:\n+    case COND_EXPR:\n+      return verify_gimple_expr (stmt);\n+\n+    case NOP_EXPR:\n+    case CHANGE_DYNAMIC_TYPE_EXPR:\n+    case ASM_EXPR:\n+      return false;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Verify the GIMPLE statements inside the statement list STMTS.  */\n+\n+void\n+verify_gimple_1 (tree stmts)\n+{\n+  tree_stmt_iterator tsi;\n+\n+  for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+    {\n+      tree stmt = tsi_stmt (tsi);\n+\n+      switch (TREE_CODE (stmt))\n+\t{\n+\tcase BIND_EXPR:\n+\t  verify_gimple_1 (BIND_EXPR_BODY (stmt));\n+\t  break;\n+\n+\tcase TRY_CATCH_EXPR:\n+\tcase TRY_FINALLY_EXPR:\n+\t  verify_gimple_1 (TREE_OPERAND (stmt, 0));\n+\t  verify_gimple_1 (TREE_OPERAND (stmt, 1));\n+\t  break;\n+\n+\tcase CATCH_EXPR:\n+\t  verify_gimple_1 (CATCH_BODY (stmt));\n+\t  break;\n+\n+\tcase EH_FILTER_EXPR:\n+\t  verify_gimple_1 (EH_FILTER_FAILURE (stmt));\n+\t  break;\n+\n+\tdefault:\n+\t  if (verify_gimple_stmt (stmt))\n+\t    debug_generic_expr (stmt);\n+\t}\n+    }\n+}\n+\n+/* Verify the GIMPLE statements inside the current function.  */\n+\n+void\n+verify_gimple (void)\n+{\n+  verify_gimple_1 (BIND_EXPR_BODY (DECL_SAVED_TREE (cfun->decl)));\n+}\n \n /* Verify STMT, return true if STMT is not in GIMPLE form.\n    TODO: Implement type checking.  */"}, {"sha": "e67bd0a50b5f93406d7b6cb389ed25ded5949c59", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e98624c5eefcd77b90ad1ebbbc06ab17b005a32/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7e98624c5eefcd77b90ad1ebbbc06ab17b005a32", "patch": "@@ -752,6 +752,8 @@ extern void bsi_commit_edge_inserts (void);\n extern void notice_special_calls (tree);\n extern void clear_special_calls (void);\n extern void verify_stmts (void);\n+extern void verify_gimple (void);\n+extern void verify_gimple_1 (tree);\n extern tree tree_block_label (basic_block);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,"}]}