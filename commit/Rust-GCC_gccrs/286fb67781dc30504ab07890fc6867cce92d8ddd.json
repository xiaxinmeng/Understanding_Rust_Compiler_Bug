{"sha": "286fb67781dc30504ab07890fc6867cce92d8ddd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg2ZmI2Nzc4MWRjMzA1MDRhYjA3ODkwZmM2ODY3Y2NlOTJkOGRkZA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2013-03-17T19:33:40Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2013-03-17T19:33:40Z"}, "message": "i386.md (isa): Add x64 and nox64.\n\n\t* config/i386/i386.md (isa): Add x64 and nox64.\n\t(enabled): Define x64 for TARGET_64BIT and nox64 for !TARGET_64BIT.\n\t(*pushtf): Enable *roF alternative for x64 isa only.\n\t(*pushxf): Merge with *pushxf_nointeger.  Use Yx*r constraint. Set\n\tmode attribute of integer alternatives to DImode for TARGET_64BIT.\n\t(*pushdf): Merge with *pushdf_rex64.  Use x64 and nox64 isa attributes.\n\t(*movtf_internal): Merge from *movtf_internal_rex64 and\n\t*movtf_internal_sse.  Use x64 and nox64 isa attributes.\n\t(*movxf_internal): Merge with *movxf_internal_rex64.  Use x64 and\n\tnox64 isa attributes.\n\t(*movdf_internal): Merge with *movdf_internal_rex64.  Use x64 and\n\tnox64 isa attributes.\n\t* config/i386/constraints.md (Yd): Do not set for TARGET_64BIT.\n\nFrom-SVN: r196757", "tree": {"sha": "ca76828c172072fae488b6f10945abd2d9faa02e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca76828c172072fae488b6f10945abd2d9faa02e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/286fb67781dc30504ab07890fc6867cce92d8ddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/286fb67781dc30504ab07890fc6867cce92d8ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/286fb67781dc30504ab07890fc6867cce92d8ddd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/286fb67781dc30504ab07890fc6867cce92d8ddd/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88b97037e2fe1b2c0958aa0c2050e050a282228e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b97037e2fe1b2c0958aa0c2050e050a282228e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b97037e2fe1b2c0958aa0c2050e050a282228e"}], "stats": {"total": 458, "additions": 128, "deletions": 330}, "files": [{"sha": "df6116d36847121e3a4a7187afd23d9501bcd6fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=286fb67781dc30504ab07890fc6867cce92d8ddd", "patch": "@@ -1,3 +1,19 @@\n+2013-03-17  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (isa): Add x64 and nox64.\n+\t(enabled): Define x64 for TARGET_64BIT and nox64 for !TARGET_64BIT.\n+\t(*pushtf): Enable *roF alternative for x64 isa only.\n+\t(*pushxf): Merge with *pushxf_nointeger.  Use Yx*r constraint. Set\n+\tmode attribute of integer alternatives to DImode for TARGET_64BIT.\n+\t(*pushdf): Merge with *pushdf_rex64.  Use x64 and nox64 isa attributes.\n+\t(*movtf_internal): Merge from *movtf_internal_rex64 and\n+\t*movtf_internal_sse.  Use x64 and nox64 isa attributes.\n+\t(*movxf_internal): Merge with *movxf_internal_rex64.  Use x64 and\n+\tnox64 isa attributes.\n+\t(*movdf_internal): Merge with *movdf_internal_rex64.  Use x64 and\n+\tnox64 isa attributes.\n+\t* config/i386/constraints.md (Yd): Do not set for TARGET_64BIT.\n+\n 2013-03-17  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.c (TARGET_LRA_P): New define."}, {"sha": "ec7c856c1acb566561ad36cab80c8f3574ce6110", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=286fb67781dc30504ab07890fc6867cce92d8ddd", "patch": "@@ -116,8 +116,7 @@\n  \"@internal Any integer register when zero extensions with AND are disabled.\")\n \n (define_register_constraint \"Yd\"\n- \"(TARGET_64BIT\n-   || (TARGET_INTEGER_DFMODE_MOVES && optimize_function_for_speed_p (cfun)))\n+ \"TARGET_INTEGER_DFMODE_MOVES && optimize_function_for_speed_p (cfun)\n   ? GENERAL_REGS : NO_REGS\"\n  \"@internal Any integer register when integer DFmode moves are enabled.\")\n "}, {"sha": "956613aadd9a524d0c739eced4915374f086c5e1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 111, "deletions": 328, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/286fb67781dc30504ab07890fc6867cce92d8ddd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=286fb67781dc30504ab07890fc6867cce92d8ddd", "patch": "@@ -651,12 +651,14 @@\n (define_attr \"movu\" \"0,1\" (const_string \"0\"))\n \n ;; Used to control the \"enabled\" attribute on a per-instruction basis.\n-(define_attr \"isa\" \"base,sse2,sse2_noavx,sse3,sse4,sse4_noavx,noavx,avx,\n-\t\t    avx2,noavx2,bmi2,fma4,fma\"\n+(define_attr \"isa\" \"base,x64,nox64,sse2,sse2_noavx,sse3,sse4,sse4_noavx,\n+\t\t    noavx,avx,avx2,noavx2,bmi2,fma4,fma\"\n   (const_string \"base\"))\n \n (define_attr \"enabled\" \"\"\n-  (cond [(eq_attr \"isa\" \"sse2\") (symbol_ref \"TARGET_SSE2\")\n+  (cond [(eq_attr \"isa\" \"x64\") (symbol_ref \"TARGET_64BIT\")\n+\t (eq_attr \"isa\" \"nox64\") (symbol_ref \"!TARGET_64BIT\")\n+\t (eq_attr \"isa\" \"sse2\") (symbol_ref \"TARGET_SSE2\")\n \t (eq_attr \"isa\" \"sse2_noavx\")\n \t   (symbol_ref \"TARGET_SSE2 && !TARGET_AVX\")\n \t (eq_attr \"isa\" \"sse3\") (symbol_ref \"TARGET_SSE3\")\n@@ -2582,16 +2584,17 @@\n ;; Floating point push instructions.\n \n (define_insn \"*pushtf\"\n-  [(set (match_operand:TF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:TF 1 \"general_no_elim_operand\" \"x,Fo,*r\"))]\n-  \"TARGET_SSE\"\n+  [(set (match_operand:TF 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:TF 1 \"general_no_elim_operand\" \"x,*roF\"))]\n+  \"TARGET_64BIT || TARGET_SSE\"\n {\n   /* This insn should be already split before reg-stack.  */\n   gcc_unreachable ();\n }\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"sse,*,*\")\n-   (set_attr \"mode\" \"TF,SI,SI\")])\n+  [(set_attr \"isa\" \"*,x64\")\n+   (set_attr \"type\" \"multi\")\n+   (set_attr \"unit\" \"sse,*\")\n+   (set_attr \"mode\" \"TF,DI\")])\n \n ;; %%% Kill this when call knows how to work this out.\n (define_split\n@@ -2603,33 +2606,21 @@\n \n (define_insn \"*pushxf\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,ro\"))]\n-  \"optimize_function_for_speed_p (cfun)\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*\")\n-   (set_attr \"mode\" \"XF,SI\")])\n-\n-;; Size of pushxf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushxf using integer instructions is 3+3*memory operand size\n-;; Pushing using integer instructions is longer except for constants\n-;; and direct memory references (assuming that any given constant is pushed\n-;; only once, but this ought to be handled elsewhere).\n-\n-(define_insn \"*pushxf_nointeger\"\n-  [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,*rFo\"))]\n-  \"optimize_function_for_size_p (cfun)\"\n+\t(match_operand:XF 1 \"general_no_elim_operand\" \"f,Yx*roF\"))]\n+  \"\"\n {\n   /* This insn should be already split before reg-stack.  */\n   gcc_unreachable ();\n }\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"unit\" \"i387,*\")\n-   (set_attr \"mode\" \"XF,SI\")])\n+   (set (attr \"mode\")\n+\t(cond [(eq_attr \"alternative\" \"1\")\n+\t\t (if_then_else (match_test \"TARGET_64BIT\")\n+\t\t   (const_string \"DI\")\n+\t\t   (const_string \"SI\"))\n+\t      ]\n+\t      (const_string \"XF\")))])\n \n ;; %%% Kill this when call knows how to work this out.\n (define_split\n@@ -2640,34 +2631,18 @@\n    (set (mem:XF (reg:P SP_REG)) (match_dup 1))]\n   \"operands[2] = GEN_INT (-GET_MODE_SIZE (XFmode));\")\n \n-(define_insn \"*pushdf_rex64\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Yd*rFm,x\"))]\n-  \"TARGET_64BIT\"\n-{\n-  /* This insn should be already split before reg-stack.  */\n-  gcc_unreachable ();\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*\")\n-   (set_attr \"mode\" \"DF,DI,DF\")])\n-\n-;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer instructions is 2+2*memory operand size\n-;; On the average, pushdf using integers can be still shorter.\n-\n (define_insn \"*pushdf\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Yd*rFo,x\"))]\n-  \"!TARGET_64BIT\"\n+  [(set (match_operand:DF 0 \"push_operand\" \"=<,<,<,<\")\n+\t(match_operand:DF 1 \"general_no_elim_operand\" \"f,Yd*roF,rmF,x\"))]\n+  \"\"\n {\n   /* This insn should be already split before reg-stack.  */\n   gcc_unreachable ();\n }\n-  [(set_attr \"isa\" \"*,*,sse2\")\n+  [(set_attr \"isa\" \"*,nox64,x64,sse2\")\n    (set_attr \"type\" \"multi\")\n-   (set_attr \"unit\" \"i387,*,*\")\n-   (set_attr \"mode\" \"DF,DI,DF\")])\n+   (set_attr \"unit\" \"i387,*,*,sse\")\n+   (set_attr \"mode\" \"DF,SI,DI,DF\")])\n \n ;; %%% Kill this when call knows how to work this out.\n (define_split\n@@ -2692,7 +2667,7 @@\n \n (define_insn \"*pushsf\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rFm,x\"))]\n+\t(match_operand:SF 1 \"general_no_elim_operand\" \"f,rmF,x\"))]\n   \"!TARGET_64BIT\"\n {\n   /* Anything else should be already split before reg-stack.  */\n@@ -2736,21 +2711,19 @@\n   [(set (match_operand:TF 0 \"nonimmediate_operand\")\n \t(match_operand:TF 1 \"nonimmediate_operand\"))]\n   \"TARGET_64BIT || TARGET_SSE\"\n-{\n-  ix86_expand_move (TFmode, operands);\n-  DONE;\n-})\n+  \"ix86_expand_move (TFmode, operands); DONE;\")\n \n (define_expand \"mov<mode>\"\n   [(set (match_operand:X87MODEF 0 \"nonimmediate_operand\")\n \t(match_operand:X87MODEF 1 \"general_operand\"))]\n   \"\"\n   \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n-(define_insn \"*movtf_internal_rex64\"\n+(define_insn \"*movtf_internal\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,x ,m,?*r ,!o\")\n \t(match_operand:TF 1 \"general_operand\"\t   \"C ,xm,x,*roF,*rC\"))]\n-  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  \"(TARGET_64BIT || TARGET_SSE)\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2792,7 +2765,8 @@\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"sselog1,ssemov,ssemov,*,*\")\n+  [(set_attr \"isa\" \"*,*,*,x64,x64\")\n+   (set_attr \"type\" \"sselog1,ssemov,ssemov,*,*\")\n    (set_attr \"prefix\" \"maybe_vex,maybe_vex,maybe_vex,*,*\")\n    (set (attr \"mode\")\n         (cond [(eq_attr \"alternative\" \"3,4\")\n@@ -2810,101 +2784,13 @@\n \t       ]\n \t       (const_string \"TI\")))])\n \n-(define_insn \"*movtf_internal_sse\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=x,x ,m\")\n-\t(match_operand:TF 1 \"general_operand\"  \t   \"C ,xm,x\"))]\n-  \"TARGET_SSE && !TARGET_64BIT\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (!can_create_pseudo_p ()\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || (optimize_function_for_size_p (cfun)\n-\t   && standard_sse_constant_p (operands[1])\n-\t   && !memory_operand (operands[0], TFmode))\n-       || (!TARGET_MEMORY_MISMATCH_STALL\n-\t   && memory_operand (operands[0], TFmode)))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return standard_sse_constant_opcode (insn, operands[1]);\n-    case 1:\n-    case 2:\n-      /* Handle misaligned load/store since we\n-         don't have movmisaligntf pattern. */\n-      if (misaligned_operand (operands[0], TFmode)\n-\t  || misaligned_operand (operands[1], TFmode))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqu\\t{%1, %0|%0, %1}\";\n-\t}\n-      else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-\t}\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set (attr \"mode\")\n-        (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n-\t\t (const_string \"V4SF\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n-\t\t    (match_test \"TARGET_SSE_TYPELESS_STORES\"))\n-\t\t (const_string \"V4SF\")\n-\t       (match_test \"TARGET_AVX\")\n-\t\t (const_string \"TI\")\n-\t       (ior (not (match_test \"TARGET_SSE2\"))\n-\t\t    (match_test \"optimize_function_for_size_p (cfun)\"))\n-\t\t (const_string \"V4SF\")\n-\t       ]\n-\t       (const_string \"TI\")))])\n-\n-(define_insn \"*movxf_internal_rex64\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,?Yx*r ,!o\")\n-\t(match_operand:XF 1 \"general_operand\"\t   \"fm,f,G,Yx*roF,Yx*rC\"))]\n-  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (!can_create_pseudo_p ()\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || (optimize_function_for_size_p (cfun)\n-\t   && standard_80387_constant_p (operands[1]) > 0\n-\t   && !memory_operand (operands[0], XFmode))\n-       || (!TARGET_MEMORY_MISMATCH_STALL\n-\t   && memory_operand (operands[0], XFmode)))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-      return \"#\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n-\n-;; Possible store forwarding (partial memory) stall in alternative 4.\n+;; Possible store forwarding (partial memory) stall in alternatives 4 and 5.\n (define_insn \"*movxf_internal\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,?Yx*r ,!o\")\n-\t(match_operand:XF 1 \"general_operand\"\t   \"fm,f,G,Yx*roF,Yx*rF\"))]\n-  \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\"\n+\t \"=f,m,f,?Yx*r ,!o   ,!o\")\n+\t(match_operand:XF 1 \"general_operand\"\n+\t \"fm,f,G,Yx*roF,Yx*rF,Yx*rC\"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -2925,166 +2811,30 @@\n \n     case 3:\n     case 4:\n+    case 5:\n       return \"#\";\n \n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")\n-   (set_attr \"mode\" \"XF,XF,XF,SI,SI\")])\n-\n-(define_insn \"*movdf_internal_rex64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=Yf*f,m   ,Yf*f,?r,?m,?r,?r,x,x,x,m,Yi,r\")\n-\t(match_operand:DF 1 \"general_operand\"\n-\t\t\"Yf*fm,Yf*f,G   ,rm,rC,C ,F ,C,x,m,x,r ,Yi\"))]\n-  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n-   && (!can_create_pseudo_p ()\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || (optimize_function_for_size_p (cfun)\n-\t   && ((!(TARGET_SSE2 && TARGET_SSE_MATH)\n-\t\t&& standard_80387_constant_p (operands[1]) > 0)\n-\t       || (TARGET_SSE2 && TARGET_SSE_MATH\n-\t\t   && standard_sse_constant_p (operands[1]))))\n-       || memory_operand (operands[0], DFmode))\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-      return \"mov{q}\\t{%1, %0|%0, %1}\";\n-\n-    case 5:\n-      return \"mov{l}\\t{%1, %k0|%k0, %1}\";\n-\n-    case 6:\n-      return \"movabs{q}\\t{%1, %0|%0, %1}\";\n-\n-    case 7:\n-      return standard_sse_constant_opcode (insn, operands[1]);\n-\n-    case 8:\n-    case 9:\n-    case 10:\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V2DF:\n-\t  return \"%vmovapd\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V4SF:\n-\t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\n-\tcase MODE_DI:\n-\t  return \"%vmovq\\t{%1, %0|%0, %1}\";\n-\tcase MODE_DF:\n-\t  if (TARGET_AVX && REG_P (operands[0]) && REG_P (operands[1]))\n-\t    return \"vmovsd\\t{%1, %0, %0|%0, %0, %1}\";\n-\t  return \"%vmovsd\\t{%1, %0|%0, %1}\";\n-\tcase MODE_V1DF:\n-\t  return \"%vmovlpd\\t{%1, %d0|%d0, %1}\";\n-\tcase MODE_V2SF:\n-\t  return \"%vmovlps\\t{%1, %d0|%d0, %1}\";\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-    case 11:\n-    case 12:\n-      /* Handle broken assemblers that require movd instead of movq.  */\n-      return \"%vmovd\\t{%1, %0|%0, %1}\";\n-\n-    default:\n-      gcc_unreachable();\n-    }\n-}\n-  [(set (attr \"type\")\n-\t(cond [(eq_attr \"alternative\" \"0,1,2\")\n-\t\t (const_string \"fmov\")\n-\t       (eq_attr \"alternative\" \"3,4,5,6\")\n-\t\t (const_string \"imov\")\n-\t       (eq_attr \"alternative\" \"7\")\n-\t\t (const_string \"sselog1\")\n-\t      ]\n-\t      (const_string \"ssemov\")))\n-   (set (attr \"modrm\")\n-     (if_then_else\n-       (and (eq_attr \"alternative\" \"6\") (eq_attr \"type\" \"imov\"))\n-\t (const_string \"0\")\n-\t (const_string \"*\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (and (eq_attr \"alternative\" \"6\") (eq_attr \"type\" \"imov\"))\n-\t (const_string \"8\")\n-\t (const_string \"*\")))\n-   (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4,5,6\")\n-       (const_string \"orig\")\n-       (const_string \"maybe_vex\")))\n-   (set (attr \"prefix_data16\")\n-     (if_then_else (eq_attr \"mode\" \"V1DF\")\n-       (const_string \"1\")\n-       (const_string \"*\")))\n+  [(set_attr \"isa\" \"*,*,*,*,nox64,x64\")\n+   (set_attr \"type\" \"fmov,fmov,fmov,multi,multi,multi\")\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0,1,2\")\n-\t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4,6,11,12\")\n-\t\t (const_string \"DI\")\n-\t       (eq_attr \"alternative\" \"5\")\n-\t\t (const_string \"SI\")\n-\n-\t       /* xorps is one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"7\")\n-\t\t (cond [(match_test \"TARGET_AVX\")\n-\t\t\t  (const_string \"V2DF\")\n-\t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_string \"V4SF\")\n-\t\t\t(match_test \"TARGET_SSE_LOAD0_BY_PXOR\")\n-\t\t\t  (const_string \"TI\")\n-\t\t       ]\n-\t\t       (const_string \"V2DF\"))\n-\n-\t       /* For architectures resolving dependencies on\n-\t\t  whole SSE registers use APD move to break dependency\n-\t\t  chains, otherwise use short move to avoid extra work.\n-\n-\t\t  movaps encodes one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"8\")\n-\t\t (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n-\t\t\t  (const_string \"V4SF\")\n-\t\t\t(match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n-\t\t\t  (const_string \"V2DF\")\n-\t\t\t(match_test \"TARGET_AVX\")\n-\t\t\t  (const_string \"DF\")\n-\t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_string \"V4SF\")\n-\t\t   ]\n-\t\t   (const_string \"DF\"))\n-\t       /* For architectures resolving dependencies on register\n-\t\t  parts we may avoid extra work to zero out upper part\n-\t\t  of register.  */\n-\t       (eq_attr \"alternative\" \"9\")\n-\t\t (if_then_else\n-\t\t   (match_test \"TARGET_SSE_SPLIT_REGS\")\n-\t\t   (const_string \"V1DF\")\n-\t\t   (const_string \"DF\"))\n+\t(cond [(eq_attr \"alternative\" \"3,4,5\")\n+\t\t (if_then_else (match_test \"TARGET_64BIT\")\n+\t\t   (const_string \"DI\")\n+\t\t   (const_string \"SI\"))\n \t      ]\n-\t      (const_string \"DF\")))])\n+\t      (const_string \"XF\")))])\n \n ;; Possible store forwarding (partial memory) stall in alternative 4.\n (define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-\t\t\"=Yf*f,m   ,Yf*f,?Yd*r ,!o   ,x,x,x,m,*x,*x,*x,m\")\n+    \"=Yf*f,m   ,Yf*f,?Yd*r ,!o   ,?r,?m,?r,?r,x,x,x,m,*x,*x,*x,m ,Yi,r\")\n \t(match_operand:DF 1 \"general_operand\"\n-\t\t\"Yf*fm,Yf*f,G   ,Yd*roF,Yd*rF,C,x,m,x,C ,*x,m ,*x\"))]\n-  \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\n+    \"Yf*fm,Yf*f,G   ,Yd*roF,Yd*rF,rm,rC,C ,F ,C,x,m,x,C ,*x,m ,*x,r ,Yi\"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -3094,7 +2844,7 @@\n \t       || (TARGET_SSE2 && TARGET_SSE_MATH\n \t\t   && standard_sse_constant_p (operands[1])))\n \t   && !memory_operand (operands[0], DFmode))\n-       || (!TARGET_MEMORY_MISMATCH_STALL\n+       || ((TARGET_64BIT || !TARGET_MEMORY_MISMATCH_STALL)\n \t   && memory_operand (operands[0], DFmode)))\"\n {\n   switch (which_alternative)\n@@ -3111,15 +2861,25 @@\n       return \"#\";\n \n     case 5:\n-    case 9:\n-      return standard_sse_constant_opcode (insn, operands[1]);\n-\n     case 6:\n+      return \"mov{q}\\t{%1, %0|%0, %1}\";\n+\n     case 7:\n+      return \"mov{l}\\t{%1, %k0|%k0, %1}\";\n+\n     case 8:\n+      return \"movabs{q}\\t{%1, %0|%0, %1}\";\n+\n+    case 9:\n+    case 13:\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+\n     case 10:\n     case 11:\n     case 12:\n+    case 14:\n+    case 15:\n+    case 16:\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_V2DF:\n@@ -3141,47 +2901,62 @@\n \t  gcc_unreachable ();\n \t}\n \n+    case 17:\n+    case 18:\n+      /* Handle broken assemblers that require movd instead of movq.  */\n+      return \"%vmovd\\t{%1, %0|%0, %1}\";\n+\n     default:\n       gcc_unreachable ();\n     }\n }\n   [(set (attr \"isa\")\n-     (if_then_else (eq_attr \"alternative\" \"5,6,7,8\")\n-       (const_string \"sse2\")\n-       (const_string \"*\")))\n+\t(cond [(eq_attr \"alternative\" \"3,4\")\n+\t\t (const_string \"nox64\")\n+\t       (eq_attr \"alternative\" \"5,6,7,8,17,18\")\n+\t\t (const_string \"x64\")\n+\t       (eq_attr \"alternative\" \"9,10,11,12\")\n+\t\t (const_string \"sse2\")\n+\t      ]\n+\t      (const_string \"*\")))\n    (set (attr \"type\")\n \t(cond [(eq_attr \"alternative\" \"0,1,2\")\n \t\t (const_string \"fmov\")\n \t       (eq_attr \"alternative\" \"3,4\")\n \t\t (const_string \"multi\")\n-\t       (eq_attr \"alternative\" \"5,9\")\n+\t       (eq_attr \"alternative\" \"5,6,7,8\")\n+\t\t (const_string \"imov\")\n+\t       (eq_attr \"alternative\" \"9,13\")\n \t\t (const_string \"sselog1\")\n \t      ]\n \t      (const_string \"ssemov\")))\n+   (set (attr \"modrm\")\n+     (if_then_else (eq_attr \"alternative\" \"8\")\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set (attr \"length_immediate\")\n+     (if_then_else (eq_attr \"alternative\" \"8\")\n+       (const_string \"8\")\n+       (const_string \"*\")))\n    (set (attr \"prefix\")\n-     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4\")\n+     (if_then_else (eq_attr \"alternative\" \"0,1,2,3,4,5,6,7,8\")\n        (const_string \"orig\")\n        (const_string \"maybe_vex\")))\n    (set (attr \"prefix_data16\")\n      (if_then_else (eq_attr \"mode\" \"V1DF\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"0,1,2\")\n-\t\t (const_string \"DF\")\n-\t       (eq_attr \"alternative\" \"3,4\")\n+\t(cond [(eq_attr \"alternative\" \"3,4,7\")\n \t\t (const_string \"SI\")\n-\n-\t       /* For SSE1, we have many fewer alternatives.  */\n-\t       (not (match_test \"TARGET_SSE2\"))\n-\t\t (if_then_else\n-\t\t   (eq_attr \"alternative\" \"5,6,9,10\")\n-\t\t   (const_string \"V4SF\")\n-\t\t   (const_string \"V2SF\"))\n+\t       (eq_attr \"alternative\" \"5,6,8,17,18\")\n+\t\t (const_string \"DI\")\n \n \t       /* xorps is one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"5,9\")\n-\t\t (cond [(match_test \"TARGET_AVX\")\n+\t       (eq_attr \"alternative\" \"9,13\")\n+\t\t (cond [(not (match_test \"TARGET_SSE2\"))\n+\t\t \t  (const_string \"V4SF\")\n+\t\t\t(match_test \"TARGET_AVX\")\n \t\t\t  (const_string \"V2DF\")\n \t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n \t\t\t  (const_string \"V4SF\")\n@@ -3195,8 +2970,9 @@\n \t\t  chains, otherwise use short move to avoid extra work.\n \n \t\t  movaps encodes one byte shorter for !TARGET_AVX.  */\n-\t       (eq_attr \"alternative\" \"6,10\")\n-\t\t (cond [(match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n+\t       (eq_attr \"alternative\" \"10,14\")\n+\t\t (cond [(ior (not (match_test \"TARGET_SSE2\"))\n+\t\t       \t     (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t\t  (const_string \"V4SF\")\n \t\t\t(match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n \t\t\t  (const_string \"V2DF\")\n@@ -3210,11 +2986,18 @@\n \t       /* For architectures resolving dependencies on register\n \t\t  parts we may avoid extra work to zero out upper part\n \t\t  of register.  */\n-\t       (eq_attr \"alternative\" \"7,11\")\n-\t\t (if_then_else\n-\t\t   (match_test \"TARGET_SSE_SPLIT_REGS\")\n-\t\t   (const_string \"V1DF\")\n+\t       (eq_attr \"alternative\" \"11,15\")\n+\t\t (cond [(not (match_test \"TARGET_SSE2\"))\n+\t\t\t  (const_string \"V2SF\")\n+\t\t\t(match_test \"TARGET_SSE_SPLIT_REGS\")\n+\t\t\t  (const_string \"V1DF\")\n+\t\t   ]\n \t\t   (const_string \"DF\"))\n+\n+\t       (eq_attr \"alternative\" \"12,16\")\n+\t\t (if_then_else (match_test \"TARGET_SSE2\")\n+\t\t   (const_string \"DF\")\n+\t\t   (const_string \"V2SF\"))\n \t      ]\n \t      (const_string \"DF\")))])\n "}]}