{"sha": "4845dbb50ed31ad03c579364e4b70bbe90e7af99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0NWRiYjUwZWQzMWFkMDNjNTc5MzY0ZTRiNzBiYmU5MGU3YWY5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-09-09T17:39:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-09-09T17:39:28Z"}, "message": "i386.h (ix86_tune_indices): Add X86_USE_VECTOR_CONVERTS.\n\n\t* i386.h (ix86_tune_indices): Add X86_USE_VECTOR_CONVERTS.\n\t(TARGET_USE_VECTOR_CONVERTS): New.\n\t* i386.md: New post-reload splitters for converting SF to DF and DF to\n\tSF.\n\t(floatsi* expander): Special case vector conversions.\n\t(floatsisf2_mixed_vector, floatsisf2_sse_vector_nointernunit,\n\tfloatsisf2_sse_vector_internunit, floatsisf2_sse_vector,\n\tfloatsidf2_mixed_vector, floatsidf2_sse_vector): New.\n\t(floatsisf2_mixed, floatsisf2_sse, floatsidf2_mixed, floatsidf2_sse):\n\tDisable when doing vector converts.\n\t(floatsi<mode>2_i387): Disable when\n\t* sse.md (vec_dupv2df): Export.\n\t* i386.c (ix86_tune_features): Enable SSE conversions.\n\nCo-Authored-By: Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\n\nFrom-SVN: r128301", "tree": {"sha": "54efc7ad309d5c940ce7d7c3e75970aa1e595b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54efc7ad309d5c940ce7d7c3e75970aa1e595b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4845dbb50ed31ad03c579364e4b70bbe90e7af99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4845dbb50ed31ad03c579364e4b70bbe90e7af99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4845dbb50ed31ad03c579364e4b70bbe90e7af99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4845dbb50ed31ad03c579364e4b70bbe90e7af99/comments", "author": null, "committer": null, "parents": [{"sha": "e9f91f6220e75cceed0abfe663bdf8d9ff51682b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9f91f6220e75cceed0abfe663bdf8d9ff51682b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9f91f6220e75cceed0abfe663bdf8d9ff51682b"}], "stats": {"total": 317, "additions": 296, "deletions": 21}, "files": [{"sha": "d748be2aa9370b09a68b01d15b358a6357023347", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4845dbb50ed31ad03c579364e4b70bbe90e7af99", "patch": "@@ -1,3 +1,20 @@\n+2007-09-09  Jan Hubicka  <jh@suse.cz>\n+            Dwarakanath Rajagopal <dwarak.rajagopal@amd.com>\n+\n+\t* i386.h (ix86_tune_indices): Add X86_USE_VECTOR_CONVERTS.\n+\t(TARGET_USE_VECTOR_CONVERTS): New.\n+\t* i386.md: New post-reload splitters for converting SF to DF and DF to\n+\tSF.\n+\t(floatsi* expander): Special case vector conversions.\n+\t(floatsisf2_mixed_vector, floatsisf2_sse_vector_nointernunit,\n+\tfloatsisf2_sse_vector_internunit, floatsisf2_sse_vector,\n+\tfloatsidf2_mixed_vector, floatsidf2_sse_vector): New.\n+\t(floatsisf2_mixed, floatsisf2_sse, floatsidf2_mixed, floatsidf2_sse):\n+\tDisable when doing vector converts.\n+\t(floatsi<mode>2_i387): Disable when\n+\t* sse.md (vec_dupv2df): Export.\n+\t* i386.c (ix86_tune_features): Enable SSE conversions.\n+\n 2007-09-09  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-operands.c (add_virtual_operand): Only mark"}, {"sha": "c01198baf6e273ea6cede14d95ce7c7b4710ecf8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4845dbb50ed31ad03c579364e4b70bbe90e7af99", "patch": "@@ -1258,6 +1258,10 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n      operand that cannot be represented using a modRM byte.  The XOR\n      replacement is long decoded, so this split helps here as well.  */\n   m_K6,\n+\n+  /* X86_USE_VECTOR_CONVERTS: Preffer vector packed SSE conversion from\n+  integer to FP. */\n+  m_AMDFAM10,\n };\n \n /* Feature tests against the various architecture variations.  */"}, {"sha": "06e90f4b6002cda9b6cb849fbaf3cdc87aaf4107", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=4845dbb50ed31ad03c579364e4b70bbe90e7af99", "patch": "@@ -257,6 +257,7 @@ enum ix86_tune_indices {\n   X86_TUNE_MOVE_M1_VIA_OR,\n   X86_TUNE_NOT_UNPAIRABLE,\n   X86_TUNE_NOT_VECTORMODE,\n+  X86_USE_VECTOR_CONVERTS,\n \n   X86_TUNE_LAST\n };\n@@ -337,6 +338,7 @@ extern unsigned int ix86_tune_features[X86_TUNE_LAST];\n #define\tTARGET_MOVE_M1_VIA_OR\tix86_tune_features[X86_TUNE_MOVE_M1_VIA_OR]\n #define TARGET_NOT_UNPAIRABLE\tix86_tune_features[X86_TUNE_NOT_UNPAIRABLE]\n #define TARGET_NOT_VECTORMODE\tix86_tune_features[X86_TUNE_NOT_VECTORMODE]\n+#define TARGET_USE_VECTOR_CONVERTS ix86_tune_features[X86_USE_VECTOR_CONVERTS]\n \n /* Feature tests against the various architecture variations.  */\n enum ix86_arch_indices {"}, {"sha": "352f67dea7262a1a336c6d9e60d5cfc966b640d5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 272, "deletions": 20, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4845dbb50ed31ad03c579364e4b70bbe90e7af99", "patch": "@@ -3916,6 +3916,49 @@\n     }\n })\n \n+/* For converting SF(xmm2) to DF(xmm1), use the following code instead of\n+   cvtss2sd:\n+      unpcklps xmm2,xmm2   ; packed conversion might crash on signaling NaNs\n+      cvtps2pd xmm2,xmm1\n+   We do the conversion post reload to avoid producing of 128bit spills\n+   that might lead to ICE on 32bit target.  The sequence unlikely combine\n+   anyway.  */\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (float_extend:DF\n+\t  (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_USE_VECTOR_CONVERTS && !optimize_size \n+   && reload_completed && SSE_REG_P (operands[0])\"\n+   [(set (match_dup 2)\n+\t (float_extend:V2DF\n+\t   (vec_select:V2SF\n+\t     (match_dup 3)\n+\t     (parallel [(const_int 0) (const_int 1)]))))]\n+{\n+  operands[2] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n+  operands[3] = simplify_gen_subreg (V4SFmode, operands[0], DFmode, 0);\n+  /* Use movss for loading from memory, unpcklps reg, reg for registers.\n+     Try to avoid move when unpacking can be done in source.  */\n+  if (REG_P (operands[1]))\n+    {\n+      /* If it is unsafe to overwrite upper half of source, we need\n+\t to move to destination and unpack there.  */\n+      if ((ORIGINAL_REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n+\t   || PSEUDO_REGNO_BYTES (ORIGINAL_REGNO (operands[1])) > 4)\n+\t  && true_regnum (operands[0]) != true_regnum (operands[1]))\n+\t{\n+\t  rtx tmp = gen_rtx_REG (SFmode, true_regnum (operands[0]));\n+\t  emit_move_insn (tmp, operands[1]);\n+\t}\n+      else\n+\toperands[3] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n+      emit_insn (gen_sse_unpcklps (operands[3], operands[3], operands[3]));\n+    }\n+  else\n+    emit_insn (gen_vec_setv4sf_0 (operands[3], \n+\t\t\t\t  CONST0_RTX (V4SFmode), operands[1]));\n+})\n+\n (define_insn \"*extendsfdf2_mixed\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,x\")\n         (float_extend:DF\n@@ -4009,6 +4052,51 @@\n     }\n })\n \n+/* For converting DF(xmm2) to SF(xmm1), use the following code instead of\n+   cvtsd2ss:\n+      unpcklpd xmm2,xmm2   ; packed conversion might crash on signaling NaNs\n+      cvtpd2ps xmm2,xmm1\n+   We do the conversion post reload to avoid producing of 128bit spills\n+   that might lead to ICE on 32bit target.  The sequence unlikely combine\n+   anyway.  */\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+        (float_truncate:SF\n+\t  (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_USE_VECTOR_CONVERTS && !optimize_size \n+   && reload_completed && SSE_REG_P (operands[0])\"\n+   [(set (match_dup 2)\n+\t (vec_concat:V4SF\n+\t   (float_truncate:V2SF\n+\t     (match_dup 4))\n+\t   (match_dup 3)))]\n+{\n+  operands[2] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  operands[3] = CONST0_RTX (V2SFmode);\n+  operands[4] = simplify_gen_subreg (V2DFmode, operands[0], SFmode, 0);\n+  /* Use movsd for loading from memory, unpcklpd for registers.\n+     Try to avoid move when unpacking can be done in source, or SSE3\n+     movddup is available.  */\n+  if (REG_P (operands[1]))\n+    {\n+      if (!TARGET_SSE3\n+\t  && true_regnum (operands[0]) != true_regnum (operands[1])\n+\t  && (ORIGINAL_REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n+\t      || PSEUDO_REGNO_BYTES (ORIGINAL_REGNO (operands[1])) > 8))\n+\t{\n+\t  rtx tmp = simplify_gen_subreg (DFmode, operands[0], SFmode, 0);\n+\t  emit_move_insn (tmp, operands[1]);\n+\t  operands[1] = tmp;\n+\t}\n+      else if (!TARGET_SSE3)\n+\toperands[4] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n+      emit_insn (gen_vec_dupv2df (operands[4], operands[1]));\n+    }\n+  else\n+    emit_insn (gen_sse2_loadlpd (operands[4],\n+\t\t\t\t CONST0_RTX (V2DFmode), operands[1]));\n+})\n+\n (define_expand \"truncdfsf2_with_temp\"\n   [(parallel [(set (match_operand:SF 0 \"\" \"\")\n \t\t   (float_truncate:SF (match_operand:DF 1 \"\" \"\")))\n@@ -4685,12 +4773,67 @@\n   [(set (match_operand:MODEF 0 \"register_operand\" \"\")\n \t(float:MODEF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n-  \"\")\n+  \"\n+   /* When we use vector converts, we can't have input in memory.  */\n+   if (GET_MODE (operands[0]) == DFmode && GET_MODE (operands[1]) == SImode\n+       && TARGET_USE_VECTOR_CONVERTS && !optimize_size && TARGET_SSE_MATH\n+       && SSE_FLOAT_MODE_P (DFmode))\n+     operands[1] = force_reg (SImode, operands[1]);\n+   \n+   if (GET_MODE (operands[0]) == SFmode && GET_MODE (operands[1]) == SImode\n+       && !optimize_size && TARGET_USE_VECTOR_CONVERTS && TARGET_SSE_MATH\n+       && SSE_FLOAT_MODE_P (SFmode))\n+     {\n+       /* When !flag_trapping_math, we handle SImode->SFmode vector\n+\t  conversions same way as SImode->DFmode.\n+\n+\t  For flat_trapping_math we can't safely use vector conversion without\n+\t  clearing upper half, otherwise precision exception might occur.\n+\t  However we can still generate the common sequence converting value\n+\t  from general register to XMM register as:\n+\n+\t    mov \treg32, mem32\n+\t    movd\tmem32, xmm\n+\t    cvtdq2pd xmm,xmm\n+\n+\t  because we know that movd clears the upper half.\n+\n+\t  Sadly in this case we can't rely on reload moving the value to XMM\n+\t  register, since we need to know if upper half is OK, so we need\n+\t  to do reloading by hand.  We force operand to memory unless target\n+\t  supports inter unit moves.  */\n+       if (!flag_trapping_math)\n+         operands[1] = force_reg (SImode, operands[1]);\n+       else if (!MEM_P (operands[1]))\n+\t {\n+\t   rtx tmp = assign_386_stack_local (SImode, SLOT_VIRTUAL);\n+\t   emit_move_insn (tmp, operands[1]);\n+\t   operands[1] = tmp;\n+\t }\n+     }\n+  \")\n+\n+(define_insn \"*floatsisf2_mixed_vector\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x,f,?f\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"x,m,r\")))]\n+  \"TARGET_MIX_SSE_I387 && !flag_trapping_math \n+   && TARGET_USE_VECTOR_CONVERTS && !optimize_size\"\n+  \"@\n+   cvtpq2ps\\t{%1, %0|%0, %1}\n+   fild%z1\\t%1\n+   #\"\n+  [(set_attr \"type\" \"sseicvt,fmov,multi\")\n+   (set_attr \"mode\" \"SF\")\n+   (set_attr \"unit\" \"*,i387,*\")\n+   (set_attr \"athlon_decode\" \"double,*,*\")\n+   (set_attr \"amdfam10_decode\" \"double,*,*\")\n+   (set_attr \"fp_int_src\" \"false,true,true\")])\n \n (define_insn \"*floatsisf2_mixed\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,?f,x,x\")\n \t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r,r,m\")))]\n-  \"TARGET_MIX_SSE_I387\"\n+  \"TARGET_MIX_SSE_I387\n+   && (!TARGET_USE_VECTOR_CONVERTS || optimize_size)\"\n   \"@\n    fild%z1\\t%1\n    #\n@@ -4703,49 +4846,158 @@\n    (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_insn \"*floatsisf2_sse_vector_nointernunit\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(float:SF (match_operand:SI 1 \"memory_operand\" \"m\")))]\n+  \"flag_trapping_math && TARGET_USE_VECTOR_CONVERTS && !optimize_size\n+   && !TARGET_INTER_UNIT_MOVES\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*floatsisf2_sse_vector_internunit\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x,x\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"rm,x\")))]\n+  \"flag_trapping_math && TARGET_USE_VECTOR_CONVERTS && !optimize_size\n+   && TARGET_INTER_UNIT_MOVES\"\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_split \n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"\")))]\n+  \"flag_trapping_math\n+   && TARGET_USE_VECTOR_CONVERTS && reload_completed\n+   && (TARGET_INTER_UNIT_MOVES || MEM_P (operands[1]))\n+   && !SSE_REG_P (operands[1]) && SSE_REG_P (operands[0])\"\n+  [(set (match_dup 0)\n+\t(float:V4SF (match_dup 2)))]\n+{\n+  operands[2] = simplify_gen_subreg (V4SImode, operands[0], SFmode, 0);\n+  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+  emit_insn (gen_sse2_loadld (operands[2], CONST0_RTX (V4SImode), operands[1]));\n+})\n+\n+(define_split \n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"flag_trapping_math\n+   && TARGET_USE_VECTOR_CONVERTS && reload_completed\n+   && SSE_REG_P (operands[1]) && SSE_REG_P (operands[0])\"\n+  [(set (match_dup 2) (vec_duplicate:V4SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(float:V4SF (match_dup 2)))]\n+{\n+  operands[2] = simplify_gen_subreg (V4SImode, operands[0], SFmode, 0);\n+  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n+})\n+\n+(define_insn \"*floatsisf2_sse_vector\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"x\")))]\n+  \"!flag_trapping_math && TARGET_USE_VECTOR_CONVERTS && !optimize_size\n+   && !TARGET_INTER_UNIT_MOVES\"\n+  \"cvtpq2ps\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseicvt\")\n+   (set_attr \"mode\" \"SF\")\n+   (set_attr \"athlon_decode\" \"double\")\n+   (set_attr \"amdfam10_decode\" \"double\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n (define_insn \"*floatsisf2_sse\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x,x\")\n \t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n-  \"TARGET_SSE_MATH\"\n+  \"TARGET_SSE_MATH\n+   && (!TARGET_USE_VECTOR_CONVERTS || optimize_size)\"\n   \"cvtsi2ss\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"athlon_decode\" \"vector,double\")\n    (set_attr \"amdfam10_decode\" \"vector,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_insn \"*floatsidf2_mixed_vector\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x,f,f\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"x,m,r\")))]\n+  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n+   && TARGET_USE_VECTOR_CONVERTS && !optimize_size\"\n+  \"@\n+   cvtdq2pd\\t{%1, %0|%0, %1}\n+   fild%z1\\t%1\n+   #\"\n+  [(set_attr \"type\" \"sseicvt,fmov,multi\")\n+   (set_attr \"mode\" \"V2DF,DF,DF\")\n+   (set_attr \"unit\" \"*,*,i387\")\n+   (set_attr \"athlon_decode\" \"double,*,*\")\n+   (set_attr \"amdfam10_decode\" \"double,*,*\")\n+   (set_attr \"fp_int_src\" \"false,true,true\")])\n+\n (define_insn \"*floatsidf2_mixed\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,x,x\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r,r,m\")))]\n-  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,x,x,!x\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"m,r,r,m,x\")))]\n+  \"TARGET_SSE2 && TARGET_MIX_SSE_I387\n+    && (!TARGET_USE_VECTOR_CONVERTS || !optimize_size)\"\n   \"@\n    fild%z1\\t%1\n    #\n    cvtsi2sd\\t{%1, %0|%0, %1}\n-   cvtsi2sd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"fmov,multi,sseicvt,sseicvt\")\n-   (set_attr \"mode\" \"DF\")\n-   (set_attr \"unit\" \"*,i387,*,*\")\n-   (set_attr \"athlon_decode\" \"*,*,double,direct\")\n-   (set_attr \"amdfam10_decode\" \"*,*,vector,double\")\n+   cvtsi2sd\\t{%1, %0|%0, %1}\n+   cvtdq2pd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"fmov,multi,sseicvt,sseicvt,sseicvt\")\n+   (set_attr \"mode\" \"DF,DF,DF,DF,V2DF\")\n+   (set_attr \"unit\" \"*,i387,*,*,*\")\n+   (set_attr \"athlon_decode\" \"*,*,double,direct,double\")\n+   (set_attr \"amdfam10_decode\" \"*,*,vector,double,double\")\n+   (set_attr \"fp_int_src\" \"true,true,true,true,false\")])\n+\n+(define_insn \"*floatsidf2_sse_vector\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\n+   && TARGET_USE_VECTOR_CONVERTS && !optimize_size\"\n+  \"cvtdq2pd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"sseicvt\")\n+   (set_attr \"mode\" \"V2DF\")\n+   (set_attr \"athlon_decode\" \"double\")\n+   (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n+(define_split \n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(float:DF (match_operand:SI 1 \"memory_operand\" \"\")))]\n+  \"TARGET_USE_VECTOR_CONVERTS && reload_completed\n+   && SSE_REG_P (operands[0])\"\n+  [(set (match_dup 0)\n+\t(float:V2DF\n+\t  (vec_select:V2SI\n+\t    (match_dup 2)\n+\t    (parallel [(const_int 0) (const_int 1)]))))]\n+{\n+  operands[2] = simplify_gen_subreg (V4SImode, operands[0], DFmode, 0);\n+  operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n+  emit_insn (gen_sse2_loadld (operands[2], CONST0_RTX (V4SImode), operands[1]));\n+})\n+\n (define_insn \"*floatsidf2_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,x\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"r,m\")))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"cvtsi2sd\\t{%1, %0|%0, %1}\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x,x,!x\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,x\")))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\n+   && (!TARGET_USE_VECTOR_CONVERTS || optimize_size)\"\n+  \"@\n+   cvtsi2sd\\t{%1, %0|%0, %1} \n+   cvtsi2sd\\t{%1, %0|%0, %1} \n+   cvtdq2pd\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sseicvt\")\n-   (set_attr \"mode\" \"DF\")\n-   (set_attr \"athlon_decode\" \"double,direct\")\n-   (set_attr \"amdfam10_decode\" \"vector,double\")\n+   (set_attr \"mode\" \"DF,DF,V2DF\")\n+   (set_attr \"athlon_decode\" \"double,direct,double\")\n+   (set_attr \"amdfam10_decode\" \"vector,double,double\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n (define_insn \"*floatsi<mode>2_i387\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f\")\n \t(float:MODEF\n \t  (match_operand:SI 1 \"nonimmediate_operand\" \"m,?r\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387\n+   && (!TARGET_SSE_MATH || !SSE_FLOAT_MODE_P (GET_MODE (operands[0])))\"\n   \"@\n    fild%z1\\t%1\n    #\""}, {"sha": "03b2577b2cec521d0b3f3b98572d74f9f0c034b2", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4845dbb50ed31ad03c579364e4b70bbe90e7af99/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=4845dbb50ed31ad03c579364e4b70bbe90e7af99", "patch": "@@ -2740,7 +2740,7 @@\n   [(set_attr \"type\" \"sselog1\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"*vec_dupv2df\"\n+(define_insn \"vec_dupv2df\"\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n \t(vec_duplicate:V2DF\n \t  (match_operand:DF 1 \"register_operand\" \"0\")))]"}]}