{"sha": "002bd6069c005f868b97d40d6c43871ed1bc87e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyYmQ2MDY5YzAwNWY4NjhiOTdkNDBkNmM0Mzg3MWVkMWJjODdlNQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-05-26T14:54:42Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-05-26T14:54:42Z"}, "message": "re PR libstdc++/9339 (filebuf::pubsetbuf(0, 0) doesn't turn off buffering)\n\n\n2003-05-26  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/9339\n\t* include/std/std_fstream.h (basic_filebuf::_M_overflow): Remove.\n\t(_M_pback): No array necessary.\n\t* include/bits/fstream.tcc (basic_filebuf::_M_overflow): Add\n\tunbuffered case, coalesec into ...\n\t(basic_filebuf::overflow): ...this.\n\t* testsuite/27_io/basic_filebuf/sputn/char/9339.cc: New.\n\t* testsuite/27_io/basic_filebuf/sputc/char/2.cc: Unbuffered.\n\nFrom-SVN: r67175", "tree": {"sha": "87e029216a1b1646c2d61ba790662dfbc132990a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87e029216a1b1646c2d61ba790662dfbc132990a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/002bd6069c005f868b97d40d6c43871ed1bc87e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002bd6069c005f868b97d40d6c43871ed1bc87e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002bd6069c005f868b97d40d6c43871ed1bc87e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002bd6069c005f868b97d40d6c43871ed1bc87e5/comments", "author": null, "committer": null, "parents": [{"sha": "b91c701d199af4c4860919595ccf2cc755418cc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91c701d199af4c4860919595ccf2cc755418cc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91c701d199af4c4860919595ccf2cc755418cc1"}], "stats": {"total": 308, "additions": 232, "deletions": 76}, "files": [{"sha": "7165b8e6cc87d201e418ef75b5bef0112d5345cf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -1,3 +1,14 @@\n+2003-05-26  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/9339\n+\t* include/std/std_fstream.h (basic_filebuf::_M_overflow): Remove.\n+\t(_M_pback): No array necessary.\n+\t* include/bits/fstream.tcc (basic_filebuf::_M_overflow): Add\n+\tunbuffered case, coalesec into ...\n+\t(basic_filebuf::overflow): ...this.\n+\t* testsuite/27_io/basic_filebuf/sputn/char/9339.cc: New.\n+\t* testsuite/27_io/basic_filebuf/sputc/char/2.cc: Unbuffered.\n+\t\n 2003-05-24  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* libsupc++/Makefile.am, libsupc++/cxxabi.h, libsupc++/del_op.cc,\n@@ -58,6 +69,7 @@\n \n 2003-05-22  Brad Spencer  <spencer@infointeractive.com>\n \n+\tPR libstdc++/10106\n \t* configure.in: Add Solaris cross bits.\n \n 2003-05-21  Danny Smith  <dannysmith@users.sourceforge.net>"}, {"sha": "9bbb5cc1a52927f28322110aff6ccce51bd70ca1", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -73,7 +73,7 @@ namespace std\n     basic_filebuf() : __streambuf_type(), _M_file(&_M_lock), \n     _M_state_cur(__state_type()), _M_state_beg(__state_type()), \n     _M_buf(NULL), _M_buf_size(BUFSIZ), _M_buf_allocated(false),\n-    _M_last_overflowed(false), _M_pback_cur_save(0),\n+    _M_last_overflowed(false), _M_filepos(0), _M_pback_cur_save(0),\n     _M_pback_end_save(0), _M_pback_init(false), _M_codecvt(0)\n     { \n       this->_M_buf_unified = true; \t  \n@@ -125,15 +125,15 @@ namespace std\n \t      const bool __testput = this->_M_out_beg < this->_M_out_lim;\n \n \t      if (__testput \n-\t\t  && traits_type::eq_int_type(_M_overflow(__eof), __eof))\n+\t\t  && traits_type::eq_int_type(this->overflow(), __eof))\n \t\t__testfail = true;\n \n #if 0\n \t      // XXX not done\n \t      if (_M_last_overflowed)\n \t\t{\n \t\t  _M_output_unshift();\n-\t\t  _M_overflow(__eof);\n+\t\t  this->overflow();\n \t\t}\n #endif\n \t    }\n@@ -204,7 +204,7 @@ namespace std\n \n \t  // Sync internal and external buffers.\n \t  if (__testout && this->_M_out_beg < this->_M_out_lim)\n-\t    _M_overflow();\n+\t    this->overflow();\n \n \t  if (_M_buf_size > 1)\n \t    {\n@@ -321,67 +321,49 @@ namespace std\n       return __ret;\n     }\n \n-  template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::int_type \n-    basic_filebuf<_CharT, _Traits>::\n-    _M_overflow(int_type __c)\n-    {\n-      int_type __ret = traits_type::eof();\n-      const bool __testeof = traits_type::eq_int_type(__c, __ret);\n-      const bool __testput = this->_M_out_beg < this->_M_out_lim;\n-\n-      if (__testput)\n- \t{\n- \t  // Need to restore current position. The position of the\n- \t  // external byte sequence (_M_file) corresponds to\n- \t  // _M_filepos, and we need to move it to _M_out_beg for the\n- \t  // write.\n-\t  if (_M_filepos != this->_M_out_beg)\n-\t    _M_file.seekoff(this->_M_out_beg - _M_filepos, ios_base::cur);\n-\n-\t  // If appropriate, append the overflow char.\n-\t  if (!__testeof)\n-\t    *this->_M_out_lim++ = traits_type::to_char_type(__c);\n-\n-\t  // Convert pending sequence to external representation,\n-\t  // output. \n-\t  if (_M_convert_to_external(this->_M_out_beg,\n-\t\t\t\t     this->_M_out_lim - this->_M_out_beg)\n-\t      && (!__testeof || (__testeof && !_M_file.sync())))\n-\t    {\n-\t      _M_set_buffer(0);\n-\t      __ret = traits_type::not_eof(__c);\n-\t    }\n-\t}\n-      _M_last_overflowed = true;\t\n-      return __ret;\n-    }\n-\n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n     overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n-      const bool __testput = this->_M_out_cur < this->_M_out_end;\n+      const bool __testeof = traits_type::eq_int_type(__c, __ret);\n       const bool __testout = this->_M_mode & ios_base::out;\n       \n-      // Perhaps set below in _M_overflow.\n-      _M_last_overflowed = false;\n-\n       if (__testout)\n \t{\n-\t  if (traits_type::eq_int_type(__c, traits_type::eof()))\n-\t    __ret = traits_type::not_eof(__c);\n-\t  else if (__testput)\n+\t  if (this->_M_out_beg < this->_M_out_lim)\n+\t    {\n+\t      // Need to restore current position. The position of the\n+\t      // external byte sequence (_M_file) corresponds to\n+\t      // _M_filepos, and we need to move it to _M_out_beg for\n+\t      // the write.\n+\t      if (_M_filepos != this->_M_out_beg)\n+\t\t_M_file.seekoff(this->_M_out_beg - _M_filepos, ios_base::cur);\n+\n+\t      // If appropriate, append the overflow char.\n+\t      if (!__testeof)\n+\t\t*this->_M_out_lim++ = traits_type::to_char_type(__c);\n+\t      \n+\t      // Convert pending sequence to external representation,\n+\t      // output.\n+\t      if (_M_convert_to_external(this->_M_out_beg,\n+\t\t\t\t\t this->_M_out_lim - this->_M_out_beg)\n+\t\t  && (!__testeof || (__testeof && !_M_file.sync())))\n+\t\t{\n+\t\t  _M_set_buffer(0);\n+\t\t  __ret = traits_type::not_eof(__c);\n+\t\t}\n+\t    }\n+\t  else\n \t    {\n- \t      *this->_M_out_cur = traits_type::to_char_type(__c);\n-\t      _M_move_out_cur(1);\n-\t      __ret = traits_type::not_eof(__c);\n+\t      // Unbuffered.\n+\t      char_type __conv = traits_type::to_char_type(__c);\n+\t      if (!__testeof && _M_convert_to_external(&__conv, 1))\n+\t\t__ret = __c;\n \t    }\n-\t  else \n-\t    __ret = this->_M_overflow(__c);\n \t}\n+      _M_last_overflowed = true;\t\n       return __ret;\n     }\n   "}, {"sha": "5b76c40f9288c85d77f47eb8aa028d6ca27cef2d", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -115,7 +115,7 @@ namespace std\n       while (__ret < __n)\n \t{\n \t  const size_t __buf_len = _M_in_end - _M_in_cur;\n-\t  if (__buf_len > 0)\n+\t  if (__buf_len)\n \t    {\n \t      const size_t __remaining = __n - __ret;\n \t      const size_t __len = std::min(__buf_len, __remaining);\n@@ -149,7 +149,7 @@ namespace std\n       while (__ret < __n)\n \t{\n \t  const size_t __buf_len = _M_out_end - _M_out_cur;\n-\t  if (__buf_len > 0)\n+\t  if (__buf_len)\n \t    {\n \t      const size_t __remaining = __n - __ret;\n \t      const size_t __len = std::min(__buf_len, __remaining);\n@@ -161,7 +161,7 @@ namespace std\n \n \t  if (__ret < __n)\n \t    {\n-\t      const int_type __c = this->overflow(traits_type::to_int_type(*__s));\n+\t      int_type __c = this->overflow(traits_type::to_int_type(*__s));\n \t      if (!traits_type::eq_int_type(__c, traits_type::eof()))\n \t\t{\n \t\t  ++__ret;"}, {"sha": "9faf73730062947996d42b69e3ff53ec0e20f832", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -158,7 +158,7 @@ namespace std\n        *  @note pbacks of over one character are not currently supported.\n        *  @endif\n       */\n-      char_type\t\t\t_M_pback[1]; \n+      char_type\t\t\t_M_pback; \n       char_type*\t\t_M_pback_cur_save;\n       char_type*\t\t_M_pback_end_save;\n       bool\t\t\t_M_pback_init; \n@@ -177,7 +177,7 @@ namespace std\n \t  {\n \t    _M_pback_cur_save = this->_M_in_cur;\n \t    _M_pback_end_save = this->_M_in_end;\n-\t    this->setg(_M_pback, _M_pback, _M_pback + 1);\n+\t    this->setg(&_M_pback, &_M_pback, &_M_pback + 1);\n \t    _M_pback_init = true;\n \t  }\n       }\n@@ -191,8 +191,8 @@ namespace std\n \tif (_M_pback_init)\n \t  {\n \t    // Length _M_in_cur moved in the pback buffer.\n-\t    const size_t __off_cur = this->_M_in_cur - _M_pback;\n-\t    this->setg(this->_M_buf, _M_pback_cur_save + __off_cur, \n+\t    const size_t __off = this->_M_in_cur == &_M_pback ? 0 : 1;\n+\t    this->setg(this->_M_buf, _M_pback_cur_save + __off, \n \t\t       _M_pback_end_save);\n \t    _M_pback_init = false;\n \t  }\n@@ -311,19 +311,6 @@ namespace std\n       virtual int_type\n       pbackfail(int_type __c = _Traits::eof());\n \n-      // NB: For what the standard expects of the overflow function,\n-      // see _M_overflow(), below. Because basic_streambuf's\n-      // sputc/sputn call overflow directly, and the complications of\n-      // this implementation's setting of the initial pointers all\n-      // equal to _M_buf when initializing, it seems essential to have\n-      // this in actuality be a helper function that checks for the\n-      // eccentricities of this implementation, and then call\n-      // overflow() if indeed the buffer is full.\n-\n-      // [documentation is inherited]\n-      virtual int_type\n-      overflow(int_type __c = _Traits::eof());\n-\n       // Stroustrup, 1998, p 648\n       // The overflow() function is called to transfer characters to the\n       // real output destination when the buffer is full. A call to\n@@ -336,8 +323,8 @@ namespace std\n        *  @doctodo\n        *  @endif\n       */\n-      int_type\n-      _M_overflow(int_type __c = _Traits::eof());\n+      virtual int_type\n+      overflow(int_type __c = _Traits::eof());\n \n       // Convert internal byte sequence to external, char-based\n       // sequence via codecvt.\n@@ -389,7 +376,7 @@ namespace std\n \t    off_type __off = this->_M_out_cur - this->_M_out_lim;\n \n \t    // _M_file.sync() will be called within\n-\t    if (traits_type::eq_int_type(_M_overflow(), traits_type::eof()))\n+\t    if (traits_type::eq_int_type(this->overflow(), traits_type::eof()))\n \t      __ret = -1;\n \t    else if (__off)\n \t      _M_file.seekoff(__off, ios_base::cur);\n@@ -444,7 +431,7 @@ namespace std\n \n       // This function sets the pointers of the internal buffer, both get\n       // and put areas. Typically, __off == _M_in_end - _M_in_beg upon\n-      // _M_underflow; __off == 0 upon _M_overflow, seekoff, open, setbuf.\n+      // _M_underflow; __off == 0 upon overflow, seekoff, open, setbuf.\n       // \n       // NB: _M_out_end - _M_out_beg == _M_buf_size - 1, since _M_buf_size\n       // reflects the actual allocated memory and the last cell is reserved"}, {"sha": "f6a4ae8b0db37e230c37a0f4ca0d7fe485c47523", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/sputc/char/2.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputc%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputc%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputc%2Fchar%2F2.cc?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -0,0 +1,129 @@\n+// 2003-05-21 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.4 Overridden virtual functions\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+// @require@ %-*.tst %-*.txt\n+// @diff@ %-*.tst %*.txt\n+\n+// NB: This test assumes that _M_buf_size == 40, and not the usual\n+// buffer_size length of BUFSIZ (8192), so that overflow/underflow can be\n+// simulated a bit more readily.\n+// NRB (Nota Really Bene): setting it to 40 breaks the test, as intended.\n+const int buffer_size = 8192;\n+//const int buffer_size = 40;\n+\n+const char name_01[] = \"filebuf_virtuals-1.txt\"; // file with data in it\n+const char name_02[] = \"filebuf_virtuals-2.txt\"; // empty file, need to create\n+const char name_03[] = \"filebuf_virtuals-3.txt\"; // empty file, need to create\n+\n+class derived_filebuf: public std::filebuf\n+{\n+ public:\n+  void\n+  set_size(int_type __size) { _M_buf_size = __size; }\n+};\n+\n+derived_filebuf fb_01; // in \n+derived_filebuf fb_02; // out\n+derived_filebuf fb_03; // in | out\n+\n+// Initialize filebufs to be the same size regardless of platform.\n+void test03()\n+{\n+  fb_01.set_size(buffer_size);\n+  fb_02.set_size(buffer_size);\n+  fb_03.set_size(buffer_size);\n+}\n+\n+// Test overloaded virtual functions.\n+void test05() \n+{\n+  typedef std::filebuf::int_type \tint_type;\n+  typedef std::filebuf::traits_type \ttraits_type;\n+  typedef std::filebuf::pos_type \tpos_type;\n+  typedef std::filebuf::off_type \toff_type;\n+  typedef size_t \t\t\tsize_type;\n+\n+  bool \t\t\t\t\ttest = true;\n+  std::filebuf \t\t\t\tf_tmp;\n+  std::streamsize \t\t\tstrmsz_1, strmsz_2;\n+  std::streamoff  \t\t\tstrmof_1, strmof_2;\n+  int \t\t\t\t\ti = 0, j = 0, k = 0;\n+\n+  // Unbuffered\n+  fb_01.pubsetbuf(0, 0);\n+  fb_02.pubsetbuf(0, 0);\n+  fb_03.pubsetbuf(0, 0);\n+\n+  fb_01.open(name_01, std::ios_base::in);\n+  fb_02.open(name_02, std::ios_base::out | std::ios_base::trunc);\n+  fb_03.open(name_03, std::ios_base::out | std::ios_base::in | std::ios_base::trunc);\n+\n+  int_type c1 = fb_01.sbumpc();\n+  int_type c2 = fb_02.sbumpc();\n+  int_type c3 = fb_01.sbumpc();\n+  int_type c4 = fb_02.sbumpc();\n+  int_type c5 = fb_03.sbumpc();\n+  int_type c6 = fb_01.sgetc();\n+  int_type c7 = fb_02.sgetc();\n+  int_type c8 = fb_01.sgetc();\n+  int_type c9 = fb_02.sgetc();\n+\n+  // PUT\n+  // int_type sputc(char_type c)\n+  // if out_cur not avail, return overflow(traits_type::to_int_type(c)) \n+  // else, stores c at out_cur,\n+  // increments out_cur, and returns c as int_type\n+  // strmsz_1 = fb_03.in_avail();  // XXX valid for in|out??\n+  c1 = fb_02.sputc('a'); \n+  c2 = fb_03.sputc('b'); \n+  VERIFY( c1 != c2 );\n+  c1 = fb_02.sputc('c'); \n+  c2 = fb_03.sputc('d'); \n+  VERIFY( c1 != c2 );\n+  // strmsz_2 = fb_03.in_avail();\n+  // VERIFY( strmsz_1 != strmsz_2 );\n+  for (int i = 50; i <= 90; ++i) \n+    c2 = fb_02.sputc(char(i));\n+  // 27filebuf-2.txt == ac23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n+  // fb_02._M_out_cur = '2'\n+  strmsz_1 = fb_03.in_avail();\n+  for (int i = 50; i <= 90; ++i) \n+    c2 = fb_03.sputc(char(i));\n+  strmsz_2 = fb_03.in_avail();\n+  // VERIFY( strmsz_1 != strmsz_2 );\n+  // VERIFY( strmsz_1 > 0 );\n+  // VERIFY( strmsz_2 > 0 );\n+  // 27filebuf-2.txt == bd23456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWX\n+  // fb_02._M_out_cur = '2'\n+  c3 = fb_01.sputc('a'); // should be EOF because this is read-only\n+  VERIFY( c3 == traits_type::eof() );\n+}\n+\n+main() \n+{\n+  test03();\n+  test05();\n+  return 0;\n+}"}, {"sha": "37a4145044919bc1e8ccd0c4e3a074932e3fa6da", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/sputn/char/9339.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputn%2Fchar%2F9339.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002bd6069c005f868b97d40d6c43871ed1bc87e5/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputn%2Fchar%2F9339.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Fsputn%2Fchar%2F9339.cc?ref=002bd6069c005f868b97d40d6c43871ed1bc87e5", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/9339\n+void test01()\n+{\n+  using namespace std;\n+  bool test = true;\n+\n+  filebuf fbuf01;\n+  int len = 35;\n+  fbuf01.pubsetbuf(0, 0);\n+  fbuf01.open(\"tmp_9339\", ios_base::out | ios_base::trunc);\n+  streamsize s1 = fbuf01.sputn(\"Pete Goldlust @ Carl Hammer Gallery\", len);\n+  VERIFY( s1 == len );\n+\n+  filebuf fbuf02;\n+  char buf[256];\n+  fbuf02.open(\"tmp_9339\", ios_base::in);\n+  streamsize s2 = fbuf02.sgetn(buf, 256);\n+  VERIFY( s2 == len );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}