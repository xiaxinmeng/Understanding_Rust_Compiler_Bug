{"sha": "a80b1eb72d6f227fc7d1cca36a6c29614a80ab10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgwYjFlYjcyZDZmMjI3ZmM3ZDFjY2EzNmE2YzI5NjE0YTgwYWIxMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-03-24T13:57:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-12T08:29:26Z"}, "message": "[Ada] Improve code generated for assignment of dynamic record aggregates\n\n2020-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb: Add with and use clauses for Sem_Mech.\n\t(Get_Base_Object): New function to get the base object of a node.\n\t(In_Place_Assign_OK): Add Target_Object parameter.  Deal with a\n\tqualified expression on entry.  Remove short-circuit for array\n\taggregates with a single \"others\" choice.  Do not look into the\n\tcomponents of the aggregate if the parent is an allocator.\n\t(Check_Component): Add T_OK parameter and rewrite.\n\t(Safe_Component): Invoke Check_Component with T_OK set to False.\n\t(Convert_To_Assignments): Try to use an in-place assignment for\n\tany target; for that, call Get_Base_Object on the target and pass\n\tthe result to In_Place_Assign_OK.\n\t(Expand_Array_Aggregate): Use Parent_Kind and Parent_Node more\n\tconsistently.  For an assignment, call Get_Base_Object on the\n\ttarget and pass the result to In_Place_Assign_OK.", "tree": {"sha": "460771b890dc690cf5337ac8acdbe29a598e0c85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/460771b890dc690cf5337ac8acdbe29a598e0c85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b7399e34bab3aec45af99da7c31eb571f27f21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2b7399e34bab3aec45af99da7c31eb571f27f21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2b7399e34bab3aec45af99da7c31eb571f27f21"}], "stats": {"total": 311, "additions": 231, "deletions": 80}, "files": [{"sha": "22ed3aeddebd906eea3dc159cfaab0be3e3a2c85", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 231, "deletions": 80, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80b1eb72d6f227fc7d1cca36a6c29614a80ab10/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=a80b1eb72d6f227fc7d1cca36a6c29614a80ab10", "patch": "@@ -53,6 +53,7 @@ with Sem_Aggr; use Sem_Aggr;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -86,6 +87,11 @@ package body Exp_Aggr is\n    procedure Expand_Delta_Array_Aggregate  (N : Node_Id; Deltas : List_Id);\n    procedure Expand_Delta_Record_Aggregate (N : Node_Id; Deltas : List_Id);\n \n+   function Get_Base_Object (N : Node_Id) return Entity_Id;\n+   --  Return the base object, i.e. the outermost prefix object, that N refers\n+   --  to statically, or Empty if it cannot be determined. The assumption is\n+   --  that all dereferences are explicit in the tree rooted at N.\n+\n    function Has_Default_Init_Comps (N : Node_Id) return Boolean;\n    --  N is an aggregate (record or array). Checks the presence of default\n    --  initialization (<>) in any component (Ada 2005: AI-287).\n@@ -217,7 +223,9 @@ package body Exp_Aggr is\n    --  defaults. An aggregate for a type with mutable components must be\n    --  expanded into individual assignments.\n \n-   function In_Place_Assign_OK (N : Node_Id) return Boolean;\n+   function In_Place_Assign_OK\n+     (N             : Node_Id;\n+      Target_Object : Entity_Id := Empty) return Boolean;\n    --  Predicate to determine whether an aggregate assignment can be done in\n    --  place, because none of the new values can depend on the components of\n    --  the target of the assignment.\n@@ -4122,23 +4130,40 @@ package body Exp_Aggr is\n    -- In_Place_Assign_OK --\n    ------------------------\n \n-   function In_Place_Assign_OK (N : Node_Id) return Boolean is\n+   function In_Place_Assign_OK\n+     (N             : Node_Id;\n+      Target_Object : Entity_Id := Empty) return Boolean\n+   is\n       Is_Array : constant Boolean := Is_Array_Type (Etype (N));\n \n-      Aggr_In : Node_Id;\n-      Aggr_Lo : Node_Id;\n-      Aggr_Hi : Node_Id;\n-      Obj_In  : Node_Id;\n-      Obj_Lo  : Node_Id;\n-      Obj_Hi  : Node_Id;\n+      Aggr_In     : Node_Id;\n+      Aggr_Lo     : Node_Id;\n+      Aggr_Hi     : Node_Id;\n+      Obj_In      : Node_Id;\n+      Obj_Lo      : Node_Id;\n+      Obj_Hi      : Node_Id;\n+      Parent_Kind : Node_Kind;\n+      Parent_Node : Node_Id;\n \n       function Safe_Aggregate (Aggr : Node_Id) return Boolean;\n       --  Check recursively that each component of a (sub)aggregate does not\n       --  depend on the variable being assigned to.\n \n       function Safe_Component (Expr : Node_Id) return Boolean;\n-      --  Verify that an expression cannot depend on the variable being\n-      --  assigned to. Room for improvement here (but less than before).\n+      --  Verify that an expression cannot depend on the target being assigned\n+      --  to. Return true for compile-time known values, stand-alone objects,\n+      --  parameters passed by copy, calls to functions that return by copy,\n+      --  selected components thereof only if the aggregate's type is an array,\n+      --  indexed components and slices thereof only if the aggregate's type is\n+      --  a record, and simple expressions involving only these as operands.\n+      --  This is OK whatever the target because, for a component to overlap\n+      --  with the target, it must be either a direct reference to a component\n+      --  of the target, in which case there must be a matching selection or\n+      --  indexation or slicing, or an indirect reference to such a component,\n+      --  which is excluded by the above condition. Additionally, if the target\n+      --  is statically known, return true for arbitrarily nested selections,\n+      --  indexations or slicings, provided that their ultimate prefix is not\n+      --  the target itself.\n \n       --------------------\n       -- Safe_Aggregate --\n@@ -4200,43 +4225,137 @@ package body Exp_Aggr is\n       function Safe_Component (Expr : Node_Id) return Boolean is\n          Comp : Node_Id := Expr;\n \n-         function Check_Component (Comp : Node_Id) return Boolean;\n-         --  Do the recursive traversal, after copy\n+         function Check_Component (C : Node_Id; T_OK : Boolean) return Boolean;\n+         --  Do the recursive traversal, after copy. If T_OK is True, return\n+         --  True for a stand-alone object only if the target is statically\n+         --  known and distinct from the object. At the top level, we start\n+         --  with T_OK set to False and set it to True at a deeper level only\n+         --  if we cannot disambiguate the component here without statically\n+         --  knowing the target. Note that this is not optimal, we should do\n+         --  something along the lines of Denotes_Same_Prefix for that.\n \n          ---------------------\n          -- Check_Component --\n          ---------------------\n \n-         function Check_Component (Comp : Node_Id) return Boolean is\n+         function Check_Component (C : Node_Id; T_OK : Boolean) return Boolean\n+         is\n+\n+            function SDO (E : Entity_Id) return Uint;\n+            --  Return the Scope Depth Of the enclosing dynamic scope of E\n+\n+            ---------\n+            -- SDO --\n+            ---------\n+\n+            function SDO (E : Entity_Id) return Uint is\n+            begin\n+               return Scope_Depth (Enclosing_Dynamic_Scope (E));\n+            end SDO;\n+\n+         --  Start of processing for Check_Component\n+\n          begin\n-            if Is_Overloaded (Comp) then\n+            if Is_Overloaded (C) then\n                return False;\n+\n+            elsif Compile_Time_Known_Value (C) then\n+               return True;\n             end if;\n \n-            return Compile_Time_Known_Value (Comp)\n+            case Nkind (C) is\n+               when N_Attribute_Reference =>\n+                  return Check_Component (Prefix (C), T_OK);\n+\n+               when N_Function_Call =>\n+                  if Nkind (Name (C)) = N_Explicit_Dereference then\n+                     return not Returns_By_Ref (Etype (Name (C)));\n+                  else\n+                     return not Returns_By_Ref (Entity (Name (C)));\n+                  end if;\n+\n+               when N_Indexed_Component | N_Slice =>\n+                  --  In a target record, these operations cannot determine\n+                  --  alone a component so we can recurse whatever the target.\n+                  return Check_Component (Prefix (C), T_OK or else Is_Array);\n+\n+               when N_Selected_Component =>\n+                  --  In a target array, this operation cannot determine alone\n+                  --  a component so we can recurse whatever the target.\n+                  return\n+                    Check_Component (Prefix (C), T_OK or else not Is_Array);\n+\n+               when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+                  return Check_Component (Expression (C), T_OK);\n \n-              or else (Is_Entity_Name (Comp)\n-                        and then Present (Entity (Comp))\n-                        and then Ekind (Entity (Comp)) not in Type_Kind\n-                        and then No (Renamed_Object (Entity (Comp))))\n+               when N_Binary_Op =>\n+                  return Check_Component (Left_Opnd (C), T_OK)\n+                    and then Check_Component (Right_Opnd (C), T_OK);\n \n-              or else (Nkind (Comp) = N_Attribute_Reference\n-                        and then Check_Component (Prefix (Comp)))\n+               when N_Unary_Op =>\n+                  return Check_Component (Right_Opnd (C), T_OK);\n \n-              or else (Nkind (Comp) in N_Binary_Op\n-                        and then Check_Component (Left_Opnd  (Comp))\n-                        and then Check_Component (Right_Opnd (Comp)))\n+               when others =>\n+                  if Is_Entity_Name (C) and then Is_Object (Entity (C)) then\n+                     --  Case of a formal parameter component. It's either\n+                     --  trivial if passed by copy or very annoying if not,\n+                     --  because in the latter case it's almost equivalent\n+                     --  to a dereference, so the path-based disambiguation\n+                     --  logic is totally off and we always need the target.\n \n-              or else (Nkind (Comp) in N_Unary_Op\n-                        and then Check_Component (Right_Opnd (Comp)))\n+                     if Is_Formal (Entity (C)) then\n+\n+                        --  If it is passed by copy, then this is safe\n+\n+                        if Mechanism (Entity (C)) = By_Copy then\n+                           return True;\n+\n+                        --  Otherwise, this is safe if the target is present\n+                        --  and is at least as deeply nested as the component.\n+\n+                        else\n+                           return Present (Target_Object)\n+                             and then not Is_Formal (Target_Object)\n+                             and then SDO (Target_Object) >= SDO (Entity (C));\n+                        end if;\n+\n+                     --  For a renamed object, recurse\n+\n+                     elsif Present (Renamed_Object (Entity (C))) then\n+                        return\n+                          Check_Component (Renamed_Object (Entity (C)), T_OK);\n+\n+                     --  If this is safe whatever the target, we are done\n+\n+                     elsif not T_OK then\n+                        return True;\n+\n+                     --  If there is no target or the component is the target,\n+                     --  this is not safe.\n+\n+                     elsif No (Target_Object)\n+                       or else Entity (C) = Target_Object\n+                     then\n+                        return False;\n+\n+                     --  Case of a formal parameter target. This is safe if it\n+                     --  is at most as deeply nested as the component.\n+\n+                     elsif Is_Formal (Target_Object) then\n+                        return SDO (Target_Object) <= SDO (Entity (C));\n+\n+                     --  For distinct stand-alone objects, this is safe\n+\n+                     else\n+                        return True;\n+                     end if;\n \n-              or else (Nkind (Comp) = N_Selected_Component\n-                        and then Is_Array\n-                        and then Check_Component (Prefix (Comp)))\n+                  --  For anything else than an object, this is not safe\n \n-              or else (Nkind_In (Comp, N_Type_Conversion,\n-                                       N_Unchecked_Type_Conversion)\n-                        and then Check_Component (Expression (Comp)));\n+                  else\n+                     return False;\n+                  end if;\n+            end case;\n          end Check_Component;\n \n       --  Start of processing for Safe_Component\n@@ -4275,7 +4394,7 @@ package body Exp_Aggr is\n          if Nkind (Comp) = N_Aggregate then\n             return Safe_Aggregate (Comp);\n          else\n-            return Check_Component (Comp);\n+            return Check_Component (Comp, False);\n          end if;\n       end Safe_Component;\n \n@@ -4286,43 +4405,51 @@ package body Exp_Aggr is\n \n       if Needs_Finalization (Etype (N)) then\n          return False;\n+      end if;\n \n-      elsif Is_Array and then Present (Component_Associations (N)) then\n+      Parent_Node := Parent (N);\n+      Parent_Kind := Nkind (Parent_Node);\n \n-         --  On assignment, sliding can take place, so we cannot do the\n-         --  assignment in place unless the bounds of the aggregate are\n-         --  statically equal to those of the target.\n+      if Parent_Kind = N_Qualified_Expression then\n+         Parent_Node := Parent (Parent_Node);\n+         Parent_Kind := Nkind (Parent_Node);\n+      end if;\n \n-         --  If the aggregate is given by an others choice, the bounds are\n-         --  derived from the left-hand side, and the assignment is safe if\n-         --  the expression is.\n+      --  On assignment, sliding can take place, so we cannot do the\n+      --  assignment in place unless the bounds of the aggregate are\n+      --  statically equal to those of the target.\n \n-         if Is_Others_Aggregate (N) then\n-            return\n-              Safe_Component\n-               (Expression (First (Component_Associations (N))));\n-         end if;\n+      --  If the aggregate is given by an others choice, the bounds are\n+      --  derived from the left-hand side, and the assignment is safe if\n+      --  the expression is.\n \n+      if Is_Array\n+        and then Present (Component_Associations (N))\n+        and then not Is_Others_Aggregate (N)\n+      then\n          Aggr_In := First_Index (Etype (N));\n \n-         if Nkind (Parent (N)) = N_Assignment_Statement then\n-            Obj_In := First_Index (Etype (Name (Parent (N))));\n+         if Parent_Kind = N_Assignment_Statement then\n+            Obj_In := First_Index (Etype (Name (Parent_Node)));\n \n          else\n             --  Context is an allocator. Check bounds of aggregate against\n             --  given type in qualified expression.\n \n-            pragma Assert (Nkind (Parent (Parent (N))) = N_Allocator);\n+            pragma Assert (Parent_Kind = N_Allocator);\n             Obj_In := First_Index (Etype (Entity (Subtype_Mark (Parent (N)))));\n          end if;\n \n          while Present (Aggr_In) loop\n             Get_Index_Bounds (Aggr_In, Aggr_Lo, Aggr_Hi);\n             Get_Index_Bounds (Obj_In, Obj_Lo, Obj_Hi);\n \n-            if not Compile_Time_Known_Value (Aggr_Lo)\n-              or else not Compile_Time_Known_Value (Obj_Lo)\n+            --  We require static bounds for the target and a static matching\n+            --  of low bound for the aggregate.\n+\n+            if not Compile_Time_Known_Value (Obj_Lo)\n               or else not Compile_Time_Known_Value (Obj_Hi)\n+              or else not Compile_Time_Known_Value (Aggr_Lo)\n               or else Expr_Value (Aggr_Lo) /= Expr_Value (Obj_Lo)\n             then\n                return False;\n@@ -4336,8 +4463,8 @@ package body Exp_Aggr is\n             --  diminishing returns) for safely building arrays in place\n             --  here.\n \n-            elsif Nkind (Parent (N)) = N_Assignment_Statement\n-              or else Is_Constrained (Etype (Parent (N)))\n+            elsif Parent_Kind = N_Assignment_Statement\n+              or else Is_Constrained (Etype (Parent_Node))\n             then\n                if not Compile_Time_Known_Value (Aggr_Hi)\n                  or else Expr_Value (Aggr_Hi) /= Expr_Value (Obj_Hi)\n@@ -4351,9 +4478,14 @@ package body Exp_Aggr is\n          end loop;\n       end if;\n \n-      --  Now check the component values themselves\n+      --  Now check the component values themselves, except for an allocator\n+      --  for which the target is newly allocated memory.\n \n-      return Safe_Aggregate (N);\n+      if Parent_Kind = N_Allocator then\n+         return True;\n+      else\n+         return Safe_Aggregate (N);\n+      end if;\n    end In_Place_Assign_OK;\n \n    ----------------------------\n@@ -4468,14 +4600,13 @@ package body Exp_Aggr is\n            Build_Record_Aggr_Code (N, Typ, Target_Expr));\n          Rewrite (Parent_Node, Make_Null_Statement (Loc));\n \n-      --  Do not declare a temporary to initialize an aggregate assigned to an\n-      --  identifier when in-place assignment is possible, preserving the\n+      --  Do not declare a temporary to initialize an aggregate assigned to\n+      --  a target when in-place assignment is possible, i.e. preserving the\n       --  by-copy semantic of aggregates. This avoids large stack usage and\n       --  generates more efficient code.\n \n       elsif Parent_Kind = N_Assignment_Statement\n-        and then Nkind (Name (Parent_Node)) = N_Identifier\n-        and then In_Place_Assign_OK (N)\n+        and then In_Place_Assign_OK (N, Get_Base_Object (Name (Parent_Node)))\n       then\n          declare\n             Lhs : constant Node_Id := Name (Parent_Node);\n@@ -6284,14 +6415,15 @@ package body Exp_Aggr is\n       then\n          Maybe_In_Place_OK := False;\n \n-      else\n+      elsif Parent_Kind = N_Assignment_Statement then\n          Maybe_In_Place_OK :=\n-          (Nkind (Parent (N)) = N_Assignment_Statement\n-            and then In_Place_Assign_OK (N))\n+           In_Place_Assign_OK (N, Get_Base_Object (Name (Parent_Node)));\n+\n+      elsif Parent_Kind = N_Allocator then\n+         Maybe_In_Place_OK := In_Place_Assign_OK (N);\n \n-            or else\n-             (Nkind (Parent (Parent (N))) = N_Allocator\n-              and then In_Place_Assign_OK (N));\n+      else\n+         Maybe_In_Place_OK := False;\n       end if;\n \n       --  If this is an array of tasks, it will be expanded into build-in-place\n@@ -6345,28 +6477,25 @@ package body Exp_Aggr is\n             Set_Etype (Tmp, Typ);\n          end if;\n \n-      elsif Maybe_In_Place_OK\n-        and then Nkind (Parent (N)) = N_Qualified_Expression\n-        and then Nkind (Parent (Parent (N))) = N_Allocator\n-      then\n+      elsif Maybe_In_Place_OK and then Parent_Kind = N_Allocator then\n          Set_Expansion_Delayed (N);\n          return;\n \n       --  Limited arrays in return statements are expanded when\n       --  enclosing construct is expanded.\n \n       elsif Maybe_In_Place_OK\n-        and then Nkind (Parent (N)) = N_Simple_Return_Statement\n+        and then Parent_Kind = N_Simple_Return_Statement\n       then\n          Set_Expansion_Delayed (N);\n          return;\n \n       --  In the remaining cases the aggregate is the RHS of an assignment\n \n       elsif Maybe_In_Place_OK\n-        and then Safe_Left_Hand_Side (Name (Parent (N)))\n+        and then Safe_Left_Hand_Side (Name (Parent_Node))\n       then\n-         Tmp := Name (Parent (N));\n+         Tmp := Name (Parent_Node);\n \n          if Etype (Tmp) /= Etype (N) then\n             Apply_Length_Check (N, Etype (Tmp));\n@@ -6384,10 +6513,10 @@ package body Exp_Aggr is\n       --  by converting it into a loop over the discrete range of the slice.\n \n       elsif Maybe_In_Place_OK\n-        and then Nkind (Name (Parent (N))) = N_Slice\n+        and then Nkind (Name (Parent_Node)) = N_Slice\n         and then Is_Others_Aggregate (N)\n       then\n-         Tmp := Name (Parent (N));\n+         Tmp := Name (Parent_Node);\n \n          --  Set type of aggregate to be type of lhs in assignment, in order\n          --  to suppress redundant length checks.\n@@ -6415,7 +6544,7 @@ package body Exp_Aggr is\n          --  around the aggregate for this purpose.\n \n          if Ekind (Current_Scope) = E_Loop\n-           and then Nkind (Parent (Parent (N))) = N_Allocator\n+           and then Parent_Kind = N_Allocator\n          then\n             Establish_Transient_Scope (N, Manage_Sec_Stack => False);\n          end if;\n@@ -6525,13 +6654,13 @@ package body Exp_Aggr is\n       --  If the aggregate has been assigned in place, remove the original\n       --  assignment.\n \n-      if Nkind (Parent (N)) = N_Assignment_Statement\n-        and then Maybe_In_Place_OK\n-      then\n-         Rewrite (Parent (N), Make_Null_Statement (Loc));\n+      if Parent_Kind = N_Assignment_Statement and then Maybe_In_Place_OK then\n+         Rewrite (Parent_Node, Make_Null_Statement (Loc));\n+\n+      --  Or else, if a temporary was created, replace the aggregate with it\n \n-      elsif Nkind (Parent (N)) /= N_Object_Declaration\n-        or else Tmp /= Defining_Identifier (Parent (N))\n+      elsif Parent_Kind /= N_Object_Declaration\n+        or else Tmp /= Defining_Identifier (Parent_Node)\n       then\n          Rewrite (N, New_Occurrence_Of (Tmp, Loc));\n          Analyze_And_Resolve (N, Typ);\n@@ -7611,6 +7740,28 @@ package body Exp_Aggr is\n       end if;\n    end Expand_Record_Aggregate;\n \n+   ---------------------\n+   -- Get_Base_Object --\n+   ---------------------\n+\n+   function Get_Base_Object (N : Node_Id) return Entity_Id is\n+      R : Node_Id;\n+\n+   begin\n+      R := Get_Referenced_Object (N);\n+\n+      while Nkind_In (R, N_Indexed_Component, N_Selected_Component, N_Slice)\n+      loop\n+         R := Get_Referenced_Object (Prefix (R));\n+      end loop;\n+\n+      if Is_Entity_Name (R) and then Is_Object (Entity (R)) then\n+         return Entity (R);\n+      else\n+         return Empty;\n+      end if;\n+   end Get_Base_Object;\n+\n    ----------------------------\n    -- Has_Default_Init_Comps --\n    ----------------------------"}]}