{"sha": "e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg2OWFhMzkzNmQ0NmRkNjdiMWRjMzRlODljM2JlZTY3ZjRmZmUwNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-01-26T21:53:22Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-01-26T21:53:22Z"}, "message": "* combine.c: Fix formatting.\n\nFrom-SVN: r61862", "tree": {"sha": "d13a8351a6ecbff2e59d36ac1483ac2ad9362efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d13a8351a6ecbff2e59d36ac1483ac2ad9362efd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06/comments", "author": null, "committer": null, "parents": [{"sha": "74fb48112b2eb9edd02860dccfcf6ed2cdf5d096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fb48112b2eb9edd02860dccfcf6ed2cdf5d096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74fb48112b2eb9edd02860dccfcf6ed2cdf5d096"}], "stats": {"total": 35, "additions": 20, "deletions": 15}, "files": [{"sha": "5dc933ef673e5d2f187edda925e0ad83ed1b5948", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "patch": "@@ -1,3 +1,7 @@\n+2003-01-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* combine.c: Fix formatting.\n+\n 2003-01-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/gccint.texi: Update the copyright."}, {"sha": "5c5bfceb0f2861af13921894c50294801f80bf60", "filename": "gcc/combine.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e869aa3936d46dd67b1dc34e89c3bee67f4ffe06/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e869aa3936d46dd67b1dc34e89c3bee67f4ffe06", "patch": "@@ -1,6 +1,6 @@\n /* Optimize by combining instructions for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -444,7 +444,7 @@ do_SUBST (into, newval)\n \t  || (GET_CODE (oldval) == ZERO_EXTEND\n \t      && GET_CODE (XEXP (oldval, 0)) == CONST_INT))\n \tabort ();\n-     }\n+    }\n \n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n@@ -4286,7 +4286,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t \"a = (b & 8) == 0;\"  */\n       if (XEXP (x, 1) == constm1_rtx\n \t  && GET_CODE (XEXP (x, 0)) != REG\n-\t  && ! (GET_CODE (XEXP (x,0)) == SUBREG\n+\t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG)\n \t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n \treturn simplify_shift_const (NULL_RTX, ASHIFTRT, mode,\n@@ -4349,8 +4349,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t     XEXP (x, 0));\n \t}\n \n-       /* Canonicalize (minus (neg A) (mult B C)) to \n-\t  (minus (mult (neg B) C) A).  */\n+      /* Canonicalize (minus (neg A) (mult B C)) to \n+\t (minus (mult (neg B) C) A).  */\n       if (GET_CODE (XEXP (x, 1)) == MULT \n \t  && GET_CODE (XEXP (x, 0)) == NEG)\n \t{\n@@ -4550,7 +4550,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t  == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE(mode)-1))\n+\t\t  == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n \t      && (i = exact_log2 (nonzero_bits (op0, mode))) >= 0)\n@@ -5325,16 +5325,16 @@ simplify_set (x)\n \n       if (GET_CODE (true_rtx) == IOR\n \t  && rtx_equal_p (XEXP (true_rtx, 0), false_rtx))\n-\tterm1 = false_rtx, true_rtx = XEXP(true_rtx, 1), false_rtx = const0_rtx;\n+\tterm1 = false_rtx, true_rtx = XEXP (true_rtx, 1), false_rtx = const0_rtx;\n       else if (GET_CODE (true_rtx) == IOR\n \t       && rtx_equal_p (XEXP (true_rtx, 1), false_rtx))\n-\tterm1 = false_rtx, true_rtx = XEXP(true_rtx, 0), false_rtx = const0_rtx;\n+\tterm1 = false_rtx, true_rtx = XEXP (true_rtx, 0), false_rtx = const0_rtx;\n       else if (GET_CODE (false_rtx) == IOR\n \t       && rtx_equal_p (XEXP (false_rtx, 0), true_rtx))\n-\tterm1 = true_rtx, false_rtx = XEXP(false_rtx, 1), true_rtx = const0_rtx;\n+\tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 1), true_rtx = const0_rtx;\n       else if (GET_CODE (false_rtx) == IOR\n \t       && rtx_equal_p (XEXP (false_rtx, 1), true_rtx))\n-\tterm1 = true_rtx, false_rtx = XEXP(false_rtx, 0), true_rtx = const0_rtx;\n+\tterm1 = true_rtx, false_rtx = XEXP (false_rtx, 0), true_rtx = const0_rtx;\n \n       term2 = gen_binary (AND, GET_MODE (src),\n \t\t\t  XEXP (XEXP (src, 0), 0), true_rtx);\n@@ -6452,7 +6452,7 @@ extract_left_shift (x, count)\n     case PLUS:  case IOR:  case XOR:  case AND:\n       /* If we can safely shift this constant and we find the inner shift,\n \t make a new operation.  */\n-      if (GET_CODE (XEXP (x,1)) == CONST_INT\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n \treturn gen_binary (code, mode, tem,\n@@ -7254,7 +7254,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t  temp = simplify_binary_operation (code == ROTATE ? ROTATERT : ROTATE,\n \t\t\t\t\t    GET_MODE (x), GEN_INT (mask),\n \t\t\t\t\t    XEXP (x, 1));\n-\t  if (temp && GET_CODE(temp) == CONST_INT)\n+\t  if (temp && GET_CODE (temp) == CONST_INT)\n \t    SUBST (XEXP (x, 0),\n \t\t   force_to_mode (XEXP (x, 0), GET_MODE (x),\n \t\t\t\t  INTVAL (temp), reg, next_select));\n@@ -7326,7 +7326,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n       SUBST (XEXP (x, 2),\n \t     gen_lowpart_for_combine (GET_MODE (x),\n \t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n-\t\t\t\t\t\t     mask, reg,next_select)));\n+\t\t\t\t\t\t     mask, reg, next_select)));\n       break;\n \n     default:\n@@ -9798,7 +9798,7 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n   /* If COMPLEMENT_P is set, we have to complement X before doing the outer\n      operation.  */\n   if (complement_p)\n-    x =simplify_gen_unary (NOT, result_mode, x, result_mode);\n+    x = simplify_gen_unary (NOT, result_mode, x, result_mode);\n \n   if (outer_op != NIL)\n     {\n@@ -10454,7 +10454,7 @@ simplify_comparison (code, pop0, pop1)\n \n \t  /* (unsigned) > 0x7fffffff is equivalent to < 0.  */\n \t  else if ((mode_width <= HOST_BITS_PER_WIDE_INT)\n-\t\t    && (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1))\n+\t\t   && (const_op == ((HOST_WIDE_INT) 1 << (mode_width - 1)) - 1))\n \t    {\n \t      const_op = 0, op1 = const0_rtx;\n \t      code = LT;\n@@ -11277,6 +11277,7 @@ combine_reversed_comparison_code (exp)\n   return reversed_comparison_code_parts (GET_CODE (exp),\n \t\t\t\t\t XEXP (x, 0), XEXP (x, 1), NULL);\n }\n+\n /* Return comparison with reversed code of EXP and operands OP0 and OP1.\n    Return NULL_RTX in case we fail to do the reversal.  */\n static rtx"}]}