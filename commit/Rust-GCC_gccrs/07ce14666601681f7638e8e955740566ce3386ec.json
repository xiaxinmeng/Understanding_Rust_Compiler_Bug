{"sha": "07ce14666601681f7638e8e955740566ce3386ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjZTE0NjY2NjAxNjgxZjc2MzhlOGU5NTU3NDA1NjZjZTMzODZlYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-23T14:35:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-23T14:35:14Z"}, "message": "Rework subreg_get_info\n\nThis isn't intended to change the behaviour, just rewrite the\nexisting logic in a different (and hopefully clearer) way.\nThe new form -- particularly the part based on the \"block\"\nconcept -- is easier to convert to polynomial sizes.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* rtlanal.c (subreg_get_info): Use more local variables.\n\tRemark that for HARD_REGNO_NREGS_HAS_PADDING, each scalar unit\n\toccupies at least one register.  Assume that full hard registers\n\thave consistent endianness.  Share previously-duplicated if block.\n\tRework the main handling so that it operates on independently-\n\taddressable YMODE-sized blocks.  Use subreg_size_lowpart_offset\n\tto check lowpart offsets, without trying to find an equivalent\n\tinteger mode first.  Handle WORDS_BIG_ENDIAN != REG_WORDS_BIG_ENDIAN\n\tas a final register-endianness correction.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242758", "tree": {"sha": "439840ddfbc5c78d1509ca3b8db2e443dd4a4a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/439840ddfbc5c78d1509ca3b8db2e443dd4a4a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07ce14666601681f7638e8e955740566ce3386ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ce14666601681f7638e8e955740566ce3386ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ce14666601681f7638e8e955740566ce3386ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ce14666601681f7638e8e955740566ce3386ec/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "712871dde1fb2d29b4f742fababb645cd3b1dbbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712871dde1fb2d29b4f742fababb645cd3b1dbbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712871dde1fb2d29b4f742fababb645cd3b1dbbe"}], "stats": {"total": 158, "additions": 81, "deletions": 77}, "files": [{"sha": "a931d1ef03ae81d6b881fca25545f3cda8ee6b15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ce14666601681f7638e8e955740566ce3386ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ce14666601681f7638e8e955740566ce3386ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07ce14666601681f7638e8e955740566ce3386ec", "patch": "@@ -1,3 +1,17 @@\n+2016-11-23  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtlanal.c (subreg_get_info): Use more local variables.\n+\tRemark that for HARD_REGNO_NREGS_HAS_PADDING, each scalar unit\n+\toccupies at least one register.  Assume that full hard registers\n+\thave consistent endianness.  Share previously-duplicated if block.\n+\tRework the main handling so that it operates on independently-\n+\taddressable YMODE-sized blocks.  Use subreg_size_lowpart_offset\n+\tto check lowpart offsets, without trying to find an equivalent\n+\tinteger mode first.  Handle WORDS_BIG_ENDIAN != REG_WORDS_BIG_ENDIAN\n+\tas a final register-endianness correction.\n+\n 2016-11-23  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/77881"}, {"sha": "17dbb1eaeb10809b2416052eda4ed8bd3f015455", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 67, "deletions": 77, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ce14666601681f7638e8e955740566ce3386ec/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ce14666601681f7638e8e955740566ce3386ec/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=07ce14666601681f7638e8e955740566ce3386ec", "patch": "@@ -3588,31 +3588,29 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t\t unsigned int offset, machine_mode ymode,\n \t\t struct subreg_info *info)\n {\n-  int nregs_xmode, nregs_ymode;\n-  int mode_multiple, nregs_multiple;\n-  int offset_adj, y_offset, y_offset_adj;\n-  int regsize_xmode, regsize_ymode;\n-  bool rknown;\n+  unsigned int nregs_xmode, nregs_ymode;\n \n   gcc_assert (xregno < FIRST_PSEUDO_REGISTER);\n \n-  rknown = false;\n+  unsigned int xsize = GET_MODE_SIZE (xmode);\n+  unsigned int ysize = GET_MODE_SIZE (ymode);\n+  bool rknown = false;\n \n-  /* If there are holes in a non-scalar mode in registers, we expect\n-     that it is made up of its units concatenated together.  */\n+  /* If the register representation of a non-scalar mode has holes in it,\n+     we expect the scalar units to be concatenated together, with the holes\n+     distributed evenly among the scalar units.  Each scalar unit must occupy\n+     at least one register.  */\n   if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n     {\n-      machine_mode xmode_unit;\n-\n       nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n-      xmode_unit = GET_MODE_INNER (xmode);\n+      unsigned int nunits = GET_MODE_NUNITS (xmode);\n+      machine_mode xmode_unit = GET_MODE_INNER (xmode);\n       gcc_assert (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode_unit));\n       gcc_assert (nregs_xmode\n-\t\t  == (GET_MODE_NUNITS (xmode)\n+\t\t  == (nunits\n \t\t      * HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode_unit)));\n       gcc_assert (hard_regno_nregs[xregno][xmode]\n-\t\t  == (hard_regno_nregs[xregno][xmode_unit]\n-\t\t      * GET_MODE_NUNITS (xmode)));\n+\t\t  == hard_regno_nregs[xregno][xmode_unit] * nunits);\n \n       /* You can only ask for a SUBREG of a value with holes in the middle\n \t if you don't cross the holes.  (Such a SUBREG should be done by\n@@ -3622,11 +3620,9 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t 3 for each part, but in memory it's two 128-bit parts.\n \t Padding is assumed to be at the end (not necessarily the 'high part')\n \t of each unit.  */\n-      if ((offset / GET_MODE_SIZE (xmode_unit) + 1\n-\t   < GET_MODE_NUNITS (xmode))\n+      if ((offset / GET_MODE_SIZE (xmode_unit) + 1 < nunits)\n \t  && (offset / GET_MODE_SIZE (xmode_unit)\n-\t      != ((offset + GET_MODE_SIZE (ymode) - 1)\n-\t\t  / GET_MODE_SIZE (xmode_unit))))\n+\t      != ((offset + ysize - 1) / GET_MODE_SIZE (xmode_unit))))\n \t{\n \t  info->representable_p = false;\n \t  rknown = true;\n@@ -3638,18 +3634,20 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n   nregs_ymode = hard_regno_nregs[xregno][ymode];\n \n   /* Paradoxical subregs are otherwise valid.  */\n-  if (!rknown\n-      && offset == 0\n-      && GET_MODE_PRECISION (ymode) > GET_MODE_PRECISION (xmode))\n+  if (!rknown && offset == 0 && ysize > xsize)\n     {\n       info->representable_p = true;\n       /* If this is a big endian paradoxical subreg, which uses more\n \t actual hard registers than the original register, we must\n \t return a negative offset so that we find the proper highpart\n-\t of the register.  */\n-      if (GET_MODE_SIZE (ymode) > UNITS_PER_WORD\n-\t  ? REG_WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN)\n-\tinfo->offset = nregs_xmode - nregs_ymode;\n+\t of the register.\n+\n+\t We assume that the ordering of registers within a multi-register\n+\t value has a consistent endianness: if bytes and register words\n+\t have different endianness, the hard registers that make up a\n+\t multi-register value must be at least word-sized.  */\n+      if (REG_WORDS_BIG_ENDIAN)\n+\tinfo->offset = (int) nregs_xmode - (int) nregs_ymode;\n       else\n \tinfo->offset = 0;\n       info->nregs = nregs_ymode;\n@@ -3660,31 +3658,23 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n      modes, we cannot generally form this subreg.  */\n   if (!HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode)\n       && !HARD_REGNO_NREGS_HAS_PADDING (xregno, ymode)\n-      && (GET_MODE_SIZE (xmode) % nregs_xmode) == 0\n-      && (GET_MODE_SIZE (ymode) % nregs_ymode) == 0)\n+      && (xsize % nregs_xmode) == 0\n+      && (ysize % nregs_ymode) == 0)\n     {\n-      regsize_xmode = GET_MODE_SIZE (xmode) / nregs_xmode;\n-      regsize_ymode = GET_MODE_SIZE (ymode) / nregs_ymode;\n-      if (!rknown && regsize_xmode > regsize_ymode && nregs_ymode > 1)\n-\t{\n-\t  info->representable_p = false;\n-\t  info->nregs\n-\t    = (GET_MODE_SIZE (ymode) + regsize_xmode - 1) / regsize_xmode;\n-\t  info->offset = offset / regsize_xmode;\n-\t  return;\n-\t}\n-      if (!rknown && regsize_ymode > regsize_xmode && nregs_xmode > 1)\n+      int regsize_xmode = xsize / nregs_xmode;\n+      int regsize_ymode = ysize / nregs_ymode;\n+      if (!rknown\n+\t  && ((nregs_ymode > 1 && regsize_xmode > regsize_ymode)\n+\t      || (nregs_xmode > 1 && regsize_ymode > regsize_xmode)))\n \t{\n \t  info->representable_p = false;\n-\t  info->nregs\n-\t    = (GET_MODE_SIZE (ymode) + regsize_xmode - 1) / regsize_xmode;\n+\t  info->nregs = CEIL (ysize, regsize_xmode);\n \t  info->offset = offset / regsize_xmode;\n \t  return;\n \t}\n       /* It's not valid to extract a subreg of mode YMODE at OFFSET that\n \t would go outside of XMODE.  */\n-      if (!rknown\n-\t  && GET_MODE_SIZE (ymode) + offset > GET_MODE_SIZE (xmode))\n+      if (!rknown && ysize + offset > xsize)\n \t{\n \t  info->representable_p = false;\n \t  info->nregs = nregs_ymode;\n@@ -3704,7 +3694,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t  info->representable_p = true;\n \t  info->nregs = nregs_ymode;\n \t  info->offset = offset / regsize_ymode;\n-\t  gcc_assert (info->offset + info->nregs <= nregs_xmode);\n+\t  gcc_assert (info->offset + info->nregs <= (int) nregs_xmode);\n \t  return;\n \t}\n     }\n@@ -3723,47 +3713,47 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t}\n     }\n \n-  /* This should always pass, otherwise we don't know how to verify\n-     the constraint.  These conditions may be relaxed but\n-     subreg_regno_offset would need to be redesigned.  */\n-  gcc_assert ((GET_MODE_SIZE (xmode) % GET_MODE_SIZE (ymode)) == 0);\n+  /* Set NUM_BLOCKS to the number of independently-representable YMODE\n+     values there are in (reg:XMODE XREGNO).  We can view the register\n+     as consisting of this number of independent \"blocks\", where each\n+     block occupies NREGS_YMODE registers and contains exactly one\n+     representable YMODE value.  */\n   gcc_assert ((nregs_xmode % nregs_ymode) == 0);\n+  unsigned int num_blocks = nregs_xmode / nregs_ymode;\n \n-  if (WORDS_BIG_ENDIAN != REG_WORDS_BIG_ENDIAN\n-      && GET_MODE_SIZE (xmode) > UNITS_PER_WORD)\n-    {\n-      HOST_WIDE_INT xsize = GET_MODE_SIZE (xmode);\n-      HOST_WIDE_INT ysize = GET_MODE_SIZE (ymode);\n-      HOST_WIDE_INT off_low = offset & (ysize - 1);\n-      HOST_WIDE_INT off_high = offset & ~(ysize - 1);\n-      offset = (xsize - ysize - off_high) | off_low;\n-    }\n-  /* The XMODE value can be seen as a vector of NREGS_XMODE\n-     values.  The subreg must represent a lowpart of given field.\n-     Compute what field it is.  */\n-  offset_adj = offset;\n-  offset_adj -= subreg_lowpart_offset (ymode,\n-\t\t\t\t       mode_for_size (GET_MODE_BITSIZE (xmode)\n-\t\t\t\t\t\t      / nregs_xmode,\n-\t\t\t\t\t\t      MODE_INT, 0));\n-\n-  /* Size of ymode must not be greater than the size of xmode.  */\n-  mode_multiple = GET_MODE_SIZE (xmode) / GET_MODE_SIZE (ymode);\n-  gcc_assert (mode_multiple != 0);\n-\n-  y_offset = offset / GET_MODE_SIZE (ymode);\n-  y_offset_adj = offset_adj / GET_MODE_SIZE (ymode);\n-  nregs_multiple = nregs_xmode / nregs_ymode;\n-\n-  gcc_assert ((offset_adj % GET_MODE_SIZE (ymode)) == 0);\n-  gcc_assert ((mode_multiple % nregs_multiple) == 0);\n+  /* Calculate the number of bytes in each block.  This must always\n+     be exact, otherwise we don't know how to verify the constraint.\n+     These conditions may be relaxed but subreg_regno_offset would\n+     need to be redesigned.  */\n+  gcc_assert ((xsize % num_blocks) == 0);\n+  unsigned int bytes_per_block = xsize / num_blocks;\n+\n+  /* Get the number of the first block that contains the subreg and the byte\n+     offset of the subreg from the start of that block.  */\n+  unsigned int block_number = offset / bytes_per_block;\n+  unsigned int subblock_offset = offset % bytes_per_block;\n \n   if (!rknown)\n     {\n-      info->representable_p = (!(y_offset_adj % (mode_multiple / nregs_multiple)));\n+      /* Only the lowpart of each block is representable.  */\n+      info->representable_p\n+\t= (subblock_offset\n+\t   == subreg_size_lowpart_offset (ysize, bytes_per_block));\n       rknown = true;\n     }\n-  info->offset = (y_offset / (mode_multiple / nregs_multiple)) * nregs_ymode;\n+\n+  /* We assume that the ordering of registers within a multi-register\n+     value has a consistent endianness: if bytes and register words\n+     have different endianness, the hard registers that make up a\n+     multi-register value must be at least word-sized.  */\n+  if (WORDS_BIG_ENDIAN != REG_WORDS_BIG_ENDIAN)\n+    /* The block number we calculated above followed memory endianness.\n+       Convert it to register endianness by counting back from the end.\n+       (Note that, because of the assumption above, each block must be\n+       at least word-sized.)  */\n+    info->offset = (num_blocks - block_number - 1) * nregs_ymode;\n+  else\n+    info->offset = block_number * nregs_ymode;\n   info->nregs = nregs_ymode;\n }\n "}]}