{"sha": "7dad9fb498327683bb15405ff77b542f10680baa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhZDlmYjQ5ODMyNzY4M2JiMTU0MDVmZjc3YjU0MmYxMDY4MGJhYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-11-22T00:13:42Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-11-22T00:13:42Z"}, "message": "cse.c (enum taken): Remove PATH_AROUND.\n\n\t* cse.c (enum taken): Remove PATH_AROUND.\n\t(addr_affects_sp_p, invalidate_skipped_set,\n\tinvalidate_skipped_block): Remove.\n\t(cse_end_of_basic_block): Remove skip_blocks and related code.\n\t(cse_main): Don't test for flag_cse_skip_blocks.\n\tUpdate cse_end_of_basic_block call.\n\t(cse_basic_block): Likewise.  Remove PATH_AROUND case.  Remove\n\tcode to lengthen the path if a jump was simplified.\n\nFrom-SVN: r119079", "tree": {"sha": "7432ac01a388f61bdb912d3b8773674dd51788ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7432ac01a388f61bdb912d3b8773674dd51788ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dad9fb498327683bb15405ff77b542f10680baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dad9fb498327683bb15405ff77b542f10680baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dad9fb498327683bb15405ff77b542f10680baa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dad9fb498327683bb15405ff77b542f10680baa/comments", "author": null, "committer": null, "parents": [{"sha": "7d93d98774676539dcda428d198342bdc793ccac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d93d98774676539dcda428d198342bdc793ccac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d93d98774676539dcda428d198342bdc793ccac"}], "stats": {"total": 233, "additions": 25, "deletions": 208}, "files": [{"sha": "1a72573b2db26069740f6eded6b00017fa330453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dad9fb498327683bb15405ff77b542f10680baa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dad9fb498327683bb15405ff77b542f10680baa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dad9fb498327683bb15405ff77b542f10680baa", "patch": "@@ -1,3 +1,14 @@\n+2006-11-22  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cse.c (enum taken): Remove PATH_AROUND.\n+\t(addr_affects_sp_p, invalidate_skipped_set,\n+\tinvalidate_skipped_block): Remove.\n+\t(cse_end_of_basic_block): Remove skip_blocks and related code.\n+\t(cse_main): Don't test for flag_cse_skip_blocks.\n+\tUpdate cse_end_of_basic_block call.\n+\t(cse_basic_block): Likewise.  Remove PATH_AROUND case.  Remove\n+\tcode to lengthen the path if a jump was simplified.\n+\n 2006-11-22  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR rtl-optimization/29924"}, {"sha": "15cc2d6a90212a07b2ef0ebd5c92db052de7621d", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 208, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dad9fb498327683bb15405ff77b542f10680baa/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dad9fb498327683bb15405ff77b542f10680baa/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7dad9fb498327683bb15405ff77b542f10680baa", "patch": "@@ -560,10 +560,8 @@ struct cse_basic_block_data\n     {\n       /* The branch insn.  */\n       rtx branch;\n-      /* Whether it should be taken or not.  AROUND is the same as taken\n-\t except that it is used when the destination label is not preceded\n-       by a BARRIER.  */\n-      enum taken {PATH_TAKEN, PATH_NOT_TAKEN, PATH_AROUND} status;\n+      /* Whether it should be taken or not.  */\n+      enum taken {PATH_TAKEN, PATH_NOT_TAKEN} status;\n     } *path;\n };\n \n@@ -610,12 +608,9 @@ static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n \t\t\t      int);\n static void cse_insn (rtx, rtx);\n static void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n-\t\t\t\t    int, int);\n-static int addr_affects_sp_p (rtx);\n+\t\t\t\t    int);\n static void invalidate_from_clobbers (rtx);\n static rtx cse_process_notes (rtx, rtx);\n-static void invalidate_skipped_set (rtx, rtx, void *);\n-static void invalidate_skipped_block (rtx);\n static rtx cse_basic_block (rtx, rtx, struct branch_path *);\n static void count_reg_usage (rtx, int *, rtx, int);\n static int check_for_label_ref (rtx *, void *);\n@@ -5679,33 +5674,6 @@ invalidate_memory (void)\n       }\n }\n \n-/* If ADDR is an address that implicitly affects the stack pointer, return\n-   1 and update the register tables to show the effect.  Else, return 0.  */\n-\n-static int\n-addr_affects_sp_p (rtx addr)\n-{\n-  if (GET_RTX_CLASS (GET_CODE (addr)) == RTX_AUTOINC\n-      && REG_P (XEXP (addr, 0))\n-      && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM)\n-    {\n-      if (REG_TICK (STACK_POINTER_REGNUM) >= 0)\n-\t{\n-\t  REG_TICK (STACK_POINTER_REGNUM)++;\n-\t  /* Is it possible to use a subreg of SP?  */\n-\t  SUBREG_TICKED (STACK_POINTER_REGNUM) = -1;\n-\t}\n-\n-      /* This should be *very* rare.  */\n-      if (TEST_HARD_REG_BIT (hard_regs_in_table, STACK_POINTER_REGNUM))\n-\tinvalidate (stack_pointer_rtx, VOIDmode);\n-\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* Perform invalidation on the basis of everything about an insn\n    except for invalidating the actual places that are SET in it.\n    This includes the places CLOBBERed, and anything that might\n@@ -5836,74 +5804,14 @@ cse_process_notes (rtx x, rtx object)\n   return x;\n }\n \f\n-/* Process one SET of an insn that was skipped.  We ignore CLOBBERs\n-   since they are done elsewhere.  This function is called via note_stores.  */\n-\n-static void\n-invalidate_skipped_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code = GET_CODE (dest);\n-\n-  if (code == MEM\n-      && ! addr_affects_sp_p (dest)\t/* If this is not a stack push ...  */\n-      /* There are times when an address can appear varying and be a PLUS\n-\t during this scan when it would be a fixed address were we to know\n-\t the proper equivalences.  So invalidate all memory if there is\n-\t a BLKmode or nonscalar memory reference or a reference to a\n-\t variable address.  */\n-      && (MEM_IN_STRUCT_P (dest) || GET_MODE (dest) == BLKmode\n-\t  || cse_rtx_varies_p (XEXP (dest, 0), 0)))\n-    {\n-      invalidate_memory ();\n-      return;\n-    }\n-\n-  if (GET_CODE (set) == CLOBBER\n-      || CC0_P (dest)\n-      || dest == pc_rtx)\n-    return;\n-\n-  if (code == STRICT_LOW_PART || code == ZERO_EXTRACT)\n-    invalidate (XEXP (dest, 0), GET_MODE (dest));\n-  else if (code == REG || code == SUBREG || code == MEM)\n-    invalidate (dest, VOIDmode);\n-}\n-\n-/* Invalidate all insns from START up to the end of the function or the\n-   next label.  This called when we wish to CSE around a block that is\n-   conditionally executed.  */\n-\n-static void\n-invalidate_skipped_block (rtx start)\n-{\n-  rtx insn;\n-\n-  for (insn = start; insn && !LABEL_P (insn);\n-       insn = NEXT_INSN (insn))\n-    {\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      if (CALL_P (insn))\n-\t{\n-\t  if (! CONST_OR_PURE_CALL_P (insn))\n-\t    invalidate_memory ();\n-\t  invalidate_for_call ();\n-\t}\n-\n-      invalidate_from_clobbers (PATTERN (insn));\n-      note_stores (PATTERN (insn), invalidate_skipped_set, NULL);\n-    }\n-}\n-\f\n /* Find the end of INSN's basic block and return its range,\n    the total number of SETs in all the insns of the block, the last insn of the\n    block, and the branch path.\n \n    The branch path indicates which branches should be followed.  If a nonzero\n    path size is specified, the block should be rescanned and a different set\n    of branches will be taken.  The branch path is only used if\n-   FLAG_CSE_FOLLOW_JUMPS or FLAG_CSE_SKIP_BLOCKS is nonzero.\n+   FLAG_CSE_FOLLOW_JUMPS is nonzero.\n \n    DATA is a pointer to a struct cse_basic_block_data, defined below, that is\n    used to describe the block.  It is filled in with the information about\n@@ -5912,7 +5820,7 @@ invalidate_skipped_block (rtx start)\n \n static void\n cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n-\t\t\tint follow_jumps, int skip_blocks)\n+\t\t\tint follow_jumps)\n {\n   rtx p = insn, q;\n   int nsets = 0;\n@@ -5943,9 +5851,9 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n      to figure out where to go next.  We want to return the next block\n      in the instruction stream, not some branched-to block somewhere\n      else.  We accomplish this by pretending our called forbid us to\n-     follow jumps, or skip blocks.  */\n+     follow jumps.  */\n   if (GET_MODE (insn) == QImode)\n-    follow_jumps = skip_blocks = 0;\n+    follow_jumps = 0;\n \n   /* Scan to end of this basic block.  */\n   while (p && !LABEL_P (p))\n@@ -5986,14 +5894,9 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n       /* If this is a conditional jump, we can follow it if -fcse-follow-jumps\n \t was specified, we haven't reached our maximum path length, there are\n \t insns following the target of the jump, this is the only use of the\n-\t jump label, and the target label is preceded by a BARRIER.\n-\n-\t Alternatively, we can follow the jump if it branches around a\n-\t block of code and there are no other branches into the block.\n-\t In this case invalidate_skipped_block will be called to invalidate any\n-\t registers set in the block when following the jump.  */\n-\n-      else if ((follow_jumps || skip_blocks) && path_size < PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH) - 1\n+\t jump label, and the target label is preceded by a BARRIER.  */\n+      else if (follow_jumps\n+\t       && path_size < PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH) - 1\n \t       && JUMP_P (p)\n \t       && GET_CODE (PATTERN (p)) == SET\n \t       && GET_CODE (SET_SRC (PATTERN (p))) == IF_THEN_ELSE\n@@ -6041,42 +5944,6 @@ cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n \t      /* Mark block so we won't scan it again later.  */\n \t      PUT_MODE (NEXT_INSN (p), QImode);\n \t    }\n-\t  /* Detect a branch around a block of code.  */\n-\t  else if (skip_blocks && q != 0 && !LABEL_P (q))\n-\t    {\n-\t      rtx tmp;\n-\n-\t      if (next_real_insn (q) == next)\n-\t\t{\n-\t\t  p = NEXT_INSN (p);\n-\t\t  continue;\n-\t\t}\n-\n-\t      for (i = 0; i < path_entry; i++)\n-\t\tif (data->path[i].branch == p)\n-\t\t  break;\n-\n-\t      if (i != path_entry)\n-\t\tbreak;\n-\n-\t      /* This is no_labels_between_p (p, q) with an added check for\n-\t\t reaching the end of a function (in case Q precedes P).  */\n-\t      for (tmp = NEXT_INSN (p); tmp && tmp != q; tmp = NEXT_INSN (tmp))\n-\t\tif (LABEL_P (tmp))\n-\t\t  break;\n-\n-\t      if (tmp == q)\n-\t\t{\n-\t\t  data->path[path_entry].branch = p;\n-\t\t  data->path[path_entry++].status = PATH_AROUND;\n-\n-\t\t  path_size = path_entry;\n-\n-\t\t  p = JUMP_LABEL (p);\n-\t\t  /* Mark block so we won't scan it again later.  */\n-\t\t  PUT_MODE (NEXT_INSN (p), QImode);\n-\t\t}\n-\t    }\n \t}\n       p = NEXT_INSN (p);\n     }\n@@ -6150,8 +6017,7 @@ cse_main (rtx f, int nregs)\n   while (insn)\n     {\n       cse_altered = 0;\n-      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps,\n-\t\t\t      flag_cse_skip_blocks);\n+      cse_end_of_basic_block (insn, &val, flag_cse_follow_jumps);\n \n       /* If this basic block was already processed or has no sets, skip it.  */\n       if (val.nsets == 0 || GET_MODE (insn) == QImode)\n@@ -6191,8 +6057,7 @@ cse_main (rtx f, int nregs)\n \t     us a new branch path to investigate.  */\n \t  cse_jumps_altered = 0;\n \t  temp = cse_basic_block (insn, val.last, val.path);\n-\t  if (cse_jumps_altered == 0\n-\t      || (flag_cse_follow_jumps == 0 && flag_cse_skip_blocks == 0))\n+\t  if (cse_jumps_altered == 0 || flag_cse_follow_jumps)\n \t    insn = temp;\n \n \t  cse_jumps_altered |= old_cse_jumps_altered;\n@@ -6264,10 +6129,8 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t  enum taken status = next_branch++->status;\n \t  if (status != PATH_NOT_TAKEN)\n \t    {\n-\t      if (status == PATH_TAKEN)\n-\t\trecord_jump_equiv (insn, 1);\n-\t      else\n-\t\tinvalidate_skipped_block (NEXT_INSN (insn));\n+\t      gcc_assert (status == PATH_TAKEN);\n+\t      record_jump_equiv (insn, 1);\n \n \t      /* Set the last insn as the jump insn; it doesn't affect cc0.\n \t\t Then follow this branch.  */\n@@ -6358,63 +6221,6 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \n \t  insn = PREV_INSN (to);\n \t}\n-\n-      /* See if it is ok to keep on going past the label\n-\t which used to end our basic block.  Remember that we incremented\n-\t the count of that label, so we decrement it here.  If we made\n-\t a jump unconditional, TO_USAGE will be one; in that case, we don't\n-\t want to count the use in that jump.  */\n-\n-      if (to != 0 && NEXT_INSN (insn) == to\n-\t  && LABEL_P (to) && --LABEL_NUSES (to) == to_usage)\n-\t{\n-\t  struct cse_basic_block_data val;\n-\t  rtx prev;\n-\n-\t  insn = NEXT_INSN (to);\n-\n-\t  /* If TO was the last insn in the function, we are done.  */\n-\t  if (insn == 0)\n-\t    {\n-\t      free (qty_table);\n-\t      return 0;\n-\t    }\n-\n-\t  /* If TO was preceded by a BARRIER we are done with this block\n-\t     because it has no continuation.  */\n-\t  prev = prev_nonnote_insn (to);\n-\t  if (prev && BARRIER_P (prev))\n-\t    {\n-\t      free (qty_table);\n-\t      return insn;\n-\t    }\n-\n-\t  /* Find the end of the following block.  Note that we won't be\n-\t     following branches in this case.  */\n-\t  to_usage = 0;\n-\t  val.path_size = 0;\n-\t  val.path = XNEWVEC (struct branch_path, PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n-\t  cse_end_of_basic_block (insn, &val, 0, 0);\n-\t  free (val.path);\n-\n-\t  /* If the tables we allocated have enough space left\n-\t     to handle all the SETs in the next basic block,\n-\t     continue through it.  Otherwise, return,\n-\t     and that block will be scanned individually.  */\n-\t  if (val.nsets * 2 + next_qty > max_qty)\n-\t    break;\n-\n-\t  cse_basic_block_start = val.low_cuid;\n-\t  cse_basic_block_end = val.high_cuid;\n-\t  to = val.last;\n-\n-\t  /* Prevent TO from being deleted if it is a label.  */\n-\t  if (to != 0 && LABEL_P (to))\n-\t    ++LABEL_NUSES (to);\n-\n-\t  /* Back up so we process the first insn in the extension.  */\n-\t  insn = PREV_INSN (insn);\n-\t}\n     }\n \n   gcc_assert (next_qty <= max_qty);"}]}