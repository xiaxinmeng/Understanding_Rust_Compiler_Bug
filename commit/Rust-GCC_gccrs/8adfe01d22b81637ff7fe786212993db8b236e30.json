{"sha": "8adfe01d22b81637ff7fe786212993db8b236e30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkZmUwMWQyMmI4MTYzN2ZmN2ZlNzg2MjEyOTkzZGI4YjIzNmUzMA==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2010-01-28T14:24:25Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2010-01-28T14:24:25Z"}, "message": "28-01-2010  Razya Ladelsky  <razya@il.ibm.com>\n\n        * tree-parloops.c (transform_to_exit_first_loop): Update the basic \n        block list passed to gimple_duplicate_sese_tail.\n        (parallelize_loops): Avoid parallelization when the function\n        has_nonlocal_label.\n        Avoid parallelization when the preheader is IRREDUCIBLE.\n        Try to optimize when estimated_loop_iterations_int is unresolved.\n        Add the loop's location to the dump file.\n        * tree-cfg.c(add_phi_args_after_redirect): Remove.\n        (gimple_duplicate_sese_tail): Remove the check for the latch.\n        Redirect nexits to the exit block.\n        Remove handling of the incoming edges to the latch.\n        Redirect the backedge from the copied latch to the exit bb.\n\nFrom-SVN: r156321", "tree": {"sha": "7a639af528d71a0f6c3e76747fe4b509e6a022a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a639af528d71a0f6c3e76747fe4b509e6a022a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8adfe01d22b81637ff7fe786212993db8b236e30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8adfe01d22b81637ff7fe786212993db8b236e30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8adfe01d22b81637ff7fe786212993db8b236e30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8adfe01d22b81637ff7fe786212993db8b236e30/comments", "author": null, "committer": null, "parents": [{"sha": "3d952fb7837516c37b16810e15fa8f197cc5cbb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d952fb7837516c37b16810e15fa8f197cc5cbb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d952fb7837516c37b16810e15fa8f197cc5cbb3"}], "stats": {"total": 163, "additions": 54, "deletions": 109}, "files": [{"sha": "147a8a26ada370a254da4d529731be3fe4e0c7c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8adfe01d22b81637ff7fe786212993db8b236e30", "patch": "@@ -1,3 +1,18 @@\n+28-01-2010  Razya Ladelsky  <razya@il.ibm.com>\n+\n+\t* tree-parloops.c (transform_to_exit_first_loop): Update the basic \n+\tblock list passed to gimple_duplicate_sese_tail.\n+\t(parallelize_loops): Avoid parallelization when the function\n+\thas_nonlocal_label.\n+\tAvoid parallelization when the preheader is IRREDUCIBLE.\n+\tTry to optimize when estimated_loop_iterations_int is unresolved.\n+\tAdd the loop's location to the dump file.\n+\t* tree-cfg.c(add_phi_args_after_redirect): Remove.\n+\t(gimple_duplicate_sese_tail): Remove the check for the latch.\n+\tRedirect nexits to the exit block.\n+\tRemove handling of the incoming edges to the latch.\n+\tRedirect the backedge from the copied latch to the exit bb.\n+\n 2010-01-28  Michael Matz  <matz@suse.de>\n \n \tPR target/42881"}, {"sha": "361b46ef01e61a09f554a43428f55dc50f53fd1f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 24, "deletions": 101, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=8adfe01d22b81637ff7fe786212993db8b236e30", "patch": "@@ -4927,31 +4927,6 @@ gimple_duplicate_bb (basic_block bb)\n   return new_bb;\n }\n \n-/* Add phi arguments to the phi nodes in E_COPY->dest according to\n-   the phi arguments coming from the equivalent edge at\n-   the phi nodes of DEST.  */\n-\n-static void\n-add_phi_args_after_redirect (edge e_copy, edge orig_e)\n-{\n-   gimple_stmt_iterator psi, psi_copy;\n-   gimple phi, phi_copy;\n-   tree def;\n-\n-    for (psi = gsi_start_phis (orig_e->dest),\n-       psi_copy = gsi_start_phis (e_copy->dest);\n-       !gsi_end_p (psi);\n-       gsi_next (&psi), gsi_next (&psi_copy))\n-    {\n-\n-      phi = gsi_stmt (psi);\n-      phi_copy = gsi_stmt (psi_copy);\n-      def = PHI_ARG_DEF_FROM_EDGE (phi, orig_e);\n-      add_phi_arg (phi_copy, def, e_copy,\n-                   gimple_phi_arg_location_from_edge (phi, orig_e));\n-    }\n-}\n-\n /* Adds phi node arguments for edge E_COPY after basic block duplication.  */\n \n static void\n@@ -5235,12 +5210,13 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   edge exits[2], nexits[2], e;\n   gimple_stmt_iterator gsi,gsi1;\n   gimple cond_stmt;\n-  edge sorig, snew, orig_e;\n+  edge sorig, snew;\n   basic_block exit_bb;\n-  edge_iterator ei;\n-  VEC (edge, heap) *redirect_edges;\n-  basic_block iters_bb, orig_src;\n+  basic_block iters_bb;\n   tree new_rhs;\n+  gimple_stmt_iterator psi;\n+  gimple phi;\n+  tree def;\n \n   gcc_assert (EDGE_COUNT (exit->src->succs) == 2);\n   exits[0] = exit;\n@@ -5249,17 +5225,6 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   if (!can_copy_bbs_p (region, n_region))\n     return false;\n \n-  /* Some sanity checking.  Note that we do not check for all possible\n-     missuses of the functions.  I.e. if you ask to copy something weird\n-     (e.g., in the example, if there is a jump from inside to the middle\n-     of some_code, or come_code defines some of the values used in cond)\n-     it will work, but the resulting code will not be correct.  */\n-  for (i = 0; i < n_region; i++)\n-    {\n-      if (region[i] == orig_loop->latch)\n-\treturn false;\n-    }\n-\n   initialize_original_copy_tables ();\n   set_loop_copy (orig_loop, loop);\n   duplicate_subloops (orig_loop, loop);\n@@ -5377,72 +5342,30 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   e = redirect_edge_and_branch (exits[0], exits[1]->dest);\n   PENDING_STMT (e) = NULL;\n \n-  /* If the block consisting of the exit condition has the latch as\n-     successor, then the body of the loop is executed before\n-     the exit condition is tested.\n-\n-     { body  }\n-     { cond  } (exit[0])  -> { latch }\n-        |\n-\tV (exit[1])\n-\n-     { exit_bb }\n-\n-\n-     In such case, the equivalent copied edge nexits[1]\n-     (for the peeled iteration) needs to be redirected to exit_bb.\n-\n-     Otherwise,\n-\n-     { cond  } (exit[0])  -> { body }\n-        |\n-\tV (exit[1])\n-\n-     { exit_bb }\n-\n-\n-     exit[0] is pointing to the body of the loop,\n-     and the equivalent nexits[0] needs to be redirected to\n-     the copied body (of the peeled iteration).  */\n-\n-  if (exits[1]->dest == orig_loop->latch)\n-    e = redirect_edge_and_branch (nexits[1], nexits[0]->dest);\n-  else\n-    e = redirect_edge_and_branch (nexits[0], nexits[1]->dest);\n-  PENDING_STMT (e) = NULL;\n-\n-  redirect_edges = VEC_alloc (edge, heap, 10);\n-\n-  for (i = 0; i < n_region; i++)\n-    region_copy[i]->flags |= BB_DUPLICATED;\n-\n-  /* Iterate all incoming edges to latch.  All those coming from\n-     copied bbs will be redirected to exit_bb.  */\n-  FOR_EACH_EDGE (e, ei, orig_loop->latch->preds)\n-    {\n-      if (e->src->flags & BB_DUPLICATED)\n-        VEC_safe_push (edge, heap, redirect_edges, e);\n-    }\n-\n+  /* The latch of ORIG_LOOP was copied, and so was the backedge \n+     to the original header.  We redirect this backedge to EXIT_BB.  */\n   for (i = 0; i < n_region; i++)\n-    region_copy[i]->flags &= ~BB_DUPLICATED;\n-\n-  for (i = 0; VEC_iterate (edge, redirect_edges, i, e); ++i)\n-    {\n-      e = redirect_edge_and_branch (e, exit_bb);\n-      PENDING_STMT (e) = NULL;\n-      orig_src = get_bb_original (e->src);\n-      orig_e = find_edge (orig_src, orig_loop->latch);\n-      add_phi_args_after_redirect (e, orig_e);\n-    }\n-\n-  VEC_free (edge, heap, redirect_edges);\n-\n+    if (get_bb_original (region_copy[i]) == orig_loop->latch)\n+      {\n+\tgcc_assert (single_succ_edge (region_copy[i]));\n+\te = redirect_edge_and_branch (single_succ_edge (region_copy[i]), exit_bb);\n+\tPENDING_STMT (e) = NULL;\n+\tfor (psi = gsi_start_phis (exit_bb);\n+\t     !gsi_end_p (psi);\n+\t     gsi_next (&psi))\n+\t  {\n+\t    phi = gsi_stmt (psi);\n+\t    def = PHI_ARG_DEF (phi, nexits[0]->dest_idx);\n+\t    add_phi_arg (phi, def, e, gimple_phi_arg_location_from_edge (phi, e));\n+\t  }\n+      }\n+  e = redirect_edge_and_branch (nexits[0], nexits[1]->dest);\n+  PENDING_STMT (e) = NULL;\n+  \n   /* Anything that is outside of the region, but was dominated by something\n      inside needs to update dominance info.  */\n   iterate_fix_dominators (CDI_DOMINATORS, doms, false);\n   VEC_free (basic_block, heap, doms);\n-\n   /* Update the SSA web.  */\n   update_ssa (TODO_update_ssa);\n "}, {"sha": "885a713c7ceeb25c85e63ac4ff7414802661bb9d", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8adfe01d22b81637ff7fe786212993db8b236e30/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=8adfe01d22b81637ff7fe786212993db8b236e30", "patch": "@@ -1329,7 +1329,6 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \n   for (n = 0; bbs[n] != loop->latch; n++)\n     continue;\n-  n--;\n   nbbs = XNEWVEC (basic_block, n);\n   ok = gimple_duplicate_sese_tail (single_succ_edge (loop->header), exit,\n \t\t\t\t   bbs + 1, n, nbbs);\n@@ -1884,10 +1883,14 @@ parallelize_loops (void)\n   struct tree_niter_desc niter_desc;\n   loop_iterator li;\n   htab_t reduction_list;\n-\n+  HOST_WIDE_INT estimated;\n+  LOC loop_loc;\n+  \n   /* Do not parallelize loops in the functions created by parallelization.  */\n   if (parallelized_function_p (cfun->decl))\n     return false;\n+  if (cfun->has_nonlocal_label)\n+    return false;\n \n   reduction_list = htab_create (10, reduction_info_hash,\n \t\t\t\t     reduction_info_eq, free);\n@@ -1926,15 +1929,16 @@ parallelize_loops (void)\n       if (/* And of course, the loop must be parallelizable.  */\n \t  !can_duplicate_loop_p (loop)\n \t  || loop_has_blocks_with_irreducible_flag (loop)\n+\t  || (loop_preheader_edge (loop)->src->flags & BB_IRREDUCIBLE_LOOP)\n \t  /* FIXME: the check for vector phi nodes could be removed.  */\n \t  || loop_has_vector_phi_nodes (loop))\n \tcontinue;\n-\n+      estimated = estimated_loop_iterations_int (loop, false);\n       /* FIXME: Bypass this check as graphite doesn't update the\n       count and frequency correctly now.  */\n       if (!flag_loop_parallelize_all\n-\t  && ((estimated_loop_iterations_int (loop, false)\n-\t       <= (HOST_WIDE_INT) n_threads * MIN_PER_THREAD)\n+\t  && ((estimated !=-1 \n+\t     && estimated <= (HOST_WIDE_INT) n_threads * MIN_PER_THREAD)\n \t      /* Do not bother with loops in cold areas.  */\n \t      || optimize_loop_nest_for_size_p (loop)))\n \tcontinue;\n@@ -1951,11 +1955,14 @@ parallelize_loops (void)\n       changed = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n       {\n-        fprintf (dump_file, \"parallelizing \");\n \tif (loop->inner)\n-\t  fprintf (dump_file, \"outer loop\\n\");\n+\t  fprintf (dump_file, \"parallelizing outer loop %d\\n\",loop->header->index);\n \telse\n-\t  fprintf (dump_file, \"inner loop\\n\");\n+\t  fprintf (dump_file, \"parallelizing inner loop %d\\n\",loop->header->index);\n+\tloop_loc = find_loop_location (loop);\n+\tif (loop_loc != UNKNOWN_LOC)\n+\t  fprintf (dump_file, \"\\nloop at %s:%d: \",\n+\t\t   LOC_FILE (loop_loc), LOC_LINE (loop_loc));\n       }\n       gen_parallel_loop (loop, reduction_list,\n \t\t\t n_threads, &niter_desc);"}]}