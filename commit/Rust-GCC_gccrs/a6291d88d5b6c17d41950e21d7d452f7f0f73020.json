{"sha": "a6291d88d5b6c17d41950e21d7d452f7f0f73020", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyOTFkODhkNWI2YzE3ZDQxOTUwZTIxZDdkNDUyZjdmMGY3MzAyMA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-07-13T10:22:03Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-07-22T05:07:29Z"}, "message": "Remove pass_cpb which is related to enable avx512 embedded broadcast from constant pool.\n\nBy optimizing vector movement to broadcast in ix86_expand_vector_move\nduring pass_expand, pass_reload/LRA can automatically generate an avx512\nembedded broadcast, pass_cpb is not needed.\n\nConsidering that in the absence of avx512f, broadcast from memory is\nstill slightly faster than loading the entire memory, so always enable\nbroadcast.\n\nbenchmark:\nhttps://gitlab.com/x86-benchmarks/microbenchmark/-/tree/vaddps/broadcast\n\nThe performance diff\n\nstrategy    : cycles\nmemory      : 1046611188\nmemory      : 1255420817\nmemory      : 1044720793\nmemory      : 1253414145\naverage\t    : 1097868397\n\nbroadcast   : 1044430688\nbroadcast   : 1044477630\nbroadcast   : 1253554603\nbroadcast   : 1044561934\naverage\t    : 1096756213\n\nBut however broadcast has larger size.\n\nthe size diff\n\nsize broadcast.o\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n    137\t      0\t      0\t    137\t     89\tbroadcast.o\n\nsize memory.o\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n    115\t      0\t      0\t    115\t     73\tmemory.o\n\ngcc/ChangeLog:\n\n\t* config/i386/i386-expand.c\n\t(ix86_broadcast_from_integer_constant): Rename to ..\n\t(ix86_broadcast_from_constant): .. this, and extend it to\n\thandle float mode.\n\t(ix86_expand_vector_move): Extend to float mode.\n\t* config/i386/i386-features.c\n\t(replace_constant_pool_with_broadcast): Remove.\n\t(remove_partial_avx_dependency_gate): Ditto.\n\t(constant_pool_broadcast): Ditto.\n\t(class pass_constant_pool_broadcast): Ditto.\n\t(make_pass_constant_pool_broadcast): Ditto.\n\t(remove_partial_avx_dependency): Adjust gate.\n\t* config/i386/i386-passes.def: Remove pass_constant_pool_broadcast.\n\t* config/i386/i386-protos.h\n\t(make_pass_constant_pool_broadcast): Remove.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/fuse-caller-save-xmm.c: Adjust testcase.", "tree": {"sha": "35f123fcca95b4c991f92c66952d105f3a1d4c7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35f123fcca95b4c991f92c66952d105f3a1d4c7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6291d88d5b6c17d41950e21d7d452f7f0f73020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6291d88d5b6c17d41950e21d7d452f7f0f73020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6291d88d5b6c17d41950e21d7d452f7f0f73020", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6291d88d5b6c17d41950e21d7d452f7f0f73020/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a56c251898ea70b46798d7893a871bcfe318529b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56c251898ea70b46798d7893a871bcfe318529b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56c251898ea70b46798d7893a871bcfe318529b"}], "stats": {"total": 197, "additions": 34, "deletions": 163}, "files": [{"sha": "896bd685b1ff7df6c9823691d750365237843ea0", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=a6291d88d5b6c17d41950e21d7d452f7f0f73020", "patch": "@@ -453,29 +453,37 @@ ix86_expand_move (machine_mode mode, rtx operands[])\n   emit_insn (gen_rtx_SET (op0, op1));\n }\n \n+/* OP is a memref of CONST_VECTOR, return scalar constant mem\n+   if CONST_VECTOR is a vec_duplicate, else return NULL.  */\n static rtx\n-ix86_broadcast_from_integer_constant (machine_mode mode, rtx op)\n+ix86_broadcast_from_constant (machine_mode mode, rtx op)\n {\n   int nunits = GET_MODE_NUNITS (mode);\n   if (nunits < 2)\n     return nullptr;\n \n   /* Don't use integer vector broadcast if we can't move from GPR to SSE\n      register directly.  */\n-  if (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n+  if (!TARGET_INTER_UNIT_MOVES_TO_VEC\n+      && INTEGRAL_MODE_P (mode))\n     return nullptr;\n \n   /* Convert CONST_VECTOR to a non-standard SSE constant integer\n      broadcast only if vector broadcast is available.  */\n   if (!(TARGET_AVX2\n \t|| (TARGET_AVX\n \t    && (GET_MODE_INNER (mode) == SImode\n-\t\t|| GET_MODE_INNER (mode) == DImode)))\n+\t\t|| GET_MODE_INNER (mode) == DImode))\n+\t|| FLOAT_MODE_P (mode))\n       || standard_sse_constant_p (op, mode))\n     return nullptr;\n \n-  /* Don't broadcast from a 64-bit integer constant in 32-bit mode.  */\n-  if (GET_MODE_INNER (mode) == DImode && !TARGET_64BIT)\n+  /* Don't broadcast from a 64-bit integer constant in 32-bit mode.\n+     We can still put 64-bit integer constant in memory when\n+     avx512 embed broadcast is available.  */\n+  if (GET_MODE_INNER (mode) == DImode && !TARGET_64BIT\n+      && (!TARGET_AVX512F\n+\t  || (GET_MODE_SIZE (mode) < 64 && !TARGET_AVX512VL)))\n     return nullptr;\n \n   if (GET_MODE_INNER (mode) == TImode)\n@@ -561,17 +569,29 @@ ix86_expand_vector_move (machine_mode mode, rtx operands[])\n \n   if (can_create_pseudo_p ()\n       && GET_MODE_SIZE (mode) >= 16\n-      && GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+      && VECTOR_MODE_P (mode)\n       && (MEM_P (op1)\n \t  && SYMBOL_REF_P (XEXP (op1, 0))\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (op1, 0))))\n     {\n-      rtx first = ix86_broadcast_from_integer_constant (mode, op1);\n+      rtx first = ix86_broadcast_from_constant (mode, op1);\n       if (first != nullptr)\n \t{\n \t  /* Broadcast to XMM/YMM/ZMM register from an integer\n-\t     constant.  */\n+\t     constant or scalar mem.  */\n+\t  /* Hard registers are used for 2 purposes:\n+\t     1. Prevent stack realignment when the original code\n+\t     doesn't use vector registers, which is the same for\n+\t     memcpy and memset.\n+\t     2. Prevent combine to convert constant broadcast to\n+\t     load from constant pool.  */\n \t  op1 = ix86_gen_scratch_sse_rtx (mode);\n+\t  if (FLOAT_MODE_P (mode)\n+\t      || (!TARGET_64BIT && GET_MODE_INNER (mode) == DImode))\n+\t    {\n+\t      first = force_const_mem (GET_MODE_INNER (mode), first);\n+\t      op1 = gen_reg_rtx (mode);\n+\t    }\n \t  bool ok = ix86_expand_vector_init_duplicate (false, mode,\n \t\t\t\t\t\t       op1, first);\n \t  gcc_assert (ok);"}, {"sha": "d9c6652d1c9c560c69602cf818daba81f5835fb8", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 5, "deletions": 152, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=a6291d88d5b6c17d41950e21d7d452f7f0f73020", "patch": "@@ -2136,81 +2136,6 @@ make_pass_insert_endbr_and_patchable_area (gcc::context *ctxt)\n   return new pass_insert_endbr_and_patchable_area (ctxt);\n }\n \n-/* Replace all one-value const vector that are referenced by SYMBOL_REFs in x\n-   with embedded broadcast. i.e.transform\n-\n-     vpaddq .LC0(%rip), %zmm0, %zmm0\n-     ret\n-  .LC0:\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-    .quad 3\n-\n-    to\n-\n-     vpaddq .LC0(%rip){1to8}, %zmm0, %zmm0\n-     ret\n-  .LC0:\n-    .quad 3  */\n-static void\n-replace_constant_pool_with_broadcast (rtx_insn *insn)\n-{\n-  subrtx_ptr_iterator::array_type array;\n-  FOR_EACH_SUBRTX_PTR (iter, array, &PATTERN (insn), ALL)\n-    {\n-      rtx *loc = *iter;\n-      rtx x = *loc;\n-      rtx broadcast_mem, vec_dup, constant, first;\n-      machine_mode mode;\n-\n-      /* Constant pool.  */\n-      if (!MEM_P (x)\n-\t  || !SYMBOL_REF_P (XEXP (x, 0))\n-\t  || !CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n-\tcontinue;\n-\n-      /* Const vector.  */\n-      mode = GET_MODE (x);\n-      if (!VECTOR_MODE_P (mode))\n-\treturn;\n-      constant = get_pool_constant (XEXP (x, 0));\n-      if (GET_CODE (constant) != CONST_VECTOR)\n-\treturn;\n-\n-      /* There could be some rtx like\n-\t (mem/u/c:V16QI (symbol_ref/u:DI (\"*.LC1\")))\n-\t but with \"*.LC1\" refer to V2DI constant vector.  */\n-      if (GET_MODE (constant) != mode)\n-\t{\n-\t  constant = simplify_subreg (mode, constant, GET_MODE (constant), 0);\n-\t  if (constant == NULL_RTX || GET_CODE (constant) != CONST_VECTOR)\n-\t    return;\n-\t}\n-      first = XVECEXP (constant, 0, 0);\n-\n-      for (int i = 1; i < GET_MODE_NUNITS (mode); ++i)\n-\t{\n-\t  rtx tmp = XVECEXP (constant, 0, i);\n-\t  /* Vector duplicate value.  */\n-\t  if (!rtx_equal_p (tmp, first))\n-\t    return;\n-\t}\n-\n-      /* Replace with embedded broadcast.  */\n-      broadcast_mem = force_const_mem (GET_MODE_INNER (mode), first);\n-      vec_dup = gen_rtx_VEC_DUPLICATE (mode, broadcast_mem);\n-      validate_change (insn, loc, vec_dup, 0);\n-\n-      /* At most 1 memory_operand in an insn.  */\n-      return;\n-    }\n-}\n-\n /* At entry of the nearest common dominator for basic blocks with\n    conversions, generate a single\n \tvxorps %xmmN, %xmmN, %xmmN\n@@ -2249,10 +2174,6 @@ remove_partial_avx_dependency (void)\n \t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \n-\t  /* Handle AVX512 embedded broadcast here to save compile time.  */\n-\t  if (TARGET_AVX512F)\n-\t    replace_constant_pool_with_broadcast (insn);\n-\n \t  set = single_set (insn);\n \t  if (!set)\n \t    continue;\n@@ -2384,16 +2305,6 @@ remove_partial_avx_dependency (void)\n   return 0;\n }\n \n-static bool\n-remove_partial_avx_dependency_gate ()\n-{\n-  return (TARGET_AVX\n-\t  && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n-\t  && TARGET_SSE_MATH\n-\t  && optimize\n-\t  && optimize_function_for_speed_p (cfun));\n-}\n-\n namespace {\n \n const pass_data pass_data_remove_partial_avx_dependency =\n@@ -2419,7 +2330,11 @@ class pass_remove_partial_avx_dependency : public rtl_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n-      return remove_partial_avx_dependency_gate ();\n+      return (TARGET_AVX\n+\t      && TARGET_SSE_PARTIAL_REG_DEPENDENCY\n+\t      && TARGET_SSE_MATH\n+\t      && optimize\n+\t      && optimize_function_for_speed_p (cfun));\n     }\n \n   virtual unsigned int execute (function *)\n@@ -2436,68 +2351,6 @@ make_pass_remove_partial_avx_dependency (gcc::context *ctxt)\n   return new pass_remove_partial_avx_dependency (ctxt);\n }\n \n-/* For const vector having one duplicated value, there's no need to put\n-   whole vector in the constant pool when target supports embedded broadcast. */\n-static unsigned int\n-constant_pool_broadcast (void)\n-{\n-  timevar_push (TV_MACH_DEP);\n-  rtx_insn *insn;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\treplace_constant_pool_with_broadcast (insn);\n-    }\n-  timevar_pop (TV_MACH_DEP);\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_constant_pool_broadcast =\n-{\n-  RTL_PASS, /* type */\n-  \"cpb\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_MACH_DEP, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  TODO_df_finish, /* todo_flags_finish */\n-};\n-\n-class pass_constant_pool_broadcast : public rtl_opt_pass\n-{\n-public:\n-  pass_constant_pool_broadcast (gcc::context *ctxt)\n-    : rtl_opt_pass (pass_data_constant_pool_broadcast, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      /* Return false if rpad pass gate is true.\n-\t replace_constant_pool_with_broadcast is called\n-\t from both this pass and rpad pass.  */\n-      return (TARGET_AVX512F && !remove_partial_avx_dependency_gate ());\n-    }\n-\n-  virtual unsigned int execute (function *)\n-    {\n-      return constant_pool_broadcast ();\n-    }\n-}; // class pass_cpb\n-\n-} // anon namespace\n-\n-rtl_opt_pass *\n-make_pass_constant_pool_broadcast (gcc::context *ctxt)\n-{\n-  return new pass_constant_pool_broadcast (ctxt);\n-}\n-\n /* This compares the priority of target features in function DECL1\n    and DECL2.  It returns positive value if DECL1 is higher priority,\n    negative value if DECL2 is higher priority and 0 if they are the"}, {"sha": "29baf8acd0bb4d5260c23910c752e01a7c4d7a13", "filename": "gcc/config/i386/i386-passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-passes.def?ref=a6291d88d5b6c17d41950e21d7d452f7f0f73020", "patch": "@@ -33,4 +33,3 @@ along with GCC; see the file COPYING3.  If not see\n   INSERT_PASS_BEFORE (pass_shorten_branches, 1, pass_insert_endbr_and_patchable_area);\n \n   INSERT_PASS_AFTER (pass_combine, 1, pass_remove_partial_avx_dependency);\n-  INSERT_PASS_AFTER (pass_combine, 1, pass_constant_pool_broadcast);"}, {"sha": "07ac02aff691916d4b801172a72bc80f514f54de", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=a6291d88d5b6c17d41950e21d7d452f7f0f73020", "patch": "@@ -395,4 +395,3 @@ extern rtl_opt_pass *make_pass_insert_endbr_and_patchable_area\n   (gcc::context *);\n extern rtl_opt_pass *make_pass_remove_partial_avx_dependency\n   (gcc::context *);\n-extern rtl_opt_pass *make_pass_constant_pool_broadcast (gcc::context *);"}, {"sha": "b0d3dc38a0cb9b034ad109f58f2f1ecb11ebd973", "filename": "gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuse-caller-save-xmm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6291d88d5b6c17d41950e21d7d452f7f0f73020/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuse-caller-save-xmm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuse-caller-save-xmm.c?ref=a6291d88d5b6c17d41950e21d7d452f7f0f73020", "patch": "@@ -6,7 +6,7 @@ typedef double v2df __attribute__((vector_size (16)));\n static v2df __attribute__((noinline))\n bar (v2df a)\n {\n-  return a + (v2df){ 3.0, 3.0 };\n+  return a + (v2df){ 3.0, 4.0 };\n }\n \n v2df __attribute__((noinline))"}]}