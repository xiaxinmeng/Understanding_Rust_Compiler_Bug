{"sha": "0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5YTNmZDM5M2FlYjM2M2JhZmI5MTE0YTZkZjJmZTVhMTM5ZDNmNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-11-06T11:55:43Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-11-06T11:55:43Z"}, "message": "re PR target/54089 ([SH] Refactor shift patterns)\n\n\tPR target/54089\n\t* config/sh/sh.c (and_xor_ior_costs, addsubcosts): Double the costs for\n\tops larger than SImode.\n\t* config/sh/sh.md (rotcl, *rotcl): New insns and splits.\n\t(ashldi3_k): Convert to insn_and_split and use new rotcl insn.\n\n\tPR target/54089\n\t* gcc.target/sh/pr54089-8.c: New.\n\t* gcc.target/sh/pr54089-9.c: New.\n\nFrom-SVN: r193236", "tree": {"sha": "01a8b85e730cf6de97aa2c8b321737ee681c8337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01a8b85e730cf6de97aa2c8b321737ee681c8337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/comments", "author": null, "committer": null, "parents": [{"sha": "ee2ba85639333f03774668c5a4b25d7ae08b1036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee2ba85639333f03774668c5a4b25d7ae08b1036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee2ba85639333f03774668c5a4b25d7ae08b1036"}], "stats": {"total": 527, "additions": 509, "deletions": 18}, "files": [{"sha": "b22409ec0a37dd3ef6ca304b8e6eedc98dd2ca72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -1,3 +1,11 @@\n+2012-11-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* config/sh/sh.c (and_xor_ior_costs, addsubcosts): Double the costs for\n+\tops larger than SImode.\n+\t* config/sh/sh.md (rotcl, *rotcl): New insns and splits.\n+\t(ashldi3_k): Convert to insn_and_split and use new rotcl insn.\n+\n 2012-11-06  Vladimir Yakovlev  <vladimir.b.yakovlev@intel.com>\n \n \t* config/i386/i386-protos.h (emit_i387_cw_initialization): Deleted."}, {"sha": "ae671a29a855c029db89525d134be3029237d195", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -3224,14 +3224,18 @@ shiftcosts (rtx x)\n static inline int\n and_xor_ior_costs (rtx x, int code)\n {\n-  int i;\n+  /* On SH1-4 we have only max. SImode operations.\n+     Double the cost for modes > SImode.  */\n+  const int cost_scale = !TARGET_SHMEDIA\n+\t\t\t && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n+\t\t\t ? 2 : 1;\n \n   /* A logical operation with two registers is a single cycle\n      instruction.  */\n   if (!CONST_INT_P (XEXP (x, 1)))\n-    return 1;\n+    return 1 * cost_scale;\n \n-  i = INTVAL (XEXP (x, 1));\n+  int i = INTVAL (XEXP (x, 1));\n \n   if (TARGET_SHMEDIA)\n     {\n@@ -3244,35 +3248,41 @@ and_xor_ior_costs (rtx x, int code)\n \n   /* These constants are single cycle extu.[bw] instructions.  */\n   if ((i == 0xff || i == 0xffff) && code == AND)\n-    return 1;\n+    return 1 * cost_scale;\n   /* Constants that can be used in an instruction as an immediate are\n      a single cycle, but this requires r0, so make it a little more\n      expensive.  */\n   if (CONST_OK_FOR_K08 (i))\n-    return 2;\n+    return 2 * cost_scale;\n   /* Constants that can be loaded with a mov immediate need one more cycle.\n      This case is probably unnecessary.  */\n   if (CONST_OK_FOR_I08 (i))\n-    return 2;\n+    return 2 * cost_scale;\n   /* Any other constant requires an additional 2 cycle pc-relative load.\n      This case is probably unnecessary.  */\n-  return 3;\n+  return 3 * cost_scale;\n }\n \n /* Return the cost of an addition or a subtraction.  */\n \n static inline int\n addsubcosts (rtx x)\n {\n+  /* On SH1-4 we have only max. SImode operations.\n+     Double the cost for modes > SImode.  */\n+  const int cost_scale = !TARGET_SHMEDIA\n+\t\t\t && GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD\n+\t\t\t ? 2 : 1;\n+\n   /* Adding a register is a single cycle insn.  */\n   if (REG_P (XEXP (x, 1))\n       || GET_CODE (XEXP (x, 1)) == SUBREG)\n-    return 1;\n+    return 1 * cost_scale;\n \n   /* Likewise for small constants.  */\n   if (CONST_INT_P (XEXP (x, 1))\n       && CONST_OK_FOR_ADD (INTVAL (XEXP (x, 1))))\n-    return 1;\n+    return 1 * cost_scale;\n \n   if (TARGET_SHMEDIA)\n     switch (GET_CODE (XEXP (x, 1)))\n@@ -3297,7 +3307,7 @@ addsubcosts (rtx x)\n \n   /* Any other constant requires a 2 cycle pc-relative load plus an\n      addition.  */\n-  return 3;\n+  return 3 * cost_scale;\n }\n \n /* Return the cost of a multiply.  */"}, {"sha": "3c9226523d7c6566a59d90b5156d5d06efc8a936", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 209, "deletions": 8, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -4006,10 +4006,11 @@ label:\n     FAIL;\n })\n \n-;; The rotcr insn is used primarily in DImode right shifts (arithmetic\n-;; and logical).  It can also be used to implement things like\n+;; The rotcr and rotcl insns are used primarily in DImode shifts by one.\n+;; They can also be used to implement things like\n ;;\tbool t = a == b;\n-;;\tint x = (y >> 1) | (t << 31);\n+;;\tint x0 = (y >> 1) | (t << 31);\t// rotcr\n+;;\tint x1 = (y << 1) | t;\t\t// rotcl\n (define_insn \"rotcr\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:SI (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -4022,6 +4023,17 @@ label:\n   \"rotcr\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t\t   (const_int 1))\n+\t\t(match_operand:SI 2 \"t_reg_operand\")))\n+   (set (reg:SI T_REG)\n+\t(lshiftrt:SI (match_dup 1) (const_int 31)))]\n+  \"TARGET_SH1\"\n+  \"rotcl\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n ;; Simplified rotcr version for combine, which allows arbitrary shift\n ;; amounts for the reg.  If the shift amount is '1' rotcr can be used\n ;; directly.  Otherwise we have to insert a shift in between.\n@@ -4121,6 +4133,160 @@ label:\n \t\t\t   (ashift:SI (match_dup 1) (const_int 31))))\n \t      (clobber (reg:SI T_REG))])])\n \n+;; Basically the same as the rotcr pattern above, but for rotcl.\n+;; FIXME: Fold copy pasted split code for rotcr and rotcl.\n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(and:SI (match_operand:SI 3 \"arith_reg_or_t_reg_operand\")\n+\t\t\t(const_int 1))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  gcc_assert (INTVAL (operands[2]) > 0);\n+\n+  if (INTVAL (operands[2]) > 1)\n+    {\n+      const rtx shift_count = GEN_INT (INTVAL (operands[2]) - 1);\n+      rtx prev_set_t_insn = NULL_RTX;\n+      rtx tmp_t_reg = NULL_RTX;\n+\n+      /* If we're going to emit a shift sequence that clobbers the T_REG,\n+\t try to find the previous insn that sets the T_REG and emit the \n+\t shift insn before that insn, to remove the T_REG dependency.\n+\t If the insn that sets the T_REG cannot be found, store the T_REG\n+\t in a temporary reg and restore it after the shift.  */\n+      if (sh_ashlsi_clobbers_t_reg_p (shift_count)\n+\t  && ! sh_dynamicalize_shift_p (shift_count))\n+\t{\n+\t  prev_set_t_insn = prev_nonnote_insn_bb (curr_insn);\n+\n+\t  /* Skip the nott insn, which was probably inserted by the splitter\n+\t     of *rotcl_neg_t.  Don't use one of the recog functions\n+\t     here during insn splitting, since that causes problems in later\n+\t     passes.  */\n+\t  if (prev_set_t_insn != NULL_RTX)\n+\t    {\n+\t      rtx pat = PATTERN (prev_set_t_insn);\n+\t      if (GET_CODE (pat) == SET\n+\t\t  && t_reg_operand (XEXP (pat, 0), SImode)\n+\t\t  && negt_reg_operand (XEXP (pat, 1), SImode))\n+\t      prev_set_t_insn = prev_nonnote_insn_bb (prev_set_t_insn);\n+\t    }\n+\n+\t  if (! (prev_set_t_insn != NULL_RTX\n+\t\t && reg_set_p (get_t_reg_rtx (), prev_set_t_insn)\n+\t\t && ! reg_referenced_p (get_t_reg_rtx (),\n+\t\t\t\t\tPATTERN (prev_set_t_insn))))\n+\t    {\n+\t      prev_set_t_insn = NULL_RTX;\n+\t      tmp_t_reg = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_move_insn (tmp_t_reg, get_t_reg_rtx ()));\n+\t    } \n+\t}\n+\n+      rtx shift_result = gen_reg_rtx (SImode);\n+      rtx shift_insn = gen_ashlsi3 (shift_result, operands[1], shift_count);\n+      operands[1] = shift_result;\n+\n+      /* Emit the shift insn before the insn that sets T_REG, if possible.  */\n+      if (prev_set_t_insn != NULL_RTX)\n+\temit_insn_before (shift_insn, prev_set_t_insn);\n+      else\n+\temit_insn (shift_insn);\n+\n+      /* Restore T_REG if it has been saved before.  */\n+      if (tmp_t_reg != NULL_RTX)\n+\temit_insn (gen_cmpgtsi_t (tmp_t_reg, const0_rtx));\n+    }\n+\n+  /* For the rotcl insn to work, operands[3] must be in T_REG.\n+     If it is not we can get it there by shifting it right one bit.\n+     In this case T_REG is not an input for this insn, thus we don't have to\n+     pay attention as of where to insert the shlr insn.  */\n+  if (! t_reg_operand (operands[3], SImode))\n+    {\n+      /* We don't care about the shifted result here, only the T_REG.  */\n+      emit_insn (gen_shlr (gen_reg_rtx (SImode), operands[3]));\n+      operands[3] = get_t_reg_rtx ();\n+    }\n+\n+  emit_insn (gen_rotcl (operands[0], operands[1], operands[3]));\n+  DONE;\n+})\n+\n+;; rotcl combine pattern variations\n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(match_operand:SI 3 \"t_reg_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 1) (match_dup 2))\n+\t\t\t   (and:SI (match_dup 3) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (and:SI (match_operand:SI 1 \"arith_reg_or_t_reg_operand\")\n+\t\t\t(const_int 1))\n+\t\t(ashift:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 3 \"const_int_operand\"))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 2) (match_dup 3))\n+\t\t\t   (and:SI (match_dup 1) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(lshiftrt:SI (match_operand:SI 3 \"arith_reg_operand\")\n+\t\t\t     (const_int 31))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 1) (match_dup 2))\n+\t\t\t   (and:SI (reg:SI T_REG) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  /* We don't care about the result of the left shift, only the T_REG.  */\n+  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[3]));\n+})\n+\n+(define_insn_and_split \"*rotcl\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (lshiftrt:SI (match_operand:SI 3 \"arith_reg_operand\")\n+\t\t\t     (const_int 31))\n+\t\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 1) (match_dup 2))\n+\t\t\t   (and:SI (reg:SI T_REG) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])]\n+{\n+  /* We don't care about the result of the left shift, only the T_REG.  */\n+  emit_insn (gen_shll (gen_reg_rtx (SImode), operands[3]));\n+})\n+\n ;; rotcr combine bridge pattern which will make combine try out more\n ;; complex patterns.\n (define_insn_and_split \"*rotcr\"\n@@ -4189,6 +4355,35 @@ label:\n   emit_insn (gen_nott (get_t_reg_rtx ()));\n })\n \n+;; rotcl combine patterns for rotating in the negated T_REG value.\n+;; For some strange reason these have to be specified as splits which combine\n+;; will pick up.  If they are specified as insn_and_split like the\n+;; *rotcr_neg_t patterns above, combine would recognize them successfully\n+;; but not emit them on non-SH2A targets.\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (match_operand:SI 1 \"negt_reg_operand\")\n+\t\t(ashift:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 3 \"const_int_operand\"))))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 2) (match_dup 3))\n+\t\t\t   (and:SI (reg:SI T_REG) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(ior:SI (ashift:SI (match_operand:SI 2 \"arith_reg_operand\")\n+\t\t\t   (match_operand:SI 3 \"const_int_operand\"))\n+\t\t(match_operand:SI 1 \"negt_reg_operand\")))]\n+  \"TARGET_SH1\"\n+  [(set (reg:SI T_REG) (xor:SI (reg:SI T_REG) (const_int 1)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (ior:SI (ashift:SI (match_dup 2) (match_dup 3))\n+\t\t\t   (and:SI (reg:SI T_REG) (const_int 1))))\n+\t      (clobber (reg:SI T_REG))])])\n+\n ;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n ;; SImode shift left\n \n@@ -4480,16 +4675,22 @@ label:\n   DONE;\n })\n \n-;; This should be an define_insn_and_split.\n-(define_insn \"ashldi3_k\"\n+(define_insn_and_split \"ashldi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n \t\t   (const_int 1)))\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1\"\n-  \"shll\t%R0\\;rotcl\t%S0\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"arith\")])\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx high = gen_highpart (SImode, operands[0]);\n+  rtx low = gen_lowpart (SImode, operands[0]);\n+  emit_insn (gen_shll (low, low));\n+  emit_insn (gen_rotcl (high, high, get_t_reg_rtx ()));\n+  DONE;\n+})\n \n (define_insn \"ashldi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r,r\")"}, {"sha": "9ff850068308c6bac8f522067dc34b4b6e14edef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -1,3 +1,9 @@\n+2012-11-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* gcc.target/sh/pr54089-8.c: New.\n+\t* gcc.target/sh/pr54089-9.c: New.\n+\n 2012-11-06  Vladimir Yakovlev  <vladimir.b.yakovlev@intel.com>\n \n \t* gcc.target/i386/avx-vzeroupper-5.c: Changed scan-assembler-times."}, {"sha": "fa9e8f38380f5c86537647259a30e9eaaa4a6a89", "filename": "gcc/testsuite/gcc.target/sh/pr54089-8.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-8.c?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -0,0 +1,203 @@\n+/* Check that the rotcl instruction is generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotcl\" 28 } } */\n+\n+typedef char bool;\n+\n+long long\n+test_00 (long long a)\n+{\n+  return a << 1;\n+}\n+\n+unsigned int\n+test_01 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 1) | r);\n+}\n+\n+unsigned int\n+test_02 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 2) | r);\n+}\n+\n+unsigned int\n+test_03 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 3) | r);\n+}\n+\n+unsigned int\n+test_04 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 4) | r);\n+}\n+\n+unsigned int\n+test_05 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 5) | r);\n+}\n+\n+unsigned int\n+test_06 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 6) | r);\n+}\n+\n+unsigned int\n+test_07 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 7) | r);\n+}\n+\n+unsigned int\n+test_08 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 8) | r);\n+}\n+\n+unsigned int\n+test_09 (unsigned int a, int b, int c)\n+{\n+  bool r = b == c;\n+  return ((a << 31) | r);\n+}\n+\n+unsigned int\n+test_10 (unsigned int a, int b)\n+{\n+  /* 1x shlr, 1x rotcl  */\n+  return (a << 1) | (b & 1);\n+}\n+\n+unsigned int\n+test_11 (unsigned int a, int b)\n+{\n+  /* 1x shlr, 1x rotcl (+1x add as shll)  */\n+  return (a << 2) | (b & 1);\n+}\n+\n+unsigned int\n+test_12 (unsigned int a, int b)\n+{\n+  /* 1x shlr, 1x shll2, 1x rotcl  */\n+  return (a << 3) | (b & 1);\n+}\n+\n+unsigned int\n+test_13 (unsigned int a, int b)\n+{\n+  /* 1x shll, 1x rotcl  */\n+  bool r = b < 0;\n+  return (a << 1) | r;\n+}\n+\n+unsigned int\n+test_14 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 1) | r);\n+}\n+\n+unsigned int\n+test_15 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 11) | r);\n+}\n+\n+unsigned int\n+test_16 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 3) | r);\n+}\n+\n+unsigned int\n+test_17 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 4) | r);\n+}\n+\n+unsigned int\n+test_18 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 5) | r);\n+}\n+\n+unsigned int\n+test_19 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 6) | r);\n+}\n+\n+unsigned int\n+test_20 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 7) | r);\n+}\n+\n+unsigned int\n+test_21 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 8) | r);\n+}\n+\n+unsigned int\n+test_22 (unsigned int a, int b, int c)\n+{\n+  bool r = b != c;\n+  return ((a << 31) | r);\n+}\n+\n+unsigned int\n+test_23 (unsigned int a, int b, int c)\n+{\n+  /* 1x shll, 1x rotcl  */\n+  return (a >> 31) | (b << 13);\n+}\n+\n+unsigned int\n+test_24 (unsigned int a, unsigned int b)\n+{\n+  /* 1x shll, 1x rotcl  */\n+  return (a >> 31) | (b << 1);\n+}\n+\n+unsigned int\n+test_25 (unsigned int a, unsigned int b)\n+{\n+  /* 1x shll, 1x rotcl  */\n+  return (a >> 31) | (b << 3);\n+}\n+\n+unsigned int\n+test_26 (unsigned int a, unsigned int b)\n+{\n+  /* 1x shll, 1x rotcl  */\n+  return (b << 3) | (a >> 31);\n+}\n+\n+unsigned int\n+test_27 (unsigned int a, unsigned int b)\n+{\n+  /* 1x shlr, 1x rotcl  */\n+  return (a << 1) | ((b >> 4) & 1);\n+}"}, {"sha": "bd889dc34be100e140c606995a5ebfd5d92af69f", "filename": "gcc/testsuite/gcc.target/sh/pr54089-9.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-9.c?ref=0f9a3fd393aeb363bafb9114a6df2fe5a139d3f5", "patch": "@@ -0,0 +1,63 @@\n+/* Check that the rotcr instruction is generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"rotcl\" 4 } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+/* { dg-final { scan-assembler-not \"or\\t\" } } */\n+/* { dg-final { scan-assembler-not \"rotl\" } } */\n+/* { dg-final { scan-assembler-not \"and\" } } */\n+\n+typedef char bool;\n+\n+int\n+test_00 (int* a, int* b)\n+{\n+  int i;\n+  int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (r << 1) | t;\n+    }\n+  return r;\n+}\n+\n+int\n+test_01 (int* a, int* b)\n+{\n+  int i;\n+  int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (r << 2) | t;\n+    }\n+  return r;\n+}\n+\n+int\n+test_02 (int* a, int* b)\n+{\n+  int i;\n+  int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i] == b[i];\n+      r = (r << 3) | t;\n+    }\n+  return r;\n+}\n+\n+int\n+test_03 (const bool* a)\n+{\n+  int i;\n+  int r = 0;\n+  for (i = 0; i < 16; ++i)\n+    {\n+      bool t = a[i];\n+      r = (r << 1) | (t & 1);\n+    }\n+  return r;\n+}"}]}