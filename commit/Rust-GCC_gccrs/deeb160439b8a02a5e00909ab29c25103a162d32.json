{"sha": "deeb160439b8a02a5e00909ab29c25103a162d32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVlYjE2MDQzOWI4YTAyYTVlMDA5MDlhYjI5YzI1MTAzYTE2MmQzMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:05:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:05:09Z"}, "message": "[multiple changes]\n\n2010-10-21  Vincent Celier  <celier@adacore.com>\n\n\t* vms_data.ads: Add new qualifiers /SRC_INFO= and\n\t/UNCHECKED_SHARED_LIB_IMPORTS for GNAT COMPILE.\n\tCorrect qualifier /SRC_INFO= for GNAT MAKE\n\n2010-10-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Flatten): An association for a subtype may be an\n\texpanded name.\n\t(Safe_Left_Hand_Side): An unchecked conversion is part of a safe\n\tleft-hand side if the expression is.\n\t(Is_Safe_Index): new predicate\n\t* exp_ch3.adb (Expand_Freeze_Enumeration_Type): Indicate that the\n\tgenerated Rep_To_Pos function is a Pure_Function.\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document Invariant pragma.\n\nFrom-SVN: r165759", "tree": {"sha": "421ea6dd7eec74742bbf1b7b282d8f26de7f904c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/421ea6dd7eec74742bbf1b7b282d8f26de7f904c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deeb160439b8a02a5e00909ab29c25103a162d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deeb160439b8a02a5e00909ab29c25103a162d32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deeb160439b8a02a5e00909ab29c25103a162d32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deeb160439b8a02a5e00909ab29c25103a162d32/comments", "author": null, "committer": null, "parents": [{"sha": "5162533940dff83f0a39246d1337a8ca090f3250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5162533940dff83f0a39246d1337a8ca090f3250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5162533940dff83f0a39246d1337a8ca090f3250"}], "stats": {"total": 170, "additions": 144, "deletions": 26}, "files": [{"sha": "48008fdb7feab403250e9b2f7006f370b40d01ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=deeb160439b8a02a5e00909ab29c25103a162d32", "patch": "@@ -1,3 +1,23 @@\n+2010-10-21  Vincent Celier  <celier@adacore.com>\n+\n+\t* vms_data.ads: Add new qualifiers /SRC_INFO= and\n+\t/UNCHECKED_SHARED_LIB_IMPORTS for GNAT COMPILE.\n+\tCorrect qualifier /SRC_INFO= for GNAT MAKE\n+\n+2010-10-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Flatten): An association for a subtype may be an\n+\texpanded name.\n+\t(Safe_Left_Hand_Side): An unchecked conversion is part of a safe\n+\tleft-hand side if the expression is.\n+\t(Is_Safe_Index): new predicate\n+\t* exp_ch3.adb (Expand_Freeze_Enumeration_Type): Indicate that the\n+\tgenerated Rep_To_Pos function is a Pure_Function.\n+\n+2010-10-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document Invariant pragma.\n+\n 2010-10-21  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch5.adb: Update comment."}, {"sha": "83aaee67e5accce1fbb8ff14668fe1eac2c9906f", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=deeb160439b8a02a5e00909ab29c25103a162d32", "patch": "@@ -227,7 +227,7 @@ package body Exp_Aggr is\n       Index       : Node_Id;\n       Into        : Node_Id;\n       Scalar_Comp : Boolean;\n-      Indices     : List_Id := No_List;\n+      Indexes     : List_Id := No_List;\n       Flist       : Node_Id := Empty) return List_Id;\n    --  This recursive routine returns a list of statements containing the\n    --  loops and assignments that are needed for the expansion of the array\n@@ -244,7 +244,7 @@ package body Exp_Aggr is\n    --\n    --    Scalar_Comp is True if the component type of the aggregate is scalar.\n    --\n-   --    Indices is the current list of expressions used to index the\n+   --    Indexes is the current list of expressions used to index the\n    --    object we are writing into.\n    --\n    --    Flist is an expression representing the finalization list on which\n@@ -701,7 +701,7 @@ package body Exp_Aggr is\n       Index       : Node_Id;\n       Into        : Node_Id;\n       Scalar_Comp : Boolean;\n-      Indices     : List_Id := No_List;\n+      Indexes     : List_Id := No_List;\n       Flist       : Node_Id := Empty) return List_Id\n    is\n       Loc          : constant Source_Ptr := Sloc (N);\n@@ -728,7 +728,7 @@ package body Exp_Aggr is\n       --  N to Build_Loop contains no sub-aggregates, then this function\n       --  returns the assignment statement:\n       --\n-      --     Into (Indices, Ind) := Expr;\n+      --     Into (Indexes, Ind) := Expr;\n       --\n       --  Otherwise we call Build_Code recursively\n       --\n@@ -741,7 +741,7 @@ package body Exp_Aggr is\n       --  This routine returns the for loop statement\n       --\n       --     for J in Index_Base'(L) .. Index_Base'(H) loop\n-      --        Into (Indices, J) := Expr;\n+      --        Into (Indexes, J) := Expr;\n       --     end loop;\n       --\n       --  Otherwise we call Build_Code recursively.\n@@ -756,7 +756,7 @@ package body Exp_Aggr is\n       --     J : Index_Base := L;\n       --     while J < H loop\n       --        J := Index_Base'Succ (J);\n-      --        Into (Indices, J) := Expr;\n+      --        Into (Indexes, J) := Expr;\n       --     end loop;\n       --\n       --  Otherwise we call Build_Code recursively\n@@ -942,7 +942,7 @@ package body Exp_Aggr is\n          F : Entity_Id;\n          A : Node_Id;\n \n-         New_Indices  : List_Id;\n+         New_Indexes  : List_Id;\n          Indexed_Comp : Node_Id;\n          Expr_Q       : Node_Id;\n          Comp_Type    : Entity_Id := Empty;\n@@ -982,13 +982,13 @@ package body Exp_Aggr is\n       --  Start of processing for Gen_Assign\n \n       begin\n-         if No (Indices) then\n-            New_Indices := New_List;\n+         if No (Indexes) then\n+            New_Indexes := New_List;\n          else\n-            New_Indices := New_Copy_List_Tree (Indices);\n+            New_Indexes := New_Copy_List_Tree (Indexes);\n          end if;\n \n-         Append_To (New_Indices, Ind);\n+         Append_To (New_Indexes, Ind);\n \n          if Present (Flist) then\n             F := New_Copy_Tree (Flist);\n@@ -1014,7 +1014,7 @@ package body Exp_Aggr is\n                    Index       => Next_Index (Index),\n                    Into        => Into,\n                    Scalar_Comp => Scalar_Comp,\n-                   Indices     => New_Indices,\n+                   Indexes     => New_Indexes,\n                    Flist       => F));\n          end if;\n \n@@ -1024,7 +1024,7 @@ package body Exp_Aggr is\n            Checks_Off\n              (Make_Indexed_Component (Loc,\n                 Prefix      => New_Copy_Tree (Into),\n-                Expressions => New_Indices));\n+                Expressions => New_Indexes));\n \n          Set_Assignment_OK (Indexed_Comp);\n \n@@ -1045,7 +1045,7 @@ package body Exp_Aggr is\n             Comp_Type := Component_Type (Etype (N));\n             pragma Assert (Comp_Type = Ctype); --  AI-287\n \n-         elsif Present (Next (First (New_Indices))) then\n+         elsif Present (Next (First (New_Indexes))) then\n \n             --  Ada 2005 (AI-287): Do nothing in case of default initialized\n             --  component because we have received the component type in\n@@ -3946,9 +3946,9 @@ package body Exp_Aggr is\n \n                      exit Component_Loop;\n \n-                  --  Case of a subtype mark\n+                  --  Case of a subtype mark, identifier or expanded name\n \n-                  elsif Nkind (Choice) = N_Identifier\n+                  elsif Is_Entity_Name (Choice)\n                     and then Is_Type (Entity (Choice))\n                   then\n                      Lo := Type_Low_Bound  (Etype (Choice));\n@@ -4217,7 +4217,7 @@ package body Exp_Aggr is\n          Comp     : Node_Id;\n          Decl     : Node_Id;\n          Typ      : constant Entity_Id := Etype (N);\n-         Indices  : constant List_Id   := New_List;\n+         Indexes  : constant List_Id   := New_List;\n          Num      : Int;\n          Sub_Agg  : Node_Id;\n \n@@ -4239,7 +4239,7 @@ package body Exp_Aggr is\n                   Next (Comp);\n                end loop;\n \n-               Append_To (Indices,\n+               Append_To (Indexes,\n                  Make_Range (Loc,\n                    Low_Bound =>  Make_Integer_Literal (Loc, 1),\n                    High_Bound => Make_Integer_Literal (Loc, Num)));\n@@ -4255,7 +4255,7 @@ package body Exp_Aggr is\n                  Make_Range (Loc,\n                     Low_Bound  => Aggr_Low  (D),\n                     High_Bound => Aggr_High (D)),\n-                 Indices);\n+                 Indexes);\n             end loop;\n          end if;\n \n@@ -4264,10 +4264,10 @@ package body Exp_Aggr is\n                Defining_Identifier => Agg_Type,\n                Type_Definition =>\n                  Make_Constrained_Array_Definition (Loc,\n-                   Discrete_Subtype_Definitions => Indices,\n-                   Component_Definition =>\n+                   Discrete_Subtype_Definitions => Indexes,\n+                   Component_Definition         =>\n                      Make_Component_Definition (Loc,\n-                       Aliased_Present => False,\n+                       Aliased_Present    => False,\n                        Subtype_Indication =>\n                          New_Occurrence_Of (Component_Type (Typ), Loc))));\n \n@@ -4940,6 +4940,41 @@ package body Exp_Aggr is\n       -------------------------\n \n       function Safe_Left_Hand_Side (N : Node_Id) return Boolean is\n+         function Is_Safe_Index (Indx : Node_Id) return Boolean;\n+         --  If the left-hand side includes an indexed component, check that\n+         --  the indexes are free of side-effect.\n+\n+         -------------------\n+         -- Is_Safe_Index --\n+         -------------------\n+\n+         function Is_Safe_Index (Indx : Node_Id) return Boolean is\n+         begin\n+            if Is_Entity_Name (Indx) then\n+               return True;\n+\n+            elsif Nkind (Indx) = N_Integer_Literal then\n+               return True;\n+\n+            elsif Nkind (Indx) = N_Function_Call\n+              and then Is_Entity_Name (Name (Indx))\n+              and then\n+                Has_Pragma_Pure_Function (Entity (Name (Indx)))\n+            then\n+               return True;\n+\n+            elsif Nkind (Indx) = N_Type_Conversion\n+              and then Is_Safe_Index (Expression (Indx))\n+            then\n+               return True;\n+\n+            else\n+               return False;\n+            end if;\n+         end Is_Safe_Index;\n+\n+      --  Start of processing for Safe_Left_Hand_Side\n+\n       begin\n          if Is_Entity_Name (N) then\n             return True;\n@@ -4952,10 +4987,13 @@ package body Exp_Aggr is\n          elsif Nkind (N) = N_Indexed_Component\n            and then Safe_Left_Hand_Side (Prefix (N))\n            and then\n-             (Is_Entity_Name (First (Expressions (N)))\n-               or else Nkind (First (Expressions (N))) = N_Integer_Literal)\n+             Is_Safe_Index (First (Expressions (N)))\n          then\n             return True;\n+\n+         elsif Nkind (N) = N_Unchecked_Type_Conversion then\n+            return Safe_Left_Hand_Side (Expression (N));\n+\n          else\n             return False;\n          end if;\n@@ -6101,7 +6139,7 @@ package body Exp_Aggr is\n               Index       => First_Index (Typ),\n               Into        => Target,\n               Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n-              Indices     => No_List,\n+              Indexes     => No_List,\n               Flist       => Flist);\n       end if;\n    end Late_Expansion;"}, {"sha": "fb2732182e018c46cadd2d5d6ccdd29f79710e34", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=deeb160439b8a02a5e00909ab29c25103a162d32", "patch": "@@ -5858,6 +5858,11 @@ package body Exp_Ch3 is\n \n       Set_TSS (Typ, Fent);\n       Set_Is_Pure (Fent);\n+      --  The Pure flag will be reset is the current context is not pure.\n+      --  For optimization purposes and constant-folding, indicate that the\n+      --  Rep_To_Pos function can be considered free of side effects.\n+\n+      Set_Has_Pragma_Pure_Function (Fent);\n \n       if not Debug_Generated_Code then\n          Set_Debug_Info_Off (Fent);"}, {"sha": "1554b5dfad799e62da8781196efa5b663df901c2", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=deeb160439b8a02a5e00909ab29c25103a162d32", "patch": "@@ -156,6 +156,7 @@ Implementation Defined Pragmas\n * Pragma Interface_Name::\n * Pragma Interrupt_Handler::\n * Pragma Interrupt_State::\n+* Pragma Invariant::\n * Pragma Keep_Names::\n * Pragma License::\n * Pragma Link_With::\n@@ -774,6 +775,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Interface_Name::\n * Pragma Interrupt_Handler::\n * Pragma Interrupt_State::\n+* Pragma Invariant::\n * Pragma Keep_Names::\n * Pragma License::\n * Pragma Link_With::\n@@ -3052,6 +3054,43 @@ Overriding the default state of signals used by the Ada runtime may interfere\n with an application's runtime behavior in the cases of the synchronous signals,\n and in the case of the signal used to implement the @code{abort} statement.\n \n+@node Pragma Invariant\n+@unnumberedsec Pragma Invariant\n+@findex Invariant\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Invariant\n+  ([Entity =>]    private_type_LOCAL_NAME,\n+   [Check  =>]    EXPRESSION\n+   [,[Message =>] String_Expression]);\n+@end smallexample\n+\n+@noindent\n+This pragma provides exactly the same capabilities as the Invariant aspect\n+defined in AI05-0146-1, and in the Ada 2012 Reference Manual. The Invariant\n+aspect is fully implemented in Ada 2012 mode, but since it requires the use\n+of the aspect syntax, which is not available exception in 2012 mode, it is\n+not possible to use the Invariant aspect in earlier versions of Ada. However\n+the Invariant pragma may be used in any version of Ada.\n+\n+The pragma must appear within the visible part of the package specification,\n+after the type to which its Entity argument appears. As with the Invariant\n+aspect, the Check expression is not analyzed until the end of the visible\n+part of the package, so it may contain forward references. The Message\n+argument, if present, provides the exception message used if the invariant\n+is violated. If no Message parameter is provided, a default message that\n+identifies the line on which the pragma appears is used.\n+\n+It is permissible to have multiple Invariants for the same type entity, in\n+which case they are and'ed together. It is permissible to use this pragma\n+in Ada 2012 mode, but you cannot have both an invariant aspect and an\n+invariant pragma for the same entity.\n+\n+For further details on the use of this pragma, see the Ada 2012 documentation\n+of the Invariant aspect.\n+\n @node Pragma Keep_Names\n @unnumberedsec Pragma Keep_Names\n @findex Keep_Names"}, {"sha": "03d8fbc18ec83c37b3cbf519d7b1576331998aae", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deeb160439b8a02a5e00909ab29c25103a162d32/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=deeb160439b8a02a5e00909ab29c25103a162d32", "patch": "@@ -2242,6 +2242,13 @@ package VMS_Data is\n    --\n    --    When looking for source files also look in directories specified.\n \n+   S_GCC_Src_Info : aliased constant S := \"/SRC_INFO=<\"                    &\n+                                             \"--source-info=>\";\n+   --        /SRC_INFO=source-info-file\n+   --\n+   --   Specify a source info file to be read or written by the Project\n+   --   Manager when project files are used.\n+\n    S_GCC_Style   : aliased constant S := \"/STYLE_CHECKS=\"                  &\n                                             \"ALL_BUILTIN \"                 &\n                                                \"-gnatyy \"                  &\n@@ -2776,6 +2783,13 @@ package VMS_Data is\n    --   semantic analyzer is more likely to encounter some internal fatal\n    --   error when given a syntactically invalid tree.\n \n+   S_GCC_USL : aliased constant S := \"/UNCHECKED_SHARED_LIB_IMPORTS \"      &\n+                                         \"--unchecked-shared-lib-imports\";\n+   --        /NOUNCHECKED_SHARED_LIB_IMPORTS (D)\n+   --        /UNCHECKED_SHARED_LIB_IMPORTS\n+   --\n+   --   Allow shared library projects to import static library projects\n+\n    S_GCC_Units   : aliased constant S := \"/UNITS_LIST \"                    &\n                                             \"-gnatu\";\n    --        /NOUNITS_LIST (D)\n@@ -3551,6 +3565,7 @@ package VMS_Data is\n                      S_GCC_RTS     'Access,\n                      S_GCC_SCO     'Access,\n                      S_GCC_Search  'Access,\n+                     S_GCC_Src_Info'Access,\n                      S_GCC_Style   'Access,\n                      S_GCC_StyleX  'Access,\n                      S_GCC_Subdirs 'Access,\n@@ -3560,6 +3575,7 @@ package VMS_Data is\n                      S_GCC_Trace   'Access,\n                      S_GCC_Tree    'Access,\n                      S_GCC_Trys    'Access,\n+                     S_GCC_USL     'Access,\n                      S_GCC_Units   'Access,\n                      S_GCC_Unique  'Access,\n                      S_GCC_Upcase  'Access,\n@@ -4903,7 +4919,7 @@ package VMS_Data is\n    --   When looking for source files also look in the specified directories.\n \n    S_Make_Src_Info : aliased constant S := \"/SRC_INFO=<\"                   &\n-                                            \"--source-info-file=>\";\n+                                             \"--source-info=>\";\n    --        /SRC_INFO=source-info-file\n    --\n    --   Specify a source info file to be read or written by the Project"}]}