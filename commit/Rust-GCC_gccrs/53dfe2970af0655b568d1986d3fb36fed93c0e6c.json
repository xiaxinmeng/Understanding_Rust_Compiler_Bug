{"sha": "53dfe2970af0655b568d1986d3fb36fed93c0e6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkZmUyOTcwYWYwNjU1YjU2OGQxOTg2ZDNmYjM2ZmVkOTNjMGU2Yw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "1999-06-11T01:38:08Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "1999-06-11T01:38:08Z"}, "message": "natInetAddress.cc (aton): Fix typos.\n\n        * java/net/natInetAddress.cc (aton): Fix typos.\n        (lookup): Use a bigger buffer size for gethostbyname_r on all\n        versions of glibc. Updated FIXME comment explaining this.\n        Modified while loops to not set herr = ERANGE to work around glibc\n        problems. Use user specified hostname in InetAddress result when\n        available (consistent with JDK).\n\nFrom-SVN: r27484", "tree": {"sha": "db3e2be0d843da62dfa2e96460604e158facfd9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db3e2be0d843da62dfa2e96460604e158facfd9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53dfe2970af0655b568d1986d3fb36fed93c0e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dfe2970af0655b568d1986d3fb36fed93c0e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53dfe2970af0655b568d1986d3fb36fed93c0e6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53dfe2970af0655b568d1986d3fb36fed93c0e6c/comments", "author": null, "committer": null, "parents": [{"sha": "b312276f5be691c10989fa5e799ee52d846b85db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b312276f5be691c10989fa5e799ee52d846b85db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b312276f5be691c10989fa5e799ee52d846b85db"}], "stats": {"total": 49, "additions": 31, "deletions": 18}, "files": [{"sha": "8a2eb837a8d23f6e83ca44c4a92e5ebca2fe7653", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dfe2970af0655b568d1986d3fb36fed93c0e6c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dfe2970af0655b568d1986d3fb36fed93c0e6c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=53dfe2970af0655b568d1986d3fb36fed93c0e6c", "patch": "@@ -1,3 +1,11 @@\n+1999-06-10  Bryce McKinlay  <bryce@albatross.co.nz>\n+\t* java/net/natInetAddress.cc (aton): Fix typos.\n+\t(lookup): Use a bigger buffer size for gethostbyname_r on all\n+\tversions of glibc. Updated FIXME comment explaining this.\n+\tModified while loops to not set herr = ERANGE to work around glibc \n+\tproblems. Use user specified hostname in InetAddress result when\n+\tavailable (consistent with JDK).\n+\n 1999-06-10  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/io/FileDescriptor.java (FileDescriptor(String, int)):"}, {"sha": "8da9102815a0920e97196576c0b17fabc52f408a", "filename": "libjava/java/net/natInetAddress.cc", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53dfe2970af0655b568d1986d3fb36fed93c0e6c/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53dfe2970af0655b568d1986d3fb36fed93c0e6c/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=53dfe2970af0655b568d1986d3fb36fed93c0e6c", "patch": "@@ -64,27 +64,27 @@ java::net::InetAddress::aton (jstring host)\n   if (inet_aton (hostname, &laddr))\n     {\n       bytes = (char*) &laddr;\n-      len = 4;\n+      blen = 4;\n     }\n #elif defined(HAVE_INET_ADDR)\n   in_addr_t laddr = inet_addr (hostname);\n   if (laddr != (in_addr_t)(-1))\n     {\n       bytes = (char*) &laddr;\n-      len = 4;\n+      blen = 4;\n     }\n #endif\n #ifdef HAVE_INET_PTON\n   char inet6_addr[16];\n   if (len == 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n     {\n       bytes = inet6_addr;\n-      len = 16;\n+      blen = 16;\n     }\n #endif\n   if (blen == 0)\n     return NULL;\n-  jbyteArray result = JvNewByteArray (len);\n+  jbyteArray result = JvNewByteArray (blen);\n   memcpy (elements (result), bytes, blen);\n   return result;\n }\n@@ -97,10 +97,11 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n   struct hostent *hptr = NULL;\n #if defined (HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR_R)\n   struct hostent hent_r;\n-#if defined (__GLIBC__) && __GLIBC__ == 2 && __GLIBC_MINOR__ == 0\n-  // glibc 2.0.7 has a bug where gethostbyname_r won't return an error\n-  // if the buffer is too small.  So in this case we size the buffer\n-  // the same way that glibc does.  This is fixed in glibc 2.1.\n+#if defined (__GLIBC__) \n+  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n+  // ERANGE to errno if the buffer size is too small, rather than what is \n+  // expected here. We work around this by setting a bigger buffer size and \n+  // hoping that it is big enough.\n   char fixed_buffer[1024];\n #else\n   char fixed_buffer[200];\n@@ -121,8 +122,8 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n       JvGetStringUTFRegion (host, 0, host->length(), hostname);\n       buf[len] = '\\0';\n #ifdef HAVE_GETHOSTBYNAME_R\n-      int herr = ERANGE;\n-      while (hptr == NULL && herr == ERANGE)\n+      int herr = 0;\n+      while (true)\n \t{\n \t  int ok;\n #ifdef GETHOSTBYNAME_R_RETURNS_INT\n@@ -137,6 +138,8 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n \t      size_r *= 2;\n \t      buffer_r = (char *) _Jv_AllocBytesChecked (size_r);\n \t    }\n+\t  else\n+\t    break;\n \t}\n #else\n       // FIXME: this is insufficient if some other piece of code calls\n@@ -168,8 +171,8 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n \tJvFail (\"unrecognized size\");\n \n #ifdef HAVE_GETHOSTBYADDR_R\n-      int herr = ERANGE;\n-      while (hptr == NULL && herr == ERANGE)\n+      int herr = 0;\n+      while (true)\n \t{\n \t  int ok;\n #ifdef GETHOSTBYADDR_R_RETURNS_INT\n@@ -185,6 +188,8 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n \t      size_r *= 2;\n \t      buffer_r = (char *) _Jv_AllocBytesChecked (size_r);\n \t    }\n+\t  else \n+\t    break;\n \t}\n #else /* HAVE_GETHOSTBYADDR_R */\n       // FIXME: this is insufficient if some other piece of code calls\n@@ -194,8 +199,9 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n #endif /* HAVE_GETHOSTBYADDR_R */\n     }\n   if (hptr != NULL)\n-    {\n-      host = JvNewStringUTF (hptr->h_name);\n+    { \n+      if (host == NULL)\n+        host = JvNewStringUTF (hptr->h_name);\n       java::lang::SecurityException *ex = checkConnect (host);\n       if (ex != NULL)\n \t{\n@@ -240,13 +246,12 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n     {\n       if (iaddrs[i] == NULL)\n \tiaddrs[i] = new java::net::InetAddress (NULL, NULL);\n-      if (i == 0)\n-\tiaddrs[0]->hostname = host;\n+      iaddrs[i]->hostname = host;\n       if (iaddrs[i]->address == NULL)\n \t{\n \t  char *bytes = hptr->h_addr_list[i];\n-\t  iaddr->address = JvNewByteArray (hptr->h_length);\n-\t  memcpy (elements (iaddr->address), bytes, hptr->h_length);\n+\t  iaddrs[i]->address = JvNewByteArray (hptr->h_length);\n+\t  memcpy (elements (iaddrs[i]->address), bytes, hptr->h_length);\n \t}\n     }\n   return result;"}]}