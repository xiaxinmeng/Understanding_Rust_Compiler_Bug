{"sha": "b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc3ZDFhMTc1Zjk0ZWI0OWY2MmEwMmM0YTU0ZmU2MTdlMWNkMzM2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:08:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:08:36Z"}, "message": "[3/77] Allow machine modes to be classes\n\nThis patch makes various changes that allow modes like SImode to be\nclasses rather than enums.\n\nFirstly, it adds inline functions for all mode size properties,\nwith the macros being simple wrappers around them.  This is necessary\nfor the __builtin_constant_p trick to continue working effectively when\nthe mode arguments are slightly more complex (but still foldable at\ncompile time).\n\nThese inline functions are trivial and heavily used.  There's not much\npoint keeping them out-of-line at -O0: if anything it would make\ndebugging harder rather than easier, and it would also slow things down.\nThe patch therefore marks them as \"always_inline\", if that's available.\nLater patches use this approach too.\n\nUsing inline functions means that it's no longer possible to pass\nan int to GET_MODE_PRECISION etc.  The Fortran and powerpcspe-c.c\nparts are needed to avoid instances of that.\n\nThe patch continues to use enums for gencondmd.c, so that more\nmode comparisons are integer constant expressions when checking\nfor always-true or always-false conditions.  This is the only\nintended use of USE_ENUM_MODES.\n\nThe patch also enforces the previous replacement of case statements\nby defining modes as:\n\n  #define FOOmode ((void) 0, E_FOOmode)\n\nThis adds no overhead but makes sure that new uses of \"case FOOmode:\"\ndon't accidentally creep in when FOOmode has no specific class associated\nwith it.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* genconditions.c (write_header): Add a \"#define USE_ENUM_MODES\".\n\t* genmodes.c (emit_insn_modes_h): Define FOOmode to E_FOOmode if\n\tUSE_ENUM_MODES is defined and to ((void) 0, E_FOOmode) otherwise.\n\t* machmode.h (mode_size): Move earlier in file.\n\t(mode_precision): Likewise.\n\t(mode_inner): Likewise.\n\t(mode_nunits): Likewise.\n\t(mode_unit_size): Likewise.\n\t(unit_unit_precision): Likewise.\n\t(mode_wider): Likewise.\n\t(mode_2xwider): Likewise.\n\t(machine_mode): New class.\n\t(mode_to_bytes): New function.\n\t(mode_to_bits): Likewise.\n\t(mode_to_precision): Likewise.\n\t(mode_to_inner): Likewise.\n\t(mode_to_unit_size): Likewise.\n\t(mode_to_unit_precision): Likewise.\n\t(mode_to_nunits): Likewise.\n\t(GET_MODE_SIZE): Use mode_to_bytes.\n\t(GET_MODE_BITSIZE): Use mode_to_bits.\n\t(GET_MODE_PRECISION): Use mode_to_precision.\n\t(GET_MODE_INNER): Use mode_to_inner.\n\t(GET_MODE_UNIT_SIZE): Use mode_to_unit_size.\n\t(GET_MODE_UNIT_PRECISION): Use mode_to_unit_precision.\n\t(GET_MODE_NUNITS): Use mode_to_nunits.\n\t* system.h (ALWAYS_INLINE): New macro.\n\t* config/powerpcspe/powerpcspe-c.c\n\t(altivec_resolve_overloaded_builtin): Use machine_mode instead of\n\tint for arg1_mode and arg2_mode.\n\ngcc/fortran/\n\t* trans-types.c (gfc_init_kinds): Use machine_mode instead of int\n\tfor \"mode\".\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251454", "tree": {"sha": "7838879f1acc681160dd36fd74ccba491b695ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7838879f1acc681160dd36fd74ccba491b695ba5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/comments", "author": null, "committer": null, "parents": [{"sha": "4e10a5a74b2571a72ab944195267334d56b9534b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e10a5a74b2571a72ab944195267334d56b9534b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e10a5a74b2571a72ab944195267334d56b9534b"}], "stats": {"total": 221, "additions": 166, "deletions": 55}, "files": [{"sha": "b15b1b7c0bd00176846e958dc84dc16d16255fd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -1,3 +1,38 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* genconditions.c (write_header): Add a \"#define USE_ENUM_MODES\".\n+\t* genmodes.c (emit_insn_modes_h): Define FOOmode to E_FOOmode if\n+\tUSE_ENUM_MODES is defined and to ((void) 0, E_FOOmode) otherwise.\n+\t* machmode.h (mode_size): Move earlier in file.\n+\t(mode_precision): Likewise.\n+\t(mode_inner): Likewise.\n+\t(mode_nunits): Likewise.\n+\t(mode_unit_size): Likewise.\n+\t(unit_unit_precision): Likewise.\n+\t(mode_wider): Likewise.\n+\t(mode_2xwider): Likewise.\n+\t(machine_mode): New class.\n+\t(mode_to_bytes): New function.\n+\t(mode_to_bits): Likewise.\n+\t(mode_to_precision): Likewise.\n+\t(mode_to_inner): Likewise.\n+\t(mode_to_unit_size): Likewise.\n+\t(mode_to_unit_precision): Likewise.\n+\t(mode_to_nunits): Likewise.\n+\t(GET_MODE_SIZE): Use mode_to_bytes.\n+\t(GET_MODE_BITSIZE): Use mode_to_bits.\n+\t(GET_MODE_PRECISION): Use mode_to_precision.\n+\t(GET_MODE_INNER): Use mode_to_inner.\n+\t(GET_MODE_UNIT_SIZE): Use mode_to_unit_size.\n+\t(GET_MODE_UNIT_PRECISION): Use mode_to_unit_precision.\n+\t(GET_MODE_NUNITS): Use mode_to_nunits.\n+\t* system.h (ALWAYS_INLINE): New macro.\n+\t* config/powerpcspe/powerpcspe-c.c\n+\t(altivec_resolve_overloaded_builtin): Use machine_mode instead of\n+\tint for arg1_mode and arg2_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "db0415312092253b9c98ab2eed8a94939102f155", "filename": "gcc/config/powerpcspe/powerpcspe-c.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-c.c?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -6504,8 +6504,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n     if (fcode == P6_OV_BUILTIN_CMPB)\n       {\n \tint overloaded_code;\n-\tint arg1_mode = TYPE_MODE (types[0]);\n-\tint arg2_mode = TYPE_MODE (types[1]);\n+\tmachine_mode arg1_mode = TYPE_MODE (types[0]);\n+\tmachine_mode arg2_mode = TYPE_MODE (types[1]);\n \n \tif (nargs != 2)\n \t  {"}, {"sha": "fe2d80214a533fd849f12dd929b0cff7804174cf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* trans-types.c (gfc_init_kinds): Use machine_mode instead of int\n+\tfor \"mode\".\n+\n 2017-08-28  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/81770"}, {"sha": "7d2d274d3baca840577c941ba1b538125ef2b2b3", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -363,22 +363,23 @@ gfc_init_c_interop_kinds (void)\n void\n gfc_init_kinds (void)\n {\n-  unsigned int mode;\n+  machine_mode mode;\n   int i_index, r_index, kind;\n   bool saw_i4 = false, saw_i8 = false;\n   bool saw_r4 = false, saw_r8 = false, saw_r10 = false, saw_r16 = false;\n \n-  for (i_index = 0, mode = MIN_MODE_INT; mode <= MAX_MODE_INT; mode++)\n+  for (i_index = 0, mode = MIN_MODE_INT; mode <= MAX_MODE_INT;\n+       mode = (machine_mode) ((int) mode + 1))\n     {\n       int kind, bitsize;\n \n-      if (!targetm.scalar_mode_supported_p ((machine_mode) mode))\n+      if (!targetm.scalar_mode_supported_p (mode))\n \tcontinue;\n \n       /* The middle end doesn't support constants larger than 2*HWI.\n \t Perhaps the target hook shouldn't have accepted these either,\n \t but just to be safe...  */\n-      bitsize = GET_MODE_BITSIZE ((machine_mode) mode);\n+      bitsize = GET_MODE_BITSIZE (mode);\n       if (bitsize > 2*HOST_BITS_PER_WIDE_INT)\n \tcontinue;\n \n@@ -418,15 +419,16 @@ gfc_init_kinds (void)\n   /* Set the maximum integer kind.  Used with at least BOZ constants.  */\n   gfc_max_integer_kind = gfc_integer_kinds[i_index - 1].kind;\n \n-  for (r_index = 0, mode = MIN_MODE_FLOAT; mode <= MAX_MODE_FLOAT; mode++)\n+  for (r_index = 0, mode = MIN_MODE_FLOAT; mode <= MAX_MODE_FLOAT;\n+       mode = (machine_mode) ((int) mode + 1))\n     {\n       const struct real_format *fmt =\n-\tREAL_MODE_FORMAT ((machine_mode) mode);\n+\tREAL_MODE_FORMAT (mode);\n       int kind;\n \n       if (fmt == NULL)\n \tcontinue;\n-      if (!targetm.scalar_mode_supported_p ((machine_mode) mode))\n+      if (!targetm.scalar_mode_supported_p (mode))\n \tcontinue;\n \n       /* Only let float, double, long double and __float128 go through."}, {"sha": "f62ff1626b1158c93710bf48428b74625210f60b", "filename": "gcc/genconditions.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -67,6 +67,7 @@ write_header (void)\n #undef ENABLE_RTL_FLAG_CHECKING\\n\\\n #undef ENABLE_GC_CHECKING\\n\\\n #undef ENABLE_GC_ALWAYS_COLLECT\\n\\\n+#define USE_ENUM_MODES\\n\\\n \\n\\\n #include \\\"coretypes.h\\\"\\n\\\n #include \\\"tm.h\\\"\\n\\"}, {"sha": "96b6ece90d78d9b84eee21d8be10521334b0e089", "filename": "gcc/genmodes.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -1155,8 +1155,12 @@ enum machine_mode\\n{\");\n \tprintf (\"%*s/* %s:%d */\\n\", 27 - count_, \"\",\n \t\t trim_filename (m->file), m->line);\n \tprintf (\"#define HAVE_%smode\\n\", m->name);\n-\tprintf (\"#define %smode E_%smode\\n\",\n+\tprintf (\"#ifdef USE_ENUM_MODES\\n\");\n+\tprintf (\"#define %smode E_%smode\\n\", m->name, m->name);\n+\tprintf (\"#else\\n\");\n+\tprintf (\"#define %smode ((void) 0, E_%smode)\\n\",\n \t\tm->name, m->name);\n+\tprintf (\"#endif\\n\");\n       }\n \n   puts (\"  MAX_MACHINE_MODE,\\n\");"}, {"sha": "330fdf9e6b1de1ac82eaf3cb8cbfdc3b1993f4bd", "filename": "gcc/machmode.h", "status": "modified", "additions": 101, "deletions": 45, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -20,6 +20,15 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef HAVE_MACHINE_MODES\n #define HAVE_MACHINE_MODES\n \n+extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n+extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n+extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n+extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n+extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n+extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n+extern const unsigned char mode_wider[NUM_MACHINE_MODES];\n+extern const unsigned char mode_2xwider[NUM_MACHINE_MODES];\n+\n /* Get the name of mode MODE as a string.  */\n \n extern const char * const mode_name[NUM_MACHINE_MODES];\n@@ -174,22 +183,98 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n #define POINTER_BOUNDS_MODE_P(MODE)      \\\n   (GET_MODE_CLASS (MODE) == MODE_POINTER_BOUNDS)\n \n-/* Get the size in bytes and bits of an object of mode MODE.  */\n+/* Return the base GET_MODE_SIZE value for MODE.  */\n \n-extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n+ALWAYS_INLINE unsigned short\n+mode_to_bytes (machine_mode mode)\n+{\n+#if GCC_VERSION >= 4001\n+  return (__builtin_constant_p (mode)\n+\t  ? mode_size_inline (mode) : mode_size[mode]);\n+#else\n+  return mode_size[mode];\n+#endif\n+}\n+\n+/* Return the base GET_MODE_BITSIZE value for MODE.  */\n+\n+ALWAYS_INLINE unsigned short\n+mode_to_bits (machine_mode mode)\n+{\n+  return mode_to_bytes (mode) * BITS_PER_UNIT;\n+}\n+\n+/* Return the base GET_MODE_PRECISION value for MODE.  */\n+\n+ALWAYS_INLINE unsigned short\n+mode_to_precision (machine_mode mode)\n+{\n+  return mode_precision[mode];\n+}\n+\n+/* Return the base GET_MODE_INNER value for MODE.  */\n+\n+ALWAYS_INLINE machine_mode\n+mode_to_inner (machine_mode mode)\n+{\n+#if GCC_VERSION >= 4001\n+  return (machine_mode) (__builtin_constant_p (mode)\n+\t\t\t ? mode_inner_inline (mode) : mode_inner[mode]);\n+#else\n+  return (machine_mode) mode_inner[mode];\n+#endif\n+}\n+\n+/* Return the base GET_MODE_UNIT_SIZE value for MODE.  */\n+\n+ALWAYS_INLINE unsigned char\n+mode_to_unit_size (machine_mode mode)\n+{\n+#if GCC_VERSION >= 4001\n+  return (__builtin_constant_p (mode)\n+\t  ? mode_unit_size_inline (mode) : mode_unit_size[mode]);\n+#else\n+  return mode_unit_size[mode];\n+#endif\n+}\n+\n+/* Return the base GET_MODE_UNIT_PRECISION value for MODE.  */\n+\n+ALWAYS_INLINE unsigned short\n+mode_to_unit_precision (machine_mode mode)\n+{\n+#if GCC_VERSION >= 4001\n+  return (__builtin_constant_p (mode)\n+\t  ? mode_unit_precision_inline (mode) : mode_unit_precision[mode]);\n+#else\n+  return mode_unit_precision[mode];\n+#endif\n+}\n+\n+/* Return the base GET_MODE_NUNITS value for MODE.  */\n+\n+ALWAYS_INLINE unsigned short\n+mode_to_nunits (machine_mode mode)\n+{\n #if GCC_VERSION >= 4001\n-#define GET_MODE_SIZE(MODE) \\\n-  ((unsigned short) (__builtin_constant_p (MODE) \\\n-\t\t     ? mode_size_inline (MODE) : mode_size[MODE]))\n+  return (__builtin_constant_p (mode)\n+\t  ? mode_nunits_inline (mode) : mode_nunits[mode]);\n #else\n-#define GET_MODE_SIZE(MODE)    ((unsigned short) mode_size[MODE])\n+  return mode_nunits[mode];\n #endif\n-#define GET_MODE_BITSIZE(MODE) \\\n-  ((unsigned short) (GET_MODE_SIZE (MODE) * BITS_PER_UNIT))\n+}\n+\n+/* Get the size in bytes of an object of mode MODE.  */\n+\n+#define GET_MODE_SIZE(MODE) (mode_to_bytes (MODE))\n+\n+/* Get the size in bits of an object of mode MODE.  */\n+\n+#define GET_MODE_BITSIZE(MODE) (mode_to_bits (MODE))\n \n /* Get the number of value bits of an object of mode MODE.  */\n-extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n-#define GET_MODE_PRECISION(MODE)  mode_precision[MODE]\n+\n+#define GET_MODE_PRECISION(MODE) (mode_to_precision (MODE))\n \n /* Get the number of integral bits of an object of mode MODE.  */\n extern CONST_MODE_IBIT unsigned char mode_ibit[NUM_MACHINE_MODES];\n@@ -210,51 +295,22 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n    mode of the vector elements.  For complex modes it is the mode of the real\n    and imaginary parts.  For other modes it is MODE itself.  */\n \n-extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n-#if GCC_VERSION >= 4001\n-#define GET_MODE_INNER(MODE) \\\n-  ((machine_mode) (__builtin_constant_p (MODE) \\\n-\t\t\t? mode_inner_inline (MODE) : mode_inner[MODE]))\n-#else\n-#define GET_MODE_INNER(MODE) ((machine_mode) mode_inner[MODE])\n-#endif\n+#define GET_MODE_INNER(MODE) (mode_to_inner (MODE))\n \n /* Get the size in bytes or bits of the basic parts of an\n    object of mode MODE.  */\n \n-extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n-#if GCC_VERSION >= 4001\n-#define GET_MODE_UNIT_SIZE(MODE) \\\n-  ((unsigned char) (__builtin_constant_p (MODE) \\\n-\t\t   ? mode_unit_size_inline (MODE) : mode_unit_size[MODE]))\n-#else\n-#define GET_MODE_UNIT_SIZE(MODE) mode_unit_size[MODE]\n-#endif\n+#define GET_MODE_UNIT_SIZE(MODE) mode_to_unit_size (MODE)\n \n #define GET_MODE_UNIT_BITSIZE(MODE) \\\n   ((unsigned short) (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT))\n \n-extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n-#if GCC_VERSION >= 4001\n-#define GET_MODE_UNIT_PRECISION(MODE) \\\n-  ((unsigned short) (__builtin_constant_p (MODE) \\\n-\t\t    ? mode_unit_precision_inline (MODE)\\\n-\t\t    : mode_unit_precision[MODE]))\n-#else\n-#define GET_MODE_UNIT_PRECISION(MODE) mode_unit_precision[MODE]\n-#endif\n-\n+#define GET_MODE_UNIT_PRECISION(MODE) (mode_to_unit_precision (MODE))\n \n-/* Get the number of units in the object.  */\n+/* Get the number of units in an object of mode MODE.  This is 2 for\n+   complex modes and the number of elements for vector modes.  */\n \n-extern const unsigned char mode_nunits[NUM_MACHINE_MODES];\n-#if GCC_VERSION >= 4001\n-#define GET_MODE_NUNITS(MODE) \\\n-  ((unsigned char) (__builtin_constant_p (MODE) \\\n-\t\t    ? mode_nunits_inline (MODE) : mode_nunits[MODE]))\n-#else\n-#define GET_MODE_NUNITS(MODE)  mode_nunits[MODE]\n-#endif\n+#define GET_MODE_NUNITS(MODE) (mode_to_nunits (MODE))\n \n /* Get the next wider natural mode (eg, QI -> HI -> SI -> DI -> TI).  */\n "}, {"sha": "5e16a77854188ebe0b15e813a4d4ebcbe0c8f185", "filename": "gcc/system.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b77d1a175f94eb49f62a02c4a54fe617e1cd3363/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=b77d1a175f94eb49f62a02c4a54fe617e1cd3363", "patch": "@@ -745,6 +745,12 @@ extern void fancy_abort (const char *, int, const char *)\n #define gcc_checking_assert(EXPR) ((void)(0 && (EXPR)))\n #endif\n \n+#if GCC_VERSION >= 4000\n+#define ALWAYS_INLINE inline __attribute__ ((always_inline))\n+#else\n+#define ALWAYS_INLINE inline\n+#endif\n+\n /* Use gcc_unreachable() to mark unreachable locations (like an\n    unreachable default case of a switch.  Do not use gcc_assert(0).  */\n #if (GCC_VERSION >= 4005) && !ENABLE_ASSERT_CHECKING"}]}