{"sha": "0a36105d5657dd7126160c5bae2b9b68af63fcff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEzNjEwNWQ1NjU3ZGQ3MTI2MTYwYzViYWUyYjliNjhhZjYzZmNmZg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:23:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:23:15Z"}, "message": "einfo.ads, einfo.adb (Available_View): New synthesized attribute applicable to types that have the With_Type flag set.\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* einfo.ads, einfo.adb (Available_View): New synthesized attribute\n\tapplicable to types that have the With_Type flag set. Returns the\n\tnon-limited view of the type, if available, otherwise the type itself.\n\tFor class-wide types, there is no direct link in the tree, so we have\n\tto retrieve the class-wide type of the non-limited view of the Etype.\n\tNew attributes Static_Initialization and Static_Elaboration_Desired.\n\tRemove the pragma Thread_Body, and the associated flag\n\tIs_Thread_Body in entities, and all related code.\n\t(Suppress_Value_Tracking_On_Call): New flag\n\tE_Exception has Esize and Alignment fields\n\t(Universal_Aliasing): New function.\n\t(Set_Universal_Aliasing): New procedure.\n\t(Write_Entity_Flags): Deal with Universal_Aliasing flag.\n\t(Check_Nested_Access): New procedure.\n\t(Has_Up_Level_Access, Set_Has_Up_Level_Access): New procedures.\n\t(Find_Direct_Name, Note_Possible_Modification): Use Check_Nested_Access.\n\t(Related_Interface): New attribute. Present in dispatch table pointer\n\tcomponents of records. Set to point to the entity of the corresponding\n\tinterface type.\n\t(Is_By_Reference_Type): Recurse on the full view of an incomplete type.\n\t(Original_Access_Type): Remove, not needed.\n\t(Root_Type): Handle properly subtypes of class-wide-types.\n\tUpdate comments.\n\n\t* sem_ch4.adb (Analyze_Explicit_Dereference): Add support for\n\tclass-wide types visible through limited-with clauses.\n\t(Try_Primitive_Operation): When examining all primitive operations of a\n\ttagged type, do not consider subprograms labeled as hidden unless they\n\tbelong to a private generic type with a tagged parent.\n\t(Try_Object_Operation): Extensive rewriting, to handle properly various\n\toverloading cases, when several ancestors may have class-wide operations\n\tthat are possible candidates, and when the overloaded functions return\n\tarray types and have defaulted parameters so that the call may be\n\tinterpreted as an indexing.\n\t(Analyze_Allocator): Remove Mark_Allocator and its invocation.\n\t(Process_Function_Call): use Next, rather than Next_Actual, to analyze\n\tsuccessive actuals before analyzing the call itself.\n\t(Try_Primitive_Operation): A primitive operation is compatible with the\n\tprefix if the prefix has a synchronized type and the type of the formal\n\tis its corresponding record, as can be the case when the primitive\n\toperation is declared outside of the body of the type.\n\t(Traverse_Homonyms): New subprocedure of Try_Class_Wide_Operation, to\n\tperform homonym traversal, looking for class-wide operation matches\n\t(formerly done in statements of Try_Class_Wide_Operation). Matches on\n\taccess parameters are now restricted to anonymous access types.\n\t(Mark_Allocator): An allocator with a discriminant association parent is\n\ta coextension.\n\t(Try_One_Prefix_Interpretation): If the type of the object is\n\tincomplete, as can be happen when it is a limited view obtained through\n\ta limited_with_clause, the selected component is not part of a prefixed\n\tcall.\n\t(Complete_Object_Operation): Diagnose properly an object that is not\n\taliased when the corresponding controlling formal is an access\n\tparameter.\n\t(Try_Primitive_Operation, Try_Class_Wide_Operation): Diagnose properly\n\tambiguous calls in prefixed notation, where two primitives differ only\n\tin that the controlling argument of one is an access parameter.\n\n\t* sem_ch6.adb (Has_Single_Return): Add guard in code that determines\n\twhether a function that returns an unconstrained type can be inlined.\n\t(Process_Formals): Diagnose properly the illegal use of an incomplete\n\ttype in the profile of an access_to_subprogram declaration.\n\t(Check_Synchronized_Overriding): Nothing check for concurrent types, the\n\toperations are attached to the corresponding record.\n\t(Analyze_Subprogram_Specification): Add variables Formal and Formal_Typ.\n\tWhen processing a primitive of a concurrent type which implements an\n\tinterface change the type of all controlling formals to that of the\n\tcorresponding record type.\n\t(Check_Synchronized_Overriding): Relax the conditional logic when trying\n\tto determine the tagged type to which a primitive belongs.\n\t(Check_Conventions): Capture condition to ignore a primitive operation\n\t(which is shared between the loop in Check_Conventions and the one in\n\tCheck_Convention) in a new local function Skip_Check.\n\t(Check_Convention): Rename Prim_Op to Second_Prim_Op to avoid possible\n\tconfusion with Check_Conventions' own Prim_Op local variable.\n\t(Create_Extra_Formals): Test for a tagged result type rather than a\n\tcontrolling result when determining whether to add a BIP_Alloc_Form\n\tformal and a BIP_Final_List formal to the function.\n\t(Check_Conformance); For parameters that are anonymous access types,\n\tsubtype conformance requires that the not null and the constant\n\tindicators must match\n\t(Check_Synchronized_Overriding): New parameter Formal_Typ. Add machinery\n\tto retrieve the appropriate type when processing a concurrent type\n\tdeclared within a generic. Minor comment reformatting. Change invocation\n\tof Overrides_Synchronized_Primitive to Find_Overridden_Synchronized_Pri-\n\tmitive.\n\t(Analyze_Subprogram_Body): If the return type of a function is an\n\tanonymous access to the limited view of a class-wide type, and the\n\tnon-limited view of the type is available, update the type of the\n\tfunction so that code can be generated.\n\t(Process_Formals): In case of access-subtype itype whose designated\n\ttype is also an itype (situation that happens now with access to\n\tsubprograms) we mark the access-type itype with the Has_Delayed_Freeze\n\tattribute to avoid backend problems.\n\t(Check_Return_Subtype_Indication): Replace R_Type with R_Stm_Type in\n\tinit of R_Stm_Type_Is_Anon_Access. Also check that base types of the\n\tanonymous types' designated types are same before testing\n\tSubtypes_Statically_Match.\n\t(Create_Extra_Formals): Test for a named access parameter that is a\n\tcontrolling formal as an additional condition for adding an\n\taccessibility level formal. This can occur in the subp type created for\n\tdispatching calls in Expand_Dispatching_Call, and allows calling\n\tCreate_Extra_Formals from that procedure rather than special-casing the\n\textra formals there.\n\t(Create_Extra_Formals): Add BIP_Alloc_Form and BIP_Final_List formals\n\twhen the function has a controlling result.\n\t(Check_Returns): Add much more knowledge of the optimization of local\n\traise statements to gotos, to retain proper warnings in this case.\n\t(Check_Statement_Sequence): Ignore N_Push_xxx_Label and N_Pop_xxx_Label\n\tnodes when looking for last statement.\n\n\t* sem_type.ads, sem_type.adb (Specific_Type): Add support for\n\tclass-wide types visible through limited with clauses.\n\t(Add_One_Interp): If the operands are anonymous access types, the\n\tpredefined operator on universal_access is immediately visibles\n\t(Find_Unique_Type): Handle anonymous access to subprogram types just as\n\tother anonymous access types.\n\t(Disambiguate): Take into account CIL convention.\n\t(Interface_Present_In_Ancestor): Add support for class-wide interfaces.\n\nFrom-SVN: r125390", "tree": {"sha": "532cf462f398cdea81f9b2907d3cf7b3ad43c7dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/532cf462f398cdea81f9b2907d3cf7b3ad43c7dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a36105d5657dd7126160c5bae2b9b68af63fcff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a36105d5657dd7126160c5bae2b9b68af63fcff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a36105d5657dd7126160c5bae2b9b68af63fcff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a36105d5657dd7126160c5bae2b9b68af63fcff/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "109949cd3ca2200473c776d19996d72af3a5c6e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/109949cd3ca2200473c776d19996d72af3a5c6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/109949cd3ca2200473c776d19996d72af3a5c6e7"}], "stats": {"total": 1726, "additions": 1258, "deletions": 468}, "files": [{"sha": "011a7eab6defe4abc13560d41ba1b70e259179bb", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 161, "deletions": 42, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,7 +35,6 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n with Atree;  use Atree;\n-with Namet;  use Namet;\n with Nlists; use Nlists;\n with Sinfo;  use Sinfo;\n with Stand;  use Stand;\n@@ -220,6 +219,8 @@ package body Einfo is\n \n    --    Overridden_Operation            Node26\n    --    Package_Instantiation           Node26\n+   --    Related_Interface               Node26\n+   --    Static_Initialization           Node26\n \n    --    Wrapped_Entity                  Node27\n \n@@ -318,7 +319,7 @@ package body Einfo is\n    --    Is_CPP_Class                    Flag74\n    --    Has_Non_Standard_Rep            Flag75\n    --    Is_Constructor                  Flag76\n-   --    Is_Thread_Body                  Flag77\n+   --    Static_Elaboration_Desired      Flag77\n    --    Is_Tag                          Flag78\n    --    Has_All_Calls_Remote            Flag79\n    --    Is_Constr_Subt_For_U_Nominal    Flag80\n@@ -470,8 +471,26 @@ package body Einfo is\n    --    Has_Pragma_Unreferenced_Objects Flag212\n    --    Requires_Overriding             Flag213\n    --    Has_RACW                        Flag214\n-\n-   --    (unused)                        Flag215\n+   --    Has_Up_Level_Access             Flag215\n+   --    Universal_Aliasing              Flag216\n+   --    Suppress_Value_Tracking_On_Call Flag217\n+\n+   --    (unused)                        Flag77\n+\n+   --    (unused)                        Flag218\n+   --    (unused)                        Flag219\n+   --    (unused)                        Flag220\n+\n+   --    (unused)                        Flag221\n+   --    (unused)                        Flag222\n+   --    (unused)                        Flag223\n+   --    (unused)                        Flag224\n+   --    (unused)                        Flag225\n+   --    (unused)                        Flag226\n+   --    (unused)                        Flag227\n+   --    (unused)                        Flag228\n+   --    (unused)                        Flag229\n+   --    (unused)                        Flag230\n \n    -----------------------\n    -- Local subprograms --\n@@ -1387,7 +1406,6 @@ package body Einfo is\n \n    function Has_Stream_Size_Clause (Id : E) return B is\n    begin\n-      pragma Assert (Is_Elementary_Type (Id));\n       return Flag184 (Id);\n    end Has_Stream_Size_Clause;\n \n@@ -1412,6 +1430,15 @@ package body Einfo is\n       return Flag72 (Id);\n    end Has_Unknown_Discriminants;\n \n+   function Has_Up_Level_Access (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Variable\n+          or else Ekind (Id) = E_Constant\n+          or else Ekind (Id) = E_Loop_Parameter);\n+      return Flag215 (Id);\n+   end Has_Up_Level_Access;\n+\n    function Has_Volatile_Components (Id : E) return B is\n    begin\n       return Flag87 (Implementation_Base_Type (Id));\n@@ -1734,7 +1761,6 @@ package body Einfo is\n \n    function Is_Limited_Interface (Id : E) return B is\n    begin\n-      pragma Assert (Is_Interface (Id));\n       return Flag197 (Id);\n    end Is_Limited_Interface;\n \n@@ -1897,11 +1923,6 @@ package body Einfo is\n       return Flag200 (Id);\n    end Is_Task_Interface;\n \n-   function Is_Thread_Body (Id : E) return B is\n-   begin\n-      return Flag77 (Id);\n-   end Is_Thread_Body;\n-\n    function Is_True_Constant (Id : E) return B is\n    begin\n       return Flag163 (Id);\n@@ -2144,14 +2165,6 @@ package body Einfo is\n       return Node24 (Id);\n    end Obsolescent_Warning;\n \n-   function Original_Access_Type (Id : E) return E is\n-   begin\n-      pragma Assert\n-        (Ekind (Id) = E_Access_Subprogram_Type\n-           or else Ekind (Id) = E_Access_Protected_Subprogram_Type);\n-      return Node21 (Id);\n-   end Original_Access_Type;\n-\n    function Original_Array_Type (Id : E) return E is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_Modular_Integer_Type (Id));\n@@ -2282,6 +2295,12 @@ package body Einfo is\n       return Node15 (Id);\n    end Related_Instance;\n \n+   function Related_Interface (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Component);\n+      return Node26 (Id);\n+   end Related_Interface;\n+\n    function Renamed_Entity (Id : E) return N is\n    begin\n       return Node18 (Id);\n@@ -2404,6 +2423,19 @@ package body Einfo is\n       return Node15 (Implementation_Base_Type (Id));\n    end Storage_Size_Variable;\n \n+   function Static_Elaboration_Desired (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Package);\n+      return Flag77 (Id);\n+   end Static_Elaboration_Desired;\n+\n+   function Static_Initialization (Id : E) return N is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Procedure and then not Is_Dispatching_Operation (Id));\n+      return Node26 (Id);\n+   end Static_Initialization;\n+\n    function Stored_Constraint (Id : E) return L is\n    begin\n       pragma Assert\n@@ -2441,6 +2473,11 @@ package body Einfo is\n       return Flag165 (Id);\n    end Suppress_Style_Checks;\n \n+   function Suppress_Value_Tracking_On_Call (Id : E) return B is\n+   begin\n+      return Flag217 (Id);\n+   end Suppress_Value_Tracking_On_Call;\n+\n    function Task_Body_Procedure (Id : E) return N is\n    begin\n       pragma Assert (Ekind (Id) in Task_Kind);\n@@ -2458,6 +2495,12 @@ package body Einfo is\n       return Node19 (Id);\n    end Underlying_Full_View;\n \n+   function Universal_Aliasing (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag216 (Base_Type (Id));\n+   end Universal_Aliasing;\n+\n    function Unset_Reference (Id : E) return N is\n    begin\n       return Node16 (Id);\n@@ -3445,6 +3488,15 @@ package body Einfo is\n       Set_Flag101 (Id, V);\n    end Set_Has_Nested_Block_With_Handler;\n \n+   procedure Set_Has_Up_Level_Access (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Variable\n+          or else Ekind (Id) = E_Constant\n+          or else Ekind (Id) = E_Loop_Parameter);\n+      Set_Flag215 (Id, V);\n+   end Set_Has_Up_Level_Access;\n+\n    procedure Set_Has_Non_Standard_Rep (Id : E; V : B := True) is\n    begin\n       pragma Assert (Base_Type (Id) = Id);\n@@ -3919,7 +3971,8 @@ package body Einfo is\n           or else Ekind (Id) = E_Record_Subtype\n           or else Ekind (Id) = E_Record_Type_With_Private\n           or else Ekind (Id) = E_Record_Subtype_With_Private\n-          or else Ekind (Id) = E_Class_Wide_Type);\n+          or else Ekind (Id) = E_Class_Wide_Type\n+          or else Ekind (Id) = E_Class_Wide_Subtype);\n       Set_Flag186 (Id, V);\n    end Set_Is_Interface;\n \n@@ -4137,11 +4190,6 @@ package body Einfo is\n       Set_Flag55 (Id, V);\n    end Set_Is_Tagged_Type;\n \n-   procedure Set_Is_Thread_Body (Id : E; V : B := True) is\n-   begin\n-      Set_Flag77 (Id, V);\n-   end Set_Is_Thread_Body;\n-\n    procedure Set_Is_Task_Interface (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Interface (Id));\n@@ -4394,14 +4442,6 @@ package body Einfo is\n       Set_Node24 (Id, V);\n    end Set_Obsolescent_Warning;\n \n-   procedure Set_Original_Access_Type (Id : E; V : E) is\n-   begin\n-      pragma Assert\n-        (Ekind (Id) = E_Access_Subprogram_Type\n-           or else Ekind (Id) = E_Access_Protected_Subprogram_Type);\n-      Set_Node21 (Id, V);\n-   end Set_Original_Access_Type;\n-\n    procedure Set_Original_Array_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_Modular_Integer_Type (Id));\n@@ -4532,6 +4572,12 @@ package body Einfo is\n       Set_Node15 (Id, V);\n    end Set_Related_Instance;\n \n+   procedure Set_Related_Interface (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Component);\n+      Set_Node26 (Id, V);\n+   end Set_Related_Interface;\n+\n    procedure Set_Renamed_Entity (Id : E; V : N) is\n    begin\n       Set_Node18 (Id, V);\n@@ -4656,6 +4702,19 @@ package body Einfo is\n       Set_Node15 (Id, V);\n    end Set_Storage_Size_Variable;\n \n+   procedure Set_Static_Elaboration_Desired (Id : E; V : B) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Package);\n+      Set_Flag77 (Id, V);\n+   end Set_Static_Elaboration_Desired;\n+\n+   procedure Set_Static_Initialization (Id : E; V : N) is\n+   begin\n+      pragma Assert\n+        (Ekind (Id) = E_Procedure and then not Is_Dispatching_Operation (Id));\n+      Set_Node26 (Id, V);\n+   end Set_Static_Initialization;\n+\n    procedure Set_Stored_Constraint (Id : E; V : L) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4696,6 +4755,11 @@ package body Einfo is\n       Set_Flag165 (Id, V);\n    end Set_Suppress_Style_Checks;\n \n+   procedure Set_Suppress_Value_Tracking_On_Call (Id : E; V : B := True) is\n+   begin\n+      Set_Flag217 (Id, V);\n+   end Set_Suppress_Value_Tracking_On_Call;\n+\n    procedure Set_Task_Body_Procedure (Id : E; V : N) is\n    begin\n       pragma Assert (Ekind (Id) in Task_Kind);\n@@ -4713,6 +4777,12 @@ package body Einfo is\n       Set_Node19 (Id, V);\n    end Set_Underlying_Full_View;\n \n+   procedure Set_Universal_Aliasing (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id) and then Base_Type (Id) = Id);\n+      Set_Flag216 (Id, V);\n+   end Set_Universal_Aliasing;\n+\n    procedure Set_Unset_Reference (Id : E; V : N) is\n    begin\n       Set_Node16 (Id, V);\n@@ -5082,6 +5152,28 @@ package body Einfo is\n       Set_Last_Entity (V, Id);\n    end Append_Entity;\n \n+   --------------------\n+   -- Available_View --\n+   --------------------\n+\n+   function Available_View (Id : E) return E is\n+   begin\n+      if Is_Incomplete_Type (Id)\n+        and then Present (Non_Limited_View (Id))\n+      then\n+         return Non_Limited_View (Id);\n+\n+      elsif Is_Class_Wide_Type (Id)\n+        and then Is_Incomplete_Type (Etype (Id))\n+        and then Present (Non_Limited_View (Etype (Id)))\n+      then\n+         return Class_Wide_Type (Non_Limited_View (Etype (Id)));\n+\n+      else\n+         return Id;\n+      end if;\n+   end Available_View;\n+\n    ---------------\n    -- Base_Type --\n    ---------------\n@@ -5816,6 +5908,8 @@ package body Einfo is\n    -- Is_By_Reference_Type --\n    --------------------------\n \n+   --  This function knows too much semantics, it should be in sem_util ???\n+\n    function Is_By_Reference_Type (Id : E) return B is\n       Btype : constant Entity_Id := Base_Type (Id);\n \n@@ -5828,7 +5922,6 @@ package body Einfo is\n       elsif Is_Private_Type (Btype) then\n          declare\n             Utyp : constant Entity_Id := Underlying_Type (Btype);\n-\n          begin\n             if No (Utyp) then\n                return False;\n@@ -5837,6 +5930,17 @@ package body Einfo is\n             end if;\n          end;\n \n+      elsif Is_Incomplete_Type (Btype) then\n+         declare\n+            Ftyp : constant Entity_Id := Full_View (Btype);\n+         begin\n+            if No (Ftyp) then\n+               return False;\n+            else\n+               return Is_By_Reference_Type (Ftyp);\n+            end if;\n+         end;\n+\n       elsif Is_Concurrent_Type (Btype) then\n          return True;\n \n@@ -6027,9 +6131,12 @@ package body Einfo is\n \n       elsif Is_Record_Type (Btype) then\n \n+         if Is_Limited_Interface (Id) then\n+            return True;\n+\n          --  AI-419: limitedness is not inherited from a limited interface\n \n-         if Is_Limited_Record (Rtype) then\n+         elsif Is_Limited_Record (Rtype) then\n             return not Is_Interface (Rtype)\n               or else Is_Protected_Interface (Rtype)\n               or else Is_Synchronized_Interface (Rtype)\n@@ -6455,6 +6562,9 @@ package body Einfo is\n       if Ekind (T) = E_Class_Wide_Type then\n          return Etype (T);\n \n+      elsif Ekind (T) = E_Class_Wide_Subtype then\n+         return Etype (Base_Type (T));\n+\n       --  All other cases\n \n       else\n@@ -6933,6 +7043,7 @@ package body Einfo is\n       W (\"Has_Task\",                        Flag30  (Id));\n       W (\"Has_Unchecked_Union\",             Flag123 (Id));\n       W (\"Has_Unknown_Discriminants\",       Flag72  (Id));\n+      W (\"Has_Up_Level_Access\",             Flag215 (Id));\n       W (\"Has_Volatile_Components\",         Flag87  (Id));\n       W (\"Has_Xref_Entry\",                  Flag182 (Id));\n       W (\"In_Package_Body\",                 Flag48  (Id));\n@@ -7019,7 +7130,6 @@ package body Einfo is\n       W (\"Is_Tag\",                          Flag78  (Id));\n       W (\"Is_Tagged_Type\",                  Flag55  (Id));\n       W (\"Is_Task_Interface\",               Flag200 (Id));\n-      W (\"Is_Thread_Body\",                  Flag77  (Id));\n       W (\"Is_True_Constant\",                Flag163 (Id));\n       W (\"Is_Unchecked_Union\",              Flag117 (Id));\n       W (\"Is_Unsigned_Type\",                Flag144 (Id));\n@@ -7056,11 +7166,14 @@ package body Einfo is\n       W (\"Sec_Stack_Needed_For_Return\",     Flag167 (Id));\n       W (\"Size_Depends_On_Discriminant\",    Flag177 (Id));\n       W (\"Size_Known_At_Compile_Time\",      Flag92  (Id));\n+      W (\"Static_Elaboration_Desired\",      Flag77  (Id));\n       W (\"Strict_Alignment\",                Flag145 (Id));\n       W (\"Suppress_Elaboration_Warnings\",   Flag148 (Id));\n       W (\"Suppress_Init_Proc\",              Flag105 (Id));\n       W (\"Suppress_Style_Checks\",           Flag165 (Id));\n+      W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n       W (\"Treat_As_Volatile\",               Flag41  (Id));\n+      W (\"Universal_Aliasing\",              Flag216 (Id));\n       W (\"Uses_Sec_Stack\",                  Flag95  (Id));\n       W (\"Vax_Float\",                       Flag151 (Id));\n       W (\"Warnings_Off\",                    Flag96  (Id));\n@@ -7360,6 +7473,7 @@ package body Einfo is\n               E_Component                                  |\n               E_Constant                                   |\n               E_Discriminant                               |\n+              E_Exception                                  |\n               E_In_Parameter                               |\n               E_In_Out_Parameter                           |\n               E_Out_Parameter                              |\n@@ -7434,6 +7548,7 @@ package body Einfo is\n          when Type_Kind                                    |\n               Formal_Kind                                  |\n               E_Constant                                   |\n+              E_Exception                                  |\n               E_Variable                                   |\n               E_Loop_Parameter                             =>\n             Write_Str (\"Alignment\");\n@@ -7822,10 +7937,6 @@ package body Einfo is\n               Modular_Integer_Kind                         =>\n             Write_Str (\"Original_Array_Type\");\n \n-         when E_Access_Subprogram_Type                     |\n-              E_Access_Protected_Subprogram_Type           =>\n-            Write_Str (\"Original_Access_Type\");\n-\n          when others                                       =>\n             Write_Str (\"Field21??\");\n       end case;\n@@ -8003,13 +8114,21 @@ package body Einfo is\n    procedure Write_Field26_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Component                                  =>\n+            Write_Str (\"Related_Interface\");\n+\n          when E_Generic_Package                            |\n               E_Package                                    =>\n             Write_Str (\"Package_Instantiation\");\n \n          when E_Procedure                                  |\n               E_Function                                   =>\n-            Write_Str (\"Overridden_Operation\");\n+\n+            if Is_Dispatching_Operation (Id) then\n+               Write_Str (\"Overridden_Operation\");\n+            else\n+               Write_Str (\"Static_Initialization\");\n+            end if;\n \n          when others                                       =>\n             Write_Str (\"Field26??\");"}, {"sha": "9d4c2e0a877d296778f65f92f8ed547c63ca6770", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 135, "deletions": 58, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Namet;  use Namet;\n with Snames; use Snames;\n with Types;  use Types;\n with Uintp;  use Uintp;\n@@ -329,8 +330,10 @@ package Einfo is\n \n --    Access_Disp_Table (Elist16) [implementation base type only]\n --       Present in record type entities. For a tagged type, points to the\n---       dispatch tables associated with the tagged type. For a non-tagged\n---       record, contains Empty.\n+--       dispatch tables associated with the tagged type; the last entity of\n+--       this list is an access type declaration used to expand dispatching\n+--       calls through the primary dispatch table. For a non-tagged record,\n+--       contains Empty.\n \n --    Address_Clause (synthesized)\n --       Applies to entries, objects and subprograms. Set if an address clause\n@@ -357,15 +360,16 @@ package Einfo is\n --       subprogram. Always empty for entries.\n \n --    Alignment (Uint14)\n---       Present in entities for types and also in constants, variables,\n---       loop parameters, and formal parameters. This indicates the desired\n---       alignment for a type, or the actual alignment for an object. A value\n---       of zero (Uint_0) indicates that the alignment has not been set yet.\n---       The alignment can be set by an explicit alignment clause, or set by\n---       the front-end in package Layout, or set by the back-end as part of\n---       the back end back-annotation process. The alignment field is also\n---       present in E_Exception entities, but there it is used only by the\n---       back-end for back annotation.\n+--       Present in entities for types and also in constants, variables\n+--       (including exceptions where it refers to the static data allocated for\n+--       an exception), loop parameters, and formal parameters. This indicates\n+--       the desired alignment for a type, or the actual alignment for an\n+--       object. A value of zero (Uint_0) indicates that the alignment has not\n+--       been set yet. The alignment can be set by an explicit alignment\n+--       clause, or set by the front-end in package Layout, or set by the\n+--       back-end as part of the back end back-annotation process. The\n+--       alignment field is also present in E_Exception entities, but there it\n+--       is used only by the back-end for back annotation.\n \n --    Alignment_Clause (synthesized)\n --       Applies to all entities for types and objects. If an alignment\n@@ -383,6 +387,13 @@ package Einfo is\n --       subtype then it returns the subtype or type from which the subtype\n --       was obtained, otherwise it returns Empty.\n \n+--    Available_View (synthesized)\n+--       Applies to types that have the With_Type flag set. Returns the\n+--       non-limited view of the type, if available, otherwise the type\n+--       itself. For class-wide types, there is no direct link in the tree,\n+--       so we have to retrieve the class-wide type of the non-limited view\n+--       of the Etype.\n+\n --    Associated_Formal_Package (Node12)\n --       Present in packages that are the actuals of formal_packages. Points\n --       to the entity in the declaration for the formal package.\n@@ -458,11 +469,19 @@ package Einfo is\n --       Export pragma).\n \n --    Can_Never_Be_Null (Flag38)\n---       This flag is present in all entities, but can only be set in an\n---       object which can never have a null value. This is used to avoid\n---       unncessary resetting of the Is_Known_Non_Null flag for such\n---       entities. The cases where this is set True are constant access\n---       values initialized to a non-null value, and access parameters.\n+--       This flag is present in all entities, but can only be set in an object\n+--       which can never have a null value. This is set True for constant\n+--       access values initialized to a non-null value. This is also True for\n+--       all access parameters in Ada 83 and Ada 95 modes, and for access\n+--       parameters that explicily exlude null in Ada 2005.\n+--\n+--       This is used to avoid unnecessary resetting of the Is_Known_Non_Null\n+--       flag for such entities. In Ada 2005 mode, this is also used when\n+--       determining subtype conformance of subprogram profiles to ensure\n+--       that two formals have the same null-exclusion status.\n+--\n+--       ??? This is also set on some access types, eg the Etype of the\n+--       anonymous access type of a controlling formal.\n \n --    Chars (Name1)\n --       Present in all entities. This field contains an entry into the names\n@@ -969,8 +988,9 @@ package Einfo is\n \n --    Esize (Uint12)\n --       Present in all types and subtypes, and also for components, constants,\n---       and variables. Contains the Object_Size of the type or of the object.\n---       A value of zero indicates that the value is not yet known.\n+--       and variables, including exceptions where it refers to the static data\n+--       allocated for an exception. Contains the Object_Size of the type or of\n+--       the object. A value of zero indicates that the value is not yet known.\n --\n --       For the case of components where a component clause is present, the\n --       value is the value from the component clause, which must be non-\n@@ -1342,8 +1362,8 @@ package Einfo is\n --       clause whose entries are successive integers.\n \n --    Has_Controlling_Result (Flag98)\n---       Present in E_Function entities. True if The function is a primitive\n---       function of a tagged type which can dispatch on result\n+--       Present in E_Function entities. True if the function is a primitive\n+--       function of a tagged type which can dispatch on result.\n \n --    Has_Controlled_Component (Flag43) [base type only]\n --       Present in all entities. Set only for composite type entities which\n@@ -1448,6 +1468,11 @@ package Einfo is\n --       control wrapping of the body in Exp_Ch6 to ensure that the program\n --       error exeption is correctly raised in this case at runtime.\n \n+--    Has_Up_Level_Access (Flag215)\n+--      Present in E_Variable and E_Constant entities. Set if the entity is\n+--      declared in a local procedure p and is accessed in a procedure nested\n+--      inside p. Only set when VM_Target /= No_VM currently.\n+\n --    Has_Nested_Block_With_Handler (Flag101)\n --       Present in scope entities. Set if there is a nested block within the\n --       scope that has an exception handler and the two scopes are in the\n@@ -1543,7 +1568,7 @@ package Einfo is\n --    Known_To_Have_Preelab_Init (Flag207)\n --       Present in all type and subtype entities. If set, then the type is\n --       known to have preelaborable initialization. In the case of a partial\n---       view of a private type, it is only possible for this tobe set if a\n+--       view of a private type, it is only possible for this to be set if a\n --       pragma Preelaborable_Initialization is given for the type. For other\n --       types, it is never set if the type does not have preelaborable\n --       initialization, it may or may not be set if the type does have\n@@ -1640,8 +1665,10 @@ package Einfo is\n --       storage size clause cannot be given to a derived type.\n \n --    Has_Stream_Size_Clause (Flag184)\n---       This flag is set on types which have a Stream_Size clause attribute.\n---       Used to prevent multiple Stream_Size clauses for a given entity.\n+--       This flag is present in all entities. It is set for types which have a\n+--       Stream_Size clause attribute. Used to prevent multiple Stream_Size\n+--       clauses for a given entity, and also whether it is necessary to check\n+--       for a stream size clause.\n \n --    Has_Subprogram_Descriptor (Flag93)\n --       This flag is set on entities for which zero-cost exception subprogram\n@@ -2219,8 +2246,9 @@ package Einfo is\n --       type itself (RM 7.3.1 (5)).\n \n --    Is_Limited_Interface (Flag197)\n---       Present in types that are interfaces. True if interface is declared\n---       limited, or is derived from limited interfaces.\n+--       Present in record types and subtypes. True for interface types, if\n+--       interface is declared limited, task, protected, or synchronized, or\n+--       is derived from a limited interface.\n \n --    Is_Limited_Record (Flag25)\n --       Present in all entities. Set to true for record (sub)types if the\n@@ -2229,8 +2257,9 @@ package Einfo is\n \n --    Is_Limited_Type (synthesized)\n --       Applies to all entities. True if entity is a limited type (limited\n---       private type, task type, protected type, composite containing a\n---       limited component, or a subtype of any of these types).\n+--       private type, limited interface type, task type, protected type,\n+--       composite containing a limited component, or a subtype of any of\n+--       these types).\n \n --    Is_Machine_Code_Subprogram (Flag137)\n --       Present in subprogram entities. Set to indicate that the subprogram\n@@ -2488,8 +2517,9 @@ package Einfo is\n --       component type that is a character type.\n \n --    Is_Synchronized_Interface (Flag199)\n---       Present_types that are interfaces. True is interface is declared\n---       synchronized, or is derived from synchronized interfaces.\n+--       Present in types that are interfaces. True if interface is declared\n+--       synchronized, task, or protected, or is derived from a synchronized\n+--       interface.\n \n --    Is_Tag (Flag78)\n --       Present in E_Component. For regular tagged type this flag is set on\n@@ -2511,10 +2541,6 @@ package Einfo is\n --    Is_Task_Type (synthesized)\n --       Applies to all entities, true for task types and subtypes\n \n---    Is_Thread_Body (Flag77)\n---       Applies to subprogram entities. Set if a valid Thread_Body pragma\n---       applies to this subprogram, which is thus a thread body.\n-\n --    Is_True_Constant (Flag163)\n --       This flag is set in constants and variables which have an initial\n --       value specified but which are never assigned, partially or in the\n@@ -2921,12 +2947,6 @@ package Einfo is\n --       the contents of the corresponding string literal node. This field is\n --       only accessed if the flag Is_Obsolescent is set.\n \n---    Original_Access_Type (Node21)\n---       Present in access to subprogram types. Anonymous access to protected\n---       subprogram types are replaced by an occurrence of an internal access\n---       to subprogram type. This field links the replacement entity with the\n---       original entity.\n-\n --    Original_Array_Type (Node21)\n --       Present in modular types and array types and subtypes. Set only\n --       if the Is_Packed_Array_Type flag is set, indicating that the type\n@@ -3111,11 +3131,16 @@ package Einfo is\n --       wrapper package, but for debugging purposes its external symbol\n --       must correspond to the name and scope of the related instance.\n \n+--    Related_Interface (Node26)\n+--       Present in components associated with secondary dispatch tables\n+--       (dispatch table pointers and offset components). Set to point to the\n+--       entity of the corresponding interface type.\n+\n --    Renamed_Entity (Node18)\n---       Present in exceptions, packages and generic units that are defined\n---       by a renaming declaration. Denotes the renamed entity, or transit-\n---       itively the ultimate renamed entity if there is a chain of renaming\n---       declarations.\n+--       Present in exceptions, packages, subprograms and generic units. Set\n+--       for entities that are defined by a renaming declaration. Denotes the\n+--       renamed entity, or transititively the ultimate renamed entity if\n+--       there is a chain of renaming declarations. Empty if no renaming.\n \n --    Renamed_Object (Node18)\n --       Present in all objects (constants, variables, components, formal\n@@ -3310,6 +3335,19 @@ package Einfo is\n --       this field is present only in the root type (since derived types\n --       share the same storage pool).\n \n+--    Static_Elaboration_Desired (Flag77)\n+--       Present in library-level packages. Set by the pragma of the same\n+--       name, to indicate that static initialization must be attempted for\n+--       all types declared in the package, and that a warning must be emitted\n+--       for those types to which static initialization is not available.\n+\n+--    Static_Initialization (Node26)\n+--       Present in initialization procedures for types whose objects can be\n+--       initialized statically. The value of this attribute is a positional\n+--       aggregate whose components are compile-time static values. Used\n+--       when available in object declarations to eliminate the call to the\n+--       initialization procedure, and to minimize elaboration code.\n+\n --    Stored_Constraint (Elist23)\n --       Present in entities that can have discriminants (concurrent types\n --       subtypes, record types and subtypes, private types and subtypes,\n@@ -3354,6 +3392,12 @@ package Einfo is\n --       Present in all entities. Suppresses any style checks specifically\n --       associated with the given entity if set.\n \n+--    Suppress_Value_Tracking_On_Call (Flag217)\n+--       Present in all entities. Set in a scope entity if value tracking is to\n+--       be suppressed on any call within the scope. Used when an access to a\n+--       local subprogram is computed, to deal with the possibility that this\n+--       value may be passed around, and if used, may clobber a local variable.\n+\n --    Task_Body_Procedure (Node25)\n --       Present in task types and subtypes. Points to the entity for\n --       the task body procedure (as further described in Exp_Ch9, task\n@@ -3414,6 +3458,15 @@ package Einfo is\n --       entity which may or may not be a type, with the intent that if it is a\n --       type, its underlying type is taken.\n \n+--    Universal_Aliasing (Flag216) [base type only]\n+--       Present in all type entities. Set to direct the back-end to avoid\n+--       any optimizations based on type-based alias analysis for this type.\n+--       Indicates that objects of this type can alias objects of any other\n+--       types, which guarantees that any objects can be referenced through\n+--       access types designating this type safely, whatever the actual type\n+--       of these objects. In other words, the effect is as though access\n+--       types designating this type were subject to No_Strict_Aliasing.\n+\n --    Unset_Reference (Node16)\n --       Present in variables and out parameters. This is normally Empty. It\n --       is set to point to an identifier that represents a reference to the\n@@ -4310,6 +4363,7 @@ package Einfo is\n    --    Referenced_As_LHS                   (Flag36)\n    --    Suppress_Elaboration_Warnings       (Flag148)\n    --    Suppress_Style_Checks               (Flag165)\n+   --    Suppress_Value_Tracking_On_Call     (Flag217)\n    --    Was_Hidden                          (Flag196)\n \n    --    Declaration_Node                    (synth)\n@@ -4354,6 +4408,7 @@ package Einfo is\n    --    Has_Specified_Stream_Output         (Flag191)\n    --    Has_Specified_Stream_Read           (Flag192)\n    --    Has_Specified_Stream_Write          (Flag193)\n+   --    Has_Stream_Size_Clause              (Flag184)\n    --    Has_Task                            (Flag30)   (base type only)\n    --    Has_Unchecked_Union                 (Flag123)  (base type only)\n    --    Has_Volatile_Components             (Flag87)   (base type only)\n@@ -4368,7 +4423,6 @@ package Einfo is\n    --    Is_Frozen                           (Flag4)\n    --    Is_Generic_Actual_Type              (Flag94)\n    --    Is_Generic_Type                     (Flag13)\n-   --    Is_Limited_Interface                (Flag197)\n    --    Is_Protected_Interface              (Flag198)\n    --    Is_Synchronized_Interface           (Flag199)\n    --    Is_Task_Interface                   (Flag200)\n@@ -4388,6 +4442,7 @@ package Einfo is\n    --    Strict_Alignment                    (Flag145)  (base type only)\n    --    Suppress_Init_Proc                  (Flag105)  (base type only)\n    --    Treat_As_Volatile                   (Flag41)\n+   --    Universal_Aliasing                  (Flag216)  (base type only)\n \n    --    Alignment_Clause                    (synth)\n    --    Ancestor_Subtype                    (synth)\n@@ -4409,14 +4464,12 @@ package Einfo is\n    --  E_Access_Protected_Subprogram_Type\n    --    Equivalent_Type                     (Node18)\n    --    Directly_Designated_Type            (Node20)\n-   --    Original_Access_Type                (Node21)\n    --    Needs_No_Actuals                    (Flag22)\n    --        (plus type attributes)\n \n    --  E_Access_Subprogram_Type\n    --    Equivalent_Type                     (Node18)   (remote types only)\n    --    Directly_Designated_Type            (Node20)\n-   --    Original_Access_Type                (Node21)\n    --    Needs_No_Actuals                    (Flag22)\n    --        (plus type attributes)\n \n@@ -4511,6 +4564,7 @@ package Einfo is\n    --    Original_Record_Component           (Node22)\n    --    Protected_Operation                 (Node23)\n    --    DT_Offset_To_Top_Func               (Node25)\n+   --    Related_Interface                   (Node26)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Per_Object_Constraint           (Flag154)\n    --    Is_Atomic                           (Flag85)\n@@ -4540,6 +4594,7 @@ package Einfo is\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Completion                      (Flag26)   (constants only)\n    --    Has_Size_Clause                     (Flag29)\n+   --    Has_Up_Level_Access                 (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n@@ -4639,6 +4694,7 @@ package Einfo is\n    --        (plus type attributes)\n \n    --  E_Exception\n+   --    Esize                               (Uint12)\n    --    Alignment                           (Uint14)\n    --    Renamed_Entity                      (Node18)\n    --    Register_Exception_Call             (Node20)\n@@ -4709,7 +4765,6 @@ package Einfo is\n    --    Is_Overriding_Operation             (Flag39)   (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Pure                             (Flag44)\n-   --    Is_Thread_Body                      (Flag77)   (non-generic case only)\n    --    Is_Visible_Child_Unit               (Flag116)\n    --    Needs_No_Actuals                    (Flag22)\n    --    Requires_Overriding                 (Flag213)  (non-generic case only)\n@@ -4883,6 +4938,7 @@ package Einfo is\n    --    Is_Visible_Child_Unit               (Flag116)\n    --    Is_Wrapper_Package                  (synth)    (non-generic case only)\n    --    Scope_Depth                         (synth)\n+   --    Static_Elaboration_Desired          (Flag77)   (non-generic case only)\n \n    --  E_Package_Body\n    --    Handler_Records                     (List10)   (non-generic case only)\n@@ -4933,6 +4989,7 @@ package Einfo is\n    --    Inner_Instances                     (Elist23)  (for generic proc)\n    --    Privals_Chain                       (Elist23)  (for protected proc)\n    --    Abstract_Interface_Alias            (Node25)\n+   --    Static_Initialization               (Node26)   (init_proc only)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n    --    Extra_Formals                       (Node28)\n@@ -4964,7 +5021,6 @@ package Einfo is\n    --    Is_Primitive_Wrapper                (Flag195)  (non-generic case only)\n    --    Is_Private_Descendant               (Flag53)\n    --    Is_Pure                             (Flag44)\n-   --    Is_Thread_Body                      (Flag77)   (non-generic case only)\n    --    Is_Valued_Procedure                 (Flag127)\n    --    Is_Visible_Child_Unit               (Flag116)\n    --    Needs_No_Actuals                    (Flag22)\n@@ -5025,6 +5081,7 @@ package Einfo is\n    --    Is_Constrained                      (Flag12)\n    --    Is_Controlled                       (Flag42)   (base type only)\n    --    Is_Interface                        (Flag186)\n+   --    Is_Limited_Interface                (Flag197)\n    --    Reverse_Bit_Order                   (Flag164)  (base type only)\n    --    First_Component                     (synth)\n    --    First_Component_Or_Discriminant     (synth)\n@@ -5052,6 +5109,7 @@ package Einfo is\n    --    Is_Constrained                      (Flag12)\n    --    Is_Controlled                       (Flag42)   (base type only)\n    --    Is_Interface                        (Flag186)\n+   --    Is_Limited_Interface                (Flag197)\n    --    Reverse_Bit_Order                   (Flag164)  (base type only)\n    --    First_Component                     (synth)\n    --    First_Component_Or_Discriminant     (synth)\n@@ -5157,6 +5215,7 @@ package Einfo is\n    --    Never_Set_In_Source                 (Flag115)\n    --    Treat_As_Volatile                   (Flag41)\n    --    Is_Return_Object                    (Flag209)\n+   --    Has_Up_Level_Access                 (Flag215)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n    --    Constant_Value                      (synth)\n@@ -5515,6 +5574,7 @@ package Einfo is\n    function Has_Missing_Return                  (Id : E) return B;\n    function Has_Nested_Block_With_Handler       (Id : E) return B;\n    function Has_Forward_Instantiation           (Id : E) return B;\n+   function Has_Up_Level_Access                 (Id : E) return B;\n    function Has_Non_Standard_Rep                (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n@@ -5630,7 +5690,6 @@ package Einfo is\n    function Is_Tag                              (Id : E) return B;\n    function Is_Tagged_Type                      (Id : E) return B;\n    function Is_Task_Interface                   (Id : E) return B;\n-   function Is_Thread_Body                      (Id : E) return B;\n    function Is_True_Constant                    (Id : E) return B;\n    function Is_Unchecked_Union                  (Id : E) return B;\n    function Is_Unsigned_Type                    (Id : E) return B;\n@@ -5672,7 +5731,6 @@ package Einfo is\n    function Normalized_Position_Max             (Id : E) return U;\n    function Object_Ref                          (Id : E) return E;\n    function Obsolescent_Warning                 (Id : E) return N;\n-   function Original_Access_Type                (Id : E) return E;\n    function Original_Array_Type                 (Id : E) return E;\n    function Original_Record_Component           (Id : E) return E;\n    function Overridden_Operation                (Id : E) return E;\n@@ -5695,6 +5753,7 @@ package Einfo is\n    function Register_Exception_Call             (Id : E) return N;\n    function Related_Array_Object                (Id : E) return E;\n    function Related_Instance                    (Id : E) return E;\n+   function Related_Interface                   (Id : E) return E;\n    function Renamed_Entity                      (Id : E) return N;\n    function Renamed_Object                      (Id : E) return N;\n    function Renaming_Map                        (Id : E) return U;\n@@ -5716,16 +5775,20 @@ package Einfo is\n    function Small_Value                         (Id : E) return R;\n    function Spec_Entity                         (Id : E) return E;\n    function Storage_Size_Variable               (Id : E) return E;\n+   function Static_Elaboration_Desired          (Id : E) return B;\n+   function Static_Initialization               (Id : E) return N;\n    function Stored_Constraint                   (Id : E) return L;\n    function Strict_Alignment                    (Id : E) return B;\n    function String_Literal_Length               (Id : E) return U;\n    function String_Literal_Low_Bound            (Id : E) return N;\n    function Suppress_Elaboration_Warnings       (Id : E) return B;\n    function Suppress_Init_Proc                  (Id : E) return B;\n    function Suppress_Style_Checks               (Id : E) return B;\n+   function Suppress_Value_Tracking_On_Call     (Id : E) return B;\n    function Task_Body_Procedure                 (Id : E) return N;\n    function Treat_As_Volatile                   (Id : E) return B;\n    function Underlying_Full_View                (Id : E) return E;\n+   function Universal_Aliasing                  (Id : E) return B;\n    function Unset_Reference                     (Id : E) return N;\n    function Uses_Sec_Stack                      (Id : E) return B;\n    function Vax_Float                           (Id : E) return B;\n@@ -5798,6 +5861,7 @@ package Einfo is\n    function Address_Clause                      (Id : E) return N;\n    function Alignment_Clause                    (Id : E) return N;\n    function Ancestor_Subtype                    (Id : E) return E;\n+   function Available_View                      (Id : E) return E;\n    function Base_Type                           (Id : E) return E;\n    function Constant_Value                      (Id : E) return N;\n    function Declaration_Node                    (Id : E) return N;\n@@ -6035,6 +6099,7 @@ package Einfo is\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n    procedure Set_Has_Nested_Block_With_Handler   (Id : E; V : B := True);\n    procedure Set_Has_Forward_Instantiation       (Id : E; V : B := True);\n+   procedure Set_Has_Up_Level_Access             (Id : E; V : B := True);\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n@@ -6157,7 +6222,6 @@ package Einfo is\n    procedure Set_Is_Tag                          (Id : E; V : B := True);\n    procedure Set_Is_Tagged_Type                  (Id : E; V : B := True);\n    procedure Set_Is_Task_Interface               (Id : E; V : B := True);\n-   procedure Set_Is_Thread_Body                  (Id : E; V : B := True);\n    procedure Set_Is_True_Constant                (Id : E; V : B := True);\n    procedure Set_Is_Unchecked_Union              (Id : E; V : B := True);\n    procedure Set_Is_Unsigned_Type                (Id : E; V : B := True);\n@@ -6199,7 +6263,6 @@ package Einfo is\n    procedure Set_Normalized_Position_Max         (Id : E; V : U);\n    procedure Set_Object_Ref                      (Id : E; V : E);\n    procedure Set_Obsolescent_Warning             (Id : E; V : N);\n-   procedure Set_Original_Access_Type            (Id : E; V : E);\n    procedure Set_Original_Array_Type             (Id : E; V : E);\n    procedure Set_Original_Record_Component       (Id : E; V : E);\n    procedure Set_Overridden_Operation            (Id : E; V : E);\n@@ -6222,6 +6285,7 @@ package Einfo is\n    procedure Set_Register_Exception_Call         (Id : E; V : N);\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n    procedure Set_Related_Instance                (Id : E; V : E);\n+   procedure Set_Related_Interface               (Id : E; V : E);\n    procedure Set_Renamed_Entity                  (Id : E; V : N);\n    procedure Set_Renamed_Object                  (Id : E; V : N);\n    procedure Set_Renaming_Map                    (Id : E; V : U);\n@@ -6243,16 +6307,20 @@ package Einfo is\n    procedure Set_Small_Value                     (Id : E; V : R);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n    procedure Set_Storage_Size_Variable           (Id : E; V : E);\n+   procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n+   procedure Set_Static_Initialization           (Id : E; V : N);\n    procedure Set_Stored_Constraint               (Id : E; V : L);\n    procedure Set_Strict_Alignment                (Id : E; V : B := True);\n    procedure Set_String_Literal_Length           (Id : E; V : U);\n    procedure Set_String_Literal_Low_Bound        (Id : E; V : N);\n    procedure Set_Suppress_Elaboration_Warnings   (Id : E; V : B := True);\n    procedure Set_Suppress_Init_Proc              (Id : E; V : B := True);\n    procedure Set_Suppress_Style_Checks           (Id : E; V : B := True);\n+   procedure Set_Suppress_Value_Tracking_On_Call (Id : E; V : B := True);\n    procedure Set_Task_Body_Procedure             (Id : E; V : N);\n    procedure Set_Treat_As_Volatile               (Id : E; V : B := True);\n    procedure Set_Underlying_Full_View            (Id : E; V : E);\n+   procedure Set_Universal_Aliasing              (Id : E; V : B := True);\n    procedure Set_Unset_Reference                 (Id : E; V : N);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n    procedure Set_Vax_Float                       (Id : E; V : B := True);\n@@ -6641,6 +6709,7 @@ package Einfo is\n    pragma Inline (Has_Task);\n    pragma Inline (Has_Unchecked_Union);\n    pragma Inline (Has_Unknown_Discriminants);\n+   pragma Inline (Has_Up_Level_Access);\n    pragma Inline (Has_Volatile_Components);\n    pragma Inline (Has_Xref_Entry);\n    pragma Inline (Hiding_Loop_Variable);\n@@ -6767,7 +6836,6 @@ package Einfo is\n    pragma Inline (Is_Tag);\n    pragma Inline (Is_Tagged_Type);\n    pragma Inline (Is_Task_Interface);\n-   pragma Inline (Is_Thread_Body);\n    pragma Inline (Is_True_Constant);\n    pragma Inline (Is_Task_Type);\n    pragma Inline (Is_Type);\n@@ -6812,7 +6880,6 @@ package Einfo is\n    pragma Inline (Normalized_Position_Max);\n    pragma Inline (Object_Ref);\n    pragma Inline (Obsolescent_Warning);\n-   pragma Inline (Original_Access_Type);\n    pragma Inline (Original_Array_Type);\n    pragma Inline (Original_Record_Component);\n    pragma Inline (Overridden_Operation);\n@@ -6836,6 +6903,7 @@ package Einfo is\n    pragma Inline (Register_Exception_Call);\n    pragma Inline (Related_Array_Object);\n    pragma Inline (Related_Instance);\n+   pragma Inline (Related_Interface);\n    pragma Inline (Renamed_Entity);\n    pragma Inline (Renamed_Object);\n    pragma Inline (Renaming_Map);\n@@ -6857,16 +6925,20 @@ package Einfo is\n    pragma Inline (Small_Value);\n    pragma Inline (Spec_Entity);\n    pragma Inline (Storage_Size_Variable);\n+   pragma Inline (Static_Elaboration_Desired);\n+   pragma Inline (Static_Initialization);\n    pragma Inline (Stored_Constraint);\n    pragma Inline (Strict_Alignment);\n    pragma Inline (String_Literal_Length);\n    pragma Inline (String_Literal_Low_Bound);\n    pragma Inline (Suppress_Elaboration_Warnings);\n    pragma Inline (Suppress_Init_Proc);\n    pragma Inline (Suppress_Style_Checks);\n+   pragma Inline (Suppress_Value_Tracking_On_Call);\n    pragma Inline (Task_Body_Procedure);\n    pragma Inline (Treat_As_Volatile);\n    pragma Inline (Underlying_Full_View);\n+   pragma Inline (Universal_Aliasing);\n    pragma Inline (Unset_Reference);\n    pragma Inline (Uses_Sec_Stack);\n    pragma Inline (Vax_Float);\n@@ -7012,7 +7084,6 @@ package Einfo is\n    pragma Inline (Set_Has_Pragma_Pure_Function);\n    pragma Inline (Set_Has_Pragma_Unreferenced);\n    pragma Inline (Set_Has_Pragma_Unreferenced_Objects);\n-   pragma Inline (Set_Known_To_Have_Preelab_Init);\n    pragma Inline (Set_Has_Primitive_Operations);\n    pragma Inline (Set_Has_Private_Declaration);\n    pragma Inline (Set_Has_Qualified_Name);\n@@ -7028,10 +7099,12 @@ package Einfo is\n    pragma Inline (Set_Has_Specified_Stream_Write);\n    pragma Inline (Set_Has_Static_Discriminants);\n    pragma Inline (Set_Has_Storage_Size_Clause);\n+   pragma Inline (Set_Has_Stream_Size_Clause);\n    pragma Inline (Set_Has_Subprogram_Descriptor);\n    pragma Inline (Set_Has_Task);\n    pragma Inline (Set_Has_Unchecked_Union);\n    pragma Inline (Set_Has_Unknown_Discriminants);\n+   pragma Inline (Set_Has_Up_Level_Access);\n    pragma Inline (Set_Has_Volatile_Components);\n    pragma Inline (Set_Has_Xref_Entry);\n    pragma Inline (Set_Hiding_Loop_Variable);\n@@ -7122,7 +7195,6 @@ package Einfo is\n    pragma Inline (Set_Is_Tag);\n    pragma Inline (Set_Is_Tagged_Type);\n    pragma Inline (Set_Is_Task_Interface);\n-   pragma Inline (Set_Is_Thread_Body);\n    pragma Inline (Set_Is_True_Constant);\n    pragma Inline (Set_Is_Unchecked_Union);\n    pragma Inline (Set_Is_Unsigned_Type);\n@@ -7135,6 +7207,7 @@ package Einfo is\n    pragma Inline (Set_Kill_Elaboration_Checks);\n    pragma Inline (Set_Kill_Range_Checks);\n    pragma Inline (Set_Kill_Tag_Checks);\n+   pragma Inline (Set_Known_To_Have_Preelab_Init);\n    pragma Inline (Set_Last_Assignment);\n    pragma Inline (Set_Last_Entity);\n    pragma Inline (Set_Limited_View);\n@@ -7163,7 +7236,6 @@ package Einfo is\n    pragma Inline (Set_Normalized_Position_Max);\n    pragma Inline (Set_Object_Ref);\n    pragma Inline (Set_Obsolescent_Warning);\n-   pragma Inline (Set_Original_Access_Type);\n    pragma Inline (Set_Original_Array_Type);\n    pragma Inline (Set_Original_Record_Component);\n    pragma Inline (Set_Overridden_Operation);\n@@ -7186,6 +7258,7 @@ package Einfo is\n    pragma Inline (Set_Register_Exception_Call);\n    pragma Inline (Set_Related_Array_Object);\n    pragma Inline (Set_Related_Instance);\n+   pragma Inline (Set_Related_Interface);\n    pragma Inline (Set_Renamed_Entity);\n    pragma Inline (Set_Renamed_Object);\n    pragma Inline (Set_Renaming_Map);\n@@ -7207,16 +7280,20 @@ package Einfo is\n    pragma Inline (Set_Small_Value);\n    pragma Inline (Set_Spec_Entity);\n    pragma Inline (Set_Storage_Size_Variable);\n+   pragma Inline (Set_Static_Elaboration_Desired);\n+   pragma Inline (Set_Static_Initialization);\n    pragma Inline (Set_Stored_Constraint);\n    pragma Inline (Set_Strict_Alignment);\n    pragma Inline (Set_String_Literal_Length);\n    pragma Inline (Set_String_Literal_Low_Bound);\n    pragma Inline (Set_Suppress_Elaboration_Warnings);\n    pragma Inline (Set_Suppress_Init_Proc);\n    pragma Inline (Set_Suppress_Style_Checks);\n+   pragma Inline (Set_Suppress_Value_Tracking_On_Call);\n    pragma Inline (Set_Task_Body_Procedure);\n    pragma Inline (Set_Treat_As_Volatile);\n    pragma Inline (Set_Underlying_Full_View);\n+   pragma Inline (Set_Universal_Aliasing);\n    pragma Inline (Set_Unset_Reference);\n    pragma Inline (Set_Uses_Sec_Stack);\n    pragma Inline (Set_Vax_Float);"}, {"sha": "8d3b7fa2d8e7e46bf7472658debfa98c2b7c65cd", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 511, "deletions": 176, "changes": 687, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -346,45 +346,8 @@ package body Sem_Ch4 is\n       Acc_Type : Entity_Id;\n       Type_Id  : Entity_Id;\n \n-      function Mark_Allocator (Nod : Node_Id) return Traverse_Result;\n-      --  Ada 2005 AI-162: Traverse the expression for an allocator, to locate\n-      --  inner allocators that may specify access discriminants. Such access\n-      --  discriminants are coextensions of the enclosing objects. They should\n-      --  be allocated from the same storage pool as the enclosing object, and\n-      --  deallocated at the same time as the enclosing object. They are\n-      --  linked to the enclosing allocator to simplify this sharing.\n-      --  On the other hand, access discriminants for stack-allocated objects\n-      --  are themselves allocated statically, and do not carry the flag.\n-\n-      --------------------\n-      -- Mark_Allocator --\n-      --------------------\n-\n-      function Mark_Allocator (Nod : Node_Id) return Traverse_Result is\n-      begin\n-         if Nkind (Nod) = N_Allocator\n-           and then Nkind (Parent (Nod)) = N_Index_Or_Discriminant_Constraint\n-         then\n-            Set_Is_Coextension (Nod);\n-\n-            if No (Coextensions (N)) then\n-               Set_Coextensions (N, New_Elmt_List);\n-            end if;\n-\n-            Append_Elmt (Nod, Coextensions (N));\n-         end if;\n-\n-         return OK;\n-      end Mark_Allocator;\n-\n-      procedure Mark_Coextensions is new Traverse_Proc (Mark_Allocator);\n-\n-   --  Start of processing for Analyze_Allocator\n-\n    begin\n       Check_Restriction (No_Allocators, N);\n-      Set_Coextensions (N, No_Elist);\n-      Mark_Coextensions (E);\n \n       if Nkind (E) = N_Qualified_Expression then\n \n@@ -1293,10 +1256,10 @@ package body Sem_Ch4 is\n       if not Is_Overloaded (P) then\n          if Is_Access_Type (Etype (P)) then\n \n-            --  Set the Etype. We need to go thru Is_For_Access_Subtypes\n-            --  to avoid other problems caused by the Private_Subtype\n-            --  and it is safe to go to the Base_Type because this is the\n-            --  same as converting the access value to its Base_Type.\n+            --  Set the Etype. We need to go thru Is_For_Access_Subtypes to\n+            --  avoid other problems caused by the Private_Subtype and it is\n+            --  safe to go to the Base_Type because this is the same as\n+            --  converting the access value to its Base_Type.\n \n             declare\n                DT : Entity_Id := Designated_Type (Etype (P));\n@@ -1308,7 +1271,23 @@ package body Sem_Ch4 is\n                   DT := Base_Type (DT);\n                end if;\n \n-               Set_Etype (N, DT);\n+               --  An explicit dereference is a legal occurrence of an\n+               --  incomplete type imported through a limited_with clause,\n+               --  if the full view is visible.\n+\n+               if From_With_Type (DT)\n+                 and then not From_With_Type (Scope (DT))\n+                 and then\n+                   (Is_Immediately_Visible (Scope (DT))\n+                     or else\n+                       (Is_Child_Unit (Scope (DT))\n+                          and then Is_Visible_Child_Unit (Scope (DT))))\n+               then\n+                  Set_Etype (N, Available_View (DT));\n+\n+               else\n+                  Set_Etype (N, DT);\n+               end if;\n             end;\n \n          elsif Etype (P) /= Any_Type then\n@@ -1466,11 +1445,31 @@ package body Sem_Ch4 is\n          Set_Name (N, P);\n          Set_Parameter_Associations (N, Exprs);\n \n+         --  Analyze actuals prior to analyzing the call itself.\n+\n          Actual := First (Parameter_Associations (N));\n          while Present (Actual) loop\n             Analyze (Actual);\n             Check_Parameterless_Call (Actual);\n-            Next_Actual (Actual);\n+\n+            --  Move to next actual. Note that we use Next, not Next_Actual\n+            --  here. The reason for this is a bit subtle. If a function call\n+            --  includes named associations, the parser recognizes the node as\n+            --  a call, and it is analyzed as such. If all associations are\n+            --  positional, the parser builds an indexed_component node, and\n+            --  it is only after analysis of the prefix that the construct\n+            --  is recognized as a call, in which case Process_Function_Call\n+            --  rewrites the node and analyzes the actuals. If the list of\n+            --  actuals is malformed, the parser may leave the node as an\n+            --  indexed component (despite the presence of named associations).\n+            --  The iterator Next_Actual is equivalent to Next if the list is\n+            --  positional, but follows the normalized chain of actuals when\n+            --  named associations are present. In this case normalization has\n+            --  not taken place, and actuals remain unanalyzed, which leads to\n+            --  subsequent crashes or loops if there is an attempt to continue\n+            --  analysis of the program.\n+\n+            Next (Actual);\n          end loop;\n \n          Analyze_Call (N);\n@@ -2448,7 +2447,9 @@ package body Sem_Ch4 is\n          Get_Next_Interp (I, It);\n       end loop;\n \n-      if Etype (N) = Any_Type then\n+      if Etype (N) = Any_Type\n+        and then not Try_Object_Operation (N)\n+      then\n          Error_Msg_NE (\"undefined selector& for overloaded prefix\", N, Sel);\n          Set_Entity (Sel, Any_Id);\n          Set_Etype  (Sel, Any_Type);\n@@ -3008,12 +3009,29 @@ package body Sem_Ch4 is\n          --  implements an interface, check whether there is some other\n          --  primitive operation with that name.\n \n-         if Etype (N) = Any_Type\n-           and then Ada_Version >= Ada_05\n+         if Ada_Version >= Ada_05\n            and then Is_Tagged_Type (Prefix_Type)\n-           and then Try_Object_Operation (N)\n          then\n-            return;\n+            if Etype (N) = Any_Type\n+              and then Try_Object_Operation (N)\n+            then\n+               return;\n+\n+            --  If the context is not syntactically a procedure call, it\n+            --  may be a call to a primitive function declared outside of\n+            --  the synchronized type.\n+\n+            --  If the context is a procedure call, there might still be\n+            --  an overloading between an entry and a primitive procedure\n+            --  declared outside of the synchronized type, called in prefix\n+            --  notation. This is harder to disambiguate because in one case\n+            --  the controlling formal is implicit ???\n+\n+            elsif Nkind (Parent (N)) /= N_Procedure_Call_Statement\n+              and then Try_Object_Operation (N)\n+            then\n+               return;\n+            end if;\n          end if;\n \n          Set_Is_Overloaded (N, Is_Overloaded (Sel));\n@@ -5099,7 +5117,11 @@ package body Sem_Ch4 is\n       Is_Subprg_Call : constant Boolean    := K = N_Procedure_Call_Statement\n                                                or else K = N_Function_Call;\n       Obj            : constant Node_Id    := Prefix (N);\n-      Subprog        : constant Node_Id    := Selector_Name (N);\n+      Subprog        : constant Node_Id    :=\n+                         Make_Identifier (Sloc (Selector_Name (N)),\n+                           Chars => Chars (Selector_Name (N)));\n+      --  Identifier on which possible interpretations will be collected.\n+\n       Success        : Boolean := False;\n \n       Report_Error : Boolean := False;\n@@ -5111,18 +5133,27 @@ package body Sem_Ch4 is\n       Node_To_Replace : Node_Id;\n       Obj_Type        : Entity_Id := Etype (Obj);\n \n+      function Valid_Candidate\n+        (Success : Boolean;\n+         Call    : Node_Id;\n+         Subp    : Entity_Id) return Entity_Id;\n+      --  If the subprogram is a valid interpretation, record it, and add\n+      --  to the list of interpretations of Subprog.\n+\n       procedure Complete_Object_Operation\n         (Call_Node       : Node_Id;\n-         Node_To_Replace : Node_Id;\n-         Subprog         : Node_Id);\n+         Node_To_Replace : Node_Id);\n       --  Make Subprog the name of Call_Node, replace Node_To_Replace with\n       --  Call_Node, insert the object (or its dereference) as the first actual\n       --  in the call, and complete the analysis of the call.\n \n+      procedure Report_Ambiguity (Op : Entity_Id);\n+      --  If a prefixed procedure call is ambiguous, indicate whether the\n+      --  call includes an implicit dereference or an implicit 'Access.\n+\n       procedure Transform_Object_Operation\n         (Call_Node       : out Node_Id;\n-         Node_To_Replace : out Node_Id;\n-         Subprog         : Node_Id);\n+         Node_To_Replace : out Node_Id);\n       --  Transform Obj.Operation (X, Y,,) into Operation (Obj, X, Y ..)\n       --  Call_Node is the resulting subprogram call,\n       --  Node_To_Replace is either N or the parent of N, and Subprog\n@@ -5134,29 +5165,91 @@ package body Sem_Ch4 is\n       --  Traverse all ancestor types looking for a class-wide subprogram\n       --  for which the current operation is a valid non-dispatching call.\n \n+      procedure Try_One_Prefix_Interpretation (T : Entity_Id);\n+      --  If prefix is overloaded, its interpretation may include different\n+      --  tagged types, and we must examine the primitive operations and\n+      --  the class-wide operations of each in order to find candidate\n+      --  interpretations for the call as a whole.\n+\n       function Try_Primitive_Operation\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean;\n       --  Traverse the list of primitive subprograms looking for a dispatching\n       --  operation for which the current node is a valid call .\n \n+      ---------------------\n+      -- Valid_Candidate --\n+      ---------------------\n+\n+      function Valid_Candidate\n+        (Success : Boolean;\n+         Call    : Node_Id;\n+         Subp    : Entity_Id) return Entity_Id\n+      is\n+         Comp_Type : Entity_Id;\n+\n+      begin\n+         --  If the subprogram is a valid interpretation, record it in global\n+         --  variable Subprog, to collect all possible overloadings.\n+\n+         if Success then\n+            if Subp /= Entity (Subprog) then\n+               Add_One_Interp (Subprog, Subp, Etype (Subp));\n+            end if;\n+         end if;\n+\n+         --  If the call may be an indexed call, retrieve component type\n+         --  of resulting expression, and add possible interpretation.\n+\n+         Comp_Type := Empty;\n+\n+         if Nkind (Call) = N_Function_Call\n+             and then Nkind (Parent (N)) = N_Indexed_Component\n+             and then Needs_One_Actual (Subp)\n+         then\n+            if Is_Array_Type (Etype (Subp)) then\n+               Comp_Type := Component_Type (Etype (Subp));\n+\n+            elsif Is_Access_Type (Etype (Subp))\n+              and then Is_Array_Type (Designated_Type (Etype (Subp)))\n+            then\n+               Comp_Type := Component_Type (Designated_Type (Etype (Subp)));\n+            end if;\n+         end if;\n+\n+         if Present (Comp_Type)\n+              and then Etype (Subprog) /= Comp_Type\n+         then\n+            Add_One_Interp (Subprog, Subp, Comp_Type);\n+         end if;\n+\n+         if Etype (Call) /= Any_Type then\n+            return Subp;\n+         else\n+            return Empty;\n+         end if;\n+      end Valid_Candidate;\n+\n       -------------------------------\n       -- Complete_Object_Operation --\n       -------------------------------\n \n       procedure Complete_Object_Operation\n         (Call_Node       : Node_Id;\n-         Node_To_Replace : Node_Id;\n-         Subprog         : Node_Id)\n+         Node_To_Replace : Node_Id)\n       is\n          Formal_Type  : constant Entity_Id :=\n                           Etype (First_Formal (Entity (Subprog)));\n          First_Actual : Node_Id;\n \n       begin\n-         First_Actual := First (Parameter_Associations (Call_Node));\n+         --  Place the name of the operation, with its interpretations,\n+         --  on the rewritten call.\n+\n          Set_Name (Call_Node, Subprog);\n \n+         First_Actual := First (Parameter_Associations (Call_Node));\n+\n          --  For cross-reference purposes, treat the new node as being in\n          --  the source if the original one is.\n \n@@ -5170,8 +5263,21 @@ package body Sem_Ch4 is\n          end if;\n \n          --  If need be, rewrite first actual as an explicit dereference\n+         --  If the call is overloaded, the rewriting can only be done\n+         --  once the primitive operation is identified.\n+\n+         if Is_Overloaded (Subprog) then\n \n-         if not Is_Access_Type (Formal_Type)\n+            --  The prefix itself may be overloaded, and its interpretations\n+            --  must be propagated to the new actual in the call.\n+\n+            if Is_Overloaded (Obj) then\n+               Save_Interps (Obj, First_Actual);\n+            end if;\n+\n+            Rewrite (First_Actual, Obj);\n+\n+         elsif not Is_Access_Type (Formal_Type)\n            and then Is_Access_Type (Etype (Obj))\n          then\n             Rewrite (First_Actual,\n@@ -5189,28 +5295,85 @@ package body Sem_Ch4 is\n               Make_Attribute_Reference (Loc,\n                 Attribute_Name => Name_Access,\n                 Prefix => Relocate_Node (Obj)));\n+\n+            if not Is_Aliased_View (Obj) then\n+               Error_Msg_NE\n+                 (\"object in prefixed call to& must be aliased\"\n+                      & \" ('R'M'-2005 4.3.1 (13))\",\n+                 Prefix (First_Actual), Subprog);\n+            end if;\n+\n             Analyze (First_Actual);\n \n          else\n-            Rewrite (First_Actual, Obj);\n-         end if;\n+            if Is_Overloaded (Obj) then\n+               Save_Interps (Obj, First_Actual);\n+            end if;\n \n-         if Is_Overloaded (Call_Node) then\n-            Save_Interps (Call_Node, Node_To_Replace);\n+            Rewrite (First_Actual, Obj);\n          end if;\n \n          Rewrite (Node_To_Replace, Call_Node);\n-         Analyze (Node_To_Replace);\n+\n+         --  Propagate the interpretations collected in subprog to the new\n+         --  function call node, to be resolved from context.\n+\n+         if Is_Overloaded (Subprog) then\n+            Save_Interps (Subprog, Node_To_Replace);\n+         else\n+            Analyze (Node_To_Replace);\n+         end if;\n       end Complete_Object_Operation;\n \n+      ----------------------\n+      -- Report_Ambiguity --\n+      ----------------------\n+\n+      procedure Report_Ambiguity (Op : Entity_Id) is\n+         Access_Formal : constant Boolean :=\n+                           Is_Access_Type (Etype (First_Formal (Op)));\n+         Access_Actual : constant Boolean :=\n+                           Is_Access_Type (Etype (Prefix (N)));\n+\n+      begin\n+         Error_Msg_Sloc := Sloc (Op);\n+\n+         if Access_Formal and then not Access_Actual then\n+            if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n+               Error_Msg_N\n+                 (\"\\possible interpretation\"\n+                   & \" (inherited, with implicit 'Access) #\", N);\n+            else\n+               Error_Msg_N\n+                 (\"\\possible interpretation (with implicit 'Access) #\", N);\n+            end if;\n+\n+         elsif not Access_Formal and then Access_Actual then\n+            if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n+               Error_Msg_N\n+                 (\"\\possible interpretation\"\n+                   & \" ( inherited, with implicit dereference) #\", N);\n+            else\n+               Error_Msg_N\n+                 (\"\\possible interpretation (with implicit dereference) #\", N);\n+            end if;\n+\n+         else\n+            if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n+               Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+            else\n+               Error_Msg_N (\"\\possible interpretation#\", N);\n+            end if;\n+         end if;\n+      end Report_Ambiguity;\n+\n       --------------------------------\n       -- Transform_Object_Operation --\n       --------------------------------\n \n       procedure Transform_Object_Operation\n         (Call_Node       : out Node_Id;\n-         Node_To_Replace : out Node_Id;\n-         Subprog         : Node_Id)\n+         Node_To_Replace : out Node_Id)\n       is\n          Parent_Node : constant Node_Id := Parent (N);\n \n@@ -5252,13 +5415,13 @@ package body Sem_Ch4 is\n             if Nkind (Parent_Node) = N_Procedure_Call_Statement then\n                Call_Node :=\n                  Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Copy_Tree (Subprog),\n+                   Name => New_Copy (Subprog),\n                    Parameter_Associations => Actuals);\n \n             else\n                Call_Node :=\n                  Make_Function_Call (Loc,\n-                   Name => New_Copy_Tree (Subprog),\n+                   Name => New_Copy (Subprog),\n                    Parameter_Associations => Actuals);\n \n             end if;\n@@ -5283,7 +5446,7 @@ package body Sem_Ch4 is\n \n             Call_Node :=\n                Make_Function_Call (Loc,\n-                 Name => New_Copy_Tree (Subprog),\n+                 Name => New_Copy (Subprog),\n                  Parameter_Associations => Actuals);\n \n          --  Parameterless call:  Obj.F is rewritten as F (Obj)\n@@ -5293,7 +5456,7 @@ package body Sem_Ch4 is\n \n             Call_Node :=\n                Make_Function_Call (Loc,\n-                 Name => New_Copy_Tree (Subprog),\n+                 Name => New_Copy (Subprog),\n                  Parameter_Associations => New_List (Dummy));\n          end if;\n       end Transform_Object_Operation;\n@@ -5306,20 +5469,41 @@ package body Sem_Ch4 is\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id) return Boolean\n       is\n-         Anc_Type : Entity_Id;\n-         Cls_Type : Entity_Id;\n-         Hom      : Entity_Id;\n-         Hom_Ref  : Node_Id;\n-         Success  : Boolean;\n+         Anc_Type    : Entity_Id;\n+         Matching_Op : Entity_Id := Empty;\n+         Error       : Boolean;\n+\n+         procedure Traverse_Homonyms\n+           (Anc_Type : Entity_Id;\n+            Error    : out Boolean);\n+         --  Traverse the homonym chain of the subprogram searching for those\n+         --  homonyms whose first formal has the Anc_Type's class-wide type,\n+         --  or an anonymous access type designating the class-wide type. If an\n+         --  ambiguity is detected, then Error is set to True.\n+\n+         procedure Traverse_Interfaces\n+           (Anc_Type : Entity_Id;\n+            Error    : out Boolean);\n+         --  Traverse the list of interfaces, if any, associated with Anc_Type\n+         --  and search for acceptable class-wide homonyms associated with each\n+         --  interface. If an ambiguity is detected, then Error is set to True.\n+\n+         -----------------------\n+         -- Traverse_Homonyms --\n+         -----------------------\n+\n+         procedure Traverse_Homonyms\n+           (Anc_Type : Entity_Id;\n+            Error    : out Boolean)\n+         is\n+            Cls_Type    : Entity_Id;\n+            Hom         : Entity_Id;\n+            Hom_Ref     : Node_Id;\n+            Success     : Boolean;\n \n-      begin\n-         --  Loop through ancestor types, traverse the homonym chain of the\n-         --  subprogram, and try out those homonyms whose first formal has the\n-         --  class-wide type of the ancestor, or an access type to it.\n-\n-         Anc_Type := Obj_Type;\n+         begin\n+            Error := False;\n \n-         loop\n             Cls_Type := Class_Wide_Type (Anc_Type);\n \n             Hom := Current_Entity (Subprog);\n@@ -5333,50 +5517,189 @@ package body Sem_Ch4 is\n                    (Etype (First_Formal (Hom)) = Cls_Type\n                      or else\n                        (Is_Access_Type (Etype (First_Formal (Hom)))\n+                          and then\n+                            Ekind (Etype (First_Formal (Hom))) =\n+                              E_Anonymous_Access_Type\n                           and then\n                             Designated_Type (Etype (First_Formal (Hom))) =\n-                                                                 Cls_Type))\n+                                                                   Cls_Type))\n                then\n-                  Hom_Ref := New_Reference_To (Hom, Sloc (Subprog));\n                   Set_Etype (Call_Node, Any_Type);\n-                  Set_Parent (Call_Node, Parent (Node_To_Replace));\n+                  Set_Is_Overloaded (Call_Node, False);\n+                  Success := False;\n \n-                  Set_Name (Call_Node, Hom_Ref);\n+                  if No (Matching_Op) then\n+                     Hom_Ref := New_Reference_To (Hom, Sloc (Subprog));\n+                     Set_Etype (Call_Node, Any_Type);\n+                     Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n-                  Analyze_One_Call\n-                    (N          => Call_Node,\n-                     Nam        => Hom,\n-                     Report     => Report_Error,\n-                     Success    => Success,\n-                     Skip_First => True);\n+                     Set_Name (Call_Node, Hom_Ref);\n \n-                  if Success then\n+                     Analyze_One_Call\n+                       (N          => Call_Node,\n+                        Nam        => Hom,\n+                        Report     => Report_Error,\n+                        Success    => Success,\n+                        Skip_First => True);\n \n-                     --  Reformat into the proper call\n+                     Matching_Op :=\n+                       Valid_Candidate (Success, Call_Node, Hom);\n \n-                     Complete_Object_Operation\n-                       (Call_Node       => Call_Node,\n-                        Node_To_Replace => Node_To_Replace,\n-                        Subprog         => Hom_Ref);\n-\n-                     return True;\n+                  else\n+                     Analyze_One_Call\n+                       (N          => Call_Node,\n+                        Nam        => Hom,\n+                        Report     => Report_Error,\n+                        Success    => Success,\n+                        Skip_First => True);\n+\n+                     if Present (Valid_Candidate (Success, Call_Node, Hom))\n+                       and then Nkind (Call_Node) /= N_Function_Call\n+                     then\n+                        Error_Msg_NE (\"ambiguous call to&\", N, Hom);\n+                        Report_Ambiguity (Matching_Op);\n+                        Report_Ambiguity (Hom);\n+                        Error := True;\n+                        return;\n+                     end if;\n                   end if;\n                end if;\n \n                Hom := Homonym (Hom);\n             end loop;\n+         end Traverse_Homonyms;\n+\n+         -------------------------\n+         -- Traverse_Interfaces --\n+         -------------------------\n \n-            --  Examine other ancestor types\n+         procedure Traverse_Interfaces\n+           (Anc_Type : Entity_Id;\n+            Error    : out Boolean)\n+         is\n+            Intface      : Node_Id;\n+            Intface_List : constant List_Id :=\n+                             Abstract_Interface_List (Anc_Type);\n+\n+         begin\n+            Error := False;\n+\n+            if Is_Non_Empty_List (Intface_List) then\n+               Intface := First (Intface_List);\n+               while Present (Intface) loop\n+\n+                  --  Look for acceptable class-wide homonyms associated with\n+                  --  the interface.\n+\n+                  Traverse_Homonyms (Etype (Intface), Error);\n+\n+                  if Error then\n+                     return;\n+                  end if;\n+\n+                  --  Continue the search by looking at each of the interface's\n+                  --  associated interface ancestors.\n+\n+                  Traverse_Interfaces (Etype (Intface), Error);\n+\n+                  if Error then\n+                     return;\n+                  end if;\n+\n+                  Next (Intface);\n+               end loop;\n+            end if;\n+         end Traverse_Interfaces;\n+\n+      --  Start of processing for Try_Class_Wide_Operation\n+\n+      begin\n+         --  Loop through ancestor types (including interfaces), traversing the\n+         --  homonym chain of the subprogram, and trying out those homonyms\n+         --  whose first formal has the class-wide type of the ancestor, or an\n+         --  anonymous access type designating the class-wide type.\n+\n+         Anc_Type := Obj_Type;\n+         loop\n+            --  Look for a match among homonyms associated with the ancestor\n+\n+            Traverse_Homonyms (Anc_Type, Error);\n+\n+            if Error then\n+               return True;\n+            end if;\n+\n+            --  Continue the search for matches among homonyms associated with\n+            --  any interfaces implemented by the ancestor.\n+\n+            Traverse_Interfaces (Anc_Type, Error);\n+\n+            if Error then\n+               return True;\n+            end if;\n \n             exit when Etype (Anc_Type) = Anc_Type;\n             Anc_Type := Etype (Anc_Type);\n          end loop;\n \n-         --  Nothing matched\n+         if Present (Matching_Op) then\n+            Set_Etype (Call_Node, Etype (Matching_Op));\n+         end if;\n \n-         return False;\n+         return Present (Matching_Op);\n       end Try_Class_Wide_Operation;\n \n+      -----------------------------------\n+      -- Try_One_Prefix_Interpretation --\n+      -----------------------------------\n+\n+      procedure Try_One_Prefix_Interpretation (T : Entity_Id) is\n+      begin\n+         Obj_Type := T;\n+\n+         if Is_Access_Type (Obj_Type) then\n+            Obj_Type := Designated_Type (Obj_Type);\n+         end if;\n+\n+         if Ekind (Obj_Type) = E_Private_Subtype then\n+            Obj_Type := Base_Type (Obj_Type);\n+         end if;\n+\n+         if Is_Class_Wide_Type (Obj_Type) then\n+            Obj_Type := Etype (Class_Wide_Type (Obj_Type));\n+         end if;\n+\n+         --  The type may have be obtained through a limited_with clause,\n+         --  in which case the primitive operations are available on its\n+         --  non-limited view.\n+\n+         if Ekind (Obj_Type) = E_Incomplete_Type\n+           and then From_With_Type (Obj_Type)\n+         then\n+            Obj_Type := Non_Limited_View (Obj_Type);\n+         end if;\n+\n+         --  If the object is not tagged, or the type is still an incomplete\n+         --  type, this is not a prefixed call.\n+\n+         if not Is_Tagged_Type (Obj_Type)\n+           or else Is_Incomplete_Type (Obj_Type)\n+         then\n+            return;\n+         end if;\n+\n+         if Try_Primitive_Operation\n+              (Call_Node       => New_Call_Node,\n+               Node_To_Replace => Node_To_Replace)\n+           or else\n+             Try_Class_Wide_Operation\n+               (Call_Node       => New_Call_Node,\n+                Node_To_Replace => Node_To_Replace)\n+         then\n+            null;\n+         end if;\n+      end Try_One_Prefix_Interpretation;\n+\n       -----------------------------\n       -- Try_Primitive_Operation --\n       -----------------------------\n@@ -5387,9 +5710,15 @@ package body Sem_Ch4 is\n       is\n          Elmt        : Elmt_Id;\n          Prim_Op     : Entity_Id;\n-         Prim_Op_Ref : Node_Id := Empty;\n-         Success     : Boolean := False;\n-         Op_Exists   : Boolean := False;\n+         Matching_Op : Entity_Id := Empty;\n+         Prim_Op_Ref : Node_Id   := Empty;\n+\n+         Corr_Type   : Entity_Id := Empty;\n+         --  If the prefix is a synchronized type, the controlling type of\n+         --  the primitive operation is the corresponding record type, else\n+         --  this is the object type itself.\n+\n+         Success     : Boolean   := False;\n \n          function Valid_First_Argument_Of (Op : Entity_Id) return Boolean;\n          --  Verify that the prefix, dereferenced if need be, is a valid\n@@ -5404,39 +5733,42 @@ package body Sem_Ch4 is\n             Typ : constant Entity_Id := Etype (First_Formal (Op));\n \n          begin\n-            --  Simple case. Object may be a subtype of the tagged type.\n+            --  Simple case. Object may be a subtype of the tagged type\n+            --  or may be the corresponding record of a synchronized type.\n \n             return Obj_Type = Typ\n               or else  Base_Type (Obj_Type) = Typ\n \n-            --  Prefix can be dereferenced\n+              or else Corr_Type = Typ\n+\n+               --  Prefix can be dereferenced\n \n               or else\n-                (Is_Access_Type (Obj_Type)\n-                  and then Designated_Type (Obj_Type) = Typ)\n+                (Is_Access_Type (Corr_Type)\n+                  and then Designated_Type (Corr_Type) = Typ)\n \n-            --  Formal is an access parameter, for which the object\n-            --  can provide an access.\n+               --  Formal is an access parameter, for which the object\n+               --  can provide an access.\n \n               or else\n                 (Ekind (Typ) = E_Anonymous_Access_Type\n-                  and then Designated_Type (Typ) = Base_Type (Obj_Type));\n+                  and then Designated_Type (Typ) = Base_Type (Corr_Type));\n          end Valid_First_Argument_Of;\n \n       --  Start of processing for Try_Primitive_Operation\n \n       begin\n-         --  Look for subprograms in the list of primitive operations\n-         --  The name must be identical, and the kind of call indicates the\n-         --  expected kind of operation (function or procedure).\n-         --  If the type is a (tagged) synchronized type, the primitive ops\n-         --  are attached to the corresponding record type.\n+         --  Look for subprograms in the list of primitive operations The name\n+         --  must be identical, and the kind of call indicates the expected\n+         --  kind of operation (function or procedure). If the type is a\n+         --  (tagged) synchronized type, the primitive ops are attached to\n+         --  the corresponding record type.\n \n          if Is_Concurrent_Type (Obj_Type) then\n-            Elmt :=\n-              First_Elmt\n-               (Primitive_Operations (Corresponding_Record_Type (Obj_Type)));\n+            Corr_Type := Corresponding_Record_Type (Obj_Type);\n+            Elmt := First_Elmt (Primitive_Operations (Corr_Type));\n          else\n+            Corr_Type := Obj_Type;\n             Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n          end if;\n \n@@ -5456,21 +5788,31 @@ package body Sem_Ch4 is\n                --  primitive is also in this list of primitive operations and\n                --  will be used instead.\n \n-               if Present (Abstract_Interface_Alias (Prim_Op))\n-                 and then Is_Ancestor (Find_Dispatching_Type\n-                                         (Alias (Prim_Op)), Obj_Type)\n+               if (Present (Abstract_Interface_Alias (Prim_Op))\n+                     and then Is_Ancestor (Find_Dispatching_Type\n+                                             (Alias (Prim_Op)), Corr_Type))\n+                 or else\n+\n+               --  Do not consider hidden primitives unless they belong to a\n+               --  generic private type with a tagged parent.\n+\n+                  (Is_Hidden (Prim_Op)\n+                     and then not Is_Immediately_Visible (Obj_Type))\n                then\n                   goto Continue;\n                end if;\n \n-               if not Success then\n+               Set_Etype (Call_Node, Any_Type);\n+               Set_Is_Overloaded (Call_Node, False);\n+\n+               if No (Matching_Op) then\n                   Prim_Op_Ref := New_Reference_To (Prim_Op, Sloc (Subprog));\n                   Candidate := Prim_Op;\n \n-                  Set_Etype (Call_Node, Any_Type);\n                   Set_Parent (Call_Node, Parent (Node_To_Replace));\n \n                   Set_Name (Call_Node, Prim_Op_Ref);\n+                  Success := False;\n \n                   Analyze_One_Call\n                     (N          => Call_Node,\n@@ -5479,65 +5821,49 @@ package body Sem_Ch4 is\n                      Success    => Success,\n                      Skip_First => True);\n \n-                  if Success\n-                    or else Needs_One_Actual (Prim_Op)\n-                  then\n-                     Op_Exists := True;\n-                  end if;\n+                  Matching_Op := Valid_Candidate (Success, Call_Node, Prim_Op);\n \n                else\n \n                   --  More than one interpretation, collect for subsequent\n-                  --  disambiguation.\n+                  --  disambiguation. If this is a procedure call and there\n+                  --  is another match, report ambiguity now.\n+\n+                  Analyze_One_Call\n+                    (N          => Call_Node,\n+                     Nam        => Prim_Op,\n+                     Report     => Report_Error,\n+                     Success    => Success,\n+                     Skip_First => True);\n \n-                  Add_One_Interp (Prim_Op_Ref, Prim_Op, Etype (Prim_Op));\n+                  if Present (Valid_Candidate (Success, Call_Node, Prim_Op))\n+                    and then Nkind (Call_Node) /= N_Function_Call\n+                  then\n+                     Error_Msg_NE (\"ambiguous call to&\", N, Prim_Op);\n+                     Report_Ambiguity (Matching_Op);\n+                     Report_Ambiguity (Prim_Op);\n+                     return True;\n+                  end if;\n                end if;\n             end if;\n \n             <<Continue>>\n             Next_Elmt (Elmt);\n          end loop;\n \n-         if Op_Exists then\n-            Complete_Object_Operation\n-              (Call_Node       => Call_Node,\n-               Node_To_Replace => Node_To_Replace,\n-               Subprog         => Prim_Op_Ref);\n+         if Present (Matching_Op) then\n+            Set_Etype (Call_Node, Etype (Matching_Op));\n          end if;\n \n-         return Op_Exists;\n+         return Present (Matching_Op);\n       end Try_Primitive_Operation;\n \n    --  Start of processing for Try_Object_Operation\n \n    begin\n-      if Is_Access_Type (Obj_Type) then\n-         Obj_Type := Designated_Type (Obj_Type);\n-      end if;\n-\n-      if Ekind (Obj_Type) = E_Private_Subtype then\n-         Obj_Type := Base_Type (Obj_Type);\n-      end if;\n-\n-      if Is_Class_Wide_Type (Obj_Type) then\n-         Obj_Type := Etype (Class_Wide_Type (Obj_Type));\n-      end if;\n-\n-      --  The type may have be obtained through a limited_with clause,\n-      --  in which case the primitive operations are available on its\n-      --  non-limited view.\n-\n-      if Ekind (Obj_Type) = E_Incomplete_Type\n-        and then From_With_Type (Obj_Type)\n-      then\n-         Obj_Type := Non_Limited_View (Obj_Type);\n-      end if;\n-\n-      if not Is_Tagged_Type (Obj_Type) then\n-         return False;\n-      end if;\n+      Analyze_Expression (Obj);\n \n-      --  Analyze the actuals if node is know to be a subprogram call\n+      --  Analyze the actuals if node is known to be a subprogram call\n \n       if Is_Subprg_Call and then N = Name (Parent (N)) then\n          Actual := First (Parameter_Associations (Parent (N)));\n@@ -5547,29 +5873,38 @@ package body Sem_Ch4 is\n          end loop;\n       end if;\n \n-      Analyze_Expression (Obj);\n-\n       --  Build a subprogram call node, using a copy of Obj as its first\n       --  actual. This is a placeholder, to be replaced by an explicit\n       --  dereference when needed.\n \n       Transform_Object_Operation\n         (Call_Node       => New_Call_Node,\n-         Node_To_Replace => Node_To_Replace,\n-         Subprog         => Subprog);\n+         Node_To_Replace => Node_To_Replace);\n \n       Set_Etype (New_Call_Node, Any_Type);\n+      Set_Etype (Subprog, Any_Type);\n       Set_Parent (New_Call_Node, Parent (Node_To_Replace));\n \n-      if Try_Primitive_Operation\n-          (Call_Node       => New_Call_Node,\n-           Node_To_Replace => Node_To_Replace)\n+      if not Is_Overloaded (Obj) then\n+         Try_One_Prefix_Interpretation (Obj_Type);\n \n-        or else\n-          Try_Class_Wide_Operation\n-            (Call_Node       => New_Call_Node,\n-             Node_To_Replace => Node_To_Replace)\n-      then\n+      else\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+         begin\n+            Get_First_Interp (Obj, I, It);\n+            while Present (It.Nam) loop\n+               Try_One_Prefix_Interpretation (It.Typ);\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end;\n+      end if;\n+\n+      if Etype (New_Call_Node) /= Any_Type then\n+         Complete_Object_Operation\n+           (Call_Node       => New_Call_Node,\n+            Node_To_Replace => Node_To_Replace);\n          return True;\n \n       elsif Present (Candidate) then"}, {"sha": "d91365b92e2f356a7dfa87d067f3daa29367fd8d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 394, "deletions": 174, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -163,7 +163,7 @@ package body Sem_Ch6 is\n       Err  : out Boolean;\n       Proc : Entity_Id := Empty);\n    --  Called to check for missing return statements in a function body, or for\n-   --  returns present in a procedure body which has No_Return set. L is the\n+   --  returns present in a procedure body which has No_Return set. HSS is the\n    --  handled statement sequence for the subprogram body. This procedure\n    --  checks all flow paths to make sure they either have return (Mode = 'F',\n    --  used for functions) or do not have a return (Mode = 'P', used for\n@@ -286,7 +286,7 @@ package body Sem_Ch6 is\n       --  return.\n \n       if Nkind (N) = N_Extended_Return_Statement then\n-         New_Scope (Stm_Entity);\n+         Push_Scope (Stm_Entity);\n       end if;\n \n       --  Check that pragma No_Return is obeyed:\n@@ -526,11 +526,11 @@ package body Sem_Ch6 is\n \n          R_Stm_Type_Is_Anon_Access :\n            constant Boolean :=\n-             Ekind (R_Type) = E_Anonymous_Access_Subprogram_Type\n+             Ekind (R_Stm_Type) = E_Anonymous_Access_Subprogram_Type\n                or else\n-             Ekind (R_Type) = E_Anonymous_Access_Protected_Subprogram_Type\n+             Ekind (R_Stm_Type) = E_Anonymous_Access_Protected_Subprogram_Type\n                or else\n-             Ekind (R_Type) = E_Anonymous_Access_Type;\n+             Ekind (R_Stm_Type) = E_Anonymous_Access_Type;\n          --  True if type of the return object is an anonymous access type\n \n       begin\n@@ -545,10 +545,15 @@ package body Sem_Ch6 is\n \n          if R_Type_Is_Anon_Access then\n             if R_Stm_Type_Is_Anon_Access then\n-               if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n+               if Base_Type (Designated_Type (R_Stm_Type)) /=\n+                    Base_Type (Designated_Type (R_Type))\n+                 or else not Subtypes_Statically_Match (R_Stm_Type, R_Type)\n+               then\n                   Error_Msg_N\n-                    (\"subtypes must statically match\", Subtype_Ind);\n+                    (\"subtype must statically match function result subtype\",\n+                     Subtype_Mark (Subtype_Ind));\n                end if;\n+\n             else\n                Error_Msg_N (\"must use anonymous access type\", Subtype_Ind);\n             end if;\n@@ -560,10 +565,30 @@ package body Sem_Ch6 is\n             if Is_Constrained (R_Type) then\n                if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n                   Error_Msg_N\n-                    (\"subtypes must statically match\", Subtype_Ind);\n+                    (\"subtype must statically match function result subtype\",\n+                     Subtype_Ind);\n                end if;\n             end if;\n \n+         --  If the function's result type doesn't match the return object\n+         --  entity's type, then we check for the case where the result type\n+         --  is class-wide, and allow the declaration if the type of the object\n+         --  definition matches the class-wide type. This prevents rejection\n+         --  in the case where the object declaration is initialized by a call\n+         --  to a build-in-place function with a specific result type and the\n+         --  object entity had its type changed to that specific type. (Note\n+         --  that the ARG believes that return objects should be allowed to\n+         --  have a type covered by a class-wide result type in any case, so\n+         --  once that relaxation is made (see AI05-32), the above check for\n+         --  type compatibility should be changed to test Covers rather than\n+         --  equality, and then the following special test will no longer be\n+         --  needed. ???)\n+\n+         elsif Is_Class_Wide_Type (R_Type)\n+           and then R_Type = Etype (Object_Definition (Obj_Decl))\n+         then\n+            null;\n+\n          else\n             Error_Msg_N\n               (\"wrong type for return_subtype_indication\", Subtype_Ind);\n@@ -742,7 +767,7 @@ package body Sem_Ch6 is\n       --  needed to process the formals declarations. Then make the formals\n       --  visible in a separate step.\n \n-      New_Scope (Gen_Id);\n+      Push_Scope (Gen_Id);\n \n       declare\n          E         : Entity_Id;\n@@ -1265,6 +1290,11 @@ package body Sem_Ch6 is\n             Set_Etype (Designator, Typ);\n \n             if Ekind (Typ) = E_Incomplete_Type\n+              and then Is_Value_Type (Typ)\n+            then\n+               null;\n+\n+            elsif Ekind (Typ) = E_Incomplete_Type\n               or else (Is_Class_Wide_Type (Typ)\n                          and then\n                            Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n@@ -1801,7 +1831,7 @@ package body Sem_Ch6 is\n \n             Install_Formals (Spec_Id);\n             Last_Formal := Last_Entity (Spec_Id);\n-            New_Scope (Spec_Id);\n+            Push_Scope (Spec_Id);\n \n             --  Make sure that the subprogram is immediately visible. For\n             --  child units that have no separate spec this is indispensable.\n@@ -1835,19 +1865,20 @@ package body Sem_Ch6 is\n               (Body_Id, Body_Id, 'b', Set_Ref => False, Force => True);\n             Generate_Reference_To_Formals (Body_Id);\n             Install_Formals (Body_Id);\n-            New_Scope (Body_Id);\n+            Push_Scope (Body_Id);\n          end if;\n       end if;\n \n       --  Ada 2005 (AI-251): Check wrong placement of abstract interface\n-      --  primitives.\n+      --  primitives, and update anonymous access returns with limited views.\n \n       if Ada_Version >= Ada_05\n         and then Comes_From_Source (N)\n       then\n          declare\n             E    : Entity_Id;\n             Etyp : Entity_Id;\n+            Rtyp : Entity_Id;\n \n          begin\n             --  Check the type of the formals\n@@ -1891,6 +1922,24 @@ package body Sem_Ch6 is\n                      \" defined in package specs\", N);\n                end if;\n             end if;\n+\n+            --  If the return type is an anonymous access type whose\n+            --  designated type is the limited view of a class-wide type\n+            --  and the non-limited view is available. update the return\n+            --  type accordingly.\n+\n+            Rtyp := Etype (Current_Scope);\n+\n+            if Ekind (Rtyp) = E_Anonymous_Access_Type then\n+               Etyp := Directly_Designated_Type (Rtyp);\n+\n+               if Is_Class_Wide_Type (Etyp)\n+                 and then From_With_Type (Etyp)\n+               then\n+                  Set_Directly_Designated_Type\n+                    (Etype (Current_Scope), Available_View (Etyp));\n+               end if;\n+            end if;\n          end;\n       end if;\n \n@@ -2060,12 +2109,15 @@ package body Sem_Ch6 is\n          Stm : Node_Id := First (Statements (HSS));\n \n       begin\n-         --  Skip an initial label (for one thing this occurs when we are in\n-         --  front end ZCX mode, but in any case it is irrelevant).\n+         --  Skip initial labels (for one thing this occurs when we are in\n+         --  front end ZCX mode, but in any case it is irrelevant), and also\n+         --  initial Push_xxx_Error_Label nodes, which are also irrelevant.\n \n-         if Nkind (Stm) = N_Label then\n+         while Nkind (Stm) = N_Label\n+           or else Nkind (Stm) in N_Push_xxx_Label\n+         loop\n             Next (Stm);\n-         end if;\n+         end loop;\n \n          --  Do the test on the original statement before expansion\n \n@@ -2165,9 +2217,9 @@ package body Sem_Ch6 is\n    begin\n       Generate_Definition (Designator);\n \n-      --  Check for RCI unit subprogram declarations against in-lined\n+      --  Check for RCI unit subprogram declarations for illegal inlined\n       --  subprograms and subprograms having access parameter or limited\n-      --  parameter without Read and Write (RM E.2.3(12-13)).\n+      --  parameter without Read and Write attributes (RM E.2.3(12-13)).\n \n       Validate_RCI_Subprogram_Declaration (N);\n \n@@ -2249,7 +2301,7 @@ package body Sem_Ch6 is\n       else\n          --  For a compilation unit, check for library-unit pragmas\n \n-         New_Scope (Designator);\n+         Push_Scope (Designator);\n          Set_Categorization_From_Pragmas (N);\n          Validate_Categorization_Dependency (N, Designator);\n          Pop_Scope;\n@@ -2299,6 +2351,8 @@ package body Sem_Ch6 is\n \n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id is\n       Designator : constant Entity_Id := Defining_Entity (N);\n+      Formal     : Entity_Id;\n+      Formal_Typ : Entity_Id;\n       Formals    : constant List_Id   := Parameter_Specifications (N);\n \n    --  Start of processing for Analyze_Subprogram_Specification\n@@ -2321,30 +2375,31 @@ package body Sem_Ch6 is\n       Set_Scope (Designator, Current_Scope);\n \n       if Present (Formals) then\n-         New_Scope (Designator);\n+         Push_Scope (Designator);\n          Process_Formals (Formals, N);\n \n-         --  Ada 2005 (AI-345): Allow overriding primitives of protected\n-         --  interfaces by means of normal subprograms. For this purpose\n-         --  temporarily use the corresponding record type as the etype\n-         --  of the first formal.\n+         --  Ada 2005 (AI-345): Allow the overriding of interface primitives\n+         --  by subprograms which belong to a concurrent type implementing an\n+         --  interface. Set the parameter type of each controlling formal to\n+         --  the corresponding record type.\n \n-         if Ada_Version >= Ada_05\n-           and then Comes_From_Source (Designator)\n-           and then Present (First_Entity (Designator))\n-           and then (Ekind (Etype (First_Entity (Designator)))\n-                             = E_Protected_Type\n-                       or else\n-                     Ekind (Etype (First_Entity (Designator)))\n-                             = E_Task_Type)\n-           and then Present (Corresponding_Record_Type\n-                             (Etype (First_Entity (Designator))))\n-           and then Present (Abstract_Interfaces\n-                             (Corresponding_Record_Type\n-                             (Etype (First_Entity (Designator)))))\n-         then\n-            Set_Etype (First_Entity (Designator),\n-              Corresponding_Record_Type (Etype (First_Entity (Designator))));\n+         if Ada_Version >= Ada_05 then\n+            Formal := First_Formal (Designator);\n+            while Present (Formal) loop\n+               Formal_Typ := Etype (Formal);\n+\n+               if (Ekind (Formal_Typ) = E_Protected_Type\n+                     or else Ekind (Formal_Typ) = E_Task_Type)\n+                 and then Present (Corresponding_Record_Type (Formal_Typ))\n+                 and then Present (Abstract_Interfaces\n+                                  (Corresponding_Record_Type (Formal_Typ)))\n+               then\n+                  Set_Etype (Formal,\n+                    Corresponding_Record_Type (Formal_Typ));\n+               end if;\n+\n+               Formal := Next_Formal (Formal);\n+            end loop;\n          end if;\n \n          End_Scope;\n@@ -2657,6 +2712,7 @@ package body Sem_Ch6 is\n       begin\n          return Check_All_Returns (N) = OK\n            and then Present (Declarations (N))\n+           and then Present (First (Declarations (N)))\n            and then Chars (Expression (Return_Statement)) =\n                     Chars (Defining_Identifier (First (Declarations (N))));\n       end Has_Single_Return;\n@@ -2836,7 +2892,7 @@ package body Sem_Ch6 is\n       Remove_Pragmas;\n \n       Analyze (Body_To_Analyze);\n-      New_Scope (Defining_Entity (Body_To_Analyze));\n+      Push_Scope (Defining_Entity (Body_To_Analyze));\n       Save_Global_References (Original_Body);\n       End_Scope;\n       Remove (Body_To_Analyze);\n@@ -2987,7 +3043,7 @@ package body Sem_Ch6 is\n          end if;\n \n          --  Ada 2005 (AI-231): In case of anonymous access types check the\n-         --  null-exclusion and access-to-constant attributes must match.\n+         --  null-exclusion and access-to-constant attributes match.\n \n          if Ada_Version >= Ada_05\n            and then Ekind (Etype (Old_Type)) = E_Anonymous_Access_Type\n@@ -3010,7 +3066,7 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n-      --  In subtype conformant case, conventions must match (RM 6.3.1(16))\n+      --  In subtype conformant case, conventions must match (RM 6.3.1(16)).\n       --  If this is a renaming as body, refine error message to indicate that\n       --  the conflict is with the original declaration. If the entity is not\n       --  frozen, the conventions don't have to match, the one of the renamed\n@@ -3161,50 +3217,49 @@ package body Sem_Ch6 is\n             return;\n          end if;\n \n-         --  Full conformance checks\n+         if Ctype >= Subtype_Conformant then\n \n-         if Ctype = Fully_Conformant then\n+            --  Ada 2005 (AI-231): In case of anonymous access types check\n+            --  the null-exclusion and access-to-constant attributes must\n+            --  match.\n \n-            --  We have checked already that names match\n+            if Ada_Version >= Ada_05\n+              and then Ekind (Etype (Old_Formal)) = E_Anonymous_Access_Type\n+              and then Ekind (Etype (New_Formal)) = E_Anonymous_Access_Type\n+              and then\n+                (Can_Never_Be_Null (Old_Formal) /=\n+                 Can_Never_Be_Null (New_Formal)\n+                   or else\n+                 Is_Access_Constant (Etype (Old_Formal)) /=\n+                 Is_Access_Constant (Etype (New_Formal)))\n+            then\n+               --  It is allowed to omit the null-exclusion in case of stream\n+               --  attribute subprograms. We recognize stream subprograms\n+               --  through their TSS-generated suffix.\n \n-            if Parameter_Mode (Old_Formal) = E_In_Parameter then\n+               declare\n+                  TSS_Name : constant TSS_Name_Type := Get_TSS_Name (New_Id);\n+               begin\n+                  if TSS_Name /= TSS_Stream_Read\n+                    and then TSS_Name /= TSS_Stream_Write\n+                    and then TSS_Name /= TSS_Stream_Input\n+                    and then TSS_Name /= TSS_Stream_Output\n+                  then\n+                     Conformance_Error\n+                       (\"type of & does not match!\", New_Formal);\n+                     return;\n+                  end if;\n+               end;\n+            end if;\n+         end if;\n \n-               --  Ada 2005 (AI-231): In case of anonymous access types check\n-               --  the null-exclusion and access-to-constant attributes must\n-               --  match.\n+         --  Full conformance checks\n \n-               if Ada_Version >= Ada_05\n-                 and then Ekind (Etype (Old_Formal)) = E_Anonymous_Access_Type\n-                 and then\n-                   (Can_Never_Be_Null (Old_Formal)\n-                      /= Can_Never_Be_Null (New_Formal)\n-                    or else Is_Access_Constant (Etype (Old_Formal))\n-                              /= Is_Access_Constant (Etype (New_Formal)))\n-               then\n-                  --  It is allowed to omit the null-exclusion in case of\n-                  --  stream attribute subprograms\n+         if Ctype = Fully_Conformant then\n \n-                  declare\n-                     TSS_Name : TSS_Name_Type;\n+            --  We have checked already that names match\n \n-                  begin\n-                     Get_Name_String (Chars (New_Id));\n-                     TSS_Name :=\n-                       TSS_Name_Type\n-                         (Name_Buffer\n-                            (Name_Len - TSS_Name'Length + 1 .. Name_Len));\n-\n-                     if TSS_Name /= TSS_Stream_Read\n-                       and then TSS_Name /= TSS_Stream_Write\n-                       and then TSS_Name /= TSS_Stream_Input\n-                       and then TSS_Name /= TSS_Stream_Output\n-                     then\n-                        Conformance_Error\n-                          (\"type of & does not match!\", New_Formal);\n-                        return;\n-                     end if;\n-                  end;\n-               end if;\n+            if Parameter_Mode (Old_Formal) = E_In_Parameter then\n \n                --  Check default expressions for in parameters\n \n@@ -3218,12 +3273,11 @@ package body Sem_Ch6 is\n \n                      --  The old default value has been analyzed because the\n                      --  current full declaration will have frozen everything\n-                     --  before. The new default values have not been\n-                     --  analyzed, so analyze them now before we check for\n-                     --  conformance.\n+                     --  before. The new default value has not been analyzed,\n+                     --  so analyze it now before we check for conformance.\n \n                      if NewD then\n-                        New_Scope (New_Id);\n+                        Push_Scope (New_Id);\n                         Analyze_Per_Use_Expression\n                           (Default_Value (New_Formal), Etype (New_Formal));\n                         End_Scope;\n@@ -3245,7 +3299,7 @@ package body Sem_Ch6 is\n          end if;\n \n          --  A couple of special checks for Ada 83 mode. These checks are\n-         --  skipped if either entity is an operator in package Standard.\n+         --  skipped if either entity is an operator in package Standard,\n          --  or if either old or new instance is not from the source program.\n \n          if Ada_Version = Ada_83\n@@ -3274,7 +3328,7 @@ package body Sem_Ch6 is\n                --  Grouping (use of comma in param lists) must be the same\n                --  This is where we catch a misconformance like:\n \n-               --    A,B : Integer\n+               --    A, B : Integer\n                --    A : Integer; B : Integer\n \n                --  which are represented identically in the tree except\n@@ -3313,14 +3367,22 @@ package body Sem_Ch6 is\n    -----------------------\n \n    procedure Check_Conventions (Typ : Entity_Id) is\n+\n+      function Skip_Check (Op : Entity_Id) return Boolean;\n+      pragma Inline (Skip_Check);\n+      --  A small optimization: skip the predefined dispatching operations,\n+      --  since they always have the same convention. Also do not consider\n+      --  abstract primitives since those are left by an erroneous overriding.\n+      --  This function returns True for any operation that is thus exempted\n+      --  exempted from checking.\n+\n       procedure Check_Convention\n         (Op          : Entity_Id;\n          Search_From : Elmt_Id);\n-      --  Verify that the convention of inherited dispatching operation\n-      --  Op is consistent among all subprograms it overrides. In order\n-      --  to minimize the search, Search_From is utilized to designate\n-      --  a specific point in the list rather than iterating over the\n-      --  whole list once more.\n+      --  Verify that the convention of inherited dispatching operation Op is\n+      --  consistent among all subprograms it overrides. In order to minimize\n+      --  the search, Search_From is utilized to designate a specific point in\n+      --  the list rather than iterating over the whole list once more.\n \n       ----------------------\n       -- Check_Convention --\n@@ -3331,8 +3393,8 @@ package body Sem_Ch6 is\n          Search_From : Elmt_Id)\n       is\n          procedure Error_Msg_Operation (Op : Entity_Id);\n-         --  Emit a continuation to an error message depicting the kind,\n-         --  name, convention and source location of subprogram Op.\n+         --  Emit a continuation to an error message depicting the kind, name,\n+         --  convention and source location of subprogram Op.\n \n          -------------------------\n          -- Error_Msg_Operation --\n@@ -3343,9 +3405,8 @@ package body Sem_Ch6 is\n             Error_Msg_Name_1 := Chars (Op);\n \n             --  Error messages of primitive subprograms do not contain a\n-            --  convention attribute since the convention may have been\n-            --  first inherited from a parent subprogram, then changed by\n-            --  a pragma.\n+            --  convention attribute since the convention may have been first\n+            --  inherited from a parent subprogram, then changed by a pragma.\n \n             if Comes_From_Source (Op) then\n                Error_Msg_Sloc := Sloc (Op);\n@@ -3370,42 +3431,46 @@ package body Sem_Ch6 is\n \n          --  Local variables\n \n-         Prim_Op      : Entity_Id;\n-         Prim_Op_Elmt : Elmt_Id;\n+         Second_Prim_Op      : Entity_Id;\n+         Second_Prim_Op_Elmt : Elmt_Id;\n \n       --  Start of processing for Check_Convention\n \n       begin\n-         Prim_Op_Elmt := Next_Elmt (Search_From);\n-         while Present (Prim_Op_Elmt) loop\n-            Prim_Op := Node (Prim_Op_Elmt);\n-\n-            --  A small optimization, skip the predefined dispatching\n-            --  operations since they always have the same convention.\n-            --  Also do not consider abstract primitives since those\n-            --  are left by an erroneous overriding.\n-\n-            if not Is_Predefined_Dispatching_Operation (Prim_Op)\n-              and then not Is_Abstract_Subprogram (Prim_Op)\n-              and then Chars (Prim_Op) = Chars (Op)\n-              and then Type_Conformant (Prim_Op, Op)\n-              and then Convention (Prim_Op) /= Convention (Op)\n+         Second_Prim_Op_Elmt := Next_Elmt (Search_From);\n+         while Present (Second_Prim_Op_Elmt) loop\n+            Second_Prim_Op := Node (Second_Prim_Op_Elmt);\n+\n+            if not Skip_Check (Second_Prim_Op)\n+              and then Chars (Second_Prim_Op) = Chars (Op)\n+              and then Type_Conformant (Second_Prim_Op, Op)\n+              and then Convention (Second_Prim_Op) /= Convention (Op)\n             then\n                Error_Msg_N\n                  (\"inconsistent conventions in primitive operations\", Typ);\n \n                Error_Msg_Operation (Op);\n-               Error_Msg_Operation (Prim_Op);\n+               Error_Msg_Operation (Second_Prim_Op);\n \n                --  Avoid cascading errors\n \n                return;\n             end if;\n \n-            Next_Elmt (Prim_Op_Elmt);\n+            Next_Elmt (Second_Prim_Op_Elmt);\n          end loop;\n       end Check_Convention;\n \n+      ----------------\n+      -- Skip_Check --\n+      ----------------\n+\n+      function Skip_Check (Op : Entity_Id) return Boolean is\n+      begin\n+         return Is_Predefined_Dispatching_Operation (Op)\n+           or else Is_Abstract_Subprogram (Op);\n+      end Skip_Check;\n+\n       --  Local variables\n \n       Prim_Op      : Entity_Id;\n@@ -3414,21 +3479,19 @@ package body Sem_Ch6 is\n    --  Start of processing for Check_Conventions\n \n    begin\n-      --  The algorithm checks every overriding dispatching operation\n-      --  against all the corresponding overridden dispatching operations,\n-      --  detecting differences in coventions.\n+      --  The algorithm checks every overriding dispatching operation against\n+      --  all the corresponding overridden dispatching operations, detecting\n+      --  differences in coventions.\n \n       Prim_Op_Elmt := First_Elmt (Primitive_Operations (Typ));\n       while Present (Prim_Op_Elmt) loop\n          Prim_Op := Node (Prim_Op_Elmt);\n \n-         --  A small optimization, skip the predefined dispatching operations\n+         --  A small optimization: skip the predefined dispatching operations\n          --  since they always have the same convention. Also avoid processing\n          --  of abstract primitives left from an erroneous overriding.\n \n-         if not Is_Predefined_Dispatching_Operation (Prim_Op)\n-           and then not Is_Abstract_Subprogram (Prim_Op)\n-         then\n+         if not Skip_Check (Prim_Op) then\n             Check_Convention\n               (Op          => Prim_Op,\n                Search_From => Prim_Op_Elmt);\n@@ -3792,6 +3855,13 @@ package body Sem_Ch6 is\n    -- Check_Returns --\n    -------------------\n \n+   --  Note: this procedure needs to know far too much about how the expander\n+   --  messes with exceptions. The use of the flag Exception_Junk and the\n+   --  incorporation of knowledge of Exp_Ch11.Expand_Local_Exception_Handlers\n+   --  works, but is not very clean. It would be better if the expansion\n+   --  routines would leave Original_Node working nicely, and we could use\n+   --  Original_Node here to ignore all the peculiar expander messing ???\n+\n    procedure Check_Returns\n      (HSS  : Node_Id;\n       Mode : Character;\n@@ -3811,6 +3881,7 @@ package body Sem_Ch6 is\n \n       procedure Check_Statement_Sequence (L : List_Id) is\n          Last_Stm : Node_Id;\n+         Stm      : Node_Id;\n          Kind     : Node_Kind;\n \n          Raise_Exception_Call : Boolean;\n@@ -3824,6 +3895,65 @@ package body Sem_Ch6 is\n \n          Last_Stm := Last (L);\n \n+         --  Deal with digging out exception handler statement sequences that\n+         --  have been transformed by the local raise to goto optimization.\n+         --  See Exp_Ch11.Expand_Local_Exception_Handlers for details. If this\n+         --  optimization has occurred, we are looking at something like:\n+\n+         --  begin\n+         --     original stmts in block\n+\n+         --  exception            \\\n+         --     when excep1 =>     |\n+         --        goto L1;        | omitted if No_Exception_Propagation\n+         --     when excep2 =>     |\n+         --        goto L2;       /\n+         --  end;\n+\n+         --  goto L3;      -- skip handler when exception not raised\n+\n+         --  <<L1>>        -- target label for local exception\n+         --     begin\n+         --        estmts1\n+         --     end;\n+\n+         --     goto L3;\n+\n+         --  <<L2>>\n+         --     begin\n+         --        estmts2\n+         --     end;\n+\n+         --  <<L3>>\n+\n+         --  and what we have to do is to dig out the estmts1 and estmts2\n+         --  sequences (which were the original sequences of statements in\n+         --  the exception handlers) and check them.\n+\n+         if Nkind (Last_Stm) = N_Label\n+           and then Exception_Junk (Last_Stm)\n+         then\n+            Stm := Last_Stm;\n+            loop\n+               Prev (Stm);\n+               exit when No (Stm);\n+               exit when Nkind (Stm) /= N_Block_Statement;\n+               exit when not Exception_Junk (Stm);\n+               Prev (Stm);\n+               exit when No (Stm);\n+               exit when Nkind (Stm) /= N_Label;\n+               exit when not Exception_Junk (Stm);\n+               Check_Statement_Sequence\n+                 (Statements (Handled_Statement_Sequence (Next (Stm))));\n+\n+               Prev (Stm);\n+               Last_Stm := Stm;\n+               exit when No (Stm);\n+               exit when Nkind (Stm) /= N_Goto_Statement;\n+               exit when not Exception_Junk (Stm);\n+            end loop;\n+         end if;\n+\n          --  Don't count pragmas\n \n          while Nkind (Last_Stm) = N_Pragma\n@@ -3843,7 +3973,9 @@ package body Sem_Ch6 is\n              ((Nkind (Last_Stm) = N_Goto_Statement\n                  or else Nkind (Last_Stm) = N_Label\n                  or else Nkind (Last_Stm) = N_Object_Declaration)\n-               and then Exception_Junk (Last_Stm))\n+                and then Exception_Junk (Last_Stm))\n+           or else Nkind (Last_Stm) in N_Push_xxx_Label\n+           or else Nkind (Last_Stm) in N_Pop_xxx_Label\n          loop\n             Prev (Last_Stm);\n          end loop;\n@@ -4236,13 +4368,20 @@ package body Sem_Ch6 is\n       Are_Anonymous_Access_To_Subprogram_Types : Boolean := False;\n \n       function Base_Types_Match (T1, T2 : Entity_Id) return Boolean;\n-      --  If neither T1 nor T2 are generic actual types, or if they are\n-      --  in different scopes (e.g. parent and child instances), then verify\n-      --  that the base types are equal. Otherwise T1 and T2 must be\n-      --  on the same subtype chain. The whole purpose of this procedure\n-      --  is to prevent spurious ambiguities in an instantiation that may\n-      --  arise if two distinct generic types are instantiated with the\n-      --  same actual.\n+      --  If neither T1 nor T2 are generic actual types, or if they are in\n+      --  different scopes (e.g. parent and child instances), then verify that\n+      --  the base types are equal. Otherwise T1 and T2 must be on the same\n+      --  subtype chain. The whole purpose of this procedure is to prevent\n+      --  spurious ambiguities in an instantiation that may arise if two\n+      --  distinct generic types are instantiated with the same actual.\n+\n+      function Matches_Limited_With_View (T1, T2 : Entity_Id) return Boolean;\n+      --  Returns True if and only if either T1 denotes a limited view of T2\n+      --  or T2 denotes a limited view of T1. This can arise when the limited\n+      --  with view of a type is used in a subprogram declaration and the\n+      --  subprogram body is in the scope of a regular with clause for the\n+      --  same unit. In such a case, the two type entities can be considered\n+      --  identical for purposes of conformance checking.\n \n       ----------------------\n       -- Base_Types_Match --\n@@ -4255,35 +4394,44 @@ package body Sem_Ch6 is\n \n          elsif Base_Type (T1) = Base_Type (T2) then\n \n-            --  The following is too permissive. A more precise test must\n+            --  The following is too permissive. A more precise test should\n             --  check that the generic actual is an ancestor subtype of the\n             --  other ???.\n \n             return not Is_Generic_Actual_Type (T1)\n               or else not Is_Generic_Actual_Type (T2)\n               or else Scope (T1) /= Scope (T2);\n \n-         --  In some cases a type imported through a limited_with clause,\n-         --  and its non-limited view are both visible, for example in an\n-         --  anonymous access_to_classwide type in a formal. Both entities\n-         --  designate the same type.\n+         else\n+            return False;\n+         end if;\n+      end Base_Types_Match;\n \n-         elsif From_With_Type (T1)\n-           and then Ekind (T1) = E_Incomplete_Type\n-           and then T2 = Non_Limited_View (T1)\n+      -------------------------------\n+      -- Matches_Limited_With_View --\n+      -------------------------------\n+\n+      function Matches_Limited_With_View (T1, T2 : Entity_Id) return Boolean is\n+      begin\n+         --  In some cases a type imported through a limited_with clause, and\n+         --  its nonlimited view are both visible, for example in an anonymous\n+         --  access-to-class-wide type in a formal. Both entities designate the\n+         --  same type.\n+\n+         if From_With_Type (T1)\n+           and then T2 = Available_View (T1)\n          then\n             return True;\n \n          elsif From_With_Type (T2)\n-           and then Ekind (T2) = E_Incomplete_Type\n-           and then T1 = Non_Limited_View (T2)\n+           and then T1 = Available_View (T2)\n          then\n             return True;\n \n          else\n             return False;\n          end if;\n-      end Base_Types_Match;\n+      end Matches_Limited_With_View;\n \n    --  Start of processing for Conforming_Types\n \n@@ -4298,9 +4446,13 @@ package body Sem_Ch6 is\n          Type_2 := Get_Instance_Of (T2);\n       end if;\n \n-      --  First see if base types match\n+      --  If one of the types is a view of the other introduced by a limited\n+      --  with clause, treat these as conforming for all purposes.\n \n-      if Base_Types_Match (Type_1, Type_2) then\n+      if Matches_Limited_With_View (T1, T2) then\n+         return True;\n+\n+      elsif Base_Types_Match (Type_1, Type_2) then\n          return Ctype <= Mode_Conformant\n            or else Subtypes_Statically_Match (Type_1, Type_2);\n \n@@ -4327,7 +4479,7 @@ package body Sem_Ch6 is\n            or else Subtypes_Statically_Match (Type_1, Full_View (Type_2));\n       end if;\n \n-      --  Ada 2005 (AI-254): Anonymous access to subprogram types must be\n+      --  Ada 2005 (AI-254): Anonymous access-to-subprogram types must be\n       --  treated recursively because they carry a signature.\n \n       Are_Anonymous_Access_To_Subprogram_Types :=\n@@ -4587,7 +4739,12 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n-         --  Create extra formal for supporting accessibility checking\n+         --  Create extra formal for supporting accessibility checking. This\n+         --  is done for both anonymous access formals and formals of named\n+         --  access types that are marked as controlling formals. The latter\n+         --  case can occur when Expand_Dispatching_Call creates a subprogram\n+         --  type and substitutes the types of access-to-class-wide actuals\n+         --  for the anonymous access-to-specific-type of controlling formals.\n \n          --  This is suppressed if we specifically suppress accessibility\n          --  checks at the package level for either the subprogram, or the\n@@ -4597,7 +4754,9 @@ package body Sem_Ch6 is\n          --  different suppression setting. The explicit checks at the\n          --  package level are safe from this point of view.\n \n-         if Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+         if (Ekind (Etype (Formal)) = E_Anonymous_Access_Type\n+              or else (Is_Controlling_Formal (Formal)\n+                        and then Is_Access_Type (Etype (Formal))))\n            and then not\n              (Explicit_Suppress (E, Accessibility_Check)\n                or else\n@@ -4648,10 +4807,15 @@ package body Sem_Ch6 is\n             --  allocated by the caller (0), or should be allocated by the\n             --  callee on the secondary stack (1) or in the global heap (2).\n             --  For the moment we just use Natural for the type of this formal.\n-            --  Note that this formal isn't needed in the case where the\n-            --  result subtype is constrained.\n-\n-            if not Is_Constrained (Result_Subt) then\n+            --  Note that this formal isn't usually needed in the case where\n+            --  the result subtype is constrained, but it is needed when the\n+            --  function has a tagged result, because generally such functions\n+            --  can be called in a dispatching context and such calls must be\n+            --  handled like calls to a class-wide function.\n+\n+            if not Is_Constrained (Result_Subt)\n+              or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n+            then\n                Discard :=\n                  Add_Extra_Formal\n                    (E, Standard_Natural,\n@@ -4669,10 +4833,13 @@ package body Sem_Ch6 is\n             --  region, rather than using copy-back after the function\n             --  returns. This is true even if we are able to get away with\n             --  having 'in out' parameters, which are normally illegal for\n-            --  functions.\n+            --  functions. This formal is also needed when the function has\n+            --  a tagged result, because generally such functions can be called\n+            --  in a dispatching context and such calls must be handled like\n+            --  calls to class-wide functions.\n \n-            if Is_Controlled (Result_Subt)\n-              or else Has_Controlled_Component (Result_Subt)\n+            if Controlled_Type (Result_Subt)\n+              or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n             then\n                Discard :=\n                  Add_Extra_Formal\n@@ -5027,7 +5194,7 @@ package body Sem_Ch6 is\n    begin\n       --  Non-conformant if paren count does not match. Note: if some idiot\n       --  complains that we don't do this right for more than 3 levels of\n-      --  parentheses, they will be treated with the respect they deserve :-)\n+      --  parentheses, they will be treated with the respect they deserve!\n \n       if Paren_Count (E1) /= Paren_Count (E2) then\n          return False;\n@@ -5767,6 +5934,7 @@ package body Sem_Ch6 is\n          First_Hom       : Entity_Id;\n          Overridden_Subp : out Entity_Id)\n       is\n+         Formal_Typ  : Entity_Id;\n          Ifaces_List : Elist_Id;\n          In_Scope    : Boolean;\n          Typ         : Entity_Id;\n@@ -5783,8 +5951,9 @@ package body Sem_Ch6 is\n             return;\n          end if;\n \n-         --  Def_Id must be declared withing the scope of a protected or\n-         --  task type or be a primitive operation of such a type.\n+         --  Search for the concurrent declaration since it contains the list\n+         --  of all implemented interfaces. In this case, the subprogram is\n+         --  declared within the scope of a protected or a task type.\n \n          if Present (Scope (Def_Id))\n            and then Is_Concurrent_Type (Scope (Def_Id))\n@@ -5793,27 +5962,49 @@ package body Sem_Ch6 is\n             Typ := Scope (Def_Id);\n             In_Scope := True;\n \n-         elsif Present (First_Formal (Def_Id))\n-           and then Is_Concurrent_Type (Etype (First_Formal (Def_Id)))\n-           and then not Is_Generic_Actual_Type (Etype (First_Formal (Def_Id)))\n-         then\n-            Typ := Etype (First_Formal (Def_Id));\n-            In_Scope := False;\n+         --  The subprogram may be a primitive of a concurrent type\n+\n+         elsif Present (First_Formal (Def_Id)) then\n+            Formal_Typ := Etype (First_Formal (Def_Id));\n+\n+            if Is_Concurrent_Type (Formal_Typ)\n+              and then not Is_Generic_Actual_Type (Formal_Typ)\n+            then\n+               Typ := Formal_Typ;\n+               In_Scope := False;\n+\n+            --  This case occurs when the concurrent type is declared within\n+            --  a generic unit. As a result the corresponding record has been\n+            --  built and used as the type of the first formal, we just have\n+            --  to retrieve the corresponding concurrent type.\n \n+            elsif Is_Concurrent_Record_Type (Formal_Typ)\n+              and then Present (Corresponding_Concurrent_Type (Formal_Typ))\n+            then\n+               Typ := Corresponding_Concurrent_Type (Formal_Typ);\n+               In_Scope := False;\n+\n+            else\n+               return;\n+            end if;\n          else\n             return;\n          end if;\n \n          --  Gather all limited, protected and task interfaces that Typ\n-         --  implements. Do not collect the interfaces in case of full type\n-         --  declarations because they don't have interface lists.\n+         --  implements. There is no overriding to check if is an inherited\n+         --  operation in a type derivation on for a generic actual.\n \n-         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration then\n+         if Nkind (Parent (Typ)) /= N_Full_Type_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Subtype_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Task_Type_Declaration\n+           and then Nkind (Parent (Def_Id)) /= N_Protected_Type_Declaration\n+         then\n             Collect_Abstract_Interfaces (Typ, Ifaces_List);\n \n             if not Is_Empty_Elmt_List (Ifaces_List) then\n                Overridden_Subp :=\n-                 Overrides_Synchronized_Primitive\n+                 Find_Overridden_Synchronized_Primitive\n                    (Def_Id, First_Hom, Ifaces_List, In_Scope);\n             end if;\n          end if;\n@@ -6163,7 +6354,7 @@ package body Sem_Ch6 is\n                      --  Indicate that E overrides the operation from which\n                      --  S is inherited.\n \n-                     if  Present (Alias (S)) then\n+                     if Present (Alias (S)) then\n                         Set_Overridden_Operation (E, Alias (S));\n                      else\n                         Set_Overridden_Operation (E, S);\n@@ -6538,10 +6729,23 @@ package body Sem_Ch6 is\n                if Is_Tagged_Type (Formal_Type) then\n                   null;\n \n+               --  Special handling of Value_Type for CIL case\n+\n+               elsif Is_Value_Type (Formal_Type) then\n+                  null;\n+\n                elsif Nkind (Parent (T)) /= N_Access_Function_Definition\n                  and then Nkind (Parent (T)) /= N_Access_Procedure_Definition\n                then\n                   Error_Msg_N (\"invalid use of incomplete type\", Param_Spec);\n+\n+               --  An incomplete type that is not tagged is allowed in an\n+               --  access-to-subprogram type only if it is a local declaration\n+               --  with a forthcoming completion (3.10.1 (9.2/2)).\n+\n+               elsif Scope (Formal_Type) /= Scope (Current_Scope) then\n+                  Error_Msg_N\n+                    (\"invalid use of limited view of type\", Param_Spec);\n                end if;\n \n             elsif Ekind (Formal_Type) = E_Void then\n@@ -6558,22 +6762,36 @@ package body Sem_Ch6 is\n               and then Null_Exclusion_Present (Param_Spec)\n             then\n                if not Is_Access_Type (Formal_Type) then\n-                  Error_Msg_N (\"null-exclusion must be applied to an \" &\n-                               \"access type\", Param_Spec);\n+                  Error_Msg_N\n+                    (\"`NOT NULL` allowed only for an access type\", Param_Spec);\n+\n                else\n                   if Can_Never_Be_Null (Formal_Type)\n                     and then Comes_From_Source (Related_Nod)\n                   then\n-                     Error_Msg_N\n-                       (\"null-exclusion cannot be applied to \" &\n-                        \"a null excluding type\", Param_Spec);\n+                     Error_Msg_NE\n+                       (\"`NOT NULL` not allowed (& already excludes null)\",\n+                        Param_Spec,\n+                        Formal_Type);\n                   end if;\n \n                   Formal_Type :=\n                     Create_Null_Excluding_Itype\n                       (T           => Formal_Type,\n                        Related_Nod => Related_Nod,\n                        Scope_Id    => Scope (Current_Scope));\n+\n+                  --  If the designated type of the itype is an itype we\n+                  --  decorate it with the Has_Delayed_Freeze attribute to\n+                  --  avoid problems with the backend.\n+\n+                  --  Example:\n+                  --     type T is access procedure;\n+                  --     procedure Op (O : not null T);\n+\n+                  if Is_Itype (Directly_Designated_Type (Formal_Type)) then\n+                     Set_Has_Delayed_Freeze (Formal_Type);\n+                  end if;\n                end if;\n             end if;\n \n@@ -6702,10 +6920,12 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n+      --  Iterate over both lists. They may be of different lengths if the two\n+      --  specs are not conformant.\n+\n       Fs := First_Formal (Spec);\n       Fb := First_Formal (Bod);\n-\n-      while Present (Fs) loop\n+      while Present (Fs) and then Present (Fb) loop\n          Generate_Reference (Fs, Fb, 'b');\n \n          if Style_Check then"}, {"sha": "462211045caa82cc8c88507e2434462f411f7690", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -167,9 +167,9 @@ package body Sem_Type is\n    --  multiple interpretations. Interpretations can be added to only one\n    --  node at a time.\n \n-   function Specific_Type (T1, T2 : Entity_Id) return Entity_Id;\n-   --  If T1 and T2 are compatible, return  the one that is not\n-   --  universal or is not a \"class\" type (any_character,  etc).\n+   function Specific_Type (Typ_1, Typ_2 : Entity_Id) return Entity_Id;\n+   --  If Typ_1 and Typ_2 are compatible, return the one that is not universal\n+   --  or is not a \"class\" type (any_character, etc).\n \n    --------------------\n    -- Add_One_Interp --\n@@ -344,6 +344,7 @@ package body Sem_Type is\n            or else Nkind (N) = N_Expanded_Name\n            or else (Nkind (N) in N_Op and then E = Entity (N))\n            or else In_Instance\n+           or else Ekind (Vis_Type) = E_Anonymous_Access_Type\n          then\n             null;\n \n@@ -1332,9 +1333,9 @@ package body Sem_Type is\n                   elsif Present (Act2)\n                     and then Nkind (Act2) in N_Op\n                     and then Is_Overloaded (Act2)\n-                    and then (Nkind (Right_Opnd (Act1)) = N_Integer_Literal\n+                    and then (Nkind (Right_Opnd (Act2)) = N_Integer_Literal\n                                 or else\n-                              Nkind (Right_Opnd (Act1)) = N_Real_Literal)\n+                              Nkind (Right_Opnd (Act2)) = N_Real_Literal)\n                     and then Has_Compatible_Type (Act2, Standard_Boolean)\n                   then\n                      --  The preference rule on the first actual is not\n@@ -1451,6 +1452,19 @@ package body Sem_Type is\n          end if;\n       end if;\n \n+      --  Check for overloaded CIL convention stuff because the CIL libraries\n+      --  do sick things like Console.WriteLine where it matches\n+      --  two different overloads, so just pick the first ???\n+\n+      if Convention (Nam1) = Convention_CIL\n+        and then Convention (Nam2) = Convention_CIL\n+        and then Ekind (Nam1) = Ekind (Nam2)\n+        and then (Ekind (Nam1) = E_Procedure\n+                   or else Ekind (Nam1) = E_Function)\n+      then\n+         return It2;\n+      end if;\n+\n       --  If the context is universal, the predefined operator is preferred.\n       --  This includes bounds in numeric type declarations, and expressions\n       --  in type conversions. If no interpretation yields a universal type,\n@@ -1869,14 +1883,19 @@ package body Sem_Type is\n       --  is no rule in 4.6 that allows \"access Integer\" to be converted to P.\n \n       elsif Ada_Version >= Ada_05\n-        and then Ekind (Etype (L)) = E_Anonymous_Access_Type\n+        and then\n+          (Ekind (Etype (L)) = E_Anonymous_Access_Type\n+             or else\n+           Ekind (Etype (L)) = E_Anonymous_Access_Subprogram_Type)\n         and then Is_Access_Type (Etype (R))\n         and then Ekind (Etype (R)) /= E_Access_Type\n       then\n          return Etype (L);\n \n       elsif Ada_Version >= Ada_05\n-        and then Ekind (Etype (R)) = E_Anonymous_Access_Type\n+        and then\n+          (Ekind (Etype (R)) = E_Anonymous_Access_Type\n+            or else Ekind (Etype (R)) = E_Anonymous_Access_Subprogram_Type)\n         and then Is_Access_Type (Etype (L))\n         and then Ekind (Etype (L)) /= E_Access_Type\n       then\n@@ -2058,17 +2077,22 @@ package body Sem_Type is\n       Iface : Entity_Id) return Boolean\n    is\n       Target_Typ : Entity_Id;\n+      Iface_Typ  : Entity_Id;\n \n       function Iface_Present_In_Ancestor (Typ : Entity_Id) return Boolean;\n       --  Returns True if Typ or some ancestor of Typ implements Iface\n \n+      -------------------------------\n+      -- Iface_Present_In_Ancestor --\n+      -------------------------------\n+\n       function Iface_Present_In_Ancestor (Typ : Entity_Id) return Boolean is\n          E    : Entity_Id;\n          AI   : Entity_Id;\n          Elmt : Elmt_Id;\n \n       begin\n-         if Typ = Iface then\n+         if Typ = Iface_Typ then\n             return True;\n          end if;\n \n@@ -2091,7 +2115,7 @@ package body Sem_Type is\n                while Present (Elmt) loop\n                   AI := Node (Elmt);\n \n-                  if AI = Iface or else Is_Ancestor (Iface, AI) then\n+                  if AI = Iface_Typ or else Is_Ancestor (Iface_Typ, AI) then\n                      return True;\n                   end if;\n \n@@ -2109,7 +2133,7 @@ package body Sem_Type is\n             --  Check if the current type is a direct derivation of the\n             --  interface\n \n-            if Etype (E) = Iface then\n+            if Etype (E) = Iface_Typ then\n                return True;\n             end if;\n \n@@ -2128,6 +2152,16 @@ package body Sem_Type is\n    --  Start of processing for Interface_Present_In_Ancestor\n \n    begin\n+      if Is_Class_Wide_Type (Iface) then\n+         Iface_Typ := Etype (Iface);\n+      else\n+         Iface_Typ := Iface;\n+      end if;\n+\n+      --  Handle subtypes\n+\n+      Iface_Typ := Base_Type (Iface_Typ);\n+\n       if Is_Access_Type (Typ) then\n          Target_Typ := Etype (Directly_Designated_Type (Typ));\n       else\n@@ -2138,20 +2172,22 @@ package body Sem_Type is\n          Target_Typ := Corresponding_Concurrent_Type (Target_Typ);\n       end if;\n \n+      Target_Typ := Base_Type (Target_Typ);\n+\n       --  In case of concurrent types we can't use the Corresponding Record_Typ\n       --  to look for the interface because it is built by the expander (and\n       --  hence it is not always available). For this reason we traverse the\n       --  list of interfaces (available in the parent of the concurrent type)\n \n       if Is_Concurrent_Type (Target_Typ) then\n-         if Present (Interface_List (Parent (Base_Type (Target_Typ)))) then\n+         if Present (Interface_List (Parent (Target_Typ))) then\n             declare\n                AI : Node_Id;\n \n             begin\n-               AI := First (Interface_List (Parent (Base_Type (Target_Typ))));\n+               AI := First (Interface_List (Parent (Target_Typ)));\n                while Present (AI) loop\n-                  if Etype (AI) = Iface then\n+                  if Etype (AI) = Iface_Typ then\n                      return True;\n \n                   elsif Present (Abstract_Interfaces (Etype (AI)))\n@@ -2674,7 +2710,9 @@ package body Sem_Type is\n    -- Specific_Type --\n    -------------------\n \n-   function Specific_Type (T1, T2 : Entity_Id) return Entity_Id is\n+   function Specific_Type (Typ_1, Typ_2 : Entity_Id) return Entity_Id is\n+      T1 : constant Entity_Id := Available_View (Typ_1);\n+      T2 : constant Entity_Id := Available_View (Typ_2);\n       B1 : constant Entity_Id := Base_Type (T1);\n       B2 : constant Entity_Id := Base_Type (T2);\n "}, {"sha": "172e146e994cf1dd2166871de31ccfb3e67682ff", "filename": "gcc/ada/sem_type.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_type.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a36105d5657dd7126160c5bae2b9b68af63fcff/gcc%2Fada%2Fsem_type.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.ads?ref=0a36105d5657dd7126160c5bae2b9b68af63fcff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -207,8 +207,9 @@ package Sem_Type is\n      (Typ   : Entity_Id;\n       Iface : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-251): Typ must be a tagged record type/subtype and Iface\n-   --  must be an abstract interface type. This function is used to check if\n-   --  Typ or some ancestor of Typ implements Iface.\n+   --  must be an abstract interface type (or a class-wide abstract interface).\n+   --  This function is used to check if Typ or some ancestor of Typ implements\n+   --  Iface (returning True only if so).\n \n    function Intersect_Types (L, R : Node_Id) return Entity_Id;\n    --  Find the common interpretation to two analyzed nodes. If one of the"}]}