{"sha": "b758ec724cc06cb866a72ce17dbfd8a426cf21db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc1OGVjNzI0Y2MwNmNiODY2YTcyY2UxN2RiZmQ4YTQyNmNmMjFkYg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-08-20T03:51:25Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Lexer cleanup", "tree": {"sha": "cffb4e7c584f7da75ea42e57011c5a1d160d67a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cffb4e7c584f7da75ea42e57011c5a1d160d67a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b758ec724cc06cb866a72ce17dbfd8a426cf21db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b758ec724cc06cb866a72ce17dbfd8a426cf21db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b758ec724cc06cb866a72ce17dbfd8a426cf21db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b758ec724cc06cb866a72ce17dbfd8a426cf21db/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26f60f6a28394e98ac1d830cbe8f632ef576dbb"}], "stats": {"total": 831, "additions": 426, "deletions": 405}, "files": [{"sha": "d95bfdf17bf2596b486747bd60098b27b58d75aa", "filename": "gcc/rust/lex/rust-codepoint.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-codepoint.h?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -1,11 +1,6 @@\n #ifndef RUST_CODEPOINT_H\n #define RUST_CODEPOINT_H\n \n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-// config, system, coretypes - TODO: ensure all are needed\n-\n #include <string>\n \n namespace Rust {\n@@ -16,11 +11,21 @@ struct Codepoint\n   // Creates a zero codepoint.\n   Codepoint () : value (0) {}\n \n-  // Creates a codepoint from UTF-8 value.\n-  Codepoint (uint32_t value_) : value (value_) {}\n+  // Creates a codepoint from an encoded UTF-8 value.\n+  Codepoint (uint32_t value) : value (value) {}\n+\n+  // Returns a C++ string containing string value of codepoint.\n+  std::string as_string ();\n+\n+  bool operator== (Codepoint other) const\n+  {\n+    return value == other.value;\n+  }\n \n-  // Returns a C++ string containing value of codepoint.\n-  ::std::string as_string ();\n+  bool operator!= (Codepoint other) const\n+  {\n+    return !operator== (other);\n+  }\n };\n } // namespace Rust\n "}, {"sha": "6f50e21a8349e249a8cb0165c7e4d9e4eb121db6", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 379, "deletions": 369, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -1,6 +1,6 @@\n #include \"rust-lex.h\"\n \n-#include \"rust-system.h\" // for rust_assert and rust_unreachable\n+#include \"rust-system.h\"      // for rust_assert and rust_unreachable\n #include \"rust-diagnostics.h\" // for rust_error_at\n #include \"rust-linemap.h\"\n #include \"safe-ctype.h\"\n@@ -10,7 +10,7 @@\n namespace Rust {\n     // TODO: move to separate compilation unit?\n     // overload += for uint32_t to allow 32-bit encoded utf-8 to be added\n-    ::std::string& operator+=(::std::string& str, Codepoint char32) {\n+    std::string& operator+=(std::string& str, Codepoint char32) {\n         if (char32.value < 0x80) {\n             str += static_cast<char>(char32.value);\n         } else if (char32.value < (0x1F + 1) << (1 * 6)) {\n@@ -27,64 +27,45 @@ namespace Rust {\n             str += static_cast<char>(0x80 | ((char32.value >> 0) & 0x3F));\n         } else {\n             fprintf(stderr, \"Invalid unicode codepoint found: '%u' \\n\", char32.value);\n-            // rust_error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\",\n-            // char32.value);\n         }\n         return str;\n     }\n \n-    ::std::string Codepoint::as_string() {\n+    std::string Codepoint::as_string() {\n         std::string str;\n \n-        // do i need to do this? or can i just do str += value due to op overloading?\n-\n-        // ok can't figure out how to just convert to codepoint or use \"this\" so create new one\n-        str += Codepoint(value);\n-\n-        /*if (value < 0x80) {\n-            str += static_cast<char>(value);\n-        } else if (value < (0x1F + 1) << (1 * 6)) {\n-            str += static_cast<char>(0xC0 | ((value >> 6) & 0x1F));\n-            str += static_cast<char>(0x80 | ((value >> 0) & 0x3F));\n-        } else if (value < (0x0F + 1) << (2 * 6)) {\n-            str += static_cast<char>(0xE0 | ((value >> 12) & 0x0F));\n-            str += static_cast<char>(0x80 | ((value >> 6) & 0x3F));\n-            str += static_cast<char>(0x80 | ((value >> 0) & 0x3F));\n-        } else if (value < (0x07 + 1) << (3 * 6)) {\n-            str += static_cast<char>(0xF0 | ((value >> 18) & 0x07));\n-            str += static_cast<char>(0x80 | ((value >> 12) & 0x3F));\n-            str += static_cast<char>(0x80 | ((value >> 6) & 0x3F));\n-            str += static_cast<char>(0x80 | ((value >> 0) & 0x3F));\n-        } else {\n-            rust_error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\", value);\n-        }*/\n+        // str += Codepoint (value);\n+        str += *this;\n+\n         return str;\n     }\n \n-    // Includes all allowable float digits EXCEPT _ and . as that needs lookahead for handling.\n-    inline bool is_float_digit(char number) {\n+    /* Includes all allowable float digits EXCEPT _ and . as that needs lookahead\n+     * for handling. */\n+    bool is_float_digit(char number) {\n         return ISDIGIT(number) || number == 'E' || number == 'e';\n     }\n \n-    // Basically ISXDIGIT from safe-ctype but may change if Rust's encoding or whatever is different\n-    inline bool is_x_digit(char number) {\n+    /* Basically ISXDIGIT from safe-ctype but may change if Rust's encoding or\n+     * whatever is different */\n+    bool is_x_digit(char number) {\n         return ISXDIGIT(number);\n     }\n \n-    inline bool is_octal_digit(char number) {\n+    bool is_octal_digit(char number) {\n         return number >= '0' && number <= '7';\n     }\n \n-    inline bool is_bin_digit(char number) {\n+    bool is_bin_digit(char number) {\n         return number == '0' || number == '1';\n     }\n \n-    inline bool check_valid_float_dot_end(char character) {\n+    bool check_valid_float_dot_end(char character) {\n         return character != '.' && character != '_' && !ISALPHA(character);\n     }\n \n     // ISSPACE from safe-ctype but may change in future\n-    inline bool is_whitespace(char character) {\n+    bool is_whitespace(char character) {\n         return ISSPACE(character);\n     }\n \n@@ -96,21 +77,22 @@ namespace Rust {\n     }\n \n     Lexer::~Lexer() {\n-        /* ok apparently stop (which is equivalent of original code in destructor) is meant to be\n-         * called after all files have finished parsing, for cleanup. On the other hand, actual code\n-         * that it calls to leave a certain line map is mentioned in GCC docs as being useful for\n-         * \"just leaving an included header\" and stuff like that, so this line mapping functionality\n-         * may need fixing.\n+        /* ok apparently stop (which is equivalent of original code in destructor) is\n+         * meant to be called after all files have finished parsing, for cleanup. On\n+         * the other hand, actual code that it calls to leave a certain line map is\n+         * mentioned in GCC docs as being useful for \"just leaving an included header\"\n+         * and stuff like that, so this line mapping functionality may need fixing.\n          * FIXME: find out whether this occurs. */\n         // line_map->stop();\n     }\n \n-    // TODO: need to optimise somehow to avoid the virtual function call in the tight loop.\n-    // Best idea at the moment is CRTP, but that might make lexer implementation annoying when storing\n-    // the \"base class\" (i.e. would need template parameter everywhere), although in practice it would\n-    // mostly just look ugly and make enclosing classes like Parser also require a type parameter.\n-    // At this point a macro might be better.\n-    // OK I guess macros can be replaced by constexpr if or something if possible.\n+    /* TODO: need to optimise somehow to avoid the virtual function call in the\n+     * tight loop. Best idea at the moment is CRTP, but that might make lexer\n+     * implementation annoying when storing the \"base class\" (i.e. would need\n+     * template parameter everywhere), although in practice it would mostly just\n+     * look ugly and make enclosing classes like Parser also require a type\n+     * parameter. At this point a macro might be better. OK I guess macros can be\n+     * replaced by constexpr if or something if possible. */\n     Location Lexer::get_current_location() {\n         return line_map->get_location(current_column);\n     }\n@@ -151,9 +133,9 @@ namespace Rust {\n         token_queue.replace_current_value(replacement);\n     }\n \n-    /* shitty anonymous namespace that can only be accessed inside the compilation unit - used for\n-     * classify_keyword\n-     * Binary search in sorted array of keywords created with x-macros. */\n+    /* shitty anonymous namespace that can only be accessed inside the compilation\n+     * unit - used for classify_keyword Binary search in sorted array of keywords\n+     * created with x-macros. */\n     namespace {\n         const std::string keyword_index[] = {\n #define RS_TOKEN(x, y)\n@@ -172,19 +154,18 @@ namespace Rust {\n         };\n \n         const int num_keywords = sizeof(keyword_index) / sizeof(*keyword_index);\n-    }\n+    } // namespace\n \n-    /* Determines whether the string passed in is a keyword or not. If it is, it returns the keyword\n-     * name.  */\n+    /* Determines whether the string passed in is a keyword or not. If it is, it\n+     * returns the keyword name.  */\n     TokenId Lexer::classify_keyword(const std::string& str) {\n         const std::string* last = keyword_index + num_keywords;\n         const std::string* idx = std::lower_bound(keyword_index, last, str);\n \n-        if (idx == last || str != *idx) {\n+        if (idx == last || str != *idx)\n             return IDENTIFIER;\n-        } else {\n+        else\n             return keyword_keys[idx - keyword_index];\n-        }\n     }\n \n     TokenPtr Lexer::build_token() {\n@@ -195,9 +176,8 @@ namespace Rust {\n             skip_input();\n \n             // return end of file token if end of file\n-            if (current_char == EOF) {\n+            if (current_char == EOF) \n                 return Token::make(END_OF_FILE, loc);\n-            }\n \n             // detect shebang\n             if (loc == 1 && current_line == 1 && current_char == '#') {\n@@ -231,12 +211,13 @@ namespace Rust {\n \n             // if not end of file, start tokenising\n             switch (current_char) {\n-                // ignore whitespace characters for tokens but continue updating location\n+                /* ignore whitespace characters for tokens but continue updating\n+                 * location */\n                 case '\\n': // newline\n                     current_line++;\n                     current_column = 1;\n                     // tell line_table that new line starts\n-                    linemap_line_start(::line_table, current_line, max_column_hint);\n+                    line_map->start_line(current_line, max_column_hint);\n                     continue;\n                 case ' ': // space\n                     current_column++;\n@@ -509,23 +490,18 @@ namespace Rust {\n                     current_column++;\n                     return Token::make(RIGHT_CURLY, loc);\n                 case '@':\n-                    // TODO: i don't know what this does, does it need special handling?\n                     current_column++;\n                     return Token::make(PATTERN_BIND, loc);\n                 case '$':\n-                    // TODO: i don't know what this does, does it need special handling?\n                     current_column++;\n                     return Token::make(DOLLAR_SIGN, loc);\n                 case '~':\n-                    // TODO: i don't know what this does, does it need special handling?\n                     current_column++;\n                     return Token::make(TILDE, loc);\n                 case '\\\\':\n-                    // TODO: i don't know what this does, does it need special handling?\n                     current_column++;\n                     return Token::make(BACKSLASH, loc);\n                 case '`':\n-                    // TODO: i don't know what this does, does it need special handling?\n                     current_column++;\n                     return Token::make(BACKTICK, loc);\n                 case '|':\n@@ -599,43 +575,34 @@ namespace Rust {\n             // byte and byte string test\n             if (current_char == 'b') {\n                 if (peek_input() == '\\'') {\n-                    // byte - allows any ascii or escapes\n-                    // would also have to take into account escapes: \\x hex_digit hex_digit,\n-                    // \\n, \\r, \\t, \\\\, \\0\n+                    skip_input();\n+                    current_column++;\n+                    // make current char the next character\n+                    current_char = peek_input();\n \n                     int length = 1;\n \n                     // char to save\n-                    char byte_char;\n-\n-                    skip_input();\n-                    // make current char the next character\n-                    current_char = peek_input();\n+                    char byte_char = 0;\n \n                     // detect escapes\n                     if (current_char == '\\\\') {\n-                        /*skip_input();\n-\n-                        // make current_char next character (letter)\n-                        current_char = peek_input();*/\n-\n-                        parse_escape(length, byte_char, '\\'');\n+                        auto escape_length_pair = parse_escape('\\'');\n+                        byte_char = escape_length_pair.first;\n+                        length += escape_length_pair.second;\n \n                         if (byte_char > 127) {\n                             rust_error_at(\n                               get_current_location(), \"byte char '%c' out of range\", byte_char);\n                             byte_char = 0;\n                         }\n \n-                        // skip_input();\n                         current_char = peek_input();\n-                        length++;\n \n                         if (current_char != '\\'') {\n                             rust_error_at(get_current_location(), \"unclosed byte char\");\n                         }\n \n-                        // TODO: ensure skipping is needed here\n                         skip_input();\n                         current_char = peek_input();\n                         length++; // go to next char\n@@ -645,12 +612,12 @@ namespace Rust {\n \n                         skip_input();\n                         current_char = peek_input();\n+                        length++;\n \n                         if (current_char != '\\'') {\n                             rust_error_at(get_current_location(), \"unclosed byte char\");\n                         }\n \n-                        // TODO: ensure skipping is needed here\n                         skip_input();\n                         current_char = peek_input();\n                         length++; // go to next char\n@@ -666,26 +633,35 @@ namespace Rust {\n \n                     // skip quote character\n                     skip_input();\n+                    current_column++;\n \n                     std::string str;\n                     str.reserve(16); // some sensible default\n \n                     int length = 1;\n                     current_char = peek_input();\n-                    // TODO: handle escapes properly\n \n                     while (current_char != '\"' && current_char != '\\n') {\n                         if (current_char == '\\\\') {\n-                            char output_char = 0;\n-                            parse_escape(length, output_char, '\"');\n+                            auto escape_length_pair = parse_escape('\"');\n+                            char output_char = escape_length_pair.first;\n+                            //length += escape_length_pair.second;\n+\n+                            // TODO: need to fix length - after escape, the length of the line up to the next non-whitespace char of the string is added to length, which is not what we want - we want length to be replaced by that.\n+                            // possible option could if \"if escape_length_pair.first == 0, then length = escape_length_pair.second else length += escape_length_pair.second.\"\n+                            if (output_char == 0)\n+                                length = escape_length_pair.second - 1; \n+                            else\n+                                length += escape_length_pair.second;\n \n                             if (output_char > 127) {\n                                 rust_error_at(get_current_location(),\n                                   \"char '%c' in byte string out of range\", output_char);\n                                 output_char = 0;\n                             }\n \n-                            str += output_char;\n+                            if (output_char != 0)\n+                                str += output_char;\n \n                             continue;\n                         }\n@@ -702,14 +678,18 @@ namespace Rust {\n                     if (current_char == '\\n') {\n                         rust_error_at(get_current_location(), \"unended byte string literal\");\n                     } else if (current_char == '\"') {\n+                        // TEST: hopefully column inc should make string line up properly\n+                        current_column++;\n+\n                         skip_input();\n                         current_char = peek_input();\n                     } else {\n-                        rust_unreachable();\n+                        gcc_unreachable();\n                     }\n \n+                    str.shrink_to_fit();\n+\n                     return Token::make_byte_string(loc, str);\n-                    // TODO: ensure escapes and string continue work properly\n                 } else if (peek_input() == 'r' && (peek_input(1) == '#' || peek_input(1) == '\"')) {\n                     // raw byte string literals\n                     std::string str;\n@@ -721,6 +701,7 @@ namespace Rust {\n                     // get hash count at beginnning\n                     skip_input();\n                     current_char = peek_input();\n+                    length++;\n                     while (current_char == '#') {\n                         hash_count++;\n                         length++;\n@@ -735,15 +716,16 @@ namespace Rust {\n \n                     skip_input();\n                     current_char = peek_input();\n+                    length++;\n \n                     while (true) {\n                         if (current_char == '\"') {\n                             bool enough_hashes = true;\n \n                             for (int i = 0; i < hash_count; i++) {\n                                 if (peek_input(i + 1) != '#') {\n-                                    enough_hashes\n-                                      = false; // could continue here - improve performance\n+                                    enough_hashes = false; // could continue here -\n+                                                           // improve performance\n                                 }\n                             }\n \n@@ -765,7 +747,9 @@ namespace Rust {\n \n                     current_column += length;\n \n-                    return Token::make_byte_string(loc, str); // TODO: does this work properly\n+                    str.shrink_to_fit();\n+\n+                    return Token::make_byte_string(loc, str);\n                 }\n             }\n \n@@ -811,65 +795,79 @@ namespace Rust {\n                         rust_error_at(\n                           get_current_location(), \"'%s' is a forbidden raw identifier\", str.c_str());\n                     } else {\n+                        str.shrink_to_fit();\n+\n                         return Token::make_identifier(loc, str);\n                     }\n-                } else if (peek == '\"' || (peek == '#' && (ISALPHA(peek1) || peek1 == '_'))) {\n-                    // raw string literals\n-                    std::string str;\n-                    str.reserve(16); // some sensible default\n+                } else {\n+                    int peek_index = 0;\n+                    while (peek_input(peek_index) == '#')\n+                        peek_index++;\n+                    // TODO: optimise by using \"peek_index\" as the hash count - 1 or something\n \n-                    int length = 1;\n-                    int hash_count = 0;\n+                    if (peek_input(peek_index) == '\"') {\n+                        // raw string literals\n+                        std::string str;\n+                        str.reserve(16); // some sensible default\n \n-                    // get hash count at beginnning\n-                    current_char = peek;\n-                    while (current_char == '#') {\n-                        hash_count++;\n-                        length++;\n+                        int length = 1;\n+                        int hash_count = 0;\n+\n+                        // get hash count at beginnning\n+                        current_char = peek;\n+                        while (current_char == '#') {\n+                            hash_count++;\n+                            length++;\n+\n+                            skip_input();\n+                            current_char = peek_input();\n+                        }\n+\n+                        if (current_char != '\"') {\n+                            rust_error_at(get_current_location(), \"raw string has no opening '\\\"'\");\n+                        }\n \n+                        length++;\n                         skip_input();\n-                        current_char = peek_input();\n-                    }\n+                        Codepoint current_char32 = test_peek_codepoint_input();\n \n-                    if (current_char != '\"') {\n-                        rust_error_at(get_current_location(), \"raw string has no opening '\\\"'\");\n-                    }\n+                        // TODO: didn't account for current_column++ somewhere - one less than is required\n \n-                    skip_input();\n-                    Codepoint current_char32 = test_peek_codepoint_input();\n+                        while (true) {\n+                            if (current_char32.value == '\"') {\n+                                bool enough_hashes = true;\n \n-                    while (true) {\n-                        if (current_char32.value == '\"') {\n-                            bool enough_hashes = true;\n+                                for (int i = 0; i < hash_count; i++) {\n+                                    // if (test_peek_codepoint_input(i + 1) != '#') {\n+                                    // TODO: ensure this is a good enough replacement\n+                                    if (peek_input(i + 1) != '#') {\n+                                        enough_hashes = false; // could continue here -\n+                                                               // improve performance\n+                                    }\n+                                }\n \n-                            for (int i = 0; i < hash_count; i++) {\n-                                // if (test_peek_codepoint_input(i + 1) != '#') {\n-                                // TODO: ensure this is a good enough replacement\n-                                if (peek_input(i + 1) != '#') {\n-                                    enough_hashes\n-                                      = false; // could continue here - improve performance\n+                                if (enough_hashes) {\n+                                    // skip enough input and peek enough input\n+                                    skip_input(hash_count); // is this enough?\n+                                    current_char = peek_input();\n+                                    length += hash_count + 1;\n+                                    break;\n                                 }\n                             }\n \n-                            if (enough_hashes) {\n-                                // skip enough input and peek enough input\n-                                skip_input(hash_count); // is this enough?\n-                                current_char = peek_input();\n-                                length += hash_count + 1;\n-                                break;\n-                            }\n-                        }\n+                            length++;\n \n-                        length++;\n+                            str += current_char32;\n+                            test_skip_codepoint_input();\n+                            current_char32 = test_peek_codepoint_input();\n+                        }\n \n-                        str += current_char32;\n-                        test_skip_codepoint_input();\n-                        current_char32 = test_peek_codepoint_input();\n-                    }\n+                        current_column += length;\n \n-                    current_column += length;\n+                        str.shrink_to_fit();\n \n-                    return Token::make_string(loc, str); // TODO: does this work properly\n+                        return Token::make_string(loc, str);\n+                    }\n                 }\n             }\n \n@@ -895,16 +893,16 @@ namespace Rust {\n                 current_column += length;\n \n                 // if just a single underscore, not an identifier\n-                if (first_is_underscore && length == 1) {\n+                if (first_is_underscore && length == 1)\n                     return Token::make(UNDERSCORE, loc);\n-                }\n+\n+                str.shrink_to_fit();\n \n                 TokenId keyword = classify_keyword(str);\n-                if (keyword == IDENTIFIER) {\n+                if (keyword == IDENTIFIER)\n                     return Token::make_identifier(loc, str);\n-                } else {\n+                else\n                     return Token::make(keyword, loc);\n-                }\n             }\n \n             // identify literals\n@@ -958,19 +956,14 @@ namespace Rust {\n                         current_column += length;\n \n                         // convert hex value to decimal representation\n-                        long hex_num = ::std::strtol(str.c_str(), NULL, 16);\n-\n-                        // create output string stream for hex value to be converted to string\n-                        // again\n-                        // TODO: if too slow, use sprintf\n-                        ::std::ostringstream ostr;\n-                        ostr << hex_num;\n+                        long hex_num = std::strtol(str.c_str(), NULL, 16);\n \n-                        // reassign string representation to converted value\n-                        str = ostr.str();\n+                        str = std::to_string(hex_num);\n \n                         // parse in type suffix if it exists\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n                             rust_error_at(get_current_location(),\n@@ -985,8 +978,6 @@ namespace Rust {\n \n                         length++;\n \n-                        // don't add any characters as C octals are just 0124 or whatever\n-\n                         // loop through to add entire octal number to string\n                         while (is_octal_digit(current_char) || current_char == '_') {\n                             if (current_char == '_') {\n@@ -1010,19 +1001,15 @@ namespace Rust {\n                         current_column += length;\n \n                         // convert octal value to decimal representation\n-                        long octal_num = ::std::strtol(str.c_str(), NULL, 8);\n-\n-                        // create output string stream for octal value to be converted to\n-                        // string again\n-                        // TODO: if too slow, use sprintf\n-                        ::std::ostringstream ostr;\n-                        ostr << octal_num;\n+                        long octal_num = std::strtol(str.c_str(), NULL, 8);\n \n-                        // reassign string representation to converted value\n-                        str = ostr.str();\n+                        str = std::to_string(octal_num);\n \n                         // parse in type suffix if it exists\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        // parse_in_type_suffix (/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n                             rust_error_at(get_current_location(),\n@@ -1037,9 +1024,6 @@ namespace Rust {\n \n                         length++;\n \n-                        // don't add any characters as C binary numbers are not really\n-                        // supported\n-\n                         // loop through to add entire binary number to string\n                         while (is_bin_digit(current_char) || current_char == '_') {\n                             if (current_char == '_') {\n@@ -1063,19 +1047,15 @@ namespace Rust {\n                         current_column += length;\n \n                         // convert binary value to decimal representation\n-                        long bin_num = ::std::strtol(str.c_str(), NULL, 2);\n+                        long bin_num = std::strtol(str.c_str(), NULL, 2);\n \n-                        // create output string stream for binary value to be converted to\n-                        // string again\n-                        // TODO: if too slow, use sprintf\n-                        ::std::ostringstream ostr;\n-                        ostr << bin_num;\n-\n-                        // reassign string representation to converted value\n-                        str = ostr.str();\n+                        str = std::to_string(bin_num);\n \n                         // parse in type suffix if it exists\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        // parse_in_type_suffix (/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n                             rust_error_at(get_current_location(),\n@@ -1089,10 +1069,13 @@ namespace Rust {\n                     current_char = peek_input();\n \n                     // parse initial decimal literal - assuming integer\n-                    // TODO: test if works\n-                    parse_in_decimal(/*current_char, */ str, length);\n+                    // parse_in_decimal (/*current_char, */ str, length);\n+                    auto str_length_pair = parse_in_decimal();\n+                    str += str_length_pair.first;\n+                    length += str_length_pair.second;\n \n-                    // detect float literal - TODO: fix: \"242.\" is not recognised as a float literal\n+                    // detect float literal - TODO: fix: \"242.\" is not recognised as a\n+                    // float literal\n                     if (current_char == '.' && is_float_digit(peek_input(1))) {\n                         // float with a '.', parse another decimal into it\n \n@@ -1106,24 +1089,26 @@ namespace Rust {\n                         length++;\n \n                         // parse another decimal number for float\n-                        // TODO: test if works\n-                        parse_in_decimal(/*current_char, */ str, length);\n+                        auto str_length_pair2 = parse_in_decimal();\n+                        str += str_length_pair2.first;\n+                        length += str_length_pair2.second;\n \n                         // parse in exponent part if it exists\n-                        // test to see if this works:\n-                        parse_in_exponent_part(/*current_char, */ str, length);\n+                        auto exponent_part = parse_in_exponent_part();\n+                        str += exponent_part.first;\n+                        length += exponent_part.second;\n \n                         // parse in type suffix if it exists\n-                        // TODO: see if works:\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n                             rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for float literal\",\n                               get_type_hint_string(type_hint));\n                         }\n-\n                     } else if (current_char == '.' && check_valid_float_dot_end(peek_input(1))) {\n                         is_real = true;\n \n@@ -1138,13 +1123,6 @@ namespace Rust {\n \n                         // don't parse another decimal number for float\n \n-                        // parse in exponent part if it exists - shouldn't exist?\n-                        // parse_in_exponent_part(/*current_char, */ str, length);\n-\n-                        // parse in type suffix if it exists - shouldn't exist?\n-                        // TODO: see if works:\n-                        // parse_in_type_suffix(/*current_char, */ type_hint, length);\n-\n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n                             rust_error_at(get_current_location(),\n@@ -1155,10 +1133,16 @@ namespace Rust {\n                         is_real = true;\n \n                         // parse exponent part\n-                        parse_in_exponent_part(/*current_char, */ str, length);\n+                        // parse_in_exponent_part (/*current_char, */ str, length);\n+                        auto exponent_part = parse_in_exponent_part();\n+                        str += exponent_part.first;\n+                        length += exponent_part.second;\n \n                         // parse in type suffix if it exists\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        // parse_in_type_suffix (/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n@@ -1170,24 +1154,29 @@ namespace Rust {\n                         // is an integer\n \n                         // parse in type suffix if it exists\n-                        parse_in_type_suffix(/*current_char, */ type_hint, length);\n+                        // parse_in_type_suffix (/*current_char, */ type_hint, length);\n+                        auto type_suffix_pair = parse_in_type_suffix();\n+                        type_hint = type_suffix_pair.first;\n+                        length += type_suffix_pair.second;\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n                             rust_error_at(get_current_location(),\n-                              \"invalid type suffix '%s' for integer (decimal) literal\",\n+                              \"invalid type suffix '%s' for integer \"\n+                              \"(decimal) literal\",\n                               get_type_hint_string(type_hint));\n                         }\n                     }\n \n                     current_column += length;\n                 }\n \n+                str.shrink_to_fit();\n+\n                 // actually make the tokens\n-                if (is_real) {\n+                if (is_real)\n                     return Token::make_float(loc, str, type_hint);\n-                } else {\n+                else\n                     return Token::make_int(loc, str, type_hint);\n-                }\n             }\n \n             // string literals - not processed properly\n@@ -1200,28 +1189,32 @@ namespace Rust {\n                 int length = 1;\n                 current_char32 = test_peek_codepoint_input();\n \n-                // ok initial peek_codepoint seems to work without \"too long\"\n-\n                 while (current_char32.value != '\\n' && current_char32.value != '\"') {\n-                    // TODO: handle escapes and string continue\n                     if (current_char32.value == '\\\\') {\n                         // parse escape\n-                        parse_utf8_escape(length, current_char32, '\\'');\n-\n-                        // TODO: find a way to parse additional characters after the escape?\n-                        // return after parsing escape?\n-\n-                        str += current_char32;\n+                        auto utf8_escape_pair = parse_utf8_escape('\\'');\n+                        current_char32 = utf8_escape_pair.first;\n+                        //length += utf8_escape_pair.second;\n+\n+                        // TODO: need to fix length - after escape, the length of the line up to the next non-whitespace char of the string is added to length, which is not what we want - we want length to be replaced by that.\n+                        // possible option could if \"if escape_length_pair.first == 0, then length = escape_length_pair.second else length += escape_length_pair.second.\"\n+                        if (current_char32 == Codepoint(0))\n+                            length = utf8_escape_pair.second - 1; \n+                        else\n+                            length += utf8_escape_pair.second;\n+\n+                        if (current_char32 != Codepoint(0))\n+                            str += current_char32;\n \n-                        // required as parsing utf8 escape only changes current_char or something\n+                        // required as parsing utf8 escape only changes current_char\n+                        // or something\n                         current_char32 = test_peek_codepoint_input();\n \n                         continue;\n                     }\n \n                     length += test_get_input_codepoint_length();\n \n-                    // does this work? not technically a char. maybe have to convert to char series\n                     str += current_char32;\n                     test_skip_codepoint_input();\n                     current_char32 = test_peek_codepoint_input();\n@@ -1232,21 +1225,20 @@ namespace Rust {\n                 if (current_char32.value == '\\n') {\n                     rust_error_at(get_current_location(), \"unended string literal\");\n                 } else if (current_char32.value == '\"') {\n+                    current_column++;\n+                    \n                     skip_input();\n-\n                     current_char = peek_input();\n                 } else {\n-                    rust_unreachable();\n+                    gcc_unreachable();\n                 }\n \n+                str.shrink_to_fit();\n                 return Token::make_string(loc, str);\n-                // TODO: account for escapes and string continue\n-                // also, in rust a string is a series of unicode characters (4 bytes)\n             }\n \n             // char literal attempt\n             if (current_char == '\\'') {\n-                // rust chars are 4 bytes and have some weird unicode representation thing\n                 Codepoint current_char32;\n \n                 int length = 1;\n@@ -1256,10 +1248,9 @@ namespace Rust {\n                 // parse escaped char literal\n                 if (current_char32.value == '\\\\') {\n                     // parse escape\n-                    parse_utf8_escape(length, current_char32, '\\'');\n-\n-                    // TODO - this skip may not be needed?\n-                    // test_skip_codepoint_input();\n+                    auto utf8_escape_pair = parse_utf8_escape('\\'');\n+                    current_char32 = utf8_escape_pair.first;\n+                    length += utf8_escape_pair.second;\n \n                     if (test_peek_codepoint_input().value != '\\'') {\n                         rust_error_at(get_current_location(), \"unended char literal\");\n@@ -1271,15 +1262,13 @@ namespace Rust {\n \n                     current_column += length;\n \n-                    // TODO: FIX - char is actually 4 bytes in Rust (uint32) due to unicode\n                     return Token::make_char(loc, current_char32);\n                 } else {\n                     // current_char32 = test_peek_codepoint_input();\n                     test_skip_codepoint_input();\n \n                     if (test_peek_codepoint_input().value == '\\'') {\n                         // parse normal char literal\n-                        // TODO: FIX - char is actually 4 bytes in Rust (uint32) due to unicode\n \n                         // skip the ' character\n                         skip_input();\n@@ -1292,11 +1281,11 @@ namespace Rust {\n                     } else if (ISDIGIT(current_char32.value) || ISALPHA(current_char32.value)\n                                || current_char32.value == '_') {\n                         // parse lifetime name\n-                        ::std::string str;\n-                        // TODO: does this work properly?\n+                        std::string str;\n                         str += current_char32;\n \n-                        // TODO: fix lifetime name thing - actually, why am I even using utf-8 here?\n+                        /* TODO: fix lifetime name thing - actually, why am I even\n+                         * using utf-8 here? */\n \n                         int length = 1;\n \n@@ -1313,6 +1302,7 @@ namespace Rust {\n \n                         current_column += length;\n \n+                        str.shrink_to_fit();\n                         return Token::make_lifetime(loc, str);\n                     } else {\n                         rust_error_at(get_current_location(), \"expected ' after character constant\");\n@@ -1327,24 +1317,25 @@ namespace Rust {\n     }\n \n     // Shitty pass-by-reference way of parsing in type suffix.\n-    bool Lexer::parse_in_type_suffix(\n-      /*char& current_char, */ PrimitiveCoreType& type_hint, int& length) {\n-        ::std::string suffix;\n+    std::pair<PrimitiveCoreType, int> Lexer::parse_in_type_suffix() {\n+        std::string suffix;\n         suffix.reserve(5);\n \n+        int additional_length_offset = 0;\n+\n         // get suffix\n         while (ISALPHA(current_char) || ISDIGIT(current_char) || current_char == '_') {\n             if (current_char == '_') {\n                 // don't add _ to suffix\n                 skip_input();\n                 current_char = peek_input();\n \n-                length++;\n+                additional_length_offset++;\n \n                 continue;\n             }\n \n-            length++;\n+            additional_length_offset++;\n \n             suffix += current_char;\n             skip_input();\n@@ -1353,52 +1344,52 @@ namespace Rust {\n \n         if (suffix.empty()) {\n             // no type suffix: do nothing but also no error\n-            return false;\n+            return std::make_pair(CORETYPE_UNKNOWN, additional_length_offset);\n         } else if (suffix == \"f32\") {\n-            type_hint = CORETYPE_F32;\n+            return std::make_pair(CORETYPE_F32, additional_length_offset);\n         } else if (suffix == \"f64\") {\n-            type_hint = CORETYPE_F64;\n+            return std::make_pair(CORETYPE_F64, additional_length_offset);\n         } else if (suffix == \"i8\") {\n-            type_hint = CORETYPE_I8;\n+            return std::make_pair(CORETYPE_I8, additional_length_offset);\n         } else if (suffix == \"i16\") {\n-            type_hint = CORETYPE_I16;\n+            return std::make_pair(CORETYPE_I16, additional_length_offset);\n         } else if (suffix == \"i32\") {\n-            type_hint = CORETYPE_I32;\n+            return std::make_pair(CORETYPE_I32, additional_length_offset);\n         } else if (suffix == \"i64\") {\n-            type_hint = CORETYPE_I64;\n+            return std::make_pair(CORETYPE_I64, additional_length_offset);\n         } else if (suffix == \"i128\") {\n-            type_hint = CORETYPE_I128;\n+            return std::make_pair(CORETYPE_I128, additional_length_offset);\n         } else if (suffix == \"isize\") {\n-            type_hint = CORETYPE_ISIZE;\n+            return std::make_pair(CORETYPE_ISIZE, additional_length_offset);\n         } else if (suffix == \"u8\") {\n-            type_hint = CORETYPE_U8;\n+            return std::make_pair(CORETYPE_U8, additional_length_offset);\n         } else if (suffix == \"u16\") {\n-            type_hint = CORETYPE_U16;\n+            return std::make_pair(CORETYPE_U16, additional_length_offset);\n         } else if (suffix == \"u32\") {\n-            type_hint = CORETYPE_U32;\n+            return std::make_pair(CORETYPE_U32, additional_length_offset);\n         } else if (suffix == \"u64\") {\n-            type_hint = CORETYPE_U64;\n+            return std::make_pair(CORETYPE_U64, additional_length_offset);\n         } else if (suffix == \"u128\") {\n-            type_hint = CORETYPE_U128;\n+            return std::make_pair(CORETYPE_U128, additional_length_offset);\n         } else if (suffix == \"usize\") {\n-            type_hint = CORETYPE_USIZE;\n+            return std::make_pair(CORETYPE_USIZE, additional_length_offset);\n         } else {\n             rust_error_at(get_current_location(), \"unknown number suffix '%s'\", suffix.c_str());\n \n-            return false;\n+            return std::make_pair(CORETYPE_UNKNOWN, additional_length_offset);\n         }\n-\n-        return true;\n     }\n \n-    void Lexer::parse_in_exponent_part(/*char& current_char, */ std::string& str, int& length) {\n+    std::pair<std::string, int> Lexer::parse_in_exponent_part() {\n+        int additional_length_offset = 0;\n+        std::string str;\n         if (current_char == 'E' || current_char == 'e') {\n             // add exponent to string as strtod works with it\n             str += current_char;\n             skip_input();\n             current_char = peek_input();\n \n-            length++;\n+            additional_length_offset++;\n \n             // special - and + handling\n             if (current_char == '-') {\n@@ -1407,46 +1398,55 @@ namespace Rust {\n                 skip_input();\n                 current_char = peek_input();\n \n-                length++;\n+                additional_length_offset++;\n             } else if (current_char == '+') {\n                 // don't add + but still skip input\n                 skip_input();\n                 current_char = peek_input();\n \n-                length++;\n+                additional_length_offset++;\n             }\n \n             // parse another decimal number for exponent\n-            parse_in_decimal(/*current_char, */ str, length);\n+            auto str_length_pair = parse_in_decimal();\n+            str += str_length_pair.first;\n+            additional_length_offset += str_length_pair.second;\n         }\n+        return std::make_pair(str, additional_length_offset);\n     }\n \n-    void Lexer::parse_in_decimal(/*char& current_char, */ std::string& str, int& length) {\n+    std::pair<std::string, int> Lexer::parse_in_decimal() {\n+        int additional_length_offset = 0;\n+        std::string str;\n         while (ISDIGIT(current_char) || current_char == '_') {\n             if (current_char == '_') {\n                 // don't add _ to number\n                 skip_input();\n                 current_char = peek_input();\n \n-                length++;\n+                additional_length_offset++;\n \n                 continue;\n             }\n \n-            length++;\n+            additional_length_offset++;\n \n             str += current_char;\n             skip_input();\n             current_char = peek_input();\n         }\n+        return std::make_pair(str, additional_length_offset);\n     }\n \n-    // Replace all assorted parse_x_escape with this? Avoids the backwards/peek issue.\n-    bool Lexer::parse_escape(int& length, char& output_char, char opening_char) {\n+    /* Parses escapes (and string continues) in \"byte\" strings and characters. Does not support unicode. */\n+    std::pair<char, int> Lexer::parse_escape(char opening_char) {\n+        int additional_length_offset = 0;\n+        char output_char = 0;\n+\n         // skip to actual letter\n         skip_input();\n         current_char = peek_input();\n-        length++;\n+        additional_length_offset++;\n \n         switch (current_char) {\n             case 'x': {\n@@ -1456,9 +1456,9 @@ namespace Rust {\n                 // first hex char\n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n-                if (!ISXDIGIT(current_char)) {\n+                if (!is_x_digit(current_char)) {\n                     rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n@@ -1467,23 +1467,21 @@ namespace Rust {\n                 // second hex char\n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n-                if (!ISXDIGIT(current_char)) {\n+                if (!is_x_digit(current_char)) {\n                     rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n-                long hexLong = ::std::strtol(hexNum, NULL, 16);\n+                long hexLong = std::strtol(hexNum, NULL, 16);\n \n-                if (hexLong > 127)\n+                if (hexLong > 255 || hexLong < 0)\n                     rust_error_at(get_current_location(),\n-                      \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\x7F'\", hexNum);\n-                // gcc_assert(hexLong < 128); // as ascii\n+                      \"byte \\\\x escape '\\\\x%s' out of range - allows up to '\\\\xFF'\", hexNum);\n                 char hexChar = static_cast<char>(hexLong);\n \n-                // TODO: fix - does this actually give the right character?\n                 output_char = hexChar;\n             } break;\n             case 'n':\n@@ -1507,28 +1505,34 @@ namespace Rust {\n             case '\"':\n                 output_char = '\"';\n                 break;\n-            case 'u': {\n+            case 'u':\n+                rust_error_at(get_current_location(),\n+                  \"cannot have a unicode escape \\\\u in a byte %s!\",\n+                  opening_char == '\\'' ? \"character\" : \"string\");\n+                return std::make_pair(output_char, additional_length_offset);\n+#if 0\n+\t\t\t{\n                 // TODO: shouldn't be used with this - use parse_utf8_escape\n \n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n                 bool need_close_brace = false;\n \n-                // TODO: rustc lexer doesn't seem to allow not having { but mrustc lexer does? look at\n-                // spec?\n+                // TODO: rustc lexer doesn't seem to allow not having { but mrustc lexer\n+                // does? look at spec?\n                 if (current_char == '{') {\n                     need_close_brace = true;\n \n                     skip_input();\n                     current_char = peek_input();\n-                    length++;\n+                    additional_length_offset++;\n                 }\n \n                 // parse unicode escape\n                 // 1-6 hex digits?\n-                ::std::string num_str;\n+                std::string num_str;\n                 num_str.reserve(6);\n \n                 // test adding number directly\n@@ -1541,20 +1545,20 @@ namespace Rust {\n                         skip_input();\n                         current_char = peek_input();\n \n-                        length++;\n+                        additional_length_offset++;\n \n                         continue;\n                     }\n \n-                    length++;\n+                    additional_length_offset++;\n \n                     // add raw hex numbers\n                     num_str += current_char;\n \n                     // test adding number directly\n                     char tmp[2] = { current_char, 0 };\n                     test_val *= 16;\n-                    test_val += ::std::strtol(tmp, NULL, 16);\n+                    test_val += std::strtol(tmp, NULL, 16);\n \n                     skip_input();\n                     current_char = peek_input();\n@@ -1565,18 +1569,21 @@ namespace Rust {\n                     // actually an error\n                     rust_error_at(\n                       get_current_location(), \"expected terminating '}' in unicode escape\");\n-                    return false;\n+                    // return false;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 }\n \n                 // ensure 1-6 hex characters\n                 if (num_str.length() > 6 || num_str.length() < 1) {\n                     rust_error_at(get_current_location(),\n-                      \"unicode escape should be between 1 and 6 hex characters; it is %lu\",\n+                      \"unicode escape should be between 1 and 6 hex \"\n+                      \"characters; it is %lu\",\n                       num_str.length());\n-                    return false;\n+                    // return false;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 }\n \n-                long hex_num = ::std::strtol(num_str.c_str(), NULL, 16);\n+                long hex_num = std::strtol(num_str.c_str(), NULL, 16);\n \n                 // as debug, check hex_num = test_val\n                 if (hex_num > 255) {\n@@ -1586,12 +1593,14 @@ namespace Rust {\n                 }\n \n                 // make output_char the value - UTF-8?\n-                // TODO: actually make this work - output char must be 4 bytes, do I need a string for\n-                // this?\n+                // TODO: actually make this work - output char must be 4 bytes, do I\n+                // need a string for this?\n                 output_char = static_cast</*uint32_t*/ char>(hex_num);\n \n-                return true;\n+                // return true;\n+                return std::make_pair(output_char, additional_length_offset);\n             } break;\n+#endif\n             case '\\r':\n             case '\\n':\n                 // string continue\n@@ -1600,10 +1609,10 @@ namespace Rust {\n                         current_line++;\n                         current_column = 1;\n                         // tell line_table that new line starts\n-                        linemap_line_start(::line_table, current_line, max_column_hint);\n+                        line_map->start_line(current_line, max_column_hint);\n \n                         // reset \"length\"\n-                        length = 1;\n+                        additional_length_offset = 1;\n \n                         // get next char\n                         skip_input();\n@@ -1614,45 +1623,56 @@ namespace Rust {\n \n                     skip_input();\n                     current_char = peek_input();\n-                    length++;\n+                    additional_length_offset++;\n                 }\n \n-                if (current_char == '\\\\') {\n-                    parse_escape(length, output_char, opening_char);\n-                    return true;\n-                } else if (current_char == opening_char) {\n+                // shouldn't need this\n+#if 0\n+                if (current_char == opening_char) {\n                     // TODO: does this skip the ' or \" character? It shouldn't.\n                     output_char = 0;\n-                    return true;\n+                    // return true;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 } else {\n-                    output_char = current_char;\n+                    // TODO: shouldn't this make output_char null so that it isn't added to string?\n+                    // or check for escape being zero?\n+                    output_char = /*current_char*/0;\n \n                     // TODO: test has right result\n                     /*skip_input();\n                     current_char = peek_input();*/\n \n-                    return true;\n+                    // return true;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 }\n+#endif\n+                return std::make_pair(0, additional_length_offset);\n             default:\n                 rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n-                return false;\n+                // return false;\n+                return std::make_pair(output_char, additional_length_offset);\n                 break;\n         }\n-        // all non-special cases (unicode, string continue) should skip their used char\n+        // all non-special cases (string continue) should skip their used char\n         skip_input();\n         current_char = peek_input();\n-        length++;\n+        additional_length_offset++;\n \n         // returns true if parsing was successful\n-        return true;\n+        // return true;\n+        return std::make_pair(output_char, additional_length_offset);\n     }\n \n-    bool Lexer::parse_utf8_escape(int& length, Codepoint& output_char, char opening_char) {\n+    // Parses an escape (or string continue) in a string or character. Supports unicode escapes.\n+    std::pair<Codepoint, int> Lexer::parse_utf8_escape(char opening_char) {\n+        Codepoint output_char;\n+        int additional_length_offset = 0;\n+\n         // skip to actual letter\n         skip_input();\n         current_char = peek_input();\n-        length++;\n+        additional_length_offset++;\n \n         switch (current_char) {\n             case 'x': {\n@@ -1662,9 +1682,9 @@ namespace Rust {\n                 // first hex char\n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n-                if (!ISXDIGIT(current_char)) {\n+                if (!is_x_digit(current_char)) {\n                     rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n@@ -1673,23 +1693,22 @@ namespace Rust {\n                 // second hex char\n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n-                if (!ISXDIGIT(current_char)) {\n+                if (!is_x_digit(current_char)) {\n                     rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n-                long hexLong = ::std::strtol(hexNum, NULL, 16);\n+                long hexLong = std::strtol(hexNum, NULL, 16);\n \n                 if (hexLong > 127)\n                     rust_error_at(get_current_location(),\n                       \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\x7F'\", hexNum);\n                 // gcc_assert(hexLong < 128); // as ascii\n                 char hexChar = static_cast<char>(hexLong);\n \n-                // TODO: fix - does this actually give the right character?\n                 output_char = hexChar;\n             } break;\n             case 'n':\n@@ -1716,50 +1735,38 @@ namespace Rust {\n             case 'u': {\n                 skip_input();\n                 current_char = peek_input();\n-                length++;\n+                additional_length_offset++;\n \n                 bool need_close_brace = false;\n-\n-                // TODO: rustc lexer doesn't seem to allow not having { but mrustc lexer does? look at\n-                // spec?\n                 if (current_char == '{') {\n                     need_close_brace = true;\n \n                     skip_input();\n                     current_char = peek_input();\n-                    length++;\n+                    additional_length_offset++;\n                 }\n \n-                // parse unicode escape\n-                // 1-6 hex digits?\n-                ::std::string num_str;\n+                // parse unicode escape - 1-6 hex digits\n+                std::string num_str;\n                 num_str.reserve(6);\n \n-                // test adding number directly\n-                uint32_t test_val;\n-\n                 // loop through to add entire hex number to string\n                 while (is_x_digit(current_char) || current_char == '_') {\n                     if (current_char == '_') {\n                         // don't add _ to number\n                         skip_input();\n                         current_char = peek_input();\n \n-                        length++;\n+                        additional_length_offset++;\n \n                         continue;\n                     }\n \n-                    length++;\n+                    additional_length_offset++;\n \n                     // add raw hex numbers\n                     num_str += current_char;\n \n-                    // test adding number directly\n-                    char tmp[2] = { current_char, 0 };\n-                    test_val *= 16;\n-                    test_val += ::std::strtol(tmp, NULL, 16);\n-\n                     skip_input();\n                     current_char = peek_input();\n                 }\n@@ -1769,36 +1776,38 @@ namespace Rust {\n                     if (current_char == '}') {\n                         skip_input();\n                         current_char = peek_input();\n-                        length++;\n+                        additional_length_offset++;\n                     } else {\n                         // actually an error\n                         rust_error_at(\n                           get_current_location(), \"expected terminating '}' in unicode escape\");\n-                        return false;\n+                        // return false;\n+                        return std::make_pair(output_char, additional_length_offset);\n                     }\n                 }\n \n                 // ensure 1-6 hex characters\n                 if (num_str.length() > 6 || num_str.length() < 1) {\n                     rust_error_at(get_current_location(),\n-                      \"unicode escape should be between 1 and 6 hex characters; it is %lu\",\n+                      \"unicode escape should be between 1 and 6 hex \"\n+                      \"characters; it is %lu\",\n                       num_str.length());\n-                    return false;\n+                    // return false;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 }\n \n-                long hex_num = ::std::strtol(num_str.c_str(), NULL, 16);\n+                long hex_num = std::strtol(num_str.c_str(), NULL, 16);\n \n                 // assert fits a uint32_t\n-                rust_assert(hex_num < 4294967296);\n+                gcc_assert(hex_num < 4294967296);\n \n-                // ok can't figure out how to just convert to codepoint or use \"this\" so create new\n-                // one\n                 output_char = Codepoint(static_cast<uint32_t>(hex_num));\n \n-                // TODO: what is being outputted? the escape code for the unicode char (unicode\n-                // number) or the character number?\n+                // TODO: what is being outputted? the escape code for the unicode char\n+                // (unicode number) or the character number?\n \n-                return true;\n+                // return true;\n+                return std::make_pair(output_char, additional_length_offset);\n             } break;\n             case '\\r':\n             case '\\n':\n@@ -1808,10 +1817,10 @@ namespace Rust {\n                         current_line++;\n                         current_column = 1;\n                         // tell line_table that new line starts\n-                        linemap_line_start(::line_table, current_line, max_column_hint);\n+                        line_map->start_line(current_line, max_column_hint);\n \n                         // reset \"length\"\n-                        length = 1;\n+                        additional_length_offset = 1;\n \n                         // get next char\n                         skip_input();\n@@ -1822,38 +1831,39 @@ namespace Rust {\n \n                     skip_input();\n                     current_char = peek_input();\n-                    length++;\n+                    additional_length_offset++;\n                 }\n \n-                if (current_char == '\\\\') {\n-                    parse_utf8_escape(length, output_char, opening_char);\n-                    return true;\n-                } else if (current_char == opening_char) {\n-                    // TODO: does this skip the ' or \" character? It shouldn't.\n+                // shouldn't need this\n+#if 0\n+                if (current_char == opening_char) {\n                     output_char = 0;\n-                    return true;\n+                    // return true;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 } else {\n-                    output_char = current_char;\n+                    output_char = /*current_char*/0;\n \n-                    // TODO: test has right result\n-                    /*skip_input();\n-                    current_char = peek_input();*/\n-\n-                    return true;\n+                    // return true;\n+                    return std::make_pair(output_char, additional_length_offset);\n                 }\n+#endif\n+                return std::make_pair(0, additional_length_offset);\n             default:\n                 rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n-                return false;\n+                // return false;\n+                return std::make_pair(output_char, additional_length_offset);\n                 break;\n         }\n-        // all non-special cases (unicode, string continue) should skip their used char\n+        /* all non-special cases (unicode, string continue) should skip their used\n+         * char */\n         skip_input();\n         current_char = peek_input();\n-        length++;\n+        additional_length_offset++;\n \n         // returns true if parsing was successful\n-        return true;\n+        // return true;\n+        return std::make_pair(output_char, additional_length_offset);\n     }\n \n #if 0\n@@ -2102,6 +2112,7 @@ namespace Rust {\n     }\n #endif\n \n+    // Returns the length of the codepoint at the current position.\n     int Lexer::test_get_input_codepoint_length() {\n         uint8_t input = peek_input();\n \n@@ -2138,8 +2149,8 @@ namespace Rust {\n             // return 0xFFFE;\n \n             /*uint32_t output\n-              = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 & 0x3F) << 0);\n-            return output;*/\n+              = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 & 0x3F) <<\n+            0); return output;*/\n             return 3;\n         } else if ((input & 0xF8) == 0xF0) {\n             // 4 bytes\n@@ -2168,7 +2179,7 @@ namespace Rust {\n         }\n     }\n \n-    // TODO: rewrite lexing system to use utf-8 \"codepoints\" rather than bytes?\n+    // Returns the codepoint at the current position.\n     Codepoint Lexer::test_peek_codepoint_input() {\n         uint8_t input = peek_input();\n \n@@ -2224,7 +2235,7 @@ namespace Rust {\n \n     void Lexer::test_skip_codepoint_input() {\n         int toSkip = test_get_input_codepoint_length();\n-        rust_assert(toSkip >= 1);\n+        gcc_assert(toSkip >= 1);\n \n         skip_input(toSkip - 1);\n     }\n@@ -2263,8 +2274,8 @@ namespace Rust {\n                 return 0;\n \n             /*uint32_t output\n-              = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 & 0x3F) << 0);\n-            return output;*/\n+              = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 & 0x3F) <<\n+            0); return output;*/\n             return 3;\n         } else if ((input & 0xF8) == 0xF0) {\n             // 4 bytes\n@@ -2293,20 +2304,22 @@ namespace Rust {\n         }\n     }\n \n-    // peeks the codepoint input at n codepoints ahead of current codepoint - try not to use\n+    // peeks the codepoint input at n codepoints ahead of current codepoint - try\n+    // not to use\n     Codepoint Lexer::test_peek_codepoint_input(int n) {\n         int totalOffset = 0;\n \n         // add up all offsets into total offset? does this do what I want?\n         for (int i = 0; i < n; i++) {\n             totalOffset += test_get_input_codepoint_n_length(totalOffset);\n         }\n-        // issues: this would have (at least) O(n) lookup time, not O(1) like the rest?\n+        // issues: this would have (at least) O(n) lookup time, not O(1) like the\n+        // rest?\n \n         // TODO: implement if still needed\n \n         // error out of function as it is not implemented\n-        rust_assert(1 == 0);\n+        gcc_assert(1 == 0);\n         return { 0 };\n         /*\n                 uint8_t input = peek_input();\n@@ -2336,9 +2349,8 @@ namespace Rust {\n                         return 0xFFFE;\n \n                     uint32_t output\n-                      = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 & 0x3F) << 0);\n-                    return output;\n-                } else if ((input & 0xF8) == 0xF0) {\n+                      = ((input & 0x0F) << 12) | ((input2 & 0x3F) << 6) | ((input3 &\n+           0x3F) << 0); return output; } else if ((input & 0xF8) == 0xF0) {\n                     // 4 bytes\n                     uint8_t input2 = peek_input(1);\n                     if ((input2 & 0xC0) != 0x80)\n@@ -2353,11 +2365,9 @@ namespace Rust {\n                         return 0xFFFE;\n \n                     uint32_t output = ((input & 0x07) << 18) | ((input2 & 0x3F) << 12)\n-                                      | ((input3 & 0x3F) << 6) | ((input4 & 0x3F) << 0);\n-                    return output;\n-                } else {\n-                    rust_error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n-                    return 0xFFFE;\n+                                      | ((input3 & 0x3F) << 6) | ((input4 & 0x3F) <<\n+           0); return output; } else { rust_error_at(get_current_location(), \"invalid\n+           UTF-8 (too long)\"); return 0xFFFE;\n                 }*/\n     }\n-}\n+} // namespace Rust"}, {"sha": "52207532d30d20dccfa7c641f614796f924e9540", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -5,6 +5,8 @@\n #include \"rust-buffered-queue.h\"\n #include \"rust-token.h\"\n \n+#include <utility>\n+\n namespace Rust {\n class Lexer\n {\n@@ -31,35 +33,39 @@ class Lexer\n   // ok maybe all these may mean the lexer structure needs to be rethought\n   /* separated into functions because main method was too long, but they rely on\n    * and change state in the lexer, so variables must be passed by reference. */\n-  inline void parse_in_decimal (/*char& current_char, */ std::string &str,\n-\t\t\t\tint &length);\n-  inline void parse_in_exponent_part (/*char& current_char, */ std::string &str,\n-\t\t\t\t      int &length);\n-  inline bool parse_in_type_suffix (\n-    /*char& current_char, */ PrimitiveCoreType &type_hint, int &length);\n-  inline bool parse_ascii_escape (/*char& current_char, */ int &length,\n-\t\t\t\t  char &output_char);\n-  inline bool parse_quote_escape (/*char& current_char, */ int &length,\n-\t\t\t\t  char &output_char);\n-  inline bool parse_unicode_escape (\n-    /*char& current_char, */ int &length, Codepoint &output_char);\n-  inline bool parse_byte_escape (/*char& current_char, */ int &length,\n-\t\t\t\t char &output_char);\n-  inline bool parse_escape (int &length, char &output_char, char opening_char);\n-  inline bool parse_utf8_escape (int &length, Codepoint &output_char,\n-\t\t\t\t char opening_char);\n-  inline int test_get_input_codepoint_length ();\n-  inline int test_get_input_codepoint_n_length (int n_start_offset);\n-  inline Codepoint test_peek_codepoint_input ();\n-  inline Codepoint test_peek_codepoint_input (\n+  std::pair<std::string, int> parse_in_decimal ();\n+  std::pair<std::string, int> parse_in_exponent_part ();\n+  std::pair<PrimitiveCoreType, int> parse_in_type_suffix ();\n+  /*bool parse_ascii_escape (int &length,\n+\t\t\t\t  char &output_char);*/\n+  /*bool parse_quote_escape (char& current_char, int &length,\n+\t\t\t\t  char &output_char);*/\n+  /*bool parse_unicode_escape (\n+    char& current_char, int &length, Codepoint &output_char);*/\n+  /*bool parse_byte_escape (char& current_char, int &length,\n+\t\t\t\t char &output_char);*/\n+  std::pair<char, int> parse_escape (char opening_char);\n+  std::pair<Codepoint, int> parse_utf8_escape (char opening_char);\n+  int test_get_input_codepoint_length ();\n+  int test_get_input_codepoint_n_length (int n_start_offset);\n+  Codepoint test_peek_codepoint_input ();\n+  Codepoint test_peek_codepoint_input (\n     int n); // maybe can use get_input_codepoint_length to get starting index\n-  inline void test_skip_codepoint_input ();\n+  void test_skip_codepoint_input ();\n \n public:\n   // Construct lexer with input file and filename provided\n   Lexer (const char *filename, FILE *input, Linemap *linemap);\n   ~Lexer ();\n \n+  // don't allow copy semantics (for now, at least)\n+  Lexer (const Lexer &other) = delete;\n+  Lexer &operator= (const Lexer &other) = delete;\n+\n+  // enable move semantics\n+  Lexer (Lexer &&other) = default;\n+  Lexer &operator= (Lexer &&other) = default;\n+\n   // Returns token n tokens ahead of current position.\n   const_TokenPtr peek_token (int n);\n   // Peeks the current token."}, {"sha": "9dd5f0b9f41194ab8c15034bb58a152b92452212", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -53,7 +53,6 @@ enum PrimitiveCoreType\n \n // note that abstract, async, become, box, do, final, macro, override, priv,\n // try, typeof, unsized, virtual, and yield are unused\n-// TODO finish converting to rust keywords\n #define RS_TOKEN_LIST                                                          \\\n   RS_TOKEN (FIRST_TOKEN, \"<first-token-marker>\")                               \\\n   RS_TOKEN (END_OF_FILE, \"end of file\")                                        \\"}, {"sha": "5ee76bde556d4f5969bb90eda9e6ecca893d4a79", "filename": "gcc/rust/rust-linemap.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Frust-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Frust-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.cc?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -72,7 +72,8 @@ Gcc_linemap::to_string (Location location)\n \n   // Strip the source file down to the base file, to reduce clutter.\n   std::stringstream ss;\n-  ss << lbasename (path) << \":\" << SOURCE_LINE (lmo, location.gcc_location ());\n+  ss << lbasename (path) << \":\" << SOURCE_LINE (lmo, location.gcc_location ()) \n+    << \":\" << SOURCE_COLUMN (lmo, location.gcc_location ());\n   return ss.str ();\n }\n "}, {"sha": "29933d5a12faed6e7313974b92d3353d4a61fa9b", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b758ec724cc06cb866a72ce17dbfd8a426cf21db/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=b758ec724cc06cb866a72ce17dbfd8a426cf21db", "patch": "@@ -340,7 +340,7 @@ Session::enable_dump (::std::string arg)\n     {\n       error_at (\n \tUNKNOWN_LOCATION,\n-\t\"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n+\t\"dumping all is not supported as of now. choose 'lex', 'parse', or 'target_options\");\n       return false;\n     }\n   else if (arg == \"lex\")\n@@ -379,13 +379,13 @@ Session::enable_dump (::std::string arg)\n   else if (arg == \"\")\n     {\n       error_at (UNKNOWN_LOCATION,\n-\t\t\"dump option was not given a name. choose 'lex' or 'parse'\");\n+\t\t\"dump option was not given a name. choose 'lex', 'parse', or 'target_options'\");\n       return false;\n     }\n   else\n     {\n       error_at (UNKNOWN_LOCATION,\n-\t\t\"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n+\t\t\"dump option '%s' was unrecognised. choose 'lex', 'parse', or 'target_options\",\n \t\targ.c_str ());\n       return false;\n     }"}]}