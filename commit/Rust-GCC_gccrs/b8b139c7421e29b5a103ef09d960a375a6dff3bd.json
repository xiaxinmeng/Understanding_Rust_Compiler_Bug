{"sha": "b8b139c7421e29b5a103ef09d960a375a6dff3bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhiMTM5Yzc0MjFlMjliNWExMDNlZjA5ZDk2MGEzNzVhNmRmZjNiZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-07-15T00:09:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-07-15T00:09:00Z"}, "message": "expr.c (expand_assignment): Reenable bitfield += optimizations.\n\n\t* expr.c (expand_assignment): Reenable bitfield += optimizations.\n\tUse alias set 0 for memory, do proper mode calculations and adjust\n\taddress for memories.\n\n\t* gcc.c-torture/execute/20040709-1.c: New test.\n\t* gcc.c-torture/execute/20040709-2.c: New test.\n\nFrom-SVN: r84722", "tree": {"sha": "78c132b5b29ebc1362f28bd7a6454e0d1cb0d045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c132b5b29ebc1362f28bd7a6454e0d1cb0d045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8b139c7421e29b5a103ef09d960a375a6dff3bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b139c7421e29b5a103ef09d960a375a6dff3bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b139c7421e29b5a103ef09d960a375a6dff3bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b139c7421e29b5a103ef09d960a375a6dff3bd/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa3c6dc1604edf2119da7cf6d39c6afab3a676d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa3c6dc1604edf2119da7cf6d39c6afab3a676d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa3c6dc1604edf2119da7cf6d39c6afab3a676d7"}], "stats": {"total": 393, "additions": 372, "deletions": 21}, "files": [{"sha": "675e22b5a6b82c6a65853fe125ff8fad542f4114", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8b139c7421e29b5a103ef09d960a375a6dff3bd", "patch": "@@ -1,3 +1,9 @@\n+2004-07-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* expr.c (expand_assignment): Reenable bitfield += optimizations.\n+\tUse alias set 0 for memory, do proper mode calculations and adjust\n+\taddress for memories.\n+\n 2004-07-14  Per Bothner  <per@bothner.com>\n \n \t* input.h:  If USE_MAPPED_LOCATION, define separate expanded_location"}, {"sha": "302c4ee1607f741df0d67f259759e1fe443cc0f0", "filename": "gcc/expr.c", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b8b139c7421e29b5a103ef09d960a375a6dff3bd", "patch": "@@ -3528,18 +3528,16 @@ expand_assignment (tree to, tree from, int want_value)\n \t  MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t}\n \n-      /* Disabled temporarily.  GET_MODE (to_rtx) is often not the right\n-\t mode.  */\n-      while (0 && mode1 == VOIDmode && !want_value\n-\t     && bitpos + bitsize <= BITS_PER_WORD\n-\t     && bitsize < BITS_PER_WORD\n+      /* Optimize bitfld op= val in certain cases.  */\n+      while (mode1 == VOIDmode && !want_value\n+\t     && bitsize > 0 && bitsize < BITS_PER_WORD\n \t     && GET_MODE_BITSIZE (GET_MODE (to_rtx)) <= BITS_PER_WORD\n \t     && !TREE_SIDE_EFFECTS (to)\n \t     && !TREE_THIS_VOLATILE (to))\n \t{\n \t  tree src, op0, op1;\n-\t  rtx value;\n-\t  HOST_WIDE_INT count = bitpos;\n+\t  rtx value, str_rtx = to_rtx;\n+\t  HOST_WIDE_INT bitpos1 = bitpos;\n \t  optab binop;\n \n \t  src = from;\n@@ -3555,45 +3553,87 @@ expand_assignment (tree to, tree from, int want_value)\n \t  if (! operand_equal_p (to, op0, 0))\n \t    break;\n \n+\t  if (MEM_P (str_rtx))\n+\t    {\n+\t      enum machine_mode mode = GET_MODE (str_rtx);\n+\t      HOST_WIDE_INT offset1;\n+\n+\t      if (GET_MODE_BITSIZE (mode) == 0\n+\t\t  || GET_MODE_BITSIZE (mode) > BITS_PER_WORD)\n+\t\tmode = word_mode;\n+\t      mode = get_best_mode (bitsize, bitpos1, MEM_ALIGN (str_rtx),\n+\t\t\t\t    mode, 0);\n+\t      if (mode == VOIDmode)\n+\t\tbreak;\n+\n+\t      offset1 = bitpos1;\n+\t      bitpos1 %= GET_MODE_BITSIZE (mode);\n+\t      offset1 = (offset1 - bitpos1) / BITS_PER_UNIT;\n+\t      str_rtx = adjust_address (str_rtx, mode, offset1);\n+\t    }\n+\t  else if (!REG_P (str_rtx) && GET_CODE (str_rtx) != SUBREG)\n+\t    break;\n+\n+\t  /* If the bit field covers the whole REG/MEM, store_field\n+\t     will likely generate better code.  */\n+\t  if (bitsize >= GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n+\t    break;\n+\n+\t  /* We can't handle fields split accross multiple entities.  */\n+\t  if (bitpos1 + bitsize > GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n+\t    break;\n+\n \t  if (BYTES_BIG_ENDIAN)\n-\t    count = GET_MODE_BITSIZE (GET_MODE (to_rtx)) - bitpos - bitsize;\n+\t    bitpos1 = GET_MODE_BITSIZE (GET_MODE (str_rtx)) - bitpos1\n+\t\t      - bitsize;\n \n \t  /* Special case some bitfield op= exp.  */\n \t  switch (TREE_CODE (src))\n \t    {\n \t    case PLUS_EXPR:\n \t    case MINUS_EXPR:\n-\t      if (count <= 0)\n-\t        break;\n-\n \t      /* For now, just optimize the case of the topmost bitfield\n \t\t where we don't need to do any masking and also\n \t\t 1 bit bitfields where xor can be used.\n \t\t We might win by one instruction for the other bitfields\n \t\t too if insv/extv instructions aren't used, so that\n \t\t can be added later.  */\n-\t      if (count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx))\n+\t      if (bitpos1 + bitsize != GET_MODE_BITSIZE (GET_MODE (str_rtx))\n \t\t  && (bitsize != 1 || TREE_CODE (op1) != INTEGER_CST))\n \t\tbreak;\n-\t      value = expand_expr (op1, NULL_RTX, VOIDmode, 0);\n+\t      value = expand_expr (op1, NULL_RTX, GET_MODE (str_rtx), 0);\n+\t      value = convert_modes (GET_MODE (str_rtx),\n+\t\t\t\t     TYPE_MODE (TREE_TYPE (op1)), value,\n+\t\t\t\t     TYPE_UNSIGNED (TREE_TYPE (op1)));\n+\n+\t      /* We may be accessing data outside the field, which means\n+\t\t we can alias adjacent data.  */\n+\t      if (MEM_P (str_rtx))\n+\t\t{\n+\t\t  str_rtx = shallow_copy_rtx (str_rtx);\n+\t\t  set_mem_alias_set (str_rtx, 0);\n+\t\t  set_mem_expr (str_rtx, 0);\n+\t\t}\n+\n \t      binop = TREE_CODE (src) == PLUS_EXPR ? add_optab : sub_optab;\n \t      if (bitsize == 1\n-\t\t  && count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n+\t\t  && bitpos1 + bitsize != GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n \t\t{\n-\t\t  value = expand_and (GET_MODE (to_rtx), value, const1_rtx,\n+\t\t  value = expand_and (GET_MODE (str_rtx), value, const1_rtx,\n \t\t\t\t      NULL_RTX);\n \t\t  binop = xor_optab;\n \t\t}\n-\t      value = expand_shift (LSHIFT_EXPR, GET_MODE (to_rtx),\n-\t\t\t\t    value, build_int_2 (count, 0),\n+\t      value = expand_shift (LSHIFT_EXPR, GET_MODE (str_rtx),\n+\t\t\t\t    value, build_int_2 (bitpos1, 0),\n \t\t\t\t    NULL_RTX, 1);\n-\t      result = expand_binop (GET_MODE (to_rtx), binop, to_rtx,\n-\t\t\t\t     value, to_rtx, 1, OPTAB_WIDEN);\n-\t      if (result != to_rtx)\n-\t\temit_move_insn (to_rtx, result);\n+\t      result = expand_binop (GET_MODE (str_rtx), binop, str_rtx,\n+\t\t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n+\t      if (result != str_rtx)\n+\t\temit_move_insn (str_rtx, result);\n \t      free_temp_slots ();\n \t      pop_temp_slots ();\n \t      return NULL_RTX;\n+\n \t    default:\n \t      break;\n \t    }"}, {"sha": "caec9d27bf0703582a1f980abf5e85b6a26d1c71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8b139c7421e29b5a103ef09d960a375a6dff3bd", "patch": "@@ -1,3 +1,8 @@\n+2004-07-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20040709-1.c: New test.\n+\t* gcc.c-torture/execute/20040709-2.c: New test.\n+\n 2004-07-14  Mike Stump  <mrs@apple.com>\n \n \t* gcc.dg/wint_t-1.c: Expect to pass on darwin 10.3.x and later."}, {"sha": "455313ade1854525b81b83b19e34fa42d9013977", "filename": "gcc/testsuite/gcc.c-torture/execute/20040709-1.c", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-1.c?ref=b8b139c7421e29b5a103ef09d960a375a6dff3bd", "patch": "@@ -0,0 +1,147 @@\n+/* Test arithmetics on bitfields.  */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+unsigned int\n+myrnd (void)\n+{\n+  static unsigned int s = 1388815473;\n+  s *= 1103515245;\n+  s += 12345;\n+  return (s / 65536) % 2048;\n+}\n+\n+#define T(S)\t\t\t\t\t\\\n+struct S s##S;\t\t\t\t\t\\\n+struct S retme##S (struct S x)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return x;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn1##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y = retme##S (y);\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn2##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y.k %= 15;\t\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int retit##S (void)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return s##S.k;\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn3##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  s##S.k += x;\t\t\t\t\t\\\n+  return retit##S ();\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+void test##S (void)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\\\n+  unsigned int mask, v, a, r;\t\t\t\\\n+  struct S x;\t\t\t\t\t\\\n+  char *p = (char *) &s##S;\t\t\t\\\n+  for (i = 0; i < sizeof (s##S); ++i)\t\t\\\n+    *p++ = myrnd ();\t\t\t\t\\\n+  if (__builtin_classify_type (s##S.l) == 8)\t\\\n+    s##S.l = 5.25;\t\t\t\t\\\n+  s##S.k = -1;\t\t\t\t\t\\\n+  mask = s##S.k;\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn1##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn2##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((((v + a) & mask) % 15) & mask) != r)\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn3##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || s##S.k != r || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+}\n+\n+struct A { unsigned int i : 6, l : 1, j : 10, k : 15; }; T(A)\n+struct B { unsigned int i : 6, j : 11, k : 15; unsigned int l; }; T(B)\n+struct C { unsigned int l; unsigned int i : 6, j : 11, k : 15; }; T(C)\n+struct D { unsigned long long l : 6, i : 6, j : 23, k : 29; }; T(D)\n+struct E { unsigned long long l, i : 12, j : 23, k : 29; }; T(E)\n+struct F { unsigned long long i : 12, j : 23, k : 29, l; }; T(F)\n+struct G { unsigned int i : 12, j : 13, k : 7; unsigned long long l; }; T(G)\n+struct H { unsigned int i : 12, j : 11, k : 9; unsigned long long l; }; T(H)\n+struct I { unsigned short i : 1, j : 6, k : 9; unsigned long long l; }; T(I)\n+struct J { unsigned short i : 1, j : 8, k : 7; unsigned short l; }; T(J)\n+struct K { unsigned int k : 6, l : 1, j : 10, i : 15; }; T(K)\n+struct L { unsigned int k : 6, j : 11, i : 15; unsigned int l; }; T(L)\n+struct M { unsigned int l; unsigned int k : 6, j : 11, i : 15; }; T(M)\n+struct N { unsigned long long l : 6, k : 6, j : 23, i : 29; }; T(N)\n+struct O { unsigned long long l, k : 12, j : 23, i : 29; }; T(O)\n+struct P { unsigned long long k : 12, j : 23, i : 29, l; }; T(P)\n+struct Q { unsigned int k : 12, j : 13, i : 7; unsigned long long l; }; T(Q)\n+struct R { unsigned int k : 12, j : 11, i : 9; unsigned long long l; }; T(R)\n+struct S { unsigned short k : 1, j : 6, i : 9; unsigned long long l; }; T(S)\n+struct T { unsigned short k : 1, j : 8, i : 7; unsigned short l; }; T(T)\n+struct U { unsigned short j : 6, k : 1, i : 9; unsigned long long l; }; T(U)\n+struct V { unsigned short j : 8, k : 1, i : 7; unsigned short l; }; T(V)\n+struct W { long double l; unsigned int k : 12, j : 13, i : 7; }; T(W)\n+struct X { unsigned int k : 12, j : 13, i : 7; long double l; }; T(X)\n+struct Y { unsigned int k : 12, j : 11, i : 9; long double l; }; T(Y)\n+struct Z { long double l; unsigned int j : 13, i : 7, k : 12; }; T(Z)\n+\n+int\n+main (void)\n+{\n+  testA ();\n+  testB ();\n+  testC ();\n+  testD ();\n+  testE ();\n+  testF ();\n+  testG ();\n+  testH ();\n+  testI ();\n+  testJ ();\n+  testK ();\n+  testL ();\n+  testM ();\n+  testN ();\n+  testO ();\n+  testP ();\n+  testQ ();\n+  testR ();\n+  testS ();\n+  testT ();\n+  testU ();\n+  testV ();\n+  testW ();\n+  testX ();\n+  testY ();\n+  testZ ();\n+  exit (0);\n+}"}, {"sha": "f06811c24b37a68bd075d2c7f119c9930a308710", "filename": "gcc/testsuite/gcc.c-torture/execute/20040709-2.c", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b139c7421e29b5a103ef09d960a375a6dff3bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040709-2.c?ref=b8b139c7421e29b5a103ef09d960a375a6dff3bd", "patch": "@@ -0,0 +1,153 @@\n+/* Test arithmetics on bitfields.  */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+unsigned int\n+myrnd (void)\n+{\n+  static unsigned int s = 1388815473;\n+  s *= 1103515245;\n+  s += 12345;\n+  return (s / 65536) % 2048;\n+}\n+\n+#define T(S)\t\t\t\t\t\\\n+struct S s##S;\t\t\t\t\t\\\n+struct S retme##S (struct S x)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return x;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn1##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y = retme##S (y);\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn2##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  struct S y = s##S;\t\t\t\t\\\n+  y.k += x;\t\t\t\t\t\\\n+  y.k %= 15;\t\t\t\t\t\\\n+  return y.k;\t\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int retit##S (void)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  return s##S.k;\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+unsigned int fn3##S (unsigned int x)\t\t\\\n+{\t\t\t\t\t\t\\\n+  s##S.k += x;\t\t\t\t\t\\\n+  return retit##S ();\t\t\t\t\\\n+}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+void test##S (void)\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\\\n+  unsigned int mask, v, a, r;\t\t\t\\\n+  struct S x;\t\t\t\t\t\\\n+  char *p = (char *) &s##S;\t\t\t\\\n+  for (i = 0; i < sizeof (s##S); ++i)\t\t\\\n+    *p++ = myrnd ();\t\t\t\t\\\n+  if (__builtin_classify_type (s##S.l) == 8)\t\\\n+    s##S.l = 5.25;\t\t\t\t\\\n+  s##S.k = -1;\t\t\t\t\t\\\n+  mask = s##S.k;\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn1##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn2##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || x.k != s##S.k || x.l != s##S.l\t\t\\\n+      || ((((v + a) & mask) % 15) & mask) != r)\t\\\n+    abort ();\t\t\t\t\t\\\n+  v = myrnd ();\t\t\t\t\t\\\n+  a = myrnd ();\t\t\t\t\t\\\n+  s##S.k = v;\t\t\t\t\t\\\n+  x = s##S;\t\t\t\t\t\\\n+  r = fn3##S (a);\t\t\t\t\\\n+  if (x.i != s##S.i || x.j != s##S.j\t\t\\\n+      || s##S.k != r || x.l != s##S.l\t\t\\\n+      || ((v + a) & mask) != r)\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+}\n+\n+#ifdef __powerpc64__\n+/* Temporary hack for broken PPC64 unaligned handling PR rtl-optimization/13674 */\n+# define pck\n+#else\n+# define pck __attribute__((packed))\n+#endif\n+struct pck A { unsigned short i : 1, l : 1, j : 3, k : 11; }; T(A)\n+struct pck B { unsigned short i : 4, j : 1, k : 11; unsigned int l; }; T(B)\n+struct pck C { unsigned int l; unsigned short i : 4, j : 1, k : 11; }; T(C)\n+struct pck D { unsigned long long l : 6, i : 6, j : 23, k : 29; }; T(D)\n+struct pck E { unsigned long long l, i : 12, j : 23, k : 29; }; T(E)\n+struct pck F { unsigned long long i : 12, j : 23, k : 29, l; }; T(F)\n+struct pck G { unsigned short i : 1, j : 1, k : 6; unsigned long long l; }; T(G)\n+struct pck H { unsigned short i : 6, j : 2, k : 8; unsigned long long l; }; T(H)\n+struct pck I { unsigned short i : 1, j : 6, k : 1; unsigned long long l; }; T(I)\n+struct pck J { unsigned short i : 1, j : 8, k : 7; unsigned short l; }; T(J)\n+struct pck K { unsigned int k : 6, l : 1, j : 10, i : 15; }; T(K)\n+struct pck L { unsigned int k : 6, j : 11, i : 15; unsigned int l; }; T(L)\n+struct pck M { unsigned int l; unsigned short k : 6, j : 11, i : 15; }; T(M)\n+struct pck N { unsigned long long l : 6, k : 6, j : 23, i : 29; }; T(N)\n+struct pck O { unsigned long long l, k : 12, j : 23, i : 29; }; T(O)\n+struct pck P { unsigned long long k : 12, j : 23, i : 29, l; }; T(P)\n+struct pck Q { unsigned short k : 12, j : 1, i : 3; unsigned long long l; }; T(Q)\n+struct pck R { unsigned short k : 2, j : 11, i : 3; unsigned long long l; }; T(R)\n+struct pck S { unsigned short k : 1, j : 6, i : 9; unsigned long long l; }; T(S)\n+struct pck T { unsigned short k : 1, j : 8, i : 7; unsigned short l; }; T(T)\n+struct pck U { unsigned short j : 6, k : 1, i : 9; unsigned long long l; }; T(U)\n+struct pck V { unsigned short j : 8, k : 1, i : 7; unsigned short l; }; T(V)\n+struct pck W { long double l; unsigned int k : 12, j : 13, i : 7; }; T(W)\n+struct pck X { unsigned int k : 12, j : 13, i : 7; long double l; }; T(X)\n+struct pck Y { unsigned int k : 12, j : 11, i : 9; long double l; }; T(Y)\n+struct pck Z { long double l; unsigned int j : 13, i : 7, k : 12; }; T(Z)\n+\n+int\n+main (void)\n+{\n+  testA ();\n+  testB ();\n+  testC ();\n+  testD ();\n+  testE ();\n+  testF ();\n+  testG ();\n+  testH ();\n+  testI ();\n+  testJ ();\n+  testK ();\n+  testL ();\n+  testM ();\n+  testN ();\n+  testO ();\n+  testP ();\n+  testQ ();\n+  testR ();\n+  testS ();\n+  testT ();\n+  testU ();\n+  testV ();\n+  testW ();\n+  testX ();\n+  testY ();\n+  testZ ();\n+  exit (0);\n+}"}]}