{"sha": "660845bf3a71cab364902d2e3b0830f08572d8f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYwODQ1YmYzYTcxY2FiMzY0OTAyZDJlM2IwODMwZjA4NTcyZDhmNA==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2005-05-24T22:22:33Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-05-24T22:22:33Z"}, "message": "class.c (layout_class_type): Do not issue C++ ABI warnings for ObjC structs.\n\n        * class.c (layout_class_type): Do not issue C++ ABI warnings\n        for ObjC structs.\n        * decl.c (objc_mark_locals_volatile): Streamline by calling\n        objc_volatilize_decl().\n        * parser.c (cp_parser_objc_message_expression): Allow simple\n        type specifiers (instead of merely type names) as message\n        receivers.\n        * pt.c (template_args_equal): Do not call objc_comptypes().\n        * typeck.c (composite_pointer_type): If both pointers are\n        ObjC-esque, arbitrarily choose the first; do not call\n        objc_comptypes().\n        (comptypes): Do not call objc_comptypes().\n        (convert_for_assignment): Call objc_compare_types().\n        (comp_ptr_ttypes_real): Call objc_type_quals_match() before\n        concluding that types do not match.\n\nFrom-SVN: r100125", "tree": {"sha": "0a08a44cd858d7e984fbacfc004a39aa76e53504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a08a44cd858d7e984fbacfc004a39aa76e53504"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/660845bf3a71cab364902d2e3b0830f08572d8f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660845bf3a71cab364902d2e3b0830f08572d8f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660845bf3a71cab364902d2e3b0830f08572d8f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660845bf3a71cab364902d2e3b0830f08572d8f4/comments", "author": null, "committer": null, "parents": [{"sha": "d11dd684081e91ffda37451fd6be1059d055130b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11dd684081e91ffda37451fd6be1059d055130b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11dd684081e91ffda37451fd6be1059d055130b"}], "stats": {"total": 138, "additions": 72, "deletions": 66}, "files": [{"sha": "524c943b171a5308e15bf3c4246cb81a90abd6e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -1,3 +1,21 @@\n+2005-05-24  Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* class.c (layout_class_type): Do not issue C++ ABI warnings\n+\tfor ObjC structs.\n+\t* decl.c (objc_mark_locals_volatile): Streamline by calling\n+\tobjc_volatilize_decl().\n+\t* parser.c (cp_parser_objc_message_expression): Allow simple\n+\ttype specifiers (instead of merely type names) as message\n+\treceivers.\n+\t* pt.c (template_args_equal): Do not call objc_comptypes().\n+\t* typeck.c (composite_pointer_type): If both pointers are\n+\tObjC-esque, arbitrarily choose the first; do not call\n+\tobjc_comptypes().\n+\t(comptypes): Do not call objc_comptypes().\n+\t(convert_for_assignment): Call objc_compare_types().\n+\t(comp_ptr_ttypes_real): Call objc_type_quals_match() before\n+\tconcluding that types do not match.\n+\n 2005-05-24  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR C++/21645"}, {"sha": "d982b39e0d1613ee8806be000ebc02691ae81bdc", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -4681,6 +4681,11 @@ layout_class_type (tree t, tree *virtuals_p)\n \t comply with the ABI.  */\n       if (warn_abi\n \t  && DECL_C_BIT_FIELD (field) \n+\t  /* The TREE_NO_WARNING flag gets set by Objective-C when\n+\t     laying out an Objective-C class.  The ObjC ABI differs\n+\t     from the C++ ABI, and so we do not want a warning\n+\t     here.  */\n+\t  && !TREE_NO_WARNING (field)\n \t  && !last_field_was_bitfield\n \t  && !integer_zerop (size_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),"}, {"sha": "0da99373e816124c1591b55d5e2816309496acf2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -425,22 +425,7 @@ objc_mark_locals_volatile (void *enclosing_blk)\n       tree decl;\n \n       for (decl = scope->names; decl; decl = TREE_CHAIN (decl))\n-        {\n-\t  /* Do not mess with variables that are 'static' or (already)\n-\t     'volatile'.  */\n-\t  if (!TREE_THIS_VOLATILE (decl) && !TREE_STATIC (decl)\n-\t      && (TREE_CODE (decl) == VAR_DECL\n-\t\t  || TREE_CODE (decl) == PARM_DECL))\n-\t    {\n-\t      TREE_TYPE (decl)\n-\t\t= build_qualified_type (TREE_TYPE (decl),\n-\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (decl))\n-\t\t\t\t\t | TYPE_QUAL_VOLATILE));\n-\t      TREE_THIS_VOLATILE (decl) = 1;\n-\t      TREE_SIDE_EFFECTS (decl) = 1;\n-\t      DECL_REGISTER (decl) = 0;\n-\t    }\n-\t}\n+\tobjc_volatilize_decl (decl);\n \n       /* Do not climb up past the current function.  */\n       if (scope->kind == sk_function_parms)"}, {"sha": "2527fb2f551f1a5b1a014089501ec29b94ebf26b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -16258,16 +16258,15 @@ cp_parser_objc_message_expression (cp_parser* parser)\n /* Parse an objc-message-receiver.\n \n    objc-message-receiver:\n-     type-name\n      expression\n+     simple-type-specifier\n \n   Returns a representation of the type or expression.  */\n \n static tree\n cp_parser_objc_message_receiver (cp_parser* parser)\n {\n   tree rcv;\n-  bool class_scope_p, template_p;\n \n   /* An Objective-C message receiver may be either (1) a type\n      or (2) an expression.  */\n@@ -16277,24 +16276,9 @@ cp_parser_objc_message_receiver (cp_parser* parser)\n   if (cp_parser_parse_definitely (parser))\n     return rcv;\n \n-  /* Look for the optional `::' operator.  */\n-  cp_parser_global_scope_opt (parser, false);\n-  /* Look for the nested-name-specifier.  */\n-  cp_parser_nested_name_specifier_opt (parser,\n-\t\t\t\t       /*typename_keyword_p=*/true,\n-\t\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t\t       /*type_p=*/true,\n-\t\t\t\t       /*is_declaration=*/true);\n-  class_scope_p = (parser->scope && TYPE_P (parser->scope));\n-  template_p = class_scope_p && cp_parser_optional_template_keyword (parser);\n-  /* Finally, look for the class-name.  */\n-  rcv = cp_parser_class_name (parser,\n-\t\t\t       class_scope_p,\n-\t\t\t       template_p,\n-\t\t\t       /*type_p=*/true,\n-\t\t\t       /*check_dependency_p=*/true,\n-\t\t\t       /*class_head_p=*/false,\n-\t\t\t       /*is_declaration=*/true);\n+  rcv = cp_parser_simple_type_specifier (parser,\n+\t\t\t\t\t /*decl_specs=*/NULL,\n+\t\t\t\t\t CP_PARSER_FLAGS_NONE);\n \n   return objc_get_class_reference (rcv);\n }"}, {"sha": "1a1d5c0f2377349cd9a607febb2b9fa5b11e2ced", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -4026,24 +4026,7 @@ template_args_equal (tree ot, tree nt)\n     /* For member templates */\n     return TREE_CODE (ot) == TREE_VEC && comp_template_args (ot, nt);\n   else if (TYPE_P (nt))\n-    {\n-      int c1, c2;\n-\n-      if (!TYPE_P (ot))\n-\treturn 0;\n-\n-      /* We must handle ObjC types specially because they may differ\n-\t only in protocol qualifications (e.g., 'NSObject *' vs.\n-\t 'NSObject <Foo> *') that must be taken into account here.\n-\t See also cp/typeck.c:build_c_cast(), where a similar problem\n-\t arises.  We must call objc_comptypes() twice, since its\n-\t comparisons are _not_ symmetric.  */\n-      if ((c1 = objc_comptypes (ot, nt, 0)) >= 0\n-\t  && (c2 = objc_comptypes (nt, ot, 0)) >= 0)\n-\treturn (c1 && c2);\n-\n-      return same_type_p (ot, nt);\n-    }\n+    return TYPE_P (ot) && same_type_p (ot, nt);\n   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n     return 0;\n   else"}, {"sha": "8bd101295fd4185d55366801a284bdd4164b2506", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/660845bf3a71cab364902d2e3b0830f08572d8f4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=660845bf3a71cab364902d2e3b0830f08572d8f4", "patch": "@@ -503,6 +503,13 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       return build_type_attribute_variant (result_type, attributes);\n     }\n \n+  if (c_dialect_objc () && TREE_CODE (t1) == POINTER_TYPE\n+      && TREE_CODE (t2) == POINTER_TYPE)\n+    {\n+      if (objc_compare_types (t1, t2, -3, NULL_TREE))\n+\treturn t1;\n+    }\n+\n   /* [expr.eq] permits the application of a pointer conversion to\n      bring the pointers to a common type.  */\n   if (TREE_CODE (t1) == POINTER_TYPE && TREE_CODE (t2) == POINTER_TYPE\n@@ -514,12 +521,10 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       class1 = TREE_TYPE (t1);\n       class2 = TREE_TYPE (t2);\n \n-      if (DERIVED_FROM_P (class1, class2) || \n-\t  (c_dialect_objc () && objc_comptypes (class1, class2, 0) == 1))\n+      if (DERIVED_FROM_P (class1, class2))\n \tt2 = (build_pointer_type \n \t      (cp_build_qualified_type (class1, TYPE_QUALS (class2))));\n-      else if (DERIVED_FROM_P (class2, class1) ||\n-\t       (c_dialect_objc () && objc_comptypes (class2, class1, 0) == 1))\n+      else if (DERIVED_FROM_P (class2, class1))\n \tt1 = (build_pointer_type \n \t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n       else\n@@ -1000,11 +1005,6 @@ comptypes (tree t1, tree t2, int strict)\n       else if ((strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n \tbreak;\n       \n-      /* We may be dealing with Objective-C instances.  */\n-      if (TREE_CODE (t1) == RECORD_TYPE\n-\t  && objc_comptypes (t1, t2, 0) > 0)\n-\tbreak;\n-\n       return false;\n \n     case OFFSET_TYPE:\n@@ -5832,7 +5832,33 @@ convert_for_assignment (tree type, tree rhs,\n   /* Simplify the RHS if possible.  */\n   if (TREE_CODE (rhs) == CONST_DECL)\n     rhs = DECL_INITIAL (rhs);\n-  \n+\n+  if (c_dialect_objc ())\n+    {\n+      int parmno;\n+      tree rname = fndecl;\n+\n+      if (!strcmp (errtype, \"assignment\"))\n+\tparmno = -1;\n+      else if (!strcmp (errtype, \"initialization\"))\n+\tparmno = -2;\n+      else\n+\t{\n+\t  tree selector = objc_message_selector ();\n+\n+\t  parmno = parmnum;\n+\n+\t  if (selector && parmno > 1)\n+\t    {\n+\t      rname = selector;\n+\t      parmno -= 1;\n+\t    }\n+\t}\n+\n+      if (objc_compare_types (type, rhstype, parmno, rname))\n+\treturn convert (type, rhs);\n+    }\n+\n   /* [expr.ass]\n \n      The expression is implicitly converted (clause _conv_) to the\n@@ -6257,10 +6283,15 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n \t{\n-\t  if (!at_least_as_qualified_p (to, from))\n+\t  /* In Objective-C++, some types may have been 'volatilized' by\n+\t     the compiler for EH; when comparing them here, the volatile\n+\t     qualification must be ignored.  */\n+\t  bool objc_quals_match = objc_type_quals_match (to, from);\n+\n+\t  if (!at_least_as_qualified_p (to, from) && !objc_quals_match)\n \t    return 0;\n \n-\t  if (!at_least_as_qualified_p (from, to))\n+\t  if (!at_least_as_qualified_p (from, to) && !objc_quals_match)\n \t    {\n \t      if (constp == 0)\n \t\treturn 0;"}]}