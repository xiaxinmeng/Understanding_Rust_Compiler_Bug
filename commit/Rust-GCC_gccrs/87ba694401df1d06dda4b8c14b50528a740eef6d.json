{"sha": "87ba694401df1d06dda4b8c14b50528a740eef6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdiYTY5NDQwMWRmMWQwNmRkYTRiOGMxNGI1MDUyOGE3NDBlZWY2ZA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-04-17T22:27:41Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-04-17T22:27:41Z"}, "message": "c4x.c (legitimize_operands): Use rtx_cost to determine if it is worthwhile forcing a constant into a register.\n\n\t* config/c4x/c4x.c (legitimize_operands): Use rtx_cost\n\tto determine if it is worthwhile forcing a constant into a register.\n\t* config/c4x/c4x.h (CONST_COSTS): An integer value of 255 or 65535\n\tused with a logical and or an integer value of 16 or 24 used with\n\ta right shift has zero cost on the C40.\n\nFrom-SVN: r26529", "tree": {"sha": "32f706527865c786d8a46ebcdc8fb6e0dbf9ae89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32f706527865c786d8a46ebcdc8fb6e0dbf9ae89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87ba694401df1d06dda4b8c14b50528a740eef6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ba694401df1d06dda4b8c14b50528a740eef6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ba694401df1d06dda4b8c14b50528a740eef6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ba694401df1d06dda4b8c14b50528a740eef6d/comments", "author": null, "committer": null, "parents": [{"sha": "695ab36a1f65a94647cb24e61772af444b8f51d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695ab36a1f65a94647cb24e61772af444b8f51d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695ab36a1f65a94647cb24e61772af444b8f51d9"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "9411c209b2f124b740c0462129c5dd00f867ec5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87ba694401df1d06dda4b8c14b50528a740eef6d", "patch": "@@ -1,3 +1,11 @@\n+Sun Apr 18 17:24:10 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (legitimize_operands): Use rtx_cost\n+\tto determine if it is worthwhile forcing a constant into a register.\n+\t* config/c4x/c4x.h (CONST_COSTS): An integer value of 255 or 65535\n+\tused with a logical and or an integer value of 16 or 24 used with\n+\ta right shift has zero cost on the C40.\n+\n Sat Apr 17 21:30:11 1999  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n \t* gcse.c (compute_local_properties): If setp is nonzero, clear"}, {"sha": "5c5690a4eaf9cfea230f7ee1245aed1a6f5ab7ce", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=87ba694401df1d06dda4b8c14b50528a740eef6d", "patch": "@@ -3582,6 +3582,11 @@ c4x_valid_operands (code, operands, mode, force)\n \n       /* Any valid memory operand screened by src_operand is OK.  */      \n     case MEM:\n+#if 0\n+      if (code2 != REG)\n+\treturn 0;\n+#endif\n+      break;\n \n       /* After CSE, any remaining (ADDRESSOF:P reg) gets converted\n \t into a stack slot memory address comprising a PLUS and a\n@@ -3644,10 +3649,9 @@ legitimize_operands (code, operands, mode)\n       if (! reload_in_progress\n \t  && TARGET_HOIST\n \t  && optimize > 0\n-\t  && ((GET_CODE (operands[1]) == CONST_INT \n-\t       && ! c4x_J_constant (operands[1])\n-\t       && INTVAL (operands[1]) != 0)\n-\t      || GET_CODE (operands[1]) == CONST_DOUBLE))\n+\t  && GET_CODE (operands[1]) == CONST_INT \n+\t  && preserve_subexpressions_p ()\n+\t  && rtx_cost (operands[1], code) > 1)\n \toperands[1] = force_reg (mode, operands[1]);\n       \n       if (! reload_in_progress\n@@ -3661,11 +3665,11 @@ legitimize_operands (code, operands, mode)\n      opportunities.  */\n   if (! reload_in_progress\n       && ! ((code == PLUS || code == MINUS) && mode == Pmode)\n-      && (TARGET_HOIST && optimize > 1\n-       && ((GET_CODE (operands[2]) == CONST_INT \n-\t    && ! c4x_J_constant (operands[2])\n-\t    && INTVAL (operands[2]) != 0)\n-\t   || GET_CODE (operands[2]) == CONST_DOUBLE)))\n+      && TARGET_HOIST\n+      && optimize > 1\n+      && GET_CODE (operands[2]) == CONST_INT\n+      && preserve_subexpressions_p ()\n+      && rtx_cost (operands[2], code) > 1)\n     operands[2] = force_reg (mode, operands[2]);\n \n   /* We can get better code on a C30 if we force constant shift counts"}, {"sha": "1dc8d5c63ed70491965b4e20f62b58eaa3952f77", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87ba694401df1d06dda4b8c14b50528a740eef6d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=87ba694401df1d06dda4b8c14b50528a740eef6d", "patch": "@@ -1763,7 +1763,13 @@ extern void c4x_encode_section_info ();\n    Some small integers are effectively free for the C40.  We should\n    also consider if we are using the small memory model.  With\n    the big memory model we require an extra insn for a constant\n-   loaded from memory.  */\n+   loaded from memory.  \n+\n+   This is used by expand_binop to decide whether to force a constant\n+   into a register.  If the cost is greater than 2 and the constant\n+   is used within a short loop, it gets forced into a register.  \n+   Ideally, there should be some weighting as to how mnay times it is used\n+   within the loop.  */\n \n #define SHIFT_CODE_P(C) ((C) == ASHIFT || (C) == ASHIFTRT || (C) == LSHIFTRT)\n \n@@ -1776,6 +1782,16 @@ extern void c4x_encode_section_info ();\n \tcase CONST_INT:\t\t\t\t\t\t\\\n            if (c4x_J_constant (RTX))\t\t\t\t\\\n \t     return 0;\t\t\t\t\t\t\\\n+\t   if (! TARGET_C3X\t\t\t\t\t\\\n+\t       && OUTER_CODE == AND\t\t\t\t\\\n+               && GET_CODE (RTX) == CONST_INT\t\t\t\\\n+\t       && (INTVAL (RTX) == 255 || INTVAL (RTX) == 65535))\t\\\n+\t     return 0;\t\t\t\t\t\t\\\n+\t   if (! TARGET_C3X\t\t\t\t\t\\\n+\t       && (OUTER_CODE == ASHIFTRT || OUTER_CODE == LSHIFTRT)\t\\\n+               && GET_CODE (RTX) == CONST_INT\t\t\t\\\n+\t       && (INTVAL (RTX) == 16 || INTVAL (RTX) == 24))\t\\\n+\t     return 0;\t\t\t\t\t\t\\\n            if (TARGET_C3X && SHIFT_CODE_P (OUTER_CODE))\t\t\\\n \t     return 3;\t\t\t\t\t\t\\\n            if (LOGICAL_CODE_P (OUTER_CODE) \t\t\t\\"}]}