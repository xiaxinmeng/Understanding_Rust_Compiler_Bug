{"sha": "5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkNmZjYTVjM2NmYzdmOGI4ZWUxMTE2M2E2ZGI1M2Q4MGMzMGU5Ng==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-06-28T22:39:21Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-06-28T22:39:21Z"}, "message": "m32r.c (m32r_sched_odd_word_p, [...]): Remove.\n\n\t* config/m32r/m32r.c (m32r_sched_odd_word_p, m32r_adjust_cost,\n\tm32r_sched_init, m32r_sched_reorder, m32r_variable_issue): Remove.\n\t(TARGET_SCHED_ADJUST_COST, TARGET_SCHED_VARIABLE_ISSUE,\n\tTARGET_SCHED_INIT, TARGET_SCHED_REORDER): Don't define.\n\t* config/m32r/m32r.md: Rewrite the pipeline description as a DFA.\n\nFrom-SVN: r83829", "tree": {"sha": "a72133bf6fc257bebc7d4bab7e804f23a794d062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a72133bf6fc257bebc7d4bab7e804f23a794d062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/comments", "author": null, "committer": null, "parents": [{"sha": "497be9785fcb4acf36758fd264571611a8d266a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497be9785fcb4acf36758fd264571611a8d266a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497be9785fcb4acf36758fd264571611a8d266a6"}], "stats": {"total": 495, "additions": 121, "deletions": 374}, "files": [{"sha": "37be9da035e5049242c1f58dba4eb6594119fe70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "patch": "@@ -1,3 +1,11 @@\n+2004-06-28  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* config/m32r/m32r.c (m32r_sched_odd_word_p, m32r_adjust_cost,\n+\tm32r_sched_init, m32r_sched_reorder, m32r_variable_issue): Remove.\n+\t(TARGET_SCHED_ADJUST_COST, TARGET_SCHED_VARIABLE_ISSUE,\n+\tTARGET_SCHED_INIT, TARGET_SCHED_REORDER): Don't define.\n+\t* config/m32r/m32r.md: Rewrite the pipeline description as a DFA.\n+\n 2004-06-28  Richard Henderson  <rth@redhat.com>\n \n \t* tree.def (REALPART_EXPR, IMAGPART_EXPR): Change class to 'r'."}, {"sha": "5adc498c52f024e41470f422f9172acbe2aaa3d8", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 2, "deletions": 180, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "patch": "@@ -57,9 +57,6 @@ enum m32r_model m32r_model;\n const char * m32r_sdata_string = M32R_SDATA_DEFAULT;\n enum m32r_sdata m32r_sdata;\n \n-/* Scheduler support */\n-static int m32r_sched_odd_word_p;\n-\n /* Machine-specific symbol_ref flags.  */\n #define SYMBOL_FLAG_MODEL_SHIFT\t\tSYMBOL_FLAG_MACH_DEP_SHIFT\n #define SYMBOL_REF_MODEL(X) \\\n@@ -92,11 +89,7 @@ static void  m32r_output_function_epilogue (FILE *, HOST_WIDE_INT);\n \n static void  m32r_file_start (void);\n \n-static int    m32r_adjust_cost (rtx, rtx, rtx, int);\n static int    m32r_adjust_priority (rtx, int);\n-static void   m32r_sched_init (FILE *, int, int);\n-static int    m32r_sched_reorder (FILE *, int, rtx *, int *, int);\n-static int    m32r_variable_issue (FILE *, int, rtx, int);\n static int    m32r_issue_rate (void);\n \n static void m32r_encode_section_info (tree, rtx, int);\n@@ -124,18 +117,12 @@ static bool m32r_rtx_costs (rtx, int, int, int *);\n #undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START m32r_file_start\n \n-#undef  TARGET_SCHED_ADJUST_COST\n-#define TARGET_SCHED_ADJUST_COST m32r_adjust_cost\n #undef  TARGET_SCHED_ADJUST_PRIORITY\n #define TARGET_SCHED_ADJUST_PRIORITY m32r_adjust_priority\n #undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE m32r_issue_rate\n-#undef  TARGET_SCHED_VARIABLE_ISSUE\n-#define TARGET_SCHED_VARIABLE_ISSUE m32r_variable_issue\n-#undef  TARGET_SCHED_INIT\n-#define TARGET_SCHED_INIT m32r_sched_init\n-#undef  TARGET_SCHED_REORDER\n-#define TARGET_SCHED_REORDER m32r_sched_reorder\n+#undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n \n #undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO m32r_encode_section_info\n@@ -1463,14 +1450,6 @@ m32r_va_arg (tree valist, tree type)\n \n   return addr_rtx;\n }\n-\f\n-static int\n-m32r_adjust_cost (rtx insn ATTRIBUTE_UNUSED, rtx link ATTRIBUTE_UNUSED,\n-\t\t  rtx dep_insn ATTRIBUTE_UNUSED, int cost)\n-{\n-  return cost;\n-}\n-\n \f\n /* Return true if INSN is real instruction bearing insn.  */\n \n@@ -1497,124 +1476,6 @@ m32r_adjust_priority (rtx insn, int priority)\n }\n \n \f\n-/* Initialize for scheduling a group of instructions.  */\n-\n-static void\n-m32r_sched_init (FILE * stream ATTRIBUTE_UNUSED,\n-\t\t int verbose ATTRIBUTE_UNUSED,\n-\t\t int max_ready ATTRIBUTE_UNUSED)\n-{\n-  m32r_sched_odd_word_p = FALSE;\n-}\n-\n-\f\n-/* Reorder the schedulers priority list if needed */\n-\n-static int\n-m32r_sched_reorder (FILE * stream, int verbose, rtx * ready,\n-\t\t    int *n_readyp, int clock ATTRIBUTE_UNUSED)\n-{\n-  int n_ready = *n_readyp;\n-\n-  if (TARGET_DEBUG)\n-    return m32r_issue_rate ();\n-\n-  if (verbose <= 7)\n-    stream = (FILE *)0;\n-\n-  if (stream)\n-    fprintf (stream,\n-\t     \";;\\t\\t::: Looking at %d insn(s) on ready list, boundary is %s word\\n\",\n-\t     n_ready,\n-\t     (m32r_sched_odd_word_p) ? \"odd\" : \"even\");\n-\n-  if (n_ready > 1)\n-    {\n-      rtx * long_head = alloca (sizeof (rtx) * n_ready);\n-      rtx * long_tail = long_head;\n-      rtx * short_head = alloca (sizeof (rtx) * n_ready);\n-      rtx * short_tail = short_head;\n-      rtx * new_head = alloca (sizeof (rtx) * n_ready);\n-      rtx * new_tail = new_head + (n_ready - 1);\n-      int   i;\n-\n-      /* Loop through the instructions, classifying them as short/long.  Try\n-\t to keep 2 short together and/or 1 long.  Note, the ready list is\n-\t actually ordered backwards, so keep it in that manner.  */\n-      for (i = n_ready-1; i >= 0; i--)\n-\t{\n-\t  rtx insn = ready[i];\n-\n-\t  if (! m32r_is_insn (insn))\n-\t    {\n-\t      /* Dump all current short/long insns just in case.  */\n-\t      while (long_head != long_tail)\n-\t\t*new_tail-- = *long_head++;\n-\n-\t      while (short_head != short_tail)\n-\t\t*new_tail-- = *short_head++;\n-\n-\t      *new_tail-- = insn;\n-\t      if (stream)\n-\t\tfprintf (stream,\n-\t\t\t \";;\\t\\t::: Skipping non instruction %d\\n\",\n-\t\t\t INSN_UID (insn));\n-\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n-\t\t*long_tail++ = insn;\n-\n-\t      else\n-\t\t*short_tail++ = insn;\n-\t    }\n-\t}\n-\n-      /* If we are on an odd word, emit a single short instruction if\n-\t we can.  */\n-      if (m32r_sched_odd_word_p && short_head != short_tail)\n-\t*new_tail-- = *short_head++;\n-\n-      /* Now dump out all of the long instructions.  */\n-      while (long_head != long_tail)\n-\t*new_tail-- = *long_head++;\n-\n-      /* Now dump out all of the short instructions.  */\n-      while (short_head != short_tail)\n-\t*new_tail-- = *short_head++;\n-\n-      if (new_tail + 1 != new_head)\n-\tabort ();\n-\n-      memcpy (ready, new_head, sizeof (rtx) * n_ready);\n-      if (stream)\n-\t{\n-\t  int i;\n-\t  fprintf (stream, \";;\\t\\t::: New ready list:               \");\n-\t  for (i = 0; i < n_ready; i++)\n-\t    {\n-\t      rtx insn = ready[i];\n-\n-\t      fprintf (stream, \" %d\", INSN_UID (ready[i]));\n-\n-\t      if (! m32r_is_insn (insn))\n-\t\tfputs (\"(?)\", stream);\n-\n-\t      else if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n-\t\tfputs (\"(l)\", stream);\n-\n-\t      else\n-\t\tfputs (\"(s)\", stream);\n-\t    }\n-\n-\t  fprintf (stream, \"\\n\");\n-\t}\n-    }\n-  return m32r_issue_rate ();\n-}\n-\n /* Indicate how many instructions can be issued at the same time.\n    This is sort of a lie.  The m32r can issue only 1 long insn at\n    once, but it can issue 2 short insns.  The default therefore is\n@@ -1626,45 +1487,6 @@ m32r_issue_rate (void)\n {\n   return ((TARGET_LOW_ISSUE_RATE) ? 1 : 2);\n }\n-\n-/* If we have a machine that can issue a variable # of instructions\n-   per cycle, indicate how many more instructions can be issued\n-   after the current one.  */\n-\n-static int\n-m32r_variable_issue (FILE * stream, int verbose, rtx insn, int how_many)\n-{\n-  int orig_odd_word_p = m32r_sched_odd_word_p;\n-  int short_p = FALSE;\n-\n-  how_many--;\n-  if (how_many > 0 && !TARGET_DEBUG)\n-    {\n-      if (! m32r_is_insn (insn))\n-\thow_many++;\n-\n-      else if (get_attr_insn_size (insn) != INSN_SIZE_SHORT)\n-\t{\n-\t  how_many = 0;\n-\t  m32r_sched_odd_word_p = 0;\n-\t}\n-      else\n-\t{\n-\t  m32r_sched_odd_word_p = !m32r_sched_odd_word_p;\n-\t  short_p = TRUE;\n-\t}\n-    }\n-\n-  if (verbose > 7 && stream)\n-    fprintf (stream,\n-\t     \";;\\t\\t::: %s insn %d starts on an %s word, can emit %d more instruction(s)\\n\",\n-\t     short_p ? \"short\" : \"long\",\n-\t     INSN_UID (insn),\n-\t     orig_odd_word_p ? \"odd\" : \"even\",\n-\t     how_many);\n-\n-  return how_many;\n-}\n \f\n /* Cost functions.  */\n "}, {"sha": "c5994ef18ca1dcd02c586c6c99fee7a4c3b9e448", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 110, "deletions": 193, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "patch": "@@ -60,225 +60,142 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"multi\")])\n \n-\n-;; Whether an instruction is 16-bit or 32-bit\n+;; Whether an instruction is short (16-bit) or long (32-bit).\n (define_attr \"insn_size\" \"short,long\"\n   (if_then_else (eq_attr \"type\" \"int2,load2,store2,shift2,mul2\")\n \t\t(const_string \"short\")\n \t\t(const_string \"long\")))\n \n-(define_attr \"debug\" \"no,yes\"\n-  (const (symbol_ref \"(TARGET_DEBUG != 0)\")))\n-\n-(define_attr \"opt_size\" \"no,yes\"\n-  (const (symbol_ref \"(optimize_size != 0)\")))\n-\n-(define_attr \"m32r\" \"no,yes\"\n-  (const (symbol_ref \"(TARGET_M32R != 0)\")))\n-\n-(define_attr \"m32rx\" \"no,yes\"\n-  (const (symbol_ref \"(TARGET_M32RX != 0)\")))\n-\n-(define_attr \"m32r2\" \"no,yes\"\n-  (const (symbol_ref \"(TARGET_M32R2 != 0)\")))\n-\n-(define_attr \"m32rx_pipeline\" \"either,s,o,long,m32r\"\n-  (cond [(and (eq_attr \"m32rx\" \"no\")\n-              (eq_attr \"m32r2\" \"no\"))\n-         (const_string \"m32r\")\n-\n+;; The target CPU we're compiling for.\n+(define_attr \"cpu\" \"m32r,m32r2,m32rx\"\n+  (cond [(ne (symbol_ref \"TARGET_M32RX\") (const_int 0))\n+\t     (const_string \"m32rx\")\n+\t (ne (symbol_ref \"TARGET_M32R2\") (const_int 0))\n+\t     (const_string \"m32r2\")]\n+    (const_string \"m32r\")))\n+\n+;; Defines the pipeline where an instruction can be executed on.\n+;; For the M32R, a short instruction can execute one of the two pipes.\n+;; For the M32Rx, the restrictions are modelled in the second\n+;; condition of this attribute definition.\n+(define_attr \"m32r_pipeline\" \"either,s,o,long,m32r\"\n+  (cond [(and (eq_attr \"cpu\" \"m32r\")\n+\t      (eq_attr \"insn_size\" \"short\"))\n+\t     (const_string \"either\")\n          (eq_attr \"insn_size\" \"!short\")\n-         (const_string \"long\")]\n-\n-        (cond [(eq_attr \"type\" \"int2\")\n-               (const_string \"either\")\n-\n-               (eq_attr \"type\" \"load2,store2,shift2,uncond_branch,branch,call\")\n-               (const_string \"o\")\n-\n-               (eq_attr \"type\" \"mul2\")\n-               (const_string \"s\")]\n-\n-              (const_string \"long\"))))\n+\t     (const_string \"long\")]\n+\t(cond [(eq_attr \"type\" \"int2\")\n+\t\t   (const_string \"either\")\n+\t       (eq_attr \"type\" \"load2,store2,shift2,uncond_branch,branch,call\")\n+\t\t   (const_string \"o\")\n+\t       (eq_attr \"type\" \"mul2\")\n+\t\t   (const_string \"s\")]\n+\t       (const_string \"long\"))))\n \f\n ;; ::::::::::::::::::::\n ;; ::\n-;; :: Function Units\n+;; :: Pipeline description\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; On most RISC machines, there are instructions whose results are not\n-;; available for a specific number of cycles.  Common cases are instructions\n-;; that load data from memory.  On many machines, a pipeline stall will result\n-;; if the data is referenced too soon after the load instruction.\n-\n-;; In addition, many newer microprocessors have multiple function units,\n-;; usually one for integer and one for floating point, and often will incur\n-;; pipeline stalls when a result that is needed is not yet ready.\n-\n-;; The descriptions in this section allow the specification of how much time\n-;; must elapse between the execution of an instruction and the time when its\n-;; result is used.  It also allows specification of when the execution of an\n-;; instruction will delay execution of similar instructions due to function\n-;; unit conflicts.\n-\n-;; For the purposes of the specifications in this section, a machine is divided\n-;; into \"function units\", each of which execute a specific class of\n-;; instructions in first-in-first-out order.  Function units that accept one\n-;; instruction each cycle and allow a result to be used in the succeeding\n-;; instruction (usually via forwarding) need not be specified.  Classic RISC\n-;; microprocessors will normally have a single function unit, which we can call\n-;; `memory'.  The newer \"superscalar\" processors will often have function units\n-;; for floating point operations, usually at least a floating point adder and\n-;; multiplier.\n-\n-;; Each usage of a function units by a class of insns is specified with a\n-;; `define_function_unit' expression, which looks like this:\n-\n-;; (define_function_unit NAME MULTIPLICITY SIMULTANEITY TEST READY-DELAY\n-;;   ISSUE-DELAY [CONFLICT-LIST])\n-\n-;; NAME is a string giving the name of the function unit.\n-\n-;; MULTIPLICITY is an integer specifying the number of identical units in the\n-;; processor.  If more than one unit is specified, they will be scheduled\n-;; independently.  Only truly independent units should be counted; a pipelined\n-;; unit should be specified as a single unit.  (The only common example of a\n-;; machine that has multiple function units for a single instruction class that\n-;; are truly independent and not pipelined are the two multiply and two\n-;; increment units of the CDC 6600.)\n-\n-;; SIMULTANEITY specifies the maximum number of insns that can be executing in\n-;; each instance of the function unit simultaneously or zero if the unit is\n-;; pipelined and has no limit.\n-\n-;; All `define_function_unit' definitions referring to function unit NAME must\n-;; have the same name and values for MULTIPLICITY and SIMULTANEITY.\n-\n-;; TEST is an attribute test that selects the insns we are describing in this\n-;; definition.  Note that an insn may use more than one function unit and a\n-;; function unit may be specified in more than one `define_function_unit'.\n-\n-;; READY-DELAY is an integer that specifies the number of cycles after which\n-;; the result of the instruction can be used without introducing any stalls.\n-\n-;; ISSUE-DELAY is an integer that specifies the number of cycles after the\n-;; instruction matching the TEST expression begins using this unit until a\n-;; subsequent instruction can begin.  A cost of N indicates an N-1 cycle delay.\n-;; A subsequent instruction may also be delayed if an earlier instruction has a\n-;; longer READY-DELAY value.  This blocking effect is computed using the\n-;; SIMULTANEITY, READY-DELAY, ISSUE-DELAY, and CONFLICT-LIST terms.  For a\n-;; normal non-pipelined function unit, SIMULTANEITY is one, the unit is taken\n-;; to block for the READY-DELAY cycles of the executing insn, and smaller\n-;; values of ISSUE-DELAY are ignored.\n-\n-;; CONFLICT-LIST is an optional list giving detailed conflict costs for this\n-;; unit.  If specified, it is a list of condition test expressions to be\n-;; applied to insns chosen to execute in NAME following the particular insn\n-;; matching TEST that is already executing in NAME.  For each insn in the list,\n-;; ISSUE-DELAY specifies the conflict cost; for insns not in the list, the cost\n-;; is zero.  If not specified, CONFLICT-LIST defaults to all instructions that\n-;; use the function unit.\n-\n-;; Typical uses of this vector are where a floating point function unit can\n-;; pipeline either single- or double-precision operations, but not both, or\n-;; where a memory unit can pipeline loads, but not stores, etc.\n-\n-;; As an example, consider a classic RISC machine where the result of a load\n-;; instruction is not available for two cycles (a single \"delay\" instruction is\n-;; required) and where only one load instruction can be executed\n-;; simultaneously.  This would be specified as:\n-\n-;; (define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n-\n-;; For the case of a floating point function unit that can pipeline\n-;; either single or double precision, but not both, the following could be\n-;; specified:\n+;; This model is based on Chapter 2, Appendix 3 and Appendix 4 of the\n+;; \"M32R-FPU Software Manual\", Revision 1.01, plus additional information\n+;; obtained by our best friend and mine, Google.\n+;;\n+;; The pipeline is modelled as a fetch unit, and a core with a memory unit,\n+;; two execution units, where \"fetch\" models IF and D, \"memory\" for MEM1\n+;; and MEM2, and \"EXEC\" for E, E1, E2, EM, and EA.  Writeback and\n+;; bypasses are not modelled.\n+(define_automaton \"m32r\")\n+\n+;; We pretend there are two short (16 bits) instruction fetchers.  The\n+;; \"s\" short fetcher cannot be reserved until the \"o\" short fetcher is\n+;; reserved.  Some instructions reserve both the left and right fetchers.\n+;; These fetch units are a hack to get GCC to better pack the instructions\n+;; for the M32Rx processor, which has two execution pipes.\n+;;\n+;; In reality there is only one decoder, which can decode either two 16 bits\n+;; instructions, or a single 32 bits instruction.\n ;;\n-;; (define_function_unit \"fp\" 1 0\n-;;   (eq_attr \"type\" \"sp_fp\") 4 4\n-;;   [(eq_attr \"type\" \"dp_fp\")])\n+;; Note, \"fetch\" models both the IF and the D pipeline stages.\n ;;\n-;; (define_function_unit \"fp\" 1 0\n-;;   (eq_attr \"type\" \"dp_fp\") 4 4\n-;;   [(eq_attr \"type\" \"sp_fp\")])\n-\n-;; Note: The scheduler attempts to avoid function unit conflicts and uses all\n-;; the specifications in the `define_function_unit' expression.  It has\n-;; recently come to our attention that these specifications may not allow\n-;; modeling of some of the newer \"superscalar\" processors that have insns using\n-;; multiple pipelined units.  These insns will cause a potential conflict for\n-;; the second unit used during their execution and there is no way of\n-;; representing that conflict.  We welcome any examples of how function unit\n-;; conflicts work in such processors and suggestions for their representation.\n-\n-;; Function units of the M32R\n-;; Units that take one cycle do not need to be specified.\n-\n-;; (define_function_unit {name} {multiplicity} {simultaneity} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\n-;; Hack to get GCC to better pack the instructions.\n-;; We pretend there is a separate long function unit that conflicts with\n-;; both the left and right 16 bit insn slots.\n-\n-(define_function_unit \"short\" 2 2\n-  (and (eq_attr \"m32r\" \"yes\")\n+;; The m32rx core has two execution pipes.  We name them o_E and s_E.\n+;; In addition, there's a memory unit.\n+\n+(define_cpu_unit \"o_IF,s_IF,o_E,s_E,memory\" \"m32r\")\n+\n+;; Prevent the s pipe from being reserved before the o pipe.\n+(final_presence_set \"s_IF\" \"o_IF\")\n+(final_presence_set \"s_E\" \"o_E\")\n+\n+;; On the M32Rx, long instructions execute on both pipes, so reserve\n+;; both fetch slots and both pipes.\n+(define_reservation \"long_IF\" \"o_IF+s_IF\")\n+(define_reservation \"long_E\" \"o_E+s_E\")\n+\n+;; ::::::::::::::::::::\n+\n+;; Simple instructions do 4 stages: IF D E WB.  WB is not modelled.\n+;; Hence, ready latency is 1.\n+(define_insn_reservation \"short_left\" 1\n+  (and (eq_attr \"m32r_pipeline\" \"o\")\n+       (and (eq_attr \"insn_size\" \"short\")\n+\t    (eq_attr \"type\" \"!load2\")))\n+  \"o_IF,o_E\")\n+\n+(define_insn_reservation \"short_right\" 1\n+  (and (eq_attr \"m32r_pipeline\" \"s\")\n        (and (eq_attr \"insn_size\" \"short\")\n \t    (eq_attr \"type\" \"!load2\")))\n-  1 0\n-  [(eq_attr \"insn_size\" \"long\")])\n+  \"s_IF,s_E\")\n \n-(define_function_unit \"short\" 2 2\t;; load delay of 1 clock for mem execution + 1 clock for WB\n-  (and (eq_attr \"m32r\" \"yes\")\n-       (eq_attr \"type\" \"load2\"))\n-  3 0\n-  [(eq_attr \"insn_size\" \"long\")])\n+(define_insn_reservation \"short_either\" 1\n+  (and (eq_attr \"m32r_pipeline\" \"either\")\n+       (and (eq_attr \"insn_size\" \"short\")\n+\t    (eq_attr \"type\" \"!load2\")))\n+  \"o_IF|s_IF,o_E|s_E\")\n \n-(define_function_unit \"long\" 1 1\n-  (and (eq_attr \"m32r\" \"yes\")\n+(define_insn_reservation \"long_m32r\" 1\n+  (and (eq_attr \"cpu\" \"m32r\")\n        (and (eq_attr \"insn_size\" \"long\")\n \t    (eq_attr \"type\" \"!load4,load8\")))\n-  1 0\n-  [(eq_attr \"insn_size\" \"short\")])\n+  \"long_IF,long_E\")\n \n-(define_function_unit \"long\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n-  (and (eq_attr \"m32r\" \"yes\")\n-       (and (eq_attr \"insn_size\" \"long\")\n-\t    (eq_attr \"type\" \"load4,load8\")))\n-  3 0\n-  [(eq_attr \"insn_size\" \"short\")])\n-\n-(define_function_unit \"left\" 1 1\n-  (and (eq_attr \"m32rx_pipeline\" \"o,either\")\n-       (eq_attr \"type\" \"!load2\"))\n-  1 0\n-  [(eq_attr \"insn_size\" \"long\")])\n-\n-(define_function_unit \"left\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n-  (and (eq_attr \"m32rx_pipeline\" \"o,either\")\n-       (eq_attr \"type\" \"load2\"))\n-  3 0\n-  [(eq_attr \"insn_size\" \"long\")])\n-\n-(define_function_unit \"right\" 1 1\n-  (eq_attr \"m32rx_pipeline\" \"s,either\")\n-  1 0\n-  [(eq_attr \"insn_size\" \"long\")])\n-\n-(define_function_unit \"long\" 1 1\n-  (and (eq_attr \"m32rx\" \"yes\")\n+(define_insn_reservation \"long_m32rx\" 2\n+  (and (eq_attr \"m32r_pipeline\" \"long\")\n        (and (eq_attr \"insn_size\" \"long\")\n \t    (eq_attr \"type\" \"!load4,load8\")))\n-  2 0\n-  [(eq_attr \"insn_size\" \"short\")])\n+  \"long_IF,long_E\")\n+\n+;; Load/store instructions do 6 stages: IF D E MEM1 MEM2 WB.\n+;; MEM1 may require more than one cycle depending on locality.  We\n+;; optimistically assume all memory is nearby, ie. MEM1 takes only\n+;; one cycle.  Hence, ready latency is 3.\n+\n+;; The M32Rx can do short load/store only on the left pipe.\n+(define_insn_reservation \"short_load_left\" 3\n+  (and (eq_attr \"m32r_pipeline\" \"o\")\n+       (and (eq_attr \"insn_size\" \"short\")\n+\t    (eq_attr \"type\" \"load2\")))\n+  \"o_IF,o_E,memory*2\")\n \n-(define_function_unit \"long\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n-  (and (eq_attr \"m32rx\" \"yes\")\n+(define_insn_reservation \"short_load\" 3\n+  (and (eq_attr \"m32r_pipeline\" \"either\")\n+       (and (eq_attr \"insn_size\" \"short\")\n+\t    (eq_attr \"type\" \"load2\")))\n+  \"s_IF|o_IF,s_E|o_E,memory*2\")\n+\n+(define_insn_reservation \"long_load\" 3\n+  (and (eq_attr \"cpu\" \"m32r\")\n        (and (eq_attr \"insn_size\" \"long\")\n \t    (eq_attr \"type\" \"load4,load8\")))\n-  3 0\n-  [(eq_attr \"insn_size\" \"short\")])\n+  \"long_IF,long_E,memory*2\")\n+\n+(define_insn_reservation \"long_load_m32rx\" 3\n+  (and (eq_attr \"m32r_pipeline\" \"long\")\n+       (eq_attr \"type\" \"load4,load8\"))\n+  \"long_IF,long_E,memory*2\")\n+\n \f\n ;; Expand prologue as RTL\n (define_expand \"prologue\""}, {"sha": "2c4b5300ec4026c8c9305323e57b744564bb1f7a", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=5ad6fca5c3cfc7f8b8ee11163a6db53d80c30e96", "patch": "@@ -233,7 +233,7 @@ struct gcc_target\n     rtx (* dfa_post_cycle_insn) (void);\n     /* The following member value is a pointer to a function returning value\n        which defines how many insns in queue `ready' will we try for\n-       multi-pass scheduling.  if the member value is nonzero and the\n+       multi-pass scheduling.  If the member value is nonzero and the\n        function returns positive value, the DFA based scheduler will make\n        multi-pass scheduling for the first cycle.  In other words, we will\n        try to choose ready insn which permits to start maximum number of"}]}