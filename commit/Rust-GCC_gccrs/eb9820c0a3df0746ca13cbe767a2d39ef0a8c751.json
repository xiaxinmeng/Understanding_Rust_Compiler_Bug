{"sha": "eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI5ODIwYzBhM2RmMDc0NmNhMTNjYmU3NjdhMmQzOWVmMGE4Yzc1MQ==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-07-27T14:59:40Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-07-27T14:59:40Z"}, "message": "gimple-fold.c (or_comparisons_1): Remove TRUTH_AND/OR expression handling.\n\n2011-07-27  Kai Tietz  <ktietz@redhat.com>\n\n        * gimple-fold.c (or_comparisons_1): Remove TRUTH_AND/OR\n        expression handling.\n        (and_var_with_comparison_1): Likewise.\n\nFrom-SVN: r176827", "tree": {"sha": "8637e94071dbdcec7fd0d5b0c89566bc5503cc18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8637e94071dbdcec7fd0d5b0c89566bc5503cc18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751/comments", "author": null, "committer": null, "parents": [{"sha": "1169e45d2716d769be78cf38bcea449414e6ce75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1169e45d2716d769be78cf38bcea449414e6ce75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1169e45d2716d769be78cf38bcea449414e6ce75"}], "stats": {"total": 26, "additions": 16, "deletions": 10}, "files": [{"sha": "996bb931166d27f6b25e2421eaeb6072f4007491", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "patch": "@@ -1,3 +1,9 @@\n+2011-07-27  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* gimple-fold.c (or_comparisons_1): Remove TRUTH_AND/OR\n+\texpression handling.\n+\t(and_var_with_comparison_1): Likewise.\n+\n 2011-07-27  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* params.h (ALLOW_STORE_DATA_RACES): New."}, {"sha": "cc89b2fd4fb661dad909eb3ba66f1ef7b760823c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb9820c0a3df0746ca13cbe767a2d39ef0a8c751/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=eb9820c0a3df0746ca13cbe767a2d39ef0a8c751", "patch": "@@ -1937,17 +1937,15 @@ and_var_with_comparison_1 (gimple stmt,\n \n   /* If the definition is an AND or OR expression, we may be able to\n      simplify by reassociating.  */\n-  if (innercode == TRUTH_AND_EXPR\n-      || innercode == TRUTH_OR_EXPR\n-      || (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n-\t  && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR)))\n+  if (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n+      && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR))\n     {\n       tree inner1 = gimple_assign_rhs1 (stmt);\n       tree inner2 = gimple_assign_rhs2 (stmt);\n       gimple s;\n       tree t;\n       tree partial = NULL_TREE;\n-      bool is_and = (innercode == TRUTH_AND_EXPR || innercode == BIT_AND_EXPR);\n+      bool is_and = (innercode == BIT_AND_EXPR);\n       \n       /* Check for boolean identities that don't require recursive examination\n \t of inner1/inner2:\n@@ -2069,6 +2067,7 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n   if (operand_equal_p (op1a, op2a, 0)\n       && operand_equal_p (op1b, op2b, 0))\n     {\n+      /* Result will be either NULL_TREE, or a combined comparison.  */\n       tree t = combine_comparisons (UNKNOWN_LOCATION,\n \t\t\t\t    TRUTH_ANDIF_EXPR, code1, code2,\n \t\t\t\t    boolean_type_node, op1a, op1b);\n@@ -2080,6 +2079,7 @@ and_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n   if (operand_equal_p (op1a, op2b, 0)\n       && operand_equal_p (op1b, op2a, 0))\n     {\n+      /* Result will be either NULL_TREE, or a combined comparison.  */\n       tree t = combine_comparisons (UNKNOWN_LOCATION,\n \t\t\t\t    TRUTH_ANDIF_EXPR, code1,\n \t\t\t\t    swap_tree_comparison (code2),\n@@ -2398,17 +2398,15 @@ or_var_with_comparison_1 (gimple stmt,\n   \n   /* If the definition is an AND or OR expression, we may be able to\n      simplify by reassociating.  */\n-  if (innercode == TRUTH_AND_EXPR\n-      || innercode == TRUTH_OR_EXPR\n-      || (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n-\t  && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR)))\n+  if (TREE_CODE (TREE_TYPE (var)) == BOOLEAN_TYPE\n+      && (innercode == BIT_AND_EXPR || innercode == BIT_IOR_EXPR))\n     {\n       tree inner1 = gimple_assign_rhs1 (stmt);\n       tree inner2 = gimple_assign_rhs2 (stmt);\n       gimple s;\n       tree t;\n       tree partial = NULL_TREE;\n-      bool is_or = (innercode == TRUTH_OR_EXPR || innercode == BIT_IOR_EXPR);\n+      bool is_or = (innercode == BIT_IOR_EXPR);\n       \n       /* Check for boolean identities that don't require recursive examination\n \t of inner1/inner2:\n@@ -2531,6 +2529,7 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n   if (operand_equal_p (op1a, op2a, 0)\n       && operand_equal_p (op1b, op2b, 0))\n     {\n+      /* Result will be either NULL_TREE, or a combined comparison.  */\n       tree t = combine_comparisons (UNKNOWN_LOCATION,\n \t\t\t\t    TRUTH_ORIF_EXPR, code1, code2,\n \t\t\t\t    boolean_type_node, op1a, op1b);\n@@ -2542,6 +2541,7 @@ or_comparisons_1 (enum tree_code code1, tree op1a, tree op1b,\n   if (operand_equal_p (op1a, op2b, 0)\n       && operand_equal_p (op1b, op2a, 0))\n     {\n+      /* Result will be either NULL_TREE, or a combined comparison.  */\n       tree t = combine_comparisons (UNKNOWN_LOCATION,\n \t\t\t\t    TRUTH_ORIF_EXPR, code1,\n \t\t\t\t    swap_tree_comparison (code2),"}]}