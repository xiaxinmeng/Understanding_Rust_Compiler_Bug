{"sha": "a521e62615e439aea7502a52fd0f8a21eaa6304f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUyMWU2MjYxNWU0MzlhZWE3NTAyYTUyZmQwZjhhMjFlYWE2MzA0Zg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-09-18T20:36:16Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-09-18T20:36:16Z"}, "message": "re PR libstdc++/87135 ([C++17] unordered containers violate iterator validity requirements)\n\n2018-09-18  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/87135\n\t* src/c++11/hashtable_c++0x.cc:\n\t(_Prime_rehash_policy::_M_next_bkt): Return a prime no smaller than\n\trequested size, but not necessarily greater.\n\t(_Prime_rehash_policy::_M_need_rehash): Rehash only if target size is\n\tstrictly greater than next resize threshold.\n\t* testsuite/23_containers/unordered_map/modifiers/reserve.cc: Adapt test\n\tto validate that there is no rehash as long as number of insertion is\n\tlower or equal to the reserved number of elements.\n\nFrom-SVN: r264413", "tree": {"sha": "0d8e691c655254cfc40fc4d1416b1a47c34e35bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d8e691c655254cfc40fc4d1416b1a47c34e35bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a521e62615e439aea7502a52fd0f8a21eaa6304f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a521e62615e439aea7502a52fd0f8a21eaa6304f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a521e62615e439aea7502a52fd0f8a21eaa6304f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a521e62615e439aea7502a52fd0f8a21eaa6304f/comments", "author": null, "committer": null, "parents": [{"sha": "998511a6100212931d039e3a46403d2d878c8e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/998511a6100212931d039e3a46403d2d878c8e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/998511a6100212931d039e3a46403d2d878c8e5a"}], "stats": {"total": 62, "additions": 48, "deletions": 14}, "files": [{"sha": "433bcdd44445258298a34b83204cd73141e872e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a521e62615e439aea7502a52fd0f8a21eaa6304f", "patch": "@@ -1,3 +1,15 @@\n+2018-09-18  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/87135\n+\t* src/c++11/hashtable_c++0x.cc:\n+\t(_Prime_rehash_policy::_M_next_bkt): Return a prime no smaller than\n+\trequested size, but not necessarily greater.\n+\t(_Prime_rehash_policy::_M_need_rehash): Rehash only if target size is\n+\tstrictly greater than next resize threshold.\n+\t* testsuite/23_containers/unordered_map/modifiers/reserve.cc: Adapt test\n+\tto validate that there is no rehash as long as number of insertion is\n+\tlower or equal to the reserved number of elements.\n+\n 2018-09-18  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/unique_ptr.h (__uniq_ptr_impl): Remove static assertion"}, {"sha": "462767612f0aacb800618bfe61c8bf735e9ae371", "filename": "libstdc++-v3/src/c++11/hashtable_c++0x.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc?ref=a521e62615e439aea7502a52fd0f8a21eaa6304f", "patch": "@@ -46,10 +46,10 @@ namespace __detail\n   {\n     // Optimize lookups involving the first elements of __prime_list.\n     // (useful to speed-up, eg, constructors)\n-    static const unsigned char __fast_bkt[13]\n-      = { 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11, 13, 13 };\n+    static const unsigned char __fast_bkt[]\n+      = { 2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11, 13, 13 };\n \n-    if (__n <= 12)\n+    if (__n < sizeof(__fast_bkt))\n       {\n \t_M_next_resize =\n \t  __builtin_ceil(__fast_bkt[__n] * (long double)_M_max_load_factor);\n@@ -65,9 +65,8 @@ namespace __detail\n     // iterator that can be dereferenced to get the last prime.\n     constexpr auto __last_prime = __prime_list + __n_primes - 1;\n \n-    // Look for 'n + 1' to make sure returned value will be greater than n.\n     const unsigned long* __next_bkt =\n-      std::lower_bound(__prime_list + 6, __last_prime, __n + 1);\n+      std::lower_bound(__prime_list + 6, __last_prime, __n);\n \n     if (__next_bkt == __last_prime)\n       // Set next resize to the max value so that we never try to rehash again\n@@ -95,7 +94,7 @@ namespace __detail\n   _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n \t\t std::size_t __n_ins) const\n   {\n-    if (__n_elt + __n_ins >= _M_next_resize)\n+    if (__n_elt + __n_ins > _M_next_resize)\n       {\n \tlong double __min_bkts = (__n_elt + __n_ins)\n \t\t\t\t   / (long double)_M_max_load_factor;"}, {"sha": "7f34325df870bb19c44b2a4225b3ad14c65cb421", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/modifiers/reserve.cc", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Freserve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a521e62615e439aea7502a52fd0f8a21eaa6304f/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Freserve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fmodifiers%2Freserve.cc?ref=a521e62615e439aea7502a52fd0f8a21eaa6304f", "patch": "@@ -18,23 +18,46 @@\n // <http://www.gnu.org/licenses/>.\n \n #include <unordered_map>\n+\n #include <testsuite_hooks.h>\n \n void test01()\n {\n-  const int N = 1000;\n-\n   typedef std::unordered_map<int, int> Map;\n   Map m;\n-  m.reserve(N);\n \n-  std::size_t bkts = m.bucket_count();\n-  for (int i = 0; i != N; ++i)\n+  // Make sure max load factor is 1 so that reserved elements is directly\n+  // the bucket count.\n+  m.max_load_factor(1);\n+\n+  int i = -1;\n+  for (;;)\n     {\n-      m.insert(std::make_pair(i, i));\n-      // As long as we insert less than the reserved number of elements we\n-      // shouldn't experiment any rehash.\n+      m.reserve(m.bucket_count());\n+\n+      std::size_t bkts = m.bucket_count();\n+\n+      m.reserve(bkts);\n       VERIFY( m.bucket_count() == bkts );\n+\n+      for (++i; i < bkts; ++i)\n+\t{\n+\t  m.insert(std::make_pair(i, i));\n+\n+\t  // As long as we insert less than the reserved number of elements we\n+\t  // shouldn't experiment any rehash.\n+\t  VERIFY( m.bucket_count() == bkts );\n+\n+\t  VERIFY( m.load_factor() <= m.max_load_factor() );\n+\t}\n+\n+      // One more element should rehash.\n+      m.insert(std::make_pair(i, i));\n+      VERIFY( m.bucket_count() != bkts );\n+      VERIFY( m.load_factor() <= m.max_load_factor() );\n+\n+      if (i > 1024)\n+\tbreak;\n     }\n }\n "}]}