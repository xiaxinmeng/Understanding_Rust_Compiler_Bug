{"sha": "0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3OGViZTRjNzgxNGIxMGYxMmUyZDJlZTY3MjM1ZmQ4M2Y5NDYyMQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-04-30T13:34:05Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-04-30T13:34:05Z"}, "message": "[AArch64] Properly handle SHIFT ops and EXTEND in aarch64_rtx_mult_cost\n\n\t* config/aarch64/aarch64.c (aarch64_shift_p): New function.\n\t(aarch64_rtx_mult_cost): Update comment to reflect that it also handles\n\tcombined arithmetic-shift ops.  Properly handle all shift and extend\n\toperations that can occur in combination with PLUS/MINUS.\n\tRename maybe_fma to compound_p.\n\t(aarch64_rtx_costs): Use aarch64_shift_p when costing compound\n\tarithmetic and shift operations.\n\nFrom-SVN: r222624", "tree": {"sha": "32aafdada8cb8ae28ef857d173de0ae642934a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32aafdada8cb8ae28ef857d173de0ae642934a86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a78ebe4c7814b10f12e2d2ee67235fd83f94621/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2533c820b3622de5982a3e079763395c5bef38c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2533c820b3622de5982a3e079763395c5bef38c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2533c820b3622de5982a3e079763395c5bef38c4"}], "stats": {"total": 63, "additions": 49, "deletions": 14}, "files": [{"sha": "4eacfc92d1a722e3039847aac63fddd2c337c805", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a78ebe4c7814b10f12e2d2ee67235fd83f94621/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a78ebe4c7814b10f12e2d2ee67235fd83f94621/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "patch": "@@ -1,3 +1,13 @@\n+2015-04-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_shift_p): New function.\n+\t(aarch64_rtx_mult_cost): Update comment to reflect that it also handles\n+\tcombined arithmetic-shift ops.  Properly handle all shift and extend\n+\toperations that can occur in combination with PLUS/MINUS.\n+\tRename maybe_fma to compound_p.\n+\t(aarch64_rtx_costs): Use aarch64_shift_p when costing compound\n+\tarithmetic and shift operations.\n+\n 2015-04-30  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_rtx_costs): Use extend_arith"}, {"sha": "595e185d44dc0b70f4f02d169a877c36fd773cbe", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a78ebe4c7814b10f12e2d2ee67235fd83f94621/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a78ebe4c7814b10f12e2d2ee67235fd83f94621/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0a78ebe4c7814b10f12e2d2ee67235fd83f94621", "patch": "@@ -5158,9 +5158,17 @@ aarch64_strip_extend (rtx x)\n   return x;\n }\n \n+/* Return true iff CODE is a shift supported in combination\n+   with arithmetic instructions.  */\n+static bool\n+aarch64_shift_p (enum rtx_code code)\n+{\n+  return code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT;\n+}\n+\n /* Helper function for rtx cost calculation.  Calculate the cost of\n-   a MULT, which may be part of a multiply-accumulate rtx.  Return\n-   the calculated cost of the expression, recursing manually in to\n+   a MULT or ASHIFT, which may be part of a compound PLUS/MINUS rtx.\n+   Return the calculated cost of the expression, recursing manually in to\n    operands where needed.  */\n \n static int\n@@ -5170,7 +5178,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params->insn_extra_cost;\n   int cost = 0;\n-  bool maybe_fma = (outer == PLUS || outer == MINUS);\n+  bool compound_p = (outer == PLUS || outer == MINUS);\n   machine_mode mode = GET_MODE (x);\n \n   gcc_checking_assert (code == MULT);\n@@ -5185,18 +5193,35 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n   if (GET_MODE_CLASS (mode) == MODE_INT)\n     {\n       /* The multiply will be canonicalized as a shift, cost it as such.  */\n-      if (CONST_INT_P (op1)\n-\t  && exact_log2 (INTVAL (op1)) > 0)\n+      if (aarch64_shift_p (GET_CODE (x))\n+\t  || (CONST_INT_P (op1)\n+\t      && exact_log2 (INTVAL (op1)) > 0))\n \t{\n+\t  bool is_extend = GET_CODE (op0) == ZERO_EXTEND\n+\t                   || GET_CODE (op0) == SIGN_EXTEND;\n \t  if (speed)\n \t    {\n-\t      if (maybe_fma)\n-\t\t/* ADD (shifted register).  */\n-\t\tcost += extra_cost->alu.arith_shift;\n+\t      if (compound_p)\n+\t        {\n+\t          if (REG_P (op1))\n+\t\t    /* ARITH + shift-by-register.  */\n+\t\t    cost += extra_cost->alu.arith_shift_reg;\n+\t\t  else if (is_extend)\n+\t\t    /* ARITH + extended register.  We don't have a cost field\n+\t\t       for ARITH+EXTEND+SHIFT, so use extend_arith here.  */\n+\t\t    cost += extra_cost->alu.extend_arith;\n+\t\t  else\n+\t\t    /* ARITH + shift-by-immediate.  */\n+\t\t    cost += extra_cost->alu.arith_shift;\n+\t\t}\n \t      else\n \t\t/* LSL (immediate).  */\n-\t\tcost += extra_cost->alu.shift;\n+\t        cost += extra_cost->alu.shift;\n+\n \t    }\n+\t  /* Strip extends as we will have costed them in the case above.  */\n+\t  if (is_extend)\n+\t    op0 = aarch64_strip_extend (op0);\n \n \t  cost += rtx_cost (op0, GET_CODE (op0), 0, speed);\n \n@@ -5214,7 +5239,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \n \t  if (speed)\n \t    {\n-\t      if (maybe_fma)\n+\t      if (compound_p)\n \t\t/* MADD/SMADDL/UMADDL.  */\n \t\tcost += extra_cost->mult[0].extend_add;\n \t      else\n@@ -5232,7 +5257,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \n       if (speed)\n \t{\n-\t  if (maybe_fma)\n+\t  if (compound_p)\n \t    /* MADD.  */\n \t    cost += extra_cost->mult[mode == DImode].add;\n \t  else\n@@ -5253,7 +5278,7 @@ aarch64_rtx_mult_cost (rtx x, int code, int outer, bool speed)\n \t  if (GET_CODE (op1) == NEG)\n \t    op1 = XEXP (op1, 0);\n \n-\t  if (maybe_fma)\n+\t  if (compound_p)\n \t    /* FMADD/FNMADD/FNMSUB/FMSUB.  */\n \t    cost += extra_cost->fp[mode == DFmode].fma;\n \t  else\n@@ -5831,7 +5856,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \n \t/* Cost this as an FMA-alike operation.  */\n \tif ((GET_CODE (new_op1) == MULT\n-\t     || GET_CODE (new_op1) == ASHIFT)\n+\t     || aarch64_shift_p (GET_CODE (new_op1)))\n \t    && code != COMPARE)\n \t  {\n \t    *cost += aarch64_rtx_mult_cost (new_op1, MULT,\n@@ -5901,7 +5926,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \tnew_op0 = aarch64_strip_extend (op0);\n \n \tif (GET_CODE (new_op0) == MULT\n-\t    || GET_CODE (new_op0) == ASHIFT)\n+\t    || aarch64_shift_p (GET_CODE (new_op0)))\n \t  {\n \t    *cost += aarch64_rtx_mult_cost (new_op0, MULT, PLUS,\n \t\t\t\t\t    speed);"}]}