{"sha": "fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUwZjZkZjQyNGEyZTEzYTdiZmRiZGM0MmRjZjI3ZDA3NjUwYzExOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-15T07:32:13Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-15T07:32:13Z"}, "message": "re PR target/54908 (misc regressions on emutls targets remain from dynamic initialization of non-function-local TLS variables)\n\n\tPR target/54908\n\t* libsupc++/atexit_thread.cc: Rewrite to keep the cleanup list\n\twith get/setspecific.  Destroy the key on dlclose.\n\nFrom-SVN: r192449", "tree": {"sha": "1696dcd339dfbaef1f0f15ef3d0c25601f68172f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1696dcd339dfbaef1f0f15ef3d0c25601f68172f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85b5d65a94c66fed37b29b04010b93fd13936219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b5d65a94c66fed37b29b04010b93fd13936219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b5d65a94c66fed37b29b04010b93fd13936219"}], "stats": {"total": 163, "additions": 78, "deletions": 85}, "files": [{"sha": "f361e2aaf088a8c41b9d934b1739b3f1b29869fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "patch": "@@ -1,3 +1,7 @@\n+2012-10-13  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/tls/thread_local7g.C: Require tls_native.\n+\n 2012-10-14  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/inh-ctor1.C: New."}, {"sha": "3479aeb31fa7fe8ecbaf9267797fa1754a211ca8", "filename": "gcc/testsuite/g++.dg/tls/thread_local7g.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C?ref=fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "patch": "@@ -3,7 +3,7 @@\n // { dg-require-alias }\n \n // The reference temp should be TLS, not normal data.\n-// { dg-final { scan-assembler-not \"\\\\.data\" } }\n+// { dg-final { scan-assembler-not \"\\\\.data\" { target tls_native } } }\n \n thread_local int&& ir = 42;\n "}, {"sha": "e6c16dbc9302fe7ccfb8ac217de96a6a9591675b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "patch": "@@ -1,3 +1,9 @@\n+2012-10-14  Jason Merrill  <jason@redhat.com>\n+\n+\tPR target/54908\n+\t* libsupc++/atexit_thread.cc: Rewrite to keep the cleanup list\n+\twith get/setspecific.  Destroy the key on dlclose.\n+\n 2012-10-12  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \t* include/ext/random: Add __gnu_cxx::arcsine_distribution<>"}, {"sha": "95bdcf09dec079554b5dca6a5ff6a8d6c594b86d", "filename": "libstdc++-v3/libsupc++/atexit_thread.cc", "status": "modified", "additions": 67, "deletions": 84, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe0f6df424a2e13a7bfdbdc42dcf27d07650c119/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fatexit_thread.cc?ref=fe0f6df424a2e13a7bfdbdc42dcf27d07650c119", "patch": "@@ -27,109 +27,92 @@\n #include \"bits/gthr.h\"\n \n namespace {\n-  // Data structure for the list of destructors: Singly-linked list\n-  // of arrays.\n-  class list\n+  // One element in a singly-linked stack of cleanups.\n+  struct elt\n   {\n-    struct elt\n-    {\n-      void *object;\n-      void (*destructor)(void *);\n-    };\n-\n-    static const int max_nelts = 32;\n-\n-    list *next;\n-    int nelts;\n-    elt array[max_nelts];\n-\n-    elt *allocate_elt();\n-  public:\n-    void run();\n-    static void run(void *p);\n-    int add_elt(void (*)(void *), void *);\n+    void (*destructor)(void *);\n+    void *object;\n+    elt *next;\n   };\n \n-  // Return the address of an open slot.\n-  list::elt *\n-  list::allocate_elt()\n-  {\n-    if (nelts < max_nelts)\n-      return &array[nelts++];\n-    if (!next)\n-      next = new (std::nothrow) list();\n-    if (!next)\n-      return 0;\n-    return next->allocate_elt();\n-  }\n+  // Keep a per-thread list of cleanups in gthread_key storage.\n+  __gthread_key_t key;\n+  // But also support non-threaded mode.\n+  elt *single_thread;\n \n-  // Run all the cleanups in the list.\n-  void\n-  list::run()\n+  // Run the specified stack of cleanups.\n+  void run (void *p)\n   {\n-    for (int i = nelts - 1; i >= 0; --i)\n-      array[i].destructor (array[i].object);\n-    if (next)\n-      next->run();\n+    elt *e = static_cast<elt*>(p);\n+    for (; e; e = e->next)\n+      e->destructor (e->object);\n   }\n \n-  // Static version to use as a callback to __gthread_key_create.\n-  void\n-  list::run(void *p)\n+  // Run the stack of cleanups for the current thread.\n+  void run ()\n   {\n-    static_cast<list *>(p)->run();\n+    void *e;\n+    if (__gthread_active_p ())\n+      e = __gthread_getspecific (key);\n+    else\n+      e = single_thread;\n+    run (e);\n   }\n \n-  // The list of cleanups is per-thread.\n-  thread_local list first;\n-\n-  // The pthread data structures for actually running the destructors at\n-  // thread exit are shared.  The constructor of the thread-local sentinel\n-  // object in add_elt performs the initialization.\n-  __gthread_key_t key;\n-  __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-  void run_current () { first.run(); }\n+  // Initialize the key for the cleanup stack.  We use a static local for\n+  // key init/delete rather than atexit so that delete is run on dlclose.\n   void key_init() {\n-    __gthread_key_create (&key, list::run);\n+    struct key_s {\n+      key_s() { __gthread_key_create (&key, run); }\n+      ~key_s() { __gthread_key_delete (key); }\n+    };\n+    static key_s ks;\n     // Also make sure the destructors are run by std::exit.\n     // FIXME TLS cleanups should run before static cleanups and atexit\n     // cleanups.\n-    std::atexit (run_current);\n+    std::atexit (run);\n   }\n-  struct sentinel\n-  {\n-    sentinel()\n+}\n+\n+extern \"C\" int\n+__cxxabiv1::__cxa_thread_atexit (void (*dtor)(void *), void *obj, void */*dso_handle*/)\n+  _GLIBCXX_NOTHROW\n+{\n+  // Do this initialization once.\n+  if (__gthread_active_p ())\n+    {\n+      // When threads are active use __gthread_once.\n+      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+      __gthread_once (&once, key_init);\n+    }\n+  else\n     {\n-      if (__gthread_active_p ())\n+      // And when threads aren't active use a static local guard.\n+      static bool queued;\n+      if (!queued)\n \t{\n-\t  __gthread_once (&once, key_init);\n-\t  __gthread_setspecific (key, &first);\n+\t  queued = true;\n+\t  std::atexit (run);\n \t}\n-      else\n-\tstd::atexit (run_current);\n     }\n-  };\n \n-  // Actually insert an element.\n-  int\n-  list::add_elt(void (*dtor)(void *), void *obj)\n-  {\n-    thread_local sentinel s;\n-    elt *e = allocate_elt ();\n-    if (!e)\n-      return -1;\n-    e->object = obj;\n-    e->destructor = dtor;\n-    return 0;\n-  }\n-}\n+  elt *first;\n+  if (__gthread_active_p ())\n+    first = static_cast<elt*>(__gthread_getspecific (key));\n+  else\n+    first = single_thread;\n \n-namespace __cxxabiv1\n-{\n-  extern \"C\" int\n-  __cxa_thread_atexit (void (*dtor)(void *), void *obj, void */*dso_handle*/)\n-    _GLIBCXX_NOTHROW\n-  {\n-    return first.add_elt (dtor, obj);\n-  }\n+  elt *new_elt = new (std::nothrow) elt;\n+  if (!new_elt)\n+    return -1;\n+  new_elt->destructor = dtor;\n+  new_elt->object = obj;\n+  new_elt->next = first;\n+\n+  if (__gthread_active_p ())\n+    __gthread_setspecific (key, new_elt);\n+  else\n+    single_thread = new_elt;\n+\n+  return 0;\n }"}]}