{"sha": "610d789832b57e9ab0158b330865e24b9b699040", "node_id": "C_kwDOANBUbNoAKDYxMGQ3ODk4MzJiNTdlOWFiMDE1OGIzMzA4NjVlMjRiOWI2OTkwNDA", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-05-27T17:36:06Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-05-27T18:19:02Z"}, "message": "d: Merge upstream dmd 4d07f22f2, druntime f89da313, phobos d46814c86.\n\nD front-end changes:\n\n    - `scope' semantics are now enforced in `@safe' code on pointers to\n      stack memory, but only as deprecation warnings.\n    - Overriding virtual functions are now marked with the `override'\n      and `final' in the generated headers of `-fdump-c++-spec='.\n    - `-fpreview=fiximmmutableconv` has been added that disallows\n      implicitly converting a return value with indirections to\n      immutable if it determines the result must be unique.\n\nD runtime changes:\n\n    - Posix (excluding Darwin): Switch default GC signals from SIGUSR1/2\n      to SIGRTMIN/SIGRTMIN+1\n\nPhobos changes:\n\n    - Import latest bug fixes to mainline.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 4d07f22f2\n\t* d-lang.cc (d_handle_option): Handle OPT_fpreview_fiximmutableconv.\n\t* lang.opt (fpreview=fiximmutableconv): New option.\n\t* runtime.def (ARRAYAPPENDT): Remove.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime f89da313.\n\t* src/MERGE: Merge upstream phobos d46814c86.\n\nSigned-off-by: Iain Buclaw <ibuclaw@gdcproject.org>", "tree": {"sha": "0b42094ea5f69e9fd0257dd578589a60ef6b736a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b42094ea5f69e9fd0257dd578589a60ef6b736a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610d789832b57e9ab0158b330865e24b9b699040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610d789832b57e9ab0158b330865e24b9b699040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610d789832b57e9ab0158b330865e24b9b699040", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610d789832b57e9ab0158b330865e24b9b699040/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d822f4bbd714c6595f70cc68888dcebecfb6662d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d822f4bbd714c6595f70cc68888dcebecfb6662d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d822f4bbd714c6595f70cc68888dcebecfb6662d"}], "stats": {"total": 4351, "additions": 2497, "deletions": 1854}, "files": [{"sha": "ef0fe0b8adb742839f00e63b8b75a747ab8720b3", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -581,6 +581,7 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.rvalueRefParam = FeatureState::enabled;\n       global.params.inclusiveInContracts = value;\n       global.params.shortenedMethods = value;\n+      global.params.fixImmutableConv = value;\n       break;\n \n     case OPT_fpreview_bitfields:\n@@ -615,6 +616,10 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       global.params.fixAliasThis = value;\n       break;\n \n+    case OPT_fpreview_fiximmutableconv:\n+      global.params.fixImmutableConv = value;\n+      break;\n+\n     case OPT_fpreview_in:\n       global.params.previewIn = value;\n       break;"}, {"sha": "c37da0585d9115f3372ccfdb3b1a6ef353d97951", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1,4 +1,4 @@\n-a6c5224b2d6b61fa3856aa8a3369581f7c949b68\n+4d07f22f29d098869ad937f0499d8895df089a71\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "f27ca0769c94803b29f71edc3670db0b587dc485", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -120,20 +120,20 @@ class AggregateDeclaration : public ScopeDsymbol\n     Sizeok sizeok;              // set when structsize contains valid data\n \n     virtual Scope *newScope(Scope *sc);\n-    void setScope(Scope *sc);\n+    void setScope(Scope *sc) override final;\n     size_t nonHiddenFields();\n     bool determineSize(const Loc &loc);\n     virtual void finalizeSize() = 0;\n-    uinteger_t size(const Loc &loc);\n+    uinteger_t size(const Loc &loc) override final;\n     bool fill(const Loc &loc, Expressions *elements, bool ctorinit);\n-    Type *getType();\n-    bool isDeprecated() const;         // is aggregate deprecated?\n+    Type *getType() override final;\n+    bool isDeprecated() const override final; // is aggregate deprecated?\n     void setDeprecated();\n     bool isNested() const;\n-    bool isExport() const;\n+    bool isExport() const override final;\n     Dsymbol *searchCtor();\n \n-    Visibility visible();\n+    Visibility visible() override final;\n \n     // 'this' type\n     Type *handleType() { return type; }\n@@ -143,8 +143,8 @@ class AggregateDeclaration : public ScopeDsymbol\n     // Back end\n     void *sinit;\n \n-    AggregateDeclaration *isAggregateDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    AggregateDeclaration *isAggregateDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n struct StructFlags\n@@ -186,28 +186,28 @@ class StructDeclaration : public AggregateDeclaration\n     TypeTuple *argTypes;\n \n     static StructDeclaration *create(const Loc &loc, Identifier *id, bool inObject);\n-    StructDeclaration *syntaxCopy(Dsymbol *s);\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    const char *kind() const;\n-    void finalizeSize();\n+    StructDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override final;\n+    const char *kind() const override;\n+    void finalizeSize() override final;\n     bool isPOD();\n \n-    StructDeclaration *isStructDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    StructDeclaration *isStructDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n \n     unsigned numArgTypes() const;\n     Type *argType(unsigned index);\n     bool hasRegularCtor(bool checkDisabled = false);\n };\n \n-class UnionDeclaration : public StructDeclaration\n+class UnionDeclaration final : public StructDeclaration\n {\n public:\n-    UnionDeclaration *syntaxCopy(Dsymbol *s);\n-    const char *kind() const;\n+    UnionDeclaration *syntaxCopy(Dsymbol *s) override;\n+    const char *kind() const override;\n \n-    UnionDeclaration *isUnionDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    UnionDeclaration *isUnionDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n struct BaseClass\n@@ -279,19 +279,19 @@ class ClassDeclaration : public AggregateDeclaration\n     Symbol *cpp_type_info_ptr_sym;      // cached instance of class Id.cpp_type_info_ptr\n \n     static ClassDeclaration *create(const Loc &loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject);\n-    const char *toPrettyChars(bool QualifyTypes = false);\n-    ClassDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n+    const char *toPrettyChars(bool QualifyTypes = false) override;\n+    ClassDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n     bool isBaseOf2(ClassDeclaration *cd);\n \n     #define OFFSET_RUNTIME 0x76543210\n     #define OFFSET_FWDREF 0x76543211\n     virtual bool isBaseOf(ClassDeclaration *cd, int *poffset);\n \n     bool isBaseInfoComplete();\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override final;\n     ClassDeclaration *searchBase(Identifier *ident);\n-    void finalizeSize();\n+    void finalizeSize() override;\n     bool hasMonitor();\n     bool isFuncHidden(FuncDeclaration *fd);\n     FuncDeclaration *findFunc(Identifier *ident, TypeFunction *tf);\n@@ -301,30 +301,30 @@ class ClassDeclaration : public AggregateDeclaration\n     virtual bool isCPPinterface() const;\n     bool isAbstract();\n     virtual int vtblOffset() const;\n-    const char *kind() const;\n+    const char *kind() const override;\n \n-    void addLocalClass(ClassDeclarations *);\n-    void addObjcSymbols(ClassDeclarations *classes, ClassDeclarations *categories);\n+    void addLocalClass(ClassDeclarations *) override final;\n+    void addObjcSymbols(ClassDeclarations *classes, ClassDeclarations *categories) override final;\n \n     // Back end\n     Dsymbol *vtblsym;\n     Dsymbol *vtblSymbol();\n \n-    ClassDeclaration *isClassDeclaration() { return (ClassDeclaration *)this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    ClassDeclaration *isClassDeclaration() override final { return (ClassDeclaration *)this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class InterfaceDeclaration : public ClassDeclaration\n+class InterfaceDeclaration final : public ClassDeclaration\n {\n public:\n-    InterfaceDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    bool isBaseOf(ClassDeclaration *cd, int *poffset);\n-    const char *kind() const;\n-    int vtblOffset() const;\n-    bool isCPPinterface() const;\n-    bool isCOMinterface() const;\n-\n-    InterfaceDeclaration *isInterfaceDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    InterfaceDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    bool isBaseOf(ClassDeclaration *cd, int *poffset) override;\n+    const char *kind() const override;\n+    int vtblOffset() const override;\n+    bool isCPPinterface() const override;\n+    bool isCOMinterface() const override;\n+\n+    InterfaceDeclaration *isInterfaceDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "c63d717a7bd415fa936be737e46332cd2c9f3868", "filename": "gcc/d/dmd/aliasthis.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Faliasthis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Faliasthis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -15,17 +15,17 @@\n \n /**************************************************************/\n \n-class AliasThis : public Dsymbol\n+class AliasThis final : public Dsymbol\n {\n public:\n    // alias Identifier this;\n     Identifier *ident;\n     Dsymbol    *sym;\n     bool       isDeprecated_;\n \n-    AliasThis *syntaxCopy(Dsymbol *);\n-    const char *kind() const;\n+    AliasThis *syntaxCopy(Dsymbol *) override;\n+    const char *kind() const override;\n     AliasThis *isAliasThis() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n-    bool isDeprecated() const { return this->isDeprecated_; }\n+    void accept(Visitor *v) override { v->visit(this); }\n+    bool isDeprecated() const override { return this->isDeprecated_; }\n };"}, {"sha": "1fe33a6ba515ba5e4654de09555de836da44e7ba", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -26,111 +26,111 @@ class AttribDeclaration : public Dsymbol\n \n     virtual Dsymbols *include(Scope *sc);\n     virtual Scope *newScope(Scope *sc);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope *sc);\n-    void importAll(Scope *sc);\n-    void addComment(const utf8_t *comment);\n-    const char *kind() const;\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n-    bool hasPointers();\n-    bool hasStaticCtorOrDtor();\n-    void checkCtorConstInit();\n-    void addLocalClass(ClassDeclarations *);\n-    AttribDeclaration *isAttribDeclaration() { return this; }\n-\n-    void accept(Visitor *v) { v->visit(this); }\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope *sc) override;\n+    void importAll(Scope *sc) override;\n+    void addComment(const utf8_t *comment) override;\n+    const char *kind() const override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override;\n+    bool hasPointers() override final;\n+    bool hasStaticCtorOrDtor() override final;\n+    void checkCtorConstInit() override final;\n+    void addLocalClass(ClassDeclarations *) override final;\n+    AttribDeclaration *isAttribDeclaration() override final { return this; }\n+\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class StorageClassDeclaration : public AttribDeclaration\n {\n public:\n     StorageClass stc;\n \n-    StorageClassDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    StorageClassDeclaration *isStorageClassDeclaration() { return this; }\n+    StorageClassDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override final;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    StorageClassDeclaration *isStorageClassDeclaration() override { return this; }\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DeprecatedDeclaration : public StorageClassDeclaration\n+class DeprecatedDeclaration final : public StorageClassDeclaration\n {\n public:\n     Expression *msg;\n     const char *msgstr;\n \n-    DeprecatedDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    void setScope(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    DeprecatedDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    void setScope(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class LinkDeclaration : public AttribDeclaration\n+class LinkDeclaration final : public AttribDeclaration\n {\n public:\n     LINK linkage;\n \n     static LinkDeclaration *create(const Loc &loc, LINK p, Dsymbols *decl);\n-    LinkDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    const char *toChars() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    LinkDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    const char *toChars() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CPPMangleDeclaration : public AttribDeclaration\n+class CPPMangleDeclaration final : public AttribDeclaration\n {\n public:\n     CPPMANGLE cppmangle;\n \n-    CPPMangleDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    void setScope(Scope *sc);\n-    const char *toChars() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    CPPMangleDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    void setScope(Scope *sc) override;\n+    const char *toChars() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CPPNamespaceDeclaration : public AttribDeclaration\n+class CPPNamespaceDeclaration final : public AttribDeclaration\n {\n public:\n     Expression *exp;\n \n-    CPPNamespaceDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    const char *toChars() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    CPPNamespaceDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    const char *toChars() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VisibilityDeclaration : public AttribDeclaration\n+class VisibilityDeclaration final : public AttribDeclaration\n {\n public:\n     Visibility visibility;\n     DArray<Identifier*> pkg_identifiers;\n \n-    VisibilityDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    const char *kind() const;\n-    const char *toPrettyChars(bool unused);\n-    VisibilityDeclaration *isVisibilityDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    VisibilityDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    const char *kind() const override;\n+    const char *toPrettyChars(bool unused) override;\n+    VisibilityDeclaration *isVisibilityDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AlignDeclaration : public AttribDeclaration\n+class AlignDeclaration final : public AttribDeclaration\n {\n public:\n     Expressions *alignExps;\n     structalign_t salign;\n \n     AlignDeclaration(const Loc &loc, Expression *ealign, Dsymbols *decl);\n-    AlignDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    AlignDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AnonDeclaration : public AttribDeclaration\n+class AnonDeclaration final : public AttribDeclaration\n {\n public:\n     bool isunion;\n@@ -139,24 +139,24 @@ class AnonDeclaration : public AttribDeclaration\n     unsigned anonstructsize;    // size of anonymous struct\n     unsigned anonalignsize;     // size of anonymous struct for alignment purposes\n \n-    AnonDeclaration *syntaxCopy(Dsymbol *s);\n-    void setScope(Scope *sc);\n-    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n-    const char *kind() const;\n-    AnonDeclaration *isAnonDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    AnonDeclaration *syntaxCopy(Dsymbol *s) override;\n+    void setScope(Scope *sc) override;\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override;\n+    const char *kind() const override;\n+    AnonDeclaration *isAnonDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PragmaDeclaration : public AttribDeclaration\n+class PragmaDeclaration final : public AttribDeclaration\n {\n public:\n     Expressions *args;          // array of Expression's\n \n-    PragmaDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n+    PragmaDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n     PINLINE evalPragmaInline(Scope* sc);\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class ConditionalDeclaration : public AttribDeclaration\n@@ -165,31 +165,31 @@ class ConditionalDeclaration : public AttribDeclaration\n     Condition *condition;\n     Dsymbols *elsedecl; // array of Dsymbol's for else block\n \n-    ConditionalDeclaration *syntaxCopy(Dsymbol *s);\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    Dsymbols *include(Scope *sc);\n-    void addComment(const utf8_t *comment);\n-    void setScope(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    ConditionalDeclaration *syntaxCopy(Dsymbol *s) override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override final;\n+    Dsymbols *include(Scope *sc) override;\n+    void addComment(const utf8_t *comment) override final;\n+    void setScope(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticIfDeclaration : public ConditionalDeclaration\n+class StaticIfDeclaration final : public ConditionalDeclaration\n {\n public:\n     ScopeDsymbol *scopesym;\n     bool addisdone;\n     bool onStack;\n \n-    StaticIfDeclaration *syntaxCopy(Dsymbol *s);\n-    Dsymbols *include(Scope *sc);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope *sc);\n-    void importAll(Scope *sc);\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticIfDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Dsymbols *include(Scope *sc) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope *sc) override;\n+    void importAll(Scope *sc) override;\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticForeachDeclaration : public AttribDeclaration\n+class StaticForeachDeclaration final : public AttribDeclaration\n {\n public:\n     StaticForeach *sfe;\n@@ -198,58 +198,58 @@ class StaticForeachDeclaration : public AttribDeclaration\n     bool cached;\n     Dsymbols *cache;\n \n-    StaticForeachDeclaration *syntaxCopy(Dsymbol *s);\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    Dsymbols *include(Scope *sc);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void addComment(const utf8_t *comment);\n-    void setScope(Scope *sc);\n-    void importAll(Scope *sc);\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticForeachDeclaration *syntaxCopy(Dsymbol *s) override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    Dsymbols *include(Scope *sc) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void addComment(const utf8_t *comment) override;\n+    void setScope(Scope *sc) override;\n+    void importAll(Scope *sc) override;\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ForwardingAttribDeclaration : public AttribDeclaration\n+class ForwardingAttribDeclaration final : public AttribDeclaration\n {\n public:\n     ForwardingScopeDsymbol *sym;\n \n-    Scope *newScope(Scope *sc);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    ForwardingAttribDeclaration *isForwardingAttribDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    Scope *newScope(Scope *sc) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    ForwardingAttribDeclaration *isForwardingAttribDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Mixin declarations\n \n-class CompileDeclaration : public AttribDeclaration\n+class CompileDeclaration final : public AttribDeclaration\n {\n public:\n     Expressions *exps;\n \n     ScopeDsymbol *scopesym;\n     bool compiled;\n \n-    CompileDeclaration *syntaxCopy(Dsymbol *s);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope *sc);\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    CompileDeclaration *syntaxCopy(Dsymbol *s) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope *sc) override;\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**\n  * User defined attributes look like:\n  *      @(args, ...)\n  */\n-class UserAttributeDeclaration : public AttribDeclaration\n+class UserAttributeDeclaration final : public AttribDeclaration\n {\n public:\n     Expressions *atts;\n \n-    UserAttributeDeclaration *syntaxCopy(Dsymbol *s);\n-    Scope *newScope(Scope *sc);\n-    void setScope(Scope *sc);\n+    UserAttributeDeclaration *syntaxCopy(Dsymbol *s) override;\n+    Scope *newScope(Scope *sc) override;\n+    void setScope(Scope *sc) override;\n     Expressions *getAttributes();\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "b33f288f9df03a1cd26f5cf20d1608594489daaa", "filename": "gcc/d/dmd/cond.h", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fcond.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fcond.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -35,14 +35,16 @@ class Condition : public ASTNode\n     Loc loc;\n     Include inc;\n \n+    DYNCAST dyncast() const override final { return DYNCAST_CONDITION; }\n+\n     virtual Condition *syntaxCopy() = 0;\n     virtual int include(Scope *sc) = 0;\n     virtual DebugCondition *isDebugCondition() { return NULL; }\n     virtual VersionCondition *isVersionCondition() { return NULL; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticForeach\n+class StaticForeach final : public RootObject\n {\n public:\n     Loc loc;\n@@ -62,37 +64,37 @@ class DVCondition : public Condition\n     Identifier *ident;\n     Module *mod;\n \n-    DVCondition *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    DVCondition *syntaxCopy() override final;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DebugCondition : public DVCondition\n+class DebugCondition final : public DVCondition\n {\n public:\n     static void addGlobalIdent(const char *ident);\n \n-    int include(Scope *sc);\n-    DebugCondition *isDebugCondition() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    int include(Scope *sc) override;\n+    DebugCondition *isDebugCondition() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VersionCondition : public DVCondition\n+class VersionCondition final : public DVCondition\n {\n public:\n     static void addGlobalIdent(const char *ident);\n     static void addPredefinedGlobalIdent(const char *ident);\n \n-    int include(Scope *sc);\n-    VersionCondition *isVersionCondition() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    int include(Scope *sc) override;\n+    VersionCondition *isVersionCondition() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticIfCondition : public Condition\n+class StaticIfCondition final : public Condition\n {\n public:\n     Expression *exp;\n \n-    StaticIfCondition *syntaxCopy();\n-    int include(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticIfCondition *syntaxCopy() override;\n+    int include(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "344933ace83c09d16c16b92ba52f01dc268d47aa", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 134, "deletions": 22, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -59,8 +59,16 @@ final class CParser(AST) : Parser!AST\n      */\n     Array!(void*) typedefTab;  /// Array of AST.Type[Identifier], typedef's indexed by Identifier\n \n+    /* This is passed in as a list of #define lines, as generated by the C preprocessor with the\n+     * appropriate switch to emit them. We append to it any #define's and #undef's encountered in the source\n+     * file, as cpp with the -dD embeds them in the preprocessed output file.\n+     * Once the file is parsed, then the #define's are converted to D symbols and appended to the array\n+     * of Dsymbols returned by parseModule().\n+     */\n+    OutBuffer* defines;\n+\n     extern (D) this(TARGET)(AST.Module _module, const(char)[] input, bool doDocComment,\n-                            const ref TARGET target)\n+                            const ref TARGET target, OutBuffer* defines)\n     {\n         super(_module, input, doDocComment);\n \n@@ -69,6 +77,7 @@ final class CParser(AST) : Parser!AST\n         linkage = LINK.c;\n         Ccompile = true;\n         this.packalign.setDefault();\n+        this.defines = defines;\n \n         // Configure sizes for C `long`, `long double`, `wchar_t`, ...\n         this.boolsize = target.boolsize;\n@@ -104,6 +113,8 @@ final class CParser(AST) : Parser!AST\n         {\n             if (token.value == TOK.endOfFile)\n             {\n+                addDefines();   // convert #define's to Dsymbols\n+\n                 // wrap the symbols in `extern (C) { symbols }`\n                 auto wrap = new AST.Dsymbols();\n                 auto ld = new AST.LinkDeclaration(token.loc, LINK.c, symbols);\n@@ -976,16 +987,19 @@ final class CParser(AST) : Parser!AST\n                         // ( type-name )\n                         e = new AST.TypeExp(loc, t);\n                     }\n-                    e = new AST.DotIdExp(loc, e, Id.__sizeof);\n-                    break;\n                 }\n-                // must be an expression\n-                e = cparsePrimaryExp();\n-                e = new AST.DotIdExp(loc, e, Id.__sizeof);\n-                break;\n+                else\n+                {\n+                    // must be an expression\n+                    e = cparseUnaryExp();\n+                }\n+            }\n+            else\n+            {\n+                //C11 6.5.3\n+                e = cparseUnaryExp();\n             }\n \n-            e = cparseUnaryExp();\n             e = new AST.DotIdExp(loc, e, Id.__sizeof);\n             break;\n         }\n@@ -1697,7 +1711,7 @@ final class CParser(AST) : Parser!AST\n         while (1)\n         {\n             Identifier id;\n-            AST.Expression asmname;\n+            AST.StringExp asmName;\n             auto dt = cparseDeclarator(DTR.xdirect, tspec, id, specifier);\n             if (!dt)\n             {\n@@ -1719,7 +1733,7 @@ final class CParser(AST) : Parser!AST\n                 case TOK.asm_:\n                 case TOK.__attribute__:\n                     if (token.value == TOK.asm_)\n-                        asmname = cparseSimpleAsmExpr();\n+                        asmName = cparseSimpleAsmExpr();\n                     if (token.value == TOK.__attribute__)\n                     {\n                         cparseGnuAttributes(specifier);\n@@ -1876,14 +1890,26 @@ final class CParser(AST) : Parser!AST\n                     s = new AST.LinkDeclaration(s.loc, linkage, decls);\n                 }\n                 // Saw `asm(\"name\")` in the function, type, or variable definition.\n-                // This maps directly to `pragma(mangle, \"name\")`\n-                if (asmname)\n+                // This is equivalent to `pragma(mangle, \"name\")` in D\n+                if (asmName)\n                 {\n-                    auto args = new AST.Expressions(1);\n-                    (*args)[0] = asmname;\n-                    auto decls = new AST.Dsymbols(1);\n-                    (*decls)[0] = s;\n-                    s = new AST.PragmaDeclaration(asmname.loc, Id.mangle, args, decls);\n+                    /*\n+                    https://issues.dlang.org/show_bug.cgi?id=23012\n+                    Ideally this would be translated to a pragma(mangle)\n+                    decl. This is not possible because ImportC symbols are\n+                    (currently) merged before semantic analysis is performed,\n+                    so the pragma(mangle) never effects any change on the declarations\n+                    it pertains too.\n+\n+                    Writing to mangleOverride directly avoids this, and is possible\n+                    because C only a StringExp is allowed unlike a full fat pragma(mangle)\n+                    which is more liberal.\n+                    */\n+                    if (auto p = s.isDeclaration())\n+                    {\n+                        auto str = asmName.peekString();\n+                        p.mangleOverride = str;\n+                    }\n                 }\n                 symbols.push(s);\n             }\n@@ -3062,15 +3088,15 @@ final class CParser(AST) : Parser!AST\n      * asm-string-literal:\n      *   string-literal\n      */\n-    private AST.Expression cparseSimpleAsmExpr()\n+    private AST.StringExp cparseSimpleAsmExpr()\n     {\n         nextToken();     // move past asm\n         check(TOK.leftParenthesis);\n         if (token.value != TOK.string_)\n             error(\"string literal expected\");\n         auto label = cparsePrimaryExp();\n         check(TOK.rightParenthesis);\n-        return label;\n+        return cast(AST.StringExp) label;\n     }\n \n     /*************************\n@@ -4250,12 +4276,21 @@ final class CParser(AST) : Parser!AST\n                 case TOK._Bool:\n                 //case TOK._Imaginary: // ? missing in Spec\n                 case TOK._Complex:\n-\n-                // typedef-name\n-                case TOK.identifier:    // will not know until semantic if typedef\n                     t = peek(t);\n                     break;\n \n+                case TOK.identifier:\n+                    // Use typedef table to disambiguate\n+                    if (isTypedef(t.ident))\n+                    {\n+                        t = peek(t);\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        return false;\n+                    }\n+\n                 // struct-or-union-specifier\n                 // enum-specifier\n                 case TOK.struct_:\n@@ -4891,6 +4926,17 @@ final class CParser(AST) : Parser!AST\n                 poundLine(n, false);\n                 return true;\n             }\n+            else if (defines && (n.ident == Id.define || n.ident == Id.undef))\n+            {\n+                /* Append this line to `defines`.\n+                 * Not canonicalizing it - assume it already is\n+                 */\n+                defines.writeByte('#');\n+                defines.writestring(n.ident.toString());\n+                skipToNextLine(defines);\n+                defines.writeByte('\\n');\n+                return true;\n+            }\n             else if (n.ident == Id.__pragma)\n             {\n                 pragmaDirective(scanloc);\n@@ -5078,4 +5124,70 @@ final class CParser(AST) : Parser!AST\n     }\n \n     //}\n+\n+    /******************************************************************************/\n+    /********************************* #define Parser *****************************/\n+    //{\n+\n+    /**\n+     * Go through the #define's in the defines buffer and see what we can convert\n+     * to Dsymbols, which are then appended to symbols[]\n+     */\n+    void addDefines()\n+    {\n+        if (!defines || defines.length < 10)  // minimum length of a #define line\n+            return;\n+        const length = defines.length;\n+        auto slice = defines.peekChars()[0 .. length];\n+        resetDefineLines(slice);                // reset lexer\n+\n+        const(char)* endp = &slice[length - 7];\n+\n+        Token n;\n+\n+        while (p < endp)\n+        {\n+            if (p[0 .. 7] == \"#define\")\n+            {\n+                p += 7;\n+                scan(&n);\n+                //printf(\"%s\\n\", n.toChars());\n+                if (n.value == TOK.identifier)\n+                {\n+                    auto id = n.ident;\n+                    scan(&n);\n+                    if (n.value == TOK.endOfLine)       // #define identifier\n+                    {\n+                        nextDefineLine();\n+                        continue;\n+                    }\n+                    if (n.value == TOK.int32Literal)\n+                    {\n+                        const value = n.intvalue;\n+                        scan(&n);\n+                        if (n.value == TOK.endOfLine)\n+                        {\n+                            /* Declare manifest constant:\n+                             *  enum id = value;\n+                             */\n+                            AST.Expression e = new AST.IntegerExp(scanloc, value, AST.Type.tint32);\n+                            auto v = new AST.VarDeclaration(scanloc, AST.Type.tint32, id, new AST.ExpInitializer(scanloc, e), STC.manifest);\n+                            symbols.push(v);\n+                            nextDefineLine();\n+                            continue;\n+                        }\n+                    }\n+                }\n+                skipToNextLine();\n+            }\n+            else if (n.value != TOK.endOfLine)\n+            {\n+                skipToNextLine();\n+            }\n+            nextDefineLine();\n+            assert(p - slice.ptr <= length);\n+        }\n+    }\n+\n+    //}\n }"}, {"sha": "ab022ff505e76ae31cff2e3ff92c0c98d8ca1c07", "filename": "gcc/d/dmd/ctfe.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fctfe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fctfe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfe.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -17,7 +17,7 @@\n   A reference to a class, or an interface. We need this when we\n   point to a base class (we must record what the type is).\n  */\n-class ClassReferenceExp : public Expression\n+class ClassReferenceExp final : public Expression\n {\n public:\n     StructLiteralExp *value;\n@@ -26,39 +26,39 @@ class ClassReferenceExp : public Expression\n     /// Return index of the field, or -1 if not found\n     /// Same as getFieldIndex, but checks for a direct match with the VarDeclaration\n     int findFieldIndexByName(VarDeclaration *v);\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**\n   An uninitialized value\n  */\n-class VoidInitExp : public Expression\n+class VoidInitExp final : public Expression\n {\n public:\n     VarDeclaration *var;\n \n-    const char *toChars() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *toChars() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**\n   Fake class which holds the thrown exception.\n   Used for implementing exception handling.\n */\n-class ThrownExceptionExp : public Expression\n+class ThrownExceptionExp final : public Expression\n {\n public:\n     ClassReferenceExp *thrown; // the thing being tossed\n-    const char *toChars() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *toChars() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n \n // This type is only used by the interpreter.\n \n-class CTFEExp : public Expression\n+class CTFEExp final : public Expression\n {\n public:\n-    const char *toChars() const;\n+    const char *toChars() const override;\n };"}, {"sha": "4607d6fee7ca665047e1b5b49d51207533f36bb7", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -824,9 +824,8 @@ MATCH implicitConvTo(Expression e, Type t)\n          * convert to immutable\n          */\n         if (e.f &&\n-            // lots of legacy code breaks with the following purity check\n-            (global.params.useDIP1000 != FeatureState.enabled || e.f.isPure() >= PURE.const_) &&\n-             e.f.isReturnIsolated() // check isReturnIsolated last, because it is potentially expensive.\n+            (!global.params.fixImmutableConv || e.f.isPure() >= PURE.const_) &&\n+            e.f.isReturnIsolated() // check isReturnIsolated last, because it is potentially expensive.\n            )\n         {\n             result = e.type.immutableOf().implicitConvTo(t);\n@@ -2768,16 +2767,14 @@ Expression scaleFactor(BinExp be, Scope* sc)\n     else\n         assert(0);\n \n-    if (sc.func && !sc.intypeof)\n+\n+    eoff = eoff.optimize(WANTvalue);\n+    if (eoff.op == EXP.int64 && eoff.toInteger() == 0)\n     {\n-        eoff = eoff.optimize(WANTvalue);\n-        if (eoff.op == EXP.int64 && eoff.toInteger() == 0)\n-        {\n-        }\n-        else if (sc.func.setUnsafe(false, be.loc, \"pointer arithmetic not allowed in @safe functions\"))\n-        {\n-            return ErrorExp.get();\n-        }\n+    }\n+    else if (sc.setUnsafe(false, be.loc, \"pointer arithmetic not allowed in @safe functions\"))\n+    {\n+        return ErrorExp.get();\n     }\n \n     return be;"}, {"sha": "2c7d381e797ec6748bac1b3ddf34c497d45499bc", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 197, "deletions": 199, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -122,10 +122,10 @@ class Declaration : public Dsymbol\n     Symbol* isym;               // import version of csym\n     DString mangleOverride;     // overridden symbol with pragma(mangle, \"...\")\n \n-    const char *kind() const;\n-    uinteger_t size(const Loc &loc);\n+    const char *kind() const override;\n+    uinteger_t size(const Loc &loc) override final;\n \n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override final;\n \n     bool isStatic() const { return (storage_class & STCstatic) != 0; }\n     LINK resolvedLinkage() const; // returns the linkage, resolving the target-specific `System` one\n@@ -142,7 +142,7 @@ class Declaration : public Dsymbol\n     bool isScope() const        { return (storage_class & STCscope) != 0; }\n     bool isSynchronized() const { return (storage_class & STCsynchronized) != 0; }\n     bool isParameter() const    { return (storage_class & STCparameter) != 0; }\n-    bool isDeprecated() const   { return (storage_class & STCdeprecated) != 0; }\n+    bool isDeprecated() const override final { return (storage_class & STCdeprecated) != 0; }\n     bool isOverride() const     { return (storage_class & STCoverride) != 0; }\n     bool isResult() const       { return (storage_class & STCresult) != 0; }\n     bool isField() const        { return (storage_class & STCfield) != 0; }\n@@ -154,72 +154,72 @@ class Declaration : public Dsymbol\n \n     bool isFuture() const { return (storage_class & STCfuture) != 0; }\n \n-    Visibility visible();\n+    Visibility visible() override final;\n \n-    Declaration *isDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    Declaration *isDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n \n-class TupleDeclaration : public Declaration\n+class TupleDeclaration final : public Declaration\n {\n public:\n     Objects *objects;\n     bool isexp;                 // true: expression tuple\n \n     TypeTuple *tupletype;       // !=NULL if this is a type tuple\n \n-    TupleDeclaration *syntaxCopy(Dsymbol *);\n-    const char *kind() const;\n-    Type *getType();\n-    Dsymbol *toAlias2();\n-    bool needThis();\n+    TupleDeclaration *syntaxCopy(Dsymbol *) override;\n+    const char *kind() const override;\n+    Type *getType() override;\n+    Dsymbol *toAlias2() override;\n+    bool needThis() override;\n \n-    TupleDeclaration *isTupleDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    TupleDeclaration *isTupleDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n \n-class AliasDeclaration : public Declaration\n+class AliasDeclaration final : public Declaration\n {\n public:\n     Dsymbol *aliassym;\n     Dsymbol *overnext;          // next in overload list\n     Dsymbol *_import;           // !=NULL if unresolved internal alias for selective import\n \n     static AliasDeclaration *create(const Loc &loc, Identifier *id, Type *type);\n-    AliasDeclaration *syntaxCopy(Dsymbol *);\n-    bool overloadInsert(Dsymbol *s);\n-    const char *kind() const;\n-    Type *getType();\n-    Dsymbol *toAlias();\n-    Dsymbol *toAlias2();\n-    bool isOverloadable() const;\n+    AliasDeclaration *syntaxCopy(Dsymbol *) override;\n+    bool overloadInsert(Dsymbol *s) override;\n+    const char *kind() const override;\n+    Type *getType() override;\n+    Dsymbol *toAlias() override;\n+    Dsymbol *toAlias2() override;\n+    bool isOverloadable() const override;\n \n-    AliasDeclaration *isAliasDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    AliasDeclaration *isAliasDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n \n-class OverDeclaration : public Declaration\n+class OverDeclaration final : public Declaration\n {\n public:\n     Dsymbol *overnext;          // next in overload list\n     Dsymbol *aliassym;\n \n-    const char *kind() const;\n-    bool equals(const RootObject *o) const;\n-    bool overloadInsert(Dsymbol *s);\n+    const char *kind() const override;\n+    bool equals(const RootObject *o) const override;\n+    bool overloadInsert(Dsymbol *s) override;\n \n-    Dsymbol *toAlias();\n+    Dsymbol *toAlias() override;\n     Dsymbol *isUnique();\n-    bool isOverloadable() const;\n+    bool isOverloadable() const override;\n \n-    OverDeclaration *isOverDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    OverDeclaration *isOverDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n@@ -271,26 +271,26 @@ class VarDeclaration : public Declaration\n     bool isArgDtorVar() const; // temporary created to handle scope destruction of a function argument\n     bool isArgDtorVar(bool v);\n     static VarDeclaration *create(const Loc &loc, Type *t, Identifier *id, Initializer *init, StorageClass storage_class = STCundefined);\n-    VarDeclaration *syntaxCopy(Dsymbol *);\n-    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n-    const char *kind() const;\n-    AggregateDeclaration *isThis();\n-    bool needThis();\n-    bool isExport() const;\n-    bool isImportedSymbol() const;\n+    VarDeclaration *syntaxCopy(Dsymbol *) override;\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override final;\n+    const char *kind() const override;\n+    AggregateDeclaration *isThis() override final;\n+    bool needThis() override final;\n+    bool isExport() const override final;\n+    bool isImportedSymbol() const override final;\n     bool isCtorinit() const;\n-    bool isDataseg();\n-    bool isThreadlocal();\n+    bool isDataseg() override final;\n+    bool isThreadlocal() override final;\n     bool isCTFE();\n     bool isOverlappedWith(VarDeclaration *v);\n-    bool hasPointers();\n+    bool hasPointers() override final;\n     bool canTakeAddressOf();\n     bool needsScopeDtor();\n-    void checkCtorConstInit();\n-    Dsymbol *toAlias();\n+    void checkCtorConstInit() override final;\n+    Dsymbol *toAlias() override final;\n     // Eliminate need for dynamic_cast\n-    VarDeclaration *isVarDeclaration() { return (VarDeclaration *)this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    VarDeclaration *isVarDeclaration() override final { return (VarDeclaration *)this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n@@ -303,23 +303,23 @@ class BitFieldDeclaration : public VarDeclaration\n     unsigned fieldWidth;\n     unsigned bitOffset;\n \n-    BitFieldDeclaration *syntaxCopy(Dsymbol*);\n-    BitFieldDeclaration *isBitFieldDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    BitFieldDeclaration *syntaxCopy(Dsymbol *) override;\n+    BitFieldDeclaration *isBitFieldDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n \n // This is a shell around a back end symbol\n \n-class SymbolDeclaration : public Declaration\n+class SymbolDeclaration final : public Declaration\n {\n public:\n     AggregateDeclaration *dsym;\n \n     // Eliminate need for dynamic_cast\n-    SymbolDeclaration *isSymbolDeclaration() { return (SymbolDeclaration *)this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    SymbolDeclaration *isSymbolDeclaration() override { return (SymbolDeclaration *)this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeInfoDeclaration : public VarDeclaration\n@@ -328,149 +328,149 @@ class TypeInfoDeclaration : public VarDeclaration\n     Type *tinfo;\n \n     static TypeInfoDeclaration *create(Type *tinfo);\n-    TypeInfoDeclaration *syntaxCopy(Dsymbol *);\n-    const char *toChars() const;\n+    TypeInfoDeclaration *syntaxCopy(Dsymbol *) override final;\n+    const char *toChars() const override final;\n \n-    TypeInfoDeclaration *isTypeInfoDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    TypeInfoDeclaration *isTypeInfoDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoStructDeclaration : public TypeInfoDeclaration\n+class TypeInfoStructDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoStructDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoClassDeclaration : public TypeInfoDeclaration\n+class TypeInfoClassDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoClassDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoInterfaceDeclaration : public TypeInfoDeclaration\n+class TypeInfoInterfaceDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoInterfaceDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoPointerDeclaration : public TypeInfoDeclaration\n+class TypeInfoPointerDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoPointerDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoArrayDeclaration : public TypeInfoDeclaration\n+class TypeInfoArrayDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoArrayDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoStaticArrayDeclaration : public TypeInfoDeclaration\n+class TypeInfoStaticArrayDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoStaticArrayDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoAssociativeArrayDeclaration : public TypeInfoDeclaration\n+class TypeInfoAssociativeArrayDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoAssociativeArrayDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoEnumDeclaration : public TypeInfoDeclaration\n+class TypeInfoEnumDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoEnumDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoFunctionDeclaration : public TypeInfoDeclaration\n+class TypeInfoFunctionDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoFunctionDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoDelegateDeclaration : public TypeInfoDeclaration\n+class TypeInfoDelegateDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoDelegateDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoTupleDeclaration : public TypeInfoDeclaration\n+class TypeInfoTupleDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoTupleDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoConstDeclaration : public TypeInfoDeclaration\n+class TypeInfoConstDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoConstDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoInvariantDeclaration : public TypeInfoDeclaration\n+class TypeInfoInvariantDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoInvariantDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoSharedDeclaration : public TypeInfoDeclaration\n+class TypeInfoSharedDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoSharedDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoWildDeclaration : public TypeInfoDeclaration\n+class TypeInfoWildDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoWildDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeInfoVectorDeclaration : public TypeInfoDeclaration\n+class TypeInfoVectorDeclaration final : public TypeInfoDeclaration\n {\n public:\n     static TypeInfoVectorDeclaration *create(Type *tinfo);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/\n \n-class ThisDeclaration : public VarDeclaration\n+class ThisDeclaration final : public VarDeclaration\n {\n public:\n-    ThisDeclaration *syntaxCopy(Dsymbol *);\n-    ThisDeclaration *isThisDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    ThisDeclaration *syntaxCopy(Dsymbol *) override;\n+    ThisDeclaration *isThisDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n enum class ILS : unsigned char\n@@ -614,9 +614,7 @@ class FuncDeclaration : public Declaration\n \n     FuncDeclarations *inlinedNestedCallees;\n \n-private:\n     AttributeViolation* safetyViolation;\n-public:\n \n     unsigned flags;                     // FUNCFLAGxxxxx\n \n@@ -625,31 +623,31 @@ class FuncDeclaration : public Declaration\n     ObjcFuncDeclaration objc;\n \n     static FuncDeclaration *create(const Loc &loc, const Loc &endloc, Identifier *id, StorageClass storage_class, Type *type, bool noreturn = false);\n-    FuncDeclaration *syntaxCopy(Dsymbol *);\n+    FuncDeclaration *syntaxCopy(Dsymbol *) override;\n     bool functionSemantic();\n     bool functionSemantic3();\n-    bool equals(const RootObject *o) const;\n+    bool equals(const RootObject *o) const override final;\n \n     int overrides(FuncDeclaration *fd);\n     int findVtblIndex(Dsymbols *vtbl, int dim);\n     BaseClass *overrideInterface();\n-    bool overloadInsert(Dsymbol *s);\n+    bool overloadInsert(Dsymbol *s) override;\n     bool inUnittest();\n     MATCH leastAsSpecialized(FuncDeclaration *g);\n     LabelDsymbol *searchLabel(Identifier *ident, const Loc &loc);\n     int getLevel(FuncDeclaration *fd, int intypeof); // lexical nesting level difference\n     int getLevelAndCheck(const Loc &loc, Scope *sc, FuncDeclaration *fd);\n-    const char *toPrettyChars(bool QualifyTypes = false);\n+    const char *toPrettyChars(bool QualifyTypes = false) override;\n     const char *toFullSignature();  // for diagnostics, e.g. 'int foo(int x, int y) pure'\n     bool isMain() const;\n     bool isCMain() const;\n     bool isWinMain() const;\n     bool isDllMain() const;\n-    bool isExport() const;\n-    bool isImportedSymbol() const;\n-    bool isCodeseg() const;\n-    bool isOverloadable() const;\n-    bool isAbstract();\n+    bool isExport() const override final;\n+    bool isImportedSymbol() const override final;\n+    bool isCodeseg() const override final;\n+    bool isOverloadable() const override final;\n+    bool isAbstract() override final;\n     PURE isPure();\n     PURE isPureBypassingInference();\n     bool isSafe();\n@@ -676,14 +674,14 @@ class FuncDeclaration : public Declaration\n     void isCrtDtor(bool v);\n \n     virtual bool isNested() const;\n-    AggregateDeclaration *isThis();\n-    bool needThis();\n+    AggregateDeclaration *isThis() override;\n+    bool needThis() override final;\n     bool isVirtualMethod();\n     virtual bool isVirtual() const;\n     bool isFinalFunc() const;\n     virtual bool addPreInvariant();\n     virtual bool addPostInvariant();\n-    const char *kind() const;\n+    const char *kind() const override;\n     bool isUnique();\n     bool needsClosure();\n     bool hasNestedFrameRefs();\n@@ -694,26 +692,26 @@ class FuncDeclaration : public Declaration\n \n     bool checkNRVO();\n \n-    FuncDeclaration *isFuncDeclaration() { return this; }\n+    FuncDeclaration *isFuncDeclaration() override final { return this; }\n \n     virtual FuncDeclaration *toAliasFunc() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class FuncAliasDeclaration : public FuncDeclaration\n+class FuncAliasDeclaration final : public FuncDeclaration\n {\n public:\n     FuncDeclaration *funcalias;\n     bool hasOverloads;\n \n-    FuncAliasDeclaration *isFuncAliasDeclaration() { return this; }\n-    const char *kind() const;\n+    FuncAliasDeclaration *isFuncAliasDeclaration() override { return this; }\n+    const char *kind() const override;\n \n-    FuncDeclaration *toAliasFunc();\n-    void accept(Visitor *v) { v->visit(this); }\n+    FuncDeclaration *toAliasFunc() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class FuncLiteralDeclaration : public FuncDeclaration\n+class FuncLiteralDeclaration final : public FuncDeclaration\n {\n public:\n     TOK tok;                       // TOKfunction or TOKdelegate\n@@ -722,151 +720,151 @@ class FuncLiteralDeclaration : public FuncDeclaration\n     // backend\n     bool deferToObj;\n \n-    FuncLiteralDeclaration *syntaxCopy(Dsymbol *);\n-    bool isNested() const;\n-    AggregateDeclaration *isThis();\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    FuncLiteralDeclaration *syntaxCopy(Dsymbol *) override;\n+    bool isNested() const override;\n+    AggregateDeclaration *isThis() override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n \n     void modifyReturns(Scope *sc, Type *tret);\n \n-    FuncLiteralDeclaration *isFuncLiteralDeclaration() { return this; }\n-    const char *kind() const;\n-    const char *toPrettyChars(bool QualifyTypes = false);\n-    void accept(Visitor *v) { v->visit(this); }\n+    FuncLiteralDeclaration *isFuncLiteralDeclaration() override { return this; }\n+    const char *kind() const override;\n+    const char *toPrettyChars(bool QualifyTypes = false) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CtorDeclaration : public FuncDeclaration\n+class CtorDeclaration final : public FuncDeclaration\n {\n public:\n     bool isCpCtor;\n-    CtorDeclaration *syntaxCopy(Dsymbol *);\n-    const char *kind() const;\n-    const char *toChars() const;\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    CtorDeclaration *syntaxCopy(Dsymbol *) override;\n+    const char *kind() const override;\n+    const char *toChars() const override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n \n-    CtorDeclaration *isCtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    CtorDeclaration *isCtorDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PostBlitDeclaration : public FuncDeclaration\n+class PostBlitDeclaration final : public FuncDeclaration\n {\n public:\n-    PostBlitDeclaration *syntaxCopy(Dsymbol *);\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n-    bool overloadInsert(Dsymbol *s);\n+    PostBlitDeclaration *syntaxCopy(Dsymbol *) override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n+    bool overloadInsert(Dsymbol *s) override;\n \n-    PostBlitDeclaration *isPostBlitDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    PostBlitDeclaration *isPostBlitDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DtorDeclaration : public FuncDeclaration\n+class DtorDeclaration final : public FuncDeclaration\n {\n public:\n-    DtorDeclaration *syntaxCopy(Dsymbol *);\n-    const char *kind() const;\n-    const char *toChars() const;\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n-    bool overloadInsert(Dsymbol *s);\n+    DtorDeclaration *syntaxCopy(Dsymbol *) override;\n+    const char *kind() const override;\n+    const char *toChars() const override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n+    bool overloadInsert(Dsymbol *s) override;\n \n-    DtorDeclaration *isDtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    DtorDeclaration *isDtorDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class StaticCtorDeclaration : public FuncDeclaration\n {\n public:\n-    StaticCtorDeclaration *syntaxCopy(Dsymbol *);\n-    AggregateDeclaration *isThis();\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n-    bool hasStaticCtorOrDtor();\n+    StaticCtorDeclaration *syntaxCopy(Dsymbol *) override;\n+    AggregateDeclaration *isThis() override final;\n+    bool isVirtual() const override final;\n+    bool addPreInvariant() override final;\n+    bool addPostInvariant() override final;\n+    bool hasStaticCtorOrDtor() override final;\n \n-    StaticCtorDeclaration *isStaticCtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticCtorDeclaration *isStaticCtorDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SharedStaticCtorDeclaration : public StaticCtorDeclaration\n+class SharedStaticCtorDeclaration final : public StaticCtorDeclaration\n {\n public:\n-    SharedStaticCtorDeclaration *syntaxCopy(Dsymbol *);\n+    SharedStaticCtorDeclaration *syntaxCopy(Dsymbol *) override;\n \n-    SharedStaticCtorDeclaration *isSharedStaticCtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    SharedStaticCtorDeclaration *isSharedStaticCtorDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class StaticDtorDeclaration : public FuncDeclaration\n {\n public:\n     VarDeclaration *vgate;      // 'gate' variable\n \n-    StaticDtorDeclaration *syntaxCopy(Dsymbol *);\n-    AggregateDeclaration *isThis();\n-    bool isVirtual() const;\n-    bool hasStaticCtorOrDtor();\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    StaticDtorDeclaration *syntaxCopy(Dsymbol *) override;\n+    AggregateDeclaration *isThis() override final;\n+    bool isVirtual() const override final;\n+    bool hasStaticCtorOrDtor() override final;\n+    bool addPreInvariant() override final;\n+    bool addPostInvariant() override final;\n \n-    StaticDtorDeclaration *isStaticDtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticDtorDeclaration *isStaticDtorDeclaration() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SharedStaticDtorDeclaration : public StaticDtorDeclaration\n+class SharedStaticDtorDeclaration final : public StaticDtorDeclaration\n {\n public:\n-    SharedStaticDtorDeclaration *syntaxCopy(Dsymbol *);\n+    SharedStaticDtorDeclaration *syntaxCopy(Dsymbol *) override;\n \n-    SharedStaticDtorDeclaration *isSharedStaticDtorDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    SharedStaticDtorDeclaration *isSharedStaticDtorDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class InvariantDeclaration : public FuncDeclaration\n+class InvariantDeclaration final : public FuncDeclaration\n {\n public:\n-    InvariantDeclaration *syntaxCopy(Dsymbol *);\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    InvariantDeclaration *syntaxCopy(Dsymbol *) override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n \n-    InvariantDeclaration *isInvariantDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    InvariantDeclaration *isInvariantDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class UnitTestDeclaration : public FuncDeclaration\n+class UnitTestDeclaration final : public FuncDeclaration\n {\n public:\n     char *codedoc; /** For documented unittest. */\n \n     // toObjFile() these nested functions after this one\n     FuncDeclarations deferredNested;\n \n-    UnitTestDeclaration *syntaxCopy(Dsymbol *);\n-    AggregateDeclaration *isThis();\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    UnitTestDeclaration *syntaxCopy(Dsymbol *) override;\n+    AggregateDeclaration *isThis() override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n \n-    UnitTestDeclaration *isUnitTestDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    UnitTestDeclaration *isUnitTestDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NewDeclaration : public FuncDeclaration\n+class NewDeclaration final : public FuncDeclaration\n {\n public:\n-    NewDeclaration *syntaxCopy(Dsymbol *);\n-    const char *kind() const;\n-    bool isVirtual() const;\n-    bool addPreInvariant();\n-    bool addPostInvariant();\n+    NewDeclaration *syntaxCopy(Dsymbol *) override;\n+    const char *kind() const override;\n+    bool isVirtual() const override;\n+    bool addPreInvariant() override;\n+    bool addPostInvariant() override;\n \n-    NewDeclaration *isNewDeclaration() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    NewDeclaration *isNewDeclaration() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "f8e5073a5f11e08f90296797675c1e589ab4f40c", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -363,6 +363,9 @@ extern (C++) final class Module : Package\n     int selfimports;            // 0: don't know, 1: does not, 2: does\n     Dsymbol[void*] tagSymTab;   /// ImportC: tag symbols that conflict with other symbols used as the index\n \n+    private OutBuffer defines;  // collect all the #define lines here\n+\n+\n     /*************************************\n      * Return true if module imports itself.\n      */\n@@ -677,33 +680,7 @@ extern (C++) final class Module : Package\n             FileName.equalsExt(srcfile.toString(), c_ext) &&\n             FileName.exists(srcfile.toString()))\n         {\n-            /* Look for \"importc.h\" by searching along import path.\n-             * It should be in the same place as \"object.d\"\n-             */\n-            const(char)* importc_h;\n-\n-            foreach (entry; (global.path ? (*global.path)[] : null))\n-            {\n-                auto f = FileName.combine(entry, \"importc.h\");\n-                if (FileName.exists(f) == 1)\n-                {\n-                     importc_h = f;\n-                     break;\n-                }\n-                FileName.free(f);\n-            }\n-\n-            if (importc_h)\n-            {\n-                if (global.params.verbose)\n-                    message(\"include   %s\", importc_h);\n-            }\n-            else\n-            {\n-                error(\"cannot find \\\"importc.h\\\" along import path\");\n-                fatal();\n-            }\n-            filename = global.preprocess(srcfile, importc_h, global.params.cppswitches, ifile);  // run C preprocessor\n+            filename = global.preprocess(srcfile, loc, global.params.cppswitches, ifile, &defines);  // run C preprocessor\n         }\n \n         if (auto result = global.fileManager.lookup(filename))\n@@ -1001,7 +978,7 @@ extern (C++) final class Module : Package\n         {\n             filetype = FileType.c;\n \n-            scope p = new CParser!AST(this, buf, cast(bool) docfile, target.c);\n+            scope p = new CParser!AST(this, buf, cast(bool) docfile, target.c, &defines);\n             p.nextToken();\n             checkCompiledImport();\n             members = p.parseModule();"}, {"sha": "3b3a527dc524d559419d534d1e08067dd2d4d663", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1978,8 +1978,9 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n         }\n \n         const DYNCAST kind = arrayContent.dyncast();\n-        if (kind == DYNCAST.dsymbol)\n+        switch (kind) with (DYNCAST)\n         {\n+        case dsymbol:\n             TupleDeclaration td = cast(TupleDeclaration) arrayContent;\n             /* $ gives the number of elements in the tuple\n              */\n@@ -1989,10 +1990,10 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n             v.storage_class |= STC.temp | STC.static_ | STC.const_;\n             v.dsymbolSemantic(sc);\n             return v;\n-        }\n-        if (kind == DYNCAST.type)\n-        {\n+        case type:\n             return dollarFromTypeTuple(loc, cast(TypeTuple) arrayContent, sc);\n+        default:\n+            break;\n         }\n         Expression exp = cast(Expression) arrayContent;\n         if (auto ie = exp.isIndexExp())\n@@ -2531,6 +2532,16 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n         if (log) printf(\" collision\\n\");\n         return null;\n     }\n+    /*\n+    Handle merging declarations with asm(\"foo\") and their definitions\n+    */\n+    static void mangleWrangle(Declaration oldDecl, Declaration newDecl)\n+    {\n+        if (oldDecl && newDecl)\n+        {\n+            newDecl.mangleOverride = oldDecl.mangleOverride ? oldDecl.mangleOverride : null;\n+        }\n+    }\n \n     auto vd = s.isVarDeclaration(); // new declaration\n     auto vd2 = s2.isVarDeclaration(); // existing declaration\n@@ -2548,6 +2559,8 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n         if (i1 && i2)\n             return collision();         // can't both have initializers\n \n+        mangleWrangle(vd2, vd);\n+\n         if (i1)                         // vd is the definition\n         {\n             vd2.storage_class |= STC.extern_;  // so toObjFile() won't emit it\n@@ -2593,6 +2606,8 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n         if (fd.fbody && fd2.fbody)\n             return collision();         // can't both have bodies\n \n+        mangleWrangle(fd2, fd);\n+\n         if (fd.fbody)                   // fd is the definition\n         {\n             if (log) printf(\" replace existing with new\\n\");"}, {"sha": "23a2c775d4c32ede9fdc9a0191e01a8a3e2f4a41", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -185,11 +185,11 @@ class Dsymbol : public ASTNode\n     UserAttributeDeclaration *userAttribDecl;   // user defined attributes\n \n     static Dsymbol *create(Identifier *);\n-    const char *toChars() const;\n+    const char *toChars() const override;\n     virtual const char *toPrettyCharsHelper(); // helper to print fully qualified (template) arguments\n     Loc getLoc();\n     const char *locToChars();\n-    bool equals(const RootObject *o) const;\n+    bool equals(const RootObject *o) const override;\n     bool isAnonymous() const;\n     void error(const Loc &loc, const char *format, ...);\n     void error(const char *format, ...);\n@@ -211,7 +211,7 @@ class Dsymbol : public ASTNode\n     Ungag ungagSpeculative();\n \n     // kludge for template.isSymbol()\n-    DYNCAST dyncast() const { return DYNCAST_DSYMBOL; }\n+    DYNCAST dyncast() const override final { return DYNCAST_DSYMBOL; }\n \n     virtual Identifier *getIdent();\n     virtual const char *toPrettyChars(bool QualifyTypes = false);\n@@ -310,7 +310,7 @@ class Dsymbol : public ASTNode\n     virtual OverloadSet *isOverloadSet() { return NULL; }\n     virtual CompileDeclaration *isCompileDeclaration() { return NULL; }\n     virtual StaticAssert *isStaticAssert() { return NULL; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Dsymbol that generates a scope\n@@ -329,89 +329,89 @@ class ScopeDsymbol : public Dsymbol\n     BitArray accessiblePackages, privateAccessiblePackages;\n \n public:\n-    ScopeDsymbol *syntaxCopy(Dsymbol *s);\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n+    ScopeDsymbol *syntaxCopy(Dsymbol *s) override;\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n     virtual void importScope(Dsymbol *s, Visibility visibility);\n     virtual bool isPackageAccessible(Package *p, Visibility visibility, int flags = 0);\n-    bool isforwardRef();\n+    bool isforwardRef() override final;\n     static void multiplyDefined(const Loc &loc, Dsymbol *s1, Dsymbol *s2);\n-    const char *kind() const;\n+    const char *kind() const override;\n     FuncDeclaration *findGetMembers();\n     virtual Dsymbol *symtabInsert(Dsymbol *s);\n     virtual Dsymbol *symtabLookup(Dsymbol *s, Identifier *id);\n-    bool hasStaticCtorOrDtor();\n+    bool hasStaticCtorOrDtor() override;\n \n-    ScopeDsymbol *isScopeDsymbol() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    ScopeDsymbol *isScopeDsymbol() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // With statement scope\n \n-class WithScopeSymbol : public ScopeDsymbol\n+class WithScopeSymbol final : public ScopeDsymbol\n {\n public:\n     WithStatement *withstate;\n \n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n \n-    WithScopeSymbol *isWithScopeSymbol() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    WithScopeSymbol *isWithScopeSymbol() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Array Index/Slice scope\n \n-class ArrayScopeSymbol : public ScopeDsymbol\n+class ArrayScopeSymbol final : public ScopeDsymbol\n {\n private:\n     RootObject *arrayContent;\n public:\n     Scope *sc;\n \n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = IgnoreNone);\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = IgnoreNone) override;\n \n-    ArrayScopeSymbol *isArrayScopeSymbol() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    ArrayScopeSymbol *isArrayScopeSymbol() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Overload Sets\n \n-class OverloadSet : public Dsymbol\n+class OverloadSet final : public Dsymbol\n {\n public:\n     Dsymbols a;         // array of Dsymbols\n \n     void push(Dsymbol *s);\n-    OverloadSet *isOverloadSet() { return this; }\n-    const char *kind() const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    OverloadSet *isOverloadSet() override { return this; }\n+    const char *kind() const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Forwarding ScopeDsymbol\n \n-class ForwardingScopeDsymbol : public ScopeDsymbol\n+class ForwardingScopeDsymbol final : public ScopeDsymbol\n {\n public:\n     ScopeDsymbol *forward;\n \n-    Dsymbol *symtabInsert(Dsymbol *s);\n-    Dsymbol *symtabLookup(Dsymbol *s, Identifier *id);\n-    void importScope(Dsymbol *s, Visibility visibility);\n-    const char *kind() const;\n+    Dsymbol *symtabInsert(Dsymbol *s) override;\n+    Dsymbol *symtabLookup(Dsymbol *s, Identifier *id) override;\n+    void importScope(Dsymbol *s, Visibility visibility) override;\n+    const char *kind() const override;\n \n-    ForwardingScopeDsymbol *isForwardingScopeDsymbol() { return this; }\n+    ForwardingScopeDsymbol *isForwardingScopeDsymbol() override { return this; }\n };\n \n-class ExpressionDsymbol : public Dsymbol\n+class ExpressionDsymbol final : public Dsymbol\n {\n public:\n     Expression *exp;\n \n-    ExpressionDsymbol *isExpressionDsymbol() { return this; }\n+    ExpressionDsymbol *isExpressionDsymbol() override { return this; }\n };\n \n // Table of Dsymbol's\n \n-class DsymbolTable : public RootObject\n+class DsymbolTable final : public RootObject\n {\n public:\n     AA *tab;"}, {"sha": "e49127220a01ed2a2fdf60a0708035d705138912", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -468,12 +468,9 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         dsym.type.checkComplexTransition(dsym.loc, sc);\n \n         // Calculate type size + safety checks\n-        if (sc.func && !sc.intypeof)\n+        if (dsym.storage_class & STC.gshared && !dsym.isMember())\n         {\n-            if (dsym.storage_class & STC.gshared && !dsym.isMember())\n-            {\n-                sc.func.setUnsafe(false, dsym.loc, \"__gshared not allowed in safe functions; use shared\");\n-            }\n+            sc.setUnsafe(false, dsym.loc, \"__gshared not allowed in safe functions; use shared\");\n         }\n \n         Dsymbol parent = dsym.toParent();\n@@ -857,23 +854,23 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n \n         // Calculate type size + safety checks\n-        if (sc.func && !sc.intypeof)\n+        if (1)\n         {\n             if (dsym._init && dsym._init.isVoidInitializer() &&\n                 (dsym.type.hasPointers() || dsym.type.hasInvariant())) // also computes type size\n             {\n                 if (dsym.type.hasPointers())\n-                    sc.func.setUnsafe(false, dsym.loc,\n+                    sc.setUnsafe(false, dsym.loc,\n                         \"`void` initializers for pointers not allowed in safe functions\");\n                 else\n-                    sc.func.setUnsafe(false, dsym.loc,\n+                    sc.setUnsafe(false, dsym.loc,\n                         \"`void` initializers for structs with invariants are not allowed in safe functions\");\n             }\n             else if (!dsym._init &&\n                      !(dsym.storage_class & (STC.static_ | STC.extern_ | STC.gshared | STC.manifest | STC.field | STC.parameter)) &&\n                      dsym.type.hasVoidInitPointers())\n             {\n-                sc.func.setUnsafe(false, dsym.loc, \"`void` initializers for pointers not allowed in safe functions\");\n+                sc.setUnsafe(false, dsym.loc, \"`void` initializers for pointers not allowed in safe functions\");\n             }\n         }\n \n@@ -3595,6 +3592,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         break;\n                     }\n \n+                    auto vtf = getFunctionType(fdv);\n+                    if (vtf.trust > TRUST.system && f.trust == TRUST.system)\n+                        funcdecl.error(\"cannot override `@safe` method `%s` with a `@system` attribute\",\n+                                       fdv.toPrettyChars);\n+\n                     if (fdc.toParent() == parent)\n                     {\n                         //printf(\"vi = %d,\\tthis = %p %s %s @ [%s]\\n\\tfdc  = %p %s %s @ [%s]\\n\\tfdv  = %p %s %s @ [%s]\\n\","}, {"sha": "a450ea559acf171a9accd6c5259aa8331deacd79", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -5352,7 +5352,7 @@ extern (C++) class TemplateParameter : ASTNode\n         return this.ident.toChars();\n     }\n \n-    override DYNCAST dyncast() const pure @nogc nothrow @safe\n+    override DYNCAST dyncast() const\n     {\n         return DYNCAST.templateparameter;\n     }"}, {"sha": "9afcc7fe6873a66f385cf51afd37e8fd7409a531", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -801,26 +801,22 @@ public:\n         if (adparent && fd.isDisabled && global.params.cplusplus < CppStdRevision.cpp11)\n             writeProtection(AST.Visibility.Kind.private_);\n         funcToBuffer(tf, fd);\n-        // FIXME: How to determine if fd is const without tf?\n-        if (adparent && tf && (tf.isConst() || tf.isImmutable()))\n+        if (adparent)\n         {\n-            bool fdOverridesAreConst = true;\n-            foreach (fdv; fd.foverrides)\n+            if (tf && (tf.isConst() || tf.isImmutable()))\n+                buf.writestring(\" const\");\n+            if (global.params.cplusplus >= CppStdRevision.cpp11)\n             {\n-                auto tfv = cast(AST.TypeFunction)fdv.type;\n-                if (!tfv.isConst() && !tfv.isImmutable())\n-                {\n-                    fdOverridesAreConst = false;\n-                    break;\n-                }\n+                if (fd.vtblIndex != -1 && !(adparent.storage_class & AST.STC.final_) && fd.isFinalFunc())\n+                    buf.writestring(\" final\");\n+                if (fd.isOverride())\n+                    buf.writestring(\" override\");\n             }\n-\n-            buf.writestring(fdOverridesAreConst ? \" const\" : \" /* const */\");\n+            if (fd.isAbstract())\n+                buf.writestring(\" = 0\");\n+            else if (global.params.cplusplus >= CppStdRevision.cpp11 && fd.isDisabled())\n+                buf.writestring(\" = delete\");\n         }\n-        if (adparent && fd.isAbstract())\n-            buf.writestring(\" = 0\");\n-        if (adparent && fd.isDisabled && global.params.cplusplus >= CppStdRevision.cpp11)\n-            buf.writestring(\" = delete\");\n         buf.writestringln(\";\");\n         if (adparent && fd.isDisabled && global.params.cplusplus < CppStdRevision.cpp11)\n             writeProtection(AST.Visibility.Kind.public_);"}, {"sha": "9ec130099feb520cb93fc1060a3fcfc66a3a710a", "filename": "gcc/d/dmd/enum.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fenum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fenum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fenum.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -17,7 +17,7 @@ class Identifier;\n class Type;\n class Expression;\n \n-class EnumDeclaration : public ScopeDsymbol\n+class EnumDeclaration final : public ScopeDsymbol\n {\n public:\n     /* The separate, and distinct, cases are:\n@@ -40,27 +40,27 @@ class EnumDeclaration : public ScopeDsymbol\n     bool added;\n     int inuse;\n \n-    EnumDeclaration *syntaxCopy(Dsymbol *s);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope *sc);\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    Type *getType();\n-    const char *kind() const;\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    bool isDeprecated() const;                // is Dsymbol deprecated?\n-    Visibility visible();\n+    EnumDeclaration *syntaxCopy(Dsymbol *s) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope *sc) override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    Type *getType() override;\n+    const char *kind() const override;\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n+    bool isDeprecated() const override;       // is Dsymbol deprecated?\n+    Visibility visible() override;\n     bool isSpecial() const;\n     Expression *getDefaultValue(const Loc &loc);\n     Type *getMemtype(const Loc &loc);\n \n-    EnumDeclaration *isEnumDeclaration() { return this; }\n+    EnumDeclaration *isEnumDeclaration() override { return this; }\n \n     Symbol *sinit;\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n \n-class EnumMember : public VarDeclaration\n+class EnumMember final : public VarDeclaration\n {\n public:\n     /* Can take the following forms:\n@@ -78,9 +78,9 @@ class EnumMember : public VarDeclaration\n \n     EnumDeclaration *ed;\n \n-    EnumMember *syntaxCopy(Dsymbol *s);\n-    const char *kind() const;\n+    EnumMember *syntaxCopy(Dsymbol *s) override;\n+    const char *kind() const override;\n \n-    EnumMember *isEnumMember() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    EnumMember *isEnumMember() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "97a655289b51d842699527b34b904d599b86c17a", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 150, "deletions": 81, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -145,7 +145,7 @@ bool checkMutableArguments(Scope* sc, FuncDeclaration fd, TypeFunction tf,\n             refs = true;\n             auto var = outerVars[i - (len - outerVars.length)];\n             eb.isMutable = var.type.isMutable();\n-            eb.er.byref.push(var);\n+            eb.er.pushRef(var, false);\n             continue;\n         }\n \n@@ -165,7 +165,7 @@ bool checkMutableArguments(Scope* sc, FuncDeclaration fd, TypeFunction tf,\n         if (!(eb.isMutable || eb2.isMutable))\n             return;\n \n-        if (!(global.params.useDIP1000 == FeatureState.enabled && sc.func.setUnsafe()))\n+        if (!(global.params.useDIP1000 == FeatureState.enabled && sc.setUnsafe()))\n             return;\n \n         if (!gag)\n@@ -1185,6 +1185,8 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         if (v.isDataseg())\n             continue;\n \n+        const vsr = buildScopeRef(v.storage_class);\n+\n         Dsymbol p = v.toParent2();\n \n         if ((v.isScope() || (v.storage_class & STC.maybescope)) &&\n@@ -1200,8 +1202,13 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n \n         if (v.isScope())\n         {\n-            if (v.storage_class & STC.return_)\n+            /* If `return scope` applies to v.\n+             */\n+            if (vsr == ScopeRef.ReturnScope ||\n+                vsr == ScopeRef.Ref_ReturnScope)\n+            {\n                 continue;\n+            }\n \n             auto pfunc = p.isFuncDeclaration();\n             if (pfunc &&\n@@ -1245,7 +1252,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         }\n     }\n \n-    foreach (VarDeclaration v; er.byref)\n+    foreach (i, VarDeclaration v; er.byref[])\n     {\n         if (log)\n         {\n@@ -1281,9 +1288,16 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n             }\n             else\n             {\n-                if (!gag)\n-                    previewErrorFunc(sc.isDeprecated(), featureState)(e.loc, msg, e.toChars(), v.toChars());\n-                result = true;\n+                if (er.refRetRefTransition[i])\n+                {\n+                    result |= sc.setUnsafeDIP1000(gag, e.loc, msg, e, v);\n+                }\n+                else\n+                {\n+                    if (!gag)\n+                        previewErrorFunc(sc.isDeprecated(), featureState)(e.loc, msg, e.toChars(), v.toChars());\n+                    result = true;\n+                }\n             }\n         }\n \n@@ -1374,14 +1388,21 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         }\n     }\n \n-    foreach (Expression ee; er.byexp)\n+    foreach (i, Expression ee; er.byexp[])\n     {\n         if (log) printf(\"byexp %s\\n\", ee.toChars());\n-        if (!gag)\n-            error(ee.loc, \"escaping reference to stack allocated value returned by `%s`\", ee.toChars());\n-        result = true;\n+        if (er.expRetRefTransition[i])\n+        {\n+            result |= sc.setUnsafeDIP1000(gag, ee.loc,\n+                \"escaping reference to stack allocated value returned by `%s`\", ee);\n+        }\n+        else\n+        {\n+            if (!gag)\n+                error(ee.loc, \"escaping reference to stack allocated value returned by `%s`\", ee.toChars());\n+            result = true;\n+        }\n     }\n-\n     return result;\n }\n \n@@ -1449,8 +1470,9 @@ private void inferReturn(FuncDeclaration fd, VarDeclaration v, bool returnScope)\n  *      e = expression to be returned by value\n  *      er = where to place collected data\n  *      live = if @live semantics apply, i.e. expressions `p`, `*p`, `**p`, etc., all return `p`.\n+  *     retRefTransition = if `e` is returned through a `return ref scope` function call\n  */\n-void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n+void escapeByValue(Expression e, EscapeByResults* er, bool live = false, bool retRefTransition = false)\n {\n     //printf(\"[%s] escapeByValue, e: %s\\n\", e.loc.toChars(), e.toChars());\n \n@@ -1465,14 +1487,14 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n          * but it'll be placed in static data so no need to check it.\n          */\n         if (e.e1.op != EXP.structLiteral)\n-            escapeByRef(e.e1, er, live);\n+            escapeByRef(e.e1, er, live, retRefTransition);\n     }\n \n     void visitSymOff(SymOffExp e)\n     {\n         VarDeclaration v = e.var.isVarDeclaration();\n         if (v)\n-            er.byref.push(v);\n+            er.pushRef(v, retRefTransition);\n     }\n \n     void visitVar(VarExp e)\n@@ -1494,25 +1516,25 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n     void visitPtr(PtrExp e)\n     {\n         if (live && e.type.hasPointers())\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitDotVar(DotVarExp e)\n     {\n         auto t = e.e1.type.toBasetype();\n         if (e.type.hasPointers() && (live || t.ty == Tstruct))\n         {\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n         }\n     }\n \n     void visitDelegate(DelegateExp e)\n     {\n         Type t = e.e1.type.toBasetype();\n         if (t.ty == Tclass || t.ty == Tpointer)\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n         else\n-            escapeByRef(e.e1, er, live);\n+            escapeByRef(e.e1, er, live, retRefTransition);\n         er.byfunc.push(e.func);\n     }\n \n@@ -1533,11 +1555,11 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         if (tb.ty == Tsarray || tb.ty == Tarray)\n         {\n             if (e.basis)\n-                escapeByValue(e.basis, er, live);\n+                escapeByValue(e.basis, er, live, retRefTransition);\n             foreach (el; *e.elements)\n             {\n                 if (el)\n-                    escapeByValue(el, er, live);\n+                    escapeByValue(el, er, live, retRefTransition);\n             }\n         }\n     }\n@@ -1549,7 +1571,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n             foreach (ex; *e.elements)\n             {\n                 if (ex)\n-                    escapeByValue(ex, er, live);\n+                    escapeByValue(ex, er, live, retRefTransition);\n             }\n         }\n     }\n@@ -1562,7 +1584,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n             foreach (ex; *e.arguments)\n             {\n                 if (ex)\n-                    escapeByValue(ex, er, live);\n+                    escapeByValue(ex, er, live, retRefTransition);\n             }\n         }\n     }\n@@ -1574,10 +1596,10 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         Type tb = e.type.toBasetype();\n         if (tb.ty == Tarray && e.e1.type.toBasetype().ty == Tsarray)\n         {\n-            escapeByRef(e.e1, er, live);\n+            escapeByRef(e.e1, er, live, retRefTransition);\n         }\n         else\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitSlice(SliceExp e)\n@@ -1602,18 +1624,18 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         {\n             Type tb = e.type.toBasetype();\n             if (tb.ty != Tsarray)\n-                escapeByRef(e.e1, er, live);\n+                escapeByRef(e.e1, er, live, retRefTransition);\n         }\n         else\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitIndex(IndexExp e)\n     {\n         if (e.e1.type.toBasetype().ty == Tsarray ||\n             live && e.type.hasPointers())\n         {\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n         }\n     }\n \n@@ -1622,30 +1644,30 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         Type tb = e.type.toBasetype();\n         if (tb.ty == Tpointer)\n         {\n-            escapeByValue(e.e1, er, live);\n-            escapeByValue(e.e2, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n+            escapeByValue(e.e2, er, live, retRefTransition);\n         }\n     }\n \n     void visitBinAssign(BinAssignExp e)\n     {\n-        escapeByValue(e.e1, er, live);\n+        escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitAssign(AssignExp e)\n     {\n-        escapeByValue(e.e1, er, live);\n+        escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitComma(CommaExp e)\n     {\n-        escapeByValue(e.e2, er, live);\n+        escapeByValue(e.e2, er, live, retRefTransition);\n     }\n \n     void visitCond(CondExp e)\n     {\n-        escapeByValue(e.e1, er, live);\n-        escapeByValue(e.e2, er, live);\n+        escapeByValue(e.e1, er, live, retRefTransition);\n+        escapeByValue(e.e2, er, live, retRefTransition);\n     }\n \n     void visitCall(CallExp e)\n@@ -1686,7 +1708,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n                     const stc = tf.parameterStorageClass(null, p);\n                     ScopeRef psr = buildScopeRef(stc);\n                     if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                        escapeByValue(arg, er, live);\n+                        escapeByValue(arg, er, live, retRefTransition);\n                     else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                     {\n                         if (tf.isref)\n@@ -1696,10 +1718,10 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n                              * as:\n                              *   p;\n                              */\n-                            escapeByValue(arg, er, live);\n+                            escapeByValue(arg, er, live, retRefTransition);\n                         }\n                         else\n-                            escapeByRef(arg, er, live);\n+                            escapeByRef(arg, er, live, retRefTransition);\n                     }\n                 }\n             }\n@@ -1709,7 +1731,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         {\n             DotVarExp dve = e.e1.isDotVarExp();\n             FuncDeclaration fd = dve.var.isFuncDeclaration();\n-            if (global.params.useDIP1000 == FeatureState.enabled)\n+            if (1)\n             {\n                 if (fd && fd.isThis())\n                 {\n@@ -1741,7 +1763,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n \n                     const psr = buildScopeRef(getThisStorageClass(fd));\n                     if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                        escapeByValue(dve.e1, er, live);\n+                        escapeByValue(dve.e1, er, live, retRefTransition);\n                     else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n                     {\n                         if (tf.isref)\n@@ -1751,10 +1773,10 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n                              * as:\n                              *   this;\n                              */\n-                            escapeByValue(dve.e1, er, live);\n+                            escapeByValue(dve.e1, er, live, retRefTransition);\n                         }\n                         else\n-                            escapeByRef(dve.e1, er, live);\n+                            escapeByRef(dve.e1, er, live, psr == ScopeRef.ReturnRef_Scope);\n                     }\n                 }\n             }\n@@ -1767,16 +1789,16 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n \n                 const psr = buildScopeRef(stc);\n                 if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                    escapeByValue(dve.e1, er, live);\n+                    escapeByValue(dve.e1, er, live, retRefTransition);\n                 else if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n-                    escapeByRef(dve.e1, er, live);\n+                    escapeByRef(dve.e1, er, live, retRefTransition);\n             }\n \n             // If it's also a nested function that is 'return scope'\n             if (fd && fd.isNested())\n             {\n                 if (tf.isreturn && tf.isScopeQual)\n-                    er.byexp.push(e);\n+                    er.pushExp(e, false);\n             }\n         }\n \n@@ -1786,7 +1808,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n         if (dg)\n         {\n             if (tf.isreturn)\n-                escapeByValue(e.e1, er, live);\n+                escapeByValue(e.e1, er, live, retRefTransition);\n         }\n \n         /* If it's a nested function that is 'return scope'\n@@ -1797,7 +1819,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n             if (fd && fd.isNested())\n             {\n                 if (tf.isreturn && tf.isScopeQual)\n-                    er.byexp.push(e);\n+                    er.pushExp(e, false);\n             }\n         }\n     }\n@@ -1852,10 +1874,11 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false)\n  *      e = expression to be returned by 'ref'\n  *      er = where to place collected data\n  *      live = if @live semantics apply, i.e. expressions `p`, `*p`, `**p`, etc., all return `p`.\n+ *      retRefTransition = if `e` is returned through a `return ref scope` function call\n  */\n-void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n+void escapeByRef(Expression e, EscapeByResults* er, bool live = false, bool retRefTransition = false)\n {\n-    //printf(\"[%s] escapeByRef, e: %s\\n\", e.loc.toChars(), e.toChars());\n+    //printf(\"[%s] escapeByRef, e: %s, retRefTransition: %d\\n\", e.loc.toChars(), e.toChars(), retRefTransition);\n     void visit(Expression e)\n     {\n     }\n@@ -1874,27 +1897,27 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                 if (ExpInitializer ez = v._init.isExpInitializer())\n                 {\n                     if (auto ce = ez.exp.isConstructExp())\n-                        escapeByRef(ce.e2, er, live);\n+                        escapeByRef(ce.e2, er, live, retRefTransition);\n                     else\n-                        escapeByRef(ez.exp, er, live);\n+                        escapeByRef(ez.exp, er, live, retRefTransition);\n                 }\n             }\n             else\n-                er.byref.push(v);\n+                er.pushRef(v, retRefTransition);\n         }\n     }\n \n     void visitThis(ThisExp e)\n     {\n         if (e.var && e.var.toParent2().isFuncDeclaration().hasDualContext())\n-            escapeByValue(e, er, live);\n+            escapeByValue(e, er, live, retRefTransition);\n         else if (e.var)\n-            er.byref.push(e.var);\n+            er.pushRef(e.var, retRefTransition);\n     }\n \n     void visitPtr(PtrExp e)\n     {\n-        escapeByValue(e.e1, er, live);\n+        escapeByValue(e.e1, er, live, retRefTransition);\n     }\n \n     void visitIndex(IndexExp e)\n@@ -1907,18 +1930,18 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n             {\n                 if (v && v.storage_class & STC.variadic)\n                 {\n-                    er.byref.push(v);\n+                    er.pushRef(v, retRefTransition);\n                     return;\n                 }\n             }\n         }\n         if (tb.ty == Tsarray)\n         {\n-            escapeByRef(e.e1, er, live);\n+            escapeByRef(e.e1, er, live, retRefTransition);\n         }\n         else if (tb.ty == Tarray)\n         {\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n         }\n     }\n \n@@ -1929,40 +1952,40 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n             foreach (ex; *e.elements)\n             {\n                 if (ex)\n-                    escapeByRef(ex, er, live);\n+                    escapeByRef(ex, er, live, retRefTransition);\n             }\n         }\n-        er.byexp.push(e);\n+        er.pushExp(e, retRefTransition);\n     }\n \n     void visitDotVar(DotVarExp e)\n     {\n         Type t1b = e.e1.type.toBasetype();\n         if (t1b.ty == Tclass)\n-            escapeByValue(e.e1, er, live);\n+            escapeByValue(e.e1, er, live, retRefTransition);\n         else\n-            escapeByRef(e.e1, er, live);\n+            escapeByRef(e.e1, er, live, retRefTransition);\n     }\n \n     void visitBinAssign(BinAssignExp e)\n     {\n-        escapeByRef(e.e1, er, live);\n+        escapeByRef(e.e1, er, live, retRefTransition);\n     }\n \n     void visitAssign(AssignExp e)\n     {\n-        escapeByRef(e.e1, er, live);\n+        escapeByRef(e.e1, er, live, retRefTransition);\n     }\n \n     void visitComma(CommaExp e)\n     {\n-        escapeByRef(e.e2, er, live);\n+        escapeByRef(e.e2, er, live, retRefTransition);\n     }\n \n     void visitCond(CondExp e)\n     {\n-        escapeByRef(e.e1, er, live);\n-        escapeByRef(e.e2, er, live);\n+        escapeByRef(e.e1, er, live, retRefTransition);\n+        escapeByRef(e.e2, er, live, retRefTransition);\n     }\n \n     void visitCall(CallExp e)\n@@ -1997,16 +2020,16 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                         const stc = tf.parameterStorageClass(null, p);\n                         ScopeRef psr = buildScopeRef(stc);\n                         if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n-                            escapeByRef(arg, er, live);\n+                            escapeByRef(arg, er, live, retRefTransition);\n                         else if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n                         {\n                             if (auto de = arg.isDelegateExp())\n                             {\n                                 if (de.func.isNested())\n-                                    er.byexp.push(de);\n+                                    er.pushExp(de, false);\n                             }\n                             else\n-                                escapeByValue(arg, er, live);\n+                                escapeByValue(arg, er, live, retRefTransition);\n                         }\n                     }\n                 }\n@@ -2019,7 +2042,7 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                 // https://issues.dlang.org/show_bug.cgi?id=20149#c10\n                 if (dve.var.isCtorDeclaration())\n                 {\n-                    er.byexp.push(e);\n+                    er.pushExp(e, false);\n                     return;\n                 }\n \n@@ -2035,23 +2058,23 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n \n                 const psr = buildScopeRef(stc);\n                 if (psr == ScopeRef.ReturnRef || psr == ScopeRef.ReturnRef_Scope)\n-                        escapeByRef(dve.e1, er, live);\n+                    escapeByRef(dve.e1, er, live, psr == ScopeRef.ReturnRef_Scope);\n                 else if (psr == ScopeRef.ReturnScope || psr == ScopeRef.Ref_ReturnScope)\n-                        escapeByValue(dve.e1, er, live);\n+                    escapeByValue(dve.e1, er, live, retRefTransition);\n \n                 // If it's also a nested function that is 'return ref'\n                 if (FuncDeclaration fd = dve.var.isFuncDeclaration())\n                 {\n                     if (fd.isNested() && tf.isreturn)\n                     {\n-                        er.byexp.push(e);\n+                        er.pushExp(e, false);\n                     }\n                 }\n             }\n             // If it's a delegate, check it too\n             if (e.e1.op == EXP.variable && t1.ty == Tdelegate)\n             {\n-                escapeByValue(e.e1, er, live);\n+                escapeByValue(e.e1, er, live, retRefTransition);\n             }\n \n             /* If it's a nested function that is 'return ref'\n@@ -2062,12 +2085,12 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n                 if (fd && fd.isNested())\n                 {\n                     if (tf.isreturn)\n-                        er.byexp.push(e);\n+                        er.pushExp(e, false);\n                 }\n             }\n         }\n         else\n-            er.byexp.push(e);\n+            er.pushExp(e, retRefTransition);\n     }\n \n     switch (e.op)\n@@ -2091,16 +2114,30 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n     }\n }\n \n-\n /************************************\n  * Aggregate the data collected by the escapeBy??() functions.\n  */\n struct EscapeByResults\n {\n     VarDeclarations byref;      // array into which variables being returned by ref are inserted\n     VarDeclarations byvalue;    // array into which variables with values containing pointers are inserted\n-    FuncDeclarations byfunc;    // nested functions that are turned into delegates\n-    Expressions byexp;          // array into which temporaries being returned by ref are inserted\n+    private FuncDeclarations byfunc; // nested functions that are turned into delegates\n+    private Expressions byexp;       // array into which temporaries being returned by ref are inserted\n+\n+    import dmd.root.array: Array;\n+\n+    /**\n+     * Whether the variable / expression went through a `return ref scope` function call\n+     *\n+     * This is needed for the dip1000 by default transition, since the rules for\n+     * disambiguating `return scope ref` have changed. Therefore, functions in legacy code\n+     * can be mistakenly treated as `return ref` making the compiler believe stack variables\n+     * are being escaped, which is an error even in `@system` code. By keeping track of this\n+     * information, variables escaped through `return ref` can be treated as a deprecation instead\n+     * of error, see test/fail_compilation/dip1000_deprecation.d\n+     */\n+    private Array!bool refRetRefTransition;\n+    private Array!bool expRetRefTransition;\n \n     /** Reset arrays so the storage can be used again\n      */\n@@ -2110,6 +2147,33 @@ struct EscapeByResults\n         byvalue.setDim(0);\n         byfunc.setDim(0);\n         byexp.setDim(0);\n+\n+        refRetRefTransition.setDim(0);\n+        expRetRefTransition.setDim(0);\n+    }\n+\n+    /**\n+     * Escape variable `v` by reference\n+     * Params:\n+     *   v = variable to escape\n+     *   retRefTransition = `v` is escaped through a `return ref scope` function call\n+     */\n+    void pushRef(VarDeclaration v, bool retRefTransition)\n+    {\n+        byref.push(v);\n+        refRetRefTransition.push(retRefTransition);\n+    }\n+\n+    /**\n+     * Escape a reference to expression `e`\n+     * Params:\n+     *   e = expression to escape\n+     *   retRefTransition = `e` is escaped through a `return ref scope` function call\n+     */\n+    void pushExp(Expression e, bool retRefTransition)\n+    {\n+        byexp.push(e);\n+        expRetRefTransition.push(retRefTransition);\n     }\n }\n \n@@ -2438,7 +2502,7 @@ private bool setUnsafePreview(Scope* sc, FeatureState fs, bool gag, Loc loc, con\n     }\n     else if (fs == FeatureState.enabled)\n     {\n-        return sc.func.setUnsafe(gag, loc, msg, arg0, arg1);\n+        return sc.setUnsafe(gag, loc, msg, arg0, arg1);\n     }\n     else\n     {\n@@ -2449,6 +2513,11 @@ private bool setUnsafePreview(Scope* sc, FeatureState fs, bool gag, Loc loc, con\n                     loc, msg, arg0 ? arg0.toChars() : \"\", arg1 ? arg1.toChars() : \"\"\n                 );\n         }\n+        else if (!sc.func.safetyViolation)\n+        {\n+            import dmd.func : AttributeViolation;\n+            sc.func.safetyViolation = new AttributeViolation(loc, msg, arg0, arg1);\n+        }\n         return false;\n     }\n }"}, {"sha": "4d171059306f0b842200afbd9c4f7741ed91b645", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1370,7 +1370,7 @@ extern (C++) abstract class Expression : ASTNode\n          */\n         if (v.storage_class & STC.gshared)\n         {\n-            if (sc.func.setUnsafe(false, this.loc,\n+            if (sc.setUnsafe(false, this.loc,\n                 \"`@safe` function `%s` cannot access `__gshared` data `%s`\", sc.func, v))\n             {\n                 err = true;\n@@ -1419,14 +1419,28 @@ extern (C++) abstract class Expression : ASTNode\n                 error(\"`@safe` %s `%s` cannot call `@system` %s `%s`\",\n                     sc.func.kind(), sc.func.toPrettyChars(), f.kind(),\n                     prettyChars);\n-                f.errorSupplementalInferredSafety(/*max depth*/ 10);\n+                f.errorSupplementalInferredSafety(/*max depth*/ 10, /*deprecation*/ false);\n                 .errorSupplemental(f.loc, \"`%s` is declared here\", prettyChars);\n \n                 checkOverridenDtor(sc, f, dd => dd.type.toTypeFunction().trust > TRUST.system, \"@system\");\n \n                 return true;\n             }\n         }\n+        else if (f.isSafe() && f.safetyViolation)\n+        {\n+            // for dip1000 by default transition, print deprecations for calling functions that will become `@system`\n+            if (sc.func.isSafeBypassingInference())\n+            {\n+                .deprecation(this.loc, \"`@safe` function `%s` calling `%s`\", sc.func.toChars(), f.toChars());\n+                errorSupplementalInferredSafety(f, 10, true);\n+            }\n+            else if (!sc.func.safetyViolation)\n+            {\n+                import dmd.func : AttributeViolation;\n+                sc.func.safetyViolation = new AttributeViolation(this.loc, null, f, null);\n+            }\n+        }\n         return false;\n     }\n \n@@ -5761,7 +5775,7 @@ extern (C++) final class DelegatePtrExp : UnaExp\n \n     override Expression modifiableLvalue(Scope* sc, Expression e)\n     {\n-        if (sc.func.setUnsafe(false, this.loc, \"cannot modify delegate pointer in `@safe` code `%s`\", this))\n+        if (sc.setUnsafe(false, this.loc, \"cannot modify delegate pointer in `@safe` code `%s`\", this))\n         {\n             return ErrorExp.get();\n         }\n@@ -5799,7 +5813,7 @@ extern (C++) final class DelegateFuncptrExp : UnaExp\n \n     override Expression modifiableLvalue(Scope* sc, Expression e)\n     {\n-        if (sc.func.setUnsafe(false, this.loc, \"cannot modify delegate function pointer in `@safe` code `%s`\", this))\n+        if (sc.setUnsafe(false, this.loc, \"cannot modify delegate function pointer in `@safe` code `%s`\", this))\n         {\n             return ErrorExp.get();\n         }"}, {"sha": "9ab1cab9877f377dacb270fbdd7b02152f9f554b", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 373, "deletions": 359, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -90,9 +90,9 @@ class Expression : public ASTNode\n     virtual Expression *syntaxCopy();\n \n     // kludge for template.isExpression()\n-    DYNCAST dyncast() const { return DYNCAST_EXPRESSION; }\n+    DYNCAST dyncast() const override final { return DYNCAST_EXPRESSION; }\n \n-    const char *toChars() const;\n+    const char *toChars() const override;\n     void error(const char *format, ...) const;\n     void warning(const char *format, ...) const;\n     void deprecation(const char *format, ...) const;\n@@ -206,6 +206,8 @@ class Expression : public ASTNode\n     ShrAssignExp* isShrAssignExp();\n     UshrAssignExp* isUshrAssignExp();\n     CatAssignExp* isCatAssignExp();\n+    CatElemAssignExp* isCatElemAssignExp();\n+    CatDcharAssignExp* isCatDcharAssignExp();\n     AddExp* isAddExp();\n     MinExp* isMinExp();\n     CatExp* isCatExp();\n@@ -238,71 +240,71 @@ class Expression : public ASTNode\n     BinExp* isBinExp();\n     BinAssignExp* isBinAssignExp();\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class IntegerExp : public Expression\n+class IntegerExp final : public Expression\n {\n public:\n     dinteger_t value;\n \n     static IntegerExp *create(const Loc &loc, dinteger_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, dinteger_t value, Type *type);\n-    bool equals(const RootObject *o) const;\n-    dinteger_t toInteger();\n-    real_t toReal();\n-    real_t toImaginary();\n-    complex_t toComplex();\n-    Optional<bool> toBool();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool equals(const RootObject *o) const override;\n+    dinteger_t toInteger() override;\n+    real_t toReal() override;\n+    real_t toImaginary() override;\n+    complex_t toComplex() override;\n+    Optional<bool> toBool() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n     dinteger_t getInteger() { return value; }\n     void setInteger(dinteger_t value);\n     template<int v>\n     static IntegerExp literal();\n };\n \n-class ErrorExp : public Expression\n+class ErrorExp final : public Expression\n {\n public:\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n \n     static ErrorExp *errorexp; // handy shared value\n };\n \n-class RealExp : public Expression\n+class RealExp final : public Expression\n {\n public:\n     real_t value;\n \n     static RealExp *create(const Loc &loc, real_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, real_t value, Type *type);\n-    bool equals(const RootObject *o) const;\n-    dinteger_t toInteger();\n-    uinteger_t toUInteger();\n-    real_t toReal();\n-    real_t toImaginary();\n-    complex_t toComplex();\n-    Optional<bool> toBool();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool equals(const RootObject *o) const override;\n+    dinteger_t toInteger() override;\n+    uinteger_t toUInteger() override;\n+    real_t toReal() override;\n+    real_t toImaginary() override;\n+    complex_t toComplex() override;\n+    Optional<bool> toBool() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ComplexExp : public Expression\n+class ComplexExp final : public Expression\n {\n public:\n     complex_t value;\n \n     static ComplexExp *create(const Loc &loc, complex_t value, Type *type);\n     static void emplace(UnionExp *pue, const Loc &loc, complex_t value, Type *type);\n-    bool equals(const RootObject *o) const;\n-    dinteger_t toInteger();\n-    uinteger_t toUInteger();\n-    real_t toReal();\n-    real_t toImaginary();\n-    complex_t toComplex();\n-    Optional<bool> toBool();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool equals(const RootObject *o) const override;\n+    dinteger_t toInteger() override;\n+    uinteger_t toUInteger() override;\n+    real_t toReal() override;\n+    real_t toImaginary() override;\n+    complex_t toComplex() override;\n+    Optional<bool> toBool() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class IdentifierExp : public Expression\n@@ -311,58 +313,58 @@ class IdentifierExp : public Expression\n     Identifier *ident;\n \n     static IdentifierExp *create(const Loc &loc, Identifier *ident);\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override final;\n+    Expression *toLvalue(Scope *sc, Expression *e) override final;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DollarExp : public IdentifierExp\n+class DollarExp final : public IdentifierExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DsymbolExp : public Expression\n+class DsymbolExp final : public Expression\n {\n public:\n     Dsymbol *s;\n     bool hasOverloads;\n \n-    DsymbolExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    DsymbolExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class ThisExp : public Expression\n {\n public:\n     VarDeclaration *var;\n \n-    ThisExp *syntaxCopy();\n-    Optional<bool> toBool();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n+    ThisExp *syntaxCopy() override;\n+    Optional<bool> toBool() override;\n+    bool isLvalue() override final;\n+    Expression *toLvalue(Scope *sc, Expression *e) override final;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SuperExp : public ThisExp\n+class SuperExp final : public ThisExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NullExp : public Expression\n+class NullExp final : public Expression\n {\n public:\n-    bool equals(const RootObject *o) const;\n-    Optional<bool> toBool();\n-    StringExp *toStringExp();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool equals(const RootObject *o) const override;\n+    Optional<bool> toBool() override;\n+    StringExp *toStringExp() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StringExp : public Expression\n+class StringExp final : public Expression\n {\n public:\n     void *string;       // char, wchar, or dchar data\n@@ -375,23 +377,23 @@ class StringExp : public Expression\n     static StringExp *create(const Loc &loc, const char *s);\n     static StringExp *create(const Loc &loc, const void *s, d_size_t len);\n     static void emplace(UnionExp *pue, const Loc &loc, const char *s);\n-    bool equals(const RootObject *o) const;\n+    bool equals(const RootObject *o) const override;\n     char32_t getCodeUnit(d_size_t i) const;\n     void setCodeUnit(d_size_t i, char32_t c);\n-    StringExp *toStringExp();\n+    StringExp *toStringExp() override;\n     StringExp *toUTF8(Scope *sc);\n-    Optional<bool> toBool();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Optional<bool> toBool() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n     size_t numberOfCodeUnits(int tynto = 0) const;\n     void writeTo(void* dest, bool zero, int tyto = 0) const;\n };\n \n // Tuple\n \n-class TupleExp : public Expression\n+class TupleExp final : public Expression\n {\n public:\n     Expression *e0;     // side-effect part\n@@ -405,13 +407,13 @@ class TupleExp : public Expression\n     Expressions *exps;\n \n     static TupleExp *create(const Loc &loc, Expressions *exps);\n-    TupleExp *syntaxCopy();\n-    bool equals(const RootObject *o) const;\n+    TupleExp *syntaxCopy() override;\n+    bool equals(const RootObject *o) const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ArrayLiteralExp : public Expression\n+class ArrayLiteralExp final : public Expression\n {\n public:\n     Expression *basis;\n@@ -420,31 +422,31 @@ class ArrayLiteralExp : public Expression\n \n     static ArrayLiteralExp *create(const Loc &loc, Expressions *elements);\n     static void emplace(UnionExp *pue, const Loc &loc, Expressions *elements);\n-    ArrayLiteralExp *syntaxCopy();\n-    bool equals(const RootObject *o) const;\n+    ArrayLiteralExp *syntaxCopy() override;\n+    bool equals(const RootObject *o) const override;\n     Expression *getElement(d_size_t i); // use opIndex instead\n     Expression *opIndex(d_size_t i);\n-    Optional<bool> toBool();\n-    StringExp *toStringExp();\n+    Optional<bool> toBool() override;\n+    StringExp *toStringExp() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AssocArrayLiteralExp : public Expression\n+class AssocArrayLiteralExp final : public Expression\n {\n public:\n     Expressions *keys;\n     Expressions *values;\n     OwnedBy ownedByCtfe;\n \n-    bool equals(const RootObject *o) const;\n-    AssocArrayLiteralExp *syntaxCopy();\n-    Optional<bool> toBool();\n+    bool equals(const RootObject *o) const override;\n+    AssocArrayLiteralExp *syntaxCopy() override;\n+    Optional<bool> toBool() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StructLiteralExp : public Expression\n+class StructLiteralExp final : public Expression\n {\n public:\n     StructDeclaration *sd;      // which aggregate this is for\n@@ -475,50 +477,50 @@ class StructLiteralExp : public Expression\n     OwnedBy ownedByCtfe;\n \n     static StructLiteralExp *create(const Loc &loc, StructDeclaration *sd, void *elements, Type *stype = NULL);\n-    bool equals(const RootObject *o) const;\n-    StructLiteralExp *syntaxCopy();\n+    bool equals(const RootObject *o) const override;\n+    StructLiteralExp *syntaxCopy() override;\n     Expression *getField(Type *type, unsigned offset);\n     int getFieldIndex(Type *type, unsigned offset);\n-    Expression *addDtorHook(Scope *sc);\n-    Expression *toLvalue(Scope *sc, Expression *e);\n+    Expression *addDtorHook(Scope *sc) override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeExp : public Expression\n+class TypeExp final : public Expression\n {\n public:\n-    TypeExp *syntaxCopy();\n-    bool checkType();\n-    bool checkValue();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TypeExp *syntaxCopy() override;\n+    bool checkType() override;\n+    bool checkValue() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ScopeExp : public Expression\n+class ScopeExp final : public Expression\n {\n public:\n     ScopeDsymbol *sds;\n \n-    ScopeExp *syntaxCopy();\n-    bool checkType();\n-    bool checkValue();\n-    void accept(Visitor *v) { v->visit(this); }\n+    ScopeExp *syntaxCopy() override;\n+    bool checkType() override;\n+    bool checkValue() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TemplateExp : public Expression\n+class TemplateExp final : public Expression\n {\n public:\n     TemplateDeclaration *td;\n     FuncDeclaration *fd;\n \n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    bool checkType();\n-    bool checkValue();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    bool checkType() override;\n+    bool checkValue() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NewExp : public Expression\n+class NewExp final : public Expression\n {\n public:\n     /* newtype(arguments)\n@@ -534,12 +536,12 @@ class NewExp : public Expression\n     bool thrownew;              // this NewExp is the expression of a ThrowStatement\n \n     static NewExp *create(const Loc &loc, Expression *thisexp, Type *newtype, Expressions *arguments);\n-    NewExp *syntaxCopy();\n+    NewExp *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NewAnonClassExp : public Expression\n+class NewAnonClassExp final : public Expression\n {\n public:\n     /* class baseclasses { } (arguments)\n@@ -548,8 +550,8 @@ class NewAnonClassExp : public Expression\n     ClassDeclaration *cd;       // class being instantiated\n     Expressions *arguments;     // Array of Expression's to call class constructor\n \n-    NewAnonClassExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    NewAnonClassExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class SymbolExp : public Expression\n@@ -559,109 +561,109 @@ class SymbolExp : public Expression\n     Dsymbol *originalScope;\n     bool hasOverloads;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Offset from symbol\n \n-class SymOffExp : public SymbolExp\n+class SymOffExp final : public SymbolExp\n {\n public:\n     dinteger_t offset;\n \n-    Optional<bool> toBool();\n+    Optional<bool> toBool() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Variable\n \n-class VarExp : public SymbolExp\n+class VarExp final : public SymbolExp\n {\n public:\n     bool delegateWasExtracted;\n     static VarExp *create(const Loc &loc, Declaration *var, bool hasOverloads = true);\n-    bool equals(const RootObject *o) const;\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n+    bool equals(const RootObject *o) const override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Overload Set\n \n-class OverExp : public Expression\n+class OverExp final : public Expression\n {\n public:\n     OverloadSet *vars;\n \n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Function/Delegate literal\n \n-class FuncExp : public Expression\n+class FuncExp final : public Expression\n {\n public:\n     FuncLiteralDeclaration *fd;\n     TemplateDeclaration *td;\n     TOK tok;\n \n-    bool equals(const RootObject *o) const;\n-    FuncExp *syntaxCopy();\n-    const char *toChars() const;\n-    bool checkType();\n-    bool checkValue();\n+    bool equals(const RootObject *o) const override;\n+    FuncExp *syntaxCopy() override;\n+    const char *toChars() const override;\n+    bool checkType() override;\n+    bool checkValue() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Declaration of a symbol\n \n // D grammar allows declarations only as statements. However in AST representation\n // it can be part of any expression. This is used, for example, during internal\n // syntax re-writes to inject hidden symbols.\n-class DeclarationExp : public Expression\n+class DeclarationExp final : public Expression\n {\n public:\n     Dsymbol *declaration;\n \n-    DeclarationExp *syntaxCopy();\n+    DeclarationExp *syntaxCopy() override;\n \n-    bool hasCode();\n+    bool hasCode() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeidExp : public Expression\n+class TypeidExp final : public Expression\n {\n public:\n     RootObject *obj;\n \n-    TypeidExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TypeidExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TraitsExp : public Expression\n+class TraitsExp final : public Expression\n {\n public:\n     Identifier *ident;\n     Objects *args;\n \n-    TraitsExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TraitsExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class HaltExp : public Expression\n+class HaltExp final : public Expression\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class IsExp : public Expression\n+class IsExp final : public Expression\n {\n public:\n     /* is(targ id tok tspec)\n@@ -674,8 +676,8 @@ class IsExp : public Expression\n     TOK tok;       // ':' or '=='\n     TOK tok2;      // 'struct', 'union', etc.\n \n-    IsExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    IsExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n@@ -686,11 +688,11 @@ class UnaExp : public Expression\n     Expression *e1;\n     Type *att1; // Save alias this type to detect recursion\n \n-    UnaExp *syntaxCopy();\n+    UnaExp *syntaxCopy() override;\n     Expression *incompatibleTypes();\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override final;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class BinExp : public Expression\n@@ -702,56 +704,56 @@ class BinExp : public Expression\n     Type *att1; // Save alias this type to detect recursion\n     Type *att2; // Save alias this type to detect recursion\n \n-    BinExp *syntaxCopy();\n+    BinExp *syntaxCopy() override;\n     Expression *incompatibleTypes();\n \n     Expression *reorderSettingAAElem(Scope *sc);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class BinAssignExp : public BinExp\n {\n public:\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *ex);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override final;\n+    Expression *toLvalue(Scope *sc, Expression *ex) override final;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override final;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n \n-class MixinExp : public UnaExp\n+class MixinExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ImportExp : public UnaExp\n+class ImportExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AssertExp : public UnaExp\n+class AssertExp final : public UnaExp\n {\n public:\n     Expression *msg;\n \n-    AssertExp *syntaxCopy();\n+    AssertExp *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ThrowExp : public UnaExp\n+class ThrowExp final : public UnaExp\n {\n public:\n-    ThrowExp *syntaxCopy();\n+    ThrowExp *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DotIdExp : public UnaExp\n+class DotIdExp final : public UnaExp\n {\n public:\n     Identifier *ident;\n@@ -760,63 +762,63 @@ class DotIdExp : public UnaExp\n     bool arrow;         // ImportC: if -> instead of .\n \n     static DotIdExp *create(const Loc &loc, Expression *e, Identifier *ident);\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DotTemplateExp : public UnaExp\n+class DotTemplateExp final : public UnaExp\n {\n public:\n     TemplateDeclaration *td;\n \n-    bool checkType();\n-    bool checkValue();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool checkType() override;\n+    bool checkValue() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DotVarExp : public UnaExp\n+class DotVarExp final : public UnaExp\n {\n public:\n     Declaration *var;\n     bool hasOverloads;\n \n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DotTemplateInstanceExp : public UnaExp\n+class DotTemplateInstanceExp final : public UnaExp\n {\n public:\n     TemplateInstance *ti;\n \n-    DotTemplateInstanceExp *syntaxCopy();\n+    DotTemplateInstanceExp *syntaxCopy() override;\n     bool findTempDecl(Scope *sc);\n-    bool checkType();\n-    bool checkValue();\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool checkType() override;\n+    bool checkValue() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DelegateExp : public UnaExp\n+class DelegateExp final : public UnaExp\n {\n public:\n     FuncDeclaration *func;\n     bool hasOverloads;\n     VarDeclaration *vthis2;  // container for multi-context\n \n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DotTypeExp : public UnaExp\n+class DotTypeExp final : public UnaExp\n {\n public:\n     Dsymbol *sym;               // symbol that represents a type\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CallExp : public UnaExp\n+class CallExp final : public UnaExp\n {\n public:\n     Expressions *arguments;     // function arguments\n@@ -831,76 +833,76 @@ class CallExp : public UnaExp\n     static CallExp *create(const Loc &loc, Expression *e, Expression *earg1);\n     static CallExp *create(const Loc &loc, FuncDeclaration *fd, Expression *earg1);\n \n-    CallExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *addDtorHook(Scope *sc);\n+    CallExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *addDtorHook(Scope *sc) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AddrExp : public UnaExp\n+class AddrExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PtrExp : public UnaExp\n+class PtrExp final : public UnaExp\n {\n public:\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NegExp : public UnaExp\n+class NegExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class UAddExp : public UnaExp\n+class UAddExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ComExp : public UnaExp\n+class ComExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class NotExp : public UnaExp\n+class NotExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DeleteExp : public UnaExp\n+class DeleteExp final : public UnaExp\n {\n public:\n     bool isRAII;\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CastExp : public UnaExp\n+class CastExp final : public UnaExp\n {\n public:\n     // Possible to cast to one type while painting to another type\n     Type *to;                   // type to cast to\n     unsigned char mod;          // MODxxxxx\n \n-    CastExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n+    CastExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VectorExp : public UnaExp\n+class VectorExp final : public UnaExp\n {\n public:\n     TypeVector *to;             // the target vector type before semantic()\n@@ -909,19 +911,19 @@ class VectorExp : public UnaExp\n \n     static VectorExp *create(const Loc &loc, Expression *e, Type *t);\n     static void emplace(UnionExp *pue, const Loc &loc, Expression *e, Type *t);\n-    VectorExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    VectorExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VectorArrayExp : public UnaExp\n+class VectorArrayExp final : public UnaExp\n {\n public:\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SliceExp : public UnaExp\n+class SliceExp final : public UnaExp\n {\n public:\n     Expression *upr;            // NULL if implicit 0\n@@ -931,115 +933,115 @@ class SliceExp : public UnaExp\n     bool lowerIsLessThanUpper;  // true if lwr <= upr\n     bool arrayop;               // an array operation, rather than a slice\n \n-    SliceExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    Optional<bool> toBool();\n+    SliceExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    Optional<bool> toBool() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ArrayLengthExp : public UnaExp\n+class ArrayLengthExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class IntervalExp : public Expression\n+class IntervalExp final : public Expression\n {\n public:\n     Expression *lwr;\n     Expression *upr;\n \n-    IntervalExp *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    IntervalExp *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DelegatePtrExp : public UnaExp\n+class DelegatePtrExp final : public UnaExp\n {\n public:\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DelegateFuncptrExp : public UnaExp\n+class DelegateFuncptrExp final : public UnaExp\n {\n public:\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // e1[a0,a1,a2,a3,...]\n \n-class ArrayExp : public UnaExp\n+class ArrayExp final : public UnaExp\n {\n public:\n     Expressions *arguments;             // Array of Expression's\n     size_t currentDimension;            // for opDollar\n     VarDeclaration *lengthVar;\n \n-    ArrayExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n+    ArrayExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n \n-class DotExp : public BinExp\n+class DotExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CommaExp : public BinExp\n+class CommaExp final : public BinExp\n {\n public:\n     bool isGenerated;\n     bool allowCommaExp;\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n-    Optional<bool> toBool();\n-    Expression *addDtorHook(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n+    Optional<bool> toBool() override;\n+    Expression *addDtorHook(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class IndexExp : public BinExp\n+class IndexExp final : public BinExp\n {\n public:\n     VarDeclaration *lengthVar;\n     bool modifiable;\n     bool indexIsInBounds;       // true if 0 <= e2 && e2 <= e1.length - 1\n \n-    IndexExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n+    IndexExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* For both i++ and i--\n  */\n-class PostExp : public BinExp\n+class PostExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* For both ++i and --i\n  */\n-class PreExp : public UnaExp\n+class PreExp final : public UnaExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n enum class MemorySet\n@@ -1054,288 +1056,300 @@ class AssignExp : public BinExp\n public:\n     MemorySet memset;\n \n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *ex);\n+    bool isLvalue() override final;\n+    Expression *toLvalue(Scope *sc, Expression *ex) override final;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ConstructExp : public AssignExp\n+class ConstructExp final : public AssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class BlitExp : public AssignExp\n+class BlitExp final : public AssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AddAssignExp : public BinAssignExp\n+class AddAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class MinAssignExp : public BinAssignExp\n+class MinAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class MulAssignExp : public BinAssignExp\n+class MulAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DivAssignExp : public BinAssignExp\n+class DivAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ModAssignExp : public BinAssignExp\n+class ModAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AndAssignExp : public BinAssignExp\n+class AndAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class OrAssignExp : public BinAssignExp\n+class OrAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class XorAssignExp : public BinAssignExp\n+class XorAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PowAssignExp : public BinAssignExp\n+class PowAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ShlAssignExp : public BinAssignExp\n+class ShlAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ShrAssignExp : public BinAssignExp\n+class ShrAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class UshrAssignExp : public BinAssignExp\n+class UshrAssignExp final : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class CatAssignExp : public BinAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AddExp : public BinExp\n+class CatElemAssignExp final : public CatAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class MinExp : public BinExp\n+class CatDcharAssignExp final : public CatAssignExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CatExp : public BinExp\n+class AddExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class MulExp : public BinExp\n+class MinExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DivExp : public BinExp\n+class CatExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ModExp : public BinExp\n+class MulExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PowExp : public BinExp\n+class DivExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ShlExp : public BinExp\n+class ModExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ShrExp : public BinExp\n+class PowExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class UshrExp : public BinExp\n+class ShlExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class AndExp : public BinExp\n+class ShrExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class OrExp : public BinExp\n+class UshrExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class XorExp : public BinExp\n+class AndExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class LogicalExp : public BinExp\n+class OrExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CmpExp : public BinExp\n+class XorExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class InExp : public BinExp\n+class LogicalExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class RemoveExp : public BinExp\n+class CmpExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n+};\n+\n+class InExp final : public BinExp\n+{\n+public:\n+    void accept(Visitor *v) override { v->visit(this); }\n+};\n+\n+class RemoveExp final : public BinExp\n+{\n+public:\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // == and !=\n \n-class EqualExp : public BinExp\n+class EqualExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // is and !is\n \n-class IdentityExp : public BinExp\n+class IdentityExp final : public BinExp\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n \n-class CondExp : public BinExp\n+class CondExp final : public BinExp\n {\n public:\n     Expression *econd;\n \n-    CondExp *syntaxCopy();\n-    bool isLvalue();\n-    Expression *toLvalue(Scope *sc, Expression *e);\n-    Expression *modifiableLvalue(Scope *sc, Expression *e);\n+    CondExp *syntaxCopy() override;\n+    bool isLvalue() override;\n+    Expression *toLvalue(Scope *sc, Expression *e) override;\n+    Expression *modifiableLvalue(Scope *sc, Expression *e) override;\n     void hookDtors(Scope *sc);\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class GenericExp : Expression\n+class GenericExp final : Expression\n {\n     Expression *cntlExp;\n     Types *types;\n     Expressions *exps;\n \n-    GenericExp *syntaxCopy();\n+    GenericExp *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n \n class DefaultInitExp : public Expression\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class FileInitExp : public DefaultInitExp\n+class FileInitExp final : public DefaultInitExp\n {\n public:\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class LineInitExp : public DefaultInitExp\n+class LineInitExp final : public DefaultInitExp\n {\n public:\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ModuleInitExp : public DefaultInitExp\n+class ModuleInitExp final : public DefaultInitExp\n {\n public:\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class FuncInitExp : public DefaultInitExp\n+class FuncInitExp final : public DefaultInitExp\n {\n public:\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PrettyFuncInitExp : public DefaultInitExp\n+class PrettyFuncInitExp final : public DefaultInitExp\n {\n public:\n-    Expression *resolveLoc(const Loc &loc, Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Expression *resolveLoc(const Loc &loc, Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /****************************************************************/\n@@ -1396,10 +1410,10 @@ struct UnionExp\n \n /****************************************************************/\n \n-class ObjcClassReferenceExp : public Expression\n+class ObjcClassReferenceExp final : public Expression\n {\n public:\n     ClassDeclaration* classDeclaration;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "cb720271ae7fcfab59f738262fba26a296c53d74", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -4989,7 +4989,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         sc.func.kind(), sc.func.toPrettyChars(), p, exp.e1.toChars());\n                     err = true;\n                 }\n-                if (tf.trust <= TRUST.system && sc.func.setUnsafe())\n+                if (tf.trust <= TRUST.system && sc.setUnsafe())\n                 {\n                     exp.error(\"`@safe` %s `%s` cannot call `@system` %s `%s`\",\n                         sc.func.kind(), sc.func.toPrettyChars(), p, exp.e1.toChars());\n@@ -5995,7 +5995,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         auto idxReserved = FileName.findReservedChar(namez);\n         if (idxReserved != size_t.max)\n         {\n-            e.error(\"`%s` is  not a valid filename on this platform\", se.toChars());\n+            e.error(\"`%s` is not a valid filename on this platform\", se.toChars());\n             e.errorSupplemental(\"Character `'%c'` is reserved and cannot be used\", namez[idxReserved]);\n             return setError();\n         }\n@@ -6543,8 +6543,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 RootObject o = (*tup.objects)[i];\n                 Expression e;\n                 Declaration var;\n-                if (o.dyncast() == DYNCAST.expression)\n+                switch (o.dyncast()) with (DYNCAST)\n                 {\n+                case expression:\n                     e = cast(Expression)o;\n                     if (auto se = e.isDsymbolExp())\n                         var = se.s.isDeclaration();\n@@ -6553,9 +6554,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                             // Exempt functions for backwards compatibility reasons.\n                             // See: https://issues.dlang.org/show_bug.cgi?id=20470#c1\n                             var = ve.var;\n-                }\n-                else if (o.dyncast() == DYNCAST.dsymbol)\n-                {\n+                    break;\n+                case dsymbol:\n                     Dsymbol s = cast(Dsymbol) o;\n                     Declaration d = s.isDeclaration();\n                     if (!d || d.isFuncDeclaration())\n@@ -6564,13 +6564,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         e = new DsymbolExp(exp.loc, s);\n                     else\n                         var = d;\n-                }\n-                else if (o.dyncast() == DYNCAST.type)\n-                {\n+                    break;\n+                case type:\n                     e = new TypeExp(exp.loc, cast(Type)o);\n-                }\n-                else\n-                {\n+                    break;\n+                default:\n                     exp.error(\"`%s` is not an expression\", o.toChars());\n                     return setError();\n                 }\n@@ -6894,9 +6892,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                          * because it might end up being a pointer to undefined\n                          * memory.\n                          */\n-                        if (sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_))\n+                        if (1)\n                         {\n-                            if (sc.func.setUnsafe(false, exp.loc,\n+                            if (sc.setUnsafe(false, exp.loc,\n                                 \"cannot take address of lazy parameter `%s` in `@safe` function `%s`\", ve, sc.func))\n                             {\n                                 setError();\n@@ -7045,7 +7043,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     }\n                     if (sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_))\n                     {\n-                        sc.func.setUnsafe(false, exp.loc,\n+                        sc.setUnsafe(false, exp.loc,\n                             \"`this` reference necessary to take address of member `%s` in `@safe` function `%s`\",\n                             f, sc.func);\n                     }\n@@ -7552,10 +7550,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         // Check for unsafe casts\n-        if (!sc.intypeof &&\n-            !(sc.flags & SCOPE.debug_) &&\n-            !isSafeCast(ex, t1b, tob) &&\n-            (!sc.func && sc.stc & STC.safe || sc.func && sc.func.setUnsafe()))\n+        if (!isSafeCast(ex, t1b, tob) &&\n+            (!sc.func && sc.stc & STC.safe || sc.setUnsafe()))\n         {\n             exp.error(\"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type.toChars(), exp.to.toChars());\n             return setError();\n@@ -7816,11 +7812,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                 return setError();\n             }\n-            if (sc.func && !sc.intypeof && !(sc.flags & SCOPE.debug_))\n-            {\n-                if (sc.func.setUnsafe(false, exp.loc, \"pointer slicing not allowed in safe functions\"))\n-                    return setError();\n-            }\n+            if (sc.setUnsafe(false, exp.loc, \"pointer slicing not allowed in safe functions\"))\n+                return setError();\n         }\n         else if (t1b.ty == Tarray)\n         {\n@@ -8328,11 +8321,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             if (exp.e2.op == EXP.int64 && exp.e2.toInteger() == 0)\n             {\n             }\n-            else if (sc.func && !(sc.flags & SCOPE.debug_))\n+            else if (sc.setUnsafe(false, exp.loc, \"`@safe` function `%s` cannot index pointer `%s`\", sc.func, exp.e1))\n             {\n-                if (sc.func.setUnsafe(false, exp.loc,\n-                    \"`@safe` function `%s` cannot index pointer `%s`\", sc.func, exp.e1))\n-                    return setError();\n+                return setError();\n             }\n             exp.type = (cast(TypeNext)t1b).next;\n             break;\n@@ -9729,11 +9720,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             if (t1n.toBasetype.ty == Tvoid && t2n.toBasetype.ty == Tvoid)\n             {\n-                if (!sc.intypeof && sc.func && !(sc.flags & SCOPE.debug_))\n-                {\n-                    if (sc.func.setUnsafe(false, exp.loc, \"cannot copy `void[]` to `void[]` in `@safe` code\"))\n-                        return setError();\n-                }\n+                if (sc.setUnsafe(false, exp.loc, \"cannot copy `void[]` to `void[]` in `@safe` code\"))\n+                    return setError();\n             }\n         }\n         else\n@@ -13089,9 +13077,8 @@ bool checkAddressVar(Scope* sc, Expression exp, VarDeclaration v)\n             v.storage_class &= ~STC.maybescope;\n             v.doNotInferScope = true;\n             if (global.params.useDIP1000 != FeatureState.enabled &&\n-                !(sc.flags & SCOPE.debug_) &&\n                 !(v.storage_class & STC.temp) &&\n-                sc.func.setUnsafe())\n+                sc.setUnsafe())\n             {\n                 exp.error(\"cannot take address of %s `%s` in `@safe` function `%s`\", p, v.toChars(), sc.func.toChars());\n                 return false;\n@@ -13304,7 +13291,7 @@ private bool fit(StructDeclaration sd, const ref Loc loc, Scope* sc, Expressions\n         {\n             if ((!stype.alignment.isDefault() && stype.alignment.get() < target.ptrsize ||\n                  (v.offset & (target.ptrsize - 1))) &&\n-                (sc.func && sc.func.setUnsafe(false, loc,\n+                (sc.setUnsafe(false, loc,\n                     \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\", sd, v)))\n             {\n                 return false;"}, {"sha": "040394839302c9dc50f4c277835044cff48bb3ca", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -346,7 +346,7 @@ extern (C++) class FuncDeclaration : Declaration\n \n     /// In case of failed `@safe` inference, store the error that made the function `@system` for\n     /// better diagnostics\n-    private AttributeViolation* safetyViolation;\n+    AttributeViolation* safetyViolation;\n \n     /// Function flags: A collection of boolean packed for memory efficiency\n     /// See the `FUNCFLAG` enum\n@@ -713,6 +713,44 @@ extern (C++) class FuncDeclaration : Declaration\n                 }\n             }\n         }\n+        if (_linkage == LINK.cpp && bestvi != -1)\n+        {\n+            StorageClass stc = 0;\n+            FuncDeclaration fdv = (*vtbl)[bestvi].isFuncDeclaration();\n+            assert(fdv && fdv.ident == ident);\n+            if (type.covariant(fdv.type, &stc, /*cppCovariant=*/true) == Covariant.no)\n+            {\n+                /* https://issues.dlang.org/show_bug.cgi?id=22351\n+                 * Under D rules, `type` and `fdv.type` are covariant, but under C++ rules, they are not.\n+                 * For now, continue to allow D covariant rules to apply when `override` has been used,\n+                 * but issue a deprecation warning that this behaviour will change in the future.\n+                 * Otherwise, follow the C++ covariant rules, which will create a new vtable entry.\n+                 */\n+                if (isOverride())\n+                {\n+                    /* @@@DEPRECATED_2.110@@@\n+                     * After deprecation period has ended, be sure to remove this entire `LINK.cpp` branch,\n+                     * but also the `cppCovariant` parameter from Type.covariant, and update the function\n+                     * so that both `LINK.cpp` covariant conditions within are always checked.\n+                     */\n+                    .deprecation(loc, \"overriding `extern(C++)` function `%s%s` with `const` qualified function `%s%s%s` is deprecated\",\n+                                 fdv.toPrettyChars(), fdv.type.toTypeFunction().parameterList.parametersTypeToChars(),\n+                                 toPrettyChars(), type.toTypeFunction().parameterList.parametersTypeToChars(), type.modToChars());\n+\n+                    const char* where = type.isNaked() ? \"parameters\" : \"type\";\n+                    deprecationSupplemental(loc, \"Either remove `override`, or adjust the `const` qualifiers of the \"\n+                                            ~ \"overriding function %s\", where);\n+                }\n+                else\n+                {\n+                    // Treat as if Covariant.no\n+                    mismatchvi = bestvi;\n+                    mismatchstc = stc;\n+                    mismatch = fdv;\n+                    bestvi = -1;\n+                }\n+            }\n+        }\n         if (bestvi == -1 && mismatch)\n         {\n             //type.print();\n@@ -1447,7 +1485,7 @@ extern (C++) class FuncDeclaration : Declaration\n         {\n             flags &= ~FUNCFLAG.safetyInprocess;\n             type.toTypeFunction().trust = TRUST.system;\n-            if (!gag && !safetyViolation && (fmt || arg0))\n+            if (fmt || arg0)\n                 safetyViolation = new AttributeViolation(loc, fmt, arg0, arg1);\n \n             if (fes)\n@@ -4321,6 +4359,50 @@ extern (C++) final class NewDeclaration : FuncDeclaration\n     }\n }\n \n+/**************************************\n+ * A statement / expression in this scope is not `@safe`,\n+ * so mark the enclosing function as `@system`\n+ *\n+ * Params:\n+ *   sc = scope that the unsafe statement / expression is in\n+ *   gag = surpress error message (used in escape.d)\n+ *   loc = location of error\n+ *   fmt = printf-style format string\n+ *   arg0  = (optional) argument for first %s format specifier\n+ *   arg1  = (optional) argument for second %s format specifier\n+ * Returns: whether there's a safe error\n+ */\n+bool setUnsafe(Scope* sc,\n+    bool gag = false, Loc loc = Loc.init, const(char)* fmt = null, RootObject arg0 = null, RootObject arg1 = null)\n+{\n+    // TODO:\n+    // For @system variables, unsafe initializers at global scope should mark\n+    // the variable @system, see https://dlang.org/dips/1035\n+\n+    if (!sc.func)\n+        return false;\n+\n+    if (sc.intypeof)\n+        return false; // typeof(cast(int*)0) is safe\n+\n+    if (sc.flags & SCOPE.debug_) // debug {} scopes are permissive\n+        return false;\n+\n+    if (sc.flags & SCOPE.compile) // __traits(compiles, x)\n+    {\n+        if (sc.func.isSafeBypassingInference())\n+        {\n+            // Message wil be gagged, but still call error() to update global.errors and for\n+            // -verrors=spec\n+            .error(loc, fmt, arg0 ? arg0.toChars() : \"\", arg1 ? arg1.toChars() : \"\");\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    return sc.func.setUnsafe(gag, loc, fmt, arg0, arg1);\n+}\n+\n /// Stores a reason why a function failed to infer a function attribute like `@safe` or `pure`\n ///\n /// Has two modes:\n@@ -4329,7 +4411,7 @@ extern (C++) final class NewDeclaration : FuncDeclaration\n ///   that function might recursively also have a `AttributeViolation`. This way, in case\n ///   of a big call stack, the error can go down all the way to the root cause.\n ///   The `FunctionDeclaration` is then stored in `arg0` and `fmtStr` must be `null`.\n-private struct AttributeViolation\n+struct AttributeViolation\n {\n     /// location of error\n     Loc loc = Loc.init;\n@@ -4345,21 +4427,25 @@ private struct AttributeViolation\n /// Params:\n ///   fd = function to check\n ///   maxDepth = up to how many functions deep to report errors\n-void errorSupplementalInferredSafety(FuncDeclaration fd, int maxDepth)\n+///   deprecation = print deprecations instead of errors\n+void errorSupplementalInferredSafety(FuncDeclaration fd, int maxDepth, bool deprecation)\n {\n+    auto errorFunc = deprecation ? &deprecationSupplemental : &errorSupplemental;\n     if (auto s = fd.safetyViolation)\n     {\n         if (s.fmtStr)\n         {\n-            errorSupplemental(s.loc, \"which was inferred `@system` because of:\");\n-            errorSupplemental(s.loc, s.fmtStr, s.arg0 ? s.arg0.toChars() : \"\", s.arg1 ? s.arg1.toChars() : \"\");\n+            errorFunc(s.loc, deprecation ?\n+                \"which would be `@system` because of:\" :\n+                \"which was inferred `@system` because of:\");\n+            errorFunc(s.loc, s.fmtStr, s.arg0 ? s.arg0.toChars() : \"\", s.arg1 ? s.arg1.toChars() : \"\");\n         }\n         else if (FuncDeclaration fd2 = cast(FuncDeclaration) s.arg0)\n         {\n             if (maxDepth > 0)\n             {\n-                errorSupplemental(s.loc, \"which calls `%s`\", fd2.toPrettyChars());\n-                errorSupplementalInferredSafety(fd2, maxDepth - 1);\n+                errorFunc(s.loc, \"which calls `%s`\", fd2.toPrettyChars());\n+                errorSupplementalInferredSafety(fd2, maxDepth - 1, deprecation);\n             }\n         }\n     }"}, {"sha": "3766a0be07de7e806ec8e060e4f87d3c61e66823", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -118,6 +118,7 @@ extern (C++) struct Param\n     bool useInline = false;     // inline expand functions\n     FeatureState useDIP25;  // implement https://wiki.dlang.org/DIP25\n     FeatureState useDIP1000; // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n+    bool fixImmutableConv;  // error on unsound immutable conversion - https://github.com/dlang/dmd/pull/14070\n     bool useDIP1021;        // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n     bool release;           // build release version\n     bool preservePaths;     // true means don't strip path from source file\n@@ -298,7 +299,7 @@ extern (C++) struct Global\n \n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n-    extern (C++) FileName function(FileName, const(char)* importc_h, ref Array!(const(char)*) cppswitches, out bool) preprocess;\n+    extern (C++) FileName function(FileName, ref const Loc, ref Array!(const(char)*) cppswitches, out bool, OutBuffer* defines) preprocess;\n \n   nothrow:\n "}, {"sha": "07298ddb792f8a643fc21a32dd0abcfbfc9306ec", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -20,6 +20,7 @@\n template <typename TYPE> struct Array;\n \n class FileManager;\n+struct Loc;\n \n typedef unsigned char Diagnostic;\n enum\n@@ -117,6 +118,7 @@ struct Param\n     bool useInline;     // inline expand functions\n     FeatureState useDIP25;      // implement https://wiki.dlang.org/DIP25\n     FeatureState useDIP1000; // implement https://dlang.org/spec/memory-safe-d.html#scope-return-params\n+    bool fixImmutableConv;\n     bool useDIP1021;    // implement https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1021.md\n     bool release;       // build release version\n     bool preservePaths; // true means don't strip path from source file\n@@ -270,7 +272,7 @@ struct Global\n \n     FileManager* fileManager;\n \n-    FileName (*preprocess)(FileName, const char*, Array<const char *>& cppswitches, bool&);\n+    FileName (*preprocess)(FileName, const Loc&, Array<const char *>& cppswitches, bool&, OutBuffer&);\n \n     /* Start gagging. Return the current number of gagged errors\n      */"}, {"sha": "fcc9b61b54a80812bff5eaa6d334d5be63521e95", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -3835,26 +3835,24 @@ private void typeToBufferx(Type t, OutBuffer* buf, HdrGenState* hgs)\n     {\n         foreach (id; t.idents)\n         {\n-            if (id.dyncast() == DYNCAST.dsymbol)\n+            switch (id.dyncast()) with (DYNCAST)\n             {\n+            case dsymbol:\n                 buf.writeByte('.');\n                 TemplateInstance ti = cast(TemplateInstance)id;\n                 ti.dsymbolToBuffer(buf, hgs);\n-            }\n-            else if (id.dyncast() == DYNCAST.expression)\n-            {\n+                break;\n+            case expression:\n                 buf.writeByte('[');\n                 (cast(Expression)id).expressionToBuffer(buf, hgs);\n                 buf.writeByte(']');\n-            }\n-            else if (id.dyncast() == DYNCAST.type)\n-            {\n+                break;\n+            case type:\n                 buf.writeByte('[');\n                 typeToBufferx(cast(Type)id, buf, hgs);\n                 buf.writeByte(']');\n-            }\n-            else\n-            {\n+                break;\n+            default:\n                 buf.writeByte('.');\n                 buf.writestring(id.toString());\n             }"}, {"sha": "4993a9eb1b2e93cc624047634ea2c7ead9de297d", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -523,6 +523,8 @@ immutable Msgtable[] msgtable =\n     { \"show\" },\n     { \"push\" },\n     { \"pop\" },\n+    { \"define\" },\n+    { \"undef\" },\n ];\n \n "}, {"sha": "fa7a25aaaa13e63553375bddab348f59392019d0", "filename": "gcc/d/dmd/identifier.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fidentifier.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fidentifier.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -13,7 +13,7 @@\n #include \"root/dcompat.h\"\n #include \"root/object.h\"\n \n-class Identifier : public RootObject\n+class Identifier final : public RootObject\n {\n private:\n     int value;\n@@ -22,12 +22,11 @@ class Identifier : public RootObject\n \n public:\n     static Identifier* create(const char *string);\n-    bool equals(const RootObject *o) const;\n-    const char *toChars() const;\n+    const char *toChars() const override;\n     int getValue() const;\n     bool isAnonymous() const;\n     const char *toHChars2() const;\n-    DYNCAST dyncast() const;\n+    DYNCAST dyncast() const override;\n \n     static Identifier *generateId(const char *prefix, size_t length, size_t suffix);\n     static Identifier *idPool(const char *s, unsigned len);"}, {"sha": "f749ef5b5f6ea33cf178479a655a5b3f3f2a548f", "filename": "gcc/d/dmd/import.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimport.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -17,7 +17,7 @@ struct Scope;\n class Module;\n class Package;\n \n-class Import : public Dsymbol\n+class Import final : public Dsymbol\n {\n public:\n     /* static import aliasId = pkg1.pkg2.id : alias1 = name1, alias2 = name2;\n@@ -38,17 +38,17 @@ class Import : public Dsymbol\n \n     AliasDeclarations aliasdecls; // corresponding AliasDeclarations for alias=name pairs\n \n-    const char *kind() const;\n-    Visibility visible();\n-    Import *syntaxCopy(Dsymbol *s);    // copy only syntax trees\n+    const char *kind() const override;\n+    Visibility visible() override;\n+    Import *syntaxCopy(Dsymbol *s) override; // copy only syntax trees\n     void load(Scope *sc);\n-    void importAll(Scope *sc);\n-    Dsymbol *toAlias();\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope* sc);\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    bool overloadInsert(Dsymbol *s);\n-\n-    Import *isImport() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    void importAll(Scope *sc) override;\n+    Dsymbol *toAlias() override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope* sc) override;\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n+    bool overloadInsert(Dsymbol *s) override;\n+\n+    Import *isImport() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "164a5f3e56b0c720e090e6251059bbf9a51979b9", "filename": "gcc/d/dmd/init.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -44,7 +44,7 @@ extern (C++) class Initializer : ASTNode\n     Loc loc;\n     InitKind kind;\n \n-    override DYNCAST dyncast() const nothrow pure\n+    override DYNCAST dyncast() const\n     {\n         return DYNCAST.initializer;\n     }"}, {"sha": "296c31d1a5e1d4f6d2b9d8f8d23eea463c6bc564", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -33,7 +33,9 @@ class Initializer : public ASTNode\n     Loc loc;\n     unsigned char kind;\n \n-    const char *toChars() const;\n+    DYNCAST dyncast() const override { return DYNCAST_INITIALIZER; }\n+\n+    const char *toChars() const override final;\n \n     ErrorInitializer   *isErrorInitializer();\n     VoidInitializer    *isVoidInitializer();\n@@ -42,33 +44,33 @@ class Initializer : public ASTNode\n     ExpInitializer     *isExpInitializer();\n     CInitializer       *isCInitializer();\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VoidInitializer : public Initializer\n+class VoidInitializer final : public Initializer\n {\n public:\n     Type *type;         // type that this will initialize to\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ErrorInitializer : public Initializer\n+class ErrorInitializer final : public Initializer\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StructInitializer : public Initializer\n+class StructInitializer final : public Initializer\n {\n public:\n     Identifiers field;  // of Identifier *'s\n     Initializers value; // parallel array of Initializer *'s\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ArrayInitializer : public Initializer\n+class ArrayInitializer final : public Initializer\n {\n public:\n     Expressions index;  // indices\n@@ -80,16 +82,16 @@ class ArrayInitializer : public Initializer\n     bool isAssociativeArray() const;\n     Expression *toAssocArrayLiteral();\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ExpInitializer : public Initializer\n+class ExpInitializer final : public Initializer\n {\n public:\n     bool expandTuples;\n     Expression *exp;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n struct Designator\n@@ -104,14 +106,14 @@ struct DesigInit\n     Initializer *initializer;\n };\n \n-class CInitializer : public Initializer\n+class CInitializer final : public Initializer\n {\n public:\n     DesigInits initializerList;\n     Type *type;         // type that array will be used to initialize\n     bool sem;           // true if semantic() is run\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n Expression *initializerToExpression(Initializer *init, Type *t = NULL, const bool isCfile = false);"}, {"sha": "a1963dabcdc7958d817f2d0c777fb68459c1ed66", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -197,10 +197,9 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 if (vd.type.hasPointers)\n                 {\n                     if ((!t.alignment.isDefault() && t.alignment.get() < target.ptrsize ||\n-                         (vd.offset & (target.ptrsize - 1))) &&\n-                        sc.func)\n+                         (vd.offset & (target.ptrsize - 1))))\n                     {\n-                        if (sc.func.setUnsafe(false, i.value[j].loc,\n+                        if (sc.setUnsafe(false, i.value[j].loc,\n                             \"field `%s.%s` cannot assign to misaligned pointers in `@safe` code\", sd, vd))\n                         {\n                             errors = true;"}, {"sha": "ef918e275d0321a1eec95838e416e0eac5599b62", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -146,6 +146,36 @@ class Lexer\n         }\n     }\n \n+    /******************\n+     * Used for unittests for a mock Lexer\n+     */\n+    this() { }\n+\n+    /**************************************\n+     * Reset lexer to lex #define's\n+     */\n+    final void resetDefineLines(const(char)[] slice)\n+    {\n+        base = slice.ptr;\n+        end = base + slice.length;\n+        assert(*end == 0);\n+        p = base;\n+        line = p;\n+        tokenizeNewlines = true;\n+        inTokenStringConstant = 0;\n+        lastDocLine = 0;\n+        scanloc = Loc(\"#defines\", 1, 1);\n+    }\n+\n+    /**********************************\n+     * Set up for next #define line.\n+     * p should be at start of next line.\n+     */\n+    final void nextDefineLine()\n+    {\n+        tokenizeNewlines = true;\n+    }\n+\n     version (DMDLIB)\n     {\n         this(const(char)* filename, const(char)* base, size_t begoffset, size_t endoffset,\n@@ -1184,7 +1214,7 @@ class Lexer\n      * Returns:\n      *  the escape sequence as a single character\n      */\n-    private static dchar escapeSequence(const ref Loc loc, ref const(char)* sequence, bool Ccompile)\n+    private dchar escapeSequence(const ref Loc loc, ref const(char)* sequence, bool Ccompile)\n     {\n         const(char)* p = sequence; // cache sequence reference on stack\n         scope(exit) sequence = p;\n@@ -1268,21 +1298,21 @@ class Lexer\n                             break;\n                         if (!ishex(cast(char)c))\n                         {\n-                            .error(loc, \"escape hex sequence has %d hex digits instead of %d\", n, ndigits);\n+                            error(loc, \"escape hex sequence has %d hex digits instead of %d\", n, ndigits);\n                             break;\n                         }\n                     }\n                     if (ndigits != 2 && !utf_isValidDchar(v))\n                     {\n-                        .error(loc, \"invalid UTF character \\\\U%08x\", v);\n+                        error(loc, \"invalid UTF character \\\\U%08x\", v);\n                         v = '?'; // recover with valid UTF character\n                     }\n                 }\n                 c = v;\n             }\n             else\n             {\n-                .error(loc, \"undefined escape hex sequence \\\\%c%c\", sequence[0], c);\n+                error(loc, \"undefined escape hex sequence \\\\%c%c\", sequence[0], c);\n                 p++;\n             }\n             break;\n@@ -1299,15 +1329,15 @@ class Lexer\n                     c = HtmlNamedEntity(idstart, p - idstart);\n                     if (c == ~0)\n                     {\n-                        .error(loc, \"unnamed character entity &%.*s;\", cast(int)(p - idstart), idstart);\n+                        error(loc, \"unnamed character entity &%.*s;\", cast(int)(p - idstart), idstart);\n                         c = '?';\n                     }\n                     p++;\n                     break;\n                 default:\n                     if (isalpha(*p) || (p != idstart && isdigit(*p)))\n                         continue;\n-                    .error(loc, \"unterminated named entity &%.*s;\", cast(int)(p - idstart + 1), idstart);\n+                    error(loc, \"unterminated named entity &%.*s;\", cast(int)(p - idstart + 1), idstart);\n                     c = '?';\n                     break;\n                 }\n@@ -1332,11 +1362,11 @@ class Lexer\n                 while (++n < 3 && isoctal(cast(char)c));\n                 c = v;\n                 if (c > 0xFF)\n-                    .error(loc, \"escape octal sequence \\\\%03o is larger than \\\\377\", c);\n+                    error(loc, \"escape octal sequence \\\\%03o is larger than \\\\377\", c);\n             }\n             else\n             {\n-                .error(loc, \"undefined escape sequence \\\\%c\", c);\n+                error(loc, \"undefined escape sequence \\\\%c\", c);\n                 p++;\n             }\n             break;\n@@ -2732,8 +2762,10 @@ class Lexer\n \n     /***************************************\n      * Scan forward to start of next line.\n+     * Params:\n+     *    defines = send characters to `defines`\n      */\n-    final void skipToNextLine()\n+    final void skipToNextLine(OutBuffer* defines = null)\n     {\n         while (1)\n         {\n@@ -2754,7 +2786,9 @@ class Lexer\n                 break;\n \n             default:\n-                if (*p & 0x80)\n+                if (defines)\n+                    defines.writeByte(*p); // don't care about Unicode line endings for C\n+                else if (*p & 0x80)\n                 {\n                     const u = decodeUTF();\n                     if (u == PS || u == LS)\n@@ -3146,7 +3180,8 @@ unittest\n     static void test(T)(string sequence, T expected, bool Ccompile = false)\n     {\n         auto p = cast(const(char)*)sequence.ptr;\n-        assert(expected == Lexer.escapeSequence(Loc.initial, p, Ccompile));\n+        Lexer lexer = new Lexer();\n+        assert(expected == lexer.escapeSequence(Loc.initial, p, Ccompile));\n         assert(p == sequence.ptr + sequence.length);\n     }\n \n@@ -3212,7 +3247,8 @@ unittest\n         gotError = false;\n         expected = expectedError;\n         auto p = cast(const(char)*)sequence.ptr;\n-        auto actualReturnValue = Lexer.escapeSequence(Loc.initial, p, Ccompile);\n+        Lexer lexer = new Lexer();\n+        auto actualReturnValue = lexer.escapeSequence(Loc.initial, p, Ccompile);\n         assert(gotError);\n         assert(expectedReturnValue == actualReturnValue);\n "}, {"sha": "5808c28dc820871778cf19ce6a47fdf76d562fa9", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -35,21 +35,21 @@ class Package : public ScopeDsymbol\n     unsigned tag;       // auto incremented tag, used to mask package tree in scopes\n     Module *mod;        // != NULL if isPkgMod == PKGmodule\n \n-    const char *kind() const;\n+    const char *kind() const override;\n \n-    bool equals(const RootObject *o) const;\n+    bool equals(const RootObject *o) const override;\n \n-    Package *isPackage() { return this; }\n+    Package *isPackage() override final { return this; }\n \n     bool isAncestorPackageOf(const Package * const pkg) const;\n \n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    void accept(Visitor *v) { v->visit(this); }\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n \n     Module *isPackageMod();\n };\n \n-class Module : public Package\n+class Module final : public Package\n {\n public:\n     static Module *rootModule;\n@@ -82,6 +82,7 @@ class Module : public Package\n     int needmoduleinfo;\n     int selfimports;            // 0: don't know, 1: does not, 2: does\n     void* tagSymTab;            // ImportC: tag symbols that conflict with other symbols used as the index\n+    OutBuffer defines;          // collect all the #define lines here\n     bool selfImports();         // returns true if module imports itself\n \n     int rootimports;            // 0: don't know, 1: does not, 2: does\n@@ -119,14 +120,14 @@ class Module : public Package\n \n     static Module *load(const Loc &loc, Identifiers *packages, Identifier *ident);\n \n-    const char *kind() const;\n+    const char *kind() const override;\n     bool read(const Loc &loc); // read file, returns 'true' if succeed, 'false' otherwise.\n     Module *parse();    // syntactic parse\n-    void importAll(Scope *sc);\n+    void importAll(Scope *sc) override;\n     int needModuleInfo();\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    bool isPackageAccessible(Package *p, Visibility visibility, int flags = 0);\n-    Dsymbol *symtabInsert(Dsymbol *s);\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n+    bool isPackageAccessible(Package *p, Visibility visibility, int flags = 0) override;\n+    Dsymbol *symtabInsert(Dsymbol *s) override;\n     void deleteObjFile();\n     static void runDeferredSemantic();\n     static void runDeferredSemantic2();\n@@ -155,8 +156,8 @@ class Module : public Package\n \n     void *ctfe_cov;             // stores coverage information from ctfe\n \n-    Module *isModule() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    Module *isModule() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n "}, {"sha": "052c23d44201442ee748fb1b247438450abaa012", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -525,10 +525,12 @@ extern (C++) abstract class Type : ASTNode\n      * Params:\n      *      t = type 'this' is covariant with\n      *      pstc = if not null, store STCxxxx which would make it covariant\n+     *      cppCovariant = true if extern(C++) function types should follow C++ covariant rules\n      * Returns:\n      *     An enum value of either `Covariant.yes` or a reason it's not covariant.\n      */\n-    final Covariant covariant(Type t, StorageClass* pstc = null)\n+    extern (D)\n+    final Covariant covariant(Type t, StorageClass* pstc = null, bool cppCovariant = false)\n     {\n         version (none)\n         {\n@@ -563,11 +565,11 @@ extern (C++) abstract class Type : ASTNode\n             foreach (i, fparam1; t1.parameterList)\n             {\n                 Parameter fparam2 = t2.parameterList[i];\n+                Type tp1 = fparam1.type;\n+                Type tp2 = fparam2.type;\n \n-                if (!fparam1.type.equals(fparam2.type))\n+                if (!tp1.equals(tp2))\n                 {\n-                    Type tp1 = fparam1.type;\n-                    Type tp2 = fparam2.type;\n                     if (tp1.ty == tp2.ty)\n                     {\n                         if (auto tc1 = tp1.isTypeClass())\n@@ -600,6 +602,16 @@ extern (C++) abstract class Type : ASTNode\n                 }\n             Lcov:\n                 notcovariant |= !fparam1.isCovariant(t1.isref, fparam2);\n+\n+                /* https://issues.dlang.org/show_bug.cgi?id=23135\n+                 * extern(C++) mutable parameters are not covariant with const.\n+                 */\n+                if (t1.linkage == LINK.cpp && cppCovariant)\n+                {\n+                    notcovariant |= tp1.isNaked() != tp2.isNaked();\n+                    if (auto tpn1 = tp1.nextOf())\n+                        notcovariant |= tpn1.isNaked() != tp2.nextOf().isNaked();\n+                }\n             }\n         }\n         else if (t1.parameterList.parameters != t2.parameterList.parameters)\n@@ -701,6 +713,12 @@ extern (C++) abstract class Type : ASTNode\n         else if (t1.isreturn && !t2.isreturn)\n             goto Lnotcovariant;\n \n+        /* https://issues.dlang.org/show_bug.cgi?id=23135\n+         * extern(C++) mutable member functions are not covariant with const.\n+         */\n+        if (t1.linkage == LINK.cpp && cppCovariant && t1.isNaked() != t2.isNaked())\n+            goto Lnotcovariant;\n+\n         /* Can convert mutable to const\n          */\n         if (!MODimplicitConv(t2.mod, t1.mod))\n@@ -3237,7 +3255,7 @@ extern (C++) final class TypeBasic : Type\n         return this;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         uint size;\n         //printf(\"TypeBasic::size()\\n\");\n@@ -3325,32 +3343,32 @@ extern (C++) final class TypeBasic : Type\n         return (flags & TFlags.integral) != 0;\n     }\n \n-    override bool isfloating() const\n+    override bool isfloating()\n     {\n         return (flags & TFlags.floating) != 0;\n     }\n \n-    override bool isreal() const\n+    override bool isreal()\n     {\n         return (flags & TFlags.real_) != 0;\n     }\n \n-    override bool isimaginary() const\n+    override bool isimaginary()\n     {\n         return (flags & TFlags.imaginary) != 0;\n     }\n \n-    override bool iscomplex() const\n+    override bool iscomplex()\n     {\n         return (flags & TFlags.complex) != 0;\n     }\n \n-    override bool isscalar() const\n+    override bool isscalar()\n     {\n         return (flags & (TFlags.integral | TFlags.floating)) != 0;\n     }\n \n-    override bool isunsigned() const\n+    override bool isunsigned()\n     {\n         return (flags & TFlags.unsigned) != 0;\n     }\n@@ -3447,7 +3465,7 @@ extern (C++) final class TypeBasic : Type\n         return MATCH.convert;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         switch (ty)\n         {\n@@ -3543,7 +3561,7 @@ extern (C++) final class TypeVector : Type\n         return basetype.nextOf().isunsigned();\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return false;\n     }\n@@ -3860,13 +3878,13 @@ extern (C++) final class TypeDArray : TypeArray\n         return result;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         //printf(\"TypeDArray::size()\\n\");\n         return target.ptrsize * 2;\n     }\n \n-    override uint alignsize() const\n+    override uint alignsize()\n     {\n         // A DArray consists of two ptr-sized values, so align it on pointer size\n         // boundary\n@@ -3879,12 +3897,12 @@ extern (C++) final class TypeDArray : TypeArray\n         return nty.isSomeChar;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;\n     }\n@@ -3918,7 +3936,7 @@ extern (C++) final class TypeDArray : TypeArray\n         return Type.implicitConvTo(to);\n     }\n \n-    override bool hasPointers() const\n+    override bool hasPointers()\n     {\n         return true;\n     }\n@@ -3964,22 +3982,22 @@ extern (C++) final class TypeAArray : TypeArray\n         return result;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return target.ptrsize;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;\n     }\n \n-    override bool hasPointers() const\n+    override bool hasPointers()\n     {\n         return true;\n     }\n@@ -4056,7 +4074,7 @@ extern (C++) final class TypePointer : TypeNext\n         return result;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return target.ptrsize;\n     }\n@@ -4112,17 +4130,17 @@ extern (C++) final class TypePointer : TypeNext\n         return TypeNext.constConv(to);\n     }\n \n-    override bool isscalar() const\n+    override bool isscalar()\n     {\n         return true;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n \n-    override bool hasPointers() const\n+    override bool hasPointers()\n     {\n         return true;\n     }\n@@ -4159,12 +4177,12 @@ extern (C++) final class TypeReference : TypeNext\n         return result;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return target.ptrsize;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n@@ -4760,7 +4778,7 @@ extern (C++) final class TypeFunction : TypeNext\n                                         char[] s;\n                                         if (!f.isPure && sc.func.setImpure())\n                                             s ~= \"pure \";\n-                                        if (!f.isSafe() && !f.isTrusted() && sc.func.setUnsafe())\n+                                        if (!f.isSafe() && !f.isTrusted() && sc.setUnsafe())\n                                             s ~= \"@safe \";\n                                         if (!f.isNogc && sc.func.setGC())\n                                             s ~= \"nogc \";\n@@ -5156,12 +5174,12 @@ extern (C++) final class TypeDelegate : TypeNext\n         return t;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return target.ptrsize * 2;\n     }\n \n-    override uint alignsize() const\n+    override uint alignsize()\n     {\n         return target.ptrsize;\n     }\n@@ -5189,17 +5207,17 @@ extern (C++) final class TypeDelegate : TypeNext\n         return MATCH.nomatch;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;\n     }\n \n-    override bool hasPointers() const\n+    override bool hasPointers()\n     {\n         return true;\n     }\n@@ -5748,12 +5766,12 @@ extern (C++) final class TypeStruct : Type\n         return assignable;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return false;\n     }\n \n-    override bool needsDestruction() const\n+    override bool needsDestruction()\n     {\n         return sym.dtor !is null;\n     }\n@@ -5985,6 +6003,7 @@ extern (C++) final class TypeEnum : Type\n     {\n         return sym.getMemtype(loc);\n     }\n+\n     override uint alignsize()\n     {\n         Type t = memType();\n@@ -6143,7 +6162,7 @@ extern (C++) final class TypeClass : Type\n         return \"class\";\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return target.ptrsize;\n     }\n@@ -6268,22 +6287,22 @@ extern (C++) final class TypeClass : Type\n         return this;\n     }\n \n-    override bool isZeroInit(const ref Loc loc) const\n+    override bool isZeroInit(const ref Loc loc)\n     {\n         return true;\n     }\n \n-    override bool isscope() const\n+    override bool isscope()\n     {\n         return sym.stack;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;\n     }\n \n-    override bool hasPointers() const\n+    override bool hasPointers()\n     {\n         return true;\n     }\n@@ -6538,12 +6557,12 @@ extern (C++) final class TypeNull : Type\n         return true;\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return tvoidptr.size(loc);\n     }\n@@ -6597,12 +6616,12 @@ extern (C++) final class TypeNoreturn : Type\n         return this.implicitConvTo(to);\n     }\n \n-    override bool isBoolean() const\n+    override bool isBoolean()\n     {\n         return true;  // bottom type can be implicitly converted to any other type\n     }\n \n-    override uinteger_t size(const ref Loc loc) const\n+    override uinteger_t size(const ref Loc loc)\n     {\n         return 0;\n     }"}, {"sha": "3565913ed27fddfe002d5527443ed57faa38e452", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 266, "deletions": 274, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -119,14 +119,6 @@ enum MODFlags\n };\n typedef unsigned char MOD;\n \n-enum class Covariant\n-{\n-    distinct = 0,\n-    yes = 1,\n-    no = 2,\n-    fwdref = 3,\n-};\n-\n enum VarArgValues\n {\n     VARARGnone     = 0,  /// fixed number of arguments\n@@ -221,13 +213,12 @@ class Type : public ASTNode\n     virtual const char *kind();\n     Type *copy() const;\n     virtual Type *syntaxCopy();\n-    bool equals(const RootObject *o) const;\n+    bool equals(const RootObject *o) const override;\n     bool equivalent(Type *t);\n     // kludge for template.isType()\n-    DYNCAST dyncast() const { return DYNCAST_TYPE; }\n+    DYNCAST dyncast() const override final { return DYNCAST_TYPE; }\n     size_t getUniqueID() const;\n-    Covariant covariant(Type *t, StorageClass *pstc = NULL);\n-    const char *toChars() const;\n+    const char *toChars() const override;\n     char *toPrettyChars(bool QualifyTypes = false);\n     static void _init();\n \n@@ -306,7 +297,7 @@ class Type : public ASTNode\n     virtual ClassDeclaration *isClassHandle();\n     virtual structalign_t alignment();\n     virtual Expression *defaultInitLiteral(const Loc &loc);\n-    virtual bool isZeroInit(const Loc &loc = Loc());                // if initializer is 0\n+    virtual bool isZeroInit(const Loc &loc = Loc()); // if initializer is 0\n     Identifier *getTypeInfoIdent();\n     virtual int hasWild() const;\n     virtual bool hasPointers();\n@@ -349,183 +340,183 @@ class Type : public ASTNode\n     TypeNoreturn *isTypeNoreturn();\n     TypeTag *isTypeTag();\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeError : public Type\n+class TypeError final : public Type\n {\n public:\n-    const char *kind();\n-    TypeError *syntaxCopy();\n+    const char *kind() override;\n+    TypeError *syntaxCopy() override;\n \n-    uinteger_t size(const Loc &loc);\n-    Expression *defaultInitLiteral(const Loc &loc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    uinteger_t size(const Loc &loc) override;\n+    Expression *defaultInitLiteral(const Loc &loc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeNext : public Type\n {\n public:\n     Type *next;\n \n-    void checkDeprecated(const Loc &loc, Scope *sc);\n-    int hasWild() const;\n-    Type *nextOf();\n-    Type *makeConst();\n-    Type *makeImmutable();\n-    Type *makeShared();\n-    Type *makeSharedConst();\n-    Type *makeWild();\n-    Type *makeWildConst();\n-    Type *makeSharedWild();\n-    Type *makeSharedWildConst();\n-    Type *makeMutable();\n-    MATCH constConv(Type *to);\n-    unsigned char deduceWild(Type *t, bool isRef);\n+    void checkDeprecated(const Loc &loc, Scope *sc) override final;\n+    int hasWild() const override final;\n+    Type *nextOf() override final;\n+    Type *makeConst() override final;\n+    Type *makeImmutable() override final;\n+    Type *makeShared() override final;\n+    Type *makeSharedConst() override final;\n+    Type *makeWild() override final;\n+    Type *makeWildConst() override final;\n+    Type *makeSharedWild() override final;\n+    Type *makeSharedWildConst() override final;\n+    Type *makeMutable() override final;\n+    MATCH constConv(Type *to) override;\n+    unsigned char deduceWild(Type *t, bool isRef) override final;\n     void transitive();\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeBasic : public Type\n+class TypeBasic final : public Type\n {\n public:\n     const char *dstring;\n     unsigned flags;\n \n-    const char *kind();\n-    TypeBasic *syntaxCopy();\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    unsigned alignsize();\n-    bool isintegral();\n-    bool isfloating() /*const*/;\n-    bool isreal() /*const*/;\n-    bool isimaginary() /*const*/;\n-    bool iscomplex() /*const*/;\n-    bool isscalar() /*const*/;\n-    bool isunsigned() /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    bool isZeroInit(const Loc &loc) /*const*/;\n+    const char *kind() override;\n+    TypeBasic *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    bool isintegral() override;\n+    bool isfloating() override;\n+    bool isreal() override;\n+    bool isimaginary() override;\n+    bool iscomplex() override;\n+    bool isscalar() override;\n+    bool isunsigned() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    bool isZeroInit(const Loc &loc) override;\n \n     // For eliminating dynamic_cast\n-    TypeBasic *isTypeBasic();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TypeBasic *isTypeBasic() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeVector : public Type\n+class TypeVector final : public Type\n {\n public:\n     Type *basetype;\n \n     static TypeVector *create(Type *basetype);\n-    const char *kind();\n-    TypeVector *syntaxCopy();\n-    uinteger_t size(const Loc &loc);\n-    unsigned alignsize();\n-    bool isintegral();\n-    bool isfloating();\n-    bool isscalar();\n-    bool isunsigned();\n-    bool isBoolean() /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    Expression *defaultInitLiteral(const Loc &loc);\n+    const char *kind() override;\n+    TypeVector *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    bool isintegral() override;\n+    bool isfloating() override;\n+    bool isscalar() override;\n+    bool isunsigned() override;\n+    bool isBoolean() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    Expression *defaultInitLiteral(const Loc &loc) override;\n     TypeBasic *elementType();\n-    bool isZeroInit(const Loc &loc);\n+    bool isZeroInit(const Loc &loc) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeArray : public TypeNext\n {\n public:\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Static array, one with a fixed dimension\n-class TypeSArray : public TypeArray\n+class TypeSArray final : public TypeArray\n {\n public:\n     Expression *dim;\n \n-    const char *kind();\n-    TypeSArray *syntaxCopy();\n+    const char *kind() override;\n+    TypeSArray *syntaxCopy() override;\n     bool isIncomplete();\n-    uinteger_t size(const Loc &loc);\n-    unsigned alignsize();\n-    bool isString();\n-    bool isZeroInit(const Loc &loc);\n-    structalign_t alignment();\n-    MATCH constConv(Type *to);\n-    MATCH implicitConvTo(Type *to);\n-    Expression *defaultInitLiteral(const Loc &loc);\n-    bool hasPointers();\n-    bool hasInvariant();\n-    bool needsDestruction();\n-    bool needsCopyOrPostblit();\n-    bool needsNested();\n-\n-    void accept(Visitor *v) { v->visit(this); }\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    bool isString() override;\n+    bool isZeroInit(const Loc &loc) override;\n+    structalign_t alignment() override;\n+    MATCH constConv(Type *to) override;\n+    MATCH implicitConvTo(Type *to) override;\n+    Expression *defaultInitLiteral(const Loc &loc) override;\n+    bool hasPointers() override;\n+    bool hasInvariant() override;\n+    bool needsDestruction() override;\n+    bool needsCopyOrPostblit() override;\n+    bool needsNested() override;\n+\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Dynamic array, no dimension\n-class TypeDArray : public TypeArray\n+class TypeDArray final : public TypeArray\n {\n public:\n-    const char *kind();\n-    TypeDArray *syntaxCopy();\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    unsigned alignsize() /*const*/;\n-    bool isString();\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    bool isBoolean() /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    bool hasPointers() /*const*/;\n+    const char *kind() override;\n+    TypeDArray *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    bool isString() override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool isBoolean() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    bool hasPointers() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeAArray : public TypeArray\n+class TypeAArray final : public TypeArray\n {\n public:\n     Type *index;                // key type\n     Loc loc;\n \n     static TypeAArray *create(Type *t, Type *index);\n-    const char *kind();\n-    TypeAArray *syntaxCopy();\n-    uinteger_t size(const Loc &loc);\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    bool isBoolean() /*const*/;\n-    bool hasPointers() /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    MATCH constConv(Type *to);\n+    const char *kind() override;\n+    TypeAArray *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool isBoolean() override;\n+    bool hasPointers() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    MATCH constConv(Type *to) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypePointer : public TypeNext\n+class TypePointer final : public TypeNext\n {\n public:\n     static TypePointer *create(Type *t);\n-    const char *kind();\n-    TypePointer *syntaxCopy();\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    MATCH constConv(Type *to);\n-    bool isscalar() /*const*/;\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    bool hasPointers() /*const*/;\n+    const char *kind() override;\n+    TypePointer *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    MATCH implicitConvTo(Type *to) override;\n+    MATCH constConv(Type *to) override;\n+    bool isscalar() override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool hasPointers() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeReference : public TypeNext\n+class TypeReference final : public TypeNext\n {\n public:\n-    const char *kind();\n-    TypeReference *syntaxCopy();\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeReference *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    bool isZeroInit(const Loc &loc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n enum RET\n@@ -556,7 +547,7 @@ enum class PURE : unsigned char\n     const_ = 3,     // parameters are values or const\n };\n \n-class Parameter : public ASTNode\n+class Parameter final : public ASTNode\n {\n public:\n     StorageClass storageClass;\n@@ -570,12 +561,12 @@ class Parameter : public ASTNode\n     Parameter *syntaxCopy();\n     Type *isLazyArray();\n     // kludge for template.isType()\n-    DYNCAST dyncast() const { return DYNCAST_PARAMETER; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    DYNCAST dyncast() const override { return DYNCAST_PARAMETER; }\n+    void accept(Visitor *v) override { v->visit(this); }\n \n     static size_t dim(Parameters *parameters);\n     static Parameter *getNth(Parameters *parameters, d_size_t nth);\n-    const char *toChars() const;\n+    const char *toChars() const override;\n     bool isCovariant(bool returnByRef, const Parameter *p, bool previewIn) const;\n };\n \n@@ -590,7 +581,7 @@ struct ParameterList\n     Parameter *operator[](size_t i) { return Parameter::getNth(parameters, i); }\n };\n \n-class TypeFunction : public TypeNext\n+class TypeFunction final : public TypeNext\n {\n public:\n     // .next is the return type\n@@ -604,16 +595,16 @@ class TypeFunction : public TypeNext\n     Expressions *fargs;          // function arguments\n \n     static TypeFunction *create(Parameters *parameters, Type *treturn, VarArg varargs, LINK linkage, StorageClass stc = 0);\n-    const char *kind();\n-    TypeFunction *syntaxCopy();\n+    const char *kind() override;\n+    TypeFunction *syntaxCopy() override;\n     void purityLevel();\n     bool hasLazyParameters();\n     bool isDstyleVariadic() const;\n     StorageClass parameterStorageClass(Parameter *p);\n-    Type *addStorageClass(StorageClass stc);\n+    Type *addStorageClass(StorageClass stc) override;\n \n-    Type *substWildTo(unsigned mod);\n-    MATCH constConv(Type *to);\n+    Type *substWildTo(unsigned mod) override;\n+    MATCH constConv(Type *to) override;\n \n     bool isnothrow() const;\n     void isnothrow(bool v);\n@@ -643,53 +634,53 @@ class TypeFunction : public TypeNext\n     void isInOutQual(bool v);\n     bool iswild() const;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeDelegate : public TypeNext\n+class TypeDelegate final : public TypeNext\n {\n public:\n     // .next is a TypeFunction\n \n     static TypeDelegate *create(TypeFunction *t);\n-    const char *kind();\n-    TypeDelegate *syntaxCopy();\n-    Type *addStorageClass(StorageClass stc);\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    unsigned alignsize() /*const*/;\n-    MATCH implicitConvTo(Type *to);\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    bool isBoolean() /*const*/;\n-    bool hasPointers() /*const*/;\n+    const char *kind() override;\n+    TypeDelegate *syntaxCopy() override;\n+    Type *addStorageClass(StorageClass stc) override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool isBoolean() override;\n+    bool hasPointers() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeTraits : public Type\n+class TypeTraits final : public Type\n {\n     Loc loc;\n     /// The expression to resolve as type or symbol.\n     TraitsExp *exp;\n     /// Cached type/symbol after semantic analysis.\n     RootObject *obj;\n \n-    const char *kind();\n-    TypeTraits *syntaxCopy();\n-    uinteger_t size(const Loc &loc);\n-    Dsymbol *toDsymbol(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeTraits *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeMixin : public Type\n+class TypeMixin final : public Type\n {\n     Loc loc;\n     Expressions *exps;\n     RootObject *obj;\n \n-    const char *kind();\n-    TypeMixin *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeMixin *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeQualified : public Type\n@@ -704,57 +695,57 @@ class TypeQualified : public Type\n     void addIdent(Identifier *ident);\n     void addInst(TemplateInstance *inst);\n     void addIndex(RootObject *expr);\n-    uinteger_t size(const Loc &loc);\n+    uinteger_t size(const Loc &loc) override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeIdentifier : public TypeQualified\n+class TypeIdentifier final : public TypeQualified\n {\n public:\n     Identifier *ident;\n     Dsymbol *originalSymbol; // The symbol representing this identifier, before alias resolution\n \n     static TypeIdentifier *create(const Loc &loc, Identifier *ident);\n-    const char *kind();\n-    TypeIdentifier *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeIdentifier *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Similar to TypeIdentifier, but with a TemplateInstance as the root\n  */\n-class TypeInstance : public TypeQualified\n+class TypeInstance final : public TypeQualified\n {\n public:\n     TemplateInstance *tempinst;\n \n-    const char *kind();\n-    TypeInstance *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeInstance *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeTypeof : public TypeQualified\n+class TypeTypeof final : public TypeQualified\n {\n public:\n     Expression *exp;\n     int inuse;\n \n-    const char *kind();\n-    TypeTypeof *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    uinteger_t size(const Loc &loc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeTypeof *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    uinteger_t size(const Loc &loc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeReturn : public TypeQualified\n+class TypeReturn final : public TypeQualified\n {\n public:\n-    const char *kind();\n-    TypeReturn *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeReturn *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // Whether alias this dependency is recursive or not.\n@@ -769,99 +760,99 @@ enum AliasThisRec\n     RECtracingDT = 0x8  // mark in progress of deduceType\n };\n \n-class TypeStruct : public Type\n+class TypeStruct final : public Type\n {\n public:\n     StructDeclaration *sym;\n     AliasThisRec att;\n     bool inuse;\n \n     static TypeStruct *create(StructDeclaration *sym);\n-    const char *kind();\n-    uinteger_t size(const Loc &loc);\n-    unsigned alignsize();\n-    TypeStruct *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    structalign_t alignment();\n-    Expression *defaultInitLiteral(const Loc &loc);\n-    bool isZeroInit(const Loc &loc);\n-    bool isAssignable();\n-    bool isBoolean() /*const*/;\n-    bool needsDestruction() /*const*/;\n-    bool needsCopyOrPostblit();\n-    bool needsNested();\n-    bool hasPointers();\n-    bool hasVoidInitPointers();\n-    bool hasInvariant();\n-    MATCH implicitConvTo(Type *to);\n-    MATCH constConv(Type *to);\n-    unsigned char deduceWild(Type *t, bool isRef);\n-    Type *toHeadMutable();\n-\n-    void accept(Visitor *v) { v->visit(this); }\n-};\n-\n-class TypeEnum : public Type\n+    const char *kind() override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n+    TypeStruct *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    structalign_t alignment() override;\n+    Expression *defaultInitLiteral(const Loc &loc) override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool isAssignable() override;\n+    bool isBoolean() override;\n+    bool needsDestruction() override;\n+    bool needsCopyOrPostblit() override;\n+    bool needsNested() override;\n+    bool hasPointers() override;\n+    bool hasVoidInitPointers() override;\n+    bool hasInvariant() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    MATCH constConv(Type *to) override;\n+    unsigned char deduceWild(Type *t, bool isRef) override;\n+    Type *toHeadMutable() override;\n+\n+    void accept(Visitor *v) override { v->visit(this); }\n+};\n+\n+class TypeEnum final : public Type\n {\n public:\n     EnumDeclaration *sym;\n \n-    const char *kind();\n-    TypeEnum *syntaxCopy();\n-    uinteger_t size(const Loc &loc);\n-    unsigned alignsize();\n+    const char *kind() override;\n+    TypeEnum *syntaxCopy() override;\n+    uinteger_t size(const Loc &loc) override;\n+    unsigned alignsize() override;\n     Type *memType(const Loc &loc = Loc());\n-    Dsymbol *toDsymbol(Scope *sc);\n-    bool isintegral();\n-    bool isfloating();\n-    bool isreal();\n-    bool isimaginary();\n-    bool iscomplex();\n-    bool isscalar();\n-    bool isunsigned();\n-    bool isBoolean();\n-    bool isString();\n-    bool isAssignable();\n-    bool needsDestruction();\n-    bool needsCopyOrPostblit();\n-    bool needsNested();\n-    MATCH implicitConvTo(Type *to);\n-    MATCH constConv(Type *to);\n-    bool isZeroInit(const Loc &loc);\n-    bool hasPointers();\n-    bool hasVoidInitPointers();\n-    bool hasInvariant();\n-    Type *nextOf();\n-\n-    void accept(Visitor *v) { v->visit(this); }\n-};\n-\n-class TypeClass : public Type\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    bool isintegral() override;\n+    bool isfloating() override;\n+    bool isreal() override;\n+    bool isimaginary() override;\n+    bool iscomplex() override;\n+    bool isscalar() override;\n+    bool isunsigned() override;\n+    bool isBoolean() override;\n+    bool isString() override;\n+    bool isAssignable() override;\n+    bool needsDestruction() override;\n+    bool needsCopyOrPostblit() override;\n+    bool needsNested() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    MATCH constConv(Type *to) override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool hasPointers() override;\n+    bool hasVoidInitPointers() override;\n+    bool hasInvariant() override;\n+    Type *nextOf() override;\n+\n+    void accept(Visitor *v) override { v->visit(this); }\n+};\n+\n+class TypeClass final : public Type\n {\n public:\n     ClassDeclaration *sym;\n     AliasThisRec att;\n     CPPMANGLE cppmangle;\n \n-    const char *kind();\n-    uinteger_t size(const Loc &loc) /*const*/;\n-    TypeClass *syntaxCopy();\n-    Dsymbol *toDsymbol(Scope *sc);\n-    ClassDeclaration *isClassHandle();\n-    bool isBaseOf(Type *t, int *poffset);\n-    MATCH implicitConvTo(Type *to);\n-    MATCH constConv(Type *to);\n-    unsigned char deduceWild(Type *t, bool isRef);\n-    Type *toHeadMutable();\n-    bool isZeroInit(const Loc &loc) /*const*/;\n-    bool isscope() /*const*/;\n-    bool isBoolean() /*const*/;\n-    bool hasPointers() /*const*/;\n+    const char *kind() override;\n+    uinteger_t size(const Loc &loc) override;\n+    TypeClass *syntaxCopy() override;\n+    Dsymbol *toDsymbol(Scope *sc) override;\n+    ClassDeclaration *isClassHandle() override;\n+    bool isBaseOf(Type *t, int *poffset) override;\n+    MATCH implicitConvTo(Type *to) override;\n+    MATCH constConv(Type *to) override;\n+    unsigned char deduceWild(Type *t, bool isRef) override;\n+    Type *toHeadMutable() override;\n+    bool isZeroInit(const Loc &loc) override;\n+    bool isscope() override;\n+    bool isBoolean() override;\n+    bool hasPointers() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeTuple : public Type\n+class TypeTuple final : public Type\n {\n public:\n     // 'logically immutable' cached global - don't modify (neither pointer nor pointee)!\n@@ -873,56 +864,57 @@ class TypeTuple : public Type\n     static TypeTuple *create();\n     static TypeTuple *create(Type *t1);\n     static TypeTuple *create(Type *t1, Type *t2);\n-    const char *kind();\n-    TypeTuple *syntaxCopy();\n-    bool equals(const RootObject *o) const;\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeTuple *syntaxCopy() override;\n+    bool equals(const RootObject *o) const override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeSlice : public TypeNext\n+class TypeSlice final : public TypeNext\n {\n public:\n     Expression *lwr;\n     Expression *upr;\n \n-    const char *kind();\n-    TypeSlice *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *kind() override;\n+    TypeSlice *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TypeNull : public Type\n+class TypeNull final : public Type\n {\n public:\n-    const char *kind();\n+    const char *kind() override;\n \n-    TypeNull *syntaxCopy();\n-    MATCH implicitConvTo(Type *to);\n-    bool isBoolean() /*const*/;\n+    TypeNull *syntaxCopy() override;\n+    MATCH implicitConvTo(Type *to) override;\n+    bool hasPointers() override;\n+    bool isBoolean() override;\n \n-    uinteger_t size(const Loc &loc) /*const*/;\n-    void accept(Visitor *v) { v->visit(this); }\n+    uinteger_t size(const Loc &loc) override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeNoreturn final : public Type\n {\n public:\n-    const char *kind();\n-    TypeNoreturn *syntaxCopy();\n-    MATCH implicitConvTo(Type* to);\n-    MATCH constConv(Type* to);\n-    bool isBoolean() /* const */;\n-    uinteger_t size(const Loc& loc) /* const */;\n-    unsigned alignsize();\n+    const char *kind() override;\n+    TypeNoreturn *syntaxCopy() override;\n+    MATCH implicitConvTo(Type* to) override;\n+    MATCH constConv(Type* to) override;\n+    bool isBoolean() override;\n+    uinteger_t size(const Loc& loc) override;\n+    unsigned alignsize() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class TypeTag final : public Type\n {\n public:\n-    TypeTag *syntaxCopy();\n+    TypeTag *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /**************************************************************/"}, {"sha": "9dbbdf2fd0aff7df3f1d4823a7069090e26cfd0a", "filename": "gcc/d/dmd/nspace.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fnspace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fnspace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -16,17 +16,17 @@\n  * Implies extern(C++).\n  */\n \n-class Nspace : public ScopeDsymbol\n+class Nspace final : public ScopeDsymbol\n {\n   public:\n     Expression *identExp;\n-    Nspace *syntaxCopy(Dsymbol *s);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void setScope(Scope *sc);\n-    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n-    bool hasPointers();\n-    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n-    const char *kind() const;\n-    Nspace *isNspace() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    Nspace *syntaxCopy(Dsymbol *s) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    void setScope(Scope *sc) override;\n+    Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly) override;\n+    bool hasPointers() override;\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override;\n+    const char *kind() const override;\n+    Nspace *isNspace() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "387b28c153292af0d1bda6d23c7710ada43c614c", "filename": "gcc/d/dmd/parsetimevisitor.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -272,6 +272,10 @@ public:\n     void visit(AST.UshrAssignExp e) { visit(cast(AST.BinAssignExp)e); }\n     void visit(AST.CatAssignExp e) { visit(cast(AST.BinAssignExp)e); }\n \n+    // CatAssignExp\n+    void visit(AST.CatElemAssignExp e) { visit(cast(AST.CatAssignExp)e); }\n+    void visit(AST.CatDcharAssignExp e) { visit(cast(AST.CatAssignExp)e); }\n+\n     //===============================================================================\n     // TemplateParameter\n     void visit(AST.TemplateAliasParameter tp) { visit(cast(AST.TemplateParameter)tp); }"}, {"sha": "0c92a9af54f18f9ec23e4126da457b3d9e40c342", "filename": "gcc/d/dmd/root/object.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fobject.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -26,7 +26,9 @@ enum DYNCAST\n     DYNCAST_TUPLE,\n     DYNCAST_PARAMETER,\n     DYNCAST_STATEMENT,\n-    DYNCAST_TEMPLATEPARAMETER\n+    DYNCAST_CONDITION,\n+    DYNCAST_TEMPLATEPARAMETER,\n+    DYNCAST_INITIALIZER\n };\n \n /*"}, {"sha": "4446b5e66b004e3215d4dcaff247356bb316aa7e", "filename": "gcc/d/dmd/safe.d", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fsafe.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fsafe.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -26,7 +26,7 @@ import dmd.identifier;\n import dmd.mtype;\n import dmd.target;\n import dmd.tokens;\n-\n+import dmd.func : setUnsafe;\n \n /*************************************************************\n  * Check for unsafe access in @safe code:\n@@ -66,7 +66,7 @@ bool checkUnsafeAccess(Scope* sc, Expression e, bool readonly, bool printmsg)\n         {\n             if (v.overlapped)\n             {\n-                if (sc.func.setUnsafe(!printmsg, e.loc,\n+                if (sc.setUnsafe(!printmsg, e.loc,\n                     \"field `%s.%s` cannot access pointers in `@safe` code that overlap other fields\", ad, v))\n                     return true;\n             }\n@@ -76,7 +76,7 @@ bool checkUnsafeAccess(Scope* sc, Expression e, bool readonly, bool printmsg)\n         {\n             if (v.overlapped)\n             {\n-                if (sc.func.setUnsafe(!printmsg, e.loc,\n+                if (sc.setUnsafe(!printmsg, e.loc,\n                     \"field `%s.%s` cannot access structs with invariants in `@safe` code that overlap other fields\",\n                     ad, v))\n                     return true;\n@@ -91,15 +91,15 @@ bool checkUnsafeAccess(Scope* sc, Expression e, bool readonly, bool printmsg)\n             if ((!ad.type.alignment.isDefault() && ad.type.alignment.get() < target.ptrsize ||\n                  (v.offset & (target.ptrsize - 1))))\n             {\n-                if (sc.func.setUnsafe(!printmsg, e.loc,\n+                if (sc.setUnsafe(!printmsg, e.loc,\n                     \"field `%s.%s` cannot modify misaligned pointers in `@safe` code\", ad, v))\n                     return true;\n             }\n         }\n \n         if (v.overlapUnsafe)\n         {\n-            if (sc.func.setUnsafe(!printmsg, e.loc,\n+            if (sc.setUnsafe(!printmsg, e.loc,\n                 \"field `%s.%s` cannot modify fields in `@safe` code that overlap fields with other storage classes\",\n                 ad, v))\n             {\n@@ -211,15 +211,12 @@ bool isSafeCast(Expression e, Type tfrom, Type tto)\n  */\n bool checkUnsafeDotExp(Scope* sc, Expression e, Identifier id, int flag)\n {\n-    if (!(flag & DotExpFlag.noDeref) && // this use is attempting a dereference\n-        sc.func &&                      // inside a function\n-        !sc.intypeof &&                 // allow unsafe code in typeof expressions\n-        !(sc.flags & SCOPE.debug_))     // allow unsafe code in debug statements\n+    if (!(flag & DotExpFlag.noDeref)) // this use is attempting a dereference\n     {\n         if (id == Id.ptr)\n-            return sc.func.setUnsafe(false, e.loc, \"`%s.ptr` cannot be used in `@safe` code, use `&%s[0]` instead\", e, e);\n+            return sc.setUnsafe(false, e.loc, \"`%s.ptr` cannot be used in `@safe` code, use `&%s[0]` instead\", e, e);\n         else\n-            return sc.func.setUnsafe(false, e.loc, \"`%s.%s` cannot be used in `@safe` code\", e, id);\n+            return sc.setUnsafe(false, e.loc, \"`%s.%s` cannot be used in `@safe` code\", e, id);\n     }\n     return false;\n }"}, {"sha": "f7a3836961c7cd5f196f77583ca2ea85f68d2562", "filename": "gcc/d/dmd/sideeffect.d", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fsideeffect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fsideeffect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -203,10 +203,9 @@ private bool lambdaHasSideEffect(Expression e, bool assumeImpureCalls = false)\n                 Type t = ce.e1.type.toBasetype();\n                 if (t.ty == Tdelegate)\n                     t = (cast(TypeDelegate)t).next;\n-                if (t.ty == Tfunction && (ce.f ? callSideEffectLevel(ce.f) : callSideEffectLevel(ce.e1.type)) > 0)\n-                {\n-                }\n-                else\n+\n+                const level = t.ty == Tfunction && (ce.f ? callSideEffectLevel(ce.f) : callSideEffectLevel(ce.e1.type));\n+                if (level == 0) // 0 means the function has a side effect\n                     return true;\n             }\n             break;\n@@ -251,8 +250,9 @@ bool discardValue(Expression e)\n             }\n             break; // complain\n         }\n+    // Assumption that error => no side effect\n     case EXP.error:\n-        return false;\n+        return true;\n     case EXP.variable:\n         {\n             VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n@@ -356,6 +356,25 @@ bool discardValue(Expression e)\n         if (!hasSideEffect(e))\n             break;\n         return false;\n+    case EXP.identity, EXP.notIdentity:\n+    case EXP.equal, EXP.notEqual:\n+        /*\n+            `[side effect] == 0`\n+            Technically has a side effect but is clearly wrong;\n+        */\n+        BinExp tmp = e.isBinExp();\n+        assert(tmp);\n+\n+        e.error(\"the result of the equality expression `%s` is discarded\", e.toChars());\n+        bool seenSideEffect = false;\n+        foreach(expr; [tmp.e1, tmp.e2])\n+        {\n+            if (hasSideEffect(expr)) {\n+                expr.errorSupplemental(\"note that `%s` may have a side effect\", expr.toChars());\n+                seenSideEffect |= true;\n+            }\n+        }\n+        return !seenSideEffect;\n     default:\n         break;\n     }"}, {"sha": "06546256d1762f94cb06cc3285e064e078006556", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -696,7 +696,7 @@ extern (C++) final class UnrolledLoopStatement : Statement\n \n /***********************************************************\n  */\n-extern (C++) class ScopeStatement : Statement\n+extern (C++) final class ScopeStatement : Statement\n {\n     Statement statement;\n     Loc endloc;                 // location of closing curly bracket"}, {"sha": "681b48163200e4d078180e03f0734d2882a2df94", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 160, "deletions": 158, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -109,9 +109,11 @@ class Statement : public ASTNode\n     Loc loc;\n     STMT stmt;\n \n+    DYNCAST dyncast() const override final { return DYNCAST_STATEMENT; }\n+\n     virtual Statement *syntaxCopy();\n \n-    const char *toChars() const;\n+    const char *toChars() const override final;\n \n     void error(const char *format, ...);\n     void warning(const char *format, ...);\n@@ -159,26 +161,26 @@ class Statement : public ASTNode\n     ForeachRangeStatement *isForeachRangeStatement() { return stmt == STMTforeachRange ? (ForeachRangeStatement*)this : NULL; }\n     CompoundDeclarationStatement *isCompoundDeclarationStatement() { return stmt == STMTcompoundDeclaration ? (CompoundDeclarationStatement*)this : NULL; }\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /** Any Statement that fails semantic() or has a component that is an ErrorExp or\n  * a TypeError should return an ErrorStatement from semantic().\n  */\n-class ErrorStatement : public Statement\n+class ErrorStatement final : public Statement\n {\n public:\n-    ErrorStatement *syntaxCopy();\n+    ErrorStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PeelStatement : public Statement\n+class PeelStatement final : public Statement\n {\n public:\n     Statement *s;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class ExpStatement : public Statement\n@@ -187,30 +189,30 @@ class ExpStatement : public Statement\n     Expression *exp;\n \n     static ExpStatement *create(const Loc &loc, Expression *exp);\n-    ExpStatement *syntaxCopy();\n+    ExpStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DtorExpStatement : public ExpStatement\n+class DtorExpStatement final : public ExpStatement\n {\n public:\n     /* Wraps an expression that is the destruction of 'var'\n      */\n \n     VarDeclaration *var;\n \n-    DtorExpStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    DtorExpStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CompileStatement : public Statement\n+class CompileStatement final : public Statement\n {\n public:\n     Expressions *exps;\n \n-    CompileStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    CompileStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n class CompoundStatement : public Statement\n@@ -219,89 +221,89 @@ class CompoundStatement : public Statement\n     Statements *statements;\n \n     static CompoundStatement *create(const Loc &loc, Statement *s1, Statement *s2);\n-    CompoundStatement *syntaxCopy();\n-    ReturnStatement *endsWithReturnStatement();\n-    Statement *last();\n+    CompoundStatement *syntaxCopy() override;\n+    ReturnStatement *endsWithReturnStatement() override final;\n+    Statement *last() override final;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CompoundDeclarationStatement : public CompoundStatement\n+class CompoundDeclarationStatement final : public CompoundStatement\n {\n public:\n-    CompoundDeclarationStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    CompoundDeclarationStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* The purpose of this is so that continue will go to the next\n  * of the statements, and break will go to the end of the statements.\n  */\n-class UnrolledLoopStatement : public Statement\n+class UnrolledLoopStatement final : public Statement\n {\n public:\n     Statements *statements;\n \n-    UnrolledLoopStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    UnrolledLoopStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ScopeStatement : public Statement\n+class ScopeStatement final : public Statement\n {\n public:\n     Statement *statement;\n     Loc endloc;                 // location of closing curly bracket\n \n-    ScopeStatement *syntaxCopy();\n-    ReturnStatement *endsWithReturnStatement();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    ScopeStatement *syntaxCopy() override;\n+    ReturnStatement *endsWithReturnStatement() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ForwardingStatement : public Statement\n+class ForwardingStatement final : public Statement\n {\n public:\n     ForwardingScopeDsymbol *sym;\n     Statement *statement;\n \n-    ForwardingStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    ForwardingStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class WhileStatement : public Statement\n+class WhileStatement final : public Statement\n {\n public:\n     Parameter *param;\n     Expression *condition;\n     Statement *_body;\n     Loc endloc;                 // location of closing curly bracket\n \n-    WhileStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    WhileStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DoStatement : public Statement\n+class DoStatement final : public Statement\n {\n public:\n     Statement *_body;\n     Expression *condition;\n     Loc endloc;                 // location of ';' after while\n \n-    DoStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    DoStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ForStatement : public Statement\n+class ForStatement final : public Statement\n {\n public:\n     Statement *_init;\n@@ -315,15 +317,15 @@ class ForStatement : public Statement\n     // treat that label as referring to this loop.\n     Statement *relatedLabeled;\n \n-    ForStatement *syntaxCopy();\n-    Statement *getRelatedLabeled() { return relatedLabeled ? relatedLabeled : this; }\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    ForStatement *syntaxCopy() override;\n+    Statement *getRelatedLabeled() override { return relatedLabeled ? relatedLabeled : this; }\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ForeachStatement : public Statement\n+class ForeachStatement final : public Statement\n {\n public:\n     TOK op;                     // TOKforeach or TOKforeach_reverse\n@@ -340,14 +342,14 @@ class ForeachStatement : public Statement\n     Statements *cases;          // put breaks, continues, gotos and returns here\n     ScopeStatements *gotos;     // forward referenced goto's go here\n \n-    ForeachStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    ForeachStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ForeachRangeStatement : public Statement\n+class ForeachRangeStatement final : public Statement\n {\n public:\n     TOK op;                     // TOKforeach or TOKforeach_reverse\n@@ -359,14 +361,14 @@ class ForeachRangeStatement : public Statement\n \n     VarDeclaration *key;\n \n-    ForeachRangeStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    ForeachRangeStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class IfStatement : public Statement\n+class IfStatement final : public Statement\n {\n public:\n     Parameter *prm;\n@@ -376,56 +378,56 @@ class IfStatement : public Statement\n     VarDeclaration *match;      // for MatchExpression results\n     Loc endloc;                 // location of closing curly bracket\n \n-    IfStatement *syntaxCopy();\n+    IfStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ConditionalStatement : public Statement\n+class ConditionalStatement final : public Statement\n {\n public:\n     Condition *condition;\n     Statement *ifbody;\n     Statement *elsebody;\n \n-    ConditionalStatement *syntaxCopy();\n+    ConditionalStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticForeachStatement : public Statement\n+class StaticForeachStatement final : public Statement\n {\n public:\n     StaticForeach *sfe;\n \n-    StaticForeachStatement *syntaxCopy();\n+    StaticForeachStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class PragmaStatement : public Statement\n+class PragmaStatement final : public Statement\n {\n public:\n     Identifier *ident;\n     Expressions *args;          // array of Expression's\n     Statement *_body;\n \n-    PragmaStatement *syntaxCopy();\n+    PragmaStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class StaticAssertStatement : public Statement\n+class StaticAssertStatement final : public Statement\n {\n public:\n     StaticAssert *sa;\n \n-    StaticAssertStatement *syntaxCopy();\n+    StaticAssertStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SwitchStatement : public Statement\n+class SwitchStatement final : public Statement\n {\n public:\n     Expression *condition;\n@@ -441,13 +443,13 @@ class SwitchStatement : public Statement\n     int hasVars;                // !=0 if has variable case values\n     VarDeclaration *lastVar;\n \n-    SwitchStatement *syntaxCopy();\n-    bool hasBreak() const;\n+    SwitchStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class CaseStatement : public Statement\n+class CaseStatement final : public Statement\n {\n public:\n     Expression *exp;\n@@ -457,137 +459,137 @@ class CaseStatement : public Statement\n     VarDeclaration *lastVar;\n     void* extra;            // for use by Statement_toIR()\n \n-    CaseStatement *syntaxCopy();\n+    CaseStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n \n-class CaseRangeStatement : public Statement\n+class CaseRangeStatement final : public Statement\n {\n public:\n     Expression *first;\n     Expression *last;\n     Statement *statement;\n \n-    CaseRangeStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    CaseRangeStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n \n-class DefaultStatement : public Statement\n+class DefaultStatement final : public Statement\n {\n public:\n     Statement *statement;\n     VarDeclaration *lastVar;\n \n-    DefaultStatement *syntaxCopy();\n+    DefaultStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class GotoDefaultStatement : public Statement\n+class GotoDefaultStatement final : public Statement\n {\n public:\n     SwitchStatement *sw;\n \n-    GotoDefaultStatement *syntaxCopy();\n+    GotoDefaultStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class GotoCaseStatement : public Statement\n+class GotoCaseStatement final : public Statement\n {\n public:\n     Expression *exp;            // NULL, or which case to goto\n     CaseStatement *cs;          // case statement it resolves to\n \n-    GotoCaseStatement *syntaxCopy();\n+    GotoCaseStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SwitchErrorStatement : public Statement\n+class SwitchErrorStatement final : public Statement\n {\n public:\n     Expression *exp;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ReturnStatement : public Statement\n+class ReturnStatement final : public Statement\n {\n public:\n     Expression *exp;\n     size_t caseDim;\n \n-    ReturnStatement *syntaxCopy();\n+    ReturnStatement *syntaxCopy() override;\n \n-    ReturnStatement *endsWithReturnStatement() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    ReturnStatement *endsWithReturnStatement() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class BreakStatement : public Statement\n+class BreakStatement final : public Statement\n {\n public:\n     Identifier *ident;\n \n-    BreakStatement *syntaxCopy();\n+    BreakStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ContinueStatement : public Statement\n+class ContinueStatement final : public Statement\n {\n public:\n     Identifier *ident;\n \n-    ContinueStatement *syntaxCopy();\n+    ContinueStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class SynchronizedStatement : public Statement\n+class SynchronizedStatement final : public Statement\n {\n public:\n     Expression *exp;\n     Statement *_body;\n \n-    SynchronizedStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    SynchronizedStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class WithStatement : public Statement\n+class WithStatement final : public Statement\n {\n public:\n     Expression *exp;\n     Statement *_body;\n     VarDeclaration *wthis;\n     Loc endloc;\n \n-    WithStatement *syntaxCopy();\n+    WithStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TryCatchStatement : public Statement\n+class TryCatchStatement final : public Statement\n {\n public:\n     Statement *_body;\n     Catches *catches;\n \n     Statement *tryBody;   /// set to enclosing TryCatchStatement or TryFinallyStatement if in _body portion\n \n-    TryCatchStatement *syntaxCopy();\n-    bool hasBreak() const;\n+    TryCatchStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class Catch : public RootObject\n+class Catch final : public RootObject\n {\n public:\n     Loc loc;\n@@ -606,7 +608,7 @@ class Catch : public RootObject\n     Catch *syntaxCopy();\n };\n \n-class TryFinallyStatement : public Statement\n+class TryFinallyStatement final : public Statement\n {\n public:\n     Statement *_body;\n@@ -616,47 +618,47 @@ class TryFinallyStatement : public Statement\n     bool bodyFallsThru;   // true if _body falls through to finally\n \n     static TryFinallyStatement *create(const Loc &loc, Statement *body, Statement *finalbody);\n-    TryFinallyStatement *syntaxCopy();\n-    bool hasBreak() const;\n-    bool hasContinue() const;\n+    TryFinallyStatement *syntaxCopy() override;\n+    bool hasBreak() const override;\n+    bool hasContinue() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ScopeGuardStatement : public Statement\n+class ScopeGuardStatement final : public Statement\n {\n public:\n     TOK tok;\n     Statement *statement;\n \n-    ScopeGuardStatement *syntaxCopy();\n+    ScopeGuardStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ThrowStatement : public Statement\n+class ThrowStatement final : public Statement\n {\n public:\n     Expression *exp;\n     // was generated by the compiler,\n     // wasn't present in source code\n     bool internalThrow;\n \n-    ThrowStatement *syntaxCopy();\n+    ThrowStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class DebugStatement : public Statement\n+class DebugStatement final : public Statement\n {\n public:\n     Statement *statement;\n \n-    DebugStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    DebugStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class GotoStatement : public Statement\n+class GotoStatement final : public Statement\n {\n public:\n     Identifier *ident;\n@@ -666,12 +668,12 @@ class GotoStatement : public Statement\n     ScopeGuardStatement *os;\n     VarDeclaration *lastVar;\n \n-    GotoStatement *syntaxCopy();\n+    GotoStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class LabelStatement : public Statement\n+class LabelStatement final : public Statement\n {\n public:\n     Identifier *ident;\n@@ -684,12 +686,12 @@ class LabelStatement : public Statement\n     void* extra;                // used by Statement_toIR()\n     bool breaks;                // someone did a 'break ident'\n \n-    LabelStatement *syntaxCopy();\n+    LabelStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class LabelDsymbol : public Dsymbol\n+class LabelDsymbol final : public Dsymbol\n {\n public:\n     LabelStatement *statement;\n@@ -698,8 +700,8 @@ class LabelDsymbol : public Dsymbol\n     bool iasm;              // set if used by inline assembler\n \n     static LabelDsymbol *create(Identifier *ident);\n-    LabelDsymbol *isLabel();\n-    void accept(Visitor *v) { v->visit(this); }\n+    LabelDsymbol *isLabel() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n Statement* asmSemantic(AsmStatement *s, Scope *sc);\n@@ -709,11 +711,11 @@ class AsmStatement : public Statement\n public:\n     Token *tokens;\n \n-    AsmStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    AsmStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class InlineAsmStatement : public AsmStatement\n+class InlineAsmStatement final : public AsmStatement\n {\n public:\n     code *asmcode;\n@@ -722,12 +724,12 @@ class InlineAsmStatement : public AsmStatement\n     bool refparam;              // true if function parameter is referenced\n     bool naked;                 // true if function is to be naked\n \n-    InlineAsmStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    InlineAsmStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // A GCC asm statement - assembler instructions with D expression operands\n-class GccAsmStatement : public AsmStatement\n+class GccAsmStatement final : public AsmStatement\n {\n public:\n     StorageClass stc;           // attributes of the asm {} block\n@@ -740,27 +742,27 @@ class GccAsmStatement : public AsmStatement\n     Identifiers *labels;        // list of goto labels\n     GotoStatements *gotos;      // of the goto labels, the equivalent statements they represent\n \n-    GccAsmStatement *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    GccAsmStatement *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n // a complete asm {} block\n-class CompoundAsmStatement : public CompoundStatement\n+class CompoundAsmStatement final : public CompoundStatement\n {\n public:\n     StorageClass stc; // postfix attributes like nothrow/pure/@trusted\n \n-    CompoundAsmStatement *syntaxCopy();\n+    CompoundAsmStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class ImportStatement : public Statement\n+class ImportStatement final : public Statement\n {\n public:\n     Dsymbols *imports;          // Array of Import's\n \n-    ImportStatement *syntaxCopy();\n+    ImportStatement *syntaxCopy() override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "ed47b916c0a097537db5e2b45950e8c072fb6b66", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1616,9 +1616,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n     static FuncExp foreachBodyToFunction(Scope* sc, ForeachStatement fs, TypeFunction tfld)\n     {\n         auto params = new Parameters();\n-        foreach (i; 0 .. fs.parameters.dim)\n+        foreach (i, p; *fs.parameters)\n         {\n-            Parameter p = (*fs.parameters)[i];\n             StorageClass stc = STC.ref_ | (p.storageClass & STC.scope_);\n             Identifier id;\n \n@@ -3929,7 +3928,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             cas.error(\"`asm` statement is assumed to use the GC - mark it with `@nogc` if it does not\");\n         if (!(cas.stc & (STC.trusted | STC.safe)))\n         {\n-            sc.func.setUnsafe(false, cas.loc, \"`asm` statement is assumed to be `@system` - mark it with `@trusted` if it is not\");\n+            sc.setUnsafe(false, cas.loc, \"`asm` statement is assumed to be `@system` - mark it with `@trusted` if it is not\");\n         }\n \n         sc.pop();\n@@ -4034,9 +4033,9 @@ void catchSemantic(Catch c, Scope* sc)\n             error(c.loc, \"catching C++ class objects not supported for this target\");\n             c.errors = true;\n         }\n-        if (sc.func && !sc.intypeof && !c.internalCatch)\n+        if (!c.internalCatch)\n         {\n-            if (sc.func.setUnsafe(false, c.loc, \"cannot catch C++ class objects in `@safe` code\"))\n+            if (sc.setUnsafe(false, c.loc, \"cannot catch C++ class objects in `@safe` code\"))\n                 c.errors = true;\n         }\n     }\n@@ -4045,9 +4044,9 @@ void catchSemantic(Catch c, Scope* sc)\n         error(c.loc, \"can only catch class objects derived from `Throwable`, not `%s`\", c.type.toChars());\n         c.errors = true;\n     }\n-    else if (sc.func && !sc.intypeof && !c.internalCatch && ClassDeclaration.exception &&\n+    else if (!c.internalCatch && ClassDeclaration.exception &&\n             cd != ClassDeclaration.exception && !ClassDeclaration.exception.isBaseOf(cd, null) &&\n-            sc.func.setUnsafe(false, c.loc,\n+            sc.setUnsafe(false, c.loc,\n                 \"can only catch class objects derived from `Exception` in `@safe` code, not `%s`\", c.type))\n     {\n         c.errors = true;"}, {"sha": "d938990146939421f488e45e5c715398bc734d2a", "filename": "gcc/d/dmd/staticassert.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstaticassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fstaticassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -20,10 +20,10 @@ class StaticAssert : public Dsymbol\n     Expression *exp;\n     Expression *msg;\n \n-    StaticAssert *syntaxCopy(Dsymbol *s);\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    const char *kind() const;\n-    StaticAssert *isStaticAssert() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    StaticAssert *syntaxCopy(Dsymbol *s) override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    const char *kind() const override;\n+    StaticAssert *isStaticAssert() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "9ad027a86477b0f6af4270b618ac7b19056202a7", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -28,15 +28,15 @@ class Expression;\n class FuncDeclaration;\n class Parameter;\n \n-class Tuple : public RootObject\n+class Tuple final : public RootObject\n {\n public:\n     Objects objects;\n \n     // kludge for template.isType()\n-    DYNCAST dyncast() const { return DYNCAST_TUPLE; }\n+    DYNCAST dyncast() const override { return DYNCAST_TUPLE; }\n \n-    const char *toChars() const { return objects.toChars(); }\n+    const char *toChars() const override { return objects.toChars(); }\n };\n \n struct TemplatePrevious\n@@ -46,7 +46,7 @@ struct TemplatePrevious\n     Objects *dedargs;\n };\n \n-class TemplateDeclaration : public ScopeDsymbol\n+class TemplateDeclaration final : public ScopeDsymbol\n {\n public:\n     TemplateParameters *parameters;     // array of TemplateParameter's\n@@ -74,24 +74,24 @@ class TemplateDeclaration : public ScopeDsymbol\n \n     TemplatePrevious *previous;         // threaded list of previous instantiation attempts on stack\n \n-    TemplateDeclaration *syntaxCopy(Dsymbol *);\n-    bool overloadInsert(Dsymbol *s);\n-    bool hasStaticCtorOrDtor();\n-    const char *kind() const;\n-    const char *toChars() const;\n+    TemplateDeclaration *syntaxCopy(Dsymbol *) override;\n+    bool overloadInsert(Dsymbol *s) override;\n+    bool hasStaticCtorOrDtor() override;\n+    const char *kind() const override;\n+    const char *toChars() const override;\n \n-    Visibility visible();\n+    Visibility visible() override;\n \n     MATCH leastAsSpecialized(Scope *sc, TemplateDeclaration *td2, Expressions *fargs);\n     RootObject *declareParameter(Scope *sc, TemplateParameter *tp, RootObject *o);\n \n-    TemplateDeclaration *isTemplateDeclaration() { return this; }\n+    TemplateDeclaration *isTemplateDeclaration() override { return this; }\n \n     TemplateTupleParameter *isVariadic();\n-    bool isDeprecated() const;\n-    bool isOverloadable() const;\n+    bool isDeprecated() const override;\n+    bool isOverloadable() const override;\n \n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* For type-parameter:\n@@ -134,10 +134,12 @@ class TemplateParameter : public ASTNode\n     virtual RootObject *defaultArg(const Loc &instLoc, Scope *sc) = 0;\n     virtual bool hasDefaultArg() = 0;\n \n+    DYNCAST dyncast() const override { return DYNCAST_TEMPLATEPARAMETER; }\n+\n     /* Create dummy argument based on parameter.\n      */\n     virtual RootObject *dummyArg() = 0;\n-    void accept(Visitor *v) { v->visit(this); }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Syntax:\n@@ -149,85 +151,85 @@ class TemplateTypeParameter : public TemplateParameter\n     Type *specType;     // type parameter: if !=NULL, this is the type specialization\n     Type *defaultType;\n \n-    TemplateTypeParameter *isTemplateTypeParameter();\n-    TemplateTypeParameter *syntaxCopy();\n-    bool declareParameter(Scope *sc);\n-    void print(RootObject *oarg, RootObject *oded);\n-    RootObject *specialization();\n-    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n-    bool hasDefaultArg();\n-    RootObject *dummyArg();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateTypeParameter *isTemplateTypeParameter() override final;\n+    TemplateTypeParameter *syntaxCopy() override;\n+    bool declareParameter(Scope *sc) override final;\n+    void print(RootObject *oarg, RootObject *oded) override final;\n+    RootObject *specialization() override final;\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc) override final;\n+    bool hasDefaultArg() override final;\n+    RootObject *dummyArg() override final;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Syntax:\n  *  this ident : specType = defaultType\n  */\n-class TemplateThisParameter : public TemplateTypeParameter\n+class TemplateThisParameter final : public TemplateTypeParameter\n {\n public:\n-    TemplateThisParameter *isTemplateThisParameter();\n-    TemplateThisParameter *syntaxCopy();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateThisParameter *isTemplateThisParameter() override;\n+    TemplateThisParameter *syntaxCopy() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Syntax:\n  *  valType ident : specValue = defaultValue\n  */\n-class TemplateValueParameter : public TemplateParameter\n+class TemplateValueParameter final : public TemplateParameter\n {\n public:\n     Type *valType;\n     Expression *specValue;\n     Expression *defaultValue;\n \n-    TemplateValueParameter *isTemplateValueParameter();\n-    TemplateValueParameter *syntaxCopy();\n-    bool declareParameter(Scope *sc);\n-    void print(RootObject *oarg, RootObject *oded);\n-    RootObject *specialization();\n-    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n-    bool hasDefaultArg();\n-    RootObject *dummyArg();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateValueParameter *isTemplateValueParameter() override;\n+    TemplateValueParameter *syntaxCopy() override;\n+    bool declareParameter(Scope *sc) override;\n+    void print(RootObject *oarg, RootObject *oded) override;\n+    RootObject *specialization() override;\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc) override;\n+    bool hasDefaultArg() override;\n+    RootObject *dummyArg() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Syntax:\n  *  specType ident : specAlias = defaultAlias\n  */\n-class TemplateAliasParameter : public TemplateParameter\n+class TemplateAliasParameter final : public TemplateParameter\n {\n public:\n     Type *specType;\n     RootObject *specAlias;\n     RootObject *defaultAlias;\n \n-    TemplateAliasParameter *isTemplateAliasParameter();\n-    TemplateAliasParameter *syntaxCopy();\n-    bool declareParameter(Scope *sc);\n-    void print(RootObject *oarg, RootObject *oded);\n-    RootObject *specialization();\n-    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n-    bool hasDefaultArg();\n-    RootObject *dummyArg();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateAliasParameter *isTemplateAliasParameter() override;\n+    TemplateAliasParameter *syntaxCopy() override;\n+    bool declareParameter(Scope *sc) override;\n+    void print(RootObject *oarg, RootObject *oded) override;\n+    RootObject *specialization() override;\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc) override;\n+    bool hasDefaultArg() override;\n+    RootObject *dummyArg() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Syntax:\n  *  ident ...\n  */\n-class TemplateTupleParameter : public TemplateParameter\n+class TemplateTupleParameter final : public TemplateParameter\n {\n public:\n-    TemplateTupleParameter *isTemplateTupleParameter();\n-    TemplateTupleParameter *syntaxCopy();\n-    bool declareParameter(Scope *sc);\n-    void print(RootObject *oarg, RootObject *oded);\n-    RootObject *specialization();\n-    RootObject *defaultArg(const Loc &instLoc, Scope *sc);\n-    bool hasDefaultArg();\n-    RootObject *dummyArg();\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateTupleParameter *isTemplateTupleParameter() override;\n+    TemplateTupleParameter *syntaxCopy() override;\n+    bool declareParameter(Scope *sc) override;\n+    void print(RootObject *oarg, RootObject *oded) override;\n+    RootObject *specialization() override;\n+    RootObject *defaultArg(const Loc &instLoc, Scope *sc) override;\n+    bool hasDefaultArg() override;\n+    RootObject *dummyArg() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n /* Given:\n@@ -275,36 +277,36 @@ class TemplateInstance : public ScopeDsymbol\n public:\n     unsigned char inuse;                 // for recursive expansion detection\n \n-    TemplateInstance *syntaxCopy(Dsymbol *);\n-    Dsymbol *toAlias();                 // resolve real symbol\n-    const char *kind() const;\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    const char *toChars() const;\n-    const char* toPrettyCharsHelper();\n-    Identifier *getIdent();\n+    TemplateInstance *syntaxCopy(Dsymbol *) override;\n+    Dsymbol *toAlias() override final;   // resolve real symbol\n+    const char *kind() const override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    const char *toChars() const override;\n+    const char* toPrettyCharsHelper() override final;\n+    Identifier *getIdent() override final;\n     hash_t toHash();\n \n     bool isDiscardable();\n     bool needsCodegen();\n \n-    TemplateInstance *isTemplateInstance() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateInstance *isTemplateInstance() override final { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class TemplateMixin : public TemplateInstance\n+class TemplateMixin final : public TemplateInstance\n {\n public:\n     TypeQualified *tqual;\n \n-    TemplateMixin *syntaxCopy(Dsymbol *s);\n-    const char *kind() const;\n-    bool oneMember(Dsymbol **ps, Identifier *ident);\n-    bool hasPointers();\n-    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n-    const char *toChars() const;\n+    TemplateMixin *syntaxCopy(Dsymbol *s) override;\n+    const char *kind() const override;\n+    bool oneMember(Dsymbol **ps, Identifier *ident) override;\n+    bool hasPointers() override;\n+    void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion) override;\n+    const char *toChars() const override;\n \n-    TemplateMixin *isTemplateMixin() { return this; }\n-    void accept(Visitor *v) { v->visit(this); }\n+    TemplateMixin *isTemplateMixin() override { return this; }\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n Expression *isExpression(RootObject *o);"}, {"sha": "25dee7f41853e00be977b7dae10a6bc56e37d27d", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -423,12 +423,20 @@ package mixin template ParseVisitMethods(AST)\n         //printf(\"Visiting TypeQualified\\n\");\n         foreach (id; t.idents)\n         {\n-            if (id.dyncast() == DYNCAST.dsymbol)\n+            switch(id.dyncast()) with(DYNCAST)\n+            {\n+            case dsymbol:\n                 (cast(AST.TemplateInstance)id).accept(this);\n-            else if (id.dyncast() == DYNCAST.expression)\n+                break;\n+            case expression:\n                 (cast(AST.Expression)id).accept(this);\n-            else if (id.dyncast() == DYNCAST.type)\n+                break;\n+            case type:\n                 (cast(AST.Type)id).accept(this);\n+                break;\n+            default:\n+                break;\n+            }\n         }\n     }\n "}, {"sha": "4c9ca28f2fccd038735bfb678a739d38eb5c31dc", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -239,9 +239,10 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n     for (size_t i = 0; i < mt.idents.dim; i++)\n     {\n         RootObject id = mt.idents[i];\n-        if (id.dyncast() == DYNCAST.expression ||\n-            id.dyncast() == DYNCAST.type)\n+        switch (id.dyncast()) with (DYNCAST)\n         {\n+        case expression:\n+        case type:\n             Type tx;\n             Expression ex;\n             Dsymbol sx;\n@@ -259,6 +260,8 @@ private void resolveHelper(TypeQualified mt, const ref Loc loc, Scope* sc, Dsymb\n             ex = ex.expressionSemantic(sc);\n             resolveExp(ex, pt, pe, ps);\n             return;\n+        default:\n+            break;\n         }\n \n         Type t = s.getType(); // type symbol, type alias, or type tuple?\n@@ -2799,21 +2802,20 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n                 }\n \n                 RootObject o = (*tup.objects)[cast(size_t)d];\n-                if (o.dyncast() == DYNCAST.dsymbol)\n+                switch (o.dyncast()) with (DYNCAST)\n                 {\n+                case dsymbol:\n                     return returnSymbol(cast(Dsymbol)o);\n-                }\n-                if (o.dyncast() == DYNCAST.expression)\n-                {\n+                case expression:\n                     Expression e = cast(Expression)o;\n                     if (e.op == EXP.dSymbol)\n                         return returnSymbol(e.isDsymbolExp().s);\n                     else\n                         return returnExp(e);\n-                }\n-                if (o.dyncast() == DYNCAST.type)\n-                {\n+                case type:\n                     return returnType((cast(Type)o).addMod(mt.mod));\n+                default:\n+                    break;\n                 }\n \n                 /* Create a new TupleDeclaration which"}, {"sha": "b76393bc1ec29960e15efe22ca3c9000352dc561", "filename": "gcc/d/dmd/version.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fversion.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -12,30 +12,30 @@\n \n #include \"dsymbol.h\"\n \n-class DebugSymbol : public Dsymbol\n+class DebugSymbol final : public Dsymbol\n {\n public:\n     unsigned level;\n \n-    DebugSymbol *syntaxCopy(Dsymbol *);\n+    DebugSymbol *syntaxCopy(Dsymbol *) override;\n \n-    const char *toChars() const;\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    const char *kind() const;\n-    DebugSymbol *isDebugSymbol();\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *toChars() const override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    const char *kind() const override;\n+    DebugSymbol *isDebugSymbol() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };\n \n-class VersionSymbol : public Dsymbol\n+class VersionSymbol final : public Dsymbol\n {\n public:\n     unsigned level;\n \n-    VersionSymbol *syntaxCopy(Dsymbol *);\n+    VersionSymbol *syntaxCopy(Dsymbol *) override;\n \n-    const char *toChars() const;\n-    void addMember(Scope *sc, ScopeDsymbol *sds);\n-    const char *kind() const;\n-    VersionSymbol *isVersionSymbol();\n-    void accept(Visitor *v) { v->visit(this); }\n+    const char *toChars() const override;\n+    void addMember(Scope *sc, ScopeDsymbol *sds) override;\n+    const char *kind() const override;\n+    VersionSymbol *isVersionSymbol() override;\n+    void accept(Visitor *v) override { v->visit(this); }\n };"}, {"sha": "b45ef790de39129aaab467864370b8311bb0f43c", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -265,6 +265,8 @@ class ShlAssignExp;\n class ShrAssignExp;\n class UshrAssignExp;\n class CatAssignExp;\n+class CatElemAssignExp;\n+class CatDcharAssignExp;\n class AddExp;\n class MinExp;\n class CatExp;\n@@ -564,6 +566,10 @@ class ParseTimeVisitor\n     virtual void visit(UshrAssignExp *e) { visit((BinAssignExp *)e); }\n     virtual void visit(CatAssignExp *e) { visit((BinAssignExp *)e); }\n \n+    // CatAssignExp\n+    virtual void visit(CatElemAssignExp *e) { visit((CatAssignExp *)e); }\n+    virtual void visit(CatDcharAssignExp *e) { visit((CatAssignExp *)e); }\n+\n     // TemplateParameter\n     virtual void visit(TemplateAliasParameter *tp) { visit((TemplateParameter *)tp); }\n     virtual void visit(TemplateTypeParameter *tp) { visit((TemplateParameter *)tp); }"}, {"sha": "954eb9a22f12a74676ebb2d85afe718879365971", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -372,6 +372,10 @@ fpreview=fixaliasthis\n D RejectNegative\n When a symbol is resolved, check `alias this' scope before going to upper scopes.\n \n+fpreview=fiximmutableconv\n+D RejectNegative\n+Disallow unsound immutable conversions that were formerly incorrectly permitted.\n+\n fpreview=in\n D RejectNegative\n Implement 'in' parameters to mean scope const."}, {"sha": "1ad0369a75de70f10e6eeeccb6d0bcd043e44c24", "filename": "gcc/d/runtime.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Fd%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fruntime.def?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -145,10 +145,6 @@ DEF_D_RUNTIME (ARRAYAPPENDCD, \"_d_arrayappendcd\", RT(ARRAY_VOID),\n DEF_D_RUNTIME (ARRAYAPPENDWD, \"_d_arrayappendwd\", RT(ARRAY_VOID),\n \t       P2(ARRAYPTR_BYTE, DCHAR), 0)\n \n-/* Used for appending an existing array to another.  */\n-DEF_D_RUNTIME (ARRAYAPPENDT, \"_d_arrayappendT\", RT(ARRAY_VOID),\n-\t       P3(TYPEINFO, ARRAYPTR_BYTE, ARRAY_BYTE), 0)\n-\n /* Used for allocating a new associative array.  */\n DEF_D_RUNTIME (ASSOCARRAYLITERALTX, \"_d_assocarrayliteralTX\", RT(VOIDPTR),\n \t       P3(CONST_TYPEINFO, ARRAY_VOID, ARRAY_VOID), 0)"}, {"sha": "169b7b1536404291b3851b23b5a60f8da1daece9", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_ClassDeclaration.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -142,8 +142,8 @@ class B : public A, public I1, public I2\n {\n public:\n     using A::bar;\n-    void foo();\n-    void bar();\n+    void foo() final override;\n+    void bar() override;\n };\n \n class Parent\n@@ -157,7 +157,7 @@ public:\n class Child final : public Parent\n {\n public:\n-    void foo() /* const */;\n+    void foo() override;\n };\n \n class VisitorBase\n@@ -289,7 +289,7 @@ interface I2 : I1\n class B : A, I1, I2\n {\n     alias bar = A.bar;\n-    override void foo() {}\n+    override final void foo() {}\n     override void bar() {}\n }\n \n@@ -303,7 +303,7 @@ class Parent\n final class Child : Parent\n {\n     extern(D) override void over() {}\n-    override void foo() const {}\n+    override void foo() {}\n }\n \n class VisitorBase"}, {"sha": "1e2be909e75a284d8a34b7edbfd1e12411494839", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_TemplateDeclaration.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_TemplateDeclaration.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -160,7 +160,7 @@ class Child final : public Parent<T >\n {\n public:\n     T childMember;\n-    void parentVirtual();\n+    void parentVirtual() override;\n     T childFinal();\n };\n "}, {"sha": "0f4026279e06d501317c170cb285ff5545e6db32", "filename": "gcc/testsuite/gdc.test/compilable/test22865.d", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22865.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22865.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22865.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,35 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22865\n+\n+// Test that safety errors inside speculative scopes don't affect attribute inference\n+\n+void main() @safe\n+{\n+    foo();\n+}\n+\n+__gshared int g;\n+\n+auto foo()\n+{\n+    alias x0 = typeof(g++);\n+    alias x1 = typeof(cast(int*) 0);\n+\n+    auto x2 = __traits(compiles, g++);\n+    enum x3 = __traits(compiles, (cast(int*) 0));\n+\n+    debug\n+    {\n+        g++;\n+        const x4 = cast(int*) 0;\n+        asm { }\n+    }\n+}\n+\n+// Test that safety violations still occur if the function is inside the __traits(compiles)\n+\n+static assert(!__traits(compiles, {\n+    void f() @safe\n+    {\n+        g++;\n+    }\n+}));"}, {"sha": "bf51363c07eff07e8d958adb2fb8ae1fad456804", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip1000_deprecation.d", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip1000_deprecation.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip1000_deprecation.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip1000_deprecation.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,59 @@\n+/*\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/dip1000_deprecation.d(20): Deprecation: `@safe` function `main` calling `inferred`\n+fail_compilation/dip1000_deprecation.d(28):        which would be `@system` because of:\n+fail_compilation/dip1000_deprecation.d(28):        scope variable `x0` may not be returned\n+fail_compilation/dip1000_deprecation.d(22): Deprecation: `@safe` function `main` calling `inferredC`\n+fail_compilation/dip1000_deprecation.d(39):        which calls `dip1000_deprecation.inferred`\n+fail_compilation/dip1000_deprecation.d(28):        which would be `@system` because of:\n+fail_compilation/dip1000_deprecation.d(28):        scope variable `x0` may not be returned\n+fail_compilation/dip1000_deprecation.d(54): Deprecation: escaping reference to stack allocated value returned by `S(null)`\n+fail_compilation/dip1000_deprecation.d(55): Deprecation: escaping reference to stack allocated value returned by `createS()`\n+fail_compilation/dip1000_deprecation.d(58): Deprecation: returning `s.incorrectReturnRef()` escapes a reference to local variable `s`\n+---\n+*/\n+\n+void main() @safe\n+{\n+    inferred();\n+    inferredB(); // no deprecation, trusted\n+    inferredC(); // nested deprecation\n+}\n+\n+auto inferred()\n+{\n+    scope int* x0;\n+    return x0;\n+}\n+\n+auto inferredB() @trusted\n+{\n+    scope int* x1;\n+    return x1;\n+}\n+\n+auto inferredC()\n+{\n+    return inferred(); // no deprecation, inferredC is not explicit `@safe`\n+}\n+\n+@safe:\n+\n+struct S\n+{\n+    int* ptr;\n+    int* incorrectReturnRef() scope return @trusted {return ptr;}\n+}\n+\n+S createS() { return S.init; }\n+\n+int* escape()\n+{\n+    return S().incorrectReturnRef();\n+    return createS().incorrectReturnRef();\n+\n+    S s;\n+    return s.incorrectReturnRef();\n+}"}, {"sha": "02f314077545b5c8958b99cc53756886b2a00c39", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip25.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -19,7 +19,7 @@ struct Data\n }\n \n ref int identity(return ref int x) @safe { return x; }\n-ref int fun(return int x) { return identity(x); }\n+ref int fun(return int x) @safe { return identity(x); }\n ref int fun2(ref int x) @safe { return identity(x); }\n \n void main()"}, {"sha": "5c852a1ac917716e33f13a5d43e48f48734b2df7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail12390.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12390.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12390.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12390.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail12390.d(14): Error: `fun().i == 4` has no effect\n+fail_compilation/fail12390.d(15): Error: the result of the equality expression `fun().i == 4` is discarded\n+fail_compilation/fail12390.d(15):        note that `fun().i` may have a side effect\n ---\n */\n "}, {"sha": "405ab557d758e2592a7f453a40f80cf1a0672282", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22351.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22351.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22351.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22351.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,20 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=22351\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22351.d(18): Deprecation: overriding `extern(C++)` function `fail22351.C22351.func(int*)` with `const` qualified function `fail22351.Fail22351.func(const(int*))` is deprecated\n+fail_compilation/fail22351.d(18):        Either remove `override`, or adjust the `const` qualifiers of the overriding function parameters\n+fail_compilation/fail22351.d(19): Error: function `extern (C++) void fail22351.Fail22351.func(const(int*)**)` does not override any function, did you mean to override `extern (C++) void fail22351.C22351.func(int*)`?\n+---\n+*/\n+extern(C++) class C22351\n+{\n+    void func(int*) { }\n+    void func(int***) { }\n+}\n+\n+extern(C++) final class Fail22351 : C22351\n+{\n+    override void func(const int*) { }\n+    override void func(const(int*)**) { }\n+}"}, {"sha": "d32c6aeef51ba07f58c99ba5a2addb2b3e2f0884", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23135.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23135.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23135.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23135.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,17 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=23135\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail23135.d(16): Deprecation: overriding `extern(C++)` function `fail23135.C23135.func()` with `const` qualified function `fail23135.Fail23135.func() const` is deprecated\n+fail_compilation/fail23135.d(16):        Either remove `override`, or adjust the `const` qualifiers of the overriding function type\n+---\n+*/\n+extern(C++) class C23135\n+{\n+    void func() { }\n+}\n+\n+extern(C++) final class Fail23135 : C23135\n+{\n+    override void func() const { }\n+}"}, {"sha": "3e7637ff6679cccc60f136cd3d813f360fdc5a78", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_scope.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_scope.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -13,7 +13,7 @@ fail_compilation/fail_scope.d(82): Error: returning `& string` escapes a referen\n fail_compilation/fail_scope.d(92): Error: returning `cast(int[])a` escapes a reference to local variable `a`\n fail_compilation/fail_scope.d(100): Error: returning `cast(int[])a` escapes a reference to local variable `a`\n fail_compilation/fail_scope.d(108): Deprecation: escaping reference to outer local variable `x`\n-fail_compilation/fail_scope.d(127): Error: returning `s.bar()` escapes a reference to local variable `s`\n+fail_compilation/fail_scope.d(127): Deprecation: returning `s.bar()` escapes a reference to local variable `s`\n fail_compilation/fail_scope.d(137): Error: returning `foo16226(i)` escapes a reference to local variable `i`\n ---\n //fail_compilation/fail_scope.d(30): Error: scope variable `da` may not be returned"}, {"sha": "149bebae0ea629452f956bba6a64597233df7f92", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix22108.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix22108.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix22108.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix22108.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,13 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/fix22108.d(12): Error: scope variable `p` may not be returned\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22108\n+\n+@safe ref int test(ref scope return int* p)\n+{\n+    return *p;\n+}"}, {"sha": "58766c86b7b1402b65e99661bc458a8db24338eb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix23138.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix23138.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix23138.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix23138.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,16 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fix23138.d(14): Error: function `fix23138.C2.foo` cannot override `@safe` method `fix23138.C1.foo` with a `@system` attribute\n+---\n+ */\n+\n+class C1 {\n+    void foo() @safe\n+    {}\n+}\n+\n+class C2 : C1\n+{\n+    override void foo() @system\n+    {}\n+}"}, {"sha": "ae573b2af2a77e87185d7e617876412c74ac5aa3", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15660.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15660.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15660.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15660.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1,4 +1,4 @@\n-/* REQUIRED_ARGS: -preview=dip1000\n+/* REQUIRED_ARGS: -preview=fixImmutableConv\n TEST_OUTPUT:\n ---\n fail_compilation/test15660.d(20): Error: cannot implicitly convert expression `f(v)` of type `int[]` to `immutable(int[])`"}, {"sha": "e51647b3491448fd2d58501c7474ab80edc8ca33", "filename": "gcc/testsuite/gdc.test/fail_compilation/test18484.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18484.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18484.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18484.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -19,7 +19,7 @@ int* test1() @safe\n     auto x = S(); return x.bar();  // error\n }\n \n-int* test2()\n+int* test2() @safe\n {\n     return S().bar();  // error\n }"}, {"sha": "d4c5f07bea5e9eec322ab1e2f85b6c7b83964ebf", "filename": "gcc/testsuite/gdc.test/fail_compilation/test20881.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest20881.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -2,6 +2,7 @@\n REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n+fail_compilation/test20881.d(20): Error: scope variable `this` may not be returned\n fail_compilation/test20881.d(27): Error: address of variable `s` assigned to `global` with longer lifetime\n fail_compilation/test20881.d(28): Error: address of variable `s` assigned to `global` with longer lifetime\n fail_compilation/test20881.d(29): Error: address of variable `s` assigned to `global` with longer lifetime\n@@ -10,7 +11,6 @@ fail_compilation/test20881.d(29): Error: address of variable `s` assigned to `gl\n @safe:\n \n // https://issues.dlang.org/show_bug.cgi?id=20881\n-\n struct S\n {\n     int* ptr;"}, {"sha": "ad70d0a01d4d2e9bd86bde906e590331eb51e982", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/test22351.cpp", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22351.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22351.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest22351.cpp?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,46 @@\n+#include <assert.h>\n+\n+class A22351\n+{\n+public:\n+    virtual int f();\n+    virtual int g(int *);\n+    virtual int h();\n+    virtual int h() const;\n+};\n+\n+class B22351 : public A22351\n+{\n+public:\n+    virtual int f() const;\n+    virtual int g(const int *);\n+    int h() const override;\n+};\n+\n+B22351 *createB();\n+\n+int main()\n+{\n+    // mutable A calls functions in A vtable\n+    A22351 *a = createB();\n+    assert(a->f() == 1);\n+    assert(a->g(0) == 3);\n+    assert(a->h() == 5);\n+\n+    // cast to B calls functions in B vtable\n+    B22351 *b = (B22351 *)a;\n+    assert(b->f() == 2);\n+    assert(b->g(0) == 4);\n+    assert(b->h() == 6);\n+\n+    // cast to const calls B override function\n+    const A22351 *ca = a;\n+    assert(ca->h() == 6);\n+\n+    // const B calls functions in B vtable\n+    const B22351 *cb = createB();\n+    assert(cb->f() == 2);\n+    assert(cb->h() == 6);\n+\n+    return 0;\n+}"}, {"sha": "d4193c95669c128cce1ac1f28b9a70ae0d4fe35d", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/test23135.cpp", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest23135.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest23135.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Ftest23135.cpp?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,52 @@\n+class Mutable\n+{\n+public:\n+    virtual ~Mutable();\n+    virtual void func();\n+};\n+\n+Mutable::~Mutable()\n+{\n+}\n+\n+class DeriveMutable final : public Mutable\n+{\n+public:\n+    virtual ~DeriveMutable();\n+    void func() override;\n+};\n+\n+DeriveMutable::~DeriveMutable()\n+{\n+}\n+\n+class Const\n+{\n+public:\n+    virtual ~Const();\n+    virtual void func() const;\n+};\n+\n+Const::~Const()\n+{\n+}\n+\n+class DeriveConst final : public Const\n+{\n+public:\n+    virtual ~DeriveConst();\n+    void func() const override;\n+};\n+\n+DeriveConst::~DeriveConst()\n+{\n+}\n+\n+void test23135()\n+{\n+    DeriveMutable mut;\n+    mut.func();\n+\n+    DeriveConst cst;\n+    cst.func();\n+}"}, {"sha": "1c930b6ea82695e74bb713f71a70f8cd6b7243e5", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test22351.d", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22351.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22351.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest22351.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,55 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22351\n+// EXTRA_CPP_SOURCES: test22351.cpp\n+// REQUIRED_ARGS: -extern-std=c++11\n+// CXXFLAGS: -std=c++11\n+// DISABLED: win32\n+\n+extern(C++) class A22351\n+{\n+    int f()\n+    {\n+        return 1;\n+    }\n+\n+    int g(int*)\n+    {\n+        return 3;\n+    }\n+\n+    int h()\n+    {\n+        return 5;\n+    }\n+\n+    int h() const\n+    {\n+        return 7;\n+    }\n+}\n+\n+extern(C++) class B22351 : A22351\n+{\n+    alias f = A22351.f;\n+    alias g = A22351.g;\n+    alias h = A22351.h;\n+\n+    int f() const\n+    {\n+        return 2;\n+    }\n+\n+    int g(const(int)*)\n+    {\n+        return 4;\n+    }\n+\n+    override int h() const\n+    {\n+        return 6;\n+    }\n+}\n+\n+extern(C++) B22351 createB()\n+{\n+    return new B22351;\n+}"}, {"sha": "4a184bb79240fa661fa0d1269d8de77391ceb032", "filename": "gcc/testsuite/gdc.test/runnable_cxx/test23135.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest23135.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest23135.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Ftest23135.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -0,0 +1,38 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23135\n+// EXTRA_CPP_SOURCES: test23135.cpp\n+// REQUIRED_ARGS: -extern-std=c++11\n+// CXXFLAGS: -std=c++11\n+// DISABLED: win32\n+\n+void main()\n+{\n+    test23135();\n+}\n+\n+extern(C++):\n+\n+void test23135();\n+\n+class Mutable\n+{\n+    ~this();\n+    void func() { }\n+}\n+\n+final class DeriveMutable : Mutable\n+{\n+    ~this();\n+    override void func() { }\n+}\n+\n+class Const\n+{\n+    ~this();\n+    void func() const { }\n+}\n+\n+final class DeriveConst : Const\n+{\n+    ~this();\n+    override void func() const { }\n+}"}, {"sha": "d503bae835cb6b28203c535344e4e6f1cd2b8433", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1,4 +1,4 @@\n-94bd5bcb448405d90bc50113d1cfd45a0880a50d\n+f89da31331ef5df50d3bc7a26efd1b7acdefde8c\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "d416efe1c5044d0a2a8cb8e49871fcf96a37947e", "filename": "libphobos/libdruntime/core/internal/array/appending.d", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -85,20 +85,35 @@ ref Tarr _d_arrayappendT(Tarr : T[], T)(return ref scope Tarr x, scope Tarr y) @\n     import core.internal.traits : hasElaborateCopyConstructor, Unqual;\n     import core.lifetime : copyEmplace;\n \n+    enum hasPostblit = __traits(hasPostblit, T);\n     auto length = x.length;\n \n     _d_arrayappendcTXImpl!Tarr._d_arrayappendcTX(x, y.length);\n \n-    static if (hasElaborateCopyConstructor!T)\n+    // Only call `copyEmplace` if `T` has a copy ctor and no postblit.\n+    static if (hasElaborateCopyConstructor!T && !hasPostblit)\n     {\n         foreach (i, ref elem; y)\n             copyEmplace(elem, x[length + i]);\n     }\n     else\n     {\n-        // blit all elements at once\n         if (y.length)\n-            memcpy(cast(Unqual!T *)&x[length], cast(Unqual!T *)&y[0], y.length * T.sizeof);\n+        {\n+            // blit all elements at once\n+            auto xptr = cast(Unqual!T *)&x[length];\n+            immutable size = T.sizeof;\n+\n+            memcpy(xptr, cast(Unqual!T *)&y[0], y.length * size);\n+\n+            // call postblits if they exist\n+            static if (hasPostblit)\n+            {\n+                auto eptr = xptr + y.length;\n+                for (auto ptr = xptr; ptr < eptr; ptr++)\n+                    ptr.__xpostblit();\n+            }\n+        }\n     }\n \n     return x;"}, {"sha": "7d1356af0be1a6dc6d73b06704d62de1507fdd8a", "filename": "libphobos/libdruntime/core/memory.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmemory.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -38,7 +38,7 @@\n  *\n  * Notes_to_implementors:\n  * $(UL\n- * $(LI On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved\n+ * $(LI On POSIX systems, the signals `SIGRTMIN` and `SIGRTMIN + 1` are reserved\n  *   by this module for use in the garbage collector implementation.\n  *   Typically, they will be used to stop and resume other threads\n  *   when performing a collection, but an implementation may choose"}, {"sha": "efbad7d6b74741563706332612af164d1edbd160", "filename": "libphobos/libdruntime/core/thread/fiber.d", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Ffiber.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -653,14 +653,9 @@ class Fiber\n      */\n     this( void delegate() dg, size_t sz = PAGESIZE * defaultStackPages,\n           size_t guardPageSize = PAGESIZE ) nothrow\n-    in\n-    {\n-        assert( dg );\n-    }\n-    do\n     {\n         allocStack( sz, guardPageSize );\n-        reset( dg );\n+        reset( cast(void delegate() const) dg );\n     }\n \n "}, {"sha": "ef073a933241212e2186b288543cfc66a60b5261", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1251,7 +1251,7 @@ version (CoreDdoc)\n {\n     /**\n      * Instruct the thread module, when initialized, to use a different set of\n-     * signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads.\n+     * signals besides SIGRTMIN and SIGRTMIN + 1 for suspension and resumption of threads.\n      * This function should be called at most once, prior to thread_init().\n      * This function is Posix-only.\n      */\n@@ -1281,8 +1281,8 @@ else version (Posix)\n \n version (Posix)\n {\n-    private __gshared int suspendSignalNumber = SIGUSR1;\n-    private __gshared int resumeSignalNumber  = SIGUSR2;\n+    private __gshared int suspendSignalNumber;\n+    private __gshared int resumeSignalNumber;\n }\n \n private extern (D) ThreadBase attachThread(ThreadBase _thisThread) @nogc nothrow\n@@ -2115,11 +2115,6 @@ extern (C) void thread_init() @nogc\n     initLowlevelThreads();\n     Thread.initLocks();\n \n-    // The Android VM runtime intercepts SIGUSR1 and apparently doesn't allow\n-    // its signal handler to run, so swap the two signals on Android, since\n-    // thread_resumeHandler does nothing.\n-    version (Android) thread_setGCSignals(SIGUSR2, SIGUSR1);\n-\n     version (Darwin)\n     {\n         // thread id different in forked child process\n@@ -2135,6 +2130,16 @@ extern (C) void thread_init() @nogc\n     }\n     else version (Posix)\n     {\n+        if ( suspendSignalNumber == 0 )\n+        {\n+            suspendSignalNumber = SIGRTMIN;\n+        }\n+\n+        if ( resumeSignalNumber == 0 )\n+        {\n+            resumeSignalNumber = SIGRTMIN + 1;\n+            assert(resumeSignalNumber <= SIGRTMAX);\n+        }\n         int         status;\n         sigaction_t suspend = void;\n         sigaction_t resume = void;"}, {"sha": "505be000c5653277544ec075ae853ea5a2ed8ce7", "filename": "libphobos/libdruntime/core/thread/threadbase.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fthreadbase.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -108,8 +108,8 @@ class ThreadBase\n         m_call = fn;\n     }\n \n-    this(void delegate() dg, size_t sz = 0) @safe pure nothrow @nogc\n-    in(dg)\n+    this(void delegate() dg, size_t sz = 0) @trusted pure nothrow @nogc\n+    in( cast(void delegate() const) dg)\n     {\n         this(sz);\n         m_call = dg;"}, {"sha": "fe65c0973e1977df9f504d2e76c3594e119935ec", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1481,7 +1481,7 @@ class TypeInfo_Delegate : TypeInfo\n \n     override size_t getHash(scope const void* p) @trusted const\n     {\n-        return hashOf(*cast(void delegate()*)p);\n+        return hashOf(*cast(const void delegate() *)p);\n     }\n \n     override bool equals(in void* p1, in void* p2) const\n@@ -4428,7 +4428,7 @@ nothrow @safe @nogc unittest\n     }\n }\n \n-private extern (C) void rt_finalize(void *data, bool det=true) nothrow;\n+private extern (C) void rt_finalize2(void* p, bool det = true, bool resetMemory = true) nothrow;\n \n /// ditto\n void destroy(bool initialize = true, T)(T obj) if (is(T == class))\n@@ -4448,7 +4448,7 @@ void destroy(bool initialize = true, T)(T obj) if (is(T == class))\n     {\n         // Bypass overloaded opCast\n         auto ptr = (() @trusted => *cast(void**) &obj)();\n-        rt_finalize(ptr);\n+        rt_finalize2(ptr, true, initialize);\n     }\n }\n \n@@ -4723,6 +4723,25 @@ nothrow unittest\n     destroy(B.init);\n }\n \n+// make sure destroy!false skips re-initialization\n+unittest\n+{\n+    static struct S { int x; }\n+    static class C { int x; }\n+    static extern(C++) class Cpp { int x; }\n+\n+    static void test(T)(T inst)\n+    {\n+        inst.x = 123;\n+        destroy!false(inst);\n+        assert(inst.x == 123, T.stringof);\n+    }\n+\n+    test(S());\n+    test(new C());\n+    test(new Cpp());\n+}\n+\n /// ditto\n void destroy(bool initialize = true, T)(ref T obj)\n if (__traits(isStaticArray, T))"}, {"sha": "9a34ec750f1bc9bf98c57d11bad9e7d01de599e4", "filename": "libphobos/libdruntime/rt/arrayassign.d", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Frt%2Farrayassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Farrayassign.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -162,45 +162,6 @@ extern (C) void[] _d_arrayassign_r(TypeInfo ti, void[] src, void[] dst, void* pt\n     return dst;\n }\n \n-/**\n- * Does array initialization (not assignment) from another\n- * array of the same element type.\n- * ti is the element type.\n- */\n-extern (C) void[] _d_arrayctor(TypeInfo ti, void[] from, void[] to)\n-{\n-    debug(PRINTF) printf(\"_d_arrayctor(from = %p,%d, to = %p,%d) size = %d\\n\", from.ptr, from.length, to.ptr, to.length, ti.tsize);\n-\n-\n-    auto element_size = ti.tsize;\n-\n-    enforceRawArraysConformable(\"initialization\", element_size, from, to);\n-\n-    size_t i;\n-    try\n-    {\n-        for (i = 0; i < to.length; i++)\n-        {\n-            // Copy construction is defined as bit copy followed by postblit.\n-            memcpy(to.ptr + i * element_size, from.ptr + i * element_size, element_size);\n-            ti.postblit(to.ptr + i * element_size);\n-        }\n-    }\n-    catch (Throwable o)\n-    {\n-        /* Destroy, in reverse order, what we've constructed so far\n-         */\n-        while (i--)\n-        {\n-            ti.destroy(to.ptr + i * element_size);\n-        }\n-\n-        throw o;\n-    }\n-    return to;\n-}\n-\n-\n /**\n  * Do assignment to an array.\n  *      p[0 .. count] = value;\n@@ -227,36 +188,3 @@ extern (C) void* _d_arraysetassign(void* p, void* value, int count, TypeInfo ti)\n         free(ptmp);\n     return pstart;\n }\n-\n-/**\n- * Do construction of an array.\n- *      ti[count] p = value;\n- */\n-extern (C) void* _d_arraysetctor(void* p, void* value, int count, TypeInfo ti)\n-{\n-    void* pstart = p;\n-    auto element_size = ti.tsize;\n-\n-    try\n-    {\n-        foreach (i; 0 .. count)\n-        {\n-            // Copy construction is defined as bit copy followed by postblit.\n-            memcpy(p, value, element_size);\n-            ti.postblit(p);\n-            p += element_size;\n-        }\n-    }\n-    catch (Throwable o)\n-    {\n-        // Destroy, in reverse order, what we've constructed so far\n-        while (p > pstart)\n-        {\n-            p -= element_size;\n-            ti.destroy(p);\n-        }\n-\n-        throw o;\n-    }\n-    return pstart;\n-}"}, {"sha": "5a18968f6eeb3e440262f9a74550097b75ea140f", "filename": "libphobos/libdruntime/rt/lifetime.d", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Flibdruntime%2Frt%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Flifetime.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -163,23 +163,6 @@ extern (C) void _d_delclass(Object* p) @weak\n     }\n }\n \n-/**\n- * This is called for a delete statement where the value\n- * being deleted is a pointer to a struct with a destructor\n- * but doesn't have an overloaded delete operator.\n- */\n-extern (C) void _d_delstruct(void** p, TypeInfo_Struct inf) @weak\n-{\n-    if (*p)\n-    {\n-        debug(PRINTF) printf(\"_d_delstruct(%p, %p)\\n\", *p, cast(void*)inf);\n-\n-        inf.destroy(*p);\n-        GC.free(*p);\n-        *p = null;\n-    }\n-}\n-\n // strip const/immutable/shared/inout from type info\n inout(TypeInfo) unqualify(return scope inout(TypeInfo) cti) pure nothrow @nogc\n {\n@@ -1872,23 +1855,6 @@ do\n     return *p;\n }\n \n-/**\n- * Append y[] to array x[]\n- */\n-extern (C) void[] _d_arrayappendT(const TypeInfo ti, ref byte[] x, byte[] y) @weak\n-{\n-    import core.stdc.string;\n-    auto length = x.length;\n-    auto tinext = unqualify(ti.next);\n-    auto sizeelem = tinext.tsize;              // array element size\n-    _d_arrayappendcTX(ti, x, y.length);\n-    memcpy(x.ptr + length * sizeelem, y.ptr, y.length * sizeelem);\n-\n-    // do postblit\n-    __doPostblit(x.ptr + length * sizeelem, y.length * sizeelem, tinext);\n-    return x;\n-}\n-\n \n /**\n  *\n@@ -2606,11 +2572,6 @@ deprecated unittest\n         }\n     }\n \n-    dtorCount = 0;\n-    S1* s1 = new S1;\n-    _d_delstruct(cast(void**)&s1, typeid(typeof(*s1))); // delete s1;\n-    assert(dtorCount == 1);\n-\n     dtorCount = 0;\n     S1[] arr1 = new S1[7];\n     _d_delarray_t(cast(void[]*)&arr1, typeid(typeof(arr1[0]))); // delete arr1;"}, {"sha": "ddf730ef333188be5535053eda98d70a5f202d87", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -1,4 +1,4 @@\n-3a1cd9a01479155958c7799e573e55a93dd189a0\n+d46814c86392007ebb4fb73cb684ef9e8caa605a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "bfb135b18858512ae8afdd0d2b1f0d6b9dd370c2", "filename": "libphobos/src/std/package.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fpackage.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -35,6 +35,7 @@ public import\n  std.base64,\n  std.bigint,\n  std.bitmanip,\n+ std.checkedint,\n  std.compiler,\n  std.complex,\n  std.concurrency,\n@@ -50,6 +51,7 @@ public import\n  std.format,\n  std.functional,\n  std.getopt,\n+ std.int128,\n  std.json,\n  std.math,\n  std.mathspecial,"}, {"sha": "d4fe8a1c7e8a21e57f01a87619fba9e4eed8eb63", "filename": "libphobos/src/std/process.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Fprocess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Fprocess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fprocess.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -613,7 +613,7 @@ private:\n  * writefln(\"Current process ID: %d\", thisProcessID);\n  * ---\n  */\n-@property int thisProcessID() @trusted nothrow //TODO: @safe\n+@property int thisProcessID() @trusted nothrow @nogc //TODO: @safe\n {\n     version (Windows)    return GetCurrentProcessId();\n     else version (Posix) return core.sys.posix.unistd.getpid();\n@@ -632,7 +632,7 @@ private:\n  * writefln(\"Current thread ID: %s\", thisThreadID);\n  * ---\n  */\n-@property ThreadID thisThreadID() @trusted nothrow //TODO: @safe\n+@property ThreadID thisThreadID() @trusted nothrow @nogc //TODO: @safe\n {\n     version (Windows)\n         return GetCurrentThreadId();"}, {"sha": "d22dac8b15daa3bab27dab57c624c90bde37516d", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610d789832b57e9ab0158b330865e24b9b699040/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=610d789832b57e9ab0158b330865e24b9b699040", "patch": "@@ -4275,10 +4275,10 @@ private int impureVariable;\n  *                            UseReplacementDchar.no means throw `UTFException` for invalid UTF\n  *\n  * Throws:\n- *      `UTFException` if invalid UTF sequence and `useReplacementDchar` is set to `UseReplacementDchar.yes`\n+ *      `UTFException` if invalid UTF sequence and `useReplacementDchar` is set to `UseReplacementDchar.no`\n  *\n  * GC:\n- *      Does not use GC if `useReplacementDchar` is set to `UseReplacementDchar.no`\n+ *      Does not use GC if `useReplacementDchar` is set to `UseReplacementDchar.yes`\n  *\n  * Returns:\n  *      A bidirectional range if `R` is a bidirectional range and not auto-decodable,"}]}