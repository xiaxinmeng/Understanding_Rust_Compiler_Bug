{"sha": "f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwOGY4MjdiMTdlY2Q0NjczZWY5ZDFjOTdkY2E5ZDFlM2I2ZjE3Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-31T05:27:03Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-31T05:27:03Z"}, "message": "ira.h (target_ira): Delete x_ira_available_class_regs.\n\ngcc/\n\t* ira.h (target_ira): Delete x_ira_available_class_regs.\n\t(ira_available_class_regs): Delete.\n\t* ira.c (setup_available_class_regs): Delete.\n\t(setup_alloc_classes): Don't call it.\n\t(setup_pressure_classes): Use ira_class_hard_regs_num instead of\n\tira_available_class_regs.\n\t* haifa-sched.c (print_curr_reg_pressure, setup_insn_reg_pressure_info)\n\t(model_spill_cost): Likewise.\n\t* ira-build.c (low_pressure_loop_node_p): Likewise.\n\t* ira-color.c (color_pass): Likewise.\n\t* ira-emit.c (change_loop): Likewise.\n\t* ira-lives.c (inc_register_pressure, dec_register_pressure)\n\t(single_reg_class, ira_implicitly_set_insn_hard_regs)\n\t(process_bb_node_lives): Likewise.\n\t* loop-invariant.c (gain_for_invariant): Likewise.\n\nFrom-SVN: r188041", "tree": {"sha": "919171bcd0413b3bddae2b9e013c5505e01059d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/919171bcd0413b3bddae2b9e013c5505e01059d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2e14fbda6cba933cb4ceaaac8cc092d5f8beb01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e14fbda6cba933cb4ceaaac8cc092d5f8beb01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e14fbda6cba933cb4ceaaac8cc092d5f8beb01c"}], "stats": {"total": 86, "additions": 40, "deletions": 46}, "files": [{"sha": "e78206eebfa6c2b1db8824d042e896781dd82874", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -1,3 +1,21 @@\n+2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira.h (target_ira): Delete x_ira_available_class_regs.\n+\t(ira_available_class_regs): Delete.\n+\t* ira.c (setup_available_class_regs): Delete.\n+\t(setup_alloc_classes): Don't call it.\n+\t(setup_pressure_classes): Use ira_class_hard_regs_num instead of\n+\tira_available_class_regs.\n+\t* haifa-sched.c (print_curr_reg_pressure, setup_insn_reg_pressure_info)\n+\t(model_spill_cost): Likewise.\n+\t* ira-build.c (low_pressure_loop_node_p): Likewise.\n+\t* ira-color.c (color_pass): Likewise.\n+\t* ira-emit.c (change_loop): Likewise.\n+\t* ira-lives.c (inc_register_pressure, dec_register_pressure)\n+\t(single_reg_class, ira_implicitly_set_insn_hard_regs)\n+\t(process_bb_node_lives): Likewise.\n+\t* loop-invariant.c (gain_for_invariant): Likewise.\n+\n 2012-05-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/52999"}, {"sha": "8aac1e3d96a5970f103b7f77336279dcb8e20948", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -1085,7 +1085,7 @@ print_curr_reg_pressure (void)\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       fprintf (sched_dump, \"  %s:%d(%d)\", reg_class_names[cl],\n \t       curr_reg_pressure[cl],\n-\t       curr_reg_pressure[cl] - ira_available_class_regs[cl]);\n+\t       curr_reg_pressure[cl] - ira_class_hard_regs_num[cl]);\n     }\n   fprintf (sched_dump, \"\\n\");\n }\n@@ -1634,9 +1634,9 @@ setup_insn_reg_pressure_info (rtx insn)\n       cl = ira_pressure_classes[i];\n       gcc_assert (curr_reg_pressure[cl] >= 0);\n       change = (int) pressure_info[i].set_increase - death[cl];\n-      before = MAX (0, max_reg_pressure[i] - ira_available_class_regs[cl]);\n+      before = MAX (0, max_reg_pressure[i] - ira_class_hard_regs_num[cl]);\n       after = MAX (0, max_reg_pressure[i] + change\n-\t\t   - ira_available_class_regs[cl]);\n+\t\t   - ira_class_hard_regs_num[cl]);\n       hard_regno = ira_class_hard_regs[cl][0];\n       gcc_assert (hard_regno >= 0);\n       mode = reg_raw_mode[hard_regno];\n@@ -2227,7 +2227,7 @@ model_recompute (rtx insn)\n /* Return the cost of increasing the pressure in class CL from FROM to TO.\n \n    Here we use the very simplistic cost model that every register above\n-   ira_available_class_regs[CL] has a spill cost of 1.  We could use other\n+   ira_class_hard_regs_num[CL] has a spill cost of 1.  We could use other\n    measures instead, such as one based on MEMORY_MOVE_COST.  However:\n \n       (1) In order for an instruction to be scheduled, the higher cost\n@@ -2251,7 +2251,7 @@ model_recompute (rtx insn)\n static int\n model_spill_cost (int cl, int from, int to)\n {\n-  from = MAX (from, ira_available_class_regs[cl]);\n+  from = MAX (from, ira_class_hard_regs_num[cl]);\n   return MAX (to, from) - from;\n }\n "}, {"sha": "b3fe5d0652ff835f9765a5ba3f845b3ef7365b59", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -1829,8 +1829,8 @@ low_pressure_loop_node_p (ira_loop_tree_node_t node)\n   for (i = 0; i < ira_pressure_classes_num; i++)\n     {\n       pclass = ira_pressure_classes[i];\n-      if (node->reg_pressure[pclass] > ira_available_class_regs[pclass]\n-\t  && ira_available_class_regs[pclass] > 1)\n+      if (node->reg_pressure[pclass] > ira_class_hard_regs_num[pclass]\n+\t  && ira_class_hard_regs_num[pclass] > 1)\n \treturn false;\n     }\n   return true;"}, {"sha": "ea933be99901e54a99ba9fe91d776e67d0280b38", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -2766,7 +2766,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \tpclass = ira_pressure_class_translate[rclass];\n \tif (flag_ira_region == IRA_REGION_MIXED\n \t    && (loop_tree_node->reg_pressure[pclass]\n-\t\t<= ira_available_class_regs[pclass]))\n+\t\t<= ira_class_hard_regs_num[pclass]))\n \t  {\n \t    mode = ALLOCNO_MODE (a);\n \t    hard_regno = ALLOCNO_HARD_REGNO (a);\n@@ -2819,7 +2819,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t\t\t    ALLOCNO_NUM (subloop_allocno)));\n \t  if ((flag_ira_region == IRA_REGION_MIXED)\n \t      && (loop_tree_node->reg_pressure[pclass]\n-\t\t  <= ira_available_class_regs[pclass]))\n+\t\t  <= ira_class_hard_regs_num[pclass]))\n \t    {\n \t      if (! ALLOCNO_ASSIGNED_P (subloop_allocno))\n \t\t{"}, {"sha": "adde4dfb039e3ae55ff1b55acb302563561acbfb", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -606,7 +606,7 @@ change_loop (ira_loop_tree_node_t node)\n \t\t  == ALLOCNO_HARD_REGNO (parent_allocno))\n \t      && (ALLOCNO_HARD_REGNO (allocno) < 0\n \t\t  || (parent->reg_pressure[pclass] + 1\n-\t\t      <= ira_available_class_regs[pclass])\n+\t\t      <= ira_class_hard_regs_num[pclass])\n \t\t  || TEST_HARD_REG_BIT (ira_prohibited_mode_move_regs\n \t\t\t\t\t[ALLOCNO_MODE (allocno)],\n \t\t\t\t\tALLOCNO_HARD_REGNO (allocno))"}, {"sha": "5eb13c1425d6ad83a1b86d99ff7ba97a03ae8477", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -192,7 +192,7 @@ inc_register_pressure (enum reg_class pclass, int n)\n \tcontinue;\n       curr_reg_pressure[cl] += n;\n       if (high_pressure_start_point[cl] < 0\n-\t  && (curr_reg_pressure[cl] > ira_available_class_regs[cl]))\n+\t  && (curr_reg_pressure[cl] > ira_class_hard_regs_num[cl]))\n \thigh_pressure_start_point[cl] = curr_point;\n       if (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n \tcurr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n@@ -221,7 +221,7 @@ dec_register_pressure (enum reg_class pclass, int nregs)\n       curr_reg_pressure[cl] -= nregs;\n       ira_assert (curr_reg_pressure[cl] >= 0);\n       if (high_pressure_start_point[cl] >= 0\n-\t  && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t  && curr_reg_pressure[cl] <= ira_class_hard_regs_num[cl])\n \tset_p = true;\n     }\n   if (set_p)\n@@ -235,7 +235,7 @@ dec_register_pressure (enum reg_class pclass, int nregs)\n \t  if (! ira_reg_pressure_class_p[cl])\n \t    continue;\n \t  if (high_pressure_start_point[cl] >= 0\n-\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t      && curr_reg_pressure[cl] <= ira_class_hard_regs_num[cl])\n \t    high_pressure_start_point[cl] = -1;\n \t}\n     }\n@@ -851,7 +851,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t\t     ? GENERAL_REGS\n \t\t     : REG_CLASS_FROM_CONSTRAINT (c, constraints));\n \t  if ((cl != NO_REGS && next_cl != cl)\n-\t      || (ira_available_class_regs[next_cl]\n+\t      || (ira_class_hard_regs_num[next_cl]\n \t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n@@ -864,7 +864,7 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t\t\t\trecog_data.operand[c - '0'], NULL_RTX);\n \t  if ((cl != NO_REGS && next_cl != cl)\n \t      || next_cl == NO_REGS\n-\t      || (ira_available_class_regs[next_cl]\n+\t      || (ira_class_hard_regs_num[next_cl]\n \t\t  > ira_reg_class_max_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n@@ -943,8 +943,8 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t\t  if (cl != NO_REGS\n \t\t      /* There is no register pressure problem if all of the\n \t\t\t regs in this class are fixed.  */\n-\t\t      && ira_available_class_regs[cl] != 0\n-\t\t      && (ira_available_class_regs[cl]\n+\t\t      && ira_class_hard_regs_num[cl] != 0\n+\t\t      && (ira_class_hard_regs_num[cl]\n \t\t\t  <= ira_reg_class_max_nregs[cl][mode]))\n \t\t    IOR_HARD_REG_SET (*set, reg_class_contents[cl]);\n \t\t  break;\n@@ -1170,7 +1170,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\tif (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n \t\t  curr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n \t\tira_assert (curr_reg_pressure[cl]\n-\t\t\t    <= ira_available_class_regs[cl]);\n+\t\t\t    <= ira_class_hard_regs_num[cl]);\n \t      }\n \t  }\n       EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)"}, {"sha": "3732c8db281a303fa88961f58742d724b2f6fc0d", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -490,23 +490,6 @@ setup_class_hard_regs (void)\n     }\n }\n \n-/* Set up IRA_AVAILABLE_CLASS_REGS.  */\n-static void\n-setup_available_class_regs (void)\n-{\n-  int i, j;\n-\n-  memset (ira_available_class_regs, 0, sizeof (ira_available_class_regs));\n-  for (i = 0; i < N_REG_CLASSES; i++)\n-    {\n-      COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[i]);\n-      AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);\n-      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (temp_hard_regset, j))\n-\t  ira_available_class_regs[i]++;\n-    }\n-}\n-\n /* Set up global variables defining info about hard registers for the\n    allocation.  These depend on USE_HARD_FRAME_P whose TRUE value means\n    that we can use the hard frame pointer for the allocation.  */\n@@ -520,7 +503,6 @@ setup_alloc_regs (bool use_hard_frame_p)\n   if (! use_hard_frame_p)\n     SET_HARD_REG_BIT (no_unit_alloc_regs, HARD_FRAME_POINTER_REGNUM);\n   setup_class_hard_regs ();\n-  setup_available_class_regs ();\n }\n \n \f\n@@ -799,9 +781,9 @@ setup_pressure_classes (void)\n   n = 0;\n   for (cl = 0; cl < N_REG_CLASSES; cl++)\n     {\n-      if (ira_available_class_regs[cl] == 0)\n+      if (ira_class_hard_regs_num[cl] == 0)\n \tcontinue;\n-      if (ira_available_class_regs[cl] != 1\n+      if (ira_class_hard_regs_num[cl] != 1\n \t  /* A register class without subclasses may contain a few\n \t     hard registers and movement between them is costly\n \t     (e.g. SPARC FPCC registers).  We still should consider it\n@@ -1504,7 +1486,7 @@ ira_init_register_move_cost (enum machine_mode mode)\n     {\n       /* Some subclasses are to small to have enough registers to hold\n \t a value of MODE.  Just ignore them.  */\n-      if (ira_reg_class_max_nregs[cl1][mode] > ira_available_class_regs[cl1])\n+      if (ira_reg_class_max_nregs[cl1][mode] > ira_class_hard_regs_num[cl1])\n \tcontinue;\n       COPY_HARD_REG_SET (temp_hard_regset, reg_class_contents[cl1]);\n       AND_COMPL_HARD_REG_SET (temp_hard_regset, no_unit_alloc_regs);"}, {"sha": "d53db4e0cee8511b3b1cee489dbf41ed7d98fa48", "filename": "gcc/ira.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -25,10 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n extern bool ira_conflicts_p;\n \n struct target_ira {\n-  /* Number of given class hard registers available for the register\n-     allocation for given classes.  */\n-  int x_ira_available_class_regs[N_REG_CLASSES];\n-\n   /* Map: hard register number -> allocno class it belongs to.  If the\n      corresponding class is NO_REGS, the hard register is not available\n      for allocation.  */\n@@ -95,8 +91,6 @@ extern struct target_ira *this_target_ira;\n #define this_target_ira (&default_target_ira)\n #endif\n \n-#define ira_available_class_regs \\\n-  (this_target_ira->x_ira_available_class_regs)\n #define ira_hard_regno_allocno_class \\\n   (this_target_ira->x_ira_hard_regno_allocno_class)\n #define ira_allocno_classes_num \\"}, {"sha": "34295a01586f24aa5869e57d6271a2810fb34075", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=f508f827b17ecd4673ef9d1c97dca9d1e3b6f17f", "patch": "@@ -1210,7 +1210,7 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \t      + (int) regs_needed[pressure_class]\n \t      + LOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]\n \t      + IRA_LOOP_RESERVED_REGS\n-\t      > ira_available_class_regs[pressure_class])\n+\t      > ira_class_hard_regs_num[pressure_class])\n \t    break;\n \t}\n       if (i < ira_pressure_classes_num)"}]}