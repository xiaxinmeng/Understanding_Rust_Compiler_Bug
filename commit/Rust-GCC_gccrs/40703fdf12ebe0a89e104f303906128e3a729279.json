{"sha": "40703fdf12ebe0a89e104f303906128e3a729279", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA3MDNmZGYxMmViZTBhODllMTA0ZjMwMzkwNjEyOGUzYTcyOTI3OQ==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-03-13T21:25:09Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-03-13T21:25:09Z"}, "message": "Use next_conversion for better safety\n\ngcc/cp/\n\n\t* call.c (standard_conversion, build_integral_nontype_arg_conv)\n\t(build_new_op_1, convert_like_real, is_subseq)\n\t(maybe_handle_implicit_object, maybe_handle_ref_bind, compare_ics)\n\t(joust): Use next_conversion instead of accessing fields of struct\n\tconversion directly.\n\nFrom-SVN: r185356", "tree": {"sha": "4a7f5344035bfa9fbe47d51845375bfea08ec94e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a7f5344035bfa9fbe47d51845375bfea08ec94e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40703fdf12ebe0a89e104f303906128e3a729279", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40703fdf12ebe0a89e104f303906128e3a729279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40703fdf12ebe0a89e104f303906128e3a729279", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40703fdf12ebe0a89e104f303906128e3a729279/comments", "author": null, "committer": null, "parents": [{"sha": "9243c51d5fa12be42dede398b3c7a812fc95519c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9243c51d5fa12be42dede398b3c7a812fc95519c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9243c51d5fa12be42dede398b3c7a812fc95519c"}], "stats": {"total": 58, "additions": 33, "deletions": 25}, "files": [{"sha": "f04ac604ae6405d46dc926be53eebb0667e75773", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40703fdf12ebe0a89e104f303906128e3a729279/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40703fdf12ebe0a89e104f303906128e3a729279/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40703fdf12ebe0a89e104f303906128e3a729279", "patch": "@@ -1,3 +1,11 @@\n+2011-12-15  Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* call.c (standard_conversion, build_integral_nontype_arg_conv)\n+    \t(build_new_op_1, convert_like_real, is_subseq)\n+    \t(maybe_handle_implicit_object, maybe_handle_ref_bind, compare_ics)\n+    \t(joust): Use next_conversion instead of accessing fields of struct\n+    \tconversion directly.\n+\n 2012-03-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52299"}, {"sha": "88733f50227a9fd9cc05f48696eea6fa681d3ece", "filename": "gcc/cp/call.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40703fdf12ebe0a89e104f303906128e3a729279/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40703fdf12ebe0a89e104f303906128e3a729279/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=40703fdf12ebe0a89e104f303906128e3a729279", "patch": "@@ -1325,7 +1325,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \n       /* Give this a better rank if it's a promotion.  */\n       if (same_type_p (to, type_promotes_to (from))\n-\t  && conv->u.next->rank <= cr_promotion)\n+\t  && next_conversion (conv)->rank <= cr_promotion)\n \tconv->rank = cr_promotion;\n     }\n   else if (fcode == VECTOR_TYPE && tcode == VECTOR_TYPE\n@@ -1335,7 +1335,7 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t   && is_properly_derived_from (from, to))\n     {\n       if (conv->kind == ck_rvalue)\n-\tconv = conv->u.next;\n+\tconv = next_conversion (conv);\n       conv = build_conv (ck_base, to, conv);\n       /* The derived-to-base conversion indicates the initialization\n \t of a parameter with base type from an object of a derived\n@@ -3697,7 +3697,7 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n \tbreak;\n \n       case ck_std:\n-\tt = conv->u.next->type;\n+\tt = next_conversion (conv)->type;\n \tif (INTEGRAL_OR_ENUMERATION_TYPE_P (t))\n \t  break;\n \n@@ -5145,7 +5145,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t     objects directly.  */\n \t  conv = cand->convs[0];\n \t  if (conv->kind == ck_ref_bind)\n-\t    conv = conv->u.next;\n+\t    conv = next_conversion (conv);\n \t  arg1 = convert_like (conv, arg1, complain);\n \n \t  if (arg2)\n@@ -5159,14 +5159,14 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \n \t      conv = cand->convs[1];\n \t      if (conv->kind == ck_ref_bind)\n-\t\tconv = conv->u.next;\n+\t\tconv = next_conversion (conv);\n \t      arg2 = convert_like (conv, arg2, complain);\n \t    }\n \t  if (arg3)\n \t    {\n \t      conv = cand->convs[2];\n \t      if (conv->kind == ck_ref_bind)\n-\t\tconv = conv->u.next;\n+\t\tconv = next_conversion (conv);\n \t      arg3 = convert_like (conv, arg3, complain);\n \t    }\n \n@@ -5806,7 +5806,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       break;\n     };\n \n-  expr = convert_like_real (convs->u.next, expr, fn, argnum,\n+  expr = convert_like_real (next_conversion (convs), expr, fn, argnum,\n \t\t\t    convs->kind == ck_ref_bind ? -1 : 1,\n \t\t\t    convs->kind == ck_ref_bind ? issue_conversion_warnings : false, \n \t\t\t    c_cast_p,\n@@ -5859,7 +5859,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       {\n \ttree ref_type = totype;\n \n-\tif (convs->bad_p && !convs->u.next->bad_p)\n+\tif (convs->bad_p && !next_conversion (convs)->bad_p)\n \t  {\n \t    gcc_assert (TYPE_REF_IS_RVALUE (ref_type)\n \t\t\t&& real_lvalue_p (expr));\n@@ -5889,7 +5889,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    cp_lvalue_kind lvalue = real_lvalue_p (expr);\n \n \t    gcc_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t(type, convs->u.next->type));\n+\t\t\t(type, next_conversion (convs)->type));\n \t    if (!CP_TYPE_CONST_NON_VOLATILE_P (type)\n \t\t&& !TYPE_REF_IS_RVALUE (ref_type))\n \t      {\n@@ -7424,13 +7424,13 @@ is_subseq (conversion *ics1, conversion *ics2)\n \n   while (ics1->kind == ck_rvalue\n \t || ics1->kind == ck_lvalue)\n-    ics1 = ics1->u.next;\n+    ics1 = next_conversion (ics1);\n \n   while (1)\n     {\n       while (ics2->kind == ck_rvalue\n \t     || ics2->kind == ck_lvalue)\n-\tics2 = ics2->u.next;\n+\tics2 = next_conversion (ics2);\n \n       if (ics2->kind == ck_user\n \t  || ics2->kind == ck_ambig\n@@ -7443,12 +7443,12 @@ is_subseq (conversion *ics1, conversion *ics2)\n \t   sequences.  */\n \treturn false;\n \n-      ics2 = ics2->u.next;\n+      ics2 = next_conversion (ics2);\n \n       if (ics2->kind == ics1->kind\n \t  && same_type_p (ics2->type, ics1->type)\n-\t  && same_type_p (ics2->u.next->type,\n-\t\t\t  ics1->u.next->type))\n+\t  && same_type_p (next_conversion (ics2)->type,\n+\t\t\t  next_conversion (ics1)->type))\n \treturn true;\n     }\n }\n@@ -7496,9 +7496,9 @@ maybe_handle_implicit_object (conversion **ics)\n       reference_type = build_reference_type (reference_type);\n \n       if (t->kind == ck_qual)\n-\tt = t->u.next;\n+\tt = next_conversion (t);\n       if (t->kind == ck_ptr)\n-\tt = t->u.next;\n+\tt = next_conversion (t);\n       t = build_identity_conv (TREE_TYPE (t->type), NULL_TREE);\n       t = direct_reference_binding (reference_type, t);\n       t->this_p = 1;\n@@ -7517,7 +7517,7 @@ maybe_handle_ref_bind (conversion **ics)\n   if ((*ics)->kind == ck_ref_bind)\n     {\n       conversion *old_ics = *ics;\n-      *ics = old_ics->u.next;\n+      *ics = next_conversion (old_ics);\n       (*ics)->user_conv_p = old_ics->user_conv_p;\n       return old_ics;\n     }\n@@ -7625,11 +7625,11 @@ compare_ics (conversion *ics1, conversion *ics2)\n       conversion *t1;\n       conversion *t2;\n \n-      for (t1 = ics1; t1->kind != ck_user; t1 = t1->u.next)\n+      for (t1 = ics1; t1->kind != ck_user; t1 = next_conversion (t1))\n \tif (t1->kind == ck_ambig || t1->kind == ck_aggr\n \t    || t1->kind == ck_list)\n \t  break;\n-      for (t2 = ics2; t2->kind != ck_user; t2 = t2->u.next)\n+      for (t2 = ics2; t2->kind != ck_user; t2 = next_conversion (t2))\n \tif (t2->kind == ck_ambig || t2->kind == ck_aggr\n \t    || t2->kind == ck_list)\n \t  break;\n@@ -7674,12 +7674,12 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n       t1 = ics1;\n       while (t1->kind != ck_identity)\n-\tt1 = t1->u.next;\n+\tt1 = next_conversion (t1);\n       from_type1 = t1->type;\n \n       t2 = ics2;\n       while (t2->kind != ck_identity)\n-\tt2 = t2->u.next;\n+\tt2 = next_conversion (t2);\n       from_type2 = t2->type;\n     }\n \n@@ -7941,7 +7941,7 @@ compare_ics (conversion *ics1, conversion *ics2)\n static tree\n source_type (conversion *t)\n {\n-  for (;; t = t->u.next)\n+  for (;; t = next_conversion (t))\n     {\n       if (t->kind == ck_user\n \t  || t->kind == ck_ambig\n@@ -8039,11 +8039,11 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t      && TREE_CODE (t2->type) == INTEGER_TYPE\n \t      && (TYPE_PRECISION (t1->type)\n \t\t  == TYPE_PRECISION (t2->type))\n-\t      && (TYPE_UNSIGNED (t1->u.next->type)\n-\t\t  || (TREE_CODE (t1->u.next->type)\n+\t      && (TYPE_UNSIGNED (next_conversion (t1)->type)\n+\t\t  || (TREE_CODE (next_conversion (t1)->type)\n \t\t      == ENUMERAL_TYPE)))\n \t    {\n-\t      tree type = t1->u.next->type;\n+\t      tree type = next_conversion (t1)->type;\n \t      tree type1, type2;\n \t      struct z_candidate *w, *l;\n \t      if (comp > 0)"}]}