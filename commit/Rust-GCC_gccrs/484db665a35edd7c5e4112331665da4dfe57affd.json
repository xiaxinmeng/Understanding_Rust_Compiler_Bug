{"sha": "484db665a35edd7c5e4112331665da4dfe57affd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg0ZGI2NjVhMzVlZGQ3YzVlNDExMjMzMTY2NWRhNGRmZTU3YWZmZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-10-05T12:59:23Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-10-05T12:59:23Z"}, "message": "invoke.texi (-fshrink-wrap): Document.\n\n\t* doc/invoke.texi (-fshrink-wrap): Document.\n\t* opts.c (default_options_table): Add it.\n\t* common.opt (fshrink-wrap): Add.\n\t* function.c (emit_return_into_block): Remove useless declaration.\n\t(record_hard_reg_uses_1, record_hard_reg_uses, frame_required_for_rtx,\n\trequires_stack_frame_p, gen_return_pattern): New static functions.\n\t(emit_return_into_block): New arg simple_p.  All callers changed.\n\tUse gen_return_pattern.\n\t(thread_prologue_and_epilogue_insns): Implement shrink-wrapping.\n\t* config/i386/i386.md (return): Expand into a simple_return.\n\t(simple_return): New expander):\n\t(simple_return_internal, simple_return_internal_long,\n\tsimple_return_pop_internal_long, simple_return_indirect_internal):\n\tRenamed from return_internal, return_internal_long,\n\treturn_pop_internal_long and return_indirect_internal; changed to use\n\tsimple_return.\n\t* config/i386/i386.c (ix86_expand_epilogue): Adjust to expand\n\tsimple returns.\n\t(ix86_pad_returns): Likewise.\n\t* function.h (struct rtl_data): Add member shrink_wrapped.\n\t* cfgcleanup.c (outgoing_edges_match): If shrink-wrapped, edges that\n\tare not jumps or sibcalls can't be compared.\n\n\t* gcc.target/i386/sw-1.c: New test.\n\nFrom-SVN: r179553", "tree": {"sha": "092a063b47d0bf2e253befae6fbbc597612758ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/092a063b47d0bf2e253befae6fbbc597612758ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/484db665a35edd7c5e4112331665da4dfe57affd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/484db665a35edd7c5e4112331665da4dfe57affd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/484db665a35edd7c5e4112331665da4dfe57affd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/484db665a35edd7c5e4112331665da4dfe57affd/comments", "author": null, "committer": null, "parents": [{"sha": "18474649d91dd922555c5af509206a7aa3c65285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18474649d91dd922555c5af509206a7aa3c65285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18474649d91dd922555c5af509206a7aa3c65285"}], "stats": {"total": 852, "additions": 705, "deletions": 147}, "files": [{"sha": "3891393d604dcdedd0871a30c28a01e2408b05e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -1,3 +1,28 @@\n+2011-10-05  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* doc/invoke.texi (-fshrink-wrap): Document.\n+\t* opts.c (default_options_table): Add it.\n+\t* common.opt (fshrink-wrap): Add.\n+\t* function.c (emit_return_into_block): Remove useless declaration.\n+\t(record_hard_reg_uses_1, record_hard_reg_uses, frame_required_for_rtx,\n+\trequires_stack_frame_p, gen_return_pattern): New static functions.\n+\t(emit_return_into_block): New arg simple_p.  All callers changed.\n+\tUse gen_return_pattern.\n+\t(thread_prologue_and_epilogue_insns): Implement shrink-wrapping.\n+\t* config/i386/i386.md (return): Expand into a simple_return.\n+\t(simple_return): New expander):\n+\t(simple_return_internal, simple_return_internal_long,\n+\tsimple_return_pop_internal_long, simple_return_indirect_internal):\n+\tRenamed from return_internal, return_internal_long,\n+\treturn_pop_internal_long and return_indirect_internal; changed to use\n+\tsimple_return.\n+\t* config/i386/i386.c (ix86_expand_epilogue): Adjust to expand\n+\tsimple returns.\n+\t(ix86_pad_returns): Likewise.\n+\t* function.h (struct rtl_data): Add member shrink_wrapped.\n+\t* cfgcleanup.c (outgoing_edges_match): If shrink-wrapped, edges that\n+\tare not jumps or sibcalls can't be compared.\n+\n 2011-10-05  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (vn_get_expr_for): Handle CONSTRUCTOR of"}, {"sha": "b59cf7bc9f0ebbaec00482b7282412b0a363d398", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -1488,6 +1488,16 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n   edge e1, e2;\n   edge_iterator ei;\n \n+  /* If we performed shrink-wrapping, edges to the EXIT_BLOCK_PTR can\n+     only be distinguished for JUMP_INSNs.  The two paths may differ in\n+     whether they went through the prologue.  Sibcalls are fine, we know\n+     that we either didn't need or inserted an epilogue before them.  */\n+  if (crtl->shrink_wrapped\n+      && single_succ_p (bb1) && single_succ (bb1) == EXIT_BLOCK_PTR\n+      && !JUMP_P (BB_END (bb1))\n+      && !(CALL_P (BB_END (bb1)) && SIBLING_CALL_P (BB_END (bb1))))\n+    return false;\n+  \n   /* If BB1 has only one successor, we may be looking at either an\n      unconditional jump, or a fake edge to exit.  */\n   if (single_succ_p (bb1)"}, {"sha": "b6b28cc89b60c818adc123dd176e2f5c1f637739", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -1772,6 +1772,11 @@ fshow-column\n Common Report Var(flag_show_column) Init(1)\n Show column numbers in diagnostics, when available.  Default on\n \n+fshrink-wrap\n+Common Report Var(flag_shrink_wrap) Optimization\n+Emit function prologues only before parts of the function that need it,\n+rather than at the top of the function.\n+\n fsignaling-nans\n Common Report Var(flag_signaling_nans) Optimization SetByCombined\n Disable optimizations observable by IEEE signaling NaNs"}, {"sha": "4c1db3a927f9b60213b84e027830bdd8a6359a51", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -10779,13 +10779,13 @@ ix86_expand_epilogue (int style)\n \n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     popc, -1, true);\n-\t  emit_jump_insn (gen_return_indirect_internal (ecx));\n+\t  emit_jump_insn (gen_simple_return_indirect_internal (ecx));\n \t}\n       else\n-\temit_jump_insn (gen_return_pop_internal (popc));\n+\temit_jump_insn (gen_simple_return_pop_internal (popc));\n     }\n   else\n-    emit_jump_insn (gen_return_internal ());\n+    emit_jump_insn (gen_simple_return_internal ());\n \n   /* Restore the state back to the state from the prologue,\n      so that it's correct for the next epilogue.  */\n@@ -31312,7 +31312,7 @@ ix86_pad_returns (void)\n \t}\n       if (replace)\n \t{\n-\t  emit_jump_insn_before (gen_return_internal_long (), ret);\n+\t  emit_jump_insn_before (gen_simple_return_internal_long (), ret);\n \t  delete_insn (ret);\n \t}\n     }"}, {"sha": "b8a649c2ee44b0b052cab5dd1b35d6a6aebbcd77", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -11695,19 +11695,31 @@\n ;; See comments for ix86_can_use_return_insn_p in i386.c.\n \n (define_expand \"return\"\n-  [(return)]\n+  [(simple_return)]\n   \"ix86_can_use_return_insn_p ()\"\n {\n   if (crtl->args.pops_args)\n     {\n       rtx popc = GEN_INT (crtl->args.pops_args);\n-      emit_jump_insn (gen_return_pop_internal (popc));\n+      emit_jump_insn (gen_simple_return_pop_internal (popc));\n       DONE;\n     }\n })\n \n-(define_insn \"return_internal\"\n-  [(return)]\n+(define_expand \"simple_return\"\n+  [(simple_return)]\n+  \"\"\n+{\n+  if (crtl->args.pops_args)\n+    {\n+      rtx popc = GEN_INT (crtl->args.pops_args);\n+      emit_jump_insn (gen_simple_return_pop_internal (popc));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"simple_return_internal\"\n+  [(simple_return)]\n   \"reload_completed\"\n   \"ret\"\n   [(set_attr \"length\" \"1\")\n@@ -11718,8 +11730,8 @@\n ;; Used by x86_machine_dependent_reorg to avoid penalty on single byte RET\n ;; instruction Athlon and K8 have.\n \n-(define_insn \"return_internal_long\"\n-  [(return)\n+(define_insn \"simple_return_internal_long\"\n+  [(simple_return)\n    (unspec [(const_int 0)] UNSPEC_REP)]\n   \"reload_completed\"\n   \"rep\\;ret\"\n@@ -11729,8 +11741,8 @@\n    (set_attr \"prefix_rep\" \"1\")\n    (set_attr \"modrm\" \"0\")])\n \n-(define_insn \"return_pop_internal\"\n-  [(return)\n+(define_insn \"simple_return_pop_internal\"\n+  [(simple_return)\n    (use (match_operand:SI 0 \"const_int_operand\" \"\"))]\n   \"reload_completed\"\n   \"ret\\t%0\"\n@@ -11739,8 +11751,8 @@\n    (set_attr \"length_immediate\" \"2\")\n    (set_attr \"modrm\" \"0\")])\n \n-(define_insn \"return_indirect_internal\"\n-  [(return)\n+(define_insn \"simple_return_indirect_internal\"\n+  [(simple_return)\n    (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n   \"reload_completed\"\n   \"jmp\\t%A0\""}, {"sha": "e0df77a0c415ce310a6a58795d5d5f81ad907e17", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -396,10 +396,10 @@ Objective-C and Objective-C++ Dialects}.\n -fschedule-insns -fschedule-insns2 -fsection-anchors @gol\n -fselective-scheduling -fselective-scheduling2 @gol\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n--fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n--fsplit-wide-types -fstack-protector -fstack-protector-all @gol\n--fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer @gol\n--ftree-bit-ccp @gol\n+-fshrink-wrap -fsignaling-nans -fsingle-precision-constant @gol\n+-fsplit-ivs-in-unroller -fsplit-wide-types -fstack-protector @gol\n+-fstack-protector-all -fstrict-aliasing -fstrict-overflow @gol\n+-fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol\n -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol\n -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol\n@@ -6880,6 +6880,12 @@ This option has no effect until one of @option{-fselective-scheduling} or\n When pipelining loops during selective scheduling, also pipeline outer loops.\n This option has no effect until @option{-fsel-sched-pipelining} is turned on.\n \n+@item -fshrink-wrap\n+@opindex fshrink-wrap\n+Emit function prologues only before parts of the function that need it,\n+rather than at the top of the function.  This flag is enabled by default at\n+@option{-O} and higher.\n+\n @item -fcaller-saves\n @opindex fcaller-saves\n Enable values to be allocated in registers that will be clobbered by"}, {"sha": "863f09d24f8a67f7e7ecace04861d664216dccdb", "filename": "gcc/function.c", "status": "modified", "additions": 603, "deletions": 129, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -147,9 +147,6 @@ extern tree debug_find_var_in_block_tree (tree, tree);\n    can always export `prologue_epilogue_contains'.  */\n static void record_insns (rtx, rtx, htab_t *) ATTRIBUTE_UNUSED;\n static bool contains (const_rtx, htab_t);\n-#ifdef HAVE_return\n-static void emit_return_into_block (basic_block);\n-#endif\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n@@ -5285,6 +5282,78 @@ prologue_epilogue_contains (const_rtx insn)\n   return 0;\n }\n \n+#ifdef HAVE_simple_return\n+\n+/* A for_each_rtx subroutine of record_hard_reg_sets.  */\n+static int\n+record_hard_reg_uses_1 (rtx *px, void *data)\n+{\n+  rtx x = *px;\n+  HARD_REG_SET *pused = (HARD_REG_SET *)data;\n+\n+  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    add_to_hard_reg_set (pused, GET_MODE (x), REGNO (x));\n+  return 0;\n+}\n+\n+/* Like record_hard_reg_sets, but called through note_uses.  */\n+static void\n+record_hard_reg_uses (rtx *px, void *data)\n+{\n+  for_each_rtx (px, record_hard_reg_uses_1, data);\n+}\n+\n+/* A subroutine of requires_stack_frame_p, called via for_each_rtx.\n+   Return 1 if we found an rtx that forces a prologue, zero otherwise.  */\n+static int\n+frame_required_for_rtx (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *loc;\n+  if (x == stack_pointer_rtx || x == hard_frame_pointer_rtx\n+      || x == arg_pointer_rtx || x == pic_offset_table_rtx)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return true if INSN requires the stack frame to be set up.\n+   PROLOGUE_USED contains the hard registers used in the function\n+   prologue.  */\n+static bool\n+requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used)\n+{\n+  df_ref *def_rec;\n+  HARD_REG_SET hardregs;\n+  unsigned regno;\n+\n+  if (!INSN_P (insn) || DEBUG_INSN_P (insn))\n+    return false;\n+  if (CALL_P (insn))\n+    return !SIBLING_CALL_P (insn);\n+  if (for_each_rtx (&PATTERN (insn), frame_required_for_rtx, NULL))\n+    return true;\n+\n+  CLEAR_HARD_REG_SET (hardregs);\n+  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+    {\n+      rtx dreg = DF_REF_REG (*def_rec);\n+\n+      if (!REG_P (dreg))\n+\tcontinue;\n+\n+      add_to_hard_reg_set (&hardregs, GET_MODE (dreg),\n+\t\t\t   REGNO (dreg));\n+    }\n+  if (hard_reg_set_intersect_p (hardregs, prologue_used))\n+    return true;\n+  AND_COMPL_HARD_REG_SET (hardregs, call_used_reg_set);\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (TEST_HARD_REG_BIT (hardregs, regno)\n+\t&& df_regs_ever_live_p (regno))\n+      return true;\n+  return false;\n+}\n+#endif\n+\n #ifdef HAVE_return\n /* Insert use of return register before the end of BB.  */\n \n@@ -5299,45 +5368,145 @@ emit_use_return_register_into_block (basic_block bb)\n   emit_insn_before (seq, BB_END (bb));\n }\n \n-/* Insert gen_return at the end of block BB.  This also means updating\n-   block_for_insn appropriately.  */\n+\n+/* Create a return pattern, either simple_return or return, depending on\n+   simple_p.  */\n+\n+static rtx\n+gen_return_pattern (bool simple_p)\n+{\n+#ifdef HAVE_simple_return\n+  return simple_p ? gen_simple_return () : gen_return ();\n+#else\n+  gcc_assert (!simple_p);\n+  return gen_return ();\n+#endif\n+}\n+\n+/* Insert an appropriate return pattern at the end of block BB.  This\n+   also means updating block_for_insn appropriately.  SIMPLE_P is\n+   the same as in gen_return_pattern and passed to it.  */\n \n static void\n-emit_return_into_block (basic_block bb)\n+emit_return_into_block (bool simple_p, basic_block bb)\n {\n-  rtx jump = emit_jump_insn_after (gen_return (), BB_END (bb));\n-  rtx pat = PATTERN (jump);\n+  rtx jump, pat;\n+  jump = emit_jump_insn_after (gen_return_pattern (simple_p), BB_END (bb));\n+  pat = PATTERN (jump);\n   if (GET_CODE (pat) == PARALLEL)\n     pat = XVECEXP (pat, 0, 0);\n   gcc_assert (ANY_RETURN_P (pat));\n   JUMP_LABEL (jump) = pat;\n }\n-#endif /* HAVE_return */\n+#endif\n \n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n-   the epilogue begins.  Update the basic block information when possible.  */\n+   the epilogue begins.  Update the basic block information when possible.\n+\n+   Notes on epilogue placement:\n+   There are several kinds of edges to the exit block:\n+   * a single fallthru edge from LAST_BB\n+   * possibly, edges from blocks containing sibcalls\n+   * possibly, fake edges from infinite loops\n+\n+   The epilogue is always emitted on the fallthru edge from the last basic\n+   block in the function, LAST_BB, into the exit block.\n+\n+   If LAST_BB is empty except for a label, it is the target of every\n+   other basic block in the function that ends in a return.  If a\n+   target has a return or simple_return pattern (possibly with\n+   conditional variants), these basic blocks can be changed so that a\n+   return insn is emitted into them, and their target is adjusted to\n+   the real exit block.\n+\n+   Notes on shrink wrapping: We implement a fairly conservative\n+   version of shrink-wrapping rather than the textbook one.  We only\n+   generate a single prologue and a single epilogue.  This is\n+   sufficient to catch a number of interesting cases involving early\n+   exits.\n+\n+   First, we identify the blocks that require the prologue to occur before\n+   them.  These are the ones that modify a call-saved register, or reference\n+   any of the stack or frame pointer registers.  To simplify things, we then\n+   mark everything reachable from these blocks as also requiring a prologue.\n+   This takes care of loops automatically, and avoids the need to examine\n+   whether MEMs reference the frame, since it is sufficient to check for\n+   occurrences of the stack or frame pointer.\n+\n+   We then compute the set of blocks for which the need for a prologue\n+   is anticipatable (borrowing terminology from the shrink-wrapping\n+   description in Muchnick's book).  These are the blocks which either\n+   require a prologue themselves, or those that have only successors\n+   where the prologue is anticipatable.  The prologue needs to be\n+   inserted on all edges from BB1->BB2 where BB2 is in ANTIC and BB1\n+   is not.  For the moment, we ensure that only one such edge exists.\n+\n+   The epilogue is placed as described above, but we make a\n+   distinction between inserting return and simple_return patterns\n+   when modifying other blocks that end in a return.  Blocks that end\n+   in a sibcall omit the sibcall_epilogue if the block is not in\n+   ANTIC.  */\n \n static void\n thread_prologue_and_epilogue_insns (void)\n {\n   bool inserted;\n+  basic_block last_bb;\n+  bool last_bb_active;\n+#ifdef HAVE_simple_return\n+  bool unconverted_simple_returns = false;\n+  basic_block simple_return_block_hot = NULL;\n+  basic_block simple_return_block_cold = NULL;\n+  bool nonempty_prologue;\n+#endif\n+  rtx returnjump ATTRIBUTE_UNUSED;\n   rtx seq ATTRIBUTE_UNUSED, epilogue_end ATTRIBUTE_UNUSED;\n-  edge entry_edge, e;\n+  rtx prologue_seq ATTRIBUTE_UNUSED, split_prologue_seq ATTRIBUTE_UNUSED;\n+  edge e, entry_edge, orig_entry_edge, exit_fallthru_edge;\n   edge_iterator ei;\n+  bitmap_head bb_flags;\n+\n+  df_analyze ();\n \n   rtl_profile_for_bb (ENTRY_BLOCK_PTR);\n \n   inserted = false;\n   seq = NULL_RTX;\n   epilogue_end = NULL_RTX;\n+  returnjump = NULL_RTX;\n \n   /* Can't deal with multiple successors of the entry block at the\n      moment.  Function should always have at least one entry\n      point.  */\n   gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));\n   entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n+  orig_entry_edge = entry_edge;\n+\n+  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+  if (exit_fallthru_edge != NULL)\n+    {\n+      rtx label;\n+\n+      last_bb = exit_fallthru_edge->src;\n+      /* Test whether there are active instructions in the last block.  */\n+      label = BB_END (last_bb);\n+      while (label && !LABEL_P (label))\n+\t{\n+\t  if (active_insn_p (label))\n+\t    break;\n+\t  label = PREV_INSN (label);\n+\t}\n \n+      last_bb_active = BB_HEAD (last_bb) != label || !LABEL_P (label);\n+    }\n+  else\n+    {\n+      last_bb = NULL;\n+      last_bb_active = false;\n+    }\n+\n+  split_prologue_seq = NULL_RTX;\n   if (flag_split_stack\n       && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n \t  == NULL))\n@@ -5349,17 +5518,15 @@ thread_prologue_and_epilogue_insns (void)\n \n       start_sequence ();\n       emit_insn (gen_split_stack_prologue ());\n-      seq = get_insns ();\n+      split_prologue_seq = get_insns ();\n       end_sequence ();\n \n-      record_insns (seq, NULL, &prologue_insn_hash);\n-      set_insn_locators (seq, prologue_locator);\n-\n-      insert_insn_on_edge (seq, entry_edge);\n-      inserted = true;\n+      record_insns (split_prologue_seq, NULL, &prologue_insn_hash);\n+      set_insn_locators (split_prologue_seq, prologue_locator);\n #endif\n     }\n \n+  prologue_seq = NULL_RTX;\n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n@@ -5382,15 +5549,222 @@ thread_prologue_and_epilogue_insns (void)\n       if (!targetm.profile_before_prologue () && crtl->profile)\n         emit_insn (gen_blockage ());\n \n-      seq = get_insns ();\n+      prologue_seq = get_insns ();\n       end_sequence ();\n-      set_insn_locators (seq, prologue_locator);\n+      set_insn_locators (prologue_seq, prologue_locator);\n+    }\n+#endif\n \n-      insert_insn_on_edge (seq, entry_edge);\n-      inserted = true;\n+  bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n+\n+#ifdef HAVE_simple_return\n+  /* Try to perform a kind of shrink-wrapping, making sure the\n+     prologue/epilogue is emitted only around those parts of the\n+     function that require it.  */\n+\n+  nonempty_prologue = false;\n+  for (seq = prologue_seq; seq; seq = NEXT_INSN (seq))\n+    if (!NOTE_P (seq) || NOTE_KIND (seq) != NOTE_INSN_PROLOGUE_END)\n+      {\n+\tnonempty_prologue = true;\n+\tbreak;\n+      }\n+      \n+  if (flag_shrink_wrap && HAVE_simple_return\n+      && nonempty_prologue && !crtl->calls_eh_return)\n+    {\n+      HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;\n+      rtx p_insn;\n+\n+      VEC(basic_block, heap) *vec;\n+      basic_block bb;\n+      bitmap_head bb_antic_flags;\n+      bitmap_head bb_on_list;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"Attempting shrink-wrapping optimization.\\n\");\n+\n+      /* Compute the registers set and used in the prologue.  */\n+      CLEAR_HARD_REG_SET (prologue_clobbered);\n+      CLEAR_HARD_REG_SET (prologue_used);\n+      for (p_insn = prologue_seq; p_insn; p_insn = NEXT_INSN (p_insn))\n+\t{\n+\t  HARD_REG_SET this_used;\n+\t  if (!NONDEBUG_INSN_P (p_insn))\n+\t    continue;\n+\n+\t  CLEAR_HARD_REG_SET (this_used);\n+\t  note_uses (&PATTERN (p_insn), record_hard_reg_uses,\n+\t\t     &this_used);\n+\t  AND_COMPL_HARD_REG_SET (this_used, prologue_clobbered);\n+\t  IOR_HARD_REG_SET (prologue_used, this_used);\n+\t  note_stores (PATTERN (p_insn), record_hard_reg_sets,\n+\t\t       &prologue_clobbered);\n+\t}\n+      for (p_insn = split_prologue_seq; p_insn; p_insn = NEXT_INSN (p_insn))\n+\tif (NONDEBUG_INSN_P (p_insn))\n+\t  note_stores (PATTERN (p_insn), record_hard_reg_sets,\n+\t\t       &prologue_clobbered);\n+\n+      bitmap_initialize (&bb_antic_flags, &bitmap_default_obstack);\n+      bitmap_initialize (&bb_on_list, &bitmap_default_obstack);\n+\n+      /* Find the set of basic blocks that require a stack frame.  */\n+\n+      vec = VEC_alloc (basic_block, heap, n_basic_blocks);\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  rtx insn;\n+\t  /* As a special case, check for jumps to the last bb that\n+\t     cannot successfully be converted to simple_returns later\n+\t     on, and mark them as requiring a frame.  These are\n+\t     conditional jumps that jump to their fallthru block, so\n+\t     it's not a case that is expected to occur often.  */\n+\t  if (JUMP_P (BB_END (bb)) && any_condjump_p (BB_END (bb))\n+\t      && single_succ_p (bb)\n+\t      && !last_bb_active\n+\t      && single_succ (bb) == last_bb)\n+\t    {\n+\t      bitmap_set_bit (&bb_flags, bb->index);\n+\t      VEC_quick_push (basic_block, vec, bb);\n+\t    }\n+\t  else\n+\t    FOR_BB_INSNS (bb, insn)\n+\t      if (requires_stack_frame_p (insn, prologue_used))\n+\t\t{\n+\t\t  bitmap_set_bit (&bb_flags, bb->index);\n+\t\t  VEC_quick_push (basic_block, vec, bb);\n+\t\t  break;\n+\t\t}\n+\t}\n+\n+      /* For every basic block that needs a prologue, mark all blocks\n+\t reachable from it, so as to ensure they are also seen as\n+\t requiring a prologue.  */\n+      while (!VEC_empty (basic_block, vec))\n+\t{\n+\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, tmp_bb->succs)\n+\t    if (e->dest != EXIT_BLOCK_PTR\n+\t\t&& bitmap_set_bit (&bb_flags, e->dest->index))\n+\t      VEC_quick_push (basic_block, vec, e->dest);\n+\t}\n+      /* If the last basic block contains only a label, we'll be able\n+\t to convert jumps to it to (potentially conditional) return\n+\t insns later.  This means we don't necessarily need a prologue\n+\t for paths reaching it.  */\n+      if (last_bb)\n+\t{\n+\t  if (!last_bb_active)\n+\t    bitmap_clear_bit (&bb_flags, last_bb->index);\n+\t  else if (!bitmap_bit_p (&bb_flags, last_bb->index))\n+\t    goto fail_shrinkwrap;\n+\t}\n+\n+      /* Now walk backwards from every block that is marked as needing\n+\t a prologue to compute the bb_antic_flags bitmap.  */\n+      bitmap_copy (&bb_antic_flags, &bb_flags);\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  if (!bitmap_bit_p (&bb_flags, bb->index))\n+\t    continue;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (!bitmap_bit_p (&bb_antic_flags, e->src->index)\n+\t\t&& bitmap_set_bit (&bb_on_list, e->src->index))\n+\t      VEC_quick_push (basic_block, vec, e->src);\n+\t}\n+      while (!VEC_empty (basic_block, vec))\n+\t{\n+\t  basic_block tmp_bb = VEC_pop (basic_block, vec);\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  bool all_set = true;\n+\n+\t  bitmap_clear_bit (&bb_on_list, tmp_bb->index);\n+\t  FOR_EACH_EDGE (e, ei, tmp_bb->succs)\n+\t    if (!bitmap_bit_p (&bb_antic_flags, e->dest->index))\n+\t      {\n+\t\tall_set = false;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (all_set)\n+\t    {\n+\t      bitmap_set_bit (&bb_antic_flags, tmp_bb->index);\n+\t      FOR_EACH_EDGE (e, ei, tmp_bb->preds)\n+\t\tif (!bitmap_bit_p (&bb_antic_flags, e->src->index)\n+\t\t    && bitmap_set_bit (&bb_on_list, e->src->index))\n+\t\t  VEC_quick_push (basic_block, vec, e->src);\n+\t    }\n+\t}\n+      /* Find exactly one edge that leads to a block in ANTIC from\n+\t a block that isn't.  */\n+      if (!bitmap_bit_p (&bb_antic_flags, entry_edge->dest->index))\n+\tFOR_EACH_BB (bb)\n+\t  {\n+\t    if (!bitmap_bit_p (&bb_antic_flags, bb->index))\n+\t      continue;\n+\t    FOR_EACH_EDGE (e, ei, bb->preds)\n+\t      if (!bitmap_bit_p (&bb_antic_flags, e->src->index))\n+\t\t{\n+\t\t  if (entry_edge != orig_entry_edge)\n+\t\t    {\n+\t\t      entry_edge = orig_entry_edge;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"More than one candidate edge.\\n\");\n+\t\t      goto fail_shrinkwrap;\n+\t\t    }\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Found candidate edge for \"\n+\t\t\t     \"shrink-wrapping, %d->%d.\\n\", e->src->index,\n+\t\t\t     e->dest->index);\n+\t\t  entry_edge = e;\n+\t\t}\n+\t  }\n+\n+      /* Test whether the prologue is known to clobber any register\n+\t (other than FP or SP) which are live on the edge.  */\n+      CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);\n+      if (frame_pointer_needed)\n+\tCLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);\n+      CLEAR_HARD_REG_SET (live_on_edge);\n+      reg_set_to_hard_reg_set (&live_on_edge,\n+\t\t\t       df_get_live_in (entry_edge->dest));\n+      if (hard_reg_set_intersect_p (live_on_edge, prologue_clobbered))\n+\t{\n+\t  entry_edge = orig_entry_edge;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Shrink-wrapping aborted due to clobber.\\n\");\n+\t}\n+      else if (dump_file && entry_edge != orig_entry_edge)\n+\t{\n+\t  crtl->shrink_wrapped = true;\n+\t  fprintf (dump_file, \"Performing shrink-wrapping.\\n\");\n+\t}\n+\n+    fail_shrinkwrap:\n+      bitmap_clear (&bb_antic_flags);\n+      bitmap_clear (&bb_on_list);\n+      VEC_free (basic_block, heap, vec);\n     }\n #endif\n \n+  if (split_prologue_seq != NULL_RTX)\n+    {\n+      insert_insn_on_edge (split_prologue_seq, entry_edge);\n+      inserted = true;\n+    }\n+  if (prologue_seq != NULL_RTX)\n+    {\n+      insert_insn_on_edge (prologue_seq, entry_edge);\n+      inserted = true;\n+    }\n+\n   /* If the exit block has no non-fake predecessors, we don't need\n      an epilogue.  */\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n@@ -5400,110 +5774,145 @@ thread_prologue_and_epilogue_insns (void)\n     goto epilogue_done;\n \n   rtl_profile_for_bb (EXIT_BLOCK_PTR);\n+\n #ifdef HAVE_return\n-  if (optimize && HAVE_return)\n+  /* If we're allowed to generate a simple return instruction, then by\n+     definition we don't need a full epilogue.  If the last basic\n+     block before the exit block does not contain active instructions,\n+     examine its predecessors and try to emit (conditional) return\n+     instructions.  */\n+  if (optimize && !last_bb_active\n+      && (HAVE_return || entry_edge != orig_entry_edge))\n     {\n-      /* If we're allowed to generate a simple return instruction,\n-\t then by definition we don't need a full epilogue.  Examine\n-\t the block that falls through to EXIT.   If it does not\n-\t contain any code, examine its predecessors and try to\n-\t emit (conditional) return instructions.  */\n-\n-      basic_block last;\n+      edge_iterator ei2;\n+      int i;\n+      basic_block bb;\n       rtx label;\n+      VEC(basic_block,heap) *src_bbs;\n \n-      e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n-      if (e == NULL)\n+      if (exit_fallthru_edge == NULL)\n \tgoto epilogue_done;\n-      last = e->src;\n+      label = BB_HEAD (last_bb);\n \n-      /* Verify that there are no active instructions in the last block.  */\n-      label = BB_END (last);\n-      while (label && !LABEL_P (label))\n-\t{\n-\t  if (active_insn_p (label))\n-\t    break;\n-\t  label = PREV_INSN (label);\n-\t}\n+      src_bbs = VEC_alloc (basic_block, heap, EDGE_COUNT (last_bb->preds));\n+      FOR_EACH_EDGE (e, ei2, last_bb->preds)\n+\tif (e->src != ENTRY_BLOCK_PTR)\n+\t  VEC_quick_push (basic_block, src_bbs, e->src);\n \n-      if (BB_HEAD (last) == label && LABEL_P (label))\n+      FOR_EACH_VEC_ELT (basic_block, src_bbs, i, bb)\n \t{\n-\t  edge_iterator ei2;\n-\n-\t  for (ei2 = ei_start (last->preds); (e = ei_safe_edge (ei2)); )\n-\t    {\n-\t      basic_block bb = e->src;\n-\t      rtx jump;\n-\n-\t      if (bb == ENTRY_BLOCK_PTR)\n-\t\t{\n-\t\t  ei_next (&ei2);\n-\t\t  continue;\n-\t\t}\n+\t  bool simple_p;\n+\t  rtx jump;\n+\t  e = find_edge (bb, last_bb);\n \n-\t      jump = BB_END (bb);\n-\t      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)\n-\t\t{\n-\t\t  ei_next (&ei2);\n-\t\t  continue;\n-\t\t}\n+\t  jump = BB_END (bb);\n \n-\t      /* If we have an unconditional jump, we can replace that\n-\t\t with a simple return instruction.  */\n-\t      if (simplejump_p (jump))\n-\t\t{\n-\t\t  /* The use of the return register might be present in the exit\n-\t\t     fallthru block.  Either:\n-\t\t     - removing the use is safe, and we should remove the use in\n-\t\t       the exit fallthru block, or\n-\t\t     - removing the use is not safe, and we should add it here.\n-\t\t     For now, we conservatively choose the latter.  Either of the\n-\t\t     2 helps in crossjumping.  */\n-\t\t  emit_use_return_register_into_block (bb);\n-\n-\t\t  emit_return_into_block (bb);\n-\t\t  delete_insn (jump);\n-\t\t}\n+#ifdef HAVE_simple_return\n+\t  simple_p = (entry_edge != orig_entry_edge\n+\t\t      && !bitmap_bit_p (&bb_flags, bb->index));\n+#else\n+\t  simple_p = false;\n+#endif\n \n-\t      /* If we have a conditional jump, we can try to replace\n-\t\t that with a conditional return instruction.  */\n-\t      else if (condjump_p (jump))\n-\t\t{\n-\t\t  if (! redirect_jump (jump, ret_rtx, 0))\n-\t\t    {\n-\t\t      ei_next (&ei2);\n-\t\t      continue;\n-\t\t    }\n+\t  if (!simple_p\n+\t      && (!HAVE_return || !JUMP_P (jump)\n+\t\t  || JUMP_LABEL (jump) != label))\n+\t    continue;\n \n-\t\t  /* See comment in simple_jump_p case above.  */\n-\t\t  emit_use_return_register_into_block (bb);\n+\t  /* If we have an unconditional jump, we can replace that\n+\t     with a simple return instruction.  */\n+\t  if (!JUMP_P (jump))\n+\t    {\n+\t      emit_barrier_after (BB_END (bb));\n+\t      emit_return_into_block (simple_p, bb);\n+\t    }\n+\t  else if (simplejump_p (jump))\n+\t    {\n+\t      /* The use of the return register might be present in the exit\n+\t         fallthru block.  Either:\n+\t         - removing the use is safe, and we should remove the use in\n+\t           the exit fallthru block, or\n+\t         - removing the use is not safe, and we should add it here.\n+\t         For now, we conservatively choose the latter.  Either of the\n+\t         2 helps in crossjumping.  */\n+\t      emit_use_return_register_into_block (bb);\n+\n+\t      emit_return_into_block (simple_p, bb);\n+\t      delete_insn (jump);\n+\t    }\n+\t  else if (condjump_p (jump) && JUMP_LABEL (jump) != label)\n+\t    {\n+\t      basic_block new_bb;\n+\t      edge new_e;\n+\n+\t      gcc_assert (simple_p);\n+\t      new_bb = split_edge (e);\n+\t      emit_barrier_after (BB_END (new_bb));\n+\t      emit_return_into_block (simple_p, new_bb);\n+#ifdef HAVE_simple_return\n+\t      if (BB_PARTITION (new_bb) == BB_HOT_PARTITION)\n+\t\tsimple_return_block_hot = new_bb;\n+\t      else\n+\t\tsimple_return_block_cold = new_bb;\n+#endif\n+\t      new_e = single_succ_edge (new_bb);\n+\t      redirect_edge_succ (new_e, EXIT_BLOCK_PTR);\n \n-\t\t  /* If this block has only one successor, it both jumps\n-\t\t     and falls through to the fallthru block, so we can't\n-\t\t     delete the edge.  */\n-\t\t  if (single_succ_p (bb))\n-\t\t    {\n-\t\t      ei_next (&ei2);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n+\t      continue;\n+\t    }\n+\t  /* If we have a conditional jump branching to the last\n+\t     block, we can try to replace that with a conditional\n+\t     return instruction.  */\n+\t  else if (condjump_p (jump))\n+\t    {\n+\t      rtx dest;\n+\t      if (simple_p)\n+\t\tdest = simple_return_rtx;\n \t      else\n+\t\tdest = ret_rtx;\n+\t      if (! redirect_jump (jump, dest, 0))\n \t\t{\n-\t\t  ei_next (&ei2);\n+#ifdef HAVE_simple_return\n+\t\t  if (simple_p)\n+\t\t    unconverted_simple_returns = true;\n+#endif\n \t\t  continue;\n \t\t}\n \n-\t      /* Fix up the CFG for the successful change we just made.  */\n-\t      redirect_edge_succ (e, EXIT_BLOCK_PTR);\n+\t      /* See comment in simple_jump_p case above.  */\n+\t      emit_use_return_register_into_block (bb);\n+\n+\t      /* If this block has only one successor, it both jumps\n+\t\t and falls through to the fallthru block, so we can't\n+\t\t delete the edge.  */\n+\t      if (single_succ_p (bb))\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+#ifdef HAVE_simple_return\n+\t      if (simple_p)\n+\t\tunconverted_simple_returns = true;\n+#endif\n+\t      continue;\n \t    }\n \n+\t  /* Fix up the CFG for the successful change we just made.  */\n+\t  redirect_edge_succ (e, EXIT_BLOCK_PTR);\n+\t}\n+      VEC_free (basic_block, heap, src_bbs);\n+\n+      if (HAVE_return)\n+\t{\n \t  /* Emit a return insn for the exit fallthru block.  Whether\n \t     this is still reachable will be determined later.  */\n \n-\t  emit_barrier_after (BB_END (last));\n-\t  emit_return_into_block (last);\n-\t  epilogue_end = BB_END (last);\n-\t  single_succ_edge (last)->flags &= ~EDGE_FALLTHRU;\n+\t  emit_barrier_after (BB_END (last_bb));\n+\t  emit_return_into_block (false, last_bb);\n+\t  epilogue_end = BB_END (last_bb);\n+\t  if (JUMP_P (epilogue_end))\n+\t    JUMP_LABEL (epilogue_end) = ret_rtx;\n+\t  single_succ_edge (last_bb)->flags &= ~EDGE_FALLTHRU;\n \t  goto epilogue_done;\n \t}\n     }\n@@ -5540,20 +5949,15 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n-  /* Find the edge that falls through to EXIT.  Other edges may exist\n-     due to RETURN instructions, but those don't need epilogues.\n-     There really shouldn't be a mixture -- either all should have\n-     been converted or none, however...  */\n+  /* If nothing falls through into the exit block, we don't need an\n+     epilogue.  */\n \n-  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n-  if (e == NULL)\n+  if (exit_fallthru_edge == NULL)\n     goto epilogue_done;\n \n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {\n-      rtx returnjump;\n-\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n       seq = gen_epilogue ();\n@@ -5564,11 +5968,11 @@ thread_prologue_and_epilogue_insns (void)\n       record_insns (seq, NULL, &epilogue_insn_hash);\n       set_insn_locators (seq, epilogue_locator);\n \n-      returnjump = get_last_insn ();\n       seq = get_insns ();\n+      returnjump = get_last_insn ();\n       end_sequence ();\n \n-      insert_insn_on_edge (seq, e);\n+      insert_insn_on_edge (seq, exit_fallthru_edge);\n       inserted = true;\n \n       if (JUMP_P (returnjump))\n@@ -5581,23 +5985,21 @@ thread_prologue_and_epilogue_insns (void)\n \t  else\n \t    JUMP_LABEL (returnjump) = ret_rtx;\n \t}\n-      else\n-\treturnjump = NULL_RTX;\n     }\n   else\n #endif\n     {\n       basic_block cur_bb;\n \n-      if (! next_active_insn (BB_END (e->src)))\n+      if (! next_active_insn (BB_END (exit_fallthru_edge->src)))\n \tgoto epilogue_done;\n       /* We have a fall-through edge to the exit block, the source is not\n          at the end of the function, and there will be an assembler epilogue\n          at the end of the function.\n          We can't use force_nonfallthru here, because that would try to\n-         use return.  Inserting a jump 'by hand' is extremely messy, so\n+\t use return.  Inserting a jump 'by hand' is extremely messy, so\n \t we take advantage of cfg_layout_finalize using\n-\tfixup_fallthru_exit_predecessor.  */\n+\t fixup_fallthru_exit_predecessor.  */\n       cfg_layout_initialize (0);\n       FOR_EACH_BB (cur_bb)\n \tif (cur_bb->index >= NUM_FIXED_BLOCKS\n@@ -5607,6 +6009,7 @@ thread_prologue_and_epilogue_insns (void)\n     }\n \n epilogue_done:\n+\n   default_rtl_profile ();\n \n   if (inserted)\n@@ -5632,33 +6035,102 @@ thread_prologue_and_epilogue_insns (void)\n \t}\n     }\n \n+#ifdef HAVE_simple_return\n+  /* If there were branches to an empty LAST_BB which we tried to\n+     convert to conditional simple_returns, but couldn't for some\n+     reason, create a block to hold a simple_return insn and redirect\n+     those remaining edges.  */\n+  if (unconverted_simple_returns)\n+    {\n+      edge_iterator ei2;\n+      basic_block exit_pred = EXIT_BLOCK_PTR->prev_bb;\n+\n+      gcc_assert (entry_edge != orig_entry_edge);\n+\n+      /* See if we can reuse the last insn that was emitted for the\n+\t epilogue.  */\n+      if (returnjump != NULL_RTX\n+\t  && JUMP_LABEL (returnjump) == simple_return_rtx)\n+\t{\n+\t  edge e = split_block (exit_fallthru_edge->src,\n+\t\t\t\tPREV_INSN (returnjump));\n+\t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n+\t    simple_return_block_hot = e->dest;\n+\t  else\n+\t    simple_return_block_cold = e->dest;\n+\t}\n+\n+    restart_scan:\n+      for (ei2 = ei_start (last_bb->preds); (e = ei_safe_edge (ei2)); )\n+\t{\n+\t  basic_block bb = e->src;\n+\t  basic_block *pdest_bb;\n+\n+\t  if (bb == ENTRY_BLOCK_PTR\n+\t      || bitmap_bit_p (&bb_flags, bb->index))\n+\t    {\n+\t      ei_next (&ei2);\n+\t      continue;\n+\t    }\n+\t  if (BB_PARTITION (e->src) == BB_HOT_PARTITION)\n+\t    pdest_bb = &simple_return_block_hot;\n+\t  else\n+\t    pdest_bb = &simple_return_block_cold;\n+\t  if (*pdest_bb == NULL)\n+\t    {\n+\t      basic_block bb;\n+\t      rtx start;\n+\n+\t      bb = create_basic_block (NULL, NULL, exit_pred);\n+\t      BB_COPY_PARTITION (bb, e->src);\n+\t      start = emit_jump_insn_after (gen_simple_return (),\n+\t\t\t\t\t    BB_END (bb));\n+\t      JUMP_LABEL (start) = simple_return_rtx;\n+\t      emit_barrier_after (start);\n+\n+\t      *pdest_bb = bb;\n+\t      make_edge (bb, EXIT_BLOCK_PTR, 0);\n+\t    }\n+\t  redirect_edge_and_branch_force (e, *pdest_bb);\n+\t  goto restart_scan;\n+\t}\n+    }\n+#endif\n+\n #ifdef HAVE_sibcall_epilogue\n   /* Emit sibling epilogues before any sibling call sites.  */\n   for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n     {\n       basic_block bb = e->src;\n       rtx insn = BB_END (bb);\n+      rtx ep_seq;\n \n       if (!CALL_P (insn)\n-\t  || ! SIBLING_CALL_P (insn))\n+\t  || ! SIBLING_CALL_P (insn)\n+\t  || (entry_edge != orig_entry_edge\n+\t      && !bitmap_bit_p (&bb_flags, bb->index)))\n \t{\n \t  ei_next (&ei);\n \t  continue;\n \t}\n \n-      start_sequence ();\n-      emit_note (NOTE_INSN_EPILOGUE_BEG);\n-      emit_insn (gen_sibcall_epilogue ());\n-      seq = get_insns ();\n-      end_sequence ();\n+      ep_seq = gen_sibcall_epilogue ();\n+      if (ep_seq)\n+\t{\n+\t  start_sequence ();\n+\t  emit_note (NOTE_INSN_EPILOGUE_BEG);\n+\t  emit_insn (ep_seq);\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n \n-      /* Retain a map of the epilogue insns.  Used in life analysis to\n-\t avoid getting rid of sibcall epilogue insns.  Do this before we\n-\t actually emit the sequence.  */\n-      record_insns (seq, NULL, &epilogue_insn_hash);\n-      set_insn_locators (seq, epilogue_locator);\n+\t  /* Retain a map of the epilogue insns.  Used in life analysis to\n+\t     avoid getting rid of sibcall epilogue insns.  Do this before we\n+\t     actually emit the sequence.  */\n+\t  record_insns (seq, NULL, &epilogue_insn_hash);\n+\t  set_insn_locators (seq, epilogue_locator);\n \n-      emit_insn_before (seq, insn);\n+\t  emit_insn_before (seq, insn);\n+\t}\n       ei_next (&ei);\n     }\n #endif\n@@ -5683,6 +6155,8 @@ thread_prologue_and_epilogue_insns (void)\n     }\n #endif\n \n+  bitmap_clear (&bb_flags);\n+\n   /* Threading the prologue and epilogue changes the artificial refs\n      in the entry and exit blocks.  */\n   epilogue_completed = 1;"}, {"sha": "42e52acaad55aea85a55e64e68d4cc10528a0bb5", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -435,6 +435,9 @@ struct GTY(()) rtl_data {\n      function where currently compiled version of it is nothrow.  */\n   bool nothrow;\n \n+  /* True if we performed shrink-wrapping for the current function.  */\n+  bool shrink_wrapped;\n+\n   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n      asm.  Unlike regs_ever_live, elements of this array corresponding\n      to eliminable regs (like the frame pointer) are set if an asm"}, {"sha": "3153fe5027494619e8d1afbd3a3731c47675dda2", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -434,6 +434,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS, OPT_fipa_reference, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_fipa_profile, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_fmerge_constants, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS, OPT_fshrink_wrap, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_fsplit_wide_types, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_ccp, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_bit_ccp, NULL, 1 },"}, {"sha": "6ddbccda88a03d456e8dad0b1049c6b2458a73fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -1,3 +1,7 @@\n+2011-10-05  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* gcc.target/i386/sw-1.c: New test.\n+\n 2011-10-05  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/avx256-unaligned-load-3.c (dg-options): Add"}, {"sha": "483d117ecb73d757c210a0806de13cd840011179", "filename": "gcc/testsuite/gcc.target/i386/sw-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/484db665a35edd7c5e4112331665da4dfe57affd/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsw-1.c?ref=484db665a35edd7c5e4112331665da4dfe57affd", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fshrink-wrap -fdump-rtl-pro_and_epilogue\" } */\n+\n+#include <string.h>\n+\n+int c;\n+int x[2000];\n+__attribute__((regparm(1))) void foo (int a, int b)\n+ {\n+   int t[200];\n+   if (a == 0 || c == 0)\n+     return;\n+   memcpy (t, x + b, sizeof t);\n+   c = t[a];\n+ }\n+\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\" } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}]}