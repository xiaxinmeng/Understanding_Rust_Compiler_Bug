{"sha": "24105bab8c2cf186720770b33176f0880136fa68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxMDViYWI4YzJjZjE4NjcyMDc3MGIzMzE3NmYwODgwMTM2ZmE2OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-22T14:06:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-22T14:06:28Z"}, "message": "[multiple changes]\n\n2004-03-22  Cyrille Comar  <comar@act-europe.fr>\n\n\t* ali.ads: Fix Comment about Dynamic_Elab.\n\n\t* gnatls.adb (Output_Unit): Add output of many flags (Dynamic_Elab,\n\tHas_RACW, Is_Generic, etc.)\n\t(Output_Object, Gnatls): Take into account ALI files not attached to\n\tan object.\n\n2004-03-22  Vincent Celier  <celier@gnat.com>\n\n\t* gprep.adb: Change all String_Access to Name_Id\n\t(Is_ASCII_Letter): new function\n\t(Double_File_Name_Buffer): New procedure\n\t(Preprocess_Infile_Name): New procedure\n\t(Process_Files): New procedure\n\t(Gnatprep): Check if output and input are existing directories.\n\tCall Process_Files to do the real job.\n\n2004-03-22  Robert Dewar  <dewar@gnat.com>\n\n\t* prj-env.adb, prj-nmsc.ads, prj-proc.ads,\n\ts-stache.ads, s-stache.adb: Comment updates. Minor reformatting.\n\n2004-03-22  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* scn.adb (Contains): Add check for EOF, is needed for a degenerated\n\tcase when the source contains only comments.\n\n2004-03-22  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch10.adb (Analyze_Compilation_Unit): When generating a\n\tdeclaration for a child subprogram body that acts as a spec, indicate\n\tthat the entity in the declaration needs debugging information.\n\n\t* sem_ch3.adb (Complete_Private_Subtype): Do not build an underlying\n\tfull view if the subtype is created for a constrained record component;\n\tgigi has enough information to construct the record, and there is no\n\tplace in the tree for the declaration.\n\n\t* sem_ch6.adb (Build_Body_To_Inline): Use an internal name without\n\tserial number for the dummy body that is built for analysis, to avoid\n\tinconsistencies in the generation of internal names when compiling\n\twith -gnatN.\n\n2004-03-22  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem_util.adb (Is_Object_Reference): A view conversion denotes an\n\tobject.\n\n2004-03-22  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r79826", "tree": {"sha": "046250c44426ffdf888413277208b576e9375d91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/046250c44426ffdf888413277208b576e9375d91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24105bab8c2cf186720770b33176f0880136fa68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24105bab8c2cf186720770b33176f0880136fa68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24105bab8c2cf186720770b33176f0880136fa68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24105bab8c2cf186720770b33176f0880136fa68/comments", "author": null, "committer": null, "parents": [{"sha": "ead61c1d430c015cba9f73466aba2c719791d7bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead61c1d430c015cba9f73466aba2c719791d7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead61c1d430c015cba9f73466aba2c719791d7bc"}], "stats": {"total": 754, "additions": 631, "deletions": 123}, "files": [{"sha": "986d55421a32f3a65e29a4f4ec40cd25e58ee9b7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -1,3 +1,57 @@\n+2004-03-22  Cyrille Comar  <comar@act-europe.fr>\n+\n+\t* ali.ads: Fix Comment about Dynamic_Elab.\n+\n+\t* gnatls.adb (Output_Unit): Add output of many flags (Dynamic_Elab,\n+\tHas_RACW, Is_Generic, etc.)\n+\t(Output_Object, Gnatls): Take into account ALI files not attached to\n+\tan object.\n+\n+2004-03-22  Vincent Celier  <celier@gnat.com>\n+\n+\t* gprep.adb: Change all String_Access to Name_Id\n+\t(Is_ASCII_Letter): new function\n+\t(Double_File_Name_Buffer): New procedure\n+\t(Preprocess_Infile_Name): New procedure\n+\t(Process_Files): New procedure\n+\t(Gnatprep): Check if output and input are existing directories.\n+\tCall Process_Files to do the real job.\n+\n+2004-03-22  Robert Dewar  <dewar@gnat.com>\n+\n+\t* prj-env.adb, prj-nmsc.ads, prj-proc.ads,\n+\ts-stache.ads, s-stache.adb: Comment updates. Minor reformatting.\n+\n+2004-03-22  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* scn.adb (Contains): Add check for EOF, is needed for a degenerated\n+\tcase when the source contains only comments.\n+\n+2004-03-22  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch10.adb (Analyze_Compilation_Unit): When generating a\n+\tdeclaration for a child subprogram body that acts as a spec, indicate\n+\tthat the entity in the declaration needs debugging information.\n+\n+\t* sem_ch3.adb (Complete_Private_Subtype): Do not build an underlying\n+\tfull view if the subtype is created for a constrained record component;\n+\tgigi has enough information to construct the record, and there is no\n+\tplace in the tree for the declaration.\n+\n+\t* sem_ch6.adb (Build_Body_To_Inline): Use an internal name without\n+\tserial number for the dummy body that is built for analysis, to avoid\n+\tinconsistencies in the generation of internal names when compiling\n+\twith -gnatN.\n+\n+2004-03-22  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_util.adb (Is_Object_Reference): A view conversion denotes an\n+\tobject.\n+\n+2004-03-22  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2004-03-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (gnat_to_gnu_entity): Use SUBSTITUTE_PLACEHOLDER_IN_EXPR."}, {"sha": "886cf7943bdd6e382d06e5dd1dbf06c74b9a6c44", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -2793,10 +2793,8 @@ ada/s-sopco5.o : ada/system.ads ada/s-secsta.ads ada/s-stoele.ads \\\n    ada/s-stoele.adb ada/s-strops.ads ada/s-sopco3.ads ada/s-sopco4.ads \\\n    ada/s-sopco5.ads ada/s-sopco5.adb ada/unchconv.ads \n \n-ada/s-stache.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n-   ada/s-crtl.ads ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-traent.ads ada/unchconv.ads \n+ada/s-stache.o : ada/system.ads ada/s-stache.ads ada/s-stache.adb \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/unchconv.ads \n \n ada/s-stalib.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n    ada/s-memory.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\"}, {"sha": "9c7d35a8e5c994d14fda10ddce3b6f036b524074", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -253,7 +253,7 @@ package ALI is\n \n       Dynamic_Elab : Boolean;\n       --  Set to True if the unit was compiled with dynamic elaboration\n-      --  checks (i.e. either -gnatE or pragma Elaboration_Checks (Static)\n+      --  checks (i.e. either -gnatE or pragma Elaboration_Checks (RM)\n       --  was used to compile the unit).\n \n       Elaborate_Body : Boolean;"}, {"sha": "c66725114c01688b6b1f22737395425887b7e585", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -45,6 +45,8 @@ procedure Gnatls is\n \n    Max_Column : constant := 80;\n \n+   No_Obj : aliased String := \"<no_obj>\";\n+\n    type File_Status is (\n      OK,                  --  matching timestamp\n      Checksum_OK,         --  only matching checksum\n@@ -271,8 +273,13 @@ procedure Gnatls is\n             end if;\n \n             if Print_Object then\n-               Get_Name_String (ALIs.Table (Id).Ofile_Full_Name);\n-               Max_Obj_Length := Integer'Max (Max_Obj_Length, Name_Len + 1);\n+               if ALIs.Table (Id).No_Object then\n+                  Max_Obj_Length :=\n+                    Integer'Max (Max_Obj_Length, No_Obj'Length);\n+               else\n+                  Get_Name_String (ALIs.Table (Id).Ofile_Full_Name);\n+                  Max_Obj_Length := Integer'Max (Max_Obj_Length, Name_Len + 1);\n+               end if;\n             end if;\n          end if;\n       end loop;\n@@ -363,8 +370,13 @@ procedure Gnatls is\n \n    begin\n       if Print_Object then\n-         Get_Name_String (O);\n-         Object_Name := To_Host_File_Spec (Name_Buffer (1 .. Name_Len));\n+         if O /= No_File then\n+            Get_Name_String (O);\n+            Object_Name := To_Host_File_Spec (Name_Buffer (1 .. Name_Len));\n+         else\n+            Object_Name := No_Obj'Unchecked_Access;\n+         end if;\n+\n          Write_Str (Object_Name.all);\n \n          if Print_Source or else Print_Unit then\n@@ -501,14 +513,21 @@ procedure Gnatls is\n          end if;\n \n          if Verbose_Mode then\n-            if U.Preelab        or\n-               U.No_Elab        or\n-               U.Pure           or\n-               U.Elaborate_Body or\n-               U.Remote_Types   or\n-               U.Shared_Passive or\n-               U.RCI            or\n-               U.Predefined\n+            if U.Preelab             or\n+               U.No_Elab             or\n+               U.Pure                or\n+               U.Dynamic_Elab        or\n+               U.Has_RACW            or\n+               U.Remote_Types        or\n+               U.Shared_Passive      or\n+               U.RCI                 or\n+               U.Predefined          or\n+               U.Internal            or\n+               U.Is_Generic          or\n+               U.Init_Scalars        or\n+               U.Interface           or\n+               U.Body_Needed_For_SAL or\n+               U.Elaborate_Body\n             then\n                Write_Eol; Write_Str (\"     Flags  =>\");\n \n@@ -524,6 +543,50 @@ procedure Gnatls is\n                   Write_Str (\" Pure\");\n                end if;\n \n+               if U.Dynamic_Elab then\n+                  Write_Str (\" Dynamic_Elab\");\n+               end if;\n+\n+               if U.Has_RACW then\n+                  Write_Str (\" Has_RACW\");\n+               end if;\n+\n+               if U.Remote_Types then\n+                  Write_Str (\" Remote_Types\");\n+               end if;\n+\n+               if U.Shared_Passive then\n+                  Write_Str (\" Shared_Passive\");\n+               end if;\n+\n+               if U.RCI then\n+                  Write_Str (\" RCI\");\n+               end if;\n+\n+               if U.Predefined then\n+                  Write_Str (\" Predefined\");\n+               end if;\n+\n+               if U.Internal then\n+                  Write_Str (\" Internal\");\n+               end if;\n+\n+               if U.Is_Generic then\n+                  Write_Str (\" Is_Generic\");\n+               end if;\n+\n+               if U.Init_Scalars then\n+                  Write_Str (\" Init_Scalars\");\n+               end if;\n+\n+               if U.Interface then\n+                  Write_Str (\" Interface\");\n+               end if;\n+\n+               if U.Body_Needed_For_SAL then\n+                  Write_Str (\" Body_Needed_For_SAL\");\n+               end if;\n+\n                if U.Elaborate_Body then\n                   Write_Str (\" Elaborate Body\");\n                end if;\n@@ -540,9 +603,6 @@ procedure Gnatls is\n                   Write_Str (\" Predefined\");\n                end if;\n \n-               if U.RCI then\n-                  Write_Str (\" Remote_Call_Interface\");\n-               end if;\n             end if;\n          end if;\n \n@@ -966,7 +1026,11 @@ begin\n          Get_Name_String (Units.Table (ALIs.Table (Id).First_Unit).Uname);\n \n          if Also_Predef or else not Is_Internal_Unit then\n-            Output_Object (ALIs.Table (Id).Ofile_Full_Name);\n+            if ALIs.Table (Id).No_Object then\n+               Output_Object (No_File);\n+            else\n+               Output_Object (ALIs.Table (Id).Ofile_Full_Name);\n+            end if;\n \n             --  In verbose mode print all main units in the ALI file, otherwise\n             --  just print the first one to ease columnwise printout"}, {"sha": "fdd1f8ba25bba0463583aeb431ebf7649baae908", "filename": "gcc/ada/gprep.adb", "status": "modified", "additions": 413, "deletions": 72, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fgprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fgprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgprep.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -39,9 +39,12 @@ with Snames;\n with Stringt;  use Stringt;\n with Types;    use Types;\n \n-with Ada.Text_IO;       use Ada.Text_IO;\n+with Ada.Text_IO;               use Ada.Text_IO;\n+with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.Command_Line;\n-with GNAT.OS_Lib;       use GNAT.OS_Lib;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n+\n \n package body GPrep is\n \n@@ -52,16 +55,27 @@ package body GPrep is\n    -- Argument Line Data --\n    ------------------------\n \n-   Infile_Name  : String_Access;\n-   Outfile_Name : String_Access;\n-   Deffile_Name : String_Access;\n+   Infile_Name  : Name_Id := No_Name;\n+   Outfile_Name : Name_Id := No_Name;\n+   Deffile_Name : Name_Id := No_Name;\n+\n+   Output_Directory : Name_Id := No_Name;\n+   --  Used when the specified output is an existing directory\n+\n+   Input_Directory : Name_Id := No_Name;\n+   --  Used when the specified input and output are existing directories\n \n    Source_Ref_Pragma : Boolean := False;\n    --  Record command line options (set if -r switch set)\n \n    Text_Outfile : aliased Ada.Text_IO.File_Type;\n    Outfile      : constant File_Access := Text_Outfile'Access;\n \n+   File_Name_Buffer_Initial_Size : constant := 50;\n+   File_Name_Buffer : String_Access :=\n+                        new String (1 .. File_Name_Buffer_Initial_Size);\n+   --  A buffer to build output file names from input file names.\n+\n    -----------------\n    -- Subprograms --\n    -----------------\n@@ -81,8 +95,22 @@ package body GPrep is\n       Errutil.Style);\n    --  The scanner for the preprocessor\n \n+   function Is_ASCII_Letter (C : Character) return Boolean;\n+   --  True if C is in 'a' .. 'z' or in 'A' .. 'Z'\n+\n+   procedure Double_File_Name_Buffer;\n+   --  Double the size of the file name buffer.\n+\n+   procedure Preprocess_Infile_Name;\n+   --  When the specified output is a directory, preprocess the infile name\n+   --  for symbol substitution, to get the output file name.\n+\n+   procedure Process_Files;\n+   --  Process the single input file or all the files in the directory tree\n+   --  rooted at the input directory.\n+\n    procedure Process_Command_Line_Symbol_Definition (S : String);\n-   --  Process a -D switch on ther command line\n+   --  Process a -D switch on the command line\n \n    procedure Put_Char_To_Outfile (C : Character);\n    --  Output one character to the output file.\n@@ -112,13 +140,24 @@ package body GPrep is\n       end if;\n    end Display_Copyright;\n \n+   -----------------------------\n+   -- Double_File_Name_Buffer --\n+   -----------------------------\n+\n+   procedure Double_File_Name_Buffer is\n+      New_Buffer : constant String_Access :=\n+                     new String (1 .. 2 * File_Name_Buffer'Length);\n+   begin\n+      New_Buffer (File_Name_Buffer'Range) := File_Name_Buffer.all;\n+      Free (File_Name_Buffer);\n+      File_Name_Buffer := New_Buffer;\n+   end Double_File_Name_Buffer;\n+\n    --------------\n    -- Gnatprep --\n    --------------\n \n    procedure Gnatprep is\n-      Infile : Source_File_Index;\n-\n    begin\n       --  Do some initializations (order is important here!)\n \n@@ -156,12 +195,13 @@ package body GPrep is\n \n       --  Test we had all the arguments needed\n \n-      if Infile_Name = null then\n+      if Infile_Name = No_Name then\n          --  No input file specified, just output the usage and exit\n \n          Usage;\n          return;\n-      elsif Outfile_Name = null then\n+\n+      elsif Outfile_Name = No_Name then\n          --  No output file specified, just output the usage and exit\n \n          Usage;\n@@ -178,13 +218,13 @@ package body GPrep is\n \n       --  If we have a definition file, parse it\n \n-      if Deffile_Name /= null then\n+      if Deffile_Name /= No_Name then\n          declare\n             Deffile : Source_File_Index;\n \n          begin\n             Errutil.Initialize;\n-            Deffile := Sinput.C.Load_File (Deffile_Name.all);\n+            Deffile := Sinput.C.Load_File (Get_Name_String (Deffile_Name));\n \n             --  Set Main_Source_File to the definition file for the benefit of\n             --  Errutil.Finalize.\n@@ -193,7 +233,7 @@ package body GPrep is\n \n             if Deffile = No_Source_File then\n                Fail (\"unable to find definition file \"\"\",\n-                     Deffile_Name.all,\n+                     Get_Name_String (Deffile_Name),\n                      \"\"\"\");\n             end if;\n \n@@ -208,7 +248,8 @@ package body GPrep is\n \n       if Total_Errors_Detected > 0 then\n          Errutil.Finalize (Source_Type => \"definition\");\n-         Fail (\"errors in definition file \"\"\", Deffile_Name.all, \"\"\"\");\n+         Fail (\"errors in definition file \"\"\",\n+               Get_Name_String (Deffile_Name), \"\"\"\");\n       end if;\n \n       --  If -s switch was specified, print a sorted list of symbol names and\n@@ -218,68 +259,37 @@ package body GPrep is\n          Prep.List_Symbols (Foreword => \"\");\n       end if;\n \n-      --  Load the input file\n-\n-      Infile := Sinput.C.Load_File (Infile_Name.all);\n-\n-      if Infile = No_Source_File then\n-         Fail (\"unable to find input file \"\"\", Infile_Name.all, \"\"\"\");\n-      end if;\n-\n-      --  Set Main_Source_File to the input file for the benefit of\n-      --  Errutil.Finalize.\n-\n-      Sinput.Main_Source_File := Infile;\n-\n-      Scanner.Initialize_Scanner (No_Unit, Infile);\n-\n-      --  If an output file were specified, create it; fails if this did not\n-      --  work.\n-\n-      if Outfile_Name /= null then\n-         begin\n-            Create (Text_Outfile, Out_File, Outfile_Name.all);\n-\n-         exception\n-            when others =>\n-               Fail\n-                 (\"unable to create output file \"\"\", Outfile_Name.all, \"\"\"\");\n-         end;\n-      end if;\n-\n-      --  Output the SFN pragma if asked to\n+      Output_Directory := No_Name;\n+      Input_Directory  := No_Name;\n \n-      if Source_Ref_Pragma then\n-         Put_Line (Outfile.all, \"pragma Source_Reference (1, \"\"\" &\n-                   Get_Name_String (Sinput.File_Name (Infile)) &\n-                   \"\"\");\");\n-      end if;\n-\n-      --  Preprocess the input file\n+      --  Check if the specified output is an existing directory\n \n-      Prep.Preprocess;\n+      if Is_Directory (Get_Name_String (Outfile_Name)) then\n+         Output_Directory := Outfile_Name;\n \n-      --  In verbose mode, if there is no error, report it\n+         --  As the output is an existing directory, check if the input too\n+         --  is a directory.\n \n-      if Opt.Verbose_Mode and then Err_Vars.Total_Errors_Detected = 0 then\n-         Errutil.Finalize (Source_Type => \"input\");\n+         if Is_Directory (Get_Name_String (Infile_Name)) then\n+            Input_Directory := Infile_Name;\n+         end if;\n       end if;\n \n-      --  If we had some errors, delete the output file, and report the errors,\n+      --  And process the single input or the files in the directory tree\n+      --  rooted at the input directory.\n \n-      if Err_Vars.Total_Errors_Detected > 0 then\n-         if Outfile /= Standard_Output then\n-            Delete (Text_Outfile);\n-         end if;\n+      Process_Files;\n \n-         Errutil.Finalize (Source_Type => \"input\");\n+   end Gnatprep;\n \n-      --  otherwise, close the output file, and we are done.\n+   ---------------------\n+   -- Is_ASCII_Letter --\n+   ---------------------\n \n-      elsif Outfile /= Standard_Output then\n-         Close (Text_Outfile);\n-      end if;\n-   end Gnatprep;\n+   function Is_ASCII_Letter (C : Character) return Boolean is\n+   begin\n+      return C in 'A' .. 'Z' or else C in 'a' .. 'z';\n+   end Is_ASCII_Letter;\n \n    ------------------------\n    -- New_EOL_To_Outfile --\n@@ -299,6 +309,112 @@ package body GPrep is\n       null;\n    end Post_Scan;\n \n+   ----------------------------\n+   -- Preprocess_Infile_Name --\n+   ----------------------------\n+\n+   procedure Preprocess_Infile_Name is\n+      Len    : Natural;\n+      First  : Positive := 1;\n+      Last   : Natural;\n+      Symbol : Name_Id;\n+      Data   : Symbol_Data;\n+\n+   begin\n+      --  Initialize the buffer with the name of the input file\n+\n+      Get_Name_String (Infile_Name);\n+      Len := Name_Len;\n+\n+      while File_Name_Buffer'Length < Len loop\n+         Double_File_Name_Buffer;\n+      end loop;\n+\n+      File_Name_Buffer (1 .. Len) := Name_Buffer (1 .. Len);\n+\n+      --  Look for possible symbols in the file name\n+\n+      while First < Len loop\n+\n+         --  A symbol starts with a dollar sign followed by a letter\n+\n+         if File_Name_Buffer (First) = '$' and then\n+           Is_ASCII_Letter (File_Name_Buffer (First + 1))\n+         then\n+            Last := First + 1;\n+\n+            --  Find the last letter of the symbol\n+\n+            while Last < Len and then\n+               Is_ASCII_Letter (File_Name_Buffer (Last + 1))\n+            loop\n+               Last := Last + 1;\n+            end loop;\n+\n+            --  Get the symbol name id\n+\n+            Name_Len := Last - First;\n+            Name_Buffer (1 .. Name_Len) :=\n+              File_Name_Buffer (First + 1 .. Last);\n+            To_Lower (Name_Buffer (1 .. Name_Len));\n+            Symbol := Name_Find;\n+\n+            --  And look for this symbol name in the symbol table\n+\n+            for Index in 1 .. Symbol_Table.Last (Mapping) loop\n+               Data := Mapping.Table (Index);\n+\n+               if Data.Symbol = Symbol then\n+\n+                  --  We found the symbol. If its value is not a string,\n+                  --  replace the symbol in the file name with the value of\n+                  --  the symbol.\n+\n+                  if not Data.Is_A_String then\n+                     String_To_Name_Buffer (Data.Value);\n+\n+                     declare\n+                        Sym_Len : constant Positive := Last - First + 1;\n+                        Offset : constant Integer := Name_Len - Sym_Len;\n+                        New_Len : constant Natural := Len + Offset;\n+\n+                     begin\n+                        while New_Len > File_Name_Buffer'Length loop\n+                           Double_File_Name_Buffer;\n+                        end loop;\n+\n+                        File_Name_Buffer (Last + 1 + Offset .. New_Len) :=\n+                          File_Name_Buffer (Last + 1 .. Len);\n+                        Len := New_Len;\n+                        Last := Last + Offset;\n+                        File_Name_Buffer (First .. Last) :=\n+                          Name_Buffer (1 .. Name_Len);\n+                     end;\n+                  end if;\n+\n+                  exit;\n+               end if;\n+            end loop;\n+\n+            --  Skip over the symbol name or its value: we are not checking\n+            --  for another symbol name in the value.\n+\n+            First := Last + 1;\n+\n+         else\n+            First := First + 1;\n+         end if;\n+      end loop;\n+\n+      --  We now have the output file name in the buffer. Get the output\n+      --  path and put it in Outfile_Name.\n+\n+      Get_Name_String (Output_Directory);\n+      Add_Char_To_Name_Buffer (Directory_Separator);\n+      Add_Str_To_Name_Buffer (File_Name_Buffer (1 .. Len));\n+      Outfile_Name := Name_Find;\n+   end Preprocess_Infile_Name;\n+\n    --------------------------------------------\n    -- Process_Command_Line_Symbol_Definition --\n    --------------------------------------------\n@@ -326,6 +442,228 @@ package body GPrep is\n       Mapping.Table (Symbol) := Data;\n    end Process_Command_Line_Symbol_Definition;\n \n+   -------------------\n+   -- Process_Files --\n+   -------------------\n+\n+   procedure Process_Files is\n+\n+      procedure Process_One_File;\n+      --  Process input file Infile_Name and put the result in file\n+      --  Outfile_Name.\n+\n+      procedure Recursive_Process (In_Dir : String; Out_Dir : String);\n+      --  Process recursively files in In_Dir. Results go to Out_Dir.\n+\n+      ----------------------\n+      -- Process_One_File --\n+      ----------------------\n+\n+      procedure Process_One_File is\n+         Infile : Source_File_Index;\n+\n+      begin\n+         --  Create the output file; fails if this does not work.\n+\n+         begin\n+            Create (Text_Outfile, Out_File, Get_Name_String (Outfile_Name));\n+\n+         exception\n+            when others =>\n+               Fail\n+                 (\"unable to create output file \"\"\",\n+                  Get_Name_String (Outfile_Name), \"\"\"\");\n+         end;\n+\n+         --  Load the input file\n+\n+         Infile := Sinput.C.Load_File (Get_Name_String (Infile_Name));\n+\n+         if Infile = No_Source_File then\n+            Fail (\"unable to find input file \"\"\",\n+                  Get_Name_String (Infile_Name), \"\"\"\");\n+         end if;\n+\n+         --  Set Main_Source_File to the input file for the benefit of\n+         --  Errutil.Finalize.\n+\n+         Sinput.Main_Source_File := Infile;\n+\n+         Scanner.Initialize_Scanner (No_Unit, Infile);\n+\n+         --  Output the SFN pragma if asked to\n+\n+         if Source_Ref_Pragma then\n+            Put_Line (Outfile.all, \"pragma Source_Reference (1, \"\"\" &\n+                      Get_Name_String (Sinput.File_Name (Infile)) &\n+                      \"\"\");\");\n+         end if;\n+\n+         --  Preprocess the input file\n+\n+         Prep.Preprocess;\n+\n+         --  In verbose mode, if there is no error, report it\n+\n+         if Opt.Verbose_Mode and then Err_Vars.Total_Errors_Detected = 0 then\n+            Errutil.Finalize (Source_Type => \"input\");\n+         end if;\n+\n+         --  If we had some errors, delete the output file, and report\n+         --  the errors.\n+\n+         if Err_Vars.Total_Errors_Detected > 0 then\n+            if Outfile /= Standard_Output then\n+               Delete (Text_Outfile);\n+            end if;\n+\n+            Errutil.Finalize (Source_Type => \"input\");\n+\n+            OS_Exit (0);\n+\n+         --  otherwise, close the output file, and we are done.\n+\n+         elsif Outfile /= Standard_Output then\n+            Close (Text_Outfile);\n+         end if;\n+      end Process_One_File;\n+\n+      -----------------------\n+      -- Recursive_Process --\n+      -----------------------\n+\n+      procedure Recursive_Process (In_Dir : String; Out_Dir : String) is\n+         Dir_In : Dir_Type;\n+         Name : String (1 .. 255);\n+         Last : Natural;\n+         In_Dir_Name  : Name_Id;\n+         Out_Dir_Name : Name_Id;\n+\n+         procedure Set_Directory_Names;\n+         --  Establish or reestablish the current input and output directories\n+\n+         -------------------------\n+         -- Set_Directory_Names --\n+         -------------------------\n+\n+         procedure Set_Directory_Names is\n+         begin\n+            Input_Directory := In_Dir_Name;\n+            Output_Directory := Out_Dir_Name;\n+         end Set_Directory_Names;\n+\n+      begin\n+         --  Open the current input directory\n+\n+         begin\n+            Open (Dir_In, In_Dir);\n+\n+         exception\n+            when Directory_Error =>\n+               Fail (\"could not read directory \" & In_Dir);\n+         end;\n+\n+         --  Set the new input and output directory names\n+\n+         Name_Len := In_Dir'Length;\n+         Name_Buffer (1 .. Name_Len) := In_Dir;\n+         In_Dir_Name := Name_Find;\n+         Name_Len := Out_Dir'Length;\n+         Name_Buffer (1 .. Name_Len) := Out_Dir;\n+         Out_Dir_Name := Name_Find;\n+\n+         Set_Directory_Names;\n+\n+         --  Traverse the input directory\n+         loop\n+            Read (Dir_In, Name, Last);\n+            exit when Last = 0;\n+\n+            if Name (1 .. Last) /= \".\" and then Name (1 .. Last) /= \"..\" then\n+               declare\n+                  Input : constant String :=\n+                            In_Dir & Directory_Separator & Name (1 .. Last);\n+                  Output : constant String :=\n+                             Out_Dir & Directory_Separator & Name (1 .. Last);\n+\n+               begin\n+                  --  If input is an ordinary file, process it\n+\n+                  if Is_Regular_File (Input) then\n+                     --  First get the output file name\n+\n+                     Name_Len := Last;\n+                     Name_Buffer (1 .. Name_Len) := Name (1 .. Last);\n+                     Infile_Name := Name_Find;\n+                     Preprocess_Infile_Name;\n+\n+                     --  Set the input file name and process the file\n+\n+                     Name_Len := Input'Length;\n+                     Name_Buffer (1 .. Name_Len) := Input;\n+                     Infile_Name := Name_Find;\n+                     Process_One_File;\n+\n+                  elsif Is_Directory (Input) then\n+                     --  Input is a directory. If the corresponding output\n+                     --  directory does not already exist, create it.\n+\n+                     if not Is_Directory (Output) then\n+                        begin\n+                           Make_Dir (Dir_Name => Output);\n+\n+                        exception\n+                           when Directory_Error =>\n+                              Fail (\"could not create directory \"\"\",\n+                                    Output, \"\"\"\");\n+                        end;\n+                     end if;\n+\n+                     --  And process this new input directory\n+\n+                     Recursive_Process (Input, Output);\n+\n+                     --  Reestablish the input and output directory names\n+                     --  that have been modified by the recursive call.\n+\n+                     Set_Directory_Names;\n+                  end if;\n+               end;\n+            end if;\n+         end loop;\n+      end Recursive_Process;\n+\n+   begin\n+      if Output_Directory = No_Name then\n+         --  If the output is not a directory, fail if the input is\n+         --  an existing directory, to avoid possible problems.\n+\n+         if Is_Directory (Get_Name_String (Infile_Name)) then\n+            Fail (\"input file \"\"\" & Get_Name_String (Infile_Name) &\n+                  \"\"\" is a directory\");\n+         end if;\n+\n+         --  Just process the single input file\n+\n+         Process_One_File;\n+\n+      elsif Input_Directory = No_Name then\n+         --  Get the output file name from the input file name, and process\n+         --  the single input file.\n+\n+         Preprocess_Infile_Name;\n+         Process_One_File;\n+\n+      else\n+         --  Recursively process files in the directory tree rooted at the\n+         --  input directory.\n+\n+         Recursive_Process\n+           (In_Dir => Get_Name_String (Input_Directory),\n+            Out_Dir => Get_Name_String (Output_Directory));\n+      end if;\n+   end Process_Files;\n+\n    -------------------------\n    -- Put_Char_To_Outfile --\n    -------------------------\n@@ -397,12 +735,15 @@ package body GPrep is\n          begin\n             exit when S'Length = 0;\n \n-            if Infile_Name = null then\n-               Infile_Name := new String'(S);\n-            elsif Outfile_Name = null then\n-               Outfile_Name := new String'(S);\n-            elsif Deffile_Name = null then\n-               Deffile_Name := new String'(S);\n+            Name_Len := S'Length;\n+            Name_Buffer (1 .. Name_Len) := S;\n+\n+            if Infile_Name = No_Name then\n+               Infile_Name := Name_Find;\n+            elsif Outfile_Name = No_Name then\n+               Outfile_Name := Name_Find;\n+            elsif Deffile_Name = No_Name then\n+               Deffile_Name := Name_Find;\n             else\n                Fail (\"too many arguments specifed\");\n             end if;"}, {"sha": "5fd829039c364dfa9302c8bc6d12381df1d9d4ef", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -335,6 +335,7 @@ package body Prj.Env is\n       --  Check if the directory is already in the table\n \n       for Index in 1 .. Object_Paths.Last loop\n+\n          --  If it is, remove it, and add it as the last one\n \n          if Object_Paths.Table (Index) = Object_Dir then\n@@ -361,7 +362,6 @@ package body Prj.Env is\n    procedure Add_To_Path (Source_Dirs : String_List_Id) is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n-\n    begin\n       while Current /= Nil_String loop\n          Source_Dir := String_Elements.Table (Current);\n@@ -384,8 +384,10 @@ package body Prj.Env is\n \n       function Is_Present (Path : String; Dir : String) return Boolean is\n          Last : constant Integer := Path'Last - Dir'Length + 1;\n+\n       begin\n          for J in Path'First .. Last loop\n+\n             --  Note: the order of the conditions below is important, since\n             --  it ensures a minimal number of string comparisons.\n \n@@ -403,8 +405,11 @@ package body Prj.Env is\n          return False;\n       end Is_Present;\n \n+   --  Start of processing for Add_To_Path\n+\n    begin\n       if Is_Present (Ada_Path_Buffer (1 .. Ada_Path_Length), Dir) then\n+\n          --  Dir is already in the path, nothing to do\n \n          return;\n@@ -413,6 +418,7 @@ package body Prj.Env is\n       Min_Len := Ada_Path_Length + Dir'Length;\n \n       if Ada_Path_Length > 0 then\n+\n          --  Add 1 for the Path_Separator character\n \n          Min_Len := Min_Len + 1;\n@@ -535,7 +541,7 @@ package body Prj.Env is\n          end;\n       end if;\n \n-      --  Returned the value stored\n+      --  Returned the stored value\n \n       return Namet.Get_Name_String (Data.File_Names (Body_Part).Path);\n    end Body_Path_Name_Of;\n@@ -566,6 +572,7 @@ package body Prj.Env is\n       --  For call to Close\n \n       procedure Check (Project : Project_Id);\n+      --  ??? requires a comment\n \n       procedure Check_Temp_File;\n       --  Check that a temporary file has been opened.\n@@ -576,11 +583,11 @@ package body Prj.Env is\n         (Unit_Name : Name_Id;\n          File_Name : Name_Id;\n          Unit_Kind : Spec_Or_Body);\n-      --  Put an SFN pragma in the temporary file.\n+      --  Put an SFN pragma in the temporary file\n \n       procedure Put (File : File_Descriptor; S : String);\n-\n       procedure Put_Line (File : File_Descriptor; S : String);\n+      --  Output procedures, analogous to normal Text_IO procs of same name\n \n       -----------\n       -- Check --\n@@ -1045,7 +1052,6 @@ package body Prj.Env is\n       if not Status then\n          Prj.Com.Fail (\"disk full\");\n       end if;\n-\n    end Create_Mapping_File;\n \n    --------------------------\n@@ -1163,7 +1169,8 @@ package body Prj.Env is\n       --  this loop will be run only once.\n \n       loop\n-         --  For every unit\n+         --  Loop through units\n+         --  Should have comment explaining reverse ???\n \n          for Current in reverse Units.First .. Units.Last loop\n             Unit := Units.Table (Current);\n@@ -1175,7 +1182,7 @@ package body Prj.Env is\n             then\n                declare\n                   Current_Name : constant Name_Id :=\n-                    Unit.File_Names (Body_Part).Name;\n+                                   Unit.File_Names (Body_Part).Name;\n \n                begin\n                   --  Case of a body present\n@@ -1238,7 +1245,7 @@ package body Prj.Env is\n             then\n                declare\n                   Current_Name : constant Name_Id :=\n-                    Unit.File_Names (Specification).Name;\n+                                   Unit.File_Names (Specification).Name;\n \n                begin\n                   --  Case of spec present\n@@ -1251,8 +1258,7 @@ package body Prj.Env is\n                         Write_Eol;\n                      end if;\n \n-                     --  If name same as the original name, return original\n-                     --  name.\n+                     --  If name same as original name, return original name\n \n                      if Unit.Name = The_Original_Name\n                        or else Current_Name = The_Original_Name\n@@ -1265,7 +1271,6 @@ package body Prj.Env is\n                         if Full_Path then\n                            return Get_Name_String\n                              (Unit.File_Names (Specification).Path);\n-\n                         else\n                            return Get_Name_String (Current_Name);\n                         end if;\n@@ -1281,7 +1286,6 @@ package body Prj.Env is\n                         if Full_Path then\n                            return Get_Name_String\n                              (Unit.File_Names (Specification).Path);\n-\n                         else\n                            return Extended_Spec_Name;\n                         end if;\n@@ -1509,6 +1513,8 @@ package body Prj.Env is\n       Path             : out Name_Id)\n    is\n    begin\n+      --  Body below could use some comments ???\n+\n       if Current_Verbosity > Default then\n          Write_Str (\"Getting Reference_Of (\"\"\");\n          Write_Str (Source_File_Name);\n@@ -1566,7 +1572,6 @@ package body Prj.Env is\n \n                return;\n             end if;\n-\n          end loop;\n       end;\n \n@@ -1583,22 +1588,25 @@ package body Prj.Env is\n    -- Initialize --\n    ----------------\n \n+   --  This is a place holder for possible required initialization in\n+   --  the future. In the current version no initialization is required.\n+\n    procedure Initialize is\n    begin\n-      --  There is nothing to do anymore\n-\n       null;\n    end Initialize;\n \n    ------------------------------------\n    -- Path_Name_Of_Library_Unit_Body --\n    ------------------------------------\n \n+   --  Could use some comments in the body here ???\n+\n    function Path_Name_Of_Library_Unit_Body\n      (Name    : String;\n       Project : Project_Id) return String\n    is\n-      Data : constant Project_Data := Projects.Table (Project);\n+      Data          : constant Project_Data := Projects.Table (Project);\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n@@ -1699,7 +1707,6 @@ package body Prj.Env is\n                   return Spec_Path_Name_Of (Current);\n \n                elsif Current_Name = Extended_Spec_Name then\n-\n                   if Current_Verbosity = High then\n                      Write_Line (\"   OK\");\n                   end if;\n@@ -1723,6 +1730,8 @@ package body Prj.Env is\n    -- Print_Sources --\n    -------------------\n \n+   --  Could use some comments in this body ???\n+\n    procedure Print_Sources is\n       Unit : Unit_Data;\n \n@@ -1769,7 +1778,6 @@ package body Prj.Env is\n               (Namet.Get_Name_String\n                (Unit.File_Names (Body_Part).Name));\n          end if;\n-\n       end loop;\n \n       Write_Line (\"end of List of Sources.\");\n@@ -2070,8 +2078,8 @@ package body Prj.Env is\n       --  Set the env vars, if they need to be changed, and set the\n       --  corresponding flags.\n \n-      if\n-        Current_Source_Path_File /= Projects.Table (Project).Include_Path_File\n+      if Current_Source_Path_File /=\n+           Projects.Table (Project).Include_Path_File\n       then\n          Current_Source_Path_File :=\n            Projects.Table (Project).Include_Path_File;\n@@ -2192,6 +2200,9 @@ package body Prj.Env is\n       return Result;\n    end Ultimate_Extension_Of;\n \n+--  Package initialization\n+--  What is relationshiop to procedure Initialize\n+\n begin\n    Path_Files.Set_Last (0);\n end Prj.Env;"}, {"sha": "e5e6bf9be3976aad5fd67e82038611a3a6daaeca", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc        --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ package Prj.Env is\n \n    procedure Initialize;\n    --  Put Standard_Naming_Data into Namings table (called by Prj.Initialize)\n+   --  Above comment is obsolete (see body) ???\n \n    procedure Print_Sources;\n    --  Output the list of sources, after Project files have been scanned"}, {"sha": "5d130714d934574bb2099a71aad30c99be39bb57", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -29,6 +29,10 @@\n \n private package Prj.Nmsc is\n \n+   --  It would be nicer to have a higher level statement of what these\n+   --  procedures do (related to their names), rather than just an english\n+   --  language summary of the implementation ???\n+\n    procedure Ada_Check\n      (Project      : Project_Id;\n       Report_Error : Put_Line_Access;\n@@ -48,7 +52,7 @@ private package Prj.Nmsc is\n       Report_Error : Put_Line_Access);\n    --  Check the object directory and the source directories.\n    --  Check the library attributes, including the library directory if any.\n-   --  Get the set of specification and implementation suffixs, if any.\n+   --  Get the set of specification and implementation suffixes, if any.\n    --  If Report_Error is null , use the standard error reporting mechanism\n    --  (Errout). Otherwise, report errors using Report_Error.\n "}, {"sha": "2d0cf4499102d770318e0c5236a7e7e81a6e06b9", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -41,9 +41,11 @@ package Prj.Proc is\n    --  Process a project file tree into project file data structures.\n    --  If Report_Error is null, use the error reporting mechanism.\n    --  Otherwise, report errors using Report_Error.\n+   --\n    --  If Trusted_Mode is True, it is assumed that the project doesn't contain\n    --  any file duplicated through symbolic links (although the latter are\n    --  still valid if they point to a file which is outside of the project),\n    --  and that no directory has a name which is a valid source name.\n+   --  Process is a bit of a junk name, how about Process_Project_Tree???\n \n end Prj.Proc;"}, {"sha": "e95fb2dbfe3221f417e3e70a2e9e60a6a478028c", "filename": "gcc/ada/s-stache.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fs-stache.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fs-stache.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stache.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -31,5 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  As noted in the spec, this dummy body is present because otherwise we\n+--  have bootstrapping path problems (there used to be a real body).\n+\n package body System.Stack_Checking is\n end System.Stack_Checking;"}, {"sha": "1e77df20968c3a2fff0f31201b66ec889d837c0c", "filename": "gcc/ada/s-stache.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fs-stache.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fs-stache.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stache.ads?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -33,15 +33,19 @@\n \n --  This package provides a system-independent implementation of stack\n --  checking using comparison with stack base and limit.\n---  This package defines basic types and objects. Operations related\n---  to stack checking can be found in package\n---  System.Stack_Checking.Operations.\n+\n+--  This package defines basic types and objects. Operations related to\n+--  stack checking can be found in package System.Stack_Checking.Operations.\n \n with System.Storage_Elements;\n \n package System.Stack_Checking is\n \n    pragma Elaborate_Body;\n+   --  This unit has a junk null body. The reason is that historically we\n+   --  used to have a real body, and it causes bootstrapping path problems\n+   --  to eliminate it, since the old body may still be present in the\n+   --  compilation environment for a build.\n \n    type Stack_Info is record\n       Limit : System.Address := System.Null_Address;"}, {"sha": "0398551d5dd0c76c5e2b527a51eb7fe0ebf1c55d", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -134,8 +134,15 @@ package body Scn is\n          SS : Source_Ptr;\n \n       begin\n+         --  Loop to check characters. This loop is terminated by end of\n+         --  line, and also we need to check for the EOF case, to take\n+         --  care of files containing only comments.\n+\n          SP := Scan_Ptr;\n-         while Source (SP) /= CR and then Source (SP) /= LF loop\n+         while Source (SP) /= CR and then\n+               Source (SP) /= LF and then\n+               Source (SP) /= EOF\n+         loop\n             if Source (SP) = S (S'First) then\n                SS := SP;\n                CP := S'First;"}, {"sha": "c821c7c2fc07852ab9ebf21d5aef0b155417dc34", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -394,7 +394,9 @@ package body Sem_Ch10 is\n                if Unum /= No_Unit then\n \n                   --  Build subprogram declaration and attach parent unit to it\n-                  --  This subprogram declaration does not come from source!\n+                  --  This subprogram declaration does not come from source,\n+                  --  Nevertheless the backend must generate debugging info for\n+                  --  it, and this must be indicated explicitly.\n \n                   declare\n                      Loc : constant Source_Ptr := Sloc (N);\n@@ -418,6 +420,7 @@ package body Sem_Ch10 is\n                      Set_Parent_Spec (Unit (Lib_Unit), Cunit (Unum));\n                      Semantics (Lib_Unit);\n                      Set_Acts_As_Spec (N, False);\n+                     Set_Needs_Debug_Info (Defining_Entity (Unit (Lib_Unit)));\n                      Set_Comes_From_Source_Default (SCS);\n                   end;\n                end if;"}, {"sha": "11483c3def74356c9adefc8b7b0cd2d93ec14906", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -6586,11 +6586,15 @@ package body Sem_Ch3 is\n            (Full, Related_Nod, Full_Base, Discriminant_Constraint (Priv));\n \n       --  If the full base is itself derived from private, build a congruent\n-      --  subtype of its underlying type, for use by the back end.\n+      --  subtype of its underlying type, for use by the back end. Do not\n+      --  do this for a constrained record component, where the back-end has\n+      --  the proper information and there is no place for the declaration.\n \n       elsif Ekind (Full_Base) in Private_Kind\n         and then Is_Derived_Type (Full_Base)\n         and then Has_Discriminants (Full_Base)\n+        and then Nkind (Related_Nod) /= N_Component_Declaration\n+        and then (Ekind (Current_Scope) /= E_Record_Subtype)\n         and then\n           Nkind (Subtype_Indication (Parent (Priv))) = N_Subtype_Indication\n       then\n@@ -7324,6 +7328,7 @@ package body Sem_Ch3 is\n            Make_Subtype_Declaration (Loc,\n              Defining_Identifier => Def_Id,\n              Subtype_Indication  => Indic);\n+\n          Set_Parent (Subtyp_Decl, Parent (Related_Node));\n \n          --  Itypes must be analyzed with checks off (see itypes.ads)."}, {"sha": "138248507d8029bb0f104ade8e1836b649959689", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -1788,10 +1788,14 @@ package body Sem_Ch6 is\n       --  the actuals at the point of inlining, i.e. instantiation. To treat\n       --  the formals as globals to the body to inline, we nest it within\n       --  a dummy parameterless subprogram, declared within the real one.\n+      --  To avoid generating an internal name (which is never public, and\n+      --  which affects serial numbers of other generated names), we use\n+      --  an internal symbol that cannot conflict with user declarations.\n \n       Set_Parameter_Specifications (Specification (Original_Body), No_List);\n-      Set_Defining_Unit_Name (Specification (Original_Body),\n-        Make_Defining_Identifier (Sloc (N), New_Internal_Name ('S')));\n+      Set_Defining_Unit_Name\n+        (Specification (Original_Body),\n+          Make_Defining_Identifier (Sloc (N), Name_uParent));\n       Set_Corresponding_Spec (Original_Body, Empty);\n \n       Body_To_Analyze := Copy_Generic_Node (Original_Body, Empty, False);"}, {"sha": "02190ca20cc1b57d9ceabdcd8ab59a72760f6564", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24105bab8c2cf186720770b33176f0880136fa68/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=24105bab8c2cf186720770b33176f0880136fa68", "patch": "@@ -3786,6 +3786,13 @@ package body Sem_Util is\n             when N_Explicit_Dereference =>\n                return True;\n \n+            --  A view conversion of a tagged object is an object reference.\n+\n+            when N_Type_Conversion =>\n+               return Is_Tagged_Type (Etype (Subtype_Mark (N)))\n+                 and then Is_Tagged_Type (Etype (Expression (N)))\n+                 and then Is_Object_Reference (Expression (N));\n+\n             --  An unchecked type conversion is considered to be an object if\n             --  the operand is an object (this construction arises only as a\n             --  result of expansion activities)."}]}