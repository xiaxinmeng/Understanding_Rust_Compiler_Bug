{"sha": "9af354b715de4ee982fe21d22a182cf131eef83c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmMzU0YjcxNWRlNGVlOTgyZmUyMWQyMmExODJjZjEzMWVlZjgzYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-08T09:56:25Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-08T09:56:25Z"}, "message": "Update docs for USE rtx.\n\nFrom-SVN: r36265", "tree": {"sha": "baef474dd526fbc321ad957822405beb6f3c2a21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baef474dd526fbc321ad957822405beb6f3c2a21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af354b715de4ee982fe21d22a182cf131eef83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af354b715de4ee982fe21d22a182cf131eef83c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af354b715de4ee982fe21d22a182cf131eef83c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af354b715de4ee982fe21d22a182cf131eef83c/comments", "author": null, "committer": null, "parents": [{"sha": "ce701d1bd7218c2c055840da396761814cf2fdf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce701d1bd7218c2c055840da396761814cf2fdf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce701d1bd7218c2c055840da396761814cf2fdf6"}], "stats": {"total": 30, "additions": 30, "deletions": 0}, "files": [{"sha": "794cf5da5dd95ec0ebb953c317d3ab3477382840", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af354b715de4ee982fe21d22a182cf131eef83c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af354b715de4ee982fe21d22a182cf131eef83c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9af354b715de4ee982fe21d22a182cf131eef83c", "patch": "@@ -2,6 +2,8 @@\n \n \t* combine.c (combine_simplify_rtx): Try to simplify VEC_SELECT of a\n \tVEC_CONCAT.\n+\t* rtl.texi (description of USE): Add note about possible pitfalls\n+\twith this rtx.\n \tFrom Richard Henderson:\n \t* reload1.c (choose_reload_regs): Compute need_mode properly.\n "}, {"sha": "17dea1ae2ec2b157c5bff40682fe0ceb2d6e768b", "filename": "gcc/rtl.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af354b715de4ee982fe21d22a182cf131eef83c/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af354b715de4ee982fe21d22a182cf131eef83c/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=9af354b715de4ee982fe21d22a182cf131eef83c", "patch": "@@ -2057,6 +2057,34 @@ it may not be apparent why this is so.  Therefore, the compiler will\n not attempt to delete previous instructions whose only effect is to\n store a value in @var{x}.  @var{x} must be a @code{reg} expression.\n \n+In some situations, it may be tempting to add a @code{use} of a\n+register in a @code{parallel} to describe a situation where the value\n+of a special register will modify the behaviour of the instruction.\n+An hypothetical example might be a pattern for an addition that can\n+either wrap around or use saturating addition depending on the value\n+of a special control register:\n+\n+@example\n+(parallel [(set (reg:SI 2) (unspec:SI [(reg:SI 3) (reg:SI 4)] 0))\n+           (use (reg:SI 1))])\n+@end example\n+\n+@noindent\n+\n+This will not work, several of the optimizers only look at expressions\n+locally; it is very likely that if you have multiple insns with\n+identical inputs to the @code{unspec}, they will be optimized away even\n+if register 1 changes in between.\n+\n+This means that @code{use} can @emph{only} be used to describe\n+that the register is live.  You should think twice before adding\n+@code{use} statements, more often you will want to use @code{unspec}\n+instead.  The @code{use} RTX is most commonly useful to describe that\n+a fixed register is implicitly used in an insn.  It is also safe to use\n+in patterns where the compiler knows for other reasons that the result\n+of the whole pattern is variable, such as @samp{movstr@var{m}} or\n+@samp{call} patterns.\n+\n During the reload phase, an insn that has a @code{use} as pattern\n can carry a reg_equal note.  These @code{use} insns will be deleted\n before the reload phase exits."}]}