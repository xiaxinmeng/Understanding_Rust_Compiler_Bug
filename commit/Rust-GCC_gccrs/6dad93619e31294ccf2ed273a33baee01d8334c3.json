{"sha": "6dad93619e31294ccf2ed273a33baee01d8334c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRhZDkzNjE5ZTMxMjk0Y2NmMmVkMjczYTMzYmFlZTAxZDgzMzRjMw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-04-28T04:47:09Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-28T04:47:09Z"}, "message": "remove #if ARGS_GROW_DOWNWARD\n\ngcc/ChangeLog:\n\n2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* calls.c (save_fixed_argument_area): Don't check\n\tARGS_GROW_DOWNWARD with the preprocessor.\n\t(restore_fixed_argument_area): Likewise.\n\t(mem_overlaps_already_clobbered_arg_p): Likewise.\n\t(check_sibcall_argument_overlap): Likewise.\n\t(expand_call): Likewise.\n\t(emit_library_call_value_1): Likewise.\n\t(store_one_arg): Likewise.\n\t* function.c (assign_parms): Likewise.\n\t(locate_and_pad_parm): Likewise.\n\t(pad_to_arg_alignment): Likewise.\n\t* targhooks.c (std_gimplify_va_arg_expr): Likewise.\n\nFrom-SVN: r222508", "tree": {"sha": "281921c3c1d8ed04317c3568e7828cb1d7973513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/281921c3c1d8ed04317c3568e7828cb1d7973513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dad93619e31294ccf2ed273a33baee01d8334c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dad93619e31294ccf2ed273a33baee01d8334c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dad93619e31294ccf2ed273a33baee01d8334c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dad93619e31294ccf2ed273a33baee01d8334c3/comments", "author": null, "committer": null, "parents": [{"sha": "376bddabe1ebdedbc0a99341f5b6a927fd40563f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/376bddabe1ebdedbc0a99341f5b6a927fd40563f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/376bddabe1ebdedbc0a99341f5b6a927fd40563f"}], "stats": {"total": 290, "additions": 155, "deletions": 135}, "files": [{"sha": "1ffe147b0cd8b7cf91c2899f64a94f932e34521a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dad93619e31294ccf2ed273a33baee01d8334c3", "patch": "@@ -1,3 +1,18 @@\n+2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* calls.c (save_fixed_argument_area): Don't check\n+\tARGS_GROW_DOWNWARD with the preprocessor.\n+\t(restore_fixed_argument_area): Likewise.\n+\t(mem_overlaps_already_clobbered_arg_p): Likewise.\n+\t(check_sibcall_argument_overlap): Likewise.\n+\t(expand_call): Likewise.\n+\t(emit_library_call_value_1): Likewise.\n+\t(store_one_arg): Likewise.\n+\t* function.c (assign_parms): Likewise.\n+\t(locate_and_pad_parm): Likewise.\n+\t(pad_to_arg_alignment): Likewise.\n+\t* targhooks.c (std_gimplify_va_arg_expr): Likewise.\n+\n 2015-04-27  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* config/pa/pa.h (ARGS_GROW_DOWNWARD): Define to 1."}, {"sha": "caa7d6070597db7b318e2daf1753d854c51b8ad1", "filename": "gcc/calls.c", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6dad93619e31294ccf2ed273a33baee01d8334c3", "patch": "@@ -948,9 +948,9 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n \n   /* Compute the boundary of the area that needs to be saved, if any.  */\n   high = reg_parm_stack_space;\n-#if ARGS_GROW_DOWNWARD\n-  high += 1;\n-#endif\n+  if (ARGS_GROW_DOWNWARD)\n+    high += 1;\n+\n   if (high > highest_outgoing_arg_in_use)\n     high = highest_outgoing_arg_in_use;\n \n@@ -979,11 +979,11 @@ save_fixed_argument_area (int reg_parm_stack_space, rtx argblock, int *low_to_sa\n \t\t\t BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n \t  save_mode = BLKmode;\n \n-#if ARGS_GROW_DOWNWARD\n-\tdelta = -high;\n-#else\n-\tdelta = low;\n-#endif\n+\tif (ARGS_GROW_DOWNWARD)\n+\t  delta = -high;\n+\telse\n+\t  delta = low;\n+\n \taddr = plus_constant (Pmode, argblock, delta);\n \tstack_area = gen_rtx_MEM (save_mode, memory_address (save_mode, addr));\n \n@@ -1013,11 +1013,11 @@ restore_fixed_argument_area (rtx save_area, rtx argblock, int high_to_save, int\n   int delta;\n   rtx addr, stack_area;\n \n-#if ARGS_GROW_DOWNWARD\n-  delta = -high_to_save;\n-#else\n-  delta = low_to_save;\n-#endif\n+  if (ARGS_GROW_DOWNWARD)\n+    delta = -high_to_save;\n+  else\n+    delta = low_to_save;\n+\n   addr = plus_constant (Pmode, argblock, delta);\n   stack_area = gen_rtx_MEM (save_mode, memory_address (save_mode, addr));\n   set_mem_align (stack_area, PARM_BOUNDARY);\n@@ -1980,9 +1980,9 @@ mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n   i += crtl->args.pretend_args_size;\n #endif\n \n-#if ARGS_GROW_DOWNWARD\n-  i = -i - size;\n-#endif\n+  if (ARGS_GROW_DOWNWARD)\n+    i = -i - size;\n+\n   if (size > 0)\n     {\n       unsigned HOST_WIDE_INT k;\n@@ -2286,11 +2286,10 @@ check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n \n   if (mark_stored_args_map)\n     {\n-#if ARGS_GROW_DOWNWARD\n-      low = -arg->locate.slot_offset.constant - arg->locate.size.constant;\n-#else\n-      low = arg->locate.slot_offset.constant;\n-#endif\n+      if (ARGS_GROW_DOWNWARD)\n+\tlow = -arg->locate.slot_offset.constant - arg->locate.size.constant;\n+      else\n+\tlow = arg->locate.slot_offset.constant;\n \n       for (high = low + arg->locate.size.constant; low < high; low++)\n \tbitmap_set_bit (stored_args_map, low);\n@@ -2979,13 +2978,13 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \t\t    needed += reg_parm_stack_space;\n \n-#if ARGS_GROW_DOWNWARD\n-\t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t\t     needed + 1);\n-#else\n-\t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t\t     needed);\n-#endif\n+\t\t  if (ARGS_GROW_DOWNWARD)\n+\t\t    highest_outgoing_arg_in_use\n+\t\t      = MAX (initial_highest_arg_in_use, needed + 1);\n+\t\t  else\n+\t\t    highest_outgoing_arg_in_use\n+\t\t      = MAX (initial_highest_arg_in_use, needed);\n+\n \t\t  free (stack_usage_map_buf);\n \t\t  stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n \t\t  stack_usage_map = stack_usage_map_buf;\n@@ -3047,9 +3046,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  else\n \t\t    {\n \t\t      argblock = push_block (GEN_INT (needed), 0, 0);\n-#if ARGS_GROW_DOWNWARD\n-\t\t      argblock = plus_constant (Pmode, argblock, needed);\n-#endif\n+\t\t      if (ARGS_GROW_DOWNWARD)\n+\t\t\targblock = plus_constant (Pmode, argblock, needed);\n \t\t    }\n \n \t\t  /* We only really need to call `copy_to_reg' in the case\n@@ -4122,13 +4120,12 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \tneeded += reg_parm_stack_space;\n \n-#if ARGS_GROW_DOWNWARD\n-      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t needed + 1);\n-#else\n-      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t needed);\n-#endif\n+      if (ARGS_GROW_DOWNWARD)\n+\thighest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t   needed + 1);\n+      else\n+\thighest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use, needed);\n+\n       stack_usage_map_buf = XNEWVEC (char, highest_outgoing_arg_in_use);\n       stack_usage_map = stack_usage_map_buf;\n \n@@ -4213,15 +4210,18 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t      /* If this is being stored into a pre-allocated, fixed-size,\n \t\t stack area, save any previous data at that location.  */\n \n-#if ARGS_GROW_DOWNWARD\n-\t      /* stack_slot is negative, but we want to index stack_usage_map\n-\t\t with positive values.  */\n-\t      upper_bound = -argvec[argnum].locate.slot_offset.constant + 1;\n-\t      lower_bound = upper_bound - argvec[argnum].locate.size.constant;\n-#else\n-\t      lower_bound = argvec[argnum].locate.slot_offset.constant;\n-\t      upper_bound = lower_bound + argvec[argnum].locate.size.constant;\n-#endif\n+\t      if (ARGS_GROW_DOWNWARD)\n+\t\t{\n+\t\t  /* stack_slot is negative, but we want to index stack_usage_map\n+\t\t     with positive values.  */\n+\t\t  upper_bound = -argvec[argnum].locate.slot_offset.constant + 1;\n+\t\t  lower_bound = upper_bound - argvec[argnum].locate.size.constant;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  lower_bound = argvec[argnum].locate.slot_offset.constant;\n+\t\t  upper_bound = lower_bound + argvec[argnum].locate.size.constant;\n+\t\t}\n \n \t      i = lower_bound;\n \t      /* Don't worry about things in the fixed argument area;\n@@ -4702,23 +4702,26 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n \t save any previous data at that location.  */\n       if (argblock && ! variable_size && arg->stack)\n \t{\n-#if ARGS_GROW_DOWNWARD\n-\t  /* stack_slot is negative, but we want to index stack_usage_map\n-\t     with positive values.  */\n-\t  if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\t    upper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n-\t  else\n-\t    upper_bound = 0;\n+\t  if (ARGS_GROW_DOWNWARD)\n+\t    {\n+\t      /* stack_slot is negative, but we want to index stack_usage_map\n+\t\t with positive values.  */\n+\t      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\t\tupper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n+\t      else\n+\t\tupper_bound = 0;\n \n-\t  lower_bound = upper_bound - arg->locate.size.constant;\n-#else\n-\t  if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\t    lower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n+\t      lower_bound = upper_bound - arg->locate.size.constant;\n+\t    }\n \t  else\n-\t    lower_bound = 0;\n+\t    {\n+\t      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\t\tlower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n+\t      else\n+\t\tlower_bound = 0;\n \n-\t  upper_bound = lower_bound + arg->locate.size.constant;\n-#endif\n+\t      upper_bound = lower_bound + arg->locate.size.constant;\n+\t    }\n \n \t  i = lower_bound;\n \t  /* Don't worry about things in the fixed argument area;"}, {"sha": "d1a2c0a26b328889b49ccc0249954f65e0e96950", "filename": "gcc/function.c", "status": "modified", "additions": 74, "deletions": 71, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6dad93619e31294ccf2ed273a33baee01d8334c3", "patch": "@@ -3771,15 +3771,16 @@ assign_parms (tree fndecl)\n   crtl->args.size = CEIL_ROUND (crtl->args.size,\n \t\t\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n \n-#if ARGS_GROW_DOWNWARD\n-  crtl->args.arg_offset_rtx\n-    = (all.stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n-       : expand_expr (size_diffop (all.stack_args_size.var,\n-\t\t\t\t   size_int (-all.stack_args_size.constant)),\n-\t\t      NULL_RTX, VOIDmode, EXPAND_NORMAL));\n-#else\n-  crtl->args.arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n-#endif\n+  if (ARGS_GROW_DOWNWARD)\n+    {\n+      crtl->args.arg_offset_rtx\n+\t= (all.stack_args_size.var == 0 ? GEN_INT (-all.stack_args_size.constant)\n+\t   : expand_expr (size_diffop (all.stack_args_size.var,\n+\t\t\t\t       size_int (-all.stack_args_size.constant)),\n+\t\t\t  NULL_RTX, VOIDmode, EXPAND_NORMAL));\n+    }\n+  else\n+    crtl->args.arg_offset_rtx = ARGS_SIZE_RTX (all.stack_args_size);\n \n   /* See how many bytes, if any, of its args a function should try to pop\n      on return.  */\n@@ -4070,68 +4071,71 @@ locate_and_pad_parm (machine_mode passed_mode, tree type, int in_regs,\n   if (crtl->preferred_stack_boundary < boundary)\n     crtl->preferred_stack_boundary = boundary;\n \n-#if ARGS_GROW_DOWNWARD\n-  locate->slot_offset.constant = -initial_offset_ptr->constant;\n-  if (initial_offset_ptr->var)\n-    locate->slot_offset.var = size_binop (MINUS_EXPR, ssize_int (0),\n-\t\t\t\t\t  initial_offset_ptr->var);\n+  if (ARGS_GROW_DOWNWARD)\n+    {\n+      locate->slot_offset.constant = -initial_offset_ptr->constant;\n+      if (initial_offset_ptr->var)\n+\tlocate->slot_offset.var = size_binop (MINUS_EXPR, ssize_int (0),\n+\t\t\t\t\t      initial_offset_ptr->var);\n \n-  {\n-    tree s2 = sizetree;\n-    if (where_pad != none\n-\t&& (!tree_fits_uhwi_p (sizetree)\n-\t    || (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n-      s2 = round_up (s2, round_boundary / BITS_PER_UNIT);\n-    SUB_PARM_SIZE (locate->slot_offset, s2);\n-  }\n+\t{\n+\t  tree s2 = sizetree;\n+\t  if (where_pad != none\n+\t      && (!tree_fits_uhwi_p (sizetree)\n+\t\t  || (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n+\t    s2 = round_up (s2, round_boundary / BITS_PER_UNIT);\n+\t  SUB_PARM_SIZE (locate->slot_offset, s2);\n+\t}\n+\n+      locate->slot_offset.constant += part_size_in_regs;\n+\n+      if (!in_regs || reg_parm_stack_space > 0)\n+\tpad_to_arg_alignment (&locate->slot_offset, boundary,\n+\t\t\t      &locate->alignment_pad);\n+\n+      locate->size.constant = (-initial_offset_ptr->constant\n+\t\t\t       - locate->slot_offset.constant);\n+      if (initial_offset_ptr->var)\n+\tlocate->size.var = size_binop (MINUS_EXPR,\n+\t\t\t\t       size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t   ssize_int (0),\n+\t\t\t\t\t\t   initial_offset_ptr->var),\n+\t\t\t\t       locate->slot_offset.var);\n \n-  locate->slot_offset.constant += part_size_in_regs;\n-\n-  if (!in_regs || reg_parm_stack_space > 0)\n-    pad_to_arg_alignment (&locate->slot_offset, boundary,\n-\t\t\t  &locate->alignment_pad);\n-\n-  locate->size.constant = (-initial_offset_ptr->constant\n-\t\t\t   - locate->slot_offset.constant);\n-  if (initial_offset_ptr->var)\n-    locate->size.var = size_binop (MINUS_EXPR,\n-\t\t\t\t   size_binop (MINUS_EXPR,\n-\t\t\t\t\t       ssize_int (0),\n-\t\t\t\t\t       initial_offset_ptr->var),\n-\t\t\t\t   locate->slot_offset.var);\n-\n-  /* Pad_below needs the pre-rounded size to know how much to pad\n-     below.  */\n-  locate->offset = locate->slot_offset;\n-  if (where_pad == downward)\n-    pad_below (&locate->offset, passed_mode, sizetree);\n-\n-#else /* !ARGS_GROW_DOWNWARD */\n-  if (!in_regs || reg_parm_stack_space > 0)\n-    pad_to_arg_alignment (initial_offset_ptr, boundary,\n-\t\t\t  &locate->alignment_pad);\n-  locate->slot_offset = *initial_offset_ptr;\n+      /* Pad_below needs the pre-rounded size to know how much to pad\n+\t below.  */\n+      locate->offset = locate->slot_offset;\n+      if (where_pad == downward)\n+\tpad_below (&locate->offset, passed_mode, sizetree);\n+\n+    }\n+  else\n+    {\n+      if (!in_regs || reg_parm_stack_space > 0)\n+\tpad_to_arg_alignment (initial_offset_ptr, boundary,\n+\t\t\t      &locate->alignment_pad);\n+      locate->slot_offset = *initial_offset_ptr;\n \n #ifdef PUSH_ROUNDING\n-  if (passed_mode != BLKmode)\n-    sizetree = size_int (PUSH_ROUNDING (TREE_INT_CST_LOW (sizetree)));\n+      if (passed_mode != BLKmode)\n+\tsizetree = size_int (PUSH_ROUNDING (TREE_INT_CST_LOW (sizetree)));\n #endif\n \n-  /* Pad_below needs the pre-rounded size to know how much to pad below\n-     so this must be done before rounding up.  */\n-  locate->offset = locate->slot_offset;\n-  if (where_pad == downward)\n-    pad_below (&locate->offset, passed_mode, sizetree);\n+      /* Pad_below needs the pre-rounded size to know how much to pad below\n+\t so this must be done before rounding up.  */\n+      locate->offset = locate->slot_offset;\n+      if (where_pad == downward)\n+\tpad_below (&locate->offset, passed_mode, sizetree);\n \n-  if (where_pad != none\n-      && (!tree_fits_uhwi_p (sizetree)\n-\t  || (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n-    sizetree = round_up (sizetree, round_boundary / BITS_PER_UNIT);\n+      if (where_pad != none\n+\t  && (!tree_fits_uhwi_p (sizetree)\n+\t      || (tree_to_uhwi (sizetree) * BITS_PER_UNIT) % round_boundary))\n+\tsizetree = round_up (sizetree, round_boundary / BITS_PER_UNIT);\n \n-  ADD_PARM_SIZE (locate->size, sizetree);\n+      ADD_PARM_SIZE (locate->size, sizetree);\n \n-  locate->size.constant -= part_size_in_regs;\n-#endif /* ARGS_GROW_DOWNWARD */\n+      locate->size.constant -= part_size_in_regs;\n+    }\n \n #ifdef FUNCTION_ARG_OFFSET\n   locate->offset.constant += FUNCTION_ARG_OFFSET (passed_mode, type);\n@@ -4175,11 +4179,11 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n \t  tree offset = size_binop (PLUS_EXPR,\n \t\t\t\t    ARGS_SIZE_TREE (*offset_ptr),\n \t\t\t\t    sp_offset_tree);\n-#if ARGS_GROW_DOWNWARD\n-\t  tree rounded = round_down (offset, boundary / BITS_PER_UNIT);\n-#else\n-\t  tree rounded = round_up   (offset, boundary / BITS_PER_UNIT);\n-#endif\n+\t  tree rounded;\n+\t  if (ARGS_GROW_DOWNWARD)\n+\t    rounded = round_down (offset, boundary / BITS_PER_UNIT);\n+\t  else\n+\t    rounded = round_up   (offset, boundary / BITS_PER_UNIT);\n \n \t  offset_ptr->var = size_binop (MINUS_EXPR, rounded, sp_offset_tree);\n \t  /* ARGS_SIZE_TREE includes constant term.  */\n@@ -4191,11 +4195,10 @@ pad_to_arg_alignment (struct args_size *offset_ptr, int boundary,\n       else\n \t{\n \t  offset_ptr->constant = -sp_offset +\n-#if ARGS_GROW_DOWNWARD\n-\t    FLOOR_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes);\n-#else\n+\t    ARGS_GROW_DOWNWARD ?\n+\t    FLOOR_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes) :\n \t    CEIL_ROUND (offset_ptr->constant + sp_offset, boundary_in_bytes);\n-#endif\n+\n \t    if (boundary > PARM_BOUNDARY)\n \t      alignment_pad->constant = offset_ptr->constant - save_constant;\n \t}"}, {"sha": "806ff8cd51234f4d55dd8a1167e4af360b84a258", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dad93619e31294ccf2ed273a33baee01d8334c3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6dad93619e31294ccf2ed273a33baee01d8334c3", "patch": "@@ -1786,12 +1786,11 @@ std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n   unsigned HOST_WIDE_INT align, boundary;\n   bool indirect;\n \n-#if ARGS_GROW_DOWNWARD\n   /* All of the alignment and movement below is for args-grow-up machines.\n      As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n      implement their own specialized gimplify_va_arg_expr routines.  */\n-  gcc_unreachable ();\n-#endif\n+  if (ARGS_GROW_DOWNWARD)\n+    gcc_unreachable ();\n \n   indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n   if (indirect)"}]}