{"sha": "50bc768da122bde65bc31bf4054f29603893455a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBiYzc2OGRhMTIyYmRlNjViYzMxYmY0MDU0ZjI5NjAzODkzNDU1YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-08-27T17:59:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-27T17:59:33Z"}, "message": "call.c (validate_conversion_obstack): Replace my_friendly_assert with gcc_assert or gcc_unreachable.\n\n\t* call.c (validate_conversion_obstack): Replace\n\tmy_friendly_assert with gcc_assert or gcc_unreachable.\n\t(direct_reference_binding, merge_conversion_sequences,\n\tbuild_user_type_conversion_1, perform_overload_resolution,\n\tbuild_op_delete_call, enforce_access, call_builtin_trap,\n\tbuild_over_call, build_special_member_call, build_new_method_call,\n\tinitialize_reference): Likewise.\n\t* class.c (build_base_path, build_primary_vtable, alter_access,\n\tcheck_bases, update_vtable_entry_for_fn, layout_empty_base,\n\tclone_function_decl, adjust_clone_args,\n\ttype_requires_array_cookie, include_empty_classes,\n\tfinish_struct_1, resolve_address_of_overloaded_function,\n\tinstantiate_type, get_vtbl_decl_for_binfo, build_vtt_inits,\n\tdfs_build_secondary_vptr_vtt_inits, build_ctor_vtbl_group,\n\taccumulate_vtbl_inits, build_vtbl_initializer,\n\tbuild_vbase_offset_vtbl_entries, build_rtti_vtbl_entries): Likewise.\n\t* cvt.c (build_up_reference, convert_to_reference): Likewise.\n\t* decl.c (poplevel, duplicate_decls, make_typename_type,\n\tcxx_init_decl_processing, reshape_init, check_initializer,\n\tmake_rtl_for_nonlocal_decl, initialize_local_var, cp_finish_decl,\n\texpand_static_init, grokfndecl, grokvardecl, build_ptrmem_type,\n\tgrokdeclarator, copy_fn_p, grok_op_properties, xref_tag,\n\txref_basetypes, start_preparsed_function, save_function_data,\n\tfinish_function, finish_method, maybe_register_incomplete_var,\n\tcomplete_vars): Likewise.\n\t* decl2.c (grok_array_decl, check_member_template,\n\tcheck_classfn, finish_static_data_member_decl, coerce_new_type,\n\tcoerce_delete_type, import_export_class, decl_needed_p,\n\tdetermine_visibility, import_export_decl, build_cleanup,\n\tstart_static_initialization_or_destructi, do_static_destruction,\n\tprune_vars_needing_no_initialization,\n\tbuild_offset_ref_call_from_tree): Likewise.\n\t* error.c (dump_decl, dump_expr): Likewise.\n\t* init.c (finish_init_stmts, build_zero_init,\n\texpand_virtual_init, expand_default_init, expand_aggr_init_1,\n\tbuild_offset_ref, build_new_1, build_delete, build_vbase_delete):\n\tLikewise.\n\t* mangle.c (write_method_parms, write_template_args,\n\twrite_expression, write_template_arg): Likewise.\n\t* method.c (make_thunk, finish_thunk, use_thunk): Likewise.\n\t* name-lookup.c (pop_binding, begin_scope, leave_scope,\n\tresume_scope, push_using_decl, validate_nonmember_using_decl,\n\tis_ancestor, poplevel_class, set_inherited_value_binding_p,\n\tpush_class_level_binding, do_class_using_decl, push_namespace,\n\tpop_namespace, add_using_namespace, ambiguous_decl,\n\tlookup_namespace_name, lookup_type_current_level,\n\tmaybe_process_template_type_declaration): Likewise.\n\t* parser.c (cp_lexer_peek_nth_token,\n\tcp_parser_parse_and_diagnose_invalid_typ,\n\tcp_parser_translation_unit, cp_parser_template_id,\n\tcp_parser_lookup_name, cp_parser_late_parsing_for_member): Likewise.\n\t* pt.c (push_access_scope, finish_member_template_decl,\n\tpush_inline_template_parms_recursive, add_outermost_template_args,\n\tget_innermost_template_args, begin_explicit_instantiation,\n\tend_explicit_instantiation, retrieve_specialization,\n\tis_specialization_of, is_specialization_of_friend,\n\tregister_specialization, check_explicit_specialization,\n\tcomp_template_parms, process_template_parm,\n\tprocess_partial_specialization, convert_nontype_argument,\n\tcoerce_template_template_parms, coerce_template_parms,\n\tmangle_class_name_for_template, lookup_template_function,\n\tlookup_template_class, instantiate_class_template, tsubst_decl,\n\ttsubst_function_type, tsubst, tsubst_qualified_id, tsubst_copy,\n\tinstantiate_template, fn_type_unification, type_unification_real,\n\tget_template_base, regenerate_decl_from_template,\n\ttemplate_for_substitution, instantiate_decl,\n\tget_mostly_instantiated_function_type, dependent_scope_ref_p,\n\tvalue_dependent_expression_p, resolve_typename_type): Likewise.\n\t* repo.c (repo_emit_p): Likewise.\n\t* rtti.c (build_headof, get_tinfo_decl, get_pseudo_ti_init,\n\tcreate_tinfo_types, emit_tinfo_decl): Likewise.\n\t* search.c (lookup_base_r, lookup_base, lookup_field_1,\n\tdfs_access_in_type, build_baselink, lookup_member,\n\tadjust_result_of_qualified_name_lookup, copied_binfo): Likewise.\n\t* semantics.c (perform_or_defer_access_check,\n\tfinish_non_static_data_member, finish_stmt_expr_expr,\n\tfinish_stmt_expr, finish_call_expr, finish_pseudo_destructor_expr,\n\tfinish_template_template_parm, finish_member_declaration,\n\temit_associated_thunks): Likewise.\n\t* tree.c (build_target_expr_with_type, force_target_expr,\n\tcopy_binfo, get_first_fn, cp_tree_equal): Likewise.\n\t* typeck.c (type_after_usual_arithmetic_conversions, comptypes,\n\tcxx_sizeof_or_alignof_type, perform_integral_promotions,\n\tbuild_class_member_access_expr, finish_class_member_access_expr,\n\tbuild_ptrmemfunc_access_expr, build_unary_op,\n\tunary_complex_lvalue, cxx_mark_addressable, build_modify_expr,\n\tbuild_ptrmemfunc, expand_ptrmemfunc_cst, check_return_expr\n\t* typeck2.c (complete_type_check_abstract,\n\tabstract_virtuals_error, process_init_constructor,\n\tadd_exception_specifier): Likewise.\n\nFrom-SVN: r86669", "tree": {"sha": "799c8fedd2cb98c51cb9c5f72999b3cc368ee8ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/799c8fedd2cb98c51cb9c5f72999b3cc368ee8ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50bc768da122bde65bc31bf4054f29603893455a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50bc768da122bde65bc31bf4054f29603893455a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50bc768da122bde65bc31bf4054f29603893455a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50bc768da122bde65bc31bf4054f29603893455a/comments", "author": null, "committer": null, "parents": [{"sha": "e3861d2a1b0dc8389f5261b78adf4eb621b74251", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3861d2a1b0dc8389f5261b78adf4eb621b74251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3861d2a1b0dc8389f5261b78adf4eb621b74251"}], "stats": {"total": 962, "additions": 484, "deletions": 478}, "files": [{"sha": "a4796a1ec16db70cea37ef73d29111002f7b496e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -1,3 +1,96 @@\n+2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (validate_conversion_obstack): Replace\n+\tmy_friendly_assert with gcc_assert or gcc_unreachable.\n+\t(direct_reference_binding, merge_conversion_sequences,\n+\tbuild_user_type_conversion_1, perform_overload_resolution,\n+\tbuild_op_delete_call, enforce_access, call_builtin_trap,\n+\tbuild_over_call, build_special_member_call, build_new_method_call,\n+\tinitialize_reference): Likewise.\n+\t* class.c (build_base_path, build_primary_vtable, alter_access,\n+\tcheck_bases, update_vtable_entry_for_fn, layout_empty_base,\n+\tclone_function_decl, adjust_clone_args,\n+\ttype_requires_array_cookie, include_empty_classes,\n+\tfinish_struct_1, resolve_address_of_overloaded_function,\n+\tinstantiate_type, get_vtbl_decl_for_binfo, build_vtt_inits,\n+\tdfs_build_secondary_vptr_vtt_inits, build_ctor_vtbl_group,\n+\taccumulate_vtbl_inits, build_vtbl_initializer,\n+\tbuild_vbase_offset_vtbl_entries, build_rtti_vtbl_entries): Likewise.\n+\t* cvt.c (build_up_reference, convert_to_reference): Likewise.\n+\t* decl.c (poplevel, duplicate_decls, make_typename_type,\n+\tcxx_init_decl_processing, reshape_init, check_initializer,\n+\tmake_rtl_for_nonlocal_decl, initialize_local_var, cp_finish_decl,\n+\texpand_static_init, grokfndecl, grokvardecl, build_ptrmem_type,\n+\tgrokdeclarator, copy_fn_p, grok_op_properties, xref_tag,\n+\txref_basetypes, start_preparsed_function, save_function_data,\n+\tfinish_function, finish_method, maybe_register_incomplete_var,\n+\tcomplete_vars): Likewise.\n+\t* decl2.c (grok_array_decl, check_member_template,\n+\tcheck_classfn, finish_static_data_member_decl, coerce_new_type,\n+\tcoerce_delete_type, import_export_class, decl_needed_p,\n+\tdetermine_visibility, import_export_decl, build_cleanup,\n+\tstart_static_initialization_or_destructi, do_static_destruction,\n+\tprune_vars_needing_no_initialization,\n+\tbuild_offset_ref_call_from_tree): Likewise.\n+\t* error.c (dump_decl, dump_expr): Likewise.\n+\t* init.c (finish_init_stmts, build_zero_init,\n+\texpand_virtual_init, expand_default_init, expand_aggr_init_1,\n+\tbuild_offset_ref, build_new_1, build_delete, build_vbase_delete):\n+\tLikewise.\n+\t* mangle.c (write_method_parms, write_template_args,\n+\twrite_expression, write_template_arg): Likewise.\n+\t* method.c (make_thunk, finish_thunk, use_thunk): Likewise.\n+\t* name-lookup.c (pop_binding, begin_scope, leave_scope,\n+\tresume_scope, push_using_decl, validate_nonmember_using_decl,\n+\tis_ancestor, poplevel_class, set_inherited_value_binding_p,\n+\tpush_class_level_binding, do_class_using_decl, push_namespace,\n+\tpop_namespace, add_using_namespace, ambiguous_decl,\n+\tlookup_namespace_name, lookup_type_current_level,\n+\tmaybe_process_template_type_declaration): Likewise.\n+\t* parser.c (cp_lexer_peek_nth_token,\n+\tcp_parser_parse_and_diagnose_invalid_typ,\n+\tcp_parser_translation_unit, cp_parser_template_id,\n+\tcp_parser_lookup_name, cp_parser_late_parsing_for_member): Likewise.\n+\t* pt.c (push_access_scope, finish_member_template_decl,\n+\tpush_inline_template_parms_recursive, add_outermost_template_args,\n+\tget_innermost_template_args, begin_explicit_instantiation,\n+\tend_explicit_instantiation, retrieve_specialization,\n+\tis_specialization_of, is_specialization_of_friend,\n+\tregister_specialization, check_explicit_specialization,\n+\tcomp_template_parms, process_template_parm,\n+\tprocess_partial_specialization, convert_nontype_argument,\n+\tcoerce_template_template_parms, coerce_template_parms,\n+\tmangle_class_name_for_template, lookup_template_function,\n+\tlookup_template_class, instantiate_class_template, tsubst_decl,\n+\ttsubst_function_type, tsubst, tsubst_qualified_id, tsubst_copy,\n+\tinstantiate_template, fn_type_unification, type_unification_real,\n+\tget_template_base, regenerate_decl_from_template,\n+\ttemplate_for_substitution, instantiate_decl,\n+\tget_mostly_instantiated_function_type, dependent_scope_ref_p,\n+\tvalue_dependent_expression_p, resolve_typename_type): Likewise.\n+\t* repo.c (repo_emit_p): Likewise.\n+\t* rtti.c (build_headof, get_tinfo_decl, get_pseudo_ti_init,\n+\tcreate_tinfo_types, emit_tinfo_decl): Likewise.\n+\t* search.c (lookup_base_r, lookup_base, lookup_field_1,\n+\tdfs_access_in_type, build_baselink, lookup_member,\n+\tadjust_result_of_qualified_name_lookup, copied_binfo): Likewise.\n+\t* semantics.c (perform_or_defer_access_check,\n+\tfinish_non_static_data_member, finish_stmt_expr_expr,\n+\tfinish_stmt_expr, finish_call_expr, finish_pseudo_destructor_expr,\n+\tfinish_template_template_parm, finish_member_declaration,\n+\temit_associated_thunks): Likewise.\n+\t* tree.c (build_target_expr_with_type, force_target_expr,\n+\tcopy_binfo, get_first_fn, cp_tree_equal): Likewise.\n+\t* typeck.c (type_after_usual_arithmetic_conversions, comptypes,\n+\tcxx_sizeof_or_alignof_type, perform_integral_promotions,\n+\tbuild_class_member_access_expr, finish_class_member_access_expr,\n+\tbuild_ptrmemfunc_access_expr, build_unary_op,\n+\tunary_complex_lvalue, cxx_mark_addressable, build_modify_expr,\n+\tbuild_ptrmemfunc, expand_ptrmemfunc_cst, check_return_expr\n+\t* typeck2.c (complete_type_check_abstract,\n+\tabstract_virtuals_error, process_init_constructor,\n+\tadd_exception_specifier): Likewise.\n+\n 2004-08-27  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (build_vtbl_initializer): Use ssize_int."}, {"sha": "07aea66308b4105d1333070df2f4758b6b91d175", "filename": "gcc/cp/call.c", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -497,9 +497,8 @@ void\n validate_conversion_obstack (void)\n {\n   if (conversion_obstack_initialized)\n-    my_friendly_assert ((obstack_next_free (&conversion_obstack) \n-\t\t\t == obstack_base (&conversion_obstack)),\n-\t\t\t20040208);\n+    gcc_assert ((obstack_next_free (&conversion_obstack) \n+\t\t == obstack_base (&conversion_obstack)));\n }\n \n #endif /* ENABLE_CHECKING */\n@@ -1033,8 +1032,8 @@ direct_reference_binding (tree type, conversion *conv)\n {\n   tree t;\n \n-  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 20030306);\n-  my_friendly_assert (TREE_CODE (conv->type) != REFERENCE_TYPE, 20030306);\n+  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n+  gcc_assert (TREE_CODE (conv->type) != REFERENCE_TYPE);\n \n   t = TREE_TYPE (type);\n \n@@ -2464,7 +2463,7 @@ merge_conversion_sequences (conversion *user_seq, conversion *std_seq)\n {\n   conversion **t;\n \n-  my_friendly_assert (user_seq->kind == ck_user, 20030306);\n+  gcc_assert (user_seq->kind == ck_user);\n \n   /* Find the end of the second conversion sequence.  */\n   t = &(std_seq); \n@@ -2501,8 +2500,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n      BASE_CONV, as specified by [over.best.ics]; these become plain\n      constructor calls, as specified in [dcl.init].  */\n-  my_friendly_assert (!IS_AGGR_TYPE (fromtype) || !IS_AGGR_TYPE (totype)\n-\t\t      || !DERIVED_FROM_P (totype, fromtype), 20011226);\n+  gcc_assert (!IS_AGGR_TYPE (fromtype) || !IS_AGGR_TYPE (totype)\n+\t      || !DERIVED_FROM_P (totype, fromtype));\n \n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (totype, complete_ctor_identifier, 0);\n@@ -2523,9 +2522,8 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       args = build_tree_list (NULL_TREE, expr);\n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n-      my_friendly_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n-\t\t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)),\n-\t\t\t  20011226);\n+      gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n+\t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n       args = tree_cons (NULL_TREE, t, args);\n     }\n   for (; ctors; ctors = OVL_NEXT (ctors))\n@@ -2718,13 +2716,11 @@ perform_overload_resolution (tree fn,\n   *any_viable_p = true;\n \n   /* Check FN and ARGS.  */\n-  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL \n-\t\t      || TREE_CODE (fn) == TEMPLATE_DECL\n-\t\t      || TREE_CODE (fn) == OVERLOAD\n-\t\t      || TREE_CODE (fn) == TEMPLATE_ID_EXPR,\n-\t\t      20020712);\n-  my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n-\t\t      20020712);\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL \n+\t      || TREE_CODE (fn) == TEMPLATE_DECL\n+\t      || TREE_CODE (fn) == OVERLOAD\n+\t      || TREE_CODE (fn) == TEMPLATE_ID_EXPR);\n+  gcc_assert (!args || TREE_CODE (args) == TREE_LIST);\n \n   if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n     {\n@@ -3960,7 +3956,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       call_expr = placement;\n       /* Extract the function.  */\n       alloc_fn = get_callee_fndecl (call_expr);\n-      my_friendly_assert (alloc_fn != NULL_TREE, 20020327);\n+      gcc_assert (alloc_fn != NULL_TREE);\n       /* Then the second parm type.  */\n       argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (alloc_fn)));\n       /* Also the second argument.  */\n@@ -4068,7 +4064,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n bool\n enforce_access (tree basetype_path, tree decl)\n {\n-  my_friendly_assert (TREE_CODE (basetype_path) == TREE_BINFO, 20030624);\n+  gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n   \n   if (!accessible_p (basetype_path, decl))\n     {\n@@ -4356,7 +4352,7 @@ call_builtin_trap (void)\n {\n   tree fn = implicit_built_in_decls[BUILT_IN_TRAP];\n \n-  my_friendly_assert (fn != NULL, 20030927);\n+  gcc_assert (fn != NULL);\n   fn = build_call (fn, NULL_TREE);\n   return fn;\n }\n@@ -4682,9 +4678,9 @@ build_over_call (struct z_candidate *cand, int flags)\n \n          So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n-      my_friendly_assert (TREE_CODE (parmtype) == POINTER_TYPE, 19990811);\n+      gcc_assert (TREE_CODE (parmtype) == POINTER_TYPE);\n       /* Convert to the base in which the function was declared.  */\n-      my_friendly_assert (cand->conversion_path != NULL_TREE, 20020730);\n+      gcc_assert (cand->conversion_path != NULL_TREE);\n       converted_arg = build_base_path (PLUS_EXPR,\n \t\t\t\t       TREE_VALUE (arg),\n \t\t\t\t       cand->conversion_path,\n@@ -4851,7 +4847,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (*p)),\n \t\t\t\tDECL_CONTEXT (fn),\n \t\t\t\tba_any, NULL);\n-      my_friendly_assert (binfo && binfo != error_mark_node, 20010730);\n+      gcc_assert (binfo && binfo != error_mark_node);\n       \n       *p = build_base_path (PLUS_EXPR, *p, binfo, 1);\n       if (TREE_SIDE_EFFECTS (*p))\n@@ -5012,13 +5008,12 @@ build_special_member_call (tree instance, tree name, tree args,\n   /* The type of the subobject to be constructed or destroyed.  */\n   tree class_type;\n \n-  my_friendly_assert (name == complete_ctor_identifier\n-\t\t      || name == base_ctor_identifier\n-\t\t      || name == complete_dtor_identifier\n-\t\t      || name == base_dtor_identifier\n-\t\t      || name == deleting_dtor_identifier\n-\t\t      || name == ansi_assopname (NOP_EXPR),\n-\t\t      20020712);\n+  gcc_assert (name == complete_ctor_identifier\n+\t      || name == base_ctor_identifier\n+\t      || name == complete_dtor_identifier\n+\t      || name == base_dtor_identifier\n+\t      || name == deleting_dtor_identifier\n+\t      || name == ansi_assopname (NOP_EXPR));\n   if (TYPE_P (binfo))\n     {\n       /* Resolve the name.  */\n@@ -5028,7 +5023,7 @@ build_special_member_call (tree instance, tree name, tree args,\n       binfo = TYPE_BINFO (binfo);\n     }\n   \n-  my_friendly_assert (binfo != NULL_TREE, 20020712);\n+  gcc_assert (binfo != NULL_TREE);\n \n   class_type = BINFO_TYPE (binfo);\n \n@@ -5043,7 +5038,7 @@ build_special_member_call (tree instance, tree name, tree args,\n       if (name == complete_dtor_identifier \n \t  || name == base_dtor_identifier\n \t  || name == deleting_dtor_identifier)\n-\tmy_friendly_assert (args == NULL_TREE, 20020712);\n+\tgcc_assert (args == NULL_TREE);\n \n       /* Convert to the base class, if necessary.  */\n       if (!same_type_ignoring_top_level_qualifiers_p \n@@ -5064,7 +5059,7 @@ build_special_member_call (tree instance, tree name, tree args,\n \t}\n     }\n   \n-  my_friendly_assert (instance != NULL_TREE, 20020712);\n+  gcc_assert (instance != NULL_TREE);\n \n   fns = lookup_fnfields (binfo, name, 1);\n     \n@@ -5088,7 +5083,7 @@ build_special_member_call (tree instance, tree name, tree args,\n \t\t\t    current_in_charge_parm, integer_zero_node),\n \t\t    current_vtt_parm,\n \t\t    vtt);\n-      my_friendly_assert (BINFO_SUBVTT_INDEX (binfo), 20010110);\n+      gcc_assert (BINFO_SUBVTT_INDEX (binfo));\n       sub_vtt = build2 (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n \t\t\tBINFO_SUBVTT_INDEX (binfo));\n \n@@ -5169,7 +5164,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree orig_args;\n   void *p;\n \n-  my_friendly_assert (instance != NULL_TREE, 20020729);\n+  gcc_assert (instance != NULL_TREE);\n \n   if (error_operand_p (instance) \n       || error_operand_p (fns)\n@@ -5220,10 +5215,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n       template_only = 1;\n     }\n \n-  my_friendly_assert (TREE_CODE (fns) == FUNCTION_DECL\n-\t\t      || TREE_CODE (fns) == TEMPLATE_DECL\n-\t\t      || TREE_CODE (fns) == OVERLOAD,\n-\t\t      20020712);\n+  gcc_assert (TREE_CODE (fns) == FUNCTION_DECL\n+\t      || TREE_CODE (fns) == TEMPLATE_DECL\n+\t      || TREE_CODE (fns) == OVERLOAD);\n \n   /* XXX this should be handled before we get here.  */\n   if (! IS_AGGR_TYPE (basetype))\n@@ -5242,9 +5236,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n     {\n       /* Callers should explicitly indicate whether they want to construct\n \t the complete object or just the part without virtual bases.  */\n-      my_friendly_assert (name != ctor_identifier, 20000408);\n+      gcc_assert (name != ctor_identifier);\n       /* Similarly for destructors.  */\n-      my_friendly_assert (name != dtor_identifier, 20000408);\n+      gcc_assert (name != dtor_identifier);\n     }\n \n   /* It's OK to call destructors on cv-qualified objects.  Therefore,\n@@ -6147,7 +6141,7 @@ the worst conversion for the second:\");\n         }\n     }\n \n-  my_friendly_assert (!winner, 20010121);\n+  gcc_assert (!winner);\n   return 0;\n }\n \n@@ -6443,7 +6437,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \n     we can extend the lifetime of the return value of the conversion\n     operator.  */\n-  my_friendly_assert (conv->kind == ck_ref_bind, 20030302);\n+  gcc_assert (conv->kind == ck_ref_bind);\n   if (decl)\n     {\n       tree var;"}, {"sha": "83977e2c1b95a3872e90c975db7f4a39a04850c1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 58, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -272,11 +272,11 @@ build_base_path (enum tree_code code,\n   if (want_pointer)\n     probe = TYPE_MAIN_VARIANT (TREE_TYPE (probe));\n \n-  my_friendly_assert (code == MINUS_EXPR\n-\t\t      ? same_type_p (BINFO_TYPE (binfo), probe)\n-\t\t      : code == PLUS_EXPR\n-\t\t      ? same_type_p (BINFO_TYPE (d_binfo), probe)\n-\t\t      : false, 20010723);\n+  gcc_assert (code == MINUS_EXPR\n+\t      ? same_type_p (BINFO_TYPE (binfo), probe)\n+\t      : code == PLUS_EXPR\n+\t      ? same_type_p (BINFO_TYPE (d_binfo), probe)\n+\t      : false);\n   \n   if (binfo == d_binfo)\n     /* Nothing to do.  */\n@@ -731,7 +731,7 @@ build_primary_vtable (tree binfo, tree type)\n     }\n   else\n     {\n-      my_friendly_assert (TREE_TYPE (decl) == vtbl_type_node, 20000118);\n+      gcc_assert (TREE_TYPE (decl) == vtbl_type_node);\n       virtuals = NULL_TREE;\n     }\n \n@@ -1039,7 +1039,7 @@ alter_access (tree t, tree fdecl, tree access)\n   if (!DECL_LANG_SPECIFIC (fdecl))\n     retrofit_lang_decl (fdecl);\n \n-  my_friendly_assert (!DECL_DISCRIMINATOR_P (fdecl), 20030624);\n+  gcc_assert (!DECL_DISCRIMINATOR_P (fdecl));\n \n   elem = purpose_member (t, DECL_ACCESS (fdecl));\n   if (elem)\n@@ -1191,7 +1191,7 @@ check_bases (tree t,\n     {\n       tree basetype = TREE_TYPE (base_binfo);\n \n-      my_friendly_assert (COMPLETE_TYPE_P (basetype), 20040714);\n+      gcc_assert (COMPLETE_TYPE_P (basetype));\n       \n       /* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P\n \t here because the case of virtual functions but non-virtual\n@@ -2081,7 +2081,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n      calling FN through BINFO.  */\n   for (b = binfo; ; b = get_primary_binfo (b))\n     {\n-      my_friendly_assert (b, 20021227);\n+      gcc_assert (b);\n       if (look_for_overrides_here (BINFO_TYPE (b), target_fn))\n \tbreak;\n \n@@ -2114,7 +2114,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n       \n       if (DECL_THUNK_P (fn))\n \t{\n-\t  my_friendly_assert (DECL_RESULT_THUNK_P (fn), 20031211);\n+\t  gcc_assert (DECL_RESULT_THUNK_P (fn));\n \t  fixed_offset = ssize_int (THUNK_FIXED_OFFSET (fn));\n \t  virtual_offset = THUNK_VIRTUAL_OFFSET (fn);\n \t}\n@@ -2174,7 +2174,7 @@ update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals,\n \t\t\t\t   fixed_offset, virtual_offset);\n     }\n   else\n-    my_friendly_assert (!DECL_THUNK_P (fn), 20021231);\n+    gcc_assert (!DECL_THUNK_P (fn));\n   \n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n@@ -3561,7 +3561,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n   bool atend = false;\n \n   /* This routine should only be used for empty classes.  */\n-  my_friendly_assert (is_empty_class (basetype), 20000321);\n+  gcc_assert (is_empty_class (basetype));\n   alignment = ssize_int (CLASSTYPE_ALIGN_UNIT (basetype));\n \n   if (!integer_zerop (BINFO_OFFSET (binfo)))\n@@ -3923,7 +3923,7 @@ clone_function_decl (tree fn, int update_method_vec_p)\n     }\n   else\n     {\n-      my_friendly_assert (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn), 20000411);\n+      gcc_assert (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn));\n \n       /* For each destructor, we need three variants: an in-charge\n \t version, a not-in-charge version, and an in-charge deleting\n@@ -3990,8 +3990,8 @@ adjust_clone_args (tree decl)\n \t   decl_parms = TREE_CHAIN (decl_parms),\n \t     clone_parms = TREE_CHAIN (clone_parms))\n \t{\n-\t  my_friendly_assert (same_type_p (TREE_TYPE (decl_parms),\n-\t\t\t\t\t   TREE_TYPE (clone_parms)), 20010424);\n+\t  gcc_assert (same_type_p (TREE_TYPE (decl_parms),\n+\t\t\t\t   TREE_TYPE (clone_parms)));\n \t  \n \t  if (TREE_PURPOSE (decl_parms) && !TREE_PURPOSE (clone_parms))\n \t    {\n@@ -4021,7 +4021,7 @@ adjust_clone_args (tree decl)\n \t      break;\n \t    }\n \t}\n-      my_friendly_assert (!clone_parms, 20010424);\n+      gcc_assert (!clone_parms);\n     }\n }\n \n@@ -4072,7 +4072,7 @@ type_requires_array_cookie (tree type)\n   tree fns;\n   bool has_two_argument_delete_p = false;\n \n-  my_friendly_assert (CLASS_TYPE_P (type), 20010712);\n+  gcc_assert (CLASS_TYPE_P (type));\n \n   /* If there's a non-trivial destructor, we need a cookie.  In order\n      to iterate through the array calling the destructor for each\n@@ -4579,10 +4579,8 @@ include_empty_classes (record_layout_info rli)\n \trli->bitpos = round_down (rli->bitpos, BITS_PER_UNIT);\n       else\n \t/* The size should have been rounded to a whole byte.  */\n-\tmy_friendly_assert (tree_int_cst_equal (rli->bitpos,\n-\t\t\t\t\t\tround_down (rli->bitpos,\n-\t\t\t\t\t\t\t    BITS_PER_UNIT)),\n-\t\t\t    20030903);\n+\tgcc_assert (tree_int_cst_equal\n+\t\t    (rli->bitpos, round_down (rli->bitpos, BITS_PER_UNIT)));\n       rli->bitpos \n \t= size_binop (PLUS_EXPR, \n \t\t      rli->bitpos,\n@@ -5024,21 +5022,18 @@ finish_struct_1 (tree t)\n     {\n       tree primary = CLASSTYPE_PRIMARY_BINFO (t);\n \n-      my_friendly_assert (same_type_p (DECL_FIELD_CONTEXT (vfield),\n-\t\t\t\t       BINFO_TYPE (primary)),\n-\t\t\t  20010726);\n+      gcc_assert (same_type_p (DECL_FIELD_CONTEXT (vfield),\n+\t\t\t       BINFO_TYPE (primary)));\n       /* The vtable better be at the start.  */\n-      my_friendly_assert (integer_zerop (DECL_FIELD_OFFSET (vfield)),\n-\t\t\t  20010726);\n-      my_friendly_assert (integer_zerop (BINFO_OFFSET (primary)),\n-\t\t\t  20010726);\n+      gcc_assert (integer_zerop (DECL_FIELD_OFFSET (vfield)));\n+      gcc_assert (integer_zerop (BINFO_OFFSET (primary)));\n       \n       vfield = copy_decl (vfield);\n       DECL_FIELD_CONTEXT (vfield) = t;\n       TYPE_VFIELD (t) = vfield;\n     }\n   else\n-    my_friendly_assert (!vfield || DECL_FIELD_CONTEXT (vfield) == t, 20010726);\n+    gcc_assert (!vfield || DECL_FIELD_CONTEXT (vfield) == t);\n \n   virtuals = modify_all_vtables (t, nreverse (virtuals));\n \n@@ -5060,11 +5055,9 @@ finish_struct_1 (tree t)\n       tree fn;\n \n       if (BINFO_VTABLE (TYPE_BINFO (t)))\n-\tmy_friendly_assert (DECL_VIRTUAL_P (BINFO_VTABLE (TYPE_BINFO (t))),\n-\t\t\t    20000116);\n+\tgcc_assert (DECL_VIRTUAL_P (BINFO_VTABLE (TYPE_BINFO (t))));\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-\tmy_friendly_assert (BINFO_VIRTUALS (TYPE_BINFO (t)) == NULL_TREE,\n-\t\t\t    20000116);\n+\tgcc_assert (BINFO_VIRTUALS (TYPE_BINFO (t)) == NULL_TREE);\n \n       /* Add entries for virtual functions introduced by this class.  */\n       BINFO_VIRTUALS (TYPE_BINFO (t))\n@@ -5709,11 +5702,10 @@ resolve_address_of_overloaded_function (tree target_type,\n   /* By the time we get here, we should be seeing only real\n      pointer-to-member types, not the internal POINTER_TYPE to\n      METHOD_TYPE representation.  */\n-  my_friendly_assert (!(TREE_CODE (target_type) == POINTER_TYPE\n-\t\t\t&& (TREE_CODE (TREE_TYPE (target_type)) \n-\t\t\t    == METHOD_TYPE)), 0);\n+  gcc_assert (TREE_CODE (target_type) != POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (target_type)) != METHOD_TYPE);\n \n-  my_friendly_assert (is_overloaded_fn (overload), 20030910);\n+  gcc_assert (is_overloaded_fn (overload));\n   \n   /* Check that the TARGET_TYPE is reasonable.  */\n   if (TYPE_PTRFN_P (target_type))\n@@ -6037,7 +6029,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n       /* This can happen if we are forming a pointer-to-member for a\n \t member template.  */\n-      my_friendly_assert (TREE_CODE (rhs) == TEMPLATE_ID_EXPR, 0);\n+      gcc_assert (TREE_CODE (rhs) == TEMPLATE_ID_EXPR);\n \n       /* Fall through.  */\n \n@@ -6061,7 +6053,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \n     case TREE_LIST:\n       /* Now we should have a baselink.  */\n-      my_friendly_assert (BASELINK_P (rhs), 990412);\n+      gcc_assert (BASELINK_P (rhs));\n \n       return instantiate_type (lhstype, BASELINK_FUNCTIONS (rhs), flags);\n \n@@ -6403,12 +6395,11 @@ get_vtbl_decl_for_binfo (tree binfo)\n   decl = BINFO_VTABLE (binfo);\n   if (decl && TREE_CODE (decl) == PLUS_EXPR)\n     {\n-      my_friendly_assert (TREE_CODE (TREE_OPERAND (decl, 0)) == ADDR_EXPR,\n-\t\t\t  2000403);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (decl, 0)) == ADDR_EXPR);\n       decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n     }\n   if (decl)\n-    my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 20000403);\n+    gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   return decl;\n }\n \n@@ -6853,7 +6844,7 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n   inits = &TREE_CHAIN (*inits);\n   if (top_level_p)\n     {\n-      my_friendly_assert (!BINFO_VPTR_INDEX (binfo), 20010129);\n+      gcc_assert (!BINFO_VPTR_INDEX (binfo));\n       BINFO_VPTR_INDEX (binfo) = *index;\n     }\n   *index = size_binop (PLUS_EXPR, *index, TYPE_SIZE_UNIT (ptr_type_node));\n@@ -6890,7 +6881,7 @@ build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n     {\n       *inits = nreverse (secondary_vptrs);\n       inits = &TREE_CHAIN (secondary_vptrs);\n-      my_friendly_assert (*inits == NULL_TREE, 20000517);\n+      gcc_assert (*inits == NULL_TREE);\n     }\n \n   /* Add the secondary VTTs for virtual bases.  */\n@@ -6959,7 +6950,7 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data)\n   index = TREE_TYPE (l);\n   if (top_level_p)\n     {\n-      my_friendly_assert (!BINFO_VPTR_INDEX (binfo), 20010129);\n+      gcc_assert (!BINFO_VPTR_INDEX (binfo));\n       BINFO_VPTR_INDEX (binfo) = index;\n     }\n   TREE_TYPE (l) = size_binop (PLUS_EXPR, index, \n@@ -7039,7 +7030,7 @@ build_ctor_vtbl_group (tree binfo, tree t)\n   if (IDENTIFIER_GLOBAL_VALUE (id))\n     return;\n \n-  my_friendly_assert (!same_type_p (BINFO_TYPE (binfo), t), 20010124);\n+  gcc_assert (!same_type_p (BINFO_TYPE (binfo), t));\n   /* Build a version of VTBL (with the wrong type) for use in\n      constructing the addresses of secondary vtables in the\n      construction vtable group.  */\n@@ -7096,9 +7087,7 @@ accumulate_vtbl_inits (tree binfo,\n   tree base_binfo;\n   int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n-  my_friendly_assert (same_type_p (BINFO_TYPE (binfo),\n-\t\t\t\t   BINFO_TYPE (orig_binfo)),\n-\t\t      20000517);\n+  gcc_assert (same_type_p (BINFO_TYPE (binfo), BINFO_TYPE (orig_binfo)));\n \n   /* If it doesn't have a vptr, we don't do anything.  */\n   if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n@@ -7378,8 +7367,8 @@ build_vtbl_initializer (tree binfo,\n \t  delta = BV_DELTA (v);\n \t  vcall_index = BV_VCALL_INDEX (v);\n \n-\t  my_friendly_assert (TREE_CODE (delta) == INTEGER_CST, 19990727);\n-\t  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 19990727);\n+\t  gcc_assert (TREE_CODE (delta) == INTEGER_CST);\n+\t  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n \n \t  /* You can't call an abstract virtual function; it's abstract.\n \t     So, we replace these functions with __pure_virtual.  */\n@@ -7523,12 +7512,8 @@ build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n \tBINFO_VPTR_FIELD (b) = delta;\n \n       if (binfo != TYPE_BINFO (t))\n-\t{\n-\t  /* The vbase offset had better be the same.  */\n-\t  my_friendly_assert (tree_int_cst_equal (delta,\n-\t\t\t\t\t\t  BINFO_VPTR_FIELD (vbase)),\n-\t\t\t      20030202);\n-\t}\n+\t/* The vbase offset had better be the same.  */\n+\tgcc_assert (tree_int_cst_equal (delta, BINFO_VPTR_FIELD (vbase)));\n \n       /* The next vbase will come at a more negative offset.  */\n       vid->index = size_binop (MINUS_EXPR, vid->index,\n@@ -7805,7 +7790,7 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n       tree primary_base;\n \n       primary_base = get_primary_binfo (b);\n-      my_friendly_assert (BINFO_PRIMARY_BASE_OF (primary_base) == b, 20010127);\n+      gcc_assert (BINFO_PRIMARY_BASE_OF (primary_base) == b);\n       b = primary_base;\n     }\n   offset = size_diffop (BINFO_OFFSET (vid->rtti_binfo), BINFO_OFFSET (b));"}, {"sha": "ed18d7c53f7d976ea9e7a29c8fab56d288edb331", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -366,7 +366,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n   tree argtype = TREE_TYPE (arg);\n   tree target_type = TREE_TYPE (type);\n \n-  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 187);\n+  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n \n   if ((flags & DIRECT_BIND) && ! real_lvalue_p (arg))\n     {\n@@ -470,7 +470,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n   intype = TREE_TYPE (expr);\n \n-  my_friendly_assert (TREE_CODE (intype) != REFERENCE_TYPE, 364);\n+  gcc_assert (TREE_CODE (intype) != REFERENCE_TYPE);\n \n   intype = TYPE_MAIN_VARIANT (intype);\n "}, {"sha": "95cf0f5e71785ad6d33121aeb9d92466ed51b956", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 43, "deletions": 52, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -438,20 +438,19 @@ poplevel (int keep, int reverse, int functionbody)\n \n   block = NULL_TREE;\n \n-  my_friendly_assert (current_binding_level->kind != sk_class, 19990916);\n+  gcc_assert (current_binding_level->kind != sk_class);\n \n   real_functionbody = (current_binding_level->kind == sk_cleanup\n \t\t       ? ((functionbody = 0), tmp) : functionbody);\n   subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n \n-  my_friendly_assert (VEC_length(cp_class_binding,\n-\t\t\t\t current_binding_level->class_shadowed) == 0,\n-\t\t      19990414);\n+  gcc_assert (!VEC_length(cp_class_binding,\n+\t\t\t  current_binding_level->class_shadowed));\n \n   /* We used to use KEEP == 2 to indicate that the new block should go\n      at the beginning of the list of blocks at this binding level,\n      rather than the end.  This hack is no longer used.  */\n-  my_friendly_assert (keep == 0 || keep == 1, 0);\n+  gcc_assert (keep == 0 || keep == 1);\n \n   if (current_binding_level->keep)\n     keep = 1;\n@@ -1793,8 +1792,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  /* If newdecl is not a specialization, then it is not a\n \t     template-related function at all.  And that means that we\n \t     should have exited above, returning 0.  */\n-\t  my_friendly_assert (DECL_TEMPLATE_SPECIALIZATION (newdecl),\n-\t\t\t      0);\n+\t  gcc_assert (DECL_TEMPLATE_SPECIALIZATION (newdecl));\n \n \t  if (TREE_USED (olddecl))\n \t    /* From [temp.expl.spec]:\n@@ -2607,7 +2605,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n       error (\"`%D' used without template parameters\", name);\n       return error_mark_node;\n     }\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 20030802);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   if (TREE_CODE (context) == NAMESPACE_DECL)\n     {\n@@ -2914,7 +2912,7 @@ cxx_init_decl_processing (void)\n   current_function_decl = NULL_TREE;\n   current_binding_level = NULL;\n   /* Enter the global namespace.  */\n-  my_friendly_assert (global_namespace == NULL_TREE, 375);\n+  gcc_assert (global_namespace == NULL_TREE);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,\n                                       void_type_node);\n   begin_scope (sk_namespace, global_namespace);\n@@ -4139,7 +4137,7 @@ reshape_init (tree type, tree *initp)\n   old_init_value = (TREE_CODE (*initp) == TREE_LIST\n \t\t    ? TREE_VALUE (*initp) : old_init);\n \n-  my_friendly_assert (old_init_value, 20030723);\n+  gcc_assert (old_init_value);\n \n   /* If the initializer is brace-enclosed, pull initializers from the\n      enclosed elements.  Advance past the brace-enclosed initializer\n@@ -4395,11 +4393,11 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \n   if (TREE_CODE (decl) == CONST_DECL)\n     {\n-      my_friendly_assert (TREE_CODE (decl) != REFERENCE_TYPE, 148);\n+      gcc_assert (TREE_CODE (decl) != REFERENCE_TYPE);\n \n       DECL_INITIAL (decl) = init;\n \n-      my_friendly_assert (init != NULL_TREE, 149);\n+      gcc_assert (init != NULL_TREE);\n       init = NULL_TREE;\n     }\n   else if (!DECL_EXTERNAL (decl) && TREE_CODE (type) == REFERENCE_TYPE)\n@@ -4536,11 +4534,11 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n      member.  */\n   if (DECL_LANG_SPECIFIC (decl) && DECL_IN_AGGR_P (decl))\n     {\n-      my_friendly_assert (TREE_STATIC (decl), 19990828);\n+      gcc_assert (TREE_STATIC (decl));\n       /* An in-class declaration of a static data member should be\n \t external; it is only a declaration, and not a definition.  */\n       if (init == NULL_TREE)\n-\tmy_friendly_assert (DECL_EXTERNAL (decl), 20000723);\n+\tgcc_assert (DECL_EXTERNAL (decl));\n     }\n \n   /* We don't create any RTL for local variables.  */\n@@ -4589,10 +4587,9 @@ initialize_local_var (tree decl, tree init)\n   tree type = TREE_TYPE (decl);\n   tree cleanup;\n \n-  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n-\t\t      || TREE_CODE (decl) == RESULT_DECL,\n-\t\t      20021010);\n-  my_friendly_assert (!TREE_STATIC (decl), 20021010);\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL);\n+  gcc_assert (!TREE_STATIC (decl));\n \n   if (DECL_SIZE (decl) == NULL_TREE)\n     {\n@@ -4613,7 +4610,7 @@ initialize_local_var (tree decl, tree init)\n \t{\n \t  int saved_stmts_are_full_exprs_p;\n \n-\t  my_friendly_assert (building_stmt_tree (), 20000906);\n+\t  gcc_assert (building_stmt_tree ());\n \t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  finish_expr_stmt (init);\n@@ -4671,7 +4668,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n       return;\n     }\n \n-  my_friendly_assert (TREE_CODE (decl) != RESULT_DECL, 20030619);\n+  gcc_assert (TREE_CODE (decl) != RESULT_DECL);\n \n   /* Assume no cleanup is required.  */\n   cleanup = NULL_TREE;\n@@ -4719,7 +4716,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     }\n \n   /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */\n-  my_friendly_assert (TREE_CODE (decl) != PARM_DECL, 19990828);\n+  gcc_assert (TREE_CODE (decl) != PARM_DECL);\n \n   /* Take care of TYPE_DECLs up front.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n@@ -5142,8 +5139,8 @@ register_dtor_fn (tree decl)\n static void\n expand_static_init (tree decl, tree init)\n {\n-  my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 20021010);\n-  my_friendly_assert (TREE_STATIC (decl), 20021010);\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (TREE_STATIC (decl));\n \n   /* Some variables require no initialization.  */\n   if (!init\n@@ -5573,12 +5570,12 @@ grokfndecl (tree ctype,\n                  (see template_id in parse.y). If the current class contains\n                  such a name, we'll get a COMPONENT_REF here. Undo that.  */\n \n-              my_friendly_assert (TREE_TYPE (TREE_OPERAND (fns, 0))\n-                                  == current_class_type, 20001120);\n+              gcc_assert (TREE_TYPE (TREE_OPERAND (fns, 0))\n+\t\t\t  == current_class_type);\n               fns = TREE_OPERAND (fns, 1);\n             }\n-\t  my_friendly_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n-\t                      || TREE_CODE (fns) == OVERLOAD, 20001120);\n+\t  gcc_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n+\t\t      || TREE_CODE (fns) == OVERLOAD);\n \t  DECL_TEMPLATE_INFO (decl) = tree_cons (fns, args, NULL_TREE);\n \n \t  if (has_default_arg)\n@@ -5725,8 +5722,7 @@ grokvardecl (tree type,\n {\n   tree decl;\n \n-  my_friendly_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE,\n-\t\t      20020808);\n+  gcc_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE);\n \n   /* Compute the scope in which to place the variable.  */\n   if (!scope)\n@@ -5920,8 +5916,7 @@ build_ptrmem_type (tree class_type, tree member_type)\n     }\n   else\n     {\n-      my_friendly_assert (TREE_CODE (member_type) != FUNCTION_TYPE,\n-\t\t\t  20030716);\n+      gcc_assert (TREE_CODE (member_type) != FUNCTION_TYPE);\n       return build_offset_type (class_type, member_type);\n     }\n }\n@@ -6416,8 +6411,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    dname = TREE_OPERAND (dname, 1);\n \t\t  if (TREE_CODE (dname) != IDENTIFIER_NODE)\n \t\t    {\n-\t\t      my_friendly_assert (is_overloaded_fn (dname),\n-\t\t\t\t\t  19990331);\n+\t\t      gcc_assert (is_overloaded_fn (dname));\n \t\t      dname = DECL_NAME (get_first_fn (dname));\n \t\t    }\n \t\t}\n@@ -6437,7 +6431,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  name = IDENTIFIER_POINTER (dname);\n \t\telse\n \t\t  {\n-\t\t    my_friendly_assert (flags == NO_SPECIAL, 154);\n+\t\t    gcc_assert (flags == NO_SPECIAL);\n \t\t    flags = TYPENAME_FLAG;\n \t\t    ctor_return_type = TREE_TYPE (dname);\n \t\t    sfk = sfk_conversion;\n@@ -8297,7 +8291,7 @@ copy_fn_p (tree d)\n   tree arg_type;\n   int result = 1;\n \n-  my_friendly_assert (DECL_FUNCTION_MEMBER_P (d), 20011208);\n+  gcc_assert (DECL_FUNCTION_MEMBER_P (d));\n \n   if (DECL_TEMPLATE_INFO (d) && is_member_template (DECL_TI_TEMPLATE (d)))\n     /* Instantiations of template member functions are never copy\n@@ -8488,7 +8482,7 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \tabort ();\n       }\n     while (0);\n-  my_friendly_assert (operator_code != LAST_CPLUS_TREE_CODE, 20000526);\n+  gcc_assert (operator_code != LAST_CPLUS_TREE_CODE);\n   SET_OVERLOADED_OPERATOR_CODE (decl, operator_code);\n \n   if (! friendp)\n@@ -8892,7 +8886,7 @@ xref_tag (enum tag_types tag_code, tree name,\n \n   timevar_push (TV_NAME_LOOKUP);\n \n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   switch (tag_code)\n     {\n@@ -9099,8 +9093,8 @@ xref_basetypes (tree ref, tree base_list)\n \n   /* The binfo slot should be empty, unless this is an (ill-formed)\n      redefinition.  */\n-  my_friendly_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref), 20040706);\n-  my_friendly_assert (TYPE_MAIN_VARIANT (ref) == ref, 20040712);\n+  gcc_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref));\n+  gcc_assert (TYPE_MAIN_VARIANT (ref) == ref);\n \n   binfo = make_tree_binfo (max_bases);\n \n@@ -9603,8 +9597,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   tree current_function_parms;\n \n   /* Sanity check.  */\n-  my_friendly_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE, 160);\n-  my_friendly_assert (TREE_CHAIN (void_list_node) == NULL_TREE, 161);\n+  gcc_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE);\n+  gcc_assert (TREE_CHAIN (void_list_node) == NULL_TREE);\n \n   fntype = TREE_TYPE (decl1);\n   if (TREE_CODE (fntype) == METHOD_TYPE)\n@@ -9789,10 +9783,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t between `current_class_type' and `current_class_ptr'.  */\n       tree t = DECL_ARGUMENTS (decl1);\n \n-      my_friendly_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL,\n-\t\t\t  162);\n-      my_friendly_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE,\n-\t\t\t  19990811);\n+      gcc_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL);\n+      gcc_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE);\n \n       cp_function_chain->x_current_class_ref\n \t= build_indirect_ref (t, NULL);\n@@ -10047,8 +10039,7 @@ save_function_data (tree decl)\n \n   /* Save the language-specific per-function data so that we can\n      get it back when we really expand this function.  */\n-  my_friendly_assert (!DECL_PENDING_INLINE_P (decl),\n-\t\t      19990908);\n+  gcc_assert (!DECL_PENDING_INLINE_P (decl));\n \n   /* Make a copy.  */\n   f = GGC_NEW (struct language_function);\n@@ -10274,7 +10265,7 @@ finish_function (int flags)\n       This caused &foo to be of type ptr-to-const-function\n       which then got a warning when stored in a ptr-to-function variable.  */\n \n-  my_friendly_assert (building_stmt_tree (), 20000911);\n+  gcc_assert (building_stmt_tree ());\n \n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */\n@@ -10339,7 +10330,7 @@ finish_function (int flags)\n \n   /* Statements should always be full-expressions at the outermost set\n      of curly braces for a function.  */\n-  my_friendly_assert (stmts_are_full_exprs_p (), 19990831);\n+  gcc_assert (stmts_are_full_exprs_p ());\n \n   /* Set up the named return value optimization, if we can.  Candidate\n      variables are selected in check_return_value.  */\n@@ -10562,7 +10553,7 @@ finish_method (tree decl)\n     {\n       if (DECL_NAME (link) != NULL_TREE)\n \tpop_binding (DECL_NAME (link), link);\n-      my_friendly_assert (TREE_CODE (link) != FUNCTION_DECL, 163);\n+      gcc_assert (TREE_CODE (link) != FUNCTION_DECL);\n       DECL_CONTEXT (link) = NULL_TREE;\n     }\n \n@@ -10590,7 +10581,7 @@ finish_method (tree decl)\n void\n maybe_register_incomplete_var (tree var)\n {\n-  my_friendly_assert (TREE_CODE (var) == VAR_DECL, 20020406);\n+  gcc_assert (TREE_CODE (var) == VAR_DECL);\n \n   /* Keep track of variables with incomplete types.  */\n   if (!processing_template_decl && TREE_TYPE (var) != error_mark_node\n@@ -10619,7 +10610,7 @@ complete_vars (tree type)\n {\n   tree *list = &incomplete_vars;\n \n-  my_friendly_assert (CLASS_TYPE_P (type), 20020406);\n+  gcc_assert (CLASS_TYPE_P (type));\n   while (*list)\n     {\n       if (same_type_p (type, TREE_PURPOSE (*list)))"}, {"sha": "5da240f6075cf7b8f4a0f179addee479e20e47e2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -338,7 +338,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n     }\n \n   type = TREE_TYPE (array_expr);\n-  my_friendly_assert (type, 20030626);\n+  gcc_assert (type);\n   type = non_reference (type);\n \n   /* If they have an `operator[]', use that.  */\n@@ -473,7 +473,7 @@ check_member_template (tree tmpl)\n {\n   tree decl;\n \n-  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n   decl = DECL_TEMPLATE_RESULT (tmpl);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n@@ -612,11 +612,9 @@ check_classfn (tree ctype, tree function, tree template_parms)\n      either were not passed, or they are the same of DECL_TEMPLATE_PARMS.  */\n   if (TREE_CODE (function) == TEMPLATE_DECL)\n     {\n-      my_friendly_assert (!template_parms \n-\t\t\t  || comp_template_parms \n-\t\t\t      (template_parms, \n-\t\t\t       DECL_TEMPLATE_PARMS (function)),\n-\t\t\t  20040303);\n+      gcc_assert (!template_parms \n+\t\t  || comp_template_parms (template_parms, \n+\t\t\t\t\t  DECL_TEMPLATE_PARMS (function)));\n       template_parms = DECL_TEMPLATE_PARMS (function);\n     }\n \n@@ -765,7 +763,7 @@ void\n finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n                                 int flags)\n {\n-  my_friendly_assert (TREE_PUBLIC (decl), 0);\n+  gcc_assert (TREE_PUBLIC (decl));\n \n   DECL_CONTEXT (decl) = current_class_type;\n \n@@ -1238,7 +1236,7 @@ coerce_new_type (tree type)\n   int e = 0;\n   tree args = TYPE_ARG_TYPES (type);\n \n-  my_friendly_assert (TREE_CODE (type) == FUNCTION_TYPE, 20001107);\n+  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n   \n   if (!same_type_p (TREE_TYPE (type), ptr_type_node))\n     e = 1, error (\"`operator new' must return type `%T'\", ptr_type_node);\n@@ -1272,7 +1270,7 @@ coerce_delete_type (tree type)\n   int e = 0;\n   tree args = TYPE_ARG_TYPES (type);\n   \n-  my_friendly_assert (TREE_CODE (type) == FUNCTION_TYPE, 20001107);\n+  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n \n   if (!same_type_p (TREE_TYPE (type), void_type_node))\n     e = 1, error (\"`operator delete' must return type `%T'\", void_type_node);\n@@ -1435,7 +1433,7 @@ import_export_class (tree ctype)\n      non-abstract virtual member function has been defined in this\n      translation unit.  But, we can't possibly know that until we've\n      seen the entire translation unit.  */\n-  my_friendly_assert (at_eof, 20000226);\n+  gcc_assert (at_eof);\n \n   if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n     return;\n@@ -1520,13 +1518,12 @@ mark_needed (tree decl)\n bool\n decl_needed_p (tree decl)\n {\n-  my_friendly_assert (TREE_CODE (decl) == VAR_DECL\n-\t\t      || TREE_CODE (decl) == FUNCTION_DECL,\n-\t\t      20040726);\n+  gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == FUNCTION_DECL);\n   /* This function should only be called at the end of the translation\n      unit.  We cannot be sure of whether or not something will be\n      COMDAT until that point.  */\n-  my_friendly_assert (at_eof, 20040726);\n+  gcc_assert (at_eof);\n \n   /* All entities with external linkage that are not COMDAT should be\n      emitted; they may be referred to from other object files.  */\n@@ -1622,7 +1619,7 @@ determine_visibility (tree decl)\n   /* Cloned constructors and destructors get the same visibility as\n      the underlying function.  That should be set up in\n      maybe_clone_body.  */\n-  my_friendly_assert (!DECL_CLONED_FUNCTION_P (decl), 20040804);\n+  gcc_assert (!DECL_CLONED_FUNCTION_P (decl));\n \n   /* Give the common code a chance to make a determination.  */\n   if (c_determine_visibility (decl))\n@@ -1640,8 +1637,8 @@ determine_visibility (tree decl)\n     {\n       /* Virtual tables have DECL_CONTEXT set to their associated class,\n \t so they are automatically handled above.  */\n-      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL\n-\t\t\t    && DECL_VTABLE_OR_VTT_P (decl)), 20040803);\n+      gcc_assert (TREE_CODE (decl) != VAR_DECL\n+\t\t  || !DECL_VTABLE_OR_VTT_P (decl));\n       /* Entities not associated with any class just get the\n \t visibility specified by their attributes.  */\n       return;\n@@ -1705,7 +1702,7 @@ import_export_decl (tree decl)\n      \"-frepo\" it would be incorrect to make decisions about what\n      entities to emit when building the PCH; those decisions must be\n      delayed until the repository information has been processed.  */\n-  my_friendly_assert (at_eof, 20040727);\n+  gcc_assert (at_eof);\n   /* Object file linkage for explicit instantiations is handled in\n      mark_decl_instantiated.  For static variables in functions with\n      vague linkage, maybe_commonize_var is used.\n@@ -1728,25 +1725,22 @@ import_export_decl (tree decl)\n      definition available in this translation unit.\n \n      The following assertions check these conditions.  */\n-  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t      || TREE_CODE (decl) == VAR_DECL,\n-\t\t      2004725);\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || TREE_CODE (decl) == VAR_DECL);\n   /* Any code that creates entities with TREE_PUBLIC cleared should\n      also set DECL_INTERFACE_KNOWN.  */\n-  my_friendly_assert (TREE_PUBLIC (decl), 20040725);\n+  gcc_assert (TREE_PUBLIC (decl));\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n-    my_friendly_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n-\t\t\t|| DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl)\n-\t\t\t|| DECL_DECLARED_INLINE_P (decl),\n-\t\t\t20040725);\n+    gcc_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t|| DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl)\n+\t\t|| DECL_DECLARED_INLINE_P (decl));\n   else\n-    my_friendly_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n-\t\t\t|| DECL_VTABLE_OR_VTT_P (decl)\n-\t\t\t|| DECL_TINFO_P (decl),\n-\t\t\t20040725);\n+    gcc_assert (DECL_IMPLICIT_INSTANTIATION (decl)\n+\t\t|| DECL_VTABLE_OR_VTT_P (decl)\n+\t\t|| DECL_TINFO_P (decl));\n   /* Check that a definition of DECL is available in this translation\n      unit.  */\n-  my_friendly_assert (!DECL_REALLY_EXTERN (decl), 20040725);\n+  gcc_assert (!DECL_REALLY_EXTERN (decl));\n \n   /* Assume that DECL will not have COMDAT linkage.  */\n   comdat_p = false;\n@@ -1923,7 +1917,7 @@ build_cleanup (tree decl)\n \n   /* This function should only be called for declarations that really\n      require cleanups.  */\n-  my_friendly_assert (!TYPE_HAS_TRIVIAL_DESTRUCTOR (type), 20030106);\n+  gcc_assert (!TYPE_HAS_TRIVIAL_DESTRUCTOR (type));\n \n   /* Treat all objects with destructors as used; the destructor may do\n      something substantive.  */\n@@ -2378,7 +2372,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n \t{\n \t  /* When using __cxa_atexit, we never try to destroy\n \t     anything from a static destructor.  */\n-\t  my_friendly_assert (initp, 20000629);\n+\t  gcc_assert (initp);\n \t  guard_cond = get_guard_cond (guard);\n \t}\n       /* If we don't have __cxa_atexit, then we will be running\n@@ -2470,7 +2464,7 @@ do_static_destruction (tree decl)\n \n   /* If we're using __cxa_atexit, then destructors are registered\n      immediately after objects are initialized.  */\n-  my_friendly_assert (!flag_use_cxa_atexit, 20000121);\n+  gcc_assert (!flag_use_cxa_atexit);\n \n   /* If we don't need a destructor, there's nothing to do.  */\n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n@@ -2511,7 +2505,7 @@ prune_vars_needing_no_initialization (tree *vars)\n \t}\n \n       /* The only things that can be initialized are variables.  */\n-      my_friendly_assert (TREE_CODE (decl) == VAR_DECL, 19990420);\n+      gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n       /* If this object is not defined, we don't need to do anything\n \t here.  */\n@@ -3120,9 +3114,8 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \n   if (processing_template_decl)\n     {\n-      my_friendly_assert (TREE_CODE (fn) == DOTSTAR_EXPR\n-\t\t\t  || TREE_CODE (fn) == MEMBER_REF,\n-\t\t\t  20030708);\n+      gcc_assert (TREE_CODE (fn) == DOTSTAR_EXPR\n+\t\t  || TREE_CODE (fn) == MEMBER_REF);\n       if (type_dependent_expression_p (fn)\n \t  || any_type_dependent_arguments_p (args))\n \treturn build_min_nt (CALL_EXPR, fn, args, NULL_TREE);"}, {"sha": "dabac033108205f2edb3a75a633631f09746ce23", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -735,7 +735,7 @@ dump_decl (tree t, int flags)\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n \t  pp_string (cxx_pp, \"vtable for \");\n-\t  my_friendly_assert (TYPE_P (DECL_CONTEXT (t)), 20010720);\n+\t  gcc_assert (TYPE_P (DECL_CONTEXT (t)));\n \t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n \t}\n@@ -1528,7 +1528,7 @@ dump_expr (tree t, int flags)\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n \t  t = TREE_OPERAND (t, 0);\n-\t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n+\t  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n \t  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n \t  pp_cxx_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n@@ -1761,7 +1761,7 @@ dump_expr (tree t, int flags)\n         pp_cxx_identifier (cxx_pp, \"sizeof\");\n       else\n \t{\n-\t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n+\t  gcc_assert (TREE_CODE (t) == ALIGNOF_EXPR);\n \t  pp_cxx_identifier (cxx_pp, \"__alignof__\");\n \t}\n       pp_cxx_whitespace (cxx_pp);"}, {"sha": "1f172d2b2f53a1ea638e269cd14344a81be4def7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -87,7 +87,7 @@ finish_init_stmts (bool is_global, tree stmt_expr, tree compound_stmt)\n   \n   stmt_expr = finish_stmt_expr (stmt_expr, true);\n \n-  my_friendly_assert (!building_stmt_tree () == is_global, 20030726);\n+  gcc_assert (!building_stmt_tree () == is_global);\n   \n   return stmt_expr;\n }\n@@ -171,8 +171,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \n      -- if T is a reference type, no initialization is performed.  */\n \n-  my_friendly_assert (nelts == NULL_TREE || TREE_CODE (nelts) == INTEGER_CST,\n-\t\t      20030618);\n+  gcc_assert (nelts == NULL_TREE || TREE_CODE (nelts) == INTEGER_CST);\n \n   if (type == error_mark_node)\n     ;\n@@ -226,7 +225,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n       /* Iterate over the array elements, building initializations.  */\n       inits = NULL_TREE;\n       max_index = nelts ? nelts : array_type_nelts (type);\n-      my_friendly_assert (TREE_CODE (max_index) == INTEGER_CST, 20030618);\n+      gcc_assert (TREE_CODE (max_index) == INTEGER_CST);\n \n       /* A zero-sized array, which is accepted as an extension, will\n \t have an upper bound of -1.  */\n@@ -787,7 +786,7 @@ expand_virtual_init (tree binfo, tree decl)\n   /* Compute the location of the vtpr.  */\n   vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL),\n \t\t\t       TREE_TYPE (binfo));\n-  my_friendly_assert (vtbl_ptr != error_mark_node, 20010730);\n+  gcc_assert (vtbl_ptr != error_mark_node);\n \n   /* Assign the vtable to the vptr.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n@@ -1180,7 +1179,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n       else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  /* A brace-enclosed initializer for an aggregate.  */\n-\t  my_friendly_assert (CP_AGGREGATE_TYPE_P (type), 20021016);\n+\t  gcc_assert (CP_AGGREGATE_TYPE_P (type));\n \t  init = digest_init (type, init, (tree *)NULL);\n \t}\n       else\n@@ -1248,8 +1247,8 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n {\n   tree type = TREE_TYPE (exp);\n \n-  my_friendly_assert (init != error_mark_node && type != error_mark_node, 211);\n-  my_friendly_assert (building_stmt_tree (), 20021010);\n+  gcc_assert (init != error_mark_node && type != error_mark_node);\n+  gcc_assert (building_stmt_tree ());\n \n   /* Use a function returning the desired type to initialize EXP for us.\n      If the function is a constructor, and its first argument is\n@@ -1351,7 +1350,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t    name = DECL_NAME (OVL_CURRENT (name));\n \t}\n \n-      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n+      gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n     }\n \n   if (type == NULL_TREE)\n@@ -1953,7 +1952,7 @@ build_new_1 (tree exp)\n   while (TREE_CODE (alloc_call) == COMPOUND_EXPR) \n     alloc_call = TREE_OPERAND (alloc_call, 1);\n   alloc_fn = get_callee_fndecl (alloc_call);\n-  my_friendly_assert (alloc_fn != NULL_TREE, 20020325);\n+  gcc_assert (alloc_fn != NULL_TREE);\n \n   /* Now, check to see if this function is actually a placement\n      allocation function.  This can happen even when PLACEMENT is NULL\n@@ -2769,7 +2768,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       addr = convert_force (build_pointer_type (type), addr, 0);\n     }\n \n-  my_friendly_assert (IS_AGGR_TYPE (type), 220);\n+  gcc_assert (IS_AGGR_TYPE (type));\n \n   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     {\n@@ -2785,7 +2784,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       tree do_delete = NULL_TREE;\n       tree ifexp;\n \n-      my_friendly_assert (TYPE_HAS_DESTRUCTOR (type), 20011213);\n+      gcc_assert (TYPE_HAS_DESTRUCTOR (type));\n \n       /* For `::delete x', we must not use the deleting destructor\n \t since then we would not be sure to get the global `operator\n@@ -2935,7 +2934,7 @@ build_vbase_delete (tree type, tree decl)\n   VEC (tree) *vbases;\n   tree addr = build_unary_op (ADDR_EXPR, decl, 0);\n \n-  my_friendly_assert (addr != error_mark_node, 222);\n+  gcc_assert (addr != error_mark_node);\n \n   result = convert_to_void (integer_zero_node, NULL);\n   for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;"}, {"sha": "d1a5766f2ab9270ab632487d7a1e1af122ec052c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -1853,7 +1853,7 @@ write_method_parms (tree parm_types, const int method_p, const tree decl)\n \t     fixed-length.  */\n \t  varargs_p = 0;\n \t  /* A void type better be the last one.  */\n-\t  my_friendly_assert (TREE_CHAIN (parm_types) == NULL, 20000523);\n+\t  gcc_assert (TREE_CHAIN (parm_types) == NULL);\n \t}\n       else\n \twrite_type (parm);\n@@ -1887,7 +1887,7 @@ write_template_args (tree args)\n \n   write_char ('I');\n \n-  my_friendly_assert (length > 0, 20000422);\n+  gcc_assert (length > 0);\n \n   if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n     {\n@@ -2095,8 +2095,7 @@ write_expression (tree expr)\n \t      template_id = TREE_OPERAND (expr, 1);\n \t      name = TREE_OPERAND (template_id, 0);\n \t      /* FIXME: What about operators?  */\n-\t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE,\n-\t\t\t\t  20030707);\n+\t      gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \t      write_source_name (TREE_OPERAND (template_id, 0));\n \t      write_template_args (TREE_OPERAND (template_id, 1));\n \t    }\n@@ -2201,8 +2200,7 @@ write_template_arg (tree node)\n       /* Template parameters can be of reference type. To maintain\n \t internal consistency, such arguments use a conversion from\n \t address of object to reference type.  */\n-      my_friendly_assert (TREE_CODE (TREE_OPERAND (node, 0)) == ADDR_EXPR,\n-\t\t\t  20031215);\n+      gcc_assert (TREE_CODE (TREE_OPERAND (node, 0)) == ADDR_EXPR);\n       if (abi_version_at_least (2))\n \tnode = TREE_OPERAND (TREE_OPERAND (node, 0), 0);\n       else"}, {"sha": "2a7ddb5a50c48b69399647121a921755b74d1015", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -88,11 +88,10 @@ make_thunk (tree function, bool this_adjusting,\n   HOST_WIDE_INT d;\n   tree thunk;\n   \n-  my_friendly_assert (TREE_CODE (function) == FUNCTION_DECL, 20021025);\n+  gcc_assert (TREE_CODE (function) == FUNCTION_DECL);\n   /* We can have this thunks to covariant thunks, but not vice versa.  */\n-  my_friendly_assert (!DECL_THIS_THUNK_P (function), 20021127);\n-  my_friendly_assert (!DECL_RESULT_THUNK_P (function) || this_adjusting,\n-\t\t      20031123);\n+  gcc_assert (!DECL_THIS_THUNK_P (function));\n+  gcc_assert (!DECL_RESULT_THUNK_P (function) || this_adjusting);\n   \n   /* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */\n   if (this_adjusting && virtual_offset)\n@@ -121,12 +120,11 @@ make_thunk (tree function, bool this_adjusting,\n   /* All thunks must be created before FUNCTION is actually emitted;\n      the ABI requires that all thunks be emitted together with the\n      function to which they transfer control.  */\n-  my_friendly_assert (!TREE_ASM_WRITTEN (function), 20021025);\n+  gcc_assert (!TREE_ASM_WRITTEN (function));\n   /* Likewise, we can only be adding thunks to a function declared in\n      the class currently being laid out.  */\n-  my_friendly_assert (TYPE_SIZE (DECL_CONTEXT (function))\n-\t\t      && TYPE_BEING_DEFINED (DECL_CONTEXT (function)),\n-\t\t      20031211);\n+  gcc_assert (TYPE_SIZE (DECL_CONTEXT (function))\n+\t      && TYPE_BEING_DEFINED (DECL_CONTEXT (function)));\n \n   thunk = build_decl (FUNCTION_DECL, NULL_TREE, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (function);\n@@ -182,7 +180,7 @@ finish_thunk (tree thunk)\n   tree fixed_offset = ssize_int (THUNK_FIXED_OFFSET (thunk));\n   tree virtual_offset = THUNK_VIRTUAL_OFFSET (thunk);\n \n-  my_friendly_assert (!DECL_NAME (thunk) && DECL_THUNK_P (thunk), 20021127);\n+  gcc_assert (!DECL_NAME (thunk) && DECL_THUNK_P (thunk));\n   if (virtual_offset && DECL_RESULT_THUNK_P (thunk))\n     virtual_offset = BINFO_VPTR_FIELD (virtual_offset);\n   function = THUNK_TARGET (thunk);\n@@ -202,7 +200,7 @@ finish_thunk (tree thunk)\n \t   cov_probe; cov_probe = TREE_CHAIN (cov_probe))\n \tif (DECL_NAME (cov_probe) == name)\n \t  {\n-\t    my_friendly_assert (!DECL_THUNKS (thunk), 20031023);\n+\t    gcc_assert (!DECL_THUNKS (thunk));\n \t    THUNK_ALIAS (thunk) = (THUNK_ALIAS (cov_probe)\n \t\t\t\t   ? THUNK_ALIAS (cov_probe) : cov_probe);\n \t    break;\n@@ -317,11 +315,11 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n   bool this_adjusting = DECL_THIS_THUNK_P (thunk_fndecl);\n \n   /* We should have called finish_thunk to give it a name.  */\n-  my_friendly_assert (DECL_NAME (thunk_fndecl), 20021127);\n+  gcc_assert (DECL_NAME (thunk_fndecl));\n \n   /* We should never be using an alias, always refer to the\n      aliased thunk.  */\n-  my_friendly_assert (!THUNK_ALIAS (thunk_fndecl), 20031023);\n+  gcc_assert (!THUNK_ALIAS (thunk_fndecl));\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n@@ -355,7 +353,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       if (!this_adjusting)\n \tvirtual_offset = BINFO_VPTR_FIELD (virtual_offset);\n       virtual_value = tree_low_cst (virtual_offset, /*pos=*/0);\n-      my_friendly_assert (virtual_value, 20021026);\n+      gcc_assert (virtual_value);\n     }\n   else\n     virtual_value = 0;"}, {"sha": "47f8cc262d5ed6338aff62b9ba5e287796251145", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -451,7 +451,7 @@ pop_binding (tree id, tree decl)\n   binding = IDENTIFIER_BINDING (id);\n \n   /* The name should be bound.  */\n-  my_friendly_assert (binding != NULL, 0);\n+  gcc_assert (binding != NULL);\n \n   /* The DECL will be either the ordinary binding or the type\n      binding for this identifier.  Remove that binding.  */\n@@ -1345,7 +1345,7 @@ begin_scope (scope_kind kind, tree entity)\n \n     default:\n       /* Should not happen.  */\n-      my_friendly_assert (false, 20030922);\n+      gcc_unreachable ();\n       break;\n     }\n   scope->kind = kind;\n@@ -1368,7 +1368,7 @@ leave_scope (void)\n \n   /* We cannot leave a scope, if there are none left.  */\n   if (NAMESPACE_LEVEL (global_namespace))\n-    my_friendly_assert (!global_scope_p (scope), 20030527);\n+    gcc_assert (!global_scope_p (scope));\n   \n   if (ENABLE_SCOPE_CHECKING)\n     {\n@@ -1398,9 +1398,8 @@ leave_scope (void)\n         scope->type_decls = NULL;\n       else\n         binding_table_free (scope->type_decls);\n-      my_friendly_assert (!ENABLE_SCOPE_CHECKING\n-                          || scope->binding_depth == binding_depth,\n-                          20030529);\n+      gcc_assert (!ENABLE_SCOPE_CHECKING\n+\t\t  || scope->binding_depth == binding_depth);\n       free_binding_level = scope;\n     }\n \n@@ -1420,9 +1419,9 @@ resume_scope (struct cp_binding_level* b)\n {\n   /* Resuming binding levels is meant only for namespaces,\n      and those cannot nest into classes.  */\n-  my_friendly_assert(!class_binding_level, 386);\n+  gcc_assert (!class_binding_level);\n   /* Also, resuming a non-directly nested namespace is a no-no.  */\n-  my_friendly_assert(b->level_chain == current_binding_level, 386);\n+  gcc_assert (b->level_chain == current_binding_level);\n   current_binding_level = b;\n   if (ENABLE_SCOPE_CHECKING)\n     {\n@@ -1929,8 +1928,8 @@ push_using_decl (tree scope, tree name)\n   tree decl;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n+  gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n     if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n       break;\n@@ -2151,7 +2150,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n   if (is_overloaded_fn (decl))\n     decl = get_first_fn (decl);\n \n-  my_friendly_assert (DECL_P (decl), 20020908);\n+  gcc_assert (DECL_P (decl));\n \n   /* Make a USING_DECL.  */\n   return push_using_decl (scope, name);\n@@ -2517,12 +2516,11 @@ lookup_tag_reverse (tree type, tree name)\n bool\n is_ancestor (tree root, tree child)\n {\n-  my_friendly_assert ((TREE_CODE (root) == NAMESPACE_DECL\n-\t\t       || TREE_CODE (root) == FUNCTION_DECL\n-\t\t       || CLASS_TYPE_P (root)), 20030307);\n-  my_friendly_assert ((TREE_CODE (child) == NAMESPACE_DECL\n-\t\t       || CLASS_TYPE_P (child)),\n-\t\t      20030307);\n+  gcc_assert ((TREE_CODE (root) == NAMESPACE_DECL\n+\t       || TREE_CODE (root) == FUNCTION_DECL\n+\t       || CLASS_TYPE_P (root)));\n+  gcc_assert ((TREE_CODE (child) == NAMESPACE_DECL\n+\t       || CLASS_TYPE_P (child)));\n   \n   /* The global namespace encloses everything.  */\n   if (root == global_namespace)\n@@ -2602,7 +2600,7 @@ poplevel_class (void)\n   tree shadowed;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (level != 0, 354);\n+  gcc_assert (level != 0);\n \n   /* If we're leaving a toplevel class, cache its binding level.  */\n   if (current_class_depth == 1)\n@@ -2648,7 +2646,7 @@ set_inherited_value_binding_p (cxx_binding *binding, tree decl,\n \tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n       else\n \t{\n-\t  my_friendly_assert (DECL_P (decl), 0);\n+\t  gcc_assert (DECL_P (decl));\n \t  context = context_for_name_lookup (decl);\n \t}\n \n@@ -2786,7 +2784,7 @@ push_class_level_binding (tree name, tree x)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n \n   /* Check for invalid member names.  */\n-  my_friendly_assert (TYPE_BEING_DEFINED (current_class_type), 20040713);\n+  gcc_assert (TYPE_BEING_DEFINED (current_class_type));\n   /* We could have been passed a tree list if this is an ambiguous\n      declaration. If so, pull the declaration out because\n      check_template_shadow will not handle a TREE_LIST. */\n@@ -2940,7 +2938,7 @@ do_class_using_decl (tree decl)\n       name = DECL_NAME (get_first_fn (fns));\n     }\n \n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   /* Dependent using decls have a NULL type, non-dependent ones have a\n      void type.  */\n@@ -3085,8 +3083,7 @@ push_namespace (tree name)\n   /* We should not get here if the global_namespace is not yet constructed\n      nor if NAME designates the global namespace:  The global scope is\n      constructed elsewhere.  */\n-  my_friendly_assert (global_namespace != NULL && name != global_scope_name,\n-                      20030531);\n+  gcc_assert (global_namespace != NULL && name != global_scope_name);\n \n   if (anon)\n     {\n@@ -3147,7 +3144,7 @@ push_namespace (tree name)\n void\n pop_namespace (void)\n {\n-  my_friendly_assert (current_namespace != global_namespace, 20010801);\n+  gcc_assert (current_namespace != global_namespace);\n   current_namespace = CP_DECL_CONTEXT (current_namespace);\n   /* The binding level is not popped, as it might be re-opened later.  */\n   leave_scope ();\n@@ -3301,8 +3298,8 @@ add_using_namespace (tree user, tree used, bool indirect)\n       timevar_pop (TV_NAME_LOOKUP);\n       return;\n     }\n-  my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n-  my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n+  gcc_assert (TREE_CODE (user) == NAMESPACE_DECL);\n+  gcc_assert (TREE_CODE (used) == NAMESPACE_DECL);\n   /* Check if we already have this.  */\n   t = purpose_member (used, DECL_NAMESPACE_USING (user));\n   if (t != NULL_TREE)\n@@ -3523,7 +3520,7 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n \t\tint flags)\n {\n   tree val, type;\n-  my_friendly_assert (old != NULL, 393);\n+  gcc_assert (old != NULL);\n   /* Copy the value.  */\n   val = new->value;\n   if (val)\n@@ -3646,7 +3643,7 @@ lookup_namespace_name (tree namespace, tree name)\n   struct scope_binding binding = EMPTY_SCOPE_BINDING;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n+  gcc_assert (TREE_CODE (namespace) == NAMESPACE_DECL);\n \n   if (TREE_CODE (name) == NAMESPACE_DECL)\n     /* This happens for A::B<int> when B is a namespace.  */\n@@ -3671,7 +3668,7 @@ lookup_namespace_name (tree namespace, tree name)\n \tname = DECL_NAME (name);\n     }\n \n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   if (!qualified_lookup_using_namespace (name, namespace, &binding, 0))\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n@@ -4181,8 +4178,7 @@ lookup_type_current_level (tree name)\n   tree t = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (current_binding_level->kind != sk_namespace, \n-\t\t      980716);\n+  gcc_assert (current_binding_level->kind != sk_namespace);\n \n   if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n       && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n@@ -4668,9 +4664,7 @@ maybe_process_template_type_declaration (tree type, int globalize,\n     {\n       maybe_check_template_type (type);\n \n-      my_friendly_assert (IS_AGGR_TYPE (type)\n-\t\t\t  || TREE_CODE (type) == ENUMERAL_TYPE, 0);\n-\n+      gcc_assert (IS_AGGR_TYPE (type) || TREE_CODE (type) == ENUMERAL_TYPE);\n \n       if (processing_template_decl)\n \t{"}, {"sha": "9d5e18b723a3709aedabb4767b6ab5e3b6f71209", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -714,7 +714,7 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n   cp_token *token;\n \n   /* N is 1-based, not zero-based.  */\n-  my_friendly_assert (n > 0, 20000224);\n+  gcc_assert (n > 0);\n \n   /* Skip ahead from NEXT_TOKEN, reading more tokens as necessary.  */\n   token = lexer->next_token;\n@@ -2272,7 +2272,7 @@ cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n   /* If we got here, this cannot be a valid variable declaration, thus\n      the cp_parser_id_expression must have resolved to a plain identifier\n      node (not a TYPE_DECL or TEMPLATE_ID_EXPR).  */\n-  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 20030203);\n+  gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE);\n   /* Emit a diagnostic for the invalid type.  */\n   cp_parser_diagnose_invalid_type_name (parser, parser->scope, id);\n   /* Skip to the end of the declaration; there's no point in\n@@ -2668,9 +2668,8 @@ cp_parser_translation_unit (cp_parser* parser)\n     }\n \n   /* Make sure the declarator obstack was fully cleaned up.  */\n-  my_friendly_assert (obstack_next_free (&declarator_obstack) ==\n-\t\t      declarator_obstack_base,\n-\t\t      20040621);\n+  gcc_assert (obstack_next_free (&declarator_obstack)\n+\t      == declarator_obstack_base);\n \n   /* All went well.  */\n   return success;\n@@ -8529,10 +8528,9 @@ cp_parser_template_id (cp_parser *parser,\n     {\n       /* If it's not a class-template or a template-template, it should be\n \t a function-template.  */\n-      my_friendly_assert ((DECL_FUNCTION_TEMPLATE_P (template)\n-\t\t\t   || TREE_CODE (template) == OVERLOAD\n-\t\t\t   || BASELINK_P (template)),\n-\t\t\t  20010716);\n+      gcc_assert ((DECL_FUNCTION_TEMPLATE_P (template)\n+\t\t   || TREE_CODE (template) == OVERLOAD\n+\t\t   || BASELINK_P (template)));\n \n       template_id = lookup_template_function (template, arguments);\n     }\n@@ -14181,9 +14179,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     return name;\n   if (BASELINK_P (name))\n     {\n-      my_friendly_assert ((TREE_CODE (BASELINK_FUNCTIONS (name))\n-\t\t\t   == TEMPLATE_ID_EXPR),\n-\t\t\t  20020909);\n+      gcc_assert (TREE_CODE (BASELINK_FUNCTIONS (name))\n+\t\t  == TEMPLATE_ID_EXPR);\n       return name;\n     }\n \n@@ -14213,8 +14210,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   /* By this point, the NAME should be an ordinary identifier.  If\n      the id-expression was a qualified name, the qualifying scope is\n      stored in PARSER->SCOPE at this point.  */\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE,\n-\t\t      20000619);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   /* Perform the lookup.  */\n   if (parser->scope)\n@@ -14326,12 +14322,11 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       return error_mark_node;\n     }\n \n-  my_friendly_assert (DECL_P (decl)\n-\t\t      || TREE_CODE (decl) == OVERLOAD\n-\t\t      || TREE_CODE (decl) == SCOPE_REF\n-\t\t      || TREE_CODE (decl) == UNBOUND_CLASS_TEMPLATE\n-\t\t      || BASELINK_P (decl),\n-\t\t      20000619);\n+  gcc_assert (DECL_P (decl)\n+\t      || TREE_CODE (decl) == OVERLOAD\n+\t      || TREE_CODE (decl) == SCOPE_REF\n+\t      || TREE_CODE (decl) == UNBOUND_CLASS_TEMPLATE\n+\t      || BASELINK_P (decl));\n \n   /* If we have resolved the name of a member declaration, check to\n      see if the declaration is accessible.  When the name resolves to\n@@ -15223,7 +15218,7 @@ cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n   /* There should not be any class definitions in progress at this\n      point; the bodies of members are only parsed outside of all class\n      definitions.  */\n-  my_friendly_assert (parser->num_classes_being_defined == 0, 20010816);\n+  gcc_assert (parser->num_classes_being_defined == 0);\n   /* While we're parsing the member functions we might encounter more\n      classes.  We want to handle them right away, but we don't want\n      them getting mixed up with functions that are currently in the"}, {"sha": "c198118a855a5515b547152bcd3dfe5eca3a5d47", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 77, "deletions": 90, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -176,9 +176,8 @@ static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static void\n push_access_scope (tree t)\n {\n-  my_friendly_assert (TREE_CODE (t) == FUNCTION_DECL\n-\t\t      || TREE_CODE (t) == VAR_DECL,\n-\t\t      0);\n+  gcc_assert (TREE_CODE (t) == FUNCTION_DECL\n+\t      || TREE_CODE (t) == VAR_DECL);\n \n   if (DECL_CLASS_SCOPE_P (t))\n     push_nested_class (DECL_CONTEXT (t));\n@@ -222,7 +221,7 @@ finish_member_template_decl (tree decl)\n   if (decl == error_mark_node)\n     return error_mark_node;\n \n-  my_friendly_assert (DECL_P (decl), 20020812);\n+  gcc_assert (DECL_P (decl));\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n@@ -357,7 +356,7 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i) \n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n-      my_friendly_assert (DECL_P (parm), 0);\n+      gcc_assert (DECL_P (parm));\n \n       switch (TREE_CODE (parm))\n \t{\n@@ -542,8 +541,7 @@ add_outermost_template_args (tree args, tree extra_args)\n \n   /* If there are more levels of EXTRA_ARGS than there are ARGS,\n      something very fishy is going on.  */\n-  my_friendly_assert (TMPL_ARGS_DEPTH (args) >= TMPL_ARGS_DEPTH (extra_args),\n-\t\t      0);\n+  gcc_assert (TMPL_ARGS_DEPTH (args) >= TMPL_ARGS_DEPTH (extra_args));\n \n   /* If *all* the new arguments will be the EXTRA_ARGS, just return\n      them.  */\n@@ -570,7 +568,7 @@ get_innermost_template_args (tree args, int n)\n   int extra_levels;\n   int i;\n \n-  my_friendly_assert (n >= 0, 20000603);\n+  gcc_assert (n >= 0);\n \n   /* If N is 1, just return the innermost set of template arguments.  */\n   if (n == 1)\n@@ -579,7 +577,7 @@ get_innermost_template_args (tree args, int n)\n   /* If we're not removing anything, just return the arguments we were\n      given.  */\n   extra_levels = TMPL_ARGS_DEPTH (args) - n;\n-  my_friendly_assert (extra_levels >= 0, 20000603);\n+  gcc_assert (extra_levels >= 0);\n   if (extra_levels == 0)\n     return args;\n \n@@ -696,15 +694,15 @@ note_template_header (int specialization)\n void\n begin_explicit_instantiation (void)\n {\n-  my_friendly_assert (!processing_explicit_instantiation, 20020913);\n+  gcc_assert (!processing_explicit_instantiation);\n   processing_explicit_instantiation = true;\n }\n \n \n void\n end_explicit_instantiation (void)\n {\n-  my_friendly_assert(processing_explicit_instantiation, 20020913);\n+  gcc_assert (processing_explicit_instantiation);\n   processing_explicit_instantiation = false;\n }\n \n@@ -843,13 +841,12 @@ retrieve_specialization (tree tmpl, tree args)\n {\n   tree s;\n \n-  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n   /* There should be as many levels of arguments as there are\n      levels of parameters.  */\n-  my_friendly_assert (TMPL_ARGS_DEPTH (args) \n-\t\t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)),\n-\t\t      0);\n+  gcc_assert (TMPL_ARGS_DEPTH (args) \n+\t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)));\n \t\t      \n   for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n        s != NULL_TREE;\n@@ -887,7 +884,7 @@ is_specialization_of (tree decl, tree tmpl)\n     }\n   else \n     {\n-      my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 0);\n+      gcc_assert (TREE_CODE (decl) == TYPE_DECL);\n \n       for (t = TREE_TYPE (decl);\n \t   t != NULL_TREE;\n@@ -909,7 +906,7 @@ is_specialization_of_friend (tree decl, tree friend)\n   bool need_template = true;\n   int template_depth;\n \n-  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   /* For [temp.friend/6] when FRIEND is an ordinary member function\n      of a template class, we want to check if DECL is a specialization\n@@ -1043,7 +1040,7 @@ register_specialization (tree spec, tree tmpl, tree args)\n {\n   tree s;\n \n-  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 0);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n   if (TREE_CODE (spec) == FUNCTION_DECL \n       && uses_template_parms (DECL_TI_ARGS (spec)))\n@@ -1062,9 +1059,8 @@ register_specialization (tree spec, tree tmpl, tree args)\n \n   /* There should be as many levels of arguments as there are\n      levels of parameters.  */\n-  my_friendly_assert (TMPL_ARGS_DEPTH (args) \n-\t\t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)),\n-\t\t      0);\n+  gcc_assert (TMPL_ARGS_DEPTH (args) \n+\t      == TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl)));\n \n   for (s = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n        s != NULL_TREE;\n@@ -1790,14 +1786,14 @@ check_explicit_specialization (tree declarator,\n \t{\n \t  tree fns;\n \n-\t  my_friendly_assert (TREE_CODE (declarator) == IDENTIFIER_NODE, 0);\n+\t  gcc_assert (TREE_CODE (declarator) == IDENTIFIER_NODE);\n \t  if (ctype)\n \t    fns = dname;\n \t  else\n \t    {\n \t      /* If there is no class context, the explicit instantiation\n                  must be at namespace scope.  */\n-\t      my_friendly_assert (DECL_NAMESPACE_SCOPE_P (decl), 20030625);\n+\t      gcc_assert (DECL_NAMESPACE_SCOPE_P (decl));\n \n \t      /* Find the namespace binding, using the declaration\n                  context.  */\n@@ -2064,7 +2060,8 @@ maybe_check_template_type (tree type)\n    parameters.  These are represented in the same format used for\n    DECL_TEMPLATE_PARMS.  */\n \n-int comp_template_parms (tree parms1, tree parms2)\n+int\n+comp_template_parms (tree parms1, tree parms2)\n {\n   tree p1;\n   tree p2;\n@@ -2080,8 +2077,8 @@ int comp_template_parms (tree parms1, tree parms2)\n       tree t2 = TREE_VALUE (p2);\n       int i;\n \n-      my_friendly_assert (TREE_CODE (t1) == TREE_VEC, 0);\n-      my_friendly_assert (TREE_CODE (t2) == TREE_VEC, 0);\n+      gcc_assert (TREE_CODE (t1) == TREE_VEC);\n+      gcc_assert (TREE_CODE (t2) == TREE_VEC);\n \n       if (TREE_VEC_LENGTH (t1) != TREE_VEC_LENGTH (t2))\n \treturn 0;\n@@ -2224,7 +2221,7 @@ process_template_parm (tree list, tree next, bool is_non_type)\n   int idx;\n \n   parm = next;\n-  my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 259);\n+  gcc_assert (TREE_CODE (parm) == TREE_LIST);\n   defval = TREE_PURPOSE (parm);\n \n   if (list)\n@@ -2576,7 +2573,7 @@ process_partial_specialization (tree decl)\n      The type of a template parameter corresponding to a specialized\n      non-type argument shall not be dependent on a parameter of the\n      specialization.  */\n-  my_friendly_assert (nargs == DECL_NTPARMS (maintmpl), 0);\n+  gcc_assert (nargs == DECL_NTPARMS (maintmpl));\n   tpd2.parms = 0;\n   for (i = 0; i < nargs; ++i)\n     {\n@@ -3468,8 +3465,7 @@ convert_nontype_argument (tree type, tree expr)\n \n \t    expr = build_unary_op (ADDR_EXPR, fn, 0);\n \n-\t    my_friendly_assert (same_type_p (type, TREE_TYPE (expr)), \n-\t\t\t\t0);\n+\t    gcc_assert (same_type_p (type, TREE_TYPE (expr)));\n \t    return expr;\n \t  }\n \telse \n@@ -3507,7 +3503,7 @@ convert_nontype_argument (tree type, tree expr)\n \t    if (TREE_CODE (expr) == NOP_EXPR\n \t\t&& TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n \t      STRIP_NOPS (expr);\n-\t    my_friendly_assert (TREE_CODE (expr) == ADDR_EXPR, 20000604);\n+\t    gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n \t    expr = TREE_OPERAND (expr, 0);\n \t    expr_type = TREE_TYPE (expr);\n \t  }\n@@ -3537,10 +3533,7 @@ convert_nontype_argument (tree type, tree expr)\n \t\t  goto bad_argument;\n \t      }\n \n-\t    my_friendly_assert (same_type_p (type_referred_to, \n-\t\t\t\t\t     TREE_TYPE (fn)),\n-\t\t\t\t0);\n-\n+\t    gcc_assert (same_type_p (type_referred_to, TREE_TYPE (fn)));\n \t    expr = fn;\n \t  }\n \telse\n@@ -3566,7 +3559,7 @@ convert_nontype_argument (tree type, tree expr)\n \n     case RECORD_TYPE:\n       {\n-\tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 20010112);\n+\tgcc_assert (TYPE_PTRMEMFUNC_P (type));\n \n \t/* For a non-type template-parameter of type pointer to member\n \t   function, no conversions apply.  If the template-argument\n@@ -3638,8 +3631,8 @@ coerce_template_template_parms (tree parm_parms,\n   int nparms, nargs, i;\n   tree parm, arg;\n \n-  my_friendly_assert (TREE_CODE (parm_parms) == TREE_VEC, 0);\n-  my_friendly_assert (TREE_CODE (arg_parms) == TREE_VEC, 0);\n+  gcc_assert (TREE_CODE (parm_parms) == TREE_VEC);\n+  gcc_assert (TREE_CODE (arg_parms) == TREE_VEC);\n \n   nparms = TREE_VEC_LENGTH (parm_parms);\n   nargs = TREE_VEC_LENGTH (arg_parms);\n@@ -3932,7 +3925,7 @@ coerce_template_parms (tree parms,\n       else\n \tbreak;\n       \n-      my_friendly_assert (arg, 20030727);\n+      gcc_assert (arg);\n       if (arg == error_mark_node)\n \terror (\"template argument %d is invalid\", i + 1);\n       else \n@@ -4015,7 +4008,7 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n   ccat ('<');\n   nparms = TREE_VEC_LENGTH (parms);\n   arglist = INNERMOST_TEMPLATE_ARGS (arglist);\n-  my_friendly_assert (nparms == TREE_VEC_LENGTH (arglist), 268);\n+  gcc_assert (nparms == TREE_VEC_LENGTH (arglist));\n   for (i = 0; i < nparms; i++)\n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n@@ -4040,11 +4033,11 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n                 {\n                   /* The template may be defined in a namespace, or\n                      may be a member template.  */\n-                  my_friendly_assert (TREE_CODE (context) == NAMESPACE_DECL\n-                                      || CLASS_TYPE_P (context), \n-                                      980422);\n-\t\t  cat(decl_as_string (DECL_CONTEXT (arg), TFF_PLAIN_IDENTIFIER));\n-\t\t  cat(\"::\");\n+                  gcc_assert (TREE_CODE (context) == NAMESPACE_DECL\n+\t\t\t      || CLASS_TYPE_P (context));\n+\t\t  cat (decl_as_string (DECL_CONTEXT (arg),\n+\t\t\t\t      TFF_PLAIN_IDENTIFIER));\n+\t\t  cat (\"::\");\n \t\t}\n \t      cat (IDENTIFIER_POINTER (DECL_NAME (arg)));\n \t    }\n@@ -4054,7 +4047,7 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n \t  continue;\n \t}\n       else\n-\tmy_friendly_assert (TREE_CODE (parm) == PARM_DECL, 269);\n+\tgcc_assert (TREE_CODE (parm) == PARM_DECL);\n \n       /* No need to check arglist against parmlist here; we did that\n \t in coerce_template_parms, called from lookup_template_class.  */\n@@ -4151,19 +4144,18 @@ lookup_template_function (tree fns, tree arglist)\n   if (fns == error_mark_node || arglist == error_mark_node)\n     return error_mark_node;\n \n-  my_friendly_assert (!arglist || TREE_CODE (arglist) == TREE_VEC, 20030726);\n+  gcc_assert (!arglist || TREE_CODE (arglist) == TREE_VEC);\n   if (fns == NULL_TREE \n       || TREE_CODE (fns) == FUNCTION_DECL)\n     {\n       error (\"non-template used as template\");\n       return error_mark_node;\n     }\n \n-  my_friendly_assert (TREE_CODE (fns) == TEMPLATE_DECL\n-\t\t      || TREE_CODE (fns) == OVERLOAD\n-\t\t      || BASELINK_P (fns)\n-\t\t      || TREE_CODE (fns) == IDENTIFIER_NODE,\n-\t\t      20020730);\n+  gcc_assert (TREE_CODE (fns) == TEMPLATE_DECL\n+\t      || TREE_CODE (fns) == OVERLOAD\n+\t      || BASELINK_P (fns)\n+\t      || TREE_CODE (fns) == IDENTIFIER_NODE);\n \n   if (BASELINK_P (fns))\n     {\n@@ -4376,7 +4368,7 @@ lookup_template_class (tree d1,\n \t}\n \n       /* Now we should have enough arguments.  */\n-      my_friendly_assert (parm_depth == arg_depth, 0);\n+      gcc_assert (parm_depth == arg_depth);\n       \n       /* From here on, we're only interested in the most general\n \t template.  */\n@@ -5368,7 +5360,7 @@ instantiate_class_template (tree type)\n \n   /* Figure out which template is being instantiated.  */\n   template = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n-  my_friendly_assert (TREE_CODE (template) == TEMPLATE_DECL, 279);\n+  gcc_assert (TREE_CODE (template) == TEMPLATE_DECL);\n \n   /* Figure out which arguments are being used to do the\n      instantiation.  */\n@@ -6078,7 +6070,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t    /* tsubst_template_args doesn't copy the vector if\n \t       nothing changed.  But, *something* should have\n \t       changed.  */\n-\t    my_friendly_assert (full_args != tmpl_args, 0);\n+\t    gcc_assert (full_args != tmpl_args);\n \n \t    spec = retrieve_specialization (t, full_args);\n \t    if (spec != NULL_TREE)\n@@ -6094,7 +6086,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t   like the old one, but points to this new template, rather\n \t   than the old one.  */\n \tr = copy_decl (t);\n-\tmy_friendly_assert (DECL_LANG_SPECIFIC (r) != 0, 0);\n+\tgcc_assert (DECL_LANG_SPECIFIC (r) != 0);\n \tTREE_CHAIN (r) = NULL_TREE;\n \n \tif (is_template_template_parm)\n@@ -6166,7 +6158,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \tint parms_depth;\n \n \t/* Nobody should be tsubst'ing into non-template functions.  */\n-\tmy_friendly_assert (DECL_TEMPLATE_INFO (t) != NULL_TREE, 0);\n+\tgcc_assert (DECL_TEMPLATE_INFO (t) != NULL_TREE);\n \n \tif (TREE_CODE (DECL_TI_TEMPLATE (t)) == TEMPLATE_DECL)\n \t  {\n@@ -6625,7 +6617,7 @@ tsubst_function_type (tree t,\n   tree fntype;\n \n   /* The TYPE_CONTEXT is not used for function/method types.  */\n-  my_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n+  gcc_assert (TYPE_CONTEXT (t) == NULL_TREE);\n \n   /* Substitute the return type.  */\n   return_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n@@ -6735,7 +6727,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   else\n     type = TREE_TYPE (t);\n \n-  my_friendly_assert (type != unknown_type_node, 20030716);\n+  gcc_assert (type != unknown_type_node);\n \n   if (type && TREE_CODE (t) != FUNCTION_DECL\n       && TREE_CODE (t) != TYPENAME_TYPE\n@@ -6851,7 +6843,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      {\n \t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t\t  {\n-\t\t    my_friendly_assert (TYPE_P (arg), 0);\n+\t\t    gcc_assert (TYPE_P (arg));\n \t\t    return cp_build_qualified_type_real\n \t\t      (arg, cp_type_quals (arg) | cp_type_quals (t),\n \t\t       complain | tf_ignore_bad_quals);\n@@ -6987,7 +6979,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case TREE_VEC:\n       /* A vector of template arguments.  */\n-      my_friendly_assert (!type, 20040628);\n+      gcc_assert (!type);\n       return tsubst_template_args (t, args, complain, in_decl);\n \n     case POINTER_TYPE:\n@@ -7075,7 +7067,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    \n \t    return error_mark_node;\n \t  }\n-\tmy_friendly_assert (TREE_CODE (type) != METHOD_TYPE, 20011231);\n+\tgcc_assert (TREE_CODE (type) != METHOD_TYPE);\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    /* This is really a method type. The cv qualifiers of the\n@@ -7364,7 +7356,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   bool is_template;\n   tree template_args;\n \n-  my_friendly_assert (TREE_CODE (qualified_id) == SCOPE_REF, 20030706);\n+  gcc_assert (TREE_CODE (qualified_id) == SCOPE_REF);\n \n   /* Figure out what name to look up.  */\n   name = TREE_OPERAND (qualified_id, 1);\n@@ -7467,7 +7459,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     {\n     case PARM_DECL:\n       r = retrieve_local_specialization (t);\n-      my_friendly_assert (r != NULL, 20020903);\n+      gcc_assert (r != NULL);\n       mark_used (r);\n       return r;\n \n@@ -8719,7 +8711,7 @@ instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n   if (tmpl == error_mark_node)\n     return error_mark_node;\n \n-  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n   /* If this function is a clone, handle it specially.  */\n   if (DECL_CLONED_FUNCTION_P (tmpl))\n@@ -8851,7 +8843,7 @@ fn_type_unification (tree fn,\n   tree fntype;\n   int result;\n \n-  my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n+  gcc_assert (TREE_CODE (fn) == TEMPLATE_DECL);\n \n   fntype = TREE_TYPE (fn);\n   if (explicit_targs)\n@@ -9073,11 +9065,10 @@ type_unification_real (tree tparms,\n   tree parms, args;\n   int len;\n \n-  my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n-  my_friendly_assert (xparms == NULL_TREE \n-\t\t      || TREE_CODE (xparms) == TREE_LIST, 290);\n-  my_friendly_assert (!xargs || TREE_CODE (xargs) == TREE_LIST, 291);\n-  my_friendly_assert (ntparms > 0, 292);\n+  gcc_assert (TREE_CODE (tparms) == TREE_VEC);\n+  gcc_assert (xparms == NULL_TREE || TREE_CODE (xparms) == TREE_LIST);\n+  gcc_assert (!xargs || TREE_CODE (xargs) == TREE_LIST);\n+  gcc_assert (ntparms > 0);\n \n   switch (strict)\n     {\n@@ -9156,7 +9147,7 @@ type_unification_real (tree tparms,\n \t\n       if (!TYPE_P (arg))\n \t{\n-\t  my_friendly_assert (TREE_TYPE (arg) != NULL_TREE, 293);\n+\t  gcc_assert (TREE_TYPE (arg) != NULL_TREE);\n \t  if (type_unknown_p (arg))\n \t    {\n \t      /* [temp.deduct.type] A template-argument can be deduced from\n@@ -9563,7 +9554,7 @@ get_template_base (tree tparms, tree targs, tree parm, tree arg)\n   tree rval;\n   tree arg_binfo;\n \n-  my_friendly_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)), 92);\n+  gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (arg)));\n   \n   arg_binfo = TYPE_BINFO (complete_type (arg));\n   if (!arg_binfo)\n@@ -10899,7 +10890,7 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n   /* If the DECL was not unregistered then something peculiar is\n      happening: we created a specialization but did not call\n      register_specialization for it.  */\n-  my_friendly_assert (unregistered, 0);\n+  gcc_assert (unregistered);\n \n   /* Make sure that we can see identifiers, and compute access\n      correctly.  */\n@@ -10994,9 +10985,8 @@ template_for_substitution (tree decl)\n \t cannot restructure the loop to just keep going until we find\n \t a template with a definition, since that might go too far if\n \t a specialization was declared, but not defined.  */\n-      my_friendly_assert (!(TREE_CODE (decl) == VAR_DECL\n-\t\t\t    && !DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (tmpl))), \n-\t\t\t  0); \n+      gcc_assert (TREE_CODE (decl) != VAR_DECL\n+\t\t  || DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (tmpl)));\n       \n       /* Fetch the more general template.  */\n       tmpl = DECL_TI_TEMPLATE (tmpl);\n@@ -11031,8 +11021,8 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n   \n   /* This function should only be used to instantiate templates for\n      functions and static member variables.  */\n-  my_friendly_assert (TREE_CODE (d) == FUNCTION_DECL\n-\t\t      || TREE_CODE (d) == VAR_DECL, 0);\n+  gcc_assert (TREE_CODE (d) == FUNCTION_DECL\n+\t      || TREE_CODE (d) == VAR_DECL);\n \n   /* Variables are never deferred; if instantiation is required, they\n      are instantiated right away.  That allows for better code in the\n@@ -11140,10 +11130,9 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n   \n   /* We should have set up DECL_INITIAL in instantiate_class_template\n      for in-class definitions of static data members.  */\n-  my_friendly_assert (!(TREE_CODE (d) == VAR_DECL \n-\t\t\t&& DECL_INITIALIZED_IN_CLASS_P (d)\n-\t\t\t&& DECL_INITIAL (d) == NULL_TREE),\n-\t\t      20040726);\n+  gcc_assert (!(TREE_CODE (d) == VAR_DECL \n+\t\t&& DECL_INITIALIZED_IN_CLASS_P (d)\n+\t\t&& DECL_INITIAL (d) == NULL_TREE));\n \n   /* Do not instantiate templates that we know will be defined\n      elsewhere.  */\n@@ -11265,7 +11254,7 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n \t  tmpl_parm = TREE_CHAIN (tmpl_parm);\n \t  spec_parm = TREE_CHAIN (spec_parm);\n \t}\n-      my_friendly_assert (!spec_parm, 20020813);\n+      gcc_assert (!spec_parm);\n \n       /* Substitute into the body of the function.  */\n       tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n@@ -11504,7 +11493,7 @@ get_mostly_instantiated_function_type (tree decl)\n \n   /* There should be as many levels of arguments as there are levels\n      of parameters.  */\n-  my_friendly_assert (parm_depth == TMPL_ARGS_DEPTH (targs), 0);\n+  gcc_assert (parm_depth == TMPL_ARGS_DEPTH (targs));\n \n   fn_type = TREE_TYPE (tmpl);\n \n@@ -11736,7 +11725,7 @@ dependent_scope_ref_p (tree expression, bool criterion (tree))\n   tree scope;\n   tree name;\n \n-  my_friendly_assert (TREE_CODE (expression) == SCOPE_REF, 20030714);\n+  gcc_assert (TREE_CODE (expression) == SCOPE_REF);\n \n   if (!TYPE_P (TREE_OPERAND (expression, 0)))\n     return true;\n@@ -11807,8 +11796,7 @@ value_dependent_expression_p (tree expression)\n \t  /* If there are no operands, it must be an expression such\n \t     as \"int()\". This should not happen for aggregate types\n \t     because it would form non-constant expressions.  */\n-\t  my_friendly_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type), \n-\t\t\t      20040318);\n+\t  gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n \n \t  return false;\n \t}\n@@ -12101,8 +12089,7 @@ resolve_typename_type (tree type, bool only_current_p)\n   int quals;\n   bool pop_p;\n \n-  my_friendly_assert (TREE_CODE (type) == TYPENAME_TYPE,\n-\t\t      20010702);\n+  gcc_assert (TREE_CODE (type) == TYPENAME_TYPE);\n \n   scope = TYPE_CONTEXT (type);\n   name = TYPE_IDENTIFIER (type);"}, {"sha": "8688771b71c4e643ddf655bccb739e93b74e8a38", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -264,11 +264,10 @@ finish_repo (void)\n int\n repo_emit_p (tree decl)\n {\n-  my_friendly_assert (TREE_PUBLIC (decl), 20040725);\n-  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t      || TREE_CODE (decl) == VAR_DECL,\n-\t\t      20040725);\n-  my_friendly_assert (!DECL_REALLY_EXTERN (decl), 20040725);\n+  gcc_assert (TREE_PUBLIC (decl));\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || TREE_CODE (decl) == VAR_DECL);\n+  gcc_assert (!DECL_REALLY_EXTERN (decl));\n \n   /* When not using the repository, emit everything.  */\n   if (!flag_use_repository)"}, {"sha": "4219d301260bb624664f9b3a089d9e4db02577e3", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -140,7 +140,7 @@ build_headof (tree exp)\n   tree offset;\n   tree index;\n \n-  my_friendly_assert (TREE_CODE (type) == POINTER_TYPE, 20000112);\n+  gcc_assert (TREE_CODE (type) == POINTER_TYPE);\n   type = TREE_TYPE (type);\n \n   if (!TYPE_POLYMORPHIC_P (type))\n@@ -364,7 +364,7 @@ get_tinfo_decl (tree type)\n       pushdecl_top_level_and_finish (d, NULL_TREE);\n \n       /* Add decl to the global array of tinfo decls.  */\n-      my_friendly_assert (unemitted_tinfo_decls != 0, 20030312);\n+      gcc_assert (unemitted_tinfo_decls != 0);\n       VARRAY_PUSH_TREE (unemitted_tinfo_decls, d);\n     }\n \n@@ -1026,7 +1026,7 @@ typeinfo_in_lib_p (tree type)\n static tree\n get_pseudo_ti_init (tree type, tree var_desc)\n {\n-  my_friendly_assert (at_eof, 20021120);\n+  gcc_assert (at_eof);\n   switch (TREE_CODE (type))\n     {\n     case OFFSET_TYPE:\n@@ -1274,7 +1274,7 @@ get_pseudo_ti_desc (tree type)\n static void\n create_tinfo_types (void)\n {\n-  my_friendly_assert (!ti_desc_type_node, 20020609);\n+  gcc_assert (!ti_desc_type_node);\n \n   push_nested_namespace (abi_node);\n   \n@@ -1436,7 +1436,7 @@ emit_tinfo_decl (tree decl)\n   int in_library = typeinfo_in_lib_p (type);\n   tree var_desc, var_init;\n \n-  my_friendly_assert (DECL_TINFO_P (decl), 20030307); \n+  gcc_assert (DECL_TINFO_P (decl)); \n   \n   if (in_library)\n     {"}, {"sha": "2c5ec6b6808f54c31b9402e0baa88f5068af289b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -148,7 +148,7 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t  bk = bk_proper_base;\n \t  /* Fall through.  */\n \tcase bk_proper_base:\n-\t  my_friendly_assert (found == bk_not_base, 20010723);\n+\t  gcc_assert (found == bk_not_base);\n \t  found = bk;\n \t  break;\n \t  \n@@ -217,7 +217,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \t*kind_ptr = bk_not_base;\n       return error_mark_node;\n     }\n-  my_friendly_assert (TYPE_P (base), 20011127);\n+  gcc_assert (TYPE_P (base));\n   \n   if (!TYPE_P (t))\n     {\n@@ -436,7 +436,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;\n #endif /* GATHER_STATISTICS */\n-      my_friendly_assert (DECL_P (field), 0);\n+      gcc_assert (DECL_P (field));\n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n \t{\n@@ -618,7 +618,7 @@ dfs_access_in_type (tree binfo, void *data)\n \t      else if (decl_access == access_private_node)\n \t\taccess = ak_private;\n \t      else\n-\t\tmy_friendly_assert (false, 20030217);\n+\t\tgcc_unreachable ();\n \t    }\n \t}\n \n@@ -1182,13 +1182,12 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n {\n   tree baselink;\n \n-  my_friendly_assert (TREE_CODE (functions) == FUNCTION_DECL\n-\t\t      || TREE_CODE (functions) == TEMPLATE_DECL\n-\t\t      || TREE_CODE (functions) == TEMPLATE_ID_EXPR\n-\t\t      || TREE_CODE (functions) == OVERLOAD,\n-\t\t      20020730);\n-  my_friendly_assert (!optype || TYPE_P (optype), 20020730);\n-  my_friendly_assert (TREE_TYPE (functions), 20020805);\n+  gcc_assert (TREE_CODE (functions) == FUNCTION_DECL\n+\t      || TREE_CODE (functions) == TEMPLATE_DECL\n+\t      || TREE_CODE (functions) == TEMPLATE_ID_EXPR\n+\t      || TREE_CODE (functions) == OVERLOAD);\n+  gcc_assert (!optype || TYPE_P (optype));\n+  gcc_assert (TREE_TYPE (functions));\n \n   baselink = make_node (BASELINK);\n   TREE_TYPE (baselink) = TREE_TYPE (functions);\n@@ -1228,7 +1227,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n \n   const char *errstr = 0;\n \n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 20030624);\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n \n   if (TREE_CODE (xbasetype) == TREE_BINFO)\n     {\n@@ -1237,7 +1236,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n     }\n   else\n     {\n-      my_friendly_assert (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)), 20030624);\n+      gcc_assert (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)));\n       type = xbasetype;\n       xbasetype = NULL_TREE;\n     }\n@@ -1491,7 +1490,7 @@ adjust_result_of_qualified_name_lookup (tree decl,\n     {\n       tree base;\n \n-      my_friendly_assert (CLASS_TYPE_P (context_class), 20020808);\n+      gcc_assert (CLASS_TYPE_P (context_class));\n \n       /* Look for the QUALIFYING_SCOPE as a base of the CONTEXT_CLASS.\n \t Because we do not yet know which function will be chosen by\n@@ -2505,11 +2504,11 @@ copied_binfo (tree binfo, tree here)\n     }\n   else\n     {\n-      my_friendly_assert (BINFO_TYPE (here) == BINFO_TYPE (binfo), 20030202);\n+      gcc_assert (BINFO_TYPE (here) == BINFO_TYPE (binfo));\n       result = here;\n     }\n \n-  my_friendly_assert (result, 20030202);\n+  gcc_assert (result);\n   return result;\n }\n "}, {"sha": "a6aea7be3c5cfb8f07c44eef44f8a83f0a770544", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -307,7 +307,7 @@ perform_or_defer_access_check (tree binfo, tree decl)\n   if (deferred_access_no_check)\n     return;\n   \n-  my_friendly_assert (TREE_CODE (binfo) == TREE_BINFO, 20030623);\n+  gcc_assert (TREE_CODE (binfo) == TREE_BINFO);\n \n   ptr = VEC_last (deferred_access, deferred_access_stack);\n   \n@@ -1249,7 +1249,7 @@ finish_parenthesized_expr (tree expr)\n tree\n finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n {\n-  my_friendly_assert (TREE_CODE (decl) == FIELD_DECL, 20020909);\n+  gcc_assert (TREE_CODE (decl) == FIELD_DECL);\n \n   if (!object)\n     {\n@@ -1497,7 +1497,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t\t build_tree_list (NULL_TREE, expr),\n \t\t type, LOOKUP_NORMAL);\n \t      expr = build_cplus_new (type, expr);\n-\t      my_friendly_assert (TREE_CODE (expr) == TARGET_EXPR, 20030729);\n+\t      gcc_assert (TREE_CODE (expr) == TARGET_EXPR);\n \t    }\n \t}\n \n@@ -1582,7 +1582,7 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \t the statement expression itself as the target's init\n \t expr. Finally, return the target expression.  */\n       tree init, target_expr = EXPR_STMT_EXPR (result_stmt);\n-      my_friendly_assert (TREE_CODE (target_expr) == TARGET_EXPR, 20030729);\n+      gcc_assert (TREE_CODE (target_expr) == TARGET_EXPR);\n \n       /* The initializer will be void if the initialization is done by\n \t AGGR_INIT_EXPR; propagate that out to the statement-expression as\n@@ -1682,8 +1682,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n     return error_mark_node;\n \n   /* ARGS should be a list of arguments.  */\n-  my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n-\t\t      20020712);\n+  gcc_assert (!args || TREE_CODE (args) == TREE_LIST);\n \n   orig_fn = fn;\n   orig_args = args;\n@@ -1858,7 +1857,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n   if (destructor == error_mark_node)\n     return error_mark_node;\n \n-  my_friendly_assert (TYPE_P (destructor), 20010905);\n+  gcc_assert (TYPE_P (destructor));\n \n   if (!processing_template_decl)\n     {\n@@ -1998,7 +1997,7 @@ finish_template_template_parm (tree aggr, tree identifier)\n   DECL_ARTIFICIAL (decl) = 1;\n   end_template_decl ();\n \n-  my_friendly_assert (DECL_TEMPLATE_PARMS (tmpl), 20010110);\n+  gcc_assert (DECL_TEMPLATE_PARMS (tmpl));\n \n   return finish_template_type_parm (aggr, tmpl);\n }\n@@ -2128,7 +2127,7 @@ finish_member_declaration (tree decl)\n     return;\n \n   /* We should see only one DECL at a time.  */\n-  my_friendly_assert (TREE_CHAIN (decl) == NULL_TREE, 0);\n+  gcc_assert (TREE_CHAIN (decl) == NULL_TREE);\n \n   /* Set up access control for DECL.  */\n   TREE_PRIVATE (decl) \n@@ -2856,7 +2855,7 @@ emit_associated_thunks (tree fn)\n \t\t}\n \t    }\n \t  else\n-\t    my_friendly_assert (!DECL_THUNKS (thunk), 20031023);\n+\t    gcc_assert (!DECL_THUNKS (thunk));\n \t}\n     }\n }"}, {"sha": "4bdadad690d9b3595dbc1d55f08dca72d8c1cebd", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -319,7 +319,7 @@ build_target_expr_with_type (tree init, tree type)\n {\n   tree slot;\n \n-  my_friendly_assert (!VOID_TYPE_P (type), 20040130);\n+  gcc_assert (!VOID_TYPE_P (type));\n \n   if (TREE_CODE (init) == TARGET_EXPR)\n     return init;\n@@ -347,7 +347,7 @@ force_target_expr (tree type, tree init)\n {\n   tree slot;\n \n-  my_friendly_assert (!VOID_TYPE_P (type), 20040130);\n+  gcc_assert (!VOID_TYPE_P (type));\n \n   slot = build_local_temp (type);\n   return build_target_expr (slot, init);\n@@ -606,8 +606,8 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n       int ix;\n       tree base_binfo;\n \n-      my_friendly_assert (!BINFO_DEPENDENT_BASE_P (binfo), 20040712);\n-      my_friendly_assert (type == BINFO_TYPE (binfo), 20040714);\n+      gcc_assert (!BINFO_DEPENDENT_BASE_P (binfo));\n+      gcc_assert (type == BINFO_TYPE (binfo));\n \n       BINFO_OFFSET (new_binfo) = BINFO_OFFSET (binfo);\n       BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (binfo);\n@@ -620,7 +620,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n \t{\n \t  tree new_base_binfo;\n \n-\t  my_friendly_assert (!BINFO_DEPENDENT_BASE_P (base_binfo), 20040713);\n+\t  gcc_assert (!BINFO_DEPENDENT_BASE_P (base_binfo));\n \t  new_base_binfo = copy_binfo (base_binfo, BINFO_TYPE (base_binfo),\n \t\t\t\t       t, igo_prev,\n \t\t\t\t       BINFO_VIRTUAL_P (base_binfo));\n@@ -840,7 +840,7 @@ really_overloaded_fn (tree x)\n tree\n get_first_fn (tree from)\n {\n-  my_friendly_assert (is_overloaded_fn (from), 9);\n+  gcc_assert (is_overloaded_fn (from));\n   /* A baselink is also considered an overloaded function.  */\n   if (BASELINK_P (from))\n     from = BASELINK_FUNCTIONS (from);\n@@ -1584,7 +1584,7 @@ cp_tree_equal (tree t1, tree t2)\n       return same_type_p (t1, t2);\n     }\n \n-  my_friendly_assert (0, 20030617);\n+  gcc_unreachable ();\n   return false;\n }\n "}, {"sha": "b204860d13bdbc0d8ef01d52b808f276f564604f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -262,14 +262,12 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n   tree attributes;\n \n   /* FIXME: Attributes.  */\n-  my_friendly_assert (ARITHMETIC_TYPE_P (t1) \n-\t\t      || TREE_CODE (t1) == COMPLEX_TYPE\n-\t\t      || TREE_CODE (t1) == ENUMERAL_TYPE,\n-\t\t      19990725);\n-  my_friendly_assert (ARITHMETIC_TYPE_P (t2) \n-\t\t      || TREE_CODE (t2) == COMPLEX_TYPE\n-\t\t      || TREE_CODE (t2) == ENUMERAL_TYPE,\n-\t\t      19990725);\n+  gcc_assert (ARITHMETIC_TYPE_P (t1) \n+\t      || TREE_CODE (t1) == COMPLEX_TYPE\n+\t      || TREE_CODE (t1) == ENUMERAL_TYPE);\n+  gcc_assert (ARITHMETIC_TYPE_P (t2) \n+\t      || TREE_CODE (t2) == COMPLEX_TYPE\n+\t      || TREE_CODE (t2) == ENUMERAL_TYPE);\n \n   /* In what follows, we slightly generalize the rules given in [expr] so\n      as to deal with `long long' and `complex'.  First, merge the\n@@ -928,7 +926,7 @@ comptypes (tree t1, tree t2, int strict)\n   if (t1 == error_mark_node || t2 == error_mark_node)\n     return false;\n   \n-  my_friendly_assert (TYPE_P (t1) && TYPE_P (t2), 20030623);\n+  gcc_assert (TYPE_P (t1) && TYPE_P (t2));\n   \n   /* TYPENAME_TYPEs should be resolved if the qualifying scope is the\n      current instantiation.  */\n@@ -1218,7 +1216,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n   tree value;\n   const char *op_name;\n \n-  my_friendly_assert (op == SIZEOF_EXPR || op == ALIGNOF_EXPR, 20020720);\n+  gcc_assert (op == SIZEOF_EXPR || op == ALIGNOF_EXPR);\n   if (type == error_mark_node)\n     return error_mark_node;\n   \n@@ -1441,7 +1439,7 @@ perform_integral_promotions (tree expr)\n   tree promoted_type;\n \n   type = TREE_TYPE (expr);\n-  my_friendly_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type), 20030703);\n+  gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n   promoted_type = type_promotes_to (type);\n   if (type != promoted_type)\n     expr = cp_convert (promoted_type, expr);\n@@ -1595,8 +1593,7 @@ build_class_member_access_expr (tree object, tree member,\n   if (TREE_CODE (member) == PSEUDO_DTOR_EXPR)\n     return member;\n \n-  my_friendly_assert (DECL_P (member) || BASELINK_P (member),\n-\t\t      20020801);\n+  gcc_assert (DECL_P (member) || BASELINK_P (member));\n \n   /* [expr.ref]\n \n@@ -1698,8 +1695,7 @@ build_class_member_access_expr (tree object, tree member,\n \t\t\t\t    /*nonnull=*/1);\n \t  /* If we found the base successfully then we should be able\n \t     to convert to it successfully.  */\n-\t  my_friendly_assert (object != error_mark_node,\n-\t\t\t      20020801);\n+\t  gcc_assert (object != error_mark_node);\n \t}\n \n       /* Complain about other invalid uses of offsetof, even though they will\n@@ -1909,9 +1905,7 @@ finish_class_member_access_expr (tree object, tree name)\n   if (BASELINK_P (name))\n     {\n       /* A member function that has already been looked up.  */\n-      my_friendly_assert ((TREE_CODE (BASELINK_FUNCTIONS (name)) \n-\t\t\t   == TEMPLATE_ID_EXPR), \n-\t\t\t  20020805);\n+      gcc_assert (TREE_CODE (BASELINK_FUNCTIONS (name)) == TEMPLATE_ID_EXPR);\n       member = name;\n     }\n   else\n@@ -1940,12 +1934,10 @@ finish_class_member_access_expr (tree object, tree name)\n \t     or a BIT_NOT_EXPR.  */\n \t  scope = TREE_OPERAND (name, 0);\n \t  name = TREE_OPERAND (name, 1);\n-\t  my_friendly_assert ((CLASS_TYPE_P (scope) \n-\t\t\t       || TREE_CODE (scope) == NAMESPACE_DECL),\n-\t\t\t      20020804);\n-\t  my_friendly_assert ((TREE_CODE (name) == IDENTIFIER_NODE\n-\t\t\t       || TREE_CODE (name) == BIT_NOT_EXPR),\n-\t\t\t      20020804);\n+\t  gcc_assert (CLASS_TYPE_P (scope)\n+\t\t      || TREE_CODE (scope) == NAMESPACE_DECL);\n+\t  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE\n+\t\t      || TREE_CODE (name) == BIT_NOT_EXPR);\n \n \t  /* If SCOPE is a namespace, then the qualified name does not\n \t     name a member of OBJECT_TYPE.  */\n@@ -2032,7 +2024,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n      routine directly because it expects the object to be of class\n      type.  */\n   ptrmem_type = TREE_TYPE (ptrmem);\n-  my_friendly_assert (TYPE_PTRMEMFUNC_P (ptrmem_type), 20020804);\n+  gcc_assert (TYPE_PTRMEMFUNC_P (ptrmem_type));\n   member = lookup_member (ptrmem_type, member_name, /*protect=*/0,\n \t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n@@ -4091,9 +4083,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \t    /* We can only get here with a single static member\n \t       function.  */\n-\t    my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t\t\t&& DECL_STATIC_FUNCTION_P (fn),\n-\t\t\t\t20030906);\n+\t    gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t\t&& DECL_STATIC_FUNCTION_P (fn));\n \t    mark_used (fn);\n \t    addr = build_address (fn);\n \t    if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n@@ -4208,7 +4199,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n     {\n       tree t;\n \n-      my_friendly_assert (TREE_CODE (arg) != SCOPE_REF, 313);\n+      gcc_assert (TREE_CODE (arg) != SCOPE_REF);\n \n       if (TREE_CODE (arg) != OFFSET_REF)\n \treturn 0;\n@@ -4312,10 +4303,10 @@ cxx_mark_addressable (tree exp)\n       case VAR_DECL:\n \t/* Caller should not be trying to mark initialized\n \t   constant fields addressable.  */\n-\tmy_friendly_assert (DECL_LANG_SPECIFIC (x) == 0\n-\t\t\t    || DECL_IN_AGGR_P (x) == 0\n-\t\t\t    || TREE_STATIC (x)\n-\t\t\t    || DECL_EXTERNAL (x), 314);\n+\tgcc_assert (DECL_LANG_SPECIFIC (x) == 0\n+\t\t    || DECL_IN_AGGR_P (x) == 0\n+\t\t    || TREE_STATIC (x)\n+\t\t    || DECL_EXTERNAL (x));\n \t/* Fall through.  */\n \n       case CONST_DECL:\n@@ -5138,8 +5129,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n      \t     value with the RHS producing the value we should actually\n      \t     store into the LHS.  */\n \n-\t  my_friendly_assert (!PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE),\n-\t\t\t      978652);\n+\t  gcc_assert (!PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE));\n \t  lhs = stabilize_reference (lhs);\n \t  newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n \t  if (newrhs == error_mark_node)\n@@ -5152,9 +5142,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  /* Now it looks like a plain assignment.  */\n \t  modifycode = NOP_EXPR;\n \t}\n-      my_friendly_assert (TREE_CODE (lhstype) != REFERENCE_TYPE, 20011220);\n-      my_friendly_assert (TREE_CODE (TREE_TYPE (newrhs)) != REFERENCE_TYPE,\n-\t\t\t  20011220);\n+      gcc_assert (TREE_CODE (lhstype) != REFERENCE_TYPE);\n+      gcc_assert (TREE_CODE (TREE_TYPE (newrhs)) != REFERENCE_TYPE);\n     }\n \n   /* The left-hand side must be an lvalue.  */\n@@ -5467,10 +5456,8 @@ build_ptrmemfunc (tree type, tree pfn, int force)\n \t}\n \n       /* Just adjust the DELTA field.  */\n-      my_friendly_assert \n-\t(same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (delta),\n-\t\t\t\t\t\t    ptrdiff_type_node), \n-\t 20030727);\n+      gcc_assert  (same_type_ignoring_top_level_qualifiers_p\n+\t\t   (TREE_TYPE (delta), ptrdiff_type_node));\n       if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n \tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node);\n       delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n@@ -5490,7 +5477,7 @@ build_ptrmemfunc (tree type, tree pfn, int force)\n     return instantiate_type (type, pfn, tf_error | tf_warning);\n \n   fn = TREE_OPERAND (pfn, 0);\n-  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n   return make_ptrmem_cst (to_type, fn);\n }\n \n@@ -5508,7 +5495,7 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n   tree fn = PTRMEM_CST_MEMBER (cst);\n   tree ptr_class, fn_class;\n \n-  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n+  gcc_assert (TREE_CODE (fn) == FUNCTION_DECL);\n \n   /* The class that the function belongs to.  */\n   fn_class = DECL_CONTEXT (fn);\n@@ -5916,7 +5903,7 @@ check_return_expr (tree retval)\n      return value, the named return value is used.  */\n   result = DECL_RESULT (current_function_decl);\n   valtype = TREE_TYPE (result);\n-  my_friendly_assert (valtype != NULL_TREE, 19990924);\n+  gcc_assert (valtype != NULL_TREE);\n   fn_returns_value_p = !VOID_TYPE_P (valtype);\n   if (!retval && DECL_NAME (result) && fn_returns_value_p)\n     retval = result;"}, {"sha": "19a11919b82ba78bcfc185c6507e0a60a2e14ceb", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50bc768da122bde65bc31bf4054f29603893455a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=50bc768da122bde65bc31bf4054f29603893455a", "patch": "@@ -179,7 +179,7 @@ complete_type_check_abstract (tree type)\n   struct pending_abstract_type *pat;\n   location_t cur_loc = input_location;\n \n-  my_friendly_assert (COMPLETE_TYPE_P (type), 20040620_3);\n+  gcc_assert (COMPLETE_TYPE_P (type));\n \n   if (!abstract_pending_vars)\n     return;\n@@ -190,7 +190,7 @@ complete_type_check_abstract (tree type)\n   if (!slot)\n     return;\n   pat = (struct pending_abstract_type*)*slot;\n-  my_friendly_assert (pat, 20040620_2);\n+  gcc_assert (pat);\n \n   /* If the type is not abstract, do not do anything.  */\n   if (CLASSTYPE_PURE_VIRTUALS (type))\n@@ -210,7 +210,7 @@ complete_type_check_abstract (tree type)\n \telement: it will issue a diagostic if the type is abstract.  */\n       while (pat)\n \t{\n-\t  my_friendly_assert (type == pat->type, 20040620_4);\n+\t  gcc_assert (type == pat->type);\n \n \t  /* Tweak input_location so that the diagnostic appears at the correct\n \t    location. Notice that this is only needed if the decl is an\n@@ -252,9 +252,8 @@ abstract_virtuals_error (tree decl, tree type)\n       void **slot;\n       struct pending_abstract_type *pat;\n \n-      my_friendly_assert (!decl || (DECL_P (decl) \n-\t\t\t\t    || TREE_CODE (decl) == IDENTIFIER_NODE),\n-\t\t\t  20040620_1);\n+      gcc_assert (!decl || DECL_P (decl) \n+\t\t  || TREE_CODE (decl) == IDENTIFIER_NODE);\n \n       if (!abstract_pending_vars)\n \tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash, \n@@ -888,12 +887,9 @@ process_init_constructor (tree type, tree init, tree* elts)\n \t\t\t\t       TREE_VALUE (tail), &tail1);\n \t\t  if (next1 == error_mark_node)\n \t\t    return next1;\n-\t\t  my_friendly_assert\n-\t\t    (same_type_ignoring_top_level_qualifiers_p\n-\t\t     (TREE_TYPE (type), TREE_TYPE (next1)),\n-\t\t     981123);\n-\t\t  my_friendly_assert (tail1 == 0\n-\t\t\t\t      || TREE_CODE (tail1) == TREE_LIST, 319);\n+\t\t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t      (TREE_TYPE (type), TREE_TYPE (next1)));\n+\t\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n \t\t  if (tail == tail1 && len < 0)\n \t\t    {\n \t\t      error (\"non-empty initializer for array of empty elements\");\n@@ -992,8 +988,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \n \t\t  next1 = digest_init (TREE_TYPE (field),\n \t\t\t\t       TREE_VALUE (tail), &tail1);\n-\t\t  my_friendly_assert (tail1 == 0\n-\t\t\t\t      || TREE_CODE (tail1) == TREE_LIST, 320);\n+\t\t  gcc_assert (!tail1 || TREE_CODE (tail1) == TREE_LIST);\n \t\t  tail = tail1;\n \t\t}\n \t      else\n@@ -1463,7 +1458,7 @@ add_exception_specifier (tree list, tree spec, int complain)\n   if (spec == error_mark_node)\n     return list;\n   \n-  my_friendly_assert (spec && (!list || TREE_VALUE (list)), 19990317);\n+  gcc_assert (spec && (!list || TREE_VALUE (list)));\n   \n   /* [except.spec] 1, type in an exception specifier shall not be\n      incomplete, or pointer or ref to incomplete other than pointer"}]}