{"sha": "8460475b4265e2a607acf6bc4bcf98bca5b38aba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2MDQ3NWI0MjY1ZTJhNjA3YWNmNmJjNGJjZjk4YmNhNWIzOGFiYQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-23T11:01:38Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-23T11:01:38Z"}, "message": "re PR fortran/41758 ([Cleanup] Don't resolve expr in gfc_match_allocate)\n\n2009-10-23  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41758\n\t* match.c (conformable_arrays): Move to resolve.c.\n\t(gfc_match_allocate): Don't resolve SOURCE expr yet, and move some\n\tchecks to resolve_allocate_expr.\n\t* resolve.c (conformable_arrays): Moved here from match.c.\n\t(resolve_allocate_expr): Moved some checks here from gfc_match_allocate.\n\t(resolve_code): Resolve SOURCE tag for ALLOCATE expressions.\n\nFrom-SVN: r153494", "tree": {"sha": "c73fa21fc6a447776ec7f36c2cb66d1bdcd615a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c73fa21fc6a447776ec7f36c2cb66d1bdcd615a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8460475b4265e2a607acf6bc4bcf98bca5b38aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8460475b4265e2a607acf6bc4bcf98bca5b38aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8460475b4265e2a607acf6bc4bcf98bca5b38aba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8460475b4265e2a607acf6bc4bcf98bca5b38aba/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e25a8c821651fdd79282b769cba179d814835666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25a8c821651fdd79282b769cba179d814835666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25a8c821651fdd79282b769cba179d814835666"}], "stats": {"total": 169, "additions": 93, "deletions": 76}, "files": [{"sha": "0668a68305cc9dcef95251c87cfb26b56ee4a22e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8460475b4265e2a607acf6bc4bcf98bca5b38aba", "patch": "@@ -1,3 +1,13 @@\n+2009-10-23  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41758\n+\t* match.c (conformable_arrays): Move to resolve.c.\n+\t(gfc_match_allocate): Don't resolve SOURCE expr yet, and move some\n+\tchecks to resolve_allocate_expr.\n+\t* resolve.c (conformable_arrays): Moved here from match.c.\n+\t(resolve_allocate_expr): Moved some checks here from gfc_match_allocate.\n+\t(resolve_code): Resolve SOURCE tag for ALLOCATE expressions.\n+\n 2009-10-22  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41781"}, {"sha": "24e292bd4d6ed05ee5b38ca840e336c28ce18243", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8460475b4265e2a607acf6bc4bcf98bca5b38aba", "patch": "@@ -2388,58 +2388,6 @@ match_type_spec (gfc_typespec *ts)\n }\n \n \n-/* Used in gfc_match_allocate to check that a allocation-object and\n-   a source-expr are conformable.  This does not catch all possible \n-   cases; in particular a runtime checking is needed.  */\n-\n-static gfc_try\n-conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n-{\n-  /* First compare rank.  */\n-  if (e2->ref && e1->rank != e2->ref->u.ar.as->rank)\n-    {\n-      gfc_error (\"Source-expr at %L must be scalar or have the \"\n-\t\t \"same rank as the allocate-object at %L\",\n-\t\t &e1->where, &e2->where);\n-      return FAILURE;\n-    }\n-\n-  if (e1->shape)\n-    {\n-      int i;\n-      mpz_t s;\n-\n-      mpz_init (s);\n-\n-      for (i = 0; i < e1->rank; i++)\n-\t{\n-\t  if (e2->ref->u.ar.end[i])\n-\t    {\n-\t      mpz_set (s, e2->ref->u.ar.end[i]->value.integer);\n-\t      mpz_sub (s, s, e2->ref->u.ar.start[i]->value.integer);\n-\t      mpz_add_ui (s, s, 1);\n-\t    }\n-\t  else\n-\t    {\n-\t      mpz_set (s, e2->ref->u.ar.start[i]->value.integer);\n-\t    }\n-\n-\t  if (mpz_cmp (e1->shape[i], s) != 0)\n-\t    {\n-\t      gfc_error (\"Source-expr at %L and allocate-object at %L must \"\n-\t\t\t \"have the same shape\", &e1->where, &e2->where);\n-\t      mpz_clear (s);\n-   \t      return FAILURE;\n-\t    }\n-\t}\n-\n-      mpz_clear (s);\n-    }\n-\n-  return SUCCESS;\n-}\n-\n-\n /* Match an ALLOCATE statement.  */\n \n match\n@@ -2620,7 +2568,7 @@ gfc_match_allocate (void)\n \t      goto cleanup;\n \t    }\n \n-\t  /* The next 3 conditionals check C631.  */\n+\t  /* The next 2 conditionals check C631.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n \t      gfc_error (\"SOURCE tag at %L conflicts with the typespec at %L\",\n@@ -2635,28 +2583,6 @@ gfc_match_allocate (void)\n \t      goto cleanup;\n             }\n \n-\t  gfc_resolve_expr (tmp);\n-\n-\t  if (!gfc_type_compatible (&head->expr->ts, &tmp->ts))\n-\t    {\n-\t      gfc_error (\"Type of entity at %L is type incompatible with \"\n-\t\t\t \"source-expr at %L\", &head->expr->where, &tmp->where);\n-\t      goto cleanup;\n-\t    }\n-\n-\t  /* Check C633.  */\n-\t  if (tmp->ts.kind != head->expr->ts.kind)\n-\t    {\n-\t      gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n-\t\t\t \"shall have the same kind type parameter\",\n-\t\t\t &head->expr->where, &tmp->where);\n-\t      goto cleanup;\n-\t    }\n-\n-\t  /* Check C632 and restriction following Note 6.18.  */\n-\t  if (tmp->rank > 0 && conformable_arrays (tmp, head->expr) == FAILURE)\n-\t    goto cleanup;\n-\n \t  source = tmp;\n \t  saw_source = true;\n "}, {"sha": "b17e8fef182b9eb12754a5109d7a8dd97d9bdda9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8460475b4265e2a607acf6bc4bcf98bca5b38aba/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8460475b4265e2a607acf6bc4bcf98bca5b38aba", "patch": "@@ -5958,6 +5958,58 @@ gfc_expr_to_initialize (gfc_expr *e)\n }\n \n \n+/* Used in resolve_allocate_expr to check that a allocation-object and\n+   a source-expr are conformable.  This does not catch all possible \n+   cases; in particular a runtime checking is needed.  */\n+\n+static gfc_try\n+conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n+{\n+  /* First compare rank.  */\n+  if (e2->ref && e1->rank != e2->ref->u.ar.as->rank)\n+    {\n+      gfc_error (\"Source-expr at %L must be scalar or have the \"\n+\t\t \"same rank as the allocate-object at %L\",\n+\t\t &e1->where, &e2->where);\n+      return FAILURE;\n+    }\n+\n+  if (e1->shape)\n+    {\n+      int i;\n+      mpz_t s;\n+\n+      mpz_init (s);\n+\n+      for (i = 0; i < e1->rank; i++)\n+\t{\n+\t  if (e2->ref->u.ar.end[i])\n+\t    {\n+\t      mpz_set (s, e2->ref->u.ar.end[i]->value.integer);\n+\t      mpz_sub (s, s, e2->ref->u.ar.start[i]->value.integer);\n+\t      mpz_add_ui (s, s, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      mpz_set (s, e2->ref->u.ar.start[i]->value.integer);\n+\t    }\n+\n+\t  if (mpz_cmp (e1->shape[i], s) != 0)\n+\t    {\n+\t      gfc_error (\"Source-expr at %L and allocate-object at %L must \"\n+\t\t\t \"have the same shape\", &e1->where, &e2->where);\n+\t      mpz_clear (s);\n+   \t      return FAILURE;\n+\t    }\n+\t}\n+\n+      mpz_clear (s);\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve the expression in an ALLOCATE statement, doing the additional\n    checks to see whether the expression is OK or not.  The expression must\n    have a trailing array reference that gives the size of the array.  */\n@@ -6057,7 +6109,32 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       return FAILURE;\n     }\n \n-  if (is_abstract && !code->expr3 && code->ext.alloc.ts.type == BT_UNKNOWN)\n+  /* Some checks for the SOURCE tag.  */\n+  if (code->expr3)\n+    {\n+      /* Check F03:C631.  */\n+      if (!gfc_type_compatible (&e->ts, &code->expr3->ts))\n+\t{\n+\t  gfc_error (\"Type of entity at %L is type incompatible with \"\n+\t\t      \"source-expr at %L\", &e->where, &code->expr3->where);\n+\t  return FAILURE;\n+\t}\n+\n+      /* Check F03:C632 and restriction following Note 6.18.  */\n+      if (code->expr3->rank > 0\n+\t  && conformable_arrays (code->expr3, e) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Check F03:C633.  */\n+      if (code->expr3->ts.kind != e->ts.kind)\n+\t{\n+\t  gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n+\t\t      \"shall have the same kind type parameter\",\n+\t\t      &e->where, &code->expr3->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+  else if (is_abstract&& code->ext.alloc.ts.type == BT_UNKNOWN)\n     {\n       gcc_assert (e->ts.type == BT_CLASS);\n       gfc_error (\"Allocating %s of ABSTRACT base type at %L requires a \"\n@@ -7734,6 +7811,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n       if (gfc_resolve_expr (code->expr2) == FAILURE)\n \tt = FAILURE;\n \n+      if (code->op == EXEC_ALLOCATE\n+\t  && gfc_resolve_expr (code->expr3) == FAILURE)\n+\tt = FAILURE;\n+\n       switch (code->op)\n \t{\n \tcase EXEC_NOP:"}]}