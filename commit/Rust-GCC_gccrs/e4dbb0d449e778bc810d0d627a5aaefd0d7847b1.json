{"sha": "e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkYmIwZDQ0OWU3NzhiYzgxMGQwZDYyN2E1YWFlZmQwZDc4NDdiMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-20T05:50:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-20T05:50:29Z"}, "message": "re PR tree-optimization/65337 (LTO bootstrap failure with Ada enabled)\n\n\tPR middle-end/65337\n\t* tree-ssa-dce.c (bb_postorder): New static var.\n\t(forward_edge_to_pdom): Remove.\n\t(remove_dead_stmt): Instead of redirecting edges only keep an edge\n\ton a path to nearest live BB.\n\t(eliminate_unnecessary_stmts): Free bb_postorder.\n\t* cfganal.c (dfs_find_deadend): Add START_POINTES.\n\t* cfganal.h (inverted_post_order_compute): Update prototype.\n\nFrom-SVN: r231856", "tree": {"sha": "4c773d3276204110d797dfcd28b3e1f57d3fbbf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c773d3276204110d797dfcd28b3e1f57d3fbbf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/comments", "author": null, "committer": null, "parents": [{"sha": "e07e03ddc14c0cb38b388812c9d5d07fd940a78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e07e03ddc14c0cb38b388812c9d5d07fd940a78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e07e03ddc14c0cb38b388812c9d5d07fd940a78f"}], "stats": {"total": 163, "additions": 77, "deletions": 86}, "files": [{"sha": "5baddef391e3e09b6c37e732ca723a0a8732ba83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "patch": "@@ -1,3 +1,14 @@\n+2015-12-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR middle-end/65337\n+\t* tree-ssa-dce.c (bb_postorder): New static var.\n+\t(forward_edge_to_pdom): Remove.\n+\t(remove_dead_stmt): Instead of redirecting edges only keep an edge\n+\ton a path to nearest live BB.\n+\t(eliminate_unnecessary_stmts): Free bb_postorder.\n+\t* cfganal.c (dfs_find_deadend): Add START_POINTES.\n+\t* cfganal.h (inverted_post_order_compute): Update prototype.\n+\n 2015-12-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR rtl-optimization/68910"}, {"sha": "b020b32a191beaa7210c1bf716a9381bba52dd77", "filename": "gcc/cfganal.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "patch": "@@ -759,6 +759,9 @@ dfs_find_deadend (basic_block bb)\n    (from successors to predecessors).\n    This ordering can be used for forward dataflow problems among others.\n \n+   Optionally if START_POINTS is specified, start from exit block and all\n+   basic blocks in START_POINTS.  This is used by CD-DCE.\n+\n    This function assumes that all blocks in the CFG are reachable\n    from the ENTRY (but not necessarily from EXIT).\n \n@@ -776,7 +779,8 @@ dfs_find_deadend (basic_block bb)\n    and do another inverted traversal from that block.  */\n \n int\n-inverted_post_order_compute (int *post_order)\n+inverted_post_order_compute (int *post_order,\n+\t\t\t     sbitmap *start_points)\n {\n   basic_block bb;\n   edge_iterator *stack;\n@@ -797,6 +801,22 @@ inverted_post_order_compute (int *post_order)\n   /* None of the nodes in the CFG have been visited yet.  */\n   bitmap_clear (visited);\n \n+  if (start_points)\n+    {\n+      FOR_ALL_BB_FN (bb, cfun)\n+        if (bitmap_bit_p (*start_points, bb->index)\n+\t    && EDGE_COUNT (bb->preds) > 0)\n+\t  {\n+            stack[sp++] = ei_start (bb->preds);\n+            bitmap_set_bit (visited, bb->index);\n+\t  }\n+      if (EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds))\n+\t{\n+          stack[sp++] = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n+          bitmap_set_bit (visited, EXIT_BLOCK_PTR_FOR_FN (cfun)->index);\n+\t}\n+    }\n+  else\n   /* Put all blocks that have no successor into the initial work list.  */\n   FOR_ALL_BB_FN (bb, cfun)\n     if (EDGE_COUNT (bb->succs) == 0)"}, {"sha": "8c32d1003723059fd576d96cc87bf6bf58ae8d9c", "filename": "gcc/cfganal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "patch": "@@ -62,7 +62,7 @@ extern void add_noreturn_fake_exit_edges (void);\n extern void connect_infinite_loops_to_exit (void);\n extern int post_order_compute (int *, bool, bool);\n extern basic_block dfs_find_deadend (basic_block);\n-extern int inverted_post_order_compute (int *);\n+extern int inverted_post_order_compute (int *, sbitmap *start_points = 0);\n extern int pre_and_rev_post_order_compute_fn (struct function *,\n \t\t\t\t\t      int *, int *, bool);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);"}, {"sha": "e26c7d276810a03c7c8a47af5a1be10eff33b67d", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 44, "deletions": 84, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4dbb0d449e778bc810d0d627a5aaefd0d7847b1/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=e4dbb0d449e778bc810d0d627a5aaefd0d7847b1", "patch": "@@ -112,6 +112,9 @@ static sbitmap visited_control_parents;\n    to be recomputed.  */\n static bool cfg_altered;\n \n+/* When non-NULL holds map from basic block index into the postorder.  */\n+static int *bb_postorder;\n+\n \n /* If STMT is not already marked necessary, mark it, and add it to the\n    worklist if ADD_TO_WORKLIST is true.  */\n@@ -134,7 +137,7 @@ mark_stmt_necessary (gimple *stmt, bool add_to_worklist)\n   gimple_set_plf (stmt, STMT_NECESSARY, true);\n   if (add_to_worklist)\n     worklist.safe_push (stmt);\n-  if (bb_contains_live_stmts && !is_gimple_debug (stmt))\n+  if (add_to_worklist && bb_contains_live_stmts && !is_gimple_debug (stmt))\n     bitmap_set_bit (bb_contains_live_stmts, gimple_bb (stmt)->index);\n }\n \n@@ -997,65 +1000,6 @@ remove_dead_phis (basic_block bb)\n   return something_changed;\n }\n \n-/* Forward edge E to respective POST_DOM_BB and update PHIs.  */\n-\n-static edge\n-forward_edge_to_pdom (edge e, basic_block post_dom_bb)\n-{\n-  gphi_iterator gsi;\n-  edge e2 = NULL;\n-  edge_iterator ei;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Redirecting edge %i->%i to %i\\n\", e->src->index,\n-\t     e->dest->index, post_dom_bb->index);\n-\n-  e2 = redirect_edge_and_branch (e, post_dom_bb);\n-  cfg_altered = true;\n-\n-  /* If edge was already around, no updating is necessary.  */\n-  if (e2 != e)\n-    return e2;\n-\n-  if (!gimple_seq_empty_p (phi_nodes (post_dom_bb)))\n-    {\n-      /* We are sure that for every live PHI we are seeing control dependent BB.\n-         This means that we can pick any edge to duplicate PHI args from.  */\n-      FOR_EACH_EDGE (e2, ei, post_dom_bb->preds)\n-\tif (e2 != e)\n-\t  break;\n-      for (gsi = gsi_start_phis (post_dom_bb); !gsi_end_p (gsi);)\n-\t{\n-\t  gphi *phi = gsi.phi ();\n-\t  tree op;\n-\t  source_location locus;\n-\n-\t  /* PHIs for virtuals have no control dependency relation on them.\n-\t     We are lost here and must force renaming of the symbol.  */\n-\t  if (virtual_operand_p (gimple_phi_result (phi)))\n-\t    {\n-\t      mark_virtual_phi_result_for_renaming (phi);\n-\t      remove_phi_node (&gsi, true);\n-\t      continue;\n-\t    }\n-\n-\t  /* Dead PHI do not imply control dependency.  */\n-          if (!gimple_plf (phi, STMT_NECESSARY))\n-\t    {\n-\t      gsi_next (&gsi);\n-\t      continue;\n-\t    }\n-\n-\t  op = gimple_phi_arg_def (phi, e2->dest_idx);\n-\t  locus = gimple_phi_arg_location (phi, e2->dest_idx);\n-\t  add_phi_arg (phi, op, e, locus);\n-\t  /* The resulting PHI if not dead can only be degenerate.  */\n-\t  gcc_assert (degenerate_phi_p (phi));\n-\t  gsi_next (&gsi);\n-\t}\n-    }\n-  return e;\n-}\n \n /* Remove dead statement pointed to by iterator I.  Receives the basic block BB\n    containing I so that we don't have to look it up.  */\n@@ -1075,38 +1019,50 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n   stats.removed++;\n \n   /* If we have determined that a conditional branch statement contributes\n-     nothing to the program, then we not only remove it, but we also change\n-     the flow graph so that the current block will simply fall-thru to its\n-     immediate post-dominator.  The blocks we are circumventing will be\n-     removed by cleanup_tree_cfg if this change in the flow graph makes them\n-     unreachable.  */\n+     nothing to the program, then we not only remove it, but we need to update\n+     the CFG.  We can chose any of edges out of BB as long as we are sure to not\n+     close infinite loops.  This is done by always choosing the edge closer to\n+     exit in inverted_post_order_compute order.  */\n   if (is_ctrl_stmt (stmt))\n     {\n-      basic_block post_dom_bb;\n-      edge e, e2;\n       edge_iterator ei;\n-\n-      post_dom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n-\n-      e = find_edge (bb, post_dom_bb);\n-\n-      /* If edge is already there, try to use it.  This avoids need to update\n-         PHI nodes.  Also watch for cases where post dominator does not exists\n-\t or is exit block.  These can happen for infinite loops as we create\n-\t fake edges in the dominator tree.  */\n-      if (e)\n-        ;\n-      else if (! post_dom_bb || post_dom_bb == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\te = EDGE_SUCC (bb, 0);\n-      else\n-        e = forward_edge_to_pdom (EDGE_SUCC (bb, 0), post_dom_bb);\n+      edge e = NULL, e2;\n+\n+      /* See if there is only one non-abnormal edge.  */\n+      if (single_succ_p (bb))\n+        e = single_succ_edge (bb);\n+      /* Otherwise chose one that is closer to bb with live statement in it.\n+         To be able to chose one, we compute inverted post order starting from\n+\t all BBs with live statements.  */\n+      if (!e)\n+\t{\n+\t  if (!bb_postorder)\n+\t    {\n+\t      int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+\t      int postorder_num\n+\t\t = inverted_post_order_compute (postorder,\n+\t\t\t\t\t\t&bb_contains_live_stmts);\n+\t      bb_postorder = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+\t      for (int i = 0; i < postorder_num; ++i)\n+\t\t bb_postorder[postorder[i]] = i;\n+\t      free (postorder);\n+\t    }\n+          FOR_EACH_EDGE (e2, ei, bb->succs)\n+\t    if (!e || e2->dest == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t\t|| bb_postorder [e->dest->index]\n+\t\t   < bb_postorder [e2->dest->index])\n+\t      e = e2;\n+\t}\n       gcc_assert (e);\n       e->probability = REG_BR_PROB_BASE;\n       e->count = bb->count;\n \n       /* The edge is no longer associated with a conditional, so it does\n-\t not have TRUE/FALSE flags.  */\n-      e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+\t not have TRUE/FALSE flags.\n+\t We are also safe to drop EH/ABNORMAL flags and turn them into\n+\t normal control flow, because we know that all the destinations (including\n+\t those odd edges) are equivalent for program execution.  */\n+      e->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE | EDGE_EH | EDGE_ABNORMAL);\n \n       /* The lone outgoing edge from BB will be a fallthru edge.  */\n       e->flags |= EDGE_FALLTHRU;\n@@ -1516,6 +1472,10 @@ eliminate_unnecessary_stmts (void)\n       something_changed |= remove_dead_phis (bb);\n     }\n \n+  if (bb_postorder)\n+    free (bb_postorder);\n+  bb_postorder = NULL;\n+\n   return something_changed;\n }\n "}]}