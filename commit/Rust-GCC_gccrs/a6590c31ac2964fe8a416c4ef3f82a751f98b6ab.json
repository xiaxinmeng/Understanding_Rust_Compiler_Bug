{"sha": "a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY1OTBjMzFhYzI5NjRmZThhNDE2YzRlZjNmODJhNzUxZjk4YjZhYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-16T14:58:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-16T14:58:34Z"}, "message": "var-tracking.c (vars_copy_1): Inline ...\n\n2010-05-16  Richard Guenther  <rguenther@suse.de>\n\n\t* var-tracking.c (vars_copy_1): Inline ...\n\t(vars_copy): ... here.  Use FOR_EACH_HTAB_ELEMENT.\n\t(variable_union): Use FOR_EACH_HTAB_ELEMENT.  Merge asserts.\n\t(variable_merge_over_cur): Adjust.  Merge asserts.\n\t(variable_merge_over_src): Likewise.\n\t(dataflow_set_merge): Use FOR_EACH_HTAB_ELEMENT.\n\t(variable_post_merge_new_vals): Merge asserts.\n\t(variable_post_merge_perm_vals): Likewise.\n\t(find_mem_expr_in_1pdv): Likewise.\n\t(dataflow_set_different_value): Remove.\n\t(onepart_variable_different_p): Merge asserts.\n\t(variable_different_p): Likewise.\n\t(dataflow_set_different_1): Inline ...\n\t(dataflow_set_different): ... here.  Use FOR_EACH_HTAB_ELEMENT.\n\t(emit_notes_for_differences_1): Merge asserts.\n\nFrom-SVN: r159456", "tree": {"sha": "1a23c7985af7b7f0cbd86ab012ccf69923199769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a23c7985af7b7f0cbd86ab012ccf69923199769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6456e26e2cd7f182ad6e8650e15799324c4b4173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6456e26e2cd7f182ad6e8650e15799324c4b4173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6456e26e2cd7f182ad6e8650e15799324c4b4173"}], "stats": {"total": 234, "additions": 108, "deletions": 126}, "files": [{"sha": "9c1cd4d80d935e5fa3b03d730295a3494b174100", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "patch": "@@ -1,3 +1,21 @@\n+2010-05-16  Richard Guenther  <rguenther@suse.de>\n+\n+\t* var-tracking.c (vars_copy_1): Inline ...\n+\t(vars_copy): ... here.  Use FOR_EACH_HTAB_ELEMENT.\n+\t(variable_union): Use FOR_EACH_HTAB_ELEMENT.  Merge asserts.\n+\t(variable_merge_over_cur): Adjust.  Merge asserts.\n+\t(variable_merge_over_src): Likewise.\n+\t(dataflow_set_merge): Use FOR_EACH_HTAB_ELEMENT.\n+\t(variable_post_merge_new_vals): Merge asserts.\n+\t(variable_post_merge_perm_vals): Likewise.\n+\t(find_mem_expr_in_1pdv): Likewise.\n+\t(dataflow_set_different_value): Remove.\n+\t(onepart_variable_different_p): Merge asserts.\n+\t(variable_different_p): Likewise.\n+\t(dataflow_set_different_1): Inline ...\n+\t(dataflow_set_different): ... here.  Use FOR_EACH_HTAB_ELEMENT.\n+\t(emit_notes_for_differences_1): Merge asserts.\n+\n 2010-05-16  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-symtab.c (lto_symtab_entry_hash): Use IDENTIFIER_HASH_VALUE."}, {"sha": "b2c828a0ee6cc1dfdb4392722ccbe7b7baf26dc6", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 90, "deletions": 126, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6590c31ac2964fe8a416c4ef3f82a751f98b6ab/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=a6590c31ac2964fe8a416c4ef3f82a751f98b6ab", "patch": "@@ -421,7 +421,6 @@ static void attrs_list_union (attrs *, attrs);\n \n static void **unshare_variable (dataflow_set *set, void **slot, variable var,\n \t\t\t\tenum var_init_status);\n-static int vars_copy_1 (void **, void *);\n static void vars_copy (htab_t, htab_t);\n static tree var_debug_decl (tree);\n static void var_reg_set (dataflow_set *, rtx, enum var_init_status, rtx);\n@@ -438,15 +437,13 @@ static void dataflow_set_init (dataflow_set *);\n static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n-static int variable_union (void **, void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n static location_chain find_loc_in_1pdv (rtx, variable, htab_t);\n static bool canon_value_cmp (rtx, rtx);\n static int loc_cmp (rtx, rtx);\n static bool variable_part_different_p (variable_part *, variable_part *);\n static bool onepart_variable_different_p (variable, variable);\n static bool variable_different_p (variable, variable);\n-static int dataflow_set_different_1 (void **, void *);\n static bool dataflow_set_different (dataflow_set *, dataflow_set *);\n static void dataflow_set_destroy (dataflow_set *);\n \n@@ -1537,34 +1534,23 @@ unshare_variable (dataflow_set *set, void **slot, variable var,\n   return slot;\n }\n \n-/* Add a variable from *SLOT to hash table DATA and increase its reference\n-   count.  */\n-\n-static int\n-vars_copy_1 (void **slot, void *data)\n-{\n-  htab_t dst = (htab_t) data;\n-  variable src;\n-  void **dstp;\n-\n-  src = (variable) *slot;\n-  src->refcount++;\n-\n-  dstp = htab_find_slot_with_hash (dst, src->dv,\n-\t\t\t\t   dv_htab_hash (src->dv),\n-\t\t\t\t   INSERT);\n-  *dstp = src;\n-\n-  /* Continue traversing the hash table.  */\n-  return 1;\n-}\n-\n /* Copy all variables from hash table SRC to hash table DST.  */\n \n static void\n vars_copy (htab_t dst, htab_t src)\n {\n-  htab_traverse_noresize (src, vars_copy_1, dst);\n+  htab_iterator hi;\n+  variable var;\n+\n+  FOR_EACH_HTAB_ELEMENT (src, var, variable, hi)\n+    {\n+      void **dstp;\n+      var->refcount++;\n+      dstp = htab_find_slot_with_hash (dst, var->dv,\n+\t\t\t\t       dv_htab_hash (var->dv),\n+\t\t\t\t       INSERT);\n+      *dstp = var;\n+    }\n }\n \n /* Map a decl to its main debug decl.  */\n@@ -2069,14 +2055,12 @@ variable_union_info_cmp_pos (const void *n1, const void *n2)\n    we keep the newest locations in the beginning.  */\n \n static int\n-variable_union (void **slot, void *data)\n+variable_union (variable src, dataflow_set *set)\n {\n-  variable src, dst;\n+  variable dst;\n   void **dstp;\n-  dataflow_set *set = (dataflow_set *) data;\n   int i, j, k;\n \n-  src = (variable) *slot;\n   dstp = shared_hash_find_slot (set->vars, src->dv);\n   if (!dstp || !*dstp)\n     {\n@@ -2102,8 +2086,8 @@ variable_union (void **slot, void *data)\n     {\n       location_chain *nodep, dnode, snode;\n \n-      gcc_assert (src->n_var_parts == 1);\n-      gcc_assert (dst->n_var_parts == 1);\n+      gcc_assert (src->n_var_parts == 1\n+\t\t  && dst->n_var_parts == 1);\n \n       snode = src->var_part[0].loc_chain;\n       gcc_assert (snode);\n@@ -2452,7 +2436,13 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n       dst->vars = shared_hash_copy (src->vars);\n     }\n   else\n-    htab_traverse (shared_hash_htab (src->vars), variable_union, dst);\n+    {\n+      htab_iterator hi;\n+      variable var;\n+\n+      FOR_EACH_HTAB_ELEMENT (shared_hash_htab (src->vars), var, variable, hi)\n+\tvariable_union (var, dst);\n+    }\n }\n \n /* Whether the value is currently being expanded.  */\n@@ -3323,12 +3313,10 @@ canonicalize_vars_star (void **slot, void *data)\n    intersection.  */\n \n static int\n-variable_merge_over_cur (void **s1slot, void *data)\n+variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n {\n-  struct dfset_merge *dsm = (struct dfset_merge *)data;\n   dataflow_set *dst = dsm->dst;\n   void **dstslot;\n-  variable s1var = (variable) *s1slot;\n   variable s2var, dvar = NULL;\n   decl_or_value dv = s1var->dv;\n   bool onepart = dv_onepart_p (dv);\n@@ -3339,14 +3327,14 @@ variable_merge_over_cur (void **s1slot, void *data)\n   /* If the incoming onepart variable has an empty location list, then\n      the intersection will be just as empty.  For other variables,\n      it's always union.  */\n-  gcc_assert (s1var->n_var_parts);\n-  gcc_assert (s1var->var_part[0].loc_chain);\n+  gcc_assert (s1var->n_var_parts\n+\t      && s1var->var_part[0].loc_chain);\n \n   if (!onepart)\n-    return variable_union (s1slot, dst);\n+    return variable_union (s1var, dst);\n \n-  gcc_assert (s1var->n_var_parts == 1);\n-  gcc_assert (s1var->var_part[0].offset == 0);\n+  gcc_assert (s1var->n_var_parts == 1\n+\t      && s1var->var_part[0].offset == 0);\n \n   dvhash = dv_htab_hash (dv);\n   if (dv_is_value_p (dv))\n@@ -3362,17 +3350,17 @@ variable_merge_over_cur (void **s1slot, void *data)\n     }\n \n   dsm->src_onepart_cnt--;\n-  gcc_assert (s2var->var_part[0].loc_chain);\n-  gcc_assert (s2var->n_var_parts == 1);\n-  gcc_assert (s2var->var_part[0].offset == 0);\n+  gcc_assert (s2var->var_part[0].loc_chain\n+\t      && s2var->n_var_parts == 1\n+\t      && s2var->var_part[0].offset == 0);\n \n   dstslot = shared_hash_find_slot_noinsert_1 (dst->vars, dv, dvhash);\n   if (dstslot)\n     {\n       dvar = (variable)*dstslot;\n-      gcc_assert (dvar->refcount == 1);\n-      gcc_assert (dvar->n_var_parts == 1);\n-      gcc_assert (dvar->var_part[0].offset == 0);\n+      gcc_assert (dvar->refcount == 1\n+\t\t  && dvar->n_var_parts == 1\n+\t\t  && dvar->var_part[0].offset == 0);\n       nodep = &dvar->var_part[0].loc_chain;\n     }\n   else\n@@ -3586,11 +3574,9 @@ variable_merge_over_cur (void **s1slot, void *data)\n    variable_merge_over_cur().  */\n \n static int\n-variable_merge_over_src (void **s2slot, void *data)\n+variable_merge_over_src (variable s2var, struct dfset_merge *dsm)\n {\n-  struct dfset_merge *dsm = (struct dfset_merge *)data;\n   dataflow_set *dst = dsm->dst;\n-  variable s2var = (variable) *s2slot;\n   decl_or_value dv = s2var->dv;\n   bool onepart = dv_onepart_p (dv);\n \n@@ -3617,6 +3603,8 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   struct dfset_merge dsm;\n   int i;\n   size_t src1_elems, src2_elems;\n+  htab_iterator hi;\n+  variable var;\n \n   src1_elems = htab_elements (shared_hash_htab (src1->vars));\n   src2_elems = htab_elements (shared_hash_htab (src2->vars));\n@@ -3637,10 +3625,10 @@ dataflow_set_merge (dataflow_set *dst, dataflow_set *src2)\n   dsm.cur = src1;\n   dsm.src_onepart_cnt = 0;\n \n-  htab_traverse (shared_hash_htab (dsm.src->vars), variable_merge_over_src,\n-\t\t &dsm);\n-  htab_traverse (shared_hash_htab (dsm.cur->vars), variable_merge_over_cur,\n-\t\t &dsm);\n+  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (dsm.src->vars), var, variable, hi)\n+    variable_merge_over_src (var, &dsm);\n+  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (dsm.cur->vars), var, variable, hi)\n+    variable_merge_over_cur (var, &dsm);\n \n   if (dsm.src_onepart_cnt)\n     dst_can_be_shared = false;\n@@ -3853,8 +3841,8 @@ variable_post_merge_new_vals (void **slot, void *info)\n \t\t       att; att = att->next)\n \t\t    if (GET_MODE (att->loc) == GET_MODE (node->loc))\n \t\t      {\n-\t\t\tgcc_assert (att->offset == 0);\n-\t\t\tgcc_assert (dv_is_value_p (att->dv));\n+\t\t\tgcc_assert (att->offset == 0\n+\t\t\t\t    && dv_is_value_p (att->dv));\n \t\t\tval_reset (set, att->dv);\n \t\t\tbreak;\n \t\t      }\n@@ -3920,12 +3908,12 @@ variable_post_merge_perm_vals (void **pslot, void *info)\n   decl_or_value dv;\n   attrs att;\n \n-  gcc_assert (dv_is_value_p (pvar->dv));\n-  gcc_assert (pvar->n_var_parts == 1);\n+  gcc_assert (dv_is_value_p (pvar->dv)\n+\t      && pvar->n_var_parts == 1);\n   pnode = pvar->var_part[0].loc_chain;\n-  gcc_assert (pnode);\n-  gcc_assert (!pnode->next);\n-  gcc_assert (REG_P (pnode->loc));\n+  gcc_assert (pnode\n+\t      && !pnode->next\n+\t      && REG_P (pnode->loc));\n \n   dv = pvar->dv;\n \n@@ -3956,7 +3944,7 @@ variable_post_merge_perm_vals (void **pslot, void *info)\n     {\n       attrs_list_insert (&set->regs[REGNO (pnode->loc)],\n \t\t\t dv, 0, pnode->loc);\n-      variable_union (pslot, set);\n+      variable_union (pvar, set);\n     }\n \n   return 1;\n@@ -3997,9 +3985,8 @@ find_mem_expr_in_1pdv (tree expr, rtx val, htab_t vars)\n   if (!val)\n     return NULL;\n \n-  gcc_assert (GET_CODE (val) == VALUE);\n-\n-  gcc_assert (!VALUE_RECURSED_INTO (val));\n+  gcc_assert (GET_CODE (val) == VALUE\n+\t      && !VALUE_RECURSED_INTO (val));\n \n   dv = dv_from_value (val);\n   var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n@@ -4265,10 +4252,6 @@ dataflow_set_clear_at_call (dataflow_set *set)\n     }\n }\n \n-/* Flag whether two dataflow sets being compared contain different data.  */\n-static bool\n-dataflow_set_different_value;\n-\n static bool\n variable_part_different_p (variable_part *vp1, variable_part *vp2)\n {\n@@ -4303,14 +4286,13 @@ onepart_variable_different_p (variable var1, variable var2)\n   if (var1 == var2)\n     return false;\n \n-  gcc_assert (var1->n_var_parts == 1);\n-  gcc_assert (var2->n_var_parts == 1);\n+  gcc_assert (var1->n_var_parts == 1\n+\t      && var2->n_var_parts == 1);\n \n   lc1 = var1->var_part[0].loc_chain;\n   lc2 = var2->var_part[0].loc_chain;\n \n-  gcc_assert (lc1);\n-  gcc_assert (lc2);\n+  gcc_assert (lc1 && lc2);\n \n   while (lc1 && lc2)\n     {\n@@ -4343,8 +4325,8 @@ variable_different_p (variable var1, variable var2)\n       /* One-part values have locations in a canonical order.  */\n       if (i == 0 && var1->var_part[i].offset == 0 && dv_onepart_p (var1->dv))\n \t{\n-\t  gcc_assert (var1->n_var_parts == 1);\n-\t  gcc_assert (dv_as_opaque (var1->dv) == dv_as_opaque (var2->dv));\n+\t  gcc_assert (var1->n_var_parts == 1\n+\t\t      && dv_as_opaque (var1->dv) == dv_as_opaque (var2->dv));\n \t  return onepart_variable_different_p (var1, var2);\n \t}\n       if (variable_part_different_p (&var1->var_part[i], &var2->var_part[i]))\n@@ -4355,71 +4337,53 @@ variable_different_p (variable var1, variable var2)\n   return false;\n }\n \n-/* Compare variable *SLOT with the same variable in hash table DATA\n-   and set DATAFLOW_SET_DIFFERENT_VALUE if they are different.  */\n-\n-static int\n-dataflow_set_different_1 (void **slot, void *data)\n-{\n-  htab_t htab = (htab_t) data;\n-  variable var1, var2;\n-\n-  var1 = (variable) *slot;\n-  var2 = (variable) htab_find_with_hash (htab, var1->dv,\n-\t\t\t\t\t dv_htab_hash (var1->dv));\n-  if (!var2)\n-    {\n-      dataflow_set_different_value = true;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"dataflow difference found: removal of:\\n\");\n-\t  dump_var (var1);\n-\t}\n-\n-      /* Stop traversing the hash table.  */\n-      return 0;\n-    }\n-\n-  if (variable_different_p (var1, var2))\n-    {\n-      dataflow_set_different_value = true;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"dataflow difference found: old and new follow:\\n\");\n-\t  dump_var (var1);\n-\t  dump_var (var2);\n-\t}\n-\n-      /* Stop traversing the hash table.  */\n-      return 0;\n-    }\n-\n-  /* Continue traversing the hash table.  */\n-  return 1;\n-}\n-\n /* Return true if dataflow sets OLD_SET and NEW_SET differ.  */\n \n static bool\n dataflow_set_different (dataflow_set *old_set, dataflow_set *new_set)\n {\n+  htab_iterator hi;\n+  variable var1;\n+\n   if (old_set->vars == new_set->vars)\n     return false;\n \n   if (htab_elements (shared_hash_htab (old_set->vars))\n       != htab_elements (shared_hash_htab (new_set->vars)))\n     return true;\n \n-  dataflow_set_different_value = false;\n+  FOR_EACH_HTAB_ELEMENT (shared_hash_htab (old_set->vars), var1, variable, hi)\n+    {\n+      htab_t htab = shared_hash_htab (new_set->vars);\n+      variable var2 = (variable) htab_find_with_hash (htab, var1->dv,\n+\t\t\t\t\t\t      dv_htab_hash (var1->dv));\n+      if (!var2)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"dataflow difference found: removal of:\\n\");\n+\t      dump_var (var1);\n+\t    }\n+\t  return true;\n+\t}\n+\n+      if (variable_different_p (var1, var2))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"dataflow difference found: \"\n+\t\t       \"old and new follow:\\n\");\n+\t      dump_var (var1);\n+\t      dump_var (var2);\n+\t    }\n+\t  return true;\n+\t}\n+    }\n \n-  htab_traverse (shared_hash_htab (old_set->vars), dataflow_set_different_1,\n-\t\t shared_hash_htab (new_set->vars));\n   /* No need to traverse the second hashtab, if both have the same number\n      of elements and the second one had all entries found in the first one,\n      then it can't have any extra entries.  */\n-  return dataflow_set_different_value;\n+  return false;\n }\n \n /* Free the contents of dataflow set SET.  */\n@@ -7469,8 +7433,8 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \t{\n \t  location_chain lc1, lc2;\n \n-\t  gcc_assert (old_var->n_var_parts == 1);\n-\t  gcc_assert (new_var->n_var_parts == 1);\n+\t  gcc_assert (old_var->n_var_parts == 1\n+\t\t      && new_var->n_var_parts == 1);\n \t  lc1 = old_var->var_part[0].loc_chain;\n \t  lc2 = new_var->var_part[0].loc_chain;\n \t  while (lc1"}]}