{"sha": "9531ffdaafe38f8cf07481430daba035e855bdf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUzMWZmZGFhZmUzOGY4Y2YwNzQ4MTQzMGRhYmEwMzVlODU1YmRmNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-01-24T19:14:14Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-04T09:11:18Z"}, "message": "[Ada] Ada_2020: contracts for formal subprograms\n\n2020-06-04  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch12.adb (Build_Suprogram_Body_Wrapper,\n\tBuild_Subprogram_Decl_Wrapper): New suprograms, to create the\n\twrappers needed to implement contracts on formsl subprograms at\n\tthe point of instantiation.\n\t(Build_Subprogram_Wrappers): New subprogram within\n\tAnalyze_Associations, calls the above when the formal subprogram\n\thas contracts, and expansion is enabled.\n\t(Instantiate_Formal_Subprogram): If the actual is not an entity,\n\tsuch as a function attribute, or a synchronized operation,\n\tcreate a function with an internal name and call it within the\n\twrapper.\n\t(Analyze_Generic_Formal_Part): Analyze contracts at the end of\n\tthe list of formal declarations.\n\t* sem_prag.adb (Analyze_Pre_Post_Condtion): In Ada_2020 the\n\taspect and corresponding pragma can appear on a formal\n\tsubprogram declaration.\n\t(Find_Related_Declaration_Or_Body): Ditto.", "tree": {"sha": "0ff699ce35670ed1cf4cda30af6def5effae4c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ff699ce35670ed1cf4cda30af6def5effae4c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9531ffdaafe38f8cf07481430daba035e855bdf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9531ffdaafe38f8cf07481430daba035e855bdf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9531ffdaafe38f8cf07481430daba035e855bdf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9531ffdaafe38f8cf07481430daba035e855bdf4/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a76d621a4b6e324777677c8a5a81c09da2db9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25a76d621a4b6e324777677c8a5a81c09da2db9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25a76d621a4b6e324777677c8a5a81c09da2db9d"}], "stats": {"total": 227, "additions": 224, "deletions": 3}, "files": [{"sha": "4dd2a31921e14a1b0903e1a8f7dee5bbe6d6e618", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 210, "deletions": 3, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9531ffdaafe38f8cf07481430daba035e855bdf4/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9531ffdaafe38f8cf07481430daba035e855bdf4/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9531ffdaafe38f8cf07481430daba035e855bdf4", "patch": "@@ -495,6 +495,23 @@ package body Sem_Ch12 is\n    --  nodes or subprogram body and declaration nodes depending on the case).\n    --  On return, the node N has been rewritten with the actual body.\n \n+   function Build_Subprogram_Decl_Wrapper\n+     (Formal_Subp : Entity_Id;\n+      Actual_Subp : Entity_Id) return Node_Id;\n+   --  Ada 2020 allows formal subprograms to carry pre/postconditions.\n+   --  At the point of instantiation these contracts apply to uses of\n+   --  the actual subprogram. This is implemented by creating wrapper\n+   --  subprograms instead of the renamings previously used to link\n+   --  formal subprograms and the corresponding actuals. If the actual\n+   --  is not an entity (e.g. an attribute reference) a renaming is\n+   --  created to handle the expansion of the attribute.\n+\n+   function Build_Subprogram_Body_Wrapper\n+     (Formal_Subp : Entity_Id;\n+      Actual_Subp : Entity_Id) return Node_Id;\n+   --  The body of the wrapper is a call to the actual, with the generated\n+   --  pre/postconditon checks added.\n+\n    procedure Check_Access_Definition (N : Node_Id);\n    --  Subsidiary routine to null exclusion processing. Perform an assertion\n    --  check on Ada version and the presence of an access definition in N.\n@@ -1078,6 +1095,14 @@ package body Sem_Ch12 is\n       --  In Ada 2005, indicates partial parameterization of a formal\n       --  package. As usual an other association must be last in the list.\n \n+      procedure Build_Subprogram_Wrappers;\n+      --  Ada_2020: AI12-0272 introduces pre/postconditions for formal\n+      --  subprograms. The implementation of making the formal into a renaming\n+      --  of the actual does not work, given that subprogram renaming cannot\n+      --  carry aspect specifications. Instead we must create subprogram\n+      --  wrappers whose body is a call to the actual, and whose declaration\n+      --  carries the aspects of the formal.\n+\n       procedure Check_Fixed_Point_Actual (Actual : Node_Id);\n       --  Warn if an actual fixed-point type has user-defined arithmetic\n       --  operations, but there is no corresponding formal in the generic,\n@@ -1131,6 +1156,49 @@ package body Sem_Ch12 is\n       --  anonymous types, the presence a formal equality will introduce an\n       --  implicit declaration for the corresponding inequality.\n \n+      -----------------------------------------\n+      -- procedure Build_Subprogram_Wrappers --\n+      -----------------------------------------\n+\n+      procedure Build_Subprogram_Wrappers is\n+         Formal : constant Entity_Id :=\n+           Defining_Unit_Name (Specification (Analyzed_Formal));\n+         Aspect_Spec : Node_Id;\n+         Decl_Node   : Node_Id;\n+         Ent         : Entity_Id;\n+\n+      begin\n+         --  Create declaration for wrapper subprogram\n+\n+         if Is_Entity_Name (Match) then\n+            Ent := Entity (Match);\n+         else\n+            Ent := Defining_Entity (Last (Assoc_List));\n+         end if;\n+\n+         Decl_Node := Build_Subprogram_Decl_Wrapper (Formal, Ent);\n+\n+         --  Transfer aspect specifications from formal subprogram to wrapper\n+\n+         Set_Aspect_Specifications (Decl_Node,\n+           New_Copy_List_Tree (Aspect_Specifications (Analyzed_Formal)));\n+\n+         Aspect_Spec := First (Aspect_Specifications (Decl_Node));\n+         while Present (Aspect_Spec) loop\n+            Set_Analyzed (Aspect_Spec, False);\n+            Next (Aspect_Spec);\n+         end loop;\n+\n+         Append_To (Assoc_List, Decl_Node);\n+\n+         --  Create corresponding body, and append it to association list\n+         --  that appears at the head of the declarations in the instance.\n+         --  The subprogram may be called in the analysis of subsequent\n+         --  actuals.\n+\n+         Append_To (Assoc_List, Build_Subprogram_Body_Wrapper (Formal, Ent));\n+      end Build_Subprogram_Wrappers;\n+\n       ----------------------------------------\n       -- Check_Overloaded_Formal_Subprogram --\n       ----------------------------------------\n@@ -1793,6 +1861,16 @@ package body Sem_Ch12 is\n                        Instantiate_Formal_Subprogram\n                          (Formal, Match, Analyzed_Formal));\n \n+                     --  If formal subprogram has contracts, create wrappers\n+                     --  for it. This is an expansion activity that cannot\n+                     --  take place e.g. within an enclosing generic unit.\n+\n+                     if Present (Aspect_Specifications (Analyzed_Formal))\n+                       and then Expander_Active\n+                     then\n+                        Build_Subprogram_Wrappers;\n+                     end if;\n+\n                      --  An instantiation is a freeze point for the actuals,\n                      --  unless this is a rewritten formal package.\n \n@@ -3475,6 +3553,12 @@ package body Sem_Ch12 is\n       end loop;\n \n       Generate_Reference_To_Generic_Formals (Current_Scope);\n+\n+      --  For Ada_2020, some formal parameters can carry aspects, which must\n+      --  be name-resolved at the end of the list of formal parameters (which\n+      --  has the semantics of a declaration list).\n+\n+      Analyze_Contracts (Generic_Formal_Declarations (N));\n    end Analyze_Generic_Formal_Part;\n \n    ------------------------------------------\n@@ -6115,6 +6199,116 @@ package body Sem_Ch12 is\n       return Decl;\n    end Build_Operator_Wrapper;\n \n+   -----------------------------------\n+   -- Build_Subprogram_Decl_Wrapper --\n+   -----------------------------------\n+\n+   function Build_Subprogram_Decl_Wrapper\n+     (Formal_Subp : Entity_Id;\n+      Actual_Subp : Entity_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Current_Scope);\n+      Ret_Type  : constant Entity_Id  := Get_Instance_Of (Etype (Formal_Subp));\n+      Decl      : Node_Id;\n+      Subp      : Entity_Id;\n+      Parm_Spec : Node_Id;\n+      Profile   : List_Id := New_List;\n+      Spec      : Node_Id;\n+      Form_F    : Entity_Id;\n+      New_F     : Entity_Id;\n+\n+   begin\n+\n+      Subp := Make_Defining_Identifier (Loc, Chars (Formal_Subp));\n+      Set_Ekind (Subp, Ekind (Formal_Subp));\n+      Set_Is_Generic_Actual_Subprogram (Subp);\n+\n+      Profile := Parameter_Specifications (\n+                   New_Copy_Tree\n+                    (Specification (Unit_Declaration_Node (Actual_Subp))));\n+\n+      Form_F := First_Formal (Formal_Subp);\n+      Parm_Spec := First (Profile);\n+\n+      --  Create new entities for the formals.\n+\n+      while Present (Parm_Spec) loop\n+         New_F := Make_Defining_Identifier (Loc, Chars (Form_F));\n+         Set_Defining_Identifier (Parm_Spec, New_F);\n+         Next (Parm_Spec);\n+         Next_Formal (Form_F);\n+      end loop;\n+\n+      if Ret_Type = Standard_Void_Type then\n+         Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name       => Subp,\n+             Parameter_Specifications => Profile);\n+      else\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => Subp,\n+             Parameter_Specifications => Profile,\n+             Result_Definition        => New_Occurrence_Of (Ret_Type, Loc));\n+      end if;\n+\n+      Decl :=\n+        Make_Subprogram_Declaration (Loc, Specification => Spec);\n+\n+      return Decl;\n+   end Build_Subprogram_Decl_Wrapper;\n+\n+   -----------------------------------\n+   -- Build_Subprogram_Body_Wrapper --\n+   -----------------------------------\n+\n+   function Build_Subprogram_Body_Wrapper\n+     (Formal_Subp : Entity_Id;\n+      Actual_Subp : Entity_Id) return Node_Id\n+   is\n+      Loc       : constant Source_Ptr := Sloc (Current_Scope);\n+      Ret_Type  : constant Entity_Id  := Get_Instance_Of (Etype (Formal_Subp));\n+      Spec_Node : constant Node_Id :=\n+        Specification\n+          (Build_Subprogram_Decl_Wrapper (Formal_Subp, Actual_Subp));\n+      Act       : Node_Id;\n+      Actuals   : List_Id;\n+      Body_Node : Node_Id;\n+      Stmt      : Node_Id;\n+   begin\n+      Actuals := New_List;\n+      Act := First (Parameter_Specifications (Spec_Node));\n+\n+      while Present (Act) loop\n+         Append_To (Actuals,\n+            Make_Identifier  (Loc, Chars (Defining_Identifier (Act))));\n+         Next (Act);\n+      end loop;\n+\n+      if Ret_Type = Standard_Void_Type then\n+         Stmt := Make_Procedure_Call_Statement (Loc,\n+          Name                   => New_Occurrence_Of (Actual_Subp, Loc),\n+          Parameter_Associations => Actuals);\n+\n+      else\n+         Stmt := Make_Simple_Return_Statement (Loc,\n+            Expression =>\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Actual_Subp, Loc),\n+                Parameter_Associations => Actuals));\n+      end if;\n+\n+      Body_Node := Make_Subprogram_Body (Loc,\n+        Specification => Spec_Node,\n+        Declarations  => New_List,\n+        Handled_Statement_Sequence =>\n+           Make_Handled_Sequence_Of_Statements (Loc,\n+             Statements    => New_List (Stmt)));\n+\n+      return Body_Node;\n+   end Build_Subprogram_Body_Wrapper;\n+\n    -------------------------------------------\n    -- Build_Instance_Compilation_Unit_Nodes --\n    -------------------------------------------\n@@ -10696,7 +10890,20 @@ package body Sem_Ch12 is\n       --  Create new entity for the actual (New_Copy_Tree does not), and\n       --  indicate that it is an actual.\n \n-      New_Subp := Make_Defining_Identifier (Loc, Chars (Formal_Sub));\n+      --  If the actual is not an entity and the formal includes aspect\n+      --  specifications for contracts, we create an internal name for\n+      --  the renaming declaration. The constructed wrapper contains a\n+      --  call to the entity in the renaming.\n+\n+      if Ada_Version >= Ada_2020\n+        and then Present (Aspect_Specifications (Analyzed_Formal))\n+      then\n+         New_Subp := Make_Temporary (Sloc (Actual), 'S');\n+         Set_Defining_Unit_Name (New_Spec, New_Subp);\n+      else\n+         New_Subp := Make_Defining_Identifier (Loc, Chars (Formal_Sub));\n+      end if;\n+\n       Set_Ekind (New_Subp, Ekind (Analyzed_S));\n       Set_Is_Generic_Actual_Subprogram (New_Subp);\n       Set_Defining_Unit_Name (New_Spec, New_Subp);\n@@ -12872,8 +13079,8 @@ package body Sem_Ch12 is\n          --  Perform atomic/volatile checks (RM C.6(12)). Note that AI05-0218-1\n          --  removes the second instance of the phrase \"or allow pass by copy\".\n \n-         --  In Ada_2020 the aspect may be specified explicitly for the formal\n-         --  regardless of whether an ancestor obeys it.\n+         --  For Ada_2020, the aspect may be specified explicitly for the\n+         --  formal regardless of whether an ancestor obeys it.\n \n          if Is_Atomic (Act_T)\n              and then not Is_Atomic (Ancestor)"}, {"sha": "4c3ca6c66e54df61c9fdf63db1fa472868dc72d9", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9531ffdaafe38f8cf07481430daba035e855bdf4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9531ffdaafe38f8cf07481430daba035e855bdf4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9531ffdaafe38f8cf07481430daba035e855bdf4", "patch": "@@ -4756,6 +4756,13 @@ package body Sem_Prag is\n          then\n             null;\n \n+         --  For Ada_2020, pre/postconditions can appear on formal subprograms\n+\n+         elsif Nkind (Subp_Decl) = N_Formal_Concrete_Subprogram_Declaration\n+            and then Ada_Version >= Ada_2020\n+         then\n+            null;\n+\n          --  Otherwise the placement is illegal\n \n          else\n@@ -30023,6 +30030,13 @@ package body Sem_Prag is\n \n                elsif Present (Generic_Parent (Specification (Stmt))) then\n                   return Stmt;\n+\n+               --  Ada_2020: contract on formal subprogram\n+\n+               elsif Is_Generic_Actual_Subprogram (Defining_Entity (Stmt))\n+                 and then Ada_Version >= Ada_2020\n+               then\n+                  return Stmt;\n                end if;\n             end if;\n "}]}