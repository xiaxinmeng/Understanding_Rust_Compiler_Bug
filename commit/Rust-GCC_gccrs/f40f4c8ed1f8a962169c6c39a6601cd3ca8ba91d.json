{"sha": "f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwZjRjOGVkMWY4YTk2MjE2OWM2YzM5YTY2MDFjZDNjYThiYTkxZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-09-08T18:07:54Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-09-08T18:07:54Z"}, "message": "combine.c (try_combine): Handle the case that undobuf.other_insn has been turned into a return or...\n\n\n\t* combine.c (try_combine): Handle the case that undobuf.other_insn\n\thas been turned into a return or unconditional jump, by inserting\n\ta BARRIER if necessary.\n\t(simplify_set):  Test if a condition code setter has a constant\n\tcomparison at compile time, if so convert this insn to a no-op move\n\tand update/simplify the condition code user (undobuf.other_insn).\n\nFrom-SVN: r56955", "tree": {"sha": "c63485aa703dc30d1e5554c4e4e4824653fbd046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c63485aa703dc30d1e5554c4e4e4824653fbd046"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d/comments", "author": null, "committer": null, "parents": [{"sha": "e2f97e264e2e7806c47e31e3f8048d66d7b8623c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f97e264e2e7806c47e31e3f8048d66d7b8623c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f97e264e2e7806c47e31e3f8048d66d7b8623c"}], "stats": {"total": 54, "additions": 52, "deletions": 2}, "files": [{"sha": "3abc016560cb5643987598e6cb458e683e2cea21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "patch": "@@ -1,3 +1,12 @@\n+2002-09-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c (try_combine): Handle the case that undobuf.other_insn\n+\thas been turned into a return or unconditional jump, by inserting\n+\ta BARRIER if necessary.\n+\t(simplify_set):  Test if a condition code setter has a constant\n+\tcomparison at compile time, if so convert this insn to a no-op move\n+\tand update/simplify the condition code user (undobuf.other_insn).\n+\n 2002-09-08  Krister Walfridsson  <cato@df.lth.se>\n \n \t* config/arm/netbsd.h (INITIALIZE_TRAMPOLINE): Redefine."}, {"sha": "e1518817ca629017f883d80ab20b76e46e461e6b", "filename": "gcc/combine.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f40f4c8ed1f8a962169c6c39a6601cd3ca8ba91d", "patch": "@@ -2823,14 +2823,26 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n \n-    if (GET_CODE (newpat) == RETURN || any_uncondjump_p (i3))\n+    if (returnjump_p (i3) || any_uncondjump_p (i3))\n       {\n \t*new_direct_jump_p = 1;\n \n \tif ((temp = next_nonnote_insn (i3)) == NULL_RTX\n \t    || GET_CODE (temp) != BARRIER)\n \t  emit_barrier_after (i3);\n       }\n+\n+    if (undobuf.other_insn != NULL_RTX\n+\t&& (returnjump_p (undobuf.other_insn)\n+\t    || any_uncondjump_p (undobuf.other_insn)))\n+      {\n+\t*new_direct_jump_p = 1;\n+\n+\tif ((temp = next_nonnote_insn (undobuf.other_insn)) == NULL_RTX\n+\t    || GET_CODE (temp) != BARRIER)\n+\t  emit_barrier_after (undobuf.other_insn);\n+      }\n+\t\n     /* An NOOP jump does not need barrier, but it does need cleaning up\n        of CFG.  */\n     if (GET_CODE (newpat) == SET\n@@ -5014,15 +5026,44 @@ simplify_set (x)\n     {\n       enum rtx_code old_code = GET_CODE (*cc_use);\n       enum rtx_code new_code;\n-      rtx op0, op1;\n+      rtx op0, op1, tmp;\n       int other_changed = 0;\n       enum machine_mode compare_mode = GET_MODE (dest);\n+      enum machine_mode tmp_mode;\n \n       if (GET_CODE (src) == COMPARE)\n \top0 = XEXP (src, 0), op1 = XEXP (src, 1);\n       else\n \top0 = src, op1 = const0_rtx;\n \n+      /* Check whether the comparison is known at compile time.  */\n+      if (GET_MODE (op0) != VOIDmode)\n+\ttmp_mode = GET_MODE (op0);\n+      else if (GET_MODE (op1) != VOIDmode)\n+\ttmp_mode = GET_MODE (op1);\n+      else\n+\ttmp_mode = compare_mode;\n+      tmp = simplify_relational_operation (old_code, tmp_mode, op0, op1);\n+      if (tmp != NULL_RTX)\n+\t{\n+\t  rtx pat = PATTERN (other_insn);\n+\t  undobuf.other_insn = other_insn;\n+\t  SUBST (*cc_use, tmp);\n+\n+\t  /* Attempt to simplify CC user.  */\n+\t  if (GET_CODE (pat) == SET)\n+\t    {\n+\t      rtx new = simplify_rtx (SET_SRC (pat));\n+\t      if (new != NULL_RTX)\n+\t\tSUBST (SET_SRC (pat), new);\n+\t    }\n+\n+\t  /* Convert X into a no-op move.  */\n+\t  SUBST (SET_DEST (x), pc_rtx);\n+\t  SUBST (SET_SRC (x), pc_rtx);\n+\t  return x;\n+\t}\n+\n       /* Simplify our comparison, if possible.  */\n       new_code = simplify_comparison (old_code, &op0, &op1);\n "}]}