{"sha": "431be04b8b6e31d950ddab340ed866d197d23d4d", "node_id": "C_kwDOANBUbNoAKDQzMWJlMDRiOGI2ZTMxZDk1MGRkYWIzNDBlZDg2NmQxOTdkMjNkNGQ", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-11-04T19:22:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-11-08T00:54:04Z"}, "message": "c++: implement P2468R2, the equality operator you are looking for\n\nThis paper is resolving the problem of well-formed C++17 code becoming\nambiguous in C++20 due to asymmetrical operator== being compared with itself\nin reverse.  I had previously implemented a tiebreaker such that if the two\ncandidates were functions with the same parameter types, we would prefer the\nnon-reversed candidate.  But the committee went with a different approach:\nif there's an operator!= with the same parameter types as the operator==,\ndon't consider the reversed form of the ==.\n\nSo this patch implements that, and changes my old tiebreaker to give a\npedwarn if it is used.  I also noticed that we were giving duplicate errors\nfor some testcases, and fixed the tourney logic to avoid that.\n\nAs a result, a lot of tests of the form\n\n  struct A { bool operator==(const A&); };\n\nneed to be fixed to add a const function-cv-qualifier, e.g.\n\n  struct A { bool operator==(const A&) const; };\n\nThe committee thought such code ought to be fixed, so breaking it was fine.\n\n18_support/comparisons/algorithms/fallback.cc also breaks with this patch,\nbecause of the similarly asymmetrical\n\n  bool operator==(const S&, S&) { return true; }\n\nAs a result, some of the asserts need to be reversed.\n\nThe H test in spaceship-eq15.C is specified in the standard to be\nwell-formed because the op!= in the inline namespace is not found by the\nsearch, but that seems wrong to me.  I've implemented that behavior, but\ndisabled it for now; if we decide that is the way we want to go, we can just\nremove the \"0 &&\" in add_candidates to enable it.\n\nCo-authored-by: Jakub Jelinek <jakub@redhat.com>\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (fns_correspond): Declare.\n\t* decl.cc (fns_correspond): New.\n\t* call.cc (add_candidates): Look for op!= matching op==.\n\t(joust): Complain about non-standard reversed tiebreaker.\n\t(tourney): Fix champ_compared_to_predecessor logic.\n\t(build_new_op): Don't complain about error_mark_node not having\n\t'bool' type.\n\t* pt.cc (tsubst_copy_and_build): Don't try to be permissive\n\twhen seen_error().\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/spaceship-eq15.C: New test.\n\t* g++.dg/cpp0x/defaulted3.C: Add const.\n\t* g++.dg/cpp2a/bit-cast7.C: Add const.\n\t* g++.dg/cpp2a/spaceship-rewrite1.C: Expect error.\n\t* g++.dg/cpp2a/spaceship-rewrite5.C: Expect error.\n\t* g++.old-deja/g++.jason/byval2.C: Expect error.\n\t* g++.old-deja/g++.other/overload13.C: Add const.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/18_support/comparisons/algorithms/fallback.cc: Adjust\n\tasserts.", "tree": {"sha": "e0d29df251d9de1334b46cd96cd350e8534510e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d29df251d9de1334b46cd96cd350e8534510e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/431be04b8b6e31d950ddab340ed866d197d23d4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431be04b8b6e31d950ddab340ed866d197d23d4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431be04b8b6e31d950ddab340ed866d197d23d4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431be04b8b6e31d950ddab340ed866d197d23d4d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c838119946c9f75f1e42f4320275355822cc86fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c838119946c9f75f1e42f4320275355822cc86fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c838119946c9f75f1e42f4320275355822cc86fc"}], "stats": {"total": 409, "additions": 389, "deletions": 20}, "files": [{"sha": "492db9b59ad5d4283464fc1e3a2fce854dca2ec4", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -6232,6 +6232,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n   bool check_list_ctor = false;\n   bool check_converting = false;\n   unification_kind_t strict;\n+  tree ne_fns = NULL_TREE;\n \n   if (!fns)\n     return;\n@@ -6269,6 +6270,32 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n       ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n     }\n \n+  /* P2468: Check if operator== is a rewrite target with first operand\n+     (*args)[0]; for now just do the lookups.  */\n+  if ((flags & (LOOKUP_REWRITTEN | LOOKUP_REVERSED))\n+      && DECL_OVERLOADED_OPERATOR_IS (fn, EQ_EXPR))\n+    {\n+      tree ne_name = ovl_op_identifier (false, NE_EXPR);\n+      if (DECL_CLASS_SCOPE_P (fn))\n+\t{\n+\t  ne_fns = lookup_fnfields (TREE_TYPE ((*args)[0]), ne_name,\n+\t\t\t\t    1, tf_none);\n+\t  if (ne_fns == error_mark_node || ne_fns == NULL_TREE)\n+\t    ne_fns = NULL_TREE;\n+\t  else\n+\t    ne_fns = BASELINK_FUNCTIONS (ne_fns);\n+\t}\n+      else\n+\t{\n+\t  tree context = decl_namespace_context (fn);\n+\t  ne_fns = lookup_qualified_name (context, ne_name, LOOK_want::NORMAL,\n+\t\t\t\t\t  /*complain*/false);\n+\t  if (ne_fns == error_mark_node\n+\t      || !is_overloaded_fn (ne_fns))\n+\t    ne_fns = NULL_TREE;\n+\t}\n+    }\n+\n   if (first_arg)\n     non_static_args = args;\n   else\n@@ -6345,6 +6372,27 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t    continue;\n \t}\n \n+      /* When considering reversed operator==, if there's a corresponding\n+\t operator!= in the same scope, it's not a rewrite target.  */\n+      if (ne_fns)\n+\t{\n+\t  bool found = false;\n+\t  for (lkp_iterator ne (ne_fns); !found && ne; ++ne)\n+\t    if (0 && !ne.using_p ()\n+\t\t&& DECL_NAMESPACE_SCOPE_P (fn)\n+\t\t&& DECL_CONTEXT (*ne) != DECL_CONTEXT (fn))\n+\t      /* ??? This kludge excludes inline namespace members for the H\n+\t\t test in spaceship-eq15.C, but I don't see why we would want\n+\t\t that behavior.  Asked Core 2022-11-04.  Disabling for now.  */;\n+\t    else if (fns_correspond (fn, *ne))\n+\t      {\n+\t\tfound = true;\n+\t\tbreak;\n+\t      }\n+\t  if (found)\n+\t    continue;\n+\t}\n+\n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t{\n \t  if (!add_template_candidate (candidates,\n@@ -6917,10 +6965,12 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n \t\t  gcc_checking_assert (cand->reversed ());\n \t\t  gcc_fallthrough ();\n \t\tcase NE_EXPR:\n+\t\t  if (result == error_mark_node)\n+\t\t    ;\n \t\t  /* If a rewritten operator== candidate is selected by\n \t\t     overload resolution for an operator @, its return type\n \t\t     shall be cv bool.... */\n-\t\t  if (TREE_CODE (TREE_TYPE (result)) != BOOLEAN_TYPE)\n+\t\t  else if (TREE_CODE (TREE_TYPE (result)) != BOOLEAN_TYPE)\n \t\t    {\n \t\t      if (complain & tf_error)\n \t\t\t{\n@@ -12488,10 +12538,53 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t  if (winner && comp != winner)\n \t    {\n \t      /* Ambiguity between normal and reversed comparison operators\n-\t\t with the same parameter types; prefer the normal one.  */\n-\t      if ((cand1->reversed () != cand2->reversed ())\n+\t\t with the same parameter types.  P2468 decided not to go with\n+\t\t this approach to resolving the ambiguity, so pedwarn.  */\n+\t      if ((complain & tf_warning_or_error)\n+\t\t  && (cand1->reversed () != cand2->reversed ())\n \t\t  && cand_parms_match (cand1, cand2))\n-\t\treturn cand1->reversed () ? -1 : 1;\n+\t\t{\n+\t\t  struct z_candidate *w, *l;\n+\t\t  if (cand2->reversed ())\n+\t\t    winner = 1, w = cand1, l = cand2;\n+\t\t  else\n+\t\t    winner = -1, w = cand2, l = cand1;\n+\t\t  if (warn)\n+\t\t    {\n+\t\t      auto_diagnostic_group d;\n+\t\t      if (pedwarn (input_location, 0,\n+\t\t\t\t   \"C++20 says that these are ambiguous, \"\n+\t\t\t\t   \"even though the second is reversed:\"))\n+\t\t\t{\n+\t\t\t  print_z_candidate (input_location,\n+\t\t\t\t\t     N_(\"candidate 1:\"), w);\n+\t\t\t  print_z_candidate (input_location,\n+\t\t\t\t\t     N_(\"candidate 2:\"), l);\n+\t\t\t  if (w->fn == l->fn\n+\t\t\t      && DECL_NONSTATIC_MEMBER_FUNCTION_P (w->fn)\n+\t\t\t      && (type_memfn_quals (TREE_TYPE (w->fn))\n+\t\t\t\t  & TYPE_QUAL_CONST) == 0)\n+\t\t\t    {\n+\t\t\t      /* Suggest adding const to\n+\t\t\t\t struct A { bool operator==(const A&); }; */\n+\t\t\t      tree parmtype\n+\t\t\t\t= FUNCTION_FIRST_USER_PARMTYPE (w->fn);\n+\t\t\t      parmtype = TREE_VALUE (parmtype);\n+\t\t\t      if (TYPE_REF_P (parmtype)\n+\t\t\t\t  && TYPE_READONLY (TREE_TYPE (parmtype))\n+\t\t\t\t  && (same_type_ignoring_top_level_qualifiers_p\n+\t\t\t\t      (TREE_TYPE (parmtype),\n+\t\t\t\t       DECL_CONTEXT (w->fn))))\n+\t\t\t\tinform (DECL_SOURCE_LOCATION (w->fn),\n+\t\t\t\t\t\"try making the operator a %<const%> \"\n+\t\t\t\t\t\"member function\");\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    add_warning (w, l);\n+\t\t  return winner;\n+\t\t}\n \n \t      winner = 0;\n \t      goto tweak;\n@@ -12880,7 +12973,7 @@ tourney (struct z_candidate *candidates, tsubst_flags_t complain)\n {\n   struct z_candidate *champ = candidates, *challenger;\n   int fate;\n-  int champ_compared_to_predecessor = 0;\n+  struct z_candidate *champ_compared_to_predecessor = nullptr;\n \n   /* Walk through the list once, comparing each current champ to the next\n      candidate, knocking out a candidate or two with each comparison.  */\n@@ -12897,12 +12990,12 @@ tourney (struct z_candidate *candidates, tsubst_flags_t complain)\n \t      champ = challenger->next;\n \t      if (champ == 0)\n \t\treturn NULL;\n-\t      champ_compared_to_predecessor = 0;\n+\t      champ_compared_to_predecessor = nullptr;\n \t    }\n \t  else\n \t    {\n+\t      champ_compared_to_predecessor = champ;\n \t      champ = challenger;\n-\t      champ_compared_to_predecessor = 1;\n \t    }\n \n \t  challenger = champ->next;\n@@ -12914,7 +13007,7 @@ tourney (struct z_candidate *candidates, tsubst_flags_t complain)\n \n   for (challenger = candidates;\n        challenger != champ\n-\t && !(champ_compared_to_predecessor && challenger->next == champ);\n+\t && challenger != champ_compared_to_predecessor;\n        challenger = challenger->next)\n     {\n       fate = joust (champ, challenger, 0, complain);"}, {"sha": "bbc8be21900438369049807e8f86643e562e5845", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -6820,6 +6820,7 @@ extern void note_break_stmt\t\t\t(void);\n extern bool note_iteration_stmt_body_start\t(void);\n extern void note_iteration_stmt_body_end\t(bool);\n extern void determine_local_discriminator\t(tree);\n+extern bool fns_correspond\t\t\t(tree, tree);\n extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree, bool);\n extern bool merge_default_template_args\t\t(tree, tree, bool);"}, {"sha": "890cfcabd35f7339d8fbc0d891873a83e158bdcc", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -980,6 +980,72 @@ function_requirements_equivalent_p (tree newfn, tree oldfn)\n   return cp_tree_equal (reqs1, reqs2);\n }\n \n+/* Two functions of the same name correspond [basic.scope.scope] if\n+\n+   + both declare functions with the same non-object-parameter-type-list,\n+   equivalent ([temp.over.link]) trailing requires-clauses (if any, except as\n+   specified in [temp.friend]), and, if both are non-static members, they have\n+   corresponding object parameters, or\n+\n+   + both declare function templates with equivalent\n+   non-object-parameter-type-lists, return types (if any), template-heads, and\n+   trailing requires-clauses (if any), and, if both are non-static members,\n+   they have corresponding object parameters.\n+\n+   This is a subset of decls_match: it identifies declarations that cannot be\n+   overloaded with one another.  This function does not consider DECL_NAME.  */\n+\n+bool\n+fns_correspond (tree newdecl, tree olddecl)\n+{\n+  if (TREE_CODE (newdecl) != TREE_CODE (olddecl))\n+    return false;\n+\n+  if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n+    {\n+      if (!template_heads_equivalent_p (newdecl, olddecl))\n+\treturn 0;\n+      newdecl = DECL_TEMPLATE_RESULT (newdecl);\n+      olddecl = DECL_TEMPLATE_RESULT (olddecl);\n+    }\n+\n+  tree f1 = TREE_TYPE (newdecl);\n+  tree f2 = TREE_TYPE (olddecl);\n+\n+  int rq1 = type_memfn_rqual (f1);\n+  int rq2 = type_memfn_rqual (f2);\n+\n+  /* If only one is a non-static member function, ignore ref-quals.  */\n+  if (TREE_CODE (f1) != TREE_CODE (f2))\n+    rq1 = rq2;\n+  /* Two non-static member functions have corresponding object parameters if:\n+     + exactly one is an implicit object member function with no ref-qualifier\n+     and the types of their object parameters ([dcl.fct]), after removing\n+     top-level references, are the same, or\n+     + their object parameters have the same type.  */\n+  /* ??? We treat member functions of different classes as corresponding even\n+     though that means the object parameters have different types.  */\n+  else if ((rq1 == REF_QUAL_NONE) != (rq2 == REF_QUAL_NONE))\n+    rq1 = rq2;\n+\n+  bool types_match = rq1 == rq2;\n+\n+  if (types_match)\n+    {\n+      tree p1 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);\n+      tree p2 = FUNCTION_FIRST_USER_PARMTYPE (olddecl);\n+      types_match = compparms (p1, p2);\n+    }\n+\n+  /* Two function declarations match if either has a requires-clause\n+     then both have a requires-clause and their constraints-expressions\n+     are equivalent.  */\n+  if (types_match && flag_concepts)\n+    types_match = function_requirements_equivalent_p (newdecl, olddecl);\n+\n+  return types_match;\n+}\n+\n /* Subroutine of duplicate_decls: return truthvalue of whether\n    or not types of these decls match.\n "}, {"sha": "57917de321f09177c7e1d5ca89085b4e1bdadefd", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -20937,8 +20937,9 @@ tsubst_copy_and_build (tree t,\n \t\t    /* In a lambda fn, we have to be careful to not\n \t\t       introduce new this captures.  Legacy code can't\n \t\t       be using lambdas anyway, so it's ok to be\n-\t\t       stricter.  Be strict with C++20 template-id ADL too.  */\n-\t\t    bool strict = in_lambda || template_id_p;\n+\t\t       stricter.  Be strict with C++20 template-id ADL too.\n+\t\t       And be strict if we're already failing anyway.  */\n+\t\t    bool strict = in_lambda || template_id_p || seen_error();\n \t\t    bool diag = true;\n \t\t    if (strict)\n \t\t      error_at (cp_expr_loc_or_input_loc (t),"}, {"sha": "33de973a1faaead9fb724c0c58e1dc36cc4c0b93", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted3.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -4,7 +4,7 @@\n template<class T>\n struct A {\n   template<class U>\n-  bool operator==(const A<U>&) = delete; // { dg-message \"declared\" }\n+  bool operator==(const A<U>&) const = delete; // { dg-message \"declared\" }\n   operator bool () { return true; }\n };\n "}, {"sha": "6927db3c961e0236e5c859fd6816ede5785fa983", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast7.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -16,7 +16,7 @@ struct J\n struct K\n {\n   long int a, b : 11, c;\n-  constexpr bool operator == (const K &x)\n+  constexpr bool operator == (const K &x) const\n   {\n     return a == x.a && b == x.b && c == x.c;\n   }\n@@ -29,7 +29,7 @@ struct L\n struct M\n {\n   long long int a, b : 11, c;\n-  constexpr bool operator == (const M &x)\n+  constexpr bool operator == (const M &x) const\n   {\n     return a == x.a && b == x.b && c == x.c;\n   }"}, {"sha": "dc509563140e323ce4a6669d0521c6f99aa6ce81", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq15.C", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq15.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -0,0 +1,208 @@\n+// P2468R2 - The Equality Operator You Are Looking For\n+// { dg-do compile { target c++20 } }\n+\n+struct A {\n+  bool operator== (const A &) { return true; }\n+  bool operator!= (const A &) { return false; }\n+};\n+bool a = A{} != A{};\n+\n+template <typename T>\n+struct B {\n+  bool operator== (const T &) const;\n+  bool operator!= (const T &) const;\n+};\n+struct B1 : B<B1> { };\n+bool b1 = B1{} == B1{};\n+bool b2 = B1{} != B1{};\n+\n+template <bool>\n+struct C {\n+  using C1 = C<true>;\n+  using C2 = C<false>;\n+  C () = default;\n+  C (const C2 &);\n+  bool operator== (C1) const;\n+  bool operator!= (C1) const;\n+};\n+using C3 = C<false>;\n+bool c = C3{} == C3{};\n+\n+struct D {\n+  D ();\n+  D (int *);\n+  bool operator== (const D &) const;\t// { dg-message \"candidate: 'bool D::operator==\\\\\\(const D&\\\\\\) const' \\\\\\(reversed\\\\\\)\" }\n+  operator int * () const;\n+};\n+bool d = nullptr != D{};\t// { dg-error \"ambiguous overload for 'operator!=' in 'nullptr != D\\\\\\(\\\\\\)' \\\\\\(operand types are 'std::nullptr_t' and 'D'\\\\\\)\" }\n+\t\t\t\t// { dg-message \"candidate: 'operator!=\\\\\\(int\\\\\\*, int\\\\\\*\\\\\\)' \\\\\\(built-in\\\\\\)\" \"\" { target *-*-* } .-1 }\n+\n+using ubool = unsigned char;\n+\n+struct E {\n+  operator bool () const;\n+};\n+unsigned char operator== (E, E);// { dg-message \"candidate: 'unsigned char operator==\\\\\\(E, E\\\\\\)'\" }\n+\t\t\t\t// { dg-message \"no known conversion for argument 1 from 'int' to 'E'\" \"\" { target *-*-* } .-1 }\n+unsigned char e = E{} != E{};\t// { dg-error \"return type of 'unsigned char operator==\\\\\\(E, E\\\\\\)' is not 'bool'\" }\n+\t\t\t\t// { dg-message \"used as rewritten candidate for comparison of 'E' and 'E'\" \"\" { target *-*-* } .-1 }\n+\n+// F-H are the testcase from [over.match.oper]\n+struct F {};\n+template <typename T>\n+bool operator== (F, T);\t\t// { dg-message \"candidate: 'template<class T> bool operator==\\\\\\(F, T\\\\\\)'\" }\n+\t\t\t\t// { dg-message \"template argument deduction/substitution failed:\" \"\" { target *-*-* } .-1 }\n+bool f1 = 0 == F ();\t\t// OK, calls reversed ==\n+template <typename T>\n+bool operator!= (F, T);\n+bool f2 = 0 == F ();\t\t// { dg-error \"no match for 'operator==' in '0 == F\\\\\\(\\\\\\)' \\\\\\(operand types are 'int' and 'F'\\\\\\)\" }\n+\t\t\t\t// { dg-message \"cannot convert '0' \\\\\\(type 'int'\\\\\\) to type 'F'\" \"\" { target *-*-* } .-1 }\n+\n+struct G {\n+  bool operator== (const G &);\n+};\n+struct G1 : G {\n+  G1 ();\n+  G1 (G);\n+  bool operator!= (const G &);\n+};\n+bool g1 = G () == G1 ();\t// OK, != prevents rewrite\n+bool g2 = G1 () == G ();\t// { dg-error \"ambiguous, even though the second is reversed\" }\n+\n+struct H {};\n+template <typename T>\n+bool operator== (H, T);\n+inline namespace H1 {\n+  template <typename T>\n+  bool operator!= (H, T);\n+}\n+// [over.match.oper] currently says that this is OK because the inline\n+// namespace isn't searched, but that seems wrong to me, so I'm going to go\n+// ahead and search it for now.  Remove the \"0 &&\" in add_candidates to\n+// change this to the currently specified behavior.\n+// { dg-error \"no match\" \"\" { target *-*-* } .+1 }\n+bool h = 0 == H ();\t\t// OK, calls reversed ==\n+\n+template <class T>\n+struct I {\n+  int operator== (const double &) const;\n+  friend inline int operator== (const double &, const T &) { return 1; }\n+};\n+struct I1 : I<I1> { };\n+bool i = I1{} == 0.;\t\t// { dg-error \"return type of 'int operator==\\\\\\(const double&, const I1&\\\\\\)' is not 'bool'\" }\n+\t\t\t\t// { dg-message \"used as rewritten candidate for comparison of 'I1' and 'double'\" \"\" { target *-*-* } .-1 }\n+\n+struct J {\n+  bool operator== (const J &) const;\n+  bool operator!= (const J &) const;\n+};\n+struct J1 : J {\n+  J1 (const J &);\n+  bool operator== (const J1 &x) const {\n+    return static_cast<const J &> (*this) == x;\t// { dg-error \"ambiguous overload for 'operator==' in '\\\\\\*\\\\\\(const J\\\\\\*\\\\\\)\\\\\\(\\\\\\(const J1\\\\\\*\\\\\\)this\\\\\\) == x' \\\\\\(operand types are 'const J' and 'const J1'\\\\\\)\" }\n+  }\n+};\n+\n+struct K {\n+  bool operator== (const K &);\n+};\n+bool k = K{} == K{};\t\t// { dg-error \"ambiguous, even though the second is reversed\" }\n+\n+struct L {\n+  bool operator== (const L &) const;\n+};\n+bool l = L{} == L{};\n+\n+struct M {\n+  bool operator== (M);\n+};\n+bool m = M () == M ();\n+\n+struct N {\n+  virtual bool operator== (const N &) const;\n+};\n+struct N1 : N {\n+  bool operator== (const N &) const override;\n+};\n+bool n = N1 () == N1 ();\t// { dg-error \"ambiguous, even though the second is reversed\" }\n+\n+struct O {\n+  virtual signed char operator== (const O &) const;\n+  signed char operator!= (const O &x) const { return !operator== (x); }\n+};\n+struct O1 : O {\n+  signed char operator== (const O &) const override;\n+};\n+bool o = O1 () != O1 ();\n+\n+template <class T>\n+bool\n+foo (T x, T y)\n+requires requires { x == y; }\n+{\n+  return x == y;\n+}\n+bool b3 = foo (B1 (), B1 ());\n+\n+struct P {};\n+template <typename T, class U = int>\n+bool operator== (P, T);\n+template <class T>\n+bool operator!= (P, T);\n+bool p = 0 == P ();\n+\n+struct Q {};\n+template <typename T>\n+bool operator== (Q, T);\n+template <typename U>\n+bool operator!= (Q, U);\n+bool q = 0 == Q ();\t\t// { dg-error \"\" }\n+\n+struct R {\n+  template <typename T>\n+  bool operator== (const T &);\n+};\n+bool r = R () == R ();\t\t// { dg-error \"ambiguous, even though the second is reversed\" }\n+\n+struct S {\n+  template <typename T>\n+  bool operator== (const T &) const;\n+  bool operator!= (const S &);\n+};\n+bool s = S () == S ();\n+\n+struct T {};\n+template <class U = int>\n+bool operator== (T, int);\n+bool operator!= (T, int);\n+bool t = 0 == T ();\n+\n+struct U {};\n+bool operator== (U, int);\n+bool u1 = 0 == U ();\n+namespace U1 { bool operator!= (U, int); }\n+bool u2 = 0 == U ();\n+using U1::operator!=;\n+bool u3 = 0 == U ();\t\t// { dg-error \"\" }\n+\n+struct V {};\n+template <typename T>\n+bool operator== (V, T);\n+bool v1 = 0 == V ();\n+namespace V1 { template <typename T> bool operator!= (V, T); }\n+bool v2 = 0 == V ();\n+using V1::operator!=;\n+bool v3 = 0 == V ();\t\t// { dg-error \"\" }\n+\n+template <int N>\n+struct W {\n+bool operator== (int) requires (N == 1);\n+bool operator!= (int) requires (N == 2);\n+};\n+int w = 0 == W<1> ();\n+\n+struct X {\n+  bool operator== (X const &);\n+  static bool operator!= (X const &, X const &);\t// { dg-error \"'static bool X::operator!=\\\\\\(const X&, const X&\\\\\\)' must be either a non-static member function or a non-member function\" }\n+};\n+bool x = X () == X ();\t\t// { dg-error \"ambiguous, even though the second is reversed\" }"}, {"sha": "ebe81e4b5e92b71af3724294c18bd7e557b28663", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-rewrite1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -11,5 +11,5 @@ int main()\n {\n   A<int> a1;\n   A<void> a2;\n-  return a1 == a2;\n+  return a1 == a2; // { dg-error \"ambiguous, even though the second is reversed\" }\n }"}, {"sha": "460f6332938fe26c2d630fe1b2e05e2798b7b601", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-rewrite5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite5.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -12,4 +12,4 @@ struct A {\n \n A<const int> a;\n A<int> b;\n-auto c = (a == b);\n+auto c = (a == b); // { dg-error \"ambiguous, even though the second is reversed\" \"\" { target c++20 } }"}, {"sha": "0575109ed1ae9b922b489a07acb803c10535754c", "filename": "gcc/testsuite/g++.old-deja/g++.jason/byval2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fbyval2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fbyval2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fbyval2.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -18,6 +18,6 @@ inline  char  operator == (const Char    a, const char b) { return 0; }\n \n char mystrcmp(Char s[31], Char t[31])\n {\n-  for (; *s == *t; ++s, ++t) if (*s == '\\0') return 0;\n+  for (; *s == *t; ++s, ++t) if (*s == '\\0') return 0; // { dg-error \"reversed\" \"\" { target c++20 } }\n   return char(*s - *t);\n }"}, {"sha": "f59bd4a49c3078d86acee7959ff354846c3ee9f1", "filename": "gcc/testsuite/g++.old-deja/g++.other/overload13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverload13.C?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -2,7 +2,7 @@\n // Origin: Nathan Sidwell <nathan@codesourcery.com>\n \n struct A {\n-  bool operator== (A const &);\n+  bool operator== (A const &) const;\n   operator bool () const;\n   operator int * () const;\n };"}, {"sha": "8bf78faf232039bff3c1feef4b965439bc074818", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/fallback.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/431be04b8b6e31d950ddab340ed866d197d23d4d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/431be04b8b6e31d950ddab340ed866d197d23d4d/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Ffallback.cc?ref=431be04b8b6e31d950ddab340ed866d197d23d4d", "patch": "@@ -31,12 +31,12 @@ template<typename T, typename U>\n \n using adl::S;\n \n-static_assert( has_strong_order_fallback<S, S> );\n+static_assert( ! has_strong_order_fallback<S, S> );\n static_assert( has_strong_order_fallback<const S, S> );\n static_assert( ! has_strong_order_fallback<const S, const S> );\n-static_assert( has_weak_order_fallback<S, S> );\n+static_assert( ! has_weak_order_fallback<S, S> );\n static_assert( has_weak_order_fallback<const S, S> );\n static_assert( ! has_weak_order_fallback<const S, const S> );\n-static_assert( has_partial_order_fallback<S, S> );\n+static_assert( ! has_partial_order_fallback<S, S> );\n static_assert( ! has_partial_order_fallback<const S, S> ); // LWG 3465\n static_assert( ! has_partial_order_fallback<const S, const S> );"}]}