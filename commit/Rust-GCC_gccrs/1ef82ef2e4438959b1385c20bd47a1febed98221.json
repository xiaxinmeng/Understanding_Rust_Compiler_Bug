{"sha": "1ef82ef2e4438959b1385c20bd47a1febed98221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmODJlZjJlNDQzODk1OWIxMzg1YzIwYmQ0N2ExZmViZWQ5ODIyMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-21T10:32:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-21T10:32:10Z"}, "message": "c-decl.c (merge_decls): Kill different_binding_level and different_tu arguments; simplify throughout.\n\n\t* c-decl.c (merge_decls): Kill different_binding_level and\n\tdifferent_tu arguments; simplify throughout.\n\t(duplicate_decls): Likewise.\n\t(pushdecl, merge_translation_unit_decls): Update calls to\n\tduplicate_decls.\ntestsuite:\n\t* gcc.dg/noncompile/20020213-1.c: Add another dg-warning line.\n\nFrom-SVN: r76269", "tree": {"sha": "5dcc4672245adad8ce68a9fc6f713d87bd453475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dcc4672245adad8ce68a9fc6f713d87bd453475"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef82ef2e4438959b1385c20bd47a1febed98221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef82ef2e4438959b1385c20bd47a1febed98221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef82ef2e4438959b1385c20bd47a1febed98221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef82ef2e4438959b1385c20bd47a1febed98221/comments", "author": null, "committer": null, "parents": [{"sha": "4543ee4782fb327781cf1f42f07f60352e9e96c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4543ee4782fb327781cf1f42f07f60352e9e96c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4543ee4782fb327781cf1f42f07f60352e9e96c8"}], "stats": {"total": 164, "additions": 59, "deletions": 105}, "files": [{"sha": "79e5924370286043e9e42e3406cd99c566b8e52d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ef82ef2e4438959b1385c20bd47a1febed98221", "patch": "@@ -1,3 +1,11 @@\n+2004-01-21  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (merge_decls): Kill different_binding_level and\n+\tdifferent_tu arguments; simplify throughout.\n+\t(duplicate_decls): Likewise.\n+\t(pushdecl, merge_translation_unit_decls): Update calls to\n+\tduplicate_decls.\n+\n 2004-01-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (pretty-print.o): Depend on $(CONFIG_H) and\n@@ -133,7 +141,7 @@\n \n 2004-01-20  Hartmut Penner  <hpenner@de.ibm.com>\n \n-\t* gcc/config/rs6000/rs6000.c (function_arg) Handle \n+\t* gcc/config/rs6000/rs6000.c (function_arg) Handle\n \tvector register special in function without prototype.\n \t(function_arg_advance): Vector parameters get always\n \tGPRs allocated for the linux64 target.\n@@ -189,9 +197,9 @@\n \n 2004-01-20  Kelley Cook  <kcook@gcc.gnu.org>\n \n-\t* Makefile.in (target_noncanonical, program_transform_name): Use \n+\t* Makefile.in (target_noncanonical, program_transform_name): Use\n \timmediate define instead of deferred.\n-\t(GCC_INSTALL_NAME, GCC_TARGET_INSTALL_NAME, CPP_INSTALL_NAME, \n+\t(GCC_INSTALL_NAME, GCC_TARGET_INSTALL_NAME, CPP_INSTALL_NAME,\n \tPROTOIZE_INSTALL_NAME, UNPROTOIZE_INSTALL_NAME, GCOV_INSTALL_NAME,\n \tGCCBUG_INSTALL_NAME): Define via a immediate $(shell) instead of\n \tdeferred backquote.\n@@ -227,23 +235,23 @@\n \n 2004-01-19  Richard Henderson  <rth@redhat.com>\n \n-        * config/alpha/alpha.c (aligned_memory_operand): Check MEM_ALIGN,\n-        don't check memory mode.\n-        (unaligned_memory_operand): Likewise.\n-        (reload_inqi, reload_inhi, reload_outqi, reload_outhi): Don't\n-        abort for op0 not MEM.\n+\t* config/alpha/alpha.c (aligned_memory_operand): Check MEM_ALIGN,\n+\tdon't check memory mode.\n+\t(unaligned_memory_operand): Likewise.\n+\t(reload_inqi, reload_inhi, reload_outqi, reload_outhi): Don't\n+\tabort for op0 not MEM.\n \n-        * config/alpha/alpha.c (alpha_expand_mov_nobwx): If the destination\n-        is not a reg, copy to a scratch first.\n-        (aligned_loadqi, aligned_loadhi, unaligned_loadqi, unaligned_loadhi,\n-        unaligned_loadqi_le, unaligned_loadqi_be, unaligned_loadhi_le,\n-        unaligned_loadhi_be): Expect op0 in DImode; don't SUBREG.\n-        (reload_inqi, reload_inhi): Fix mode of op0.\n-        (reload_inqi_help, reload_inhi_help, reload_outqi_help,\n-        reload_outhi_help): Likewise.  Use define_insn_and_split.\n+\t* config/alpha/alpha.c (alpha_expand_mov_nobwx): If the destination\n+\tis not a reg, copy to a scratch first.\n+\t(aligned_loadqi, aligned_loadhi, unaligned_loadqi, unaligned_loadhi,\n+\tunaligned_loadqi_le, unaligned_loadqi_be, unaligned_loadhi_le,\n+\tunaligned_loadhi_be): Expect op0 in DImode; don't SUBREG.\n+\t(reload_inqi, reload_inhi): Fix mode of op0.\n+\t(reload_inqi_help, reload_inhi_help, reload_outqi_help,\n+\treload_outhi_help): Likewise.  Use define_insn_and_split.\n \n-        * config/alpha/alpha.md (call peepholes): Check for REG_NORETURN\n-        as well as $29 dead.\n+\t* config/alpha/alpha.md (call peepholes): Check for REG_NORETURN\n+\tas well as $29 dead.\n \n 2004-01-19  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n@@ -260,7 +268,7 @@\n \n \t* contrib.texi: Update Paolo Carlini's entry.  New entries for\n \tJerry Quinn and Petur Runolfsson.\n- \n+\n 2004-01-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md (*movhi_1, *movqi_1): When optimizing for\n@@ -425,7 +433,7 @@\n 2004-01-17  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc/objc-act.c (build_objc_method_call): Use target\n-\thooks instead of macros to determine if ..._stret \n+\thooks instead of macros to determine if ..._stret\n \tdispatchers should be used (NeXT runtime only).\n \n 2004-01-17  Roger Sayle  <roger@eyesopen.com>"}, {"sha": "9316c62cb3263878915d2f7060241a316b792a12", "filename": "gcc/c-decl.c", "status": "modified", "additions": 24, "deletions": 83, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1ef82ef2e4438959b1385c20bd47a1febed98221", "patch": "@@ -1252,23 +1252,15 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \n /* Subroutine of duplicate_decls.  NEWDECL has been found to be\n    consistent with OLDDECL, but carries new information.  Merge the\n-   new information into OLDDECL.  If DIFFERENT_BINDING_LEVEL or\n-   DIFFERENT_TU is true, avoid completely merging the decls, as this\n-   will break assumptions elsewhere.  This function issues no\n+   new information into OLDDECL.  This function issues no\n    diagnostics.  */\n \n static void\n-merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n-\t     bool different_binding_level, bool different_tu)\n+merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n {\n   int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t   && DECL_INITIAL (newdecl) != 0);\n \n-  /* When copying info to olddecl, we store into write_olddecl\n-     instead.  This allows us to avoid modifying olddecl when\n-     different_binding_level is true.  */\n-  tree write_olddecl = different_binding_level ? newdecl : olddecl;\n-\n   /* For real parm decl following a forward decl, return 1 so old decl\n      will be reused.  Only allow this to happen once.  */\n   if (TREE_CODE (newdecl) == PARM_DECL\n@@ -1282,25 +1274,9 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n     = (*targetm.merge_decl_attributes) (olddecl, newdecl);\n \n   /* Merge the data types specified in the two decls.  */\n-  if (TREE_CODE (newdecl) != FUNCTION_DECL || !DECL_BUILT_IN (olddecl))\n-    {\n-      if (different_binding_level)\n-\t{\n-\t  if (TYPE_ARG_TYPES (oldtype) != 0\n-\t      && TYPE_ARG_TYPES (newtype) == 0)\n-\t    TREE_TYPE (newdecl) = common_type (newtype, oldtype);\n-\t  else\n-\t    TREE_TYPE (newdecl)\n-\t      = build_type_attribute_variant\n-\t      (newtype,\n-\t       merge_attributes (TYPE_ATTRIBUTES (newtype),\n-\t\t\t\t TYPE_ATTRIBUTES (oldtype)));\n-\t}\n-      else\n-\tTREE_TYPE (newdecl)\n-\t  = TREE_TYPE (olddecl)\n-\t  = common_type (newtype, oldtype);\n-    }\n+  TREE_TYPE (newdecl)\n+    = TREE_TYPE (olddecl)\n+    = common_type (newtype, oldtype);\n \n   /* Lay the type out, unless already done.  */\n   if (oldtype != TREE_TYPE (newdecl))\n@@ -1331,33 +1307,27 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n \n   /* Merge the type qualifiers.  */\n   if (TREE_READONLY (newdecl))\n-    TREE_READONLY (write_olddecl) = 1;\n+    TREE_READONLY (olddecl) = 1;\n \n   if (TREE_THIS_VOLATILE (newdecl))\n     {\n-      TREE_THIS_VOLATILE (write_olddecl) = 1;\n+      TREE_THIS_VOLATILE (olddecl) = 1;\n       if (TREE_CODE (newdecl) == VAR_DECL)\n \tmake_var_volatile (newdecl);\n     }\n \n   /* Keep source location of definition rather than declaration.  */\n-  /* When called with different_binding_level set, keep the old\n-     information so that meaningful diagnostics can be given.  */\n-  if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0\n-      && ! different_binding_level)\n+  if (DECL_INITIAL (newdecl) == 0 && DECL_INITIAL (olddecl) != 0)\n     DECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);\n \n   /* Merge the unused-warning information.  */\n   if (DECL_IN_SYSTEM_HEADER (olddecl))\n     DECL_IN_SYSTEM_HEADER (newdecl) = 1;\n   else if (DECL_IN_SYSTEM_HEADER (newdecl))\n-    DECL_IN_SYSTEM_HEADER (write_olddecl) = 1;\n+    DECL_IN_SYSTEM_HEADER (olddecl) = 1;\n \n   /* Merge the initialization information.  */\n-  /* When called with different_binding_level set, don't copy over\n-     DECL_INITIAL, so that we don't accidentally change function\n-     declarations into function definitions.  */\n-  if (DECL_INITIAL (newdecl) == 0 && ! different_binding_level)\n+   if (DECL_INITIAL (newdecl) == 0)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n   /* Merge the section attribute.\n@@ -1397,33 +1367,22 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n       TREE_PUBLIC (newdecl) &= TREE_PUBLIC (olddecl);\n       /* This is since we don't automatically\n \t copy the attributes of NEWDECL into OLDDECL.  */\n-      /* No need to worry about different_binding_level here because\n-\t then TREE_PUBLIC (newdecl) was true.  */\n       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n       /* If this clears `static', clear it in the identifier too.  */\n       if (! TREE_PUBLIC (olddecl))\n \tTREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n     }\n   if (DECL_EXTERNAL (newdecl))\n     {\n-      if (! different_binding_level || different_tu)\n-\t{\n-\t  /* Don't mess with these flags on local externs; they remain\n-\t     external even if there's a declaration at file scope which\n-\t     isn't.  */\n-\t  TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n-\t  DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n-\t}\n+      TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n+      DECL_EXTERNAL (newdecl) = DECL_EXTERNAL (olddecl);\n+\n       /* An extern decl does not override previous storage class.  */\n       TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n       if (! DECL_EXTERNAL (newdecl))\n \t{\n \t  DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n \t  DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n-\t  /* If we have two non-EXTERNAL file-scope decls that are\n-\t     the same, only one of them should be written out.  */\n-\t  if (different_tu)\n-\t    TREE_ASM_WRITTEN (newdecl) = 1;\n \t}\n     }\n   else\n@@ -1469,11 +1428,8 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n \t     definition.  */\n \t  if (new_is_definition)\n \t    {\n-\t      if (! different_binding_level)\n-\t\t{\n-\t\t  TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n-\t\t  DECL_BUILT_IN_CLASS (olddecl) = NOT_BUILT_IN;\n-\t\t}\n+\t      TREE_TYPE (olddecl) = TREE_TYPE (newdecl);\n+\t      DECL_BUILT_IN_CLASS (olddecl) = NOT_BUILT_IN;\n \t    }\n \t  else\n \t    {\n@@ -1488,11 +1444,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n       if (! new_is_definition)\n \t{\n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n-\t  /* When called with different_binding_level set, don't copy over\n-\t     DECL_INITIAL, so that we don't accidentally change function\n-\t     declarations into function definitions.  */\n-\t  if (! different_binding_level)\n-\t    DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n+\t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);\n \t  DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n \t  DECL_ESTIMATED_INSNS (newdecl) = DECL_ESTIMATED_INSNS (olddecl);\n@@ -1504,9 +1456,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n \t    {\n \t      DECL_INLINE (newdecl) = 1;\n \t      DECL_ABSTRACT_ORIGIN (newdecl)\n-\t\t= (different_binding_level\n-\t\t   ? DECL_ORIGIN (olddecl)\n-\t\t   : DECL_ABSTRACT_ORIGIN (olddecl));\n+\t\t= DECL_ABSTRACT_ORIGIN (olddecl);\n \t    }\n \t}\n       else\n@@ -1518,8 +1468,6 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n \t    DECL_INLINE (newdecl) = 1;\n \t}\n     }\n-  if (different_binding_level)\n-    return;\n \n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID.  */\n@@ -1547,24 +1495,18 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype,\n    if appropriate.\n \n    If safely possible, alter OLDDECL to look like NEWDECL, and return\n-   true.  Otherwise, return false.\n-\n-   When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external\n-   declaration, and OLDDECL is in an outer scope and should thus not\n-   be changed.  */\n+   true.  Otherwise, return false.  */\n \n static bool\n-duplicate_decls (tree newdecl, tree olddecl,\n-\t\t bool different_binding_level, bool different_tu)\n+duplicate_decls (tree newdecl, tree olddecl)\n {\n   tree newtype, oldtype;\n \n   if (!diagnose_mismatched_decls (newdecl, olddecl, &newtype, &oldtype))\n     return false;\n \n-  merge_decls (newdecl, olddecl, newtype, oldtype,\n-\t       different_binding_level, different_tu);\n-  return !different_binding_level;\n+  merge_decls (newdecl, olddecl, newtype, oldtype);\n+  return true;\n }\n   \n \f\n@@ -1745,7 +1687,7 @@ pushdecl (tree x)\n \t\t IDENTIFIER_POINTER (name));\n \n       old = lookup_name_current_level (name);\n-      if (old && duplicate_decls (x, old, 0, false))\n+      if (old && duplicate_decls (x, old))\n \t{\n \t  /* For PARM_DECLs, old may be a forward declaration.\n \t     If so, we want to remove it from its old location\n@@ -1773,8 +1715,7 @@ pushdecl (tree x)\n  \t  tree ext = any_external_decl (name);\n \t  if (ext)\n \t    {\n-\t      if (duplicate_decls (x, ext, scope != global_scope,\n-\t\t\t\t   false))\n+\t      if (duplicate_decls (x, ext))\n \t\tx = copy_node (ext);\n \t    }\n \t  else\n@@ -6606,7 +6547,7 @@ merge_translation_unit_decls (void)\n \n \t  /* Print any appropriate error messages, and partially merge\n \t     the decls.  */\n-\t  (void) duplicate_decls (decl, global_decl, true, true);\n+\t  (void) duplicate_decls (decl, global_decl);\n \t}\n \n   htab_delete (link_hash_table);"}, {"sha": "9b022b87dcf224cf26d4d0c9ea034ce93aa96654", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ef82ef2e4438959b1385c20bd47a1febed98221", "patch": "@@ -1,11 +1,15 @@\n+2004-01-21  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/noncompile/20020213-1.c: Add another dg-warning line.\n+\n 2004-01-20  Hartmut Penner  <hpenner@de.ibm.com>\n \n \t* gcc.dg/ppc64-abi-2.c: New test.\n \n 2004-01-18  James A. Morrison  <ja2morri@uwaterloo.ca>\n \n-        * lib/treelang.exp: Fill out this file.\n-        * lib/treelang-dg.exp: New File.\n+\t* lib/treelang.exp: Fill out this file.\n+\t* lib/treelang-dg.exp: New File.\n \n 2004-01-20  Joseph S. Myers  <jsm@polyomino.org.uk>\n "}, {"sha": "77798b57c4b2e1f8063f5dc324cf55d31918acd7", "filename": "gcc/testsuite/gcc.dg/noncompile/20020213-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef82ef2e4438959b1385c20bd47a1febed98221/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2F20020213-1.c?ref=1ef82ef2e4438959b1385c20bd47a1febed98221", "patch": "@@ -24,6 +24,7 @@ int main ()\n   return 0;\n }\n \n+/* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 15 } */\n /* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 16 } */\n /* { dg-warning \"passing arg 2 of\" \"2nd incompatible\" { target *-*-* } 16 } */\n /* { dg-warning \"passing arg 1 of\" \"1st incompatible\" { target *-*-* } 18 } */"}]}