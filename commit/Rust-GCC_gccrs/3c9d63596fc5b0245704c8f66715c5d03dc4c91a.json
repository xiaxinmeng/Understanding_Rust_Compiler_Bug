{"sha": "3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5ZDYzNTk2ZmM1YjAyNDU3MDRjOGY2NjcxNWM1ZDAzZGM0YzkxYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-22T21:43:45Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-22T21:43:45Z"}, "message": "cp-tree.h (BINFO_FOR_VBASE): Adjust documentation.\n\n\t* cp-tree.h (BINFO_FOR_VBASE): Adjust documentation.\n\t(CANONICAL_BINFO): New macro.\n\t(BINFO_NEW_VTABLE_MARKED): Use it.\n\t(SET_BINFO_NEW_VTABLE_MARKED): Likewise.\n\t(CLEAR_BINFO_NEW_VTABLE_MARKED): Likewise.\n\t* class.c (dfs_build_vbase_offset_vtbl_entries): Use BINFO_TYPE,\n\tnot TREE_TYPE.\n\t(build_primary_vtable): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n\t(build_secondary_vtable): Likewise.\n\t(dfs_finish_vtbls): Likewise.\n\t(dfs_accumulate_vtbl_inits): Likewise.\n\t(accumulate_vtbl_inits): New function.\n\t(finish_vtbls): Make sure that virtual bases come after\n\tnon-virtual bases in the vtable group.\n\t(record_base_offsets): Don't save and restore TREE_VIA_VIRTUAL.\n\t(finish_struct_1): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n\t* search.c (struct vbase_info): Move definition.\n\t(marked_new_vtable_p): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n\t(unmarked_new_vtable_p): Likewise.\n\t(dfs_mark_vtable_path): Remove.\n\t(dfs_mark_new_vtable): Remove.\n\t(dfs_unmark_new_vtable): Likewise.\n\t(dfs_clear_search_slot): Likewise.\n\t(dfs_find_vbases):  Adjust usage of BINFO_NEW_VTABLE_MARKED.\n\t(dfs_clear_vbase_slots): Likewise.\n\t(init_vbase_pointers): LIkewise.\n\nFrom-SVN: r32689", "tree": {"sha": "6d0f3bdb88c1291bb8d71766a4c9bdec7640952d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d0f3bdb88c1291bb8d71766a4c9bdec7640952d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/comments", "author": null, "committer": null, "parents": [{"sha": "26356fee5ba5a558889329f911024af9e77351ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26356fee5ba5a558889329f911024af9e77351ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26356fee5ba5a558889329f911024af9e77351ec"}], "stats": {"total": 285, "additions": 209, "deletions": 76}, "files": [{"sha": "33d688ffb716633f9fc5b6df4c425cc975835877", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "patch": "@@ -1,3 +1,32 @@\n+2000-03-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (BINFO_FOR_VBASE): Adjust documentation.\n+\t(CANONICAL_BINFO): New macro.\n+\t(BINFO_NEW_VTABLE_MARKED): Use it.\n+\t(SET_BINFO_NEW_VTABLE_MARKED): Likewise.\n+\t(CLEAR_BINFO_NEW_VTABLE_MARKED): Likewise.\n+\t* class.c (dfs_build_vbase_offset_vtbl_entries): Use BINFO_TYPE,\n+\tnot TREE_TYPE.\n+\t(build_primary_vtable): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n+\t(build_secondary_vtable): Likewise.\n+\t(dfs_finish_vtbls): Likewise.\n+\t(dfs_accumulate_vtbl_inits): Likewise.\n+\t(accumulate_vtbl_inits): New function.\n+\t(finish_vtbls): Make sure that virtual bases come after\n+\tnon-virtual bases in the vtable group.\n+\t(record_base_offsets): Don't save and restore TREE_VIA_VIRTUAL.\n+\t(finish_struct_1): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n+\t* search.c (struct vbase_info): Move definition.\n+\t(marked_new_vtable_p): Adjust usage of BINFO_NEW_VTABLE_MARKED.\n+\t(unmarked_new_vtable_p): Likewise.\n+\t(dfs_mark_vtable_path): Remove.\n+\t(dfs_mark_new_vtable): Remove.\n+\t(dfs_unmark_new_vtable): Likewise.\n+\t(dfs_clear_search_slot): Likewise.\n+\t(dfs_find_vbases):  Adjust usage of BINFO_NEW_VTABLE_MARKED.\n+\t(dfs_clear_vbase_slots): Likewise.\n+\t(init_vbase_pointers): LIkewise.\n+\t\n 2000-03-22  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* typeck.c (type_after_usual_arithmetic_conversions): Prefer a"}, {"sha": "216d7e3cfea69b27416791d3248ee775fcb88057", "filename": "gcc/cp/class.c", "status": "modified", "additions": 54, "deletions": 37, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "patch": "@@ -161,6 +161,7 @@ static tree dfs_search_base_offsets PARAMS ((tree, void *));\n static int layout_conflict_p PARAMS ((tree, varray_type));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, varray_type));\n+static void accumulate_vtbl_inits PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -276,7 +277,7 @@ dfs_build_vbase_offset_vtbl_entries (binfo, data)\n \n       /* Remember the index to the vbase offset for this virtual\n \t base.  */\n-      vbase = BINFO_FOR_VBASE (TREE_TYPE (binfo), TREE_PURPOSE (list));\n+      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n       if (!TREE_VALUE (list))\n \tBINFO_VPTR_FIELD (vbase) = build_int_2 (-1, 0);\n       else\n@@ -1072,7 +1073,7 @@ build_primary_vtable (binfo, type)\n     {\n       tree offset;\n \n-      if (BINFO_NEW_VTABLE_MARKED (binfo))\n+      if (BINFO_NEW_VTABLE_MARKED (binfo, type))\n \t/* We have already created a vtable for this base, so there's\n \t   no need to do it again.  */\n \treturn 0;\n@@ -1106,7 +1107,7 @@ build_primary_vtable (binfo, type)\n   TYPE_BINFO_VIRTUALS (type) = virtuals;\n \n   binfo = TYPE_BINFO (type);\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo, type);\n   return 1;\n }\n \n@@ -1147,14 +1148,14 @@ build_secondary_vtable (binfo, for_type)\n \t\t\t\t\t\t  current_class_type),\n \t\t\t170);\n \n-  if (BINFO_NEW_VTABLE_MARKED (binfo))\n+  if (BINFO_NEW_VTABLE_MARKED (binfo, current_class_type))\n     /* We already created a vtable for this base.  There's no need to\n        do it again.  */\n     return 0;\n \n   /* Remember that we've created a vtable for this BINFO, so that we\n      don't try to do so again.  */\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo, current_class_type);\n   \n   /* Make fresh virtual list, so we can smash it later.  */\n   BINFO_VIRTUALS (binfo) = copy_list (BINFO_VIRTUALS (binfo));\n@@ -2760,13 +2761,15 @@ dfs_finish_vtbls (binfo, data)\n      tree binfo;\n      void *data;\n {\n+  tree t = (tree) data;\n+\n   if (!BINFO_PRIMARY_MARKED_P (binfo)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo))\n+      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n     initialize_vtable (binfo, \n-\t\t       build_vtbl_initializer (binfo, (tree) data));\n+\t\t       build_vtbl_initializer (binfo, t));\n \n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n   SET_BINFO_MARKED (binfo);\n \n   return NULL_TREE;\n@@ -2781,15 +2784,16 @@ dfs_accumulate_vtbl_inits (binfo, data)\n      tree binfo;\n      void *data;\n {\n+  tree l;\n+  tree t;\n+\n+  l = (tree) data;\n+  t = TREE_PURPOSE (l);\n+\n   if (!BINFO_PRIMARY_MARKED_P (binfo)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo))\n+      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n     {\n-      tree l;\n-      tree t;\n-\n-      l = (tree) data;\n-      t = TREE_PURPOSE (l);\n \n       /* If this is a secondary vtable, record its location.  */\n       if (binfo != TYPE_BINFO (t))\n@@ -2807,19 +2811,34 @@ dfs_accumulate_vtbl_inits (binfo, data)\n \t\t\t\t size_int (list_length (TREE_VALUE (l)))));\n \t}\n \n-      /* Add the initializers for this vtable to the initailizers for\n+      /* Add the initializers for this vtable to the initializers for\n \t the other vtables we've already got.  */\n       TREE_VALUE (l) \n \t= chainon (TREE_VALUE (l),\n \t\t   build_vtbl_initializer (binfo, t));\n     }\n \n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n-  SET_BINFO_MARKED (binfo);\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n \n   return NULL_TREE;\n }\n \n+/* Add the vtbl initializers for BINFO (and its non-primary,\n+   non-virtual bases) to the list of INITS.  */\n+\n+static void\n+accumulate_vtbl_inits (binfo, inits)\n+     tree binfo;\n+     tree inits;\n+{\n+  /* Walk the BINFO and its bases.  */\n+  dfs_walk_real (binfo,\n+\t\t dfs_accumulate_vtbl_inits,\n+\t\t NULL, \n+\t\t dfs_skip_vbases,\n+\t\t inits);\n+}\n+\n /* Create all the necessary vtables for T and its base classes.  */\n \n static void\n@@ -2829,26 +2848,31 @@ finish_vtbls (t)\n   if (merge_primary_and_secondary_vtables_p ())\n     {\n       tree list;\n+      tree vbase;\n \n       /* Under the new ABI, we lay out the primary and secondary\n \t vtables in one contiguous vtable.  The primary vtable is\n-\t first, followed by the secondary vtables as encountered in a\n-\t pre-order depth-first left-to-right traversal.  */\n+\t first, followed by the non-virtual secondary vtables in\n+\t inheritance graph order.  */\n       list = build_tree_list (t, NULL_TREE);\n-      dfs_walk_real (TYPE_BINFO (t), \n-\t\t     dfs_accumulate_vtbl_inits,\n-\t\t     NULL, \n-\t\t     dfs_unmarked_real_bases_queue_p, \n-\t\t     list);\n+      accumulate_vtbl_inits (TYPE_BINFO (t), list);\n+      /* Then come the virtual bases, also in inheritance graph\n+\t order.  */\n+      for (vbase = CLASSTYPE_VBASECLASSES (t);\n+\t   vbase;\n+\t   vbase = TREE_CHAIN (vbase))\n+\taccumulate_vtbl_inits (vbase, list);\n+\n       if (TYPE_BINFO_VTABLE (t))\n \tinitialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));\n     }\n   else\n-    dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n-\t      dfs_unmarked_real_bases_queue_p, t);\n-\n-  dfs_walk (TYPE_BINFO (t), dfs_unmark, \n-\t    dfs_marked_real_bases_queue_p, t);\n+    {\n+      dfs_walk (TYPE_BINFO (t), dfs_finish_vtbls, \n+\t\tdfs_unmarked_real_bases_queue_p, t);\n+      dfs_walk (TYPE_BINFO (t), dfs_unmark, \n+\t\tdfs_marked_real_bases_queue_p, t);\n+    }\n }\n \n /* True if we should override the given BASE_FNDECL with the given\n@@ -4142,17 +4166,10 @@ record_base_offsets (binfo, base_offsets)\n      tree binfo;\n      varray_type *base_offsets;\n {\n-  int virtual_p;\n-\n-  /* If BINFO is virtual, we still want to mention its offset in\n-     BASE_OFFSETS.  */\n-  virtual_p = TREE_VIA_VIRTUAL (binfo);\n-  TREE_VIA_VIRTUAL (binfo) = 0;\n   dfs_walk (binfo,\n \t    dfs_record_base_offsets,\n \t    dfs_skip_vbases,\n \t    base_offsets);\n-  TREE_VIA_VIRTUAL (binfo) = virtual_p;\n }\n \n /* Returns non-NULL if there is already an entry in DATA (which is\n@@ -5308,7 +5325,7 @@ finish_struct_1 (t)\n \t    }\n \t  build_primary_vtable (NULL_TREE, t);\n \t}\n-      else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n+      else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t), t))\n \t/* Here we know enough to change the type of our virtual\n \t   function table, but we will wait until later this function.  */\n \tbuild_primary_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);"}, {"sha": "9ccd28a529b6a62ebf185d53903b253c053ad7b0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "patch": "@@ -1566,10 +1566,19 @@ struct lang_type\n    (also distinct from the copies in the TYPE_BINFO hierarchy.)  */\n #define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n \n-/* The BINFO (if any) for the virtual baseclass T of the class C.  */\n+/* The BINFO (if any) for the virtual baseclass T of the class C from\n+   the CLASSTYPE_VBASECLASSES list.  */\n #define BINFO_FOR_VBASE(T, C) \\\n   (binfo_member (T, CLASSTYPE_VBASECLASSES (C)))\n \n+/* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n+   BINFO_FOR_VBASE.  C is the most derived class for the hierarchy\n+   containing BINFO.  */\n+#define CANONICAL_BINFO(BINFO, C)\t\t\\\n+  (TREE_VIA_VIRTUAL (BINFO) \t\t\t\\\n+   ? BINFO_FOR_VBASE (BINFO_TYPE (BINFO), C) \t\\\n+   : BINFO)\n+\n /* Number of direct baseclasses of NODE.  */\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n@@ -1704,11 +1713,14 @@ struct lang_type\n #define SET_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=1))\n #define CLEAR_BINFO_VTABLE_PATH_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED3(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_3(NODE)=0))\n \n-/* Nonzero means that this class has a new vtable.  */\n-#define BINFO_NEW_VTABLE_MARKED(NODE) \\\n-  (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):TREE_LANG_FLAG_4(NODE))\n-#define SET_BINFO_NEW_VTABLE_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?SET_CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_4(NODE)=1))\n-#define CLEAR_BINFO_NEW_VTABLE_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLEAR_CLASSTYPE_MARKED4(BINFO_TYPE(NODE)):(TREE_LANG_FLAG_4(NODE)=0))\n+/* Nonzero means B (a BINFO) needs a new vtable.  B is part of the\n+   hierarchy dominated by C.  */\n+#define BINFO_NEW_VTABLE_MARKED(B, C) \\\n+  (TREE_LANG_FLAG_4 (CANONICAL_BINFO (B, C)))\n+#define SET_BINFO_NEW_VTABLE_MARKED(B, C) \\\n+  (BINFO_NEW_VTABLE_MARKED (B, C) = 1)\n+#define CLEAR_BINFO_NEW_VTABLE_MARKED(B, C) \\\n+  (BINFO_NEW_VTABLE_MARKED (B, C) = 0)\n \n /* Nonzero means this class has done dfs_pushdecls.  */\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)"}, {"sha": "314dab901a7c8ba6380f699050a48675a5c27cda", "filename": "gcc/cp/search.c", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "patch": "@@ -76,6 +76,15 @@ pop_stack_level (stack)\n #define search_level stack_level\n static struct search_level *search_stack;\n \n+struct vbase_info \n+{\n+  /* The class dominating the hierarchy.  */\n+  tree type;\n+  tree decl_ptr;\n+  tree inits;\n+  tree vbase_types;\n+};\n+\n static tree next_baselink PARAMS ((tree));\n static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n@@ -2537,17 +2546,21 @@ unmarked_vtable_pathp (binfo, data)\n static tree \n marked_new_vtablep (binfo, data) \n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n-  return BINFO_NEW_VTABLE_MARKED (binfo) ? binfo : NULL_TREE; \n+  struct vbase_info *vi = (struct vbase_info *) data;\n+\n+  return BINFO_NEW_VTABLE_MARKED (binfo, vi->type) ? binfo : NULL_TREE; \n }\n \n static tree\n unmarked_new_vtablep (binfo, data) \n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n { \n-  return !BINFO_NEW_VTABLE_MARKED (binfo) ? binfo : NULL_TREE; \n+  struct vbase_info *vi = (struct vbase_info *) data;\n+\n+  return !BINFO_NEW_VTABLE_MARKED (binfo, vi->type) ? binfo : NULL_TREE; \n }\n \n static tree\n@@ -2614,31 +2627,7 @@ dfs_vtable_path_unmark (binfo, data)\n   return NULL_TREE;\n }\n \n-#if 0\n-static void\n-dfs_mark_vtable_path (binfo) tree binfo;\n-{ SET_BINFO_VTABLE_PATH_MARKED (binfo); }\n-\n-static void\n-dfs_mark_new_vtable (binfo) tree binfo;\n-{ SET_BINFO_NEW_VTABLE_MARKED (binfo); }\n-\n-static void\n-dfs_unmark_new_vtable (binfo) tree binfo;\n-{ CLEAR_BINFO_NEW_VTABLE_MARKED (binfo); }\n-\n-static void\n-dfs_clear_search_slot (binfo) tree binfo;\n-{ CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (binfo)) = 0; }\n-#endif\n \f\n-struct vbase_info \n-{\n-  tree decl_ptr;\n-  tree inits;\n-  tree vbase_types;\n-};\n-\n /*  Attach to the type of the virtual base class, the pointer to the\n     virtual base class.  */\n \n@@ -2668,7 +2657,7 @@ dfs_find_vbases (binfo, data)\n \t}\n     }\n   SET_BINFO_VTABLE_PATH_MARKED (binfo);\n-  SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  SET_BINFO_NEW_VTABLE_MARKED (binfo, vi->type);\n \n   return NULL_TREE;\n }\n@@ -2737,12 +2726,14 @@ dfs_init_vbase_pointers (binfo, data)\n static tree\n dfs_clear_vbase_slots (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n   tree type = BINFO_TYPE (binfo);\n+  struct vbase_info *vi = (struct vbase_info *) data;\n+\n   CLASSTYPE_SEARCH_SLOT (type) = 0;\n   CLEAR_BINFO_VTABLE_PATH_MARKED (binfo);\n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n+  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, vi->type);\n   return NULL_TREE;\n }\n \n@@ -2760,6 +2751,7 @@ init_vbase_pointers (type, decl_ptr)\n \n       /* Find all the virtual base classes, marking them for later\n \t initialization.  */\n+      vi.type = type;\n       vi.decl_ptr = decl_ptr;\n       vi.vbase_types = CLASSTYPE_VBASECLASSES (type);\n       vi.inits = NULL_TREE;\n@@ -2773,7 +2765,7 @@ init_vbase_pointers (type, decl_ptr)\n \t\t     marked_vtable_pathp,\n \t\t     &vi);\n \n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n+      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, &vi);\n       flag_this_is_variable = old_flag;\n       return vi.inits;\n     }\n@@ -3088,12 +3080,13 @@ expand_indirect_vtbls_init (binfo, decl_ptr)\n     {\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       struct vbase_info vi;\n+      vi.type = type;\n       vi.decl_ptr = decl_ptr;\n       vi.vbase_types = vbases;\n \n       dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep, &vi);\n       fixup_all_virtual_upcast_offsets (type, vi.decl_ptr);\n-      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n+      dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, &vi);\n     }\n }\n "}, {"sha": "aafcad8d19c3130b8e8e348da5a377f4b5e71603", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vtable.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9d63596fc5b0245704c8f66715c5d03dc4c91a/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvtable.C?ref=3c9d63596fc5b0245704c8f66715c5d03dc4c91a", "patch": "@@ -0,0 +1,82 @@\n+// Test various aspects of vtable layout.\n+// Special g++ Options: -fno-strict-aliasing\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+\n+struct S0\n+{\n+  virtual void h ()\n+  {\n+  }\n+\n+  int k;\n+};\n+\n+\n+struct S1 \n+{\n+  virtual void f () \n+  {\n+  }\n+\n+  int i;\n+};\n+\n+struct S2 : virtual public S0\n+{\n+  virtual void g ()\n+  {\n+  }\n+\n+  int j;\n+};\n+\n+struct S3 \n+{\n+  virtual void k () \n+  {\n+  }\n+\n+  int l;\n+};\n+\n+struct S4 : public virtual S1, public S2, public S3\n+{\n+};\n+\n+inline void* vtable (void *object)\n+{\n+  // The vptr is always the first part of the object.\n+  return * (void **) object;\n+}\n+\n+int main ()\n+{\n+  // The vtable layout order for S4 should consist of S4's primary\n+  // vtable (shared with S2), followed by the vtable for S3 (because\n+  // it is a non-virtual base).  Then, these should be followed by the\n+  // the vtables for S1 and S0, which are virtual.\n+  S4 s4;\n+  S0 *s0 = &s4;\n+  S1 *s1 = &s4;\n+  S2 *s2 = &s4;\n+  S3 *s3 = &s4;\n+  \n+  if (vtable (&s4) != vtable (s2))\n+    return 1;\n+    if (vtable (s2) >= vtable (s3))\n+    return 2;\n+  if (vtable (s3) >= vtable (s1))\n+    return 3;\n+  if (vtable (s1) >= vtable (s0))\n+    return 4;\n+}\n+\n+#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+\n+int main () \n+{\n+}\n+\n+#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}]}