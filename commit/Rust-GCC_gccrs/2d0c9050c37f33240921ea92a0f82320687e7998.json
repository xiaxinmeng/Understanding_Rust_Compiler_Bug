{"sha": "2d0c9050c37f33240921ea92a0f82320687e7998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQwYzkwNTBjMzdmMzMyNDA5MjFlYTkyYTBmODIzMjA2ODdlNzk5OA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-21T10:31:55Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-21T10:31:55Z"}, "message": "LogRecord.java, [...]: New files from classpath.\n\n2003-06-21  Michael Koch  <konqueror@gmx.de>\n\n\t* java/util/logging/LogRecord.java,\n\tjava/util/logging/Logger.java,\n\tjava/util/logging/SocketHandler.java,\n\tjava/util/logging/SimpleFormatter.java,\n\tjava/util/logging/Formatter.java,\n\tjava/util/logging/ErrorManager.java,\n\tjava/util/logging/Handler.java,\n\tjava/util/logging/FileHandler.java,\n\tjava/util/logging/LogManager.java,\n\tjava/util/logging/Level.java,\n\tjava/util/logging/ConsoleHandler.java,\n\tjava/util/logging/StreamHandler.java,\n\tjava/util/logging/LoggingPermission.java,\n\tjava/util/logging/Filter.java,\n\tjava/util/logging/MemoryHandler.java,\n\tjava/util/logging/XMLFormatter.java:\n\tNew files from classpath.\n\nFrom-SVN: r68295", "tree": {"sha": "86745e71f6be972feca8e633cd19a7fcd10ad300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86745e71f6be972feca8e633cd19a7fcd10ad300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d0c9050c37f33240921ea92a0f82320687e7998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d0c9050c37f33240921ea92a0f82320687e7998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d0c9050c37f33240921ea92a0f82320687e7998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d0c9050c37f33240921ea92a0f82320687e7998/comments", "author": null, "committer": null, "parents": [{"sha": "c18cd64247e570d64af9269986cda2b10b32b949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c18cd64247e570d64af9269986cda2b10b32b949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c18cd64247e570d64af9269986cda2b10b32b949"}], "stats": {"total": 6247, "additions": 6247, "deletions": 0}, "files": [{"sha": "d00354d257b784e81ea23b2c5cd81615f91aab5c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -1,3 +1,23 @@\n+2003-06-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/util/logging/LogRecord.java,\n+\tjava/util/logging/Logger.java,\n+\tjava/util/logging/SocketHandler.java,\n+\tjava/util/logging/SimpleFormatter.java,\n+\tjava/util/logging/Formatter.java,\n+\tjava/util/logging/ErrorManager.java,\n+\tjava/util/logging/Handler.java,\n+\tjava/util/logging/FileHandler.java,\n+\tjava/util/logging/LogManager.java,\n+\tjava/util/logging/Level.java,\n+\tjava/util/logging/ConsoleHandler.java,\n+\tjava/util/logging/StreamHandler.java,\n+\tjava/util/logging/LoggingPermission.java,\n+\tjava/util/logging/Filter.java,\n+\tjava/util/logging/MemoryHandler.java,\n+\tjava/util/logging/XMLFormatter.java:\n+\tNew files from classpath.\n+\n 2003-06-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/ObjectStreamField.java"}, {"sha": "dd519b682f4217baab3a4543d8159dd2490707d7", "filename": "libjava/java/util/logging/ConsoleHandler.java", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FConsoleHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FConsoleHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FConsoleHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,129 @@\n+/* ConsoleHandler.java\n+   -- a class for publishing log messages to System.err\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+/**\n+ * A <code>ConsoleHandler</code> publishes log records to\n+ * <code>System.err</code>.\n+ *\n+ * <p><strong>Configuration:</strong> Values of the subsequent\n+ * <code>LogManager</code> properties are taken into consideration\n+ * when a <code>ConsoleHandler</code> is initialized.\n+ * If a property is not defined, or if it has an invalid\n+ * value, a default is taken without an exception being thrown.\n+ *\n+ * <ul>\n+ *\n+ * <li><code>java.util.logging.ConsoleHandler.level</code> - specifies\n+ *     the initial severity level threshold. Default value:\n+ *     <code>Level.INFO</code>.</li>\n+ *\n+ * <li><code>java.util.logging.ConsoleHandler.filter</code> - specifies\n+ *     the name of a Filter class. Default value: No Filter.</li>\n+ *\n+ * <li><code>java.util.logging.ConsoleHandler.formatter</code> - specifies\n+ *     the name of a Formatter class. Default value:\n+ *     <code>java.util.logging.SimpleFormatter</code>.</li>\n+ *\n+ * <li><code>java.util.logging.ConsoleHandler.encoding</code> - specifies\n+ *     the name of the character encoding. Default value:\n+ *     the default platform encoding.\n+ *\n+ * </ul>\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class ConsoleHandler\n+  extends StreamHandler\n+{\n+  /**\n+   * Constructs a <code>StreamHandler</code> that publishes\n+   * log records to <code>System.err</code>.  The initial\n+   * configuration is determined by the <code>LogManager</code>\n+   * properties described above.\n+   */\n+  public ConsoleHandler()\n+  {\n+    super(System.err, \"java.util.logging.ConsoleHandler\", Level.INFO,\n+\t /* formatter */ null, SimpleFormatter.class);\n+  }\n+\n+\n+  /**\n+   * Forces any data that may have been buffered to the underlying\n+   * output device, but does <i>not</i> close <code>System.err</code>.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>ConsoleHandler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   */\n+  public void close()\n+  {\n+    flush();\n+  }\n+\n+\n+  /**\n+   * Publishes a <code>LogRecord</code> to the console, provided the\n+   * record passes all tests for being loggable.\n+   *\n+   * <p>Most applications do not need to call this method directly.\n+   * Instead, they will use use a <code>Logger</code>, which will\n+   * create LogRecords and distribute them to registered handlers.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>SocketHandler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * <p>The GNU implementation of <code>ConsoleHandler.publish</code>\n+   * calls flush() for every request to publish a record, so\n+   * they appear immediately on the console.\n+   *\n+   * @param record the log event to be published.\n+   */\n+  public void publish(LogRecord record)\n+  {\n+    super.publish(record);\n+    flush();\n+  }\n+}"}, {"sha": "cc36bf6301ce1f4cb53225c4c91d69d997227d60", "filename": "libjava/java/util/logging/ErrorManager.java", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FErrorManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FErrorManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FErrorManager.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,182 @@\n+/* ErrorManager.java\n+   -- a class for dealing with errors that a Handler encounters\n+      during logging\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+/**\n+ * An <code>ErrorManager</code> deals with errors that a <code>Handler</code>\n+ * encounters while logging.\n+ *\n+ * @see Handler#setErrorManager(ErrorManager)\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class ErrorManager\n+{\n+  /* The values have been taken from Sun's public J2SE 1.4 API\n+   * documentation.\n+   * See http://java.sun.com/j2se/1.4/docs/api/constant-values.html\n+   */\n+\n+  /**\n+   * Indicates that there was a failure that does not readily\n+   * fall into any of the other categories.\n+   */\n+  public static final int GENERIC_FAILURE = 0;\n+\n+\n+  /**\n+   * Indicates that there was a problem upon writing to\n+   * an output stream.\n+   */\n+  public static final int WRITE_FAILURE = 1;\n+\n+\n+  /**\n+   * Indicates that there was a problem upon flushing\n+   * an output stream.\n+   */\n+  public static final int FLUSH_FAILURE = 2;\n+\n+\n+  /**\n+   * Indicates that there was a problem upon closing\n+   * an output stream.\n+   */\n+  public static final int CLOSE_FAILURE = 3;\n+\n+    \n+  /**\n+   * Indicates that there was a problem upon opening\n+   * an output stream.\n+   */\n+  public static final int OPEN_FAILURE = 4;\n+\n+\n+  /**\n+   * Indicates that there was a problem upon formatting\n+   * the message of a log record.\n+   */\n+  public static final int FORMAT_FAILURE = 5;\n+\n+\n+  private boolean everUsed = false;\n+\n+  public ErrorManager()\n+  {\n+  }\n+\n+\n+  /**\n+   * Reports an error that occured upon logging.  The default implementation\n+   * emits the very first error to System.err, ignoring subsequent errors.\n+   *\n+   * @param message a message describing the error, or <code>null</code> if\n+   *                there is no suitable description.\n+   *\n+   * @param ex      an exception, or <code>null</code> if the error is not\n+   *                related to an exception.\n+   *\n+   * @param errorCode  one of the defined error codes, for example\n+   *                   <code>ErrorManager.CLOSE_FAILURE</code>.\n+   */\n+  public void error(String message, Exception ex, int errorCode)\n+  {\n+    if (everUsed)\n+      return;\n+\n+    synchronized (ErrorManager.class)\n+    {\n+      /* The double check is intentional. If the first check was\n+       * omitted, the monitor would have to be entered every time\n+       * error() method was called. If the second check was\n+       * omitted, the code below could be executed by multiple\n+       * threads simultaneously.\n+       */\n+      if (everUsed)\n+\treturn;\n+\n+      everUsed = true;\n+    }\n+\n+    String codeMsg;\n+    switch (errorCode)\n+    {\n+    case GENERIC_FAILURE:\n+      codeMsg = \"GENERIC_FAILURE\";\n+      break;\n+\n+    case WRITE_FAILURE:\n+      codeMsg = \"WRITE_FAILURE\";\n+      break;\n+\n+    case FLUSH_FAILURE:\n+      codeMsg = \"FLUSH_FAILURE\";\n+      break;\n+\n+    case CLOSE_FAILURE:\n+      codeMsg = \"CLOSE_FAILURE\";\n+      break;\n+\n+    case OPEN_FAILURE:\n+      codeMsg = \"OPEN_FAILURE\";\n+      break;\n+\n+    case FORMAT_FAILURE:\n+      codeMsg = \"FORMAT_FAILURE\";\n+      break;\n+\n+    default:\n+      codeMsg = String.valueOf(errorCode);\n+      break;\n+    }\n+\n+    System.err.println(\"Error upon logging: \" + codeMsg);\n+    if ((message != null) && (message.length() > 0))\n+      System.err.println(message);\n+\n+    if (ex != null)\n+      ex.printStackTrace();\n+  }\n+}\n+"}, {"sha": "b9f61109d3b8032dcda178bb40dfc097e9137cd9", "filename": "libjava/java/util/logging/FileHandler.java", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFileHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFileHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FFileHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,509 @@\n+/* FileHandler.java\n+   -- a class for publishing log messages to log files\n+\n+Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+package java.util.logging;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+\n+/**\n+ * A <code>FileHandler</code> publishes log records to a set of log\n+ * files.  A maximum file size can be specified; as soon as a log file\n+ * reaches the size limit, it is closed and the next file in the set\n+ * is taken.\n+ *\n+ * <p><strong>Configuration:</strong> Values of the subsequent\n+ * <code>LogManager</code> properties are taken into consideration\n+ * when a <code>FileHandler</code> is initialized.  If a property is\n+ * not defined, or if it has an invalid value, a default is taken\n+ * without an exception being thrown.\n+ *\n+ * <ul>\n+ *\n+ * <li><code>java.util.FileHandler.level</code> - specifies\n+ *     the initial severity level threshold. Default value:\n+ *     <code>Level.ALL</code>.</li>\n+ *\n+ * <li><code>java.util.FileHandler.filter</code> - specifies\n+ *     the name of a Filter class. Default value: No Filter.</li>\n+ *\n+ * <li><code>java.util.FileHandler.formatter</code> - specifies\n+ *     the name of a Formatter class. Default value:\n+ *     <code>java.util.logging.XMLFormatter</code>.</li>\n+ *\n+ * <li><code>java.util.FileHandler.encoding</code> - specifies\n+ *     the name of the character encoding. Default value:\n+ *     the default platform encoding.</li>\n+ *\n+ * <li><code>java.util.FileHandler.limit</code> - specifies the number\n+ *     of bytes a log file is approximately allowed to reach before it\n+ *     is closed and the handler switches to the next file in the\n+ *     rotating set.  A value of zero means that files can grow\n+ *     without limit.  Default value: 0 (unlimited growth).</li>\n+ *\n+ * <li><code>java.util.FileHandler.count</code> - specifies the number\n+ *     of log files through which this handler cycles.  Default value:\n+ *     1.</li>\n+ *\n+ * <li><code>java.util.FileHandler.pattern</code> - specifies a\n+ *     pattern for the location and name of the produced log files.\n+ *     See the section on <a href=\"#filePatterns\">file name\n+ *     patterns</a> for details.  Default value:\n+ *     <code>\"%h/java%u.log\"</code>.</li>\n+ *\n+ * <li><code>java.util.FileHandler.append</code> - specifies\n+ *     whether the handler will append log records to existing\n+ *     files, or whether the handler will clear log files\n+ *     upon switching to them. Default value: <code>false</code>,\n+ *     indicating that files will be cleared.</li>\n+ *\n+ * </ul>\n+ *\n+ * <p><a name=\"filePatterns\"><strong>File Name Patterns:</strong></a>\n+ * The name and location and log files are specified with pattern\n+ * strings. The handler will replace the following character sequences\n+ * when opening log files:\n+ *\n+ * <p><ul>\n+ * <li><code>/</code> - replaced by the platform-specific path name\n+ *     separator.  This value is taken from the system property\n+ *     <code>file.separator</code>.</li>\n+ *\n+ * <li><code>%t</code> - replaced by the platform-specific location of\n+ *     the directory intended for temporary files.  This value is\n+ *     taken from the system property <code>java.io.tmpdir</code>.</li>\n+ *\n+ * <li><code>%h</code> - replaced by the location of the home\n+ *     directory of the current user.  This value is taken from the\n+ *     system property <code>file.separator</code>.</li>\n+ *\n+ * <li><code>%g</code> - replaced by a generation number for\n+ *     distinguisthing the individual items in the rotating set \n+ *     of log files.  The generation number cycles through the\n+ *     sequence 0, 1, ..., <code>count</code> - 1.</li>\n+ *\n+ * <li><code>%u</code> - replaced by a unique number for\n+ *     distinguisthing the output files of several concurrently\n+ *     running processes.  The <code>FileHandler</code> starts\n+ *     with 0 when it tries to open a log file.  If the file\n+ *     cannot be opened because it is currently in use,\n+ *     the unique number is incremented by one and opening\n+ *     is tried again.  These steps are repeated until the\n+ *     opening operation succeeds.\n+ *\n+ *     <p>FIXME: Is the following correct? Please review.  The unique\n+ *     number is determined for each log file individually when it is\n+ *     opened upon switching to the next file.  Therefore, it is not\n+ *     correct to assume that all log files in a rotating set bear the\n+ *     same unique number.\n+ *\n+ *     <p>FIXME: The Javadoc for the Sun reference implementation\n+ *     says: \"Note that the use of unique ids to avoid conflicts is\n+ *     only guaranteed to work reliably when using a local disk file\n+ *     system.\" Why? This needs to be mentioned as well, in case\n+ *     the reviewers decide the statement is true.  Otherwise,\n+ *     file a bug report with Sun.</li>\n+ *\n+ * <li><code>%%</code> - replaced by a single percent sign.</li>\n+ * </ul>\n+ *\n+ * <p>If the pattern string does not contain <code>%g</code> and\n+ * <code>count</code> is greater than one, the handler will append\n+ * the string <code>.%g</code> to the specified pattern.\n+ *\n+ * <p>If the handler attempts to open a log file, this log file\n+ * is being used at the time of the attempt, and the pattern string\n+ * does not contain <code>%u</code>, the handler will append\n+ * the string <code>.%u</code> to the specified pattern. This\n+ * step is performed after any generation number has been\n+ * appended.\n+ *\n+ * <p><em>Examples for the GNU platform:</em> \n+ *\n+ * <p><ul>\n+ *\n+ * <li><code>%h/java%u.log</code> will lead to a single log file\n+ *     <code>/home/janet/java0.log</code>, assuming <code>count</code>\n+ *     equals 1, the user's home directory is\n+ *     <code>/home/janet</code>, and the attempt to open the file\n+ *     succeeds.</li>\n+ *\n+ * <li><code>%h/java%u.log</code> will lead to three log files\n+ *     <code>/home/janet/java0.log.0</code>,\n+ *     <code>/home/janet/java0.log.1</code>, and\n+ *     <code>/home/janet/java0.log.2</code>,\n+ *     assuming <code>count</code> equals 3, the user's home\n+ *     directory is <code>/home/janet</code>, and all attempts\n+ *     to open files succeed.</li>\n+ *\n+ * <li><code>%h/java%u.log</code> will lead to three log files\n+ *     <code>/home/janet/java0.log.0</code>,\n+ *     <code>/home/janet/java1.log.1</code>, and\n+ *     <code>/home/janet/java0.log.2</code>,\n+ *     assuming <code>count</code> equals 3, the user's home\n+ *     directory is <code>/home/janet</code>, and the attempt\n+ *     to open <code>/home/janet/java0.log.1</code> fails.</li>\n+ *\n+ * </ul>\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class FileHandler\n+  extends StreamHandler\n+{\n+  /**\n+   * The number of bytes a log file is approximately allowed to reach\n+   * before it is closed and the handler switches to the next file in\n+   * the rotating set.  A value of zero means that files can grow\n+   * without limit.\n+   */\n+  private final int limit;\n+\n+\n+ /**\n+  * The number of log files through which this handler cycles.\n+  */\n+  private final int count;\n+\n+\n+  /**\n+   * The pattern for the location and name of the produced log files.\n+   * See the section on <a href=\"#filePatterns\">file name patterns</a>\n+   * for details.\n+   */\n+  private final String pattern;\n+\n+\n+  /**\n+   * Indicates whether the handler will append log records to existing\n+   * files (<code>true</code>), or whether the handler will clear log files\n+   * upon switching to them (<code>false</code>).\n+   */\n+  private final boolean append;\n+\n+\n+  /**\n+   * Constructs a <code>FileHandler</code>, taking all property values\n+   * from the current {@link LogManager LogManager} configuration.\n+   *\n+   * @throws java.io.IOException FIXME: The Sun Javadoc says: \"if\n+   *         there are IO problems opening the files.\"  This conflicts\n+   *         with the general principle that configuration errors do\n+   *         not prohibit construction. Needs review.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   */\n+  public FileHandler()\n+    throws IOException, SecurityException\n+  {\n+    this(/* pattern: use configiguration */ null,\n+\n+\t LogManager.getIntProperty(\"java.util.logging.FileHandler.limit\",\n+\t\t\t\t   /* default */ 0),\n+\n+\t LogManager.getIntProperty(\"java.util.logging.FileHandler.count\",\n+\t\t\t\t   /* default */ 1),\n+\n+\t LogManager.getBooleanProperty(\"java.util.logging.FileHandler.append\",\n+\t\t\t\t       /* default */ false));\n+  }\n+\n+\n+  /* FIXME: Javadoc missing. */\n+  public FileHandler(String pattern)\n+    throws IOException, SecurityException\n+  {\n+    this(pattern,\n+\t /* limit */ 0,\n+\t /* count */ 1,\n+\t /* append */ false);\n+  }\n+\n+\n+  /* FIXME: Javadoc missing. */\n+  public FileHandler(String pattern, boolean append)\n+    throws IOException, SecurityException\n+  {\n+    this(pattern,\n+\t /* limit */ 0,\n+\t /* count */ 1,\n+\t append);\n+  }\n+\n+\n+  /* FIXME: Javadoc missing. */\n+  public FileHandler(String pattern, int limit, int count)\n+    throws IOException, SecurityException\n+  {\n+    this(pattern, limit, count, \n+\t LogManager.getBooleanProperty(\n+\t   \"java.util.logging.FileHandler.append\",\n+\t   /* default */ false));\n+  }\n+\n+\n+  /**\n+   * Constructs a <code>FileHandler</code> given the pattern for the\n+   * location and name of the produced log files, the size limit, the\n+   * number of log files thorough which the handler will rotate, and\n+   * the <code>append</code> property.  All other property values are\n+   * taken from the current {@link LogManager LogManager}\n+   * configuration.\n+   *\n+   * @param pattern The pattern for the location and name of the\n+   *        produced log files.  See the section on <a\n+   *        href=\"#filePatterns\">file name patterns</a> for details.\n+   *        If <code>pattern</code> is <code>null</code>, the value is\n+   *        taken from the {@link LogManager LogManager} configuration\n+   *        property\n+   *        <code>java.util.logging.FileHandler.pattern</code>.\n+   *        However, this is a pecularity of the GNU implementation,\n+   *        and Sun's API specification does not mention what behavior\n+   *        is to be expected for <code>null</code>. Therefore,\n+   *        applications should not rely on this feature.\n+   *\n+   * @param limit specifies the number of bytes a log file is\n+   *        approximately allowed to reach before it is closed and the\n+   *        handler switches to the next file in the rotating set.  A\n+   *        value of zero means that files can grow without limit.\n+   *\n+   * @param count specifies the number of log files through which this\n+   *        handler cycles.\n+   *\n+   * @param append specifies whether the handler will append log\n+   *        records to existing files (<code>true</code>), or whether the\n+   *        handler will clear log files upon switching to them\n+   *        (<code>false</code>).\n+   *\n+   * @throws java.io.IOException FIXME: The Sun Javadoc says: \"if\n+   *         there are IO problems opening the files.\"  This conflicts\n+   *         with the general principle that configuration errors do\n+   *         not prohibit construction. Needs review.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   *         <p>FIXME: This seems in contrast to all other handler\n+   *         constructors -- verify this by running tests against\n+   *         the Sun reference implementation.\n+   */\n+  public FileHandler(String pattern,\n+\t\t     int limit,\n+\t\t     int count,\n+\t\t     boolean append)\n+    throws IOException, SecurityException\n+  {\n+    super(createFileStream(pattern, limit, count, append,\n+\t\t\t   /* generation */ 0),\n+\t  \"java.util.logging.FileHandler\",\n+\t  /* default level */ Level.ALL,\n+\t  /* formatter */ null,\n+\t  /* default formatter */ XMLFormatter.class);\n+\n+    if ((limit <0) || (count < 1))\n+      throw new IllegalArgumentException();\n+\n+    this.pattern = pattern;\n+    this.limit = limit;\n+    this.count = count;\n+    this.append = append;\n+  }\n+\n+\n+  /* FIXME: Javadoc missing. */\n+  private static java.io.OutputStream createFileStream(String pattern,\n+\t\t\t\t\t\t       int limit,\n+\t\t\t\t\t\t       int count,\n+\t\t\t\t\t\t       boolean append,\n+\t\t\t\t\t\t       int generation)\n+  {\n+    String  path;\n+    int     unique = 0;\n+\n+    /* Throws a SecurityException if the caller does not have\n+     * LoggingPermission(\"control\").\n+     */\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Default value from the java.util.logging.FileHandler.pattern\n+     * LogManager configuration property.\n+     */\n+    if (pattern == null)\n+      pattern = LogManager.getLogManager().getProperty(\n+                              \"java.util.logging.FileHandler.pattern\");\n+    if (pattern == null)\n+      pattern = \"%h/java%u.log\";\n+\n+    do\n+    {\n+      path = replaceFileNameEscapes(pattern, generation, unique, count);\n+\n+      try\n+      {\n+\tFile file = new File(path);\n+\tif (file.createNewFile())\n+\t  return new FileOutputStream(path, append);\n+      }\n+      catch (Exception ex)\n+      {\n+\tex.printStackTrace();\t\n+      }\n+\n+      unique = unique + 1;\n+      if (pattern.indexOf(\"%u\") < 0)\n+        pattern = pattern + \".%u\";\n+    }\n+    while (true);\n+  }\n+\n+\n+  /**\n+   * Replaces the substrings <code>\"/\"</code> by the value of the\n+   * system property <code>\"file.separator\"</code>, <code>\"%t\"</code>\n+   * by the value of the system property\n+   * <code>\"java.io.tmpdir\"</code>, <code>\"%h\"</code> by the value of\n+   * the system property <code>\"user.home\"</code>, <code>\"%g\"</code>\n+   * by the value of <code>generation</code>, <code>\"%u\"</code> by the\n+   * value of <code>uniqueNumber</code>, and <code>\"%%\"</code> by a\n+   * single percent character.  If <code>pattern<code> does\n+   * <em>not</em> contain the sequence <code>\"%g\"</code>,\n+   * the value of <code>generation</code> will be appended to\n+   * the result.\n+   *\n+   * @throws NullPointerException if one of the system properties\n+   *         <code>\"file.separator\"</code>,\n+   *         <code>\"java.io.tmpdir\"</code>, or\n+   *         <code>\"user.home\"</code> has no value and the\n+   *         corresponding escape sequence appears in\n+   *         <code>pattern</code>.\n+   */\n+  private static String replaceFileNameEscapes(String pattern,\n+\t\t\t\t\t       int generation,\n+\t\t\t\t\t       int uniqueNumber,\n+\t\t\t\t\t       int count)\n+  {\n+    StringBuffer buf = new StringBuffer(pattern);\n+    String       replaceWith;\n+    boolean      foundGeneration = false;\n+\n+    int pos = 0;\n+    do\n+    {\n+      // Uncomment the next line for finding bugs.\n+      // System.out.println(buf.substring(0,pos) + '|' + buf.substring(pos));\n+      \n+      if (buf.charAt(pos) == '/')\n+      {\n+\t/* The same value is also provided by java.io.File.separator. */\n+\treplaceWith = System.getProperty(\"file.separator\");\n+\tbuf.replace(pos, pos + 1, replaceWith);\n+\tpos = pos + replaceWith.length() - 1;\n+\tcontinue;\n+      }\n+\n+      if (buf.charAt(pos) == '%')\n+      {\n+        switch (buf.charAt(pos + 1))\n+\t{\n+\tcase 't':\n+\t  replaceWith = System.getProperty(\"java.io.tmpdir\");\n+\t  break;\n+\n+\tcase 'h':\n+\t  replaceWith = System.getProperty(\"user.home\");\n+\t  break;\n+\n+\tcase 'g':\n+\t  replaceWith = Integer.toString(generation);\n+\t  foundGeneration = true;\n+\t  break;\n+\n+\tcase 'u':\n+\t  replaceWith = Integer.toString(uniqueNumber);\n+\t  break;\n+\n+\tcase '%':\n+\t  replaceWith = \"%\";\n+\t  break;\n+\n+\tdefault:\n+\t  replaceWith = \"??\";\n+\t  break; // FIXME: Throw exception?\n+\t}\n+\n+\tbuf.replace(pos, pos + 2, replaceWith);\n+\tpos = pos + replaceWith.length() - 1;\n+\tcontinue;\n+      }\n+    }\n+    while (++pos < buf.length() - 1);\n+\n+    if (!foundGeneration && (count > 1))\n+    {\n+      buf.append('.');\n+      buf.append(generation);\n+    }\n+\n+    return buf.toString();\n+  }\n+\n+\n+  /* FIXME: Javadoc missing, implementation incomplete. */\n+  public void publish(LogRecord record)\n+  {\n+    super.publish(record);\n+\n+    /* FIXME: Decide when to switch over. How do we get to\n+     * the number of bytes published so far? Two possibilities:\n+     * 1. File.length, 2. have metering wrapper around\n+     * output stream counting the number of written bytes.\n+     */\n+  \n+    /* FIXME: Switch over if needed! This implementation always\n+     * writes into a single file, i.e. behaves as if limit\n+     * always was zero. So, the implementation is somewhat\n+     * functional but incomplete.\n+     */\n+  }\n+}"}, {"sha": "a25fd3d3814bdeaf2b2599d7604de1752c6bc1c9", "filename": "libjava/java/util/logging/Filter.java", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFilter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFilter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FFilter.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,68 @@\n+/* Filter.java\n+   -- an interface for filters that decide whether a LogRecord should\n+      be published or discarded\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+/**\n+ * By implementing the <code>Filter</code> interface, applications\n+ * can control what is being logged based on arbitrary properties,\n+ * not just the severity level.  Both <code>Handler</code> and\n+ * <code>Logger</code> allow to register Filters whose\n+ * <code>isLoggable</code> method will be called when a\n+ * <code>LogRecord</code> has passed the test based on the\n+ * severity level.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public interface Filter\n+{\n+  /**\n+   * Determines whether a LogRecord should be published or discarded.\n+   *\n+   * @param record the <code>LogRecord</code> to be inspected.\n+   *\n+   * @return <code>true</code> if the record should be published,\n+   *         <code>false</code> if it should be discarded.\n+   */\n+  public boolean isLoggable(LogRecord record);\n+}"}, {"sha": "c4819695165a04b01a5cf89829b42b50aff2caf1", "filename": "libjava/java/util/logging/Formatter.java", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFormatter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FFormatter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FFormatter.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,174 @@\n+/* Formatter.java\n+   -- a class for formatting log messages by localizing message texts\n+      and performing substitution of parameters\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.ResourceBundle;\n+import java.text.MessageFormat;\n+\n+/**\n+ * A <code>Formatter</code> supports handlers by localizing\n+ * message texts and by subsituting parameter values for their\n+ * placeholders.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public abstract class Formatter\n+{\n+  /**\n+   * Constructs a new Formatter.\n+   */\n+  protected Formatter()\n+  {\n+  }\n+\n+\n+  /**\n+   * Formats a LogRecord into a string.  Usually called by handlers\n+   * which need a string for a log record, for example to append\n+   * a record to a log file or to transmit a record over the network.\n+   *\n+   * @param record the log record for which a string form is requested.\n+   */\n+  public abstract String format(LogRecord record);\n+\n+\n+  /**\n+   * Returns a string that handlers are supposed to emit before\n+   * the first log record.  The base implementation returns an\n+   * empty string, but subclasses such as {@link XMLFormatter}\n+   * override this method in order to provide a suitable header.\n+   *\n+   * @return a string for the header.\n+   *\n+   * @param handler the handler which will prepend the returned\n+   *     string in front of the first log record.  This method\n+   *     may inspect certain properties of the handler, for\n+   *     example its encoding, in order to construct the header.\n+   */\n+  public String getHead(Handler handler)\n+  {\n+    return \"\";\n+  }\n+\n+\n+  /**\n+   * Returns a string that handlers are supposed to emit after\n+   * the last log record.  The base implementation returns an\n+   * empty string, but subclasses such as {@link XMLFormatter}\n+   * override this method in order to provide a suitable tail.\n+   *\n+   * @return a string for the header.\n+   *\n+   * @param handler the handler which will append the returned\n+   *     string after the last log record.  This method\n+   *     may inspect certain properties of the handler\n+   *     in order to construct the tail.\n+   */\n+  public String getTail(Handler handler)\n+  {\n+    return \"\";\n+  }\n+\n+\n+  /**\n+   * Formats the message part of a log record.\n+   *\n+   * <p>First, the Formatter localizes the record message to the\n+   * default locale by looking up the message in the record's\n+   * localization resource bundle.  If this step fails because there\n+   * is no resource bundle associated with the record, or because the\n+   * record message is not a key in the bundle, the raw message is\n+   * used instead.\n+   *\n+   * <p>Second, the Formatter substitutes appropriate strings for\n+   * the message parameters. If the record returns a non-empty\n+   * array for <code>getParameters()</code> and the localized\n+   * message string contains the character sequence \"{0\", the\n+   * formatter uses <code>java.text.MessageFormat</code> to format\n+   * the message.  Otherwise, no parameter substitution is performed.\n+   *\n+   * @param record the log record to be localized and formatted.\n+   *\n+   * @return the localized message text where parameters have been\n+   *         substituted by suitable strings.\n+   *\n+   * @throws NullPointerException if <code>record</code>\n+   *         is <code>null</code>.\n+   */\n+  public String formatMessage(LogRecord record)\n+  {\n+    String          msg;\n+    ResourceBundle  bundle;\n+    Object[]        params;\n+\n+    /* This will throw a NullPointerExceptionif record is null. */\n+    msg = record.getMessage();\n+    if (msg == null)\n+      msg = \"\";\n+\n+    /* Try to localize the message. */\n+    bundle = record.getResourceBundle();\n+    if (bundle != null)\n+    {\n+      try\n+      {\n+\tmsg = bundle.getString(msg);\n+      }\n+      catch (java.util.MissingResourceException _)\n+      {\n+      }\n+    }\n+\n+    /* Format the message if there are parameters. */\n+    params = record.getParameters();\n+    if ((params != null)\n+\t&& (params.length > 0)\n+\t&& (msg.indexOf(\"{0\") >= 0))\n+    {\n+      msg = MessageFormat.format(msg, params);\n+    }\n+\n+    return msg;\n+  }\n+}"}, {"sha": "324532187d365dbc0e96ee04ff2d4f192acd5771", "filename": "libjava/java/util/logging/Handler.java", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,390 @@\n+/* Handler.java\n+   -- a class for publishing log messages\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.AccessController;\n+\n+/**\n+ * A <code>Handler</code> publishes <code>LogRecords</code> to\n+ * a sink, for example a file, the console or a network socket.\n+ * There are different subclasses of <code>Handler</code>\n+ * to deal with different kinds of sinks.\n+ *\n+ * <p>FIXME: Are handlers thread-safe, or is the assumption that only\n+ * loggers are, and a handler can belong only to one single logger? If\n+ * the latter, should we enforce it? (Spec not clear). In any\n+ * case, it needs documentation.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public abstract class Handler\n+{\n+  Formatter     formatter;\n+  Filter        filter;\n+  Level         level;\n+  ErrorManager  errorManager;\n+  String        encoding;\n+\n+  /**\n+   * Constructs a Handler with a logging severity level of\n+   * <code>Level.ALL</code>, no formatter, no filter, and\n+   * an instance of <code>ErrorManager</code> managing errors.\n+   *\n+   * <p><strong>Specification Note:</strong> The specification of the\n+   * Java<sup>TM</sup> Logging API does not mention which character\n+   * encoding is to be used by freshly constructed Handlers.  The GNU\n+   * implementation uses the default platform encoding, but other\n+   * Java implementations might behave differently.\n+   *\n+   * <p><strong>Specification Note:</strong> While a freshly constructed\n+   * Handler is required to have <em>no filter</em> according to the\n+   * specification, <code>null</code> is not a valid parameter for\n+   * <code>Handler.setFormatter</code>.  Therefore, the following\n+   * code will throw a <code>java.lang.NullPointerException</code>:\n+   *\n+   * <p><pre>Handler h = new MyConcreteSubclassOfHandler();\n+h.setFormatter(h.getFormatter());</pre>\n+   *\n+   * It seems strange that a freshly constructed Handler is not\n+   * supposed to provide a Formatter, but this is what the specification\n+   * says.\n+   */\n+  {\n+    level = Level.ALL;\n+  }\n+\n+\n+  /**\n+   * Publishes a <code>LogRecord</code> to an appropriate sink,\n+   * provided the record passes all tests for being loggable.  The\n+   * <code>Handler</code> will localize the message of the log\n+   * record and substitute any message parameters.\n+   *\n+   * <p>Most applications do not need to call this method directly.\n+   * Instead, they will use use a {@link Logger}, which will\n+   * create LogRecords and distribute them to registered handlers.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * @param record the log event to be published.\n+   */\n+  public abstract void publish(LogRecord record);\n+\n+\n+  /**\n+   * Forces any data that may have been buffered to the underlying\n+   * output device.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   */\n+  public abstract void flush();\n+\n+\n+  /**\n+   * Closes this <code>Handler</code> after having flushed\n+   * the buffers.  As soon as <code>close</code> has been called,\n+   * a <code>Handler</code> should not be used anymore. Attempts\n+   * to publish log records, to flush buffers, or to modify the\n+   * <code>Handler</code> in any other way may throw runtime\n+   * exceptions after calling <code>close</code>.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   */\n+  public abstract void close()\n+    throws SecurityException;\n+\n+\n+  /**\n+   * Returns the <code>Formatter</code> which will be used to\n+   * localize the text of log messages and to substitute\n+   * message parameters.  A <code>Handler</code> is encouraged,\n+   * but not required to actually use an assigned\n+   * <code>Formatter</code>.\n+   *\n+   * @return the <code>Formatter</code> being used, or\n+   *         <code>null</code> if this <code>Handler</code>\n+   *         does not use formatters and no formatter has\n+   *         ever been set by calling <code>setFormatter</code>.\n+   */\n+  public Formatter getFormatter()\n+  {\n+    return formatter;\n+  }\n+\n+\n+  /**\n+   * Sets the <code>Formatter</code> which will be used to\n+   * localize the text of log messages and to substitute\n+   * message parameters.  A <code>Handler</code> is encouraged,\n+   * but not required to actually use an assigned\n+   * <code>Formatter</code>.\n+   *\n+   * @param formatter the new <code>Formatter</code> to use.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   *\n+   * @throws NullPointerException if <code>formatter</code> is\n+   *         <code>null</code>.\n+   */\n+  public void setFormatter(Formatter formatter)\n+    throws SecurityException\n+  {\n+    LogManager.getLogManager().checkAccess();\n+    \n+    /* Throws a NullPointerException if formatter is null. */\n+    formatter.getClass();\n+\n+    this.formatter = formatter;\n+  }\n+\n+\n+  /**\n+   * Returns the character encoding which this handler uses for publishing\n+   * log records.\n+   *\n+   * @param encoding the name of a character encoding, or <code>null</code>\n+   *            for the default platform encoding.\n+   */\n+  public String getEncoding()\n+  {\n+    return encoding;\n+  }\n+\n+\n+  /**\n+   * Sets the character encoding which this handler uses for publishing\n+   * log records.  The encoding of a <code>Handler</code> must be\n+   * set before any log records have been published.\n+   *\n+   * @param encoding the name of a character encoding, or <code>null</code>\n+   *            for the default encoding.\n+   *\n+   * @exception SecurityException if a security manager exists and\n+   *            the caller is not granted the permission to control\n+   *            the logging infrastructure.\n+   *\n+   */\n+  public void setEncoding(String encoding)\n+    throws SecurityException, UnsupportedEncodingException\n+  {\n+    /* Should any developer ever change this implementation, they are\n+     * advised to have a look at StreamHandler.setEncoding(String),\n+     * which overrides this method without calling super.setEncoding.\n+     */\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Simple check for supported encodings. This is more expensive\n+     * than it could be, but this method is overwritten by StreamHandler\n+     * anyway.\n+     */\n+    if (encoding != null)\n+      new String(new byte[0], encoding);\n+\n+    this.encoding = encoding;\n+  }\n+\n+\n+  /**\n+   * Returns the <code>Filter</code> that currently controls which\n+   * log records are being published by this <code>Handler</code>.\n+   *\n+   * @return the currently active <code>Filter</code>, or\n+   *         <code>null</code> if no filter has been associated.\n+   *         In the latter case, log records are filtered purely\n+   *         based on their severity level.\n+   */\n+  public Filter getFilter()\n+  {\n+    return filter;\n+  }\n+\n+\n+  /**\n+   * Sets the <code>Filter</code> for controlling which\n+   * log records will be published by this <code>Handler</code>.\n+   *\n+   * @return the <code>Filter</code> to use, or\n+   *         <code>null</code> to filter log records purely based\n+   *         on their severity level.\n+   */\n+  public void setFilter(Filter filter)\n+    throws SecurityException\n+  {\n+    LogManager.getLogManager().checkAccess();\n+    this.filter = filter;\n+  }\n+\n+\n+  /**\n+   * Returns the <code>ErrorManager</code> that currently deals\n+   * with errors originating from this Handler.\n+   *\n+   * @exception SecurityException if a security manager exists and\n+   *            the caller is not granted the permission to control\n+   *            the logging infrastructure.\n+   */\n+  public ErrorManager getErrorManager()\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Developers wanting to change the subsequent code should\n+     * have a look at Handler.reportError -- it also can create\n+     * an ErrorManager, but does so without checking permissions\n+     * to control the logging infrastructure.\n+     */\n+    if (errorManager == null)\n+      errorManager = new ErrorManager();\n+\n+    return errorManager;\n+  }\n+\n+\n+  public void setErrorManager(ErrorManager manager)\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Make sure manager is not null. */\n+    manager.getClass();\n+\n+    this.errorManager = manager;\n+  }\n+\n+\n+  protected void reportError(String message, Exception ex, int code)\n+  {\n+    if (errorManager == null)\n+      errorManager = new ErrorManager();\n+\n+    errorManager.error(message, ex, code);\n+  }\n+\n+\n+  /**\n+   * Returns the severity level threshold for this <code>Handler</code>\n+   * All log records with a lower severity level will be discarded;\n+   * a log record of the same or a higher level will be published\n+   * unless an installed <code>Filter</code> decides to discard it.\n+   *\n+   * @return the severity level below which all log messages\n+   *         will be discarded.\n+   */\n+  public Level getLevel()\n+  {\n+    return level;\n+  }\n+\n+\n+  /**\n+   * Sets the severity level threshold for this <code>Handler</code>.\n+   * All log records with a lower severity level will be discarded;\n+   * a log record of the same or a higher level will be published\n+   * unless an installed <code>Filter</code> decides to discard it.\n+   *\n+   * @param level the severity level below which all log messages\n+   *              will be discarded.\n+   *\n+   * @exception SecurityException if a security manager exists and\n+   *            the caller is not granted the permission to control\n+   *            the logging infrastructure.\n+   *\n+   * @exception NullPointerException if <code>level</code> is\n+   *            <code>null</code>.\n+   */\n+  public void setLevel(Level level)\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Throw NullPointerException if level is null.  */\n+    level.getClass();\n+    this.level = level;\n+  }\n+\n+\n+  /**\n+   * Checks whether a <code>LogRecord</code> would be logged\n+   * if it was passed to this <code>Handler</code> for publication.\n+   *\n+   * <p>The <code>Handler</code> implementation considers a record as\n+   * loggable if its level is greater than or equal to the severity\n+   * level threshold.  In a second step, if a {@link Filter} has\n+   * been installed, its {@link Filter#isLoggable(LogRecord) isLoggable}\n+   * method is invoked. Subclasses of <code>Handler</code> can override\n+   * this method to impose their own constraints.\n+   *\n+   * @param record the <code>LogRecord</code> to be checked.\n+   *\n+   * @return <code>true</code> if <code>record</code> would\n+   *         be published by {@link #publish(LogRecord) publish},\n+   *         <code>false</code> if it would be discarded.\n+   *\n+   * @see #setLevel(Level)\n+   * @see #setFilter(Filter)\n+   * @see Filter#isLoggable(LogRecord)\n+   *\n+   * @throws NullPointerException if <code>record</code>\n+   *         is <code>null</code>.\n+   */\n+  public boolean isLoggable(LogRecord record)\n+  {\n+    if (record.getLevel().intValue() < level.intValue())\n+      return false;\n+    \n+    if (filter != null)\n+      return filter.isLoggable(record);\n+    else\n+      return true;\n+  }\n+}"}, {"sha": "d8987f6b5813fa2203f12fe9158a27b5de020b67", "filename": "libjava/java/util/logging/Level.java", "status": "added", "additions": 417, "deletions": 0, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLevel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLevel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLevel.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,417 @@\n+/* Level.java -- a class for indicating logging levels\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.ResourceBundle;\n+\n+\n+/**\n+ * A class for indicating logging levels.  A number of commonly used\n+ * levels is pre-defined (such as <code>java.util.logging.Level.INFO</code>),\n+ * and applications should utilize those whenever possible.  For specialized\n+ * purposes, however, applications can sub-class Level in order to define\n+ * custom logging levels.\n+ *\n+ * @author Sascha Brawer <brawer@acm.org>\n+ */\n+public class Level\n+  implements java.io.Serializable\n+{\n+  /* The integer values are the same as in the Sun J2SE 1.4.\n+   * They have been obtained with a test program. In J2SE 1.4.1,\n+   * Sun has amended the API documentation; these values are now\n+   * publicly documented.\n+   */\n+\n+  /**\n+   * The <code>OFF</code> level is used as a threshold for filtering\n+   * log records, meaning that no message should be logged.\n+   *\n+   * @see Logger#setLevel(java.util.logging.Level)\n+   */\n+  public static final Level OFF = new Level (\"OFF\", Integer.MAX_VALUE);\n+\n+  /**\n+   * Log records whose level is <code>SEVERE</code> indicate a serious\n+   * failure that prevents normal program execution.  Messages at this\n+   * level should be understandable to an inexperienced, non-technical\n+   * end user.  Ideally, they explain in simple words what actions the\n+   * user can take in order to resolve the problem.\n+   */\n+  public static final Level SEVERE = new Level (\"SEVERE\", 1000);\n+\n+\n+  /**\n+   * Log records whose level is <code>WARNING</code> indicate a\n+   * potential problem that does not prevent normal program execution.\n+   * Messages at this level should be understandable to an\n+   * inexperienced, non-technical end user.  Ideally, they explain in\n+   * simple words what actions the user can take in order to resolve\n+   * the problem.\n+   */\n+  public static final Level WARNING = new Level (\"WARNING\", 900);\n+\n+\n+  /**\n+   * Log records whose level is <code>INFO</code> are used in purely\n+   * informational situations that do not constitute serious errors or\n+   * potential problems. In the default logging configuration, INFO\n+   * messages will be written to the system console.  For this reason,\n+   * the INFO level should be used only for messages that are\n+   * important to end users and system administrators.  Messages at\n+   * this level should be understandable to an inexperienced,\n+   * non-technical user.\n+   */\n+  public static final Level INFO = new Level (\"INFO\", 800);\n+\n+\n+  /**\n+   * Log records whose level is <code>CONFIG</code> are used for\n+   * describing the static configuration, for example the windowing\n+   * environment, the operating system version, etc.\n+   */\n+  public static final Level CONFIG = new Level (\"CONFIG\", 700);\n+\n+\n+  /**\n+   * Log records whose level is <code>FINE</code> are typically used\n+   * for messages that are relevant for developers using\n+   * the component generating log messages.  Examples include minor,\n+   * recoverable failures, or possible inefficiencies.\n+   */\n+  public static final Level FINE = new Level (\"FINE\", 500);\n+\n+\n+  /**\n+   * Log records whose level is <code>FINER</code> are intended for\n+   * rather detailed tracing, for example entering a method, returning\n+   * from a method, or throwing an exception.\n+   */\n+  public static final Level FINER = new Level (\"FINER\", 400);\n+\n+\n+  /**\n+   * Log records whose level is <code>FINEST</code> are used for\n+   * highly detailed tracing, for example to indicate that a certain\n+   * point inside the body of a method has been reached.\n+   */\n+  public static final Level FINEST = new Level (\"FINEST\", 300);\n+\n+\n+  /**\n+   * The <code>ALL</code> level is used as a threshold for filtering\n+   * log records, meaning that every message should be logged.\n+   *\n+   * @see Logger#setLevel(java.util.logging.Level)\n+   */\n+  public static final Level ALL = new Level (\"ALL\", Integer.MIN_VALUE);\n+\n+\n+  private static final Level[] knownLevels = {\n+    ALL, FINEST, FINER, FINE, CONFIG, INFO, WARNING, SEVERE, OFF\n+  };\n+\n+\n+  /**\n+   * The name of the Level without localizing it, for example\n+   * \"WARNING\".\n+   */\n+  private String name;\n+\n+\n+  /**\n+   * The integer value of this <code>Level</code>.\n+   */\n+  private int value;\n+\n+\n+  /**\n+   * The name of the resource bundle used for localizing the level\n+   * name, or <code>null</code> if the name does not undergo\n+   * localization.\n+   */\n+  private String resourceBundleName;\n+\n+\n+  /**\n+   * Creates a logging level given a name and an integer value.\n+   * It rarely is necessary to create custom levels,\n+   * as most applications should be well served with one of the\n+   * standard levels such as <code>Level.CONFIG</code>,\n+   * <code>Level.INFO</code>, or <code>Level.FINE</code>.\n+   *\n+   * @param name the name of the level.\n+   *\n+   * @param value the integer value of the level.  Please note\n+   *     that the Java<small><sup>TM</sup></small>\n+   *     Logging API does not specify integer\n+   *\t values for standard levels (such as\n+   *\t Level.FINE).  Therefore, a custom\n+   *\t level should pass an integer value that\n+   *\t is calculated at run-time, e.g.\n+   *\t <code>(Level.FINE.intValue() + Level.CONFIG.intValue())\n+   *\t / 2</code> for a level between FINE and CONFIG.\n+   */\n+  protected Level(String name, int value)\n+  {\n+    this(name, value, null);\n+  }\n+\n+\n+  /**\n+   * Create a logging level given a name, an integer value and a name\n+   * of a resource bundle for localizing the level name.  It rarely\n+   * is necessary to create custom levels, as most applications\n+   * should be well served with one of the standard levels such as\n+   * <code>Level.CONFIG</code>, <code>Level.INFO</code>, or\n+   * <code>Level.FINE</code>.\n+   *\n+   * @param name the name of the level.\n+   *\n+   * @param value the integer value of the level.  Please note\n+   *        that the Java<small><sup>TM</sup></small>\n+   *\t    Logging API does not specify integer\n+   *\t    values for standard levels (such as\n+   *\t    Level.FINE).  Therefore, a custom\n+   *\t    level should pass an integer value that\n+   *\t    is calculated at run-time, e.g.\n+   *\t    <code>(Level.FINE.intValue() + Level.CONFIG.intValue())\n+   *\t    / 2</code> for a level between FINE and CONFIG.\n+   *\n+   * @param resourceBundleName the name of a resource bundle\n+   *       for localizing the level name, or <code>null</code>\n+   *       if the name does not need to be localized.\n+   */\n+  protected Level(String name, int value, String resourceBundleName)\n+  {\n+    this.name = name;\n+    this.value = value;\n+    this.resourceBundleName = resourceBundleName;\n+  }\n+\n+\n+  static final long serialVersionUID = -8176160795706313070L;\n+\n+\n+  /**\n+   * Checks whether the Level has the same intValue as one of the\n+   * pre-defined levels.  If so, the pre-defined level object is\n+   * returned.\n+   *\n+   * <br/>Since the resource bundle name is not taken into\n+   * consideration, it is possible to resolve Level objects that have\n+   * been de-serialized by another implementation, even if the other\n+   * implementation uses a different resource bundle for localizing\n+   * the names of pre-defined levels.\n+   */\n+  private Object readResolve()\n+  {\n+    for (int i = 0; i < knownLevels.length; i++)\n+      if (value == knownLevels[i].intValue())\n+\treturn knownLevels[i];\n+\n+    return this;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the resource bundle used for localizing the\n+   * level name.\n+   *\n+   * @return the name of the resource bundle used for localizing the\n+   * level name, or <code>null</code> if the name does not undergo\n+   * localization.\n+   */\n+  public String getResourceBundleName()\n+  {\n+    return resourceBundleName;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the Level without localizing it, for example\n+   * \"WARNING\".\n+   */\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the Level after localizing it, for example\n+   * \"WARNUNG\".\n+   */\n+  public String getLocalizedName()\n+  {\n+    String localizedName = null;\n+\n+    if (resourceBundleName != null)\n+    {\n+      try\n+      {\n+        ResourceBundle b = ResourceBundle.getBundle(resourceBundleName);\n+\tlocalizedName = b.getString(name);\n+      }\n+      catch (Exception _)\n+      {\n+      }\n+    }\n+\n+    if (localizedName != null)\n+      return localizedName;\n+    else\n+      return name;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the Level without localizing it, for example\n+   * \"WARNING\".\n+   */\n+  public final String toString()\n+  {\n+    return getName();\n+  }\n+\n+\n+  /**\n+   * Returns the integer value of the Level.\n+   */\n+  public final int intValue()\n+  {\n+    return value;\n+  }\n+\n+\n+  /**\n+   * Returns one of the standard Levels given either its name or its\n+   * integer value.  Custom subclasses of Level will not be returned\n+   * by this method.\n+   *\n+   * @throws IllegalArgumentException if <code>name</code> is neither\n+   * the name nor the integer value of one of the pre-defined standard\n+   * logging levels.\n+   *\n+   * @throws NullPointerException if <code>name</code> is null.\n+   *\n+   */\n+  public static Level parse(String name)\n+    throws IllegalArgumentException\n+  {\n+    /* This will throw a NullPointerException if name is null,\n+     * as required by the API specification.\n+     */\n+    name = name.intern();\n+\n+    for (int i = 0; i < knownLevels.length; i++)\n+    {\n+      if (name == knownLevels[i].name)\n+\treturn knownLevels[i];\n+    }\n+    \n+    try\n+    {\n+      int num = Integer.parseInt(name);\n+      for (int i = 0; i < knownLevels.length; i++)\n+\tif (num == knownLevels[i].value)\n+\t  return knownLevels[i];\n+    }\n+    catch (NumberFormatException _)\n+    {\n+    }\n+\n+    String msg = \"Not the name of a standard logging level: \\\"\" + name + \"\\\"\";\n+    throw new IllegalArgumentException(msg);\n+  }\n+\n+\n+  /**\n+   * Checks whether this Level's integer value is equal to that of\n+   * another object.\n+   *\n+   * @return <code>true</code> if <code>other</code> is an instance of\n+   *\t <code>java.util.logging.Level</code> and has the same integer\n+   * value, <code>false</code> otherwise.\n+   */\n+  public boolean equals(Object other)\n+  {\n+    if (!(other instanceof Level))\n+      return false;\n+\n+    return value == ((Level) other).value;\n+  }\n+\n+\n+  /**\n+   * Returns a hash code for this Level which is based on its numeric\n+   * value.\n+   */\n+  public int hashCode()\n+  {\n+    return value;\n+  }  \n+\n+\n+  /**\n+   * Determines whether or not this Level is one of the standard\n+   * levels specified in the Logging API.\n+   *\n+   * <p>This method is package-private because it is not part\n+   * of the logging API specification.  However, an XMLFormatter\n+   * is supposed to emit the numeric value for a custom log\n+   * level, but the name for a pre-defined level. It seems\n+   * cleaner to put this method to Level than to write some\n+   * procedural code for XMLFormatter.\n+   *\n+   * @return <code>true</code> if this Level is a standard level,\n+   *         <code>false</code> otherwise.\n+   */\n+  final boolean isStandardLevel()\n+  {\n+    for (int i = 0; i < knownLevels.length; i++)\n+      if (knownLevels[i] == this)\n+\treturn true;\n+\n+    return false;\n+  }\n+}\n+"}, {"sha": "d6536e71d1cd332082d4bf17fb53ae055aea404a", "filename": "libjava/java/util/logging/LogManager.java", "status": "added", "additions": 821, "deletions": 0, "changes": 821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogManager.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,821 @@\n+/* LogManager.java\n+   -- a class for maintaining Loggers and managing configuration\n+      properties\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+package java.util.logging;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * The <code>LogManager</code> maintains a hierarchical namespace\n+ * of Logger objects and manages properties for configuring the logging\n+ * framework. There exists only one single <code>LogManager</code>\n+ * per virtual machine. This instance can be retrieved using the\n+ * static method {@link #getLogManager()}.\n+ *\n+ * <p><strong>Configuration Process:</strong> The global LogManager\n+ * object is created and configured when the class\n+ * <code>java.util.logging.LogManager</code> is initialized.\n+ * The configuration process includes the subsequent steps:\n+ *\n+ * <ol>\n+ * <li>If the system property <code>java.util.logging.manager</code>\n+ *     is set to the name of a subclass of\n+ *     <code>java.util.logging.LogManager</code>, an instance of\n+ *     that subclass is created and becomes the global LogManager.\n+ *     Otherwise, a new instance of LogManager is created.</li>\n+ *     \n+ * <li>The <code>LogManager</code> constructor tries to create\n+ *     a new instance of the class specified by the system\n+ *     property <code>java.util.logging.config.class</code>.\n+ *     Typically, the constructor of this class will call\n+ *     <code>LogManager.getLogManager().readConfiguration(java.io.InputStream)</code>\n+ *     for configuring the logging framework.\n+ *     The configuration process stops at this point if\n+ *     the system property <code>java.util.logging.config.class</code>\n+ *     is set (irrespective of whether the class constructor\n+ *     could be called or an exception was thrown).</li>\n+ *\n+ * <li>If the system property <code>java.util.logging.config.class</code>\n+ *     is <em>not</em> set, the configuration parameters are read in from\n+ *     a file and passed to\n+ *     {@link #readConfiguration(java.io.InputStream)}.\n+ *     The name and location of this file are specified by the system\n+ *     property <code>java.util.logging.config.file</code>.</li>\n+ *\n+ * <li>If the system property <code>java.util.logging.config.file</code>\n+ *     is not set, however, the contents of the URL\n+ *     \"{gnu.classpath.home.url}/logging.properties\" are passed to\n+ *     {@link #readConfiguration(java.io.InputStream)}.\n+ *     Here, \"{gnu.classpath.home.url}\" stands for the value of\n+ *     the system property <code>gnu.classpath.home.url</code>.</li>\n+ * </ol>\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class LogManager\n+{\n+  /**\n+   * The singleton LogManager instance.\n+   */\n+  private static LogManager logManager;\n+  \n+\n+  /**\n+   * The registered named loggers; maps the name of a Logger to\n+   * a WeakReference to it.\n+   */\n+  private Map loggers;\n+\n+  final Logger rootLogger;\n+\n+\n+  /**\n+   * The properties for the logging framework which have been\n+   * read in last.\n+   */\n+  private Properties properties;\n+\n+  /**\n+   * A delegate object that provides support for handling\n+   * PropertyChangeEvents.  The API specification does not\n+   * mention which bean should be the source in the distributed\n+   * PropertyChangeEvents, but Mauve test code has determined that\n+   * the Sun J2SE 1.4 reference implementation uses the LogManager\n+   * class object. This is somewhat strange, as the class object\n+   * is not the bean with which listeners have to register, but\n+   * there is no reason for the GNU Classpath implementation to\n+   * behave differently from the reference implementation in\n+   * this case.\n+   */\n+  private final PropertyChangeSupport pcs\n+    = new PropertyChangeSupport(/* source bean */ LogManager.class);\n+\n+  protected LogManager()\n+  {\n+    if (logManager != null)\n+      throw new IllegalStateException(\n+        \"there can be only one LogManager; use LogManager.getLogManager()\");\n+\n+    logManager = this;\n+    loggers = new java.util.HashMap();\n+    rootLogger = new Logger(\"\", null);\n+    addLogger(rootLogger);\n+    \n+    /* Make sure that Logger.global has the rootLogger as its parent.\n+     *\n+     * Logger.global is set during class initialization of Logger,\n+     * which may or may not be before this code is being executed.\n+     * For example, on the Sun 1.3.1 and 1.4.0 JVMs, Logger.global\n+     * has been set before this code is being executed. In contrast,\n+     * Logger.global still is null on GCJ 3.2.  Since the LogManager\n+     * and Logger classes are mutually dependent, both behaviors are\n+     * correct.\n+     *\n+     * This means that we cannot depend on Logger.global to have its\n+     * value when this code executes, although that variable is final.\n+     * Since Logger.getLogger will always return the same logger for\n+     * the same name, the subsequent line works fine irrespective of\n+     * the order in which classes are initialized.\n+     */\n+    Logger.getLogger(\"global\").setParent(rootLogger);\n+  }\n+\n+\n+  /**\n+   * Returns the globally shared LogManager instance.\n+   */\n+  public static LogManager getLogManager()\n+  {\n+    return logManager;\n+  }\n+\n+  static\n+  {\n+    makeLogManager();\n+    \n+    /* The Javadoc description of the class explains\n+     * what is going on here.\n+     */\n+    Object configurator = createInstance(\n+      System.getProperty(\"java.util.logging.config.class\"),\n+      /* must be instance of */ Object.class);\n+\n+    try\n+    {\n+      if (configurator == null)\n+        getLogManager().readConfiguration();\n+    }\n+    catch (IOException ex)\n+    {\n+      /* FIXME: Is it ok to ignore exceptions here? */\n+    }\n+  };\n+  \n+\n+  private static LogManager makeLogManager()\n+  {\n+    String      managerClassName;\n+    LogManager  manager;\n+\n+    managerClassName = System.getProperty(\"java.util.logging.manager\");\n+    manager = (LogManager) createInstance(managerClassName, LogManager.class);\n+    if (manager != null)\n+      return manager;\n+\n+    if (managerClassName != null)\n+      System.err.println(\"WARNING: System property \\\"java.util.logging.manager\\\"\"\n+\t\t\t + \" should be the name of a subclass of java.util.logging.LogManager\");\n+\n+    return new LogManager();\n+  }\n+\n+\n+  /**\n+   * Registers a listener which will be notified when the\n+   * logging properties are re-read.\n+   */\n+  public synchronized void addPropertyChangeListener(PropertyChangeListener listener)\n+  {\n+    /* do not register null. */\n+    listener.getClass();\n+\n+    pcs.addPropertyChangeListener(listener);\n+  }\n+\n+\n+  /**\n+   * Unregisters a listener.\n+   *\n+   * If <code>listener</code> has not been registered previously,\n+   * nothing happens.  Also, no exception is thrown if\n+   * <code>listener</code> is <code>null</code>.\n+   */\n+  public synchronized void removePropertyChangeListener(PropertyChangeListener listener)\n+  {\n+    if (listener != null)\n+      pcs.removePropertyChangeListener(listener);\n+  }\n+\n+\n+  /**\n+   * Adds a named logger.  If a logger with the same name has\n+   * already been registered, the method returns <code>false</code>\n+   * without adding the logger.\n+   *\n+   * <p>The <code>LogManager</code> only keeps weak references\n+   * to registered loggers.  Therefore, names can become available\n+   * after automatic garbage collection.\n+   *\n+   * @param logger the logger to be added.\n+   *\n+   * @return <code>true<code>if <code>logger</code> was added,\n+   *         <code>false</code> otherwise.\n+   *\n+   * @throws NullPointerException if <code>name<code> is\n+   *         <code>null</code>.\n+   */\n+  public synchronized boolean addLogger(Logger logger)\n+  {\n+    /* To developers thinking about to remove the 'synchronized'\n+     * declaration from this method: Please read the comment\n+     * in java.util.logging.Logger.getLogger(String, String)\n+     * and make sure that whatever you change wrt. synchronization\n+     * does not endanger thread-safety of Logger.getLogger.\n+     * The current implementation of Logger.getLogger assumes\n+     * that LogManager does its synchronization on the globally\n+     * shared instance of LogManager.\n+     */\n+\n+    String name;\n+    WeakReference  ref;\n+\n+    /* This will throw a NullPointerException if logger is null,\n+     * as required by the API specification.\n+     */\n+    name = logger.getName();\n+\n+    ref = (WeakReference) loggers.get(name);\n+    if (ref != null)\n+    {\n+      if (ref.get() != null)\n+\treturn false;\n+\n+      /* There has been a logger under this name in the past,\n+       * but it has been garbage collected.\n+       */\n+      loggers.remove(ref);\n+    }\n+\n+    /* Adding a named logger requires a security permission. */\n+    if ((name != null) && !name.equals(\"\"))\n+      checkAccess();\n+\n+    Logger parent = findAncestor(logger);\n+    loggers.put(name, new WeakReference(logger));\n+    if (parent != logger.getParent())\n+      logger.setParent(parent);\n+\n+    /* It can happen that existing loggers should be children of\n+     * the newly added logger. For example, assume that there\n+     * already exist loggers under the names \"\", \"foo\", and \"foo.bar.baz\".\n+     * When adding \"foo.bar\", the logger \"foo.bar.baz\" should change\n+     * its parent to \"foo.bar\".\n+     */\n+    if (parent != rootLogger)\n+    {\n+      for (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n+      {\n+        Logger possChild = (Logger) ((WeakReference) loggers.get(iter.next())).get();\n+        if ((possChild == null) || (possChild == logger) || (possChild.getParent() != parent))\n+\t  continue;\n+\n+\tif (!possChild.getName().startsWith(name))\n+\t  continue;\n+\n+\tif (possChild.getName().charAt(name.length()) != '.')\n+\t  continue;\n+\n+\tpossChild.setParent(logger);\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Finds the closest ancestor for a logger among the currently\n+   * registered ones.  For example, if the currently registered\n+   * loggers have the names \"\", \"foo\", and \"foo.bar\", the result for\n+   * \"foo.bar.baz\" will be the logger whose name is \"foo.bar\".\n+   *\n+   * @param child a logger for whose name no logger has been\n+   *        registered.\n+   *\n+   * @return the closest ancestor for <code>child</code>,\n+   *         or <code>null</code> if <code>child</code>\n+   *         is the root logger.\n+   *\n+   * @throws NullPointerException if <code>child</code>\n+   *         is <code>null</code>.\n+   */\n+  private synchronized Logger findAncestor(Logger child)\n+  {\n+    String childName = child.getName();\n+    Logger best = rootLogger;\n+    int    bestNameLength = 0;\n+\n+    Logger  cand;\n+    String  candName;\n+    int     candNameLength;\n+\n+    if (child == rootLogger)\n+      return null;\n+\n+    for (Iterator iter = loggers.keySet().iterator(); iter.hasNext();)\n+    {\n+      candName = (String) iter.next();\n+      candNameLength = candName.length();\n+\n+      if ((candNameLength > bestNameLength)\n+\t  && childName.startsWith(candName)\n+\t  && (childName.charAt(candNameLength) == '.'))\n+      {\n+        cand = (Logger) ((WeakReference) loggers.get(candName)).get();\n+\tif ((cand == null) || (cand == child))\n+\t  continue;\n+\n+\tbestNameLength = candName.length();\n+\tbest = cand;\n+      }\n+    }\n+\n+    return best;\n+  }\n+\n+\n+  /**\n+   * Returns a Logger given its name.\n+   *\n+   * @param name the name of the logger.\n+   *\n+   * @return a named Logger, or <code>null</code> if there is no\n+   *     logger with that name.\n+   *\n+   * @throw java.lang.NullPointerException if <code>name</code>\n+   *     is <code>null</code>.\n+   */\n+  public synchronized Logger getLogger(String name)\n+  {\n+    WeakReference  ref;\n+\n+    /* Throw a NullPointerException if name is null. */\n+    name.getClass();\n+\n+    ref = (WeakReference) loggers.get(name);\n+    if (ref != null)\n+      return (Logger) ref.get();\n+    else\n+      return null;\n+  }\n+\n+\n+  /**\n+   * Returns an Enumeration of currently registered Logger names.\n+   * Since other threads can register loggers at any time, the\n+   * result could be different any time this method is called.\n+   *\n+   * @return an Enumeration with the names of the currently\n+   *    registered Loggers.\n+   */\n+  public synchronized Enumeration getLoggerNames()\n+  {\n+    return Collections.enumeration(loggers.keySet());\n+  }\n+\n+\n+  /**\n+   * Resets the logging configuration by removing all handlers for\n+   * registered named loggers and setting their level to <code>null</code>.\n+   * The level of the root logger will be set to <code>Level.INFO</code>.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   */\n+  public synchronized void reset()\n+    throws SecurityException\n+  {\n+    /* Throw a SecurityException if the caller does not have the\n+     * permission to control the logging infrastructure.\n+     */\n+    checkAccess();\n+\n+    properties = new Properties();\n+\n+    Iterator iter = loggers.values().iterator();\n+    while (iter.hasNext())\n+    {\n+      WeakReference  ref;\n+      Logger         logger;\n+\n+      ref = (WeakReference) iter.next();\n+      if (ref != null)\n+      {\n+\tlogger = (Logger) ref.get();\n+\n+\tif (logger == null)\n+\t  iter.remove();\n+\telse if (logger != rootLogger)\n+\t  logger.setLevel(null);\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.INFO);\n+  }\n+\n+\n+  /**\n+   * Configures the logging framework by reading a configuration file.\n+   * The name and location of this file are specified by the system\n+   * property <code>java.util.logging.config.file</code>.  If this\n+   * property is not set, the URL\n+   * \"{gnu.classpath.home.url}/logging.properties\" is taken, where\n+   * \"{gnu.classpath.home.url}\" stands for the value of the system\n+   * property <code>gnu.classpath.home.url</code>.\n+   *\n+   * <p>The task of configuring the framework is then delegated to\n+   * {@link #readConfiguration(java.io.InputStream)}, which will\n+   * notify registered listeners after having read the properties.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure, or if the caller is\n+   *         not granted the permission to read the configuration\n+   *         file.\n+   *\n+   * @throws IOException if there is a problem reading in the\n+   *         configuration file.\n+   */\n+  public synchronized void readConfiguration()\n+    throws IOException, SecurityException\n+  {\n+    String       path;\n+    InputStream  inputStream;\n+\n+    path = System.getProperty(\"java.util.logging.config.file\");\n+    if ((path == null) || (path.length() == 0))\n+    {\n+      String url = (System.getProperty(\"gnu.classpath.home.url\")\n+\t\t    + \"/logging.properties\");\n+      inputStream = new URL(url).openStream();\n+    }\n+    else\n+    {\n+      inputStream = new java.io.FileInputStream(path);\n+    }\n+\n+    try\n+    {\n+      readConfiguration(inputStream);\n+    }\n+    finally\n+    {\n+      /* Close the stream in order to save\n+       * resources such as file descriptors.\n+       */\n+      inputStream.close();\n+    }\n+  }\n+\n+\n+  public synchronized void readConfiguration(InputStream inputStream)\n+    throws IOException, SecurityException\n+  {\n+    Properties   newProperties;\n+    Enumeration  keys;\n+\n+    checkAccess();\n+    newProperties = new Properties();\n+    newProperties.load(inputStream);\n+    this.properties = newProperties;    \n+    keys = newProperties.propertyNames();\n+\n+    while (keys.hasMoreElements())\n+    {\n+      String key = (String) keys.nextElement();\n+      String value = newProperties.getProperty(key);\n+\n+      if (value == null)\n+\tcontinue;\n+\n+      if (key.endsWith(\".level\"))\n+      {\n+\tString loggerName = key.substring(0, key.length() - 6);\n+\tLogger logger = getLogger(loggerName);\n+\tif (logger != null)\n+\t{\n+\t  try\n+\t  {\n+\t    logger.setLevel(Level.parse(value));\n+\t  }\n+\t  catch (Exception _)\n+\t  {\n+\t  }\n+\t  continue;\n+\t}\n+      }\n+    }\n+\n+    /* The API specification does not talk about the\n+     * property name that is distributed with the\n+     * PropertyChangeEvent.  With test code, it could\n+     * be determined that the Sun J2SE 1.4 reference\n+     * implementation uses null for the property name.\n+     */\n+    pcs.firePropertyChange(null, null, null);\n+  }\n+\n+  \n+  /**\n+   * Returns the value of a configuration property as a String.\n+   */\n+  public synchronized String getProperty(String name)\n+  {\n+    if (properties != null)\n+      return properties.getProperty(name);\n+    else\n+      return null;\n+  }\n+\n+\n+  /**\n+   * Returns the value of a configuration property as an integer.\n+   * This function is a helper used by the Classpath implementation\n+   * of java.util.logging, it is <em>not</em> specified in the\n+   * logging API.\n+   *\n+   * @param name the name of the configuration property.\n+   *\n+   * @param defaultValue the value that will be returned if the\n+   *        property is not defined, or if its value is not an integer\n+   *        number.\n+   */\n+  static int getIntProperty(String name, int defaultValue)\n+  {\n+    try\n+    {\n+      return Integer.parseInt(getLogManager().getProperty(name));\n+    }\n+    catch (Exception ex)\n+    {\n+      return defaultValue;\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns the value of a configuration property as an integer,\n+   * provided it is inside the acceptable range.\n+   * This function is a helper used by the Classpath implementation\n+   * of java.util.logging, it is <em>not</em> specified in the\n+   * logging API.\n+   *\n+   * @param name the name of the configuration property.\n+   *\n+   * @param minValue the lowest acceptable value.\n+   *\n+   * @param maxValue the highest acceptable value.\n+   *\n+   * @param defaultValue the value that will be returned if the\n+   *        property is not defined, or if its value is not an integer\n+   *        number, or if it is less than the minimum value,\n+   *        or if it is greater than the maximum value.\n+   */\n+  static int getIntPropertyClamped(String name, int defaultValue,\n+\t\t\t\t   int minValue, int maxValue)\n+  {\n+    int val = getIntProperty(name, defaultValue);\n+    if ((val < minValue) || (val > maxValue))\n+      val = defaultValue;\n+    return val;\n+  }\n+\n+\n+  /**\n+   * Returns the value of a configuration property as a boolean.\n+   * This function is a helper used by the Classpath implementation\n+   * of java.util.logging, it is <em>not</em> specified in the\n+   * logging API.\n+   *\n+   * @param name the name of the configuration property.\n+   *\n+   * @param defaultValue the value that will be returned if the\n+   *        property is not defined, or if its value is neither\n+   *        <code>\"true\"</code> nor <code>\"false\"</code>.\n+   */\n+  static boolean getBooleanProperty(String name, boolean defaultValue)\n+  {\n+    try\n+    {\n+      return (new Boolean(getLogManager().getProperty(name)))\n+        .booleanValue();\n+    }\n+    catch (Exception ex)\n+    {\n+      return defaultValue;\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns the value of a configuration property as a Level.\n+   * This function is a helper used by the Classpath implementation\n+   * of java.util.logging, it is <em>not</em> specified in the\n+   * logging API.\n+   *\n+   * @param propertyName the name of the configuration property.\n+   *\n+   * @param defaultValue the value that will be returned if the\n+   *        property is not defined, or if\n+   *        {@link Level.parse(java.lang.String)} does not like\n+   *        the property value.\n+   */\n+  static Level getLevelProperty(String propertyName, Level defaultValue)\n+  {\n+    try\n+    {\n+      return Level.parse(getLogManager().getProperty(propertyName));\n+    }\n+    catch (Exception ex)\n+    {\n+      return defaultValue;\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns the value of a configuration property as a Class.\n+   * This function is a helper used by the Classpath implementation\n+   * of java.util.logging, it is <em>not</em> specified in the\n+   * logging API.\n+   *\n+   * @param propertyName the name of the configuration property.\n+   *\n+   * @param defaultValue the value that will be returned if the\n+   *        property is not defined, or if it does not specify\n+   *        the name of a loadable class.\n+   */\n+  static final Class getClassProperty(String propertyName, Class defaultValue)\n+  {\n+    Class usingClass = null;\n+\n+    try\n+    {\n+      String propertyValue = logManager.getProperty(propertyName);\n+      if (propertyValue != null)\n+        usingClass = Class.forName(propertyValue);\n+      if (usingClass != null)\n+        return usingClass;\n+    }\n+    catch (Exception _)\n+    {\n+    }\n+\n+    return defaultValue;\n+  }\n+\n+\n+  static final Object getInstanceProperty(String propertyName,\n+\t\t\t\t\t  Class ofClass,\n+\t\t\t\t\t  Class defaultClass)\n+  {\n+    Class klass = getClassProperty(propertyName, defaultClass);\n+    if (klass == null)\n+      return null;\n+\n+    try\n+    {\n+      Object obj = klass.newInstance();\n+      if (ofClass.isInstance(obj))\n+\treturn obj;\n+    }\n+    catch (Exception _)\n+    {\n+    }\n+\n+    if (defaultClass == null)\n+      return null;\n+\n+    try\n+    {\n+      return defaultClass.newInstance();\n+    }\n+    catch (java.lang.InstantiationException ex)\n+    {\n+      throw new RuntimeException(ex.getMessage());\n+    }\n+    catch (java.lang.IllegalAccessException ex)\n+    {\n+      throw new RuntimeException(ex.getMessage());\n+    }\n+  }\n+\n+\n+  /**\n+   * An instance of <code>LoggingPermission(\"control\")</code>\n+   * that is shared between calls to <code>checkAccess()</code>.\n+   */\n+  private static final LoggingPermission controlPermission\n+    = new LoggingPermission(\"control\", null);\n+\n+\n+  /**\n+   * Checks whether the current security context allows changing\n+   * the configuration of the logging framework.  For the security\n+   * context to be trusted, it has to be granted\n+   * a LoggingPermission(\"control\").\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   */\n+  public void checkAccess()\n+    throws SecurityException\n+  {\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkPermission(controlPermission);\n+  }\n+\n+\n+  /** \n+   * Creates a new instance of a class specified by name.\n+   *\n+   * @param className the name of the class of which a new instance\n+   *        should be created.\n+   *       \n+   * @param ofClass the class to which the new instance should\n+   *        be either an instance or an instance of a subclass.\n+   *        FIXME: This description is just terrible.\n+   *\n+   * @return the new instance, or <code>null</code> if\n+   *         <code>className</code> is <code>null</code>, if no class\n+   *         with that name could be found, if there was an error\n+   *         loading that class, or if the constructor of the class\n+   *         has thrown an exception.\n+   */\n+  static final Object createInstance(String className, Class ofClass)\n+  {\n+    Class   klass;\n+\n+    if ((className == null) || (className.length() == 0))\n+      return null;\n+\n+    try\n+    {\n+      klass = Class.forName(className);\n+      if (!ofClass.isAssignableFrom(klass))\n+\treturn null;\n+\n+      return klass.newInstance();\n+    }\n+    catch (Exception _)\n+    {\n+      return null;\n+    }\n+    catch (java.lang.LinkageError _)\n+    {\n+      return null;\n+    }\n+  }\n+}"}, {"sha": "9fd6cd878f79d3187286ba7d20fcde1e2cfa396c", "filename": "libjava/java/util/logging/LogRecord.java", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogRecord.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogRecord.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogRecord.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,675 @@\n+/* LogRecord.java\n+   -- a class for the state associated with individual logging events\n+\n+Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.ResourceBundle;\n+\n+\n+/**\n+ * A <code>LogRecord</code> contains the state for an individual\n+ * event to be logged.\n+ *\n+ * <p>As soon as a LogRecord instance has been handed over to the\n+ * logging framework, applications should not manipulate it anymore.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class LogRecord\n+  implements java.io.Serializable\n+{\n+  /**\n+   * The severity level of this <code>LogRecord</code>.\n+   */\n+  private Level      level;\n+\n+\n+  /**\n+   * The sequence number of this <code>LogRecord</code>.\n+   */\n+  private long       sequenceNumber;\n+\n+\n+  /**\n+   * The name of the class that issued the logging request, or\n+   * <code>null</code> if this information could not be obtained.\n+   */\n+  private String     sourceClassName;\n+\n+\n+  /**\n+   * The name of the method that issued the logging request, or\n+   * <code>null</code> if this information could not be obtained.\n+   */\n+  private String sourceMethodName;\n+\n+\n+  /**\n+   * The message for this <code>LogRecord</code> before\n+   * any localization or formatting.\n+   */\n+  private String message;\n+\n+\n+  /**\n+   * An identifier for the thread in which this <code>LogRecord</code>\n+   * was created.  The identifier is not necessarily related to any\n+   * thread identifiers used by the operating system.\n+   */\n+  private int threadID;\n+\n+\n+  /**\n+   * The time when this <code>LogRecord</code> was created,\n+   * in milliseconds since the beginning of January 1, 1970.\n+   */\n+  private long millis;\n+\n+\n+  /**\n+   * The Throwable associated with this <code>LogRecord</code>, or\n+   * <code>null</code> if the logged event is not related to an\n+   * exception or error.\n+   */\n+  private Throwable thrown;\n+\n+\n+  /**\n+   * The name of the logger where this <code>LogRecord</code> has\n+   * originated, or <code>null</code> if this <code>LogRecord</code>\n+   * does not originate from a <code>Logger</code>.\n+   */\n+  private String  loggerName;\n+\n+\n+  /**\n+   * The name of the resource bundle used for localizing log messages,\n+   * or <code>null</code> if no bundle has been specified.\n+   */\n+  private String resourceBundleName;\n+\n+  private transient Object[] parameters;\n+\n+  private transient ResourceBundle bundle;\n+\n+\n+  /**\n+   * Constructs a <code>LogRecord</code> given a severity level and\n+   * an unlocalized message text.  In addition, the sequence number,\n+   * creation time (as returned by <code>getMillis()</code>) and\n+   * thread ID are assigned. All other properties are set to\n+   * <code>null</code>.\n+   *\n+   * @param level the severity level, for example <code>Level.WARNING</code>.\n+   *\n+   * @param message the message text (which will be used as key\n+   *                for looking up the localized message text\n+   *                if a resource bundle has been associated). \n+   */\n+  public LogRecord(Level level, String message)\n+  {\n+    this.level = level;\n+    this.message = message;\n+    this.millis = System.currentTimeMillis();\n+\n+    /* A subclass of java.lang.Thread could override hashCode(),\n+     * in which case the result would not be guaranteed anymore\n+     * to be unique among all threads.  While System.identityHashCode\n+     * is not necessarily unique either, it at least cannot be\n+     * overridden by user code.  However, is might be a good idea\n+     * to use something better for generating thread IDs.\n+     */\n+    this.threadID = System.identityHashCode(Thread.currentThread());\n+\n+    sequenceNumber = allocateSeqNum();\n+  }\n+\n+\n+  /**\n+   * Determined with the serialver tool of the Sun J2SE 1.4.\n+   */\n+  static final long serialVersionUID = 5372048053134512534L;\n+\n+  private void readObject(java.io.ObjectInputStream in)\n+    throws java.io.IOException, java.lang.ClassNotFoundException\n+  {\n+    in.defaultReadObject();\n+\n+    /* We assume that future versions will be downwards compatible,\n+     * so we can ignore the versions.\n+     */\n+    byte majorVersion = in.readByte();\n+    byte minorVersion = in.readByte();\n+\n+    int numParams = in.readInt();\n+    if (numParams >= 0)\n+    {\n+      parameters = new Object[numParams];\n+      for (int i = 0; i < numParams; i++)\n+\tparameters[i] = in.readObject();\n+    }\n+  }\n+\n+\n+  /**\n+   * @serialData The default fields, followed by a major byte version\n+   * number, followed by a minor byte version number, followed by\n+   * information about the log record parameters.  If\n+   * <code>parameters</code> is <code>null</code>, the integer -1 is\n+   * written, otherwise the length of the <code>parameters</code>\n+   * array (which can be zero), followed by the result of calling\n+   * {@link Object#toString() toString()} on the parameter (or\n+   * <code>null</code> if the parameter is <code>null</code>).\n+   *\n+   * <p><strong>Specification Note:</strong> The Javadoc for the\n+   * Sun reference implementation does not specify the version\n+   * number. FIXME: Reverse-engineer the JDK and file a bug\n+   * report with Sun, asking for amendment of the specification.\n+   */\n+  private void writeObject(java.io.ObjectOutputStream out)\n+    throws java.io.IOException\n+  {\n+    out.defaultWriteObject();\n+\n+    /* Major, minor version number: The Javadoc for J2SE1.4 does not\n+     * specify the values.\n+     */\n+    out.writeByte(0);\n+    out.writeByte(0);\n+\n+    if (parameters == null)\n+      out.writeInt(-1);\n+    else\n+    {\n+      out.writeInt(parameters.length);\n+      for (int i = 0; i < parameters.length; i++)\n+      {\n+\tif (parameters[i] == null)\n+\t  out.writeObject(null);\n+\telse\n+\t  out.writeObject(parameters[i].toString());\n+      }\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns the name of the logger where this <code>LogRecord</code>\n+   * has originated.\n+   *\n+   * @return the name of the source {@link Logger}, or\n+   *         <code>null</code> if this <code>LogRecord</code>\n+   *         does not originate from a <code>Logger</code>.\n+   */\n+  public String getLoggerName()\n+  {\n+    return loggerName;\n+  }\n+\n+\n+  /**\n+   * Sets the name of the logger where this <code>LogRecord</code>\n+   * has originated.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param name the name of the source logger, or <code>null</code> to\n+   *             indicate that this <code>LogRecord</code> does not\n+   *             originate from a <code>Logger</code>.\n+   */\n+  public void setLoggerName(String name)\n+  {\n+    loggerName = name;\n+  }\n+\n+\n+  /**\n+   * Returns the resource bundle that is used when the message\n+   * of this <code>LogRecord</code> needs to be localized.\n+   *\n+   * @return the resource bundle used for localization,\n+   *         or <code>null</code> if this message does not need\n+   *         to be localized.\n+   */\n+  public ResourceBundle getResourceBundle()\n+  {\n+    return bundle;\n+  }\n+\n+\n+  /**\n+   * Sets the resource bundle that is used when the message\n+   * of this <code>LogRecord</code> needs to be localized.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param bundle  the resource bundle to be used, or\n+   *                <code>null</code> to indicate that this\n+   *                message does not need to be localized.\n+   */\n+  public void setResourceBundle(ResourceBundle bundle)\n+  {\n+    this.bundle = bundle;\n+\n+    /* FIXME: Is there a way to infer the name\n+     * of a resource bundle from a ResourceBundle object?\n+     */\n+    this.resourceBundleName = null;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the resource bundle that is used when the\n+   * message of this <code>LogRecord</code> needs to be localized.\n+   *\n+   * @return the name of the resource bundle used for localization,\n+   *         or <code>null</code> if this message does not need\n+   *         to be localized.\n+   */\n+  public String getResourceBundleName()\n+  {\n+    return resourceBundleName;\n+  }\n+\n+\n+  /**\n+   * Sets the name of the resource bundle that is used when the\n+   * message of this <code>LogRecord</code> needs to be localized.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param name the name of the resource bundle to be used, or\n+   *             <code>null</code> to indicate that this message\n+   *             does not need to be localized.\n+   */\n+  public void setResourceBundleName(String name)\n+  {\n+    resourceBundleName = name;\n+    bundle = null;\n+    \n+    try\n+    {\n+      if (resourceBundleName != null)\n+\tbundle = ResourceBundle.getBundle(resourceBundleName);\n+    }\n+    catch (java.util.MissingResourceException _)\n+    {\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns the level of the LogRecord.\n+   *\n+   * <p>Applications should be aware of the possibility that the\n+   *  result is not necessarily one of the standard logging levels,\n+   *  since the logging framework allows to create custom subclasses\n+   *  of <code>java.util.logging.Level</code>.  Therefore, filters\n+   *  should perform checks like <code>theRecord.getLevel().intValue()\n+   *  == Level.INFO.intValue()</code> instead of <code>theRecord.getLevel()\n+   *  == Level.INFO</code>.\n+   */\n+  public Level getLevel()\n+  {\n+    return level;\n+  }\n+\n+\n+  /**\n+   * Sets the severity level of this <code>LogRecord</code> to a new\n+   * value.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param level the new severity level, for example\n+   *              <code>Level.WARNING</code>.\n+   */\n+  public void setLevel(Level level)\n+  {\n+    this.level = level;\n+  }\n+\n+\n+  /**\n+   * The last used sequence number for any LogRecord.\n+   */\n+  private static long lastSeqNum = 0;\n+\n+\n+  /**\n+   * Allocates a sequence number for a new LogRecord.  This class\n+   * method is only called by the LogRecord constructor.\n+   */\n+  private synchronized static long allocateSeqNum()\n+  {\n+    lastSeqNum += 1;\n+    return lastSeqNum;\n+  }\n+\n+\n+  /**\n+   * Returns the sequence number of this <code>LogRecord</code>.\n+   */\n+  public long getSequenceNumber()\n+  {\n+    return sequenceNumber;\n+  }\n+\n+\n+  /**\n+   * Sets the sequence number of this <code>LogRecord</code> to a new\n+   * value.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param seqNum the new sequence number.\n+   */\n+  public void setSequenceNumber(long seqNum)\n+  {\n+    this.sequenceNumber = seqNum;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the class where the event being logged\n+   * has had its origin.  This information can be passed as\n+   * parameter to some logging calls, and in certain cases, the\n+   * logging framework tries to determine an approximation\n+   * (which may or may not be accurate).\n+   * \n+   * @return the name of the class that issued the logging request,\n+   *         or <code>null</code> if this information could not\n+   *         be obtained.\n+   */\n+  public String getSourceClassName()\n+  {\n+    if (sourceClassName != null)\n+      return sourceClassName;\n+\n+    /*  FIXME: Should infer this information from the call stack. */\n+    return null;\n+  }\n+\n+\n+  /**\n+   * Sets the name of the class where the event being logged\n+   * has had its origin.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   * \n+   * @param sourceClassName the name of the class that issued the\n+   *          logging request, or <code>null</code> to indicate that\n+   *          this information could not be obtained.\n+   */\n+  public void setSourceClassName(String sourceClassName)\n+  {\n+    this.sourceClassName = sourceClassName;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the method where the event being logged\n+   * has had its origin.  This information can be passed as\n+   * parameter to some logging calls, and in certain cases, the\n+   * logging framework tries to determine an approximation\n+   * (which may or may not be accurate).\n+   * \n+   * @return the name of the method that issued the logging request,\n+   *         or <code>null</code> if this information could not\n+   *         be obtained.\n+   */\n+  public String getSourceMethodName()\n+  {\n+    if (sourceMethodName != null)\n+      return sourceMethodName;\n+\n+    /* FIXME: Should infer this information from the call stack. */\n+    return null;\n+  }\n+\n+\n+  /**\n+   * Sets the name of the method where the event being logged\n+   * has had its origin.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   * \n+   * @param sourceMethodName the name of the method that issued the\n+   *          logging request, or <code>null</code> to indicate that\n+   *          this information could not be obtained.\n+   */\n+  public void setSourceMethodName(String sourceMethodName)\n+  {\n+    this.sourceMethodName = sourceMethodName;\n+  }\n+\n+\n+  /**\n+   * Returns the message for this <code>LogRecord</code> before\n+   * any localization or parameter substitution.\n+   *\n+   * <p>A {@link Logger} will try to localize the message\n+   * if a resource bundle has been associated with this\n+   * <code>LogRecord</code>.  In this case, the logger will call\n+   * <code>getMessage()</code> and use the result as the key\n+   * for looking up the localized message in the bundle.\n+   * If no bundle has been associated, or if the result of\n+   * <code>getMessage()</code> is not a valid key in the\n+   * bundle, the logger will use the raw message text as\n+   * returned by this method.\n+   *\n+   * @return the message text, or <code>null</code> if there\n+   *         is no message text.\n+   */\n+  public String getMessage()\n+  {\n+    return message;\n+  }\n+\n+\n+  /**\n+   * Sets the message for this <code>LogRecord</code>.\n+   *\n+   * <p>A <code>Logger</code> will try to localize the message\n+   * if a resource bundle has been associated with this\n+   * <code>LogRecord</code>.  In this case, the logger will call\n+   * <code>getMessage()</code> and use the result as the key\n+   * for looking up the localized message in the bundle.\n+   * If no bundle has been associated, or if the result of\n+   * <code>getMessage()</code> is not a valid key in the\n+   * bundle, the logger will use the raw message text as\n+   * returned by this method.\n+   *\n+   * <p>It is possible to set the message to either an empty String or\n+   * <code>null</code>, although this does not make the the message\n+   * very helpful to human users.\n+   *\n+   * @param message the message text (which will be used as key\n+   *                for looking up the localized message text\n+   *                if a resource bundle has been associated). \n+   */\n+  public void setMessage(String message)\n+  {\n+    this.message = message;\n+  }\n+\n+\n+  /**\n+   * Returns the parameters to the log message.\n+   *\n+   * @return the parameters to the message, or <code>null</code> if\n+   *         the message has no parameters.\n+   */\n+  public Object[] getParameters()\n+  {\n+    return parameters;\n+  }\n+\n+\n+  /**\n+   * Sets the parameters to the log message.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param parameters the parameters to the message, or <code>null</code>\n+   *                   to indicate that the message has no parameters.\n+   */\n+  public void setParameters(Object[] parameters)\n+  {\n+    this.parameters = parameters;\n+  }\n+\n+\n+  /**\n+   * Returns an identifier for the thread in which this\n+   * <code>LogRecord</code> was created.  The identifier is not\n+   * necessarily related to any thread identifiers used by the\n+   * operating system.\n+   *\n+   * @return an identifier for the source thread.\n+   */\n+  public int getThreadID()\n+  {\n+    return threadID;\n+  }\n+\n+\n+  /**\n+   * Sets the identifier indicating in which thread this\n+   * <code>LogRecord</code> was created.  The identifier is not\n+   * necessarily related to any thread identifiers used by the\n+   * operating system.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param threadID the identifier for the source thread.\n+   */\n+  public void setThreadID(int threadID)\n+  {\n+    this.threadID = threadID;\n+  }\n+\n+\n+  /**\n+   * Returns the time when this <code>LogRecord</code> was created.\n+   *\n+   * @return the time of creation in milliseconds since the beginning\n+   *         of January 1, 1970.\n+   */\n+  public long getMillis()\n+  {\n+    return millis;\n+  }\n+\n+\n+  /**\n+   * Sets the time when this <code>LogRecord</code> was created.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param millis the time of creation in milliseconds since the\n+   *               beginning of January 1, 1970.\n+   */\n+  public void setMillis(long millis)\n+  {\n+    this.millis = millis;\n+  }\n+\n+\n+  /**\n+   * Returns the Throwable associated with this <code>LogRecord</code>,\n+   * or <code>null</code> if the logged event is not related to an exception\n+   * or error.\n+   */\n+  public Throwable getThrown()\n+  {\n+    return thrown;\n+  }\n+\n+\n+  /**\n+   * Associates this <code>LogRecord</code> with an exception or error.\n+   *\n+   * <p>As soon as a <code>LogRecord</code> has been handed over\n+   * to the logging framework, applications should not modify it\n+   * anymore.  Therefore, this method should only be called on\n+   * freshly constructed LogRecords.\n+   *\n+   * @param thrown the exception or error to associate with, or\n+   *               <code>null</code> if this <code>LogRecord</code>\n+   *               should be made unrelated to an exception or error.\n+   */\n+  public void setThrown(Throwable thrown)\n+  {\n+    this.thrown = thrown;\n+  }\n+}"}, {"sha": "e142e201f70b0d5f77e380acb5cac7921cbb0d6f", "filename": "libjava/java/util/logging/Logger.java", "status": "added", "additions": 1167, "deletions": 0, "changes": 1167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLogger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLogger.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,1167 @@\n+/* Logger.java\n+   -- a class for logging messages\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.ResourceBundle;\n+import java.util.MissingResourceException;\n+import java.util.List;\n+\n+/**\n+ * A Logger is used for logging information about events. Usually, there\n+ * is a seprate logger for each subsystem or component, although there\n+ * is a shared instance for components that make only occasional use of\n+ * the logging framework.\n+ *\n+ * <p>It is common to name a logger after the name of a corresponding\n+ * Java package.  Loggers are organized into a hierarchical namespace;\n+ * for example, the logger <code>\"org.gnu.foo\"</code> is the\n+ * <em>parent</em> of logger <code>\"org.gnu.foo.bar\"</code>.\n+ *\n+ * <p>A logger for a named subsystem can be obtained through {@link\n+ * java.util.logging.Logger#getLogger(java.lang.String)}.  However,\n+ * only code which has been granted the permission to control the\n+ * logging infrastructure will be allowed to customize that logger.\n+ * Untrusted code can obtain a private, anonymous logger through\n+ * {@link #getAnonymousLogger()} if it wants to perform any\n+ * modifications to the logger.\n+ *\n+ * <p>FIXME: Write more documentation.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class Logger\n+{\n+  /**\n+   * A logger provided to applications that make only occasional use\n+   * of the logging framework, typically early prototypes.  Serious\n+   * products are supposed to create and use their own Loggers, so\n+   * they can be controlled individually.\n+   */\n+  public static final Logger global = getLogger(\"global\");\n+\n+\n+  /**\n+   * The name of the Logger, or <code>null</code> if the logger is\n+   * anonymous.\n+   *\n+   * <p>A previous version of the GNU Classpath implementation granted\n+   * untrusted code the permission to control any logger whose name\n+   * was null.  However, test code revealed that the Sun J2SE 1.4\n+   * reference implementation enforces the security control for any\n+   * logger that was not created through getAnonymousLogger, even if\n+   * it has a null name.  Therefore, a separate flag {@link\n+   * Logger#anonymous} was introduced.\n+   */\n+  private final String name;\n+\n+\n+  /**\n+   * The name of the resource bundle used for localization.\n+   *\n+   * <p>This variable cannot be declared as <code>final</code>\n+   * because its value can change as a result of calling\n+   * getLogger(String,String).\n+   */\n+  private String resourceBundleName;\n+\n+\n+  /**\n+   * The resource bundle used for localization.\n+   *\n+   * <p>This variable cannot be declared as <code>final</code>\n+   * because its value can change as a result of calling\n+   * getLogger(String,String).\n+   */\n+  private ResourceBundle resourceBundle;\n+\n+  private Filter filter;\n+\n+  private final List handlerList = new java.util.ArrayList(4);\n+  private Handler[] handlers = new Handler[0];\n+\n+  /**\n+   * Indicates whether or not this logger is anonymous.  While\n+   * a LoggingPermission is required for any modifications to\n+   * a normal logger, untrusted code can obtain an anonymous logger\n+   * and modify it according to its needs.\n+   *\n+   * <p>A previous version of the GNU Classpath implementation\n+   * granted access to every logger whose name was null.\n+   * However, test code revealed that the Sun J2SE 1.4 reference\n+   * implementation enforces the security control for any logger\n+   * that was not created through getAnonymousLogger, even\n+   * if it has a null name.\n+   */\n+  private boolean anonymous;\n+\n+\n+  private boolean useParentHandlers;\n+\n+  private Level level;\n+\n+  private Logger parent;\n+\n+  /**\n+   * Constructs a Logger for a subsystem.  Most applications do not\n+   * need to create new Loggers explicitly; instead, they should call\n+   * the static factory methods\n+   * {@link #getLogger(java.lang.String,java.lang.String) getLogger}\n+   * (with ResourceBundle for localization) or\n+   * {@link #getLogger(java.lang.String) getLogger} (without\n+   * ResourceBundle), respectively.\n+   *\n+   * @param name the name for the logger, for example \"java.awt\"\n+   *             or \"com.foo.bar\". The name should be based on\n+   *             the name of the package issuing log records\n+   *             and consist of dot-separated Java identifiers.\n+   *\n+   * @param resourceBundleName the name of a resource bundle\n+   *        for localizing messages, or <code>null</code>\n+   *\t    to indicate that messages do not need to be localized.\n+   *\n+   * @throws java.util.MissingResourceException if\n+   *         <code>resourceBundleName</code> is not <code>null</code>\n+   *         and no such bundle could be located.\n+   */\n+  protected Logger(String name, String resourceBundleName)\n+    throws MissingResourceException\n+  {\n+    this.name = name;\n+    this.resourceBundleName = resourceBundleName;\n+\n+    if (resourceBundleName == null)\n+      resourceBundle = null;\n+    else\n+      resourceBundle = ResourceBundle.getBundle(resourceBundleName);\n+\n+    level = null;\n+\n+    /* This is null when the root logger is being constructed,\n+     * and the root logger afterwards.\n+     */\n+    parent = LogManager.getLogManager().rootLogger;\n+\n+    useParentHandlers = (parent != null);\n+  }\n+\n+\n+\n+  /**\n+   * Finds a registered logger for a subsystem, or creates one in\n+   * case no logger has been registered yet.\n+   *\n+   * @param name the name for the logger, for example \"java.awt\"\n+   *             or \"com.foo.bar\". The name should be based on\n+   *             the name of the package issuing log records\n+   *             and consist of dot-separated Java identifiers.\n+   *\n+   * @throws IllegalArgumentException if a logger for the subsystem\n+   *         identified by <code>name</code> has already been created,\n+   *         but uses a a resource bundle for localizing messages.\n+   *\n+   * @throws NullPointerException if <code>name</code> is\n+   *         <code>null</code>.\n+   *\n+   * @return a logger for the subsystem specified by <code>name</code>\n+   *         that does not localize messages.\n+   */\n+  public static Logger getLogger(String name)\n+  {\n+    return getLogger(name, null);\n+  }\n+\n+    \n+  /**\n+   * Finds a registered logger for a subsystem, or creates one in case\n+   * no logger has been registered yet.\n+   *\n+   * <p>If a logger with the specified name has already been\n+   * registered, the behavior depends on the resource bundle that is\n+   * currently associated with the existing logger.\n+   *\n+   * <ul><li>If the existing logger uses the same resource bundle as\n+   * specified by <code>resourceBundleName</code>, the existing logger\n+   * is returned.</li>\n+   *\n+   * <li>If the existing logger currently does not localize messages,\n+   * the existing logger is modified to use the bundle specified by\n+   * <code>resourceBundleName</code>.  The existing logger is then\n+   * returned.  Therefore, all subsystems currently using this logger\n+   * will produce localized messages from now on.</li>\n+   *\n+   * <li>If the existing logger already has an associated resource\n+   * bundle, but a different one than specified by\n+   * <code>resourceBundleName</code>, an\n+   * <code>IllegalArgumentException</code> is thrown.</li></ul>\n+   *\n+   * @param name the name for the logger, for example \"java.awt\"\n+   *             or \"org.gnu.foo\". The name should be based on\n+   *             the name of the package issuing log records\n+   *             and consist of dot-separated Java identifiers.\n+   *\n+   * @param resourceBundleName the name of a resource bundle\n+   *        for localizing messages, or <code>null</code>\n+   *\t    to indicate that messages do not need to be localized.\n+   *\n+   * @return a logger for the subsystem specified by <code>name</code>.\n+   *\n+   * @throws java.util.MissingResourceException if\n+   *         <code>resourceBundleName</code> is not <code>null</code>\n+   *         and no such bundle could be located.   \n+   *\n+   * @throws IllegalArgumentException if a logger for the subsystem\n+   *         identified by <code>name</code> has already been created,\n+   *         but uses a different resource bundle for localizing\n+   *         messages.\n+   *\n+   * @throws NullPointerException if <code>name</code> is\n+   *         <code>null</code>.\n+   */\n+  public static Logger getLogger(String name, String resourceBundleName)\n+  {\n+    LogManager lm = LogManager.getLogManager();\n+    Logger     result;\n+\n+    /* Throw NullPointerException if name is null. */\n+    name.getClass();\n+\n+    /* Without synchronized(lm), it could happen that another thread\n+     * would create a logger between our calls to getLogger and\n+     * addLogger.  While addLogger would indicate this by returning\n+     * false, we could not be sure that this other logger was still\n+     * existing when we called getLogger a second time in order\n+     * to retrieve it -- note that LogManager is only allowed to\n+     * keep weak references to registered loggers, so Loggers\n+     * can be garbage collected at any time in general, and between\n+     * our call to addLogger and our second call go getLogger\n+     * in particular.\n+     *\n+     * Of course, we assume here that LogManager.addLogger etc.\n+     * are synchronizing on the global LogManager object. There\n+     * is a comment in the implementation of LogManager.addLogger\n+     * referring to this comment here, so that any change in\n+     * the synchronization of LogManager will be reflected here.\n+     */\n+    synchronized (lm)\n+    {\n+      result = lm.getLogger(name);\n+      if (result == null)\n+      {\n+\tboolean couldBeAdded;\n+\n+\tresult = new Logger(name, resourceBundleName);\n+\tcouldBeAdded = lm.addLogger(result);\n+\tif (!couldBeAdded)\n+\t  throw new IllegalStateException(\"cannot register new logger\");\n+      }\n+      else\n+      {\n+\t/* The logger already exists. Make sure it uses\n+\t * the same resource bundle for localizing messages.\n+\t */\n+\tString existingBundleName = result.getResourceBundleName();\n+\n+\t/* The Sun J2SE 1.4 reference implementation will return the\n+\t * registered logger object, even if it does not have a resource\n+\t * bundle associated with it. However, it seems to change the\n+\t * resourceBundle of the registered logger to the bundle\n+\t * whose name was passed to getLogger.\n+\t */\n+\tif ((existingBundleName == null) && (resourceBundleName != null))\n+\t{\n+\t  /* If ResourceBundle.getBundle throws an exception, the\n+\t   * existing logger will be unchanged.  This would be\n+\t   * different if the assignment to resourceBundleName\n+\t   * came first.\n+\t   */\n+\t  result.resourceBundle = ResourceBundle.getBundle(resourceBundleName);\n+\t  result.resourceBundleName = resourceBundleName;\n+\t  return result;\n+\t}\n+\n+\tif ((existingBundleName != resourceBundleName)\n+\t    && ((existingBundleName == null)\n+\t\t|| !existingBundleName.equals(resourceBundleName)))\n+\t{\n+\t  throw new IllegalArgumentException();\n+\t}\n+      }\n+    }\n+\n+    return result;\n+  }\n+\n+  \n+  /**\n+   * Creates a new, unnamed logger.  Unnamed loggers are not\n+   * registered in the namespace of the LogManager, and no special\n+   * security permission is required for changing their state.\n+   * Therefore, untrusted applets are able to modify their private\n+   * logger instance obtained through this method.\n+   *\n+   * <p>The parent of the newly created logger will the the root\n+   * logger, from which the level threshold and the handlers are\n+   * inherited.\n+   */\n+  public static Logger getAnonymousLogger()\n+  {\n+    return getAnonymousLogger(null);\n+  }\n+\n+\n+  /**\n+   * Creates a new, unnamed logger.  Unnamed loggers are not\n+   * registered in the namespace of the LogManager, and no special\n+   * security permission is required for changing their state.\n+   * Therefore, untrusted applets are able to modify their private\n+   * logger instance obtained through this method.\n+   *\n+   * <p>The parent of the newly created logger will the the root\n+   * logger, from which the level threshold and the handlers are\n+   * inherited.\n+   *\n+   * @param resourceBundleName the name of a resource bundle\n+   *        for localizing messages, or <code>null</code>\n+   *\t    to indicate that messages do not need to be localized.\n+   *\n+   * @throws java.util.MissingResourceException if\n+   *         <code>resourceBundleName</code> is not <code>null</code>\n+   *         and no such bundle could be located.\n+   */\n+  public static Logger getAnonymousLogger(String resourceBundleName)\n+    throws MissingResourceException\n+  {\n+    Logger  result;\n+\n+    result = new Logger(null, resourceBundleName);\n+    result.anonymous = true;\n+    return result;\n+  }\n+\n+\n+  /**\n+   * Returns the name of the resource bundle that is being used for\n+   * localizing messages.\n+   *\n+   * @return the name of the resource bundle used for localizing messages,\n+   *         or <code>null</code> if the parent's resource bundle\n+   *         is used for this purpose.\n+   */\n+  public synchronized String getResourceBundleName()\n+  {\n+    return resourceBundleName;\n+  }\n+\n+\n+  /**\n+   * Returns the resource bundle that is being used for localizing\n+   * messages.\n+   *\n+   * @return the resource bundle used for localizing messages,\n+   *         or <code>null</code> if the parent's resource bundle\n+   *         is used for this purpose.\n+   */\n+  public synchronized ResourceBundle getResourceBundle()\n+  {\n+    return resourceBundle;\n+  }\n+\n+\n+  /**\n+   * Returns the severity level threshold for this <code>Handler</code>.\n+   * All log records with a lower severity level will be discarded;\n+   * a log record of the same or a higher level will be published\n+   * unless an installed <code>Filter</code> decides to discard it.\n+   *\n+   * @return the severity level below which all log messages will be\n+   *         discarded, or <code>null</code> if the logger inherits\n+   *         the threshold from its parent.\n+   */\n+  public synchronized Level getLevel()\n+  {\n+    return level;\n+  }\n+\n+\n+  /**\n+   * Returns whether or not a message of the specified level\n+   * would be logged by this logger.\n+   *\n+   * @throws NullPointerException if <code>level</code>\n+   *         is <code>null</code>.\n+   */\n+  public synchronized boolean isLoggable(Level level)\n+  {\n+    if (this.level != null)\n+      return this.level.intValue() <= level.intValue();\n+\n+    if (parent != null)\n+      return parent.isLoggable(level);\n+    else\n+      return false;\n+  }\n+\n+\n+  /**\n+   * Sets the severity level threshold for this <code>Handler</code>.\n+   * All log records with a lower severity level will be discarded\n+   * immediately.  A log record of the same or a higher level will be\n+   * published unless an installed <code>Filter</code> decides to\n+   * discard it.\n+   *\n+   * @param level the severity level below which all log messages\n+   *              will be discarded, or <code>null</code> to\n+   *              indicate that the logger should inherit the\n+   *              threshold from its parent.\n+   *\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted\n+   *     the permission to control the logging infrastructure by\n+   *     having LoggingPermission(\"control\").  Untrusted code can\n+   *     obtain an anonymous logger through the static factory method\n+   *     {@link #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   */\n+  public synchronized void setLevel(Level level)\n+  {\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    this.level = level;\n+  }\n+\n+\n+  public synchronized Filter getFilter()\n+  {\n+    return filter;\n+  }\n+\n+\n+  /**\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted\n+   *     the permission to control the logging infrastructure by\n+   *     having LoggingPermission(\"control\").  Untrusted code can\n+   *     obtain an anonymous logger through the static factory method\n+   *     {@link #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   */\n+  public synchronized void setFilter(Filter filter)\n+    throws SecurityException\n+  {\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    this.filter = filter;\n+  }\n+\n+\n+\n+\n+  /**\n+   * Returns the name of this logger.\n+   *\n+   * @return the name of this logger, or <code>null</code> if\n+   *         the logger is anonymous.\n+   */\n+  public String getName()\n+  {\n+    /* Note that the name of a logger cannot be changed during\n+     * its lifetime, so no synchronization is needed.\n+     */\n+    return name;\n+  }\n+\n+\n+  /**\n+   * Passes a record to registered handlers, provided the record\n+   * is considered as loggable both by {@link #isLoggable(Level)}\n+   * and a possibly installed custom {@link #setFilter(Filter) filter}.\n+   *\n+   * <p>If the logger has been configured to use parent handlers,\n+   * the record will be forwarded to the parent of this logger\n+   * in addition to being processed by the handlers registered with\n+   * this logger.\n+   *\n+   * <p>The other logging methods in this class are convenience methods\n+   * that merely create a new LogRecord and pass it to this method.\n+   * Therefore, subclasses usually just need to override this single\n+   * method for customizing the logging behavior.\n+   *\n+   * @param record the log record to be inspected and possibly forwarded.\n+   */\n+  public synchronized void log(LogRecord record)\n+  {\n+    if (!isLoggable(record.getLevel()))\n+      return;\n+\n+    if ((filter != null) && !filter.isLoggable(record))\n+      return;\n+\n+    /* If no logger name has been set for the log record,\n+     * use the name of this logger.\n+     */\n+    if (record.getLoggerName() == null)\n+      record.setLoggerName(name);\n+\n+    /* Avoid that some other thread is changing the logger hierarchy\n+     * while we are traversing it.\n+     */\n+    synchronized (LogManager.getLogManager())\n+    {\n+      Logger curLogger = this;\n+\n+      do\n+      {\n+        /* The Sun J2SE 1.4 reference implementation seems to call the\n+\t * filter only for the logger whose log method is called,\n+\t * never for any of its parents.  Also, parent loggers publish\n+\t * log record whatever their level might be.  This is pretty\n+\t * weird, but GNU Classpath tries to be as compatible as\n+\t * possible to the reference implementation.\n+\t */\n+        for (int i = 0; i < curLogger.handlers.length; i++)\n+          curLogger.handlers[i].publish(record);\n+\n+\tif (curLogger.getUseParentHandlers() == false)\n+\t  break;\n+\t\n+\tcurLogger = curLogger.getParent();\n+      }\n+      while (parent != null);\n+    }\n+  }\n+\n+\n+  public void log(Level level, String message)\n+  {\n+    log(level, message, (Object[]) null);\n+  }\n+\n+\n+  public synchronized void log(Level level,\n+\t\t\t       String message,\n+\t\t\t       Object param)\n+  {\n+    logp(level,\n+\t /* sourceClass*/ null,\n+\t /* sourceMethod */ null,\n+\t message,\n+\t param);\n+  }\n+\n+\n+  public synchronized void log(Level level,\n+\t\t\t       String message,\n+\t\t\t       Object[] params)\n+  {\n+    logp(level,\n+\t /* sourceClass*/ null,\n+\t /* sourceMethod */ null,\n+\t message,\n+\t params);\n+  }\n+\n+\n+  public synchronized void log(Level level,\n+\t\t\t       String message,\n+\t\t\t       Throwable thrown)\n+  {\n+    logp(level,\n+\t /* sourceClass*/ null,\n+\t /* sourceMethod */ null,\n+\t message,\n+\t thrown);\n+  }\n+\n+\n+  public synchronized void logp(Level level,\n+\t\t\t\tString sourceClass,\n+\t\t\t\tString sourceMethod,\n+\t\t\t\tString message)\n+  {\n+    logp(level, sourceClass, sourceMethod, message,\n+\t (Object[]) null);\n+  }\n+\n+\n+  public synchronized void logp(Level level,\n+\t\t\t\tString sourceClass,\n+\t\t\t\tString sourceMethod,\n+\t\t\t\tString message,\n+\t\t\t\tObject param)\n+  {\n+    logp(level, sourceClass, sourceMethod, message,\n+\t new Object[] { param });\n+  }\n+\n+\n+  private synchronized ResourceBundle findResourceBundle()\n+  {\n+    if (resourceBundle != null)\n+      return resourceBundle;\n+\n+    if (parent != null)\n+      return parent.findResourceBundle();\n+\n+    return null;\n+  }\n+\n+\n+  private synchronized void logImpl(Level level,\n+\t\t\t\t    String sourceClass,\n+\t\t\t\t    String sourceMethod,\n+\t\t\t\t    String message,\n+\t\t\t\t    Object[] params)\n+  {\n+    LogRecord rec = new LogRecord(level, message);\n+\n+    rec.setResourceBundle(findResourceBundle());\n+    rec.setSourceClassName(sourceClass);\n+    rec.setSourceMethodName(sourceMethod);\n+    rec.setParameters(params);\n+\n+    log(rec);\n+  }\n+\n+\n+  public synchronized void logp(Level level,\n+\t\t\t\tString sourceClass,\n+\t\t\t\tString sourceMethod,\n+\t\t\t\tString message,\n+\t\t\t\tObject[] params)\n+  {\n+    logImpl(level, sourceClass, sourceMethod, message, params);\n+  }\n+\n+\n+  public synchronized void logp(Level level,\n+\t\t\t\tString sourceClass,\n+\t\t\t\tString sourceMethod,\n+\t\t\t\tString message,\n+\t\t\t\tThrowable thrown)\n+  {\n+    LogRecord rec = new LogRecord(level, message);\n+\n+    rec.setResourceBundle(resourceBundle);\n+    rec.setSourceClassName(sourceClass);\n+    rec.setSourceMethodName(sourceMethod);\n+    rec.setThrown(thrown);\n+\n+    log(rec);\n+  }\n+\n+\n+  public synchronized void logrb(Level level,\n+\t\t\t\t String sourceClass,\n+\t\t\t\t String sourceMethod,\n+\t\t\t\t String bundleName,\n+\t\t\t\t String message)\n+  {\n+    logrb(level, sourceClass, sourceMethod, bundleName,\n+\t  message, (Object[]) null);\n+  }\n+\n+\n+  public synchronized void logrb(Level level,\n+\t\t\t\t String sourceClass,\n+\t\t\t\t String sourceMethod,\n+\t\t\t\t String bundleName,\n+\t\t\t\t String message,\n+\t\t\t\t Object param)\n+  {\n+    logrb(level, sourceClass, sourceMethod, bundleName,\n+\t  message, new Object[] { param });\n+  }\n+\n+\n+  public synchronized void logrb(Level level,\n+\t\t\t\t String sourceClass,\n+\t\t\t\t String sourceMethod,\n+\t\t\t\t String bundleName,\n+\t\t\t\t String message,\n+\t\t\t\t Object[] params)\n+  {\n+    LogRecord rec = new LogRecord(level, message);\n+\n+    rec.setResourceBundleName(bundleName);\n+    rec.setSourceClassName(sourceClass);\n+    rec.setSourceMethodName(sourceMethod);\n+    rec.setParameters(params);\n+\n+    log(rec);\n+  }\n+\n+\n+  public synchronized void logrb(Level level,\n+\t\t\t\t String sourceClass,\n+\t\t\t\t String sourceMethod,\n+\t\t\t\t String bundleName,\n+\t\t\t\t String message,\n+\t\t\t\t Throwable thrown)\n+  {\n+    LogRecord rec = new LogRecord(level, message);\n+\n+    rec.setResourceBundleName(bundleName);\n+    rec.setSourceClassName(sourceClass);\n+    rec.setSourceMethodName(sourceMethod);\n+    rec.setThrown(thrown);\n+\n+    log(rec);\n+  }\n+\n+\n+  public synchronized void entering(String sourceClass,\n+\t\t\t\t    String sourceMethod)\n+  {\n+    if (isLoggable(Level.FINER))\n+      logp(Level.FINER, sourceClass, sourceMethod, \"ENTRY\");\n+  }\n+\n+\n+  public synchronized void entering(String sourceClass,\n+\t\t\t\t    String sourceMethod,\n+\t\t\t\t    Object param)\n+  {\n+    if (isLoggable(Level.FINER))\n+      logp(Level.FINER, sourceClass, sourceMethod, \"ENTRY {0}\", param);\n+  }\n+\n+\n+  public synchronized void entering(String sourceClass,\n+\t\t\t\t    String sourceMethod,\n+\t\t\t\t    Object[] params)\n+  {\n+    if (isLoggable(Level.FINER))\n+    {\n+      StringBuffer buf = new StringBuffer(80);\n+      buf.append(\"ENTRY\");\n+      for (int i = 0; i < params.length; i++)\n+      {\n+\tbuf.append(\" {\");\n+\tbuf.append(i);\n+\tbuf.append('}');\n+      }\n+      \n+      logp(Level.FINER, sourceClass, sourceMethod, buf.toString(), params);\n+    }\n+  }\n+\n+\n+  public synchronized void exiting(String sourceClass,\n+\t\t\t\t   String sourceMethod)\n+  {\n+    if (isLoggable(Level.FINER))\n+      logp(Level.FINER, sourceClass, sourceMethod, \"RETURN\");\n+  }\n+\n+   \n+  public synchronized void exiting(String sourceClass,\n+\t\t\t\t   String sourceMethod,\n+\t\t\t\t   Object result)\n+  {\n+    if (isLoggable(Level.FINER))\n+      logp(Level.FINER, sourceClass, sourceMethod, \"RETURN {0}\", result);\n+  }\n+\n+ \n+  public synchronized void throwing(String sourceClass,\n+\t\t\t\t    String sourceMethod,\n+\t\t\t\t    Throwable thrown)\n+  {\n+    if (isLoggable(Level.FINER))\n+      logp(Level.FINER, sourceClass, sourceMethod, \"THROW\", thrown);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level SEVERE, indicating a serious\n+   * failure that prevents normal program execution.  Messages at this\n+   * level should be understandable to an inexperienced, non-technical\n+   * end user.  Ideally, they explain in simple words what actions the\n+   * user can take in order to resolve the problem.\n+   *\n+   * @see Level#SEVERE\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void severe(String message)\n+  {\n+    if (isLoggable(Level.SEVERE))\n+      log(Level.SEVERE, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level WARNING, indicating a\n+   * potential problem that does not prevent normal program execution.\n+   * Messages at this level should be understandable to an\n+   * inexperienced, non-technical end user.  Ideally, they explain in\n+   * simple words what actions the user can take in order to resolve\n+   * the problem.\n+   *\n+   * @see Level#WARNING\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void warning(String message)\n+  {\n+    if (isLoggable(Level.WARNING))\n+      log(Level.WARNING, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level INFO.  {@link Level#INFO} is\n+   * intended for purely informational messages that do not indicate\n+   * error or warning situations. In the default logging\n+   * configuration, INFO messages will be written to the system\n+   * console.  For this reason, the INFO level should be used only for\n+   * messages that are important to end users and system\n+   * administrators.  Messages at this level should be understandable\n+   * to an inexperienced, non-technical user.\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void info(String message)\n+  {\n+    if (isLoggable(Level.INFO))\n+      log(Level.INFO, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level CONFIG.  {@link Level#CONFIG} is\n+   * intended for static configuration messages, for example about the\n+   * windowing environment, the operating system version, etc.\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *     logger is localizing messages with a resource bundle.  While\n+   *     it is possible to pass <code>null</code>, this is not\n+   *     recommended, since a logging message without text is unlikely\n+   *     to be helpful.\n+   */\n+  public synchronized void config(String message)\n+  {\n+    if (isLoggable(Level.CONFIG))\n+      log(Level.CONFIG, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level FINE.  {@link Level#FINE} is\n+   * intended for messages that are relevant for developers using\n+   * the component generating log messages. Examples include minor,\n+   * recoverable failures, or possible inefficiencies.\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void fine(String message)\n+  {\n+    if (isLoggable(Level.FINE))\n+      log(Level.FINE, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level FINER.  {@link Level#FINER} is\n+   * intended for rather detailed tracing, for example entering a\n+   * method, returning from a method, or throwing an exception.\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void finer(String message)\n+  {\n+    if (isLoggable(Level.FINER))\n+      log(Level.FINER, message);\n+  }\n+\n+\n+  /**\n+   * Logs a message with severity level FINEST.  {@link Level#FINEST}\n+   * is intended for highly detailed tracing, for example reaching a\n+   * certain point inside the body of a method.\n+   *\n+   * @param message the message text, also used as look-up key if the\n+   *                logger is localizing messages with a resource\n+   *                bundle.  While it is possible to pass\n+   *                <code>null</code>, this is not recommended, since\n+   *                a logging message without text is unlikely to be\n+   *                helpful.\n+   */\n+  public synchronized void finest(String message)\n+  {\n+    if (isLoggable(Level.FINEST))\n+      log(Level.FINEST, message);\n+  }\n+\n+\n+  /**\n+   * Adds a handler to the set of handlers that get notified\n+   * when a log record is to be published.\n+   *\n+   * @param handler the handler to be added.\n+   *\n+   * @throws NullPointerException if <code>handler</code>\n+   *     is <code>null</code>.\n+   *\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted\n+   *     the permission to control the logging infrastructure by\n+   *     having LoggingPermission(\"control\").  Untrusted code can\n+   *     obtain an anonymous logger through the static factory method\n+   *     {@link #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   */\n+  public synchronized void addHandler(Handler handler)\n+    throws SecurityException\n+  {\n+    /* Throw a new NullPointerException if handler is null. */\n+    handler.getClass();\n+\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    if (!handlerList.contains(handler))\n+    {\n+      handlerList.add(handler);\n+      handlers = getHandlers();\n+    }\n+  }\n+\n+\n+  /**\n+   * Removes a handler from the set of handlers that get notified\n+   * when a log record is to be published.\n+   *\n+   * @param handler the handler to be removed.\n+   *\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted the\n+   *     permission to control the logging infrastructure by having\n+   *     LoggingPermission(\"control\").  Untrusted code can obtain an\n+   *     anonymous logger through the static factory method {@link\n+   *     #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   *\n+   * @throws NullPointerException if <code>handler</code>\n+   *     is <code>null</code>.\n+   */\n+  public synchronized void removeHandler(Handler handler)\n+    throws SecurityException\n+  {\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    /* Throw a new NullPointerException if handler is null. */\n+    handler.getClass();\n+\n+    handlerList.remove(handler);\n+    handlers = getHandlers();\n+  }\n+\n+\n+  /**\n+   * Returns the handlers currently registered for this Logger.\n+   * When a log record has been deemed as being loggable,\n+   * it will be passed to all registered handlers for\n+   * publication.  In addition, if the logger uses parent handlers\n+   * (see {@link #getUseParentHandlers() getUseParentHandlers}\n+   * and {@link #setUseParentHandlers(boolean) setUseParentHandlers},\n+   * the log record will be passed to the parent's handlers.\n+   */\n+  public synchronized Handler[] getHandlers()\n+  {\n+    /* We cannot return our internal handlers array\n+     * because we do not have any guarantee that the\n+     * caller would not change the array entries.\n+     */\n+    return (Handler[]) handlerList.toArray(new Handler[handlerList.size()]);\n+  }\n+\n+\n+  /**\n+   * Returns whether or not this Logger forwards log records to\n+   * handlers registered for its parent loggers.\n+   *\n+   * @return <code>false</code> if this Logger sends log records\n+   *         merely to Handlers registered with itself;\n+   *         <code>true</code> if this Logger sends log records\n+   *         not only to Handlers registered with itself, but also\n+   *         to those Handlers registered with parent loggers.\n+   */\n+  public synchronized boolean getUseParentHandlers()\n+  {\n+    return useParentHandlers;\n+  }\n+\n+\n+  /**\n+   * Sets whether or not this Logger forwards log records to\n+   * handlers registered for its parent loggers.\n+   *\n+   * @param useParentHandlers <code>false</code> to let this\n+   *         Logger send log records merely to Handlers registered\n+   *         with itself; <code>true</code> to let this Logger\n+   *         send log records not only to Handlers registered\n+   *         with itself, but also to those Handlers registered with\n+   *         parent loggers.\n+   *\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted\n+   *     the permission to control the logging infrastructure by\n+   *     having LoggingPermission(\"control\").  Untrusted code can\n+   *     obtain an anonymous logger through the static factory method\n+   *     {@link #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   *\n+   */\n+  public synchronized void setUseParentHandlers(boolean useParentHandlers)\n+  {\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    this.useParentHandlers = useParentHandlers;\n+  }\n+\n+\n+  /**\n+   * Returns the parent of this logger.  By default, the parent is\n+   * assigned by the LogManager by inspecting the logger's name.\n+   *\n+   * @return the parent of this logger (as detemined by the LogManager\n+   *     by inspecting logger names), the root logger if no other\n+   *     logger has a name which is a prefix of this logger's name, or\n+   *     <code>null</code> for the root logger.\n+   */\n+  public synchronized Logger getParent()\n+  {\n+    return parent;\n+  }\n+\n+\n+  /**\n+   * Sets the parent of this logger.  Usually, applications do not\n+   * call this method directly.  Instead, the LogManager will ensure\n+   * that the tree of loggers reflects the hierarchical logger\n+   * namespace.  Basically, this method should not be public at all,\n+   * but the GNU implementation follows the API specification.\n+   *\n+   * @throws NullPointerException if <code>parent</code> is\n+   *     <code>null</code>.\n+   *\n+   * @throws SecurityException if this logger is not anonymous, a\n+   *     security manager exists, and the caller is not granted\n+   *     the permission to control the logging infrastructure by\n+   *     having LoggingPermission(\"control\").  Untrusted code can\n+   *     obtain an anonymous logger through the static factory method\n+   *     {@link #getAnonymousLogger(java.lang.String) getAnonymousLogger}.\n+   */\n+  public synchronized void setParent(Logger parent)\n+  {\n+    LogManager lm;\n+\n+    /* Throw a new NullPointerException if parent is null. */\n+    parent.getClass();\n+\n+    lm = LogManager.getLogManager();\n+\n+    if (this == lm.rootLogger)\n+    {\n+      if (parent != null)\n+        throw new IllegalArgumentException(\n+          \"only the root logger can have a null parent\");\n+      this.parent = null;\n+      return;\n+    }\n+\n+    /* An application is allowed to control an anonymous logger\n+     * without having the permission to control the logging\n+     * infrastructure.\n+     */\n+    if (!anonymous)\n+      LogManager.getLogManager().checkAccess();\n+\n+    this.parent = parent;\n+  }\n+}"}, {"sha": "e9b5c4ac6475cf6b546b7186596b31799d77f470", "filename": "libjava/java/util/logging/LoggingPermission.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLoggingPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FLoggingPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FLoggingPermission.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,75 @@\n+/* LoggingPermission.java -- a class for logging permissions.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+public final class LoggingPermission\n+  extends java.security.BasicPermission\n+{\n+  /**\n+   * Creates a new LoggingPermission.\n+   *\n+   * @param name the name of the permission, which must be \"control\".\n+   *\n+   * @param actions the list of actions for the permission, which\n+   *                must be either <code>null</code> or an empty\n+   *                string.\n+   *\n+   * @exception IllegalArgumentException if <code>name</code>\n+   *            is not \"control\", or <code>actions</code> is\n+   *            neither <code>null</code> nor empty.\n+   */\n+  public LoggingPermission(String name, String actions)\n+  {\n+    super(\"control\", \"\");\n+    \n+    if (!\"control\".equals(name))\n+    {\n+      throw new IllegalArgumentException(\n+        \"name of LoggingPermission must be \\\"control\\\"\");\n+    }\n+    \n+    if ((actions != null) && (actions.length() != 0))\n+    {\n+      throw new IllegalArgumentException(\n+\t\"actions of LoggingPermissions must be null or empty\");\n+    }    \n+  }\n+}"}, {"sha": "825a6fa86d648cb934c93c338db2baa6cfd2a34e", "filename": "libjava/java/util/logging/MemoryHandler.java", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FMemoryHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FMemoryHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FMemoryHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,356 @@\n+/* MemoryHandler.java\n+   -- a class for buffering log messages in a memory buffer\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+/**\n+ * A <code>MemoryHandler</code> maintains a circular buffer of\n+ * log records.\n+ *\n+ * <p><strong>Configuration:</strong> Values of the subsequent\n+ * <code>LogManager</code> properties are taken into consideration\n+ * when a <code>MemoryHandler</code> is initialized.\n+ * If a property is not defined, or if it has an invalid\n+ * value, a default is taken without an exception being thrown.\n+ *\n+ * <ul>\n+ *\n+ * <li><code>java.util.MemoryHandler.level</code> - specifies\n+ *     the initial severity level threshold. Default value:\n+ *     <code>Level.ALL</code>.</li>\n+ *\n+ * <li><code>java.util.MemoryHandler.filter</code> - specifies\n+ *     the name of a Filter class. Default value: No Filter.</li>\n+ *\n+ * <li><code>java.util.MemoryHandler.size</code> - specifies the\n+ *     maximum number of log records that are kept in the circular\n+ *     buffer.  Default value: 1000.</li>\n+ *\n+ * <li><code>java.util.MemoryHandler.push</code> - specifies the\n+ *     <code>pushLevel</code>. Default value:\n+ *     <code>Level.SEVERE</code>.</li>\n+ *\n+ * <li><code>java.util.MemoryHandler.target</code> - specifies the\n+ *     name of a subclass of {@link Handler} that will be used as the\n+ *     target handler.  There is no default value for this property;\n+ *     if it is not set, the no-argument MemoryHandler constructor\n+ *     will throw an exception.</li>\n+ *\n+ * </ul>\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class MemoryHandler\n+  extends Handler\n+{\n+  /**\n+   * The storage area used for buffering the unpushed log records in\n+   * memory.\n+   */\n+  private final LogRecord[] buffer;\n+\n+\n+  /**\n+   * The current position in the circular buffer. For a new\n+   * MemoryHandler, or immediately after {@link #push()} was called,\n+   * the value of this variable is zero.  Each call to {@link\n+   * #publish(LogRecord)} will store the published LogRecord into\n+   * <code>buffer[position]</code> before position is incremented by\n+   * one.  If position becomes greater than the size of the buffer, it\n+   * is reset to zero.\n+   */\n+  private int position;\n+\n+\n+  /**\n+   * The number of log records which have been published, but not\n+   * pushed yet to the target handler.\n+   */\n+  private int numPublished;\n+\n+\n+  /**\n+   * The push level threshold for this <code>Handler</code>.  When a\n+   * record is published whose severity level is greater than or equal\n+   * to the <code>pushLevel</code> of this <code>MemoryHandler</code>,\n+   * the {@link #push()} method will be invoked for pushing the buffer\n+   * contents to the target <code>Handler</code>.\n+   */\n+  private Level pushLevel;\n+\n+\n+  /**\n+   * The Handler to which log records are forwarded for actual\n+   * publication.\n+   */\n+  private final Handler target;\n+\n+\n+  /**\n+   * Constructs a <code>MemoryHandler</code> for keeping a circular\n+   * buffer of LogRecords; the initial configuration is determined by\n+   * the <code>LogManager</code> properties described above.\n+   */\n+  public MemoryHandler()\n+  {\n+    this((Handler) LogManager.getInstanceProperty(\n+\t   \"java.util.logging.MemoryHandler.target\",\n+\t   Handler.class, /* default */ null),\n+\t LogManager.getIntPropertyClamped(\n+\t   \"java.util.logging.MemoryHandler.size\",\n+\t   /* default */ 1000,\n+\t   /* minimum value */ 1,\n+\t   /* maximum value */ Integer.MAX_VALUE),\n+\t LogManager.getLevelProperty(\n+\t   \"java.util.logging.MemoryHandler.push\",\n+\t   /* default push level */ Level.SEVERE));\n+  }\n+\n+  \n+  /**\n+   * Constructs a <code>MemoryHandler</code> for keeping a circular\n+   * buffer of LogRecords, given some parameters. The values of the\n+   * other parameters are taken from LogManager properties, as\n+   * described above.\n+   *\n+   * @param target the target handler that will receive those\n+   *               log records that are passed on for publication.\n+   *\n+   * @param size the number of log records that are kept in the buffer.\n+   *             The value must be a at least one.\n+   *\n+   * @param pushLevel the push level threshold for this\n+   *     <code>MemoryHandler</code>.  When a record is published whose\n+   *     severity level is greater than or equal to\n+   *     <code>pushLevel</code>, the {@link #push()} method will be\n+   *     invoked in order to push the bufffer contents to\n+   *     <code>target</code>.\n+   *\n+   * @throws java.lang.IllegalArgumentException if <code>size</code>\n+   *         is negative or zero. The GNU implementation also throws\n+   *         an IllegalArgumentException if <code>target</code> or\n+   *         <code>pushLevel</code> are <code>null</code>, but the\n+   *         API specification does not prescribe what should happen\n+   *         in those cases.\n+   */\n+  public MemoryHandler(Handler target, int size, Level pushLevel)\n+  { \n+    if ((target == null) || (size <= 0) || (pushLevel == null))\n+      throw new IllegalArgumentException();\n+\n+    buffer = new LogRecord[size];\n+    this.pushLevel = pushLevel;\n+    this.target = target;\n+\n+    setLevel(LogManager.getLevelProperty(\n+      \"java.util.logging.MemoryHandler.level\",\n+      /* default value */ Level.ALL));\n+\n+    setFilter((Filter) LogManager.getInstanceProperty(\n+      \"java.util.logging.MemoryHandler.filter\",\n+      /* must be instance of */ Filter.class,\n+      /* default value */ null));\n+  }\n+\n+\n+  /**\n+   * Stores a <code>LogRecord</code> in a fixed-size circular buffer,\n+   * provided the record passes all tests for being loggable.  If the\n+   * buffer is full, the oldest record will be discarded.\n+   *\n+   * <p>If the record has a severity level which is greater than or\n+   * equal to the <code>pushLevel</code> of this\n+   * <code>MemoryHandler</code>, the {@link #push()} method will be\n+   * invoked for pushing the buffer contents to the target\n+   * <code>Handler</code>.\n+   *\n+   * <p>Most applications do not need to call this method directly.\n+   * Instead, they will use use a {@link Logger}, which will create\n+   * LogRecords and distribute them to registered handlers.\n+   *\n+   * @param record the log event to be published.\n+   */\n+  public void publish(LogRecord record)\n+  {\n+    if (!isLoggable(record))\n+      return;\n+\n+    buffer[position] = record;\n+    position = (position + 1) % buffer.length;\n+    numPublished = numPublished + 1;\n+\n+    if (record.getLevel().intValue() >= pushLevel.intValue())\n+      push();\n+  }\n+\n+\n+  /**\n+   * Pushes the contents of the memory buffer to the target\n+   * <code>Handler</code> and clears the buffer. Note that\n+   * the target handler will discard those records that do\n+   * not satisfy its own severity level threshold, or that are\n+   * not considered loggable by an installed {@link Filter}.\n+   *\n+   * <p>In case of an I/O failure, the {@link ErrorManager} of the\n+   * target <code>Handler</code> will be notified, but the caller of\n+   * this method will not receive an exception.\n+   */\n+  public void push()\n+  {\n+    int i;\n+\n+    if (numPublished < buffer.length)\n+    {\n+      for (i = 0; i < position; i++)\n+        target.publish(buffer[i]);\n+    }\n+    else\n+    {\n+      for (i = position; i < buffer.length; i++)\n+\ttarget.publish(buffer[i]);\n+      for (i = 0; i < position; i++)\n+\ttarget.publish(buffer[i]);\n+    }\n+\n+    numPublished = 0;\n+    position = 0;\n+  }\n+\n+\n+  /**\n+   * Forces any data that may have been buffered by the target\n+   * <code>Handler</code> to the underlying output device, but\n+   * does <em>not</em> push the contents of the circular memory\n+   * buffer to the target handler.\n+   *\n+   * <p>In case of an I/O failure, the {@link ErrorManager} of the\n+   * target <code>Handler</code> will be notified, but the caller of\n+   * this method will not receive an exception.\n+   *\n+   * @see #push()\n+   */\n+  public void flush()\n+  {\n+    target.flush();\n+  }\n+\n+\n+  /**\n+   * Closes this <code>MemoryHandler</code> and its associated target\n+   * handler, discarding the contents of the memory buffer.  However,\n+   * any data that may have been buffered by the target\n+   * <code>Handler</code> is forced to the underlying output device.\n+   *\n+   * <p>As soon as <code>close</code> has been called,\n+   * a <code>Handler</code> should not be used anymore. Attempts\n+   * to publish log records, to flush buffers, or to modify the\n+   * <code>Handler</code> in any other way may throw runtime\n+   * exceptions after calling <code>close</code>.</p>\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code> of\n+   * the associated target <code>Handler</code> will be informed, but\n+   * the caller of this method will not receive an exception.</p>\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   *\n+   * @see #push()\n+   */\n+  public void close()\n+    throws SecurityException\n+  {\n+    push();\n+\n+    /* This will check for LoggingPermission(\"control\"). If the\n+     * current security context does not grant this permission,\n+     * push() has been executed, but this does not impose a\n+     * security risk.\n+     */\n+    target.close();\n+  }\n+\n+    \n+\n+  /**\n+   * Returns the push level threshold for this <code>Handler</code>.\n+   * When a record is published whose severity level is greater\n+   * than or equal to the <code>pushLevel</code> of this\n+   * <code>MemoryHandler</code>, the {@link #push()} method will be\n+   * invoked for pushing the buffer contents to the target\n+   * <code>Handler</code>.\n+   *\n+   * @return the push level threshold for automatic pushing.\n+   */\n+  public Level getPushLevel()\n+  {\n+    return pushLevel;\n+  }\n+\n+\n+  /**\n+   * Sets the push level threshold for this <code>Handler</code>.\n+   * When a record is published whose severity level is greater\n+   * than or equal to the <code>pushLevel</code> of this\n+   * <code>MemoryHandler</code>, the {@link #push()} method will be\n+   * invoked for pushing the buffer contents to the target\n+   * <code>Handler</code>.\n+   *\n+   * @param pushLevel the push level threshold for automatic pushing.\n+   *\n+   * @exception SecurityException if a security manager exists and\n+   *            the caller is not granted the permission to control\n+   *            the logging infrastructure.\n+   *\n+   * @exception NullPointerException if <code>pushLevel</code> is\n+   *            <code>null</code>.\n+   */\n+  public void setPushLevel(Level pushLevel)\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Throws a NullPointerException if pushLevel is null. */\n+    pushLevel.getClass();\n+\n+    this.pushLevel = pushLevel;\n+  }\n+}"}, {"sha": "8a95638b7b8d9a96d85f9b5fef08739fc8930454", "filename": "libjava/java/util/logging/SimpleFormatter.java", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FSimpleFormatter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FSimpleFormatter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FSimpleFormatter.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,120 @@\n+/* SimpleFormatter.java\n+   -- a class for formatting log records into short human-readable messages\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.Date;\n+import java.text.DateFormat;\n+\n+/**\n+ * A <code>SimpleFormatter</code> formats log records into\n+ * short human-readable messages, typically one or two lines.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class SimpleFormatter\n+  extends Formatter\n+{\n+  /**\n+   * Constructs a SimpleFormatter.\n+   */\n+  public SimpleFormatter()\n+  {\n+  }\n+\n+\n+  /**\n+   * An instance of a DateFormatter that is used for formatting\n+   * the time of a log record into a human-readable string,\n+   * according to the rules of the current locale.  The value\n+   * is set after the first invocation of format, since it is\n+   * common that a JVM will instantiate a SimpleFormatter without\n+   * ever using it.\n+   */\n+  private DateFormat dateFormat;\n+\n+  /**\n+   * The character sequence that is used to separate lines in the\n+   * generated stream. Somewhat surprisingly, the Sun J2SE 1.4\n+   * reference implementation always uses UNIX line endings, even on\n+   * platforms that have different line ending conventions (i.e.,\n+   * DOS). The GNU implementation does not replicate this bug.\n+   *\n+   * @see Sun bug parade, bug #4462871,\n+   * \"java.util.logging.SimpleFormatter uses hard-coded line separator\".\n+   */\n+  static final String lineSep = System.getProperty(\"line.separator\");\n+\n+\n+  /**\n+   * Formats a log record into a String.\n+   *\n+   * @param the log record to be formatted.\n+   *\n+   * @return a short human-readable message, typically one or two\n+   *   lines.  Lines are separated using the default platform line\n+   *   separator.\n+   *\n+   * @throws NullPointerException if <code>record</code>\n+   *         is <code>null</code>.\n+   */\n+  public String format(LogRecord record)\n+  {\n+    StringBuffer buf = new StringBuffer(180);\n+\n+    if (dateFormat == null)\n+      dateFormat = DateFormat.getDateTimeInstance();\n+\n+    buf.append(dateFormat.format(new Date(record.getMillis())));\n+    buf.append(' ');\n+    buf.append(record.getLoggerName());\n+    buf.append(lineSep);\n+\n+    buf.append(record.getLevel());\n+    buf.append(\": \");\n+    buf.append(formatMessage(record));\n+\n+    buf.append(lineSep);\n+\n+    return buf.toString();\n+  }\n+}"}, {"sha": "d9939a0f780abd168eb940f1358dcf88ae292fb0", "filename": "libjava/java/util/logging/SocketHandler.java", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FSocketHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FSocketHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FSocketHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,225 @@\n+/* SocketHandler.java\n+   -- a class for publishing log messages to network sockets\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+\n+/**\n+ * A <code>SocketHandler</code> publishes log records to\n+ * a TCP/IP socket.\n+ *\n+ * <p><strong>Configuration:</strong> Values of the subsequent\n+ * <code>LogManager</code> properties are taken into consideration\n+ * when a <code>SocketHandler</code> is initialized.\n+ * If a property is not defined, or if it has an invalid\n+ * value, a default is taken without an exception being thrown.\n+ *\n+ * <ul>\n+ *\n+ * <li><code>java.util.SocketHandler.level</code> - specifies\n+ *     the initial severity level threshold. Default value:\n+ *     <code>Level.ALL</code>.</li>\n+ *\n+ * <li><code>java.util.SocketHandler.filter</code> - specifies\n+ *     the name of a Filter class. Default value: No Filter.</li>\n+ *\n+ * <li><code>java.util.SocketHandler.formatter</code> - specifies\n+ *     the name of a Formatter class. Default value:\n+ *     <code>java.util.logging.XMLFormatter</code>.</li>\n+ *\n+ * <li><code>java.util.SocketHandler.encoding</code> - specifies\n+ *     the name of the character encoding. Default value:\n+ *     the default platform encoding.\n+ *\n+ * <li><code>java.util.SocketHandler.host</code> - specifies\n+ *     the name of the host to which records are published.\n+ *     There is no default value for this property; if it is\n+ *     not set, the SocketHandler constructor will throw\n+ *     an exception.</li>\n+ *\n+ * <li><code>java.util.SocketHandler.port</code> - specifies\n+ *     the TCP/IP port to which records are published.\n+ *     There is no default value for this property; if it is\n+ *     not set, the SocketHandler constructor will throw\n+ *     an exception.</li>\n+ *\n+ * </ul>\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class SocketHandler\n+  extends StreamHandler\n+{\n+  /**\n+   * Constructs a <code>SocketHandler</code> that publishes log\n+   * records to a TCP/IP socket.  Tthe initial configuration is\n+   * determined by the <code>LogManager</code> properties described\n+   * above.\n+   *\n+   * @throws java.io.IOException if the connection to the specified\n+   *         network host and port cannot be established.\n+   *\n+   * @throws java.lang.IllegalArgumentException if either the\n+   *         <code>java.util.logging.SocketHandler.host</code>\n+   *         or <code>java.util.logging.SocketHandler.port</code>\n+   *         LogManager properties is not defined, or specifies\n+   *         an invalid value.\n+   */\n+  public SocketHandler()\n+    throws java.io.IOException\n+  {\n+    this(LogManager.getLogManager().getProperty(\"java.util.logging.SocketHandler.host\"),\n+\t getPortNumber());\n+  }\n+\n+    \n+  /**\n+   * Constructs a <code>SocketHandler</code> that publishes log\n+   * records to a TCP/IP socket.  With the exception of the internet\n+   * host and port, the initial configuration is determined by the\n+   * <code>LogManager</code> properties described above.\n+   *\n+   * @param host the Internet host to which log records will be\n+   *        forwarded.\n+   *\n+   * @param port the port at the host which will accept a request\n+   *        for a TCP/IP connection.\n+   *\n+   * @throws java.io.IOException if the connection to the specified\n+   *         network host and port cannot be established.\n+   *\n+   * @throws java.lang.IllegalArgumentException if either\n+   *         <code>host</code> or <code>port</code> specify\n+   *         an invalid value.\n+   */\n+  public SocketHandler(String host, int port)\n+    throws java.io.IOException\n+  {\n+    super(createSocket(host, port),\n+\t  \"java.util.logging.SocketHandler\",\n+\t  /* default level */ Level.ALL,\n+\t  /* formatter */ null,\n+\t  /* default formatter */ XMLFormatter.class);\n+  }\n+\n+\n+  /**\n+   * Retrieves the port number from the java.util.logging.SocketHandler.port\n+   * LogManager property.\n+   *\n+   * @throws IllegalArgumentException if the property is not defined or\n+   *         does not specify an integer value.\n+   */\n+  private static int getPortNumber()\n+  {\n+    try {\n+      return Integer.parseInt(LogManager.getLogManager().getProperty(\"java.util.logging.SocketHandler.port\"));\n+    } catch (Exception ex) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+\n+  /**\n+   * Creates an OutputStream for publishing log records to an Internet\n+   * host and port.  This private method is a helper for use by the\n+   * constructor of SocketHandler.\n+   *\n+   * @param host the Internet host to which log records will be\n+   *        forwarded.\n+   *\n+   * @param port the port at the host which will accept a request\n+   *        for a TCP/IP connection.\n+   *\n+   * @throws java.io.IOException if the connection to the specified\n+   *         network host and port cannot be established.\n+   *\n+   * @throws java.lang.IllegalArgumentException if either\n+   *         <code>host</code> or <code>port</code> specify\n+   *         an invalid value.\n+   */\n+  private static java.io.OutputStream createSocket(String host, int port)\n+    throws java.io.IOException, java.lang.IllegalArgumentException\n+  {\n+    java.net.Socket  socket;\n+\n+    if ((host == null) || (port < 1))\n+      throw new IllegalArgumentException();\n+\n+    socket = new java.net.Socket(host, port);\n+\n+    socket.shutdownInput();\n+\n+    /* The architecture of the logging framework provides replaceable\n+     * formatters.  Because these formatters perform their task by\n+     * returning one single String for each LogRecord to be formatted,\n+     * there is no need to buffer.\n+     */\n+    socket.setTcpNoDelay(true);\n+\n+    return socket.getOutputStream();\n+  }\n+\n+\n+  /**\n+   * Publishes a <code>LogRecord</code> to the network socket,\n+   * provided the record passes all tests for being loggable.\n+   * In addition, all data that may have been buffered will\n+   * be forced to the network stream.\n+   *\n+   * <p>Most applications do not need to call this method directly.\n+   * Instead, they will use a {@link Logger} instance, which will\n+   * create LogRecords and distribute them to registered handlers.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>SocketHandler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * @param record the log event to be published.\n+   */\n+  public void publish(LogRecord record)\n+  {\n+    super.publish(record);\n+    flush();\n+  }\n+}\n+    "}, {"sha": "add2d3a22cc16e955e54d6717b32f477c81591f1", "filename": "libjava/java/util/logging/StreamHandler.java", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FStreamHandler.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,524 @@\n+/* StreamHandler.java\n+   -- a class for publishing log messages to instances of java.io.OutputStream\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UnsupportedEncodingException;\n+import java.io.Writer;\n+\n+/**\n+ * A <code>StreamHandler</code> publishes <code>LogRecords</code> to\n+ * a instances of <code>java.io.OutputStream</code>.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class StreamHandler\n+  extends Handler\n+{\n+  private OutputStream  out;\n+  private Writer        writer;\n+\n+\n+ /**\n+  * Indicates the current state of this StreamHandler.  The value\n+  * should be one of STATE_FRESH, STATE_PUBLISHED, or STATE_CLOSED.\n+  */\n+  private int streamState = STATE_FRESH;\n+\n+\n+  /**\n+   * streamState having this value indicates that the StreamHandler\n+   * has been created, but the publish(LogRecord) method has not been\n+   * called yet.  If the StreamHandler has been constructed without an\n+   * OutputStream, writer will be null, otherwise it is set to a\n+   * freshly created OutputStreamWriter.\n+   */\n+  private static final int STATE_FRESH = 0;\n+\n+\n+  /**\n+   * streamState having this value indicates that the publish(LocRecord)\n+   * method has been called at least once.\n+   */\n+  private static final int STATE_PUBLISHED = 1;\n+\n+\n+  /**\n+   * streamState having this value indicates that the close() method\n+   * has been called.\n+   */\n+  private static final int STATE_CLOSED = 2;\n+\n+\n+  /**\n+   * Creates a <code>StreamHandler</code> without an output stream.\n+   * Subclasses can later use {@link\n+   * #setOutputStream(java.io.OutputStream)} to associate an output\n+   * stream with this StreamHandler.\n+   */\n+  public StreamHandler()\n+  {\n+    this(null, null);\n+  }\n+\n+\n+  /**\n+   * Creates a <code>StreamHandler</code> that formats log messages\n+   * with the specified Formatter and publishes them to the specified\n+   * output stream.\n+   *\n+   * @param out the output stream to which the formatted log messages\n+   *     are published.\n+   *\n+   * @param formatter the <code>Formatter</code> that will be used\n+   *     to format log messages.\n+   */\n+  public StreamHandler(OutputStream out, Formatter formatter)\n+  {\n+    this(out, \"java.util.logging.StreamHandler\", Level.INFO,\n+\t formatter, SimpleFormatter.class);\n+  }\n+\n+\n+  StreamHandler(\n+    OutputStream out,\n+    String propertyPrefix,\n+    Level defaultLevel,\n+    Formatter formatter, Class defaultFormatterClass)\n+  {\n+    this.level = LogManager.getLevelProperty(propertyPrefix + \".level\",\n+\t\t\t\t\t     defaultLevel);\n+\n+    this.filter = (Filter) LogManager.getInstanceProperty(\n+      propertyPrefix + \".filter\",\n+      /* must be instance of */       Filter.class,\n+      /* default: new instance of */  null);\n+\n+    if (formatter != null)\n+      this.formatter = formatter;\n+    else\n+      this.formatter = (Formatter) LogManager.getInstanceProperty(\n+\tpropertyPrefix + \".formatter\",\n+        /* must be instance of */       Formatter.class,\n+        /* default: new instance of */  defaultFormatterClass);\n+\n+    try\n+    {\n+      String enc = LogManager.getLogManager().getProperty(propertyPrefix\n+\t\t\t\t\t\t\t  + \".encoding\");\n+\n+      /* make sure enc actually is a valid encoding */\n+      if ((enc != null) && (enc.length() > 0))\n+        new String(new byte[0], enc);\n+\n+      this.encoding = enc;\n+    }\n+    catch (Exception _)\n+    {\n+    }\n+\n+    if (out != null)\n+    {\n+      try\n+      {\n+        changeWriter(out, getEncoding());\n+      }\n+      catch (UnsupportedEncodingException uex)\n+      {\n+\t/* This should never happen, since the validity of the encoding\n+\t * name has been checked above.\n+\t */\n+\tthrow new RuntimeException(uex.getMessage());\n+      }\n+    }\n+  }\n+\n+\n+  private void checkOpen()\n+  {\n+    if (streamState == STATE_CLOSED)\n+      throw new IllegalStateException(this.toString() + \" has been closed\");\n+  }\n+\n+  private void checkFresh()\n+  {\n+    checkOpen();\n+    if (streamState != STATE_FRESH)\n+      throw new IllegalStateException(\"some log records have been published to \" + this);\n+  }\n+\n+\n+  private void changeWriter(OutputStream out, String encoding)\n+    throws UnsupportedEncodingException\n+  {\n+    OutputStreamWriter writer;\n+\n+    /* The logging API says that a null encoding means the default\n+     * platform encoding. However, java.io.OutputStreamWriter needs\n+     * another constructor for the default platform encoding,\n+     * passing null would throw an exception.\n+     */\n+    if (encoding == null)\n+      writer = new OutputStreamWriter(out);\n+    else\n+      writer = new OutputStreamWriter(out, encoding);\n+\n+    /* Closing the stream has side effects -- do this only after\n+     * creating a new writer has been successful.\n+     */\n+    if ((streamState != STATE_FRESH) || (this.writer != null))\n+      close();\n+\n+    this.writer = writer;\n+    this.out = out;\n+    this.encoding = encoding;\n+    streamState = STATE_FRESH;\n+  }\n+\n+\n+  /**\n+   * Sets the character encoding which this handler uses for publishing\n+   * log records.  The encoding of a <code>StreamHandler</code> must be\n+   * set before any log records have been published.\n+   *\n+   * @param encoding the name of a character encoding, or <code>null</code>\n+   *            for the default encoding.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *     the caller is not granted the permission to control the\n+   *     the logging infrastructure.\n+   *\n+   * @exception IllegalStateException if any log records have been\n+   *     published to this <code>StreamHandler</code> before.  Please\n+   *     be aware that this is a pecularity of the GNU implementation.\n+   *     While the API specification indicates that it is an error\n+   *     if the encoding is set after records have been published,\n+   *     it does not mandate any specific behavior for that case.\n+   */\n+  public void setEncoding(String encoding)\n+    throws SecurityException, UnsupportedEncodingException\n+  {\n+    /* The inherited implementation first checks whether the invoking\n+     * code indeed has the permission to control the logging infra-\n+     * structure, and throws a SecurityException if this was not the\n+     * case.\n+     *\n+     * Next, it verifies that the encoding is supported and throws\n+     * an UnsupportedEncodingExcpetion otherwise. Finally, it remembers\n+     * the name of the encoding.\n+     */\n+    super.setEncoding(encoding);\n+\n+    checkFresh();\n+\n+    /* If out is null, setEncoding is being called before an output\n+     * stream has been set. In that case, we need to check that the\n+     * encoding is valid, and remember it if this is the case.  Since\n+     * this is exactly what the inherited implementation of\n+     * Handler.setEncoding does, we can delegate.\n+     */\n+    if (out != null)\n+    {\n+      /* The logging API says that a null encoding means the default\n+       * platform encoding. However, java.io.OutputStreamWriter needs\n+       * another constructor for the default platform encoding, passing\n+       * null would throw an exception.\n+       */\n+      if (encoding == null)\n+\twriter = new OutputStreamWriter(out);\n+      else\n+\twriter = new OutputStreamWriter(out, encoding);\n+    }\n+  }\n+\n+\n+  /**\n+   * Changes the output stream to which this handler publishes\n+   * logging records.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   *\n+   * @throws NullPointerException if <code>out</code>\n+   *         is <code>null</code>.\n+   */\n+  protected void setOutputStream(OutputStream out)\n+    throws SecurityException\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    /* Throw a NullPointerException if out is null. */\n+    out.getClass();\n+\n+    try\n+    {\n+      changeWriter(out, getEncoding());\n+    }\n+    catch (UnsupportedEncodingException ex)\n+    {\n+      /* This seems quite unlikely to happen, unless the underlying\n+       * implementation of java.io.OutputStreamWriter changes its\n+       * mind (at runtime) about the set of supported character\n+       * encodings.\n+       */\n+      throw new RuntimeException(ex.getMessage());\n+    }\n+  }\n+\n+\n+  /**\n+   * Publishes a <code>LogRecord</code> to the associated output\n+   * stream, provided the record passes all tests for being loggable.\n+   * The <code>StreamHandler</code> will localize the message of the\n+   * log record and substitute any message parameters.\n+   *\n+   * <p>Most applications do not need to call this method directly.\n+   * Instead, they will use use a {@link Logger}, which will create\n+   * LogRecords and distribute them to registered handlers.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * <p>If a log record is being published to a\n+   * <code>StreamHandler</code> that has been closed earlier, the Sun\n+   * J2SE 1.4 reference can be observed to silently ignore the\n+   * call. The GNU implementation, however, intentionally behaves\n+   * differently by informing the <code>ErrorManager</code> associated\n+   * with this <code>StreamHandler</code>.  Since the condition\n+   * indicates a programming error, the programmer should be\n+   * informed. It also seems extremely unlikely that any application\n+   * would depend on the exact behavior in this rather obscure,\n+   * erroneous case -- especially since the API specification does not\n+   * prescribe what is supposed to happen.\n+   * \n+   * @param record the log event to be published.\n+   */\n+  public void publish(LogRecord record)\n+  {\n+    String formattedMessage;\n+\n+    if (!isLoggable(record))\n+      return;\n+\n+    if (streamState == STATE_FRESH)\n+    {\n+      try\n+      {\n+        writer.write(formatter.getHead(this));\n+      }\n+      catch (java.io.IOException ex)\n+      {\n+\treportError(null, ex, ErrorManager.WRITE_FAILURE);\n+\treturn;\n+      }\n+      catch (Exception ex)\n+      {\n+\treportError(null, ex, ErrorManager.GENERIC_FAILURE);\n+\treturn;\n+      }\n+\n+      streamState = STATE_PUBLISHED;\n+    }\n+\n+    try\n+    {\n+      formattedMessage = formatter.format(record);\n+    }\n+    catch (Exception ex)\n+    {\n+      reportError(null, ex, ErrorManager.FORMAT_FAILURE);\n+      return;\n+    }\n+\n+    try\n+    {\n+      writer.write(formattedMessage);\n+    }\n+    catch (Exception ex)\n+    {\n+      reportError(null, ex, ErrorManager.WRITE_FAILURE);\n+    }\n+  }\n+\n+\n+  /**\n+   * Checks whether or not a <code>LogRecord</code> would be logged\n+   * if it was passed to this <code>StreamHandler</code> for publication.\n+   *\n+   * <p>The <code>StreamHandler</code> implementation first checks\n+   * whether a writer is present and the handler's level is greater\n+   * than or equal to the severity level threshold.  In a second step,\n+   * if a {@link Filter} has been installed, its {@link\n+   * Filter#isLoggable(LogRecord) isLoggable} method is\n+   * invoked. Subclasses of <code>StreamHandler</code> can override\n+   * this method to impose their own constraints.\n+   *\n+   * @param record the <code>LogRecord</code> to be checked.\n+   *\n+   * @return <code>true</code> if <code>record</code> would\n+   *         be published by {@link #publish(LogRecord) publish},\n+   *         <code>false</code> if it would be discarded.\n+   *\n+   * @see #setLevel(Level)\n+   * @see #setFilter(Filter)\n+   * @see Filter#isLoggable(LogRecord)\n+   *\n+   * @throws NullPointerException if <code>record</code> is\n+   *         <code>null</code>.  */\n+  public boolean isLoggable(LogRecord record)\n+  {\n+    return (writer != null) && super.isLoggable(record);\n+  }\n+\n+\n+  /**\n+   * Forces any data that may have been buffered to the underlying\n+   * output device.\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.\n+   *\n+   * <p>If a <code>StreamHandler</code> that has been closed earlier\n+   * is closed a second time, the Sun J2SE 1.4 reference can be\n+   * observed to silently ignore the call. The GNU implementation,\n+   * however, intentionally behaves differently by informing the\n+   * <code>ErrorManager</code> associated with this\n+   * <code>StreamHandler</code>.  Since the condition indicates a\n+   * programming error, the programmer should be informed. It also\n+   * seems extremely unlikely that any application would depend on the\n+   * exact behavior in this rather obscure, erroneous case --\n+   * especially since the API specification does not prescribe what is\n+   * supposed to happen.\n+   */\n+  public void flush()\n+  {\n+    try\n+    {\n+      checkOpen();\n+      if (writer != null)\n+        writer.flush();\n+    }\n+    catch (Exception ex)\n+    {\n+      reportError(null, ex, ErrorManager.FLUSH_FAILURE);\n+    }\n+  }\n+\n+\n+  /**\n+   * Closes this <code>StreamHandler</code> after having forced any\n+   * data that may have been buffered to the underlying output\n+   * device. \n+   *\n+   * <p>As soon as <code>close</code> has been called,\n+   * a <code>Handler</code> should not be used anymore. Attempts\n+   * to publish log records, to flush buffers, or to modify the\n+   * <code>Handler</code> in any other way may throw runtime\n+   * exceptions after calling <code>close</code>.</p>\n+   *\n+   * <p>In case of an I/O failure, the <code>ErrorManager</code>\n+   * of this <code>Handler</code> will be informed, but the caller\n+   * of this method will not receive an exception.</p>\n+   *\n+   * <p>If a <code>StreamHandler</code> that has been closed earlier\n+   * is closed a second time, the Sun J2SE 1.4 reference can be\n+   * observed to silently ignore the call. The GNU implementation,\n+   * however, intentionally behaves differently by informing the\n+   * <code>ErrorManager</code> associated with this\n+   * <code>StreamHandler</code>.  Since the condition indicates a\n+   * programming error, the programmer should be informed. It also\n+   * seems extremely unlikely that any application would depend on the\n+   * exact behavior in this rather obscure, erroneous case --\n+   * especially since the API specification does not prescribe what is\n+   * supposed to happen.\n+   *\n+   * @throws SecurityException if a security manager exists and\n+   *         the caller is not granted the permission to control\n+   *         the logging infrastructure.\n+   */\n+  public void close()\n+    throws SecurityException\n+  {\n+    LogManager.getLogManager().checkAccess();\n+\n+    try\n+    {\n+      /* Although  flush also calls checkOpen, it catches\n+       * any exceptions and reports them to the ErrorManager\n+       * as flush failures.  However, we want to report\n+       * a closed stream as a close failure, not as a\n+       * flush failure here.  Therefore, we call checkOpen()\n+       * before flush().\n+       */\n+      checkOpen();\n+      flush();\n+\n+      if (writer != null)\n+      {\n+\tif (formatter != null)\n+\t{\n+\t  /* Even if the StreamHandler has never published a record,\n+\t   * it emits head and tail upon closing. An earlier version\n+\t   * of the GNU Classpath implementation did not emitted\n+\t   * anything. However, this had caused XML log files to be\n+\t   * entirely empty instead of containing no log records.\n+\t   */\n+\t  if (streamState == STATE_FRESH)\n+            writer.write(formatter.getHead(this));\n+\t  if (streamState != STATE_CLOSED)\n+\t    writer.write(formatter.getTail(this));\n+\t}\n+\tstreamState = STATE_CLOSED;\n+        writer.close();\n+      }\n+    }\n+    catch (Exception ex)\n+    {\n+      reportError(null, ex, ErrorManager.CLOSE_FAILURE);\n+    }\n+  }\n+}"}, {"sha": "fbaab1cde3fb6bdfea560a13459140ccd77954a1", "filename": "libjava/java/util/logging/XMLFormatter.java", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FXMLFormatter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c9050c37f33240921ea92a0f82320687e7998/libjava%2Fjava%2Futil%2Flogging%2FXMLFormatter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Flogging%2FXMLFormatter.java?ref=2d0c9050c37f33240921ea92a0f82320687e7998", "patch": "@@ -0,0 +1,395 @@\n+/* XMLFormatter.java\n+   -- a class for formatting log messages into a standard XML format\n+\n+Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version.\n+\n+*/\n+\n+\n+package java.util.logging;\n+\n+import java.util.Date;\n+import java.util.ResourceBundle;\n+import java.text.MessageFormat;\n+import java.text.SimpleDateFormat;\n+\n+/**\n+ * An <code>XMLFormatter</code> formats LogRecords into\n+ * a standard XML format.\n+ *\n+ * @author Sascha Brawer (brawer@acm.org)\n+ */\n+public class XMLFormatter\n+  extends Formatter\n+{\n+  /**\n+   * Constructs a new XMLFormatter.\n+   */\n+  public XMLFormatter()\n+  {\n+  }\n+\n+\n+  /**\n+   * The character sequence that is used to separate lines in the\n+   * generated XML stream. Somewhat surprisingly, the Sun J2SE 1.4\n+   * reference implementation always uses UNIX line endings, even on\n+   * platforms that have different line ending conventions (i.e.,\n+   * DOS). The GNU Classpath implementation does not replicates this\n+   * bug.\n+   *\n+   * See also the Sun bug parade, bug #4462871,\n+   * \"java.util.logging.SimpleFormatter uses hard-coded line separator\".\n+   */\n+  private static final String lineSep = SimpleFormatter.lineSep;\n+\n+    \n+  /**\n+   * A DateFormat for emitting time in the ISO 8601 format.\n+   * Since the API specification of SimpleDateFormat does not talk\n+   * about its thread-safety, we cannot share a singleton instance.\n+   */\n+  private final SimpleDateFormat iso8601\n+    = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+\n+  /**\n+   * Appends a line consisting of indentation, opening element tag,\n+   * element content, closing element tag and line separator to\n+   * a StringBuffer, provided that the element content is\n+   * actually existing.\n+   *\n+   * @param buf the StringBuffer to which the line will be appended.\n+   *\n+   * @param indent the indentation level.\n+   *\n+   * @param tag the element tag name, for instance <code>method</code>.\n+   *\n+   * @param content the element content, or <code>null</code> to\n+   *        have no output whatsoever appended to <code>buf</code>.\n+   */\n+  private static final void appendTag(StringBuffer buf,\n+\t\t\t\t      int indent,\n+\t\t\t\t      String tag,\n+\t\t\t\t      String content)\n+  {\n+    int i;\n+\n+    if (content == null)\n+      return;\n+\n+    for (i = 0; i < indent * 2; i++)\n+      buf.append(' ');\n+\n+    buf.append(\"<\");\n+    buf.append(tag);\n+    buf.append('>');\n+\n+    /* Append the content, but escape for XML by replacing\n+     * '&', '<', '>' and all non-ASCII characters with\n+     * appropriate escape sequences.\n+     * The Sun J2SE 1.4 reference implementation does not\n+     * escape non-ASCII characters. This is a bug in their\n+     * implementation which has been reported in the Java\n+     * bug parade as bug number (FIXME: Insert number here).\n+     */\n+    for (i = 0; i < content.length(); i++)\n+    {\n+      char c = content.charAt(i);\n+      switch (c)\n+      {\n+      case '&':\n+\tbuf.append(\"&amp;\");\n+\tbreak;\n+\n+      case '<':\n+\tbuf.append(\"&lt;\");\n+\tbreak;\n+\n+      case '>':\n+\tbuf.append(\"&gt;\");\n+\tbreak;\n+\n+      default:\n+\tif (((c >= 0x20) && (c <= 0x7e))\n+\t    || (c == /* line feed */ 10)\n+\t    || (c == /* carriage return */ 13))\n+\t  buf.append(c);\n+\telse\n+\t{\n+\t  buf.append(\"&#\");\n+\t  buf.append((int) c);\n+\t  buf.append(';');\n+\t}\n+\tbreak;\n+      } /* switch (c) */\n+    } /* for i */\n+\n+    buf.append(\"</\");\n+    buf.append(tag);\n+    buf.append(\">\");\n+    buf.append(lineSep);\n+  }\n+\n+\n+  /**\n+   * Appends a line consisting of indentation, opening element tag,\n+   * numeric element content, closing element tag and line separator\n+   * to a StringBuffer.\n+   *\n+   * @param buf the StringBuffer to which the line will be appended.\n+   *\n+   * @param indent the indentation level.\n+   *\n+   * @param tag the element tag name, for instance <code>method</code>.\n+   *\n+   * @param content the element content.\n+   */\n+  private static final void appendTag(StringBuffer buf,\n+\t\t\t\t      int indent,\n+\t\t\t\t      String tag,\n+\t\t\t\t      long content)\n+  {\n+    appendTag(buf, indent, tag, Long.toString(content));\n+  }\n+\n+\n+  public String format(LogRecord record)\n+  {\n+    StringBuffer    buf = new StringBuffer(400);\n+    Level           level = record.getLevel();\n+    long            millis = record.getMillis();\n+    Object[]        params = record.getParameters();\n+    ResourceBundle  bundle = record.getResourceBundle();\n+    String          key, message;\n+    \n+    buf.append(\"<record>\");\n+    buf.append(lineSep);\n+    \n+    \n+    appendTag(buf, 1, \"date\", iso8601.format(new Date(millis)));\n+    appendTag(buf, 1, \"millis\", record.getMillis());\n+    appendTag(buf, 1, \"sequence\", record.getSequenceNumber());\n+    appendTag(buf, 1, \"logger\", record.getLoggerName());\n+\n+    if (level.isStandardLevel())\n+      appendTag(buf, 1, \"level\", level.toString());\n+    else\n+      appendTag(buf, 1, \"level\", level.intValue());\n+\n+    appendTag(buf, 1, \"class\", record.getSourceClassName());\n+    appendTag(buf, 1, \"method\", record.getSourceMethodName());\n+    appendTag(buf, 1, \"thread\", record.getThreadID());\n+\n+    /* The Sun J2SE 1.4 reference implementation does not emit the\n+     * message in localized form. This is in violation of the API\n+     * specification. The GNU Classpath implementation intentionally\n+     * replicates the buggy behavior of the Sun implementation, as\n+     * different log files might be a big nuisance to users.\n+     */\n+    try\n+    {\n+      record.setResourceBundle(null);\n+      message = formatMessage(record);\n+    }\n+    finally\n+    {\n+      record.setResourceBundle(bundle);\n+    }\n+    appendTag(buf, 1, \"message\", message);\n+\n+    /* The Sun J2SE 1.4 reference implementation does not\n+     * emit key, catalog and param tags. This is in violation\n+     * of the API specification.  The Classpath implementation\n+     * intentionally replicates the buggy behavior of the\n+     * Sun implementation, as different log files might be\n+     * a big nuisance to users.\n+     *\n+     * FIXME: File a bug report with Sun. Insert bug number here.\n+     *\n+     *\n+     * key = record.getMessage();\n+     * if (key == null)\n+     *   key = \"\";\n+     *\n+     * if ((bundle != null) && !key.equals(message))\n+     * {\n+     *   appendTag(buf, 1, \"key\", key);\n+     *   appendTag(buf, 1, \"catalog\", record.getResourceBundleName());\n+     * }\n+     *\n+     * if (params != null)\n+     * {\n+     *   for (int i = 0; i < params.length; i++)\n+     *     appendTag(buf, 1, \"param\", params[i].toString());\n+     * }\n+     */\n+\n+    /* FIXME: We have no way to obtain the stacktrace before free JVMs\n+     * support the corresponding method in java.lang.Throwable.  Well,\n+     * it would be possible to parse the output of printStackTrace,\n+     * but this would be pretty kludgy. Instead, we postpose the\n+     * implementation until Throwable has made progress.\n+     */\n+    Throwable thrown = record.getThrown();\n+    if (thrown != null)\n+    {\n+      buf.append(\"  <exception>\");\n+      buf.append(lineSep);\n+\n+      /* The API specification is not clear about what exactly\n+       * goes into the XML record for a thrown exception: It\n+       * could be the result of getMessage(), getLocalizedMessage(),\n+       * or toString(). Therefore, it was necessary to write a\n+       * Mauve testlet and run it with the Sun J2SE 1.4 reference\n+       * implementation. It turned out that the we need to call\n+       * toString().\n+       *\n+       * FIXME: File a bug report with Sun, asking for clearer\n+       * specs.\n+       */\n+      appendTag(buf, 2, \"message\", thrown.toString());\n+\n+      /* FIXME: The Logging DTD specifies:\n+       *\n+       * <!ELEMENT exception (message?, frame+)>\n+       *\n+       * However, java.lang.Throwable.getStackTrace() is\n+       * allowed to return an empty array. So, what frame should\n+       * be emitted for an empty stack trace? We probably\n+       * should file a bug report with Sun, asking for the DTD\n+       * to be changed.\n+       */\n+\n+      buf.append(\"  </exception>\");\n+      buf.append(lineSep);\n+    }\n+\n+\n+    buf.append(\"</record>\");\n+    buf.append(lineSep);\n+\n+    return buf.toString();\n+  }\n+\n+\n+  /**\n+   * Returns a string that handlers are supposed to emit before\n+   * the first log record.  The base implementation returns an\n+   * empty string, but subclasses such as {@link XMLFormatter}\n+   * override this method in order to provide a suitable header.\n+   *\n+   * @return a string for the header.\n+   *\n+   * @param handler the handler which will prepend the returned\n+   *     string in front of the first log record.  This method\n+   *     will inspect certain properties of the handler, for\n+   *     example its encoding, in order to construct the header.\n+   */\n+  public String getHead(Handler h)\n+  {\n+    StringBuffer  buf;\n+    String        encoding;\n+\n+    buf = new StringBuffer(80);\n+    buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n+\n+    encoding = h.getEncoding();\n+\n+    /* file.encoding is a system property with the Sun JVM, indicating\n+     * the platform-default file encoding. Unfortunately, the API\n+     * specification for java.lang.System.getProperties() does not\n+     * list this property.\n+     */\n+    if (encoding == null)\n+      encoding = System.getProperty(\"file.encoding\");\n+\n+    /* Since file.encoding is not listed with the API specification of\n+     * java.lang.System.getProperties(), there might be some VMs that\n+     * do not define this system property.  Therefore, we use UTF-8 as\n+     * a reasonable default. Please note that if the platform encoding\n+     * uses the same codepoints as US-ASCII for the US-ASCII character\n+     * set (e.g, 65 for A), it does not matter whether we emit the\n+     * wrong encoding into the XML header -- the GNU Classpath will\n+     * emit XML escape sequences like &#1234; for any non-ASCII\n+     * character.  Virtually all character encodings use the same code\n+     * points as US-ASCII for ASCII characters.  Probably, EBCDIC is\n+     * the only exception.\n+     */\n+    if (encoding == null)\n+      encoding = \"UTF-8\";\n+    \n+    /* On Windows XP localized for Swiss German (this is one of\n+     * my [Sascha Brawer's] test machines), the default encoding\n+     * has the canonical name \"windows-1252\". The \"historical\" name\n+     * of this encoding is \"Cp1252\" (see the Javadoc for the class\n+     * java.nio.charset.Charset for the distinction). Now, that class\n+     * does have a method for mapping historical to canonical encoding\n+     * names. However, if we used it here, we would be come dependent\n+     * on java.nio.*, which was only introduced with J2SE 1.4.\n+     * Thus, we do this little hack here. As soon as Classpath supports\n+     * java.nio.charset.CharSet, this hack should be replaced by\n+     * code that correctly canonicalizes the encoding name.\n+     */\n+    if ((encoding.length() > 2) && encoding.startsWith(\"Cp\"))\n+      encoding = \"windows-\" + encoding.substring(2);\n+\n+    buf.append(encoding);\n+\n+    buf.append(\"\\\" standalone=\\\"no\\\"?>\");\n+    buf.append(lineSep);\n+\n+    /* SYSTEM is not a fully qualified URL so that validating\n+     * XML parsers do not need to connect to the Internet in\n+     * order to read in a log file.  See also the Sun Bug Parade,\n+     * bug #4372790, \"Logging APIs: need to use relative URL for XML\n+     * doctype\".\n+     */\n+    buf.append(\"<!DOCTYPE log SYSTEM \\\"logger.dtd\\\">\");\n+    buf.append(lineSep);\n+    buf.append(\"<log>\");\n+    buf.append(lineSep);\n+\n+    return buf.toString();\n+  }\n+\n+\n+  public String getTail(Handler h)\n+  {\n+    return \"</log>\" + lineSep;\n+  }\n+}"}]}