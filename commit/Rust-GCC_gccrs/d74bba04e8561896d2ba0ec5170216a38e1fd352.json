{"sha": "d74bba04e8561896d2ba0ec5170216a38e1fd352", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0YmJhMDRlODU2MTg5NmQyYmEwZWM1MTcwMjE2YTM4ZTFmZDM1Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-06-25T05:29:22Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-06-25T05:29:22Z"}, "message": "natPlainDatagramSocketImpl.cc (BooleanClass): Removed.\n\n\t* java/net/natPlainDatagramSocketImpl.cc (BooleanClass): Removed.\n\t(IntegerClass): Likewise.\n\t* java/lang/natClass.cc (CloneableClass): Removed.\n\t(ObjectClass, ErrorClass, ClassClass, MethodClass, FieldClass,\n\tConstructorClass): Likewise.\n\t* java/lang/natClassLoader.cc (CloneableClass): Removed.\n\t(ObjectClass, ClassClass, VMClassLoaderClass, ClassLoaderClass,\n\tSerializableClass): Likewise.\n\t* java/lang/reflect/natMethod.cc (BooleanClass): Removed.\n\t(VoidClass, ByteClass, ShortClass, CharacterClass, IntegerClass,\n\tLongClass, FloatClass, DoubleClass): Likewise.\n\nFrom-SVN: r54977", "tree": {"sha": "5511f3352a20d4f21a558daeea7feda7f1cb7cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5511f3352a20d4f21a558daeea7feda7f1cb7cbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74bba04e8561896d2ba0ec5170216a38e1fd352", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74bba04e8561896d2ba0ec5170216a38e1fd352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74bba04e8561896d2ba0ec5170216a38e1fd352", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74bba04e8561896d2ba0ec5170216a38e1fd352/comments", "author": null, "committer": null, "parents": [{"sha": "b41e09a79f0a1f2de0dbd31963f1edd54287f99c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41e09a79f0a1f2de0dbd31963f1edd54287f99c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41e09a79f0a1f2de0dbd31963f1edd54287f99c"}], "stats": {"total": 142, "additions": 67, "deletions": 75}, "files": [{"sha": "84ae3a2b451ce5d13c8520c0ca0f7b87339cbfc6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d74bba04e8561896d2ba0ec5170216a38e1fd352", "patch": "@@ -1,5 +1,17 @@\n 2002-06-24  Tom Tromey  <tromey@redhat.com>\n \n+\t* java/net/natPlainDatagramSocketImpl.cc (BooleanClass): Removed.\n+\t(IntegerClass): Likewise.\n+\t* java/lang/natClass.cc (CloneableClass): Removed.\n+\t(ObjectClass, ErrorClass, ClassClass, MethodClass, FieldClass,\n+\tConstructorClass): Likewise.\n+\t* java/lang/natClassLoader.cc (CloneableClass): Removed.\n+\t(ObjectClass, ClassClass, VMClassLoaderClass, ClassLoaderClass,\n+\tSerializableClass): Likewise.\n+\t* java/lang/reflect/natMethod.cc (BooleanClass): Removed.\n+\t(VoidClass, ByteClass, ShortClass, CharacterClass, IntegerClass,\n+\tLongClass, FloatClass, DoubleClass): Likewise.\n+\n \t* verify.cc (branch_prepass): Updated for change to exception\n \thandler type.\n \t(verify_instructions_0): Likewise."}, {"sha": "539909025663c2d2882319a1ce55588feab728a6", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=d74bba04e8561896d2ba0ec5170216a38e1fd352", "patch": "@@ -1,6 +1,6 @@\n // natClass.cc - Implementation of java.lang.Class native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -53,17 +53,6 @@ details.  */\n \n \f\n \n-// FIXME: remove these.\n-#define CloneableClass java::lang::Cloneable::class$\n-#define ObjectClass java::lang::Object::class$\n-#define ErrorClass java::lang::Error::class$\n-#define ClassClass java::lang::Class::class$\n-#define MethodClass java::lang::reflect::Method::class$\n-#define FieldClass java::lang::reflect::Field::class$\n-#define ConstructorClass java::lang::reflect::Constructor::class$\n-\n-\f\n-\n using namespace gcj;\n \n jclass\n@@ -174,7 +163,9 @@ java::lang::Class::_getConstructors (jboolean declared)\n     }\n   JArray<java::lang::reflect::Constructor *> *result\n     = (JArray<java::lang::reflect::Constructor *> *)\n-    JvNewObjectArray (numConstructors, &ConstructorClass, NULL);\n+    JvNewObjectArray (numConstructors,\n+\t\t      &java::lang::reflect::Constructor::class$,\n+\t\t      NULL);\n   java::lang::reflect::Constructor** cptr = elements (result);\n   for (i = 0;  i < max;  i++)\n     {\n@@ -273,7 +264,7 @@ java::lang::Class::getDeclaredFields (void)\n     s->checkMemberAccess (this, java::lang::reflect::Member::DECLARED);\n   JArray<java::lang::reflect::Field *> *result\n     = (JArray<java::lang::reflect::Field *> *)\n-    JvNewObjectArray (field_count, &FieldClass, NULL);\n+    JvNewObjectArray (field_count, &java::lang::reflect::Field::class$, NULL);\n   java::lang::reflect::Field** fptr = elements (result);\n   for (int i = 0;  i < field_count;  i++)\n     {\n@@ -366,7 +357,7 @@ java::lang::Class::getDeclaredMethods (void)\n     }\n   JArray<java::lang::reflect::Method *> *result\n     = (JArray<java::lang::reflect::Method *> *)\n-    JvNewObjectArray (numMethods, &MethodClass, NULL);\n+    JvNewObjectArray (numMethods, &java::lang::reflect::Method::class$, NULL);\n   java::lang::reflect::Method** mptr = elements (result);\n   for (i = 0;  i < max;  i++)\n     {\n@@ -402,7 +393,8 @@ java::lang::Class::getClasses (void)\n   // Until we have inner classes, it always makes sense to return an\n   // empty array.\n   JArray<jclass> *result\n-    = (JArray<jclass> *) JvNewObjectArray (0, &ClassClass, NULL);\n+    = (JArray<jclass> *) JvNewObjectArray (0, &java::lang::Class::class$,\n+\t\t\t\t\t   NULL);\n   return result;\n }\n \n@@ -413,7 +405,8 @@ java::lang::Class::getDeclaredClasses (void)\n   // Until we have inner classes, it always makes sense to return an\n   // empty array.\n   JArray<jclass> *result\n-    = (JArray<jclass> *) JvNewObjectArray (0, &ClassClass, NULL);\n+    = (JArray<jclass> *) JvNewObjectArray (0, &java::lang::Class::class$,\n+\t\t\t\t\t   NULL);\n   return result;\n }\n \n@@ -474,7 +467,7 @@ java::lang::Class::getFields (void)\n \n   JArray<java::lang::reflect::Field *> *result\n     = ((JArray<java::lang::reflect::Field *> *)\n-       JvNewObjectArray (count, &FieldClass, NULL));\n+       JvNewObjectArray (count, &java::lang::reflect::Field::class$, NULL));\n \n   _getFields (result, 0);\n \n@@ -614,7 +607,9 @@ java::lang::Class::getMethods (void)\n   jint count = _getMethods (NULL, 0);\n \n   JArray<Method *> *result\n-    = ((JArray<Method *> *) JvNewObjectArray (count, &MethodClass, NULL));\n+    = ((JArray<Method *> *) JvNewObjectArray (count,\n+\t\t\t\t\t      &Method::class$,\n+\t\t\t\t\t      NULL));\n \n   // When filling the array for real, we get the actual count.  Then\n   // we resize the array.\n@@ -623,7 +618,8 @@ java::lang::Class::getMethods (void)\n   if (real_count != count)\n     {\n       JArray<Method *> *r2\n-\t= ((JArray<Method *> *) JvNewObjectArray (real_count, &MethodClass,\n+\t= ((JArray<Method *> *) JvNewObjectArray (real_count,\n+\t\t\t\t\t\t  &Method::class$,\n \t\t\t\t\t\t  NULL));\n       \n       Method **destp = elements (r2);\n@@ -663,7 +659,7 @@ java::lang::Class::newInstance (void)\n   // seem to be any way to do these.\n   // FIXME: we special-case one check here just to pass a Plum Hall\n   // test.  Once access checking is implemented, remove this.\n-  if (this == &ClassClass)\n+  if (this == &java::lang::Class::class$)\n     throw new java::lang::IllegalAccessException;\n \n   if (isPrimitive ()\n@@ -780,7 +776,7 @@ java::lang::Class::initializeClass (void)\n     }\n   catch (java::lang::Throwable *except)\n     {\n-      if (! ErrorClass.isInstance(except))\n+      if (! java::lang::Error::class$.isInstance(except))\n \t{\n \t  try\n \t    {\n@@ -872,14 +868,14 @@ static void\n _Jv_AddMethodToCache (jclass klass,\n                        _Jv_Method *method)\n {\n-  _Jv_MonitorEnter (&ClassClass); \n+  _Jv_MonitorEnter (&java::lang::Class::class$); \n \n   int index = method->name->hash & MCACHE_SIZE;\n \n   method_cache[index].method = method;\n   method_cache[index].klass = klass;\n \n-  _Jv_MonitorExit (&ClassClass);\n+  _Jv_MonitorExit (&java::lang::Class::class$);\n }\n \n void *\n@@ -967,7 +963,7 @@ _Jv_IsAssignableFrom (jclass target, jclass source)\n   if (__builtin_expect (target->isPrimitive(), false))\n     return false;\n     \n-  if (target == &ObjectClass)\n+  if (target == &java::lang::Object::class$)\n     {\n       if (source->isPrimitive())\n         return false;\n@@ -1067,7 +1063,7 @@ _Jv_PrepareConstantTimeTables (jclass klass)\n    \n   jclass klass0 = klass;\n   jboolean has_interfaces = 0;\n-  while (klass0 != &ObjectClass)\n+  while (klass0 != &java::lang::Object::class$)\n     {\n       has_interfaces += klass0->interface_count;\n       klass0 = klass0->superclass;"}, {"sha": "9c83d593ebb77b1119ec132a176795504a7c98c5", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=d74bba04e8561896d2ba0ec5170216a38e1fd352", "patch": "@@ -41,14 +41,6 @@ details.  */\n #include <java/io/Serializable.h>\n #include <java/lang/Cloneable.h>\n \n-// FIXME: remove these.\n-#define CloneableClass java::lang::Cloneable::class$\n-#define ObjectClass java::lang::Object::class$\n-#define ClassClass java::lang::Class::class$\n-#define VMClassLoaderClass gnu::gcj::runtime::VMClassLoader::class$\n-#define ClassLoaderClass java::lang::ClassLoader::class$\n-#define SerializableClass java::io::Serializable::class$\n-\n /////////// java.lang.ClassLoader native methods ////////////\n \n java::lang::Class *\n@@ -60,7 +52,8 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n {\n #ifdef INTERPRETER\n   jclass klass;\n-  klass = (jclass) JvAllocObject (&ClassClass, sizeof (_Jv_InterpClass));\n+  klass = (jclass) JvAllocObject (&java::lang::Class::class$,\n+\t\t\t\t  sizeof (_Jv_InterpClass));\n   _Jv_InitNewClassFields (klass);\n \n   // synchronize on the class, so that it is not\n@@ -295,7 +288,7 @@ _Jv_PrepareCompiledClass (jclass klass)\n \t  int mod = f->getModifiers ();\n \t  // If we have a static String field with a non-null initial\n \t  // value, we know it points to a Utf8Const.\n-\t  if (f->getClass () == &StringClass\n+\t  if (f->getClass () == &java::lang::String::class$\n \t      && java::lang::reflect::Modifier::isStatic (mod))\n \t    {\n \t      jstring *strp = (jstring *) f->u.addr;\n@@ -353,7 +346,7 @@ static jclass loaded_classes[HASH_LEN];\n jclass\n _Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n {\n-  _Jv_MonitorEnter (&ClassClass);\n+  _Jv_MonitorEnter (&java::lang::Class::class$);\n   jint hash = HASH_UTF (name);\n \n   // first, if LOADER is a defining loader, then it is also initiating\n@@ -381,15 +374,15 @@ _Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t}\n     }\n \n-  _Jv_MonitorExit (&ClassClass);\n+  _Jv_MonitorExit (&java::lang::Class::class$);\n \n   return klass;\n }\n \n void\n _Jv_UnregisterClass (jclass the_class)\n {\n-  _Jv_MonitorEnter (&ClassClass);\n+  _Jv_MonitorEnter (&java::lang::Class::class$);\n   jint hash = HASH_UTF(the_class->name);\n \n   jclass *klass = &(loaded_classes[hash]);\n@@ -414,7 +407,7 @@ _Jv_UnregisterClass (jclass the_class)\n \tbreak;\n     }\n \n-  _Jv_MonitorExit (&ClassClass);\n+  _Jv_MonitorExit (&java::lang::Class::class$);\n }\n \n void\n@@ -424,12 +417,12 @@ _Jv_RegisterInitiatingLoader (jclass klass, java::lang::ClassLoader *loader)\n   _Jv_LoaderInfo *info = (_Jv_LoaderInfo *) _Jv_Malloc (sizeof(_Jv_LoaderInfo));\n   jint hash = HASH_UTF(klass->name);\n \n-  _Jv_MonitorEnter (&ClassClass);\n+  _Jv_MonitorEnter (&java::lang::Class::class$);\n   info->loader = loader;\n   info->klass  = klass;\n   info->next   = initiated_classes[hash];\n   initiated_classes[hash] = info;\n-  _Jv_MonitorExit (&ClassClass);\n+  _Jv_MonitorExit (&java::lang::Class::class$);\n }\n \n // This function is called many times during startup, before main() is\n@@ -582,7 +575,7 @@ jclass\n _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n \t      java::lang::ClassLoader *loader)\n {\n-  jclass ret = (jclass) JvAllocObject (&ClassClass);\n+  jclass ret = (jclass) JvAllocObject (&java::lang::Class::class$);\n   _Jv_InitNewClassFields (ret);\n   ret->name = name;\n   ret->superclass = superclass;\n@@ -646,13 +639,14 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n   }\n \n   // Create new array class.\n-  jclass array_class = _Jv_NewClass (array_name, &ObjectClass,\n+  jclass array_class = _Jv_NewClass (array_name, &java::lang::Object::class$,\n   \t\t\t\t     element->loader);\n \n   // Note that `vtable_method_count' doesn't include the initial\n   // gc_descr slot.\n-  JvAssert (ObjectClass.vtable_method_count == NUM_OBJECT_METHODS);\n-  int dm_count = ObjectClass.vtable_method_count;\n+  JvAssert (java::lang::Object::class$.vtable_method_count\n+\t    == NUM_OBJECT_METHODS);\n+  int dm_count = java::lang::Object::class$.vtable_method_count;\n \n   // Create a new vtable by copying Object's vtable.\n   _Jv_VTable *vtable;\n@@ -661,18 +655,23 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n   else\n     vtable = _Jv_VTable::new_vtable (dm_count);\n   vtable->clas = array_class;\n-  vtable->gc_descr = ObjectClass.vtable->gc_descr;\n+  vtable->gc_descr = java::lang::Object::class$.vtable->gc_descr;\n   for (int i = 0; i < dm_count; ++i)\n-    vtable->set_method (i, ObjectClass.vtable->get_method (i));\n+    vtable->set_method (i, java::lang::Object::class$.vtable->get_method (i));\n \n   array_class->vtable = vtable;\n-  array_class->vtable_method_count = ObjectClass.vtable_method_count;\n+  array_class->vtable_method_count\n+    = java::lang::Object::class$.vtable_method_count;\n \n   // Stash the pointer to the element type.\n   array_class->methods = (_Jv_Method *) element;\n \n   // Register our interfaces.\n-  static jclass interfaces[] = { &CloneableClass, &SerializableClass };\n+  static jclass interfaces[] =\n+    {\n+      &java::lang::Cloneable::class$,\n+      &java::io::Serializable::class$\n+    };\n   array_class->interfaces = interfaces;\n   array_class->interface_count = sizeof interfaces / sizeof interfaces[0];\n "}, {"sha": "8e3b7b2140da0863c6e3095be384627cfaf2d8db", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=d74bba04e8561896d2ba0ec5170216a38e1fd352", "patch": "@@ -42,17 +42,6 @@ details.  */\n #include <java/lang/UnsupportedOperationException.h>\n #endif\n \n-// FIXME: remove these.\n-#define BooleanClass java::lang::Boolean::class$\n-#define VoidClass java::lang::Void::class$\n-#define ByteClass java::lang::Byte::class$\n-#define ShortClass java::lang::Short::class$\n-#define CharacterClass java::lang::Character::class$\n-#define IntegerClass java::lang::Integer::class$\n-#define LongClass java::lang::Long::class$\n-#define FloatClass java::lang::Float::class$\n-#define DoubleClass java::lang::Double::class$\n-\n struct cpair\n {\n   jclass prim;\n@@ -64,16 +53,16 @@ struct cpair\n static cpair primitives[] =\n {\n #define BOOLEAN 0\n-  { JvPrimClass (boolean), &BooleanClass },\n-  { JvPrimClass (byte), &ByteClass },\n+  { JvPrimClass (boolean), &java::lang::Boolean::class$ },\n+  { JvPrimClass (byte), &java::lang::Byte::class$ },\n #define SHORT 2\n-  { JvPrimClass (short), &ShortClass },\n+  { JvPrimClass (short), &java::lang::Short::class$ },\n #define CHAR 3\n-  { JvPrimClass (char), &CharacterClass },\n-  { JvPrimClass (int), &IntegerClass },\n-  { JvPrimClass (long), &LongClass },\n-  { JvPrimClass (float), &FloatClass },\n-  { JvPrimClass (double), &DoubleClass },\n+  { JvPrimClass (char), &java::lang::Character::class$ },\n+  { JvPrimClass (int), &java::lang::Integer::class$ },\n+  { JvPrimClass (long), &java::lang::Long::class$ },\n+  { JvPrimClass (float), &java::lang::Float::class$ },\n+  { JvPrimClass (double), &java::lang::Double::class$ },\n   { NULL, NULL }\n };\n "}, {"sha": "2375bdbae4e752d7d671514970dc069157a5becf", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74bba04e8561896d2ba0ec5170216a38e1fd352/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=d74bba04e8561896d2ba0ec5170216a38e1fd352", "patch": "@@ -69,10 +69,6 @@ _Jv_bind (int fd, struct sockaddr *addr, int addrlen)\n #include <java/lang/Boolean.h>\n #include <java/lang/Integer.h>\n \n-// FIXME: remove these\n-#define BooleanClass java::lang::Boolean::class$\n-#define IntegerClass java::lang::Integer::class$\n-\n #ifdef DISABLE_JAVA_NET\n \n void\n@@ -504,13 +500,13 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n   if (fnum < 0)\n     throw new java::net::SocketException (JvNewStringUTF (\"Socket closed\"));\n \n-  if (_Jv_IsInstanceOf (value, &BooleanClass))\n+  if (_Jv_IsInstanceOf (value, &java::lang::Boolean::class$))\n     {\n       java::lang::Boolean *boolobj = \n         static_cast<java::lang::Boolean *> (value);\n       val = boolobj->booleanValue() ? 1 : 0;\n     }\n-  else if (_Jv_IsInstanceOf (value, &IntegerClass))\n+  else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n     {\n       java::lang::Integer *intobj = \n         static_cast<java::lang::Integer *> (value);          "}]}