{"sha": "b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMxYTU4MzFjMjljMGQ4ZThmNWFmYmY3ZTBmMmUwZDFhOTNhODM4Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-07T20:01:01Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-07T20:01:01Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r933", "tree": {"sha": "fac4052dda20bd3f73ca1ead6c383e88d8bf14ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fac4052dda20bd3f73ca1ead6c383e88d8bf14ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b/comments", "author": null, "committer": null, "parents": [{"sha": "5ace4ac449caa94c2750f8d660b894b10efbfb50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ace4ac449caa94c2750f8d660b894b10efbfb50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ace4ac449caa94c2750f8d660b894b10efbfb50"}], "stats": {"total": 37, "additions": 32, "deletions": 5}, "files": [{"sha": "ffd728dccaaab162ffb0d2124fa27376f4fb5894", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b31a5831c29c0d8e8f5afbf7e0f2e0d1a93a838b", "patch": "@@ -690,7 +690,7 @@ attr_string (str, len)\n       return h->u.str;\t\t\t/* <-- return if found.  */\n \n   /* Not found; create a permanent copy and add it to the hash table.  */\n-  new_str = (char *) xmalloc (len + 1);\n+  new_str = (char *) obstack_alloc (hash_obstack, len + 1);\n   bcopy (str, new_str, len);\n   new_str[len] = '\\0';\n   attr_hash_add_string (hashcode, new_str);\n@@ -838,6 +838,12 @@ check_attr_test (exp, is_const)\n \t     so expressions using it can be permanent too.  */\n \t  exp = attr_eq (XSTR (exp, 0), XSTR (exp, 1));\n \n+\t  /* It shouldn't be possible to simplfy the value given to a\n+\t     constant attribute, so don't expand this until it's time to\n+\t     write the test expression.  */\t       \n+\t  if (attr->is_const)\n+\t    RTX_UNCHANGING_P (exp) = 1;\n+\n \t  if (attr->is_numeric)\n \t    {\n \t      for (p = XSTR (exp, 1); *p; p++)\n@@ -1698,6 +1704,11 @@ fill_attr (attr)\n   int i;\n   rtx value;\n \n+  /* Don't fill constant attributes.  The value is independent of\n+     any particular insn.  */\n+  if (attr->is_const)\n+    return;\n+\n   for (id = defs; id; id = id->next)\n     {\n       /* If no value is specified for this insn for this attribute, use the\n@@ -2123,21 +2134,26 @@ compute_alternative_mask (exp, code)\n      rtx exp;\n      RTX_CODE code;\n {\n+  char *string;\n   if (GET_CODE (exp) == code)\n     return compute_alternative_mask (XEXP (exp, 0), code)\n \t   | compute_alternative_mask (XEXP (exp, 1), code);\n \n   else if (code == AND && GET_CODE (exp) == NOT\n \t   && GET_CODE (XEXP (exp, 0)) == EQ_ATTR\n \t   && XSTR (XEXP (exp, 0), 0) == alternative_name)\n-    return 1 << atoi (XSTR (XEXP (exp, 0), 1));\n+    string = XSTR (XEXP (exp, 0), 1);\n \n   else if (code == IOR && GET_CODE (exp) == EQ_ATTR\n \t   && XSTR (exp, 0) == alternative_name)\n-    return 1 << atoi (XSTR (exp, 1));\n+    string = XSTR (exp, 1);\n \n   else\n     return 0;\n+\n+  if (string[1] == 0)\n+    return 1 << (string[0] - '0');\n+  return 1 << atoi (string);\n }\n \n /* Given I, a single-bit mask, return RTX to compare the `alternative'\n@@ -3448,8 +3464,19 @@ write_test_expr (exp, in_comparison)\n \n       attr = find_attr (XSTR (exp, 0), 0);\n       if (! attr) abort ();\n-      printf (\"get_attr_%s (insn) == \", attr->name);\n-      write_attr_valueq (attr, XSTR (exp, 1)); \n+\n+      /* Now is the time to expand the value of a constant attribute.  */\n+      if (attr->is_const)\n+\t{\n+\t  write_test_expr (evaluate_eq_attr (exp, attr->default_val->value,\n+\t\t\t\t\t     0, 0),\n+\t\t\t   in_comparison);\n+\t}\n+      else\n+\t{\n+\t  printf (\"get_attr_%s (insn) == \", attr->name);\n+\t  write_attr_valueq (attr, XSTR (exp, 1)); \n+\t}\n       break;\n \n     /* See if an operand matches a predicate.  */"}]}