{"sha": "27c489df7577f8ab076d3111e226582779531a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdjNDg5ZGY3NTc3ZjhhYjA3NmQzMTExZTIyNjU4Mjc3OTUzMWE5MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:43:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:43:37Z"}, "message": "2007-04-20  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb\n\t(Find_Var): Do not consider function call in test for infinite loop\n\twarning if warnings set off for function entity.\n\t(One_Bound): Do not create a temporary for a loop bound if it is a\n\tcharacter literal.\n\t(Analyze_Assignment): Traverse the right hand side of an assignment and\n\tmark all allocators as static coextensions.\n\t(Analyze_Assignment): Exempt assignments involving a dispatching call\n\tto a function with a controlling access result from the check requiring\n\tthe target to be class-wide.\n\nFrom-SVN: r125450", "tree": {"sha": "97071f9c9a6016c9fe7470fdedab5db10d0e1ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97071f9c9a6016c9fe7470fdedab5db10d0e1ec4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27c489df7577f8ab076d3111e226582779531a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c489df7577f8ab076d3111e226582779531a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c489df7577f8ab076d3111e226582779531a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c489df7577f8ab076d3111e226582779531a91/comments", "author": null, "committer": null, "parents": [{"sha": "8f7770f9f85cbf63fa11291f7c5ad1b3962b918f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7770f9f85cbf63fa11291f7c5ad1b3962b918f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7770f9f85cbf63fa11291f7c5ad1b3962b918f"}], "stats": {"total": 331, "additions": 53, "deletions": 278}, "files": [{"sha": "5df476b5a68196e8c923940cb04f4f51e1748be2", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 53, "deletions": 278, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27c489df7577f8ab076d3111e226582779531a91/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27c489df7577f8ab076d3111e226582779531a91/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=27c489df7577f8ab076d3111e226582779531a91", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,14 +26,14 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -60,15 +60,15 @@ package body Sem_Ch5 is\n \n    Unblocked_Exit_Count : Nat := 0;\n    --  This variable is used when processing if statements, case statements,\n-   --  and block statements. It counts the number of exit points that are\n-   --  not blocked by unconditional transfer instructions: for IF and CASE,\n-   --  these are the branches of the conditional; for a block, they are the\n-   --  statement sequence of the block, and the statement sequences of any\n-   --  exception handlers that are part of the block. When processing is\n-   --  complete, if this count is zero, it means that control cannot fall\n-   --  through the IF, CASE or block statement. This is used for the\n-   --  generation of warning messages. This variable is recursively saved\n-   --  on entry to processing the construct, and restored on exit.\n+   --  and block statements. It counts the number of exit points that are not\n+   --  blocked by unconditional transfer instructions: for IF and CASE, these\n+   --  are the branches of the conditional; for a block, they are the statement\n+   --  sequence of the block, and the statement sequences of any exception\n+   --  handlers that are part of the block. When processing is complete, if\n+   --  this count is zero, it means that control cannot fall through the IF,\n+   --  CASE or block statement. This is used for the generation of warning\n+   --  messages. This variable is recursively saved on entry to processing the\n+   --  construct, and restored on exit.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -111,7 +111,7 @@ package body Sem_Ch5 is\n       procedure Diagnose_Non_Variable_Lhs (N : Node_Id) is\n       begin\n          --  Not worth posting another error if left hand side already\n-         --  flagged as being illegal in some respect\n+         --  flagged as being illegal in some respect.\n \n          if Error_Posted (N) then\n             return;\n@@ -250,6 +250,7 @@ package body Sem_Ch5 is\n    --  Start of processing for Analyze_Assignment\n \n    begin\n+      Mark_Static_Coextensions (Rhs);\n       Analyze (Rhs);\n       Analyze (Lhs);\n \n@@ -340,8 +341,13 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n+      --  The resulting assignment type is T1, so now we will resolve the\n+      --  left hand side of the assignment using this determined type.\n+\n       Resolve (Lhs, T1);\n \n+      --  Cases where Lhs is not a variable\n+\n       if not Is_Variable (Lhs) then\n \n          --  Ada 2005 (AI-327): Check assignment to the attribute Priority of\n@@ -414,9 +420,13 @@ package body Sem_Ch5 is\n          Diagnose_Non_Variable_Lhs (Lhs);\n          return;\n \n+      --  Error of assigning to limited type. We do however allow this in\n+      --  certain cases where the front end generates the assignments.\n+\n       elsif Is_Limited_Type (T1)\n         and then not Assignment_OK (Lhs)\n         and then not Assignment_OK (Original_Node (Lhs))\n+        and then not Is_Value_Type (T1)\n       then\n          Error_Msg_N\n            (\"left hand of assignment must not be limited type\", Lhs);\n@@ -453,9 +463,13 @@ package body Sem_Ch5 is\n          return;\n       end if;\n \n-      Set_Assignment_Type (Lhs, T1);\n+      --  Now we can complete the resolution of the right hand side\n \n+      Set_Assignment_Type (Lhs, T1);\n       Resolve (Rhs, T1);\n+\n+      --  This is the point at which we check for an unset reference\n+\n       Check_Unset_Reference (Rhs);\n \n       --  Remaining steps are skipped if Rhs was syntactically in error\n@@ -501,7 +515,15 @@ package body Sem_Ch5 is\n          return;\n       end if;\n \n-      if (Is_Class_Wide_Type (T2) or else Is_Dynamically_Tagged (Rhs))\n+      --  If the rhs is class-wide or dynamically tagged, then require the lhs\n+      --  to be class-wide. The case where the rhs is a dynamically tagged call\n+      --  to a dispatching operation with a controlling access result is\n+      --  excluded from this check, since the target has an access type (and\n+      --  no tag propagation occurs in that case).\n+\n+      if (Is_Class_Wide_Type (T2)\n+           or else (Is_Dynamically_Tagged (Rhs)\n+                     and then not Is_Access_Type (T1)))\n         and then not Is_Class_Wide_Type (T1)\n       then\n          Error_Msg_N (\"dynamically tagged expression not allowed!\", Rhs);\n@@ -800,7 +822,7 @@ package body Sem_Ch5 is\n \n          Set_Etype (Ent, Standard_Void_Type);\n          Set_Block_Node (Ent, Identifier (N));\n-         New_Scope (Ent);\n+         Push_Scope (Ent);\n \n          if Present (Decls) then\n             Analyze_Declarations (Decls);\n@@ -1418,6 +1440,7 @@ package body Sem_Ch5 is\n                return Original_Bound;\n \n             elsif Nkind (Analyzed_Bound) = N_Integer_Literal\n+              or else Nkind (Analyzed_Bound) = N_Character_Literal\n               or else Is_Entity_Name (Analyzed_Bound)\n             then\n                Analyze_And_Resolve (Original_Bound, Typ);\n@@ -1834,8 +1857,10 @@ package body Sem_Ch5 is\n    ----------------------------\n \n    procedure Analyze_Loop_Statement (N : Node_Id) is\n-      Id   : constant Node_Id := Identifier (N);\n-      Iter : constant Node_Id := Iteration_Scheme (N);\n+      Loop_Statement : constant Node_Id := N;\n+\n+      Id   : constant Node_Id := Identifier (Loop_Statement);\n+      Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n       Ent  : Entity_Id;\n \n    begin\n@@ -1846,7 +1871,7 @@ package body Sem_Ch5 is\n \n          Analyze (Id);\n          Ent := Entity (Id);\n-         Generate_Reference  (Ent, N, ' ');\n+         Generate_Reference  (Ent, Loop_Statement, ' ');\n          Generate_Definition (Ent);\n \n          --  If we found a label, mark its type. If not, ignore it, since it\n@@ -1859,16 +1884,18 @@ package body Sem_Ch5 is\n             Set_Ekind (Ent, E_Loop);\n \n             if Nkind (Parent (Ent)) = N_Implicit_Label_Declaration then\n-               Set_Label_Construct (Parent (Ent), N);\n+               Set_Label_Construct (Parent (Ent), Loop_Statement);\n             end if;\n          end if;\n \n       --  Case of no identifier present\n \n       else\n-         Ent := New_Internal_Entity (E_Loop, Current_Scope, Sloc (N), 'L');\n+         Ent :=\n+           New_Internal_Entity\n+             (E_Loop, Current_Scope, Sloc (Loop_Statement), 'L');\n          Set_Etype (Ent,  Standard_Void_Type);\n-         Set_Parent (Ent, N);\n+         Set_Parent (Ent, Loop_Statement);\n       end if;\n \n       --  Kill current values on entry to loop, since statements in body\n@@ -1877,265 +1904,13 @@ package body Sem_Ch5 is\n       --  that the body of the loop was executed.\n \n       Kill_Current_Values;\n-      New_Scope (Ent);\n+      Push_Scope (Ent);\n       Analyze_Iteration_Scheme (Iter);\n-      Analyze_Statements (Statements (N));\n-      Process_End_Label (N, 'e', Ent);\n+      Analyze_Statements (Statements (Loop_Statement));\n+      Process_End_Label (Loop_Statement, 'e', Ent);\n       End_Scope;\n       Kill_Current_Values;\n-\n-      --  Check for possible infinite loop which we can diagnose successfully.\n-      --  The case we look for is a while loop which tests a local variable,\n-      --  where there is no obvious direct or indirect update of the variable\n-      --  within the body of the loop.\n-\n-      --  Note: we don't try to give a warning if condition actions are\n-      --  present, since the loop structure can be very complex in this case.\n-\n-      if No (Iter)\n-        or else No (Condition (Iter))\n-        or else Present (Condition_Actions (Iter))\n-        or else Debug_Flag_Dot_W\n-      then\n-         return;\n-      end if;\n-\n-      --  Initial conditions met, see if condition is of right form\n-\n-      declare\n-         Loc  : Node_Id := Empty;\n-         Var  : Entity_Id := Empty;\n-\n-         function Has_Indirection (T : Entity_Id) return Boolean;\n-         --  If the controlling variable is an access type, or is a record type\n-         --  with access components, assume that it is changed indirectly and\n-         --  suppress the warning. As a concession to low-level programming, in\n-         --  particular within Declib, we also suppress warnings on a record\n-         --  type that contains components of type Address or Short_Address.\n-\n-         procedure Find_Var (N : Node_Id);\n-         --  Find whether the condition in a while-loop can be reduced to\n-         --  a test on a single variable. Recurse if condition is negation.\n-\n-         ---------------------\n-         -- Has_Indirection --\n-         ---------------------\n-\n-         function Has_Indirection (T : Entity_Id) return Boolean is\n-            Comp : Entity_Id;\n-            Rec  : Entity_Id;\n-\n-         begin\n-            if Is_Access_Type (T) then\n-               return True;\n-\n-            elsif Is_Private_Type (T)\n-              and then Present (Full_View (T))\n-              and then Is_Access_Type (Full_View (T))\n-            then\n-               return True;\n-\n-            elsif Is_Record_Type (T) then\n-               Rec := T;\n-\n-            elsif Is_Private_Type (T)\n-              and then Present (Full_View (T))\n-              and then Is_Record_Type (Full_View (T))\n-            then\n-               Rec := Full_View (T);\n-            else\n-               return False;\n-            end if;\n-\n-            Comp := First_Component (Rec);\n-            while Present (Comp) loop\n-               if Is_Access_Type (Etype (Comp))\n-                 or else Is_Descendent_Of_Address (Etype (Comp))\n-               then\n-                  return True;\n-               end if;\n-\n-               Next_Component (Comp);\n-            end loop;\n-\n-            return False;\n-         end Has_Indirection;\n-\n-         --------------\n-         -- Find_Var --\n-         --------------\n-\n-         procedure Find_Var (N : Node_Id) is\n-         begin\n-            --  Condition is a direct variable reference\n-\n-            if Is_Entity_Name (N)\n-              and then not Is_Library_Level_Entity (Entity (N))\n-            then\n-               Loc := N;\n-\n-            --  Case of condition is a comparison with compile time known value\n-\n-            elsif Nkind (N) in N_Op_Compare then\n-               if Is_Entity_Name (Left_Opnd (N))\n-                 and then Compile_Time_Known_Value (Right_Opnd (N))\n-               then\n-                  Loc := Left_Opnd (N);\n-\n-               elsif Is_Entity_Name (Right_Opnd (N))\n-                 and then Compile_Time_Known_Value (Left_Opnd (N))\n-               then\n-                  Loc :=  Right_Opnd (N);\n-\n-               else\n-                  return;\n-               end if;\n-\n-            --  If condition is a negation, check whether the operand has the\n-            --  proper form.\n-\n-            elsif Nkind (N) = N_Op_Not then\n-               Find_Var (Right_Opnd (N));\n-\n-            --  Case of condition is function call with one parameter\n-\n-            elsif Nkind (N) = N_Function_Call then\n-               declare\n-                  PA : constant List_Id := Parameter_Associations (N);\n-               begin\n-                  if Present (PA)\n-                    and then List_Length (PA) = 1\n-                    and then Is_Entity_Name (First (PA))\n-                  then\n-                     Loc := First (PA);\n-                  else\n-                     return;\n-                  end if;\n-               end;\n-\n-            else\n-               return;\n-            end if;\n-         end Find_Var;\n-\n-      begin\n-         Find_Var (Condition (Iter));\n-\n-         if Present (Loc) then\n-            Var := Entity (Loc);\n-         end if;\n-\n-         if Present (Var)\n-           and then Ekind (Var) = E_Variable\n-           and then not Is_Library_Level_Entity (Var)\n-           and then Comes_From_Source (Var)\n-         then\n-            if Has_Indirection (Etype (Var)) then\n-\n-               --  Assume that the designated object is modified in some\n-               --  other way, to avoid false positives.\n-\n-               return;\n-\n-            elsif Is_Volatile (Var) then\n-\n-               --  If the variable is marked as volatile, we assume that\n-               --  the condition may be affected by other tasks.\n-\n-               return;\n-\n-            elsif Nkind (Original_Node (First (Statements (N))))\n-                 = N_Delay_Relative_Statement\n-              or else Nkind (Original_Node (First (Statements (N))))\n-                 = N_Delay_Until_Statement\n-            then\n-\n-               --  Assume that this is a multitasking program, and the\n-               --  condition is affected by other threads.\n-\n-               return;\n-\n-            end if;\n-\n-         --  There no identifiable single variable in the condition\n-\n-         else\n-            return;\n-         end if;\n-\n-         --  Search for reference to variable in loop\n-\n-         Ref_Search : declare\n-            function Test_Ref (N : Node_Id) return Traverse_Result;\n-            --  Test for reference to variable in question. Returns Abandon\n-            --  if matching reference found.\n-\n-            function Find_Ref is new Traverse_Func (Test_Ref);\n-            --  Function to traverse body of procedure. Returns Abandon if\n-            --  matching reference found.\n-\n-            --------------\n-            -- Test_Ref --\n-            --------------\n-\n-            function Test_Ref (N : Node_Id) return Traverse_Result is\n-            begin\n-               --  Waste of time to look at iteration scheme\n-\n-               if N = Iter then\n-                  return Skip;\n-\n-               --  Direct reference to variable in question\n-\n-               elsif Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then Entity (N) = Var\n-                 and then May_Be_Lvalue (N)\n-               then\n-                  return Abandon;\n-\n-                  --  Reference to variable renaming variable in question\n-\n-               elsif Is_Entity_Name (N)\n-                 and then Present (Entity (N))\n-                 and then Ekind (Entity (N)) = E_Variable\n-                 and then Present (Renamed_Object (Entity (N)))\n-                 and then Is_Entity_Name (Renamed_Object (Entity (N)))\n-                 and then Entity (Renamed_Object (Entity (N))) = Var\n-                 and then May_Be_Lvalue (N)\n-               then\n-                  return Abandon;\n-\n-               --  Calls to subprograms are OK, unless the subprogram is\n-               --  within the scope of the entity in question and could\n-               --  therefore possibly modify it\n-\n-               elsif Nkind (N) = N_Procedure_Call_Statement\n-                 or else Nkind (N) = N_Function_Call\n-               then\n-                  if not Is_Entity_Name (Name (N))\n-                    or else Scope_Within (Entity (Name (N)), Scope (Var))\n-                  then\n-                     return Abandon;\n-                  end if;\n-               end if;\n-\n-               --  All OK, continue scan\n-\n-               return OK;\n-            end Test_Ref;\n-\n-         --  Start of processing for Ref_Search\n-\n-         begin\n-            if Find_Ref (N) = OK then\n-               Error_Msg_NE\n-                 (\"variable& is not modified in loop body?\", Loc, Var);\n-               Error_Msg_N\n-                 (\"\\possible infinite loop\", Loc);\n-            end if;\n-         end Ref_Search;\n-      end;\n+      Check_Infinite_Loop_Warning (N);\n    end Analyze_Loop_Statement;\n \n    ----------------------------\n@@ -2265,7 +2040,7 @@ package body Sem_Ch5 is\n                   --  The rather strange shenanigans with the warning message\n                   --  here reflects the fact that Kill_Dead_Code is very good\n                   --  at removing warnings in deleted code, and this is one\n-                  --  warning we would prefer NOT to have removed :-)\n+                  --  warning we would prefer NOT to have removed.\n \n                   Error_Loc := Sloc (Nxt);\n "}]}