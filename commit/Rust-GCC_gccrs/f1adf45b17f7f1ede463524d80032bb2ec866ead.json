{"sha": "f1adf45b17f7f1ede463524d80032bb2ec866ead", "node_id": "C_kwDOANBUbNoAKGYxYWRmNDViMTdmN2YxZWRlNDYzNTI0ZDgwMDMyYmIyZWM4NjZlYWQ", "commit": {"author": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-04-21T22:42:15Z"}, "committer": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-09-28T21:25:18Z"}, "message": "Add instruction level discriminator support.\n\nThis is the first in a series of patches to enable discriminator support\nin AutoFDO.\n\nThis patch switches to tracking discriminators per statement/instruction\ninstead of per basic block. Tracking per basic block was problematic since\nnot all statements in a basic block needed a discriminator and, also, later\noptimizations could move statements between basic blocks making correlation\nduring AutoFDO compilation unreliable. Tracking per statement also allows\nus to assign different discriminators to multiple function calls in the same\nbasic block. A subsequent patch will add that support.\n\nThe idea of this patch is based on commit 4c311d95cf6d9519c3c20f641cc77af7df491fdf\nby Dehao Chen in vendors/google/heads/gcc-4_8 but uses a slightly different\napproach. In Dehao's work special (normally unused) location ids and side tables\nwere used to keep track of locations with discriminators. Things have changed\nsince then and I don't think we have unused location ids anymore. Instead,\nI made discriminators a part of ad-hoc locations.\n\nThe difference from Dehao's work also includes support for discriminator\nreading/writing in lto streaming and in modules.\n\nTested on x86_64-pc-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* basic-block.h: Remove discriminator from basic blocks.\n\t* cfghooks.cc (split_block_1): Remove discriminator from basic blocks.\n\t* final.cc (final_start_function_1): Switch from per-bb to per statement\n\tdiscriminator.\n\t(final_scan_insn_1): Don't keep track of basic block discriminators.\n\t(compute_discriminator): Switch from basic block discriminators to\n\tinstruction discriminators.\n\t(insn_discriminator): New function to return instruction discriminator.\n\t(notice_source_line): Use insn_discriminator.\n\t* gimple-pretty-print.cc (dump_gimple_bb_header): Remove dumping of\n\tbasic block discriminators.\n\t* gimple-streamer-in.cc (input_bb): Remove reading of basic block\n\tdiscriminators.\n\t* gimple-streamer-out.cc (output_bb): Remove writing of basic block\n\tdiscriminators.\n\t* input.cc (make_location): Pass 0 discriminator to COMBINE_LOCATION_DATA.\n\t(location_with_discriminator): New function to combine locus with\n\ta discriminator.\n\t(has_discriminator): New function to check if a location has a discriminator.\n\t(get_discriminator_from_loc): New function to get the discriminator\n\tfrom a location.\n\t* input.h: Declarations of new functions.\n\t* lto-streamer-in.cc (cmp_loc): Use discriminators in location comparison.\n\t(apply_location_cache): Keep track of current discriminator.\n\t(input_location_and_block): Read discriminator from stream.\n\t* lto-streamer-out.cc (clear_line_info): Set current discriminator to\n\tUINT_MAX.\n\t(lto_output_location_1): Write discriminator to stream.\n\t* lto-streamer.h: Add discriminator to cached_location.\n\tAdd current_discr to lto_location_cache.\n\tAdd current_discr to output_block.\n\t* print-rtl.cc (print_rtx_operand_code_i): Print discriminator.\n\t* rtl.h: Add extern declaration of insn_discriminator.\n\t* tree-cfg.cc (assign_discriminator): New function to assign a unique\n\tdiscriminator value to all statements in a basic block that have the given\n\tline number.\n\t(assign_discriminators): Assign discriminators to statement locations.\n\t* tree-pretty-print.cc (dump_location): Dump discriminators.\n\t* tree.cc (set_block): Preserve discriminator when setting block.\n\t(set_source_range): Preserve discriminator when setting source range.\n\ngcc/cp/ChangeLog:\n\t* module.cc (write_location): Write discriminator.\n\t(read_location): Read discriminator.\n\nlibcpp/ChangeLog:\n\n\t* include/line-map.h: Add discriminator to location_adhoc_data.\n\t(get_combined_adhoc_loc): Add discriminator parameter.\n\t(get_discriminator_from_adhoc_loc): Add external declaration.\n\t(get_discriminator_from_loc): Add external declaration.\n\t(COMBINE_LOCATION_DATA): Add discriminator parameter.\n\t* lex.cc (get_location_for_byte_range_in_cur_line) Pass 0 discriminator\n\tin a call to COMBINE_LOCATION_DATA.\n\t(warn_about_normalization): Pass 0 discriminator in a call to\n\tCOMBINE_LOCATION_DATA.\n\t(_cpp_lex_direct): Pass 0 discriminator in a call to\n\tCOMBINE_LOCATION_DATA.\n\t* line-map.cc (location_adhoc_data_hash): Use discriminator compute\n\tlocation_adhoc_data hash.\n\t(location_adhoc_data_eq): Use discriminator when comparing\n\tlocation_adhoc_data.\n\t(can_be_stored_compactly_p): Check discriminator to determine\n\tcompact storage.\n\t(get_combined_adhoc_loc): Add discriminator parameter.\n\t(get_discriminator_from_adhoc_loc): New function to get the discriminator\n\tfrom an ad-hoc location.\n\t(get_discriminator_from_loc): New function to get the discriminator\n\tfrom a location.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/ubsan/pr85213.c: Pass -gno-statement-frontiers.", "tree": {"sha": "eaaa2359742e34e7ee8f4c889e7b852c864ccae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaaa2359742e34e7ee8f4c889e7b852c864ccae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1adf45b17f7f1ede463524d80032bb2ec866ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1adf45b17f7f1ede463524d80032bb2ec866ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1adf45b17f7f1ede463524d80032bb2ec866ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1adf45b17f7f1ede463524d80032bb2ec866ead/comments", "author": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f65eecdbef6027722e93aadf3fa6b3cc342eb4f"}], "stats": {"total": 242, "additions": 187, "deletions": 55}, "files": [{"sha": "1eae03d1acad05df7ddacafc7ce8dd146bacea85", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -148,11 +148,6 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n \n   /* Expected number of executions: calculated in profile.cc.  */\n   profile_count count;\n-\n-  /* The discriminator for this block.  The discriminator distinguishes\n-     among several basic blocks that share a common locus, allowing for\n-     more accurate sample-based profiling.  */\n-  int discriminator;\n };\n \n /* This ensures that struct gimple_bb_info is smaller than"}, {"sha": "29ded570734a4dce3449d2cf376c6c6ecd496a50", "filename": "gcc/cfghooks.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fcfghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fcfghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -541,7 +541,6 @@ split_block_1 (basic_block bb, void *i)\n     return NULL;\n \n   new_bb->count = bb->count;\n-  new_bb->discriminator = bb->discriminator;\n \n   if (dom_info_available_p (CDI_DOMINATORS))\n     {"}, {"sha": "d965017940a010f2cbd0bd874702fb814887b6f9", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -15777,6 +15777,8 @@ module_state::write_location (bytes_out &sec, location_t loc)\n \trange.m_start = UNKNOWN_LOCATION;\n       write_location (sec, range.m_start);\n       write_location (sec, range.m_finish);\n+      unsigned discriminator = get_discriminator_from_adhoc_loc (line_table, loc);\n+      sec.u (discriminator);\n     }\n   else if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))\n     {\n@@ -15902,8 +15904,9 @@ module_state::read_location (bytes_in &sec) const\n \tif (range.m_start == UNKNOWN_LOCATION)\n \t  range.m_start = locus;\n \trange.m_finish = read_location (sec);\n+\tunsigned discriminator = sec.u ();\n \tif (locus != loc && range.m_start != loc && range.m_finish != loc)\n-\t  locus = get_combined_adhoc_loc (line_table, locus, range, NULL);\n+\t  locus = get_combined_adhoc_loc (line_table, locus, range, NULL, discriminator);\n       }\n       break;\n "}, {"sha": "eea572238f601b2a873e80066312e21258867c55", "filename": "gcc/final.cc", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ffinal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ffinal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -118,18 +118,10 @@ static int last_columnnum;\n /* Discriminator written to assembly.  */\n static int last_discriminator;\n \n-/* Discriminator to be written to assembly for current instruction.\n+/* Compute discriminator to be written to assembly for current instruction.\n    Note: actual usage depends on loc_discriminator_kind setting.  */\n-static int discriminator;\n static inline int compute_discriminator (location_t loc);\n \n-/* Discriminator identifying current basic block among others sharing\n-   the same locus.  */\n-static int bb_discriminator;\n-\n-/* Basic block discriminator for previous instruction.  */\n-static int last_bb_discriminator;\n-\n /* Highest line number in current block.  */\n static int high_block_linenum;\n \n@@ -1688,8 +1680,7 @@ final_start_function_1 (rtx_insn **firstp, FILE *file, int *seen,\n   last_filename = LOCATION_FILE (prologue_location);\n   last_linenum = LOCATION_LINE (prologue_location);\n   last_columnnum = LOCATION_COLUMN (prologue_location);\n-  last_discriminator = discriminator = 0;\n-  last_bb_discriminator = bb_discriminator = 0;\n+  last_discriminator = 0;\n   force_source_line = false;\n \n   high_block_linenum = high_function_linenum = last_linenum;\n@@ -2234,7 +2225,6 @@ final_scan_insn_1 (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t  if (targetm.asm_out.unwind_emit)\n \t    targetm.asm_out.unwind_emit (asm_out_file, insn);\n \n-\t  bb_discriminator = NOTE_BASIC_BLOCK (insn)->discriminator;\n \t  break;\n \n \tcase NOTE_INSN_EH_REGION_BEG:\n@@ -2939,7 +2929,7 @@ compute_discriminator (location_t loc)\n   int discriminator;\n \n   if (!decl_to_instance_map)\n-    discriminator = bb_discriminator;\n+    discriminator = get_discriminator_from_loc (loc);\n   else\n     {\n       tree block = LOCATION_BLOCK (loc);\n@@ -2963,6 +2953,13 @@ compute_discriminator (location_t loc)\n   return discriminator;\n }\n \n+/* Return discriminator of the statement that produced this insn.  */\n+int\n+insn_discriminator (const rtx_insn *insn)\n+{\n+  return compute_discriminator (INSN_LOCATION (insn));\n+}\n+\n /* Return whether a source line note needs to be emitted before INSN.\n    Sets IS_STMT to TRUE if the line should be marked as a possible\n    breakpoint location.  */\n@@ -2972,6 +2969,7 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n {\n   const char *filename;\n   int linenum, columnnum;\n+  int discriminator;\n \n   if (NOTE_MARKER_P (insn))\n     {\n@@ -3001,7 +2999,7 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n       filename = xloc.file;\n       linenum = xloc.line;\n       columnnum = xloc.column;\n-      discriminator = compute_discriminator (INSN_LOCATION (insn));\n+      discriminator = insn_discriminator (insn);\n     }\n   else\n     {"}, {"sha": "a87e2ae68b355355e733def3d3bff7d6e9de2f30", "filename": "gcc/gimple-pretty-print.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -2875,8 +2875,6 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,\n \t\t\t indent, \"\", get_lineno (gsi_stmt (gsi)));\n \t\tbreak;\n \t      }\n-\t  if (bb->discriminator)\n-\t    fprintf (outf, \", discriminator %i\", bb->discriminator);\n \t  fputc ('\\n', outf);\n \t}\n     }"}, {"sha": "ea8891e8e92769be6ccf8eb24074a89e5e8f5688", "filename": "gcc/gimple-streamer-in.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -267,7 +267,6 @@ input_bb (class lto_input_block *ib, enum LTO_tags tag,\n     bb->count\n       = bb->count.apply_scale (count_materialization_scale, REG_BR_PROB_BASE);\n   bb->flags = streamer_read_hwi (ib);\n-  bb->discriminator = streamer_read_hwi (ib);\n \n   /* LTO_bb1 has statements.  LTO_bb0 does not.  */\n   if (tag == LTO_bb0)"}, {"sha": "45832547bf54d4b6bded5ba064eca24e82b0b615", "filename": "gcc/gimple-streamer-out.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fgimple-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -208,7 +208,6 @@ output_bb (struct output_block *ob, basic_block bb, struct function *fn)\n   streamer_write_uhwi (ob, bb->index);\n   bb->count.stream_out (ob);\n   streamer_write_hwi (ob, bb->flags);\n-  streamer_write_hwi (ob, bb->discriminator);\n \n   if (!gsi_end_p (bsi) || phi_nodes (bb))\n     {"}, {"sha": "a28abfac5ace7537b0f60120d0cb35fbfc4a8504", "filename": "gcc/input.cc", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Finput.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Finput.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -1082,7 +1082,8 @@ make_location (location_t caret, location_t start, location_t finish)\n   location_t combined_loc = COMBINE_LOCATION_DATA (line_table,\n \t\t\t\t\t\t   pure_loc,\n \t\t\t\t\t\t   src_range,\n-\t\t\t\t\t\t   NULL);\n+\t\t\t\t\t\t   NULL,\n+\t\t\t\t\t\t   0);\n   return combined_loc;\n }\n \n@@ -1092,7 +1093,7 @@ location_t\n make_location (location_t caret, source_range src_range)\n {\n   location_t pure_loc = get_pure_location (caret);\n-  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL);\n+  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL, 0);\n }\n \n /* An expanded_location stores the column in byte units.  This function\n@@ -1766,6 +1767,37 @@ get_location_within_string (cpp_reader *pfile,\n   return NULL;\n }\n \n+/* Associate the DISCRIMINATOR with LOCUS, and return a new locus. */\n+\n+location_t\n+location_with_discriminator (location_t locus, int discriminator)\n+{\n+  tree block = LOCATION_BLOCK (locus);\n+  source_range src_range = get_range_from_loc (line_table, locus);\n+  locus = get_pure_location (locus);\n+\n+  if (locus == UNKNOWN_LOCATION)\n+    return locus;\n+\n+  return COMBINE_LOCATION_DATA (line_table, locus, src_range, block, discriminator);\n+}\n+\n+/* Return TRUE if LOCUS represents a location with a discriminator.  */\n+\n+bool\n+has_discriminator (location_t locus)\n+{\n+  return get_discriminator_from_loc (locus) != 0;\n+}\n+\n+/* Return the discriminator for LOCUS.  */\n+\n+int\n+get_discriminator_from_loc (location_t locus)\n+{\n+  return get_discriminator_from_loc (line_table, locus);\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "11c571d076f759b5244d78d8acdcd19ceda1254b", "filename": "gcc/input.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -165,6 +165,10 @@ extern location_t expansion_point_location (location_t);\n \n extern location_t input_location;\n \n+extern location_t location_with_discriminator (location_t, int);\n+extern bool has_discriminator (location_t);\n+extern int get_discriminator_from_loc (location_t);\n+\n #define LOCATION_FILE(LOC) ((expand_location (LOC)).file)\n #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)\n #define LOCATION_COLUMN(LOC)((expand_location (LOC)).column)"}, {"sha": "fa896340dafd7ddfc6698abc01429922bea0ed18", "filename": "gcc/lto-streamer-in.cc", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -409,6 +409,8 @@ lto_location_cache::cmp_loc (const void *pa, const void *pb)\n     return a->line - b->line;\n   if (a->col != b->col)\n     return a->col - b->col;\n+  if (a->discr != b->discr)\n+    return a->discr - b->discr;\n   if ((a->block == NULL_TREE) != (b->block == NULL_TREE))\n     return a->block ? 1 : -1;\n   if (a->block)\n@@ -460,19 +462,26 @@ lto_location_cache::apply_location_cache ()\n \t  current_loc = linemap_position_for_column (line_table, loc.col);\n \t  if (loc.block)\n \t    current_loc = set_block (current_loc, loc.block);\n+\t  if (loc.discr)\n+\t    current_loc = location_with_discriminator (current_loc, loc.discr);\n \t}\n       else if (current_block != loc.block)\n \t{\n \t  if (loc.block)\n \t    current_loc = set_block (current_loc, loc.block);\n \t  else\n \t    current_loc = LOCATION_LOCUS (current_loc);\n+\t  if (loc.discr)\n+\t    current_loc = location_with_discriminator (current_loc, loc.discr);\n \t}\n+      else if (current_discr != loc.discr)\n+\tcurrent_loc = location_with_discriminator (current_loc, loc.discr);\n       *loc.loc = current_loc;\n       current_line = loc.line;\n       prev_file = current_file = loc.file;\n       current_col = loc.col;\n       current_block = loc.block;\n+      current_discr = loc.discr;\n     }\n   loc_cache.truncate (0);\n   accepted_length = 0;\n@@ -512,6 +521,7 @@ lto_location_cache::input_location_and_block (location_t *loc,\n   static int stream_col;\n   static bool stream_sysp;\n   static tree stream_block;\n+  static unsigned stream_discr;\n   static const char *stream_relative_path_prefix;\n \n   gcc_assert (current_cache == this);\n@@ -538,6 +548,7 @@ lto_location_cache::input_location_and_block (location_t *loc,\n   *loc = RESERVED_LOCATION_COUNT;\n   bool line_change = bp_unpack_value (bp, 1);\n   bool column_change = bp_unpack_value (bp, 1);\n+  bool discr_change = bp_unpack_value (bp, 1);\n \n   if (file_change)\n     {\n@@ -563,6 +574,9 @@ lto_location_cache::input_location_and_block (location_t *loc,\n   if (column_change)\n     stream_col = bp_unpack_var_len_unsigned (bp);\n \n+  if (discr_change)\n+    stream_discr = bp_unpack_var_len_unsigned (bp);\n+\n   tree block = NULL_TREE;\n   if (ib)\n     {\n@@ -578,7 +592,8 @@ lto_location_cache::input_location_and_block (location_t *loc,\n   if (current_file == stream_file\n       && current_line == stream_line\n       && current_col == stream_col\n-      && current_sysp == stream_sysp)\n+      && current_sysp == stream_sysp\n+      && current_discr == stream_discr)\n     {\n       if (current_block == block)\n \t*loc = current_loc;\n@@ -590,7 +605,7 @@ lto_location_cache::input_location_and_block (location_t *loc,\n     }\n \n   struct cached_location entry\n-    = {stream_file, loc, stream_line, stream_col, stream_sysp, block};\n+    = {stream_file, loc, stream_line, stream_col, stream_sysp, block, stream_discr};\n   loc_cache.safe_push (entry);\n }\n "}, {"sha": "2e7af03888b38b9262b6c4dd42fc32571a6f3165", "filename": "gcc/lto-streamer-out.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -67,6 +67,7 @@ clear_line_info (struct output_block *ob)\n      so that the first location with block in a function etc.\n      always streams a change_block bit and the first block.  */\n   ob->current_block = void_node;\n+  ob->current_discr = UINT_MAX;\n }\n \n \n@@ -194,6 +195,7 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n   if (loc >= RESERVED_LOCATION_COUNT)\n     {\n       expanded_location xloc = expand_location (loc);\n+      unsigned discr = get_discriminator_from_loc (orig_loc);\n \n       if (ob->reset_locus)\n \t{\n@@ -216,6 +218,7 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n \n       bp_pack_value (bp, ob->current_line != xloc.line, 1);\n       bp_pack_value (bp, ob->current_col != xloc.column, 1);\n+      bp_pack_value (bp, ob->current_discr != discr, 1);\n \n       if (ob->current_file != xloc.file)\n \t{\n@@ -242,6 +245,10 @@ lto_output_location_1 (struct output_block *ob, struct bitpack_d *bp,\n       if (ob->current_col != xloc.column)\n \tbp_pack_var_len_unsigned (bp, xloc.column);\n       ob->current_col = xloc.column;\n+\n+      if (ob->current_discr != discr)\n+\tbp_pack_var_len_unsigned (bp, discr);\n+      ob->current_discr = discr;\n     }\n   else\n     bp_pack_int_in_range (bp, 0, RESERVED_LOCATION_COUNT + 1, loc);"}, {"sha": "2e3abd97959a836090daeee10e21d2e5fd3ede75", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -311,6 +311,7 @@ class lto_location_cache\n     int line, col;\n     bool sysp;\n     tree block;\n+    unsigned discr;\n   };\n \n   /* The location cache.  */\n@@ -333,6 +334,7 @@ class lto_location_cache\n   bool current_sysp;\n   location_t current_loc;\n   tree current_block;\n+  unsigned current_discr;\n };\n \n /* Structure used as buffer for reading an LTO file.  */\n@@ -723,6 +725,7 @@ struct output_block\n   bool reset_locus;\n   bool emit_pwd;\n   tree current_block;\n+  unsigned current_discr;\n \n   /* Cache of nodes written in this section.  */\n   struct streamer_tree_cache_d *writer_cache;"}, {"sha": "e115f987173c1e0b338de1d3edbe1eb60ec70e04", "filename": "gcc/print-rtl.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fprint-rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Fprint-rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -453,6 +453,10 @@ rtx_writer::print_rtx_operand_code_i (const_rtx in_rtx, int idx)\n \t  expanded_location xloc = insn_location (in_insn);\n \t  fprintf (m_outfile, \" \\\"%s\\\":%i:%i\", xloc.file, xloc.line,\n \t\t   xloc.column);\n+\t  int discriminator = insn_discriminator (in_insn);\n+\t    if (discriminator)\n+\t      fprintf (m_outfile, \" discrim %d\", discriminator);\n+\n \t}\n #endif\n     }"}, {"sha": "7a8c4709257d8d06ecebe4da2ddebb85765436d5", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -3369,6 +3369,7 @@ extern int insn_line (const rtx_insn *);\n extern const char * insn_file (const rtx_insn *);\n extern tree insn_scope (const rtx_insn *);\n extern expanded_location insn_location (const rtx_insn *);\n+extern int insn_discriminator (const rtx_insn *);\n extern location_t prologue_location, epilogue_location;\n \n /* In jump.cc */"}, {"sha": "e903e976f2c3254e32efcece9c5532d47ef15c29", "filename": "gcc/testsuite/c-c++-common/ubsan/pr85213.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr85213.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr85213.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fpr85213.c?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -1,6 +1,11 @@\n /* PR sanitizer/85213 */\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fsanitize=undefined -fcompare-debug\" } */\n+/* Pass -gno-statement-frontiers to work around\n+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100733 :\n+   without it the IR coming from the front end may be different with and without\n+   debug information turned on. That may cause e.g., different discriminator values\n+   and -fcompare-debug failures. */\n+/* { dg-options \"-O1 -fsanitize=undefined -fcompare-debug -gno-statement-frontiers\" } */\n \n int\n foo (int x)"}, {"sha": "ade66c54499ff481bb9d58fd5f3c616646514d65", "filename": "gcc/tree-cfg.cc", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree-cfg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree-cfg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -1166,7 +1166,33 @@ same_line_p (location_t locus1, expanded_location *from, location_t locus2)\n           && filename_cmp (from->file, to.file) == 0);\n }\n \n-/* Assign discriminators to each basic block.  */\n+/* Assign a unique discriminator value to all statements in block bb that\n+   have the same line number as locus. */\n+\n+static void\n+assign_discriminator (location_t locus, basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  int discriminator;\n+\n+  if (locus == UNKNOWN_LOCATION)\n+    return;\n+\n+  expanded_location locus_e = expand_location (locus);\n+\n+  discriminator = next_discriminator_for_locus (locus_e.line);\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      location_t stmt_locus = gimple_location (stmt);\n+      if (same_line_p (locus, &locus_e, stmt_locus))\n+\tgimple_set_location (stmt,\n+\t    location_with_discriminator (stmt_locus, discriminator));\n+    }\n+}\n+\n+/* Assign discriminators to statement locations.  */\n \n static void\n assign_discriminators (void)\n@@ -1189,17 +1215,22 @@ assign_discriminators (void)\n \t{\n \t  gimple *first = first_non_label_stmt (e->dest);\n \t  gimple *last = last_stmt (e->dest);\n-\t  if ((first && same_line_p (locus, &locus_e,\n+\n+\t  gimple *stmt_on_same_line = NULL;\n+\t  if (first && same_line_p (locus, &locus_e,\n \t\t\t\t     gimple_location (first)))\n-\t      || (last && same_line_p (locus, &locus_e,\n-\t\t\t\t       gimple_location (last))))\n+\t    stmt_on_same_line = first;\n+\t  else if (last && same_line_p (locus, &locus_e,\n+\t\t\t\t\tgimple_location (last)))\n+\t    stmt_on_same_line = last;\n+\n+\t  if (stmt_on_same_line)\n \t    {\n-\t      if (e->dest->discriminator != 0 && bb->discriminator == 0)\n-\t\tbb->discriminator\n-\t\t  = next_discriminator_for_locus (locus_e.line);\n+\t      if (has_discriminator (gimple_location (stmt_on_same_line))\n+\t\t  && !has_discriminator (locus))\n+\t\tassign_discriminator (locus, bb);\n \t      else\n-\t\te->dest->discriminator\n-\t\t  = next_discriminator_for_locus (locus_e.line);\n+\t\tassign_discriminator (locus, e->dest);\n \t    }\n \t}\n     }"}, {"sha": "e7a8c9481a6463b7016441b66ea68e6e604052f0", "filename": "gcc/tree-pretty-print.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -1455,6 +1455,7 @@ void\n dump_location (pretty_printer *pp, location_t loc)\n {\n   expanded_location xloc = expand_location (loc);\n+  int discriminator = get_discriminator_from_loc (loc);\n \n   pp_left_bracket (pp);\n   if (xloc.file)\n@@ -1465,6 +1466,11 @@ dump_location (pretty_printer *pp, location_t loc)\n   pp_decimal_int (pp, xloc.line);\n   pp_colon (pp);\n   pp_decimal_int (pp, xloc.column);\n+  if (discriminator)\n+  {\n+    pp_string (pp, \" discrim \");\n+    pp_decimal_int (pp, discriminator);\n+  }\n   pp_string (pp, \"] \");\n }\n "}, {"sha": "f8d24b5d4cf375bdeaf14fe8f9095b54e6e8ea56", "filename": "gcc/tree.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -14253,7 +14253,8 @@ set_block (location_t loc, tree block)\n {\n   location_t pure_loc = get_pure_location (loc);\n   source_range src_range = get_range_from_loc (line_table, loc);\n-  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block);\n+  unsigned discriminator = get_discriminator_from_loc (line_table, loc);\n+  return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block, discriminator);\n }\n \n location_t\n@@ -14271,11 +14272,14 @@ set_source_range (tree expr, source_range src_range)\n   if (!EXPR_P (expr))\n     return UNKNOWN_LOCATION;\n \n-  location_t pure_loc = get_pure_location (EXPR_LOCATION (expr));\n+  location_t expr_location = EXPR_LOCATION (expr);\n+  location_t pure_loc = get_pure_location (expr_location);\n+  unsigned discriminator = get_discriminator_from_loc (expr_location);\n   location_t adhoc = COMBINE_LOCATION_DATA (line_table,\n \t\t\t\t\t    pure_loc,\n \t\t\t\t\t    src_range,\n-\t\t\t\t\t    NULL);\n+\t\t\t\t\t    NULL,\n+\t\t\t\t\t    discriminator);\n   SET_EXPR_LOCATION (expr, adhoc);\n   return adhoc;\n }"}, {"sha": "50207cacc12d4fdff70438cce486c6ec25d12e54", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -757,6 +757,7 @@ struct GTY(()) location_adhoc_data {\n   location_t locus;\n   source_range src_range;\n   void * GTY((skip)) data;\n+  unsigned discriminator;\n };\n \n struct htab;\n@@ -1034,12 +1035,14 @@ LINEMAPS_LAST_ALLOCATED_MACRO_MAP (const line_maps *set)\n }\n \n extern location_t get_combined_adhoc_loc (line_maps *, location_t,\n-\t\t\t\t\t  source_range, void *);\n+\t\t\t\t\t  source_range, void *, unsigned);\n extern void *get_data_from_adhoc_loc (const line_maps *, location_t);\n+extern unsigned get_discriminator_from_adhoc_loc (const line_maps *, location_t);\n extern location_t get_location_from_adhoc_loc (const line_maps *,\n \t\t\t\t\t       location_t);\n \n extern source_range get_range_from_loc (line_maps *set, location_t loc);\n+extern unsigned get_discriminator_from_loc (line_maps *set, location_t loc);\n \n /* Get whether location LOC is a \"pure\" location, or\n    whether it is an ad-hoc location, or embeds range information.  */\n@@ -1058,9 +1061,10 @@ inline location_t\n COMBINE_LOCATION_DATA (class line_maps *set,\n \t\t       location_t loc,\n \t\t       source_range src_range,\n-\t\t       void *block)\n+\t\t       void *block,\n+\t\t       unsigned discriminator)\n {\n-  return get_combined_adhoc_loc (set, loc, src_range, block);\n+  return get_combined_adhoc_loc (set, loc, src_range, block, discriminator);\n }\n \n extern void rebuild_location_adhoc_htab (class line_maps *);"}, {"sha": "a429a3d44ceee9e7b2b7e8c43d158916a5733427", "filename": "libcpp/lex.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -1362,7 +1362,8 @@ get_location_for_byte_range_in_cur_line (cpp_reader *pfile,\n   location_t combined_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n \t\t\t\t\t\t   start_loc,\n \t\t\t\t\t\t   src_range,\n-\t\t\t\t\t\t   NULL);\n+\t\t\t\t\t\t   NULL,\n+\t\t\t\t\t\t   0);\n   return combined_loc;\n }\n \n@@ -2028,7 +2029,7 @@ warn_about_normalization (cpp_reader *pfile,\n \t\t\t\t\t   CPP_BUF_COLUMN (pfile->buffer,\n \t\t\t\t\t\t\t   pfile->buffer->cur));\n \t  loc = COMBINE_LOCATION_DATA (pfile->line_table,\n-\t\t\t\t       loc, tok_range, NULL);\n+\t\t\t\t       loc, tok_range, NULL, 0);\n \t}\n \n       encoding_rich_location rich_loc (pfile, loc);\n@@ -4256,7 +4257,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n \n       result->src_loc = COMBINE_LOCATION_DATA (pfile->line_table,\n \t\t\t\t\t       result->src_loc,\n-\t\t\t\t\t       tok_range, NULL);\n+\t\t\t\t\t       tok_range, NULL, 0);\n     }\n \n   return result;"}, {"sha": "50e8043255ecf607bab5b8265d2ea137fd82cdf1", "filename": "libcpp/line-map.cc", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Fline-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1adf45b17f7f1ede463524d80032bb2ec866ead/libcpp%2Fline-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.cc?ref=f1adf45b17f7f1ede463524d80032bb2ec866ead", "patch": "@@ -67,7 +67,8 @@ location_adhoc_data_hash (const void *l)\n   return ((hashval_t) lb->locus\n \t  + (hashval_t) lb->src_range.m_start\n \t  + (hashval_t) lb->src_range.m_finish\n-\t  + (size_t) lb->data);\n+\t  + (size_t) lb->data\n+\t  + lb->discriminator);\n }\n \n /* Compare function for location_adhoc_data hashtable.  */\n@@ -82,7 +83,8 @@ location_adhoc_data_eq (const void *l1, const void *l2)\n   return (lb1->locus == lb2->locus\n \t  && lb1->src_range.m_start == lb2->src_range.m_start\n \t  && lb1->src_range.m_finish == lb2->src_range.m_finish\n-\t  && lb1->data == lb2->data);\n+\t  && lb1->data == lb2->data\n+\t  && lb1->discriminator == lb2->discriminator);\n }\n \n /* Update the hashtable when location_adhoc_data_map::data is reallocated.\n@@ -127,13 +129,17 @@ static bool\n can_be_stored_compactly_p (line_maps *set,\n \t\t\t   location_t locus,\n \t\t\t   source_range src_range,\n-\t\t\t   void *data)\n+\t\t\t   void *data,\n+\t\t\t   unsigned discriminator)\n {\n   /* If there's an ad-hoc pointer, we can't store it directly in the\n      location_t, we need the lookaside.  */\n   if (data)\n     return false;\n \n+  if (discriminator != 0)\n+    return false;\n+\n   /* We only store ranges that begin at the locus and that are sufficiently\n      \"sane\".  */\n   if (src_range.m_start != locus)\n@@ -168,7 +174,8 @@ location_t\n get_combined_adhoc_loc (line_maps *set,\n \t\t\tlocation_t locus,\n \t\t\tsource_range src_range,\n-\t\t\tvoid *data)\n+\t\t\tvoid *data,\n+\t\t\tunsigned discriminator)\n {\n   struct location_adhoc_data lb;\n   struct location_adhoc_data **slot;\n@@ -186,7 +193,7 @@ get_combined_adhoc_loc (line_maps *set,\n \t\t  || pure_location_p (set, locus));\n \n   /* Consider short-range optimization.  */\n-  if (can_be_stored_compactly_p (set, locus, src_range, data))\n+  if (can_be_stored_compactly_p (set, locus, src_range, data, discriminator))\n     {\n       /* The low bits ought to be clear.  */\n       linemap_assert (pure_location_p (set, locus));\n@@ -206,15 +213,16 @@ get_combined_adhoc_loc (line_maps *set,\n      when locus == start == finish (and data is NULL).  */\n   if (locus == src_range.m_start\n       && locus == src_range.m_finish\n-      && !data)\n+      && !data && discriminator == 0)\n     return locus;\n \n-  if (!data)\n+  if (!data && discriminator == 0)\n     set->num_unoptimized_ranges++;\n \n   lb.locus = locus;\n   lb.src_range = src_range;\n   lb.data = data;\n+  lb.discriminator = discriminator;\n   slot = (struct location_adhoc_data **)\n       htab_find_slot (set->location_adhoc_data_map.htab, &lb, INSERT);\n   if (*slot == NULL)\n@@ -261,6 +269,13 @@ get_data_from_adhoc_loc (const class line_maps *set, location_t loc)\n   return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].data;\n }\n \n+unsigned\n+get_discriminator_from_adhoc_loc (const class line_maps *set, location_t loc)\n+{\n+  linemap_assert (IS_ADHOC_LOC (loc));\n+  return set->location_adhoc_data_map.data[loc & MAX_LOCATION_T].discriminator;\n+}\n+\n /* Return the location for the adhoc loc.  */\n \n location_t\n@@ -306,6 +321,15 @@ get_range_from_loc (line_maps *set,\n   return source_range::from_location (loc);\n }\n \n+unsigned\n+get_discriminator_from_loc (line_maps *set,\n+\t\t\t    location_t loc)\n+{\n+  if (IS_ADHOC_LOC (loc))\n+    return get_discriminator_from_adhoc_loc (set, loc);\n+  return 0;\n+}\n+\n /* Get whether location LOC is a \"pure\" location, or\n    whether it is an ad-hoc location, or embeds range information.  */\n "}]}