{"sha": "f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA4YTE4ZDA3OGUyYjRiYjJhZWIzZjI5OTgwYWQzODliNzAxZjljZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-09T15:00:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-09T15:00:25Z"}, "message": "tree-eh.c (struct leh_state): Remove prev_try.\n\n\t* tree-eh.c (struct leh_state): Remove prev_try.\n\t(lower_try_finally, lower_catch, lower_eh_filter, lower_cleanup): Do\n\tnot track prev_try.\n\t* except.c (gen_eh_region_cleanup, duplicate_eh_regions, \n\tcopy_eh_region_1, copy_eh_region, redirect_eh_edge_to_label,\n\tremove_eh_handler_and_replace, foreach_reachable_handler,\n\tverify_eh_region, verify_eh_tree): Remove tracking of prev_try pointer.\n\t* except.h (struct eh_region): Remove eh_region_u_cleanup.\n\t(gen_eh_region_cleanup): Update prototype.\n\nFrom-SVN: r147318", "tree": {"sha": "6a98a3da525eb5ac32d4be39115d2cb149ca7112", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a98a3da525eb5ac32d4be39115d2cb149ca7112"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/comments", "author": null, "committer": null, "parents": [{"sha": "0afd721984444224c371c811504d7db8eccf9fce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0afd721984444224c371c811504d7db8eccf9fce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0afd721984444224c371c811504d7db8eccf9fce"}], "stats": {"total": 132, "additions": 29, "deletions": 103}, "files": [{"sha": "26f2a689a2a34722a206f5117bc36e7bc8446a0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "patch": "@@ -1,3 +1,15 @@\n+2009-05-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-eh.c (struct leh_state): Remove prev_try.\n+\t(lower_try_finally, lower_catch, lower_eh_filter, lower_cleanup): Do\n+\tnot track prev_try.\n+\t* except.c (gen_eh_region_cleanup, duplicate_eh_regions, \n+\tcopy_eh_region_1, copy_eh_region, redirect_eh_edge_to_label,\n+\tremove_eh_handler_and_replace, foreach_reachable_handler,\n+\tverify_eh_region, verify_eh_tree): Remove tracking of prev_try pointer.\n+\t* except.h (struct eh_region): Remove eh_region_u_cleanup.\n+\t(gen_eh_region_cleanup): Update prototype.\n+\n 2009-05-09  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/40043"}, {"sha": "a33f3096fbf61f3683c3699e32572c05999aae4d", "filename": "gcc/except.c", "status": "modified", "additions": 14, "deletions": 85, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "patch": "@@ -338,10 +338,9 @@ gen_eh_region (enum eh_region_type type, struct eh_region *outer)\n }\n \n struct eh_region *\n-gen_eh_region_cleanup (struct eh_region *outer, struct eh_region *prev_try)\n+gen_eh_region_cleanup (struct eh_region *outer)\n {\n   struct eh_region *cleanup = gen_eh_region (ERT_CLEANUP, outer);\n-  cleanup->u.cleanup.prev_try = prev_try;\n   return cleanup;\n }\n \n@@ -1183,8 +1182,8 @@ duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n   return ret;\n }\n \n-/* Return prev_try pointers catch subregions of R should\n-   point to.  */\n+/* Look for first outer region of R (or R itself) that is\n+   TRY region. Return NULL if none.  */\n \n static struct eh_region *\n find_prev_try (struct eh_region * r)\n@@ -1208,7 +1207,7 @@ int\n duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \t\t      void *data, int copy_region, int outer_region)\n {\n-  eh_region cur, prev_try, old_prev_try, outer, *splice;\n+  eh_region cur, outer, *splice;\n   int i, min_region, max_region, eh_offset, cfun_last_region_number;\n   int num_regions;\n \n@@ -1228,14 +1227,12 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n       max_region = 0;\n \n       cur = VEC_index (eh_region, ifun->eh->region_array, copy_region);\n-      old_prev_try = find_prev_try (cur);\n       duplicate_eh_regions_0 (cur, &min_region, &max_region);\n     }\n   else\n     {\n       min_region = 1;\n       max_region = ifun->eh->last_region_number;\n-      old_prev_try = NULL;\n     }\n   num_regions = max_region - min_region + 1;\n   cfun_last_region_number = cfun->eh->last_region_number;\n@@ -1302,12 +1299,6 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n     if (cur && cur->tree_label)\n       cur->tree_label = map (cur->tree_label, data);\n \n-  /* Search for the containing ERT_TRY region to fix up\n-     the prev_try short-cuts for ERT_CLEANUP regions.  */\n-  prev_try = NULL;\n-  if (outer_region > 0)\n-    prev_try = find_prev_try (VEC_index (eh_region, cfun->eh->region_array, outer_region));\n-\n   /* Remap all of the internal catch and cleanup linkages.  Since we \n      duplicate entire subtrees, all of the referenced regions will have\n      been copied too.  And since we renumbered them as a block, a simple\n@@ -1354,13 +1345,6 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \t    REMAP (cur->u.eh_catch.prev_catch);\n \t  break;\n \n-\tcase ERT_CLEANUP:\n-\t  if (cur->u.cleanup.prev_try != old_prev_try)\n-\t    REMAP (cur->u.cleanup.prev_try);\n-\t  else\n-\t    cur->u.cleanup.prev_try = prev_try;\n-\t  break;\n-\n \tdefault:\n \t  break;\n \t}\n@@ -1394,14 +1378,10 @@ copy_eh_region_1 (struct eh_region *old, struct eh_region *new_outer)\n \n /* Return new copy of eh region OLD inside region NEW_OUTER.  \n   \n-   Copy whole catch-try chain if neccesary and update cleanup region prev_try\n-   pointers.\n-\n-   PREV_TRY_MAP points to outer TRY region if it was copied in trace already.  */\n+   Copy whole catch-try chain if neccesary.  */\n \n static struct eh_region *\n-copy_eh_region (struct eh_region *old, struct eh_region *new_outer,\n-\t\tstruct eh_region *prev_try_map)\n+copy_eh_region (struct eh_region *old, struct eh_region *new_outer)\n {\n   struct eh_region *r, *n, *old_try, *new_try, *ret = NULL;\n   VEC(eh_region,heap) *catch_list = NULL;\n@@ -1410,11 +1390,6 @@ copy_eh_region (struct eh_region *old, struct eh_region *new_outer,\n     {\n       gcc_assert (old->type != ERT_TRY);\n       r = copy_eh_region_1 (old, new_outer);\n-      if (r->type == ERT_CLEANUP)\n-        {\n-\t  gcc_assert (r->u.cleanup.prev_try || !prev_try_map);\n-          r->u.cleanup.prev_try = prev_try_map;\n-\t}\n       return r;\n     }\n \n@@ -1477,7 +1452,7 @@ struct eh_region *\n redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n \t\t\t   bool inlinable_call, int region_number)\n {\n-  struct eh_region *outer, *prev_try_map;\n+  struct eh_region *outer;\n   struct eh_region *region;\n   VEC (eh_region, heap) * trace = NULL;\n   int i;\n@@ -1539,7 +1514,6 @@ redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n \t}\n       outer = VEC_index (eh_region, trace, start_here)->outer;\n       gcc_assert (start_here >= 0);\n-      prev_try_map = find_prev_try (outer);\n \n       /* And now do the dirty job!  */\n       for (i = start_here; i >= 0; i--)\n@@ -1548,7 +1522,7 @@ redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n \t  gcc_assert (!outer || old->outer != outer->outer);\n \n \t  /* Copy region and update label.  */\n-\t  r = copy_eh_region (old, outer, prev_try_map);\n+\t  r = copy_eh_region (old, outer);\n \t  VEC_replace (eh_region, trace, i, r);\n \t  if (r->tree_label && label_to_block (r->tree_label) == old_bb)\n \t    {\n@@ -1588,14 +1562,11 @@ redirect_eh_edge_to_label (edge e, tree new_dest_label, bool is_resx,\n \t\t }\n \t     }\n \n-\t  /* Cleanup regions points to outer TRY blocks.  */\n-\t  if (r->type == ERT_TRY)\n-\t    prev_try_map = r;\n \t  outer = r;\n \t}\n         \n       if (is_resx || region->type == ERT_THROW)\n-\tr = copy_eh_region (region, outer, prev_try_map);\n+\tr = copy_eh_region (region, outer);\n     }\n \n   VEC_free (eh_region, heap, trace);\n@@ -2674,32 +2645,6 @@ remove_eh_handler_and_replace (struct eh_region *region,\n \n   outer = region->outer;\n \n-  /* When we are moving the region in EH tree, update prev_try pointers.  */\n-  if ((outer != replace || region->type == ERT_TRY) && region->inner)\n-    {\n-      struct eh_region *prev_try = find_prev_try (replace);\n-      p = region->inner;\n-      while (p != region)\n-\t{\n-\t  if (p->type == ERT_CLEANUP)\n-\t    p->u.cleanup.prev_try = prev_try;\n-          if (p->type != ERT_TRY\n-\t      && p->type != ERT_MUST_NOT_THROW\n-\t      && (p->type != ERT_ALLOWED_EXCEPTIONS\n-\t          || p->u.allowed.type_list)\n-\t      && p->inner)\n-\t    p = p->inner;\n-\t  else if (p->next_peer)\n-\t    p = p->next_peer;\n-\t  else\n-\t    {\n-\t      while (p != region && !p->next_peer)\n-\t        p = p->outer;\n-\t      if (p != region)\n-\t\tp = p->next_peer;\n-\t    }\n-\t}\n-    }\n   /* For the benefit of efficiently handling REG_EH_REGION notes,\n      replace this region in the region array with its containing\n      region.  Note that previous region deletions may result in\n@@ -3123,7 +3068,7 @@ foreach_reachable_handler (int region_number, bool is_resx, bool inlinable_call,\n       if (region->type == ERT_CLEANUP)\n         {\n \t  enum reachable_code code = RNL_NOT_CAUGHT;\n-\t  region = region->u.cleanup.prev_try;\n+\t  region = find_prev_try (region->outer);\n \t  /* Continue looking for outer TRY region until we find one\n \t     that might cath something.  */\n           while (region\n@@ -4431,9 +4376,6 @@ dump_eh_tree (FILE * out, struct function *fun)\n       switch (i->type)\n \t{\n \tcase ERT_CLEANUP:\n-\t  if (i->u.cleanup.prev_try)\n-\t    fprintf (out, \" prev try:%i\",\n-\t\t     i->u.cleanup.prev_try->region_number);\n \t  break;\n \n \tcase ERT_TRY:\n@@ -4513,21 +4455,13 @@ debug_eh_tree (struct function *fn)\n /* Verify EH region invariants.  */\n \n static bool\n-verify_eh_region (struct eh_region *region, struct eh_region *prev_try)\n+verify_eh_region (struct eh_region *region)\n {\n   bool found = false;\n   if (!region)\n     return false;\n   switch (region->type)\n     {\n-    case ERT_CLEANUP:\n-      if (region->u.cleanup.prev_try != prev_try)\n-\t{\n-\t  error (\"Wrong prev_try pointer in EH region %i\",\n-\t\t region->region_number);\n-\t  found = true;\n-\t}\n-      break;\n     case ERT_TRY:\n       {\n \tstruct eh_region *c, *prev = NULL;\n@@ -4574,21 +4508,16 @@ verify_eh_region (struct eh_region *region, struct eh_region *prev_try)\n \t  found = true;\n \t}\n       break;\n+    case ERT_CLEANUP:\n     case ERT_ALLOWED_EXCEPTIONS:\n     case ERT_MUST_NOT_THROW:\n     case ERT_THROW:\n       break;\n     case ERT_UNKNOWN:\n       gcc_unreachable ();\n     }\n-  if (region->type == ERT_TRY)\n-    prev_try = region;\n-  else if (region->type == ERT_MUST_NOT_THROW\n-\t   || (region->type == ERT_ALLOWED_EXCEPTIONS\n-\t       && !region->u.allowed.type_list))\n-    prev_try = NULL;\n   for (region = region->inner; region; region = region->next_peer)\n-    found |= verify_eh_region (region, prev_try);\n+    found |= verify_eh_region (region);\n   return found;\n }\n \n@@ -4672,7 +4601,7 @@ verify_eh_tree (struct function *fun)\n \t\t    }\n \t\t  if (!err)\n \t\t    for (i = fun->eh->region_tree; i; i = i->next_peer)\n-\t\t      err |= verify_eh_region (i, NULL);\n+\t\t      err |= verify_eh_region (i);\n \t\t  \n \t\t  if (err)\n \t\t    {"}, {"sha": "7769b381f411b4a9253fdf3b22f796159f35c4bd", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "patch": "@@ -85,12 +85,6 @@ struct GTY(()) eh_region\n     struct eh_region_u_throw {\n       tree type;\n     } GTY ((tag (\"ERT_THROW\"))) eh_throw;\n-\n-    /* Retain the cleanup expression even after expansion so that\n-       we can match up fixup regions.  */\n-    struct eh_region_u_cleanup {\n-      struct eh_region *prev_try;\n-    } GTY ((tag (\"ERT_CLEANUP\"))) cleanup;\n   } GTY ((desc (\"%0.type\"))) u;\n \n   /* Entry point for this region's handler before landing pads are built.  */\n@@ -185,8 +179,7 @@ extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map,\n extern void sjlj_emit_function_exit_after (rtx);\n extern void default_init_unwind_resume_libfunc (void);\n \n-extern struct eh_region *gen_eh_region_cleanup (struct eh_region *,\n-\t\t\t\t\t\tstruct eh_region *);\n+extern struct eh_region *gen_eh_region_cleanup (struct eh_region *);\n extern struct eh_region *gen_eh_region_try (struct eh_region *);\n extern struct eh_region *gen_eh_region_catch (struct eh_region *, tree);\n extern struct eh_region *gen_eh_region_allowed (struct eh_region *, tree);"}, {"sha": "3cac10f96d6c4ac8f7a1022a21fb09614b7f9635", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08a18d078e2b4bb2aeb3f29980ad389b701f9ce/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=f08a18d078e2b4bb2aeb3f29980ad389b701f9ce", "patch": "@@ -352,7 +352,6 @@ struct leh_state\n      correspond to variables of the same name in cfun->eh, which we\n      don't have easy access to.  */\n   struct eh_region *cur_region;\n-  struct eh_region *prev_try;\n \n   /* Processing of TRY_FINALLY requires a bit more state.  This is\n      split out into a separate structure so that we don't have to\n@@ -1566,12 +1565,11 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   this_tf.outer = state;\n   if (using_eh_for_cleanups_p)\n     this_tf.region\n-      = gen_eh_region_cleanup (state->cur_region, state->prev_try);\n+      = gen_eh_region_cleanup (state->cur_region);\n   else\n     this_tf.region = NULL;\n \n   this_state.cur_region = this_tf.region;\n-  this_state.prev_try = state->prev_try;\n   this_state.tf = &this_tf;\n \n   lower_eh_constructs_1 (&this_state, gimple_try_eval(tp));\n@@ -1650,7 +1648,6 @@ lower_catch (struct leh_state *state, gimple tp)\n \n   try_region = gen_eh_region_try (state->cur_region);\n   this_state.cur_region = try_region;\n-  this_state.prev_try = try_region;\n   this_state.tf = state->tf;\n \n   lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n@@ -1672,7 +1669,6 @@ lower_catch (struct leh_state *state, gimple tp)\n                                           gimple_catch_types (gcatch));\n \n       this_state.cur_region = catch_region;\n-      this_state.prev_try = state->prev_try;\n       lower_eh_constructs_1 (&this_state, gimple_catch_handler (gcatch));\n \n       eh_label = create_artificial_label ();\n@@ -1719,10 +1715,6 @@ lower_eh_filter (struct leh_state *state, gimple tp)\n \t\t\t\t\t gimple_eh_filter_types (inner));\n   this_state = *state;\n   this_state.cur_region = this_region;\n-  /* For must not throw regions any cleanup regions inside it\n-     can't reach outer catch regions.  */\n-  if (gimple_eh_filter_must_not_throw (inner))\n-    this_state.prev_try = NULL;\n \n   lower_eh_constructs_1 (&this_state, gimple_try_eval (tp));\n \n@@ -1759,7 +1751,7 @@ lower_cleanup (struct leh_state *state, gimple tp)\n       return result;\n     }\n \n-  this_region = gen_eh_region_cleanup (state->cur_region, state->prev_try);\n+  this_region = gen_eh_region_cleanup (state->cur_region);\n   this_state = *state;\n   this_state.cur_region = this_region;\n "}]}