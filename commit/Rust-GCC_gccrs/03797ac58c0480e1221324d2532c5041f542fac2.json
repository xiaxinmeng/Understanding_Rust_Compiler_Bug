{"sha": "03797ac58c0480e1221324d2532c5041f542fac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM3OTdhYzU4YzA0ODBlMTIyMTMyNGQyNTMyYzUwNDFmNTQyZmFjMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-06-28T12:12:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-28T12:12:51Z"}, "message": "tree-sra.c (is_sra_candidate_ref): Remove second arg; all callers changed.\n\n\t* tree-sra.c (is_sra_candidate_ref): Remove second arg; all callers\n\tchanged.\n\t(is_sra_candidate_complex_ref): New function.\n\t(scalarize_modify_expr): Call it and check for LHS also.\n\nFrom-SVN: r83784", "tree": {"sha": "ebd7965dd7e0d7e3491d71a34ab36c403cd68810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebd7965dd7e0d7e3491d71a34ab36c403cd68810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03797ac58c0480e1221324d2532c5041f542fac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03797ac58c0480e1221324d2532c5041f542fac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03797ac58c0480e1221324d2532c5041f542fac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03797ac58c0480e1221324d2532c5041f542fac2/comments", "author": null, "committer": null, "parents": [{"sha": "5f2dcbe1ffa17b74c21b0fbc901793e2bae55e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2dcbe1ffa17b74c21b0fbc901793e2bae55e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2dcbe1ffa17b74c21b0fbc901793e2bae55e22"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "e65f82346d874b1fe7a69facf662b8ea51d5beb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03797ac58c0480e1221324d2532c5041f542fac2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03797ac58c0480e1221324d2532c5041f542fac2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03797ac58c0480e1221324d2532c5041f542fac2", "patch": "@@ -1,5 +1,10 @@\n 2004-06-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree-sra.c (is_sra_candidate_ref): Remove second arg; all callers\n+\tchanged.\n+\t(is_sra_candidate_complex_ref): New function.\n+\t(scalarize_modify_expr): Call it and check for LHS also.\n+\n \t* tree-pretty-print.c (dump_function_declaration): New.\n \t(dump_generic_node, case FUNCTION_TYPE): Call it.\n \t(dump_generic_node, case RECORD_TYPE): Don't output dup semicolon."}, {"sha": "24b2d187c961806b51948d43aaa0286c8505a7d7", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03797ac58c0480e1221324d2532c5041f542fac2/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03797ac58c0480e1221324d2532c5041f542fac2/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=03797ac58c0480e1221324d2532c5041f542fac2", "patch": "@@ -160,21 +160,13 @@ is_sra_candidate_decl (tree decl)\n }\n \n /* Return true if EXP is of the form <ref decl>, where REF is one of the\n-   field access references we handle and DECL is an SRA candidate. \n-\n-   Set ALLOW_BIT_FIELD_REF to accept BIT_FIELD_REF as well.  This is\n-   normally false, except when we're trying to work around it.  */\n+   field access references we handle and DECL is an SRA candidate.   */\n \n static bool\n-is_sra_candidate_ref (tree exp, bool allow_bit_field_ref)\n+is_sra_candidate_ref (tree exp)\n {\n   switch (TREE_CODE (exp))\n     {\n-    case BIT_FIELD_REF:\n-      if (!allow_bit_field_ref)\n-\tbreak;\n-      /* FALLTHRU */\n-\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -187,6 +179,28 @@ is_sra_candidate_ref (tree exp, bool allow_bit_field_ref)\n   return false;\n }\n \n+/* Return true if EXP is of the form <ref decl>, where REF is a nest of\n+   references handled by handle_components_p and DECL is an SRA candidate. \n+   *VAR_P is set to DECL.  */\n+\n+static bool\n+is_sra_candidate_complex_ref (tree exp, tree *var_p)\n+{\n+  tree orig_exp = exp;\n+\n+  while (TREE_CODE (exp) == REALPART_EXPR || TREE_CODE (exp) == IMAGPART_EXPR\n+\t || handled_component_p (exp))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  if (orig_exp != exp && is_sra_candidate_decl (exp))\n+    {\n+      *var_p = exp;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return the scalar in SRA_MAP[VAR_IX][FIELD_IX].  If none exists, create\n    a new scalar with type TYPE.  */\n \n@@ -916,9 +930,10 @@ scalarize_modify_expr (block_stmt_iterator *si_p)\n   tree stmt = bsi_stmt (*si_p);\n   tree lhs = TREE_OPERAND (stmt, 0);\n   tree rhs = TREE_OPERAND (stmt, 1);\n+  tree var = NULL_TREE;\n \n   /* Found AGGREGATE.FIELD = ...  */\n-  if (is_sra_candidate_ref (lhs, false))\n+  if (is_sra_candidate_ref (lhs))\n     {\n       tree sym;\n       v_may_def_optype v_may_defs;\n@@ -936,10 +951,12 @@ scalarize_modify_expr (block_stmt_iterator *si_p)\n     }\n \n   /* Found ... = AGGREGATE.FIELD  */\n-  else if (is_sra_candidate_ref (rhs, false))\n+  else if (is_sra_candidate_ref (rhs))\n     scalarize_component_ref (stmt, &TREE_OPERAND (stmt, 1));\n \n-  /* Found ... = BIT_FIELD_REF <>.  This is similar to a CALL_EXPR, if the\n+  /* Found a complex reference nesting involving a candidate decl.  This\n+     should only occur if the above condition is false if a BIT_FIELD_REF or\n+     VIEW_CONVERT_EXPR is involved.  This is similar to a CALL_EXPR, if the\n      operand of the BIT_FIELD_REF is a scalarizable structure, we need to\n      copy from its scalar replacements before doing the bitfield operation.\n \n@@ -951,10 +968,22 @@ scalarize_modify_expr (block_stmt_iterator *si_p)\n      generates a BIT_FIELD_REF operation for one of the comparisons,\n      preventing the optimizers from removing all the redundant\n      operations.  */\n-  else if (is_sra_candidate_ref (rhs, true))\n+  else if (is_sra_candidate_complex_ref (rhs, &var))\n     {\n-      tree var = TREE_OPERAND (rhs, 0);\n       emit_scalar_copies (si_p, var, var, FIELD_SCALAR);\n+\n+      /* If the LHS of the assignment is also a scalarizable structure, insert\n+\t copies into the scalar replacements after the call.  */\n+      if (is_sra_candidate_decl (lhs))\n+\t{\n+\t  tree list = create_scalar_copies (lhs, lhs, SCALAR_FIELD);\n+\t  if (EXPR_HAS_LOCATION (stmt))\n+\t    annotate_all_with_locus (&list, EXPR_LOCATION (stmt));\n+\t  if (stmt_ends_bb_p (stmt))\n+\t    insert_edge_copies (list, bb_for_stmt (stmt));\n+\t  else\n+\t    bsi_insert_after (si_p, list, BSI_NEW_STMT);\n+\t}\n     }\n \n   /* Found AGGREGATE = ... or ... = AGGREGATE  */\n@@ -983,7 +1012,7 @@ scalarize_tree_list (tree list, block_stmt_iterator *si_p, bitmap done)\n \t      bitmap_set_bit (done, index);\n \t    }\n \t}\n-      else if (is_sra_candidate_ref (arg, false))\n+      else if (is_sra_candidate_ref (arg))\n \t{\n \t  tree stmt = bsi_stmt (*si_p);\n \t  scalarize_component_ref (stmt, &TREE_VALUE (op));\n@@ -1071,7 +1100,7 @@ scalarize_return_expr (block_stmt_iterator *si_p)\n \temit_scalar_copies (si_p, rhs, rhs, FIELD_SCALAR);\n \n       /* Handle 'return STRUCTURE.FIELD;'  */\n-      else if (is_sra_candidate_ref (rhs, false))\n+      else if (is_sra_candidate_ref (rhs))\n \tscalarize_component_ref (stmt, rhs_p);\n \n       /* Handle 'return CALL_EXPR;'  */"}]}