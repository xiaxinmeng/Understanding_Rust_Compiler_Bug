{"sha": "ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2Y2MxZjVjYjNiNmNjMzE2ZjJmNjc1ODNiNjJiOTJhNWRlNGU0Yg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-09-04T23:38:25Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-09-04T23:38:25Z"}, "message": "loop.c (scan_loop): Don't mark separate insns out of a libcall for moving.\n\ngcc:\n\t* loop.c (scan_loop): Don't mark separate insns out of a libcall\n\tfor moving.\n\t(move_movables): Abort if we see the first insn of a libcall.\ngcc/testsuite\n\t* gcc.c-torture/execute/loop-14.c: New test.\n\nFrom-SVN: r56823", "tree": {"sha": "5a91ef9a878ee4265409da26fe95d2576261983a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a91ef9a878ee4265409da26fe95d2576261983a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/comments", "author": null, "committer": null, "parents": [{"sha": "5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aa3396cd44c61d134aab3b123b1f2a73aa9d1a9"}], "stats": {"total": 563, "additions": 308, "deletions": 255}, "files": [{"sha": "c9718d5a395a8ceaff16a1cce6423642b4fbca9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "patch": "@@ -1,3 +1,9 @@\n+Thu Sep  5 00:34:33 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* loop.c (scan_loop): Don't mark separate insns out of a libcall\n+\tfor moving.\n+\t(move_movables): Abort if we see the first insn of a libcall.\n+\n 2002-09-04  Richard Henderson  <rth@redhat.com>\n \n \t* builtin-types.def (BT_FN_FLOAT): New."}, {"sha": "a367d345213c417e8f25a54f818139876d424022", "filename": "gcc/loop.c", "status": "modified", "additions": 278, "deletions": 255, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "patch": "@@ -633,6 +633,7 @@ scan_loop (loop, flags)\n   int threshold;\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n+  int in_libcall;\n \n   loop->top = 0;\n \n@@ -749,290 +750,312 @@ scan_loop (loop, flags)\n      When MAYBE_NEVER is 0, all insns will be executed at least once\n      so that is not a problem.  */\n \n-  for (p = next_insn_in_loop (loop, loop->scan_start);\n+  for (in_libcall = 0, p = next_insn_in_loop (loop, loop->scan_start);\n        p != NULL_RTX;\n        p = next_insn_in_loop (loop, p))\n     {\n-      if (GET_CODE (p) == INSN\n-\t  && (set = single_set (p))\n-\t  && GET_CODE (SET_DEST (set)) == REG\n-#ifdef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n-\t  && SET_DEST (set) != pic_offset_table_rtx\n-#endif\n-\t  && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n+      if (in_libcall && INSN_P (p) && find_reg_note (p, REG_RETVAL, NULL_RTX))\n+\tin_libcall--;\n+      if (GET_CODE (p) == INSN)\n \t{\n-\t  int tem1 = 0;\n-\t  int tem2 = 0;\n-\t  int move_insn = 0;\n-\t  rtx src = SET_SRC (set);\n-\t  rtx dependencies = 0;\n-\n-\t  /* Figure out what to use as a source of this insn.  If a REG_EQUIV\n-\t     note is given or if a REG_EQUAL note with a constant operand is\n-\t     specified, use it as the source and mark that we should move\n-\t     this insn by calling emit_move_insn rather that duplicating the\n-\t     insn.\n-\n-\t     Otherwise, only use the REG_EQUAL contents if a REG_RETVAL note\n-\t     is present.  */\n-\t  temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n+\t  temp = find_reg_note (p, REG_LIBCALL, NULL_RTX);\n \t  if (temp)\n-\t    src = XEXP (temp, 0), move_insn = 1;\n-\t  else\n+\t    in_libcall++;\n+\t  if (! in_libcall\n+\t      && (set = single_set (p))\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+#ifdef PIC_OFFSET_TABLE_REG_CALL_CLOBBERED\n+\t      && SET_DEST (set) != pic_offset_table_rtx\n+#endif\n+\t      && ! regs->array[REGNO (SET_DEST (set))].may_not_optimize)\n \t    {\n-\t      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n-\t      if (temp && CONSTANT_P (XEXP (temp, 0)))\n+\t      int tem1 = 0;\n+\t      int tem2 = 0;\n+\t      int move_insn = 0;\n+\t      rtx src = SET_SRC (set);\n+\t      rtx dependencies = 0;\n+\n+\t      /* Figure out what to use as a source of this insn.  If a\n+\t\t REG_EQUIV note is given or if a REG_EQUAL note with a\n+\t\t constant operand is specified, use it as the source and\n+\t\t mark that we should move this insn by calling\n+\t\t emit_move_insn rather that duplicating the insn.\n+\n+\t\t Otherwise, only use the REG_EQUAL contents if a REG_RETVAL\n+\t\t note is present.  */\n+\t      temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n+\t      if (temp)\n \t\tsrc = XEXP (temp, 0), move_insn = 1;\n-\t      if (temp && find_reg_note (p, REG_RETVAL, NULL_RTX))\n-\t\t{\n-\t\t  src = XEXP (temp, 0);\n-\t\t  /* A libcall block can use regs that don't appear in\n-\t\t     the equivalent expression.  To move the libcall,\n-\t\t     we must move those regs too.  */\n-\t\t  dependencies = libcall_other_reg (p, src);\n-\t\t}\n-\t    }\n-\n-\t  /* For parallels, add any possible uses to the depencies, as we can't move\n-\t     the insn without resolving them first.  */\n-\t  if (GET_CODE (PATTERN (p)) == PARALLEL)\n-\t    {\n-\t      for (i = 0; i < XVECLEN (PATTERN (p), 0); i++)\n+\t      else\n \t\t{\n-\t\t  rtx x = XVECEXP (PATTERN (p), 0, i);\n-\t\t  if (GET_CODE (x) == USE)\n-\t\t    dependencies = gen_rtx_EXPR_LIST (VOIDmode, XEXP (x, 0), dependencies);\n+\t\t  temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n+\t\t  if (temp && CONSTANT_P (XEXP (temp, 0)))\n+\t\t    src = XEXP (temp, 0), move_insn = 1;\n+\t\t  if (temp && find_reg_note (p, REG_RETVAL, NULL_RTX))\n+\t\t    {\n+\t\t      src = XEXP (temp, 0);\n+\t\t      /* A libcall block can use regs that don't appear in\n+\t\t\t the equivalent expression.  To move the libcall,\n+\t\t\t we must move those regs too.  */\n+\t\t      dependencies = libcall_other_reg (p, src);\n+\t\t    }\n \t\t}\n-\t    }\n \n-\t  /* Don't try to optimize a register that was made\n-\t     by loop-optimization for an inner loop.\n-\t     We don't know its life-span, so we can't compute the benefit.  */\n-\t  if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n-\t    ;\n-\t  else if (/* The register is used in basic blocks other\n-\t\t      than the one where it is set (meaning that\n-\t\t      something after this point in the loop might\n-\t\t      depend on its value before the set).  */\n-\t\t   ! reg_in_basic_block_p (p, SET_DEST (set))\n-\t\t   /* And the set is not guaranteed to be executed once\n-\t\t      the loop starts, or the value before the set is\n-\t\t      needed before the set occurs...\n-\n-\t\t      ??? Note we have quadratic behaviour here, mitigated\n-\t\t      by the fact that the previous test will often fail for\n-\t\t      large loops.  Rather than re-scanning the entire loop\n-\t\t      each time for register usage, we should build tables\n-\t\t      of the register usage and use them here instead.  */\n-\t\t   && (maybe_never\n-\t\t       || loop_reg_used_before_p (loop, set, p)))\n-\t    /* It is unsafe to move the set.\n-\n-\t       This code used to consider it OK to move a set of a variable\n-\t       which was not created by the user and not used in an exit test.\n-\t       That behavior is incorrect and was removed.  */\n-\t    ;\n-\t  else if ((tem = loop_invariant_p (loop, src))\n-\t\t   && (dependencies == 0\n-\t\t       || (tem2 = loop_invariant_p (loop, dependencies)) != 0)\n-\t\t   && (regs->array[REGNO (SET_DEST (set))].set_in_loop == 1\n-\t\t       || (tem1\n-\t\t\t   = consec_sets_invariant_p\n-\t\t\t   (loop, SET_DEST (set),\n-\t\t\t    regs->array[REGNO (SET_DEST (set))].set_in_loop,\n-\t\t\t    p)))\n-\t\t   /* If the insn can cause a trap (such as divide by zero),\n-\t\t      can't move it unless it's guaranteed to be executed\n-\t\t      once loop is entered.  Even a function call might\n-\t\t      prevent the trap insn from being reached\n-\t\t      (since it might exit!)  */\n-\t\t   && ! ((maybe_never || call_passed)\n-\t\t\t && may_trap_p (src)))\n-\t    {\n-\t      struct movable *m;\n-\t      int regno = REGNO (SET_DEST (set));\n-\n-\t      /* A potential lossage is where we have a case where two insns\n-\t\t can be combined as long as they are both in the loop, but\n-\t\t we move one of them outside the loop.  For large loops,\n-\t\t this can lose.  The most common case of this is the address\n-\t\t of a function being called.\n-\n-\t\t Therefore, if this register is marked as being used exactly\n-\t\t once if we are in a loop with calls (a \"large loop\"), see if\n-\t\t we can replace the usage of this register with the source\n-\t\t of this SET.  If we can, delete this insn.\n-\n-\t\t Don't do this if P has a REG_RETVAL note or if we have\n-\t\t SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n-\n-\t      if (loop_info->has_call\n-\t\t  && regs->array[regno].single_usage != 0\n-\t\t  && regs->array[regno].single_usage != const0_rtx\n-\t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n-\t\t  && (REGNO_LAST_UID (regno)\n-\t\t      == INSN_UID (regs->array[regno].single_usage))\n-\t\t  && regs->array[regno].set_in_loop == 1\n-\t\t  && GET_CODE (SET_SRC (set)) != ASM_OPERANDS\n-\t\t  && ! side_effects_p (SET_SRC (set))\n-\t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n-\t\t  && (! SMALL_REGISTER_CLASSES\n-\t\t      || (! (GET_CODE (SET_SRC (set)) == REG\n-\t\t\t     && REGNO (SET_SRC (set)) < FIRST_PSEUDO_REGISTER)))\n-\t\t  /* This test is not redundant; SET_SRC (set) might be\n-\t\t     a call-clobbered register and the life of REGNO\n-\t\t     might span a call.  */\n-\t\t  && ! modified_between_p (SET_SRC (set), p,\n-\t\t\t\t\t   regs->array[regno].single_usage)\n-\t\t  && no_labels_between_p (p, regs->array[regno].single_usage)\n-\t\t  && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n-\t\t\t\t\t   regs->array[regno].single_usage))\n+\t      /* For parallels, add any possible uses to the depencies, as\n+\t\t we can't move the insn without resolving them first.  */\n+\t      if (GET_CODE (PATTERN (p)) == PARALLEL)\n \t\t{\n-\t\t  /* Replace any usage in a REG_EQUAL note.  Must copy the\n-\t\t     new source, so that we don't get rtx sharing between the\n-\t\t     SET_SOURCE and REG_NOTES of insn p.  */\n-\t\t  REG_NOTES (regs->array[regno].single_usage)\n-\t\t    = replace_rtx (REG_NOTES (regs->array[regno].single_usage),\n-\t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n-\n-\t\t  delete_insn (p);\n-\t\t  for (i = 0; i < (int) LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n-\t\t    regs->array[regno+i].set_in_loop = 0;\n-\t\t  continue;\n+\t\t  for (i = 0; i < XVECLEN (PATTERN (p), 0); i++)\n+\t\t    {\n+\t\t      rtx x = XVECEXP (PATTERN (p), 0, i);\n+\t\t      if (GET_CODE (x) == USE)\n+\t\t\tdependencies\n+\t\t\t  = gen_rtx_EXPR_LIST (VOIDmode, XEXP (x, 0),\n+\t\t\t\t\t       dependencies);\n+\t\t    }\n \t\t}\n \n-\t      m = (struct movable *) xmalloc (sizeof (struct movable));\n-\t      m->next = 0;\n-\t      m->insn = p;\n-\t      m->set_src = src;\n-\t      m->dependencies = dependencies;\n-\t      m->set_dest = SET_DEST (set);\n-\t      m->force = 0;\n-\t      m->consec = regs->array[REGNO (SET_DEST (set))].set_in_loop - 1;\n-\t      m->done = 0;\n-\t      m->forces = 0;\n-\t      m->partial = 0;\n-\t      m->move_insn = move_insn;\n-\t      m->move_insn_first = 0;\n-\t      m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n-\t      m->savemode = VOIDmode;\n-\t      m->regno = regno;\n-\t      /* Set M->cond if either loop_invariant_p\n-\t\t or consec_sets_invariant_p returned 2\n-\t\t (only conditionally invariant).  */\n-\t      m->cond = ((tem | tem1 | tem2) > 1);\n-\t      m->global =  LOOP_REG_GLOBAL_P (loop, regno);\n-\t      m->match = 0;\n-\t      m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n-\t      m->savings = regs->array[regno].n_times_set;\n-\t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n-\t\tm->savings += libcall_benefit (p);\n-\t      for (i = 0; i < (int) LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n-\t\tregs->array[regno+i].set_in_loop = move_insn ? -2 : -1;\n-\t      /* Add M to the end of the chain MOVABLES.  */\n-\t      loop_movables_add (movables, m);\n-\n-\t      if (m->consec > 0)\n+\t      /* Don't try to optimize a register that was made\n+\t\t by loop-optimization for an inner loop.\n+\t\t We don't know its life-span, so we can't compute\n+\t\t the benefit.  */\n+\t      if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n+\t\t;\n+\t      else if (/* The register is used in basic blocks other\n+\t\t\t  than the one where it is set (meaning that\n+\t\t\t  something after this point in the loop might\n+\t\t\t  depend on its value before the set).  */\n+\t\t       ! reg_in_basic_block_p (p, SET_DEST (set))\n+\t\t       /* And the set is not guaranteed to be executed once\n+\t\t\t  the loop starts, or the value before the set is\n+\t\t\t  needed before the set occurs...\n+\n+\t\t\t  ??? Note we have quadratic behaviour here, mitigated\n+\t\t\t  by the fact that the previous test will often fail for\n+\t\t\t  large loops.  Rather than re-scanning the entire loop\n+\t\t\t  each time for register usage, we should build tables\n+\t\t\t  of the register usage and use them here instead.  */\n+\t\t       && (maybe_never\n+\t\t\t   || loop_reg_used_before_p (loop, set, p)))\n+\t\t/* It is unsafe to move the set.\n+\n+\t\t   This code used to consider it OK to move a set of a variable\n+\t\t   which was not created by the user and not used in an exit\n+\t\t   test.\n+\t\t   That behavior is incorrect and was removed.  */\n+\t\t;\n+\t      else if ((tem = loop_invariant_p (loop, src))\n+\t\t       && (dependencies == 0\n+\t\t\t   || (tem2\n+\t\t\t       = loop_invariant_p (loop, dependencies)) != 0)\n+\t\t       && (regs->array[REGNO (SET_DEST (set))].set_in_loop == 1\n+\t\t\t   || (tem1\n+\t\t\t       = consec_sets_invariant_p\n+\t\t\t       (loop, SET_DEST (set),\n+\t\t\t\tregs->array[REGNO (SET_DEST (set))].set_in_loop,\n+\t\t\t\tp)))\n+\t\t       /* If the insn can cause a trap (such as divide by zero),\n+\t\t\t  can't move it unless it's guaranteed to be executed\n+\t\t\t  once loop is entered.  Even a function call might\n+\t\t\t  prevent the trap insn from being reached\n+\t\t\t  (since it might exit!)  */\n+\t\t       && ! ((maybe_never || call_passed)\n+\t\t\t     && may_trap_p (src)))\n \t\t{\n-\t\t  /* It is possible for the first instruction to have a\n-\t\t     REG_EQUAL note but a non-invariant SET_SRC, so we must\n-\t\t     remember the status of the first instruction in case\n-\t\t     the last instruction doesn't have a REG_EQUAL note.  */\n-\t\t  m->move_insn_first = m->move_insn;\n-\n-\t\t  /* Skip this insn, not checking REG_LIBCALL notes.  */\n-\t\t  p = next_nonnote_insn (p);\n-\t\t  /* Skip the consecutive insns, if there are any.  */\n-\t\t  p = skip_consec_insns (p, m->consec);\n-\t\t  /* Back up to the last insn of the consecutive group.  */\n-\t\t  p = prev_nonnote_insn (p);\n-\n-\t\t  /* We must now reset m->move_insn, m->is_equiv, and possibly\n-\t\t     m->set_src to correspond to the effects of all the\n-\t\t     insns.  */\n-\t\t  temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n-\t\t  if (temp)\n-\t\t    m->set_src = XEXP (temp, 0), m->move_insn = 1;\n-\t\t  else\n+\t\t  struct movable *m;\n+\t\t  int regno = REGNO (SET_DEST (set));\n+\n+\t\t  /* A potential lossage is where we have a case where two insns\n+\t\t     can be combined as long as they are both in the loop, but\n+\t\t     we move one of them outside the loop.  For large loops,\n+\t\t     this can lose.  The most common case of this is the address\n+\t\t     of a function being called.\n+\n+\t\t     Therefore, if this register is marked as being used\n+\t\t     exactly once if we are in a loop with calls\n+\t\t     (a \"large loop\"), see if we can replace the usage of\n+\t\t     this register with the source of this SET.  If we can,\n+\t\t     delete this insn.\n+\n+\t\t     Don't do this if P has a REG_RETVAL note or if we have\n+\t\t     SMALL_REGISTER_CLASSES and SET_SRC is a hard register.  */\n+\n+\t\t  if (loop_info->has_call\n+\t\t      && regs->array[regno].single_usage != 0\n+\t\t      && regs->array[regno].single_usage != const0_rtx\n+\t\t      && REGNO_FIRST_UID (regno) == INSN_UID (p)\n+\t\t      && (REGNO_LAST_UID (regno)\n+\t\t\t  == INSN_UID (regs->array[regno].single_usage))\n+\t\t      && regs->array[regno].set_in_loop == 1\n+\t\t      && GET_CODE (SET_SRC (set)) != ASM_OPERANDS\n+\t\t      && ! side_effects_p (SET_SRC (set))\n+\t\t      && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n+\t\t      && (! SMALL_REGISTER_CLASSES\n+\t\t\t  || (! (GET_CODE (SET_SRC (set)) == REG\n+\t\t\t\t && (REGNO (SET_SRC (set))\n+\t\t\t\t     < FIRST_PSEUDO_REGISTER))))\n+\t\t      /* This test is not redundant; SET_SRC (set) might be\n+\t\t\t a call-clobbered register and the life of REGNO\n+\t\t\t might span a call.  */\n+\t\t      && ! modified_between_p (SET_SRC (set), p,\n+\t\t\t\t\t       regs->array[regno].single_usage)\n+\t\t      && no_labels_between_p (p,\n+\t\t\t\t\t      regs->array[regno].single_usage)\n+\t\t      && validate_replace_rtx (SET_DEST (set), SET_SRC (set),\n+\t\t\t\t\t       regs->array[regno].single_usage))\n \t\t    {\n-\t\t      temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n-\t\t      if (temp && CONSTANT_P (XEXP (temp, 0)))\n-\t\t\tm->set_src = XEXP (temp, 0), m->move_insn = 1;\n-\t\t      else\n-\t\t\tm->move_insn = 0;\n+\t\t      /* Replace any usage in a REG_EQUAL note.  Must copy\n+\t\t\t the new source, so that we don't get rtx sharing\n+\t\t\t between the SET_SOURCE and REG_NOTES of insn p.  */\n+\t\t      REG_NOTES (regs->array[regno].single_usage)\n+\t\t\t= (replace_rtx\n+\t\t\t   (REG_NOTES (regs->array[regno].single_usage),\n+\t\t\t    SET_DEST (set), copy_rtx (SET_SRC (set))));\n \n+\t\t      delete_insn (p);\n+\t\t      for (i = 0; i < LOOP_REGNO_NREGS (regno, SET_DEST (set));\n+\t\t\t   i++)\n+\t\t\tregs->array[regno+i].set_in_loop = 0;\n+\t\t      continue;\n \t\t    }\n-\t\t  m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n-\t\t}\n-\t    }\n-\t  /* If this register is always set within a STRICT_LOW_PART\n-\t     or set to zero, then its high bytes are constant.\n-\t     So clear them outside the loop and within the loop\n-\t     just load the low bytes.\n-\t     We must check that the machine has an instruction to do so.\n-\t     Also, if the value loaded into the register\n-\t     depends on the same register, this cannot be done.  */\n-\t  else if (SET_SRC (set) == const0_rtx\n-\t\t   && GET_CODE (NEXT_INSN (p)) == INSN\n-\t\t   && (set1 = single_set (NEXT_INSN (p)))\n-\t\t   && GET_CODE (set1) == SET\n-\t\t   && (GET_CODE (SET_DEST (set1)) == STRICT_LOW_PART)\n-\t\t   && (GET_CODE (XEXP (SET_DEST (set1), 0)) == SUBREG)\n-\t\t   && (SUBREG_REG (XEXP (SET_DEST (set1), 0))\n-\t\t       == SET_DEST (set))\n-\t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n-\t    {\n-\t      int regno = REGNO (SET_DEST (set));\n-\t      if (regs->array[regno].set_in_loop == 2)\n-\t\t{\n-\t\t  struct movable *m;\n+\n \t\t  m = (struct movable *) xmalloc (sizeof (struct movable));\n \t\t  m->next = 0;\n \t\t  m->insn = p;\n+\t\t  m->set_src = src;\n+\t\t  m->dependencies = dependencies;\n \t\t  m->set_dest = SET_DEST (set);\n-\t\t  m->dependencies = 0;\n \t\t  m->force = 0;\n-\t\t  m->consec = 0;\n+\t\t  m->consec\n+\t\t    = regs->array[REGNO (SET_DEST (set))].set_in_loop - 1;\n \t\t  m->done = 0;\n \t\t  m->forces = 0;\n-\t\t  m->move_insn = 0;\n+\t\t  m->partial = 0;\n+\t\t  m->move_insn = move_insn;\n \t\t  m->move_insn_first = 0;\n-\t\t  m->partial = 1;\n-\t\t  /* If the insn may not be executed on some cycles,\n-\t\t     we can't clear the whole reg; clear just high part.\n-\t\t     Not even if the reg is used only within this loop.\n-\t\t     Consider this:\n-\t\t     while (1)\n-\t\t       while (s != t) {\n-\t\t         if (foo ()) x = *s;\n-\t\t\t use (x);\n-\t\t       }\n-\t\t     Clearing x before the inner loop could clobber a value\n-\t\t     being saved from the last time around the outer loop.\n-\t\t     However, if the reg is not used outside this loop\n-\t\t     and all uses of the register are in the same\n-\t\t     basic block as the store, there is no problem.\n-\n-\t\t     If this insn was made by loop, we don't know its\n-\t\t     INSN_LUID and hence must make a conservative\n-\t\t     assumption.  */\n-\t\t  m->global = (INSN_UID (p) >= max_uid_for_loop\n-\t\t\t       || LOOP_REG_GLOBAL_P (loop, regno)\n-\t\t\t       || (labels_in_range_p\n-\t\t\t\t   (p, REGNO_FIRST_LUID (regno))));\n-\t\t  if (maybe_never && m->global)\n-\t\t    m->savemode = GET_MODE (SET_SRC (set1));\n-\t\t  else\n-\t\t    m->savemode = VOIDmode;\n+\t\t  m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n+\t\t  m->savemode = VOIDmode;\n \t\t  m->regno = regno;\n-\t\t  m->cond = 0;\n+\t\t  /* Set M->cond if either loop_invariant_p\n+\t\t     or consec_sets_invariant_p returned 2\n+\t\t     (only conditionally invariant).  */\n+\t\t  m->cond = ((tem | tem1 | tem2) > 1);\n+\t\t  m->global =  LOOP_REG_GLOBAL_P (loop, regno);\n \t\t  m->match = 0;\n \t\t  m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n-\t\t  m->savings = 1;\n+\t\t  m->savings = regs->array[regno].n_times_set;\n+\t\t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n+\t\t    m->savings += libcall_benefit (p);\n \t\t  for (i = 0; i < (int) LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n-\t\t    regs->array[regno+i].set_in_loop = -1;\n+\t\t    regs->array[regno+i].set_in_loop = move_insn ? -2 : -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  loop_movables_add (movables, m);\n+\n+\t\t  if (m->consec > 0)\n+\t\t    {\n+\t\t      /* It is possible for the first instruction to have a\n+\t\t\t REG_EQUAL note but a non-invariant SET_SRC, so we must\n+\t\t\t remember the status of the first instruction in case\n+\t\t\t the last instruction doesn't have a REG_EQUAL note.  */\n+\t\t      m->move_insn_first = m->move_insn;\n+\n+\t\t      /* Skip this insn, not checking REG_LIBCALL notes.  */\n+\t\t      p = next_nonnote_insn (p);\n+\t\t      /* Skip the consecutive insns, if there are any.  */\n+\t\t      p = skip_consec_insns (p, m->consec);\n+\t\t      /* Back up to the last insn of the consecutive group.  */\n+\t\t      p = prev_nonnote_insn (p);\n+\n+\t\t      /* We must now reset m->move_insn, m->is_equiv, and\n+\t\t\t possibly m->set_src to correspond to the effects of\n+\t\t\t all the insns.  */\n+\t\t      temp = find_reg_note (p, REG_EQUIV, NULL_RTX);\n+\t\t      if (temp)\n+\t\t\tm->set_src = XEXP (temp, 0), m->move_insn = 1;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  temp = find_reg_note (p, REG_EQUAL, NULL_RTX);\n+\t\t\t  if (temp && CONSTANT_P (XEXP (temp, 0)))\n+\t\t\t    m->set_src = XEXP (temp, 0), m->move_insn = 1;\n+\t\t\t  else\n+\t\t\t    m->move_insn = 0;\n+\n+\t\t\t}\n+\t\t      m->is_equiv\n+\t\t\t= (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n+\t\t    }\n+\t\t}\n+\t      /* If this register is always set within a STRICT_LOW_PART\n+\t\t or set to zero, then its high bytes are constant.\n+\t\t So clear them outside the loop and within the loop\n+\t\t just load the low bytes.\n+\t\t We must check that the machine has an instruction to do so.\n+\t\t Also, if the value loaded into the register\n+\t\t depends on the same register, this cannot be done.  */\n+\t      else if (SET_SRC (set) == const0_rtx\n+\t\t       && GET_CODE (NEXT_INSN (p)) == INSN\n+\t\t       && (set1 = single_set (NEXT_INSN (p)))\n+\t\t       && GET_CODE (set1) == SET\n+\t\t       && (GET_CODE (SET_DEST (set1)) == STRICT_LOW_PART)\n+\t\t       && (GET_CODE (XEXP (SET_DEST (set1), 0)) == SUBREG)\n+\t\t       && (SUBREG_REG (XEXP (SET_DEST (set1), 0))\n+\t\t\t   == SET_DEST (set))\n+\t\t       && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n+\t\t{\n+\t\t  int regno = REGNO (SET_DEST (set));\n+\t\t  if (regs->array[regno].set_in_loop == 2)\n+\t\t    {\n+\t\t      struct movable *m;\n+\t\t      m = (struct movable *) xmalloc (sizeof (struct movable));\n+\t\t      m->next = 0;\n+\t\t      m->insn = p;\n+\t\t      m->set_dest = SET_DEST (set);\n+\t\t      m->dependencies = 0;\n+\t\t      m->force = 0;\n+\t\t      m->consec = 0;\n+\t\t      m->done = 0;\n+\t\t      m->forces = 0;\n+\t\t      m->move_insn = 0;\n+\t\t      m->move_insn_first = 0;\n+\t\t      m->partial = 1;\n+\t\t      /* If the insn may not be executed on some cycles,\n+\t\t\t we can't clear the whole reg; clear just high part.\n+\t\t\t Not even if the reg is used only within this loop.\n+\t\t\t Consider this:\n+\t\t\t while (1)\n+\t\t\t   while (s != t) {\n+\t\t\t     if (foo ()) x = *s;\n+\t\t\t     use (x);\n+\t\t\t   }\n+\t\t\t Clearing x before the inner loop could clobber a value\n+\t\t\t being saved from the last time around the outer loop.\n+\t\t\t However, if the reg is not used outside this loop\n+\t\t\t and all uses of the register are in the same\n+\t\t\t basic block as the store, there is no problem.\n+\n+\t\t\t If this insn was made by loop, we don't know its\n+\t\t\t INSN_LUID and hence must make a conservative\n+\t\t\t assumption.  */\n+\t\t      m->global = (INSN_UID (p) >= max_uid_for_loop\n+\t\t\t\t   || LOOP_REG_GLOBAL_P (loop, regno)\n+\t\t\t\t   || (labels_in_range_p\n+\t\t\t\t       (p, REGNO_FIRST_LUID (regno))));\n+\t\t      if (maybe_never && m->global)\n+\t\t\tm->savemode = GET_MODE (SET_SRC (set1));\n+\t\t      else\n+\t\t\tm->savemode = VOIDmode;\n+\t\t      m->regno = regno;\n+\t\t      m->cond = 0;\n+\t\t      m->match = 0;\n+\t\t      m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n+\t\t      m->savings = 1;\n+\t\t      for (i = 0;\n+\t\t\t   i < (int) LOOP_REGNO_NREGS (regno, SET_DEST (set));\n+\t\t\t   i++)\n+\t\t\tregs->array[regno+i].set_in_loop = -1;\n+\t\t      /* Add M to the end of the chain MOVABLES.  */\n+\t\t      loop_movables_add (movables, m);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -1905,10 +1928,10 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t  for (count = m->consec; count >= 0; count--)\n \t\t    {\n \t\t      /* If this is the first insn of a library call sequence,\n-\t\t\t skip to the end.  */\n+\t\t\t something is very wrong.  */\n \t\t      if (GET_CODE (p) != NOTE\n \t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n-\t\t\tp = XEXP (temp, 0);\n+\t\t\tabort ();\n \n \t\t      /* If this is the last insn of a libcall sequence, then\n \t\t\t delete every insn in the sequence except the last."}, {"sha": "82c56ca6094e1ec211f94f1b4628c566b9bd8684", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "patch": "@@ -1,3 +1,7 @@\n+Thu Sep  5 00:34:33 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* gcc.c-torture/execute/loop-14.c: New test.\n+\n 2002-09-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/other/cxa-atexit1.C: New test."}, {"sha": "8c9929276bc57ced227a710e2922dcf6a74ca9c1", "filename": "gcc/testsuite/gcc.c-torture/execute/loop-14.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Floop-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Floop-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Floop-14.c?ref=ed6cc1f5cb3b6cc316f2f67583b62b92a5de4e4b", "patch": "@@ -0,0 +1,20 @@\n+int a3[3];\n+\n+void f(int *a)\n+{\n+  int i;\n+\n+  for (i=3; --i;)\n+    a[i] = 42 / i;\n+}\n+\n+int\n+main ()\n+{\n+  f(a3);\n+\n+  if (a3[1] != 42 || a3[2] != 21)\n+    abort ();\n+\n+  exit (0);\n+}"}]}