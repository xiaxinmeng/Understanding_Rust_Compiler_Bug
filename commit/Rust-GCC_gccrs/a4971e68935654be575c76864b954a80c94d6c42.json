{"sha": "a4971e68935654be575c76864b954a80c94d6c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ5NzFlNjg5MzU2NTRiZTU3NWM3Njg2NGI5NTRhODBjOTRkNmM0Mg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-03-28T15:27:58Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-03-28T15:27:58Z"}, "message": "re PR target/60675 ([aarch64] internal compiler error: Max. number of generated reload insns per insn is achieved (90))\n\n2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/60675\n\t* lra-assigns.c (find_hard_regno_for): Remove unavailable hard\n\tregs from checking multi-reg pseudos.\n\n2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/60675\n\t* gcc.target/aarch64/pr60675.C: New.\n\nFrom-SVN: r208900", "tree": {"sha": "204028c15c937ba36953d0e2a4dd188e33c2a946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/204028c15c937ba36953d0e2a4dd188e33c2a946"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4971e68935654be575c76864b954a80c94d6c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4971e68935654be575c76864b954a80c94d6c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4971e68935654be575c76864b954a80c94d6c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4971e68935654be575c76864b954a80c94d6c42/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2486c24a8c2b1b603899e99c7424784de976f8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2486c24a8c2b1b603899e99c7424784de976f8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2486c24a8c2b1b603899e99c7424784de976f8d2"}], "stats": {"total": 296, "additions": 293, "deletions": 3}, "files": [{"sha": "c619f8e6dcec62e86e17259af785d469ab6c2d62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4971e68935654be575c76864b954a80c94d6c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4971e68935654be575c76864b954a80c94d6c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4971e68935654be575c76864b954a80c94d6c42", "patch": "@@ -1,3 +1,9 @@\n+2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/60675\n+\t* lra-assigns.c (find_hard_regno_for): Remove unavailable hard\n+\tregs from checking multi-reg pseudos.\n+\n 2014-03-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/arm/t-aprofile (MULTILIB_MATCHES): Correct A12 rule."}, {"sha": "f7bb86b2160adc8173a4733f272f779bdffa7d6c", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=a4971e68935654be575c76864b954a80c94d6c42", "patch": "@@ -473,7 +473,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno,\n   enum reg_class rclass;\n   bitmap_iterator bi;\n   bool *rclass_intersect_p;\n-  HARD_REG_SET impossible_start_hard_regs;\n+  HARD_REG_SET impossible_start_hard_regs, available_regs;\n \n   COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);\n   rclass = regno_allocno_class_array[regno];\n@@ -586,6 +586,8 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno,\n   biggest_nregs = hard_regno_nregs[hard_regno][biggest_mode];\n   nregs_diff = (biggest_nregs\n \t\t- hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (regno)]);\n+  COPY_HARD_REG_SET (available_regs, reg_class_contents[rclass]);\n+  AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);\n   for (i = 0; i < rclass_size; i++)\n     {\n       if (try_only_hard_regno >= 0)\n@@ -601,9 +603,9 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno,\n \t  && (nregs_diff == 0\n \t      || (WORDS_BIG_ENDIAN\n \t\t  ? (hard_regno - nregs_diff >= 0\n-\t\t     && TEST_HARD_REG_BIT (reg_class_contents[rclass],\n+\t\t     && TEST_HARD_REG_BIT (available_regs,\n \t\t\t\t\t   hard_regno - nregs_diff))\n-\t\t  : TEST_HARD_REG_BIT (reg_class_contents[rclass],\n+\t\t  : TEST_HARD_REG_BIT (available_regs,\n \t\t\t\t       hard_regno + nregs_diff))))\n \t{\n \t  if (hard_regno_costs_check[hard_regno]"}, {"sha": "e5ae8565b32b1938da2b8e41baea75d3a5bfebbf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4971e68935654be575c76864b954a80c94d6c42", "patch": "@@ -1,3 +1,8 @@\n+2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/60675\n+\t* gcc.target/aarch64/pr60675.C: New.\n+\n 2014-03-28  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* gcc.dg/tree-ssa/ssa-dom-thread-4.c: Remove s390 special"}, {"sha": "aa88cdb240358629d2be575297c2acc957364f23", "filename": "gcc/testsuite/gcc.target/aarch64/pr60675.C", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60675.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4971e68935654be575c76864b954a80c94d6c42/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60675.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60675.C?ref=a4971e68935654be575c76864b954a80c94d6c42", "patch": "@@ -0,0 +1,277 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c++11 -w -O2 -fPIC\" } */\n+namespace CLHEP {\n+      static const double meter = 1000.*10;\n+      static const double meter2 = meter*meter;\n+      static const double megaelectronvolt = 1. ;\n+      static const double gigaelectronvolt = 1.e+3;\n+      static const double GeV = gigaelectronvolt;\n+      static const double megavolt = megaelectronvolt;\n+      static const double volt = 1.e-6*megavolt;\n+      static const double tesla = volt*1.e+9/meter2;\n+    }\n+       using CLHEP::GeV;\n+       using CLHEP::tesla;\n+       namespace std {\n+      typedef long int ptrdiff_t;\n+    }\n+       extern \"C\" {\n+    extern double cos (double __x) throw ();\n+    extern double sin (double __x) throw ();\n+    extern double sqrt (double __x) throw ();\n+    }\n+       namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+      using ::cos;\n+      using ::sin;\n+      using ::sqrt;\n+      template<class _CharT>     struct char_traits;\n+      template<typename _CharT, typename _Traits = char_traits<_CharT> >     struct basic_ostream;\n+      typedef basic_ostream<char> ostream;\n+      template<typename _Iterator>     struct iterator_traits     {      };\n+      template<typename _Tp>     struct iterator_traits<_Tp*>     {\n+        typedef ptrdiff_t difference_type;\n+        typedef _Tp& reference;\n+      };\n+    }\n+       namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+      using std::iterator_traits;\n+      template<typename _Iterator, typename _Container>     struct __normal_iterator     {\n+    _Iterator _M_current;\n+        typedef iterator_traits<_Iterator> __traits_type;\n+        typedef typename __traits_type::difference_type difference_type;\n+        typedef typename __traits_type::reference reference;\n+        explicit       __normal_iterator(const _Iterator& __i)       : _M_current(__i) {  }\n+        reference       operator*() const       {\n+  return *_M_current;\n+  }\n+        __normal_iterator       operator+(difference_type __n) const       {\n+  return __normal_iterator(_M_current + __n);\n+  }\n+      };\n+      template<typename _Tp>     struct new_allocator     {\n+      };\n+    }\n+       namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+      template<typename _Tp>     struct allocator: public __gnu_cxx::new_allocator<_Tp>     {\n+    };\n+      struct ios_base   {      };\n+      template<typename _CharT, typename _Traits>     struct basic_ios : public ios_base     {      };\n+      template<typename _CharT, typename _Traits>     struct basic_ostream : virtual public basic_ios<_CharT, _Traits>     {\n+        typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+        __ostream_type&       operator<<(__ostream_type& (*__pf)(__ostream_type&))       {  }\n+        __ostream_type&       operator<<(const void* __p)       {\n+  return _M_insert(__p);\n+  }\n+        template<typename _ValueT>  __ostream_type&  _M_insert(_ValueT __v);\n+      };\n+      template<typename _CharT, typename _Traits>     inline basic_ostream<_CharT, _Traits>&     endl(basic_ostream<_CharT, _Traits>& __os)     {\n+  }\n+    }\n+       typedef double G4double;\n+       typedef int G4int;\n+         extern __thread std::ostream *G4cout_p;\n+       struct G4Field;\n+       struct G4FieldManager {\n+         inline  G4Field* GetDetectorField() ;\n+    };\n+       namespace CLHEP {\n+    struct Hep3Vector {\n+    Hep3Vector(double x, double y, double z);\n+    inline ~Hep3Vector();\n+    inline double x() const;\n+    inline double y() const;\n+    inline double z() const;\n+    inline double mag() const;\n+    inline Hep3Vector cross(const Hep3Vector &) const;\n+  double dx;\n+    double dy;\n+    double dz;\n+  };\n+    Hep3Vector operator / (const Hep3Vector &, double a);\n+    inline double Hep3Vector::x() const {\n+  return dx;\n+  }\n+    inline double Hep3Vector::y() const {\n+  return dy;\n+  }\n+    inline double Hep3Vector::z() const {\n+  return dz;\n+  }\n+    inline Hep3Vector operator + (const Hep3Vector & a, const Hep3Vector & b) {  }\n+    inline Hep3Vector operator * (const Hep3Vector & p, double a) {  }\n+    inline double operator * (const Hep3Vector & a, const Hep3Vector & b) {  }\n+    inline Hep3Vector::Hep3Vector(double x1, double y1, double z1)   : dx(x1), dy(y1), dz(z1) {\n+ }\n+    inline Hep3Vector::~Hep3Vector() {  }\n+    inline Hep3Vector Hep3Vector::cross(const Hep3Vector & p) const {\n+    return Hep3Vector(dy*p.dz-p.dy*dz, dz*p.dx-p.dz*dx, dx*p.dy-p.dx*dy);\n+  }\n+    }\n+       typedef CLHEP::Hep3Vector G4ThreeVector;\n+       namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+      template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     struct vector\n+  {\n+        typedef _Tp *pointer;\n+        typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;\n+        iterator       begin()       {   }\n+      };\n+    }\n+       struct G4TransportationManager {\n+ static G4TransportationManager* GetTransportationManager();\n+         inline G4FieldManager* GetFieldManager() const;\n+    };\n+       struct G4ErrorMatrix {\n+       G4ErrorMatrix(G4int p, G4int q, G4int i);\n+       virtual ~G4ErrorMatrix();\n+       struct G4ErrorMatrix_row    {\n+    inline G4ErrorMatrix_row(G4ErrorMatrix&,G4int);\n+         G4double & operator[](G4int);\n+     G4ErrorMatrix& _a;\n+         G4int _r;\n+     };\n+       inline G4ErrorMatrix_row operator[] (G4int);\n+       std::vector<G4double > m;\n+       G4int nrow, ncol;\n+    };\n+       inline G4ErrorMatrix::G4ErrorMatrix_row G4ErrorMatrix::operator[] (G4int r) {\n+      G4ErrorMatrix_row b(*this,r);\n+      return b;\n+    }\n+       inline G4double &G4ErrorMatrix::G4ErrorMatrix_row::operator[](G4int c) {\n+      return *(_a.m.begin()+_r*_a.ncol+c);\n+    }\n+       inline G4ErrorMatrix:: G4ErrorMatrix_row::G4ErrorMatrix_row(G4ErrorMatrix&a, G4int r)    : _a(a) {\n+      _r = r;\n+    };\n+       struct G4DynamicParticle {\n+         G4double GetCharge() const;\n+    };\n+       struct G4Step;\n+       struct G4Track {\n+       const G4DynamicParticle* GetDynamicParticle() const;\n+       const G4ThreeVector& GetPosition() const;\n+       G4ThreeVector GetMomentum() const;\n+       const G4Step* GetStep() const;\n+    };\n+       struct G4StepPoint {\n+  const G4ThreeVector& GetPosition() const;\n+       G4ThreeVector GetMomentum() const;\n+    };\n+       struct G4Step {\n+       G4StepPoint* GetPreStepPoint() const;\n+       G4double GetStepLength() const;\n+    };\n+       namespace HepGeom {\n+      template<class T> struct BasicVector3D {\n+     T v_[3];\n+      BasicVector3D(T x1, T y1, T z1) {      }\n+      operator T * () {\n+  return v_;\n+  }\n+      T x() const {\n+  return v_[0];\n+  }\n+      T y() const {\n+  return v_[1];\n+  }\n+      T z() const {\n+  return v_[2];\n+  }\n+      T perp2() const {  }\n+      T perp() const {\n+  return std::sqrt(perp2());\n+      }\n+      T mag2() const {  }\n+      T mag() const {\n+  return std::sqrt(mag2());\n+  }\n+      T theta() const {      }\n+    };\n+      inline BasicVector3D<double>   operator-(const BasicVector3D<double> & a,const BasicVector3D<double> & b) {    }\n+      inline BasicVector3D<double>   operator*(const BasicVector3D<double> & v, double a) {    }\n+      template<class T>   struct Point3D : public BasicVector3D<T> {\n+      explicit Point3D(const double * a)       : BasicVector3D<double>(a[0],a[1],a[2]) { }\n+      Point3D(const CLHEP::Hep3Vector & v)       : BasicVector3D<double>(v.dx,v.dy,v.dz) {      }\n+    };\n+    }\n+       typedef HepGeom::Point3D<G4double> G4Point3D;\n+       namespace HepGeom {\n+      template<class T>   struct Vector3D : public BasicVector3D<T> {\n+      Vector3D(const BasicVector3D<double> & v) : BasicVector3D<double>(v) { }\n+      Vector3D(const CLHEP::Hep3Vector & v)       : BasicVector3D<double>(v.dx,v.dy,v.dz) { }\n+      operator CLHEP::Hep3Vector () const {      }\n+    };\n+    }\n+       typedef HepGeom::Vector3D<G4double> G4Vector3D;\n+       struct G4ErrorFreeTrajState \n+{\n+      virtual G4int PropagateError( const G4Track* aTrack );\n+      G4int PropagateErrorMSC( const G4Track* aTrack );\n+    };\n+       G4int G4ErrorFreeTrajState::PropagateError( const G4Track* aTrack ) {\n+      G4double stepLengthCm = aTrack->GetStep()->GetStepLength()/10.;\n+      G4Point3D vposPost = aTrack->GetPosition()/10.;\n+      G4Vector3D vpPost = aTrack->GetMomentum()/GeV;\n+      G4Point3D vposPre = aTrack->GetStep()->GetPreStepPoint()->GetPosition()/10.;\n+      G4Vector3D vpPre = aTrack->GetStep()->GetPreStepPoint()->GetMomentum()/GeV;\n+      G4double pPre = vpPre.mag();\n+      G4double pPost = vpPost.mag();\n+      G4double pInvPre = 1./pPre;\n+      G4double pInvPost = 1./pPost;\n+      G4double deltaPInv = pInvPost - pInvPre;\n+      G4Vector3D vpPreNorm = vpPre * pInvPre;\n+      G4Vector3D vpPostNorm = vpPost * pInvPost;\n+ (*G4cout_p) << \"G4EP: vpPreNorm \" << vpPreNorm << \" vpPostNorm \" << vpPostNorm << std::endl;\n+      G4double sinpPre = std::sin( vpPreNorm.theta() );\n+      G4double sinpPostInv = 1./std::sin( vpPreNorm.theta() );\n+      G4ErrorMatrix transf(5, 5, 0 );\n+      G4double charge = aTrack->GetDynamicParticle()->GetCharge();\n+      G4double h1[3], h2[3];\n+ G4Field* field \n+= G4TransportationManager::GetTransportationManager()->GetFieldManager()->GetDetectorField()\n+;\n+      if( charge != 0. && field )\n+ {\n+      G4ThreeVector HPre = G4ThreeVector( h1[0], h1[1], h1[2] ) / tesla *10.;\n+      G4ThreeVector HPost= G4ThreeVector( h2[0], h2[1], h2[2] ) / tesla *10.;\n+ {\n+      G4double pInvAver = 1./(pInvPre + pInvPost );\n+      G4double CFACT8 = 2.997925E-4;\n+      G4ThreeVector vHAverNorm( (HPre*pInvPre + HPost*pInvPost ) * pInvAver * charge * CFACT8 );\n+      G4double HAver = vHAverNorm.mag();\n+      G4double pAver = (pPre+pPost)*0.5;\n+      G4double QAver = -HAver/pAver;\n+      G4double thetaAver = QAver * stepLengthCm;\n+      G4double sinThetaAver = std::sin(thetaAver);\n+      G4double cosThetaAver = std::cos(thetaAver);\n+      G4double gamma = vHAverNorm * vpPostNorm;\n+      G4ThreeVector AN2 = vHAverNorm.cross( vpPostNorm );\n+      G4double AU = 1./vpPreNorm.perp();\n+      G4ThreeVector vUPre( -AU*vpPreNorm.y(),                       AU*vpPreNorm.x(),                       0. );\n+      G4ThreeVector vVPre( -vpPreNorm.z()*vUPre.y(),                       vpPreNorm.z()*vUPre.x(),                       vpPreNorm.x()*vUPre.y() - vpPreNorm.y()*vUPre.x() );\n+      AU = 1./vpPostNorm.perp();\n+      G4ThreeVector vUPost( -AU*vpPostNorm.y(),                        AU*vpPostNorm.x(),                        0. );\n+      G4ThreeVector vVPost( -vpPostNorm.z()*vUPost.y(),                        vpPostNorm.z()*vUPost.x(),                        vpPostNorm.x()*vUPost.y() - vpPostNorm.y()*vUPost.x() );\n+      G4Point3D deltaPos( vposPre - vposPost );\n+      G4double QP = QAver * pAver;\n+      G4double ANV = -( vHAverNorm.x()*vUPost.x() + vHAverNorm.y()*vUPost.y() );\n+      G4double ANU = ( vHAverNorm.x()*vVPost.x() + vHAverNorm.y()*vVPost.y() + vHAverNorm.z()*vVPost.z() );\n+      G4double OMcosThetaAver = 1. - cosThetaAver;\n+      G4double TMSINT = thetaAver - sinThetaAver;\n+      G4ThreeVector vHUPre( -vHAverNorm.z() * vUPre.y(),                           vHAverNorm.z() * vUPre.x(),                           vHAverNorm.x() * vUPre.y() - vHAverNorm.y() * vUPre.x() );\n+      G4ThreeVector vHVPre( vHAverNorm.y() * vVPre.z() - vHAverNorm.z() * vVPre.y(),                           vHAverNorm.z() * vVPre.x() - vHAverNorm.x() * vVPre.z(),                           vHAverNorm.x() * vVPre.y() - vHAverNorm.y() * vVPre.x() );\n+      transf[0][1] = -deltaPInv/thetaAver*       ( TMSINT*gamma*(vHAverNorm.x()*vVPre.x()+vHAverNorm.y()*vVPre.y()+vHAverNorm.z()*vVPre.z()) +         sinThetaAver*(vVPre.x()*vpPostNorm.x()+vVPre.y()*vpPostNorm.y()+vVPre.z()*vpPostNorm.z()) +         OMcosThetaAver*(vHVPre.x()*vpPostNorm.x()+vHVPre.y()*vpPostNorm.y()+vHVPre.z()*vpPostNorm.z()) );\n+      transf[0][2] = -sinpPre*deltaPInv/thetaAver*       ( TMSINT*gamma*(vHAverNorm.x()*vUPre.x()+vHAverNorm.y()*vUPre.y() ) +         sinThetaAver*(vUPre.x()*vpPostNorm.x()+vUPre.y()*vpPostNorm.y() ) +         OMcosThetaAver*(vHUPre.x()*vpPostNorm.x()+vHUPre.y()*vpPostNorm.y()+vHUPre.z()*vpPostNorm.z()) );\n+      transf[0][3] = -deltaPInv/stepLengthCm*(vUPre.x()*vpPostNorm.x()+vUPre.y()*vpPostNorm.y() );\n+      transf[1][1] = cosThetaAver*(vVPre.x()*vVPost.x()+vVPre.y()*vVPost.y()+vVPre.z()*vVPost.z()) +       sinThetaAver*(vHVPre.x()*vVPost.x()+vHVPre.y()*vVPost.y()+vHVPre.z()*vVPost.z()) +       OMcosThetaAver*(vHAverNorm.x()*vVPre.x()+vHAverNorm.y()*vVPre.y()+vHAverNorm.z()*vVPre.z())*       (vHAverNorm.x()*vVPost.x()+vHAverNorm.y()*vVPost.y()+vHAverNorm.z()*vVPost.z()) +       ANV*( -sinThetaAver*(vVPre.x()*vpPostNorm.x()+vVPre.y()*vpPostNorm.y()+vVPre.z()*vpPostNorm.z()) +             OMcosThetaAver*(vVPre.x()*AN2.x()+vVPre.y()*AN2.y()+vVPre.z()*AN2.z()) -             TMSINT*gamma*(vHAverNorm.x()*vVPre.x()+vHAverNorm.y()*vVPre.y()+vHAverNorm.z()*vVPre.z()) );\n+      transf[1][2] = cosThetaAver*(vUPre.x()*vVPost.x()+vUPre.y()*vVPost.y() ) +       sinThetaAver*(vHUPre.x()*vVPost.x()+vHUPre.y()*vVPost.y()+vHUPre.z()*vVPost.z()) +       OMcosThetaAver*(vHAverNorm.x()*vUPre.x()+vHAverNorm.y()*vUPre.y() )*       (vHAverNorm.x()*vVPost.x()+vHAverNorm.y()*vVPost.y()+vHAverNorm.z()*vVPost.z()) +       ANV*( -sinThetaAver*(vUPre.x()*vpPostNorm.x()+vUPre.y()*vpPostNorm.y() ) +             OMcosThetaAver*(vUPre.x()*AN2.x()+vUPre.y()*AN2.y() ) -             TMSINT*gamma*(vHAverNorm.x()*vUPre.x()+vHAverNorm.y()*vUPre.y() ) );\n+      transf[2][0] = -QP*ANU*(vpPostNorm.x()*deltaPos.x()+vpPostNorm.y()*deltaPos.y()+vpPostNorm.z()*deltaPos.z())*sinpPostInv       *(1.+deltaPInv*pAver);\n+      transf[2][3] = -QAver*ANU*(vUPre.x()*vpPostNorm.x()+vUPre.y()*vpPostNorm.y() )*sinpPostInv;\n+      transf[3][4] = (vVPre.x()*vUPost.x()+vVPre.y()*vUPost.y() );\n+      transf[4][0] = pAver*(vVPost.x()*deltaPos.x()+vVPost.y()*deltaPos.y()+vVPost.z()*deltaPos.z())       *(1.+deltaPInv*pAver);\n+      transf[4][1] = ( sinThetaAver*(vVPre.x()*vVPost.x()+vVPre.y()*vVPost.y()+vVPre.z()*vVPost.z()) +                        OMcosThetaAver*(vHVPre.x()*vVPost.x()+vHVPre.y()*vVPost.y()+vHVPre.z()*vVPost.z()) +                        TMSINT*(vHAverNorm.x()*vVPost.x()+vHAverNorm.y()*vVPost.y()+vHAverNorm.z()*vVPost.z())*                        (vHAverNorm.x()*vVPre.x()+vHAverNorm.y()*vVPre.y()+vHAverNorm.z()*vVPre.z()) )/QAver;\n+      transf[4][2] = ( sinThetaAver*(vUPre.x()*vVPost.x()+vUPre.y()*vVPost.y() ) +                        OMcosThetaAver*(vHUPre.x()*vVPost.x()+vHUPre.y()*vVPost.y()+vHUPre.z()*vVPost.z()) +                        TMSINT*(vHAverNorm.x()*vVPost.x()+vHAverNorm.y()*vVPost.y()+vHAverNorm.z()*vVPost.z())*                        (vHAverNorm.x()*vUPre.x()+vHAverNorm.y()*vUPre.y() ) )*sinpPre/QAver;\n+     }\n+    }\n+       PropagateErrorMSC( aTrack );\n+    }"}]}