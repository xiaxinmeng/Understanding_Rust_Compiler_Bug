{"sha": "a9098fd024e128b97dc4cbf338a10eb6056f487e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkwOThmZDAyNGUxMjhiOTdkYzRjYmYzMzhhMTBlYjYwNTZmNDg3ZQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-07-21T00:46:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-07-21T00:46:23Z"}, "message": "rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): All constants of size no larger than a pointer should go in the TOC.\n\n* config/rs6000/rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): All\nconstants of size no larger than a pointer should go in the TOC.\nAdd 'MODE' parameter.\n(LEGITIMIZE_RELOAD_ADDRESS): Add MODE parameter to\nASM_OUTPUT_SPECIAL_POOL_ENTRY_P.\n(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Likewise.\n* config/rs6000/aix.h (SELECT_RTX_SECTION): Likewise.\n* config/rs6000/netware.h (SELECT_RTX_SECTION): Likewise.\n* config/rs6000/rs6000.c (constant_pool_expr_1): Likewise.\n(rs6000_legitimize_address): Likewise.\n(rs6000_emit_move): Likewise.\n(rs6000_select_rtx_section): Likewise.\n(output_toc): Deal properly with outputting small constants like\nHImode, and SFmode in 32-bit mode, and DFmode in 64-bit mode.\n* config/rs6000/sysv4.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Add\nMODE parameter.  Put small constants in the TOC.\n\n* config/rs6000/rs6000.c (easy_fp_constant_p): All constants are\neasy in SImode.\n(rs6000_emit_move): When reload calls us with an illegitimate\naddress, exit early.  Move the change_address calls to one place\nat the end of the routine.  Merge the SImode and DImode expanders.\nWhen called by reload to put an integer into a FP register, force\nit to memory.\n\n* config/rs6000/rs6000.c (struct toc_hash_struct): Add 'key_mode'\nfield.\n(rs6000_hash_constant): Hash mode too.\n(toc_hash_function): Allow for key_mode.\n(toc_hash_eq): Structures are different if key_mode differs.\n(output_toc): Add 'mode' parameter.  Save key_mode.\n* config/rs6000/rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY):\nPass 'mode' parameter.\n* config/rs6000/rs6000-protos.h (output_toc): Add 'mode' param.\n\nFrom-SVN: r35164", "tree": {"sha": "c609543e2d3c0d4795d304373e863e0e265ff0ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c609543e2d3c0d4795d304373e863e0e265ff0ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9098fd024e128b97dc4cbf338a10eb6056f487e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9098fd024e128b97dc4cbf338a10eb6056f487e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9098fd024e128b97dc4cbf338a10eb6056f487e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9098fd024e128b97dc4cbf338a10eb6056f487e/comments", "author": null, "committer": null, "parents": [{"sha": "89c01f0e759a74a8e2917733b1328c2a29f98a7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c01f0e759a74a8e2917733b1328c2a29f98a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c01f0e759a74a8e2917733b1328c2a29f98a7d"}], "stats": {"total": 434, "additions": 232, "deletions": 202}, "files": [{"sha": "9f16d764d532bdb5ae73311fae62bc743fef7cad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -1,5 +1,40 @@\n 2000-07-20  Geoff Keating  <geoffk@cygnus.com>\n \n+\t* config/rs6000/rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): All\n+\tconstants of size no larger than a pointer should go in the TOC.\n+\tAdd 'MODE' parameter.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Add MODE parameter to\n+\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P.\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY): Likewise.\n+\t* config/rs6000/aix.h (SELECT_RTX_SECTION): Likewise.\n+\t* config/rs6000/netware.h (SELECT_RTX_SECTION): Likewise.\n+\t* config/rs6000/rs6000.c (constant_pool_expr_1): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(rs6000_select_rtx_section): Likewise.\n+\t(output_toc): Deal properly with outputting small constants like\n+\tHImode, and SFmode in 32-bit mode, and DFmode in 64-bit mode.\n+\t* config/rs6000/sysv4.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P): Add\n+\tMODE parameter.  Put small constants in the TOC.\n+\t\n+\t* config/rs6000/rs6000.c (easy_fp_constant_p): All constants are\n+\teasy in SImode.\n+\t(rs6000_emit_move): When reload calls us with an illegitimate\n+\taddress, exit early.  Move the change_address calls to one place\n+\tat the end of the routine.  Merge the SImode and DImode expanders.\n+\tWhen called by reload to put an integer into a FP register, force\n+\tit to memory.\n+\n+\t* config/rs6000/rs6000.c (struct toc_hash_struct): Add 'key_mode'\n+\tfield.\n+\t(rs6000_hash_constant): Hash mode too.\n+\t(toc_hash_function): Allow for key_mode.\n+\t(toc_hash_eq): Structures are different if key_mode differs.\n+\t(output_toc): Add 'mode' parameter.  Save key_mode.\n+\t* config/rs6000/rs6000.h (ASM_OUTPUT_SPECIAL_POOL_ENTRY):\n+\tPass 'mode' parameter.\n+\t* config/rs6000/rs6000-protos.h (output_toc): Add 'mode' param.\n+\n \t* config/rs6000/rs6000.c (output_toc): Use RS6000_OUTPUT_BASENAME\n \tfor vtable references.\n "}, {"sha": "b863b5e654335549a812835c4798ed6cfb0a8601", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -100,14 +100,14 @@ Boston, MA 02111-1307, USA.  */\n /* Define the options for the binder: Start text at 512, align all segments\n    to 512 bytes, and warn if there is text relocation.\n \n- The -bhalt:4 option supposedly changes the level at which ld will abort,\n+   The -bhalt:4 option supposedly changes the level at which ld will abort,\n    but it also suppresses warnings about multiply defined symbols and is\n    used by the AIX cc command.  So we use it here.\n \n    -bnodelcsect undoes a poor choice of default relating to multiply-defined\n    csects.  See AIX documentation for more information about this.\n \n- -bM:SRE tells the linker that the output file is Shared REusable.  Note\n+   -bM:SRE tells the linker that the output file is Shared REusable.  Note\n    that to actually build a shared library you will also need to specify an\n    export list with the -Wl,-bE option.  */\n \n@@ -233,11 +233,11 @@ toc_section ()\t\t\t\t\t\t\\\n    However, if this is being placed in the TOC it must be output as a\n    toc entry.  */\n \n-#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n-{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n-    toc_section ();\t\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    read_only_private_data_section ();\t\t\\\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\t\\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X, MODE))\t\\\n+    toc_section ();\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    read_only_private_data_section ();\t\t\t\\\n }\n \n /* Indicate that jump tables go in the text section.  */"}, {"sha": "374c5a1bfc530c33575bee66144b22f48c5d481f", "filename": "gcc/config/rs6000/netware.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fnetware.h?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -162,11 +162,11 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n /* Use the TOC section for TOC entries.  */\n \n #undef SELECT_RTX_SECTION\n-#define SELECT_RTX_SECTION(MODE, X)\t\t\\\n-{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n-    toc_section ();\t\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    const_section ();\t\t\t\t\\\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\t\\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X, MODE))\t\\\n+    toc_section ();\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\\\n }\n \n /* How to renumber registers for dbx and gdb.  */"}, {"sha": "995e36781ba1a11683435d46db5651e54bd61bfb", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -86,7 +86,7 @@ extern int ccr_bit PARAMS ((rtx, int));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n-extern void output_toc PARAMS ((FILE *, rtx, int));\n+extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));\n extern int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int rs6000_adjust_priority PARAMS ((rtx, int));\n extern void rs6000_initialize_trampoline PARAMS ((rtx, rtx, rtx));"}, {"sha": "5c4114104764a77c91c303073aa0b626222a0398", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 108, "deletions": 117, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -119,6 +119,7 @@ static int rs6000_sr_alias_set;\n static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n static rtx expand_block_move_mem PARAMS ((enum machine_mode, rtx, rtx));\n+static void rs6000_maybe_dead PARAMS ((rtx));\n static void rs6000_emit_stack_tie PARAMS ((void));\n static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n static void rs6000_emit_allocate_stack PARAMS ((HOST_WIDE_INT, int));\n@@ -890,6 +891,8 @@ easy_fp_constant (op, mode)\n \t     && GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_LOW (op) == 0)\n \t    || (num_insns_constant (op, DImode) <= 2));\n \n+  else if (mode == SImode)\n+    return 1;\n   else\n     abort ();\n }\n@@ -1339,7 +1342,7 @@ constant_pool_expr_1 (op, have_sym, have_toc)\n     case SYMBOL_REF:\n \tif (CONSTANT_POOL_ADDRESS_P (op))\n \t  {\n-\t   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (op)))\n+\t   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (op), Pmode))\n \t     {\n \t       *have_sym = 1;\n \t       return 1;\n@@ -1451,7 +1454,7 @@ rs6000_legitimize_address (x, oldx, mode)\n     }\n   else if (TARGET_TOC \n \t   && CONSTANT_POOL_EXPR_P (x)\n-\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x)))\n+\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n     {\n       return create_TOC_reference (x);\n     }\n@@ -1491,7 +1494,7 @@ rs6000_emit_move (dest, source, mode)\n   \n   if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n     operands[1] = force_reg (mode, operands[1]);\n-  \n+\n   if (mode == SFmode && ! TARGET_POWERPC && TARGET_HARD_FLOAT\n       && GET_CODE (operands[0]) == MEM)\n     {\n@@ -1516,13 +1519,16 @@ rs6000_emit_move (dest, source, mode)\n \t}\n     }\n \n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n+  /* Handle the case where reload calls us with an invalid address;\n+     and the case of CONSTANT_P_RTX.  */\n+  if (! general_operand (operands[1], mode)\n+      || ! nonimmediate_operand (operands[0], mode)\n+      || GET_CODE (operands[1]) == CONSTANT_P_RTX)\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n       return;\n     }\n-\n+  \n   /* FIXME:  In the long term, this switch statement should go away\n      and be replaced by a sequence of tests based on things like\n      mode == Pmode.  */\n@@ -1532,53 +1538,45 @@ rs6000_emit_move (dest, source, mode)\n     case QImode:\n       if (CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != CONST_INT)\n-\t{\n-\t  operands[1] = force_const_mem (mode, operands[1]);\n-\t  if (! memory_address_p (mode, XEXP (operands[1], 0))\n-\t      && ! reload_in_progress)\n-\t    operands[1] = change_address (operands[1], mode,\n-\t\t\t\t\t  XEXP (operands[1], 0));\n-\t}\n+\toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n \n     case DFmode:\n     case SFmode:\n       if (CONSTANT_P (operands[1]) \n \t  && ! easy_fp_constant (operands[1], mode))\n-\t{\n-\t  operands[1] = force_const_mem (mode, operands[1]);\n-\t  if (! memory_address_p (mode, XEXP (operands[1], 0))\n-\t      && ! reload_in_progress)\n-\t    operands[1] = change_address (operands[1], mode,\n-\t\t\t\t\t  XEXP (operands[1], 0));\n-\t}\n+\toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n       \n     case SImode:\n+    case DImode:\n       /* Use default pattern for address of ELF small data */\n       if (TARGET_ELF\n+\t  && mode == Pmode\n \t  && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-\t  && (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n-\t  && small_data_operand (operands[1], SImode))\n+\t  && (GET_CODE (operands[1]) == SYMBOL_REF \n+\t      || GET_CODE (operands[1]) == CONST)\n+\t  && small_data_operand (operands[1], mode))\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n \t  return;\n \t}\n \n       if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-\t  && flag_pic == 1 && got_operand (operands[1], SImode))\n+\t  && mode == Pmode && mode == SImode\n+\t  && flag_pic == 1 && got_operand (operands[1], mode))\n \t{\n \t  emit_insn (gen_movsi_got (operands[0], operands[1]));\n \t  return;\n \t}\n \n-      if (TARGET_ELF && TARGET_NO_TOC && ! TARGET_64BIT\n-\t  && ! flag_pic\n+      if (TARGET_ELF && TARGET_NO_TOC && ! flag_pic\n+\t  && mode == Pmode\n \t  && CONSTANT_P (operands[1])\n \t  && GET_CODE (operands[1]) != HIGH\n \t  && GET_CODE (operands[1]) != CONST_INT)\n \t{\n-\t  rtx target = (no_new_pseudos ? operands[0] : gen_reg_rtx (SImode));\n+\t  rtx target = (no_new_pseudos ? operands[0] : gen_reg_rtx (mode));\n \n \t  /* If this is a function address on -mcall-aixdesc,\n \t     convert it to the address of the descriptor.  */\n@@ -1603,70 +1601,30 @@ rs6000_emit_move (dest, source, mode)\n \t  return;\n \t}\n \n-      if (CONSTANT_P (operands[1])\n-\t  && GET_CODE (operands[1]) != CONST_INT\n-\t  && GET_CODE (operands[1]) != HIGH\n-\t  && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n-\t  && ! TOC_RELATIVE_EXPR_P (operands[1]))\n+      /* If this is a SYMBOL_REF that refers to a constant pool entry,\n+\t and we have put it in the TOC, we just need to make a TOC-relative\n+\t reference to it.  */\n+      if (TARGET_TOC\n+\t  && GET_CODE (operands[1]) == SYMBOL_REF\n+\t  && CONSTANT_POOL_EXPR_P (operands[1])\n+\t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (operands[1]),\n+\t\t\t\t\t      get_pool_mode (operands[1])))\n \t{\n-\t  /* Emit a USE operation so that the constant isn't deleted if\n-\t     expensive optimizations are turned on because nobody\n-\t     references it.  This should only be done for operands that\n-\t     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n-\t     This should not be done for operands that contain LABEL_REFs.\n-\t     For now, we just handle the obvious case.  */\n-\t  if (GET_CODE (operands[1]) != LABEL_REF)\n-\t    emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n-\n-      /* If we are to limit the number of things we put in the TOC and\n-\t this is a symbol plus a constant we can add in one insn,\n-\t just put the symbol in the TOC and add the constant.  Don't do\n-\t this if reload is in progress.  */\n-\t  if (GET_CODE (operands[1]) == CONST\n-\t      && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n-\t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t      && add_operand (XEXP (XEXP (operands[1], 0), 1), SImode)\n-\t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n-\t      && ! side_effects_p (operands[0]))\n-\t    {\n-\t      rtx sym = force_const_mem (SImode, XEXP (XEXP (operands[1], 0), 0));\n-\t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n-\n-\t      emit_insn (gen_addsi3 (operands[0], force_reg (SImode, sym), other));\n-\t      return;\n-\t    }\n-\n-\t  operands[1] = force_const_mem (SImode, operands[1]);\n-\n-\t  if (TARGET_TOC \n-\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n-\t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n-\t\t\t\t\t\t\t\t     XEXP (operands[1], 0))))\n-\t    {\n-\t      operands[1] = gen_rtx_MEM (SImode,\n-\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n-\t      MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n-\t      RTX_UNCHANGING_P (operands[1]) = 1;\n-\t    }\n-\n-\t  if (! memory_address_p (SImode, XEXP (operands[1], 0))\n-\t      && ! reload_in_progress)\n-\t    operands[1] = change_address (operands[1], SImode,\n-\t\t\t\t\t  XEXP (operands[1], 0));\n+\t  operands[1] = create_TOC_reference (operands[1]);\n \t}\n-      break;\n-\n-    case DImode:\n-      if (TARGET_64BIT\n-\t  && CONSTANT_P (operands[1])\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  && GET_CODE (operands[1]) != CONST_INT\n-#endif\n-\t  && ! easy_fp_constant (operands[1], DImode)\n-\t  && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n-\t  && ! TOC_RELATIVE_EXPR_P (operands[1]))\n+      else if (mode == Pmode\n+\t       && CONSTANT_P (operands[1])\n+ \t       && (((HOST_BITS_PER_WIDE_INT != 32 \n+ \t\t     || GET_CODE (operands[1]) != CONST_INT)\n+ \t\t    && ! easy_fp_constant (operands[1], mode))\n+ \t\t   || (GET_CODE (operands[0]) == REG\n+ \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n+\t       && GET_CODE (operands[1]) != HIGH\n+\t       && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n+\t       && ! TOC_RELATIVE_EXPR_P (operands[1]))\n \t{\n+\t  int special_constant_p = 0;\n+\n \t  /* Emit a USE operation so that the constant isn't deleted if\n \t     expensive optimizations are turned on because nobody\n \t     references it.  This should only be done for operands that\n@@ -1683,39 +1641,46 @@ rs6000_emit_move (dest, source, mode)\n \t  if (GET_CODE (operands[1]) == CONST\n \t      && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n \t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t      && add_operand (XEXP (XEXP (operands[1], 0), 1), DImode)\n+\t      && add_operand (XEXP (XEXP (operands[1], 0), 1), mode)\n \t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n \t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n \t      && ! side_effects_p (operands[0]))\n \t    {\n-\t      rtx sym = force_const_mem (DImode, XEXP (XEXP (operands[1], 0), 0));\n+\t      rtx sym = force_const_mem (mode, XEXP (XEXP (operands[1], 0), 0));\n \t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n \n-\t      emit_insn (gen_adddi3 (operands[0], force_reg (DImode, sym), other));\n+\t      sym = force_reg (mode, sym);\n+\t      if (mode == SImode)\n+\t\temit_insn (gen_addsi3 (operands[0], sym, other));\n+\t      else\n+\t\temit_insn (gen_adddi3 (operands[0], sym, other));\n \t      return;\n \t    }\n \n-\t  operands[1] = force_const_mem (DImode, operands[1]);\n+\t  operands[1] = force_const_mem (mode, operands[1]);\n \n \t  if (TARGET_TOC \n-\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n-\t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n-\t\t\t\t\t\t\t\t     XEXP (operands[1], 0))))\n+\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0)))\n \t    {\n-\t      operands[1] = gen_rtx_MEM (DImode,\n-\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n+\t      rtx constant;\n+\t      enum machine_mode cmode;\n \n+\t      constant = get_pool_constant (XEXP (operands[1], 0));\n+\t      cmode = get_pool_mode (XEXP (operands[1], 0));\n+\t      special_constant_p = \n+\t\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P (constant, cmode);\n+\t    }\n+\n+\t  if (special_constant_p)\n+\t    {\n+\t      operands[1] = gen_rtx_MEM (mode,\n+\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n \t      MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n \t      RTX_UNCHANGING_P (operands[1]) = 1;\n-\t    }\t\n-\n-\t  if (! memory_address_p (DImode, XEXP (operands[1], 0))\n-\t      && ! reload_in_progress)\n-\t    operands[1] = change_address (operands[1], DImode,\n-\t\t\t\t\t  XEXP (operands[1], 0));\n+\t    }\n \t}\n       break;\n-  \n+\n     case TImode:\n       if (GET_CODE (operands[0]) == MEM\n \t  && GET_CODE (XEXP (operands[0], 0)) != REG\n@@ -1734,6 +1699,15 @@ rs6000_emit_move (dest, source, mode)\n       abort ();\n     }\n \n+  /* Above, we may have called force_const_mem which may have returned\n+     an invalid address.  If we can, fix this up; otherwise, reload will\n+     have to deal with it.  */\n+  if (GET_CODE (operands[1]) == MEM\n+      && ! memory_address_p (mode, XEXP (operands[1], 0))\n+      && ! reload_in_progress)\n+    operands[1] = change_address (operands[1], mode,\n+\t\t\t\t  XEXP (operands[1], 0));\n+\n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n }\n \f\n@@ -6309,6 +6283,7 @@ struct toc_hash_struct\n   /* `key' will satisfy CONSTANT_P; in fact, it will satisfy\n      ASM_OUTPUT_SPECIAL_POOL_ENTRY_P.  */\n   rtx key;\n+  enum machine_mode key_mode;\n   int labelno;\n };\n \n@@ -6320,7 +6295,7 @@ static unsigned\n rs6000_hash_constant (k)\n      rtx k;\n {\n-  unsigned result = GET_CODE (k);\n+  unsigned result = (GET_CODE (k) << 3) ^ GET_MODE (k);\n   const char *format = GET_RTX_FORMAT (GET_CODE (k));\n   int flen = strlen (format);\n   int fidx;\n@@ -6377,8 +6352,9 @@ static unsigned\n toc_hash_function (hash_entry)\n      const void * hash_entry;\n {\n-  return rs6000_hash_constant (((const struct toc_hash_struct *) \n-\t\t\t\thash_entry)->key);\n+  const struct toc_hash_struct *thc = \n+    (const struct toc_hash_struct *) hash_entry;\n+  return rs6000_hash_constant (thc->key) ^ thc->key_mode;\n }\n \n /* Compare H1 and H2 for equivalence.  */\n@@ -6391,6 +6367,10 @@ toc_hash_eq (h1, h2)\n   rtx r1 = ((const struct toc_hash_struct *) h1)->key;\n   rtx r2 = ((const struct toc_hash_struct *) h2)->key;\n \n+  if (((const struct toc_hash_struct *) h1)->key_mode\n+      != ((const struct toc_hash_struct *) h2)->key_mode)\n+    return 0;\n+\n   /* Gotcha:  One of these const_doubles will be in memory.\n      The other may be on the constant-pool chain.\n      So rtx_equal_p will think they are different... */\n@@ -6453,10 +6433,11 @@ toc_hash_mark_table (vht)\n    being written.  */\n \n void\n-output_toc (file, x, labelno)\n+output_toc (file, x, labelno, mode)\n      FILE *file;\n      rtx x;\n      int labelno;\n+     enum machine_mode mode;\n {\n   char buf[256];\n   const char *name = buf;\n@@ -6479,6 +6460,7 @@ output_toc (file, x, labelno)\n       \n       h = ggc_alloc (sizeof (*h));\n       h->key = x;\n+      h->key_mode = mode;\n       h->labelno = labelno;\n       \n       found = htab_find_slot (toc_hash_table, h, 1);\n@@ -6501,7 +6483,7 @@ output_toc (file, x, labelno)\n      aligned properly when strict alignment is on.  */\n   if (GET_CODE (x) == CONST_DOUBLE\n       && STRICT_ALIGNMENT\n-      && GET_MODE (x) == DFmode\n+      && GET_MODE_BITSIZE (mode) >= 64\n       && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC)) {\n     ASM_OUTPUT_ALIGN (file, 3);\n   }\n@@ -6511,8 +6493,7 @@ output_toc (file, x, labelno)\n   /* Handle FP constants specially.  Note that if we have a minimal\n      TOC, things we put here aren't actually in the TOC, so we can allow\n      FP constants.  */\n-  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode\n-      && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n+  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n     {\n       REAL_VALUE_TYPE rv;\n       long k[2];\n@@ -6539,8 +6520,7 @@ output_toc (file, x, labelno)\n \t  return;\n \t}\n     }\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode\n-\t   && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n     {\n       REAL_VALUE_TYPE rv;\n       long l;\n@@ -6566,8 +6546,7 @@ output_toc (file, x, labelno)\n \t}\n     }\n   else if (GET_MODE (x) == VOIDmode\n-\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n-\t   && ! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC))\n+\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE))\n     {\n       HOST_WIDE_INT low;\n       HOST_WIDE_INT high;\n@@ -6590,6 +6569,18 @@ output_toc (file, x, labelno)\n \t}\n #endif\n \n+      /* TOC entries are always Pmode-sized, but since this\n+\t is a bigendian machine then if we're putting smaller\n+\t integer constants in the TOC we have to pad them.\n+\t (This is still a win over putting the constants in\n+\t a separate constant pool, because then we'd have\n+\t to have both a TOC entry _and_ the actual constant.)  */\n+      if (POINTER_SIZE < GET_MODE_BITSIZE (mode))\n+\tabort ();/* It would be easy to make this work, but it doesn't now.  */\n+      if (mode != Pmode)\n+\tlshift_double (low, high, POINTER_SIZE - GET_MODE_BITSIZE (mode),\n+\t\t       POINTER_SIZE, &low, &high, 0);\n+\n       if (TARGET_64BIT)\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n@@ -7191,10 +7182,10 @@ rs6000_longcall_ref (call_ref)\n \n void\n rs6000_select_rtx_section (mode, x)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n      rtx x;\n {\n-  if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x))\n+  if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n     toc_section ();\n   else\n     const_section ();\n@@ -7219,7 +7210,7 @@ rs6000_select_section (decl, reloc)\n       else\n \tdata_section ();\n     }\n-  else if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == CONSTRUCTOR)\n+  else if (TREE_CODE (decl) == VAR_DECL)\n     {\n       if ((flag_pic && reloc)\n \t  || ! TREE_READONLY (decl)"}, {"sha": "9b3de41fcbd2ed0bfacb17fd3cdea5c887b3a04c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -1934,55 +1934,55 @@ typedef struct rs6000_args\n    register by splitting the addend across an addiu/addis and the mem insn.\n    This cuts number of extra insns needed from 3 to 1.  */\n    \n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n-do {                                                                    \\\n-  /* We must recognize output that we have already generated ourselves.  */ \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,       \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n-                   OPNUM, TYPE);                                        \\\n-      goto WIN;                                                         \\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS                                              \\\n-      && GET_CODE (XEXP (X, 0)) == REG                                  \\\n-      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER                    \\\n-      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)                     \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)                           \\\n-    {                                                                   \\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));                         \\\n-      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;           \\\n-      unsigned HOST_WIDE_INT high                                       \\\n-        = (((val - low) & 0xffffffffu) ^ 0x80000000u) - 0x80000000u;    \\\n-                                                                        \\\n-      /* Check for 32-bit overflow.  */                                 \\\n-      if (high + low != val)                                            \\\n-        break;                                                          \\\n-                                                                        \\\n-      /* Reload the high part into a base reg; leave the low part       \\\n-         in the mem directly.  */                                       \\\n-                                                                        \\\n-      X = gen_rtx_PLUS (GET_MODE (X),                                   \\\n-                        gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),        \\\n-                                      GEN_INT (high)),                  \\\n-                        GEN_INT (low));                                 \\\n-                                                                        \\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,       \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n-                   OPNUM, TYPE);                                        \\\n-      goto WIN;                                                         \\\n-    }                                                                   \\\n-  else if (TARGET_TOC \t\t\t\t\t\t\t\\\n-\t   && CONSTANT_POOL_EXPR_P (X)\t\t\t\t\t\\\n-\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X)))\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (X) = create_TOC_reference (X);\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n+do {\t\t\t\t\t\t\t\t\t     \\\n+  /* We must recognize output that we have already generated ourselves.  */  \\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t     \\\n+      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t     \\\n+      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t     \\\n+      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t     \\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t     \\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t     \\\n+                   OPNUM, TYPE);\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+  if (GET_CODE (X) == PLUS\t\t\t\t\t\t     \\\n+      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t     \\\n+      && REGNO (XEXP (X, 0)) < FIRST_PSEUDO_REGISTER\t\t\t     \\\n+      && REG_MODE_OK_FOR_BASE_P (XEXP (X, 0), MODE)\t\t\t     \\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\t     \\\n+      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\t\t     \\\n+      HOST_WIDE_INT high\t\t\t\t\t\t     \\\n+        = (((val - low) & 0xffffffffu) ^ 0x80000000u) - 0x80000000u;\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+      /* Check for 32-bit overflow.  */\t\t\t\t\t     \\\n+      if (high + low != val)\t\t\t\t\t\t     \\\n+        break;\t\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+      /* Reload the high part into a base reg; leave the low part\t     \\\n+         in the mem directly.  */\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+      X = gen_rtx_PLUS (GET_MODE (X),\t\t\t\t\t     \\\n+                        gen_rtx_PLUS (GET_MODE (X), XEXP (X, 0),\t     \\\n+                                      GEN_INT (high)),\t\t\t     \\\n+                        GEN_INT (low));\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL_PTR,\t     \\\n+                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,\t     \\\n+                   OPNUM, TYPE);\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+  else if (TARGET_TOC\t\t\t\t\t\t\t     \\\n+\t   && CONSTANT_POOL_EXPR_P (X)\t\t\t\t\t     \\\n+\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (X), MODE)) \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      (X) = create_TOC_reference (X);\t\t\t\t\t     \\\n+      goto WIN;\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n } while (0)\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n@@ -2359,39 +2359,41 @@ extern int rs6000_trunc_used;\n /* Flag to say the TOC is initialized */\n extern int toc_initialized;\n \n-/* Return non-zero if this entry is to be written into the constant pool\n-   in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF or a CONST\n-   containing one of them.  If -mfp-in-toc (the default), we also do\n-   this for floating-point constants.  We actually can only do this\n-   if the FP formats of the target and host machines are the same, but\n-   we can't check that since not every file that uses\n-   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  */\n-\n-#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\t\\\n+/* Return non-zero if this entry is to be written into the constant\n+   pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n+   or a CONST containing one of them.  If -mfp-in-toc (the default),\n+   we also do this for floating-point constants.  We actually can only\n+   do this if the FP formats of the target and host machines are the\n+   same, but we can't check that since not every file that uses\n+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n+   we can write the entry into the TOC and the entry is not larger\n+   than a TOC entry.  */\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n    && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n \t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (! (TARGET_NO_FP_IN_TOC && ! TARGET_MINIMAL_TOC)\t\t\\\n-\t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-\t   && (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n-\t       || TARGET_POWERPC64))))\n-#if 0\n-\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))\n-#endif\n+       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+\t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n+       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+\t   && (TARGET_POWERPC64\t\t\t\t\t\t\\\n+\t       || TARGET_MINIMAL_TOC\t\t\t\t\t\\\n+\t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t\t   && ! TARGET_NO_FP_IN_TOC)))))\n \n /* Macro to output a special constant pool entry.  Go to WIN if we output\n    it.  Otherwise, it is written the usual way.\n \n    On the RS/6000, toc entries are handled this way.  */\n \n-#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, X, MODE, ALIGN, LABELNO, WIN)  \\\n-{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X))\t\\\n-    {\t\t\t\t\t\t\\\n-      output_toc (FILE, X, LABELNO);\t\t\\\n-      goto WIN;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, X, MODE, ALIGN, LABELNO, WIN) \\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X, MODE))\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      output_toc (FILE, X, LABELNO, MODE);\t\t\t\t  \\\n+      goto WIN;\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n }\n \n /* This is how we tell the assembler that two symbols have the same value.  */"}, {"sha": "ef53b7db39a7b1cfad3fb8e5b53d70e7259bdaf3", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9098fd024e128b97dc4cbf338a10eb6056f487e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=a9098fd024e128b97dc4cbf338a10eb6056f487e", "patch": "@@ -563,12 +563,14 @@ fini_section ()\t\t\t\t\t\t\t\t\\\n    allow floating point constants in the TOC if -mrelocatable.  */\n \n #undef\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n-#define\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X)\t\t\t\t\\\n+#define\tASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n   (TARGET_TOC\t\t\t\t\t\t\t\t\\\n    && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n        || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n \t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n        || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+\t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n        || (!TARGET_NO_FP_IN_TOC\t\t\t\t\t\t\\\n \t   && !TARGET_RELOCATABLE\t\t\t\t\t\\\n \t   && GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\"}]}