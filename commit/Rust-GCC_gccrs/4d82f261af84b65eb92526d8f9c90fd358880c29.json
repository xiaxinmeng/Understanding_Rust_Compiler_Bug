{"sha": "4d82f261af84b65eb92526d8f9c90fd358880c29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4MmYyNjFhZjg0YjY1ZWI5MjUyNmQ4ZjljOTBmZDM1ODg4MGMyOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-11-19T15:46:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-11-19T15:46:41Z"}, "message": "bfin.c (must_save_p): New function, mostly broken out of n_dregs_to_save and n_pregs_to_save.\n\n\t* config/bfin/bfin.c (must_save_p): New function, mostly broken out of\n\tn_dregs_to_save and n_pregs_to_save.\n\t(n_pregs_to_save, n_dregs_to_save): Use it.  New argument CONSECUTIVE;\n\tall callers changed.\n\t(expand_prologue_reg_save, expand_epilogue_reg_restore): Enhance to be\n\table to save single D/P registers that aren't saved by the push/pop\n\tmultiple insns.\n\nFrom-SVN: r130292", "tree": {"sha": "cd4b55c7c35130b7fef9f78514d4c0bb2f730205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd4b55c7c35130b7fef9f78514d4c0bb2f730205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d82f261af84b65eb92526d8f9c90fd358880c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d82f261af84b65eb92526d8f9c90fd358880c29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d82f261af84b65eb92526d8f9c90fd358880c29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d82f261af84b65eb92526d8f9c90fd358880c29/comments", "author": null, "committer": null, "parents": [{"sha": "60f1711a6d52865b59bc5320d3d0595bf398db12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f1711a6d52865b59bc5320d3d0595bf398db12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f1711a6d52865b59bc5320d3d0595bf398db12"}], "stats": {"total": 281, "additions": 185, "deletions": 96}, "files": [{"sha": "0a507a6152ba4385b3fa8e5bff6cf18ce0569552", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d82f261af84b65eb92526d8f9c90fd358880c29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d82f261af84b65eb92526d8f9c90fd358880c29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d82f261af84b65eb92526d8f9c90fd358880c29", "patch": "@@ -1,3 +1,13 @@\n+2007-11-19  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\t\n+\t* config/bfin/bfin.c (must_save_p): New function, mostly broken out of\n+\tn_dregs_to_save and n_pregs_to_save.\n+\t(n_pregs_to_save, n_dregs_to_save): Use it.  New argument CONSECUTIVE;\n+\tall callers changed.\n+\t(expand_prologue_reg_save, expand_epilogue_reg_restore): Enhance to be\n+\table to save single D/P registers that aren't saved by the push/pop\n+\tmultiple insns.\n+\n 2007-11-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/34099"}, {"sha": "e5f867ba7aa3153af1df00bcaa8cb8edc0b828b5", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 175, "deletions": 96, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d82f261af84b65eb92526d8f9c90fd358880c29/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d82f261af84b65eb92526d8f9c90fd358880c29/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=4d82f261af84b65eb92526d8f9c90fd358880c29", "patch": "@@ -340,22 +340,15 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \f\n /* Stack frame layout. */\n \n-/* Compute the number of DREGS to save with a push_multiple operation.\n-   This could include registers that aren't modified in the function,\n-   since push_multiple only takes a range of registers.\n-   If IS_INTHANDLER, then everything that is live must be saved, even\n-   if normally call-clobbered.  */\n-\n-static int\n-n_dregs_to_save (bool is_inthandler)\n+/* For a given REGNO, determine whether it must be saved in the function\n+   prologue.  IS_INTHANDLER specifies whether we're generating a normal\n+   prologue or an interrupt/exception one.  */\n+static bool\n+must_save_p (bool is_inthandler, unsigned regno)\n {\n-  unsigned i;\n-\n-  for (i = REG_R0; i <= REG_R7; i++)\n+  if (D_REGNO_P (regno))\n     {\n-      if (df_regs_ever_live_p (i) && (is_inthandler || ! call_used_regs[i]))\n-\treturn REG_R7 - i + 1;\n-\n+      bool is_eh_return_reg = false;\n       if (current_function_calls_eh_return)\n \t{\n \t  unsigned j;\n@@ -364,30 +357,71 @@ n_dregs_to_save (bool is_inthandler)\n \t      unsigned test = EH_RETURN_DATA_REGNO (j);\n \t      if (test == INVALID_REGNUM)\n \t\tbreak;\n-\t      if (test == i)\n-\t\treturn REG_R7 - i + 1;\n+\t      if (test == regno)\n+\t\tis_eh_return_reg = true;\n \t    }\n \t}\n \n+      return (is_eh_return_reg\n+\t      || (df_regs_ever_live_p (regno)\n+\t\t  && !fixed_regs[regno]\n+\t\t  && (is_inthandler || !call_used_regs[regno])));\n     }\n-  return 0;\n+  else if (P_REGNO_P (regno))\n+    {\n+      return ((df_regs_ever_live_p (regno)\n+\t       && !fixed_regs[regno]\n+\t       && (is_inthandler || !call_used_regs[regno]))\n+\t      || (!TARGET_FDPIC\n+\t\t  && regno == PIC_OFFSET_TABLE_REGNUM\n+\t\t  && (current_function_uses_pic_offset_table\n+\t\t      || (TARGET_ID_SHARED_LIBRARY && !current_function_is_leaf))));\n+    }\n+  else\n+    return ((is_inthandler || !call_used_regs[regno])\n+\t    && (df_regs_ever_live_p (regno)\n+\t\t|| (!leaf_function_p () && call_used_regs[regno])));\n+\n+}\n+\n+/* Compute the number of DREGS to save with a push_multiple operation.\n+   This could include registers that aren't modified in the function,\n+   since push_multiple only takes a range of registers.\n+   If IS_INTHANDLER, then everything that is live must be saved, even\n+   if normally call-clobbered.\n+   If CONSECUTIVE, return the number of registers we can save in one\n+   instruction with a push/pop multiple instruction.  */\n+\n+static int\n+n_dregs_to_save (bool is_inthandler, bool consecutive)\n+{\n+  int count = 0;\n+  unsigned i;\n+\n+  for (i = REG_R7 + 1; i-- != REG_R0;)\n+    {\n+      if (must_save_p (is_inthandler, i))\n+\tcount++;\n+      else if (consecutive)\n+\treturn count;\n+    }\n+  return count;\n }\n \n /* Like n_dregs_to_save, but compute number of PREGS to save.  */\n \n static int\n-n_pregs_to_save (bool is_inthandler)\n+n_pregs_to_save (bool is_inthandler, bool consecutive)\n {\n+  int count = 0;\n   unsigned i;\n \n-  for (i = REG_P0; i <= REG_P5; i++)\n-    if ((df_regs_ever_live_p (i) && (is_inthandler || ! call_used_regs[i]))\n-\t|| (!TARGET_FDPIC\n-\t    && i == PIC_OFFSET_TABLE_REGNUM\n-\t    && (current_function_uses_pic_offset_table\n-\t\t|| (TARGET_ID_SHARED_LIBRARY && ! current_function_is_leaf))))\n-      return REG_P5 - i + 1;\n-  return 0;\n+  for (i = REG_P5 + 1; i-- != REG_P0;)\n+    if (must_save_p (is_inthandler, i))\n+      count++;\n+    else if (consecutive)\n+      return count;\n+  return count;\n }\n \n /* Determine if we are going to save the frame pointer in the prologue.  */\n@@ -418,61 +452,85 @@ expand_prologue_reg_save (rtx spreg, int saveall, bool is_inthandler)\n {\n   rtx predec1 = gen_rtx_PRE_DEC (SImode, spreg);\n   rtx predec = gen_rtx_MEM (SImode, predec1);\n-  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n-  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n-  int dregno = REG_R7 + 1 - ndregs;\n-  int pregno = REG_P5 + 1 - npregs;\n-  int total = ndregs + npregs;\n-  int i;\n-  rtx pat, insn, val;\n+  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler, false);\n+  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler, false);\n+  int ndregs_consec = saveall ? 8 : n_dregs_to_save (is_inthandler, true);\n+  int npregs_consec = saveall ? 6 : n_pregs_to_save (is_inthandler, true);\n+  int dregno, pregno;\n+  int total_consec = ndregs_consec + npregs_consec;\n+  int i, d_to_save;\n \n   if (saveall || is_inthandler)\n     {\n-      insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n+      rtx insn = emit_move_insn (predec, gen_rtx_REG (SImode, REG_ASTAT));\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  if (total == 0 && !saveall)\n-    return;\n+  if (total_consec != 0)\n+    {\n+      rtx insn;\n+      rtx val = GEN_INT (-total_consec * 4);\n+      rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_consec + 2));\n+\n+      XVECEXP (pat, 0, 0) = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, val),\n+\t\t\t\t\t    UNSPEC_PUSH_MULTIPLE);\n+      XVECEXP (pat, 0, total_consec + 1) = gen_rtx_SET (VOIDmode, spreg,\n+\t\t\t\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\t      spreg,\n+\t\t\t\t\t\t\t\t      val));\n+      RTX_FRAME_RELATED_P (XVECEXP (pat, 0, total_consec + 1)) = 1;\n+      d_to_save = ndregs_consec;\n+      dregno = REG_R7 + 1 - ndregs_consec;\n+      pregno = REG_P5 + 1 - npregs_consec;\n+      for (i = 0; i < total_consec; i++)\n+\t{\n+\t  rtx memref = gen_rtx_MEM (word_mode,\n+\t\t\t\t    gen_rtx_PLUS (Pmode, spreg,\n+\t\t\t\t\t\t  GEN_INT (- i * 4 - 4)));\n+\t  rtx subpat;\n+\t  if (d_to_save > 0)\n+\t    {\n+\t      subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n+\t\t\t\t\t\t\t\t   dregno++));\n+\t      d_to_save--;\n+\t    }\n+\t  else\n+\t    {\n+\t      subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n+\t\t\t\t\t\t\t\t   pregno++));\n+\t    }\n+\t  XVECEXP (pat, 0, i + 1) = subpat;\n+\t  RTX_FRAME_RELATED_P (subpat) = 1;\n+\t}\n+      insn = emit_insn (pat);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n \n-  val = GEN_INT (-total * 4);\n-  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total + 2));\n-  XVECEXP (pat, 0, 0) = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, val),\n-\t\t\t\t\tUNSPEC_PUSH_MULTIPLE);\n-  XVECEXP (pat, 0, total + 1) = gen_rtx_SET (VOIDmode, spreg,\n-\t\t\t\t\t     gen_rtx_PLUS (Pmode, spreg,\n-\t\t\t\t\t\t\t   val));\n-  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, total + 1)) = 1;\n-  for (i = 0; i < total; i++)\n-    {\n-      rtx memref = gen_rtx_MEM (word_mode,\n-\t\t\t\tgen_rtx_PLUS (Pmode, spreg,\n-\t\t\t\t\t      GEN_INT (- i * 4 - 4)));\n-      rtx subpat;\n-      if (ndregs > 0)\n+  for (dregno = REG_R0; ndregs != ndregs_consec; dregno++)\n+    {\n+      if (must_save_p (is_inthandler, dregno))\n \t{\n-\t  subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n-\t\t\t\t\t\t\t       dregno++));\n+\t  rtx insn = emit_move_insn (predec, gen_rtx_REG (word_mode, dregno));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t  ndregs--;\n \t}\n-      else\n+    }\n+  for (pregno = REG_P0; npregs != npregs_consec; pregno++)\n+    {\n+      if (must_save_p (is_inthandler, pregno))\n \t{\n-\t  subpat = gen_rtx_SET (VOIDmode, memref, gen_rtx_REG (word_mode,\n-\t\t\t\t\t\t\t       pregno++));\n-\t  npregs++;\n+\t  rtx insn = emit_move_insn (predec, gen_rtx_REG (word_mode, pregno));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  npregs--;\n \t}\n-      XVECEXP (pat, 0, i + 1) = subpat;\n-      RTX_FRAME_RELATED_P (subpat) = 1;\n     }\n-  insn = emit_insn (pat);\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-\n   for (i = REG_P7 + 1; i < REG_CC; i++)\n     if (saveall \n \t|| (is_inthandler\n \t    && (df_regs_ever_live_p (i)\n \t\t|| (!leaf_function_p () && call_used_regs[i]))))\n       {\n+\trtx insn;\n \tif (i == REG_A0 || i == REG_A1)\n \t  insn = emit_move_insn (gen_rtx_MEM (PDImode, predec1),\n \t\t\t\t gen_rtx_REG (PDImode, i));\n@@ -493,11 +551,13 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n   rtx postinc1 = gen_rtx_POST_INC (SImode, spreg);\n   rtx postinc = gen_rtx_MEM (SImode, postinc1);\n \n-  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler);\n-  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler);\n-  int total = ndregs + npregs;\n+  int ndregs = saveall ? 8 : n_dregs_to_save (is_inthandler, false);\n+  int npregs = saveall ? 6 : n_pregs_to_save (is_inthandler, false);\n+  int ndregs_consec = saveall ? 8 : n_dregs_to_save (is_inthandler, true);\n+  int npregs_consec = saveall ? 6 : n_pregs_to_save (is_inthandler, true);\n+  int total_consec = ndregs_consec + npregs_consec;\n   int i, regno;\n-  rtx pat, insn;\n+  rtx insn;\n \n   /* A slightly crude technique to stop flow from trying to delete \"dead\"\n      insns.  */\n@@ -519,40 +579,59 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n \t  emit_move_insn (gen_rtx_REG (SImode, i), postinc);\n       }\n \n-  if (total == 0)\n-    return;\n-\n-  pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total + 1));\n-  XVECEXP (pat, 0, 0) = gen_rtx_SET (VOIDmode, spreg,\n-\t\t\t\t     gen_rtx_PLUS (Pmode, spreg,\n-\t\t\t\t\t\t   GEN_INT (total * 4)));\n-\n-  if (npregs > 0)\n-    regno = REG_P5 + 1;\n-  else\n-    regno = REG_R7 + 1;\n-\n-  for (i = 0; i < total; i++)\n+  regno = REG_P5 - npregs_consec;\n+  for (; npregs != npregs_consec; regno--)\n     {\n-      rtx addr = (i > 0\n-\t\t  ? gen_rtx_PLUS (Pmode, spreg, GEN_INT (i * 4))\n-\t\t  : spreg);\n-      rtx memref = gen_rtx_MEM (word_mode, addr);\n-\n-      regno--;\n-      XVECEXP (pat, 0, i + 1)\n-\t= gen_rtx_SET (VOIDmode, gen_rtx_REG (word_mode, regno), memref);\n-\n-      if (npregs > 0)\n+      if (must_save_p (is_inthandler, regno))\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (word_mode, regno), postinc);\n+\t  npregs--;\n+\t}\n+    }\n+  regno = REG_R7 - ndregs_consec;\n+  for (; ndregs != ndregs_consec; regno--)\n+    {\n+      if (must_save_p (is_inthandler, regno))\n \t{\n-\t  if (--npregs == 0)\n-\t    regno = REG_R7 + 1;\n+\t  emit_move_insn (gen_rtx_REG (word_mode, regno), postinc);\n+\t  ndregs--;\n \t}\n     }\n \n-  insn = emit_insn (pat);\n-  RTX_FRAME_RELATED_P (insn) = 1;\n+  if (total_consec != 0)\n+    {\n+      rtx pat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_consec + 1));\n+      XVECEXP (pat, 0, 0)\n+\t= gen_rtx_SET (VOIDmode, spreg,\n+\t\t       gen_rtx_PLUS (Pmode, spreg,\n+\t\t\t\t     GEN_INT (total_consec * 4)));\n+\n+      if (npregs_consec > 0)\n+\tregno = REG_P5 + 1;\n+      else\n+\tregno = REG_R7 + 1;\n \n+      for (i = 0; i < total_consec; i++)\n+\t{\n+\t  rtx addr = (i > 0\n+\t\t      ? gen_rtx_PLUS (Pmode, spreg, GEN_INT (i * 4))\n+\t\t      : spreg);\n+\t  rtx memref = gen_rtx_MEM (word_mode, addr);\n+\n+\t  regno--;\n+\t  XVECEXP (pat, 0, i + 1)\n+\t    = gen_rtx_SET (VOIDmode, gen_rtx_REG (word_mode, regno), memref);\n+\n+\t  if (npregs_consec > 0)\n+\t    {\n+\t      if (--npregs_consec == 0)\n+\t\tregno = REG_R7 + 1;\n+\t    }\n+\t}\n+\n+      insn = emit_insn (pat);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n   if (saveall || is_inthandler)\n     emit_move_insn (gen_rtx_REG (SImode, REG_ASTAT), postinc);\n }\n@@ -636,8 +715,8 @@ n_regs_saved_by_prologue (void)\n   tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n   bool all = (lookup_attribute (\"saveall\", attrs) != NULL_TREE\n \t      || (is_inthandler && !current_function_is_leaf));\n-  int ndregs = all ? 8 : n_dregs_to_save (is_inthandler);\n-  int npregs = all ? 6 : n_pregs_to_save (is_inthandler);  \n+  int ndregs = all ? 8 : n_dregs_to_save (is_inthandler, false);\n+  int npregs = all ? 6 : n_pregs_to_save (is_inthandler, false);\n   int n = ndregs + npregs;\n   int i;\n "}]}