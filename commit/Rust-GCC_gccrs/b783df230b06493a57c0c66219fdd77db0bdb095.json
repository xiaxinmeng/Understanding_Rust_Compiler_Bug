{"sha": "b783df230b06493a57c0c66219fdd77db0bdb095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4M2RmMjMwYjA2NDkzYTU3YzBjNjYyMTlmZGQ3N2RiMGJkYjA5NQ==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T10:05:25Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-08-24T10:05:25Z"}, "message": "Initial revision\n\nFrom-SVN: r5206", "tree": {"sha": "c567aba813f069bff3fb01b3dec742a0571b557a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c567aba813f069bff3fb01b3dec742a0571b557a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b783df230b06493a57c0c66219fdd77db0bdb095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b783df230b06493a57c0c66219fdd77db0bdb095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b783df230b06493a57c0c66219fdd77db0bdb095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b783df230b06493a57c0c66219fdd77db0bdb095/comments", "author": null, "committer": null, "parents": [{"sha": "772fa04a92db00e2aa86f61f5cc3a1e1d9720d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772fa04a92db00e2aa86f61f5cc3a1e1d9720d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772fa04a92db00e2aa86f61f5cc3a1e1d9720d52"}], "stats": {"total": 598, "additions": 598, "deletions": 0}, "files": [{"sha": "075d2eee5cd82a167e13a84c8ace1e09ce03c68f", "filename": "gcc/objc/encoding.c", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b783df230b06493a57c0c66219fdd77db0bdb095/gcc%2Fobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b783df230b06493a57c0c66219fdd77db0bdb095/gcc%2Fobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.c?ref=b783df230b06493a57c0c66219fdd77db0bdb095", "patch": "@@ -0,0 +1,525 @@\n+/* Encoding of types for Objective C.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"encoding.h\"\n+\n+#define MAX(X, Y)                    \\\n+  ({ typeof(X) __x = (X), __y = (Y); \\\n+     (__x > __y ? __x : __y); })\n+\n+#define MIN(X, Y)                    \\\n+  ({ typeof(X) __x = (X), __y = (Y); \\\n+     (__x < __y ? __x : __y); })\n+\n+\n+static inline int\n+atoi (const char* str)\n+{\n+  int res = 0;\n+  \n+  while (isdigit (*str))\n+    res *= 10, res += (*str++ - '0');\n+\n+  return res;\n+}\n+\n+/*\n+  return the size of an object specified by type \n+*/\n+\n+int\n+objc_sizeof_type(const char* type)\n+{\n+  switch(*type) {\n+  case _C_ID:\n+    return sizeof(id);\n+    break;\n+\n+  case _C_CLASS:\n+    return sizeof(Class*);\n+    break;\n+\n+  case _C_SEL:\n+    return sizeof(SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return sizeof(char);\n+    break;\n+    \n+  case _C_UCHR:\n+    return sizeof(unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return sizeof(short);\n+    break;\n+\n+  case _C_USHT:\n+    return sizeof(unsigned short);\n+    break;\n+\n+  case _C_INT:\n+    return sizeof(int);\n+    break;\n+\n+  case _C_UINT:\n+    return sizeof(unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return sizeof(long);\n+    break;\n+\n+  case _C_ULNG:\n+    return sizeof(unsigned long);\n+    break;\n+\n+  case _C_PTR:\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return sizeof(char*);\n+    break;\n+\n+  case _C_ARY_B:\n+    {\n+      int len = atoi(type+1);\n+      while (isdigit(*++type));\n+      return len*objc_aligned_size (type);\n+    }\n+    break; \n+\n+  case _C_STRUCT_B:\n+    {\n+      int acc_size = 0;\n+      int align;\n+      while (*type != _C_STRUCT_E && *type++ != '='); /* skip \"<name>=\" */\n+      while (*type != _C_STRUCT_E);\n+\t{\n+\t  align = objc_alignof_type (type);       /* padd to alignment */\n+\t  if ((acc_size % align) != 0)\n+\t    acc_size += align - (acc_size % align);\n+\t  acc_size += objc_sizeof_type (type);   /* add component size */\n+\t  type = objc_skip_typespec (type);\t         /* skip component */\n+\t}\n+      return acc_size;\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int max_size = 0;\n+      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  max_size = MAX (max_size, objc_sizeof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return max_size;\n+    }\n+    \n+  default:\n+    abort();\n+  }\n+}\n+\n+\n+/*\n+  Return the alignment of an object specified by type \n+*/\n+\n+int\n+objc_alignof_type(const char* type)\n+{\n+  switch(*type) {\n+  case _C_ID:\n+    return __alignof__(id);\n+    break;\n+\n+  case _C_CLASS:\n+    return __alignof__(Class*);\n+    break;\n+    \n+  case _C_SEL:\n+    return __alignof__(SEL);\n+    break;\n+\n+  case _C_CHR:\n+    return __alignof__(char);\n+    break;\n+    \n+  case _C_UCHR:\n+    return __alignof__(unsigned char);\n+    break;\n+\n+  case _C_SHT:\n+    return __alignof__(short);\n+    break;\n+\n+  case _C_USHT:\n+    return __alignof__(unsigned short);\n+    break;\n+\n+  case _C_INT:\n+    return __alignof__(int);\n+    break;\n+\n+  case _C_UINT:\n+    return __alignof__(unsigned int);\n+    break;\n+\n+  case _C_LNG:\n+    return __alignof__(long);\n+    break;\n+\n+  case _C_ULNG:\n+    return __alignof__(unsigned long);\n+    break;\n+\n+  case _C_ATOM:\n+  case _C_CHARPTR:\n+    return __alignof__(char*);\n+    break;\n+\n+  case _C_ARY_B:\n+    while (isdigit(*++type)) /* do nothing */;\n+    return objc_alignof_type (type);\n+      \n+  case _C_STRUCT_B:\n+    {\n+      struct { int x; double y; } fooalign;\n+      while(*type != _C_STRUCT_E && *type++ != '=') /* do nothing */;\n+      if (*type != _C_STRUCT_E)\n+\treturn MAX (objc_alignof_type (type), __alignof__ (fooalign));\n+      else\n+\treturn __alignof__ (fooalign);\n+    }\n+\n+  case _C_UNION_B:\n+    {\n+      int maxalign = 0;\n+      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E)\n+\t{\n+\t  maxalign = MAX (maxalign, objc_alignof_type (type));\n+\t  type = objc_skip_typespec (type);\n+\t}\n+      return maxalign;\n+    }\n+    \n+  default:\n+    abort();\n+  }\n+}\n+\n+/*\n+  The aligned size if the size rounded up to the nearest alignment.\n+*/\n+\n+int\n+objc_aligned_size (const char* type)\n+{\n+  int size = objc_sizeof_type (type);\n+  int align = objc_alignof_type (type);\n+\n+  if ((size % align) != 0)\n+    return size + align - (size % align);\n+  else\n+    return size;\n+}\n+\n+/*\n+  The size rounded up to the nearest integral of the wordsize, taken\n+  to be the size of a void*.\n+*/\n+\n+int \n+objc_promoted_size (const char* type)\n+{\n+  int size = objc_sizeof_type (type);\n+  int wordsize = sizeof (void*);\n+\n+  if ((size % wordsize) != 0)\n+    return size + wordsize - (size % wordsize);\n+  else\n+    return size;\n+}\n+\n+/*\n+  Skip type qualifiers.  These may eventually precede typespecs\n+  occuring in method prototype encodings.\n+*/\n+\n+inline const char*\n+objc_skip_type_qualifiers (const char* type)\n+{\n+  while (*type == _C_CONST\n+\t || *type == _C_IN \n+\t || *type == _C_INOUT\n+\t || *type == _C_OUT \n+\t || *type == _C_BYCOPY\n+\t || *type == _C_ONEWAY)\n+    {\n+      type += 1;\n+    }\n+  return type;\n+}\n+\n+  \n+/*\n+  Skip one typespec element.  If the typespec is prepended by type\n+  qualifiers, these are skipped as well.\n+*/\n+\n+const char* \n+objc_skip_typespec (const char* type)\n+{\n+  type = objc_skip_type_qualifiers (type);\n+  \n+  switch (*type) {\n+\n+  case _C_ID:\n+    /* An id may be annotated by the actual type if it is known\n+       with the @\"ClassName\" syntax */\n+\n+    if (*++type != '\"')\n+      return type;\n+    else\n+      {\n+\twhile (*++type != '\"') /* do nothing */;\n+\treturn type + 1;\n+      }\n+\n+    /* The following are one character type codes */\n+  case _C_CLASS:\n+  case _C_SEL:\n+  case _C_CHR:\n+  case _C_UCHR:\n+  case _C_CHARPTR:\n+  case _C_ATOM:\n+  case _C_SHT:\n+  case _C_USHT:\n+  case _C_INT:\n+  case _C_UINT:\n+  case _C_LNG:\n+  case _C_ULNG:\n+  case _C_FLT:\n+  case _C_DBL:\n+  case _C_VOID:\n+    return ++type;\n+    break;\n+\n+  case _C_ARY_B:\n+    /* skip digits, typespec and closing ']' */\n+    \n+    while(isdigit(*++type));\n+    type = objc_skip_typespec(type);\n+    if (*type == _C_ARY_E)\n+      return ++type;\n+    else\n+      abort();\n+\n+  case _C_STRUCT_B:\n+    /* skip name, and elements until closing '}'  */\n+    \n+    while (*type != _C_STRUCT_E && *type++ != '=');\n+    while (*type != _C_STRUCT_E) { type = objc_skip_typespec (type); }\n+    return ++type;\n+\n+  case _C_UNION_B:\n+    /* skip name, and elements until closing ')'  */\n+    \n+    while (*type != _C_UNION_E && *type++ != '=');\n+    while (*type != _C_UNION_E) { type = objc_skip_typespec (type); }\n+    return ++type;\n+\n+  case _C_PTR:\n+    /* Just skip the following typespec */\n+    \n+    return objc_skip_typespec (++type);\n+    \n+  default:\n+    abort();\n+  }\n+}\n+\n+/*\n+  Skip an offset as part of a method encoding.  This is prepended by a\n+  '+' if the argument is passed in registers.\n+*/\n+inline const char* \n+objc_skip_offset (const char* type)\n+{\n+  if (*type == '+') type++;\n+  while(isdigit(*++type));\n+  return type;\n+}\n+\n+/*\n+  Skip an argument specification of a method encoding.\n+*/\n+const char*\n+objc_skip_argspec (const char* type)\n+{\n+  type = objc_skip_typespec (type);\n+  type = objc_skip_offset (type);\n+  return type;\n+}\n+\n+/*\n+  Return the number of arguments that the method MTH expects.\n+  Note that all methods need two implicit arguments `self' and\n+  `_cmd'. \n+*/\n+int\n+method_get_number_of_arguments (struct objc_method* mth)\n+{\n+  int i = 0;\n+  const char* type = mth->method_types;\n+  while (*type)\n+    {\n+      type = objc_skip_argspec (type);\n+      i += 1;\n+    }\n+  return i - 1;\n+}\n+\n+/*\n+  Return the size of the argument block needed on the stack to invoke\n+  the method MTH.  This may be zero, if all arguments are passed in\n+  registers.\n+*/\n+\n+int\n+method_get_sizeof_arguments (struct objc_method* mth)\n+{\n+  const char* type = objc_skip_typespec (mth->method_types);\n+  return atoi (type);\n+}\n+\n+/*\n+  Return a pointer to the next argument of ARGFRAME.  type points to\n+  the last argument.  Typical use of this look like:\n+\n+  {\n+    char *datum, *type; \n+    for (datum = method_get_first_argument (method, argframe, &type);\n+         datum; datum = method_get_next_argument (argframe, &type))\n+      {\n+        unsigned flags = objc_get_type_qualifiers (type);\n+        type = objc_skip_type_qualifiers (type);\n+\tif (*type != _C_PTR)\n+          [portal encodeData: datum ofType: type];\n+\telse\n+\t  {\n+\t    if ((flags & _F_IN) == _F_IN)\n+              [portal encodeData: *(char**)datum ofType: ++type];\n+\t  }\n+      }\n+  }\n+*/  \n+\n+char*\n+method_get_next_argument (arglist_t argframe,\n+\t\t\t  const char **type)\n+{\n+  const char *t = objc_skip_argspec (*type);\n+\n+  if (*t == '\\0')\n+    return 0;\n+\n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+/*\n+  Return a pointer to the value of the first argument of the method \n+  described in M with the given argumentframe ARGFRAME.  The type\n+  is returned in TYPE.  type must be passed to successive calls of \n+  method_get_next_argument.\n+*/\n+char*\n+method_get_first_argument (struct objc_method* m,\n+\t\t\t   arglist_t argframe, \n+\t\t\t   const char** type)\n+{\n+  *type = m->method_types;\n+  return method_get_next_argument (argframe, type);\n+}\n+\n+/*\n+   Return a pointer to the ARGth argument of the method\n+   M from the frame ARGFRAME.  The type of the argument\n+   is returned in the value-result argument TYPE \n+*/\n+\n+char*\n+method_get_nth_argument (struct objc_method* m,\n+\t\t\t arglist_t argframe, int arg, \n+\t\t\t const char **type)\n+{\n+  const char* t = objc_skip_argspec (m->method_types);\n+\n+  if (arg > method_get_number_of_arguments (m))\n+    return 0;\n+\n+  while (arg--)\n+    t = objc_skip_argspec (t);\n+  \n+  *type = t;\n+  t = objc_skip_typespec (t);\n+\n+  if (*t == '+')\n+    return argframe->arg_regs + atoi (++t);\n+  else\n+    return argframe->arg_ptr + atoi (t);\n+}\n+\n+unsigned\n+objc_get_type_qualifiers (const char* type)\n+{\n+  unsigned res = 0;\n+  BOOL flag = YES;\n+\n+  while (flag)\n+    switch (*type++)\n+      {\n+      case _C_CONST:  res |= _F_CONST; break;\n+      case _C_IN:     res |= _F_IN; break;\n+      case _C_INOUT:  res |= _F_INOUT; break;\n+      case _C_OUT:    res |= _F_OUT; break;\n+      case _C_BYCOPY: res |= _F_BYCOPY; break;\n+      case _C_ONEWAY: res |= _F_ONEWAY; break;\n+      default: flag = NO;\n+    }\n+\n+  return res;\n+}"}, {"sha": "79fdc795ad96205a94ff142462bbff0ce7e9a783", "filename": "gcc/objc/encoding.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b783df230b06493a57c0c66219fdd77db0bdb095/gcc%2Fobjc%2Fencoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b783df230b06493a57c0c66219fdd77db0bdb095/gcc%2Fobjc%2Fencoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.h?ref=b783df230b06493a57c0c66219fdd77db0bdb095", "patch": "@@ -0,0 +1,73 @@\n+/* Encoding of types for Objective C.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+Author: Kresten Krab Thorup\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __encoding_INCLUDE_GNU\n+#define __encoding_INCLUDE_GNU\n+\n+#include \"objc/objc-api.h\"\n+\n+#define _C_CONST    'r'\n+#define _C_IN       'n'\n+#define _C_INOUT    'N'\n+#define _C_OUT      'o'\n+#define _C_BYCOPY   'O'\n+#define _C_ONEWAY   'V'\n+\n+#define _F_CONST    0x01\n+#define _F_IN       0x01\n+#define _F_OUT      0x02\n+#define _F_INOUT    0x03\n+#define _F_BYCOPY   0x04\n+#define _F_ONEWAY   0x08\n+\n+\n+int objc_aligned_size (const char* type);\n+int objc_sizeof_type (const char* type);\n+int objc_alignof_type (const char* type);\n+int objc_aligned_size (const char* type);\n+int objc_promoted_size (const char* type);\n+const char* objc_skip_type_qualifiers (const char* type);\n+const char* objc_skip_typespec (const char* type);\n+const char* objc_skip_offset (const char* type);\n+const char* objc_skip_argspec (const char* type);\n+int method_get_number_of_arguments (struct objc_method*);\n+int method_get_size_of_arguments (struct objc_method*);\n+\n+char* method_get_first_argument (struct objc_method*,\n+\t\t\t\t arglist_t argframe, \n+\t\t\t\t const char** type);\n+char* method_get_next_argument (arglist_t argframe, \n+\t\t\t\tconst char **type);\n+char* method_get_nth_argument (struct objc_method* m, \n+\t\t\t       arglist_t argframe,\n+\t\t\t       int arg, \n+\t\t\t       const char **type);\n+\n+unsigned objc_get_type_qualifiers (const char* type);\n+\n+\n+#endif /* __encoding_INCLUDE_GNU */"}]}