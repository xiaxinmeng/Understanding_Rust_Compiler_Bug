{"sha": "c1a9321f29f76325f6fcf278c60678dcf9c71cde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFhOTMyMWYyOWY3NjMyNWY2ZmNmMjc4YzYwNjc4ZGNmOWM3MWNkZQ==", "commit": {"author": {"name": "Robert Schuster", "email": "robertschuster@fsfe.org", "date": "2006-02-01T13:40:05Z"}, "committer": {"name": "Robert Schuster", "email": "rschuster@gcc.gnu.org", "date": "2006-02-01T13:40:05Z"}, "message": "2006-02-01  Robert Schuster  <robertschuster@fsfe.org>\n\n\t* link.cc:\n\t(_Jv_Linker::find_field_helper): Added checks.\n\t(_Jv_Linker::find_field): Use exception swallowing class resolution\n\tand added early return.\n\t(_Jv_ThrowNoClassDefFoundErrorTrampoline): New function.\n\t(_Jv_Linker::link_symbol_table):  Use exception swallowing class\n\tresolution, added ffi_closure installation routine, use\n\t_Jv_ThrowNoClassDefFoundError for missing static method.\n\t(_Jv_Linker::ensure_class_linked): Added string check which does\n\tnot trigger class resolution.\n\t* java/lang/natClassLoader.cc:\n\t(_Jv_FindClassNoException): New method.\n\t* java/lang/Class.h:\n\t(_Jv_FindClassNoException): New method declaration.\n\t* include/jvm.h:\n\t(_Jv_FindClassNoException): New method declaration.\n\t(_Jv_FindClassFromSignatureNoException): New method declaration.\n\t* prims.cc:\n\t(_Jv_FindClassFromSignatureNoException): New method.\n        * gcj/javaprims.h:\n        (_Jv_equalsUtf8Classname): New method declaration.\n        (_Jv_isPrimitiveOrDerived): Dito.\n        * prims.cc:\n\t(_Jv_equalsUtf8Classnames): New method.\n        (_Jv_isPrimitiveOrDerived): New method.\n        * verify.cc:\n        (ref_intersection::equals): Use new classname comparison method.\n        (type::compatible): Use new classname comparison method. Added\n        check whether LHS' type is java.lang.Object .\n        (type::resolve): Added new optional debug message and simplified\n        if-expression.\n        (type::to_array): Added codepath that generates an array type\n        without resolving the element type.\n\nFrom-SVN: r110474", "tree": {"sha": "331725f44321f544a0c7d62882b65627f0e43522", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/331725f44321f544a0c7d62882b65627f0e43522"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1a9321f29f76325f6fcf278c60678dcf9c71cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a9321f29f76325f6fcf278c60678dcf9c71cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a9321f29f76325f6fcf278c60678dcf9c71cde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a9321f29f76325f6fcf278c60678dcf9c71cde/comments", "author": null, "committer": null, "parents": [{"sha": "168b93e9e32b3b6e95b7e3f149889298a051a935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168b93e9e32b3b6e95b7e3f149889298a051a935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/168b93e9e32b3b6e95b7e3f149889298a051a935"}], "stats": {"total": 541, "additions": 493, "deletions": 48}, "files": [{"sha": "ff1d6dd9a65b78dbd30f114f14e06d613174cd02", "filename": "libjava/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -1,3 +1,39 @@\n+2006-02-01  Robert Schuster  <robertschuster@fsfe.org>\n+\n+\t* link.cc:\n+\t(_Jv_Linker::find_field_helper): Added checks.\n+\t(_Jv_Linker::find_field): Use exception swallowing class resolution\n+\tand added early return.\n+\t(_Jv_ThrowNoClassDefFoundErrorTrampoline): New function.\n+\t(_Jv_Linker::link_symbol_table):  Use exception swallowing class\n+\tresolution, added ffi_closure installation routine, use\n+\t_Jv_ThrowNoClassDefFoundError for missing static method.\n+\t(_Jv_Linker::ensure_class_linked): Added string check which does\n+\tnot trigger class resolution.\n+\t* java/lang/natClassLoader.cc:\n+\t(_Jv_FindClassNoException): New method.\n+\t* java/lang/Class.h:\n+\t(_Jv_FindClassNoException): New method declaration.\n+\t* include/jvm.h:\n+\t(_Jv_FindClassNoException): New method declaration.\n+\t(_Jv_FindClassFromSignatureNoException): New method declaration.\n+\t* prims.cc:\n+\t(_Jv_FindClassFromSignatureNoException): New method.\n+        * gcj/javaprims.h:\n+        (_Jv_equalsUtf8Classname): New method declaration.\n+        (_Jv_isPrimitiveOrDerived): Dito.\n+        * prims.cc:\n+\t(_Jv_equalsUtf8Classnames): New method.\n+        (_Jv_isPrimitiveOrDerived): New method.\n+        * verify.cc:\n+        (ref_intersection::equals): Use new classname comparison method.\n+        (type::compatible): Use new classname comparison method. Added\n+        check whether LHS' type is java.lang.Object .\n+        (type::resolve): Added new optional debug message and simplified\n+        if-expression.\n+        (type::to_array): Added codepath that generates an array type\n+        without resolving the element type.\n+\n 2006-01-31  Mark Wielaard  <mark@klomp.org>\n  \n  \t* NEWS: Add 4.1 updates."}, {"sha": "c4f815f4d6b8c25420fc029814ecc3bbef578bf1", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -566,6 +566,9 @@ class _Jv_Utf8Const\n   friend jboolean _Jv_equalUtf8Consts (const _Jv_Utf8Const*, const _Jv_Utf8Const *);\n   friend jboolean _Jv_equal (_Jv_Utf8Const*, jstring, jint);\n   friend jboolean _Jv_equaln (_Jv_Utf8Const*, jstring, jint);\n+  friend jboolean _Jv_equalUtf8Classnames (const _Jv_Utf8Const*,\n+                                             const _Jv_Utf8Const*);\n+  friend jboolean _Jv_isPrimitiveOrDerived (const _Jv_Utf8Const*);\n   friend _Jv_Utf8Const *_Jv_makeUtf8Const (char*, int);\n   friend _Jv_Utf8Const *_Jv_makeUtf8Const (jstring);\n   friend jstring _Jv_NewStringUtf8Const (_Jv_Utf8Const*);"}, {"sha": "7110971f882004c42b430408b94fd6ff0fa1bd57", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -239,7 +239,7 @@ class _Jv_Linker\n {\n private:\n   static _Jv_Field *find_field_helper(jclass, _Jv_Utf8Const *, _Jv_Utf8Const *,\n-\t\t\t\t      jclass *);\n+\t\t\t\t      jclass, jclass *);\n   static _Jv_Field *find_field(jclass, jclass, jclass *, _Jv_Utf8Const *,\n \t\t\t       _Jv_Utf8Const *);\n   static void prepare_constant_time_tables(jclass);\n@@ -271,7 +271,7 @@ class _Jv_Linker\n   static void print_class_loaded (jclass);\n   static void resolve_class_ref (jclass, jclass *);\n   static void wait_for_state(jclass, int);\n-  static _Jv_word resolve_pool_entry (jclass, int);\n+  static _Jv_word resolve_pool_entry (jclass, int, bool =false);\n   static void resolve_field (_Jv_Field *, java::lang::ClassLoader *);\n   static void verify_type_assertions (jclass);\n };\n@@ -463,9 +463,18 @@ extern \"C\" jobject _Jv_UnwrapJNIweakReference (jobject);\n \n extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t\t     java::lang::ClassLoader *loader);\n+\n+extern jclass _Jv_FindClassNoException (_Jv_Utf8Const *name,\n+\t\t\t     java::lang::ClassLoader *loader);\n+\n extern jclass _Jv_FindClassFromSignature (char *,\n \t\t\t\t\t  java::lang::ClassLoader *loader,\n \t\t\t\t\t  char ** = NULL);\n+\n+extern jclass _Jv_FindClassFromSignatureNoException (char *,\n+\t\t\t\t\t  java::lang::ClassLoader *loader,\n+\t\t\t\t\t  char ** = NULL);\n+\n extern void _Jv_GetTypesFromSignature (jmethodID method,\n \t\t\t\t       jclass declaringClass,\n \t\t\t\t       JArray<jclass> **arg_types_out,\n@@ -643,4 +652,14 @@ _Jv_IsBinaryCompatibilityABI (jclass c)\n   return c->otable_syms || c->atable_syms || c->itable_syms;\n }\n \n+// Returns whether the given class does not really exists (ie. we have no\n+// bytecode) but still allows us to do some very conservative actions.\n+// E.g. throwing a NoClassDefFoundError with the name of the missing\n+// class.\n+extern inline jboolean\n+_Jv_IsPhantomClass (jclass c)\n+{\n+  return c->state == JV_STATE_PHANTOM;\n+}\n+\n #endif /* __JAVA_JVM_H__ */"}, {"sha": "2ddc8e16752edeaf9e47ee84241d6fdce3ce34e8", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -69,7 +69,13 @@ enum\n \n   JV_STATE_ERROR = 12,\n \n-  JV_STATE_DONE = 14\t\t// Must be last.\n+  JV_STATE_PHANTOM = 13,\t// Bytecode is missing. In many cases we can\n+                                // work around that. If not, throw a\n+                                // NoClassDefFoundError.\n+\n+  JV_STATE_DONE = 14,\t\t// Must be last.\n+\n+\n };\n \n struct _Jv_Field;\n@@ -240,6 +246,8 @@ void _Jv_RegisterClassHookDefault (jclass klass);\n void _Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n void _Jv_UnregisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n void _Jv_UnregisterClass (jclass);\n+jclass _Jv_FindClassNoException (_Jv_Utf8Const *name,\n+\t\t      java::lang::ClassLoader *loader);\n jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t      java::lang::ClassLoader *loader);\n jclass _Jv_FindClassInCache (_Jv_Utf8Const *name);\n@@ -263,6 +271,8 @@ jclass _Jv_GetArrayClass (jclass klass, java::lang::ClassLoader *loader);\n jboolean _Jv_IsInterpretedClass (jclass);\n jboolean _Jv_IsBinaryCompatibilityABI (jclass);\n \n+jboolean _Jv_IsPhantomClass (jclass);\n+\n void _Jv_CopyClassesToSystemLoader (gnu::gcj::runtime::SystemClassLoader *);\n \n #ifdef INTERPRETER\n@@ -469,6 +479,8 @@ class java::lang::Class : public java::lang::Object\n   friend void ::_Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n   friend void ::_Jv_UnregisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n   friend void ::_Jv_UnregisterClass (jclass);\n+  friend jclass (::_Jv_FindClassNoException) (_Jv_Utf8Const *name,\n+\t\t\t\t   java::lang::ClassLoader *loader);\n   friend jclass (::_Jv_FindClass) (_Jv_Utf8Const *name,\n \t\t\t\t   java::lang::ClassLoader *loader);\n   friend jclass (::_Jv_FindClassInCache) (_Jv_Utf8Const *name);\n@@ -499,6 +511,8 @@ class java::lang::Class : public java::lang::Object\n   friend jboolean (::_Jv_IsInterpretedClass) (jclass);\n   friend jboolean (::_Jv_IsBinaryCompatibilityABI) (jclass);\n \n+  friend jboolean (::_Jv_IsPhantomClass) (jclass);\n+\n #ifdef INTERPRETER\n   friend void ::_Jv_InitField (jobject, jclass, int);\n "}, {"sha": "04a5bc46310b5b821ad5fffc9228e31d7a73cf11", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -668,8 +668,9 @@ java::lang::Class::finalize (void)\n void\n java::lang::Class::initializeClass (void)\n {\n-  // Short-circuit to avoid needless locking.\n-  if (state == JV_STATE_DONE)\n+  // Short-circuit to avoid needless locking (expression includes\n+  // JV_STATE_PHANTOM and JV_STATE_DONE).\n+  if (state >= JV_STATE_PHANTOM)\n     return;\n \n   // Step 1.  We introduce a new scope so we can synchronize more"}, {"sha": "5f4d957f61cb11f9d87a98ec006f3d5ee64a7d83", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -266,6 +266,30 @@ _Jv_CopyClassesToSystemLoader (gnu::gcj::runtime::SystemClassLoader *loader)\n   system_class_list = SYSTEM_LOADER_INITIALIZED;\n }\n \n+// An internal variant of _Jv_FindClass which simply swallows a\n+// NoClassDefFoundError or a ClassNotFoundException. This gives the\n+// caller a chance to evaluate the situation and behave accordingly.\n+jclass\n+_Jv_FindClassNoException (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n+{\n+  jclass klass;\n+\n+  try\n+    {\n+      klass = _Jv_FindClass(name, loader);\n+    }\n+  catch ( java::lang::NoClassDefFoundError *ncdfe )\n+    {\n+      return NULL;\n+    }\n+  catch ( java::lang::ClassNotFoundException *cnfe )\n+    {\n+      return NULL;\n+    }\n+\n+  return klass;\n+}\n+\n jclass\n _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n {"}, {"sha": "1118d9b8bab9bf28a5463e79abfa6b3b98b8b86c", "filename": "libjava/link.cc", "status": "modified", "additions": 158, "deletions": 33, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -34,6 +34,7 @@ details.  */\n #include <java/lang/NoSuchMethodError.h>\n #include <java/lang/ClassFormatError.h>\n #include <java/lang/IllegalAccessError.h>\n+#include <java/lang/InternalError.h>\n #include <java/lang/AbstractMethodError.h>\n #include <java/lang/NoClassDefFoundError.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n@@ -100,7 +101,7 @@ _Jv_Linker::resolve_field (_Jv_Field *field, java::lang::ClassLoader *loader)\n // superclasses and interfaces.\n _Jv_Field *\n _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n-\t\t\t       _Jv_Utf8Const *type_name,\n+\t\t\t       _Jv_Utf8Const *type_name, jclass type,\n \t\t\t       jclass *declarer)\n {\n   while (search)\n@@ -112,8 +113,26 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n \t  if (! _Jv_equalUtf8Consts (field->name, name))\n \t    continue;\n \n-\t  if (! field->isResolved ())\n-\t    resolve_field (field, search->loader);\n+          // Checks for the odd situation where we were able to retrieve the\n+          // field's class from signature but the resolution of the field itself\n+          // failed which means a different class was resolved.\n+          if (type != NULL)\n+            {\n+              try\n+                {\n+                  resolve_field (field, search->loader);\n+                }\n+              catch (java::lang::Throwable *exc)\n+                {\n+                  java::lang::LinkageError *le = new java::lang::LinkageError\n+\t            (JvNewStringLatin1 \n+                      (\"field type mismatch with different loaders\"));\n+\n+                  le->initCause(exc);\n+\n+                  throw le;\n+                }\n+            }\n \n \t  // Note that we compare type names and not types.  This is\n \t  // bizarre, but we do it because we want to find a field\n@@ -123,7 +142,10 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n \t  // pass in the descriptor and check that way, because when\n \t  // the field is already resolved there is no easy way to\n \t  // find its descriptor again.\n-\t  if (_Jv_equalUtf8Consts (type_name, field->type->name))\n+\t  if ( (field->isResolved () ? \n+                _Jv_equalUtf8Classnames (type_name, field->type->name) :\n+                _Jv_equalUtf8Classnames (\n+                  type_name, (_Jv_Utf8Const *) field->type)) )\n \t    {\n \t      *declarer = search;\n \t      return field;\n@@ -134,7 +156,7 @@ _Jv_Linker::find_field_helper (jclass search, _Jv_Utf8Const *name,\n       for (int i = 0; i < search->interface_count; ++i)\n \t{\n \t  _Jv_Field *result = find_field_helper (search->interfaces[i], name,\n-\t\t\t\t\t\t type_name, declarer);\n+\t\t\t\t\t\t type_name, type, declarer);\n \t  if (result)\n \t    return result;\n \t}\n@@ -175,13 +197,21 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n {\n   // FIXME: this allocates a _Jv_Utf8Const each time.  We should make\n   // it cheaper.\n-  jclass field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n-\t\t\t\t\t\t  klass->loader);\n-  if (field_type == NULL)\n-    throw new java::lang::NoClassDefFoundError(field_name->toString());\n-\n-  _Jv_Field *the_field = find_field_helper (owner, field_name,\n-\t\t\t\t\t    field_type->name, found_class);\n+  // Note: This call will resolve the primitive type names (\"Z\", \"B\", ...) to\n+  // their Java counterparts (\"boolean\", \"byte\", ...) if accessed via\n+  // field_type->name later.  Using these variants of the type name is in turn\n+  // important for the find_field_helper function.  However if the class\n+  // resolution failed then we can only use the already given type name.\n+  jclass field_type \n+    = _Jv_FindClassFromSignatureNoException (field_type_name->chars(),\n+                                             klass->loader);\n+\n+  _Jv_Field *the_field\n+    = find_field_helper (owner, field_name,\n+                         (field_type\n+                           ? field_type->name :\n+                             field_type_name ),\n+                           field_type, found_class);\n \n   if (the_field == 0)\n     {\n@@ -194,6 +224,12 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n       throw new java::lang::NoSuchFieldError (sb->toString());\n     }\n \n+  // Accept it when the field's class could not be resolved.\n+  if (field_type == NULL)\n+    // Silently ignore that we were not able to retrieve the type to make it\n+    // possible to run code which does not access this field.\n+    return the_field;\n+\n   if (_Jv_CheckAccess (klass, *found_class, the_field->flags))\n     {\n       // Note that the field returned by find_field_helper is always\n@@ -221,7 +257,7 @@ _Jv_Linker::find_field (jclass klass, jclass owner,\n }\n \n _Jv_word\n-_Jv_Linker::resolve_pool_entry (jclass klass, int index)\n+_Jv_Linker::resolve_pool_entry (jclass klass, int index, bool lazy)\n {\n   using namespace java::lang::reflect;\n \n@@ -238,13 +274,26 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index)\n \n \tjclass found;\n \tif (name->first() == '[')\n-\t  found = _Jv_FindClassFromSignature (name->chars(),\n-\t\t\t\t\t      klass->loader);\n-\telse\n-\t  found = _Jv_FindClass (name, klass->loader);\n-\n+\t  found = _Jv_FindClassFromSignatureNoException (name->chars(),\n+\t\t                                         klass->loader);\n+        else\n+\t  found = _Jv_FindClassNoException (name, klass->loader);\n+\n+        // If the class could not be loaded a phantom class is created. Any\n+        // function that deals with such a class but cannot do something useful\n+        // with it should just throw a NoClassDefFoundError with the class'\n+        // name.\n \tif (! found)\n-\t  throw new java::lang::NoClassDefFoundError (name->toString());\n+          if (lazy)\n+            {\n+              found = _Jv_NewClass(name, NULL, NULL);\n+              found->state = JV_STATE_PHANTOM;\n+              pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+              pool->data[index].clazz = found;\n+              break;\n+            }\n+          else\n+\t    throw new java::lang::NoClassDefFoundError (name->toString());\n \n \t// Check accessibility, but first strip array types as\n \t// _Jv_ClassNameSamePackage can't handle arrays.\n@@ -286,7 +335,12 @@ _Jv_Linker::resolve_pool_entry (jclass klass, int index)\n \t_Jv_loadIndexes (&pool->data[index],\n \t\t\t class_index,\n \t\t\t name_and_type_index);\n-\tjclass owner = (resolve_pool_entry (klass, class_index)).clazz;\n+\tjclass owner = (resolve_pool_entry (klass, class_index, true)).clazz;\n+\n+        // If a phantom class was resolved our field reference is\n+        // unusable because of the missing class.\n+        if (owner->state == JV_STATE_PHANTOM)\n+          throw new java::lang::NoClassDefFoundError(owner->getName());\n \n \tif (owner != klass)\n \t  _Jv_InitClass (owner);\n@@ -707,12 +761,31 @@ _Jv_GetMethodString (jclass klass, _Jv_Method *meth,\n   return buf->toString();\n }\n \n-void \n+void\n _Jv_ThrowNoSuchMethodError ()\n {\n   throw new java::lang::NoSuchMethodError;\n }\n \n+// A function whose invocation is prepared using libffi. It gets called\n+// whenever a static method of a missing class is invoked. The data argument\n+// holds a reference to a String denoting the missing class.\n+// The prepared function call is stored in a class' atable.\n+void\n+_Jv_ThrowNoClassDefFoundErrorTrampoline(ffi_cif *,\n+                                        void *,\n+                                        void **,\n+                                        void *data)\n+{\n+  throw new java::lang::NoClassDefFoundError((jstring) data);\n+}\n+\n+void\n+_Jv_ThrowNoClassDefFoundError()\n+{\n+  throw new java::lang::NoClassDefFoundError();\n+}\n+\n // Throw a NoSuchFieldError.  Called by compiler-generated code when\n // an otable entry is zero.  OTABLE_INDEX is the index in the caller's\n // otable that refers to the missing field.  This index may be used to\n@@ -723,7 +796,6 @@ _Jv_ThrowNoSuchFieldError (int /* otable_index */)\n   throw new java::lang::NoSuchFieldError;\n }\n \n-\n // This is put in empty vtable slots.\n void\n _Jv_ThrowAbstractMethodError ()\n@@ -1030,21 +1102,65 @@ _Jv_Linker::link_symbol_table (jclass klass)\n        (sym = klass->atable_syms[index]).class_name != NULL;\n        ++index)\n     {\n-      jclass target_class = _Jv_FindClass (sym.class_name, klass->loader);\n+      jclass target_class =\n+        _Jv_FindClassNoException (sym.class_name, klass->loader);\n+\n       _Jv_Method *meth = NULL;            \n       _Jv_Utf8Const *signature = sym.signature;\n \n       // ??? Setting this pointer to null will at least get us a\n       // NullPointerException\n       klass->atable->addresses[index] = NULL;\n-      \n+\n+      // If the target class is missing we prepare a function call\n+      // that throws a NoClassDefFoundError and store the address of\n+      // that newly prepare method in the atable. The user can run\n+      // code in classes where the missing class is part of the\n+      // execution environment as long as it is never referenced.\n       if (target_class == NULL)\n-\tthrow new java::lang::NoClassDefFoundError \n-\t  (_Jv_NewStringUTF (sym.class_name->chars()));\n-      \n+        {\n+          // TODO: The following structs/objects are heap allocated are\n+          // unreachable by the garbage collector:\n+          // - cif, arg_types\n+          // - the Java string inside the if-statement\n+\n+          ffi_closure *closure =\n+            (ffi_closure *) _Jv_Malloc( sizeof( ffi_closure ));\n+          ffi_cif *cif = (ffi_cif *) _Jv_Malloc( sizeof( ffi_cif ));\n+\n+          // Pretends that we want to call a void (*) (void) function via\n+          // ffi_call.\n+          ffi_type **arg_types = (ffi_type **) _Jv_Malloc( sizeof( ffi_type * ));\n+          arg_types[0] = &ffi_type_void;\n+\n+          // Initializes the cif and the closure. If that worked the closure is\n+          // stored as a function pointer in the atable.\n+          if ( ffi_prep_cif(cif, FFI_DEFAULT_ABI, 1,\n+                            &ffi_type_void, arg_types) == FFI_OK\n+               && (ffi_prep_closure \n+                   (closure, cif,\n+                   _Jv_ThrowNoClassDefFoundErrorTrampoline,\n+                   (void *) _Jv_NewStringUtf8Const(sym.class_name))\n+                   == FFI_OK))\n+            {\n+              klass->atable->addresses[index] = (void *) closure;\n+            }\n+          else\n+            {\n+              // If you land here it is possible that your architecture does\n+              // not support the Closure API yet. Let's port it!\n+              java::lang::StringBuffer *buffer = new java::lang::StringBuffer();\n+              buffer->append \n+                (JvNewStringLatin1(\"Error setting up FFI closure\"\n+                                   \" for static method of missing class: \"));\n+              buffer->append (_Jv_NewStringUtf8Const(sym.class_name));\n+\n+              throw new java::lang::InternalError(buffer->toString());\n+            }\n+        }\n       // We're looking for a static field or a static method, and we\n       // can tell which is needed by looking at the signature.\n-      if (signature->first() == '(' && signature->len() >= 2)\n+      else if (signature->first() == '(' && signature->len() >= 2)\n \t{\n  \t  // If the target class does not have a vtable_method_count yet, \n \t  // then we can't tell the offsets for its methods, so we must lay \n@@ -1082,13 +1198,16 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t\t}\n \t    }\n \t  else\n+            // TODO: Use _Jv_ThrowNoClassDefFoundErrorTrampoline to be able\n+            // to print the class name.\n \t    klass->atable->addresses[index]\n-\t      = (void *)_Jv_ThrowNoSuchMethodError;\n+\t\t= (void *) _Jv_ThrowNoClassDefFoundError;\n \n \t  continue;\n \t}\n \n-      // Try fields.\n+      // Try fields only if the target class exists.\n+      if ( target_class != NULL )\n       {\n \twait_for_state(target_class, JV_STATE_PREPARED);\n \tjclass found_class;\n@@ -1453,7 +1572,8 @@ _Jv_Linker::ensure_class_linked (jclass klass)\n \t  for (int index = 1; index < pool->size; ++index)\n \t    {\n \t      if (pool->tags[index] == JV_CONSTANT_Class)\n-\t\tresolve_pool_entry (klass, index);\n+                // Lazily resolve the entries.\n+\t\tresolve_pool_entry (klass, index, true);\n \t    }\n \t}\n \n@@ -1493,8 +1613,13 @@ _Jv_Linker::ensure_class_linked (jclass klass)\n \t      int mod = f->getModifiers ();\n \t      // If we have a static String field with a non-null initial\n \t      // value, we know it points to a Utf8Const.\n-\t      resolve_field(f, klass->loader);\n-\t      if (f->getClass () == &java::lang::String::class$\n+\n+              // Finds out whether we have to initialize a String without the\n+              // need to resolve the field.\n+              if ((f->isResolved()\n+                   ? (f->type == &java::lang::String::class$)\n+                   : _Jv_equalUtf8Classnames((_Jv_Utf8Const *) f->type,\n+                                             java::lang::String::class$.name))\n \t\t  && (mod & java::lang::reflect::Modifier::STATIC) != 0)\n \t\t{\n \t\t  jstring *strp = (jstring *) f->u.addr;"}, {"sha": "0352669315dd0b9f5501e14245746fedcbf7ebf1", "filename": "libjava/prims.cc", "status": "modified", "additions": 146, "deletions": 2, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -49,8 +49,10 @@ details.  */\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/ArithmeticException.h>\n #include <java/lang/ClassFormatError.h>\n+#include <java/lang/ClassNotFoundException.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/NegativeArraySizeException.h>\n+#include <java/lang/NoClassDefFoundError.h>\n #include <java/lang/NullPointerException.h>\n #include <java/lang/OutOfMemoryError.h>\n #include <java/lang/System.h>\n@@ -168,7 +170,6 @@ SIGNAL_HANDLER (catch_fpe)\n }\n #endif\n \n-\f\n \n jboolean\n _Jv_equalUtf8Consts (const Utf8Const* a, const Utf8Const *b)\n@@ -236,6 +237,120 @@ _Jv_equaln (Utf8Const *a, jstring str, jint n)\n   return true;\n }\n \n+// Determines whether the given Utf8Const object contains\n+// a type which is primitive or some derived form of it, eg.\n+// an array or multi-dimensional array variant.\n+jboolean\n+_Jv_isPrimitiveOrDerived(const Utf8Const *a)\n+{\n+  unsigned char *aptr = (unsigned char *) a->data;\n+  unsigned char *alimit = aptr + a->length;\n+  int ac = UTF8_GET(aptr, alimit);\n+\n+  // Skips any leading array marks.\n+  while (ac == '[')\n+    ac = UTF8_GET(aptr, alimit);\n+\n+  // There should not be another character. This implies that\n+  // the type name is only one character long.\n+  if (UTF8_GET(aptr, alimit) == -1)\n+    switch ( ac )\n+      {\n+        case 'Z':\n+        case 'B':\n+        case 'C':\n+        case 'S':\n+        case 'I':\n+        case 'J':\n+        case 'F':\n+        case 'D':\n+          return true;\n+        default:\n+          break;\n+       }\n+\n+   return false;\n+}\n+\n+// Find out whether two _Jv_Utf8Const candidates contain the same\n+// classname.\n+// The method is written to handle the different formats of classnames.\n+// Eg. \"Ljava/lang/Class;\", \"Ljava.lang.Class;\", \"java/lang/Class\" and\n+// \"java.lang.Class\" will be seen as equal.\n+// Warning: This function is not smart enough to declare \"Z\" and \"boolean\"\n+// and similar cases as equal (and is not meant to be used this way)!\n+jboolean\n+_Jv_equalUtf8Classnames (const Utf8Const *a, const Utf8Const *b)\n+{\n+  // If the class name's length differs by two characters\n+  // it is possible that we have candidates which are given\n+  // in the two different formats (\"Lp1/p2/cn;\" vs. \"p1/p2/cn\")\n+  switch (a->length - b->length)\n+    {\n+      case -2:\n+      case 0:\n+      case 2:\n+        break;\n+      default:\n+        return false;\n+    }\n+\n+  unsigned char *aptr = (unsigned char *) a->data;\n+  unsigned char *alimit = aptr + a->length;\n+  unsigned char *bptr = (unsigned char *) b->data;\n+  unsigned char *blimit = bptr + b->length;\n+\n+  if (alimit[-1] == ';')\n+    alimit--;\n+\n+  if (blimit[-1] == ';')\n+    blimit--;\n+\n+  int ac = UTF8_GET(aptr, alimit);\n+  int bc = UTF8_GET(bptr, blimit);\n+\n+  // Checks whether both strings have the same amount of leading [ characters.\n+  while (ac == '[')\n+    {\n+      if (bc == '[')\n+        {\n+          ac = UTF8_GET(aptr, alimit);\n+          bc = UTF8_GET(bptr, blimit);\n+          continue;\n+        }\n+\n+      return false;\n+    }\n+\n+  // Skips leading L character.\n+  if (ac == 'L')\n+    ac = UTF8_GET(aptr, alimit);\n+        \n+  if (bc == 'L')\n+    bc = UTF8_GET(bptr, blimit);\n+\n+  // Compares the remaining characters.\n+  while (ac != -1 && bc != -1)\n+    {\n+      // Replaces package separating dots with slashes.\n+      if (ac == '.')\n+        ac = '/';\n+\n+      if (bc == '.')\n+        bc = '/';\n+      \n+      // Now classnames differ if there is at least one non-matching\n+      // character.\n+      if (ac != bc)\n+        return false;\n+\n+      ac = UTF8_GET(aptr, alimit);\n+      bc = UTF8_GET(bptr, blimit);\n+    }\n+\n+  return (ac == bc);\n+}\n+\n /* Count the number of Unicode chars encoded in a given Ut8 string. */\n int\n _Jv_strLengthUtf8(char* str, int len)\n@@ -434,6 +549,9 @@ _Jv_AllocObjectNoInitNoFinalizer (jclass klass)\n jobject\n _Jv_AllocObjectNoFinalizer (jclass klass)\n {\n+  if (_Jv_IsPhantomClass(klass) )\n+    throw new java::lang::NoClassDefFoundError(klass->getName());\n+\n   _Jv_InitClass (klass);\n   jint size = klass->size ();\n   jobject obj = (jobject) _Jv_AllocObj (size, klass);\n@@ -512,6 +630,11 @@ _Jv_AllocPtrFreeObject (jclass klass)\n jobjectArray\n _Jv_NewObjectArray (jsize count, jclass elementClass, jobject init)\n {\n+  // Creating an array of an unresolved type is impossible. So we throw\n+  // the NoClassDefFoundError.\n+  if ( _Jv_IsPhantomClass(elementClass) )\n+    throw new java::lang::NoClassDefFoundError(elementClass->getName());\n+\n   if (__builtin_expect (count < 0, false))\n     throw new java::lang::NegativeArraySizeException;\n \n@@ -766,7 +889,28 @@ _Jv_FindClassFromSignature (char *sig, java::lang::ClassLoader *loader,\n   return result;\n }\n \n-\f\n+\n+jclass\n+_Jv_FindClassFromSignatureNoException (char *sig, java::lang::ClassLoader *loader,\n+                                       char **endp)\n+{\n+  jclass klass;\n+\n+  try\n+    {\n+      klass = _Jv_FindClassFromSignature(sig, loader, endp);\n+    }\n+  catch (java::lang::NoClassDefFoundError *ncdfe)\n+    {\n+      return NULL;\n+    }\n+  catch (java::lang::ClassNotFoundException *cnfe)\n+    {\n+      return NULL;\n+    }\n+\n+  return klass;\n+}\n \n JArray<jstring> *\n JvConvertArgv (int argc, const char **argv)"}, {"sha": "4df6ead95c5215e40a4c22e6f29e9a84cef8d5a2", "filename": "libjava/verify.cc", "status": "modified", "additions": 87, "deletions": 8, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1a9321f29f76325f6fcf278c60678dcf9c71cde/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=c1a9321f29f76325f6fcf278c60678dcf9c71cde", "patch": "@@ -14,6 +14,8 @@ details.  */\n \n #include <config.h>\n \n+#include <string.h>\n+\n #include <jvm.h>\n #include <gcj/cni.h>\n #include <java-insns.h>\n@@ -324,7 +326,7 @@ class _Jv_BytecodeVerifier\n     bool equals (ref_intersection *other, _Jv_BytecodeVerifier *verifier)\n     {\n       if (! is_resolved && ! other->is_resolved\n-\t  && _Jv_equalUtf8Consts (data.name, other->data.name))\n+\t  && _Jv_equalUtf8Classnames (data.name, other->data.name))\n \treturn true;\n       if (! is_resolved)\n \tresolve (verifier);\n@@ -364,11 +366,18 @@ class _Jv_BytecodeVerifier\n       if (is_resolved)\n \treturn;\n \n+      // This is useful if you want to see which classes have to be resolved\n+      // while doing the class verification.\n+      debug_print(\"resolving class: %s\\n\", data.name->chars());\n+\n       using namespace java::lang;\n       java::lang::ClassLoader *loader\n \t= verifier->current_class->getClassLoaderInternal();\n-      // We might see either kind of name.  Sigh.\n-      if (data.name->first() == 'L' && data.name->limit()[-1] == ';')\n+\n+      // Due to special handling in to_array() array classes will always\n+      // be of the \"L ... ;\" kind. The separator char ('.' or '/' may vary\n+      // however.\n+      if (data.name->limit()[-1] == ';')\n \t{\n \t  data.klass = _Jv_FindClassFromSignature (data.name->chars(), loader);\n \t  if (data.klass == NULL)\n@@ -397,12 +406,21 @@ class _Jv_BytecodeVerifier\n \t      // Avoid resolving if possible.\n \t      if (! self->is_resolved\n \t\t  && ! other_iter->is_resolved\n-\t\t  && _Jv_equalUtf8Consts (self->data.name,\n-\t\t\t\t\t  other_iter->data.name))\n+\t\t  && _Jv_equalUtf8Classnames (self->data.name,\n+\t\t \t\t\t      other_iter->data.name))\n \t\tcontinue;\n \n \t      if (! self->is_resolved)\n \t\tself->resolve(verifier);\n+\n+              // If the LHS of the expression is of type\n+              // java.lang.Object, assignment will succeed, no matter\n+              // what the type of the RHS is. Using this short-cut we\n+              // don't need to resolve the class of the RHS at\n+              // verification time.\n+              if (self->data.klass == &java::lang::Object::class$)\n+                continue;\n+\n \t      if (! other_iter->is_resolved)\n \t\tother_iter->resolve(verifier);\n \n@@ -852,9 +870,70 @@ class _Jv_BytecodeVerifier\n       if (key != reference_type)\n \tverifier->verify_fail (\"internal error in type::to_array()\");\n \n-      jclass k = klass->getclass (verifier);\n-      return type (_Jv_GetArrayClass (k, k->getClassLoaderInternal()),\n-\t\t   verifier);\n+      // In case the class is already resolved we can simply ask the runtime\n+      // to give us the array version.\n+      // If it is not resolved we prepend \"[\" to the classname to make the\n+      // array usage verification more lazy. In other words: makes new Foo[300]\n+      // pass the verifier if Foo.class is missing.\n+      if (klass->is_resolved)\n+        {\n+          jclass k = klass->getclass (verifier);\n+\n+          return type (_Jv_GetArrayClass (k, k->getClassLoaderInternal()),\n+\t\t       verifier);\n+        }\n+      else\n+        {\n+          int len = klass->data.name->len();\n+\n+          // If the classname is given in the Lp1/p2/cn; format we only need\n+          // to add a leading '['. The same procedure has to be done for\n+          // primitive arrays (ie. provided \"[I\", the result should be \"[[I\".\n+          // If the classname is given as p1.p2.cn we have to embed it into\n+          // \"[L\" and ';'.\n+          if (klass->data.name->limit()[-1] == ';' ||\n+               _Jv_isPrimitiveOrDerived(klass->data.name))\n+            {\n+              // Reserves space for leading '[' and trailing '\\0' .\n+              char arrayName[len + 2];\n+\n+              arrayName[0] = '[';\n+              strcpy(&arrayName[1], klass->data.name->chars());\n+\n+#ifdef VERIFY_DEBUG\n+              // This is only needed when we want to print the string to the\n+              // screen while debugging.\n+              arrayName[len + 1] = '\\0';\n+\n+              debug_print(\"len: %d - old: '%s' - new: '%s'\\n\", len, klass->data.name->chars(), arrayName);\n+#endif\n+\n+              return type (verifier->make_utf8_const( arrayName, len + 1 ),\n+                           verifier);\n+            }\n+           else\n+            {\n+              // Reserves space for leading \"[L\" and trailing ';' and '\\0' .\n+              char arrayName[len + 4];\n+\n+              arrayName[0] = '[';\n+              arrayName[1] = 'L';\n+              strcpy(&arrayName[2], klass->data.name->chars());\n+              arrayName[len + 2] = ';';\n+\n+#ifdef VERIFY_DEBUG\n+              // This is only needed when we want to print the string to the\n+              // screen while debugging.\n+              arrayName[len + 3] = '\\0';\n+\n+              debug_print(\"len: %d - old: '%s' - new: '%s'\\n\", len, klass->data.name->chars(), arrayName);\n+#endif\n+\n+              return type (verifier->make_utf8_const( arrayName, len + 3 ),\n+                           verifier);\n+            }\n+        }\n+\n     }\n \n     bool isreference () const"}]}