{"sha": "d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQyMjk4MGIzZjNkNTBhMzRmOTFmZGY1Yzg0M2IxNGQzZjU5ZmM0Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-05-24T23:09:53Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-05-24T23:09:53Z"}, "message": "basic_ios.tcc: Small tweak.\n\n\n2001-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/2832\n\t* include/bits/basic_ios.tcc: Small tweak.\n\t* include/bits/std_fstream.h (ifstream): Add buffer member. Adjust\n\tctors and dtors, and rdbuf settings.\n\t(ofstream): Same.\n\t(fstream): Same.\n\t* include/bits/std_sstream.h: Same, but for stringstream classes.\n\t* testsuite/27_io/ostringstream_members.cc: New.\n\t* testsuite/27_io/stringstream_members.cc: New.\n\t* testsuite/27_io/fstream_members.cc: New.\n\t* testsuite/27_io/ifstream_members.cc: Add test.\n\t* testsuite/27_io/istringstream_members.cc: Add test.\n\t* testsuite/27_io/ofstream_members.cc: Add test.\n\nFrom-SVN: r42547", "tree": {"sha": "3975f4738acb72cc4f7e5793c2818e975ac86248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3975f4738acb72cc4f7e5793c2818e975ac86248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/comments", "author": null, "committer": null, "parents": [{"sha": "476c334ecf62dda42aaa30728ee03cf314fe947e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476c334ecf62dda42aaa30728ee03cf314fe947e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476c334ecf62dda42aaa30728ee03cf314fe947e"}], "stats": {"total": 654, "additions": 559, "deletions": 95}, "files": [{"sha": "afe93e7c82344294c596ac5ff8cbaf9777600c7c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -1,3 +1,19 @@\n+2001-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/2832\n+\t* include/bits/basic_ios.tcc: Small tweak.\n+\t* include/bits/std_fstream.h (ifstream): Add buffer member. Adjust\n+\tctors and dtors, and rdbuf settings.\n+\t(ofstream): Same.\n+\t(fstream): Same.\n+\t* include/bits/std_sstream.h: Same, but for stringstream classes.\n+\t* testsuite/27_io/ostringstream_members.cc: New.\n+\t* testsuite/27_io/stringstream_members.cc: New.\t\n+\t* testsuite/27_io/fstream_members.cc: New.\t\t\n+\t* testsuite/27_io/ifstream_members.cc: Add test.\n+\t* testsuite/27_io/istringstream_members.cc: Add test.\n+\t* testsuite/27_io/ofstream_members.cc: Add test.\n+\n 2001-05-24  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t* include/bits/c++config(__NO_MATH_INLINES): Move to..."}, {"sha": "f1b634744c82572c05904a0344bfeea24d8ddf50", "filename": "libstdc++-v3/include/bits/basic_ios.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -132,6 +132,6 @@ namespace std {\n \n } // namespace std\n \n-#endif /* _CPP_BITS_BASICIOS_TCC */\n+#endif // _CPP_BITS_BASICIOS_TCC\n \n "}, {"sha": "a06721f6cf8cf30a2aa6da0f3529305ab195ae1d", "filename": "libstdc++-v3/include/bits/std_fstream.h", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -244,41 +244,45 @@ namespace std\n       typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n       typedef basic_istream<char_type, traits_type>\t__istream_type;\n     \n-      // Constructors/Destructors:\n+    private:\n+      __filebuf_type\t_M_filebuf;\n+\n+    public:\n+     // Constructors/Destructors:\n       basic_ifstream()\n-      : __istream_type(new __filebuf_type())\n-      { }\n+      : __istream_type(NULL), _M_filebuf()\n+      { this->init(&_M_filebuf); }\n \n       explicit \n       basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)\n-      : __istream_type(new __filebuf_type())\n-      { this->open(__s, __mode); }\n-    \n-      ~basic_ifstream()\n+      : __istream_type(NULL), _M_filebuf()\n       { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n+\tthis->init(&_M_filebuf); \n+\tthis->open(__s, __mode); \n       }\n+    \n+      ~basic_ifstream()\n+      { }\n \n       // Members:\n       __filebuf_type* \n       rdbuf() const \n-      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+      { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       bool \n-      is_open(void) { return rdbuf()->is_open(); }\n+      is_open(void) { return _M_filebuf.is_open(); }\n \n       void \n       open(const char* __s, ios_base::openmode __mode = ios_base::in)\n       { \n-\tif (rdbuf()->open(__s, __mode | ios_base::in) == NULL)\n+\tif (_M_filebuf.open(__s, __mode | ios_base::in) == NULL)\n \t  this->setstate(ios_base::failbit); \n       }\n \n       void \n       close(void)\n       { \n-\tif (!rdbuf()->close())\n+\tif (!_M_filebuf.close())\n \t  this->setstate(ios_base::failbit);\t\n       }\n     };\n@@ -300,43 +304,47 @@ namespace std\n       typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n       typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n       \n+    private:\n+      __filebuf_type\t_M_filebuf;\n+\n+    public:\n       // Constructors:\n       basic_ofstream()\n-      : __ostream_type(new __filebuf_type())\n-      { }\n+      : __ostream_type(NULL), _M_filebuf()\n+      { this->init(&_M_filebuf); }\n       \n       explicit \n       basic_ofstream(const char* __s, \n \t\t     ios_base::openmode __mode = ios_base::out|ios_base::trunc)\n-      : __ostream_type(new __filebuf_type())\n-      { this->open(__s, __mode); }\n-\n-      ~basic_ofstream()\n+      : __ostream_type(NULL), _M_filebuf()\n       { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n+\tthis->init(&_M_filebuf); \n+\tthis->open(__s, __mode); \n       }\n \n+      ~basic_ofstream()\n+      { }\n+\n       // Members:\n       __filebuf_type* \n       rdbuf(void) const\n-      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+      { return const_cast<__filebuf_type*>(&_M_filebuf); }\n  \n       bool \n-      is_open(void) { return rdbuf()->is_open(); }\n+      is_open(void) { return _M_filebuf.is_open(); }\n \n       void \n       open(const char* __s, \n \t   ios_base::openmode __mode = ios_base::out | ios_base::trunc)\n       { \n-\tif (!rdbuf()->open(__s, __mode | ios_base::out))\n+\tif (!_M_filebuf.open(__s, __mode | ios_base::out))\n \t  this->setstate(ios_base::failbit); \n       }\n \n       void \n       close(void)\n       { \n-\tif (!rdbuf()->close())\n+\tif (!_M_filebuf.close())\n \t  setstate(ios_base::failbit); \n       }\n     };\n@@ -359,44 +367,48 @@ namespace std\n       typedef basic_ios<char_type, traits_type>\t\t__ios_type;\n       typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n \n+    private:\n+      __filebuf_type\t_M_filebuf;\n+      \n+    public:\n       // Constructors/destructor:\n       basic_fstream()\n-      : __iostream_type(new __filebuf_type())\n-      { }\n+      : __iostream_type(NULL), _M_filebuf()\n+      { this->init(&_M_filebuf); }\n \n       explicit \n       basic_fstream(const char* __s,\n \t\t    ios_base::openmode __mode = ios_base::in | ios_base::out)\n-      : __iostream_type(new __filebuf_type())\n-      { this->open(__s, __mode); }\n-\n-      ~basic_fstream()\n+      : __iostream_type(NULL), _M_filebuf()\n       { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n+\tthis->init(&_M_filebuf); \n+\tthis->open(__s, __mode); \n       }\n+ \n+      ~basic_fstream()\n+      { }\n     \n       // Members:\n       __filebuf_type* \n       rdbuf(void) const \n-      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+      { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       bool \n-      is_open(void) { return rdbuf()->is_open(); }\n+      is_open(void) { return _M_filebuf.is_open(); }\n \n       void \n       open(const char* __s, \n \t   ios_base::openmode __mode = ios_base::in | ios_base::out)\n       { \n-\tif (!rdbuf()->open(__s, __mode))\n-\t  setstate (ios_base::failbit); \n+\tif (!_M_filebuf.open(__s, __mode))\n+\t  setstate(ios_base::failbit); \n       }\n \n       void \n       close(void)\n       { \n-\tif (!rdbuf()->close())\n-\t  setstate (ios_base::failbit); \n+\tif (!_M_filebuf.close())\n+\t  setstate(ios_base::failbit); \n       }\n     };\n } // namespace std"}, {"sha": "ca347dc326c5c34a5aada27cac1826720b3df992", "filename": "libstdc++-v3/include/bits/std_sstream.h", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -203,37 +203,37 @@ namespace std\n       typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n       typedef basic_istream<char_type, traits_type>\t__istream_type;\n \n+    private:\n+      __stringbuf_type\t_M_stringbuf;\n+\n+    public:\n       // Constructors:\n       explicit \n       basic_istringstream(ios_base::openmode __mode = ios_base::in)\n-      : __istream_type(new __stringbuf_type(__mode | ios_base::in))\n-      { }\n+      : __istream_type(NULL), _M_stringbuf(__mode | ios_base::in)\n+      { this->init(&_M_stringbuf); }\n \n       explicit \n       basic_istringstream(const __string_type& __str,\n \t\t\t  ios_base::openmode __mode = ios_base::in)\n-      : __istream_type(new __stringbuf_type(__str, __mode | ios_base::in))\n-      { }\n+      : __istream_type(NULL), _M_stringbuf(__str, __mode | ios_base::in)\n+      { this->init(&_M_stringbuf); }\n \n       ~basic_istringstream()\n-      { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n-      }\n+      { }\n \n       // Members:\n       __stringbuf_type* \n       rdbuf() const\n-      { return static_cast<__stringbuf_type*>(_M_streambuf); }\n+      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n       __string_type\n       str() const\n-      { return this->rdbuf()->str(); }\n+      { return _M_stringbuf.str(); }\n   \n       void \n       str(const __string_type& __s)\n-      { rdbuf()->str(__s); }\n-\n+      { _M_stringbuf.str(__s); }\n     };\n \n \n@@ -254,37 +254,37 @@ namespace std\n       typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n       typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n \n-      // Constructors/destructor:\n+    private:\n+      __stringbuf_type\t_M_stringbuf;\n+\n+    public:\n+     // Constructors/destructor:\n       explicit \n       basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n-      : __ostream_type(new __stringbuf_type(__mode | ios_base::out))\n-      { }\n+      : __ostream_type(NULL), _M_stringbuf(__mode | ios_base::out)\n+      { this->init(&_M_stringbuf); }\n \n       explicit \n       basic_ostringstream(const __string_type __str,\n \t\t\t  ios_base::openmode __mode = ios_base::out)\n-      : __ostream_type(new __stringbuf_type(__str, __mode | ios_base::out))\n-      { }\n+      : __ostream_type(NULL), _M_stringbuf(__str, __mode | ios_base::out)\n+      { this->init(&_M_stringbuf); }\n \n       ~basic_ostringstream()\n-      { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n-      }\n+      { }\n \n       // Members:\n       __stringbuf_type* \n       rdbuf() const\n-      { return static_cast<__stringbuf_type*>(_M_streambuf); }\n+      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n       __string_type\n       str() const\n-      { return this->rdbuf()->str(); }\n+      { return _M_stringbuf.str(); }\n  \n       void \n       str(const __string_type& __s)\n-      { rdbuf()->str(__s); }\n-\n+      { _M_stringbuf.str(__s); }\n     };\n   \n   \n@@ -304,41 +304,39 @@ namespace std\n       typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n       typedef basic_stringbuf<_CharT, _Traits, _Alloc> \t__stringbuf_type;\n       typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n-     \n+\n+    private:\n+      __stringbuf_type\t_M_stringbuf;\n+\n+    public:\n       // Constructors/destructors\n       explicit \n-      basic_stringstream(ios_base::openmode __mode = \n-\t\t\t ios_base::out | ios_base::in)\n-      : __iostream_type(new __stringbuf_type(__mode))\n-      { }\n+      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n+      : __iostream_type(NULL), _M_stringbuf(__m)\n+      { this->init(&_M_stringbuf); }\n \n       explicit \n       basic_stringstream(const __string_type& __str,\n-\t\t\t ios_base::openmode __mode = \n-\t\t\t ios_base::out | ios_base::in)\n-      : __iostream_type(new __stringbuf_type(__str, __mode))\n-      { }\n+\t\t\t ios_base::openmode __m = ios_base::out | ios_base::in)\n+      : __iostream_type(NULL), _M_stringbuf(__str, __m)\n+      { this->init(&_M_stringbuf); }\n \n       ~basic_stringstream()\n-      { \n-\tdelete _M_streambuf; \n-\t_M_streambuf = NULL;\n-      }\n+      { }\n \n       // Members:\n       __stringbuf_type* \n       rdbuf() const\n-      { return static_cast<__stringbuf_type*>(_M_streambuf); }\n+      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n       __string_type\n       str() const\n-      { return rdbuf()->str(); }\n+      { return _M_stringbuf.str(); }\n \n       void \n       str(const __string_type& __s)\n-      { rdbuf()->str(__s); }\n+      { _M_stringbuf.str(__s); }\n     };\n-\n } // namespace std\n \n \n@@ -350,5 +348,5 @@ namespace std\n #endif\n #endif\n \n-#endif\t/* _CPP_SSTREAM */\n+#endif\t// _CPP_SSTREAM\n "}, {"sha": "13520119f8d85fcc300cacb0d25b93daaa4a7ffc", "filename": "libstdc++-v3/testsuite/27_io/fstream_members.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -0,0 +1,70 @@\n+// 2001-05-24 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.8.1.13 member functions (fstream_members)\n+\n+#include <fstream>\n+#include <debug_assert.h>\n+\n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::filebuf fbuf;\n+  std::streambuf* pbasebuf0 = &fbuf;\n+\n+  std::fstream sstrm1;\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::filebuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &fbuf);\n+  std::filebuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n+\n+int main()\n+{\n+  test02();\n+  return 0;\n+}\n+\n+\n+"}, {"sha": "6a4961a82a1cdcebabb6fd4a13ab0818bd3efd8e", "filename": "libstdc++-v3/testsuite/27_io/ifstream_members.cc", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -73,10 +73,51 @@ bool test01()\n   return test;\n }\n \n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::filebuf fbuf;\n+  std::streambuf* pbasebuf0 = &fbuf;\n+\n+  std::ifstream sstrm1;\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::filebuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &fbuf);\n+  std::filebuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n \n int main()\n {\n   test00();\n   test01();\n+\n+  test02();\n   return 0;\n }\n+\n+\n+"}, {"sha": "58885b934e790ea6eb6832c85b7f208664193f8c", "filename": "libstdc++-v3/testsuite/27_io/istringstream_members.cc", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -1,6 +1,6 @@\n // 2000-01-10 bkoz\n \n-// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,19 +18,16 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-// 27.7.2 template class basic_istringstream\n // 27.7.2.2 member functions (istringstream_members)\n \n-// stringbuf* rdbuf() const\n-\n #include <sstream>\n #include <debug_assert.h>\n \n-\n void test01()\n {\n   bool test = true;\n   std::istringstream is01;\n+  const std::string str00; \n   const std::string str01 = \"123\";\n   std::string str02;\n   const int i01 = 123;\n@@ -39,9 +36,15 @@ void test01()\n   std::ios_base::iostate state1, state2, statefail, stateeof;\n   statefail = std::ios_base::failbit;\n   stateeof = std::ios_base::eofbit;\n-  \n+\n+  // string str() const\n+  str02 = is01.str();\n+  VERIFY( str00 == str02 );\n+\n   // void str(const basic_string&)\n   is01.str(str01);\n+  str02 = is01.str();\n+  VERIFY( str01 == str02 );\n   state1 = is01.rdstate();\n   is01 >> a;\n   state2 = is01.rdstate();\n@@ -66,17 +69,63 @@ void test01()\n   VERIFY( state1 != state2 );\n   VERIFY( state2 == stateeof ); \n \n-  // string str() const\n-  str02 = is01.str();\n-  VERIFY( str01 == str02 );\n-\n  #ifdef DEBUG_ASSERT\n   assert(test);\n #endif\n }\n \n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::stringbuf sbuf(str01);\n+  std::streambuf* pbasebuf0 = &sbuf;\n+\n+  std::istringstream sstrm1;\n+  VERIFY( sstrm1.str() == str00 );\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::stringbuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &sbuf);\n+  std::stringbuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // derived rdbuf() returns the original buf, so str() doesn't change.\n+  VERIFY( sstrm1.str() != str01 );\n+  VERIFY( sstrm1.str() == str00 );\n+  // however, casting the active streambuf to a stringbuf shows what's up:\n+  std::stringbuf* psbuf = dynamic_cast<std::stringbuf*>(pbasebuf2);\n+  str02 = psbuf->str();\n+  VERIFY( str02 == str01 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n   return 0;\n }\n+\n+\n+"}, {"sha": "7a10072b94d4f7882d31ecf92dfff526385ecf1a", "filename": "libstdc++-v3/testsuite/27_io/ofstream_members.cc", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -74,9 +74,51 @@ bool test01()\n   return test;\n }\n \n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::filebuf fbuf;\n+  std::streambuf* pbasebuf0 = &fbuf;\n+\n+  std::ofstream sstrm1;\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::filebuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &fbuf);\n+  std::filebuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n+\n int main()\n {\n   test00();\n   test01();\n+\n+  test02();\n   return 0;\n }\n+\n+\n+"}, {"sha": "856544cb6255b02d10d9cb085defad6b8e80f008", "filename": "libstdc++-v3/testsuite/27_io/ostringstream_members.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -0,0 +1,105 @@\n+// 2001-05-23 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.7.3.2 member functions (ostringstream_members)\n+\n+#include <sstream>\n+#include <debug_assert.h>\n+\n+void test01()\n+{\n+  bool test = true;\n+  std::ostringstream os01;\n+  const std::string str00; \n+  const std::string str01 = \"123\";\n+  std::string str02;\n+  const int i01 = 123;\n+  int a,b;\n+\n+  std::ios_base::iostate state1, state2, statefail, stateeof;\n+  statefail = std::ios_base::failbit;\n+  stateeof = std::ios_base::eofbit;\n+\n+  // string str() const\n+  str02 = os01.str();\n+  VERIFY( str00 == str02 );\n+\n+  // void str(const basic_string&)\n+  os01.str(str01);\n+  str02 = os01.str();\n+  VERIFY( str01 == str02 );\n+\n+ #ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n+\n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::stringbuf sbuf(str01);\n+  std::streambuf* pbasebuf0 = &sbuf;\n+\n+  std::ostringstream sstrm1;\n+  VERIFY( sstrm1.str() == str00 );\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::stringbuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &sbuf);\n+  std::stringbuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // derived rdbuf() returns the original buf, so str() doesn't change.\n+  VERIFY( sstrm1.str() != str01 );\n+  VERIFY( sstrm1.str() == str00 );\n+  // however, casting the active streambuf to a stringbuf shows what's up:\n+  std::stringbuf* psbuf = dynamic_cast<std::stringbuf*>(pbasebuf2);\n+  str02 = psbuf->str();\n+  VERIFY( str02 == str01 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5b3ead1b2d075b65b315c6dc655c0f3cf27b0f23", "filename": "libstdc++-v3/testsuite/27_io/stringstream_members.cc", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d422980b3f3d50a34f91fdf5c843b14d3f59fc4c/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc?ref=d422980b3f3d50a34f91fdf5c843b14d3f59fc4c", "patch": "@@ -0,0 +1,131 @@\n+// 2001-05-24 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 27.7.6 member functions (stringstream_members)\n+\n+#include <sstream>\n+#include <debug_assert.h>\n+\n+void test01()\n+{\n+  bool test = true;\n+  std::stringstream is01;\n+  const std::string str00; \n+  const std::string str01 = \"123\";\n+  std::string str02;\n+  const int i01 = 123;\n+  int a,b;\n+\n+  std::ios_base::iostate state1, state2, statefail, stateeof;\n+  statefail = std::ios_base::failbit;\n+  stateeof = std::ios_base::eofbit;\n+\n+  // string str() const\n+  str02 = is01.str();\n+  VERIFY( str00 == str02 );\n+\n+  // void str(const basic_string&)\n+  is01.str(str01);\n+  str02 = is01.str();\n+  VERIFY( str01 == str02 );\n+  state1 = is01.rdstate();\n+  is01 >> a;\n+  state2 = is01.rdstate();\n+  VERIFY( a = i01 );\n+  // 22.2.2.1.2 num_get virtual functions\n+  // p 13\n+  // in any case, if stage 2 processing was terminated by the test for\n+  // in == end then err != ios_base::eofbit is performed.\n+  VERIFY( state1 != state2 );\n+  VERIFY( state2 == stateeof ); \n+\n+  is01.str(str01);\n+  is01 >> b;\n+  VERIFY( b != a ); \n+  // as is01.good() is false, istream::sentry blocks extraction.\n+\n+  is01.clear();\n+  state1 = is01.rdstate();\n+  is01 >> b;\n+  state2 = is01.rdstate();\n+  VERIFY( b == a ); \n+  VERIFY( state1 != state2 );\n+  VERIFY( state2 == stateeof ); \n+\n+ #ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n+\n+void \n+redirect_buffer(std::ios& stream, std::streambuf* new_buf) \n+{ stream.rdbuf(new_buf); }\n+\n+std::streambuf*\n+active_buffer(std::ios& stream)\n+{ return stream.rdbuf(); }\n+\n+// libstdc++/2832\n+void test02()\n+{\n+  bool test = true;\n+  const char* strlit01 = \"fuck war\";\n+  const char* strlit02 = \"two less cars abstract riot crew, critical mass/SF\";\n+  const std::string str00;\n+  const std::string str01(strlit01);\n+  std::string str02;\n+  std::stringbuf sbuf(str01);\n+  std::streambuf* pbasebuf0 = &sbuf;\n+\n+  std::stringstream sstrm1;\n+  VERIFY( sstrm1.str() == str00 );\n+  // derived rdbuf() always returns original streambuf, even though\n+  // it's no longer associated with the stream.\n+  std::stringbuf* const buf1 = sstrm1.rdbuf();\n+  // base rdbuf() returns the currently associated streambuf\n+  std::streambuf* pbasebuf1 = active_buffer(sstrm1);\n+  redirect_buffer(sstrm1, &sbuf);\n+  std::stringbuf* const buf2 = sstrm1.rdbuf();\n+  std::streambuf* pbasebuf2 = active_buffer(sstrm1);\n+  VERIFY( buf1 == buf2 ); \n+  VERIFY( pbasebuf1 != pbasebuf2 );\n+  VERIFY( pbasebuf2 == pbasebuf0 );\n+\n+  // derived rdbuf() returns the original buf, so str() doesn't change.\n+  VERIFY( sstrm1.str() != str01 );\n+  VERIFY( sstrm1.str() == str00 );\n+  // however, casting the active streambuf to a stringbuf shows what's up:\n+  std::stringbuf* psbuf = dynamic_cast<std::stringbuf*>(pbasebuf2);\n+  str02 = psbuf->str();\n+  VERIFY( str02 == str01 );\n+\n+  // How confusing and non-intuitive is this?\n+  // These semantics are a joke, a serious defect, and incredibly lame.\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}\n+\n+\n+"}]}