{"sha": "52fb276947febba5f17dbb30ad2ce2a818f714f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmYjI3Njk0N2ZlYmJhNWYxN2RiYjMwYWQyY2UyYTgxOGY3MTRmNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-08-03T15:04:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-08-03T15:04:49Z"}, "message": "call.c (convert_arg_to_ellipsis): Use pod_type_p.\n\n        * call.c (convert_arg_to_ellipsis): Use pod_type_p.\n        * cp-tree.h (struct lang_type): Added non_pod_class flag.\n        (CLASSTYPE_NON_POD_P): New macro to access it.\n        * class.c (finish_struct_1): Determine non-PODness.\n        Check for arrays of pointers (-Weffc++).\n        Remove array inspection duplicated code.\n        * tree.c (pod_type_p): Detect non-pod non-aggregate types.\n        Use CLASSTYPE_NON_POD_P.\n\nFrom-SVN: r28475", "tree": {"sha": "ea01d0c326ebc211b3750d68cadb0c3e78b38bdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea01d0c326ebc211b3750d68cadb0c3e78b38bdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52fb276947febba5f17dbb30ad2ce2a818f714f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fb276947febba5f17dbb30ad2ce2a818f714f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52fb276947febba5f17dbb30ad2ce2a818f714f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fb276947febba5f17dbb30ad2ce2a818f714f6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a30151d102fe111f5de787992494970248ae246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a30151d102fe111f5de787992494970248ae246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a30151d102fe111f5de787992494970248ae246"}], "stats": {"total": 143, "additions": 84, "deletions": 59}, "files": [{"sha": "74bde45ccf54f77bfe09b28ef4d25e487cb27665", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=52fb276947febba5f17dbb30ad2ce2a818f714f6", "patch": "@@ -1,3 +1,14 @@\n+1999-08-03  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* call.c (convert_arg_to_ellipsis): Use pod_type_p.\n+\t* cp-tree.h (struct lang_type): Added non_pod_class flag.\n+\t(CLASSTYPE_NON_POD_P): New macro to access it.\n+\t* class.c (finish_struct_1): Determine non-PODness.\n+\tCheck for arrays of pointers (-Weffc++).\n+\tRemove array inspection duplicated code.\n+\t* tree.c (pod_type_p): Detect non-pod non-aggregate types.\n+\tUse CLASSTYPE_NON_POD_P.\n+\n 1999-08-03  Nathan Sidwell  <nathan@acm.org>\n \n \t* class.c (duplicate_tag_error): Preserve template information."}, {"sha": "fb8f12961badbf51167d1717b5a9254d14ecf0f6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=52fb276947febba5f17dbb30ad2ce2a818f714f6", "patch": "@@ -3752,21 +3752,25 @@ convert_like (convs, expr)\n }\n \n /* ARG is being passed to a varargs function.  Perform any conversions\n-   required.  Return the converted value.  */\n+   required.  Array/function to pointer decay must have already happened.\n+   Return the converted value.  */\n \n tree\n convert_arg_to_ellipsis (arg)\n      tree arg;\n {\n+  if (! pod_type_p (TREE_TYPE (arg)))\n+    {\n+      /* Undefined behaviour [expr.call] 5.2.2/7.  */\n+      cp_warning (\"cannot pass objects of non-POD type `%#T' through `...'\",\n+\t\t  TREE_TYPE (arg));\n+    }\n+\n   if (TREE_CODE (TREE_TYPE (arg)) == REAL_TYPE\n       && (TYPE_PRECISION (TREE_TYPE (arg))\n \t  < TYPE_PRECISION (double_type_node)))\n     /* Convert `float' to `double'.  */\n     arg = cp_convert (double_type_node, arg);\n-  else if (IS_AGGR_TYPE (TREE_TYPE (arg))\n-\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (arg)))\n-    cp_warning (\"cannot pass objects of type `%T' through `...'\",\n-\t\tTREE_TYPE (arg));\n   else\n     /* Convert `short' and `char' to full-size `int'.  */\n     arg = default_conversion (arg);"}, {"sha": "8ba5694525a814df9feb2748d1b02def654b10eb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=52fb276947febba5f17dbb30ad2ce2a818f714f6", "patch": "@@ -3297,6 +3297,7 @@ finish_struct_1 (t)\n   int no_const_asn_ref;\n   int has_mutable = 0;\n   int n_fields = 0;\n+  int non_pod_class = 0;\n \n   /* The index of the first base class which has virtual\n      functions.  Only applied to non-virtual baseclasses.  */\n@@ -3431,6 +3432,7 @@ finish_struct_1 (t)\n   last_x = NULL_TREE;\n   for (x = fields; x; x = TREE_CHAIN (x))\n     {\n+      tree type = TREE_TYPE (x);\n       GNU_xref_member (current_class_name, x);\n \n       if (TREE_CODE (x) == FIELD_DECL)\n@@ -3472,29 +3474,32 @@ finish_struct_1 (t)\n \n       /* Perform error checking that did not get done in\n \t grokdeclarator.  */\n-      if (TREE_CODE (TREE_TYPE (x)) == FUNCTION_TYPE)\n+      if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n \t  cp_error_at (\"field `%D' invalidly declared function type\",\n \t\t       x);\n-\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t  type = build_pointer_type (type);\n+\t  TREE_TYPE (x) = type;\n \t}\n-      else if (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE)\n+      else if (TREE_CODE (type) == METHOD_TYPE)\n \t{\n \t  cp_error_at (\"field `%D' invalidly declared method type\", x);\n-\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t  type = build_pointer_type (type);\n+\t  TREE_TYPE (x) = type;\n \t}\n-      else if (TREE_CODE (TREE_TYPE (x)) == OFFSET_TYPE)\n+      else if (TREE_CODE (type) == OFFSET_TYPE)\n \t{\n \t  cp_error_at (\"field `%D' invalidly declared offset type\", x);\n-\t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n+\t  type = build_pointer_type (type);\n+\t  TREE_TYPE (x) = type;\n \t}\n \n #if 0\n       if (DECL_NAME (x) == constructor_name (t))\n \tcant_have_default_ctor = 1;\n #endif\n \n-      if (TREE_TYPE (x) == error_mark_node)\n+      if (type == error_mark_node)\n \tcontinue;\n \t  \n       DECL_SAVED_INSNS (x) = NULL_RTX;\n@@ -3522,8 +3527,10 @@ finish_struct_1 (t)\n \n       /* If this is of reference type, check if it needs an init.\n \t Also do a little ANSI jig if necessary.  */\n-      if (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE)\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n  \t{\n+          non_pod_class = 1;\n+          \n \t  if (DECL_INITIAL (x) == NULL_TREE)\n \t    ref_sans_init = 1;\n \n@@ -3543,14 +3550,21 @@ finish_struct_1 (t)\n \t    }\n \t}\n \n-      if (TREE_CODE (TREE_TYPE (x)) == POINTER_TYPE)\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+        type = TREE_TYPE (type);\n+      \n+      if (TREE_CODE (type) == POINTER_TYPE)\n \thas_pointers = 1;\n \n-      if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (TREE_TYPE (x)))\n+      if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (type))\n         has_mutable = 1;\n \n+      if (! pod_type_p (type) || TYPE_PTRMEM_P (type)\n+          || TYPE_PTRMEMFUNC_P (type))\n+        non_pod_class = 1;\n+\n       /* If any field is const, the structure type is pseudo-const.  */\n-      if (CP_TYPE_CONST_P (TREE_TYPE (x)))\n+      if (CP_TYPE_CONST_P (type))\n \t{\n \t  C_TYPE_FIELDS_READONLY (t) = 1;\n \t  if (DECL_INITIAL (x) == NULL_TREE)\n@@ -3576,14 +3590,11 @@ finish_struct_1 (t)\n \t{\n \t  /* A field that is pseudo-const makes the structure\n \t     likewise.  */\n-\t  tree t1 = TREE_TYPE (x);\n-\t  while (TREE_CODE (t1) == ARRAY_TYPE)\n-\t    t1 = TREE_TYPE (t1);\n-\t  if (IS_AGGR_TYPE (t1))\n+\t  if (IS_AGGR_TYPE (type))\n \t    {\n-\t      if (C_TYPE_FIELDS_READONLY (t1))\n+\t      if (C_TYPE_FIELDS_READONLY (type))\n \t\tC_TYPE_FIELDS_READONLY (t) = 1;\n-\t      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (t1))\n+\t      if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (type))\n \t\tconst_sans_init = 1;\n \t    }\n \t}\n@@ -3593,7 +3604,10 @@ finish_struct_1 (t)\n       if (DECL_C_BIT_FIELD (x))\n \t{\n \t  /* Invalid bit-field size done by grokfield.  */\n-\t  /* Detect invalid bit-field type.  */\n+\t  /* Detect invalid bit-field type. Simply checking if TYPE is\n+             integral is insufficient, as that is the array core of the\n+             field type. If TREE_TYPE (x) is integral, then TYPE must be\n+             the same.  */\n \t  if (DECL_INITIAL (x)\n \t      && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n \t    {\n@@ -3643,20 +3657,20 @@ finish_struct_1 (t)\n \t\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n \t\t  cp_error_at (\"  in declaration of `%D'\", x);\n \t\t}\n-\t      else if (width > TYPE_PRECISION (TREE_TYPE (x))\n-\t\t       && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE\n-\t\t       && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE)\n+\t      else if (width > TYPE_PRECISION (type)\n+\t\t       && TREE_CODE (type) != ENUMERAL_TYPE\n+\t\t       && TREE_CODE (type) != BOOLEAN_TYPE)\n \t\t{\n \t\t  cp_warning_at (\"width of `%D' exceeds its type\", x);\n \t\t}\n-\t      else if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n-\t\t       && ((min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))) > width)\n-\t\t\t   || (min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n-\t\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (x))) > width)))\n+\t      else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t\t       && ((min_precision (TYPE_MIN_VALUE (type),\n+\t\t\t\t\t   TREE_UNSIGNED (type)) > width)\n+\t\t\t   || (min_precision (TYPE_MAX_VALUE (type),\n+\t\t\t\t\t      TREE_UNSIGNED (type)) > width)))\n \t\t{\n \t\t  cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n-\t\t\t\t x, TREE_TYPE (x));\n+\t\t\t\t x, type);\n \t\t}\n \n \t      if (DECL_INITIAL (x))\n@@ -3674,22 +3688,17 @@ finish_struct_1 (t)\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n \t\t      if (PCC_BITFIELD_TYPE_MATTERS)\n \t\t\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t      TYPE_ALIGN (TREE_TYPE (x)));\n+\t\t\t\t\t      TYPE_ALIGN (type));\n #endif\n \t\t    }\n \t\t}\n \t    }\n \t  else\n \t    /* Non-bit-fields are aligned for their type.  */\n-\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (TREE_TYPE (x)));\n+\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (type));\n \t}\n       else\n \t{\n-\t  tree type = TREE_TYPE (x);\n-\n-\t  while (TREE_CODE (type) == ARRAY_TYPE)\n-\t    type = TREE_TYPE (type);\n-\n \t  if (CLASS_TYPE_P (type) && ! ANON_AGGR_TYPE_P (type))\n \t    {\n \t      /* Never let anything with uninheritable virtuals\n@@ -3792,6 +3801,9 @@ finish_struct_1 (t)\n   if (! IS_SIGNATURE (t))\n     CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n+  CLASSTYPE_NON_POD_P (t)\n+      = non_pod_class || CLASSTYPE_NON_AGGREGATE (t)\n+        || TYPE_HAS_DESTRUCTOR (t) || TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);"}, {"sha": "31e9f8cf047e226c2cbe76204fdaf08bda5606d2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=52fb276947febba5f17dbb30ad2ce2a818f714f6", "patch": "@@ -802,14 +802,15 @@ struct lang_type\n       unsigned is_partial_instantiation : 1;\n       unsigned has_mutable : 1;\n       unsigned com_interface : 1;\n+      unsigned non_pod_class : 1;\n       /* When adding a flag here, consider whether or not it ought to\n \t apply to a template instance if it applies to the template.\n \t If so, make sure to copy it in instantiate_class_template!  */\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 10;\n+      unsigned dummy : 9;\n     } type_flags;\n \n   int vsize;\n@@ -1076,6 +1077,9 @@ struct lang_type\n #define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n+/*  Nonzero means that this class type is a non-POD class.  */\n+#define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.non_pod_class)\n+\n /* Nonzero means that this type is meant for communication via COM.  */\n #define CLASSTYPE_COM_INTERFACE(NODE) \\\n   (TYPE_LANG_SPECIFIC(NODE)->type_flags.com_interface)"}, {"sha": "ab714705b99684fcc113a7df02628adf1b514d73", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb276947febba5f17dbb30ad2ce2a818f714f6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=52fb276947febba5f17dbb30ad2ce2a818f714f6", "patch": "@@ -2749,30 +2749,24 @@ int\n pod_type_p (t)\n      tree t;\n {\n-  tree f;\n-\n   while (TREE_CODE (t) == ARRAY_TYPE)\n     t = TREE_TYPE (t);\n \n-  if (! IS_AGGR_TYPE (t))\n+  if (INTEGRAL_TYPE_P (t))\n+    return 1;  /* integral, character or enumeral type */\n+  if (FLOAT_TYPE_P (t))\n     return 1;\n-\n-  if (CLASSTYPE_NON_AGGREGATE (t)\n-      || TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-      || TYPE_HAS_DESTRUCTOR (t))\n+  if (TYPE_PTR_P (t))\n+    return 1; /* pointer to non-member */\n+  if (TYPE_PTRMEM_P (t))\n+    return 1; /* pointer to member object */\n+  if (TYPE_PTRMEMFUNC_P (t))\n+    return 1; /* pointer to member function */\n+  \n+  if (! CLASS_TYPE_P (t))\n+    return 0; /* other non-class type (reference or function) */\n+  if (CLASSTYPE_NON_POD_P (t))\n     return 0;\n-\n-  for (f = TYPE_FIELDS (t); f; f = TREE_CHAIN (f))\n-    {\n-      if (TREE_CODE (f) != FIELD_DECL)\n-\tcontinue;\n-\n-      if (TREE_CODE (TREE_TYPE (f)) == REFERENCE_TYPE\n-\t  || TYPE_PTRMEMFUNC_P (TREE_TYPE (f))\n-\t  || TYPE_PTRMEM_P (TREE_TYPE (f)))\n-\treturn 0;\n-    }\n-\n   return 1;\n }\n "}]}