{"sha": "92643fea9381b2d137f19d19e28e24a61dc44b0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI2NDNmZWE5MzgxYjJkMTM3ZjE5ZDE5ZTI4ZTI0YTYxZGM0NGIwYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-03-19T23:50:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-03-19T23:50:04Z"}, "message": "Compute DECL_ASSEMBLER_NAME lazily.\n\n\t* tree.h (DECL_ASSEMBLER_NAME): Compute it lazily.\n\t(DECL_ASSEMBLER_NAME_SET_P): New macro.\n\t(SET_DECL_ASSEMBLER_NAME): Likewise.\n\t(COPY_DECL_ASSEMBLER_NAME): Likewise.\n\t(set_decl_assembler_name): Declare.\n\t(lang_set_decl_assembler_name): Likewise.\n\t* tree.c (lang_set_decl_assembler_name): New variab.e\n\t(set_decl_assembler_name): New function.\n\t(init_obstacks): Set lang_set_decl_assembler_name.\n\t(build_decl): Don't set DECL_ASSEMBLER_NAME.\n\t* c-decl.c (duplicate_decls): Use SET_DECL_ASSEMBLER_NAME,\n\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n\twhere it's not necessary.\n\t(builtin_function): Likewise.\n\t(finish_decl): Likewise.\n\t* dbxout.c (dbxout_type_methods): Likewise.\n\t* ggc-common.c (ggc_mark_trees): Likewise.\n\t* profile.c (output_func_start_profiler): Likewise.\n\t* varasm.c (make_decl_rtl): Likewise.\n\n\t* class.c (get_vtable_decl): Use SET_DECL_ASSEMBLER_NAME,\n\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n\twhere it's not necessary.\n\t(add_method): Remove optimization involving comparison of\n\tDECL_ASSEMBLER_NAME.\n\t(build_vtbl_or_vbase_field): Use SET_DECL_ASSEMBLER_NAME,\n\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n\twhere it's not necessary.\n\t(check_methods): Likewise.\n\t(build_clone): Likewise.\n\t(built_vtt): Likewise.\n\t* cp-tree.h (DECL_NEEDED_P): Likewise.\n\t* decl.c (pushtag): Likewise.\n\t(duplicate_decls): Likewise.\n\t(pushdecl): Likewise.\n\t(builtin_function): Likewise.\n\t(build_library_fn_1): Set DECL_LANGUAGE for library functions.\n\t(build_cp_library_fn): Likewise.\n\t(maybe_commonize_var): Use SET_DECL_ASSEMBLER_NAME,\n\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n\twhere it's not necessary.\n\t(make_rtl_for_nonlocal_decl): Likewise.\n\t(cp_finish_decl): Likewise.\n\t(grokfndecl): Likewise.\n\t(grokvardecl): Likewise.\n\t(grokdeclarator): Likewise.\n\t(start_function): Likewise.\n\t(cp_missing_return_ok_p): Likewise.\n\t* decl2.c (grokclassfn): Likewise.\n\t(check_classfn): Likewise.\n\t(finish_static_data_member_decl): Likewise.\n\t(grokfield): Likewise.\n\t* error.c (GLOBAL_IORD_P): Remove.\n\t(dump_global_iord): Improve output.\n\t(dump_decl): Avoid using DECL_ASSEMBLER_NAME.\n\t* except.c (nothrow_libfn_p): Summarily reject any function not in\n\tnamespace-scope.\n\t* init.c (build_java_class_ref): Don't explicitly set\n\tDECL_ASSEMBLER_NAME after calling mangle_decl.\n\t* mangle.c (mangle_decl_string): Handle extern \"C\" functions.\n\t(mangle_decl): Set the DECL_ASSEMBLER_NAME for the decl.\n\t* method.c (set_mangled_name_for_decl): Don't explicitly set\n\tDECL_ASSEMBLER_NAME after calling mangle_decl.\n\t(make_thunk): Explicitly set the DECL_ASSEMBLER_NAME and\n\tIDENTIFIER_GLOBAL_VALUE for the thunk.\n\t* pt.c (set_mangled_name_for_template_decl): Remove.\n\t(check_explicit_specialization): Don't use it.\n\t(looup_template_class): Don't set DECL_ASSEMBLER_NAME.\n\t(tsubst_friend_function): Likewise.\n\t(tsubst_decl): Likewise.\n\t(regenerate_decl_from_template): Use COPY_DECL_ASSEMBLER_NAME.\n\t* rtti.c (get_tinfo_decl): Use SET_DECL_ASSEMBLER_NAME,\n\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n\twhere it's not necessary.\n\t(tinfo_base_init): Likewise.\n\t(create_real_tinfo_var): Likewise.\n\t* search.c (looup_field_1): Likewise.\n\t* semantics.c (finish_named_return_value): Likewise.\n\t* tree.c (init_tree): Set lang_set_decl_assembler_name.\n\n\t* com.c (builtin_function): Use SET_DECL_ASSEMBLER_NAME.\n\n\t* class.c (build_class_ref): Use SET_DECL_ASSEMBLER_NAME.\n\t(layout_class): Likewise.\n\t(layout_class_method): Likewise.\n\t(emit_register_classes): Likewise.\n\t* decl.c (builtin_function): Likewise.\n\t(give_name_to_locals): Likewise.\n\nFrom-SVN: r40642", "tree": {"sha": "0e001bd33ab3dcdd688aa773f49f4ddf63c89df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e001bd33ab3dcdd688aa773f49f4ddf63c89df6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92643fea9381b2d137f19d19e28e24a61dc44b0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92643fea9381b2d137f19d19e28e24a61dc44b0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92643fea9381b2d137f19d19e28e24a61dc44b0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92643fea9381b2d137f19d19e28e24a61dc44b0c/comments", "author": null, "committer": null, "parents": [{"sha": "b90f4049d36e101e2090dd2c1a0595bdb3790ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b90f4049d36e101e2090dd2c1a0595bdb3790ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b90f4049d36e101e2090dd2c1a0595bdb3790ec2"}], "stats": {"total": 646, "additions": 300, "deletions": 346}, "files": [{"sha": "20504499974ed7aae9675887644d8e01b2dfccbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1,5 +1,26 @@\n 2001-03-19  Mark Mitchell  <mark@codesourcery.com>\n \n+\tCompute DECL_ASSEMBLER_NAME lazily.\n+\t* tree.h (DECL_ASSEMBLER_NAME): Compute it lazily.\n+\t(DECL_ASSEMBLER_NAME_SET_P): New macro.\n+\t(SET_DECL_ASSEMBLER_NAME): Likewise.\n+\t(COPY_DECL_ASSEMBLER_NAME): Likewise.\n+\t(set_decl_assembler_name): Declare.\n+\t(lang_set_decl_assembler_name): Likewise.\n+\t* tree.c (lang_set_decl_assembler_name): New variab.e\n+\t(set_decl_assembler_name): New function.\n+\t(init_obstacks): Set lang_set_decl_assembler_name.\n+\t(build_decl): Don't set DECL_ASSEMBLER_NAME.\n+\t* c-decl.c (duplicate_decls): Use SET_DECL_ASSEMBLER_NAME,\n+\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n+\twhere it's not necessary.\n+\t(builtin_function): Likewise.\n+\t(finish_decl): Likewise.\n+\t* dbxout.c (dbxout_type_methods): Likewise.\n+\t* ggc-common.c (ggc_mark_trees): Likewise.\n+\t* profile.c (output_func_start_profiler): Likewise.\n+\t* varasm.c (make_decl_rtl): Likewise.\n+\n \t* cse.c (find_comparison_args): Update documentation.  Fix\n \tmishandling of COMPARE operations.\n "}, {"sha": "1d5172549978caf591c227cc4b27a238a36e90f2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1902,7 +1902,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \n       /* Copy the assembler name.\n \t Currently, it can only be defined in the prototype.  */\n-      DECL_ASSEMBLER_NAME (newdecl) = DECL_ASSEMBLER_NAME (olddecl);\n+      COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n@@ -3186,7 +3186,7 @@ builtin_function (name, type, function_code, class, library_name)\n   if (flag_traditional && name[0] != '_')\n     DECL_BUILT_IN_NONANSI (decl) = 1;\n   if (library_name)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n   make_decl_rtl (decl, NULL_PTR);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n@@ -3599,7 +3599,7 @@ finish_decl (decl, init, asmspec_tree)\n     {\n       DECL_BUILT_IN_CLASS (decl) = NOT_BUILT_IN;\n       SET_DECL_RTL (decl, NULL_RTX);\n-      DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n     }\n \n   /* Output the assembler code and/or RTL code for variables and functions,\n@@ -3627,7 +3627,7 @@ finish_decl (decl, init, asmspec_tree)\n \t{\n \t  if (asmspec)\n \t    {\n-\t      DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+\t      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n \t      DECL_C_HARD_REGISTER (decl) = 1;\n \t    }\n \t  add_decl_stmt (decl);"}, {"sha": "15ff7b546bb335993a144a83958297f1e0d61c78", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1,3 +1,65 @@\n+2001-03-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (get_vtable_decl): Use SET_DECL_ASSEMBLER_NAME,\n+\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n+\twhere it's not necessary.\n+\t(add_method): Remove optimization involving comparison of\n+\tDECL_ASSEMBLER_NAME.\n+\t(build_vtbl_or_vbase_field): Use SET_DECL_ASSEMBLER_NAME,\n+\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n+\twhere it's not necessary.\n+\t(check_methods): Likewise.\n+\t(build_clone): Likewise.\n+\t(built_vtt): Likewise.\n+\t* cp-tree.h (DECL_NEEDED_P): Likewise.\n+\t* decl.c (pushtag): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(pushdecl): Likewise.\n+\t(builtin_function): Likewise.\n+\t(build_library_fn_1): Set DECL_LANGUAGE for library functions.\n+\t(build_cp_library_fn): Likewise.\n+\t(maybe_commonize_var): Use SET_DECL_ASSEMBLER_NAME,\n+\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n+\twhere it's not necessary.\n+\t(make_rtl_for_nonlocal_decl): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(grokfndecl): Likewise.\n+\t(grokvardecl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(start_function): Likewise.\n+\t(cp_missing_return_ok_p): Likewise.\n+\t* decl2.c (grokclassfn): Likewise.\n+\t(check_classfn): Likewise.\n+\t(finish_static_data_member_decl): Likewise.\n+\t(grokfield): Likewise.\n+\t* error.c (GLOBAL_IORD_P): Remove.\n+\t(dump_global_iord): Improve output.\n+\t(dump_decl): Avoid using DECL_ASSEMBLER_NAME.\n+\t* except.c (nothrow_libfn_p): Summarily reject any function not in\n+\tnamespace-scope.\n+\t* init.c (build_java_class_ref): Don't explicitly set\n+\tDECL_ASSEMBLER_NAME after calling mangle_decl.\n+\t* mangle.c (mangle_decl_string): Handle extern \"C\" functions.\n+\t(mangle_decl): Set the DECL_ASSEMBLER_NAME for the decl.\n+\t* method.c (set_mangled_name_for_decl): Don't explicitly set\n+\tDECL_ASSEMBLER_NAME after calling mangle_decl.\n+\t(make_thunk): Explicitly set the DECL_ASSEMBLER_NAME and\n+\tIDENTIFIER_GLOBAL_VALUE for the thunk.\n+\t* pt.c (set_mangled_name_for_template_decl): Remove.\n+\t(check_explicit_specialization): Don't use it.\n+\t(looup_template_class): Don't set DECL_ASSEMBLER_NAME.\n+\t(tsubst_friend_function): Likewise.\n+\t(tsubst_decl): Likewise.\n+\t(regenerate_decl_from_template): Use COPY_DECL_ASSEMBLER_NAME.\n+\t* rtti.c (get_tinfo_decl): Use SET_DECL_ASSEMBLER_NAME,\n+\tCOPY_DECL_ASSEMBLER_NAME, etc.  Don't set DECL_ASSEMBLER_NAME\n+\twhere it's not necessary.\n+\t(tinfo_base_init): Likewise.\n+\t(create_real_tinfo_var): Likewise.\n+\t* search.c (looup_field_1): Likewise.\n+\t* semantics.c (finish_named_return_value): Likewise.\n+\t* tree.c (init_tree): Set lang_set_decl_assembler_name.\n+\t\n 2001-03-15  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \tCorrect semantics restrictions checking in throw-expression."}, {"sha": "cf3b666fd1a51322d60ed0cf1a2707ae17a5f2bf", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -760,6 +760,7 @@ get_vtable_decl (type, complete)\n     }\n   \n   decl = build_vtable (type, name, void_type_node);\n+  SET_DECL_ASSEMBLER_NAME (decl, name);\n   decl = pushdecl_top_level (decl);\n   my_friendly_assert (IDENTIFIER_GLOBAL_VALUE (name) == decl,\n \t\t      20000517);\n@@ -1310,17 +1311,9 @@ add_method (type, method, error_p)\n \t\t\t\t  fn, method);\n \t\t    }\n \t\t}\n-\n-\t      /* Since this is an ordinary function in a\n-\t\t non-template class, it's mangled name can be used\n-\t\t as a unique identifier.  This technique is only\n-\t\t an optimization; we would get the same results if\n-\t\t we just used decls_match here.  */\n-\t      if (DECL_ASSEMBLER_NAME (fn) \n-\t\t  != DECL_ASSEMBLER_NAME (method))\n-\t\tcontinue;\n \t    }\n-\t  else if (!decls_match (fn, method))\n+\n+\t  if (!decls_match (fn, method))\n \t    continue;\n \n \t  /* There has already been a declaration of this method\n@@ -3693,7 +3686,7 @@ build_vtbl_or_vbase_field (name, assembler_name, type, class_type, fcontext,\n \n   /* Build the FIELD_DECL.  */\n   field = build_decl (FIELD_DECL, name, type);\n-  DECL_ASSEMBLER_NAME (field) = assembler_name;\n+  SET_DECL_ASSEMBLER_NAME (field, assembler_name);\n   DECL_VIRTUAL_P (field) = 1;\n   DECL_ARTIFICIAL (field) = 1;\n   DECL_FIELD_CONTEXT (field) = class_type;\n@@ -4120,7 +4113,8 @@ check_methods (t)\n       GNU_xref_member (current_class_name, x);\n \n       /* If this was an evil function, don't keep it in class.  */\n-      if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n+      if (DECL_ASSEMBLER_NAME_SET_P (x) \n+\t  && IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n \tcontinue;\n \n       check_for_override (x, t);\n@@ -4184,7 +4178,6 @@ build_clone (fn, name)\n   DECL_ABSTRACT_ORIGIN (clone) = fn;\n   /* Reset the function name.  */\n   DECL_NAME (clone) = name;\n-  DECL_ASSEMBLER_NAME (clone) = DECL_NAME (clone);\n   /* There's no pending inline data for this function.  */\n   DECL_PENDING_INLINE_INFO (clone) = NULL;\n   DECL_PENDING_INLINE_P (clone) = 0;\n@@ -4261,9 +4254,6 @@ build_clone (fn, name)\n \t}\n     }\n \n-  /* Mangle the function name.  */\n-  set_mangled_name_for_decl (clone);\n-\n   /* Create the RTL for this function.  */\n   SET_DECL_RTL (clone, NULL_RTX);\n   rest_of_decl_compilation (clone, NULL, /*top_level=*/1, at_eof);\n@@ -6823,6 +6813,7 @@ build_vtt (t)\n \t\t\t\t \n   /* Now, build the VTT object itself.  */\n   vtt = build_vtable (t, get_vtt_name (t), type);\n+  SET_DECL_ASSEMBLER_NAME (vtt, DECL_NAME (vtt));\n   pushdecl_top_level (vtt);\n   initialize_array (vtt, inits);\n }"}, {"sha": "eb4bc7c54544394dbbdf57846701d525487825de", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1904,9 +1904,10 @@ struct lang_decl\n    just been used somewhere, even if it's not really needed.  We need\n    anything that isn't comdat, but we don't know for sure whether or\n    not something is comdat until end-of-file.  */\n-#define DECL_NEEDED_P(DECL)\t\t\t\t\t\\\n-  ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\\\n-   || (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME ((DECL))))\t\\\n+#define DECL_NEEDED_P(DECL)\t\t\t\t\t\t\\\n+  ((at_eof && TREE_PUBLIC (DECL) && !DECL_COMDAT (DECL))\t\t\\\n+   || (DECL_ASSEMBLER_NAME_SET_P (DECL)\t\t\t\t\t\\\n+       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME ((DECL))))\t\\\n    || (flag_syntax_only && TREE_USED ((DECL))))\n \n /* Non-zero iff DECL is memory-based.  The DECL_RTL of\n@@ -4531,7 +4532,7 @@ extern void GNU_xref_member\t\t\tPARAMS ((tree, tree));\n \n /* in mangle.c */\n extern void init_mangle                         PARAMS ((void));\n-extern tree mangle_decl                         PARAMS ((tree));\n+extern void mangle_decl                         PARAMS ((tree));\n extern const char *mangle_type_string           PARAMS ((tree));\n extern tree mangle_type                         PARAMS ((tree));\n extern tree mangle_typeinfo_for_type            PARAMS ((tree));"}, {"sha": "f540cc5475af2090b7a6affdad8c4005d896e68f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -2827,7 +2827,6 @@ pushtag (name, type, globalize)\n \t    DECL_IGNORED_P (d) = 1;\n \n \t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\t  DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n \n \t  /* If this is a local class, keep track of it.  We need this\n \t     information for name-mangling, and so that it is possible to find\n@@ -2838,9 +2837,6 @@ pushtag (name, type, globalize)\n \t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL\n \t      && !processing_template_decl)\n \t    VARRAY_PUSH_TREE (local_classes, type);\n-\n-\t  if (!uses_template_parms (type))\n-\t    DECL_ASSEMBLER_NAME (d) = mangle_type (type);\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -3161,7 +3157,7 @@ duplicate_decls (newdecl, olddecl)\n \t     will be banished.  */\n \t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);\n \t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n-\t  DECL_ASSEMBLER_NAME (olddecl) = DECL_ASSEMBLER_NAME (newdecl);\n+\t  COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \t  SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (newdecl),\n \t\t\t\t       newdecl);\n \t}\n@@ -3633,7 +3629,7 @@ duplicate_decls (newdecl, olddecl)\n       if (! types_match)\n \t{\n \t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);\n-\t  DECL_ASSEMBLER_NAME (olddecl) = DECL_ASSEMBLER_NAME (newdecl);\n+\t  COPY_DECL_ASSEMBLER_NAME (newdecl, olddecl);\n \t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n \t}\n       if (! types_match || new_defines_function)\n@@ -3683,7 +3679,7 @@ duplicate_decls (newdecl, olddecl)\n   TREE_ADDRESSABLE (newdecl) = TREE_ADDRESSABLE (olddecl);\n   TREE_ASM_WRITTEN (newdecl) = TREE_ASM_WRITTEN (olddecl);\n   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n-  DECL_ASSEMBLER_NAME (newdecl) = DECL_ASSEMBLER_NAME (olddecl);\n+  COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -3846,8 +3842,7 @@ pushdecl (x)\n \t  if (TREE_CODE (x) == FUNCTION_DECL)\n \t    for (match = t; match; match = OVL_NEXT (match))\n \t      {\n-\t\tif (DECL_ASSEMBLER_NAME (OVL_CURRENT (t))\n-\t\t    == DECL_ASSEMBLER_NAME (x))\n+\t\tif (decls_match (OVL_CURRENT (match), x))\n \t\t  break;\n \t      }\n \t  else\n@@ -4028,32 +4023,15 @@ pushdecl (x)\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n-\t  /* Bind the mangled name for the entity.  In the future, we\n-\t     should not need to do this; mangled names are an\n-\t     implementation detail of which the front-end should not\n-\t     need to be aware.  */\n-\t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n-\t\t&& t != NULL_TREE)\n-\t      /* For an ordinary function, we create a binding from\n-\t\t the mangled name (i.e., NAME) to the DECL.  But, for\n-\t\t an `extern \"C\"' function, the mangled name and the\n-\t\t ordinary name are the same so we need not do this.  */\n-\t      && !DECL_EXTERN_C_FUNCTION_P (x))\n-\t    {\n-\t      tree mangled_name;\n-\n-\t      if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n-\t\t  || TREE_CODE (x) == NAMESPACE_DECL)\n-\t\tmangled_name = name;\n-\t      else\n-\t\tmangled_name = DECL_ASSEMBLER_NAME (x);\n-\n-\t      if (TREE_CODE (x) == FUNCTION_DECL)\n-\t\tmy_friendly_assert\n-\t\t  ((IDENTIFIER_GLOBAL_VALUE (mangled_name) == NULL_TREE)\n-\t\t  || (IDENTIFIER_GLOBAL_VALUE (mangled_name) == x), 378);\n-\t      SET_IDENTIFIER_NAMESPACE_VALUE (mangled_name, x);\n-\t    }\n+ \t  /* Bind the name for the entity.  */\n+ \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+  \t\t&& t != NULL_TREE)\n+ \t      && (TREE_CODE (x) == TYPE_DECL\n+ \t\t  || TREE_CODE (x) == VAR_DECL\n+ \t\t  || TREE_CODE (x) == NAMESPACE_DECL\n+ \t\t  || TREE_CODE (x) == CONST_DECL\n+ \t\t  || TREE_CODE (x) == TEMPLATE_DECL))\n+ \t    SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n \n \t  /* Don't forget if the function was used via an implicit decl.  */\n \t  if (IDENTIFIER_IMPLICIT_DECL (name)\n@@ -6670,7 +6648,8 @@ builtin_function (name, type, code, class, libname)\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n      function in the namespace.  */\n   if (libname)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (libname);\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));\n+  make_decl_rtl (decl, NULL);\n \n   /* Warn if a function in the namespace for users\n      is used without an occasion to consider it declared.  */\n@@ -6695,6 +6674,7 @@ build_library_fn_1 (name, operator_code, type)\n   DECL_ARTIFICIAL (fn) = 1;\n   TREE_NOTHROW (fn) = 1;\n   SET_OVERLOADED_OPERATOR_CODE (fn, operator_code);\n+  DECL_LANGUAGE (fn) = lang_c;\n   return fn;\n }\n \n@@ -6721,6 +6701,7 @@ build_cp_library_fn (name, operator_code, type)\n   tree fn = build_library_fn_1 (name, operator_code, type);\n   TREE_NOTHROW (fn) = TYPE_NOTHROW_P (type);\n   DECL_CONTEXT (fn) = FROB_CONTEXT (current_namespace);\n+  DECL_LANGUAGE (fn) = lang_cplusplus;\n   set_mangled_name_for_decl (fn);\n   return fn;\n }\n@@ -7534,9 +7515,7 @@ maybe_commonize_var (decl)\n \t  /* else we lose. We can only do this if we can use common,\n \t     which we can't if it has been initialized.  */\n \n-\t  if (TREE_PUBLIC (decl))\n-\t    DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-\t  else\n+\t  if (!TREE_PUBLIC (decl))\n \t    {\n \t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n \t      cp_warning_at (\"  you can work around this by removing the initializer\", decl);\n@@ -7721,7 +7700,7 @@ make_rtl_for_nonlocal_decl (decl, init, asmspec)\n \n   /* Set the DECL_ASSEMBLER_NAME for the variable.  */\n   if (asmspec)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n \n   /* We don't create any RTL for local variables.  */\n   if (DECL_FUNCTION_SCOPE_P (decl) && !TREE_STATIC (decl))\n@@ -7751,12 +7730,15 @@ make_rtl_for_nonlocal_decl (decl, init, asmspec)\n       defer_p = 1;\n     }\n \n-  /* If we're deferring the variable, just make RTL.  Do not actually\n-     emit the variable.  */\n-  if (defer_p)\n+  /* If we're deferring the variable, we only need to make RTL if\n+     there's an ASMSPEC.  Otherwise, we'll lazily create it later when\n+     we need it.  (There's no way to lazily create RTL for things that\n+     have assembly specs because the information about the specifier\n+     isn't stored in the tree, yet)  */\n+  if (defer_p && asmspec)\n     make_decl_rtl (decl, asmspec);\n   /* If we're not deferring, go ahead and assemble the variable.  */\n-  else\n+  else if (!defer_p)\n     rest_of_decl_compilation (decl, asmspec, toplev, at_eof);\n }\n \n@@ -8034,7 +8016,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       /* This must override the asm specifier which was placed by\n \t grokclassfn.  Lay this out fresh.  */\n       SET_DECL_RTL (TREE_TYPE (decl), NULL_RTX);\n-      DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n       make_decl_rtl (decl, asmspec);\n     }\n \n@@ -8858,12 +8840,6 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   if (has_default_arg)\n     add_defarg_fn (decl);\n \n-  /* Plain overloading: will not be grok'd by grokclassfn.  */\n-  if (! ctype && ! processing_template_decl\n-      && (! DECL_EXTERN_C_P (decl) || DECL_OVERLOADED_OPERATOR_P (decl))\n-      && ! DECL_USE_TEMPLATE (decl))\n-    set_mangled_name_for_decl (decl);\n-\n   if (funcdef_flag)\n     /* Make the init_value nonzero so pushdecl knows this is not\n        tentative.  error_mark_node is replaced later with the BLOCK.  */\n@@ -8968,10 +8944,6 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       type = TREE_TYPE (type);\n       decl = build_lang_decl (VAR_DECL, declarator, type);\n       DECL_CONTEXT (decl) = basetype;\n-      /* DECL_ASSEMBLER_NAME is needed only for full-instantiated\n-\t templates.  */\n-      if (!uses_template_parms (decl))\n-\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n     }\n   else\n     {\n@@ -8996,7 +8968,10 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n \n       context = DECL_CONTEXT (decl);\n       if (declarator && context && current_lang_name != lang_name_c)\n-\tDECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+\t/* We can't mangle lazily here because we don't have any\n+\t   way to recover whether or not a variable was `extern\n+\t   \"C\"' later.  */\n+\tmangle_decl (decl);\n     }\n \n   if (in_namespace)\n@@ -11005,8 +10980,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  DECL_ASSEMBLER_NAME (decl) = mangle_type (type);\n-\n \t  /* FIXME remangle member functions; member functions of a\n \t     type with external linkage have external linkage.  */\n \t}\n@@ -13537,19 +13510,10 @@ start_function (declspecs, declarator, attrs, flags)\n   if (attrs)\n     cplus_decl_attributes (decl1, NULL_TREE, attrs);\n \n-  /* We need to do this even if we aren't expanding yet so that\n-     assemble_external works.  */\n-  make_decl_rtl (decl1, NULL);\n-\n   /* Promote the value to int before returning it.  */\n   if (C_PROMOTING_INTEGER_TYPE_P (restype))\n     restype = type_promotes_to (restype);\n \n-  /* If this fcn was already referenced via a block-scope `extern' decl\n-     (or an implicit decl), propagate certain information about the usage.  */\n-  if (TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (decl1)))\n-    TREE_ADDRESSABLE (decl1) = 1;\n-\n   if (DECL_RESULT (decl1) == NULL_TREE)\n     {\n       DECL_RESULT (decl1)\n@@ -14488,5 +14452,5 @@ cp_missing_noreturn_ok_p (decl)\n      tree decl;\n {\n   /* A missing noreturn is ok for the `main' function.  */\n-  return MAIN_NAME_P (DECL_ASSEMBLER_NAME (decl));\n+  return DECL_MAIN_P (decl);\n }"}, {"sha": "1487a5be9e23627596324e45c794798d69db330f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1061,17 +1061,17 @@ grokclassfn (ctype, function, flags, quals)\n   DECL_ARGUMENTS (function) = last_function_parms;\n   DECL_CONTEXT (function) = ctype;\n \n+  if (flags == DTOR_FLAG)\n+    DECL_DESTRUCTOR_P (function) = 1;\n+\n   if (flags == DTOR_FLAG || DECL_CONSTRUCTOR_P (function))\n     maybe_retrofit_in_chrg (function);\n \n   if (flags == DTOR_FLAG)\n     {\n       DECL_DESTRUCTOR_P (function) = 1;\n-      set_mangled_name_for_decl (function);\n       TYPE_HAS_DESTRUCTOR (ctype) = 1;\n     }\n-  else\n-    set_mangled_name_for_decl (function);\n }\n \n /* Work on the expr used by alignof (this is only called by the parser).  */\n@@ -1436,22 +1436,6 @@ check_classfn (ctype, function)\n \t\t   fndecls = OVL_NEXT (fndecls))\n \t\t{\n \t\t  fndecl = OVL_CURRENT (fndecls);\n-\t\t  /* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL, or\n-\t\t     for a for member function of a template class, is\n-\t\t     not mangled, so the check below does not work\n-\t\t     correctly in that case.  Since mangled destructor\n-\t\t     names do not include the type of the arguments,\n-\t\t     we can't use this short-cut for them, either.\n-\t\t     (It's not legal to declare arguments for a\n-\t\t     destructor, but some people try.)  */\n-\t\t  if (!DECL_DESTRUCTOR_P (function)\n-\t\t      && (DECL_ASSEMBLER_NAME (function)\n-\t\t\t  != DECL_NAME (function))\n-\t\t      && (DECL_ASSEMBLER_NAME (fndecl)\n-\t\t\t  != DECL_NAME (fndecl))\n-\t\t      && (DECL_ASSEMBLER_NAME (function) \n-\t\t\t  == DECL_ASSEMBLER_NAME (fndecl)))\n-\t\t    return fndecl;\n \n \t\t  /* We cannot simply call decls_match because this\n \t\t     doesn't work for static member functions that are \n@@ -1525,11 +1509,6 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n      tree asmspec_tree;\n      int flags;\n {\n-  const char *asmspec = 0;\n-\n-  if (asmspec_tree)\n-    asmspec = TREE_STRING_POINTER (asmspec_tree);\n-\n   my_friendly_assert (TREE_PUBLIC (decl), 0);\n \n   DECL_CONTEXT (decl) = current_class_type;\n@@ -1538,11 +1517,9 @@ finish_static_data_member_decl (decl, init, asmspec_tree, flags)\n      decl of our TREE_CHAIN.  Instead, we modify cp_finish_decl to do\n      the right thing, namely, to put this decl out straight away.  */\n   /* current_class_type can be NULL_TREE in case of error.  */\n-  if (!asmspec && current_class_type)\n-    {\n-      DECL_INITIAL (decl) = error_mark_node;\n-      DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n-    }\n+  if (!asmspec_tree && current_class_type)\n+    DECL_INITIAL (decl) = error_mark_node;\n+\n   if (! processing_template_decl)\n     {\n       if (!pending_statics)\n@@ -1672,12 +1649,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       if (CLASS_TYPE_P (TREE_TYPE (value)))\n         CLASSTYPE_GOT_SEMICOLON (TREE_TYPE (value)) = 1;\n       \n-      /* Now that we've updated the context, we need to remangle the\n-\t name for this TYPE_DECL.  */\n-      DECL_ASSEMBLER_NAME (value) = DECL_NAME (value);\n-      if (!uses_template_parms (value)) \n-\tDECL_ASSEMBLER_NAME (value) = mangle_type (TREE_TYPE (value));\n-\n       if (processing_template_decl)\n \tvalue = push_template_decl (value);\n \n@@ -1776,7 +1747,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t  /* This must override the asm specifier which was placed\n \t     by grokclassfn.  Lay this out fresh.  */\n \t  SET_DECL_RTL (value, NULL_RTX);\n-\t  DECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n+\t  SET_DECL_ASSEMBLER_NAME (value, get_identifier (asmspec));\n \t}\n       cp_finish_decl (value, init, asmspec_tree, flags);\n "}, {"sha": "0ab06fa05a49e0425b9b52bf66c5f40cf64c44ae", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -883,19 +883,15 @@ ident_fndecl (t)\n #  endif\n #endif\n \n-#define GLOBAL_IORD_P(NODE) \\\n-  ! strncmp (IDENTIFIER_POINTER(NODE), GLOBAL_THING, sizeof (GLOBAL_THING) - 1)\n-\n static void\n dump_global_iord (t)\n      tree t;\n {\n-  const char *name = IDENTIFIER_POINTER (t);\n   const char *p = NULL;\n \n-  if (name [sizeof (GLOBAL_THING) - 1] == 'I')\n+  if (DECL_GLOBAL_CTOR_P (t))\n     p = \"initializers\";\n-  else if (name [sizeof (GLOBAL_THING) - 1] == 'D')\n+  else if (DECL_GLOBAL_DTOR_P (t))\n     p = \"destructors\";\n   else\n     my_friendly_abort (352);\n@@ -1041,8 +1037,8 @@ dump_decl (t, flags)\n       /* Fall through.  */\n \n     case FUNCTION_DECL:\n-      if (GLOBAL_IORD_P (DECL_ASSEMBLER_NAME (t)))\n-\tdump_global_iord (DECL_ASSEMBLER_NAME (t));\n+      if (DECL_GLOBAL_CTOR_P (t) || DECL_GLOBAL_DTOR_P (t))\n+\tdump_global_iord (t);\n       else if (! DECL_LANG_SPECIFIC (t))\n \tprint_identifier (scratch_buffer, \"<internal>\");\n       else"}, {"sha": "fd99a9310895e2522d6d90a8f46df3b0f6f46327", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1121,6 +1121,7 @@ nothrow_libfn_p (fn)\n \n   if (TREE_PUBLIC (fn)\n       && DECL_EXTERNAL (fn)\n+      && DECL_NAMESPACE_SCOPE_P (fn)\n       && DECL_EXTERN_C_P (fn))\n     /* OK */;\n   else"}, {"sha": "f680ee0425cc9937ba22c94fb7a35e49f8310b95", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -2219,7 +2219,8 @@ build_java_class_ref (type)\n     for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n       if (DECL_NAME (field) == CL_suffix)\n \t{\n-\t  name = mangle_decl (field);\n+\t  mangle_decl (field);\n+\t  name = DECL_ASSEMBLER_NAME (field);\n \t  break;\n \t}\n     if (!field)"}, {"sha": "4d63f768b35cc0a91bb6fbada040a8d950605add", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -2069,6 +2069,17 @@ mangle_decl_string (decl)\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     write_type (TREE_TYPE (decl));\n+  else if (/* The names of `extern \"C\"' functions are not mangled.  */\n+\t   (TREE_CODE (decl) == FUNCTION_DECL \n+\t    /* If there's no DECL_LANG_SPECIFIC, it's a function built\n+\t       by language-independent code, which never builds\n+\t       functions with C++ linkage.  */\n+\t    && (!DECL_LANG_SPECIFIC (decl) \n+\t\t|| DECL_EXTERN_C_FUNCTION_P (decl)))\n+\t   /* The names of global variables aren't mangled either.  */\n+\t   || (TREE_CODE (decl) == VAR_DECL\n+\t       && CP_DECL_CONTEXT (decl) == global_namespace))\n+    write_string (IDENTIFIER_POINTER (DECL_NAME (decl)));\n   else\n     {\n       write_mangled_name (decl);\n@@ -2089,11 +2100,13 @@ mangle_decl_string (decl)\n \n /* Create an identifier for the external mangled name of DECL.  */\n \n-tree\n+void\n mangle_decl (decl)\n      tree decl;\n {\n-  return get_identifier (mangle_decl_string (decl));\n+  tree id = get_identifier (mangle_decl_string (decl));\n+\n+  SET_DECL_ASSEMBLER_NAME (decl, id);\n }\n \n /* Generate the mangled representation of TYPE.  */"}, {"sha": "5f917d5aabb6b7b5a8f85f14f8b37f6bc3bc822b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -90,7 +90,7 @@ set_mangled_name_for_decl (decl)\n     /* There's no need to mangle the name of a template function.  */\n     return;\n \n-  DECL_ASSEMBLER_NAME (decl) = mangle_decl (decl);\n+  mangle_decl (decl);\n }\n \n \f\n@@ -346,6 +346,7 @@ make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n       thunk = build_decl (FUNCTION_DECL, thunk_id, TREE_TYPE (func_decl));\n       DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (func_decl);\n       copy_lang_decl (func_decl);\n+      SET_DECL_ASSEMBLER_NAME (thunk, thunk_id);\n       DECL_CONTEXT (thunk) = DECL_CONTEXT (func_decl);\n       TREE_READONLY (thunk) = TREE_READONLY (func_decl);\n       TREE_THIS_VOLATILE (thunk) = TREE_THIS_VOLATILE (func_decl);\n@@ -373,6 +374,7 @@ make_thunk (function, delta, vcall_index, generate_with_vtable_p)\n       DECL_DEFERRED_FN (thunk) = 0;\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n+      SET_IDENTIFIER_GLOBAL_VALUE (thunk_id, thunk);\n     }\n   return thunk;\n }"}, {"sha": "1644f739aa0962f131e0adf4e2bf00e3daeb1b78", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 81, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -144,7 +144,6 @@ static tree tsubst_template_parms PARAMS ((tree, tree, int));\n static void regenerate_decl_from_template PARAMS ((tree, tree));\n static tree most_specialized PARAMS ((tree, tree, tree));\n static tree most_specialized_class PARAMS ((tree, tree));\n-static void set_mangled_name_for_template_decl PARAMS ((tree));\n static int template_class_depth_real PARAMS ((tree, int));\n static tree tsubst_aggr_type PARAMS ((tree, tree, int, tree, int));\n static tree tsubst_decl PARAMS ((tree, tree, tree));\n@@ -1678,24 +1677,6 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  TREE_PRIVATE (decl) = TREE_PRIVATE (gen_tmpl);\n \t  TREE_PROTECTED (decl) = TREE_PROTECTED (gen_tmpl);\n \n-\t  /* Mangle the function name appropriately.  Note that we do\n-\t     not mangle specializations of non-template member\n-\t     functions of template classes, e.g. with\n-\n-\t       template <class T> struct S { void f(); }\n-\n-\t     and given the specialization \n-\n-\t       template <> void S<int>::f() {}\n-\n-\t     we do not mangle S<int>::f() here.  That's because it's\n-\t     just an ordinary member function and doesn't need special\n-\t     treatment.  We do this here so that the ordinary,\n-\t     non-template, name-mangling algorithm will not be used\n-\t     later.  */\n-\t  if (is_member_template (tmpl) || ctype == NULL_TREE)\n-\t    set_mangled_name_for_template_decl (decl);\n-\n \t  if (is_friend && !have_def)\n \t    /* This is not really a declaration of a specialization.\n \t       It's just the name of an instantiation.  But, it's not\n@@ -4220,11 +4201,8 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n \t is set up.  */\n       if (TREE_CODE (t) != ENUMERAL_TYPE)\n \tDECL_NAME (type_decl) = classtype_mangled_name (t);\n-      DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n       if (!is_partial_instantiation)\n \t{\n-\t  DECL_ASSEMBLER_NAME (type_decl) = mangle_decl (type_decl);\n-\n \t  /* For backwards compatibility; code that uses\n \t     -fexternal-templates expects looking up a template to\n \t     instantiate it.  I think DDD still relies on this.\n@@ -4606,18 +4584,14 @@ tsubst_friend_function (decl, args)\n \t= DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (decl));\n     }\n \n-  /* The mangled name for the NEW_FRIEND is incorrect.  The call to\n-     tsubst will have resulted in a call to\n-     set_mangled_name_for_template_decl.  But, the function is not a\n-     template instantiation and should not be mangled like one.\n-     Therefore, we remangle the function name.  We don't have to do\n-     this if the NEW_FRIEND is a template since\n-     set_mangled_name_for_template_decl doesn't do anything if the\n-     function declaration still uses template arguments.  */\n+  /* The mangled name for the NEW_FRIEND is incorrect.  The function\n+     is not a template instantiation and should not be mangled like\n+     one.  Therefore, we forget the mangling here; we'll recompute it\n+     later if we need it.  */\n   if (TREE_CODE (new_friend) != TEMPLATE_DECL)\n     {\n-      set_mangled_name_for_decl (new_friend);\n       SET_DECL_RTL (new_friend, NULL_RTX);\n+      SET_DECL_ASSEMBLER_NAME (new_friend, NULL_TREE);\n     }\n       \n   if (DECL_NAMESPACE_SCOPE_P (new_friend))\n@@ -5805,6 +5779,9 @@ tsubst_decl (t, args, type)\n \tr = copy_decl (t);\n \tDECL_USE_TEMPLATE (r) = 0;\n \tTREE_TYPE (r) = type;\n+\t/* Clear out the mangled name and RTL for the instantiation.  */\n+\tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n+\tSET_DECL_RTL (r, NULL_RTX);\n \n \tDECL_CONTEXT (r) = ctx;\n \tDECL_VIRTUAL_CONTEXT (r)\n@@ -5839,47 +5816,16 @@ tsubst_decl (t, args, type)\n \t    TREE_CHAIN (DECL_CLONED_FUNCTION (r)) = r;\n \t  }\n \n-\t/* Set up the DECL_TEMPLATE_INFO for R and compute its mangled\n-\t   name.  There's no need to do this in the special friend\n-\t   case mentioned above where GEN_TMPL is NULL.  */\n+\t/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do\n+\t   this in the special friend case mentioned above where\n+\t   GEN_TMPL is NULL.  */\n \tif (gen_tmpl)\n \t  {\n \t    DECL_TEMPLATE_INFO (r) \n \t      = tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t    register_specialization (r, gen_tmpl, argvec);\n \n-\t    /* Set the mangled name for R.  */\n-\t    if (DECL_DESTRUCTOR_P (t)) \n-\t      set_mangled_name_for_decl (r);\n-\t    else \n-\t      {\n-\t\t/* Instantiations of template functions must be mangled\n-\t\t   specially, in order to conform to 14.5.5.1\n-\t\t   [temp.over.link].  */\n-\t\ttree tmpl = DECL_TI_TEMPLATE (t);\n-\t\t\n-\t\t/* TMPL will be NULL if this is a specialization of a\n-\t\t   member function of a template class.  */\n-\t\tif (tmpl == NULL_TREE\n-\t\t    || (member && !is_member_template (tmpl)\n-\t\t\t&& !DECL_TEMPLATE_INFO (tmpl)))\n-\t\t  set_mangled_name_for_decl (r);\n-\t\telse\n-\t\t  set_mangled_name_for_template_decl (r);\n-\t      }\n-\t    \n-\t    SET_DECL_RTL (r, NULL_RTX);\n-\t    \n-\t    /* Like grokfndecl.  If we don't do this, pushdecl will\n-\t       mess up our TREE_CHAIN because it doesn't find a\n-\t       previous decl.  Sigh.  */\n-\t    if (member\n-\t\t&& ! uses_template_parms (r)\n-\t\t&& (IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r)) \n-\t\t    == NULL_TREE))\n-\t      SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (r), r);\n-\n \t    /* We're not supposed to instantiate default arguments\n \t       until they are called, for a template.  But, for a\n \t       declaration like:\n@@ -6032,6 +5978,9 @@ tsubst_decl (t, args, type)\n \tTREE_TYPE (r) = type;\n \tc_apply_type_quals_to_decl (CP_TYPE_QUALS (type), r);\n \tDECL_CONTEXT (r) = ctx;\n+\t/* Clear out the mangled name and RTL for the instantiation.  */\n+\tSET_DECL_ASSEMBLER_NAME (r, NULL_TREE);\n+\tSET_DECL_RTL (r, NULL_RTX);\n \n \t/* Don't try to expand the initializer until someone tries to use\n \t   this variable; otherwise we run into circular dependencies.  */\n@@ -9762,7 +9711,7 @@ regenerate_decl_from_template (decl, tmpl)\n      functions, this is not so.  See tsubst_friend_function for\n      details.  */\n   DECL_TI_TEMPLATE (new_decl) = DECL_TI_TEMPLATE (decl);\n-  DECL_ASSEMBLER_NAME (new_decl) = DECL_ASSEMBLER_NAME (decl);\n+  COPY_DECL_ASSEMBLER_NAME (decl, new_decl);\n   COPY_DECL_RTL (decl, new_decl);\n   DECL_USE_TEMPLATE (new_decl) = DECL_USE_TEMPLATE (decl);\n \n@@ -10292,21 +10241,6 @@ get_mostly_instantiated_function_type (decl, contextp, tparmsp)\n   return fn_type;\n }\n \n-/* Set the DECL_ASSEMBLER_NAME for DECL, which is a FUNCTION_DECL that\n-   is either an instantiation or specialization of a template\n-   function.  */\n-\n-static void\n-set_mangled_name_for_template_decl (decl)\n-     tree decl;\n-{\n-  my_friendly_assert (TREE_CODE (decl) == FUNCTION_DECL, 0);\n-  my_friendly_assert (DECL_TEMPLATE_INFO (decl) != NULL_TREE, 0);\n-\n-  /* Under the new ABI, we don't need special machinery.  */\n-  set_mangled_name_for_decl (decl);\n-}\n-\n /* Return truthvalue if we're processing a template different from\n    the last one involved in diagnostics.  */\n int"}, {"sha": "49fc1ba5b1a760a82b54008b15841dee3fa774cf", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -354,7 +354,7 @@ get_tinfo_decl (type)\n       TREE_PUBLIC (d) = 1;\n       if (flag_weak || !typeinfo_in_lib_p (d))\n \tcomdat_linkage (d);\n-      DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n+      SET_DECL_ASSEMBLER_NAME (d, name);\n       cp_finish_decl (d, NULL_TREE, NULL_TREE, 0);\n \n       pushdecl_top_level (d);\n@@ -837,8 +837,8 @@ tinfo_base_init (desc, target)\n     comdat_linkage (name_decl);\n     /* The new ABI specifies the external name of the string\n        containing the type's name.  */\n-    DECL_ASSEMBLER_NAME (name_decl) \n-      = mangle_typeinfo_string_for_type (target);\n+    SET_DECL_ASSEMBLER_NAME (name_decl,\n+\t\t\t     mangle_typeinfo_string_for_type (target));\n     DECL_INITIAL (name_decl) = name_string;\n     cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n     pushdecl_top_level (name_decl);\n@@ -1243,7 +1243,7 @@ create_real_tinfo_var (target_type, name, type, init, non_public)\n       if (flag_weak || !typeinfo_in_lib_p (target_type))\n \tcomdat_linkage (decl);\n     }\n-  DECL_ASSEMBLER_NAME (decl) = name;\n+  SET_DECL_ASSEMBLER_NAME (decl, name);\n   DECL_INITIAL (decl) = init;\n   cp_finish_decl (decl, init, NULL_TREE, 0);\n   pushdecl_top_level (decl);"}, {"sha": "95ede8bcdea249c6d4938ada82298ba09be95756", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -649,8 +649,8 @@ lookup_field_1 (type, name)\n \t;\n       else if (DECL_NAME (field) == name)\n \t{\n-\t  if ((TREE_CODE(field) == VAR_DECL || TREE_CODE(field) == CONST_DECL)\n-\t      && DECL_ASSEMBLER_NAME (field) != NULL)\n+\t  if (TREE_CODE(field) == VAR_DECL \n+\t      && (TREE_STATIC (field) || DECL_EXTERNAL (field)))\n \t    GNU_xref_ref(current_function_decl,\n \t\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (field)));\n \t  return field;"}, {"sha": "dec0e8d0b4a2783424fd1d6def73795915534930", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1033,10 +1033,7 @@ finish_named_return_value (return_id, init)\n   if (return_id != NULL_TREE)\n     {\n       if (DECL_NAME (decl) == NULL_TREE)\n-\t{\n-\t  DECL_NAME (decl) = return_id;\n-\t  DECL_ASSEMBLER_NAME (decl) = return_id;\n-\t}\n+\tDECL_NAME (decl) = return_id;\n       else\n \t{\n \t  cp_error (\"return identifier `%D' already in place\", return_id);"}, {"sha": "93e12beeaf54a69de08842ed745486b50e2535ac", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -2319,6 +2319,7 @@ init_tree ()\n   make_lang_type_fn = cp_make_lang_type;\n   lang_unsave = cp_unsave;\n   lang_statement_code_p = cp_statement_code_p;\n+  lang_set_decl_assembler_name = mangle_decl;\n   list_hash_table = htab_create (31, list_hash, list_hash_eq, NULL);\n   ggc_add_root (&list_hash_table, 1, \n \t\tsizeof (list_hash_table),"}, {"sha": "fd9fc0c0284acb0b9ed9148488a3ef66c8a2600b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -833,10 +833,18 @@ dbxout_type_methods (type)\n \t{\n \t  /* This is the \"mangled\" name of the method.\n \t     It encodes the argument types.  */\n-\t  const char *debug_name =\n-\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+\t  const char *debug_name;\n \t  int show_arg_types = 0;\n \n+\t  /* Skip methods that aren't FUNCTION_DECLs.  (In C++, these\n+\t     include TEMPLATE_DECLs.)  The debugger doesn't know what\n+\t     to do with such entities anyhow.  */\n+\t  if (TREE_CODE (fndecl) != FUNCTION_DECL)\n+\t    continue;\n+\n+\t  debug_name =\n+\t    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n+\n \t  CONTIN;\n \n \t  last = fndecl;"}, {"sha": "78fc6804b627285ae0ef8db1741a5d68cb54831a", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1,3 +1,7 @@\n+Mon Mar 19 15:05:39 2001  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* com.c (builtin_function): Use SET_DECL_ASSEMBLER_NAME.\n+\n Wed Mar 14 09:29:27 2001  Mark Mitchell  <mark@codesourcery.com>\n \n \t* com.c (ffecom_member_phase_2): Use COPY_DECL_RTL,"}, {"sha": "bce0bbbb06c16e4e0de68a9d3e57ecb3e8bcdcc5", "filename": "gcc/f/com.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -13497,7 +13497,7 @@ builtin_function (const char *name, tree type, int function_code,\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n   make_decl_rtl (decl, NULL_PTR);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;"}, {"sha": "b82eb5b8df6edd8feda0cd8aedadef37893fe10d", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -373,13 +373,14 @@ ggc_mark_trees ()\n \t  ggc_mark_tree (DECL_RESULT_FLD (t));\n \t  ggc_mark_tree (DECL_INITIAL (t));\n \t  ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n-\t  ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n \t  ggc_mark_tree (DECL_SECTION_NAME (t));\n \t  ggc_mark_tree (DECL_MACHINE_ATTRIBUTES (t));\n \t  if (DECL_RTL_SET_P (t))\n \t    ggc_mark_rtx (DECL_RTL (t));\n \t  ggc_mark_rtx (DECL_LIVE_RANGE_RTL (t));\n \t  ggc_mark_tree (DECL_VINDEX (t));\n+\t  if (DECL_ASSEMBLER_NAME_SET_P (t))\n+\t    ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n \t  lang_mark_tree (t);\n \t  break;\n "}, {"sha": "3d1f6e4c70ea4cabbf1aaf3b1b5ace51034397b9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1,3 +1,12 @@\n+2001-03-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (build_class_ref): Use SET_DECL_ASSEMBLER_NAME.\n+\t(layout_class): Likewise.\n+\t(layout_class_method): Likewise.\n+\t(emit_register_classes): Likewise.\n+\t* decl.c (builtin_function): Likewise.\n+\t(give_name_to_locals): Likewise.\n+\n 2001-03-19  Per Bothner  <per@bothner.com>\n \n \t* jcf-parse.c (load_inner_classes):  Check CLASS_LOADED_P"}, {"sha": "6deb46e61d69c7b8fb36a80a1aa4b52cfe7256ac", "filename": "gcc/java/class.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -899,8 +899,9 @@ build_class_ref (type)\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_IGNORED_P (decl) = 1;\n \t      DECL_ARTIFICIAL (decl) = 1;\n-\t      DECL_ASSEMBLER_NAME (decl) = \n-\t\tjava_mangle_class_field (&temporary_obstack, type);\n+\t      SET_DECL_ASSEMBLER_NAME (decl, \n+\t\t\t\t       java_mangle_class_field\n+\t\t\t\t       (&temporary_obstack, type));\n \t      make_decl_rtl (decl, NULL);\n \t      pushdecl_top_level (decl);\n \t      if (is_compiled == 1)\n@@ -1701,8 +1702,9 @@ layout_class (this_class)\n       if (FIELD_STATIC (field))\n \t{\n \t  /* Set DECL_ASSEMBLER_NAME to something suitably mangled. */\n-\t  DECL_ASSEMBLER_NAME (field) = \n-\t    java_mangle_decl (&temporary_obstack, field);\n+\t  SET_DECL_ASSEMBLER_NAME (field,\n+\t\t\t\t   java_mangle_decl\n+\t\t\t\t   (&temporary_obstack, field));\n \t}\n     }\n \n@@ -1797,8 +1799,9 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n   TREE_PUBLIC (method_decl) = 1;\n \n   /* This is a good occasion to mangle the method's name */\n-  DECL_ASSEMBLER_NAME (method_decl) = \n-    java_mangle_decl (&temporary_obstack, method_decl);\n+  SET_DECL_ASSEMBLER_NAME (method_decl,\n+\t\t\t   java_mangle_decl (&temporary_obstack, \n+\t\t\t\t\t     method_decl));\n   /* We don't generate a RTL for the method if it's abstract, or if\n      it's an interface method that isn't clinit. */\n   if (! METHOD_ABSTRACT (method_decl) \n@@ -1878,7 +1881,7 @@ emit_register_classes ()\n   tree t;\n \n   init_decl = build_decl (FUNCTION_DECL, init_name, init_type);\n-  DECL_ASSEMBLER_NAME (init_decl) = init_name;\n+  SET_DECL_ASSEMBLER_NAME (init_decl, init_name);\n   TREE_STATIC (init_decl) = 1;\n   current_function_decl = init_decl;\n   DECL_RESULT (init_decl) = build_decl(RESULT_DECL, NULL_TREE, void_type_node);"}, {"sha": "1a68a0421383cfb2731c1c153c137a6c1eb17d05", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -377,7 +377,7 @@ builtin_function (name, type, function_code, class, library_name)\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   if (library_name)\n-    DECL_ASSEMBLER_NAME (decl) = get_identifier (library_name);\n+    SET_DECL_ASSEMBLER_NAME (decl, get_identifier (library_name));\n   make_decl_rtl (decl, NULL_PTR);\n   pushdecl (decl);\n   DECL_BUILT_IN_CLASS (decl) = class;\n@@ -1569,7 +1569,7 @@ give_name_to_locals (jcf)\n \t{\n \t  tree decl = TREE_VEC_ELT (decl_map, slot);\n \t  DECL_NAME (decl) = name;\n-\t  DECL_ASSEMBLER_NAME (decl) = name;\n+\t  SET_DECL_ASSEMBLER_NAME (decl, name);\n \t  if (TREE_CODE (decl) != PARM_DECL || TREE_TYPE (decl) != type)\n \t    warning (\"bad type in parameter debug info\");\n \t}\n@@ -1636,7 +1636,7 @@ give_name_to_locals (jcf)\n \t      sprintf (buffer, \"ARG_%d\", arg_i);\n \t      DECL_NAME (parm) = get_identifier (buffer);\n \t    }\n-\t  DECL_ASSEMBLER_NAME (parm) = DECL_NAME (parm);\n+\t  SET_DECL_ASSEMBLER_NAME (parm, DECL_NAME (parm));\n \t}\n     }\n }"}, {"sha": "55eab8b117c67d547b45417ede40eb12a551b1f7", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1108,7 +1108,6 @@ output_func_start_profiler ()\n   TREE_PUBLIC (fndecl) = 1;\n #endif\n \n-  DECL_ASSEMBLER_NAME (fndecl) = fnname;\n   DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n \n   fndecl = pushdecl (fndecl);"}, {"sha": "b4f7245297da4cce9fdf5e567702b0aa89d05283", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle1.C", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle1.C?ref=b90f4049d36e101e2090dd2c1a0595bdb3790ec2", "patch": "@@ -1,57 +0,0 @@\n-// Test for proper mangling by setting up name clashes.\n-\n-#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-#define NAME(OLD, NEW) OLD\n-#else\n-#define NAME(OLD, NEW) NEW\n-#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n-\n-class A { };\n-typedef A A2;\n-typedef int I;\n-typedef void V;\n-typedef I I2;\n-\n-void f (const A2&, int, const A2&, const A&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0T0, _Z1fRK1AiS1_S1_) = 0; // ERROR - name clash\n-\n-void f (int, long, int, I) { } // ERROR - name clash\n-int NAME (f__Filii, _Z1filii) = 0; // ERROR - name clash\n-\n-void f (I, float, I, I2) { } // ERROR - name clash\n-int NAME (f__Fifii, _Z1fifii) = 0; // ERROR - name clash\n-\n-void f (void*, float, void*, V*) { } // ERROR - name clash\n-int NAME (f__FPvfT0T0, _Z1fPvfS_S_) = 0; // ERROR - name clash\n-\n-void f (wchar_t) { } // ERROR - name clash\n-int NAME (f__Fw, _Z1fw) = 0; // ERROR - name clash\n-\n-void f(int, A, A2, A) { } // ERROR - name clash\n-int NAME (f__FiG1AN21, _Z1fi1AS_S_) = 0; // ERROR - name clash\n-\n-void f(const A2&, const A2&, const A2&, const A2&,\n-       int&) { } // ERROR - name clash\n-int NAME (f__FRC1AN30Ri, _Z1fRK1AS1_S1_S1_Ri) = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&,\n-       int&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20Ri, _Z1fRK1AiS1_S1_S1_Ri) = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&, int&, int&,\n-       int&) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20RiN25, _Z1fRK1AiS1_S1_S1_RiS2_S2_) = 0; // ERROR - name clash\n-\n-void f(const A2&, int, const A2&, const A2&, const A2&, int, int,\n-       int) { } // ERROR - name clash\n-int NAME (f__FRC1AiT0N20iii, _Z1fRK1AiS1_S1_S1_iii) = 0; // ERROR - name clash\n-\n-void f(bool, bool) {} // ERROR - name clash\n-int NAME (f__FbT0, _Z1fbb) = 0; // ERROR - name clash\n-\n-int\n-main ()\n-{\n-  return 0;\n-}\n-"}, {"sha": "25bab87a24986a52661014784ce8ea6827bc2203", "filename": "gcc/testsuite/g++.old-deja/g++.other/mangle2.C", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fmangle2.C?ref=b90f4049d36e101e2090dd2c1a0595bdb3790ec2", "patch": "@@ -1,24 +0,0 @@\n-// Test for overloaded operators in \"C\" linkage\n-// Build don't link:\n-\n-extern \"C\" {\n-typedef struct b\n-{\n-  int a;\n-} c;\n-\n-extern const c z;\n-\n-inline bool operator!=(const c& x, const c& y)\n-{\n-  return x.a != y.a;\n-}\n-};\n-\n-void foo();\n-\n-void bar(c x)\n-{\n-  if (x != z)\n-    foo();\n-}"}, {"sha": "4cd89ca6ac448e16a443ae6a851f348d85e4cb3b", "filename": "gcc/testsuite/g++.old-deja/g++.other/static8.C", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90f4049d36e101e2090dd2c1a0595bdb3790ec2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fstatic8.C?ref=b90f4049d36e101e2090dd2c1a0595bdb3790ec2", "patch": "@@ -1,12 +0,0 @@\n-// Build don't link:\n-// Origin: Mark Mitchell <mark@codesourcery.com>\n-\n-#if (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100)\n-#define NAME(OLD, NEW) OLD\n-#else\n-#define NAME(OLD, NEW) NEW\n-#endif /* (!defined (__GXX_ABI_VERSION) || __GXX_ABI_VERSION < 100) */\n-\n-static unsigned int strlen (const char*) {return 0;} // ERROR - previous declaration\n-\n-int NAME (strlen__FPCc, _Z6strlenPKc) = 0; // ERROR - duplicate declaration"}, {"sha": "573d7a2aa138460fa8f6db02e5419cd22f055f13", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -182,10 +182,42 @@ void (*lang_unsave_expr_now) PARAMS ((tree));\n /* If non-null, these are language-specific helper functions for\n    unsafe_for_reeval.  Return negative to not handle some tree.  */\n int (*lang_unsafe_for_reeval) PARAMS ((tree));\n+\n+/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of thing\n+   that the assembler should talk about, set DECL_ASSEMBLER_NAME to an\n+   appropriate IDENTIFIER_NODE.  Otherwise, set it to the\n+   ERROR_MARK_NODE to ensure that the assembler does not talk about\n+   it.  */\n+void (*lang_set_decl_assembler_name)     PARAMS ((tree));\n \f\n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n \f\n+/* Set the DECL_ASSEMBLER_NAME for DECL.  */\n+void\n+set_decl_assembler_name (decl)\n+     tree decl;\n+{\n+  /* The language-independent code should never use the\n+     DECL_ASSEMBLER_NAME for lots of DECLs.  Only FUNCTION_DECLs and\n+     VAR_DECLs for variables with static storage duration need a real\n+     DECL_ASSEMBLER_NAME.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      || (TREE_CODE (decl) == VAR_DECL \n+\t  && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))))\n+    /* By default, assume the name to use in assembly code is the\n+       same as that used in the source language.  (That's correct\n+       for C, and GCC used to set DECL_ASSEMBLER_NAME to the same\n+       value as DECL_NAME in build_decl, so this choice provides\n+       backwards compatibility with existing front-ends.  */\n+    SET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));\n+  else\n+    /* Nobody should ever be asking for the DECL_ASSEMBLER_NAME of\n+       these DECLs -- unless they're in language-dependent code, in\n+       which case lang_set_decl_assembler_name should handle things.  */\n+    abort ();\n+}\n+\f\n /* Init the principal obstacks.  */\n \n void\n@@ -199,6 +231,9 @@ init_obstacks ()\n   ggc_add_root (&type_hash_table, 1, sizeof type_hash_table, mark_type_hash);\n   ggc_add_tree_root (global_trees, TI_MAX);\n   ggc_add_tree_root (integer_types, itk_none);\n+\n+  /* Set lang_set_decl_set_assembler_name to a default value.  */\n+  lang_set_decl_assembler_name = set_decl_assembler_name;\n }\n \n void\n@@ -2557,7 +2592,6 @@ build_decl (code, name, type)\n    as the type can suppress useless errors in the use of this variable.  */\n \n   DECL_NAME (t) = name;\n-  DECL_ASSEMBLER_NAME (t) = name;\n   TREE_TYPE (t) = type;\n \n   if (code == VAR_DECL || code == PARM_DECL || code == RESULT_DECL)"}, {"sha": "e7a2df17ae5baefad3d78a59c5bb4a4a60ad683f", "filename": "gcc/tree.h", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -1255,11 +1255,37 @@ struct tree_type\n /* This is the name of the object as written by the user.\n    It is an IDENTIFIER_NODE.  */\n #define DECL_NAME(NODE) (DECL_CHECK (NODE)->decl.name)\n-/* This is the name of the object as the assembler will see it\n-   (but before any translations made by ASM_OUTPUT_LABELREF).\n-   Often this is the same as DECL_NAME.\n-   It is an IDENTIFIER_NODE.  */\n-#define DECL_ASSEMBLER_NAME(NODE) (DECL_CHECK (NODE)->decl.assembler_name)\n+/* The name of the object as the assembler will see it (but before any\n+   translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n+   as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n+#define DECL_ASSEMBLER_NAME(NODE)\t\t\\\n+  ((DECL_ASSEMBLER_NAME_SET_P (NODE)\t\t\\\n+    ? (void) 0\t\t\t\t\t\\\n+    : (*lang_set_decl_assembler_name) (NODE)),\t\\\n+   DECL_CHECK (NODE)->decl.assembler_name)\n+/* Returns non-zero if the DECL_ASSEMBLER_NAME for NODE has been \n+   set.  If zero, the NODE might still have a DECL_ASSEMBLER_NAME --\n+   it just hasn't been set yet.  */\n+#define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n+  (DECL_CHECK (NODE)->decl.assembler_name != NULL_TREE)\n+/* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n+#define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n+  (DECL_CHECK (NODE)->decl.assembler_name = (NAME))\n+/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if\n+   DECL1's DECL_ASSEMBLER_NAME has not yet been set, using this macro\n+   will not cause the DECL_ASSEMBLER_NAME of either DECL to be set.\n+   In other words, the semantics of using this macro, are different\n+   than saying:\n+     \n+     SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n+\n+   which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n+#define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n+  (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n+   ? (void) SET_DECL_ASSEMBLER_NAME (DECL2, \t\t\t\t\\\n+                                     DECL_ASSEMBLER_NAME (DECL1))\t\\\n+   : (void) 0)\n+\n /* Records the section name in a section attribute.  Used to pass\n    the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n #define DECL_SECTION_NAME(NODE) (DECL_CHECK (NODE)->decl.section_name)\n@@ -2497,6 +2523,7 @@ extern tree get_set_constructor_bits\t\tPARAMS ((tree, char *, int));\n extern tree get_set_constructor_bytes\t\tPARAMS ((tree,\n \t\t\t\t\t\t       unsigned char *, int));\n extern tree get_callee_fndecl                   PARAMS ((tree));\n+extern void set_decl_assembler_name             PARAMS ((tree));\n \f\n /* In stmt.c */\n \n@@ -2666,6 +2693,13 @@ extern int objects_must_conflict_p\t\tPARAMS ((tree, tree));\n /* In c-common.c */\n extern HOST_WIDE_INT lang_get_alias_set\t\tPARAMS ((tree));\n \n+/* Set the DECL_ASSEMBLER_NAME for a node.  If it is the sort of thing\n+   that the assembler should talk about, set DECL_ASSEMBLER_NAME to an\n+   appropriate IDENTIFIER_NODE.  Otherwise, set it to the\n+   ERROR_MARK_NODE to ensure that the assembler does not talk about\n+   it.  */\n+extern void (*lang_set_decl_assembler_name)     PARAMS ((tree));\n+\n struct obstack;\n \n /* In tree.c */"}, {"sha": "380df027acdbba1651334d239085cafbda781d27", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92643fea9381b2d137f19d19e28e24a61dc44b0c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=92643fea9381b2d137f19d19e28e24a61dc44b0c", "patch": "@@ -738,7 +738,7 @@ make_decl_rtl (decl, asmspec)\n \n   if (name != new_name)\n     {\n-      DECL_ASSEMBLER_NAME (decl) = get_identifier (new_name);\n+      SET_DECL_ASSEMBLER_NAME (decl, get_identifier (new_name));\n       name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n     }\n "}]}