{"sha": "ef3843807ecc4825706ae4277b81124ac3cd67eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzODQzODA3ZWNjNDgyNTcwNmFlNDI3N2I4MTEyNGFjM2NkNjdlYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-06-13T22:23:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-06-13T22:23:49Z"}, "message": "flow.c (insn_dead_p): Keep sets to PIC_OFFSET_TABLE_REGNUM alive before reload.\n\n        * flow.c (insn_dead_p): Keep sets to PIC_OFFSET_TABLE_REGNUM\n        alive before reload.\n\n        * haifa-sched.c (struct deps): Add in_post_call_group_p.\n        (add_dependence): Handle notes between SCHED_GROUP_P insns.\n        (remove_dependence): Always define.\n        (set_sched_group_p): New.\n        (sched_analyze_2): Use it.\n        (sched_analyze_insn): Don't special-case naked uses.  Look for\n        and extend in_post_call_group_p.\n        (sched_analyze): Clear stale SCHED_GROUP_P.  Set in_post_call_group_p.\n        (init_deps): Clear in_post_call_group_p.\n\nFrom-SVN: r34529", "tree": {"sha": "d176792f9bc4ea013b98e715c82ca606ceee997b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d176792f9bc4ea013b98e715c82ca606ceee997b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3843807ecc4825706ae4277b81124ac3cd67eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3843807ecc4825706ae4277b81124ac3cd67eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3843807ecc4825706ae4277b81124ac3cd67eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3843807ecc4825706ae4277b81124ac3cd67eb/comments", "author": null, "committer": null, "parents": [{"sha": "96cbf48b356f055114db997b653cf08cdf8a7535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cbf48b356f055114db997b653cf08cdf8a7535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96cbf48b356f055114db997b653cf08cdf8a7535"}], "stats": {"total": 232, "additions": 141, "deletions": 91}, "files": [{"sha": "18b53125756df0828a461abe4568aa79d835511f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef3843807ecc4825706ae4277b81124ac3cd67eb", "patch": "@@ -1,3 +1,18 @@\n+2000-06-13  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (insn_dead_p): Keep sets to PIC_OFFSET_TABLE_REGNUM\n+\talive before reload.\n+\n+\t* haifa-sched.c (struct deps): Add in_post_call_group_p.\n+\t(add_dependence): Handle notes between SCHED_GROUP_P insns.\n+\t(remove_dependence): Always define.\n+\t(set_sched_group_p): New.\n+\t(sched_analyze_2): Use it.\n+\t(sched_analyze_insn): Don't special-case naked uses.  Look for\n+\tand extend in_post_call_group_p.\n+\t(sched_analyze): Clear stale SCHED_GROUP_P.  Set in_post_call_group_p.\n+\t(init_deps): Clear in_post_call_group_p.\n+\n 2000-06-13  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (subst): Use CLASS_CANNOT_CHANGE_MODE and"}, {"sha": "99cfbfcff1222e2a6039af9838dcea2eb624d2b4", "filename": "gcc/flow.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ef3843807ecc4825706ae4277b81124ac3cd67eb", "patch": "@@ -3955,6 +3955,16 @@ insn_dead_p (pbi, x, call_ok, notes)\n \t\treturn 0;\n #endif\n \n+#ifdef PIC_OFFSET_TABLE_REGNUM\n+\t      /* Before reload, do not allow sets of the pic register\n+\t\t to be deleted.  Reload can insert references to\n+\t\t constant pool memory anywhere in the function, making\n+\t\t the PIC register live where it wasn't before.  */\n+\t      if (regno == PIC_OFFSET_TABLE_REGNUM && fixed_regs[regno]\n+\t\t  && ! reload_completed)\n+\t\treturn 0;\n+#endif\n+\n \t      /* Otherwise, the set is dead.  */\n \t      return 1;\n \t    }"}, {"sha": "63bdce043ffd2e517b44115e61ea172140f7b6b7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 116, "deletions": 91, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3843807ecc4825706ae4277b81124ac3cd67eb/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ef3843807ecc4825706ae4277b81124ac3cd67eb", "patch": "@@ -277,10 +277,14 @@ struct deps\n      the last function call, must depend on this.  */\n   rtx last_function_call;\n \n-  /* The LOG_LINKS field of this is a list of insns which use a pseudo register\n-     that does not already cross a call.  We create dependencies between each\n-     of those insn and the next call insn, to ensure that they won't cross a call\n-     after scheduling is done.  */\n+  /* Used to keep post-call psuedo/hard reg movements together with\n+     the call.  */\n+  int in_post_call_group_p;\n+\n+  /* The LOG_LINKS field of this is a list of insns which use a pseudo\n+     register that does not already cross a call.  We create\n+     dependencies between each of those insn and the next call insn,\n+     to ensure that they won't cross a call after scheduling is done.  */\n   rtx sched_before_next_call;\n \n   /* Element N is the next insn that sets (hard or pseudo) register\n@@ -466,10 +470,9 @@ static int q_size = 0;\n \n /* Forward declarations.  */\n static void add_dependence PARAMS ((rtx, rtx, enum reg_note));\n-#ifdef HAVE_cc0\n static void remove_dependence PARAMS ((rtx, rtx));\n-#endif\n static rtx find_insn_list PARAMS ((rtx, rtx));\n+static void set_sched_group_p PARAMS ((rtx));\n static int insn_unit PARAMS ((rtx));\n static unsigned int blockage_range PARAMS ((int, rtx));\n static void clear_units PARAMS ((void));\n@@ -822,26 +825,23 @@ add_dependence (insn, elem, dep_type)\n      When HAVE_cc0, it is possible for NOTEs to exist between users and\n      setters of the condition codes, so we must skip past notes here.\n      Otherwise, NOTEs are impossible here.  */\n-\n-  next = NEXT_INSN (elem);\n-\n-#ifdef HAVE_cc0\n-  while (next && GET_CODE (next) == NOTE)\n-    next = NEXT_INSN (next);\n-#endif\n-\n+  next = next_nonnote_insn (elem);\n   if (next && SCHED_GROUP_P (next)\n       && GET_CODE (next) != CODE_LABEL)\n     {\n       /* Notes will never intervene here though, so don't bother checking\n          for them.  */\n+      /* Hah!  Wrong.  */\n       /* We must reject CODE_LABELs, so that we don't get confused by one\n          that has LABEL_PRESERVE_P set, which is represented by the same\n          bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be\n          SCHED_GROUP_P.  */\n-      while (NEXT_INSN (next) && SCHED_GROUP_P (NEXT_INSN (next))\n-\t     && GET_CODE (NEXT_INSN (next)) != CODE_LABEL)\n-\tnext = NEXT_INSN (next);\n+\n+      rtx nnext;\n+      while ((nnext = next_nonnote_insn (next)) != NULL\n+\t     && SCHED_GROUP_P (nnext)\n+\t     && GET_CODE (nnext) != CODE_LABEL)\n+\tnext = nnext;\n \n       /* Again, don't depend an insn on itself.  */\n       if (insn == next)\n@@ -861,7 +861,6 @@ add_dependence (insn, elem, dep_type)\n       && (INSN_BB (elem) != INSN_BB (insn)))\n     return;\n \n-\n   /* If we already have a true dependency for ELEM, then we do not\n      need to do anything.  Avoiding the list walk below can cut\n      compile times dramatically for some code.  */\n@@ -903,7 +902,6 @@ add_dependence (insn, elem, dep_type)\n #endif\n }\n \n-#ifdef HAVE_cc0\n /* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n    of INSN.  Abort if not found.  */\n \n@@ -945,7 +943,51 @@ remove_dependence (insn, elem)\n     abort ();\n   return;\n }\n-#endif /* HAVE_cc0 */\n+\n+/* Return the INSN_LIST containing INSN in LIST, or NULL\n+   if LIST does not contain INSN.  */\n+\n+static inline rtx\n+find_insn_list (insn, list)\n+     rtx insn;\n+     rtx list;\n+{\n+  while (list)\n+    {\n+      if (XEXP (list, 0) == insn)\n+\treturn list;\n+      list = XEXP (list, 1);\n+    }\n+  return 0;\n+}\n+\n+/* Set SCHED_GROUP_P and care for the rest of the bookkeeping that\n+   goes along with that.  */\n+\n+static void\n+set_sched_group_p (insn)\n+     rtx insn;\n+{\n+  rtx link, prev;\n+\n+  SCHED_GROUP_P (insn) = 1;\n+\n+  /* There may be a note before this insn now, but all notes will\n+     be removed before we actually try to schedule the insns, so\n+     it won't cause a problem later.  We must avoid it here though.  */\n+  prev = prev_nonnote_insn (insn);\n+\n+  /* Make a copy of all dependencies on the immediately previous insn,\n+     and add to this insn.  This is so that all the dependencies will\n+     apply to the group.  Remove an explicit dependence on this insn\n+     as SCHED_GROUP_P now represents it.  */\n+\n+  if (find_insn_list (prev, LOG_LINKS (insn)))\n+    remove_dependence (insn, prev);\n+\n+  for (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n+    add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n+}\n \f\n #ifndef INSN_SCHEDULING\n void\n@@ -2711,24 +2753,6 @@ is_exception_free (insn, bb_src, bb_trg)\n    We are careful to build only dependencies which actually exist, and\n    use transitivity to avoid building too many links.  */\n \f\n-/* Return the INSN_LIST containing INSN in LIST, or NULL\n-   if LIST does not contain INSN.  */\n-\n-HAIFA_INLINE static rtx\n-find_insn_list (insn, list)\n-     rtx insn;\n-     rtx list;\n-{\n-  while (list)\n-    {\n-      if (XEXP (list, 0) == insn)\n-\treturn list;\n-      list = XEXP (list, 1);\n-    }\n-  return 0;\n-}\n-\n-\n /* Return 1 if the pair (insn, x) is found in (LIST, LIST1), or 0\n    otherwise.  */\n \n@@ -3430,30 +3454,9 @@ sched_analyze_2 (deps, x, insn)\n \n #ifdef HAVE_cc0\n     case CC0:\n-      {\n-\trtx link, prev;\n-\n-\t/* User of CC0 depends on immediately preceding insn.  */\n-\tSCHED_GROUP_P (insn) = 1;\n-\n-\t/* There may be a note before this insn now, but all notes will\n-\t   be removed before we actually try to schedule the insns, so\n-\t   it won't cause a problem later.  We must avoid it here though.  */\n-\tprev = prev_nonnote_insn (insn);\n-\n-\t/* Make a copy of all dependencies on the immediately previous insn,\n-\t   and add to this insn.  This is so that all the dependencies will\n-\t   apply to the group.  Remove an explicit dependence on this insn\n-\t   as SCHED_GROUP_P now represents it.  */\n-\n-\tif (find_insn_list (prev, LOG_LINKS (insn)))\n-\t  remove_dependence (insn, prev);\n-\n-\tfor (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n-\t  add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n-\n-\treturn;\n-      }\n+      /* User of CC0 depends on immediately preceding insn.  */\n+      set_sched_group_p (insn);\n+      return;\n #endif\n \n     case REG:\n@@ -3778,39 +3781,49 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n       reg_pending_sets_all = 0;\n     }\n \n-  /* Handle function calls and function returns created by the epilogue\n-     threading code.  */\n-  if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n+  /* If a post-call group is still open, see if it should remain so.\n+     This insn must be a simple move of a hard reg to a pseudo or\n+     vice-versa. \n+\n+     We must avoid moving these insns for correctness on\n+     SMALL_REGISTER_CLASS machines, and for special registers like\n+     PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all \n+     hard regs for all targets.  */\n+\n+  if (deps->in_post_call_group_p)\n     {\n-      rtx dep_insn;\n-      rtx prev_dep_insn;\n-\n-      /* When scheduling instructions, we make sure calls don't lose their\n-         accompanying USE insns by depending them one on another in order.\n-\n-         Also, we must do the same thing for returns created by the epilogue\n-         threading code.  Note this code works only in this special case,\n-         because other passes make no guarantee that they will never emit\n-         an instruction between a USE and a RETURN.  There is such a guarantee\n-         for USE instructions immediately before a call.  */\n-\n-      prev_dep_insn = insn;\n-      dep_insn = PREV_INSN (insn);\n-      while (GET_CODE (dep_insn) == INSN\n-\t     && GET_CODE (PATTERN (dep_insn)) == USE\n-\t     && GET_CODE (XEXP (PATTERN (dep_insn), 0)) == REG)\n-\t{\n-\t  SCHED_GROUP_P (prev_dep_insn) = 1;\n+      rtx tmp, set = single_set (insn);\n+      int src_regno, dest_regno;\n \n-\t  /* Make a copy of all dependencies on dep_insn, and add to insn.\n-\t     This is so that all of the dependencies will apply to the\n-\t     group.  */\n+      if (set == NULL)\n+\tgoto end_call_group;\n \n-\t  for (link = LOG_LINKS (dep_insn); link; link = XEXP (link, 1))\n-\t    add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n+      tmp = SET_DEST (set);\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG)\n+\tdest_regno = REGNO (tmp);\n+      else\n+\tgoto end_call_group;\n \n-\t  prev_dep_insn = dep_insn;\n-\t  dep_insn = PREV_INSN (dep_insn);\n+      tmp = SET_SRC (set);\n+      if (GET_CODE (tmp) == SUBREG)\n+\ttmp = SUBREG_REG (tmp);\n+      if (GET_CODE (tmp) == REG)\n+\tsrc_regno = REGNO (tmp);\n+      else\n+\tgoto end_call_group;\n+\n+      if (src_regno < FIRST_PSEUDO_REGISTER\n+\t  || dest_regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  set_sched_group_p (insn);\n+\t  CANT_MOVE (insn) = 1;\n+\t}\n+      else\n+\t{\n+\tend_call_group:\n+\t  deps->in_post_call_group_p = 0;\n \t}\n     }\n }\n@@ -3834,6 +3847,9 @@ sched_analyze (deps, head, tail)\n \t  /* Clear out the stale LOG_LINKS from flow.  */\n \t  free_INSN_LIST_list (&LOG_LINKS (insn));\n \n+\t  /* Clear out stale SCHED_GROUP_P.  */\n+\t  SCHED_GROUP_P (insn) = 0;\n+\n \t  /* Make each JUMP_INSN a scheduling barrier for memory\n              references.  */\n \t  if (GET_CODE (insn) == JUMP_INSN)\n@@ -3847,6 +3863,9 @@ sched_analyze (deps, head, tail)\n \t  rtx x;\n \t  register int i;\n \n+\t  /* Clear out stale SCHED_GROUP_P.  */\n+\t  SCHED_GROUP_P (insn) = 0;\n+\n \t  CANT_MOVE (insn) = 1;\n \n \t  /* Clear out the stale LOG_LINKS from flow.  */\n@@ -3933,6 +3952,11 @@ sched_analyze (deps, head, tail)\n \t  /* last_function_call is now a list of insns.  */\n \t  free_INSN_LIST_list (&deps->last_function_call);\n \t  deps->last_function_call = alloc_INSN_LIST (insn, NULL_RTX);\n+\n+\t  /* Before reload, begin a post-call group, so as to keep the \n+\t     lifetimes of hard registers correct.  */\n+\t  if (! reload_completed)\n+\t    deps->in_post_call_group_p = 1;\n \t}\n \n       /* See comments on reemit_notes as to why we do this.  \n@@ -6237,6 +6261,7 @@ init_deps (deps)\n   deps->pending_lists_length = 0;\n   deps->last_pending_memory_flush = 0;\n   deps->last_function_call = 0;\n+  deps->in_post_call_group_p = 0;\n \n   deps->sched_before_next_call\n     = gen_rtx_INSN (VOIDmode, 0, NULL_RTX, NULL_RTX,"}]}