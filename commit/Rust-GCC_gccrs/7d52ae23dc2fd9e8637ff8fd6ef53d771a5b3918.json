{"sha": "7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1MmFlMjNkYzJmZDllODYzN2ZmOGZkNmVmNTNkNzcxYTViMzkxOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-02-20T02:46:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-02-20T02:46:56Z"}, "message": "class.c (dfs_build_vcall_offset_vtbl_entries): Fix typo in comment.\n\n\t* class.c (dfs_build_vcall_offset_vtbl_entries): Fix typo in\n\tcomment.\n\t(build_vtable_entry): Don't assume all vtable entries are\n\tfunctions.\n\t(build_vtbl_initializer): Adjust accordingly.\n\t(get_vtable_decl): Fix formatting.\n\nFrom-SVN: r32069", "tree": {"sha": "3177f23010fb6a2a3042ab848605b5abb843d74a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3177f23010fb6a2a3042ab848605b5abb843d74a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918/comments", "author": null, "committer": null, "parents": [{"sha": "06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ceef4e7bd12a2097bef4cd68d8d7397dac83ff"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "031a77fdefcf45481aa489b255bd7e360acef911", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "patch": "@@ -1,3 +1,12 @@\n+2000-02-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (dfs_build_vcall_offset_vtbl_entries): Fix typo in\n+\tcomment.\n+\t(build_vtable_entry): Don't assume all vtable entries are\n+\tfunctions.\n+\t(build_vtbl_initializer): Adjust accordingly.\n+\t(get_vtable_decl): Fix formatting.\n+\t\n 2000-02-18  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* semantics.c (deferred_type_access_control): Walk the entire"}, {"sha": "f3f39ebe7f51d9ec8e5fdfeb25cdcf49fd2b80fd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7d52ae23dc2fd9e8637ff8fd6ef53d771a5b3918", "patch": "@@ -412,9 +412,8 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n       fn = TREE_VALUE (virtuals);\n       base = DECL_CONTEXT (fn);\n \n-      /* The FN is comes from BASE.  So, we must caculate the\n-\t adjustment from the virtual base that derived from BINFO to\n-\t BASE.  */\n+      /* The FN comes from BASE.  So, we must caculate the adjustment\n+\t from the virtual base that derived from BINFO to BASE.  */\n       base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n       offset = ssize_binop (MINUS_EXPR,\n \t\t\t    BINFO_OFFSET (base_binfo),\n@@ -684,23 +683,18 @@ build_vbase_path (code, type, expr, path, nonnull)\n \n /* Build an entry in the virtual function table.  DELTA is the offset\n    for the `this' pointer.  VCALL_INDEX is the vtable index containing\n-   the vcall offset; zero if none.  FNDECL is the virtual function\n-   itself.  */\n+   the vcall offset; zero if none.  ENTRY is the virtual function\n+   table entry itself.  It's TREE_TYPE must be VFUNC_PTR_TYPE_NODE,\n+   but it may not actually be a virtual function table pointer.  (For\n+   example, it might be the address of the RTTI object, under the new\n+   ABI.)  */\n \n static tree\n-build_vtable_entry (delta, vcall_index, fndecl)\n+build_vtable_entry (delta, vcall_index, entry)\n      tree delta;\n      tree vcall_index;\n-     tree fndecl;\n+     tree entry;\n {\n-  tree pfn;\n-\n-  /* Take the address of the function, considering it to be of an\n-     appropriate generic type.  */\n-  pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fndecl);\n-  /* The address of a function can't change.  */\n-  TREE_CONSTANT (pfn) = 1;\n-\n   if (flag_vtable_thunks)\n     {\n       HOST_WIDE_INT idelta;\n@@ -709,24 +703,24 @@ build_vtable_entry (delta, vcall_index, fndecl)\n       idelta = TREE_INT_CST_LOW (delta);\n       ivindex = TREE_INT_CST_LOW (vcall_index);\n       if ((idelta || ivindex) \n-\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (pfn, 0)))\n+\t  && ! DECL_PURE_VIRTUAL_P (TREE_OPERAND (entry, 0)))\n \t{\n-\t  pfn = make_thunk (pfn, idelta, ivindex);\n-\t  pfn = build1 (ADDR_EXPR, vtable_entry_type, pfn);\n-\t  TREE_READONLY (pfn) = 1;\n-\t  TREE_CONSTANT (pfn) = 1;\n+\t  entry = make_thunk (entry, idelta, ivindex);\n+\t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n+\t  TREE_READONLY (entry) = 1;\n+\t  TREE_CONSTANT (entry) = 1;\n \t}\n #ifdef GATHER_STATISTICS\n       n_vtable_entries += 1;\n #endif\n-      return pfn;\n+      return entry;\n     }\n   else\n     {\n       extern int flag_huge_objects;\n       tree elems = tree_cons (NULL_TREE, delta,\n \t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t build_tree_list (NULL_TREE, pfn)));\n+\t\t\t\t\t build_tree_list (NULL_TREE, entry)));\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n       /* We don't use vcall offsets when not using vtable thunks.  */\n@@ -1001,7 +995,8 @@ set_rtti_entry (virtuals, offset, type)\n    impossible to actually build the vtable, but is useful to get at those\n    which are known to exist in the runtime.  */\n \n-tree get_vtable_decl (type, complete)\n+tree \n+get_vtable_decl (type, complete)\n      tree type;\n      int complete;\n {\n@@ -2694,6 +2689,7 @@ build_vtbl_initializer (binfo, t)\n       tree delta;\n       tree vcall_index;\n       tree fn;\n+      tree pfn;\n       tree init;\n \n       /* Pull the offset for `this', and the function to call, out of\n@@ -2709,8 +2705,13 @@ build_vtbl_initializer (binfo, t)\n       if (DECL_PURE_VIRTUAL_P (fn))\n \tfn = abort_fndecl;\n \n-      /* Package up that information for the vtable.  */\n-      init = build_vtable_entry (delta, vcall_index, fn);\n+      /* Take the address of the function, considering it to be of an\n+\t appropriate generic type.  */\n+      pfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, fn);\n+      /* The address of a function can't change.  */\n+      TREE_CONSTANT (pfn) = 1;\n+      /* Enter it in the vtable.  */\n+      init = build_vtable_entry (delta, vcall_index, pfn);\n       /* And add it to the chain of initializers.  */\n       inits = tree_cons (NULL_TREE, init, inits);\n \n@@ -3128,6 +3129,7 @@ modify_all_vtables (t, has_virtual_p, overridden_virtuals)\n \t      /* We don't need to convert to a base class when calling\n \t\t this function.  */\n \t      DECL_VIRTUAL_CONTEXT (fn) = t;\n+\n \t      /* We don't need to adjust the `this' pointer when\n \t\t calling this function.  */\n \t      BV_DELTA (*fnsp) = integer_zero_node;"}]}