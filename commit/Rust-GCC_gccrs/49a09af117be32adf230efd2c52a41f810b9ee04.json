{"sha": "49a09af117be32adf230efd2c52a41f810b9ee04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlhMDlhZjExN2JlMzJhZGYyMzBlZmQyYzUyYTQxZjgxMGI5ZWUwNA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-08T19:57:59Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-08T20:02:18Z"}, "message": "d: Merge upstream dmd 955b8b36f.\n\nMerges AndAndExp and OrOrExp into a LogicalExp AST node.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 955b8b36f.\n\t* expr.cc (ExprVisitor::visit (AndAndExp *)): Rename type to ...\n\t(ExprVisitor::visit (LogicalExp *)): ... this.  Handle both 'and if'\n\tand 'or if' expression nodes.\n\t(ExprVisitor::visit (OrOrExp *)): Remove.", "tree": {"sha": "b80a467ae0cf80347884d81b45332229fe9a236a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b80a467ae0cf80347884d81b45332229fe9a236a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49a09af117be32adf230efd2c52a41f810b9ee04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a09af117be32adf230efd2c52a41f810b9ee04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a09af117be32adf230efd2c52a41f810b9ee04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a09af117be32adf230efd2c52a41f810b9ee04/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cd239614e43c9dcc0838845aec504e5eb938dbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd239614e43c9dcc0838845aec504e5eb938dbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd239614e43c9dcc0838845aec504e5eb938dbd"}], "stats": {"total": 340, "additions": 60, "deletions": 280}, "files": [{"sha": "e2ebd27b19b79d19164ff0c6456b9058ce90ade2", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -1,4 +1,4 @@\n-73d8e2fecb9e73422464b4cbf71f2b2967c9a75d\n+955b8b36f8bbacc59745b44cdf48ef1ddeb01bcd\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "ada1d8bc54fdb7d021406433589b676e8c53ec8d", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -4465,7 +4465,7 @@ class Interpreter : public Visitor\n         result = pue->exp();\n     }\n \n-    void visit(AndAndExp *e)\n+    void visit(LogicalExp *e)\n     {\n         // Check for an insidePointer expression, evaluate it if so\n         interpretFourPointerRelation(pue, e);\n@@ -4477,9 +4477,10 @@ class Interpreter : public Visitor\n             return;\n \n         int res;\n-        if (result->isBool(false))\n-            res = 0;\n-        else if (isTrueBool(result))\n+        const bool andand = e->op == TOKandand;\n+        if (andand ? result->isBool(false) : isTrueBool(result))\n+            res = !andand;\n+        else if (andand ? isTrueBool(result) : result->isBool(false))\n         {\n             UnionExp ue2;\n             result = interpret(&ue2, e->e2, istate);\n@@ -4497,64 +4498,14 @@ class Interpreter : public Visitor\n                 res = 1;\n             else\n             {\n-                result->error(\"%s does not evaluate to a boolean\", result->toChars());\n+                result->error(\"`%s` does not evaluate to a boolean\", result->toChars());\n                 result = CTFEExp::cantexp;\n                 return;\n             }\n         }\n         else\n         {\n-            result->error(\"%s cannot be interpreted as a boolean\", result->toChars());\n-            result = CTFEExp::cantexp;\n-            return;\n-        }\n-        if (goal != ctfeNeedNothing)\n-        {\n-            new(pue) IntegerExp(e->loc, res, e->type);\n-            result = pue->exp();\n-        }\n-    }\n-\n-    void visit(OrOrExp *e)\n-    {\n-        // Check for an insidePointer expression, evaluate it if so\n-        interpretFourPointerRelation(pue, e);\n-        if (result)\n-            return;\n-\n-        result = interpret(e->e1, istate);\n-        if (exceptionOrCant(result))\n-            return;\n-\n-        int res;\n-        if (isTrueBool(result))\n-            res = 1;\n-        else if (result->isBool(false))\n-        {\n-            UnionExp ue2;\n-            result = interpret(&ue2, e->e2, istate);\n-            if (exceptionOrCant(result))\n-                return;\n-            if (result->op == TOKvoidexp)\n-            {\n-                assert(e->type->ty == Tvoid);\n-                result = NULL;\n-                return;\n-            }\n-            if (result->isBool(false))\n-                res = 0;\n-            else if (isTrueBool(result))\n-                res = 1;\n-            else\n-            {\n-                result->error(\"%s cannot be interpreted as a boolean\", result->toChars());\n-                result = CTFEExp::cantexp;\n-                return;\n-            }\n-        }\n-        else\n-        {\n-            result->error(\"%s cannot be interpreted as a boolean\", result->toChars());\n+            result->error(\"`%s` cannot be interpreted as a boolean\", result->toChars());\n             result = CTFEExp::cantexp;\n             return;\n         }"}, {"sha": "0b21fc949c567408166c1473b726cbe0a5fa67e8", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -1895,7 +1895,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                     // edtor => (__gate || edtor)\n                     assert(tmp->edtor);\n                     Expression *e = tmp->edtor;\n-                    e = new OrOrExp(e->loc, new VarExp(e->loc, gate), e);\n+                    e = new LogicalExp(e->loc, TOKoror, new VarExp(e->loc, gate), e);\n                     tmp->edtor = semantic(e, sc);\n                     //printf(\"edtor: %s\\n\", tmp->edtor->toChars());\n                 }\n@@ -6457,28 +6457,12 @@ XorExp::XorExp(Loc loc, Expression *e1, Expression *e2)\n \n /************************************************************/\n \n-OrOrExp::OrOrExp(Loc loc, Expression *e1, Expression *e2)\n-        : BinExp(loc, TOKoror, sizeof(OrOrExp), e1, e2)\n+LogicalExp::LogicalExp(Loc loc, TOK op, Expression *e1, Expression *e2)\n+        : BinExp(loc, op, sizeof(LogicalExp), e1, e2)\n {\n }\n \n-Expression *OrOrExp::toBoolean(Scope *sc)\n-{\n-    Expression *ex2 = e2->toBoolean(sc);\n-    if (ex2->op == TOKerror)\n-        return ex2;\n-    e2 = ex2;\n-    return this;\n-}\n-\n-/************************************************************/\n-\n-AndAndExp::AndAndExp(Loc loc, Expression *e1, Expression *e2)\n-        : BinExp(loc, TOKandand, sizeof(AndAndExp), e1, e2)\n-{\n-}\n-\n-Expression *AndAndExp::toBoolean(Scope *sc)\n+Expression *LogicalExp::toBoolean(Scope *sc)\n {\n     Expression *ex2 = e2->toBoolean(sc);\n     if (ex2->op == TOKerror)\n@@ -6591,9 +6575,9 @@ void CondExp::hookDtors(Scope *sc)\n                     //printf(\"\\t++v = %s, v->edtor = %s\\n\", v->toChars(), v->edtor->toChars());\n                     Expression *ve = new VarExp(vcond->loc, vcond);\n                     if (isThen)\n-                        v->edtor = new AndAndExp(v->edtor->loc, ve, v->edtor);\n+                        v->edtor = new LogicalExp(v->edtor->loc, TOKandand, ve, v->edtor);\n                     else\n-                        v->edtor = new OrOrExp(v->edtor->loc, ve, v->edtor);\n+                        v->edtor = new LogicalExp(v->edtor->loc, TOKoror, ve, v->edtor);\n                     v->edtor = semantic(v->edtor, sc);\n                     //printf(\"\\t--v = %s, v->edtor = %s\\n\", v->toChars(), v->edtor->toChars());\n                 }"}, {"sha": "e353fdc96a5fd0f590124cc4f4c3b9eda42b6b36", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -1350,18 +1350,10 @@ class XorExp : public BinExp\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n-class OrOrExp : public BinExp\n+class LogicalExp : public BinExp\n {\n public:\n-    OrOrExp(Loc loc, Expression *e1, Expression *e2);\n-    Expression *toBoolean(Scope *sc);\n-    void accept(Visitor *v) { v->visit(this); }\n-};\n-\n-class AndAndExp : public BinExp\n-{\n-public:\n-    AndAndExp(Loc loc, Expression *e1, Expression *e2);\n+    LogicalExp(Loc loc, TOK op, Expression *e1, Expression *e2);\n     Expression *toBoolean(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };"}, {"sha": "e3a5cb36a82cdc1ae749b055971b76dd1093068b", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 3, "deletions": 82, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -7445,7 +7445,7 @@ class ExpressionSemanticVisitor : public Visitor\n         result = exp;\n     }\n \n-    void visit(OrOrExp *exp)\n+    void visit(LogicalExp *exp)\n     {\n         if (exp->type)\n         {\n@@ -7455,7 +7455,6 @@ class ExpressionSemanticVisitor : public Visitor\n \n         setNoderefOperands(exp);\n \n-        // same as for AndAnd\n         Expression *e1x = semantic(exp->e1, sc);\n \n         // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n@@ -7471,87 +7470,9 @@ class ExpressionSemanticVisitor : public Visitor\n             /* If in static if, don't evaluate e2 if we don't have to.\n             */\n             e1x = e1x->optimize(WANTvalue);\n-            if (e1x->isBool(true))\n+            if (e1x->isBool(exp->op == TOKoror))\n             {\n-                result = new IntegerExp(exp->loc, 1, Type::tbool);\n-                return;\n-            }\n-        }\n-\n-        Expression *e2x = semantic(exp->e2, sc);\n-        sc->mergeCallSuper(exp->loc, cs1);\n-\n-        // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n-        if (e2x->op == TOKtype)\n-            e2x = resolveAliasThis(sc, e2x);\n-\n-        e2x = resolveProperties(sc, e2x);\n-\n-        bool f1 = checkNonAssignmentArrayOp(e1x);\n-        bool f2 = checkNonAssignmentArrayOp(e2x);\n-        if (f1 || f2)\n-            return setError();\n-\n-        // Unless the right operand is 'void', the expression is converted to 'bool'.\n-        if (e2x->type->ty != Tvoid)\n-            e2x = e2x->toBoolean(sc);\n-\n-        if (e2x->op == TOKtype || e2x->op == TOKscope)\n-        {\n-            exp->error(\"%s is not an expression\", exp->e2->toChars());\n-            return setError();\n-        }\n-        if (e1x->op == TOKerror)\n-        {\n-            result = e1x;\n-            return;\n-        }\n-        if (e2x->op == TOKerror)\n-        {\n-            result = e2x;\n-            return;\n-        }\n-\n-        // The result type is 'bool', unless the right operand has type 'void'.\n-        if (e2x->type->ty == Tvoid)\n-            exp->type = Type::tvoid;\n-        else\n-            exp->type = Type::tbool;\n-\n-        exp->e1 = e1x;\n-        exp->e2 = e2x;\n-        result = exp;\n-    }\n-\n-    void visit(AndAndExp *exp)\n-    {\n-        if (exp->type)\n-        {\n-            result = exp;\n-            return;\n-        }\n-\n-        setNoderefOperands(exp);\n-\n-        // same as for OrOr\n-        Expression *e1x = semantic(exp->e1, sc);\n-\n-        // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n-        if (e1x->op == TOKtype)\n-            e1x = resolveAliasThis(sc, e1x);\n-\n-        e1x = resolveProperties(sc, e1x);\n-        e1x = e1x->toBoolean(sc);\n-        unsigned cs1 = sc->callSuper;\n-\n-        if (sc->flags & SCOPEcondition)\n-        {\n-            /* If in static if, don't evaluate e2 if we don't have to.\n-            */\n-            e1x = e1x->optimize(WANTvalue);\n-            if (e1x->isBool(false))\n-            {\n-                result = new IntegerExp(exp->loc, 0, Type::tbool);\n+                result = new IntegerExp(exp->loc, exp->op == TOKoror, Type::tbool);\n                 return;\n             }\n         }"}, {"sha": "66a0d235eee05bbdd384f5ff64c783fa97f6d24e", "filename": "gcc/d/dmd/opover.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fopover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fopover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -1106,9 +1106,9 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (!result)\n                             result = eeq;\n                         else if (e->op == TOKequal)\n-                            result = new AndAndExp(e->loc, result, eeq);\n+                            result = new LogicalExp(e->loc, TOKandand, result, eeq);\n                         else\n-                            result = new OrOrExp(e->loc, result, eeq);\n+                            result = new LogicalExp(e->loc, TOKoror, result, eeq);\n                     }\n                     assert(result);\n                 }"}, {"sha": "e907229be4c40bb41aeb55d17d6baf00b4e2bd26", "filename": "gcc/d/dmd/optimize.c", "status": "modified", "additions": 9, "deletions": 51, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -1095,65 +1095,23 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n             //printf(\"-SliceExp::optimize() %s\\n\", ret->toChars());\n         }\n \n-        void visit(AndAndExp *e)\n+        void visit(LogicalExp *e)\n         {\n-            //printf(\"AndAndExp::optimize(%d) %s\\n\", result, e->toChars());\n+            //printf(\"LogicalExp::optimize(%d) %s\\n\", result, e->toChars());\n             if (expOptimize(e->e1, WANTvalue))\n                 return;\n-\n-            if (e->e1->isBool(false))\n-            {\n-                // Replace with (e1, false)\n-                ret = new IntegerExp(e->loc, 0, Type::tbool);\n-                ret = Expression::combine(e->e1, ret);\n-                if (e->type->toBasetype()->ty == Tvoid)\n-                {\n-                    ret = new CastExp(e->loc, ret, Type::tvoid);\n-                    ret->type = e->type;\n-                }\n-                return;\n-            }\n-\n-            if (expOptimize(e->e2, WANTvalue))\n-                return;\n-\n-            if (e->e1->isConst())\n-            {\n-                if (e->e2->isConst())\n-                {\n-                    bool n1 = e->e1->isBool(true);\n-                    bool n2 = e->e2->isBool(true);\n-                    ret = new IntegerExp(e->loc, n1 && n2, e->type);\n-                }\n-                else if (e->e1->isBool(true))\n-                {\n-                    if (e->type->toBasetype()->ty == Tvoid)\n-                        ret = e->e2;\n-                    else\n-                    {\n-                        ret = new CastExp(e->loc, e->e2, e->type);\n-                        ret->type = e->type;\n-                    }\n-                }\n-            }\n-        }\n-\n-        void visit(OrOrExp *e)\n-        {\n-            //printf(\"OrOrExp::optimize(%d) %s\\n\", result, e->toChars());\n-            if (expOptimize(e->e1, WANTvalue))\n-                return;\n-\n-            if (e->e1->isBool(true))\n+            const bool oror = e->op == TOKoror;\n+            if (e->e1->isBool(oror))\n             {\n-                // Replace with (e1, true)\n-                ret = new IntegerExp(e->loc, 1, Type::tbool);\n+                // Replace with (e1, oror)\n+                ret = new IntegerExp(e->loc, oror, Type::tbool);\n                 ret = Expression::combine(e->e1, ret);\n                 if (e->type->toBasetype()->ty == Tvoid)\n                 {\n                     ret = new CastExp(e->loc, ret, Type::tvoid);\n                     ret->type = e->type;\n                 }\n+                ret = ret->optimize(result);\n                 return;\n             }\n \n@@ -1166,9 +1124,9 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n                 {\n                     bool n1 = e->e1->isBool(true);\n                     bool n2 = e->e2->isBool(true);\n-                    ret = new IntegerExp(e->loc, n1 || n2, e->type);\n+                    ret = new IntegerExp(e->loc, oror ? (n1 || n2) : (n1 && n2), e->type);\n                 }\n-                else if (e->e1->isBool(false))\n+                else if (e->e1->isBool(!oror))\n                 {\n                     if (e->type->toBasetype()->ty == Tvoid)\n                         ret = e->e2;"}, {"sha": "4aec7a46e7b23ccd1bd908aec007203dcba89a8c", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -7773,7 +7773,7 @@ Expression *Parser::parseAndAndExp()\n     {\n         nextToken();\n         e2 = parseOrExp();\n-        e = new AndAndExp(loc, e, e2);\n+        e = new LogicalExp(loc, TOKandand, e, e2);\n     }\n     return e;\n }\n@@ -7789,7 +7789,7 @@ Expression *Parser::parseOrOrExp()\n     {\n         nextToken();\n         e2 = parseAndAndExp();\n-        e = new OrOrExp(loc, e, e2);\n+        e = new LogicalExp(loc, TOKoror, e, e2);\n     }\n     return e;\n }"}, {"sha": "efab276d8496fae7807a0f0c2c517b5a355c801a", "filename": "gcc/d/dmd/sideeffect.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fsideeffect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fsideeffect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -301,15 +301,10 @@ bool discardValue(Expression *e)\n             return true;\n \n         case TOKandand:\n-        {\n-            AndAndExp *aae = (AndAndExp *)e;\n-            return discardValue(aae->e2);\n-        }\n-\n         case TOKoror:\n         {\n-            OrOrExp *ooe = (OrOrExp *)e;\n-            return discardValue(ooe->e2);\n+            LogicalExp *aae = (LogicalExp  *)e;\n+            return discardValue(aae->e2);\n         }\n \n         case TOKquestion:"}, {"sha": "48a60d34fb1b91841522d426eef968e8cff22cb9", "filename": "gcc/d/dmd/staticcond.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fstaticcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fstaticcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.c?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -28,25 +28,23 @@ Expression *semantic(Expression *e, Scope *sc);\n \n bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors)\n {\n-    if (e->op == TOKandand)\n+    if (e->op == TOKandand || e->op == TOKoror)\n     {\n-        AndAndExp *aae = (AndAndExp *)e;\n+        LogicalExp *aae = (LogicalExp *)e;\n         bool result = evalStaticCondition(sc, exp, aae->e1, errors);\n-        if (errors || !result)\n-            return false;\n-        result = evalStaticCondition(sc, exp, aae->e2, errors);\n-        return !errors && result;\n-    }\n-\n-    if (e->op == TOKoror)\n-    {\n-        OrOrExp *ooe = (OrOrExp *)e;\n-        bool result = evalStaticCondition(sc, exp, ooe->e1, errors);\n         if (errors)\n             return false;\n-        if (result)\n-            return true;\n-        result = evalStaticCondition(sc, exp, ooe->e2, errors);\n+        if (e->op == TOKandand)\n+        {\n+            if (!result)\n+                return false;\n+        }\n+        else\n+        {\n+            if (result)\n+                return true;\n+        }\n+        result = evalStaticCondition(sc, exp, aae->e2, errors);\n         return !errors && result;\n     }\n "}, {"sha": "8093c94cfeec2045f0eb5ea04c06c0ac21e75304", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -269,8 +269,7 @@ class UshrExp;\n class AndExp;\n class OrExp;\n class XorExp;\n-class OrOrExp;\n-class AndAndExp;\n+class LogicalExp;\n class CmpExp;\n class InExp;\n class RemoveExp;\n@@ -563,8 +562,7 @@ class Visitor\n     virtual void visit(AndExp *e) { visit((BinExp *)e); }\n     virtual void visit(OrExp *e) { visit((BinExp *)e); }\n     virtual void visit(XorExp *e) { visit((BinExp *)e); }\n-    virtual void visit(OrOrExp *e) { visit((BinExp *)e); }\n-    virtual void visit(AndAndExp *e) { visit((BinExp *)e); }\n+    virtual void visit(LogicalExp *e) { visit((BinExp *)e); }\n     virtual void visit(CmpExp *e) { visit((BinExp *)e); }\n     virtual void visit(InExp *e) { visit((BinExp *)e); }\n     virtual void visit(RemoveExp *e) { visit((BinExp *)e); }"}, {"sha": "41d97964dd3e9c7fe694df59805e0e19cdd25326", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49a09af117be32adf230efd2c52a41f810b9ee04/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=49a09af117be32adf230efd2c52a41f810b9ee04", "patch": "@@ -545,11 +545,14 @@ class ExprVisitor : public Visitor\n     this->result_ = d_convert (build_ctype (e->type), result);\n   }\n \n-  /* Build an `and if' expression.  If the right operand expression is void,\n-     then the resulting type is void.  Otherwise the result is bool.  */\n+  /* Build a logical `and if' or `or if' expression.  If the right operand\n+     expression is void, then the resulting type is void.  Otherwise the\n+     result is bool.  */\n \n-  void visit (AndAndExp *e)\n+  void visit (LogicalExp *e)\n   {\n+    tree_code code = (e->op == TOKandand) ? TRUTH_ANDIF_EXPR : TRUTH_ORIF_EXPR;\n+\n     if (e->e2->type->toBasetype ()->ty != Tvoid)\n       {\n \ttree t1 = build_expr (e->e1);\n@@ -559,39 +562,19 @@ class ExprVisitor : public Visitor\n \tt2 = convert_for_condition (t2, e->e2->type);\n \n \tthis->result_ = d_convert (build_ctype (e->type),\n-\t\t\t\t   build_boolop (TRUTH_ANDIF_EXPR, t1, t2));\n+\t\t\t\t   build_boolop (code, t1, t2));\n       }\n     else\n       {\n \ttree t1 = convert_for_condition (build_expr (e->e1), e->e1->type);\n \ttree t2 = build_expr_dtor (e->e2);\n \n-\tthis->result_ = build_condition (build_ctype (e->type),\n-\t\t\t\t\t t1, t2, void_node);\n-      }\n-  }\n-\n-  /* Build an `or if' expression.  If the right operand expression is void,\n-     then the resulting type is void.  Otherwise the result is bool.  */\n-\n-  void visit (OrOrExp *e)\n-  {\n-    if (e->e2->type->toBasetype ()->ty != Tvoid)\n-      {\n-\ttree t1 = convert_for_condition (build_expr (e->e1), e->e1->type);\n-\ttree t2 = convert_for_condition (build_expr (e->e2), e->e2->type);\n-\n-\tthis->result_ = d_convert (build_ctype (e->type),\n-\t\t\t\t   build_boolop (TRUTH_ORIF_EXPR, t1, t2));\n-      }\n-    else\n-      {\n-\ttree t1 = convert_for_condition (build_expr (e->e1), e->e1->type);\n-\ttree t2 = build_expr_dtor (e->e2);\n-\ttree cond = build1 (TRUTH_NOT_EXPR, d_bool_type, t1);\n+\t/* Invert condition for logical or if expression.  */\n+\tif (e->op == TOKoror)\n+\t  t1 = build1 (TRUTH_NOT_EXPR, d_bool_type, t1);\n \n \tthis->result_ = build_condition (build_ctype (e->type),\n-\t\t\t\t\t cond, t2, void_node);\n+\t\t\t\t\t t1, t2, void_node);\n       }\n   }\n "}]}