{"sha": "635072248a426c933c74ef4431e82401249b6218", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1MDcyMjQ4YTQyNmM5MzNjNzRlZjQ0MzFlODI0MDEyNDliNjIxOA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-09-10T21:27:43Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-10-07T21:11:37Z"}, "message": "c++: Fix P0846 (ADL and function templates) in template [PR97010]\n\nTo quickly recap, P0846 says that a name is also considered to refer to\na template if it is an unqualified-id followed by a < and name lookup\nfinds either one or more functions or finds nothing.\n\nIn a template, when parsing a function call that has type-dependent\narguments, we can't perform ADL right away so we set KOENIG_LOOKUP_P in\nthe call to remember to do it when instantiating the call\n(tsubst_copy_and_build/CALL_EXPR).  When the called function is a\nfunction template, we represent the call with a TEMPLATE_ID_EXPR;\nusually the operand is an OVERLOAD.\n\nIn the P0846 case though, the operand can be an IDENTIFIER_NODE, when\nname lookup found nothing when parsing the template name.  But we\nweren't handling this correctly in tsubst_copy_and_build.  First\nwe need to pass the FUNCTION_P argument from <case TEMPLATE_ID_EXPR> to\n<case IDENTIFIER_NODE>, otherwise we give a bogus error.  And then in\n<case CALL_EXPR> we need to perform ADL.  The rest of the changes is to\ngive better errors when ADL didn't find anything.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97010\n\t* pt.c (tsubst_copy_and_build) <case TEMPLATE_ID_EXPR>: Call\n\ttsubst_copy_and_build explicitly instead of using the RECUR macro.\n\tHandle a TEMPLATE_ID_EXPR with an IDENTIFIER_NODE as its operand.\n\t<case CALL_EXPR>: Perform ADL for a TEMPLATE_ID_EXPR with an\n\tIDENTIFIER_NODE as its operand.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97010\n\t* g++.dg/cpp2a/fn-template21.C: New test.\n\t* g++.dg/cpp2a/fn-template22.C: New test.", "tree": {"sha": "7fe1c8448401684da9f7960a77ffb6f8b13aaf7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe1c8448401684da9f7960a77ffb6f8b13aaf7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/635072248a426c933c74ef4431e82401249b6218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635072248a426c933c74ef4431e82401249b6218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635072248a426c933c74ef4431e82401249b6218", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635072248a426c933c74ef4431e82401249b6218/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45376dc0f426c0fc39c5ee77937c928c27fab77a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45376dc0f426c0fc39c5ee77937c928c27fab77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45376dc0f426c0fc39c5ee77937c928c27fab77a"}], "stats": {"total": 86, "additions": 77, "deletions": 9}, "files": [{"sha": "d9cc7766a5907aa4fb68575a545f9550cf74d3d8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635072248a426c933c74ef4431e82401249b6218/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635072248a426c933c74ef4431e82401249b6218/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=635072248a426c933c74ef4431e82401249b6218", "patch": "@@ -19278,7 +19278,8 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n }\n \n /* Like tsubst but deals with expressions and performs semantic\n-   analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\".  */\n+   analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\" or\n+   \"F<TARGS> (ARGS)\".  */\n \n tree\n tsubst_copy_and_build (tree t,\n@@ -19360,7 +19361,10 @@ tsubst_copy_and_build (tree t,\n     case TEMPLATE_ID_EXPR:\n       {\n \ttree object;\n-\ttree templ = RECUR (TREE_OPERAND (t, 0));\n+\ttree templ = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n+\t\t\t\t\t    complain, in_decl,\n+\t\t\t\t\t    function_p,\n+\t\t\t\t\t    integral_constant_expression_p);\n \ttree targs = TREE_OPERAND (t, 1);\n \n \tif (targs)\n@@ -19407,13 +19411,21 @@ tsubst_copy_and_build (tree t,\n \t  }\n \telse\n \t  object = NULL_TREE;\n-\ttempl = lookup_template_function (templ, targs);\n+\n+\ttree tid = lookup_template_function (templ, targs);\n \n \tif (object)\n-\t  RETURN (build3 (COMPONENT_REF, TREE_TYPE (templ),\n-\t\t\t object, templ, NULL_TREE));\n+\t  RETURN (build3 (COMPONENT_REF, TREE_TYPE (tid),\n+\t\t\t object, tid, NULL_TREE));\n+\telse if (identifier_p (templ))\n+\t  {\n+\t    /* C++20 P0846: we can encounter an IDENTIFIER_NODE here when\n+\t       name lookup found nothing when parsing the template name.  */\n+\t    gcc_assert (cxx_dialect >= cxx20 || seen_error ());\n+\t    RETURN (tid);\n+\t  }\n \telse\n-\t  RETURN (baselink_for_fns (templ));\n+\t  RETURN (baselink_for_fns (tid));\n       }\n \n     case INDIRECT_REF:\n@@ -20004,24 +20016,31 @@ tsubst_copy_and_build (tree t,\n \n \t/* We do not perform argument-dependent lookup if normal\n \t   lookup finds a non-function, in accordance with the\n-\t   expected resolution of DR 218.  */\n+\t   resolution of DR 218.  */\n \tif (koenig_p\n \t    && ((is_overloaded_fn (function)\n \t\t /* If lookup found a member function, the Koenig lookup is\n \t\t    not appropriate, even if an unqualified-name was used\n \t\t    to denote the function.  */\n \t\t && !DECL_FUNCTION_MEMBER_P (get_first_fn (function)))\n-\t\t|| identifier_p (function))\n+\t\t|| identifier_p (function)\n+\t\t/* C++20 P0846: Lookup found nothing.  */\n+\t\t|| (TREE_CODE (function) == TEMPLATE_ID_EXPR\n+\t\t    && identifier_p (TREE_OPERAND (function, 0))))\n \t    /* Only do this when substitution turns a dependent call\n \t       into a non-dependent call.  */\n \t    && type_dependent_expression_p_push (t)\n \t    && !any_type_dependent_arguments_p (call_args))\n \t  function = perform_koenig_lookup (function, call_args, tf_none);\n \n \tif (function != NULL_TREE\n-\t    && identifier_p (function)\n+\t    && (identifier_p (function)\n+\t\t|| (TREE_CODE (function) == TEMPLATE_ID_EXPR\n+\t\t    && identifier_p (TREE_OPERAND (function, 0))))\n \t    && !any_type_dependent_arguments_p (call_args))\n \t  {\n+\t    if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n+\t      function = TREE_OPERAND (function, 0);\n \t    if (koenig_p && (complain & tf_warning_or_error))\n \t      {\n \t\t/* For backwards compatibility and good diagnostics, try"}, {"sha": "7b3f26bbfa03c70bf9697e86e34b396d6c736285", "filename": "gcc/testsuite/g++.dg/cpp2a/fn-template21.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635072248a426c933c74ef4431e82401249b6218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635072248a426c933c74ef4431e82401249b6218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template21.C?ref=635072248a426c933c74ef4431e82401249b6218", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/97010\n+// { dg-do compile { target c++20 } }\n+\n+namespace M {\n+  struct S { int x; };\n+  S foo ();\n+\n+  template<typename>\n+  void get (S);\n+}\n+\n+template<typename T>\n+void bar (const T& t)\n+{\n+  get<int>(t);\n+}\n+\n+int\n+main ()\n+{\n+  auto a = M::foo ();\n+  get<int>(a);\n+  bar (a);\n+}"}, {"sha": "62cc81db0c75d18f8632b5d38c7935e0fd359a87", "filename": "gcc/testsuite/g++.dg/cpp2a/fn-template22.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635072248a426c933c74ef4431e82401249b6218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635072248a426c933c74ef4431e82401249b6218/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffn-template22.C?ref=635072248a426c933c74ef4431e82401249b6218", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/97010\n+// { dg-do compile { target c++20 } }\n+\n+namespace M {\n+  struct S { int x; };\n+  S foo ();\n+\n+// Test not-found-by-ADL scenario.\n+// template<typename>\n+// void get (S);\n+}\n+\n+template<typename T>\n+void bar (const T& t)\n+{\n+  get<int>(t); // { dg-error \".get. was not declared in this scope\" }\n+}\n+\n+int\n+main ()\n+{\n+  auto a = M::foo ();\n+  get<int>(a); // { dg-error \".get. was not declared in this scope\" }\n+  bar (a);\n+}"}]}