{"sha": "52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJlZWVmM2FjYTVhNzFlYTFhODM2Yjg2YjYyZjdiOGZkMGIxZmRlMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-05T01:54:36Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-05T01:54:36Z"}, "message": "Initial revision\n\nFrom-SVN: r98", "tree": {"sha": "9e0d2dfa97780927b371e732fdafa7323078cda3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e0d2dfa97780927b371e732fdafa7323078cda3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2/comments", "author": null, "committer": null, "parents": [{"sha": "1ca3705eadb87d1646c2ca716ff478a55465fc31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca3705eadb87d1646c2ca716ff478a55465fc31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ca3705eadb87d1646c2ca716ff478a55465fc31"}], "stats": {"total": 579, "additions": 579, "deletions": 0}, "files": [{"sha": "ff5aacb90ee99fdbc0f086bc749278b861f6da71", "filename": "gcc/print-tree.c", "status": "added", "additions": 579, "deletions": 0, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=52eeef3aca5a71ea1a836b86b62f7b8fd0b1fde2", "patch": "@@ -0,0 +1,579 @@\n+/* Prints out tree in human readable form - GNU C-compiler\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include <stdio.h>\n+\n+extern char **tree_code_name;\n+\n+extern char *mode_name[];\n+\n+void print_node ();\n+void indent_to ();\n+\n+/* Define the hash table of nodes already seen.\n+   Such nodes are not repeated; brief cross-references are used.  */\n+\n+#define HASH_SIZE 37\n+\n+struct bucket\n+{\n+  tree node;\n+  struct bucket *next;\n+};\n+\n+static struct bucket **table;\n+\n+/* Print the node NODE on standard error, for debugging.\n+   Most nodes referred to by this one are printed recursively\n+   down to a depth of six.  */\n+\n+void\n+debug_tree (node)\n+     tree node;\n+{\n+  char *object = (char *) oballoc (0);\n+  table = (struct bucket **) oballoc (HASH_SIZE * sizeof (struct bucket *));\n+  bzero (table, HASH_SIZE * sizeof (struct bucket *));\n+  print_node (stderr, \"\", node, 0);\n+  table = 0;\n+  obfree (object);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+/* Print a node in brief fashion, with just the code, address and name.  */\n+\n+void\n+print_node_brief (file, prefix, node, indent)\n+     FILE *file;\n+     char *prefix;\n+     tree node;\n+     int indent;\n+{\n+  char class;\n+\n+  if (node == 0)\n+    return;\n+\n+  class = TREE_CODE_CLASS (TREE_CODE (node));\n+\n+  /* Always print the slot this node is in, and its code, address and\n+     name if any.  */\n+  if (indent > 0)\n+    fprintf (file, \" \");\n+  fprintf (file, \"%s <%s %x\", prefix,\n+\t   tree_code_name[(int) TREE_CODE (node)], (int) node);\n+\n+  if (class == 'd')\n+    {\n+      if (DECL_NAME (node))\n+\tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n+    }\n+  else if (class == 't')\n+    {\n+      if (TYPE_NAME (node))\n+\t{\n+\t  if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n+\t    fprintf (file, \" %s\", IDENTIFIER_POINTER (TYPE_NAME (node)));\n+\t  else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n+\t\t   && DECL_NAME (TYPE_NAME (node)))\n+\t    fprintf (file, \" %s\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node))));\n+\t}\n+    }\n+  if (TREE_CODE (node) == IDENTIFIER_NODE)\n+    fprintf (file, \" %s\", IDENTIFIER_POINTER (node));\n+  /* We might as well always print the value of an integer.  */\n+  if (TREE_CODE (node) == INTEGER_CST)\n+    {\n+      if (TREE_INT_CST_HIGH (node) == 0)\n+\tfprintf (file, \" %1u\", TREE_INT_CST_LOW (node));\n+      else if (TREE_INT_CST_HIGH (node) == -1\n+\t       && TREE_INT_CST_LOW (node) != 0)\n+\tfprintf (file, \" -%1u\", -TREE_INT_CST_LOW (node));\n+      else\n+\tfprintf (file, \" 0x%x%08x\",\n+\t\t TREE_INT_CST_HIGH (node),\n+\t\t TREE_INT_CST_LOW (node));\n+    }\n+  if (TREE_CODE (node) == REAL_CST)\n+    {\n+#ifndef REAL_IS_NOT_DOUBLE\n+      fprintf (file, \" %e\", TREE_REAL_CST (node));\n+#else\n+      {\n+\tint i;\n+\tchar *p = (char *) &TREE_REAL_CST (node);\n+\tfprintf (file, \" 0x\");\n+\tfor (i = 0; i < sizeof TREE_REAL_CST (node); i++)\n+\t  fprintf (file, \"%02x\", *p++);\n+\tfprintf (file, \"\");\n+      }\n+#endif /* REAL_IS_NOT_DOUBLE */\n+    }\n+\n+  fprintf (file, \">\");\n+}\n+\n+void\n+indent_to (file, column)\n+     FILE *file;\n+     int column;\n+{\n+  int i;\n+\n+  /* Since this is the long way, indent to desired column.  */\n+  if (column > 0)\n+    fprintf (file, \"\\n\");\n+  for (i = 0; i < column; i++)\n+    fprintf (file, \" \");\n+}\n+\f\n+/* Print the node NODE in full on file FILE, preceded by PREFIX,\n+   starting in column INDENT.  */\n+\n+void\n+print_node (file, prefix, node, indent)\n+     FILE *file;\n+     char *prefix;\n+     tree node;\n+     int indent;\n+{\n+  int hash;\n+  struct bucket *b;\n+  enum machine_mode mode;\n+  char class;\n+  int len;\n+  int first_rtl;\n+  int i;\n+\n+  if (node == 0)\n+    return;\n+\n+  class = TREE_CODE_CLASS (TREE_CODE (node));\n+\n+  /* Don't get too deep in nesting.  If the user wants to see deeper,\n+     it is easy to use the address of a lowest-level node\n+     as an argument in another call to debug_tree.  */\n+\n+  if (indent > 24)\n+    {\n+      print_node_brief (file, prefix, node, indent);\n+      return;\n+    }\n+\n+  if (indent > 8 && (class == 't' || class == 'd'))\n+    {\n+      print_node_brief (file, prefix, node, indent);\n+      return;\n+    }\n+\n+  /* It is unsafe to look at any other filds of an ERROR_MARK node. */\n+  if (TREE_CODE (node) == ERROR_MARK)\n+    {\n+      print_node_brief (file, prefix, node, indent);\n+      return;\n+    }\n+\n+  hash = ((int) node & ~(1 << (HOST_BITS_PER_INT - 1))) % HASH_SIZE;\n+\n+  /* If node is in the table, just mention its address.  */\n+  for (b = table[hash]; b; b = b->next)\n+    if (b->node == node)\n+      {\n+\tprint_node_brief (file, prefix, node, indent);\n+\treturn;\n+      }\n+\n+  /* Add this node to the table.  */\n+  b = (struct bucket *) oballoc (sizeof (struct bucket));\n+  b->node = node;\n+  b->next = table[hash];\n+  table[hash] = b;\n+\n+  /* Indent to the specified column, since this is the long form.  */\n+  indent_to (file, indent);\n+\n+  /* Print the slot this node is in, and its code, and address.  */\n+  fprintf (file, \"%s <%s %x\", prefix,\n+\t   tree_code_name[(int) TREE_CODE (node)], (int) node);\n+\n+  /* Print the name, if any.  */\n+  if (class == 'd')\n+    {\n+      if (DECL_NAME (node))\n+\tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n+    }\n+  else if (class == 't')\n+    {\n+      if (TYPE_NAME (node))\n+\t{\n+\t  if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n+\t    fprintf (file, \" %s\", IDENTIFIER_POINTER (TYPE_NAME (node)));\n+\t  else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n+\t\t   && DECL_NAME (TYPE_NAME (node)))\n+\t    fprintf (file, \" %s\",\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node))));\n+\t}\n+    }\n+  if (TREE_CODE (node) == IDENTIFIER_NODE)\n+    fprintf (file, \" %s\", IDENTIFIER_POINTER (node));\n+\n+  if (TREE_CODE (node) == INTEGER_CST)\n+    {\n+      if (indent <= 4)\n+\tprint_node_brief (file, \"type\", TREE_TYPE (node), indent + 4);\n+    }\n+  else\n+    {\n+      print_node (file, \"type\", TREE_TYPE (node), indent + 4);\n+      if (TREE_TYPE (node))\n+\tindent_to (file, indent + 3);\n+    }\n+\n+  /* If a permanent object is in the wrong obstack, or the reverse, warn.  */\n+  if (object_permanent_p (node) != TREE_PERMANENT (node))\n+    {\n+      if (TREE_PERMANENT (node))\n+\tfputs (\" !!permanent object in non-permanent obstack!!\", file);\n+      else\n+\tfputs (\" !!non-permanent object in permanent obstack!!\", file);\n+      indent_to (file, indent + 3);\n+    }\n+\n+  if (TREE_SIDE_EFFECTS (node))\n+    fputs (\" side-effects\", file);\n+  if (TREE_READONLY (node))\n+    fputs (\" readonly\", file);\n+  if (TREE_CONSTANT (node))\n+    fputs (\" constant\", file);\n+  if (TREE_ADDRESSABLE (node))\n+    fputs (\" addressable\", file);\n+  if (TREE_THIS_VOLATILE (node))\n+    fputs (\" volatile\", file);\n+  if (TREE_UNSIGNED (node))\n+    fputs (\" unsigned\", file);\n+  if (TREE_ASM_WRITTEN (node))\n+    fputs (\" asm_written\", file);\n+  if (TREE_USED (node))\n+    fputs (\" used\", file);\n+  if (TREE_PERMANENT (node))\n+    fputs (\" permanent\", file);\n+  if (TREE_PUBLIC (node))\n+    fputs (\" public\", file);\n+  if (TREE_STATIC (node))\n+    fputs (\" static\", file);\n+  if (TREE_LANG_FLAG_0 (node))\n+    fputs (\" tree_0\", file);\n+  if (TREE_LANG_FLAG_1 (node))\n+    fputs (\" tree_1\", file);\n+  if (TREE_LANG_FLAG_2 (node))\n+    fputs (\" tree_2\", file);\n+  if (TREE_LANG_FLAG_3 (node))\n+    fputs (\" tree_3\", file);\n+  if (TREE_LANG_FLAG_4 (node))\n+    fputs (\" tree_4\", file);\n+  if (TREE_LANG_FLAG_5 (node))\n+    fputs (\" tree_5\", file);\n+  if (TREE_LANG_FLAG_6 (node))\n+    fputs (\" tree_6\", file);\n+\n+  /* DECL_ nodes have additional attributes.  */\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (node)))\n+    {\n+    case 'd':\n+      mode = DECL_MODE (node);\n+\n+      if (TREE_EXTERNAL (node))\n+\tfputs (\" external\", file);\n+      if (TREE_NONLOCAL (node))\n+\tfputs (\" nonlocal\", file);\n+      if (TREE_REGDECL (node))\n+\tfputs (\" regdecl\", file);\n+      if (TREE_INLINE (node))\n+\tfputs (\" inline\", file);\n+      if (DECL_BIT_FIELD (node))\n+\tfputs (\" bit-field\", file);\n+      if (DECL_VIRTUAL_P (node))\n+\tfputs (\" virtual\", file);\n+      if (DECL_FROM_INLINE (node))\n+\tfputs (\" from_inline\", file);\n+      if (DECL_IGNORED_P (node))\n+\tfputs (\" ignored\", file);\n+      if (DECL_LANG_FLAG_0 (node))\n+\tfputs (\" decl_0\", file);\n+      if (DECL_LANG_FLAG_1 (node))\n+\tfputs (\" decl_1\", file);\n+      if (DECL_LANG_FLAG_2 (node))\n+\tfputs (\" decl_2\", file);\n+      if (DECL_LANG_FLAG_3 (node))\n+\tfputs (\" decl_3\", file);\n+      if (DECL_LANG_FLAG_4 (node))\n+\tfputs (\" decl_4\", file);\n+      if (DECL_LANG_FLAG_5 (node))\n+\tfputs (\" decl_5\", file);\n+      if (DECL_LANG_FLAG_6 (node))\n+\tfputs (\" decl_6\", file);\n+      if (DECL_LANG_FLAG_7 (node))\n+\tfputs (\" decl_7\", file);\n+\n+      fprintf (file, \" %s\", mode_name[(int) mode]);\n+\n+      fprintf (file, \" file %s line %d\",\n+\t       DECL_SOURCE_FILE (node), DECL_SOURCE_LINE (node));\n+\n+      print_node (file, \"size\", DECL_SIZE (node), indent + 4);\n+      indent_to (file, indent + 3);\n+      fprintf (file, \" align %d\", DECL_ALIGN (node));\n+      fprintf (file, \" frame_size %d\", DECL_FRAME_SIZE (node));\n+      if (TREE_CODE (node) == FIELD_DECL)\n+\tprint_node (file, \"bitpos\", DECL_FIELD_BITPOS (node), indent + 4);\n+      print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n+\n+      print_node (file, \"arguments\", DECL_ARGUMENTS (node), indent + 4);\n+      print_node (file, \"result\", DECL_RESULT (node), indent + 4);\n+      print_node_brief (file, \"initial\", DECL_INITIAL (node), indent + 4);\n+\n+      print_lang_decl (file, node, indent);\n+\n+      if (DECL_RTL (node) != 0)\n+\t{\n+\t  indent_to (file, indent + 4);\n+\t  print_rtl (file, DECL_RTL (node));\n+\t}\n+\n+      if (DECL_SAVED_INSNS (node) != 0)\n+\t{\n+\t  indent_to (file, indent + 4);\n+\t  if (TREE_CODE (node) == PARM_DECL)\n+\t    {\n+\t      fprintf (file, \"incoming-rtl \");\n+\t      print_rtl (file, DECL_INCOMING_RTL (node));\n+\t    }\n+\t  else if (TREE_CODE (node) == FUNCTION_DECL)\n+\t    fprintf (file, \"saved-insns 0x%x\", DECL_SAVED_INSNS (node));\n+\t}\n+\n+      /* Print the decl chain only if decl is at second level.  */\n+      if (indent == 4)\n+\tprint_node (file, \"chain\", TREE_CHAIN (node), indent + 4);\n+      else\n+\tprint_node_brief (file, \"chain\", TREE_CHAIN (node), indent + 4);\n+      break;\n+\n+    case 't':\n+      if (TYPE_NO_FORCE_BLK (node))\n+\tfputs (\" no_force_blk\", file);\n+      if (TYPE_LANG_FLAG_0 (node))\n+\tfputs (\" type_0\", file);\n+      if (TYPE_LANG_FLAG_1 (node))\n+\tfputs (\" type_1\", file);\n+      if (TYPE_LANG_FLAG_2 (node))\n+\tfputs (\" type_2\", file);\n+      if (TYPE_LANG_FLAG_3 (node))\n+\tfputs (\" type_3\", file);\n+      if (TYPE_LANG_FLAG_4 (node))\n+\tfputs (\" type_4\", file);\n+      if (TYPE_LANG_FLAG_5 (node))\n+\tfputs (\" type_5\", file);\n+      if (TYPE_LANG_FLAG_6 (node))\n+\tfputs (\" type_6\", file);\n+\n+      mode = TYPE_MODE (node);\n+      fprintf (file, \" %s\", mode_name[(int) mode]);\n+\n+      print_node (file, \"size\", TYPE_SIZE (node), indent + 4);\n+      indent_to (file, indent + 3);\n+\n+      fprintf (file, \" align %d\", TYPE_ALIGN (node));\n+      fprintf (file, \" symtab %d\", TYPE_SYMTAB_ADDRESS (node));\n+\n+      if (TREE_CODE (node) == ARRAY_TYPE || TREE_CODE (node) == SET_TYPE)\n+\tprint_node (file, \"domain\", TYPE_DOMAIN (node), indent + 4);\n+      else if (TREE_CODE (node) == INTEGER_TYPE)\n+\t{\n+\t  fprintf (file, \" precision %d\", TYPE_PRECISION (node));\n+\t  print_node (file, \"min\", TYPE_MIN_VALUE (node), indent + 4);\n+\t  print_node (file, \"max\", TYPE_MAX_VALUE (node), indent + 4);\n+\t}\n+      else if (TREE_CODE (node) == ENUMERAL_TYPE)\n+\t{\n+\t  fprintf (file, \" precision %d\", TYPE_PRECISION (node));\n+\t  print_node (file, \"min\", TYPE_MIN_VALUE (node), indent + 4);\n+\t  print_node (file, \"max\", TYPE_MAX_VALUE (node), indent + 4);\n+\t  print_node (file, \"values\", TYPE_VALUES (node), indent + 4);\n+\t}\n+      else if (TREE_CODE (node) == REAL_TYPE)\n+\tfprintf (file, \" precision %d\", TYPE_PRECISION (node));\n+      else if (TREE_CODE (node) == RECORD_TYPE || TREE_CODE (node) == UNION_TYPE)\n+\tprint_node (file, \"fields\", TYPE_FIELDS (node), indent + 4);\n+      else if (TREE_CODE (node) == FUNCTION_TYPE || TREE_CODE (node) == METHOD_TYPE)\n+\t{\n+\t  if (TYPE_METHOD_BASETYPE (node))\n+\t    print_node_brief (file, \"method basetype\", TYPE_METHOD_BASETYPE (node), indent + 4);\n+\t  print_node (file, \"arg-types\", TYPE_ARG_TYPES (node), indent + 4);\n+\t}\n+      if (TYPE_CONTEXT (node))\n+\tprint_node_brief (file, \"context\", TYPE_CONTEXT (node), indent + 4);\n+\n+      print_lang_type (file, node, indent);\n+\n+      if (TYPE_POINTER_TO (node) || TREE_CHAIN (node))\n+\tindent_to (file, indent + 3);\n+      print_node_brief (file, \"pointer_to_this\", TYPE_POINTER_TO (node), indent + 4);\n+      print_node_brief (file, \"reference_to_this\", TYPE_REFERENCE_TO (node), indent + 4);\n+      print_node_brief (file, \"chain\", TREE_CHAIN (node), indent + 4);\n+      break;\n+\n+    case 'e':\n+    case '<':\n+    case '1':\n+    case '2':\n+    case 'r':\n+    case 's':\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase BLOCK:\n+\t  print_node (file, \"vars\", BLOCK_VARS (node), indent + 4);\n+\t  print_node (file, \"tags\", BLOCK_TYPE_TAGS (node), indent + 4);\n+\t  print_node (file, \"supercontext\", BLOCK_SUPERCONTEXT (node), indent + 4);\n+\t  print_node (file, \"subblocks\", BLOCK_SUBBLOCKS (node), indent + 4);\n+\t  print_node (file, \"chain\", BLOCK_CHAIN (node), indent + 4);\n+\t  return;\n+\n+\tcase BIND_EXPR:\n+\t  print_node (file, \"vars\", TREE_OPERAND (node, 0), indent + 4);\n+\t  print_node (file, \"body\", TREE_OPERAND (node, 1), indent + 4);\n+\t  return;\n+\t}\n+\n+      first_rtl = len = tree_code_length[(int) TREE_CODE (node)];\n+      /* These kinds of nodes contain rtx's, not trees,\n+\t after a certain point.  Print the rtx's as rtx's.  */\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase SAVE_EXPR:\n+\t  first_rtl = 2;\n+\t  break;\n+\tcase CALL_EXPR:\n+\t  first_rtl = 2;\n+\t  break;\n+\tcase METHOD_CALL_EXPR:\n+\t  first_rtl = 3;\n+\t  break;\n+\tcase WITH_CLEANUP_EXPR:\n+\t  /* Should be defined to be 2.  */\n+\t  first_rtl = 1;\n+\t  break;\n+\tcase RTL_EXPR:\n+\t  first_rtl = 0;\n+\t}\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  if (i >= first_rtl)\n+\t    {\n+\t      indent_to (file, indent + 4);\n+\t      fprintf (file, \"rtl %d \", i);\n+\t      if (TREE_OPERAND (node, i))\n+\t\tprint_rtl (file, TREE_OPERAND (node, i));\n+\t      else\n+\t\tfprintf (file, \"(nil)\");\n+\t      fprintf (file, \"\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      char temp[10];\n+\n+\t      sprintf (temp, \"arg %d\", i);\n+\t      print_node (file, temp, TREE_OPERAND (node, i), indent + 4);\n+\t    }\n+\t}\n+      break;\n+\n+    case 'c':\n+    case 'x':\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase INTEGER_CST:\n+\t  if (TREE_INT_CST_HIGH (node) == 0)\n+\t    fprintf (file, \" %1u\", TREE_INT_CST_LOW (node));\n+\t  else if (TREE_INT_CST_HIGH (node) == -1\n+\t\t   && TREE_INT_CST_LOW (node) != 0)\n+\t    fprintf (file, \" -%1u\", -TREE_INT_CST_LOW (node));\n+\t  else\n+\t    fprintf (file, \" 0x%x%08x\",\n+\t\t     TREE_INT_CST_HIGH (node),\n+\t\t     TREE_INT_CST_LOW (node));\n+\t  break;\n+\n+\tcase REAL_CST:\n+#ifndef REAL_IS_NOT_DOUBLE\n+\t  fprintf (file, \" %e\", TREE_REAL_CST (node));\n+#else\n+\t  {\n+\t    char *p = (char *) &TREE_REAL_CST (node);\n+\t    fprintf (file, \" 0x\");\n+\t    for (i = 0; i < sizeof TREE_REAL_CST (node); i++)\n+\t      fprintf (file, \"%02x\", *p++);\n+\t    fprintf (file, \"\");\n+\t  }\n+#endif /* REAL_IS_NOT_DOUBLE */\n+\t  break;\n+\n+\tcase COMPLEX_CST:\n+\t  print_node (file, \"real\", TREE_REALPART (node), indent + 4);\n+\t  print_node (file, \"imag\", TREE_IMAGPART (node), indent + 4);\n+\t  break;\n+\n+\tcase STRING_CST:\n+\t  fprintf (file, \" \\\"%s\\\"\", TREE_STRING_POINTER (node));\n+\t  break;\n+\n+\tcase IDENTIFIER_NODE:\n+\t  print_lang_identifier (file, node, indent);\n+\t  break;\n+\n+\tcase TREE_LIST:\n+\t  print_node (file, \"purpose\", TREE_PURPOSE (node), indent + 4);\n+\t  print_node (file, \"value\", TREE_VALUE (node), indent + 4);\n+\t  print_node (file, \"chain\", TREE_CHAIN (node), indent + 4);\n+\t  break;\n+\n+\tcase TREE_VEC:\n+\t  len = TREE_VEC_LENGTH (node);\n+\t  for (i = 0; i < len; i++)\n+\t    {\n+\t      char temp[10];\n+\t      sprintf (temp, \"elt %d\", i);\n+\t      indent_to (file, indent + 4);\n+\t      print_node_brief (file, temp, TREE_VEC_ELT (node, i), 0);\n+\t    }\n+\t  break;\n+\n+\tcase OP_IDENTIFIER:\n+\t  print_node (file, \"op1\", TREE_PURPOSE (node), indent + 4);\n+\t  print_node (file, \"op2\", TREE_VALUE (node), indent + 4);\n+\t}\n+\n+      break;\n+    }\n+}"}]}