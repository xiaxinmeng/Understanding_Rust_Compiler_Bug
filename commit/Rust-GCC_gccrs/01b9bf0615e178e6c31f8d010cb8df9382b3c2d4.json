{"sha": "01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiOWJmMDYxNWUxNzhlNmMzMWY4ZDAxMGNiOGRmOTM4MmIzYzJkNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-14T10:56:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-14T10:56:56Z"}, "message": "inline_small_functions speedup\n\nAfter inlining A into B, inline_small_functions updates the information\nfor (most) callees and callers of the new B:\n\n\t  update_callee_keys (&edge_heap, where, updated_nodes);\n      [...]\n      /* Our profitability metric can depend on local properties\n\t such as number of inlinable calls and size of the function body.\n\t After inlining these properties might change for the function we\n\t inlined into (since it's body size changed) and for the functions\n\t called by function we inlined (since number of it inlinable callers\n\t might change).  */\n      update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n\nThese functions in turn call can_inline_edge_p for most of the associated\nedges:\n\n\t    if (can_inline_edge_p (edge, false)\n\t\t&& want_inline_small_function_p (edge, false))\n\t      update_edge_key (heap, edge);\n\ncan_inline_edge_p indirectly calls estimate_calls_size_and_time\non the caller node, which seems to recursively process all callee\nedges rooted at the node.  It looks from this like the algorithm\ncan be at least quadratic in the worst case.\n\nMaybe there's something we can do to make can_inline_edge_p cheaper, but\nsince neither of these two calls is responsible for reporting an inline\nfailure reason, it seems cheaper to test want_inline_small_function_p\nfirst, so that we don't calculate an estimate for something that we\nalready know isn't a \"small function\".  I think the only change\nneeded to make that work is to check for CIF_FINAL_ERROR in\nwant_inline_small_function_p; at the moment we rely on can_inline_edge_p\nto make that check.\n\nThis cuts the time to build optabs.ii by over 4% with an\n--enable-checking=release compiler on x86_64-linux-gnu.  I've seen more\ndramatic wins on aarch64-linux-gnu due to the NUM_POLY_INT_COEFFS==2\nthing.  The patch doesn't affect the output code.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* ipa-inline.c (want_inline_small_function_p): Return false if\n\tinlining has already failed with CIF_FINAL_ERROR.\n\t(update_caller_keys): Call want_inline_small_function_p before\n\tcan_inline_edge_p.\n\t(update_callee_keys): Likewise.\n\nFrom-SVN: r256658", "tree": {"sha": "1983359622b757b8b73b643d518e350d3ce588aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1983359622b757b8b73b643d518e350d3ce588aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4/comments", "author": null, "committer": null, "parents": [{"sha": "61760b925ca4732c6eac2e1fe3582185aba826e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61760b925ca4732c6eac2e1fe3582185aba826e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61760b925ca4732c6eac2e1fe3582185aba826e7"}], "stats": {"total": 22, "additions": 17, "deletions": 5}, "files": [{"sha": "abce2c83d5336f267df4bd42312aac2831480a20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "patch": "@@ -1,3 +1,11 @@\n+2018-01-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* ipa-inline.c (want_inline_small_function_p): Return false if\n+\tinlining has already failed with CIF_FINAL_ERROR.\n+\t(update_caller_keys): Call want_inline_small_function_p before\n+\tcan_inline_edge_p.\n+\t(update_callee_keys): Likewise.\n+\n 2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \t* config/rs6000/rs6000-p8swap.c (rs6000_sum_of_two_registers_p):"}, {"sha": "c3acfb29b4029b2f097042d0442a717fcfe6e435", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b9bf0615e178e6c31f8d010cb8df9382b3c2d4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=01b9bf0615e178e6c31f8d010cb8df9382b3c2d4", "patch": "@@ -706,7 +706,11 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   bool want_inline = true;\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+  /* Allow this function to be called before can_inline_edge_p,\n+     since it's usually cheaper.  */\n+  if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+    want_inline = false;\n+  else if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n   else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && !opt_for_fn (e->caller->decl, flag_inline_small_functions))\n@@ -1312,8 +1316,8 @@ update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n         if (!check_inlinablity_for\n \t    || check_inlinablity_for == edge)\n \t  {\n-\t    if (can_inline_edge_p (edge, false)\n-\t\t&& want_inline_small_function_p (edge, false))\n+\t    if (want_inline_small_function_p (edge, false)\n+\t\t&& can_inline_edge_p (edge, false))\n \t      update_edge_key (heap, edge);\n \t    else if (edge->aux)\n \t      {\n@@ -1356,8 +1360,8 @@ update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n \t    && avail >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, callee->uid))\n \t  {\n-\t    if (can_inline_edge_p (e, false)\n-\t\t&& want_inline_small_function_p (e, false))\n+\t    if (want_inline_small_function_p (e, false)\n+\t\t&& can_inline_edge_p (e, false))\n \t      update_edge_key (heap, e);\n \t    else if (e->aux)\n \t      {"}]}