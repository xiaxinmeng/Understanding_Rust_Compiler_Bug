{"sha": "0fb2335d4ccfbc928951ddeba5ead045a1dff172", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiMjMzNWQ0Y2NmYmM5Mjg5NTFkZGViYTVlYWQwNDVhMWRmZjE3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-22T07:28:48Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-22T07:28:48Z"}, "message": "fe.h (Get_External_Name): Declare.\n\n\t* fe.h (Get_External_Name): Declare.\n\t* gcc-interface/gigi.h (concat_id_with_name): Rename to...\n\t(concat_name): ...this.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Rename gnu_entity_id to\n\tgnu_entity_name and adjust for above renaming.\n\t<E_Access_Type>: Use create_concat_name to get the name of the various\n\ttypes associated with unconstrained array types.\n\t(make_aligning_type): Adjust for above renaming.\n\t(maybe_pad_type): Likewise.\n\t(components_to_record): Likewise. \u00a0Use get_identifier_with_length for\n\tthe encoding of the variant.\n\t(get_entity_name): Use get_identifier_with_length.\n\t(create_concat_name): Likewise. \u00a0Use Get_External_Name if no suffix.\n\tDo not fiddle with Name_Buffer.\n\t(concat_id_with_name): Rename to...\n\t(concat_name): ...this. \u00a0Use get_identifier_with_length. \u00a0Do not fiddle\n\twith Name_Buffer.\n\t* gcc-interface/utils.c (rest_of_record_type_compilation): Adjust for\n\tabove renaming.\n\nFrom-SVN: r146547", "tree": {"sha": "950ce5c9336788a41cdb4bf91464fab566a2861b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/950ce5c9336788a41cdb4bf91464fab566a2861b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb2335d4ccfbc928951ddeba5ead045a1dff172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2335d4ccfbc928951ddeba5ead045a1dff172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb2335d4ccfbc928951ddeba5ead045a1dff172", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2335d4ccfbc928951ddeba5ead045a1dff172/comments", "author": null, "committer": null, "parents": [{"sha": "8ff1dd836408a49359dbac9321678ccf6d33a6f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff1dd836408a49359dbac9321678ccf6d33a6f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff1dd836408a49359dbac9321678ccf6d33a6f9"}], "stats": {"total": 248, "additions": 132, "deletions": 116}, "files": [{"sha": "2bdc461f2dc0ce6254f866721b61aec8bda896cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0fb2335d4ccfbc928951ddeba5ead045a1dff172", "patch": "@@ -1,3 +1,25 @@\n+2009-04-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h (Get_External_Name): Declare.\n+\t* gcc-interface/gigi.h (concat_id_with_name): Rename to...\n+\t(concat_name): ...this.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Rename gnu_entity_id to\n+\tgnu_entity_name and adjust for above renaming.\n+\t<E_Access_Type>: Use create_concat_name to get the name of the various\n+\ttypes associated with unconstrained array types.\n+\t(make_aligning_type): Adjust for above renaming.\n+\t(maybe_pad_type): Likewise.\n+\t(components_to_record): Likewise. \ufffdUse get_identifier_with_length for\n+\tthe encoding of the variant.\n+\t(get_entity_name): Use get_identifier_with_length.\n+\t(create_concat_name): Likewise. \ufffdUse Get_External_Name if no suffix.\n+\tDo not fiddle with Name_Buffer.\n+\t(concat_id_with_name): Rename to...\n+\t(concat_name): ...this. \ufffdUse get_identifier_with_length. \ufffdDo not fiddle\n+\twith Name_Buffer.\n+\t* gcc-interface/utils.c (rest_of_record_type_compilation): Adjust for\n+\tabove renaming.\n+\n 2009-04-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* ChangeLog, ChangeLog.ptr, ChangeLog.tree-ssa: Add copyright and"}, {"sha": "6141552c4c065530943c262db4fc363a2adf0e50", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=0fb2335d4ccfbc928951ddeba5ead045a1dff172", "patch": "@@ -135,10 +135,12 @@ extern void Setup_Asm_Outputs\t\t(Node_Id);\n /* exp_dbug:  */\n \n #define Get_Encoded_Name exp_dbug__get_encoded_name\n+#define Get_External_Name exp_dbug__get_external_name\n #define Get_External_Name_With_Suffix exp_dbug__get_external_name_with_suffix\n \n-extern void Get_Encoded_Name\t(Entity_Id);\n-extern void Get_External_Name_With_Suffix (Entity_Id, Fat_Pointer);\n+extern void Get_Encoded_Name\t\t\t(Entity_Id);\n+extern void Get_External_Name\t\t\t(Entity_Id, Boolean);\n+extern void Get_External_Name_With_Suffix\t(Entity_Id, Fat_Pointer);\n \n /* lib: */\n "}, {"sha": "3cd801743d7c3e33a05f85f5fb319f1d0a9a8024", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 87, "deletions": 94, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=0fb2335d4ccfbc928951ddeba5ead045a1dff172", "patch": "@@ -184,7 +184,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* Contains the GCC size tree to be used for the GCC node.  */\n   tree gnu_size = NULL_TREE;\n   /* Contains the GCC name to be used for the GCC node.  */\n-  tree gnu_entity_id;\n+  tree gnu_entity_name;\n   /* True if we have already saved gnu_decl as a GNAT association.  */\n   bool saved = false;\n   /* True if we incremented defer_incomplete_level.  */\n@@ -316,7 +316,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* Get the name of the entity and set up the line number and filename of\n      the original definition for use in any decl we make.  */\n-  gnu_entity_id = get_entity_name (gnat_entity);\n+  gnu_entity_name = get_entity_name (gnat_entity);\n   Sloc_to_locus (Sloc (gnat_entity), &input_location);\n \n   /* If we get here, it means we have not yet done anything with this\n@@ -560,7 +560,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Present (Debug_Renaming_Link (gnat_entity)))\n \t  {\n \t    rtx addr;\n-\t    gnu_decl = build_decl (VAR_DECL, gnu_entity_id, gnu_type);\n+\t    gnu_decl = build_decl (VAR_DECL, gnu_entity_name, gnu_type);\n \t    /* The (MEM (CONST (0))) pattern is prescribed by STABS.  */\n \t    if (global_bindings_p ())\n \t      addr = gen_rtx_CONST (VOIDmode, const0_rtx);\n@@ -780,8 +780,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  gnu_type\n \t    = build_unc_object_type_from_ptr (gnu_fat, gnu_type,\n-\t\t\t\t     concat_id_with_name (gnu_entity_id,\n-\t\t\t\t\t\t\t  \"UNC\"));\n+\t\t\t\t\t      concat_name (gnu_entity_name,\n+\t\t\t\t\t\t\t   \"UNC\"));\n \t}\n \n #ifdef MINIMUM_ATOMIC_ALIGNMENT\n@@ -1263,7 +1263,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| (Is_Public (gnat_entity)\n \t\t    && (!Is_Imported (gnat_entity)\n \t\t\t|| Is_Exported (gnat_entity)))))\n-\t  gnu_ext_name = create_concat_name (gnat_entity, 0);\n+\t  gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \n \t/* If this is constant initialized to a static constant and the\n \t   object has an aggregate type, force it to be statically\n@@ -1278,7 +1278,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    (TREE_TYPE (TYPE_FIELDS (gnu_type))), 1)))\n \t  static_p = true;\n \n-\tgnu_decl = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\tgnu_decl = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t    gnu_expr, const_flag,\n \t\t\t\t    Is_Public (gnat_entity),\n \t\t\t\t    imported_p || !definition,\n@@ -1314,7 +1314,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   accessed from within the debugger through the PARM_DECL.  */\n \tif (kind == E_Out_Parameter && definition && !optimize)\n \t  {\n-\t    tree param = create_param_decl (gnu_entity_id, gnu_type, false);\n+\t    tree param = create_param_decl (gnu_entity_name, gnu_type, false);\n \t    gnat_pushdecl (param, gnat_entity);\n \t    SET_DECL_VALUE_EXPR (param, gnu_decl);\n \t    DECL_HAS_VALUE_EXPR_P (param) = 1;\n@@ -1341,7 +1341,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n \t  {\n \t    tree gnu_corr_var\n-\t      = create_true_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t      = create_true_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t      gnu_expr, true, Is_Public (gnat_entity),\n \t\t\t\t      !definition, static_p, NULL,\n \t\t\t\t      gnat_entity);\n@@ -1401,7 +1401,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (No (First_Literal (gnat_entity)))\n \t{\n \t  gnu_type = make_unsigned_type (esize);\n-\t  TYPE_NAME (gnu_type) = gnu_entity_id;\n+\t  TYPE_NAME (gnu_type) = gnu_entity_name;\n \n \t  /* Set TYPE_STRING_FLAG for Ada Character and Wide_Character types.\n \t     This is needed by the DWARF-2 back-end to distinguish between\n@@ -1633,7 +1633,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* Create a stripped-down declaration of the original type, mainly\n \t     for debugging.  */\n-\t  create_type_decl (gnu_entity_id, gnu_field_type, NULL, true,\n+\t  create_type_decl (gnu_entity_name, gnu_field_type, NULL, true,\n \t\t\t    debug_info_p, gnat_entity);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n@@ -1671,7 +1671,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* Create a stripped-down declaration of the original type, mainly\n \t     for debugging.  */\n-\t  create_type_decl (gnu_entity_id, gnu_field_type, NULL, true,\n+\t  create_type_decl (gnu_entity_name, gnu_field_type, NULL, true,\n \t\t\t    debug_info_p, gnat_entity);\n \n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n@@ -2352,7 +2352,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n \t  if (need_index_type_struct)\n \t    TYPE_STUB_DECL (gnu_type)\n-\t      = create_type_stub_decl (gnu_entity_id, gnu_type);\n+\t      = create_type_stub_decl (gnu_entity_name, gnu_type);\n \n \t  /* If we are at file level and this is a multi-dimensional array, we\n \t     need to make a variable corresponding to the stride of the\n@@ -2365,7 +2365,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      for (gnu_arr_type = TREE_TYPE (gnu_type);\n \t\t   TREE_CODE (gnu_arr_type) == ARRAY_TYPE;\n \t\t   gnu_arr_type = TREE_TYPE (gnu_arr_type),\n-\t\t   gnu_str_name = concat_id_with_name (gnu_str_name, \"ST\"))\n+\t\t   gnu_str_name = concat_name (gnu_str_name, \"ST\"))\n \t\t{\n \t\t  tree eltype = TREE_TYPE (gnu_arr_type);\n \n@@ -2386,8 +2386,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t TYPE_SIZE_UNIT (gnu_arr_type),\n \t\t\t\t\t size_int (TYPE_ALIGN (eltype)\n \t\t\t\t\t\t   / BITS_PER_UNIT)),\n-\t\t\tconcat_id_with_name (gnu_str_name, \"A_U\"),\n-\t\t\tdefinition, 0),\n+\t\t\tconcat_name (gnu_str_name, \"A_U\"), definition, 0),\n \t\t       size_int (TYPE_ALIGN (eltype) / BITS_PER_UNIT));\n \n \t\t  /* ??? create_type_decl is not invoked on the inner types so\n@@ -2474,7 +2473,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     That's sort of \"morally\" true and will make it possible for the\n \t     debugger to look it up by name in DWARF more easily.  */\n \t  gnu_decl\n-\t    = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t    = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t!Comes_From_Source (gnat_entity)\n \t\t\t\t&& !Comes_From_Source (Etype (gnat_entity)),\n \t\t\t\tdebug_info_p, gnat_entity);\n@@ -2688,7 +2687,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Make a node for the record.  If we are not defining the record,\n \t   suppress expanding incomplete types.  */\n \tgnu_type = make_node (tree_code_for_record_type (gnat_entity));\n-\tTYPE_NAME (gnu_type) = gnu_entity_id;\n+\tTYPE_NAME (gnu_type) = gnu_entity_name;\n \tTYPE_PACKED (gnu_type) = (packed != 0) || has_rep;\n \n \tif (!definition)\n@@ -3000,7 +2999,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      tree gnu_temp;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n-\t      TYPE_NAME (gnu_type) = gnu_entity_id;\n+\t      TYPE_NAME (gnu_type) = gnu_entity_name;\n \t      TYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \n \t      /* Set the size, alignment and alias set of the new type to\n@@ -3263,7 +3262,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_type\n \t    = build_pointer_type\n \t      (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n-\t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t       !Comes_From_Source (gnat_entity),\n \t\t\t\t       debug_info_p, gnat_entity);\n \t  this_made_decl = true;\n@@ -3400,13 +3399,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\ttree gnu_ptr_array = build_pointer_type (gnu_array_type);\n \n \t\tTYPE_NAME (gnu_template_type)\n-\t\t  = concat_id_with_name (get_entity_name (gnat_desig_equiv),\n-\t\t\t\t\t \"XUB\");\n+\t\t  = create_concat_name (gnat_desig_equiv, \"XUB\");\n \t\tTYPE_DUMMY_P (gnu_template_type) = 1;\n \n \t\tTYPE_NAME (gnu_array_type)\n-\t\t  = concat_id_with_name (get_entity_name (gnat_desig_equiv),\n-\t\t\t\t\t \"XUA\");\n+\t\t  = create_concat_name (gnat_desig_equiv, \"XUA\");\n \t\tTYPE_DUMMY_P (gnu_array_type) = 1;\n \n \t\tgnu_type = make_node (RECORD_TYPE);\n@@ -3435,8 +3432,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\tTYPE_OBJECT_RECORD_TYPE (gnu_old) = make_node (RECORD_TYPE);\n \t\tTYPE_NAME (TYPE_OBJECT_RECORD_TYPE (gnu_old))\n-\t\t  = concat_id_with_name (get_entity_name (gnat_desig_equiv),\n-\t\t\t\t\t \"XUT\");\n+\t\t  = create_concat_name (gnat_desig_equiv, \"XUT\");\n \t\tTYPE_DUMMY_P (TYPE_OBJECT_RECORD_TYPE (gnu_old)) = 1;\n \t      }\n \t  }\n@@ -3572,7 +3568,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  (TYPE_OBJECT_RECORD_TYPE\n \t\t   (TYPE_UNCONSTRAINED_ARRAY (gnu_type)));\n \n-\t    gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t\t !Comes_From_Source (gnat_entity),\n \t\t\t\t\t debug_info_p, gnat_entity);\n \t    this_made_decl = true;\n@@ -4133,7 +4129,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If there was no specified Interface_Name and the external and\n \t   internal names of the subprogram are the same, only use the\n \t   internal name to allow disambiguation of nested subprograms.  */\n-\tif (No (Interface_Name (gnat_entity)) && gnu_ext_name == gnu_entity_id)\n+\tif (No (Interface_Name (gnat_entity))\n+\t    && gnu_ext_name == gnu_entity_name)\n \t  gnu_ext_name = NULL_TREE;\n \n \t/* If we are defining the subprogram and it has an Address clause\n@@ -4163,14 +4160,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_address = convert (gnu_type, gnu_address);\n \n \t    gnu_decl\n-\t      = create_var_decl (gnu_entity_id, gnu_ext_name, gnu_type,\n+\t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t\t gnu_address, false, Is_Public (gnat_entity),\n \t\t\t\t extern_flag, false, NULL, gnat_entity);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n-\t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t       !Comes_From_Source (gnat_entity),\n \t\t\t\t       debug_info_p, gnat_entity);\n \telse\n@@ -4182,15 +4179,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tpublic_flag = false;\n \t      }\n \n-\t    gnu_decl = create_subprog_decl (gnu_entity_id, gnu_ext_name,\n+\t    gnu_decl = create_subprog_decl (gnu_entity_name, gnu_ext_name,\n \t\t\t\t\t    gnu_type, gnu_param_list,\n \t\t\t\t\t    inline_flag, public_flag,\n \t\t\t\t\t    extern_flag, attr_list,\n \t\t\t\t\t    gnat_entity);\n \t    if (has_stub)\n \t      {\n \t\ttree gnu_stub_decl\n-\t\t  = create_subprog_decl (gnu_entity_id, gnu_stub_name,\n+\t\t  = create_subprog_decl (gnu_entity_name, gnu_stub_name,\n \t\t\t\t\t gnu_stub_type, gnu_stub_param_list,\n \t\t\t\t\t inline_flag, true,\n \t\t\t\t\t extern_flag, attr_list,\n@@ -4296,7 +4293,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Label:\n-      gnu_decl = create_label_decl (gnu_entity_id);\n+      gnu_decl = create_label_decl (gnu_entity_name);\n       break;\n \n     case E_Block:\n@@ -4411,9 +4408,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (gnu_type))\n \t{\n-\t  gnu_entity_id = TYPE_NAME (gnu_type);\n-\t  if (TREE_CODE (gnu_entity_id) == TYPE_DECL)\n-\t    gnu_entity_id = DECL_NAME (gnu_entity_id);\n+\t  gnu_entity_name = TYPE_NAME (gnu_type);\n+\t  if (TREE_CODE (gnu_entity_name) == TYPE_DECL)\n+\t    gnu_entity_name = DECL_NAME (gnu_entity_name);\n \t}\n \n       set_rm_size (RM_Size (gnat_entity), gnu_type, gnat_entity);\n@@ -4527,7 +4524,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (gnu_type)) = 1;\n \n       if (!gnu_decl)\n-\tgnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n \t\t\t\t     !Comes_From_Source (gnat_entity),\n \t\t\t\t     debug_info_p, gnat_entity);\n       else\n@@ -5670,7 +5667,7 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   if (TREE_CODE (name) == TYPE_DECL)\n     name = DECL_NAME (name);\n \n-  TYPE_NAME (record_type) = concat_id_with_name (name, \"_ALIGN\");\n+  TYPE_NAME (record_type) = concat_name (name, \"_ALIGN\");\n \n   /* Compute VOFFSET and then POS.  The next byte position multiple of some\n      alignment after some address is obtained by \"and\"ing the alignment minus\n@@ -6031,7 +6028,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       if (TREE_CODE (orig_name) == TYPE_DECL)\n \torig_name = DECL_NAME (orig_name);\n \n-      TYPE_NAME (marker) = concat_id_with_name (name, \"XVS\");\n+      TYPE_NAME (marker) = concat_name (name, \"XVS\");\n       finish_record_type (marker,\n \t\t\t  create_field_decl (orig_name, integer_type_node,\n \t\t\t\t\t     marker, 0, NULL_TREE, NULL_TREE,\n@@ -6041,9 +6038,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       add_parallel_type (TYPE_STUB_DECL (record), marker);\n \n       if (size && TREE_CODE (size) != INTEGER_CST && definition)\n-\tcreate_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n-\t\t\t sizetype, TYPE_SIZE_UNIT (record), false, false,\n-\t\t\t false, false, NULL, gnat_entity);\n+\tcreate_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n+\t\t\t TYPE_SIZE_UNIT (record), false, false, false,\n+\t\t\t false, NULL, gnat_entity);\n     }\n \n   rest_of_record_type_compilation (record);\n@@ -6605,23 +6602,20 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n      use GNU_RECORD_TYPE if there are no fields so far.  */\n   if (Present (variant_part))\n     {\n-      tree gnu_discriminant = gnat_to_gnu (Name (variant_part));\n-      Node_Id variant;\n+      Node_Id gnat_discr = Name (variant_part), variant;\n+      tree gnu_discr = gnat_to_gnu (gnat_discr);\n       tree gnu_name = TYPE_NAME (gnu_record_type);\n       tree gnu_var_name\n-\t= concat_id_with_name (get_identifier (Get_Name_String\n-\t\t\t\t\t       (Chars (Name (variant_part)))),\n-\t\t\t       \"XVN\");\n-      tree gnu_union_type;\n-      tree gnu_union_name;\n-      tree gnu_union_field;\n+\t= concat_name (get_identifier (Get_Name_String (Chars (gnat_discr))),\n+\t\t       \"XVN\");\n+      tree gnu_union_type, gnu_union_name, gnu_union_field;\n       tree gnu_variant_list = NULL_TREE;\n \n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n \tgnu_name = DECL_NAME (gnu_name);\n \n-      gnu_union_name = concat_id_with_name (gnu_name,\n-\t\t\t\t\t    IDENTIFIER_POINTER (gnu_var_name));\n+      gnu_union_name\n+\t= concat_name (gnu_name, IDENTIFIER_POINTER (gnu_var_name));\n \n       /* Reuse an enclosing union if all fields are in the variant part\n \t and there is no representation clause on the record, to match\n@@ -6649,10 +6643,10 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  tree gnu_qual;\n \n \t  Get_Variant_Encoding (variant);\n-\t  gnu_inner_name = get_identifier (Name_Buffer);\n+\t  gnu_inner_name = get_identifier_with_length (Name_Buffer, Name_Len);\n \t  TYPE_NAME (gnu_variant_type)\n-\t    = concat_id_with_name (gnu_union_name,\n-\t\t\t\t   IDENTIFIER_POINTER (gnu_inner_name));\n+\t    = concat_name (gnu_union_name,\n+\t\t\t   IDENTIFIER_POINTER (gnu_inner_name));\n \n \t  /* Set the alignment of the inner type in case we need to make\n \t     inner objects into bitfields, but then clear it out\n@@ -6677,8 +6671,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n \t\t\t\ttrue, unchecked_union);\n \n-\t  gnu_qual = choices_to_gnu (gnu_discriminant,\n-\t\t\t\t     Discrete_Choices (variant));\n+\t  gnu_qual = choices_to_gnu (gnu_discr, Discrete_Choices (variant));\n \n \t  Set_Present_Expr (variant, annotate_value (gnu_qual));\n \n@@ -7749,6 +7742,17 @@ rm_size (tree gnu_type)\n   return TYPE_SIZE (gnu_type);\n }\n \f\n+/* Return the name to be used for GNAT_ENTITY.  If a type, create a\n+   fully-qualified name, possibly with type information encoding.\n+   Otherwise, return the name.  */\n+\n+tree\n+get_entity_name (Entity_Id gnat_entity)\n+{\n+  Get_Encoded_Name (gnat_entity);\n+  return get_identifier_with_length (Name_Buffer, Name_Len);\n+}\n+\n /* Return an identifier representing the external name to be used for\n    GNAT_ENTITY.  If SUFFIX is specified, the name is followed by \"___\"\n    and the specified suffix.  */\n@@ -7758,55 +7762,44 @@ create_concat_name (Entity_Id gnat_entity, const char *suffix)\n {\n   Entity_Kind kind = Ekind (gnat_entity);\n \n-  const char *str = (!suffix ? \"\" : suffix);\n-  String_Template temp = {1, strlen (str)};\n-  Fat_Pointer fp = {str, &temp};\n-\n-  Get_External_Name_With_Suffix (gnat_entity, fp);\n+  if (suffix)\n+    {\n+      String_Template temp = {1, strlen (suffix)};\n+      Fat_Pointer fp = {suffix, &temp};\n+      Get_External_Name_With_Suffix (gnat_entity, fp);\n+    }\n+  else\n+    Get_External_Name (gnat_entity, 0);\n \n-  /* A variable using the Stdcall convention (meaning we are running\n-     on a Windows box) live in a DLL.  Here we adjust its name to use\n-     the jump-table, the _imp__NAME contains the address for the NAME\n-     variable.  */\n+  /* A variable using the Stdcall convention lives in a DLL.  We adjust\n+     its name to use the jump table, the _imp__NAME contains the address\n+     for the NAME variable.  */\n   if ((kind == E_Variable || kind == E_Constant)\n       && Has_Stdcall_Convention (gnat_entity))\n     {\n-      const char *prefix = \"_imp__\";\n-      int k, plen = strlen (prefix);\n-\n-      for (k = 0; k <= Name_Len; k++)\n-\tName_Buffer [Name_Len - k + plen] = Name_Buffer [Name_Len - k];\n-      strncpy (Name_Buffer, prefix, plen);\n+      const int len = 6 + Name_Len;\n+      char *new_name = (char *) alloca (len + 1);\n+      strcpy (new_name, \"_imp__\");\n+      strcat (new_name, Name_Buffer);\n+      return get_identifier_with_length (new_name, len);\n     }\n \n-  return get_identifier (Name_Buffer);\n+  return get_identifier_with_length (Name_Buffer, Name_Len);\n }\n \n-/* Return the name to be used for GNAT_ENTITY.  If a type, create a\n-   fully-qualified name, possibly with type information encoding.\n-   Otherwise, return the name.  */\n-\n-tree\n-get_entity_name (Entity_Id gnat_entity)\n-{\n-  Get_Encoded_Name (gnat_entity);\n-  return get_identifier (Name_Buffer);\n-}\n-\n-/* Given GNU_ID, an IDENTIFIER_NODE containing a name and SUFFIX, a\n+/* Given GNU_NAME, an IDENTIFIER_NODE containing a name and SUFFIX, a\n    string, return a new IDENTIFIER_NODE that is the concatenation of\n-   the name in GNU_ID and SUFFIX.  */\n+   the name followed by \"___\" and the specified suffix.  */\n \n tree\n-concat_id_with_name (tree gnu_id, const char *suffix)\n+concat_name (tree gnu_name, const char *suffix)\n {\n-  int len = IDENTIFIER_LENGTH (gnu_id);\n-\n-  strncpy (Name_Buffer, IDENTIFIER_POINTER (gnu_id), len);\n-  strncpy (Name_Buffer + len, \"___\", 3);\n-  len += 3;\n-  strcpy (Name_Buffer + len, suffix);\n-  return get_identifier (Name_Buffer);\n+  const int len = IDENTIFIER_LENGTH (gnu_name) + 3 + strlen (suffix);\n+  char *new_name = (char *) alloca (len + 1);\n+  strcpy (new_name, IDENTIFIER_POINTER (gnu_name));\n+  strcat (new_name, \"___\");\n+  strcat (new_name, suffix);\n+  return get_identifier_with_length (new_name, len);\n }\n \n #include \"gt-ada-decl.h\""}, {"sha": "f4113f81adfd9daa9f7049c1c24d8fd6172ebdb9", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=0fb2335d4ccfbc928951ddeba5ead045a1dff172", "patch": "@@ -168,20 +168,21 @@ extern tree substitute_in_type (tree t, tree f, tree r);\n    needed to represent the object.  */\n extern tree rm_size (tree gnu_type);\n \n-/* Given GNU_ID, an IDENTIFIER_NODE containing a name, and SUFFIX, a\n-   string, return a new IDENTIFIER_NODE that is the concatenation of\n-   the name in GNU_ID and SUFFIX.  */\n-extern tree concat_id_with_name (tree gnu_id, const char *suffix);\n-\n /* Return the name to be used for GNAT_ENTITY.  If a type, create a\n    fully-qualified name, possibly with type information encoding.\n    Otherwise, return the name.  */\n extern tree get_entity_name (Entity_Id gnat_entity);\n \n-/* Return a name for GNAT_ENTITY concatenated with two underscores and\n-   SUFFIX.  */\n+/* Return an identifier representing the external name to be used for\n+   GNAT_ENTITY.  If SUFFIX is specified, the name is followed by \"___\"\n+   and the specified suffix.  */\n extern tree create_concat_name (Entity_Id gnat_entity, const char *suffix);\n \n+/* Given GNU_NAME, an IDENTIFIER_NODE containing a name and SUFFIX, a\n+   string, return a new IDENTIFIER_NODE that is the concatenation of\n+   the name followed by \"___\" and the specified suffix.  */\n+extern tree concat_name (tree gnu_name, const char *suffix);\n+\n /* If true, then gigi is being called on an analyzed but unexpanded tree, and\n    the only purpose of the call is to properly annotate types with\n    representation information.  */"}, {"sha": "c1af571992ec5a4d3d5ace5359b657bbb8fc13db", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2335d4ccfbc928951ddeba5ead045a1dff172/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=0fb2335d4ccfbc928951ddeba5ead045a1dff172", "patch": "@@ -802,22 +802,20 @@ rest_of_record_type_compilation (tree record_type)\n       tree new_record_type\n \t= make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n \t\t     ? UNION_TYPE : TREE_CODE (record_type));\n-      tree orig_name = TYPE_NAME (record_type);\n-      tree orig_id\n-\t= (TREE_CODE (orig_name) == TYPE_DECL ? DECL_NAME (orig_name)\n-\t   : orig_name);\n-      tree new_id\n-\t= concat_id_with_name (orig_id,\n-\t\t\t       TREE_CODE (record_type) == QUAL_UNION_TYPE\n-\t\t\t       ? \"XVU\" : \"XVE\");\n+      tree orig_name = TYPE_NAME (record_type), new_name;\n       tree last_pos = bitsize_zero_node;\n-      tree old_field;\n-      tree prev_old_field = 0;\n+      tree old_field, prev_old_field = NULL_TREE;\n \n-      TYPE_NAME (new_record_type) = new_id;\n+      if (TREE_CODE (orig_name) == TYPE_DECL)\n+\torig_name = DECL_NAME (orig_name);\n+\n+      new_name\n+\t= concat_name (orig_name, TREE_CODE (record_type) == QUAL_UNION_TYPE\n+\t\t\t\t  ? \"XVU\" : \"XVE\");\n+      TYPE_NAME (new_record_type) = new_name;\n       TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n       TYPE_STUB_DECL (new_record_type)\n-\t= create_type_stub_decl (new_id, new_record_type);\n+\t= create_type_stub_decl (new_name, new_record_type);\n       DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n \t= DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n       TYPE_SIZE (new_record_type) = size_int (TYPE_ALIGN (record_type));\n@@ -937,7 +935,7 @@ rest_of_record_type_compilation (tree record_type)\n \t      else\n \t\tstrcpy (suffix, \"XVL\");\n \n-\t      field_name = concat_id_with_name (field_name, suffix);\n+\t      field_name = concat_name (field_name, suffix);\n \t    }\n \n \t  new_field = create_field_decl (field_name, field_type,"}]}