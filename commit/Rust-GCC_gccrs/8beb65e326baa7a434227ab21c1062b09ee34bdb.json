{"sha": "8beb65e326baa7a434227ab21c1062b09ee34bdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJlYjY1ZTMyNmJhYTdhNDM0MjI3YWIyMWMxMDYyYjA5ZWUzNGJkYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-06-25T23:07:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-06-25T23:07:07Z"}, "message": "power7 patch #2: add bswap64; add preliminary VSX register support; add more -mdebug=* support\n\nCo-Authored-By: Pat Haugen <pthaugen@us.ibm.com>\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r148955", "tree": {"sha": "e9b80a98369f5a1302118a83e8fd20dce190e56d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9b80a98369f5a1302118a83e8fd20dce190e56d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8beb65e326baa7a434227ab21c1062b09ee34bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8beb65e326baa7a434227ab21c1062b09ee34bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8beb65e326baa7a434227ab21c1062b09ee34bdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8beb65e326baa7a434227ab21c1062b09ee34bdb/comments", "author": null, "committer": null, "parents": [{"sha": "c8aca64f5b1cc43734c6c31945638a65030a3801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8aca64f5b1cc43734c6c31945638a65030a3801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8aca64f5b1cc43734c6c31945638a65030a3801"}], "stats": {"total": 1394, "additions": 1264, "deletions": 130}, "files": [{"sha": "0823094be8d1c42de00364ca9a2df5efd3fcd1e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8beb65e326baa7a434227ab21c1062b09ee34bdb", "patch": "@@ -1,3 +1,69 @@\n+2009-06-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen  <pthaugen@us.ibm.com>\n+\t    Revital Eres <ERES@il.ibm.com>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_reload_class):\n+\tChange some of the functions called by macros to being called\n+\tthrough a pointer, so debug functions can be inserted if\n+\t-mdebug=addr or -mdebug=cost. \n+\t(rs6000_preferred_reload_class_ptr): Ditto.\n+\t(rs6000_secondary_reload_class_ptr): Ditto.\n+\t(rs6000_secondary_memory_needed_ptr): Ditto.\n+\t(rs6000_cannot_change_mode_class_ptr): Ditto.\n+\t(rs6000_secondary_reload_inner): Ditto.\n+\t(rs6000_legitimize_reload_address): Ditto.\n+\t(rs6000_legitimize_reload_address_ptr): Ditto.\n+\t(rs6000_mode_dependent_address): Ditto.\n+\t(rs6000_mode_dependent_address_ptr): Ditto.\n+\n+\t* config/rs6000/rs6000.c (reg_offset_addressing_ok_p): New\n+\tfunction to return true if the mode allows reg + integer\n+\taddresses.\n+\t(virtual_stack_registers_memory_p): New function to return true if\n+\tthe address refers to a virtual stack register.\n+\t(rs6000_legitimate_offset_address_p): Move code to say whether a\n+\tmode supports reg+int addressing to reg_offset_addressing_ok_p and\n+\tcall it.\n+\t(rs6000_legitimate_address_p): Add checks for modes that only can\n+\tdo reg+reg addressing.  Start adding VSX support.\n+\t(rs6000_legitimize_reload_address): Ditto.\n+\t(rs6000_legitimize_address): Ditto.\n+\t(rs6000_debug_legitimate_address_p): New debug functions for\n+\t-mdebug=addr and -mdebug=cost.\n+\t(rs6000_debug_rtx_costs): Ditto.\n+\t(rs6000_debug_address_costs): Ditto.\n+\t(rs6000_debug_adjust_cost): Ditto.\n+\t(rs6000_debug_legitimize_address): Ditto.\n+\t(rs6000_legitimize_reload_address_ptr): Point to call normal\n+\tfunction or debug function.  Make functions called via pointer\n+\tstatic.\n+\t(rs6000_mode_dependent_address_ptr): Ditto.\n+\t(rs6000_secondary_reload_class_ptr): Ditto.\n+\t(rs6000_hard_regno_mode_ok): Add preliminary VSX support.\n+\t(rs6000_emit_move): Add -mdebug=addr support.  Change an abort\n+\tinto a friendlier error.\n+\t(rs6000_init_builtins): Add initial VSX support.\n+\t(rs6000_adjust_cost): Fix some spacing issues.\n+\n+\t* config/rs6000/rs6000.h (enum reg_class): Add VSX_REGS.\n+\t(REG_CLASS_NAMES): Ditto.\n+\t(REG_CLASS_CONTENTS): Ditto.\n+\t(PREFERRED_RELOAD_CLASS): Move from a macro to calling through a\n+\tpointer, to add -mdebug=addr support.\n+\t(CANNOT_CHANGE_MODE_CLASS): Ditto.\n+\t(SECONDARY_RELOAD_CLASS): Call through a pointer to add\n+\t-mdebug=addr support.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Ditto.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): Ditto.\n+\t(enum rs6000_builtins): Add RS6000_BUILTIN_BSWAP_HI.\n+\n+\t* config/rs6000/rs6000.md (bswaphi*): Add support for swapping\n+\t16-bit values.\n+\t(bswapsi*): Set attribute types for load/store.  Add combiner\n+\tpatterns to eliminate zero extend on 64-bit.\n+\t(bswapdi*): Add support for swapping 64-bit values.  Use ldbrx and\n+\tstdbrx if the hardware supports those instructions.\n+\n 2009-06-25  Ian Lance Taylor  <iant@google.com>\n \n \t* doc/invoke.texi (Option Summary): Mention -static-libstdc++."}, {"sha": "96f215be9e3b44b419381eac9d46434d91299e14", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=8beb65e326baa7a434227ab21c1062b09ee34bdb", "patch": "@@ -64,9 +64,18 @@ extern int insvdi_rshift_rlwimi_p (rtx, rtx, rtx);\n extern int registers_ok_for_quad_peep (rtx, rtx);\n extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n-extern enum reg_class rs6000_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t     enum machine_mode, rtx);\n-\n+extern enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx,\n+\t\t\t\t\t\t\t    enum reg_class);\n+extern enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n+\t\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t\t    rtx);\n+extern bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class,\n+\t\t\t\t\t\t   enum reg_class,\n+\t\t\t\t\t\t   enum machine_mode);\n+extern bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n+\t\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t\t    enum reg_class);\n+extern void rs6000_secondary_reload_inner (rtx, rtx, rtx, bool);\n extern int paired_emit_vector_cond_expr (rtx, rtx, rtx,\n                                          rtx, rtx, rtx);\n extern void paired_expand_vector_move (rtx operands[]);\n@@ -107,10 +116,10 @@ extern rtx create_TOC_reference (rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n-extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n-\t\t\t\t\t     int, int, int, int *);\n+extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode,\n+\t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n-extern bool rs6000_mode_dependent_address (rtx);\n+extern bool (*rs6000_mode_dependent_address_ptr) (rtx);\n extern rtx rs6000_find_base_term (rtx);\n extern bool rs6000_offsettable_memref_p (rtx);\n extern rtx rs6000_return_addr (int, rtx);"}, {"sha": "cf8f53faf00fc9497d21cc1206c7e2a5141632ae", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 795, "deletions": 86, "changes": 881, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8beb65e326baa7a434227ab21c1062b09ee34bdb", "patch": "@@ -792,6 +792,7 @@ struct processor_costs power7_cost = {\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static const char *rs6000_invalid_within_doloop (const_rtx);\n static bool rs6000_legitimate_address_p (enum machine_mode, rtx, bool);\n+static bool rs6000_debug_legitimate_address_p (enum machine_mode, rtx, bool);\n static rtx rs6000_generate_compare (rtx, enum machine_mode);\n static void rs6000_emit_stack_tie (void);\n static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n@@ -803,6 +804,8 @@ static void rs6000_emit_allocate_stack (HOST_WIDE_INT, int, int);\n static unsigned rs6000_hash_constant (rtx);\n static unsigned toc_hash_function (const void *);\n static int toc_hash_eq (const void *, const void *);\n+static bool reg_offset_addressing_ok_p (enum machine_mode);\n+static bool virtual_stack_registers_memory_p (rtx);\n static bool constant_pool_expr_p (rtx);\n static bool legitimate_small_data_p (enum machine_mode, rtx);\n static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n@@ -866,7 +869,10 @@ static void rs6000_xcoff_file_end (void);\n #endif\n static int rs6000_variable_issue (FILE *, int, rtx, int);\n static bool rs6000_rtx_costs (rtx, int, int, int *, bool);\n+static bool rs6000_debug_rtx_costs (rtx, int, int, int *, bool);\n+static int rs6000_debug_address_cost (rtx, bool);\n static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n+static int rs6000_debug_adjust_cost (rtx, rtx, rtx, int);\n static void rs6000_sched_init (FILE *, int, int);\n static bool is_microcoded_insn (rtx);\n static bool is_nonpipeline_insn (rtx);\n@@ -957,6 +963,7 @@ int easy_vector_constant (rtx, enum machine_mode);\n static rtx rs6000_dwarf_register_span (rtx);\n static void rs6000_init_dwarf_reg_sizes_extra (tree);\n static rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n+static rtx rs6000_debug_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n static void rs6000_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static rtx rs6000_tls_get_addr (void);\n@@ -1009,6 +1016,59 @@ static int get_vsel_insn (enum machine_mode);\n static void rs6000_emit_vector_select (rtx, rtx, rtx, rtx);\n static tree rs6000_stack_protect_fail (void);\n \n+static rtx rs6000_legitimize_reload_address (rtx, enum machine_mode, int, int,\n+\t\t\t\t\t     int, int *);\n+\n+static rtx rs6000_debug_legitimize_reload_address (rtx, enum machine_mode, int,\n+\t\t\t\t\t\t   int, int, int *);\n+\n+rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode, int, int,\n+\t\t\t\t\t     int, int *)\n+  = rs6000_legitimize_reload_address;\n+\n+static bool rs6000_mode_dependent_address (rtx);\n+static bool rs6000_debug_mode_dependent_address (rtx);\n+bool (*rs6000_mode_dependent_address_ptr) (rtx)\n+  = rs6000_mode_dependent_address;\n+\n+static enum reg_class rs6000_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t     enum machine_mode, rtx);\n+static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t\t   rtx);\n+enum reg_class (*rs6000_secondary_reload_class_ptr) (enum reg_class,\n+\t\t\t\t\t\t     enum machine_mode, rtx)\n+  = rs6000_secondary_reload_class;\n+\n+static enum reg_class rs6000_preferred_reload_class (rtx, enum reg_class);\n+static enum reg_class rs6000_debug_preferred_reload_class (rtx,\n+\t\t\t\t\t\t\t   enum reg_class);\n+enum reg_class (*rs6000_preferred_reload_class_ptr) (rtx, enum reg_class)\n+  = rs6000_preferred_reload_class;\n+\n+static bool rs6000_secondary_memory_needed (enum reg_class, enum reg_class,\n+\t\t\t\t\t    enum machine_mode);\n+\n+static bool rs6000_debug_secondary_memory_needed (enum reg_class,\n+\t\t\t\t\t\t  enum reg_class,\n+\t\t\t\t\t\t  enum machine_mode);\n+\n+bool (*rs6000_secondary_memory_needed_ptr) (enum reg_class, enum reg_class,\n+\t\t\t\t\t    enum machine_mode)\n+  = rs6000_secondary_memory_needed;\n+\n+static bool rs6000_cannot_change_mode_class (enum machine_mode,\n+\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t     enum reg_class);\n+static bool rs6000_debug_cannot_change_mode_class (enum machine_mode,\n+\t\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t\t   enum reg_class);\n+\n+bool (*rs6000_cannot_change_mode_class_ptr) (enum machine_mode,\n+\t\t\t\t\t     enum machine_mode,\n+\t\t\t\t\t     enum reg_class)\n+  = rs6000_cannot_change_mode_class;\n+\n const int INSN_NOT_AVAILABLE = -1;\n static enum machine_mode rs6000_eh_return_filter_mode (void);\n \n@@ -1431,7 +1491,7 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n   /* AltiVec only in AldyVec registers.  */\n   if (ALTIVEC_REGNO_P (regno))\n-    return ALTIVEC_VECTOR_MODE (mode);\n+    return VECTOR_MEM_ALTIVEC_OR_VSX_P (mode);\n \n   /* ...but GPRs can hold SIMD data on the SPE in one register.  */\n   if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n@@ -2057,6 +2117,34 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_debug_cost = 1;\n       else\n \terror (\"unknown -mdebug-%s switch\", rs6000_debug_name);\n+\n+      /* If the appropriate debug option is enabled, replace the target hooks\n+\t with debug versions that call the real version and then prints\n+\t debugging information.  */\n+      if (TARGET_DEBUG_COST)\n+\t{\n+\t  targetm.rtx_costs = rs6000_debug_rtx_costs;\n+\t  targetm.address_cost = rs6000_debug_address_cost;\n+\t  targetm.sched.adjust_cost = rs6000_debug_adjust_cost;\n+\t}\n+\n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  targetm.legitimate_address_p = rs6000_debug_legitimate_address_p;\n+\t  targetm.legitimize_address = rs6000_debug_legitimize_address;\n+\t  rs6000_secondary_reload_class_ptr\n+\t    = rs6000_debug_secondary_reload_class;\n+\t  rs6000_secondary_memory_needed_ptr\n+\t    = rs6000_debug_secondary_memory_needed;\n+\t  rs6000_cannot_change_mode_class_ptr\n+\t    = rs6000_debug_cannot_change_mode_class;\n+\t  rs6000_preferred_reload_class_ptr\n+\t    = rs6000_debug_preferred_reload_class;\n+\t  rs6000_legitimize_reload_address_ptr\n+\t    = rs6000_debug_legitimize_reload_address;\n+\t  rs6000_mode_dependent_address_ptr\n+\t    = rs6000_debug_mode_dependent_address;\n+\t}\n     }\n \n   if (rs6000_traceback_name)\n@@ -3977,6 +4065,58 @@ gpr_or_gpr_p (rtx op0, rtx op1)\n \f\n /* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address_p.  */\n \n+static bool\n+reg_offset_addressing_ok_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SFmode:\n+    case V4SImode:\n+    case V2DFmode:\n+    case V2DImode:\n+      /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  */\n+      if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n+\treturn false;\n+      break;\n+\n+    case V4HImode:\n+    case V2SImode:\n+    case V1DImode:\n+    case V2SFmode:\n+       /* Paired vector modes.  Only reg+reg addressing is valid.  */\n+      if (TARGET_PAIRED_FLOAT)\n+        return false;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+static bool\n+virtual_stack_registers_memory_p (rtx op)\n+{\n+  int regnum;\n+\n+  if (GET_CODE (op) == REG)\n+    regnum = REGNO (op);\n+\n+  else if (GET_CODE (op) == PLUS\n+\t   && GET_CODE (XEXP (op, 0)) == REG\n+\t   && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+    regnum = REGNO (XEXP (op, 0));\n+\n+  else\n+    return false;\n+\n+  return (regnum >= FIRST_VIRTUAL_REGISTER\n+\t  && regnum <= LAST_VIRTUAL_REGISTER);\n+}\n+\n static bool\n constant_pool_expr_p (rtx op)\n {\n@@ -4034,6 +4174,8 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n+  if (!reg_offset_addressing_ok_p (mode))\n+    return virtual_stack_registers_memory_p (x);\n   if (legitimate_constant_pool_address_p (x))\n     return true;\n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n@@ -4043,29 +4185,22 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n   extra = 0;\n   switch (mode)\n     {\n-    case V16QImode:\n-    case V8HImode:\n-    case V4SFmode:\n-    case V4SImode:\n-      /* AltiVec vector modes.  Only reg+reg addressing is valid and\n-\t constant offset zero should not occur due to canonicalization.  */\n-      return false;\n-\n     case V4HImode:\n     case V2SImode:\n     case V1DImode:\n     case V2SFmode:\n-       /* Paired vector modes.  Only reg+reg addressing is valid and\n-\t  constant offset zero should not occur due to canonicalization.  */\n-      if (TARGET_PAIRED_FLOAT)\n-        return false;\n       /* SPE vector modes.  */\n       return SPE_CONST_OFFSET_OK (offset);\n \n     case DFmode:\n       if (TARGET_E500_DOUBLE)\n \treturn SPE_CONST_OFFSET_OK (offset);\n \n+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n+\t addressing.  */\n+      if (VECTOR_MEM_VSX_P (DFmode))\n+\treturn false;\n+\n     case DDmode:\n     case DImode:\n       /* On e500v2, we may have:\n@@ -4136,7 +4271,7 @@ avoiding_indexed_address_p (enum machine_mode mode)\n {\n   /* Avoid indexed addressing for modes that have non-indexed\n      load/store instruction forms.  */\n-  return TARGET_AVOID_XFORM && !ALTIVEC_VECTOR_MODE (mode);\n+  return (TARGET_AVOID_XFORM && VECTOR_MEM_NONE_P (mode));\n }\n \n inline bool\n@@ -4222,17 +4357,34 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n    Then check for the sum of a register and something not constant, try to\n    load the other things into a register and return the sum.  */\n \n-rtx\n+static rtx\n rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t   enum machine_mode mode)\n {\n+  if (!reg_offset_addressing_ok_p (mode))\n+    {\n+      if (virtual_stack_registers_memory_p (x))\n+\treturn x;\n+\n+      /* In theory we should not be seeing addresses of the form reg+0,\n+\t but just in case it is generated, optimize it away.  */\n+      if (GET_CODE (x) == PLUS && XEXP (x, 1) == const0_rtx)\n+\treturn force_reg (Pmode, XEXP (x, 0));\n+\n+      /* Make sure both operands are registers.  */\n+      else if (GET_CODE (x) == PLUS)\n+\treturn gen_rtx_PLUS (Pmode,\n+\t\t\t     force_reg (Pmode, XEXP (x, 0)),\n+\t\t\t     force_reg (Pmode, XEXP (x, 1)));\n+      else\n+\treturn force_reg (Pmode, x);\n+    }\n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n       enum tls_model model = SYMBOL_REF_TLS_MODEL (x);\n       if (model != 0)\n \treturn rs6000_legitimize_tls_address (x, model);\n     }\n-\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n@@ -4241,7 +4393,6 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t    && (mode == DImode || mode == TImode)\n \t    && (INTVAL (XEXP (x, 1)) & 3) != 0)\n \t   || SPE_VECTOR_MODE (mode)\n-\t   || ALTIVEC_VECTOR_MODE (mode)\n \t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t      || mode == DImode || mode == DDmode\n \t\t\t\t      || mode == TDmode))))\n@@ -4271,18 +4422,6 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return gen_rtx_PLUS (Pmode, XEXP (x, 0),\n \t\t\t   force_reg (Pmode, force_operand (XEXP (x, 1), 0)));\n     }\n-  else if (ALTIVEC_VECTOR_MODE (mode))\n-    {\n-      rtx reg;\n-\n-      /* Make sure both operands are registers.  */\n-      if (GET_CODE (x) == PLUS)\n-\treturn gen_rtx_PLUS (Pmode, force_reg (Pmode, XEXP (x, 0)),\n-\t\t\t     force_reg (Pmode, XEXP (x, 1)));\n-\n-      reg = force_reg (Pmode, x);\n-      return reg;\n-    }\n   else if (SPE_VECTOR_MODE (mode)\n \t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t      || mode == DDmode || mode == TDmode\n@@ -4364,6 +4503,56 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n     return x;\n }\n \n+/* Debug version of rs6000_legitimize_address.  */\n+static rtx\n+rs6000_debug_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n+{\n+  rtx ret;\n+  rtx insns;\n+\n+  start_sequence ();\n+  ret = rs6000_legitimize_address (x, oldx, mode);\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  if (ret != x)\n+    {\n+      fprintf (stderr,\n+\t       \"\\nrs6000_legitimize_address: mode %s, old code %s, \"\n+\t       \"new code %s, modified\\n\",\n+\t       GET_MODE_NAME (mode), GET_RTX_NAME (GET_CODE (x)),\n+\t       GET_RTX_NAME (GET_CODE (ret)));\n+\n+      fprintf (stderr, \"Original address:\\n\");\n+      debug_rtx (x);\n+\n+      fprintf (stderr, \"oldx:\\n\");\n+      debug_rtx (oldx);\n+\n+      fprintf (stderr, \"New address:\\n\");\n+      debug_rtx (ret);\n+\n+      if (insns)\n+\t{\n+\t  fprintf (stderr, \"Insns added:\\n\");\n+\t  debug_rtx_list (insns, 20);\n+\t}\n+    }\n+  else\n+    {\n+      fprintf (stderr,\n+\t       \"\\nrs6000_legitimize_address: mode %s, code %s, no change:\\n\",\n+\t       GET_MODE_NAME (mode), GET_RTX_NAME (GET_CODE (x)));\n+\n+      debug_rtx (x);\n+    }\n+\n+  if (insns)\n+    emit_insn (insns);\n+\n+  return ret;\n+}\n+\n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n \n@@ -4638,11 +4827,13 @@ rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n    A movsf_low is generated so we wind up with 2 instructions rather than 3.\n    The Darwin code is inside #if TARGET_MACHO because only then are the\n    machopic_* functions defined.  */\n-rtx\n+static rtx\n rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t\t\t\t  int opnum, int type,\n \t\t\t\t  int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n+  bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n+\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n@@ -4683,8 +4874,9 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && REGNO (XEXP (x, 0)) < 32\n       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && reg_offset_p\n       && (INTVAL (XEXP (x, 1)) & 3) != 0\n-      && !ALTIVEC_VECTOR_MODE (mode)\n+      && VECTOR_MEM_NONE_P (mode)\n       && GET_MODE_SIZE (mode) >= UNITS_PER_WORD\n       && TARGET_POWERPC64)\n     {\n@@ -4701,11 +4893,12 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n       && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n+      && reg_offset_p\n       && !SPE_VECTOR_MODE (mode)\n       && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t  || mode == DDmode || mode == TDmode\n \t\t\t\t  || mode == DImode))\n-      && !ALTIVEC_VECTOR_MODE (mode))\n+      && VECTOR_MEM_NONE_P (mode))\n     {\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n@@ -4735,7 +4928,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     }\n \n   if (GET_CODE (x) == SYMBOL_REF\n-      && !ALTIVEC_VECTOR_MODE (mode)\n+      && reg_offset_p\n+      && VECTOR_MEM_NONE_P (mode)\n       && !SPE_VECTOR_MODE (mode)\n #if TARGET_MACHO\n       && DEFAULT_ABI == ABI_DARWIN\n@@ -4775,9 +4969,11 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \n   /* Reload an offset address wrapped by an AND that represents the\n      masking of the lower bits.  Strip the outer AND and let reload\n-     convert the offset address into an indirect address.  */\n-  if (TARGET_ALTIVEC\n-      && ALTIVEC_VECTOR_MODE (mode)\n+     convert the offset address into an indirect address.  For VSX,\n+     force reload to create the address with an AND in a separate\n+     register, because we can't guarantee an altivec register will\n+     be used.  */\n+  if (VECTOR_MEM_ALTIVEC_P (mode)\n       && GET_CODE (x) == AND\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n@@ -4791,6 +4987,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     }\n \n   if (TARGET_TOC\n+      && reg_offset_p\n       && GET_CODE (x) == SYMBOL_REF\n       && constant_pool_expr_p (x)\n       && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), mode))\n@@ -4803,6 +5000,33 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n   return x;\n }\n \n+/* Debug version of rs6000_legitimize_reload_address.  */\n+static rtx\n+rs6000_debug_legitimize_reload_address (rtx x, enum machine_mode mode,\n+\t\t\t\t\tint opnum, int type,\n+\t\t\t\t\tint ind_levels, int *win)\n+{\n+  rtx ret = rs6000_legitimize_reload_address (x, mode, opnum, type,\n+\t\t\t\t\t      ind_levels, win);\n+  fprintf (stderr,\n+\t   \"\\nrs6000_legitimize_reload_address: mode = %s, opnum = %d, \"\n+\t   \"type = %d, ind_levels = %d, win = %d, original addr:\\n\",\n+\t   GET_MODE_NAME (mode), opnum, type, ind_levels, *win);\n+  debug_rtx (x);\n+\n+  if (x == ret)\n+    fprintf (stderr, \"Same address returned\\n\");\n+  else if (!ret)\n+    fprintf (stderr, \"NULL returned\\n\");\n+  else\n+    {\n+      fprintf (stderr, \"New address:\\n\");\n+      debug_rtx (ret);\n+    }\n+\n+  return ret;\n+}\n+\n /* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n@@ -4823,9 +5047,10 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n bool\n rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n {\n+  bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n+\n   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */\n-  if (TARGET_ALTIVEC\n-      && ALTIVEC_VECTOR_MODE (mode)\n+  if (VECTOR_MEM_ALTIVEC_P (mode)\n       && GET_CODE (x) == AND\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && INTVAL (XEXP (x, 1)) == -16)\n@@ -4836,7 +5061,7 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n   if (legitimate_indirect_address_p (x, reg_ok_strict))\n     return 1;\n   if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n-      && !ALTIVEC_VECTOR_MODE (mode)\n+      && !VECTOR_MEM_ALTIVEC_OR_VSX_P (mode)\n       && !SPE_VECTOR_MODE (mode)\n       && mode != TFmode\n       && mode != TDmode\n@@ -4846,12 +5071,15 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n-  if (legitimate_small_data_p (mode, x))\n+  if (virtual_stack_registers_memory_p (x))\n     return 1;\n-  if (legitimate_constant_pool_address_p (x))\n+  if (reg_offset_p && legitimate_small_data_p (mode, x))\n+    return 1;\n+  if (reg_offset_p && legitimate_constant_pool_address_p (x))\n     return 1;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n+      && reg_offset_p\n       && GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && (XEXP (x, 0) == virtual_stack_vars_rtx\n@@ -4871,6 +5099,12 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n       && !avoiding_indexed_address_p (mode)\n       && legitimate_indexed_address_p (x, reg_ok_strict))\n     return 1;\n+  if (GET_CODE (x) == PRE_MODIFY\n+      && VECTOR_MEM_VSX_P (mode)\n+      && TARGET_UPDATE\n+      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)\n+      && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n+    return 1;\n   if (GET_CODE (x) == PRE_MODIFY\n       && mode != TImode\n       && mode != TFmode\n@@ -4879,7 +5113,7 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n \t  || TARGET_POWERPC64\n \t  || ((mode != DFmode && mode != DDmode) || TARGET_E500_DOUBLE))\n       && (TARGET_POWERPC64 || mode != DImode)\n-      && !ALTIVEC_VECTOR_MODE (mode)\n+      && !VECTOR_MEM_ALTIVEC_P (mode)\n       && !SPE_VECTOR_MODE (mode)\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n       && !(TARGET_E500_DOUBLE\n@@ -4891,23 +5125,41 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n \t      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)))\n       && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n     return 1;\n-  if (legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n+  if (reg_offset_p && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n     return 1;\n   return 0;\n }\n \n+/* Debug version of rs6000_legitimate_address_p.  */\n+static bool\n+rs6000_debug_legitimate_address_p (enum machine_mode mode, rtx x,\n+\t\t\t\t   bool reg_ok_strict)\n+{\n+  bool ret = rs6000_legitimate_address_p (mode, x, reg_ok_strict);\n+  fprintf (stderr,\n+\t   \"\\nrs6000_legitimate_address_p: return = %s, mode = %s, \"\n+\t   \"strict = %d, code = %s\\n\",\n+\t   ret ? \"true\" : \"false\",\n+\t   GET_MODE_NAME (mode),\n+\t   reg_ok_strict,\n+\t   GET_RTX_NAME (GET_CODE (x)));\n+  debug_rtx (x);\n+\n+  return ret;\n+}\n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n \n    On the RS/6000 this is true of all integral offsets (since AltiVec\n-   modes don't allow them) or is a pre-increment or decrement.\n+   and VSX modes don't allow them) or is a pre-increment or decrement.\n \n    ??? Except that due to conceptual problems in offsettable_address_p\n    we can't really report the problems of integral offsets.  So leave\n    this assuming that the adjustable offset must be valid for the\n    sub-words of a TFmode operand, which is what we had before.  */\n \n-bool\n+static bool\n rs6000_mode_dependent_address (rtx addr)\n {\n   switch (GET_CODE (addr))\n@@ -4934,6 +5186,19 @@ rs6000_mode_dependent_address (rtx addr)\n   return false;\n }\n \n+/* Debug version of rs6000_mode_dependent_address.  */\n+static bool\n+rs6000_debug_mode_dependent_address (rtx addr)\n+{\n+  bool ret = rs6000_mode_dependent_address (addr);\n+\n+  fprintf (stderr, \"\\nrs6000_mode_dependent_address: ret = %s\\n\",\n+\t   ret ? \"true\" : \"false\");\n+  debug_rtx (addr);\n+\n+  return ret;\n+}\n+\n /* Implement FIND_BASE_TERM.  */\n \n rtx\n@@ -5271,6 +5536,20 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n   operands[0] = dest;\n   operands[1] = source;\n \n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr,\n+\t       \"\\nrs6000_emit_move: mode = %s, reload_in_progress = %d, \"\n+\t       \"reload_completed = %d, can_create_pseudos = %d.\\ndest:\\n\",\n+\t       GET_MODE_NAME (mode),\n+\t       reload_in_progress,\n+\t       reload_completed,\n+\t       can_create_pseudo_p ());\n+      debug_rtx (dest);\n+      fprintf (stderr, \"source:\\n\");\n+      debug_rtx (source);\n+    }\n+\n   /* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && ! FLOAT_MODE_P (mode)\n@@ -5651,7 +5930,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       break;\n \n     default:\n-      gcc_unreachable ();\n+      fatal_insn (\"bad move\", gen_rtx_SET (VOIDmode, dest, source));\n     }\n \n   /* Above, we may have called force_const_mem which may have returned\n@@ -9632,6 +9911,9 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   if (fcode == RS6000_BUILTIN_RSQRTF)\n       return rs6000_expand_unop_builtin (CODE_FOR_rsqrtsf2, exp, target);    \n \n+  if (fcode == RS6000_BUILTIN_BSWAP_HI)\n+    return rs6000_expand_unop_builtin (CODE_FOR_bswaphi2, exp, target);\n+\n   if (fcode == ALTIVEC_BUILTIN_MASK_FOR_LOAD\n       || fcode == ALTIVEC_BUILTIN_MASK_FOR_STORE)\n     {\n@@ -9861,7 +10143,7 @@ rs6000_init_builtins (void)\n     spe_init_builtins ();\n   if (TARGET_ALTIVEC)\n     altivec_init_builtins ();\n-  if (TARGET_ALTIVEC || TARGET_SPE || TARGET_PAIRED_FLOAT)\n+  if (TARGET_ALTIVEC || TARGET_SPE || TARGET_PAIRED_FLOAT || TARGET_VSX)\n     rs6000_common_init_builtins ();\n   if (TARGET_PPC_GFXOPT)\n     {\n@@ -9888,6 +10170,14 @@ rs6000_init_builtins (void)\n \t\t   RS6000_BUILTIN_RECIP);\n \n     }\n+  if (TARGET_POWERPC)\n+    {\n+      tree ftype = build_function_type_list (unsigned_intHI_type_node,\n+\t\t\t\t\t     unsigned_intHI_type_node,\n+\t\t\t\t\t     NULL_TREE);\n+      def_builtin (MASK_POWERPC, \"__builtin_bswap16\", ftype,\n+\t\t   RS6000_BUILTIN_BSWAP_HI);\n+    }\n \n #if TARGET_XCOFF\n   /* AIX libm provides clog as __clog.  */\n@@ -11897,8 +12187,10 @@ rtx\n rs6000_secondary_memory_needed_rtx (enum machine_mode mode)\n {\n   static bool eliminated = false;\n+  rtx ret;\n+\n   if (mode != SDmode)\n-    return assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n+    ret = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n   else\n     {\n       rtx mem = cfun->machine->sdmode_stack_slot;\n@@ -11910,8 +12202,20 @@ rs6000_secondary_memory_needed_rtx (enum machine_mode mode)\n \t  cfun->machine->sdmode_stack_slot = mem;\n \t  eliminated = true;\n \t}\n-      return mem;\n+      ret = mem;\n+    }\n+\n+  if (TARGET_DEBUG_ADDR)\n+    {\n+      fprintf (stderr, \"\\nrs6000_secondary_memory_needed_rtx, mode %s, rtx:\\n\",\n+\t       GET_MODE_NAME (mode));\n+      if (!ret)\n+\tfprintf (stderr, \"\\tNULL_RTX\\n\");\n+      else\n+\tdebug_rtx (ret);\n     }\n+\n+  return ret;\n }\n \n static tree\n@@ -11946,7 +12250,6 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-\n /* Allocate a 64-bit stack slot to be used for copying SDmode\n    values through if this function has any SDmode references.  */\n \n@@ -11996,13 +12299,163 @@ rs6000_instantiate_decls (void)\n     instantiate_decl_rtl (cfun->machine->sdmode_stack_slot);\n }\n \n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+\n+   On the RS/6000, we have to return NO_REGS when we want to reload a\n+   floating-point CONST_DOUBLE to force it to be copied to memory.\n+\n+   We also don't want to reload integer values into floating-point\n+   registers if we can at all help it.  In fact, this can\n+   cause reload to die, if it tries to generate a reload of CTR\n+   into a FP register and discovers it doesn't have the memory location\n+   required.\n+\n+   ??? Would it be a good idea to have reload do the converse, that is\n+   try to reload floating modes into FP registers if possible?\n+ */\n+\n+static enum reg_class\n+rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (VECTOR_UNIT_VSX_P (mode)\n+      && x == CONST0_RTX (mode) && VSX_REG_CLASS_P (rclass))\n+    return rclass;\n+\n+  if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (mode)\n+      && (rclass == ALTIVEC_REGS || rclass == VSX_REGS)\n+      && easy_vector_constant (x, mode))\n+    return ALTIVEC_REGS;\n+\n+  if (CONSTANT_P (x) && reg_classes_intersect_p (rclass, FLOAT_REGS))\n+    return NO_REGS;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_INT && rclass == NON_SPECIAL_REGS)\n+    return GENERAL_REGS;\n+\n+  /* For VSX, prefer the traditional registers for DF if the address is of the\n+     form reg+offset because we can use the non-VSX loads.  Prefer the Altivec\n+     registers if Altivec is handling the vector operations (i.e. V16QI, V8HI,\n+     and V4SI).  */\n+  if (rclass == VSX_REGS && VECTOR_MEM_VSX_P (mode))\n+    {\n+      if (mode == DFmode && GET_CODE (x) == MEM)\n+\t{\n+\t  rtx addr = XEXP (x, 0);\n+\n+\t  if (legitimate_indirect_address_p (addr, false))\t/* reg */\n+\t    return VSX_REGS;\n+\n+\t  if (legitimate_indexed_address_p (addr, false))\t/* reg+reg */\n+\t    return VSX_REGS;\n+\n+\t  if (GET_CODE (addr) == PRE_MODIFY\n+\t      && legitimate_indexed_address_p (XEXP (addr, 0), false))\n+\t    return VSX_REGS;\n+\n+\t  return FLOAT_REGS;\n+\t}\n+\n+      if (VECTOR_UNIT_ALTIVEC_P (mode))\n+\treturn ALTIVEC_REGS;\n+\n+      return rclass;\n+    }\n+\n+  return rclass;\n+}\n+\n+/* Debug version of rs6000_preferred_reload_class.  */\n+static enum reg_class\n+rs6000_debug_preferred_reload_class (rtx x, enum reg_class rclass)\n+{\n+  enum reg_class ret = rs6000_preferred_reload_class (x, rclass);\n+\n+  fprintf (stderr,\n+\t   \"\\nrs6000_preferred_reload_class, return %s, rclass = %s, \"\n+\t   \"mode = %s, x:\\n\",\n+\t   reg_class_names[ret], reg_class_names[rclass],\n+\t   GET_MODE_NAME (GET_MODE (x)));\n+  debug_rtx (x);\n+\n+  return ret;\n+}\n+\n+/* If we are copying between FP or AltiVec registers and anything else, we need\n+   a memory location.  The exception is when we are targeting ppc64 and the\n+   move to/from fpr to gpr instructions are available.  Also, under VSX, you\n+   can copy vector registers from the FP register set to the Altivec register\n+   set and vice versa.  */\n+\n+static bool\n+rs6000_secondary_memory_needed (enum reg_class class1,\n+\t\t\t\tenum reg_class class2,\n+\t\t\t\tenum machine_mode mode)\n+{\n+  if (class1 == class2)\n+    return false;\n+\n+  /* Under VSX, there are 3 register classes that values could be in (VSX_REGS,\n+     ALTIVEC_REGS, and FLOAT_REGS).  We don't need to use memory to copy\n+     between these classes.  But we need memory for other things that can go in\n+     FLOAT_REGS like SFmode.  */\n+  if (TARGET_VSX\n+      && (VECTOR_MEM_VSX_P (mode) || VECTOR_UNIT_VSX_P (mode))\n+      && (class1 == VSX_REGS || class1 == ALTIVEC_REGS\n+\t  || class1 == FLOAT_REGS))\n+    return (class2 != VSX_REGS && class2 != ALTIVEC_REGS\n+\t    && class2 != FLOAT_REGS);\n+\n+  if (class1 == VSX_REGS || class2 == VSX_REGS)\n+    return true;\n+\n+  if (class1 == FLOAT_REGS\n+      && (!TARGET_MFPGPR || !TARGET_POWERPC64\n+\t  || ((mode != DFmode)\n+\t      && (mode != DDmode)\n+\t      && (mode != DImode))))\n+    return true;\n+\n+  if (class2 == FLOAT_REGS\n+      && (!TARGET_MFPGPR || !TARGET_POWERPC64\n+\t  || ((mode != DFmode)\n+\t      && (mode != DDmode)\n+\t      && (mode != DImode))))\n+    return true;\n+\n+  if (class1 == ALTIVEC_REGS || class2 == ALTIVEC_REGS)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Debug version of rs6000_secondary_memory_needed.  */\n+static bool\n+rs6000_debug_secondary_memory_needed (enum reg_class class1,\n+\t\t\t\t      enum reg_class class2,\n+\t\t\t\t      enum machine_mode mode)\n+{\n+  bool ret = rs6000_secondary_memory_needed (class1, class2, mode);\n+\n+  fprintf (stderr,\n+\t   \"rs6000_secondary_memory_needed, return: %s, class1 = %s, \"\n+\t   \"class2 = %s, mode = %s\\n\",\n+\t   ret ? \"true\" : \"false\", reg_class_names[class1],\n+\t   reg_class_names[class2], GET_MODE_NAME (mode));\n+\n+  return ret;\n+}\n+\n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in RCLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n \n-enum reg_class\n-rs6000_secondary_reload_class (enum reg_class rclass,\n-\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+static enum reg_class\n+rs6000_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t\t\t       rtx in)\n {\n   int regno;\n@@ -12071,6 +12524,83 @@ rs6000_secondary_reload_class (enum reg_class rclass,\n   /* Otherwise, we need GENERAL_REGS.  */\n   return GENERAL_REGS;\n }\n+\n+/* Debug version of rs6000_secondary_reload_class.  */\n+static enum reg_class\n+rs6000_debug_secondary_reload_class (enum reg_class rclass,\n+\t\t\t\t     enum machine_mode mode, rtx in)\n+{\n+  enum reg_class ret = rs6000_secondary_reload_class (rclass, mode, in);\n+  fprintf (stderr,\n+\t   \"\\nrs6000_secondary_reload_class, return %s, rclass = %s, \"\n+\t   \"mode = %s, input rtx:\\n\",\n+\t   reg_class_names[ret], reg_class_names[rclass],\n+\t   GET_MODE_NAME (mode));\n+  debug_rtx (in);\n+\n+  return ret;\n+}\n+\n+/* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n+\n+static bool\n+rs6000_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t\t enum machine_mode to,\n+\t\t\t\t enum reg_class rclass)\n+{\n+  unsigned from_size = GET_MODE_SIZE (from);\n+  unsigned to_size = GET_MODE_SIZE (to);\n+\n+  if (from_size != to_size)\n+    {\n+      enum reg_class xclass = (TARGET_VSX) ? VSX_REGS : FLOAT_REGS;\n+      return ((from_size < 8 || to_size < 8 || TARGET_IEEEQUAD)\n+\t      && reg_classes_intersect_p (xclass, rclass));\n+    }\n+\n+  if (TARGET_E500_DOUBLE\n+      && ((((to) == DFmode) + ((from) == DFmode)) == 1\n+\t  || (((to) == TFmode) + ((from) == TFmode)) == 1\n+\t  || (((to) == DDmode) + ((from) == DDmode)) == 1\n+\t  || (((to) == TDmode) + ((from) == TDmode)) == 1\n+\t  || (((to) == DImode) + ((from) == DImode)) == 1))\n+    return true;\n+\n+  /* Since the VSX register set includes traditional floating point registers\n+     and altivec registers, just check for the size being different instead of\n+     trying to check whether the modes are vector modes.  Otherwise it won't\n+     allow say DF and DI to change classes.  */\n+  if (TARGET_VSX && VSX_REG_CLASS_P (rclass))\n+    return (from_size != 8 && from_size != 16);\n+\n+  if (TARGET_ALTIVEC && rclass == ALTIVEC_REGS\n+      && (ALTIVEC_VECTOR_MODE (from) + ALTIVEC_VECTOR_MODE (to)) == 1)\n+    return true;\n+\n+  if (TARGET_SPE && (SPE_VECTOR_MODE (from) + SPE_VECTOR_MODE (to)) == 1\n+      && reg_classes_intersect_p (GENERAL_REGS, rclass))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Debug version of rs6000_cannot_change_mode_class.  */\n+static bool\n+rs6000_debug_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t\t       enum machine_mode to,\n+\t\t\t\t       enum reg_class rclass)\n+{\n+  bool ret = rs6000_cannot_change_mode_class (from, to, rclass);\n+\n+  fprintf (stderr,\n+\t   \"rs6000_cannot_change_mode_class, return %s, from = %s, \"\n+\t   \"to = %s, rclass = %s\\n\",\n+\t   ret ? \"true\" : \"false\",\n+\t   GET_MODE_NAME (from), GET_MODE_NAME (to),\n+\t   reg_class_names[rclass]);\n+\n+  return ret;\n+}\n \f\n /* Given a comparison operation, return the bit number in CCR to test.  We\n    know this is a valid comparison.\n@@ -12364,7 +12894,7 @@ print_operand (FILE *file, rtx x, int code)\n     case 'c':\n       /* X is a CR register.  Print the number of the GT bit of the CR.  */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n-\toutput_operand_lossage (\"invalid %%E value\");\n+\toutput_operand_lossage (\"invalid %%c value\");\n       else\n \tfprintf (file, \"%d\", 4 * (REGNO (x) - CR0_REGNO) + 1);\n       return;\n@@ -12801,6 +13331,26 @@ print_operand (FILE *file, rtx x, int code)\n       fprintf (file, \"%d\", i + 1);\n       return;\n \n+    case 'x':\n+      /* X is a FPR or Altivec register used in a VSX context.  */\n+      if (GET_CODE (x) != REG || !VSX_REGNO_P (REGNO (x)))\n+\toutput_operand_lossage (\"invalid %%x value\");\n+      else\n+\t{\n+\t  int reg = REGNO (x);\n+\t  int vsx_reg = (FP_REGNO_P (reg)\n+\t\t\t ? reg - 32\n+\t\t\t : reg - FIRST_ALTIVEC_REGNO + 32);\n+\n+#ifdef TARGET_REGNAMES      \n+\t  if (TARGET_REGNAMES)\n+\t    fprintf (file, \"%%vs%d\", vsx_reg);\n+\t  else\n+#endif\n+\t    fprintf (file, \"%d\", vsx_reg);\n+\t}\n+      return;\n+\n     case 'X':\n       if (GET_CODE (x) == MEM\n \t  && (legitimate_indexed_address_p (XEXP (x, 0), 0)\n@@ -12913,13 +13463,16 @@ print_operand (FILE *file, rtx x, int code)\n \n \t    /* Fall through.  Must be [reg+reg].  */\n \t  }\n-\tif (TARGET_ALTIVEC\n+\tif (VECTOR_MEM_ALTIVEC_P (GET_MODE (x))\n \t    && GET_CODE (tmp) == AND\n \t    && GET_CODE (XEXP (tmp, 1)) == CONST_INT\n \t    && INTVAL (XEXP (tmp, 1)) == -16)\n \t  tmp = XEXP (tmp, 0);\n+\telse if (VECTOR_MEM_VSX_P (GET_MODE (x))\n+\t\t && GET_CODE (tmp) == PRE_MODIFY)\n+\t  tmp = XEXP (tmp, 1);\n \tif (GET_CODE (tmp) == REG)\n-\t  fprintf (file, \"0,%s\", reg_names[REGNO (tmp)]);\n+\t  fprintf (file, \"%s,%s\", reg_names[0], reg_names[REGNO (tmp)]);\n \telse\n \t  {\n \t    if (!GET_CODE (tmp) == PLUS\n@@ -18817,7 +19370,8 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \n   if (GET_CODE (x) == CONST)\n     {\n-      gcc_assert (GET_CODE (XEXP (x, 0)) == PLUS);\n+      gcc_assert (GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT);\n \n       base = XEXP (XEXP (x, 0), 0);\n       offset = INTVAL (XEXP (XEXP (x, 0), 1));\n@@ -19235,15 +19789,15 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n         /* Data dependency; DEP_INSN writes a register that INSN reads\n \t   some cycles later.  */\n \n-        /* Separate a load from a narrower, dependent store.  */\n-        if (rs6000_sched_groups\n-            && GET_CODE (PATTERN (insn)) == SET\n-            && GET_CODE (PATTERN (dep_insn)) == SET\n-            && GET_CODE (XEXP (PATTERN (insn), 1)) == MEM\n-            && GET_CODE (XEXP (PATTERN (dep_insn), 0)) == MEM\n-            && (GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (insn), 1)))\n-                > GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (dep_insn), 0)))))\n-          return cost + 14;\n+\t/* Separate a load from a narrower, dependent store.  */\n+\tif (rs6000_sched_groups\n+\t    && GET_CODE (PATTERN (insn)) == SET\n+\t    && GET_CODE (PATTERN (dep_insn)) == SET\n+\t    && GET_CODE (XEXP (PATTERN (insn), 1)) == MEM\n+\t    && GET_CODE (XEXP (PATTERN (dep_insn), 0)) == MEM\n+\t    && (GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (insn), 1)))\n+\t\t> GET_MODE_SIZE (GET_MODE (XEXP (PATTERN (dep_insn), 0)))))\n+\t  return cost + 14;\n \n         attr_type = get_attr_type (insn);\n \n@@ -19269,6 +19823,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                  || rs6000_cpu_attr == CPU_PPC7450\n                  || rs6000_cpu_attr == CPU_POWER4\n                  || rs6000_cpu_attr == CPU_POWER5\n+\t\t || rs6000_cpu_attr == CPU_POWER7\n                  || rs6000_cpu_attr == CPU_CELL)\n                 && recog_memoized (dep_insn)\n                 && (INSN_CODE (dep_insn) >= 0))\n@@ -19283,7 +19838,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                 case TYPE_FPCOMPARE:\n                 case TYPE_CR_LOGICAL:\n                 case TYPE_DELAYED_CR:\n-                    return cost + 2;\n+\t\t  return cost + 2;\n \t\tdefault:\n \t\t  break;\n \t\t}\n@@ -19328,7 +19883,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                       if (! store_data_bypass_p (dep_insn, insn))\n                         return 6;\n                       break;\n-                      }\n+\t\t    }\n                   case TYPE_INTEGER:\n                   case TYPE_COMPARE:\n                   case TYPE_FAST_COMPARE:\n@@ -19374,7 +19929,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                     break;\n                   }\n               }\n-              break;\n+\t    break;\n \n           case TYPE_LOAD:\n           case TYPE_LOAD_U:\n@@ -19469,7 +20024,7 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n             break;\n           }\n \n-      /* Fall out to return default cost.  */\n+\t/* Fall out to return default cost.  */\n       }\n       break;\n \n@@ -19508,6 +20063,35 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n   return cost;\n }\n \n+/* Debug version of rs6000_adjust_cost.  */\n+\n+static int\n+rs6000_debug_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n+{\n+  int ret = rs6000_adjust_cost (insn, link, dep_insn, cost);\n+\n+  if (ret != cost)\n+    {\n+      const char *dep;\n+\n+      switch (REG_NOTE_KIND (link))\n+\t{\n+\tdefault:\t     dep = \"unknown depencency\"; break;\n+\tcase REG_DEP_TRUE:   dep = \"data dependency\";\t break;\n+\tcase REG_DEP_OUTPUT: dep = \"output dependency\";  break;\n+\tcase REG_DEP_ANTI:   dep = \"anti depencency\";\t break;\n+\t}\n+\n+      fprintf (stderr,\n+\t       \"\\nrs6000_adjust_cost, final cost = %d, orig cost = %d, \"\n+\t       \"%s, insn:\\n\", ret, cost, dep);\n+\n+      debug_rtx (insn);\n+    }\n+\n+  return ret;\n+}\n+\n /* The function returns a true if INSN is microcoded.\n    Return false otherwise.  */\n \n@@ -19789,6 +20373,7 @@ rs6000_issue_rate (void)\n   case CPU_POWER4:\n   case CPU_POWER5:\n   case CPU_POWER6:\n+  case CPU_POWER7:\n     return 5;\n   default:\n     return 1;\n@@ -20390,6 +20975,41 @@ insn_must_be_first_in_group (rtx insn)\n           break;\n         }\n       break;\n+    case PROCESSOR_POWER7:\n+      type = get_attr_type (insn);\n+\n+      switch (type)\n+        {\n+        case TYPE_CR_LOGICAL:\n+        case TYPE_MFCR:\n+        case TYPE_MFCRF:\n+        case TYPE_MTCR:\n+        case TYPE_IDIV:\n+        case TYPE_LDIV:\n+        case TYPE_COMPARE:\n+        case TYPE_DELAYED_COMPARE:\n+        case TYPE_VAR_DELAYED_COMPARE:\n+        case TYPE_ISYNC:\n+        case TYPE_LOAD_L:\n+        case TYPE_STORE_C:\n+        case TYPE_LOAD_U:\n+        case TYPE_LOAD_UX:\n+        case TYPE_LOAD_EXT:\n+        case TYPE_LOAD_EXT_U:\n+        case TYPE_LOAD_EXT_UX:\n+        case TYPE_STORE_U:\n+        case TYPE_STORE_UX:\n+        case TYPE_FPLOAD_U:\n+        case TYPE_FPLOAD_UX:\n+        case TYPE_FPSTORE_U:\n+        case TYPE_FPSTORE_UX:\n+        case TYPE_MFJMPR:\n+        case TYPE_MTJMPR:\n+          return true;\n+        default:\n+          break;\n+        }\n+      break;\n     default:\n       break;\n     }\n@@ -20451,6 +21071,23 @@ insn_must_be_last_in_group (rtx insn)\n         break;\n     }\n     break;\n+  case PROCESSOR_POWER7:\n+    type = get_attr_type (insn);\n+\n+    switch (type)\n+      {\n+      case TYPE_ISYNC:\n+      case TYPE_SYNC:\n+      case TYPE_LOAD_L:\n+      case TYPE_STORE_C:\n+      case TYPE_LOAD_EXT_U:\n+      case TYPE_LOAD_EXT_UX:\n+      case TYPE_STORE_UX:\n+        return true;\n+      default:\n+        break;\n+    }\n+    break;\n   default:\n     break;\n   }\n@@ -22555,48 +23192,101 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total,\n   return false;\n }\n \n+/* Debug form of r6000_rtx_costs that is selected if -mdebug=cost.  */\n+\n+static bool\n+rs6000_debug_rtx_costs (rtx x, int code, int outer_code, int *total,\n+\t\t\tbool speed)\n+{\n+  bool ret = rs6000_rtx_costs (x, code, outer_code, total, speed);\n+\n+  fprintf (stderr,\n+\t   \"\\nrs6000_rtx_costs, return = %s, code = %s, outer_code = %s, \"\n+\t   \"total = %d, speed = %s, x:\\n\",\n+\t   ret ? \"complete\" : \"scan inner\",\n+\t   GET_RTX_NAME (code),\n+\t   GET_RTX_NAME (outer_code),\n+\t   *total,\n+\t   speed ? \"true\" : \"false\");\n+\n+  debug_rtx (x);\n+\n+  return ret;\n+}\n+\n+/* Debug form of ADDRESS_COST that is selected if -mdebug=cost.  */\n+\n+static int\n+rs6000_debug_address_cost (rtx x, bool speed)\n+{\n+  int ret = TARGET_ADDRESS_COST (x, speed);\n+\n+  fprintf (stderr, \"\\nrs6000_address_cost, return = %d, speed = %s, x:\\n\",\n+\t   ret, speed ? \"true\" : \"false\");\n+  debug_rtx (x);\n+\n+  return ret;\n+}\n+\n+\n /* A C expression returning the cost of moving data from a register of class\n    CLASS1 to one of CLASS2.  */\n \n int\n rs6000_register_move_cost (enum machine_mode mode,\n \t\t\t   enum reg_class from, enum reg_class to)\n {\n+  int ret;\n+\n   /*  Moves from/to GENERAL_REGS.  */\n   if (reg_classes_intersect_p (to, GENERAL_REGS)\n       || reg_classes_intersect_p (from, GENERAL_REGS))\n     {\n       if (! reg_classes_intersect_p (to, GENERAL_REGS))\n \tfrom = to;\n \n-      if (from == FLOAT_REGS || from == ALTIVEC_REGS)\n-\treturn (rs6000_memory_move_cost (mode, from, 0)\n-\t\t+ rs6000_memory_move_cost (mode, GENERAL_REGS, 0));\n+      if (from == FLOAT_REGS || from == ALTIVEC_REGS || from == VSX_REGS)\n+\tret = (rs6000_memory_move_cost (mode, from, 0)\n+\t       + rs6000_memory_move_cost (mode, GENERAL_REGS, 0));\n \n       /* It's more expensive to move CR_REGS than CR0_REGS because of the\n \t shift.  */\n       else if (from == CR_REGS)\n-\treturn 4;\n+\tret = 4;\n \n       /* Power6 has slower LR/CTR moves so make them more expensive than\n \t memory in order to bias spills to memory .*/\n       else if (rs6000_cpu == PROCESSOR_POWER6\n \t       && reg_classes_intersect_p (from, LINK_OR_CTR_REGS))\n-        return 6 * hard_regno_nregs[0][mode];\n+        ret = 6 * hard_regno_nregs[0][mode];\n \n       else\n \t/* A move will cost one instruction per GPR moved.  */\n-\treturn 2 * hard_regno_nregs[0][mode];\n+\tret = 2 * hard_regno_nregs[0][mode];\n     }\n \n+  /* If we have VSX, we can easily move between FPR or Altivec registers.  */\n+  else if (VECTOR_UNIT_VSX_P (mode)\n+\t   && reg_classes_intersect_p (to, VSX_REGS)\n+\t   && reg_classes_intersect_p (from, VSX_REGS))\n+    ret = 2 * hard_regno_nregs[32][mode];\n+\n   /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n-    return (mode == TFmode || mode == TDmode) ? 4 : 2;\n+    ret = (mode == TFmode || mode == TDmode) ? 4 : 2;\n \n   /* Everything else has to go through GENERAL_REGS.  */\n   else\n-    return (rs6000_register_move_cost (mode, GENERAL_REGS, to)\n-\t    + rs6000_register_move_cost (mode, from, GENERAL_REGS));\n+    ret = (rs6000_register_move_cost (mode, GENERAL_REGS, to)\n+\t   + rs6000_register_move_cost (mode, from, GENERAL_REGS));\n+\n+  if (TARGET_DEBUG_COST)\n+    fprintf (stderr,\n+\t     \"rs6000_register_move_cost:, ret=%d, mode=%s, from=%s, to=%s\\n\",\n+\t     ret, GET_MODE_NAME (mode), reg_class_names[from],\n+\t     reg_class_names[to]);\n+\n+  return ret;\n }\n \n /* A C expressions returning the cost of moving data of MODE from a register to\n@@ -22606,14 +23296,23 @@ int\n rs6000_memory_move_cost (enum machine_mode mode, enum reg_class rclass,\n \t\t\t int in ATTRIBUTE_UNUSED)\n {\n+  int ret;\n+\n   if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n-    return 4 * hard_regno_nregs[0][mode];\n+    ret = 4 * hard_regno_nregs[0][mode];\n   else if (reg_classes_intersect_p (rclass, FLOAT_REGS))\n-    return 4 * hard_regno_nregs[32][mode];\n+    ret = 4 * hard_regno_nregs[32][mode];\n   else if (reg_classes_intersect_p (rclass, ALTIVEC_REGS))\n-    return 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n+    ret = 4 * hard_regno_nregs[FIRST_ALTIVEC_REGNO][mode];\n   else\n-    return 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);\n+    ret = 4 + rs6000_register_move_cost (mode, rclass, GENERAL_REGS);\n+\n+  if (TARGET_DEBUG_COST)\n+    fprintf (stderr,\n+\t     \"rs6000_memory_move_cost: ret=%d, mode=%s, rclass=%s, in=%d\\n\",\n+\t     ret, GET_MODE_NAME (mode), reg_class_names[rclass], in);\n+\n+  return ret;\n }\n \n /* Returns a code for a target-specific builtin that implements\n@@ -22829,15 +23528,25 @@ rs6000_emit_swrsqrtsf (rtx dst, rtx src)\n   emit_label (XEXP (label, 0));\n }\n \n-/* Emit popcount intrinsic on TARGET_POPCNTB targets.  DST is the\n-   target, and SRC is the argument operand.  */\n+/* Emit popcount intrinsic on TARGET_POPCNTB (Power5) and TARGET_POPCNTD\n+   (Power7) targets.  DST is the target, and SRC is the argument operand.  */\n \n void\n rs6000_emit_popcount (rtx dst, rtx src)\n {\n   enum machine_mode mode = GET_MODE (dst);\n   rtx tmp1, tmp2;\n \n+  /* Use the PPC ISA 2.06 popcnt{w,d} instruction if we can.  */\n+  if (TARGET_POPCNTD)\n+    {\n+      if (mode == SImode)\n+\temit_insn (gen_popcntwsi2 (dst, src));\n+      else\n+\temit_insn (gen_popcntddi2 (dst, src));\n+      return;\n+    }\n+\n   tmp1 = gen_reg_rtx (mode);\n \n   if (mode == SImode)\n@@ -23254,7 +23963,7 @@ rs6000_vector_mode_supported_p (enum machine_mode mode)\n   if (TARGET_SPE && SPE_VECTOR_MODE (mode))\n     return true;\n \n-  else if (TARGET_ALTIVEC && ALTIVEC_VECTOR_MODE (mode))\n+  else if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (mode))\n     return true;\n \n   else"}, {"sha": "1c686c2bb17dfab02e6eec1a85e2be299bd1951c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=8beb65e326baa7a434227ab21c1062b09ee34bdb", "patch": "@@ -1194,6 +1194,7 @@ enum reg_class\n   GENERAL_REGS,\n   FLOAT_REGS,\n   ALTIVEC_REGS,\n+  VSX_REGS,\n   VRSAVE_REGS,\n   VSCR_REGS,\n   SPE_ACC_REGS,\n@@ -1224,6 +1225,7 @@ enum reg_class\n   \"GENERAL_REGS\",\t\t\t\t\t\t\t\\\n   \"FLOAT_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALTIVEC_REGS\",\t\t\t\t\t\t\t\\\n+  \"VSX_REGS\",\t\t\t\t\t\t\t\t\\\n   \"VRSAVE_REGS\",\t\t\t\t\t\t\t\\\n   \"VSCR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"SPE_ACC_REGS\",                                                       \\\n@@ -1253,6 +1255,7 @@ enum reg_class\n   { 0xffffffff, 0x00000000, 0x00000008, 0x00020000 }, /* GENERAL_REGS */     \\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000 }, /* FLOAT_REGS */       \\\n   { 0x00000000, 0x00000000, 0xffffe000, 0x00001fff }, /* ALTIVEC_REGS */     \\\n+  { 0x00000000, 0xffffffff, 0xffffe000, 0x00001fff }, /* VSX_REGS */\t     \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00002000 }, /* VRSAVE_REGS */\t     \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00004000 }, /* VSCR_REGS */\t     \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00008000 }, /* SPE_ACC_REGS */     \\\n@@ -1334,39 +1337,22 @@ extern enum reg_class rs6000_vector_reg_class[];\n  */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n-  ((CONSTANT_P (X)\t\t\t\t\t\\\n-    && reg_classes_intersect_p ((CLASS), FLOAT_REGS))\t\\\n-   ? NO_REGS \t\t\t\t\t\t\\\n-   : (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT \t\\\n-      && (CLASS) == NON_SPECIAL_REGS)\t\t\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\\\n-   : (CLASS))\n+  rs6000_preferred_reload_class_ptr (X, CLASS)\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n \n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  rs6000_secondary_reload_class (CLASS, MODE, IN)\n+  rs6000_secondary_reload_class_ptr (CLASS, MODE, IN)\n \n /* If we are copying between FP or AltiVec registers and anything\n    else, we need a memory location.  The exception is when we are\n    targeting ppc64 and the move to/from fpr to gpr instructions\n    are available.*/\n \n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\t\t\\\n- ((CLASS1) != (CLASS2) && (((CLASS1) == FLOAT_REGS\t\t\t\\\n-                            && (!TARGET_MFPGPR || !TARGET_POWERPC64\t\\\n-\t\t\t\t|| ((MODE != DFmode)\t\t\t\\\n-\t\t\t\t    && (MODE != DDmode)\t\t\t\\\n-\t\t\t\t    && (MODE != DImode))))\t\t\\\n-\t\t\t   || ((CLASS2) == FLOAT_REGS\t\t\t\\\n-                               && (!TARGET_MFPGPR || !TARGET_POWERPC64\t\\\n-\t\t\t\t   || ((MODE != DFmode)\t\t\t\\\n-\t\t\t\t       && (MODE != DDmode)\t\t\\\n-\t\t\t\t       && (MODE != DImode))))\t\t\\\n-\t\t\t   || (CLASS1) == ALTIVEC_REGS\t\t\t\\\n-\t\t\t   || (CLASS2) == ALTIVEC_REGS))\n+  rs6000_secondary_memory_needed_ptr (CLASS1, CLASS2, MODE)\n \n /* For cpus that cannot load/store SDmode values from the 64-bit\n    FP registers without using a full 64-bit load/store, we need\n@@ -1386,19 +1372,7 @@ extern enum reg_class rs6000_vector_reg_class[];\n /* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\t\\\n-  (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)\t\t\t\t\\\n-   ? ((GET_MODE_SIZE (FROM) < 8 || GET_MODE_SIZE (TO) < 8\t\t\\\n-       || TARGET_IEEEQUAD)\t\t\t\t\t\t\\\n-      && reg_classes_intersect_p (FLOAT_REGS, CLASS))\t\t\t\\\n-   : (((TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n-\t&& ((((TO) == DFmode) + ((FROM) == DFmode)) == 1\t\t\\\n-\t    || (((TO) == TFmode) + ((FROM) == TFmode)) == 1\t\t\\\n-\t    || (((TO) == DDmode) + ((FROM) == DDmode)) == 1\t\t\\\n-\t    || (((TO) == TDmode) + ((FROM) == TDmode)) == 1\t\t\\\n-\t    || (((TO) == DImode) + ((FROM) == DImode)) == 1))\t\t\\\n-       || (TARGET_SPE\t\t\t\t\t\t\t\\\n-\t   && (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1))\t\\\n-      && reg_classes_intersect_p (GENERAL_REGS, CLASS)))\n+  rs6000_cannot_change_mode_class_ptr (FROM, TO, CLASS)\n \n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1897,7 +1871,7 @@ typedef struct rs6000_args\n #define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n do {\t\t\t\t\t\t\t\t\t     \\\n   int win;\t\t\t\t\t\t\t\t     \\\n-  (X) = rs6000_legitimize_reload_address ((X), (MODE), (OPNUM),\t\t     \\\n+  (X) = rs6000_legitimize_reload_address_ptr ((X), (MODE), (OPNUM),\t     \\\n \t\t\t(int)(TYPE), (IND_LEVELS), &win);\t\t     \\\n   if ( win )\t\t\t\t\t\t\t\t     \\\n     goto WIN;\t\t\t\t\t\t\t\t     \\\n@@ -1908,7 +1882,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n-  if (rs6000_mode_dependent_address (ADDR))\t\t\t\\\n+  if (rs6000_mode_dependent_address_ptr (ADDR))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\\\n } while (0)\n \n@@ -3162,6 +3136,7 @@ enum rs6000_builtins\n   RS6000_BUILTIN_RECIP,\n   RS6000_BUILTIN_RECIPF,\n   RS6000_BUILTIN_RSQRTF,\n+  RS6000_BUILTIN_BSWAP_HI,\n \n   RS6000_BUILTIN_COUNT\n };"}, {"sha": "64de3dc5337d8b4654d5055ad0436ef0d49b50e7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 378, "deletions": 3, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8beb65e326baa7a434227ab21c1062b09ee34bdb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8beb65e326baa7a434227ab21c1062b09ee34bdb", "patch": "@@ -2264,15 +2264,102 @@\n     DONE;\n   })\n \n-(define_insn \"bswapsi2\"\n+;; Since the hardware zeros the upper part of the register, save generating the\n+;; AND immediate if we are converting to unsigned\n+(define_insn \"*bswaphi2_extenddi\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (bswap:HI (match_operand:HI 1 \"memory_operand\" \"Z\"))))]\n+  \"TARGET_POWERPC64\"\n+  \"lhbrx %0,%y1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"load\")])\n+\n+(define_insn \"*bswaphi2_extendsi\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (bswap:HI (match_operand:HI 1 \"memory_operand\" \"Z\"))))]\n+  \"TARGET_POWERPC\"\n+  \"lhbrx %0,%y1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"load\")])\n+\n+(define_expand \"bswaphi2\"\n+  [(parallel [(set (match_operand:HI 0 \"reg_or_mem_operand\" \"\")\n+\t\t   (bswap:HI\n+\t\t    (match_operand:HI 1 \"reg_or_mem_operand\" \"\")))\n+\t      (clobber (match_scratch:SI 2 \"\"))])]\n+  \"\"\n+{\n+  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n+    operands[1] = force_reg (HImode, operands[1]);\n+})\n+\n+(define_insn \"bswaphi2_internal\"\n+  [(set (match_operand:HI 0 \"reg_or_mem_operand\" \"=r,Z,&r\")\n+\t(bswap:HI\n+\t (match_operand:HI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n+   (clobber (match_scratch:SI 2 \"=X,X,&r\"))]\n+  \"TARGET_POWERPC\"\n+  \"@\n+   lhbrx %0,%y1\n+   sthbrx %1,%y0\n+   #\"\n+  [(set_attr \"length\" \"4,4,12\")\n+   (set_attr \"type\" \"load,store,*\")])\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"gpc_reg_operand\" \"\")\n+\t(bswap:HI (match_operand:HI 1 \"gpc_reg_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC && reload_completed\"\n+  [(set (match_dup 3)\n+\t(zero_extract:SI (match_dup 4)\n+\t\t\t (const_int 8)\n+\t\t\t (const_int 16)))\n+   (set (match_dup 2)\n+\t(and:SI (ashift:SI (match_dup 4)\n+\t\t\t   (const_int 8))\n+\t\t(const_int 65280)))\t\t;; 0xff00\n+   (set (match_dup 3)\n+\t(ior:SI (match_dup 3)\n+\t\t(match_dup 2)))]\n+  \"\n+{\n+  operands[3] = simplify_gen_subreg (SImode, operands[0], HImode, 0);\n+  operands[4] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n+}\")\n+\n+(define_insn \"*bswapsi2_extenddi\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t (bswap:SI (match_operand:SI 1 \"memory_operand\" \"Z\"))))]\n+  \"TARGET_POWERPC64\"\n+  \"lwbrx %0,%y1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"load\")])\n+\n+(define_expand \"bswapsi2\"\n+  [(set (match_operand:SI 0 \"reg_or_mem_operand\" \"\")\n+\t(bswap:SI\n+\t (match_operand:SI 1 \"reg_or_mem_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n+    operands[1] = force_reg (SImode, operands[1]);\n+})\n+\n+(define_insn \"*bswapsi2_internal\"\n   [(set (match_operand:SI 0 \"reg_or_mem_operand\" \"=r,Z,&r\")\n-\t(bswap:SI (match_operand:SI 1 \"reg_or_mem_operand\" \"Z,r,r\")))]\n+\t(bswap:SI\n+\t (match_operand:SI 1 \"reg_or_mem_operand\" \"Z,r,r\")))]\n   \"\"\n   \"@\n    {lbrx|lwbrx} %0,%y1\n    {stbrx|stwbrx} %1,%y0\n    #\"\n-  [(set_attr \"length\" \"4,4,12\")])\n+  [(set_attr \"length\" \"4,4,12\")\n+   (set_attr \"type\" \"load,store,*\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n@@ -2291,6 +2378,294 @@\n \t\t   (const_int 16)))]\n   \"\")\n \n+(define_expand \"bswapdi2\"\n+  [(parallel [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"\")\n+\t\t   (bswap:DI\n+\t\t    (match_operand:DI 1 \"reg_or_mem_operand\" \"\")))\n+\t      (clobber (match_scratch:DI 2 \"\"))\n+\t      (clobber (match_scratch:DI 3 \"\"))\n+\t      (clobber (match_scratch:DI 4 \"\"))])]\n+  \"\"\n+{\n+  if (!REG_P (operands[0]) && !REG_P (operands[1]))\n+    operands[1] = force_reg (DImode, operands[1]);\n+\n+  if (TARGET_32BIT)\n+    {\n+      /* 32-bit needs fewer scratch registers.  */\n+      emit_insn (gen_bswapdi2_32bit (operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+;; Power7/cell has ldbrx/stdbrx, so use it directly\n+(define_insn \"*bswapdi2_ldbrx\"\n+  [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=&r,Z,??&r\")\n+\t(bswap:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n+   (clobber (match_scratch:DI 2 \"=X,X,&r\"))\n+   (clobber (match_scratch:DI 3 \"=X,X,&r\"))\n+   (clobber (match_scratch:DI 4 \"=X,X,&r\"))]\n+  \"TARGET_POWERPC64 && TARGET_LDBRX\n+   && (REG_P (operands[0]) || REG_P (operands[1]))\"\n+  \"@\n+   ldbrx %0,%y1\n+   stdbrx %1,%y0\n+   #\"\n+  [(set_attr \"length\" \"4,4,36\")\n+   (set_attr \"type\" \"load,store,*\")])\n+\n+;; Non-power7/cell, fall back to use lwbrx/stwbrx\n+(define_insn \"*bswapdi2_64bit\"\n+  [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=&r,Z,??&r\")\n+\t(bswap:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n+   (clobber (match_scratch:DI 2 \"=&b,&b,&r\"))\n+   (clobber (match_scratch:DI 3 \"=&b,&r,&r\"))\n+   (clobber (match_scratch:DI 4 \"=&b,X,&r\"))]\n+  \"TARGET_POWERPC64 && !TARGET_LDBRX\n+   && (REG_P (operands[0]) || REG_P (operands[1]))\"\n+  \"#\"\n+  [(set_attr \"length\" \"16,12,36\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"indexed_or_indirect_operand\" \"\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 4 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && !TARGET_LDBRX && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest   = operands[0];\n+  rtx src    = operands[1];\n+  rtx op2    = operands[2];\n+  rtx op3    = operands[3];\n+  rtx op4    = operands[4];\n+  rtx op3_32 = simplify_gen_subreg (SImode, op3, DImode, 4);\n+  rtx op4_32 = simplify_gen_subreg (SImode, op4, DImode, 4);\n+  rtx addr1;\n+  rtx addr2;\n+  rtx word_high;\n+  rtx word_low;\n+\n+  addr1 = XEXP (src, 0);\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      emit_insn (gen_adddi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr1 = XEXP (addr1, 1);\n+    }\n+  else\n+    emit_move_insn (op2, GEN_INT (4));\n+\n+  addr2 = gen_rtx_PLUS (DImode, op2, addr1);\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      word_high = change_address (src, SImode, addr1);\n+      word_low  = change_address (src, SImode, addr2);\n+    }\n+  else\n+    {\n+      word_high = change_address (src, SImode, addr2);\n+      word_low  = change_address (src, SImode, addr1);\n+    }\n+\n+  emit_insn (gen_bswapsi2 (op3_32, word_low));\n+  emit_insn (gen_bswapsi2 (op4_32, word_high));\n+  emit_insn (gen_ashldi3 (dest, op3, GEN_INT (32)));\n+  emit_insn (gen_iordi3 (dest, dest, op4));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"indexed_or_indirect_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed && !TARGET_LDBRX\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest   = operands[0];\n+  rtx src    = operands[1];\n+  rtx op2    = operands[2];\n+  rtx op3    = operands[3];\n+  rtx src_si = simplify_gen_subreg (SImode, src, DImode, 4);\n+  rtx op3_si = simplify_gen_subreg (SImode, op3, DImode, 4);\n+  rtx addr1;\n+  rtx addr2;\n+  rtx word_high;\n+  rtx word_low;\n+\n+  addr1 = XEXP (dest, 0);\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      emit_insn (gen_adddi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr1 = XEXP (addr1, 1);\n+    }\n+  else\n+    emit_move_insn (op2, GEN_INT (4));\n+\n+  addr2 = gen_rtx_PLUS (DImode, op2, addr1);\n+\n+  emit_insn (gen_lshrdi3 (op3, src, GEN_INT (32)));\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      word_high = change_address (dest, SImode, addr1);\n+      word_low  = change_address (dest, SImode, addr2);\n+      emit_insn (gen_bswapsi2 (word_high, src_si));\n+      emit_insn (gen_bswapsi2 (word_low, op3_si));\n+    }\n+  else\n+    {\n+      word_high = change_address (dest, SImode, addr2);\n+      word_low  = change_address (dest, SImode, addr1);\n+      emit_insn (gen_bswapsi2 (word_low, src_si));\n+      emit_insn (gen_bswapsi2 (word_high, op3_si));\n+    }\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:DI 4 \"\" \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest    = operands[0];\n+  rtx src     = operands[1];\n+  rtx op2     = operands[2];\n+  rtx op3     = operands[3];\n+  rtx dest_si = simplify_gen_subreg (SImode, dest, DImode, 4);\n+  rtx src_si  = simplify_gen_subreg (SImode, src, DImode, 4);\n+  rtx op2_si  = simplify_gen_subreg (SImode, op2, DImode, 4);\n+  rtx op3_si  = simplify_gen_subreg (SImode, op3, DImode, 4);\n+\n+  emit_insn (gen_lshrdi3 (op2, src, GEN_INT (32)));\n+  emit_insn (gen_bswapsi2 (dest_si, src_si));\n+  emit_insn (gen_bswapsi2 (op3_si, op2_si));\n+  emit_insn (gen_ashldi3 (dest, dest, GEN_INT (32)));\n+  emit_insn (gen_iordi3 (dest, dest, op3));\n+}\")\n+\n+(define_insn \"bswapdi2_32bit\"\n+  [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=&r,Z,??&r\")\n+\t(bswap:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n+   (clobber (match_scratch:SI 2 \"=&b,&b,X\"))]\n+  \"TARGET_32BIT && (REG_P (operands[0]) || REG_P (operands[1]))\"\n+  \"#\"\n+  [(set_attr \"length\" \"16,12,36\")])\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"indexed_or_indirect_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest   = operands[0];\n+  rtx src    = operands[1];\n+  rtx op2    = operands[2];\n+  rtx dest_hi = simplify_gen_subreg (SImode, dest, DImode, 0);\n+  rtx dest_lo = simplify_gen_subreg (SImode, dest, DImode, 4);\n+  rtx addr1;\n+  rtx addr2;\n+  rtx word_high;\n+  rtx word_low;\n+\n+  addr1 = XEXP (src, 0);\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      emit_insn (gen_adddi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr1 = XEXP (addr1, 1);\n+    }\n+  else\n+    emit_move_insn (op2, GEN_INT (4));\n+\n+  addr2 = gen_rtx_PLUS (DImode, op2, addr1);\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      word_high = change_address (src, SImode, addr1);\n+      word_low  = change_address (src, SImode, addr2);\n+    }\n+  else\n+    {\n+      word_high = change_address (src, SImode, addr2);\n+      word_low  = change_address (src, SImode, addr1);\n+    }\n+\n+  emit_insn (gen_bswapsi2 (dest_hi, word_low));\n+  emit_insn (gen_bswapsi2 (dest_lo, word_high));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"indexed_or_indirect_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n+  \"TARGET_32BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest     = operands[0];\n+  rtx src      = operands[1];\n+  rtx op2      = operands[2];\n+  rtx src_high = simplify_gen_subreg (SImode, src, DImode, 0);\n+  rtx src_low  = simplify_gen_subreg (SImode, src, DImode, 4);\n+  rtx addr1;\n+  rtx addr2;\n+  rtx word_high;\n+  rtx word_low;\n+\n+  addr1 = XEXP (dest, 0);\n+  if (GET_CODE (addr1) == PLUS)\n+    {\n+      emit_insn (gen_addsi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr1 = XEXP (addr1, 1);\n+    }\n+  else\n+    emit_move_insn (op2, GEN_INT (4));\n+\n+  addr2 = gen_rtx_PLUS (SImode, op2, addr1);\n+\n+  if (BYTES_BIG_ENDIAN)\n+    {\n+      word_high = change_address (dest, SImode, addr1);\n+      word_low  = change_address (dest, SImode, addr2);\n+    }\n+  else\n+    {\n+      word_high = change_address (dest, SImode, addr2);\n+      word_low  = change_address (dest, SImode, addr1);\n+    }\n+\n+  emit_insn (gen_bswapsi2 (word_high, src_low));\n+  emit_insn (gen_bswapsi2 (word_low, src_high));\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"\" \"\"))]\n+  \"TARGET_32BIT && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx dest      = operands[0];\n+  rtx src       = operands[1];\n+  rtx src_high  = simplify_gen_subreg (SImode, src, DImode, 0);\n+  rtx src_low   = simplify_gen_subreg (SImode, src, DImode, 4);\n+  rtx dest_high = simplify_gen_subreg (SImode, dest, DImode, 0);\n+  rtx dest_low  = simplify_gen_subreg (SImode, dest, DImode, 4);\n+\n+  emit_insn (gen_bswapsi2 (dest_high, src_low));\n+  emit_insn (gen_bswapsi2 (dest_low, src_high));\n+}\")\n+\n (define_expand \"mulsi3\"\n   [(use (match_operand:SI 0 \"gpc_reg_operand\" \"\"))\n    (use (match_operand:SI 1 \"gpc_reg_operand\" \"\"))"}]}