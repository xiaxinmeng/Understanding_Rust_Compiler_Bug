{"sha": "b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "node_id": "C_kwDOANBUbNoAKGIzMWNlYzljMjJiOGRmYTQwYmFlZmQ0YzJkZDc3NDQ3N2U4ZTA0YzU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-11-12T15:06:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-14T01:18:20Z"}, "message": "Add __attribute__ ((tainted_args))\n\nThis patch adds a new __attribute__ ((tainted_args)) to the C/C++ frontends.\n\nIt can be used on function decls: the analyzer will treat as tainted\nall parameters to the function and all buffers pointed to by parameters\nto the function.  Adding this in one place to the Linux kernel's\n__SYSCALL_DEFINEx macro allows the analyzer to treat all syscalls as\nhaving tainted inputs.  This gives some coverage of system calls without\nneeding to \"teach\" the analyzer about \"__user\" - an example of the use\nof this can be seen in CVE-2011-2210, where given:\n\n SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n                 unsigned long, nbytes, int __user *, start, void __user *, arg)\n\nthe analyzer will treat the nbytes param as under attacker control, and\ncan complain accordingly:\n\ntaint-CVE-2011-2210-1.c: In function 'sys_osf_getsysinfo':\ntaint-CVE-2011-2210-1.c:69:21: warning: use of attacker-controlled value\n  'nbytes' as size without upper-bounds checking [CWE-129] [-Wanalyzer-tainted-size]\n   69 |                 if (copy_to_user(buffer, hwrpb, nbytes) != 0)\n      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAdditionally, the patch allows the attribute to be used on field decls:\nspecifically function pointers.  Any function used as an initializer\nfor such a field gets treated as being called with tainted arguments.\nAn example can be seen in CVE-2020-13143, where adding\n__attribute__((tainted_args)) to the \"store\" callback of\nconfigfs_attribute:\n\n  struct configfs_attribute {\n    /* [...snip...] */\n    ssize_t (*store)(struct config_item *, const char *, size_t)\n      __attribute__((tainted_args));\n    /* [...snip...] */\n  };\n\nallows the analyzer to see:\n\n CONFIGFS_ATTR(gadget_dev_desc_, UDC);\n\nand treat gadget_dev_desc_UDC_store as having tainted arguments, so that\nit complains:\n\ntaint-CVE-2020-13143-1.c: In function 'gadget_dev_desc_UDC_store':\ntaint-CVE-2020-13143-1.c:33:17: warning: use of attacker-controlled value\n  'len + 18446744073709551615' as offset without upper-bounds checking [CWE-823] [-Wanalyzer-tainted-offset]\n   33 |         if (name[len - 1] == '\\n')\n      |             ~~~~^~~~~~~~~\n\nAs before this currently still needs -fanalyzer-checker=taint (in\naddition to -fanalyzer).\n\ngcc/analyzer/ChangeLog:\n\t* engine.cc: Include \"stringpool.h\", \"attribs.h\", and\n\t\"tree-dfa.h\".\n\t(mark_params_as_tainted): New.\n\t(class tainted_args_function_custom_event): New.\n\t(class tainted_args_function_info): New.\n\t(exploded_graph::add_function_entry): Handle functions with\n\t\"tainted_args\" attribute.\n\t(class tainted_args_field_custom_event): New.\n\t(class tainted_args_callback_custom_event): New.\n\t(class tainted_args_call_info): New.\n\t(add_tainted_args_callback): New.\n\t(add_any_callbacks): New.\n\t(exploded_graph::build_initial_worklist): Likewise.\n\t(exploded_graph::build_initial_worklist): Find callbacks that are\n\treachable from global initializers, calling add_any_callbacks on\n\tthem.\n\ngcc/c-family/ChangeLog:\n\t* c-attribs.c (c_common_attribute_table): Add \"tainted_args\".\n\t(handle_tainted_args_attribute): New.\n\ngcc/ChangeLog:\n\t* doc/extend.texi (Function Attributes): Note that \"tainted_args\" can\n\tbe used on field decls.\n\t(Common Function Attributes): Add entry on \"tainted_args\" attribute.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/attr-tainted_args-1.c: New test.\n\t* gcc.dg/analyzer/attr-tainted_args-misuses.c: New test.\n\t* gcc.dg/analyzer/taint-CVE-2011-2210-1.c: New test.\n\t* gcc.dg/analyzer/taint-CVE-2020-13143-1.c: New test.\n\t* gcc.dg/analyzer/taint-CVE-2020-13143-2.c: New test.\n\t* gcc.dg/analyzer/taint-CVE-2020-13143.h: New test.\n\t* gcc.dg/analyzer/taint-alloc-3.c: New test.\n\t* gcc.dg/analyzer/taint-alloc-4.c: New test.\n\t* gcc.dg/analyzer/test-uaccess.h: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "4675de9d964069a4cf3d2b6c630e440bb8e022ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4675de9d964069a4cf3d2b6c630e440bb8e022ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad3f0d0806d64ae8ceddfbde1560d4829085202b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad3f0d0806d64ae8ceddfbde1560d4829085202b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad3f0d0806d64ae8ceddfbde1560d4829085202b"}], "stats": {"total": 794, "additions": 791, "deletions": 3}, "files": [{"sha": "243235e4cd4d4b48501708d1cf596bcad3f73a55", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 318, "deletions": 2, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -68,6 +68,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"target.h\"\n #include <memory>\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"tree-dfa.h\"\n \n /* For an overview, see gcc/doc/analyzer.texi.  */\n \n@@ -2287,6 +2290,116 @@ exploded_graph::~exploded_graph ()\n     delete (*iter).second;\n }\n \n+/* Subroutine for use when implementing __attribute__((tainted_args))\n+   on functions and on function pointer fields in structs.\n+\n+   Called on STATE representing a call to FNDECL.\n+   Mark all params of FNDECL in STATE as \"tainted\".  Mark the value of all\n+   regions pointed to by params of FNDECL as \"tainted\".\n+\n+   Return true if successful; return false if the \"taint\" state machine\n+   was not found.  */\n+\n+static bool\n+mark_params_as_tainted (program_state *state, tree fndecl,\n+\t\t\tconst extrinsic_state &ext_state)\n+{\n+  unsigned taint_sm_idx;\n+  if (!ext_state.get_sm_idx_by_name (\"taint\", &taint_sm_idx))\n+    return false;\n+  sm_state_map *smap = state->m_checker_states[taint_sm_idx];\n+\n+  const state_machine &sm = ext_state.get_sm (taint_sm_idx);\n+  state_machine::state_t tainted = sm.get_state_by_name (\"tainted\");\n+\n+  region_model_manager *mgr = ext_state.get_model_manager ();\n+\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  gcc_assert (fun);\n+\n+  for (tree iter_parm = DECL_ARGUMENTS (fndecl); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm))\n+    {\n+      tree param = iter_parm;\n+      if (tree parm_default_ssa = ssa_default_def (fun, iter_parm))\n+\tparam = parm_default_ssa;\n+      const region *param_reg = state->m_region_model->get_lvalue (param, NULL);\n+      const svalue *init_sval = mgr->get_or_create_initial_value (param_reg);\n+      smap->set_state (state->m_region_model, init_sval,\n+\t\t       tainted, NULL /*origin_new_sval*/, ext_state);\n+      if (POINTER_TYPE_P (TREE_TYPE (param)))\n+\t{\n+\t  const region *pointee_reg = mgr->get_symbolic_region (init_sval);\n+\t  /* Mark \"*param\" as tainted.  */\n+\t  const svalue *init_pointee_sval\n+\t    = mgr->get_or_create_initial_value (pointee_reg);\n+\t  smap->set_state (state->m_region_model, init_pointee_sval,\n+\t\t\t   tainted, NULL /*origin_new_sval*/, ext_state);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Custom event for use by tainted_args_function_info when a function\n+   has been marked with __attribute__((tainted_args)).  */\n+\n+class tainted_args_function_custom_event : public custom_event\n+{\n+public:\n+  tainted_args_function_custom_event (location_t loc, tree fndecl, int depth)\n+  : custom_event (loc, fndecl, depth),\n+    m_fndecl (fndecl)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+  {\n+    return make_label_text\n+      (can_colorize,\n+       \"function %qE marked with %<__attribute__((tainted_args))%>\",\n+       m_fndecl);\n+  }\n+\n+private:\n+  tree m_fndecl;\n+};\n+\n+/* Custom exploded_edge info for top-level calls to a function\n+   marked with __attribute__((tainted_args)).  */\n+\n+class tainted_args_function_info : public custom_edge_info\n+{\n+public:\n+  tainted_args_function_info (tree fndecl)\n+  : m_fndecl (fndecl)\n+  {}\n+\n+  void print (pretty_printer *pp) const FINAL OVERRIDE\n+  {\n+    pp_string (pp, \"call to tainted_args function\");\n+  };\n+\n+  bool update_model (region_model *,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *) const FINAL OVERRIDE\n+  {\n+    /* No-op.  */\n+    return true;\n+  }\n+\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &) const FINAL OVERRIDE\n+  {\n+    emission_path->add_event\n+      (new tainted_args_function_custom_event\n+       (DECL_SOURCE_LOCATION (m_fndecl), m_fndecl, 0));\n+  }\n+\n+private:\n+  tree m_fndecl;\n+};\n+\n /* Ensure that there is an exploded_node representing an external call to\n    FUN, adding it to the worklist if creating it.\n \n@@ -2313,14 +2426,25 @@ exploded_graph::add_function_entry (function *fun)\n   program_state state (m_ext_state);\n   state.push_frame (m_ext_state, fun);\n \n+  custom_edge_info *edge_info = NULL;\n+\n+  if (lookup_attribute (\"tainted_args\", DECL_ATTRIBUTES (fun->decl)))\n+    {\n+      if (mark_params_as_tainted (&state, fun->decl, m_ext_state))\n+\tedge_info = new tainted_args_function_info (fun->decl);\n+    }\n+\n   if (!state.m_valid)\n     return NULL;\n \n   exploded_node *enode = get_or_create_node (point, state, NULL);\n   if (!enode)\n-    return NULL;\n+    {\n+      delete edge_info;\n+      return NULL;\n+    }\n \n-  add_edge (m_origin, enode, NULL);\n+  add_edge (m_origin, enode, NULL, edge_info);\n \n   m_functions_with_enodes.add (fun);\n \n@@ -2634,6 +2758,187 @@ toplevel_function_p (function *fun, logger *logger)\n   return true;\n }\n \n+/* Custom event for use by tainted_call_info when a callback field has been\n+   marked with __attribute__((tainted_args)), for labelling the field.  */\n+\n+class tainted_args_field_custom_event : public custom_event\n+{\n+public:\n+  tainted_args_field_custom_event (tree field)\n+  : custom_event (DECL_SOURCE_LOCATION (field), NULL_TREE, 0),\n+    m_field (field)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+  {\n+    return make_label_text (can_colorize,\n+\t\t\t    \"field %qE of %qT\"\n+\t\t\t    \" is marked with %<__attribute__((tainted_args))%>\",\n+\t\t\t    m_field, DECL_CONTEXT (m_field));\n+  }\n+\n+private:\n+  tree m_field;\n+};\n+\n+/* Custom event for use by tainted_call_info when a callback field has been\n+   marked with __attribute__((tainted_args)), for labelling the function used\n+   in that callback.  */\n+\n+class tainted_args_callback_custom_event : public custom_event\n+{\n+public:\n+  tainted_args_callback_custom_event (location_t loc, tree fndecl, int depth,\n+\t\t\t\t tree field)\n+  : custom_event (loc, fndecl, depth),\n+    m_field (field)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE\n+  {\n+    return make_label_text (can_colorize,\n+\t\t\t    \"function %qE used as initializer for field %qE\"\n+\t\t\t    \" marked with %<__attribute__((tainted_args))%>\",\n+\t\t\t    m_fndecl, m_field);\n+  }\n+\n+private:\n+  tree m_field;\n+};\n+\n+/* Custom edge info for use when adding a function used by a callback field\n+   marked with '__attribute__((tainted_args))'.   */\n+\n+class tainted_args_call_info : public custom_edge_info\n+{\n+public:\n+  tainted_args_call_info (tree field, tree fndecl, location_t loc)\n+  : m_field (field), m_fndecl (fndecl), m_loc (loc)\n+  {}\n+\n+  void print (pretty_printer *pp) const FINAL OVERRIDE\n+  {\n+    pp_string (pp, \"call to tainted field\");\n+  };\n+\n+  bool update_model (region_model *,\n+\t\t     const exploded_edge *,\n+\t\t     region_model_context *) const FINAL OVERRIDE\n+  {\n+    /* No-op.  */\n+    return true;\n+  }\n+\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &) const FINAL OVERRIDE\n+  {\n+    /* Show the field in the struct declaration, e.g.\n+       \"(1) field 'store' is marked with '__attribute__((tainted_args))'\"  */\n+    emission_path->add_event\n+      (new tainted_args_field_custom_event (m_field));\n+\n+    /* Show the callback in the initializer\n+       e.g.\n+       \"(2) function 'gadget_dev_desc_UDC_store' used as initializer\n+       for field 'store' marked with '__attribute__((tainted_args))'\".  */\n+    emission_path->add_event\n+      (new tainted_args_callback_custom_event (m_loc, m_fndecl, 0, m_field));\n+  }\n+\n+private:\n+  tree m_field;\n+  tree m_fndecl;\n+  location_t m_loc;\n+};\n+\n+/* Given an initializer at LOC for FIELD marked with\n+   '__attribute__((tainted_args))' initialized with FNDECL, add an\n+   entrypoint to FNDECL to EG (and to its worklist) where the params to\n+   FNDECL are marked as tainted.  */\n+\n+static void\n+add_tainted_args_callback (exploded_graph *eg, tree field, tree fndecl,\n+\t\t\t   location_t loc)\n+{\n+  logger *logger = eg->get_logger ();\n+\n+  LOG_SCOPE (logger);\n+\n+  if (!gimple_has_body_p (fndecl))\n+    return;\n+\n+  const extrinsic_state &ext_state = eg->get_ext_state ();\n+\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  gcc_assert (fun);\n+\n+  program_point point\n+    = program_point::from_function_entry (eg->get_supergraph (), fun);\n+  program_state state (ext_state);\n+  state.push_frame (ext_state, fun);\n+\n+  if (!mark_params_as_tainted (&state, fndecl, ext_state))\n+    return;\n+\n+  if (!state.m_valid)\n+    return;\n+\n+  exploded_node *enode = eg->get_or_create_node (point, state, NULL);\n+  if (logger)\n+    {\n+      if (enode)\n+\tlogger->log (\"created EN %i for tainted_args %qE entrypoint\",\n+\t\t     enode->m_index, fndecl);\n+      else\n+\t{\n+\t  logger->log (\"did not create enode for tainted_args %qE entrypoint\",\n+\t\t       fndecl);\n+\t  return;\n+\t}\n+    }\n+\n+  tainted_args_call_info *info\n+    = new tainted_args_call_info (field, fndecl, loc);\n+  eg->add_edge (eg->get_origin (), enode, NULL, info);\n+}\n+\n+/* Callback for walk_tree for finding callbacks within initializers;\n+   ensure that any callback initializer where the corresponding field is\n+   marked with '__attribute__((tainted_args))' is treated as an entrypoint\n+   to the analysis, special-casing that the inputs to the callback are\n+   untrustworthy.  */\n+\n+static tree\n+add_any_callbacks (tree *tp, int *, void *data)\n+{\n+  exploded_graph *eg = (exploded_graph *)data;\n+  if (TREE_CODE (*tp) == CONSTRUCTOR)\n+    {\n+      /* Find fields with the \"tainted_args\" attribute.\n+\t walk_tree only walks the values, not the index values;\n+\t look at the index values.  */\n+      unsigned HOST_WIDE_INT idx;\n+      constructor_elt *ce;\n+\n+      for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (*tp), idx, &ce);\n+\t   idx++)\n+\tif (ce->index && TREE_CODE (ce->index) == FIELD_DECL)\n+\t  if (lookup_attribute (\"tainted_args\", DECL_ATTRIBUTES (ce->index)))\n+\t    {\n+\t      tree value = ce->value;\n+\t      if (TREE_CODE (value) == ADDR_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (value, 0)) == FUNCTION_DECL)\n+\t\tadd_tainted_args_callback (eg, ce->index,\n+\t\t\t\t\t   TREE_OPERAND (value, 0),\n+\t\t\t\t\t   EXPR_LOCATION (value));\n+\t    }\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Add initial nodes to EG, with entrypoints for externally-callable\n    functions.  */\n \n@@ -2659,6 +2964,17 @@ exploded_graph::build_initial_worklist ()\n \t  logger->log (\"did not create enode for %qE entrypoint\", fun->decl);\n       }\n   }\n+\n+  /* Find callbacks that are reachable from global initializers.  */\n+  varpool_node *vpnode;\n+  FOR_EACH_VARIABLE (vpnode)\n+    {\n+      tree decl = vpnode->decl;\n+      tree init = DECL_INITIAL (decl);\n+      if (!init)\n+\tcontinue;\n+      walk_tree (&init, add_any_callbacks, this, NULL);\n+    }\n }\n \n /* The main loop of the analysis."}, {"sha": "4fb5dbd14091bdf550921bd2b090784d665dd129", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -117,6 +117,7 @@ static tree handle_no_profile_instrument_function_attribute (tree *, tree,\n \t\t\t\t\t\t\t     tree, int, bool *);\n static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n static tree handle_dealloc_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_tainted_args_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_limit_stack_attribute (tree *, tree, tree, int,\n \t\t\t\t\t     bool *);\n@@ -548,6 +549,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_objc_nullability_attribute, NULL },\n   { \"*dealloc\",                1, 2, true, false, false, false,\n \t\t\t      handle_dealloc_attribute, NULL },\n+  { \"tainted_args\",\t      0, 0, true,  false, false, false,\n+\t\t\t      handle_tainted_args_attribute, NULL },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -5774,6 +5777,39 @@ handle_objc_nullability_attribute (tree *node, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"tainted_args\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_tainted_args_attribute (tree *node, tree name, tree, int,\n+\t\t\t       bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL\n+      && TREE_CODE (*node) != FIELD_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored; valid only \"\n+\t       \"for functions and function pointer fields\",\n+\t       name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (*node) == FIELD_DECL\n+      && !(TREE_CODE (TREE_TYPE (*node)) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (*node))) == FUNCTION_TYPE))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored;\"\n+\t       \" field must be a function pointer\",\n+\t       name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  *no_add_attrs = false; /* OK */\n+\n+  return NULL_TREE;\n+}\n+\n /* Attempt to partially validate a single attribute ATTR as if\n    it were to be applied to an entity OPER.  */\n "}, {"sha": "20a5944256aebd5c052c8a8282a6985e2e4bdd40", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -2512,7 +2512,8 @@ variable declarations (@pxref{Variable Attributes}),\n labels (@pxref{Label Attributes}),\n enumerators (@pxref{Enumerator Attributes}),\n statements (@pxref{Statement Attributes}),\n-and types (@pxref{Type Attributes}).\n+types (@pxref{Type Attributes}),\n+and on field declarations (for @code{tainted_args}).\n \n There is some overlap between the purposes of attributes and pragmas\n (@pxref{Pragmas,,Pragmas Accepted by GCC}).  It has been\n@@ -4009,6 +4010,26 @@ addition to creating a symbol version (as if\n @code{\"@var{name2}@@@var{nodename}\"} was used) the version will be also used\n to resolve @var{name2} by the linker.\n \n+@item tainted_args\n+@cindex @code{tainted_args} function attribute\n+The @code{tainted_args} attribute is used to specify that a function is called\n+in a way that requires sanitization of its arguments, such as a system\n+call in an operating system kernel.  Such a function can be considered part\n+of the ``attack surface'' of the program.  The attribute can be used both\n+on function declarations, and on field declarations containing function\n+pointers.  In the latter case, any function used as an initializer of\n+such a callback field will be treated as being called with tainted\n+arguments.\n+\n+The analyzer will pay particular attention to such functions when both\n+@option{-fanalyzer} and @option{-fanalyzer-checker=taint} are supplied,\n+potentially issuing warnings guarded by\n+@option{-Wanalyzer-tainted-allocation-size},\n+@option{-Wanalyzer-tainted-array-index},\n+@option{-Wanalyzer-tainted-divisor},\n+@option{-Wanalyzer-tainted-offset},\n+and @option{-Wanalyzer-tainted-size}.\n+\n @item target_clones (@var{options})\n @cindex @code{target_clones} function attribute\n The @code{target_clones} attribute is used to specify that a function"}, {"sha": "e1d87c9cece1b5325876b85be592a8a59c2b1a78", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-tainted_args-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-1.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,88 @@\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+struct arg_buf\n+{\n+  int i;\n+  int j;\n+};\n+\n+/* Example of marking a function as tainted.  */\n+\n+void __attribute__((tainted_args))\n+test_1 (int i, void *p, char *q)\n+{\n+  /* There should be a single enode,\n+     for the \"tainted\" entry to the function.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  __analyzer_dump_state (\"taint\", i); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", p); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", q); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", *q); /* { dg-warning \"state: 'tainted'\" } */\n+\n+  struct arg_buf *args = p;\n+  __analyzer_dump_state (\"taint\", args->i); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", args->j); /* { dg-warning \"state: 'tainted'\" } */  \n+}\n+\n+/* Example of marking a callback field as tainted.  */\n+\n+struct s2\n+{\n+  void (*cb) (int, void *, char *)\n+    __attribute__((tainted_args));\n+};\n+\n+/* Function not marked as tainted.  */\n+\n+void\n+test_2a (int i, void *p, char *q)\n+{\n+  /* There should be a single enode,\n+     for the normal entry to the function.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  __analyzer_dump_state (\"taint\", i); /* { dg-warning \"state: 'start'\" } */\n+  __analyzer_dump_state (\"taint\", p); /* { dg-warning \"state: 'start'\" } */\n+  __analyzer_dump_state (\"taint\", q); /* { dg-warning \"state: 'start'\" } */\n+\n+  struct arg_buf *args = p;\n+  __analyzer_dump_state (\"taint\", args->i); /* { dg-warning \"state: 'start'\" } */\n+  __analyzer_dump_state (\"taint\", args->j); /* { dg-warning \"state: 'start'\" } */  \n+}\n+\n+/* Function referenced via t2b.cb, marked as \"tainted\".  */\n+\n+void\n+test_2b (int i, void *p, char *q)\n+{\n+  /* There should be two enodes\n+     for the direct call, and the \"tainted\" entry to the function.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+}\n+\n+/* Callback used via t2c.cb, marked as \"tainted\".  */\n+void\n+__analyzer_test_2c (int i, void *p, char *q)\n+{\n+  /* There should be a single enode,\n+     for the \"tainted\" entry to the function.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  __analyzer_dump_state (\"taint\", i); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", p); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", q); /* { dg-warning \"state: 'tainted'\" } */\n+}\n+\n+struct s2 t2b =\n+{\n+  .cb = test_2b\n+};\n+\n+struct s2 t2c =\n+{\n+  .cb = __analyzer_test_2c\n+};"}, {"sha": "4b0dc915059e000cf98725d388384a64625770c3", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-tainted_args-misuses.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-misuses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-misuses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-tainted_args-misuses.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,6 @@\n+int not_a_fn __attribute__ ((tainted_args)); /* { dg-warning \"'tainted_args' attribute ignored; valid only for functions and function pointer fields\" } */\n+\n+struct s\n+{\n+  int f __attribute__ ((tainted_args)); /* { dg-warning \"'tainted_args' attribute ignored; field must be a function pointer\" } */\n+};"}, {"sha": "b44be99356802bb7a44491dd413fb7a6dc3e74d1", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-CVE-2011-2210-1.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2011-2210-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2011-2210-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2011-2210-1.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,93 @@\n+/* \"The osf_getsysinfo function in arch/alpha/kernel/osf_sys.c in the\n+   Linux kernel before 2.6.39.4 on the Alpha platform does not properly\n+   restrict the data size for GSI_GET_HWRPB operations, which allows\n+   local users to obtain sensitive information from kernel memory via\n+   a crafted call.\"\n+\n+   Fixed in 3d0475119d8722798db5e88f26493f6547a4bb5b on linux-2.6.39.y\n+   in linux-stable.  */\n+\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include \"test-uaccess.h\"\n+\n+/* Adapted from include/linux/linkage.h.  */\n+\n+#define asmlinkage\n+\n+/* Adapted from include/linux/syscalls.h.  */\n+\n+#define __SC_DECL1(t1, a1)\tt1 a1\n+#define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)\n+#define __SC_DECL3(t3, a3, ...) t3 a3, __SC_DECL2(__VA_ARGS__)\n+#define __SC_DECL4(t4, a4, ...) t4 a4, __SC_DECL3(__VA_ARGS__)\n+#define __SC_DECL5(t5, a5, ...) t5 a5, __SC_DECL4(__VA_ARGS__)\n+#define __SC_DECL6(t6, a6, ...) t6 a6, __SC_DECL5(__VA_ARGS__)\n+\n+#define SYSCALL_DEFINEx(x, sname, ...)\t\t\t\t\\\n+\t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)\n+\n+#define SYSCALL_DEFINE(name) asmlinkage long sys_##name\n+#define __SYSCALL_DEFINEx(x, name, ...)\t\t\t\t\t\\\n+\tasmlinkage __attribute__((tainted_args)) \\\n+\tlong sys##name(__SC_DECL##x(__VA_ARGS__))\n+\n+#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)\n+\n+/* Adapted from arch/alpha/include/asm/hwrpb.h.  */\n+\n+struct hwrpb_struct {\n+\tunsigned long phys_addr;\t/* check: physical address of the hwrpb */\n+\tunsigned long id;\t\t/* check: \"HWRPB\\0\\0\\0\" */\n+\tunsigned long revision;\n+\tunsigned long size;\t\t/* size of hwrpb */\n+\t/* [...snip...] */\n+};\n+\n+extern struct hwrpb_struct *hwrpb;\n+\n+/* Adapted from arch/alpha/kernel/osf_sys.c.  */\n+\n+SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n+\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n+{\n+\t/* [...snip...] */\n+\n+\t__analyzer_dump_state (\"taint\", nbytes);  /* { dg-warning \"tainted\" } */\n+\n+\t/* TODO: should have an event explaining why \"nbytes\" is treated as\n+\t   attacker-controlled.  */\n+\n+\t/* case GSI_GET_HWRPB: */\n+\t\tif (nbytes < sizeof(*hwrpb))\n+\t\t\treturn -1;\n+\n+\t\t__analyzer_dump_state (\"taint\", nbytes);  /* { dg-warning \"has_lb\" } */\n+\n+\t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0) /* { dg-warning \"use of attacker-controlled value 'nbytes' as size without upper-bounds checking\" } */\n+\t\t\treturn -2;\n+\n+\t\treturn 1;\n+\n+\t/* [...snip...] */\n+}\n+\n+/* With the fix for the sense of the size comparison.  */\n+\n+SYSCALL_DEFINE5(osf_getsysinfo_fixed, unsigned long, op, void __user *, buffer,\n+\t\tunsigned long, nbytes, int __user *, start, void __user *, arg)\n+{\n+\t/* [...snip...] */\n+\n+\t/* case GSI_GET_HWRPB: */\n+\t\tif (nbytes > sizeof(*hwrpb))\n+\t\t\treturn -1;\n+\t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0) /* { dg-bogus \"attacker-controlled\" } */\n+\t\t\treturn -2;\n+\n+\t\treturn 1;\n+\n+\t/* [...snip...] */\n+}"}, {"sha": "328c5799145fe95c268165b52ae1d90d04abca68", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-CVE-2020-13143-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-1.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,38 @@\n+/* See notes in this header.  */\n+#include \"taint-CVE-2020-13143.h\"\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+struct configfs_attribute {\n+\t/* [...snip...] */\n+\tssize_t (*store)(struct config_item *, const char *, size_t) /* { dg-message \"\\\\(1\\\\) field 'store' of 'struct configfs_attribute' is marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */\n+\t\t__attribute__((tainted_args)); /* (this is added).  */\n+};\n+static inline struct gadget_info *to_gadget_info(struct config_item *item)\n+{\n+\t return container_of(to_config_group(item), struct gadget_info, group);\n+}\n+\n+static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\n+\t\tconst char *page, size_t len)\n+{\n+\tstruct gadget_info *gi = to_gadget_info(item);\n+\tchar *name;\n+\tint ret;\n+\n+#if 0\n+\t/* FIXME: this is the fix.  */\n+\tif (strlen(page) < len)\n+\t\treturn -EOVERFLOW;\n+#endif\n+\n+\tname = kstrdup(page, GFP_KERNEL);\n+\tif (!name)\n+\t\treturn -ENOMEM;\n+\tif (name[len - 1] == '\\n') /* { dg-warning \"use of attacker-controlled value 'len \\[^\\n\\r\\]+' as offset without upper-bounds checking\" } */\n+\t\tname[len - 1] = '\\0'; /* { dg-warning \"use of attacker-controlled value 'len \\[^\\n\\r\\]+' as offset without upper-bounds checking\" } */\n+\t/* [...snip...] */\t\t\t\t\\\n+}\n+\n+CONFIGFS_ATTR(gadget_dev_desc_, UDC); /* { dg-message \"\\\\(2\\\\) function 'gadget_dev_desc_UDC_store' used as initializer for field 'store' marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */"}, {"sha": "c74a460b01ef4bf48a0169689f2302fb73c0a273", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-CVE-2020-13143-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143-2.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,32 @@\n+/* See notes in this header.  */\n+#include \"taint-CVE-2020-13143.h\"\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+struct configfs_attribute {\n+\t/* [...snip...] */\n+\tssize_t (*store)(struct config_item *, const char *, size_t) /* { dg-message \"\\\\(1\\\\) field 'store' of 'struct configfs_attribute' is marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */\n+\t\t__attribute__((tainted_args)); /* (this is added).  */\n+};\n+\n+/* Highly simplified version.  */\n+\n+static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\n+\t\tconst char *page, size_t len)\n+{\n+\t/* TODO: ought to have state_change_event talking about where the tainted value comes from.  */\n+\n+\tchar *name;\n+\t/* [...snip...] */\n+\n+\tname = kstrdup(page, GFP_KERNEL);\n+\tif (!name)\n+\t\treturn -ENOMEM;\n+\tif (name[len - 1] == '\\n') /* { dg-warning \"use of attacker-controlled value 'len \\[^\\n\\r\\]+' as offset without upper-bounds checking\" } */\n+\t\tname[len - 1] = '\\0';  /* { dg-warning \"use of attacker-controlled value 'len \\[^\\n\\r\\]+' as offset without upper-bounds checking\" } */\n+\t/* [...snip...] */\n+\treturn 0;\n+}\n+\n+CONFIGFS_ATTR(gadget_dev_desc_, UDC); /* { dg-message \"\\\\(2\\\\) function 'gadget_dev_desc_UDC_store' used as initializer for field 'store' marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */"}, {"sha": "0ba023539af06aae5e3055d7fe552c7583e08241", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-CVE-2020-13143.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-CVE-2020-13143.h?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,91 @@\n+/* Shared header for the various taint-CVE-2020-13143.h tests.\n+   \n+   \"gadget_dev_desc_UDC_store in drivers/usb/gadget/configfs.c in the\n+   Linux kernel 3.16 through 5.6.13 relies on kstrdup without considering\n+   the possibility of an internal '\\0' value, which allows attackers to\n+   trigger an out-of-bounds read, aka CID-15753588bcd4.\"\n+\n+   Fixed by 15753588bcd4bbffae1cca33c8ced5722477fe1f on linux-5.7.y\n+   in linux-stable.  */\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include <stddef.h>\n+\n+/* Adapted from include/uapi/asm-generic/posix_types.h  */\n+\n+typedef unsigned int     __kernel_size_t;\n+typedef int              __kernel_ssize_t;\n+\n+/* Adapted from include/linux/types.h  */\n+\n+//typedef __kernel_size_t\t\tsize_t;\n+typedef __kernel_ssize_t\tssize_t;\n+\n+/* Adapted from include/linux/kernel.h  */\n+\n+#define container_of(ptr, type, member) ({\t\t\t\t\\\n+\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n+\t/* [...snip...] */\t\t\t\t\t\t\\\n+\t((type *)(__mptr - offsetof(type, member))); })\n+\n+/* Adapted from include/linux/configfs.h  */\n+\n+struct config_item {\n+\t/* [...snip...] */\n+};\n+\n+struct config_group {\n+\tstruct config_item\t\tcg_item;\n+\t/* [...snip...] */\n+};\n+\n+static inline struct config_group *to_config_group(struct config_item *item)\n+{\n+\treturn item ? container_of(item,struct config_group,cg_item) : NULL;\n+}\n+\n+#define CONFIGFS_ATTR(_pfx, _name)\t\t\t\t\\\n+static struct configfs_attribute _pfx##attr_##_name = {\t\\\n+\t/* [...snip...] */\t\t\t\t\\\n+\t.store\t\t= _pfx##_name##_store,\t\t\\\n+}\n+\n+/* Adapted from include/linux/compiler.h  */\n+\n+#define __force\n+\n+/* Adapted from include/asm-generic/errno-base.h  */\n+\n+#define\tENOMEM\t\t12\t/* Out of memory */\n+\n+/* Adapted from include/linux/types.h  */\n+\n+#define __bitwise__\n+typedef unsigned __bitwise__ gfp_t;\n+\n+/* Adapted from include/linux/gfp.h  */\n+\n+#define ___GFP_WAIT\t\t0x10u\n+#define ___GFP_IO\t\t0x40u\n+#define ___GFP_FS\t\t0x80u\n+#define __GFP_WAIT\t((__force gfp_t)___GFP_WAIT)\n+#define __GFP_IO\t((__force gfp_t)___GFP_IO)\n+#define __GFP_FS\t((__force gfp_t)___GFP_FS)\n+#define GFP_KERNEL  (__GFP_WAIT | __GFP_IO | __GFP_FS)\n+\n+/* Adapted from include/linux/compiler_attributes.h  */\n+\n+#define __malloc                        __attribute__((__malloc__))\n+\n+/* Adapted from include/linux/string.h  */\n+\n+extern char *kstrdup(const char *s, gfp_t gfp) __malloc;\n+\n+/* Adapted from drivers/usb/gadget/configfs.c  */\n+\n+struct gadget_info {\n+\tstruct config_group group;\n+\t/* [...snip...] */\t\t\t\t\\\n+};"}, {"sha": "80d8f0b824793204bb49217b02da59f241904c53", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-alloc-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-3.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,21 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+/* malloc with tainted size from a syscall.  */\n+\n+void *p;\n+\n+void __attribute__((tainted_args))\n+test_1 (size_t sz) /* { dg-message \"\\\\(1\\\\) function 'test_1' marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */\n+{\n+  /* TODO: should have a message saying why \"sz\" is tainted, e.g.\n+     \"treating 'sz' as attacker-controlled because 'test_1' is marked with '__attribute__((tainted_args))'\"  */\n+\n+  p = malloc (sz); /* { dg-warning \"use of attacker-controlled value 'sz' as allocation size without upper-bounds checking\" \"warning\" } */\n+  /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value 'sz' as allocation size without upper-bounds checking\" \"final event\" { target *-*-* } .-1 } */\n+}"}, {"sha": "bd47097b1d5f9a2142edd22c8420726659d7d987", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-alloc-4.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-alloc-4.c?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,31 @@\n+// TODO: remove need for this option:\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+#include \"analyzer-decls.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+/* malloc with tainted size from a syscall.  */\n+\n+struct arg_buf\n+{\n+  size_t sz;\n+};\n+\n+void *p;\n+\n+void __attribute__((tainted_args))\n+test_1 (void *data) /* { dg-message \"\\\\(1\\\\) function 'test_1' marked with '__attribute__\\\\(\\\\(tainted_args\\\\)\\\\)'\" } */\n+{\n+  /* we should treat pointed-to-structs as tainted.  */\n+  __analyzer_dump_state (\"taint\", data); /* { dg-warning \"state: 'tainted'\" } */\n+  \n+  struct arg_buf *args = data;\n+\n+  __analyzer_dump_state (\"taint\", args); /* { dg-warning \"state: 'tainted'\" } */\n+  __analyzer_dump_state (\"taint\", args->sz); /* { dg-warning \"state: 'tainted'\" } */\n+  \n+  p = malloc (args->sz); /* { dg-warning \"use of attacker-controlled value '\\\\*args.sz' as allocation size without upper-bounds checking\" \"warning\" } */\n+  /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of attacker-controlled value '\\\\*args.sz' as allocation size without upper-bounds checking\" \"final event\" { target *-*-* } .-1 } */\n+}"}, {"sha": "70c9d6309ef6ce53535050d6a5ba4a0fb871d726", "filename": "gcc/testsuite/gcc.dg/analyzer/test-uaccess.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-uaccess.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b31cec9c22b8dfa40baefd4c2dd774477e8e04c5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-uaccess.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-uaccess.h?ref=b31cec9c22b8dfa40baefd4c2dd774477e8e04c5", "patch": "@@ -0,0 +1,15 @@\n+/* Shared header for testcases for copy_from_user/copy_to_user.  */\n+\n+/* Adapted from include/linux/compiler.h  */\n+\n+#define __user\n+\n+/* Adapted from include/asm-generic/uaccess.h  */\n+\n+extern int copy_from_user(void *to, const void __user *from, long n)\n+  __attribute__((access (write_only, 1, 3),\n+\t\t access (read_only, 2, 3)));\n+\n+extern long copy_to_user(void __user *to, const void *from, unsigned long n)\n+  __attribute__((access (write_only, 1, 3),\n+\t\t access (read_only, 2, 3)));"}]}