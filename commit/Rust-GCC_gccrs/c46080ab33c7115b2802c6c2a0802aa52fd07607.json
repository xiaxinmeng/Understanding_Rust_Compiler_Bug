{"sha": "c46080ab33c7115b2802c6c2a0802aa52fd07607", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ2MDgwYWIzM2M3MTE1YjI4MDJjNmMyYTA4MDJhYTUyZmQwNzYwNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-28T12:33:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-28T12:33:03Z"}, "message": "tree.h: Add missing checks on some macros; make formatting more consistent.\n\n\t* tree.h: Add missing checks on some macros; make formatting more\n\tconsistent.\n\nFrom-SVN: r47416", "tree": {"sha": "1fd0d0fd23bd5e871be3371a53bf7888822c2137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd0d0fd23bd5e871be3371a53bf7888822c2137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c46080ab33c7115b2802c6c2a0802aa52fd07607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46080ab33c7115b2802c6c2a0802aa52fd07607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46080ab33c7115b2802c6c2a0802aa52fd07607", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46080ab33c7115b2802c6c2a0802aa52fd07607/comments", "author": null, "committer": null, "parents": [{"sha": "3874585e2e5521585d1733f177c25a5a0e224142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3874585e2e5521585d1733f177c25a5a0e224142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3874585e2e5521585d1733f177c25a5a0e224142"}], "stats": {"total": 210, "additions": 120, "deletions": 90}, "files": [{"sha": "34bddc33c8690d31fd3bff932733716d426276b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46080ab33c7115b2802c6c2a0802aa52fd07607/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46080ab33c7115b2802c6c2a0802aa52fd07607/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c46080ab33c7115b2802c6c2a0802aa52fd07607", "patch": "@@ -1,5 +1,8 @@\n Wed Nov 28 08:21:47 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree.h: Add missing checks on some macros; make formatting more\n+\tconsistent.\n+\n \t* stor-layout.c (put_pending_size): Look for SAVE_EXPR if not at top\n \tlevel; only add to pending_sizes if find it.\n "}, {"sha": "9182c31927b68d5aa7c37659ebcba3e22ebb72b2", "filename": "gcc/tree.h", "status": "modified", "additions": 117, "deletions": 90, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46080ab33c7115b2802c6c2a0802aa52fd07607/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46080ab33c7115b2802c6c2a0802aa52fd07607/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c46080ab33c7115b2802c6c2a0802aa52fd07607", "patch": "@@ -444,7 +444,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n #define MAYBE_BOUNDED_POINTER_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == POINTER_TYPE || BOUNDED_POINTER_TYPE_P (TYPE))\n \n-/* Nonzero if TYPE represents a reference type, either bounded or unbounded.  */\n+/* Nonzero if TYPE represents a reference type, either bounded or\n+   unbounded.  */\n \n #define MAYBE_BOUNDED_REFERENCE_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == REFERENCE_TYPE || BOUNDED_REFERENCE_TYPE_P (TYPE))\n@@ -457,11 +458,11 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n \n /* Nonzero if this type is complete or is cv void.  */\n #define COMPLETE_OR_VOID_TYPE_P(NODE) \\\n-    (COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))\n+  (COMPLETE_TYPE_P (NODE) || VOID_TYPE_P (NODE))\n \n /* Nonzero if this type is complete or is an array with unspecified bound.  */\n #define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n-    (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : NODE))\n+  (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : NODE))\n \n /* Nonzero if TYPE represents a type.  */\n \n@@ -506,7 +507,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n \n /* In an IDENTIFIER_NODE, this means that assemble_name was called with\n    this string as an argument.  */\n-#define TREE_SYMBOL_REFERENCED(NODE) ((NODE)->common.static_flag)\n+#define TREE_SYMBOL_REFERENCED(NODE) \\\n+\t(IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n \n /* In an INTEGER_CST, REAL_CST, of COMPLEX_CST, this means there was an\n    overflow in folding, and no warning has been issued for this subexpression.\n@@ -532,7 +534,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    base class is via a `protected' declaration, which preserves\n    protected fields from the base class as protected.\n    OVERLOADED.  */\n-#define TREE_VIA_PROTECTED(NODE) ((NODE)->common.protected_flag)\n+#define TREE_VIA_PROTECTED(NODE) \\\n+  (TREE_LIST_CHECK (NODE)->common.protected_flag)\n \n /* In any expression, nonzero means it has side effects or reevaluation\n    of the whole expression could produce a different value.\n@@ -561,8 +564,7 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n #define TREE_READONLY(NODE) ((NODE)->common.readonly_flag)\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n-#define TREE_READONLY_DECL_P(NODE) \\\n-  (TREE_READONLY (NODE) && DECL_P (NODE))\n+#define TREE_READONLY_DECL_P(NODE) (TREE_READONLY (NODE) && DECL_P (NODE))\n \n /* Value of expression is constant.\n    Always appears in all ..._CST nodes.\n@@ -575,7 +577,8 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    The same bit is used in functions as DECL_BUILT_IN_NONANSI.  */\n #define TREE_UNSIGNED(NODE) ((NODE)->common.unsigned_flag)\n \n-#define TYPE_TRAP_SIGNED(NODE) (flag_trapv && ! TREE_UNSIGNED (NODE))\n+#define TYPE_TRAP_SIGNED(NODE) \\\n+  (flag_trapv && ! TREE_UNSIGNED (TYPE_CHECK (NODE)))\n \n /* Nonzero in a VAR_DECL means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n@@ -664,17 +667,17 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n #define TREE_INT_CST_HIGH(NODE) (TREE_INT_CST (NODE).high)\n \n #define INT_CST_LT(A, B)  \\\n-(TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\t\t\\\n- || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\t\\\n-     && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n+  (TREE_INT_CST_HIGH (A) < TREE_INT_CST_HIGH (B)\t\t\t\\\n+   || (TREE_INT_CST_HIGH (A) == TREE_INT_CST_HIGH (B)\t\t\\\n+       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n \n #define INT_CST_LT_UNSIGNED(A, B)  \\\n-(((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n-  < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n- || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n-      == (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B)) \\\n-     && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n-\n+  (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n+    < (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B))\t\\\n+   || (((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (A)\t\\\n+        == (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (B)) \\\n+       && TREE_INT_CST_LOW (A) < TREE_INT_CST_LOW (B)))\n+ \n struct tree_int_cst\n {\n   struct tree_common common;\n@@ -695,10 +698,10 @@ struct tree_int_cst\n \n #define TREE_CST_RTL(NODE) (CST_OR_CONSTRUCTOR_CHECK (NODE)->real_cst.rtl)\n \n-/* In a REAL_CST node.  */\n-/* We can represent a real value as either a `double' or a string.\n-   Strings don't allow for any optimization, but they do allow\n-   for cross-compilation.  */\n+/* In a REAL_CST node.\n+\n+   We can represent a real value as either a `double' or an array of\n+   longs.  */\n \n #define TREE_REAL_CST(NODE) (REAL_CST_CHECK (NODE)->real_cst.real_cst)\n \n@@ -743,17 +746,16 @@ struct tree_complex\n /* Define fields and accessors for some special-purpose tree nodes.  */\n \n #define IDENTIFIER_LENGTH(NODE) \\\n-\t(IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n+  (IDENTIFIER_NODE_CHECK (NODE)->identifier.id.len)\n #define IDENTIFIER_POINTER(NODE) \\\n-\t((char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n+  ((char *) IDENTIFIER_NODE_CHECK (NODE)->identifier.id.str)\n \n /* Translate a hash table identifier pointer to a tree_identifier\n    pointer, and vice versa.  */\n \n #define HT_IDENT_TO_GCC_IDENT(NODE) \\\n-\t((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n-#define GCC_IDENT_TO_HT_IDENT(NODE) \\\n-\t(&((struct tree_identifier *) (NODE))->id)\n+  ((tree) ((char *) (NODE) - sizeof (struct tree_common)))\n+#define GCC_IDENT_TO_HT_IDENT(NODE) (&((struct tree_identifier *) (NODE))->id)\n \n struct tree_identifier\n {\n@@ -775,7 +777,8 @@ struct tree_list\n /* In a TREE_VEC node.  */\n #define TREE_VEC_LENGTH(NODE) (TREE_VEC_CHECK (NODE)->vec.length)\n #define TREE_VEC_ELT(NODE,I) (TREE_VEC_CHECK (NODE)->vec.a[I])\n-#define TREE_VEC_END(NODE) ((void) TREE_VEC_CHECK (NODE),&((NODE)->vec.a[(NODE)->vec.length]))\n+#define TREE_VEC_END(NODE) \\\n+  ((void) TREE_VEC_CHECK (NODE), &((NODE)->vec.a[(NODE)->vec.length]))\n \n struct tree_vec\n {\n@@ -787,49 +790,58 @@ struct tree_vec\n /* Define fields and accessors for some nodes that represent expressions.  */\n \n /* In a SAVE_EXPR node.  */\n-#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND(NODE, 1)\n-#define SAVE_EXPR_RTL(NODE) (*(rtx *) &EXPR_CHECK (NODE)->exp.operands[2])\n-#define SAVE_EXPR_NOPLACEHOLDER(NODE) TREE_UNSIGNED (NODE)\n+#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND(SAVE_EXPR_CHECK (NODE), 1)\n+#define SAVE_EXPR_RTL(NODE) (*(rtx *) &SAVE_EXPR_CHECK (NODE)->exp.operands[2])\n+#define SAVE_EXPR_NOPLACEHOLDER(NODE) TREE_UNSIGNED (SAVE_EXPR_CHECK (NODE))\n /* Nonzero if the SAVE_EXPRs value should be kept, even if it occurs\n    both in normal code and in a handler.  (Normally, in a handler, all\n    SAVE_EXPRs are unsaved, meaning that there values are\n    recalculated.)  */\n-#define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (NODE)\n+#define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (SAVE_EXPR_CHECK (NODE))\n \n /* In a RTL_EXPR node.  */\n-#define RTL_EXPR_SEQUENCE(NODE) (*(rtx *) &EXPR_CHECK (NODE)->exp.operands[0])\n-#define RTL_EXPR_RTL(NODE) (*(rtx *) &EXPR_CHECK (NODE)->exp.operands[1])\n+#define RTL_EXPR_SEQUENCE(NODE) \\\n+  (*(rtx *) &RTL_EXPR_CHECK (NODE)->exp.operands[0])\n+#define RTL_EXPR_RTL(NODE) (*(rtx *) &RTL_EXPR_CHECK (NODE)->exp.operands[1])\n \n /* In a WITH_CLEANUP_EXPR node.  */\n #define WITH_CLEANUP_EXPR_RTL(NODE) \\\n-  (*(rtx *) &EXPR_CHECK (NODE)->exp.operands[2])\n+  (*(rtx *) &WITH_CLEANUP_EXPR_CHECK (NODE)->exp.operands[2])\n \n /* In a CONSTRUCTOR node.  */\n-#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND (NODE, 1)\n+#define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND (CONSTRUCTOR_CHECK (NODE), 1)\n \n /* In ordinary expression nodes.  */\n #define TREE_OPERAND(NODE, I) (EXPR_CHECK (NODE)->exp.operands[I])\n #define TREE_COMPLEXITY(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n \n /* In a LABELED_BLOCK_EXPR node.  */\n-#define LABELED_BLOCK_LABEL(NODE) TREE_OPERAND (NODE, 0)\n-#define LABELED_BLOCK_BODY(NODE) TREE_OPERAND (NODE, 1)\n+#define LABELED_BLOCK_LABEL(NODE) \\\n+  TREE_OPERAND (LABELED_BLOCK_EXPR_CHECK (NODE), 0)\n+#define LABELED_BLOCK_BODY(NODE) \\\n+  TREE_OPERAND (LABELED_BLOCK_EXPR_CHECK (NODE), 1)\n \n /* In a EXIT_BLOCK_EXPR node.  */\n-#define EXIT_BLOCK_LABELED_BLOCK(NODE) TREE_OPERAND (NODE, 0)\n-#define EXIT_BLOCK_RETURN(NODE) TREE_OPERAND (NODE, 1)\n+#define EXIT_BLOCK_LABELED_BLOCK(NODE) \\\n+  TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 0)\n+#define EXIT_BLOCK_RETURN(NODE) TREE_OPERAND (EXIT_BLOCK_EXPR_CHECK (NODE), 1)\n \n /* In a LOOP_EXPR node.  */\n-#define LOOP_EXPR_BODY(NODE) TREE_OPERAND (NODE, 0)\n+#define LOOP_EXPR_BODY(NODE) TREE_OPERAND (LOOP_EXPR_CHECK (NODE), 0)\n \n /* In a EXPR_WITH_FILE_LOCATION node.  */\n-#define EXPR_WFL_NODE(NODE) TREE_OPERAND((NODE), 0)\n+#define EXPR_WFL_NODE(NODE) \\\n+  TREE_OPERAND (EXPR_WITH_FILE_LOCATION_CHECK (NODE), 0)\n+#define EXPR_WFL_FILENAME_NODE(NODE) \\\n+  TREE_OPERAND(EXPR_WITH_FILE_LOCATION_CHECK (NODE), 1)\n #define EXPR_WFL_FILENAME(NODE) \\\n-  (IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE ((NODE))))\n-#define EXPR_WFL_FILENAME_NODE(NODE) TREE_OPERAND((NODE), 1)\n-#define EXPR_WFL_LINENO(NODE) (EXPR_CHECK (NODE)->exp.complexity >> 12)\n-#define EXPR_WFL_COLNO(NODE) (EXPR_CHECK (NODE)->exp.complexity & 0xfff)\n-#define EXPR_WFL_LINECOL(NODE) (EXPR_CHECK (NODE)->exp.complexity)\n+  IDENTIFIER_POINTER (EXPR_WFL_FILENAME_NODE ((NODE)))\n+#define EXPR_WFL_LINENO(NODE) \\\n+  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->exp.complexity >> 12)\n+#define EXPR_WFL_COLNO(NODE) \\\n+  (EXPR_WITH_FILE_LOCATION_CHECK (NODE)->exp.complexity & 0xfff)\n+#define EXPR_WFL_LINECOL(NODE) \\\n+  EXPR_WITH_FILE_LOCATION_CHECK (NODE)->exp.complexity\n #define EXPR_WFL_SET_LINECOL(NODE, LINE, COL) \\\n   (EXPR_WFL_LINECOL(NODE) = ((LINE) << 12) | ((COL) & 0xfff))\n #define EXPR_WFL_EMIT_LINE_NOTE(NODE) ((NODE)->common.public_flag)\n@@ -853,7 +865,8 @@ struct tree_exp\n \n /* Nonzero means that this block is prepared to handle exceptions\n    listed in the BLOCK_VARS slot.  */\n-#define BLOCK_HANDLER_BLOCK(NODE) (BLOCK_CHECK (NODE)->block.handler_block_flag)\n+#define BLOCK_HANDLER_BLOCK(NODE) \\\n+  (BLOCK_CHECK (NODE)->block.handler_block_flag)\n \n /* An index number for this block.  These values are not guaranteed to\n    be unique across functions -- whether or not they are depends on\n@@ -882,10 +895,8 @@ struct tree_exp\n    be null.  The list of fragments will be chained through \n    BLOCK_FRAGMENT_CHAIN from the origin.  */\n \n-#define BLOCK_FRAGMENT_ORIGIN(NODE) \\\n-  (BLOCK_CHECK (NODE)->block.fragment_origin)\n-#define BLOCK_FRAGMENT_CHAIN(NODE) \\\n-  (BLOCK_CHECK (NODE)->block.fragment_chain)\n+#define BLOCK_FRAGMENT_ORIGIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_origin)\n+#define BLOCK_FRAGMENT_CHAIN(NODE) (BLOCK_CHECK (NODE)->block.fragment_chain)\n \n struct tree_block\n {\n@@ -972,8 +983,7 @@ struct tree_block\n \n /* Nonzero iff the typed-based alias set for this type has been\n    calculated.  */\n-#define TYPE_ALIAS_SET_KNOWN_P(NODE) \\\n-  (TYPE_CHECK (NODE)->type.alias_set != -1)\n+#define TYPE_ALIAS_SET_KNOWN_P(NODE) (TYPE_CHECK (NODE)->type.alias_set != -1)\n \n /* A TREE_LIST of IDENTIFIER nodes of the attributes that apply\n    to this type.  */\n@@ -988,8 +998,7 @@ struct tree_block\n #define TYPE_USER_ALIGN(NODE) (TYPE_CHECK (NODE)->type.user_align)\n \n /* The alignment for NODE, in bytes.  */\n-#define TYPE_ALIGN_UNIT(NODE) \\\n-  (TYPE_ALIGN (NODE) / BITS_PER_UNIT)\n+#define TYPE_ALIGN_UNIT(NODE) (TYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n /* If your language allows you to declare types, and you want debug info\n    for them, then you need to generate corresponding TYPE_DECL nodes.\n@@ -998,7 +1007,7 @@ struct tree_block\n    to point back at the TYPE_DECL node.  This allows the debug routines\n    to know that the two nodes represent the same type, so that we only\n    get one debug info record for them.  */\n-#define TYPE_STUB_DECL(NODE) (TREE_CHAIN (NODE))\n+#define TYPE_STUB_DECL(NODE) TREE_CHAIN (NODE)\n \n /* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type\n    has BLKmode only because it lacks the alignment requirement for\n@@ -1079,11 +1088,14 @@ struct tree_block\n #define TYPE_STRING_FLAG(NODE) (TYPE_CHECK (NODE)->type.string_flag)\n \n /* If non-NULL, this is an upper bound of the size (in bytes) of an\n-   object of the given ARRAY_TYPE.  This allows temporaries to be allocated.  */\n-#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) TYPE_MAX_VALUE (ARRAY_TYPE)\n+   object of the given ARRAY_TYPE.  This allows temporaries to be\n+   allocated.  */\n+#define TYPE_ARRAY_MAX_SIZE(ARRAY_TYPE) \\\n+  TYPE_MAX_VALUE (ARRAY_TYPE_CHECK (ARRAY_TYPE))\n \n /* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n-#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) (GET_MODE_NUNITS (TYPE_CHECK (VECTOR_TYPE)->type.mode))\n+#define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n+  GET_MODE_NUNITS (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.mode)\n \n   /* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n@@ -1269,7 +1281,8 @@ struct tree_type\n \n /* Accessor macro to get to the Nth basetype of this basetype.  */\n #define BINFO_BASETYPE(NODE,N) TREE_VEC_ELT (BINFO_BASETYPES (NODE), (N))\n-#define TYPE_BINFO_BASETYPE(NODE,N) BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n+#define TYPE_BINFO_BASETYPE(NODE,N) \\\n+  BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (TYPE_BINFO (NODE)), (N)))\n \n /* For a BINFO record describing a virtual base class, i.e., one where\n    TREE_VIA_VIRTUAL is set, this field assists in locating the virtual\n@@ -1278,12 +1291,12 @@ struct tree_type\n    pointer to the virtual base; under the new ABI this field is\n    instead a INTEGER_CST giving an offset into the vtable where the\n    offset to the virtual base can be found.  */\n-#define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT ((NODE), 5)\n+#define BINFO_VPTR_FIELD(NODE) TREE_VEC_ELT (NODE, 5)\n \n /* The size of a base class subobject of this type.  Not all frontends\n    currently allocate the space for these fields.  */\n-#define BINFO_SIZE(NODE) TREE_VEC_ELT ((NODE), 6)\n-#define BINFO_SIZE_UNIT(NODE) TREE_VEC_ELT ((NODE), 7)\n+#define BINFO_SIZE(NODE) TREE_VEC_ELT (NODE, 6)\n+#define BINFO_SIZE_UNIT(NODE) TREE_VEC_ELT (NODE, 7)\n #define TYPE_BINFO_SIZE(NODE) BINFO_SIZE (TYPE_BINFO (NODE))\n #define TYPE_BINFO_SIZE_UNIT(NODE) BINFO_SIZE_UNIT (TYPE_BINFO (NODE))\n \n@@ -1304,9 +1317,11 @@ struct tree_type\n \n /* Nonzero if DECL represents a decl.  */\n #define DECL_P(DECL)\t(TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd')\n+\n /* This is the name of the object as written by the user.\n    It is an IDENTIFIER_NODE.  */\n #define DECL_NAME(NODE) (DECL_CHECK (NODE)->decl.name)\n+\n /* The name of the object as the assembler will see it (but before any\n    translations made by ASM_OUTPUT_LABELREF).  Often this is the same\n    as DECL_NAME.  It is an IDENTIFIER_NODE.  */\n@@ -1315,23 +1330,26 @@ struct tree_type\n     ? (void) 0\t\t\t\t\t\\\n     : (*lang_set_decl_assembler_name) (NODE)),\t\\\n    DECL_CHECK (NODE)->decl.assembler_name)\n-/* Returns non-zero if the DECL_ASSEMBLER_NAME for NODE has been \n-   set.  If zero, the NODE might still have a DECL_ASSEMBLER_NAME --\n-   it just hasn't been set yet.  */\n+\n+/* Returns non-zero if the DECL_ASSEMBLER_NAME for NODE has been set.  If zero,\n+   the NODE might still have a DECL_ASSEMBLER_NAME -- it just hasn't been set\n+   yet.  */\n #define DECL_ASSEMBLER_NAME_SET_P(NODE) \\\n   (DECL_CHECK (NODE)->decl.assembler_name != NULL_TREE)\n+\n /* Set the DECL_ASSEMBLER_NAME for NODE to NAME.  */\n #define SET_DECL_ASSEMBLER_NAME(NODE, NAME) \\\n   (DECL_CHECK (NODE)->decl.assembler_name = (NAME))\n-/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if\n-   DECL1's DECL_ASSEMBLER_NAME has not yet been set, using this macro\n-   will not cause the DECL_ASSEMBLER_NAME of either DECL to be set.\n-   In other words, the semantics of using this macro, are different\n-   than saying:\n+\n+/* Copy the DECL_ASSEMBLER_NAME from DECL1 to DECL2.  Note that if DECL1's\n+   DECL_ASSEMBLER_NAME has not yet been set, using this macro will not cause\n+   the DECL_ASSEMBLER_NAME of either DECL to be set.  In other words, the\n+   semantics of using this macro, are different than saying:\n      \n      SET_DECL_ASSEMBLER_NAME(DECL2, DECL_ASSEMBLER_NAME (DECL1))\n \n    which will try to set the DECL_ASSEMBLER_NAME for DECL1.  */\n+\n #define COPY_DECL_ASSEMBLER_NAME(DECL1, DECL2)\t\t\t\t\\\n   (DECL_ASSEMBLER_NAME_SET_P (DECL1)\t\t\t\t\t\\\n    ? (void) SET_DECL_ASSEMBLER_NAME (DECL2, \t\t\t\t\\\n@@ -1341,6 +1359,7 @@ struct tree_type\n /* Records the section name in a section attribute.  Used to pass\n    the name from decl_attributes to make_function_rtl and make_decl_rtl.  */\n #define DECL_SECTION_NAME(NODE) (DECL_CHECK (NODE)->decl.section_name)\n+\n /*  For FIELD_DECLs, this is the\n     RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field is\n     a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n@@ -1361,9 +1380,9 @@ struct tree_type\n    if so, the type that was originally specified for it.\n    TREE_TYPE may have been modified (in finish_struct).  */\n #define DECL_BIT_FIELD_TYPE(NODE) (FIELD_DECL_CHECK (NODE)->decl.result)\n-/* In FUNCTION_DECL, a chain of ..._DECL nodes.  */\n-/* VAR_DECL and PARM_DECL reserve the arguments slot\n-   for language-specific uses.  */\n+/* In FUNCTION_DECL, a chain of ..._DECL nodes.\n+   VAR_DECL and PARM_DECL reserve the arguments slot for language-specific\n+   uses.  */\n #define DECL_ARGUMENTS(NODE) (DECL_CHECK (NODE)->decl.arguments)\n /* This field is used to reference anything in decl.result and is meant only\n    for use by the garbage collector.  */\n@@ -1430,26 +1449,27 @@ struct tree_type\n    ? (NODE)->decl.rtl\t\t\t\t\t\\\n    : (make_decl_rtl (NODE, NULL), (NODE)->decl.rtl))\n /* Set the DECL_RTL for NODE to RTL.  */\n-#define SET_DECL_RTL(NODE, RTL) \\\n-  (DECL_CHECK (NODE)->decl.rtl = (RTL))\n+#define SET_DECL_RTL(NODE, RTL) (DECL_CHECK (NODE)->decl.rtl = (RTL))\n /* Returns non-zero if the DECL_RTL for NODE has already been set.  */\n-#define DECL_RTL_SET_P(NODE) \\\n-  (DECL_CHECK (NODE)->decl.rtl != NULL)\n+#define DECL_RTL_SET_P(NODE)  (DECL_CHECK (NODE)->decl.rtl != NULL)\n /* Copy the RTL from NODE1 to NODE2.  If the RTL was not set for\n    NODE1, it will not be set for NODE2; this is a lazy copy.  */\n #define COPY_DECL_RTL(NODE1, NODE2) \\\n   (DECL_CHECK (NODE2)->decl.rtl = DECL_CHECK (NODE1)->decl.rtl)\n /* The DECL_RTL for NODE, if it is set, or NULL, if it is not set.  */\n-#define DECL_RTL_IF_SET(NODE) \\\n-  (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n+#define DECL_RTL_IF_SET(NODE) (DECL_RTL_SET_P (NODE) ? DECL_RTL (NODE) : NULL)\n+\n /* Holds an INSN_LIST of all of the live ranges in which the variable\n    has been moved to a possibly different register.  */\n #define DECL_LIVE_RANGE_RTL(NODE) (DECL_CHECK (NODE)->decl.live_range_rtl)\n+\n /* For PARM_DECL, holds an RTL for the stack slot or register\n    where the data was actually passed.  */\n #define DECL_INCOMING_RTL(NODE) (PARM_DECL_CHECK (NODE)->decl.u2.r)\n+\n /* For FUNCTION_DECL, if it is inline, holds the saved insn chain.  */\n #define DECL_SAVED_INSNS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u2.f)\n+\n /* For FUNCTION_DECL, if it is built-in,\n    this identifies which built-in operation it is.  */\n #define DECL_FUNCTION_CODE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.u1.f)\n@@ -1462,6 +1482,7 @@ struct tree_type\n    to an INTEGER_CST node which is suitable for use as an index\n    into the virtual function table.  */\n #define DECL_VINDEX(NODE) (DECL_CHECK (NODE)->decl.vindex)\n+\n /* For FIELD_DECLS, DECL_FCONTEXT is the *first* baseclass in\n    which this FIELD_DECL is defined.  This information is needed when\n    writing debugging information about vfield and vbase decls for C++.  */\n@@ -1503,7 +1524,8 @@ struct tree_type\n \n /* Nonzero if a _DECL means that no warnings should be generated just\n    because this decl is unused.  */\n-#define DECL_IN_SYSTEM_HEADER(NODE) (DECL_CHECK (NODE)->decl.in_system_header_flag)\n+#define DECL_IN_SYSTEM_HEADER(NODE) \\\n+  (DECL_CHECK (NODE)->decl.in_system_header_flag)\n \n /* Nonzero for a given ..._DECL node means that this node should be\n    put in .common, if possible.  If a DECL_INITIAL is given, and it\n@@ -1529,19 +1551,22 @@ struct tree_type\n    Instead it will generate cross reference ('x') of names. \n    This uses the same flag as DECL_EXTERNAL.  */\n #define TYPE_DECL_SUPPRESS_DEBUG(NODE) \\\n-(TYPE_DECL_CHECK (NODE)->decl.external_flag)\n+  (TYPE_DECL_CHECK (NODE)->decl.external_flag)\n \n /* In VAR_DECL and PARM_DECL nodes, nonzero means declared `register'.  */\n #define DECL_REGISTER(NODE) (DECL_CHECK (NODE)->decl.regdecl_flag)\n+\n /* In LABEL_DECL nodes, nonzero means that an error message about\n    jumping into such a binding contour has been printed for this label.  */\n #define DECL_ERROR_ISSUED(NODE) (LABEL_DECL_CHECK (NODE)->decl.regdecl_flag)\n+\n /* In a FIELD_DECL, indicates this field should be bit-packed.  */\n #define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->decl.regdecl_flag)\n+\n /* In a FUNCTION_DECL with a non-zero DECL_CONTEXT, indicates that a\n    static chain is not needed.  */\n #define DECL_NO_STATIC_CHAIN(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.regdecl_flag)\n+  (FUNCTION_DECL_CHECK (NODE)->decl.regdecl_flag)\n \n /* Nonzero in a ..._DECL means this variable is ref'd from a nested function.\n    For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.\n@@ -1571,7 +1596,7 @@ struct tree_type\n    that is not specified by ansi C and that users are supposed to be allowed\n    to redefine for any purpose whatever.  */\n #define DECL_BUILT_IN_NONANSI(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->common.unsigned_flag)\n+  (FUNCTION_DECL_CHECK (NODE)->common.unsigned_flag)\n \n /* Nonzero in a FUNCTION_DECL means this function should be treated\n    as if it were a malloc, meaning it returns a pointer that is\n@@ -1585,6 +1610,7 @@ struct tree_type\n /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n    specially.  */\n #define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n+\n /* In a LABEL_DECL, nonzero means label was defined inside a binding\n    contour that restored a stack level and which is now exited.  */\n #define DECL_TOO_LATE(NODE) (LABEL_DECL_CHECK (NODE)->decl.bit_field_flag)\n@@ -1597,9 +1623,10 @@ struct tree_type\n \n /* In a FUNCTION_DECL, nonzero means a built in function.  */\n #define DECL_BUILT_IN(NODE) (DECL_BUILT_IN_CLASS (NODE) != NOT_BUILT_IN)\n+\n /* For a builtin function, identify which part of the compiler defined it.  */\n #define DECL_BUILT_IN_CLASS(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.built_in_class)\n+   (FUNCTION_DECL_CHECK (NODE)->decl.built_in_class)\n \n /* Used in VAR_DECLs to indicate that the variable is a vtable.\n    Used in FIELD_DECLs for vtable pointers.\n@@ -1614,12 +1641,12 @@ struct tree_type\n    argument should be passed in the same way that the first union\n    alternative would be passed.  */\n #define DECL_TRANSPARENT_UNION(NODE) \\\n-(PARM_DECL_CHECK (NODE)->decl.transparent_union)\n+  (PARM_DECL_CHECK (NODE)->decl.transparent_union)\n \n /* Used in FUNCTION_DECLs to indicate that they should be run automatically\n    at the beginning or end of execution.  */\n #define DECL_STATIC_CONSTRUCTOR(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.static_ctor_flag)\n+  (FUNCTION_DECL_CHECK (NODE)->decl.static_ctor_flag)\n \n #define DECL_STATIC_DESTRUCTOR(NODE) \\\n (FUNCTION_DECL_CHECK (NODE)->decl.static_dtor_flag)\n@@ -1648,17 +1675,17 @@ struct tree_type\n /* Used in FUNCTION_DECLs to indicate that function entry and exit should\n    be instrumented with calls to support routines.  */\n #define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n+  (FUNCTION_DECL_CHECK (NODE)->decl.no_instrument_function_entry_exit)\n \n /* Used in FUNCTION_DECLs to indicate that check-memory-usage should be\n    disabled in this function.  */\n #define DECL_NO_CHECK_MEMORY_USAGE(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.no_check_memory_usage)\n+  (FUNCTION_DECL_CHECK (NODE)->decl.no_check_memory_usage)\n \n /* Used in FUNCTION_DECLs to indicate that limit-stack-* should be\n    disabled in this function.  */\n #define DECL_NO_LIMIT_STACK(NODE) \\\n-(FUNCTION_DECL_CHECK (NODE)->decl.no_limit_stack)\n+  (FUNCTION_DECL_CHECK (NODE)->decl.no_limit_stack)\n \n /* Additional flags for language-specific uses.  */\n #define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)"}]}