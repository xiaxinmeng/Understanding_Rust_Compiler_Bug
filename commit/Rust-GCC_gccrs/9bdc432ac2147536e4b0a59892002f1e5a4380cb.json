{"sha": "9bdc432ac2147536e4b0a59892002f1e5a4380cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJkYzQzMmFjMjE0NzUzNmU0YjBhNTk4OTIwMDJmMWU1YTQzODBjYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:01:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T13:01:25Z"}, "message": "[multiple changes]\n\n2015-10-26  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Return False when\n\tgenerating C code.\n\t* sem_ch3.adb: Fix typos.\n\n2015-10-26  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch13.adb (Build_Predicate_Functions): Change the\n\tstructure of the predicate functions to reflect the requirements\n\tof AI12-0071.\n\t(Add_Condition): New procedure to do the \"and-then-ing\" in Add_Call\n\tand Add_Predicates.\n\t* einfo.ads (Static_Real_Or_String_Predicate): Change the\n\tdocumentation to reflect the new structure.\n\t* sem_eval.adb (Real_Or_String_Static_Predicate_Matches):\n\tChange the walking of the predicate expression to reflect the\n\tnew structure.\n\t* exp_util.adb: Minor comment fix.\n\nFrom-SVN: r229352", "tree": {"sha": "cc393328bff9bf65326ec0f0c5b7c3d5818f52ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc393328bff9bf65326ec0f0c5b7c3d5818f52ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bdc432ac2147536e4b0a59892002f1e5a4380cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdc432ac2147536e4b0a59892002f1e5a4380cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bdc432ac2147536e4b0a59892002f1e5a4380cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bdc432ac2147536e4b0a59892002f1e5a4380cb/comments", "author": null, "committer": null, "parents": [{"sha": "2f7ae2aa904ddd130485196be47193a1f9ca54c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7ae2aa904ddd130485196be47193a1f9ca54c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7ae2aa904ddd130485196be47193a1f9ca54c1"}], "stats": {"total": 149, "additions": 97, "deletions": 52}, "files": [{"sha": "2066c1f865610a9fab6144cee3d1408f9577d5a6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -1,3 +1,23 @@\n+2015-10-26  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Aggr_Assignment_OK_For_Backend): Return False when\n+\tgenerating C code.\n+\t* sem_ch3.adb: Fix typos.\n+\n+2015-10-26  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Build_Predicate_Functions): Change the\n+\tstructure of the predicate functions to reflect the requirements\n+\tof AI12-0071.\n+\t(Add_Condition): New procedure to do the \"and-then-ing\" in Add_Call\n+\tand Add_Predicates.\n+\t* einfo.ads (Static_Real_Or_String_Predicate): Change the\n+\tdocumentation to reflect the new structure.\n+\t* sem_eval.adb (Real_Or_String_Static_Predicate_Matches):\n+\tChange the walking of the predicate expression to reflect the\n+\tnew structure.\n+\t* exp_util.adb: Minor comment fix.\n+\n 2015-10-26  Bob Duff  <duff@adacore.com>\n \n \t* s-rident.ads (No_Dynamic_Sized_Objects): New restriction name."}, {"sha": "ae4ad47312f374e63e2d136b051cb07d2a9ab13e", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -4149,7 +4149,7 @@ package Einfo is\n --       as Predicate_Function (typ). Also, in the case where a predicate is\n --       inherited, the expression is of the form:\n --\n---         expression AND THEN xxxPredicate (typ2 (ent))\n+--         xxxPredicate (typ2 (ent)) AND THEN expression\n --\n --       where typ2 is the type from which the predicate is inherited, ent is\n --       the entity for the current predicate function, and xxxPredicate is the"}, {"sha": "53f1c91cd178a3bf9325af9fba7e96a6e532d543", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -4105,6 +4105,8 @@ package body Exp_Aggr is\n       --  Backend processing by Gigi/gcc is possible only if all the following\n       --  conditions are met:\n \n+      --    0. We are not generating C code\n+\n       --    1. N consists of a single OTHERS choice, possibly recursively\n \n       --    2. The array type is not packed\n@@ -4135,6 +4137,10 @@ package body Exp_Aggr is\n          Nunits    : Nat;\n \n       begin\n+         if Generate_C_Code then\n+            return False;\n+         end if;\n+\n          --  Recurse as far as possible to find the innermost component type\n \n          Ctyp := Etype (N);"}, {"sha": "aec732036963e839abd67945076ee6fc906c93fc", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -3860,10 +3860,10 @@ package body Exp_Util is\n       --  caller. Note that in the subexpression case, N is always the child we\n       --  came from.\n \n-      --  N_Raise_xxx_Error is an annoying special case, it is a statement if\n-      --  it has type Standard_Void_Type, and a subexpression otherwise.\n-      --  otherwise. Procedure calls, and similarly procedure attribute\n-      --  references, are also statements.\n+      --  N_Raise_xxx_Error is an annoying special case, it is a statement\n+      --  if it has type Standard_Void_Type, and a subexpression otherwise.\n+      --  Procedure calls, and similarly procedure attribute references, are\n+      --  also statements.\n \n       if Nkind (Assoc_Node) in N_Subexpr\n         and then (Nkind (Assoc_Node) not in N_Raise_xxx_Error"}, {"sha": "d187023bca001d7d5e8a756183d3e3bb951913ed", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -8340,10 +8340,10 @@ package body Sem_Ch13 is\n    --    function typPredicate (Ixxx : typ) return Boolean is\n    --    begin\n    --       return\n-   --          exp1 and then exp2 and then ...\n-   --          and then typ1Predicate (typ1 (Ixxx))\n+   --          typ1Predicate (typ1 (Ixxx))\n    --          and then typ2Predicate (typ2 (Ixxx))\n    --          and then ...;\n+   --          exp1 and then exp2 and then ...\n    --    end typPredicate;\n \n    --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n@@ -8352,6 +8352,12 @@ package body Sem_Ch13 is\n    --  inherited. Note that we do NOT generate Check pragmas, that's because we\n    --  use this function even if checks are off, e.g. for membership tests.\n \n+   --  Note that the inherited predicates are evaluated first, as required by\n+   --  AI12-0071-1.\n+\n+   --  Note that Sem_Eval.Real_Or_String_Static_Predicate_Matches depends on\n+   --  the form of this return expression.\n+\n    --  If the expression has at least one Raise_Expression, then we also build\n    --  the typPredicateM version of the function, in which any occurrence of a\n    --  Raise_Expression is converted to \"return False\".\n@@ -8384,16 +8390,20 @@ package body Sem_Ch13 is\n       Raise_Expression_Present : Boolean := False;\n       --  Set True if Expr has at least one Raise_Expression\n \n-      procedure Add_Call (T : Entity_Id);\n-      --  Includes a call to the predicate function for type T in Expr if T\n-      --  has predicates and Predicate_Function (T) is non-empty.\n+      procedure Add_Condition (Cond : Node_Id);\n+      --  Append Cond to Expr using \"and then\" (or just copy Cond to Expr if\n+      --  Expr is empty).\n \n       procedure Add_Predicates;\n       --  Appends expressions for any Predicate pragmas in the rep item chain\n       --  Typ to Expr. Note that we look only at items for this exact entity.\n       --  Inheritance of predicates for the parent type is done by calling the\n       --  Predicate_Function of the parent type, using Add_Call above.\n \n+      procedure Add_Call (T : Entity_Id);\n+      --  Includes a call to the predicate function for type T in Expr if T\n+      --  has predicates and Predicate_Function (T) is non-empty.\n+\n       function Process_RE (N : Node_Id) return Traverse_Result;\n       --  Used in Process REs, tests if node N is a raise expression, and if\n       --  so, marks it to be converted to return False.\n@@ -8425,17 +8435,9 @@ package body Sem_Ch13 is\n               Make_Predicate_Call\n                 (T, Convert_To (T, Make_Identifier (Loc, Object_Name)));\n \n-            --  Add call to evolving expression, using AND THEN if needed\n+            --  \"and\"-in the call to evolving expression\n \n-            if No (Expr) then\n-               Expr := Exp;\n-\n-            else\n-               Expr :=\n-                 Make_And_Then (Sloc (Expr),\n-                   Left_Opnd  => Relocate_Node (Expr),\n-                   Right_Opnd => Exp);\n-            end if;\n+            Add_Condition (Exp);\n \n             --  Output info message on inheritance if required. Note we do not\n             --  give this information for generic actual types, since it is\n@@ -8456,6 +8458,28 @@ package body Sem_Ch13 is\n          end if;\n       end Add_Call;\n \n+      -------------------\n+      -- Add_Condition --\n+      -------------------\n+\n+      procedure Add_Condition (Cond : Node_Id) is\n+      begin\n+         --  This is the first predicate expression\n+\n+         if No (Expr) then\n+            Expr := Cond;\n+\n+         --  Otherwise concatenate to the existing predicate expressions by\n+         --  using \"and then\".\n+\n+         else\n+            Expr :=\n+              Make_And_Then (Loc,\n+                Left_Opnd  => Relocate_Node (Expr),\n+                Right_Opnd => Cond);\n+         end if;\n+      end Add_Condition;\n+\n       --------------------\n       -- Add_Predicates --\n       --------------------\n@@ -8535,24 +8559,12 @@ package body Sem_Ch13 is\n                --  Check_Aspect_At_xxx routines.\n \n                if Present (Asp) then\n-\n                   Set_Entity (Identifier (Asp), New_Copy_Tree (Arg2));\n                end if;\n \n-               --  Concatenate to the existing predicate expressions by using\n-               --  \"and then\".\n-\n-               if Present (Expr) then\n-                  Expr :=\n-                    Make_And_Then (Loc,\n-                      Left_Opnd  => Relocate_Node (Expr),\n-                      Right_Opnd => Relocate_Node (Arg2));\n-\n-               --  Otherwise this is the first predicate expression\n+               --  \"and\"-in the Arg2 condition to evolving expression\n \n-               else\n-                  Expr := Relocate_Node (Arg2);\n-               end if;\n+               Add_Condition (Relocate_Node (Arg2));\n             end if;\n          end Add_Predicate;\n \n@@ -8627,11 +8639,8 @@ package body Sem_Ch13 is\n \n       Expr := Empty;\n \n-      --  Add Predicates for the current type\n-\n-      Add_Predicates;\n-\n-      --  Add predicates for ancestor if present\n+      --  Add predicates for ancestor if present. These must come before the\n+      --  ones for the current type, as required by AI12-0071-1.\n \n       declare\n          Atyp : constant Entity_Id := Nearest_Ancestor (Typ);\n@@ -8641,6 +8650,10 @@ package body Sem_Ch13 is\n          end if;\n       end;\n \n+      --  Add Predicates for the current type\n+\n+      Add_Predicates;\n+\n       --  Case where predicates are present\n \n       if Present (Expr) then\n@@ -8955,13 +8968,18 @@ package body Sem_Ch13 is\n \n                --  First a little fiddling to get a nice location for the\n                --  message. If the expression is of the form (A and then B),\n-               --  then use the left operand for the Sloc. This avoids getting\n-               --  confused by a call to a higher-level predicate with a less\n-               --  convenient source location.\n+               --  where A is an inherited predicate, then use the right\n+               --  operand for the Sloc. This avoids getting confused by a call\n+               --  to an inherited predicate with a less convenient source\n+               --  location.\n \n                EN := Expr;\n-               while Nkind (EN) = N_And_Then loop\n-                  EN := Left_Opnd (EN);\n+               while Nkind (EN) = N_And_Then\n+                 and then Nkind (Left_Opnd (EN)) = N_Function_Call\n+                 and then Is_Predicate_Function\n+                            (Entity (Name (Left_Opnd (EN))))\n+               loop\n+                  EN := Right_Opnd (EN);\n                end loop;\n \n                --  Now post appropriate message\n@@ -11688,7 +11706,7 @@ package body Sem_Ch13 is\n       --  references to inherited predicates, so that the expression we are\n       --  processing looks like:\n \n-      --    expression and then xxPredicate (typ (Inns))\n+      --    xxPredicate (typ (Inns)) and then expression\n \n       --  Where the call is to a Predicate function for an inherited predicate.\n       --  We simply ignore such a call, which could be to either a dynamic or"}, {"sha": "9b5f5dac3d90fa9e454c7f857faa22895b1be09f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -3278,7 +3278,7 @@ package body Sem_Ch3 is\n       --  task type is declared. Its function is to count the static number of\n       --  tasks declared within the type (it is only called if Has_Tasks is set\n       --  for T). As a side effect, if an array of tasks with non-static bounds\n-      --  or a variant record type is encountered, Check_Restrictions is called\n+      --  or a variant record type is encountered, Check_Restriction is called\n       --  indicating the count is unknown.\n \n       function Delayed_Aspect_Present return Boolean;"}, {"sha": "5110f16b4de7c5e0526220e888b0d928e910c5cb", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bdc432ac2147536e4b0a59892002f1e5a4380cb/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=9bdc432ac2147536e4b0a59892002f1e5a4380cb", "patch": "@@ -5408,28 +5408,29 @@ package body Sem_Eval is\n       --  First deal with special case of inherited predicate, where the\n       --  predicate expression looks like:\n \n-      --     Expr and then xxPredicate (typ (Ent))\n+      --     xxPredicate (typ (Ent)) and then Expr\n \n       --  where Expr is the predicate expression for this level, and the\n-      --  right operand is the call to evaluate the inherited predicate.\n+      --  left operand is the call to evaluate the inherited predicate.\n \n       if Nkind (Expr) = N_And_Then\n-        and then Nkind (Right_Opnd (Expr)) = N_Function_Call\n+        and then Nkind (Left_Opnd (Expr)) = N_Function_Call\n+        and then Is_Predicate_Function (Entity (Name (Left_Opnd (Expr))))\n       then\n          --  OK we have the inherited case, so make a call to evaluate the\n          --  inherited predicate. If that fails, so do we!\n \n          if not\n            Real_Or_String_Static_Predicate_Matches\n              (Val => Val,\n-              Typ => Etype (First_Formal (Entity (Name (Right_Opnd (Expr))))))\n+              Typ => Etype (First_Formal (Entity (Name (Left_Opnd (Expr))))))\n          then\n             return False;\n          end if;\n \n-         --  Use the left operand for the continued processing\n+         --  Use the right operand for the continued processing\n \n-         Copy := Copy_Separate_Tree (Left_Opnd (Expr));\n+         Copy := Copy_Separate_Tree (Right_Opnd (Expr));\n \n       --  Case where call to predicate function appears on its own (this means\n       --  that the predicate at this level is just inherited from the parent)."}]}