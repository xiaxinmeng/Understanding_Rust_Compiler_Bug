{"sha": "59f5868d30d8ec3379b02db36b31c3fff121d724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlmNTg2OGQzMGQ4ZWMzMzc5YjAyZGIzNmIzMWMzZmZmMTIxZDcyNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-08-11T19:48:17Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-08-11T19:48:17Z"}, "message": "constraints.md (wh constraint): New constraint, for FP registers if direct move is available.\n\n2014-08-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/constraints.md (wh constraint): New constraint,\n\tfor FP registers if direct move is available.\n\t(wi constraint): New constraint, for VSX/FP registers that can\n\thandle 64-bit integers.\n\t(wj constraint): New constraint for VSX/FP registers that can\n\thandle 64-bit integers for direct moves.\n\t(wk constraint): New constraint for VSX/FP registers that can\n\thandle 64-bit doubles for direct moves.\n\t(wy constraint): Make documentation match implementation.\n\n\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add\n\tscalar_in_vmx_p field to simplify tests of whether SFmode or\n\tDFmode can go in the Altivec registers.\n\t(rs6000_hard_regno_mode_ok): Use scalar_in_vmx_p field.\n\t(rs6000_setup_reg_addr_masks): Likewise.\n\t(rs6000_debug_print_mode): Add debug support for scalar_in_vmx_p\n\tfield, and wh/wi/wj/wk constraints.\n\t(rs6000_init_hard_regno_mode_ok): Setup scalar_in_vmx_p field, and\n\tthe wh/wi/wj/wk constraints.\n\t(rs6000_preferred_reload_class): If SFmode/DFmode can go in the\n\tupper registers, prefer VSX registers unless the operation is a\n\tmemory operation with REG+OFFSET addressing.\n\n\t* config/rs6000/vsx.md (VSr mode attribute): Add support for\n\tDImode.  Change SFmode to use ww constraint instead of d to allow\n\tSF registers in the upper registers.\n\t(VSr2): Likewise.\n\t(VSr3): Likewise.\n\t(VSr5): Fix thinko in comment.\n\t(VSa): New mode attribute that is an alternative to wa, that\n\treturns the VSX register class that a mode can go in, but may not\n\tbe the preferred register class.\n\t(VS_64dm): New mode attribute for appropriate register classes for\n\treferencing 64-bit elements of vectors for direct moves and normal\n\tmoves.\n\t(VS_64reg): Likewise.\n\t(vsx_mov<mode>): Change wa constraint to <VSa> to limit the\n\tregister allocator to only registers the data type can handle.\n\t(vsx_le_perm_load_<mode>): Likewise.\n\t(vsx_le_perm_store_<mode>): Likewise.\n\t(vsx_xxpermdi2_le_<mode>): Likewise.\n\t(vsx_xxpermdi4_le_<mode>): Likewise.\n\t(vsx_lxvd2x2_le_<mode>): Likewise.\n\t(vsx_lxvd2x4_le_<mode>): Likewise.\n\t(vsx_stxvd2x2_le_<mode>): Likewise.\n\t(vsx_add<mode>3): Likewise.\n\t(vsx_sub<mode>3): Likewise.\n\t(vsx_mul<mode>3): Likewise.\n\t(vsx_div<mode>3): Likewise.\n\t(vsx_tdiv<mode>3_internal): Likewise.\n\t(vsx_fre<mode>2): Likewise.\n\t(vsx_neg<mode>2): Likewise.\n\t(vsx_abs<mode>2): Likewise.\n\t(vsx_nabs<mode>2): Likewise.\n\t(vsx_smax<mode>3): Likewise.\n\t(vsx_smin<mode>3): Likewise.\n\t(vsx_sqrt<mode>2): Likewise.\n\t(vsx_rsqrte<mode>2): Likewise.\n\t(vsx_tsqrt<mode>2_internal): Likewise.\n\t(vsx_fms<mode>4): Likewise.\n\t(vsx_nfma<mode>4): Likewise.\n\t(vsx_eq<mode>): Likewise.\n\t(vsx_gt<mode>): Likewise.\n\t(vsx_ge<mode>): Likewise.\n\t(vsx_eq<mode>_p): Likewise.\n\t(vsx_gt<mode>_p): Likewise.\n\t(vsx_ge<mode>_p): Likewise.\n\t(vsx_xxsel<mode>): Likewise.\n\t(vsx_xxsel<mode>_uns): Likewise.\n\t(vsx_copysign<mode>3): Likewise.\n\t(vsx_float<VSi><mode>2): Likewise.\n\t(vsx_floatuns<VSi><mode>2): Likewise.\n\t(vsx_fix_trunc<mode><VSi>2): Likewise.\n\t(vsx_fixuns_trunc<mode><VSi>2): Likewise.\n\t(vsx_x<VSv>r<VSs>i): Likewise.\n\t(vsx_x<VSv>r<VSs>ic): Likewise.\n\t(vsx_btrunc<mode>2): Likewise.\n\t(vsx_b2trunc<mode>2): Likewise.\n\t(vsx_floor<mode>2): Likewise.\n\t(vsx_ceil<mode>2): Likewise.\n\t(vsx_<VS_spdp_insn>): Likewise.\n\t(vsx_xscvspdp): Likewise.\n\t(vsx_xvcvspuxds): Likewise.\n\t(vsx_float_fix_<mode>2): Likewise.\n\t(vsx_set_<mode>): Likewise.\n\t(vsx_extract_<mode>_internal1): Likewise.\n\t(vsx_extract_<mode>_internal2): Likewise.\n\t(vsx_extract_<mode>_load): Likewise.\n\t(vsx_extract_<mode>_store): Likewise.\n\t(vsx_splat_<mode>): Likewise.\n\t(vsx_xxspltw_<mode>): Likewise.\n\t(vsx_xxspltw_<mode>_direct): Likewise.\n\t(vsx_xxmrghw_<mode>): Likewise.\n\t(vsx_xxmrglw_<mode>): Likewise.\n\t(vsx_xxsldwi_<mode>): Likewise.\n\t(vsx_xscvdpspn): Tighten constraints to only use register classes\n\tthe types use.\n\t(vsx_xscvspdpn): Likewise.\n\t(vsx_xscvdpspn_scalar): Likewise.\n\n\t* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wh, wi,\n\twj, and wk constraints.\n\t(GPR_REG_CLASS_P): New helper macro for register classes targeting\n\tgeneral purpose registers.\n\n\t* config/rs6000/rs6000.md (f32_dm): Use wh constraint for SDmode\n\tdirect moves.\n\t(zero_extendsidi2_lfiwz): Use wj constraint for direct move of\n\tDImode instead of wm.  Use wk constraint for direct move of DFmode\n\tinstead of wm.\n\t(extendsidi2_lfiwax): Likewise.\n\t(lfiwax): Likewise.\n\t(lfiwzx): Likewise.\n\t(movdi_internal64): Likewise.\n\n\t* doc/md.texi (PowerPC and IBM RS6000): Document wh, wi, wj, and\n\twk constraints. Make the wy constraint documentation match them\n\timplementation.\n\nFrom-SVN: r213834", "tree": {"sha": "92874f2285b7859e085ceb865fce8edf7e0f6725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92874f2285b7859e085ceb865fce8edf7e0f6725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59f5868d30d8ec3379b02db36b31c3fff121d724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f5868d30d8ec3379b02db36b31c3fff121d724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f5868d30d8ec3379b02db36b31c3fff121d724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f5868d30d8ec3379b02db36b31c3fff121d724/comments", "author": null, "committer": null, "parents": [{"sha": "69b682f23a9b3a7fb04fd73bb6b59d7544455d3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b682f23a9b3a7fb04fd73bb6b59d7544455d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b682f23a9b3a7fb04fd73bb6b59d7544455d3e"}], "stats": {"total": 610, "additions": 416, "deletions": 194}, "files": [{"sha": "15555c67d62dd99e4c0e8598bf81b236cf9e83e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -1,3 +1,124 @@\n+2014-08-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wh constraint): New constraint,\n+\tfor FP registers if direct move is available.\n+\t(wi constraint): New constraint, for VSX/FP registers that can\n+\thandle 64-bit integers.\n+\t(wj constraint): New constraint for VSX/FP registers that can\n+\thandle 64-bit integers for direct moves.\n+\t(wk constraint): New constraint for VSX/FP registers that can\n+\thandle 64-bit doubles for direct moves.\n+\t(wy constraint): Make documentation match implementation.\n+\n+\t* config/rs6000/rs6000.c (struct rs6000_reg_addr): Add\n+\tscalar_in_vmx_p field to simplify tests of whether SFmode or\n+\tDFmode can go in the Altivec registers.\n+\t(rs6000_hard_regno_mode_ok): Use scalar_in_vmx_p field.\n+\t(rs6000_setup_reg_addr_masks): Likewise.\n+\t(rs6000_debug_print_mode): Add debug support for scalar_in_vmx_p\n+\tfield, and wh/wi/wj/wk constraints.\n+\t(rs6000_init_hard_regno_mode_ok): Setup scalar_in_vmx_p field, and\n+\tthe wh/wi/wj/wk constraints.\n+\t(rs6000_preferred_reload_class): If SFmode/DFmode can go in the\n+\tupper registers, prefer VSX registers unless the operation is a\n+\tmemory operation with REG+OFFSET addressing.\n+\n+\t* config/rs6000/vsx.md (VSr mode attribute): Add support for\n+\tDImode.  Change SFmode to use ww constraint instead of d to allow\n+\tSF registers in the upper registers.\n+\t(VSr2): Likewise.\n+\t(VSr3): Likewise.\n+\t(VSr5): Fix thinko in comment.\n+\t(VSa): New mode attribute that is an alternative to wa, that\n+\treturns the VSX register class that a mode can go in, but may not\n+\tbe the preferred register class.\n+\t(VS_64dm): New mode attribute for appropriate register classes for\n+\treferencing 64-bit elements of vectors for direct moves and normal\n+\tmoves.\n+\t(VS_64reg): Likewise.\n+\t(vsx_mov<mode>): Change wa constraint to <VSa> to limit the\n+\tregister allocator to only registers the data type can handle.\n+\t(vsx_le_perm_load_<mode>): Likewise.\n+\t(vsx_le_perm_store_<mode>): Likewise.\n+\t(vsx_xxpermdi2_le_<mode>): Likewise.\n+\t(vsx_xxpermdi4_le_<mode>): Likewise.\n+\t(vsx_lxvd2x2_le_<mode>): Likewise.\n+\t(vsx_lxvd2x4_le_<mode>): Likewise.\n+\t(vsx_stxvd2x2_le_<mode>): Likewise.\n+\t(vsx_add<mode>3): Likewise.\n+\t(vsx_sub<mode>3): Likewise.\n+\t(vsx_mul<mode>3): Likewise.\n+\t(vsx_div<mode>3): Likewise.\n+\t(vsx_tdiv<mode>3_internal): Likewise.\n+\t(vsx_fre<mode>2): Likewise.\n+\t(vsx_neg<mode>2): Likewise.\n+\t(vsx_abs<mode>2): Likewise.\n+\t(vsx_nabs<mode>2): Likewise.\n+\t(vsx_smax<mode>3): Likewise.\n+\t(vsx_smin<mode>3): Likewise.\n+\t(vsx_sqrt<mode>2): Likewise.\n+\t(vsx_rsqrte<mode>2): Likewise.\n+\t(vsx_tsqrt<mode>2_internal): Likewise.\n+\t(vsx_fms<mode>4): Likewise.\n+\t(vsx_nfma<mode>4): Likewise.\n+\t(vsx_eq<mode>): Likewise.\n+\t(vsx_gt<mode>): Likewise.\n+\t(vsx_ge<mode>): Likewise.\n+\t(vsx_eq<mode>_p): Likewise.\n+\t(vsx_gt<mode>_p): Likewise.\n+\t(vsx_ge<mode>_p): Likewise.\n+\t(vsx_xxsel<mode>): Likewise.\n+\t(vsx_xxsel<mode>_uns): Likewise.\n+\t(vsx_copysign<mode>3): Likewise.\n+\t(vsx_float<VSi><mode>2): Likewise.\n+\t(vsx_floatuns<VSi><mode>2): Likewise.\n+\t(vsx_fix_trunc<mode><VSi>2): Likewise.\n+\t(vsx_fixuns_trunc<mode><VSi>2): Likewise.\n+\t(vsx_x<VSv>r<VSs>i): Likewise.\n+\t(vsx_x<VSv>r<VSs>ic): Likewise.\n+\t(vsx_btrunc<mode>2): Likewise.\n+\t(vsx_b2trunc<mode>2): Likewise.\n+\t(vsx_floor<mode>2): Likewise.\n+\t(vsx_ceil<mode>2): Likewise.\n+\t(vsx_<VS_spdp_insn>): Likewise.\n+\t(vsx_xscvspdp): Likewise.\n+\t(vsx_xvcvspuxds): Likewise.\n+\t(vsx_float_fix_<mode>2): Likewise.\n+\t(vsx_set_<mode>): Likewise.\n+\t(vsx_extract_<mode>_internal1): Likewise.\n+\t(vsx_extract_<mode>_internal2): Likewise.\n+\t(vsx_extract_<mode>_load): Likewise.\n+\t(vsx_extract_<mode>_store): Likewise.\n+\t(vsx_splat_<mode>): Likewise.\n+\t(vsx_xxspltw_<mode>): Likewise.\n+\t(vsx_xxspltw_<mode>_direct): Likewise.\n+\t(vsx_xxmrghw_<mode>): Likewise.\n+\t(vsx_xxmrglw_<mode>): Likewise.\n+\t(vsx_xxsldwi_<mode>): Likewise.\n+\t(vsx_xscvdpspn): Tighten constraints to only use register classes\n+\tthe types use.\n+\t(vsx_xscvspdpn): Likewise.\n+\t(vsx_xscvdpspn_scalar): Likewise.\n+\n+\t* config/rs6000/rs6000.h (enum rs6000_reg_class_enum): Add wh, wi,\n+\twj, and wk constraints.\n+\t(GPR_REG_CLASS_P): New helper macro for register classes targeting\n+\tgeneral purpose registers.\n+\n+\t* config/rs6000/rs6000.md (f32_dm): Use wh constraint for SDmode\n+\tdirect moves.\n+\t(zero_extendsidi2_lfiwz): Use wj constraint for direct move of\n+\tDImode instead of wm.  Use wk constraint for direct move of DFmode\n+\tinstead of wm.\n+\t(extendsidi2_lfiwax): Likewise.\n+\t(lfiwax): Likewise.\n+\t(lfiwzx): Likewise.\n+\t(movdi_internal64): Likewise.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000): Document wh, wi, wj, and\n+\twk constraints. Make the wy constraint documentation match them\n+\timplementation.\n+\n 2014-08-11  John Dave Anglin  <danglin@gcc.gnu.org>\n \n \tPR target/62038\n@@ -62,7 +183,7 @@\n \tPR tree-optimization/62073\n \t* tree-vect-loop.c (vect_is_simple_reduction_1): Check that DEF1 has\n \ta basic block.\n-\t\n+\n 2014-08-11  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Anna Tikhonova  <anna.tikhonova@intel.com>"}, {"sha": "0385f3c7f92dd49de6ed17b0e0e9eec0f677ec03", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -68,6 +68,20 @@\n (define_register_constraint \"wg\" \"rs6000_constraints[RS6000_CONSTRAINT_wg]\"\n   \"If -mmfpgpr was used, a floating point register or NO_REGS.\")\n \n+(define_register_constraint \"wh\" \"rs6000_constraints[RS6000_CONSTRAINT_wh]\"\n+  \"Floating point register if direct moves are available, or NO_REGS.\")\n+\n+;; At present, DImode is not allowed in the Altivec registers.  If in the\n+;; future it is allowed, wi/wj can be set to VSX_REGS instead of FLOAT_REGS.\n+(define_register_constraint \"wi\" \"rs6000_constraints[RS6000_CONSTRAINT_wi]\"\n+  \"FP or VSX register to hold 64-bit integers or NO_REGS.\")\n+\n+(define_register_constraint \"wj\" \"rs6000_constraints[RS6000_CONSTRAINT_wj]\"\n+  \"FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.\")\n+\n+(define_register_constraint \"wk\" \"rs6000_constraints[RS6000_CONSTRAINT_wk]\"\n+  \"FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.\")\n+\n (define_register_constraint \"wl\" \"rs6000_constraints[RS6000_CONSTRAINT_wl]\"\n   \"Floating point register if the LFIWAX instruction is enabled or NO_REGS.\")\n \n@@ -101,7 +115,7 @@\n   \"Floating point register if the STFIWX instruction is enabled or NO_REGS.\")\n \n (define_register_constraint \"wy\" \"rs6000_constraints[RS6000_CONSTRAINT_wy]\"\n-  \"VSX vector register to hold scalar float values or NO_REGS.\")\n+  \"FP or VSX register to perform ISA 2.07 float ops or NO_REGS.\")\n \n (define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n   \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")"}, {"sha": "d90afcc8e5f4f09818d3ebdace00eb5d8e33345a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -388,6 +388,7 @@ struct rs6000_reg_addr {\n   enum insn_code reload_gpr_vsx;\t/* INSN to move from GPR to VSX.  */\n   enum insn_code reload_vsx_gpr;\t/* INSN to move from VSX to GPR.  */\n   addr_mask_type addr_mask[(int)N_RELOAD_REG]; /* Valid address masks.  */\n+  bool scalar_in_vmx_p;\t\t\t/* Scalar value can go in VMX.  */\n };\n \n static struct rs6000_reg_addr reg_addr[NUM_MACHINE_MODES];\n@@ -1732,8 +1733,7 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n      asked for it.  */\n   if (TARGET_VSX && VSX_REGNO_P (regno)\n       && (VECTOR_MEM_VSX_P (mode)\n-\t  || (TARGET_VSX_SCALAR_FLOAT && mode == SFmode)\n-\t  || (TARGET_VSX_SCALAR_DOUBLE && (mode == DFmode || mode == DImode))\n+\t  || reg_addr[mode].scalar_in_vmx_p\n \t  || (TARGET_VSX_TIMODE && mode == TImode)\n \t  || (TARGET_VADDUQM && mode == V1TImode)))\n     {\n@@ -1742,10 +1742,7 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n       if (ALTIVEC_REGNO_P (regno))\n \t{\n-\t  if (mode == SFmode && !TARGET_UPPER_REGS_SF)\n-\t    return 0;\n-\n-\t  if ((mode == DFmode || mode == DImode) && !TARGET_UPPER_REGS_DF)\n+\t  if (GET_MODE_SIZE (mode) != 16 && !reg_addr[mode].scalar_in_vmx_p)\n \t    return 0;\n \n \t  return ALTIVEC_REGNO_P (last_regno);\n@@ -1925,14 +1922,16 @@ rs6000_debug_print_mode (ssize_t m)\n   if (rs6000_vector_unit[m] != VECTOR_NONE\n       || rs6000_vector_mem[m] != VECTOR_NONE\n       || (reg_addr[m].reload_store != CODE_FOR_nothing)\n-      || (reg_addr[m].reload_load != CODE_FOR_nothing))\n+      || (reg_addr[m].reload_load != CODE_FOR_nothing)\n+      || reg_addr[m].scalar_in_vmx_p)\n     {\n       fprintf (stderr,\n-\t       \"  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c\",\n+\t       \"  Vector-arith=%-10s Vector-mem=%-10s Reload=%c%c Upper=%c\",\n \t       rs6000_debug_vector_unit (rs6000_vector_unit[m]),\n \t       rs6000_debug_vector_unit (rs6000_vector_mem[m]),\n \t       (reg_addr[m].reload_store != CODE_FOR_nothing) ? 's' : '*',\n-\t       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*');\n+\t       (reg_addr[m].reload_load != CODE_FOR_nothing) ? 'l' : '*',\n+\t       (reg_addr[m].scalar_in_vmx_p) ? 'y' : 'n');\n     }\n \n   fputs (\"\\n\", stderr);\n@@ -2049,6 +2048,10 @@ rs6000_debug_reg_global (void)\n \t   \"wd reg_class = %s\\n\"\n \t   \"wf reg_class = %s\\n\"\n \t   \"wg reg_class = %s\\n\"\n+\t   \"wh reg_class = %s\\n\"\n+\t   \"wi reg_class = %s\\n\"\n+\t   \"wj reg_class = %s\\n\"\n+\t   \"wk reg_class = %s\\n\"\n \t   \"wl reg_class = %s\\n\"\n \t   \"wm reg_class = %s\\n\"\n \t   \"wr reg_class = %s\\n\"\n@@ -2068,6 +2071,10 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wd]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wh]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wi]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wj]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wk]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wl]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wm]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wr]],\n@@ -2397,8 +2404,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\t  && !COMPLEX_MODE_P (m2)\n \t\t  && !indexed_only_p\n \t\t  && !(TARGET_E500_DOUBLE && GET_MODE_SIZE (m2) == 8)\n-\t\t  && !(m2 == DFmode && TARGET_UPPER_REGS_DF)\n-\t\t  && !(m2 == SFmode && TARGET_UPPER_REGS_SF))\n+\t\t  && !reg_addr[m2].scalar_in_vmx_p)\n \t\t{\n \t\t  addr_mask |= RELOAD_REG_PRE_INCDEC;\n \n@@ -2629,37 +2635,46 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \tf  - Register class to use with traditional SFmode instructions.\n \tv  - Altivec register.\n \twa - Any VSX register.\n+\twc - Reserved to represent individual CR bits (used in LLVM).\n \twd - Preferred register class for V2DFmode.\n \twf - Preferred register class for V4SFmode.\n \twg - Float register for power6x move insns.\n+\twh - FP register for direct move instructions.\n+\twi - FP or VSX register to hold 64-bit integers.\n+\twj - FP or VSX register to hold 64-bit integers for direct moves.\n+\twk - FP or VSX register to hold 64-bit doubles for direct moves.\n \twl - Float register if we can do 32-bit signed int loads.\n \twm - VSX register for ISA 2.07 direct move operations.\n+\twn - always NO_REGS.\n \twr - GPR if 64-bit mode is permitted.\n \tws - Register class to do ISA 2.06 DF operations.\n+\twt - VSX register for TImode in VSX registers.\n \twu - Altivec register for ISA 2.07 VSX SF/SI load/stores.\n \twv - Altivec register for ISA 2.06 VSX DF/DI load/stores.\n-\twt - VSX register for TImode in VSX registers.\n \tww - Register class to do SF conversions in with VSX operations.\n \twx - Float register if we can do 32-bit int stores.\n \twy - Register class to do ISA 2.07 SF operations.\n \twz - Float register if we can do 32-bit unsigned int loads.  */\n \n   if (TARGET_HARD_FLOAT && TARGET_FPRS)\n-    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\n+    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\t/* SFmode  */\n \n   if (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT)\n-    rs6000_constraints[RS6000_CONSTRAINT_d] = FLOAT_REGS;\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_d]  = FLOAT_REGS;\t/* DFmode  */\n+      rs6000_constraints[RS6000_CONSTRAINT_wi] = FLOAT_REGS;\t/* DImode  */\n+    }\n \n   if (TARGET_VSX)\n     {\n       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\t/* V2DFmode  */\n+      rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\t/* V4SFmode  */\n \n       if (TARGET_VSX_TIMODE)\n-\trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\n+\trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\t/* TImode  */\n \n-      if (TARGET_UPPER_REGS_DF)\n+      if (TARGET_UPPER_REGS_DF)\t\t\t\t\t/* DFmode  */\n \t{\n \t  rs6000_constraints[RS6000_CONSTRAINT_ws] = VSX_REGS;\n \t  rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n@@ -2673,19 +2688,26 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_ALTIVEC)\n     rs6000_constraints[RS6000_CONSTRAINT_v] = ALTIVEC_REGS;\n \n-  if (TARGET_MFPGPR)\n+  if (TARGET_MFPGPR)\t\t\t\t\t\t/* DFmode  */\n     rs6000_constraints[RS6000_CONSTRAINT_wg] = FLOAT_REGS;\n \n   if (TARGET_LFIWAX)\n-    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;\n+    rs6000_constraints[RS6000_CONSTRAINT_wl] = FLOAT_REGS;\t/* DImode  */\n \n   if (TARGET_DIRECT_MOVE)\n-    rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_wh] = FLOAT_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wj]\t\t\t/* DImode  */\n+\t= rs6000_constraints[RS6000_CONSTRAINT_wi];\n+      rs6000_constraints[RS6000_CONSTRAINT_wk]\t\t\t/* DFmode  */\n+\t= rs6000_constraints[RS6000_CONSTRAINT_ws];\n+      rs6000_constraints[RS6000_CONSTRAINT_wm] = VSX_REGS;\n+    }\n \n   if (TARGET_POWERPC64)\n     rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;\n \n-  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)\n+  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)\t\t\t/* SFmode  */\n     {\n       rs6000_constraints[RS6000_CONSTRAINT_wu] = ALTIVEC_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wy] = VSX_REGS;\n@@ -2700,10 +2722,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n     rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;\n \n   if (TARGET_STFIWX)\n-    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;\n+    rs6000_constraints[RS6000_CONSTRAINT_wx] = FLOAT_REGS;\t/* DImode  */\n \n   if (TARGET_LFIWZX)\n-    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\n+    rs6000_constraints[RS6000_CONSTRAINT_wz] = FLOAT_REGS;\t/* DImode  */\n \n   /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n@@ -2726,17 +2748,20 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_di_load;\n \t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n-\t      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_di_store;\n-\t      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_di_load;\n-\t      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_di_store;\n-\t      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_di_load;\n+\t      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_di_store;\n+\t      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_di_load;\n+\t      reg_addr[DFmode].scalar_in_vmx_p = true;\n+\t      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_di_store;\n+\t      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_di_load;\n \t    }\n \t  if (TARGET_P8_VECTOR)\n \t    {\n \t      reg_addr[SFmode].reload_store  = CODE_FOR_reload_sf_di_store;\n \t      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_di_load;\n \t      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_di_store;\n \t      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_di_load;\n+\t      if (TARGET_UPPER_REGS_SF)\n+\t\treg_addr[SFmode].scalar_in_vmx_p = true;\n \t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n@@ -2793,17 +2818,20 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V2DFmode].reload_load   = CODE_FOR_reload_v2df_si_load;\n \t  if (TARGET_VSX && TARGET_UPPER_REGS_DF)\n \t    {\n-\t      reg_addr[DFmode].reload_store  = CODE_FOR_reload_df_si_store;\n-\t      reg_addr[DFmode].reload_load   = CODE_FOR_reload_df_si_load;\n-\t      reg_addr[DDmode].reload_store  = CODE_FOR_reload_dd_si_store;\n-\t      reg_addr[DDmode].reload_load   = CODE_FOR_reload_dd_si_load;\n+\t      reg_addr[DFmode].reload_store    = CODE_FOR_reload_df_si_store;\n+\t      reg_addr[DFmode].reload_load     = CODE_FOR_reload_df_si_load;\n+\t      reg_addr[DFmode].scalar_in_vmx_p = true;\n+\t      reg_addr[DDmode].reload_store    = CODE_FOR_reload_dd_si_store;\n+\t      reg_addr[DDmode].reload_load     = CODE_FOR_reload_dd_si_load;\n \t    }\n \t  if (TARGET_P8_VECTOR)\n \t    {\n \t      reg_addr[SFmode].reload_store  = CODE_FOR_reload_sf_si_store;\n \t      reg_addr[SFmode].reload_load   = CODE_FOR_reload_sf_si_load;\n \t      reg_addr[SDmode].reload_store  = CODE_FOR_reload_sd_si_store;\n \t      reg_addr[SDmode].reload_load   = CODE_FOR_reload_sd_si_load;\n+\t      if (TARGET_UPPER_REGS_SF)\n+\t\treg_addr[SFmode].scalar_in_vmx_p = true;\n \t    }\n \t  if (TARGET_VSX_TIMODE)\n \t    {\n@@ -17215,7 +17243,14 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n      prefer Altivec loads..  */\n   if (rclass == VSX_REGS)\n     {\n-      if (GET_MODE_SIZE (mode) <= 8)\n+      if (MEM_P (x) && reg_addr[mode].scalar_in_vmx_p)\n+\t{\n+\t  rtx addr = XEXP (x, 0);\n+\t  if (rs6000_legitimate_offset_address_p (mode, addr, false, true)\n+\t      || legitimate_lo_sum_address_p (mode, addr, false))\n+\t    return FLOAT_REGS;\n+\t}\n+      else if (GET_MODE_SIZE (mode) <= 8 && !reg_addr[mode].scalar_in_vmx_p)\n \treturn FLOAT_REGS;\n \n       if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode)"}, {"sha": "8a0fcab63f8b16590e9276565efe48cb95c9a2d5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -1477,6 +1477,10 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_wd,\t\t/* VSX register for V2DF */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */\n   RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n+  RS6000_CONSTRAINT_wh,\t\t/* FPR register for direct moves.  */\n+  RS6000_CONSTRAINT_wi,\t\t/* FPR/VSX register to hold DImode */\n+  RS6000_CONSTRAINT_wj,\t\t/* FPR/VSX register for DImode direct moves. */\n+  RS6000_CONSTRAINT_wk,\t\t/* FPR/VSX register for DFmode direct moves. */\n   RS6000_CONSTRAINT_wl,\t\t/* FPR register for LFIWAX */\n   RS6000_CONSTRAINT_wm,\t\t/* VSX register for direct move */\n   RS6000_CONSTRAINT_wr,\t\t/* GPR register if 64-bit  */\n@@ -1501,6 +1505,9 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define VSX_REG_CLASS_P(CLASS)\t\t\t\\\n   ((CLASS) == VSX_REGS || (CLASS) == FLOAT_REGS || (CLASS) == ALTIVEC_REGS)\n \n+/* Return whether a given register class targets general purpose registers.  */\n+#define GPR_REG_CLASS_P(CLASS) ((CLASS) == GENERAL_REGS || (CLASS) == BASE_REGS)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines"}, {"sha": "7a99957b5e0fb58e0d30fa52f1e5656803c3bf93", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -394,7 +394,7 @@\n (define_mode_attr f32_sv [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n \n ; Definitions for 32-bit fpr direct move\n-(define_mode_attr f32_dm [(SF \"wn\") (SD \"wm\")])\n+(define_mode_attr f32_dm [(SF \"wn\") (SD \"wh\")])\n \n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n@@ -638,7 +638,7 @@\n   \"\")\n \n (define_insn \"*zero_extendsidi2_lfiwzx\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wz,!wu\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wj,!wz,!wu\")\n \t(zero_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"m,r,r,Z,Z\")))]\n   \"TARGET_POWERPC64 && TARGET_LFIWZX\"\n   \"@\n@@ -790,7 +790,7 @@\n   \"\")\n \n (define_insn \"*extendsidi2_lfiwax\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wl,!wu\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wj,!wl,!wu\")\n \t(sign_extend:DI (match_operand:SI 1 \"lwa_operand\" \"Y,r,r,Z,Z\")))]\n   \"TARGET_POWERPC64 && TARGET_LFIWAX\"\n   \"@\n@@ -5631,7 +5631,7 @@\n ; We don't define lfiwax/lfiwzx with the normal definition, because we\n ; don't want to support putting SImode in FPR registers.\n (define_insn \"lfiwax\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wm,!wm\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi,!wj\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n \t\t   UNSPEC_LFIWAX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n@@ -5711,7 +5711,7 @@\n    (set_attr \"type\" \"fpload\")])\n \n (define_insn \"lfiwzx\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wm,!wm\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi,!wj\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r\")]\n \t\t   UNSPEC_LFIWZX))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n@@ -8962,8 +8962,8 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wk\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wk,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -9652,8 +9652,8 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wm,?*wm\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wm,r,O\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,r,*h,*h,r,?*wg,r,?*wj,?*wi\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,*h,r,0,*wg,r,*wj,r,O\"))]\n   \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\""}, {"sha": "be9d6a7980da22755373c23e4563f634d0731eb8", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 182, "deletions": 149, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -86,32 +86,54 @@\n \t\t\t (V4SF  \"wf\")\n \t\t\t (V2DI  \"wd\")\n \t\t\t (V2DF  \"wd\")\n+\t\t\t (DI\t\"wi\")\n \t\t\t (DF    \"ws\")\n-\t\t\t (SF\t\"d\")\n+\t\t\t (SF\t\"ww\")\n \t\t\t (V1TI  \"v\")\n \t\t\t (TI    \"wt\")])\n \n-;; Map the register class used for float<->int conversions\n+;; Map the register class used for float<->int conversions (floating point side)\n+;; VSr2 is the preferred register class, VSr3 is any register class that will\n+;; hold the data\n (define_mode_attr VSr2\t[(V2DF  \"wd\")\n \t\t\t (V4SF  \"wf\")\n-\t\t\t (DF    \"ws\")])\n+\t\t\t (DF    \"ws\")\n+\t\t\t (SF\t\"ww\")\n+\t\t\t (DI\t\"wi\")])\n \n (define_mode_attr VSr3\t[(V2DF  \"wa\")\n \t\t\t (V4SF  \"wa\")\n-\t\t\t (DF    \"ws\")])\n+\t\t\t (DF    \"ws\")\n+\t\t\t (SF\t\"ww\")\n+\t\t\t (DI\t\"wi\")])\n \n ;; Map the register class for sp<->dp float conversions, destination\n (define_mode_attr VSr4\t[(SF\t\"ws\")\n \t\t\t (DF\t\"f\")\n \t\t\t (V2DF  \"wd\")\n \t\t\t (V4SF\t\"v\")])\n \n-;; Map the register class for sp<->dp float conversions, destination\n+;; Map the register class for sp<->dp float conversions, source\n (define_mode_attr VSr5\t[(SF\t\"ws\")\n \t\t\t (DF\t\"f\")\n \t\t\t (V2DF  \"v\")\n \t\t\t (V4SF\t\"wd\")])\n \n+;; The VSX register class that a type can occupy, even if it is not the\n+;; preferred register class (VSr is the preferred register class that will get\n+;; allocated first).\n+(define_mode_attr VSa\t[(V16QI \"wa\")\n+\t\t\t (V8HI  \"wa\")\n+\t\t\t (V4SI  \"wa\")\n+\t\t\t (V4SF  \"wa\")\n+\t\t\t (V2DI  \"wa\")\n+\t\t\t (V2DF  \"wa\")\n+\t\t\t (DI\t\"wi\")\n+\t\t\t (DF    \"ws\")\n+\t\t\t (SF\t\"ww\")\n+\t\t\t (V1TI\t\"wa\")\n+\t\t\t (TI    \"wt\")])\n+\n ;; Same size integer type for floating point data\n (define_mode_attr VSi [(V4SF  \"v4si\")\n \t\t       (V2DF  \"v2di\")\n@@ -207,6 +229,16 @@\n \t\t\t     (V2DF\t\"V4DF\")\n \t\t\t     (V1TI\t\"V2TI\")])\n \n+;; Map register class for 64-bit element in 128-bit vector for direct moves\n+;; to/from gprs\n+(define_mode_attr VS_64dm [(V2DF\t\"wk\")\n+\t\t\t   (V2DI\t\"wj\")])\n+\n+;; Map register class for 64-bit element in 128-bit vector for normal register\n+;; to register moves\n+(define_mode_attr VS_64reg [(V2DF\t\"ws\")\n+\t\t\t    (V2DI\t\"wi\")])\n+\n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n   [UNSPEC_VSX_CONCAT\n@@ -235,7 +267,7 @@\n ;; The patterns for LE permuted loads and stores come before the general\n ;; VSX moves so they match first.\n (define_insn_and_split \"*vsx_le_perm_load_<mode>\"\n-  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=<VSa>\")\n         (match_operand:VSX_LE 1 \"memory_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n   \"#\"\n@@ -258,7 +290,7 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn_and_split \"*vsx_le_perm_load_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=<VSa>\")\n         (match_operand:VSX_W 1 \"memory_operand\" \"Z\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n   \"#\"\n@@ -350,7 +382,7 @@\n \n (define_insn \"*vsx_le_perm_store_<mode>\"\n   [(set (match_operand:VSX_LE 0 \"memory_operand\" \"=Z\")\n-        (match_operand:VSX_LE 1 \"vsx_register_operand\" \"+wa\"))]\n+        (match_operand:VSX_LE 1 \"vsx_register_operand\" \"+<VSa>\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n   \"#\"\n   [(set_attr \"type\" \"vecstore\")\n@@ -395,7 +427,7 @@\n \n (define_insn \"*vsx_le_perm_store_<mode>\"\n   [(set (match_operand:VSX_W 0 \"memory_operand\" \"=Z\")\n-        (match_operand:VSX_W 1 \"vsx_register_operand\" \"+wa\"))]\n+        (match_operand:VSX_W 1 \"vsx_register_operand\" \"+<VSa>\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n   \"#\"\n   [(set_attr \"type\" \"vecstore\")\n@@ -585,8 +617,8 @@\n \n \n (define_insn \"*vsx_mov<mode>\"\n-  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?wa,?wa,wQ,?&r,??Y,??r,??r,<VSr>,?wa,*r,v,wZ, v\")\n-\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,wa,Z,wa,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ, v\")\n+\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\n    && (register_operand (operands[0], <MODE>mode) \n        || register_operand (operands[1], <MODE>mode))\"\n@@ -689,36 +721,36 @@\n ;; instructions are now combined with the insn for the traditional floating\n ;; point unit.\n (define_insn \"*vsx_add<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (plus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (plus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvadd<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_sub<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (minus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t     (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (minus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t     (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvsub<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_mul<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (mult:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (mult:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmul<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n \n (define_insn \"*vsx_div<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (div:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t   (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (div:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t   (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvdiv<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_div>\")\n@@ -754,78 +786,78 @@\n \n (define_insn \"*vsx_tdiv<mode>3_internal\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=x,x\")\n-\t(unspec:CCFP [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t      (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,wa\")]\n+\t(unspec:CCFP [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t      (match_operand:VSX_B 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t   UNSPEC_VSX_TDIV))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>tdiv<VSs> %0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_fre<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRES))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvre<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_neg<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (neg:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (neg:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvneg<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_abs<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (abs:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (abs:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvabs<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_nabs<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (neg:VSX_F\n \t (abs:VSX_F\n-\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\"))))]\n+\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvnabs<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_smax<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (smax:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (smax:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmax<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_smin<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (smin:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (smin:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmin<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_sqrt<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-        (sqrt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+        (sqrt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvsqrt<VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_sqrt>\")\n    (set_attr \"fp_type\" \"<VSfptype_sqrt>\")])\n \n (define_insn \"*vsx_rsqrte<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_RSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvrsqrte<VSs> %x0,%x1\"\n@@ -860,7 +892,7 @@\n \n (define_insn \"*vsx_tsqrt<mode>2_internal\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=x,x\")\n-\t(unspec:CCFP [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+\t(unspec:CCFP [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t     UNSPEC_VSX_TSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>tsqrt<VSs> %0,%x1\"\n@@ -902,12 +934,12 @@\n   [(set_attr \"type\" \"vecdouble\")])\n \n (define_insn \"*vsx_fms<mode>4\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?<VSa>,?<VSa>\")\n \t(fma:VSX_F\n-\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,wa,wa\")\n-\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n+\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"%<VSr>,<VSr>,<VSa>,<VSa>\")\n+\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,0,<VSa>,0\")\n \t  (neg:VSX_F\n-\t    (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n+\t    (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,<VSa>\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n    xvmsuba<VSs> %x0,%x1,%x2\n@@ -917,12 +949,12 @@\n   [(set_attr \"type\" \"<VStype_mul>\")])\n \n (define_insn \"*vsx_nfma<mode>4\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?wa,?wa\")\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,<VSr>,?<VSa>,?<VSa>\")\n \t(neg:VSX_F\n \t (fma:VSX_F\n-\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSr>,wa,wa\")\n-\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,0,wa,0\")\n-\t  (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,wa\"))))]\n+\t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSr>,<VSa>,<VSa>\")\n+\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,0,<VSa>,0\")\n+\t  (match_operand:VSX_F 3 \"vsx_register_operand\" \"0,<VSr>,0,<VSa>\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"@\n    xvnmadda<VSs> %x0,%x1,%x2\n@@ -967,27 +999,27 @@\n \n ;; Vector conditional expressions (no scalar version for these instructions)\n (define_insn \"vsx_eq<mode>\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(eq:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(eq:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpeq<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_gt<mode>\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(gt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(gt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpgt<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_ge<mode>\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(ge:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(ge:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpge<VSs> %x0,%x1,%x2\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n@@ -998,10 +1030,10 @@\n (define_insn \"*vsx_eq_<mode>_p\"\n   [(set (reg:CC 74)\n \t(unspec:CC\n-\t [(eq:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?wa\"))]\n+\t [(eq:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?<VSa>\")\n+\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?<VSa>\"))]\n \t UNSPEC_PREDICATE))\n-   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(eq:VSX_F (match_dup 1)\n \t\t  (match_dup 2)))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n@@ -1011,10 +1043,10 @@\n (define_insn \"*vsx_gt_<mode>_p\"\n   [(set (reg:CC 74)\n \t(unspec:CC\n-\t [(gt:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?wa\"))]\n+\t [(gt:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?<VSa>\")\n+\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?<VSa>\"))]\n \t UNSPEC_PREDICATE))\n-   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(gt:VSX_F (match_dup 1)\n \t\t  (match_dup 2)))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n@@ -1024,10 +1056,10 @@\n (define_insn \"*vsx_ge_<mode>_p\"\n   [(set (reg:CC 74)\n \t(unspec:CC\n-\t [(ge:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?wa\")\n-\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?wa\"))]\n+\t [(ge:CC (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,?<VSa>\")\n+\t\t (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,?<VSa>\"))]\n \t UNSPEC_PREDICATE))\n-   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+   (set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(ge:VSX_F (match_dup 1)\n \t\t  (match_dup 2)))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n@@ -1036,33 +1068,33 @@\n \n ;; Vector select\n (define_insn \"*vsx_xxsel<mode>\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(if_then_else:VSX_L\n-\t (ne:CC (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t (ne:CC (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t(match_operand:VSX_L 4 \"zero_constant\" \"\"))\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxsel %x0,%x3,%x2,%x1\"\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"*vsx_xxsel<mode>_uns\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(if_then_else:VSX_L\n-\t (ne:CCUNS (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,wa\")\n+\t (ne:CCUNS (match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t   (match_operand:VSX_L 4 \"zero_constant\" \"\"))\n-\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+\t (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t (match_operand:VSX_L 3 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxsel %x0,%x3,%x2,%x1\"\n   [(set_attr \"type\" \"vecperm\")])\n \n ;; Copy sign\n (define_insn \"vsx_copysign<mode>3\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_F\n-\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")\n-\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,wa\")]\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n+\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcpsgn<VSs> %x0,%x2,%x1\"\n@@ -1075,15 +1107,15 @@\n ;; in rs6000.md so don't test VECTOR_UNIT_VSX_P, just test against VSX.\n ;; Don't use vsx_register_operand here, use gpc_reg_operand to match rs6000.md.\n (define_insn \"vsx_float<VSi><mode>2\"\n-  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n \t(float:VSX_B (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cvsx<VSc><VSs> %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_floatuns<VSi><mode>2\"\n-  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_B 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n \t(unsigned_float:VSX_B (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cvux<VSc><VSs> %x0,%x1\"\n@@ -1092,68 +1124,68 @@\n \n (define_insn \"vsx_fix_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n-\t(fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,wa\")))]\n+\t(fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>sx<VSc>s %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_fixuns_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n-\t(unsigned_fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,wa\")))]\n+\t(unsigned_fix:<VSI> (match_operand:VSX_B 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>ux<VSc>s %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n ;; Math rounding functions\n (define_insn \"vsx_x<VSv>r<VSs>i\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_VSX_ROUND_I))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>i %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_x<VSv>r<VSs>ic\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_VSX_ROUND_IC))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>ic %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_btrunc<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(fix:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")))]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(fix:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>iz %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"*vsx_b2trunc<mode>2\"\n-  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIZ))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>iz %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_floor<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIM))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>im %x0,%x1\"\n   [(set_attr \"type\" \"<VStype_simple>\")\n    (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n \n (define_insn \"vsx_ceil<mode>2\"\n-  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n-\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,wa\")]\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n+\t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIP))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>ip %x0,%x1\"\n@@ -1168,17 +1200,17 @@\n ;; scalar single precision instructions internally use the double format.\n ;; Prefer the altivec registers, since we likely will need to do a vperm\n (define_insn \"vsx_<VS_spdp_insn>\"\n-  [(set (match_operand:<VS_spdp_res> 0 \"vsx_register_operand\" \"=<VSr4>,?wa\")\n-\t(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 \"vsx_register_operand\" \"<VSr5>,wa\")]\n+  [(set (match_operand:<VS_spdp_res> 0 \"vsx_register_operand\" \"=<VSr4>,?<VSa>\")\n+\t(unspec:<VS_spdp_res> [(match_operand:VSX_SPDP 1 \"vsx_register_operand\" \"<VSr5>,<VSa>\")]\n \t\t\t      UNSPEC_VSX_CVSPDP))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"<VS_spdp_insn> %x0,%x1\"\n   [(set_attr \"type\" \"<VS_spdp_type>\")])\n \n ;; xscvspdp, represent the scalar SF type as V4SF\n (define_insn \"vsx_xscvspdp\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,?wa\")\n-\t(unspec:DF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")]\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws\")\n+\t(unspec:DF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa\")]\n \t\t   UNSPEC_VSX_CVSPDP))]\n   \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n   \"xscvspdp %x0,%x1\"\n@@ -1205,24 +1237,24 @@\n \n ;; ISA 2.07 xscvdpspn/xscvspdpn that does not raise an error on signalling NaNs\n (define_insn \"vsx_xscvdpspn\"\n-  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=ws,?wa\")\n+  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=ww,?ww\")\n \t(unspec:V4SF [(match_operand:DF 1 \"vsx_register_operand\" \"wd,wa\")]\n \t\t     UNSPEC_VSX_CVDPSPN))]\n   \"TARGET_XSCVDPSPN\"\n   \"xscvdpspn %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"vsx_xscvspdpn\"\n-  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,?wa\")\n-\t(unspec:DF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")]\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws,?ws\")\n+\t(unspec:DF [(match_operand:V4SF 1 \"vsx_register_operand\" \"wf,wa\")]\n \t\t   UNSPEC_VSX_CVSPDPN))]\n   \"TARGET_XSCVSPDPN\"\n   \"xscvspdpn %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"vsx_xscvdpspn_scalar\"\n-  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wa\")\n-\t(unspec:V4SF [(match_operand:SF 1 \"vsx_register_operand\" \"f\")]\n+  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wf,?wa\")\n+\t(unspec:V4SF [(match_operand:SF 1 \"vsx_register_operand\" \"ww,ww\")]\n \t\t     UNSPEC_VSX_CVDPSPN))]\n   \"TARGET_XSCVDPSPN\"\n   \"xscvdpspn %x0,%x1\"\n@@ -1310,10 +1342,10 @@\n ;; since the xsrdpiz instruction does not truncate the value if the floating\n ;; point value is < LONG_MIN or > LONG_MAX.\n (define_insn \"*vsx_float_fix_<mode>2\"\n-  [(set (match_operand:VSX_DF 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_DF 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(float:VSX_DF\n \t (fix:<VSI>\n-\t  (match_operand:VSX_DF 1 \"vsx_register_operand\" \"<VSr>,?wa\"))))]\n+\t  (match_operand:VSX_DF 1 \"vsx_register_operand\" \"<VSr>,?<VSa>\"))))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && VECTOR_UNIT_VSX_P (<MODE>mode) && flag_unsafe_math_optimizations\n    && !flag_trapping_math && TARGET_FRIZ\"\n@@ -1326,10 +1358,10 @@\n \n ;; Build a V2DF/V2DI vector from two scalars\n (define_insn \"vsx_concat_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSr>,?wa\")\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(vec_concat:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"vsx_register_operand\" \"ws,wa\")\n-\t (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"ws,wa\")))]\n+\t (match_operand:<VS_scalar> 1 \"vsx_register_operand\" \"ws,<VSa>\")\n+\t (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"ws,<VSa>\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   if (BYTES_BIG_ENDIAN)\n@@ -1360,18 +1392,18 @@\n ;; xxpermdi for little endian loads and stores.  We need several of\n ;; these since the form of the PARALLEL differs by mode.\n (define_insn \"*vsx_xxpermdi2_le_<mode>\"\n-  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=<VSa>\")\n         (vec_select:VSX_LE\n-          (match_operand:VSX_LE 1 \"vsx_register_operand\" \"wa\")\n+          (match_operand:VSX_LE 1 \"vsx_register_operand\" \"<VSa>\")\n           (parallel [(const_int 1) (const_int 0)])))]\n   \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"xxpermdi %x0,%x1,%x1,2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"*vsx_xxpermdi4_le_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=<VSa>\")\n         (vec_select:VSX_W\n-          (match_operand:VSX_W 1 \"vsx_register_operand\" \"wa\")\n+          (match_operand:VSX_W 1 \"vsx_register_operand\" \"<VSa>\")\n           (parallel [(const_int 2) (const_int 3)\n                      (const_int 0) (const_int 1)])))]\n   \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1409,7 +1441,7 @@\n ;; lxvd2x for little endian loads.  We need several of\n ;; these since the form of the PARALLEL differs by mode.\n (define_insn \"*vsx_lxvd2x2_le_<mode>\"\n-  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_LE 0 \"vsx_register_operand\" \"=<VSa>\")\n         (vec_select:VSX_LE\n           (match_operand:VSX_LE 1 \"memory_operand\" \"Z\")\n           (parallel [(const_int 1) (const_int 0)])))]\n@@ -1418,7 +1450,7 @@\n   [(set_attr \"type\" \"vecload\")])\n \n (define_insn \"*vsx_lxvd2x4_le_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=<VSa>\")\n         (vec_select:VSX_W\n           (match_operand:VSX_W 1 \"memory_operand\" \"Z\")\n           (parallel [(const_int 2) (const_int 3)\n@@ -1460,7 +1492,7 @@\n (define_insn \"*vsx_stxvd2x2_le_<mode>\"\n   [(set (match_operand:VSX_LE 0 \"memory_operand\" \"=Z\")\n         (vec_select:VSX_LE\n-          (match_operand:VSX_LE 1 \"vsx_register_operand\" \"wa\")\n+          (match_operand:VSX_LE 1 \"vsx_register_operand\" \"<VSa>\")\n           (parallel [(const_int 1) (const_int 0)])))]\n   \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"stxvd2x %x1,%y0\"\n@@ -1469,7 +1501,7 @@\n (define_insn \"*vsx_stxvd2x4_le_<mode>\"\n   [(set (match_operand:VSX_W 0 \"memory_operand\" \"=Z\")\n         (vec_select:VSX_W\n-          (match_operand:VSX_W 1 \"vsx_register_operand\" \"wa\")\n+          (match_operand:VSX_W 1 \"vsx_register_operand\" \"<VSa>\")\n           (parallel [(const_int 2) (const_int 3)\n                      (const_int 0) (const_int 1)])))]\n   \"!BYTES_BIG_ENDIAN && VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1521,11 +1553,12 @@\n \n ;; Set the element of a V2DI/VD2F mode\n (define_insn \"vsx_set_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?wa\")\n-\t(unspec:VSX_D [(match_operand:VSX_D 1 \"vsx_register_operand\" \"wd,wa\")\n-\t\t       (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"ws,wa\")\n-\t\t       (match_operand:QI 3 \"u5bit_cint_operand\" \"i,i\")]\n-\t\t      UNSPEC_VSX_SET))]\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?<VSa>\")\n+\t(unspec:VSX_D\n+\t [(match_operand:VSX_D 1 \"vsx_register_operand\" \"wd,<VSa>\")\n+\t  (match_operand:<VS_scalar> 2 \"vsx_register_operand\" \"<VS_64reg>,<VSa>\")\n+\t  (match_operand:QI 3 \"u5bit_cint_operand\" \"i,i\")]\n+\t UNSPEC_VSX_SET))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n {\n   int idx_first = BYTES_BIG_ENDIAN ? 0 : 1;\n@@ -1550,11 +1583,11 @@\n ;; Optimize cases were we can do a simple or direct move.\n ;; Or see if we can avoid doing the move at all\n (define_insn \"*vsx_extract_<mode>_internal1\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,ws,?wa,r\")\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,<VS_64reg>,r\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,wa,wm\")\n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,<VS_64reg>,<VS_64dm>\")\n \t (parallel\n-\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD,wD\")])))]\n+\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n {\n   int op0_regno = REGNO (operands[0]);\n@@ -1571,14 +1604,14 @@\n \n   return \"xxlor %x0,%x1,%x1\";\n }\n-  [(set_attr \"type\" \"fp,vecsimple,vecsimple,mftgpr\")\n+  [(set_attr \"type\" \"fp,vecsimple,mftgpr\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*vsx_extract_<mode>_internal2\"\n-  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=d,ws,ws,?wa\")\n+  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=d,<VS_64reg>,<VS_64reg>\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"vsx_register_operand\" \"d,wd,wd,wa\")\n-\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"wD,wD,i,i\")])))]\n+\t (match_operand:VSX_D 1 \"vsx_register_operand\" \"d,wd,wd\")\n+\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"wD,wD,i\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\n    && (!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE\n        || INTVAL (operands[2]) != VECTOR_ELEMENT_SCALAR_64BIT)\"\n@@ -1606,7 +1639,7 @@\n   operands[3] = GEN_INT (fldDM);\n   return \"xxpermdi %x0,%x1,%x1,%3\";\n }\n-  [(set_attr \"type\" \"fp,vecsimple,vecperm,vecperm\")\n+  [(set_attr \"type\" \"fp,vecsimple,vecperm\")\n    (set_attr \"length\" \"4\")])\n \n ;; Optimize extracting a single scalar element from memory if the scalar is in\n@@ -1629,7 +1662,7 @@\n (define_insn \"*vsx_extract_<mode>_store\"\n   [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=m,Z,?Z\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,wa\")\n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,<VSa>\")\n \t (parallel [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"@\n@@ -1643,7 +1676,7 @@\n (define_insn_and_split \"vsx_extract_v4sf\"\n   [(set (match_operand:SF 0 \"vsx_register_operand\" \"=f,f\")\n \t(vec_select:SF\n-\t (match_operand:V4SF 1 \"vsx_register_operand\" \"wa,wa\")\n+\t (match_operand:V4SF 1 \"vsx_register_operand\" \"<VSa>,<VSa>\")\n \t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"O,i\")])))\n    (clobber (match_scratch:V4SF 3 \"=X,0\"))]\n   \"VECTOR_UNIT_VSX_P (V4SFmode)\"\n@@ -1826,9 +1859,9 @@\n \n ;; V2DF/V2DI splat\n (define_insn \"vsx_splat_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,wd,wd,?wa,?wa,?wa\")\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,wd,wd,?<VSa>,?<VSa>,?<VSa>\")\n \t(vec_duplicate:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"splat_input_operand\" \"ws,f,Z,wa,wa,Z\")))]\n+\t (match_operand:<VS_scalar> 1 \"splat_input_operand\" \"<VS_64reg>,f,Z,<VSa>,<VSa>,Z\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"@\n    xxpermdi %x0,%x1,%x1,0\n@@ -1841,10 +1874,10 @@\n \n ;; V4SF/V4SI splat\n (define_insn \"vsx_xxspltw_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n \t(vec_duplicate:VSX_W\n \t (vec_select:<VS_scalar>\n-\t  (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,wa\")\n+\t  (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n \t  (parallel\n \t   [(match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]))))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1857,8 +1890,8 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"vsx_xxspltw_<mode>_direct\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?wa\")\n-        (unspec:VSX_W [(match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n+        (unspec:VSX_W [(match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n                        (match_operand:QI 2 \"u5bit_cint_operand\" \"i,i\")]\n                       UNSPEC_VSX_XXSPLTW))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1867,11 +1900,11 @@\n \n ;; V4SF/V4SI interleave\n (define_insn \"vsx_xxmrghw_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n         (vec_select:VSX_W\n \t  (vec_concat:<VS_double>\n-\t    (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,wa\")\n-\t    (match_operand:VSX_W 2 \"vsx_register_operand\" \"wf,wa\"))\n+\t    (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n+\t    (match_operand:VSX_W 2 \"vsx_register_operand\" \"wf,<VSa>\"))\n \t  (parallel [(const_int 0) (const_int 4)\n \t\t     (const_int 1) (const_int 5)])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1884,11 +1917,11 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n (define_insn \"vsx_xxmrglw_<mode>\"\n-  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?wa\")\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n \t(vec_select:VSX_W\n \t  (vec_concat:<VS_double>\n-\t    (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,wa\")\n-\t    (match_operand:VSX_W 2 \"vsx_register_operand\" \"wf,?wa\"))\n+\t    (match_operand:VSX_W 1 \"vsx_register_operand\" \"wf,<VSa>\")\n+\t    (match_operand:VSX_W 2 \"vsx_register_operand\" \"wf,?<VSa>\"))\n \t  (parallel [(const_int 2) (const_int 6)\n \t\t     (const_int 3) (const_int 7)])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n@@ -1902,9 +1935,9 @@\n \n ;; Shift left double by word immediate\n (define_insn \"vsx_xxsldwi_<mode>\"\n-  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=wa\")\n-\t(unspec:VSX_L [(match_operand:VSX_L 1 \"vsx_register_operand\" \"wa\")\n-\t\t       (match_operand:VSX_L 2 \"vsx_register_operand\" \"wa\")\n+  [(set (match_operand:VSX_L 0 \"vsx_register_operand\" \"=<VSa>\")\n+\t(unspec:VSX_L [(match_operand:VSX_L 1 \"vsx_register_operand\" \"<VSa>\")\n+\t\t       (match_operand:VSX_L 2 \"vsx_register_operand\" \"<VSa>\")\n \t\t       (match_operand:QI 3 \"u5bit_cint_operand\" \"i\")]\n \t\t      UNSPEC_VSX_SLDWI))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\""}, {"sha": "a2d5bd79371022217c911ab96f1c530224964ae2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59f5868d30d8ec3379b02db36b31c3fff121d724/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=59f5868d30d8ec3379b02db36b31c3fff121d724", "patch": "@@ -2132,6 +2132,18 @@ VSX vector register to hold vector float data or NO_REGS.\n @item wg\n If @option{-mmfpgpr} was used, a floating point register or NO_REGS.\n \n+@item wh\n+Floating point register if direct moves are available, or NO_REGS.\n+\n+@item wi\n+FP or VSX register to hold 64-bit integers or NO_REGS.\n+\n+@item wj\n+FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.\n+\n+@item wk\n+FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.\n+\n @item wl\n Floating point register if the LFIWAX instruction is enabled or NO_REGS.\n \n@@ -2163,7 +2175,7 @@ FP or VSX register to perform float operations under @option{-mvsx} or NO_REGS.\n Floating point register if the STFIWX instruction is enabled or NO_REGS.\n \n @item wy\n-VSX vector register to hold scalar float values or NO_REGS.\n+FP or VSX register to perform ISA 2.07 float ops or NO_REGS.\n \n @item wz\n Floating point register if the LFIWZX instruction is enabled or NO_REGS."}]}