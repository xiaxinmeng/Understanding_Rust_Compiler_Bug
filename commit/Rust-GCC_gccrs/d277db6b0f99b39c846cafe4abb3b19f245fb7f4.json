{"sha": "d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI3N2RiNmIwZjk5YjM5Yzg0NmNhZmU0YWJiM2IxOWYyNDVmYjdmNA==", "commit": {"author": {"name": "Wolfgang Gellerich", "email": "gellerich@de.ibm.com", "date": "2008-12-15T14:24:03Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-12-15T14:24:03Z"}, "message": "s390.c (s390_swap_cmp): New function.\n\n2008-12-15  Wolfgang Gellerich  <gellerich@de.ibm.com>\n\n\t* config/s390/s390.c (s390_swap_cmp): New function.\n\t(s390_non_addr_reg_read_p): New function.\n\t(s390_z10_optimize_cmp): New function.\n\t(s390_reorg): Added call to s390_optimize_cmp.\n\t* config/s390/s390.md (nop1): New insn.\n\nFrom-SVN: r142762", "tree": {"sha": "7e277a3c3fb3e1d051c6ab13c2d10111164e71c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e277a3c3fb3e1d051c6ab13c2d10111164e71c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/comments", "author": null, "committer": null, "parents": [{"sha": "d7fda78bf4273b7334197e393cf33fde971a72bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fda78bf4273b7334197e393cf33fde971a72bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fda78bf4273b7334197e393cf33fde971a72bb"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "de6eded788883b2b140323e87822425fd8aa3972", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "patch": "@@ -1,3 +1,11 @@\n+2008-12-15  Wolfgang Gellerich  <gellerich@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_swap_cmp): New function.\n+\t(s390_non_addr_reg_read_p): New function.\n+\t(s390_z10_optimize_cmp): New function.\n+\t(s390_reorg): Added call to s390_optimize_cmp.\n+\t* config/s390/s390.md (nop1): New insn.\n+\n 2008-12-12  Rainer Emrich  <r.emrich@de.tecosim.com>\n \n \tPR bootstrap/38383"}, {"sha": "7ad230ea3a98cdbc1cfa3f087b967eb4e8399b24", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "patch": "@@ -9589,6 +9589,104 @@ s390_optimize_prologue (void)\n     }\n }\n \n+\n+/* Exchange the two operands of COND, and swap its mask so that the\n+   semantics does not change.  */\n+static void \n+s390_swap_cmp (rtx cond)\n+{\n+  enum rtx_code code = swap_condition (GET_CODE (cond));\n+  rtx tmp = XEXP (cond, 0);\n+\n+  XEXP (cond, 0) = XEXP (cond, 1);\n+  XEXP (cond, 1) = tmp;\n+  PUT_CODE (cond, code);\n+}\n+\n+\n+/* Returns 1 if INSN reads the value of REG for purposes not related\n+   to addressing of memory, and 0 otherwise.  */\n+static int\n+s390_non_addr_reg_read_p (rtx reg, rtx insn)\n+{\n+  return reg_referenced_p (reg, PATTERN (insn))\n+    && !reg_used_in_mem_p (REGNO (reg), PATTERN (insn));\n+}\n+\n+\n+/* On z10, instructions of the compare-and-branch family have the\n+   property to access the register occurring as second operand with\n+   its bits complemented.  If such a compare is grouped with a second\n+   instruction that accesses the same register non-complemented, and\n+   if that register's value is delivered via a bypass, then the\n+   pipeline recycles, thereby causing significant performance decline.\n+   This function locates such situations and exchanges the two\n+   operands of the compare.  */\n+static void \n+s390_z10_optimize_cmp (void)\n+{\n+  rtx insn, prev_insn, next_insn;\n+  int added_NOPs = 0;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n+\tcontinue;\n+\n+      if (get_attr_z10prop (insn) == Z10PROP_Z10_COBRA)\n+\t{\n+\t  rtx op0, op1, pattern, jump_expr, cond;\n+\n+\t  /* Extract the comparison\ufffds condition and its operands.  */\n+\t  pattern = single_set (insn);\n+\t  gcc_assert (GET_CODE (pattern) == SET);\n+\t  jump_expr = XEXP (pattern, 1);\n+\t  gcc_assert (GET_CODE (jump_expr) == IF_THEN_ELSE);\n+\t  cond = XEXP (jump_expr, 0);\n+\t  op0 = XEXP (cond, 0);\n+\t  op1 = XEXP (cond, 1);\n+\n+\t  /* Swap the COMPARE\ufffds arguments and its mask if there is a\n+\t     conflicting access in the previous insn.  */\n+\t  prev_insn = PREV_INSN (insn);\n+          if (prev_insn != NULL_RTX && INSN_P (prev_insn) \n+              && reg_referenced_p (op1, PATTERN (prev_insn)))\n+\t    {\n+\t      s390_swap_cmp (cond);\n+   \t      op0 = XEXP (cond, 0);\n+\t      op1 = XEXP (cond, 1);\n+\t    }\n+\n+\t  /* Check if there is a conflict with the next insn. If there\n+\t     was no conflict with the previous insn, then swap the\n+\t     COMPARE\u00b4s arguments and its mask.  If we already swapped\n+\t     the operands, or if swapping them would cause a conflict\n+\t     with the previous insn, issue a NOP after the COMPARE in\n+\t     order to separate the two instuctions.  */\n+\t  next_insn = NEXT_INSN (insn);\n+          if (next_insn != NULL_RTX && INSN_P (next_insn) \n+              && s390_non_addr_reg_read_p (op1, next_insn))\n+            {\n+\t      if (s390_non_addr_reg_read_p (op0, prev_insn))\n+\t\t{\n+                  if (REGNO(op1) == 0)\n+\t\t    emit_insn_after (gen_nop1 (), insn);\n+                  else\n+\t\t    emit_insn_after (gen_nop (), insn);\n+                  added_NOPs = 1;\n+                }\n+\t      else\n+ \t        s390_swap_cmp (cond);\n+\t    }\n+\t}\n+    }\n+\n+  /* Adjust branches if we added new instructions.  */\n+  if (added_NOPs)\n+    shorten_branches (get_insns ());\n+}\n+\n+\n /* Perform machine-dependent processing.  */\n \n static void\n@@ -9698,6 +9796,11 @@ s390_reorg (void)\n \n   /* Try to optimize prologue and epilogue further.  */\n   s390_optimize_prologue ();\n+\n+  /* Eliminate z10-specific pipeline recycles related to some compare\n+     instructions.  */\n+  if (TARGET_Z10)\n+    s390_z10_optimize_cmp ();\n }\n \n "}, {"sha": "3df8755ba808977358d86f579c40a0b24ec6693e", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d277db6b0f99b39c846cafe4abb3b19f245fb7f4/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=d277db6b0f99b39c846cafe4abb3b19f245fb7f4", "patch": "@@ -8467,6 +8467,12 @@\n   \"lr\\t0,0\"\n   [(set_attr \"op_type\" \"RR\")])\n \n+(define_insn \"nop1\"\n+  [(const_int 1)]\n+  \"\"\n+  \"lr\\t1,1\"\n+  [(set_attr \"op_type\" \"RR\")])\n+\n \n ;\n ; Special literal pool access instruction pattern(s)."}]}