{"sha": "f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlYmRmYzUyYWVkNmY4ZTFmODMyYmZkMDU2YjhiZTkwYjIwMDllZA==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@cygnus.com", "date": "2000-01-14T02:01:21Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-01-14T02:01:21Z"}, "message": "predict.c: New file.\n\nThu Jan 13 14:46:03 2000  Jason Eckhardt  <jle@cygnus.com>\n                          Stan Cox  <scox@cygnus.com>\n\n\t* predict.c: New file. Preliminary infrastructure work for static\n\tbranch prediction and basic block reordering.\n\t* basic-block.h: Add prototype for estimate_probability.\n\t* Makefile.in: Add rules for predict.o.\n\nCo-Authored-By: Stan Cox <scox@cygnus.com>\n\nFrom-SVN: r31402", "tree": {"sha": "d79b4673d0ca33038a51be9706ab28638202e3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d79b4673d0ca33038a51be9706ab28638202e3ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/comments", "author": null, "committer": null, "parents": [{"sha": "91baa9184150434e144761ba1720a048c4b515f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91baa9184150434e144761ba1720a048c4b515f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91baa9184150434e144761ba1720a048c4b515f0"}], "stats": {"total": 159, "additions": 158, "deletions": 1}, "files": [{"sha": "31527b57fe51b4d5ad71faef221d345c1ef9f4ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "patch": "@@ -1,3 +1,11 @@\n+Thu Jan 13 14:46:03 2000  Jason Eckhardt  <jle@cygnus.com>\n+                          Stan Cox  <scox@cygnus.com>\n+\n+\t* predict.c: New file. Preliminary infrastructure work for static\n+\tbranch prediction and basic block reordering.\n+\t* basic-block.h: Add prototype for estimate_probability.\n+\t* Makefile.in: Add rules for predict.o.\n+\n 2000-01-13  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* fixincludes (va_list): Use __not_va_list__ for the dummy."}, {"sha": "bd7476402e58c6e5bb8d753193b2f625bc8c3b61", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "patch": "@@ -673,7 +673,7 @@ OBJS = diagnostic.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n- lists.o ggc-common.o $(GGC) simplify-rtx.o\n+ predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1620,6 +1620,9 @@ reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) $(RECOG_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n    varray.h function.h\n dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h\n+predict.o: predict.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n+   $(RECOG_H) insn-flags.h function.h except.h expr.h\n lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H) ggc.h\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) ggc.h \\"}, {"sha": "0b732f67425a5288985eba621b58e3125c6088d6", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "patch": "@@ -384,4 +384,7 @@ extern void compute_available\t\tPARAMS ((sbitmap *, sbitmap *,\n extern rtx emit_block_insn_after\tPARAMS ((rtx, rtx, basic_block));\n extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n \n+/* In predict.c */\n+extern void estimate_probability        PARAMS ((struct loops *));\n+\n #endif /* _BASIC_BLOCK_H */"}, {"sha": "1846b4a8f7cc4367fbb1281c247a977eb0cc7335", "filename": "gcc/predict.c", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=f1ebdfc52aed6f8e1f832bfd056b8be90b2009ed", "patch": "@@ -0,0 +1,143 @@\n+/* Branch prediction routines for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* References:\n+\n+   [1] \"Branch Prediction for Free\"\n+       Ball and Larus; PLDI '93.\n+   [2] \"Static Branch Frequency and Program Profile Analysis\"\n+       Wu and Larus; MICRO-27.\n+   [3] \"Corpus-based Static Branch Prediction\"\n+       Calder, Grunwald, Lindsay, Martin, Mozer, and Zorn; PLDI '95.\n+*/\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"insn-flags.h\"\n+#include \"expr.h\"\n+\n+\n+\n+/* Statically estimate the probability that a branch will be taken.\n+   ??? In the next revision there will be a number of other predictors added\n+   from the above references. Further, each heuristic will be factored out\n+   into its own function for clarity (and to facilitate the combination of\n+   predictions). */\n+\n+void\n+estimate_probability (loops_info)\n+     struct loops *loops_info;\n+{\n+  int i;\n+\n+  /* Try to predict out blocks in a loop that are not part of a natural loop */\n+  for (i = 0; i < loops_info->num; i++)\n+    {\n+      int j;\n+\n+      for (j = loops_info->array[i].header->index;\n+\t   j <= loops_info->array[i].latch->index;\n+\t   ++j)\n+\t{\n+\t  edge e;\n+\t  \n+\t  if (! TEST_BIT (loops_info->array[i].nodes, j))\n+\t    for (e = BASIC_BLOCK(j)->pred; e; e = e->pred_next)\n+\t      if (TEST_BIT (loops_info->array[i].nodes, e->src->index))\n+\t\t{\n+\t\t  rtx last_insn = BLOCK_END (e->src->index);\n+\t\t  rtx cond, earliest;\n+\n+\t\t  if (GET_CODE (last_insn) != JUMP_INSN\n+\t\t      || ! condjump_p (last_insn) || simplejump_p (last_insn))\n+\t\t    continue;\n+\t\t  cond = get_condition (last_insn, &earliest);\n+\t\t  if (!cond)\n+\t\t    continue;\n+\t\t  if (! find_reg_note (last_insn, REG_BR_PROB, 0))\n+\t\t    REG_NOTES (last_insn)\n+\t\t      = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (REG_BR_PROB_BASE),\n+\t\t\t\t\t   REG_NOTES (last_insn));\n+\t\t}\n+\t}\n+    }\n+\n+  /* Try to predict condjumps using same algorithm as mostly_true_jump */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      rtx last_insn = BLOCK_END (i);\n+      rtx cond, earliest;\n+      int prob = 0;\n+\n+      if (GET_CODE (last_insn) != JUMP_INSN\n+\t  || ! condjump_p (last_insn) || simplejump_p (last_insn))\n+\tcontinue;\n+      cond = get_condition (last_insn, &earliest);\n+      if (! cond)\n+\tcontinue;\n+      /* EQ tests are usually false and NE tests are usually true.  Also,\n+\t most quantities are positive, so we can make the appropriate guesses\n+\t about signed comparisons against zero.  */\n+      switch (GET_CODE (cond))\n+\t{\n+\tcase CONST_INT:\n+\t  /* Unconditional branch.  */\n+\t  prob = REG_BR_PROB_BASE / 2;\n+\tcase EQ:\n+\t  prob = REG_BR_PROB_BASE / 10;\n+\tcase NE:\n+\t  prob = REG_BR_PROB_BASE / 2;\n+\tcase LE:\n+\tcase LT:\n+\t  if (XEXP (cond, 1) == const0_rtx)\n+\t    prob = REG_BR_PROB_BASE / 10;\n+\t  break;\n+\tcase GE:\n+\tcase GT:\n+\t  if (XEXP (cond, 1) == const0_rtx\n+\t      || (GET_CODE (XEXP (cond, 1)) == CONST_INT\n+\t\t  && INTVAL (XEXP (cond, 1)) == -1))\n+\t    prob = REG_BR_PROB_BASE / 2;\n+\t  break;\n+\n+\tdefault:\n+\t  prob = 0;\n+\t}\n+      if (! find_reg_note (last_insn, REG_BR_PROB, 0))\n+\tREG_NOTES (last_insn)\n+\t  = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n+\t\t\t       REG_NOTES (last_insn));\n+    }\n+}\n+"}]}