{"sha": "8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjZTRkYmMwNjhlYzFjMmZhOWZmNjRmMDU3MGU1YzEwNzk0MDdhNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-28T03:01:20Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-28T03:01:20Z"}, "message": "Initial version of gdb hooks\n    \n    \t* MAINTAINERS (gdbhooks.py): Add myself as maintainer\n    \n    gcc/\n    \t* gdbhooks.py: New.\n    \t* configure.ac (gdbinit.in): Add import of gcc/gdbhooks.py.\n    \t* configure: Regenerate.\n\nFrom-SVN: r202040", "tree": {"sha": "c0b78765ca4c3a2f4d8521caa4232178bcbc6f38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0b78765ca4c3a2f4d8521caa4232178bcbc6f38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99236f3ae03ca0a9c9f779b0b745acb5a9881143", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99236f3ae03ca0a9c9f779b0b745acb5a9881143", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99236f3ae03ca0a9c9f779b0b745acb5a9881143"}], "stats": {"total": 410, "additions": 410, "deletions": 0}, "files": [{"sha": "2f8ddb7da40553ee4269f843b558eaa9c64ebad8", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -1,3 +1,7 @@\n+2013-08-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* MAINTAINERS (gdbhooks.py): Add myself as maintainer.\n+\n 2013-08-26  Caroline Tice  <cmtice@google.com>\n \n \t* MAINTAINERS:  Correct earliers update:  Move myself from libvtv"}, {"sha": "6d9a4cd3898e214852642848823821c0e21fca34", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -257,6 +257,7 @@ testsuite\t\tRainer Orth\t\tro@CeBiTec.Uni-Bielefeld.DE\n testsuite\t\tMike Stump\t\tmikestump@comcast.net\n testsuite\t\tJanis Johnson\t\tjanisjo@codesourcery.com\n register allocation\tVladimir Makarov\tvmakarov@redhat.com\n+gdbhooks.py\t\tDavid Malcolm\t\tdmalcolm@redhat.com\n \n Note that individuals who maintain parts of the compiler need approval to\n check in changes outside of the parts of the compiler they maintain."}, {"sha": "1657b44e374a57287c0162e3a7bab7175a9c70e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -1,3 +1,9 @@\n+2013-08-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gdbhooks.py: New.\n+\t* configure.ac (gdbinit.in): Add import of gcc/gdbhooks.py.\n+\t* configure: Regenerate.\n+\n 2013-08-27  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.h (ipa_pass_through_data): New field type_preserved."}, {"sha": "c6bc3a69d8408e72c93c8f3b039ba178c0a47866", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -27397,6 +27397,7 @@ if test \"x$subdirs\" != x; then\n \tdone\n fi\n echo \"source ${srcdir}/gdbinit.in\" >> .gdbinit\n+echo \"python import sys; sys.path.append('${srcdir}'); import gdbhooks\" >> .gdbinit\n \n gcc_tooldir='$(libsubdir)/$(libsubdir_to_prefix)$(target_noncanonical)'\n "}, {"sha": "5d3e5ad5823acd042d957fb190875ff83c568241", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -5181,6 +5181,7 @@ if test \"x$subdirs\" != x; then\n \tdone\n fi\n echo \"source ${srcdir}/gdbinit.in\" >> .gdbinit\n+echo \"python import sys; sys.path.append('${srcdir}'); import gdbhooks\" >> .gdbinit\n \n gcc_tooldir='$(libsubdir)/$(libsubdir_to_prefix)$(target_noncanonical)'\n AC_SUBST(gcc_tooldir)"}, {"sha": "3d69b11bfe95dac85d88b7f04372058eef44b2ae", "filename": "gcc/gdbhooks.py", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=8dce4dbc068ec1c2fa9ff64f0570e5c1079407a7", "patch": "@@ -0,0 +1,397 @@\n+# Python hooks for gdb for debugging GCC\n+# Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+# Contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\"\"\"\n+Enabling the debugging hooks\n+----------------------------\n+gcc/configure (from configure.ac) generates a .gdbinit within the \"gcc\"\n+subdirectory of the build directory, and when run by gdb, this imports\n+gcc/gdbhooks.py from the source directory, injecting useful Python code\n+into gdb.\n+\n+You may see a message from gdb of the form:\n+  \"path-to-build/gcc/.gdbinit\" auto-loading has been declined by your `auto-load safe-path'\n+as a protection against untrustworthy python scripts.  See\n+  http://sourceware.org/gdb/onlinedocs/gdb/Auto_002dloading-safe-path.html\n+\n+The fix is to mark the paths of the build/gcc directory as trustworthy.\n+An easy way to do so is by adding the following to your ~/.gdbinit script:\n+  add-auto-load-safe-path /absolute/path/to/build/gcc\n+for the build directories for your various checkouts of gcc.\n+\n+If it's working, you should see the message:\n+  Successfully loaded GDB hooks for GCC\n+as gdb starts up.\n+\n+During development, I've been manually invoking the code in this way, as a\n+precanned way of printing a variety of different kinds of value:\n+\n+  gdb \\\n+    -ex \"break expand_gimple_stmt\" \\\n+    -ex \"run\" \\\n+    -ex \"bt\" \\\n+    --args \\\n+      ./cc1 foo.c -O3\n+\n+Examples of output using the pretty-printers\n+--------------------------------------------\n+Pointer values are generally shown in the form:\n+  <type address extra_info>\n+\n+For example, an opt_pass* might appear as:\n+  (gdb) p pass\n+  $2 = <opt_pass* 0x188b600 \"expand\"(170)>\n+\n+The name of the pass is given (\"expand\"), together with the\n+static_pass_number.\n+\n+Note that you can dereference the pointer in the normal way:\n+  (gdb) p *pass\n+  $4 = {type = RTL_PASS, name = 0x120a312 \"expand\",\n+  [etc, ...snipped...]\n+\n+and you can suppress pretty-printers using /r (for \"raw\"):\n+  (gdb) p /r pass\n+  $3 = (opt_pass *) 0x188b600\n+\n+Basic blocks are shown with their index in parentheses, apart from the\n+CFG's entry and exit blocks, which are given as \"ENTRY\" and \"EXIT\":\n+  (gdb) p bb\n+  $9 = <basic_block 0x7ffff041f1a0 (2)>\n+  (gdb) p cfun->cfg->x_entry_block_ptr\n+  $10 = <basic_block 0x7ffff041f0d0 (ENTRY)>\n+  (gdb) p cfun->cfg->x_exit_block_ptr\n+  $11 = <basic_block 0x7ffff041f138 (EXIT)>\n+\n+CFG edges are shown with the src and dest blocks given in parentheses:\n+  (gdb) p e\n+  $1 = <edge 0x7ffff043f118 (ENTRY -> 6)>\n+\n+Tree nodes are printed using Python code that emulates print_node_brief,\n+running in gdb, rather than in the inferior:\n+  (gdb) p cfun->decl\n+  $1 = <function_decl 0x7ffff0420b00 foo>\n+For usability, the type is printed first (e.g. \"function_decl\"), rather\n+than just \"tree\".\n+\n+RTL expressions use a kludge: they are pretty-printed by injecting\n+calls into print-rtl.c into the inferior:\n+  Value returned is $1 = (note 9 8 10 [bb 3] NOTE_INSN_BASIC_BLOCK)\n+  (gdb) p $1\n+  $2 = (note 9 8 10 [bb 3] NOTE_INSN_BASIC_BLOCK)\n+  (gdb) p /r $1\n+  $3 = (rtx_def *) 0x7ffff043e140\n+This won't work for coredumps, and probably in other circumstances, but\n+it's a quick way of getting lots of debuggability quickly.\n+\n+Callgraph nodes are printed with the name of the function decl, if\n+available:\n+  (gdb) frame 5\n+  #5  0x00000000006c288a in expand_function (node=<cgraph_node* 0x7ffff0312720 \"foo\">) at ../../src/gcc/cgraphunit.c:1594\n+  1594\t  execute_pass_list (g->get_passes ()->all_passes);\n+  (gdb) p node\n+  $1 = <cgraph_node* 0x7ffff0312720 \"foo\">\n+\"\"\"\n+import re\n+\n+import gdb\n+import gdb.printing\n+import gdb.types\n+\n+# Convert \"enum tree_code\" (tree.def and tree.h) to a dict:\n+tree_code_dict = gdb.types.make_enum_dict(gdb.lookup_type('enum tree_code'))\n+\n+# ...and look up specific values for use later:\n+IDENTIFIER_NODE = tree_code_dict['IDENTIFIER_NODE']\n+TYPE_DECL = tree_code_dict['TYPE_DECL']\n+\n+# Similarly for \"enum tree_code_class\" (tree.h):\n+tree_code_class_dict = gdb.types.make_enum_dict(gdb.lookup_type('enum tree_code_class'))\n+tcc_type = tree_code_class_dict['tcc_type']\n+tcc_declaration = tree_code_class_dict['tcc_declaration']\n+\n+class Tree:\n+    \"\"\"\n+    Wrapper around a gdb.Value for a tree, with various methods\n+    corresponding to macros in gcc/tree.h\n+    \"\"\"\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def is_nonnull(self):\n+        return long(self.gdbval)\n+\n+    def TREE_CODE(self):\n+        \"\"\"\n+        Get gdb.Value corresponding to TREE_CODE (self)\n+        as per:\n+          #define TREE_CODE(NODE) ((enum tree_code) (NODE)->base.code)\n+        \"\"\"\n+        return self.gdbval['base']['code']\n+\n+    def DECL_NAME(self):\n+        \"\"\"\n+        Get Tree instance corresponding to DECL_NAME (self)\n+        \"\"\"\n+        return Tree(self.gdbval['decl_minimal']['name'])\n+\n+    def TYPE_NAME(self):\n+        \"\"\"\n+        Get Tree instance corresponding to result of TYPE_NAME (self)\n+        \"\"\"\n+        return Tree(self.gdbval['type_common']['name'])\n+\n+    def IDENTIFIER_POINTER(self):\n+        \"\"\"\n+        Get str correspoinding to result of IDENTIFIER_NODE (self)\n+        \"\"\"\n+        return self.gdbval['identifier']['id']['str'].string()\n+\n+class TreePrinter:\n+    \"Prints a tree\"\n+\n+    def __init__ (self, gdbval):\n+        self.gdbval = gdbval\n+        self.node = Tree(gdbval)\n+\n+    def to_string (self):\n+        # like gcc/print-tree.c:print_node_brief\n+        # #define TREE_CODE(NODE) ((enum tree_code) (NODE)->base.code)\n+        # tree_code_name[(int) TREE_CODE (node)])\n+        if long(self.gdbval) == 0:\n+            return '<tree 0x0>'\n+\n+        val_TREE_CODE = self.node.TREE_CODE()\n+\n+        # extern const enum tree_code_class tree_code_type[];\n+        # #define TREE_CODE_CLASS(CODE)\ttree_code_type[(int) (CODE)]\n+\n+        val_tree_code_type = gdb.parse_and_eval('tree_code_type')\n+        val_tclass = val_tree_code_type[val_TREE_CODE]\n+\n+        val_tree_code_name = gdb.parse_and_eval('tree_code_name')\n+        val_code_name = val_tree_code_name[long(val_TREE_CODE)]\n+        #print val_code_name.string()\n+\n+        result = '<%s 0x%x' % (val_code_name.string(), long(self.gdbval))\n+        if long(val_tclass) == tcc_declaration:\n+            tree_DECL_NAME = self.node.DECL_NAME()\n+            if tree_DECL_NAME.is_nonnull():\n+                 result += ' %s' % tree_DECL_NAME.IDENTIFIER_POINTER()\n+            else:\n+                pass # TODO: labels etc\n+        elif long(val_tclass) == tcc_type:\n+            tree_TYPE_NAME = Tree(self.gdbval['type_common']['name'])\n+            if tree_TYPE_NAME.is_nonnull():\n+                if tree_TYPE_NAME.TREE_CODE() == IDENTIFIER_NODE:\n+                    result += ' %s' % tree_TYPE_NAME.IDENTIFIER_POINTER()\n+                elif tree_TYPE_NAME.TREE_CODE() == TYPE_DECL:\n+                    if tree_TYPE_NAME.DECL_NAME().is_nonnull():\n+                        result += ' %s' % tree_TYPE_NAME.DECL_NAME().IDENTIFIER_POINTER()\n+        if self.node.TREE_CODE() == IDENTIFIER_NODE:\n+            result += ' %s' % self.node.IDENTIFIER_POINTER()\n+        # etc\n+        result += '>'\n+        return result\n+\n+######################################################################\n+# Callgraph pretty-printers\n+######################################################################\n+\n+class CGraphNodePrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        result = '<cgraph_node* 0x%x' % long(self.gdbval)\n+        if long(self.gdbval):\n+            # symtab_node_name calls lang_hooks.decl_printable_name\n+            # default implementation (lhd_decl_printable_name) is:\n+            #    return IDENTIFIER_POINTER (DECL_NAME (decl));\n+            symbol = self.gdbval['symbol']\n+            tree_decl = Tree(symbol['decl'])\n+            result += ' \"%s\"' % tree_decl.DECL_NAME().IDENTIFIER_POINTER()\n+        result += '>'\n+        return result\n+\n+######################################################################\n+\n+class GimplePrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        if long(self.gdbval) == 0:\n+            return '<gimple 0x0>'\n+        val_gimple_code = self.gdbval['gsbase']['code']\n+        val_gimple_code_name = gdb.parse_and_eval('gimple_code_name')\n+        val_code_name = val_gimple_code_name[long(val_gimple_code)]\n+        result = '<%s 0x%x' % (val_code_name.string(),\n+                               long(self.gdbval))\n+        result += '>'\n+        return result\n+\n+######################################################################\n+# CFG pretty-printers\n+######################################################################\n+\n+def bb_index_to_str(index):\n+    if index == 0:\n+        return 'ENTRY'\n+    elif index == 1:\n+        return 'EXIT'\n+    else:\n+        return '%i' % index\n+\n+class BasicBlockPrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        result = '<basic_block 0x%x' % long(self.gdbval)\n+        if long(self.gdbval):\n+            result += ' (%s)' % bb_index_to_str(long(self.gdbval['index']))\n+        result += '>'\n+        return result\n+\n+class CfgEdgePrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        result = '<edge 0x%x' % long(self.gdbval)\n+        if long(self.gdbval):\n+            src = bb_index_to_str(long(self.gdbval['src']['index']))\n+            dest = bb_index_to_str(long(self.gdbval['dest']['index']))\n+            result += ' (%s -> %s)' % (src, dest)\n+        result += '>'\n+        return result\n+\n+######################################################################\n+\n+class Rtx:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def GET_CODE(self):\n+        return self.gdbval['code']\n+\n+def GET_RTX_LENGTH(code):\n+    val_rtx_length = gdb.parse_and_eval('rtx_length')\n+    return long(val_rtx_length[code])\n+\n+def GET_RTX_NAME(code):\n+    val_rtx_name = gdb.parse_and_eval('rtx_name')\n+    return val_rtx_name[code].string()\n+\n+def GET_RTX_FORMAT(code):\n+    val_rtx_format = gdb.parse_and_eval('rtx_format')\n+    return val_rtx_format[code].string()\n+\n+class RtxPrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+        self.rtx = Rtx(gdbval)\n+\n+    def to_string (self):\n+        \"\"\"\n+        For now, a cheap kludge: invoke the inferior's print\n+        function to get a string to use the user, and return an empty\n+        string for gdb\n+        \"\"\"\n+        # We use print_inline_rtx to avoid a trailing newline\n+        gdb.execute('call print_inline_rtx (stderr, (const_rtx) %s, 0)'\n+                    % long(self.gdbval))\n+        return ''\n+\n+        # or by hand; based on gcc/print-rtl.c:print_rtx\n+        result = ('<rtx_def 0x%x'\n+                  % (long(self.gdbval)))\n+        code = self.rtx.GET_CODE()\n+        result += ' (%s' % GET_RTX_NAME(code)\n+        format_ = GET_RTX_FORMAT(code)\n+        for i in range(GET_RTX_LENGTH(code)):\n+            print format_[i]\n+        result += ')>'\n+        return result\n+\n+######################################################################\n+\n+class PassPrinter:\n+    def __init__(self, gdbval):\n+        self.gdbval = gdbval\n+\n+    def to_string (self):\n+        result = '<opt_pass* 0x%x' % long(self.gdbval)\n+        if long(self.gdbval):\n+            result += (' \"%s\"(%i)'\n+                       % (self.gdbval['name'].string(),\n+                          long(self.gdbval['static_pass_number'])))\n+        result += '>'\n+        return result\n+\n+######################################################################\n+\n+# TODO:\n+#   * vec\n+#   * hashtab\n+#   * location_t\n+\n+class GdbSubprinter(gdb.printing.SubPrettyPrinter):\n+    def __init__(self, name, str_type_, class_):\n+        super(GdbSubprinter, self).__init__(name)\n+        self.str_type_ = str_type_\n+        self.class_ = class_\n+\n+class GdbPrettyPrinters(gdb.printing.PrettyPrinter):\n+    def __init__(self, name):\n+        super(GdbPrettyPrinters, self).__init__(name, [])\n+\n+    def add_printer(self, name, exp, class_):\n+        self.subprinters.append(GdbSubprinter(name, exp, class_))\n+\n+    def __call__(self, gdbval):\n+        type_ = gdbval.type.unqualified()\n+        str_type_ = str(type_)\n+        for printer in self.subprinters:\n+            if printer.enabled and str_type_ == printer.str_type_:\n+                return printer.class_(gdbval)\n+\n+        # Couldn't find a pretty printer (or it was disabled):\n+        return None\n+\n+\n+def build_pretty_printer():\n+    pp = GdbPrettyPrinters('gcc')\n+    pp.add_printer('tree', 'tree', TreePrinter)\n+    pp.add_printer('cgraph_node', 'cgraph_node *', CGraphNodePrinter)\n+    pp.add_printer('gimple', 'gimple', GimplePrinter)\n+    pp.add_printer('basic_block', 'basic_block', BasicBlockPrinter)\n+    pp.add_printer('edge', 'edge', CfgEdgePrinter)\n+    pp.add_printer('rtx_def', 'rtx_def *', RtxPrinter)\n+    pp.add_printer('opt_pass', 'opt_pass *', PassPrinter)\n+    return pp\n+\n+gdb.printing.register_pretty_printer(\n+    gdb.current_objfile(),\n+    build_pretty_printer())\n+\n+print('Successfully loaded GDB hooks for GCC')"}]}