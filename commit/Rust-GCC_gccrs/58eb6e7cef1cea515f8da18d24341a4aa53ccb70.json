{"sha": "58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThlYjZlN2NlZjFjZWE1MTVmOGRhMThkMjQzNDFhNGFhNTNjY2I3MA==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1999-08-08T14:06:23Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1999-08-08T14:06:23Z"}, "message": "[multiple changes]\n\n1999-08-09  Anthony Green  <green@cygnus.com>\n\n        * gij.cc: New file.\n\n        * include/config.h.in: Rebuilt.\n        * acconfig.h: Add INTERPRETER.\n\n        * configure: Rebuilt.\n\n        * Makefile.in: Rebuilt.\n        * Makefile.am (libffi_files): Identify the libffi object files for\n        inclusion in libgcj.\n        (LIBFFIINCS): Define.\n\n        * interpret.cc (gnu::gcj::runtime::MethodInvocation::continue1):\n        Dummy definition for configurations without an interpreter.\n\n        * java/net/natPlainSocketImpl.cc (getOption): Disamiguate call to\n        java::lang::Boolean constructor.\n\n        * include/java-interp.h: Always include java-cpool.h.\n\n        * java/lang/natClassLoader.cc (getVMClassLoader0): Always return 0\n        when INTERPRETER not defined.\n\n        * java/lang/Class.h (finalize): Define.\n\n        * gnu/gcj/util/path/DirectoryPathEntry.java (getURL): Catch\n        IOException from File.getCanonicalPath.\n        (getStream): Likewise.\n\n        * NEWS: More news.\n        * THANKS: More thanks.\n\n1999-08-09  Kresten Krab Thorup  <krab@gnu.org>\n\n        * resolve.cc (get_ffi_type_from_signature): Generate uint16 for\n        jchar type.\n        (_Jv_PrepareClass): Allow non-abstract classes to\n        have abstract subclasses.\n        (_Jv_ResolvePoolEntry): Revert subclass check for protected\n        fields and methods.\n        * interpret.cc (continue1/perform_invoke): Don't sign extend\n        uint16 return val.\n        (continue1/lshl,lshr): Push long, not int.\n        (continue1/ulshr): Use UINT64, not long long.\n        * defineclass.cc (handleFieldsEnd): Handle case when all fields\n        are static.\n        * java/lang/natClass.cc (forName): Add call to _Jv_InitClass.\n        * java/lang/FirstThread.java (run): Add top-level exception\n        handler.\n        (run0): Renamed from run.\n\n1999-08-08  Kresten Krab Thorup  <krab@gnu.org>\n\n        * configure.in (--with-interpreter): Added.\n        * include/config.h.in (INTERPRETER): Added.\n\n        * java/lang/ClassLoader.java: File replaced.\n        * java/lang/VMClassLoader.java: New file.\n        * java/lang/natClassLoader.cc: New file.\n        * gnu/gcj/runtime/MethodInvocation.java: New file.\n        * gnu/gcj/util/path/SearchPath.java: New file.\n        * gnu/gcj/util/path/PathEntry.java: New file.\n        * gnu/gcj/util/path/DirectoryPathEntry.java: New file.\n        * gnu/gcj/util/path/ZipPathEntry.java: New file.\n        * gnu/gcj/util/path/URLPathEntry.java: New file.\n        * gnu/gcj/util/path/CacheEntry.java: New file.\n        * include/java-interp.h: New file.\n        * include/java-cpool.h: New file.\n        * include/java-insns.h: New file.\n        * defineclass.cc: New file.\n        * interpret.cc: New file.\n        * resolve.cc: New file.\n\n        * java/lang/natClass.cc (loaded_classes, _Jv_RegisterClass,\n        _Jv_RegisterClasses, _Jv_FindClassInCache, _Jv_FindClass,\n        _Jv_NewClass, _Jv_FindArrayClass): Moved to natClassLoader.cc.\n        (finalize): New.\n        (STATE_NOTHING, STATE_RESOLVED, STATE_IN_PROGRESS, STATE_DONE,\n        STATE_ERROR): Moved to java/lang/Class.h and renamed with JV_\n        prefix.\n        (initializeClass): Use new JV_ prefixed names.  Also, call\n        ClassLoader::resolveClass instead of _Jv_ResolveClass.\n\n        * java/lang/Class.h (JV_STATE_PRELOADING, JV_STATE_LOADING,\n        JV_STATE_LOADED, JV_STATE_COMPILED, JV_STATE_PREPARED,\n        JV_STATE_LINKED): New.\n        (_Jv_WaitForState, _Jv_RegisterInitiatingLoader,\n        _Jv_UnregisterClass, _Jv_InternClassStrings): New friends.\n        (_Jv_IsInterpretedClass, _Jv_InitField, _Jv_LookupDeclaredMethod,\n        _Jv_DetermineVTableIndex, _Jv_ResolvePoolEntry, _Jv_PrepareClass,\n        _Jv_ClassReader, _Jv_InterpClass, _Jv_InterpMethod,\n        _Jv_InterpMethodInvocation): New friends for interpreter.\n        (finalize): New.\n        (CONSTANT_Class, CONSTANT_String, etc.): Moved to\n        include/java-cpool.h and renamed with JV_ prefix.\n\n        * include/jvm.h (_Jv_makeUtf8Const, _Jv_makeUtf8TypeConst): New\n        decls.\n        (_Jv_UnregisterClass): New decl.\n\n        * java/lang/natClassLoader.cc (_Jv_FindArrayClass): Added\n        class loader argument.\n        (_Jv_FindClass): Use class loader.\n\n        * prims.cc (_Jv_makeUtf8Const): New function.\n        (_Jv_NewObjectArray): Change use of _Jv_FindArrayClass.\n        (_Jv_NewPrimArray): Ditto.\n        (_Jv_FindClassFromSignature): Ditto.\n        * java/lang/reflect/natArray.cc (newInstance): Ditto.\n        * java/lang/reflect/natMethod.cc (getType): Ditto.\n\n        * include/java-field.h (_Jv_Field::isRef): Make robust for\n        non-resolved contexts.\n\n        * boehm.cc (_Jv_MarkObj): Mark interpreter-related fields.\n        Also, don't mark class->next field.\n\n        * java/lang/VirtualMachineError.java: Added FIXME note.\n\n        * configure.in (INTERPSPEC): New spec.\n        * libgcj.spec.in: Added INTERPSPEC.\n        * Makefile.am: Added gcjh friends for java/lang/VMClassLoader and\n        gnu/gcj/runtime/MethodInvocation.\n        (libgcj_la_SOURCES): Added resolve.cc defineclass.cc interpret.cc.\n        (ordinary_java_source_files): Added above mentioned java classes.\n\n        * configure: Rebuilt.\n        * Makefile.in: Rebuilt.\n\nFrom-SVN: r28597", "tree": {"sha": "277498eeeff558237a9cd88b0ea8b3788b31d645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/277498eeeff558237a9cd88b0ea8b3788b31d645"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/comments", "author": null, "committer": null, "parents": [{"sha": "63e5e3e0dbb7207e95c0437499b980a304665589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e5e3e0dbb7207e95c0437499b980a304665589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e5e3e0dbb7207e95c0437499b980a304665589"}], "stats": {"total": 8927, "additions": 8335, "deletions": 592}, "files": [{"sha": "24051fcdc4807064bc68e7d9418cb3d3c7e02be0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -1,3 +1,132 @@\n+1999-08-09  Anthony Green  <green@cygnus.com>\n+\n+\t* gij.cc: New file.\n+\n+\t* include/config.h.in: Rebuilt.\n+\t* acconfig.h: Add INTERPRETER.\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (libffi_files): Identify the libffi object files for\n+\tinclusion in libgcj.\n+\t(LIBFFIINCS): Define.\n+\n+\t* interpret.cc (gnu::gcj::runtime::MethodInvocation::continue1):\n+\tDummy definition for configurations without an interpreter.\n+\t\n+\t* java/net/natPlainSocketImpl.cc (getOption): Disamiguate call to\n+\tjava::lang::Boolean constructor.\n+\n+\t* include/java-interp.h: Always include java-cpool.h.\n+\n+\t* java/lang/natClassLoader.cc (getVMClassLoader0): Always return 0\n+\twhen INTERPRETER not defined.\n+\n+\t* java/lang/Class.h (finalize): Define.\n+\n+\t* gnu/gcj/util/path/DirectoryPathEntry.java (getURL): Catch\n+\tIOException from File.getCanonicalPath.\n+\t(getStream): Likewise.\n+\n+\t* NEWS: More news.\n+\t* THANKS: More thanks.\n+\n+1999-08-09  Kresten Krab Thorup  <krab@gnu.org>\n+\n+\t* resolve.cc (get_ffi_type_from_signature): Generate uint16 for\n+\tjchar type.\n+\t(_Jv_PrepareClass): Allow non-abstract classes to\n+\thave abstract subclasses.\n+\t(_Jv_ResolvePoolEntry): Revert subclass check for protected\n+\tfields and methods.\n+\t* interpret.cc (continue1/perform_invoke): Don't sign extend\n+\tuint16 return val. \n+\t(continue1/lshl,lshr): Push long, not int.\n+\t(continue1/ulshr): Use UINT64, not long long.\n+ \t* defineclass.cc (handleFieldsEnd): Handle case when all fields\n+\tare static.\n+\t* java/lang/natClass.cc (forName): Add call to _Jv_InitClass.\n+ \t* java/lang/FirstThread.java (run): Add top-level exception\n+\thandler. \n+\t(run0): Renamed from run.\n+\n+1999-08-08  Kresten Krab Thorup  <krab@gnu.org>\n+ \n+ \t* configure.in (--with-interpreter): Added.\n+ \t* include/config.h.in (INTERPRETER): Added.\n+ \n+ \t* java/lang/ClassLoader.java: File replaced.\n+ \t* java/lang/VMClassLoader.java: New file.\n+ \t* java/lang/natClassLoader.cc: New file.\n+ \t* gnu/gcj/runtime/MethodInvocation.java: New file.\n+ \t* gnu/gcj/util/path/SearchPath.java: New file.\n+ \t* gnu/gcj/util/path/PathEntry.java: New file.\n+ \t* gnu/gcj/util/path/DirectoryPathEntry.java: New file.\n+ \t* gnu/gcj/util/path/ZipPathEntry.java: New file.\n+ \t* gnu/gcj/util/path/URLPathEntry.java: New file.\n+ \t* gnu/gcj/util/path/CacheEntry.java: New file. \n+ \t* include/java-interp.h: New file.\n+ \t* include/java-cpool.h: New file.\n+ \t* include/java-insns.h: New file.\n+ \t* defineclass.cc: New file.\n+ \t* interpret.cc: New file.\n+ \t* resolve.cc: New file.\n+ \n+ \t* java/lang/natClass.cc (loaded_classes, _Jv_RegisterClass,\n+ \t_Jv_RegisterClasses, _Jv_FindClassInCache, _Jv_FindClass,\n+ \t_Jv_NewClass, _Jv_FindArrayClass): Moved to natClassLoader.cc.\n+ \t(finalize): New.\n+ \t(STATE_NOTHING, STATE_RESOLVED, STATE_IN_PROGRESS, STATE_DONE,\n+ \tSTATE_ERROR): Moved to java/lang/Class.h and renamed with JV_\n+ \tprefix. \n+ \t(initializeClass): Use new JV_ prefixed names.  Also, call\n+ \tClassLoader::resolveClass instead of _Jv_ResolveClass.\n+ \t\t\n+ \t* java/lang/Class.h (JV_STATE_PRELOADING, JV_STATE_LOADING,\n+ \tJV_STATE_LOADED, JV_STATE_COMPILED, JV_STATE_PREPARED,\n+ \tJV_STATE_LINKED): New.\n+ \t(_Jv_WaitForState, _Jv_RegisterInitiatingLoader,\n+ \t_Jv_UnregisterClass, _Jv_InternClassStrings): New friends.\n+ \t(_Jv_IsInterpretedClass, _Jv_InitField, _Jv_LookupDeclaredMethod,\n+ \t_Jv_DetermineVTableIndex, _Jv_ResolvePoolEntry, _Jv_PrepareClass,\n+ \t_Jv_ClassReader, _Jv_InterpClass, _Jv_InterpMethod,\n+ \t_Jv_InterpMethodInvocation): New friends for interpreter.\n+ \t(finalize): New.\n+ \t(CONSTANT_Class, CONSTANT_String, etc.): Moved to\n+ \tinclude/java-cpool.h and renamed with JV_ prefix.\n+ \t\n+ \t* include/jvm.h (_Jv_makeUtf8Const, _Jv_makeUtf8TypeConst): New\n+ \tdecls.\n+ \t(_Jv_UnregisterClass): New decl.\n+ \n+ \t* java/lang/natClassLoader.cc (_Jv_FindArrayClass): Added\n+ \tclass loader argument. \n+ \t(_Jv_FindClass): Use class loader.\n+ \t\n+ \t* prims.cc (_Jv_makeUtf8Const): New function.\n+ \t(_Jv_NewObjectArray): Change use of _Jv_FindArrayClass.\n+ \t(_Jv_NewPrimArray): Ditto.\n+ \t(_Jv_FindClassFromSignature): Ditto.\n+ \t* java/lang/reflect/natArray.cc (newInstance): Ditto.\n+ \t* java/lang/reflect/natMethod.cc (getType): Ditto.\n+ \n+ \t* include/java-field.h (_Jv_Field::isRef): Make robust for\n+ \tnon-resolved contexts. \n+ \n+ \t* boehm.cc (_Jv_MarkObj): Mark interpreter-related fields. \n+ \tAlso, don't mark class->next field.\n+ \n+ \t* java/lang/VirtualMachineError.java: Added FIXME note.\n+ \n+ \t* configure.in (INTERPSPEC): New spec.\n+ \t* libgcj.spec.in: Added INTERPSPEC.\n+ \t* Makefile.am: Added gcjh friends for java/lang/VMClassLoader and\n+ \tgnu/gcj/runtime/MethodInvocation.\n+ \t(libgcj_la_SOURCES): Added resolve.cc defineclass.cc interpret.cc.\n+ \t(ordinary_java_source_files): Added above mentioned java classes.\n+ \n+ \t* configure: Rebuilt.\n+ \t* Makefile.in: Rebuilt.\n+\n 1999-08-06  Tom Tromey  <tromey@cygnus.com>\n \n \t* configure: Rebuilt."}, {"sha": "83217c894923fab09b70a138dbda61e02d85a1a9", "filename": "libjava/Makefile.am", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -27,7 +27,7 @@ data_DATA = libgcj.zip\n \n ## For now, only on native systems.\n if NATIVE\n-bin_PROGRAMS = jv-convert\n+bin_PROGRAMS = jv-convert gij\n endif\n \n ## ################################################################\n@@ -77,8 +77,10 @@ endif\n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n \n+LIBFFIINCS = -I$(top_srcdir)/../libffi/include -I../libffi/include\n+\n INCLUDES = -Iinclude -I$(top_srcdir)/include $(GCINCS) $(THREADINCS) \\\n-\t$(EH_COMMON_INCLUDE) $(ZINCS)\n+\t$(EH_COMMON_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n \n DIVIDESPEC = @DIVIDESPEC@\n \n@@ -97,13 +99,17 @@ c_files = $(c_source_files:.c=.lo)\n javao_files = $(java_source_files:.java=.lo) \\\n \t$(built_java_source_files:.java=.lo)\n \n-libgcj_la_SOURCES = prims.cc jni.cc exception.cc\n+## Extract the libffi object file names.\n+libffi_files = `$(AR) t ../libffi/.libs/libffi.a 2>/dev/null | sed 's/\\.o/\\.lo/g' | sed 's/^/..\\/libffi\\//g'`\n+\n+libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n+\tresolve.cc defineclass.cc interpret.cc\n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \t$(c_source_files) $(java_source_files) $(built_java_source_files)\n libgcj_la_DEPENDENCIES = libgcj.zip $(javao_files) $(nat_files) \\\n \t$(c_files) $(GCOBJS) $(THREADOBJS)\n libgcj_la_LIBADD = $(javao_files) $(nat_files) $(c_files) $(GCOBJS) \\\n-\t$(THREADOBJS)\n+\t$(THREADOBJS) $(libffi_files)\n libgcj_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n ## The mysterious backslash is consumed by make.\n \t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n@@ -230,6 +236,16 @@ java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n \t    -friend 'java::lang::Class;' \\\n \t    $(basename $<)\n \n+java/lang/VMClassLoader.h: java/lang/VMClassLoader.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'java::lang::ClassLoader;' \\\n+\t    $(basename $<)\n+\n+gnu/gcj/runtime/MethodInvocation.h: gnu/gcj/runtime/MethodInvocation.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'class _Jv_InterpMethod;' \\\n+\t    $(basename $<)\n+\n \n ## ################################################################\n \n@@ -299,6 +315,26 @@ jv_convert_LDADD = $(convert_source_files:.java=.lo) libgcj.la \\\n jv_convert_DEPENDENCIES = $(convert_source_files:.java=.lo) \\\n \t$(GCDEPS) $(THREADDEPS) $(ZDEPS) libgcj.la libgcj.spec\n \n+gij_SOURCES =\n+EXTRA_gij_SOURCES = gij.cc\n+## We need -nodefaultlibs because we want to avoid gcj's `-lgcj'.  We\n+## need this because we are explicitly using libtool to link using the\n+## `.la' file.\n+gij_LDFLAGS = -rpath $(toolexeclibdir)\n+gij_LINK = $(LIBTOOL) --mode=link $(GCJ) $(JC1FLAGS) $(LDFLAGS) \\\n+\t-o gij\n+## We explicitly link in the libraries we need.  This way we don't\n+## need -nodefaultlibs, so we can still rely on gcj picking up the\n+## system libraries we need (via the specs file).\n+## We need the -L so that gcj can find libgcj with `-lgcj'.\n+## FIXME: should be _libs on some systems.\n+gij_LDADD = gij.lo libgcj.la \\\n+\t$(GCLIBS) $(THREADLIBS) $(ZLIBS) -L$(here)/.libs\n+## Depend on the spec file to make sure it is up to date before\n+## linking this program.\n+gij_DEPENDENCIES = gij.lo \\\n+\t$(GCDEPS) $(THREADDEPS) $(ZDEPS) libgcj.la libgcj.spec\n+\n # The Unicode consortium does not permit re-distributing the file JIS0201.TXT.\n # You can get it from ftp://ftp.unicode.org/Public/MAPPINGS/EASTASIA/JIS/.\n \n@@ -444,6 +480,13 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ## convert_source_files.  If the .java file has a hand-maintained\n ## header, please list it in special_java_source_files.\n ordinary_java_source_files =  $(convert_source_files) \\\n+gnu/gcj/runtime/MethodInvocation.java \\\n+gnu/gcj/util/path/SearchPath.java \\\n+gnu/gcj/util/path/PathEntry.java \\\n+gnu/gcj/util/path/DirectoryPathEntry.java \\\n+gnu/gcj/util/path/ZipPathEntry.java \\\n+gnu/gcj/util/path/URLPathEntry.java \\\n+gnu/gcj/util/path/CacheEntry.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n@@ -522,6 +565,7 @@ java/lang/ClassCastException.java \\\n java/lang/ClassCircularityError.java \\\n java/lang/ClassFormatError.java\t\\\n java/lang/ClassLoader.java \\\n+java/lang/VMClassLoader.java \\\n java/lang/ClassNotFoundException.java \\\n java/lang/CloneNotSupportedException.java \\\n java/lang/Cloneable.java \\\n@@ -719,6 +763,7 @@ java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\\n+java/lang/natClassLoader.cc \\\n java/lang/natConcreteProcess.cc \\\n java/lang/natDouble.cc \\\n java/lang/natFirstThread.cc \\"}, {"sha": "c03c3223311b2db12c9b23ae6342204b64c61618", "filename": "libjava/Makefile.in", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -78,6 +78,7 @@ GCINCS = @GCINCS@\n GCLIBS = @GCLIBS@\n GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n+INTERPSPEC = @INTERPSPEC@\n LD = @LD@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n@@ -120,7 +121,7 @@ toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n @NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert\n+@NATIVE_TRUE@jv-convert gij\n @CANADIAN_TRUE@@NULL_TARGET_TRUE@GCJ = \\\n @CANADIAN_TRUE@@NULL_TARGET_TRUE@gcj\n @CANADIAN_TRUE@@NULL_TARGET_FALSE@GCJ = \\\n@@ -156,8 +157,10 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks @LIBGCJ_CXXFLAGS@ $(WARNINGS)\n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n \n+LIBFFIINCS = -I$(top_srcdir)/../libffi/include -I../libffi/include\n+\n INCLUDES = -Iinclude -I$(top_srcdir)/include $(GCINCS) $(THREADINCS) \\\n-\t$(EH_COMMON_INCLUDE) $(ZINCS)\n+\t$(EH_COMMON_INCLUDE) $(ZINCS) $(LIBFFIINCS)\n \n \n DIVIDESPEC = @DIVIDESPEC@\n@@ -168,15 +171,19 @@ javao_files = $(java_source_files:.java=.lo) \\\n \t$(built_java_source_files:.java=.lo)\n \n \n-libgcj_la_SOURCES = prims.cc jni.cc exception.cc\n+libffi_files = `$(AR) t ../libffi/.libs/libffi.a 2>/dev/null | sed 's/\\.o/\\.lo/g' | sed 's/^/..\\/libffi\\//g'`\n+\n+libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n+\tresolve.cc defineclass.cc interpret.cc\n+\n EXTRA_libgcj_la_SOURCES = boehm.cc nogc.cc posix-threads.cc no-threads.cc \\\n \t$(c_source_files) $(java_source_files) $(built_java_source_files)\n \n libgcj_la_DEPENDENCIES = libgcj.zip $(javao_files) $(nat_files) \\\n \t$(c_files) $(GCOBJS) $(THREADOBJS)\n \n libgcj_la_LIBADD = $(javao_files) $(nat_files) $(c_files) $(GCOBJS) \\\n-\t$(THREADOBJS)\n+\t$(THREADOBJS) $(libffi_files)\n \n libgcj_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n \t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n@@ -217,6 +224,19 @@ jv_convert_DEPENDENCIES = $(convert_source_files:.java=.lo) \\\n \t$(GCDEPS) $(THREADDEPS) $(ZDEPS) libgcj.la libgcj.spec\n \n \n+gij_SOURCES = \n+EXTRA_gij_SOURCES = gij.cc\n+gij_LDFLAGS = -rpath $(toolexeclibdir)\n+gij_LINK = $(LIBTOOL) --mode=link $(GCJ) $(JC1FLAGS) $(LDFLAGS) \\\n+\t-o gij\n+\n+gij_LDADD = gij.lo libgcj.la \\\n+\t$(GCLIBS) $(THREADLIBS) $(ZLIBS) -L$(here)/.libs\n+\n+gij_DEPENDENCIES = gij.lo \\\n+\t$(GCDEPS) $(THREADDEPS) $(ZDEPS) libgcj.la libgcj.spec\n+\n+\n gen_from_JIS_SOURCES = \n EXTRA_gen_from_JIS_SOURCES = $(srcdir)/$(CONVERT_DIR)/gen-from-JIS.c \\\n \t\t$(srcdir)/$(CONVERT_DIR)/make-trie.c \\\n@@ -294,6 +314,13 @@ java/awt/peer/WindowPeer.java\n built_java_source_files = java/lang/ConcreteProcess.java\n \n ordinary_java_source_files = $(convert_source_files) \\\n+gnu/gcj/runtime/MethodInvocation.java \\\n+gnu/gcj/util/path/SearchPath.java \\\n+gnu/gcj/util/path/PathEntry.java \\\n+gnu/gcj/util/path/DirectoryPathEntry.java \\\n+gnu/gcj/util/path/ZipPathEntry.java \\\n+gnu/gcj/util/path/URLPathEntry.java \\\n+gnu/gcj/util/path/CacheEntry.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n@@ -372,6 +399,7 @@ java/lang/ClassCastException.java \\\n java/lang/ClassCircularityError.java \\\n java/lang/ClassFormatError.java\t\\\n java/lang/ClassLoader.java \\\n+java/lang/VMClassLoader.java \\\n java/lang/ClassNotFoundException.java \\\n java/lang/CloneNotSupportedException.java \\\n java/lang/Cloneable.java \\\n@@ -569,6 +597,7 @@ java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/lang/natCharacter.cc \\\n java/lang/natClass.cc \\\n+java/lang/natClassLoader.cc \\\n java/lang/natConcreteProcess.cc \\\n java/lang/natDouble.cc \\\n java/lang/natFirstThread.cc \\\n@@ -655,13 +684,15 @@ DEFS = @DEFS@ -I. -I$(srcdir) -I./include\n CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n-libgcj_la_OBJECTS =  prims.lo jni.lo exception.lo\n-@NATIVE_TRUE@bin_PROGRAMS =  jv-convert$(EXEEXT)\n+libgcj_la_OBJECTS =  prims.lo jni.lo exception.lo resolve.lo \\\n+defineclass.lo interpret.lo\n+@NATIVE_TRUE@bin_PROGRAMS =  jv-convert$(EXEEXT) gij$(EXEEXT)\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS =  \\\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS$(EXEEXT)\n PROGRAMS =  $(bin_PROGRAMS) $(noinst_PROGRAMS)\n \n jv_convert_OBJECTS = \n+gij_OBJECTS = \n gen_from_JIS_OBJECTS = \n gen_from_JIS_LDFLAGS = \n CXXFLAGS = @CXXFLAGS@\n@@ -688,9 +719,9 @@ GZIP_ENV = --best\n DIST_SUBDIRS =  testsuite\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/$(srcdir)/$(CONVERT_DIR)/make-trie.P .deps/boehm.P \\\n-.deps/exception.P .deps/gnu/gcj/RawData.P \\\n-.deps/gnu/gcj/convert/BytesToUnicode.P .deps/gnu/gcj/convert/Convert.P \\\n-.deps/gnu/gcj/convert/Input_8859_1.P \\\n+.deps/defineclass.P .deps/exception.P .deps/gij.P \\\n+.deps/gnu/gcj/RawData.P .deps/gnu/gcj/convert/BytesToUnicode.P \\\n+.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\\n .deps/gnu/gcj/convert/Input_JavaSrc.P \\\n .deps/gnu/gcj/convert/Input_SJIS.P .deps/gnu/gcj/convert/Input_UTF8.P \\\n@@ -703,6 +734,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/protocol/file/Handler.P \\\n .deps/gnu/gcj/protocol/http/Connection.P \\\n .deps/gnu/gcj/protocol/http/Handler.P \\\n+.deps/gnu/gcj/runtime/MethodInvocation.P \\\n .deps/gnu/gcj/text/BaseBreakIterator.P \\\n .deps/gnu/gcj/text/CharacterBreakIterator.P \\\n .deps/gnu/gcj/text/LineBreakIterator.P \\\n@@ -711,6 +743,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/text/SentenceBreakIterator.P \\\n .deps/gnu/gcj/text/WordBreakIterator.P \\\n .deps/gnu/gcj/util/EnumerationChain.P \\\n+.deps/gnu/gcj/util/path/CacheEntry.P \\\n+.deps/gnu/gcj/util/path/DirectoryPathEntry.P \\\n+.deps/gnu/gcj/util/path/PathEntry.P \\\n+.deps/gnu/gcj/util/path/SearchPath.P \\\n+.deps/gnu/gcj/util/path/URLPathEntry.P \\\n+.deps/gnu/gcj/util/path/ZipPathEntry.P .deps/interpret.P \\\n .deps/java/io/BufferedInputStream.P \\\n .deps/java/io/BufferedOutputStream.P .deps/java/io/BufferedReader.P \\\n .deps/java/io/BufferedWriter.P .deps/java/io/ByteArrayInputStream.P \\\n@@ -788,8 +826,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/Throwable.P .deps/java/lang/UnknownError.P \\\n .deps/java/lang/UnsatisfiedLinkError.P \\\n .deps/java/lang/UnsupportedOperationException.P \\\n-.deps/java/lang/VerifyError.P .deps/java/lang/VirtualMachineError.P \\\n-.deps/java/lang/Void.P .deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n+.deps/java/lang/VMClassLoader.P .deps/java/lang/VerifyError.P \\\n+.deps/java/lang/VirtualMachineError.P .deps/java/lang/Void.P \\\n+.deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n .deps/java/lang/e_asin.P .deps/java/lang/e_atan2.P \\\n .deps/java/lang/e_exp.P .deps/java/lang/e_fmod.P \\\n .deps/java/lang/e_log.P .deps/java/lang/e_pow.P \\\n@@ -872,9 +911,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/zip/ZipException.P .deps/java/util/zip/ZipFile.P \\\n .deps/java/util/zip/ZipInputStream.P \\\n .deps/java/util/zip/ZipOutputStream.P .deps/jni.P .deps/no-threads.P \\\n-.deps/nogc.P .deps/posix-threads.P .deps/prims.P\n-SOURCES = $(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n-OBJECTS = $(libgcj_la_OBJECTS) $(jv_convert_OBJECTS) $(gen_from_JIS_OBJECTS)\n+.deps/nogc.P .deps/posix-threads.P .deps/prims.P .deps/resolve.P\n+SOURCES = $(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gij_SOURCES) $(EXTRA_gij_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n+OBJECTS = $(libgcj_la_OBJECTS) $(jv_convert_OBJECTS) $(gij_OBJECTS) $(gen_from_JIS_OBJECTS)\n \n all: all-redirect\n .SUFFIXES:\n@@ -1022,6 +1061,10 @@ jv-convert$(EXEEXT): $(jv_convert_OBJECTS) $(jv_convert_DEPENDENCIES)\n \t@rm -f jv-convert$(EXEEXT)\n \t$(jv_convert_LINK) $(jv_convert_LDFLAGS) $(jv_convert_OBJECTS) $(jv_convert_LDADD) $(LIBS)\n \n+gij$(EXEEXT): $(gij_OBJECTS) $(gij_DEPENDENCIES)\n+\t@rm -f gij$(EXEEXT)\n+\t$(gij_LINK) $(gij_LDFLAGS) $(gij_OBJECTS) $(gij_LDADD) $(LIBS)\n+\n gen-from-JIS$(EXEEXT): $(gen_from_JIS_OBJECTS) $(gen_from_JIS_DEPENDENCIES)\n \t@rm -f gen-from-JIS$(EXEEXT)\n \t$(LINK) $(gen_from_JIS_LDFLAGS) $(gen_from_JIS_OBJECTS) $(gen_from_JIS_LDADD) $(LIBS)\n@@ -1451,6 +1494,16 @@ java/lang/reflect/Method.h: java/lang/reflect/Method.class libgcj.zip\n \t    -friend 'java::lang::Class;' \\\n \t    $(basename $<)\n \n+java/lang/VMClassLoader.h: java/lang/VMClassLoader.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'java::lang::ClassLoader;' \\\n+\t    $(basename $<)\n+\n+gnu/gcj/runtime/MethodInvocation.h: gnu/gcj/runtime/MethodInvocation.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t    -friend 'class _Jv_InterpMethod;' \\\n+\t    $(basename $<)\n+\n maintainer-check: libgcj.la\n \t$(NM) .libs/libgcj.a | grep ' T ' \\\n \t  | grep -v '4java' \\"}, {"sha": "e83836db437e12f3250040054c426e0e393753a2", "filename": "libjava/NEWS", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FNEWS?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -1,3 +1,7 @@\n+New in libgcj X.XX:\n+\n+* libgcj now includes a bytecode interpreter.\n+\n New in libgcj 2.95:\n \n * First public release"}, {"sha": "5b9b9f8cf0764a15976d19931b73aa295497c7ed", "filename": "libjava/THANKS", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FTHANKS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2FTHANKS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FTHANKS?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -10,9 +10,10 @@ Eric Christopher\techristo@cygnus.com\n Franz Sirl\t\tFranz.Sirl-kernel@lauterbach.com\n Geoff Berry\t\tgcb@gnu.org\n Gilles Zunino\t\tGilles.Zunino@hei.fr\n-Per Bothner\t\tper@bother.com\n+Kresten Krab Thorup\tkrab@gnu.org\n+Per Bothner\t\tper@bothner.com\n Rainer Orth\t\tro@TechFak.Uni-Bielefeld.DE\n-Stu Grossman\t\tgrossman@cygnus.com\n+Stu Grossman\t\tgrossman@juniper.com\n Tom Tromey\t\ttromey@cygnus.com\n Urban Widmark\t\turban@svenskatest.se\n Warren Levy\t\twarrenl@cygnus.com"}, {"sha": "1bd5025ef326eb92a6d0360f8a3cb4d579ec67cd", "filename": "libjava/acconfig.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Facconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Facconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Facconfig.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -93,3 +93,6 @@\n #undef HAVE_READDIR_R\n #undef HAVE_GETHOSTBYNAME_R\n #undef HAVE_GETHOSTBYADDR_R\n+\n+/* Define if you want a bytecode interpreter.  */\n+#undef INTERPRETER"}, {"sha": "2e1b5f23cf79932b78812aa73a776c9b089a2ca1", "filename": "libjava/boehm.cc", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -16,6 +16,7 @@ details.  */\n #include <java/lang/Class.h>\n #include <jvm.h>\n #include <java-field.h>\n+#include <java-interp.h>\n \n // We need to include gc_priv.h.  However, it tries to include\n // config.h if it hasn't already been included.  So we force the\n@@ -97,8 +98,14 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n     {\n       jclass c = (jclass) addr;\n \n+#if 0\n+      // The next field should probably not be marked, since this is\n+      // only used in the class hash table.  Marking this field\n+      // basically prohibits class unloading. --Kresten\n       w = (word) c->next;\n       MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c2label);\n+#endif\n+\n       w = (word) c->name;\n       MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c3label);\n       w = (word) c->superclass;\n@@ -109,12 +116,23 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5label);\n \t}\n \n+#ifdef INTERPRETER\n+      if (_Jv_IsInterpretedClass (c))\n+\t{\n+\t  w = (word) c->constants.tags;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5alabel);\n+\t  w = (word) c->constants.data;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5blabel);\n+\t}\n+#endif\n+\n       // If the class is an array, then the methods field holds a\n       // pointer to the element class.  If the class is primitive,\n       // then the methods field holds a pointer to the array class.\n       w = (word) c->methods;\n       MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c6label);\n \n+\n       if (! c->isArray() && ! c->isPrimitive())\n \t{\n \t  // Scan each method in the cases where `methods' really\n@@ -127,7 +145,19 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t      w = (word) c->methods[i].signature;\n \t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm2label);\n+\n \t      // FIXME: `ncode' entry?\n+\n+#ifdef INTERPRETER\n+\t      // The interpreter installs a heap-allocated\n+\t      // trampoline here, so we'll mark it. \n+\t      if (_Jv_IsInterpretedClass (c))\n+\t\t  {\n+\t\t      w = (word) c->methods[i].ncode;\n+\t\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t\t\t\t  cm3label);\n+\t\t  }\n+#endif\n \t    }\n \t}\n \n@@ -136,12 +166,34 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n       MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8label);\n       for (int i = 0; i < c->field_count; ++i)\n \t{\n+\t  _Jv_Field* field = &c->fields[i];\n+\n #ifndef COMPACT_FIELDS\n-\t  w = (word) c->fields[i].name;\n+\t  w = (word) field->name;\n \t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n #endif\n-\t  w = (word) c->fields[i].type;\n+\t  w = (word) field->type;\n \t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n+\n+\t  // For the interpreter, we also need to mark the memory\n+\t  // containing static members\n+\t  if (field->flags & 0x0008)\n+\t    {\n+\t      w = (word) field->u.addr;\n+\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8clabel);\n+\n+\t      // also, if the static member is a reference,\n+\t      // mark also the value pointed to.  We check for isResolved\n+\t      // since marking can happen before memory is allocated for\n+\t      // static members.\n+\t      if (JvFieldIsRef (field) && field->isResolved()) \n+\t\t{\n+\t\t  jobject val = *(jobject*) field->u.addr;\n+\t\t  w = (word) val;\n+\t\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit,\n+\t\t\t      c, c8elabel);\n+\t\t}\n+\t    }\n \t}\n \n       w = (word) c->vtable;\n@@ -155,6 +207,28 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t}\n       w = (word) c->loader;\n       MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n+\n+#ifdef INTERPRETER\n+      if (_Jv_IsInterpretedClass (c))\n+\t{\n+\t  _Jv_InterpClass* ic = (_Jv_InterpClass*)c;\n+\n+\t  w = (word) ic->interpreted_methods;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n+\n+\t  for (int i = 0; i < c->method_count; i++)\n+\t    {\n+\t      w = (word) ic->interpreted_methods[i];\n+\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, \\\n+\t\t\t  cFlabel);\n+\t    }\n+\n+\t  w = (word) ic->field_initializers;\n+\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, cGlabel);\n+\t  \n+\t}\n+#endif\n+\n     }\n   else\n     {"}, {"sha": "eac0e543a4b21741548c9e8b016d2456400b4327", "filename": "libjava/configure", "status": "modified", "additions": 225, "deletions": 192, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -34,6 +34,8 @@ ac_help=\"$ac_help\n   --enable-fast-character          Prefer speed over size for Character\"\n ac_help=\"$ac_help\n   --enable-libgcj-debug           Enable runtime debugging code\"\n+ac_help=\"$ac_help\n+  --enable-interpreter            Enable interpreter\"\n ac_help=\"$ac_help\n   --with-ecos      Enable runtime eCos target support.\"\n ac_help=\"$ac_help\n@@ -59,6 +61,7 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n+sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -173,6 +176,7 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n+  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -343,6 +347,11 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n+  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n+    ac_prev=sitefile ;;\n+  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n+    sitefile=\"$ac_optarg\" ;;\n+\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -508,12 +517,16 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$CONFIG_SITE\"; then\n-  if test \"x$prefix\" != xNONE; then\n-    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-  else\n-    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n+if test -z \"$sitefile\"; then\n+  if test -z \"$CONFIG_SITE\"; then\n+    if test \"x$prefix\" != xNONE; then\n+      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+    else\n+      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n+    fi\n   fi\n+else\n+  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -601,7 +614,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:605: checking host system type\" >&5\n+echo \"configure:618: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -622,7 +635,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:626: checking target system type\" >&5\n+echo \"configure:639: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -640,7 +653,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:644: checking build system type\" >&5\n+echo \"configure:657: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -688,7 +701,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:692: checking for a BSD compatible install\" >&5\n+echo \"configure:705: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -741,7 +754,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:745: checking whether build environment is sane\" >&5\n+echo \"configure:758: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -798,7 +811,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:802: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:815: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -831,12 +844,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:835: checking for Cygwin environment\" >&5\n+echo \"configure:848: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 840 \"configure\"\n+#line 853 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -847,7 +860,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:851: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:864: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -864,19 +877,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:868: checking for mingw32 environment\" >&5\n+echo \"configure:881: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 873 \"configure\"\n+#line 886 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:880: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:893: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -924,7 +937,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:928: checking host system type\" >&5\n+echo \"configure:941: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -966,7 +979,7 @@ EOF\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:970: checking for working aclocal\" >&5\n+echo \"configure:983: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -979,7 +992,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:983: checking for working autoconf\" >&5\n+echo \"configure:996: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -992,7 +1005,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:996: checking for working automake\" >&5\n+echo \"configure:1009: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1005,7 +1018,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:1009: checking for working autoheader\" >&5\n+echo \"configure:1022: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1018,7 +1031,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1022: checking for working makeinfo\" >&5\n+echo \"configure:1035: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1043,7 +1056,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1047: checking for $ac_word\" >&5\n+echo \"configure:1060: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1073,7 +1086,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1077: checking for $ac_word\" >&5\n+echo \"configure:1090: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1122,7 +1135,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1126: checking whether we are using GNU C\" >&5\n+echo \"configure:1139: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1131,7 +1144,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1135: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1148: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1146,7 +1159,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1150: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1163: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1182,7 +1195,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1186: checking for $ac_word\" >&5\n+echo \"configure:1199: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1215,7 +1228,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1219: checking whether we are using GNU C++\" >&5\n+echo \"configure:1232: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1224,7 +1237,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1228: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1241: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1239,7 +1252,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1243: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1256: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1272,7 +1285,7 @@ fi\n # LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1276: checking build system type\" >&5\n+echo \"configure:1289: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1293,7 +1306,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1297: checking for $ac_word\" >&5\n+echo \"configure:1310: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1325,7 +1338,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1329: checking for $ac_word\" >&5\n+echo \"configure:1342: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1357,7 +1370,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1361: checking for $ac_word\" >&5\n+echo \"configure:1374: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1389,7 +1402,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1393: checking for $ac_word\" >&5\n+echo \"configure:1406: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1434,7 +1447,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1438: checking for a BSD compatible install\" >&5\n+echo \"configure:1451: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1488,7 +1501,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1492: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1505: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1522,7 +1535,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1526: checking for executable suffix\" >&5\n+echo \"configure:1539: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1532,7 +1545,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1536: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1549: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n@@ -1654,7 +1667,7 @@ fi\n # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1658: checking for $ac_word\" >&5\n+echo \"configure:1671: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1684,7 +1697,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1688: checking for $ac_word\" >&5\n+echo \"configure:1701: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1714,7 +1727,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1718: checking for $ac_word\" >&5\n+echo \"configure:1731: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1765,7 +1778,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1769: checking for $ac_word\" >&5\n+echo \"configure:1782: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1797,7 +1810,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:1801: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:1814: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -1808,12 +1821,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 1812 \"configure\"\n+#line 1825 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:1817: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1830: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -1839,12 +1852,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:1843: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:1856: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1848: checking whether we are using GNU C\" >&5\n+echo \"configure:1861: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1853,7 +1866,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1857: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1870: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1872,7 +1885,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1876: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1889: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1915,7 +1928,7 @@ ac_prog=ld\n if test \"$ac_cv_prog_gcc\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1919: checking for ld used by GCC\" >&5\n+echo \"configure:1932: checking for ld used by GCC\" >&5\n   ac_prog=`($CC -print-prog-name=ld) 2>&5`\n   case \"$ac_prog\" in\n     # Accept absolute paths.\n@@ -1939,10 +1952,10 @@ echo \"configure:1919: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1943: checking for GNU ld\" >&5\n+echo \"configure:1956: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1946: checking for non-GNU ld\" >&5\n+echo \"configure:1959: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'ac_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1978,7 +1991,7 @@ fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1982: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1995: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1994,7 +2007,7 @@ echo \"$ac_t\"\"$ac_cv_prog_gnu_ld\" 1>&6\n \n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1998: checking for BSD-compatible nm\" >&5\n+echo \"configure:2011: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2031,7 +2044,7 @@ echo \"$ac_t\"\"$NM\" 1>&6\n \n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:2035: checking whether ln -s works\" >&5\n+echo \"configure:2048: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2075,8 +2088,8 @@ test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n case \"$host\" in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2079 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2080: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2092 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2093: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2097,19 +2110,19 @@ case \"$host\" in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2101: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2114: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2106 \"configure\"\n+#line 2119 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2113: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2126: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2253,6 +2266,21 @@ EOF\n fi\n \n \n+# Check whether --enable-interpreter or --disable-interpreter was given.\n+if test \"${enable_interpreter+set}\" = set; then\n+  enableval=\"$enable_interpreter\"\n+  if test \"$enable_interpreter\" = yes; then\n+     cat >> confdefs.h <<\\EOF\n+#define INTERPRETER 1\n+EOF\n+\n+  fi\n+fi\n+\n+\n+INTERPSPEC=\n+\n+\n TARGET_ECOS=\"no\"\n # Check whether --with-ecos or --without-ecos was given.\n if test \"${with_ecos+set}\" = set; then\n@@ -2278,7 +2306,7 @@ EOF\n esac\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2282: checking how to run the C preprocessor\" >&5\n+echo \"configure:2310: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2293,13 +2321,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2297 \"configure\"\n+#line 2325 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2303: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2331: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2310,13 +2338,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2314 \"configure\"\n+#line 2342 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2320: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2348: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2327,13 +2355,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2331 \"configure\"\n+#line 2359 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2337: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2365: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2358,7 +2386,7 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n cat > conftest.$ac_ext <<EOF\n-#line 2362 \"configure\"\n+#line 2390 \"configure\"\n #include \"confdefs.h\"\n #include <stdint.h>\n EOF\n@@ -2373,7 +2401,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2377 \"configure\"\n+#line 2405 \"configure\"\n #include \"confdefs.h\"\n #include <inttypes.h>\n EOF\n@@ -2388,7 +2416,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2392 \"configure\"\n+#line 2420 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n EOF\n@@ -2403,7 +2431,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2407 \"configure\"\n+#line 2435 \"configure\"\n #include \"confdefs.h\"\n #include <sys/config.h>\n EOF\n@@ -2420,7 +2448,7 @@ rm -f conftest*\n \n \n cat > conftest.$ac_ext <<EOF\n-#line 2424 \"configure\"\n+#line 2452 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2435,7 +2463,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2439 \"configure\"\n+#line 2467 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2473,7 +2501,7 @@ ZLIBSPEC=\n libsubdir=.libs\n \n echo $ac_n \"checking for garbage collector to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2477: checking for garbage collector to use\" >&5\n+echo \"configure:2505: checking for garbage collector to use\" >&5\n # Check whether --enable-java-gc or --disable-java-gc was given.\n if test \"${enable_java_gc+set}\" = set; then\n   enableval=\"$enable_java_gc\"\n@@ -2523,7 +2551,7 @@ esac\n \n \n echo $ac_n \"checking for threads package to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2527: checking for threads package to use\" >&5\n+echo \"configure:2555: checking for threads package to use\" >&5\n # Check whether --enable-threads or --disable-threads was given.\n if test \"${enable_threads+set}\" = set; then\n   enableval=\"$enable_threads\"\n@@ -2715,12 +2743,12 @@ else\n    for ac_func in strerror ioctl select open fsync sleep\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2719: checking for $ac_func\" >&5\n+echo \"configure:2747: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2724 \"configure\"\n+#line 2752 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2743,7 +2771,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2747: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2775: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2770,12 +2798,12 @@ done\n    for ac_func in ctime_r ctime\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2774: checking for $ac_func\" >&5\n+echo \"configure:2802: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2779 \"configure\"\n+#line 2807 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2798,7 +2826,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2802: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2830: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2825,12 +2853,12 @@ done\n    for ac_func in gmtime_r localtime_r readdir_r getpwuid_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2829: checking for $ac_func\" >&5\n+echo \"configure:2857: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2834 \"configure\"\n+#line 2862 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2853,7 +2881,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2857: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2885: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2880,12 +2908,12 @@ done\n    for ac_func in access stat mkdir rename rmdir unlink realpath\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2884: checking for $ac_func\" >&5\n+echo \"configure:2912: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2889 \"configure\"\n+#line 2917 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2908,7 +2936,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2912: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2940: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2935,12 +2963,12 @@ done\n    for ac_func in inet_aton inet_addr\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2939: checking for $ac_func\" >&5\n+echo \"configure:2967: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2944 \"configure\"\n+#line 2972 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2963,7 +2991,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2967: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2995: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2990,12 +3018,12 @@ done\n    for ac_func in inet_pton uname inet_ntoa\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2994: checking for $ac_func\" >&5\n+echo \"configure:3022: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2999 \"configure\"\n+#line 3027 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3018,7 +3046,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3022: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3050: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3046,12 +3074,12 @@ done\n    for ac_func in gethostbyname_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3050: checking for $ac_func\" >&5\n+echo \"configure:3078: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3055 \"configure\"\n+#line 3083 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3074,7 +3102,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3078: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3106: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3101,7 +3129,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3105 \"configure\"\n+#line 3133 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -3121,7 +3149,7 @@ rm -f conftest*\n      *\" -D_REENTRANT \"*) ;;\n      *)\n \t\techo $ac_n \"checking whether gethostbyname_r declaration requires -D_REENTRANT\"\"... $ac_c\" 1>&6\n-echo \"configure:3125: checking whether gethostbyname_r declaration requires -D_REENTRANT\" >&5\n+echo \"configure:3153: checking whether gethostbyname_r declaration requires -D_REENTRANT\" >&5\n if eval \"test \\\"`echo '$''{'libjava_cv_gethostbyname_r_needs_reentrant'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3134,14 +3162,14 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n \n \t  cat > conftest.$ac_ext <<EOF\n-#line 3138 \"configure\"\n+#line 3166 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n int main() {\n gethostbyname_r(\"\", 0, 0);\n ; return 0; }\n EOF\n-if { (eval echo configure:3145: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3173: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_gethostbyname_r_needs_reentrant=no\n else\n@@ -3151,14 +3179,14 @@ else\n   \t\tCPPFLAGS_SAVE=\"$CPPFLAGS\"\n \t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n \t\tcat > conftest.$ac_ext <<EOF\n-#line 3155 \"configure\"\n+#line 3183 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n int main() {\n gethostbyname_r(\"\", 0, 0);\n ; return 0; }\n EOF\n-if { (eval echo configure:3162: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3190: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_gethostbyname_r_needs_reentrant=yes\n else\n@@ -3193,12 +3221,12 @@ EOF\n      esac\n \n      echo $ac_n \"checking for struct hostent_data\"\"... $ac_c\" 1>&6\n-echo \"configure:3197: checking for struct hostent_data\" >&5\n+echo \"configure:3225: checking for struct hostent_data\" >&5\n if eval \"test \\\"`echo '$''{'libjava_cv_struct_hostent_data'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   \tcat > conftest.$ac_ext <<EOF\n-#line 3202 \"configure\"\n+#line 3230 \"configure\"\n #include \"confdefs.h\"\n \n #if GETHOSTBYNAME_R_NEEDS_REENTRANT && !defined(_REENTRANT)\n@@ -3209,7 +3237,7 @@ int main() {\n struct hostent_data data;\n ; return 0; }\n EOF\n-if { (eval echo configure:3213: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3241: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_struct_hostent_data=yes\n else\n@@ -3238,12 +3266,12 @@ done\n    for ac_func in gethostbyaddr_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3242: checking for $ac_func\" >&5\n+echo \"configure:3270: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3247 \"configure\"\n+#line 3275 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3266,7 +3294,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3270: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3298: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3293,7 +3321,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3297 \"configure\"\n+#line 3325 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -3317,12 +3345,12 @@ done\n    for ac_func in gethostname\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3321: checking for $ac_func\" >&5\n+echo \"configure:3349: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3326 \"configure\"\n+#line 3354 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3345,7 +3373,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3349: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3377: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3369,7 +3397,7 @@ EOF\n EOF\n \n      cat > conftest.$ac_ext <<EOF\n-#line 3373 \"configure\"\n+#line 3401 \"configure\"\n #include \"confdefs.h\"\n #include <unistd.h>\n EOF\n@@ -3396,12 +3424,12 @@ done\n    for ac_func in pthread_mutexattr_settype pthread_mutexattr_setkind_np\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3400: checking for $ac_func\" >&5\n+echo \"configure:3428: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3405 \"configure\"\n+#line 3433 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3424,7 +3452,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3428: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3456: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3454,12 +3482,12 @@ done\n    for ac_func in sched_yield\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3458: checking for $ac_func\" >&5\n+echo \"configure:3486: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3463 \"configure\"\n+#line 3491 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3482,7 +3510,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3486: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3514: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3504,15 +3532,15 @@ EOF\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for sched_yield in -lposix4\"\"... $ac_c\" 1>&6\n-echo \"configure:3508: checking for sched_yield in -lposix4\" >&5\n+echo \"configure:3536: checking for sched_yield in -lposix4\" >&5\n ac_lib_var=`echo posix4'_'sched_yield | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lposix4  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 3516 \"configure\"\n+#line 3544 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -3523,7 +3551,7 @@ int main() {\n sched_yield()\n ; return 0; }\n EOF\n-if { (eval echo configure:3527: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3555: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -3548,15 +3576,15 @@ else\n   echo \"$ac_t\"\"no\" 1>&6\n \n        echo $ac_n \"checking for sched_yield in -lrt\"\"... $ac_c\" 1>&6\n-echo \"configure:3552: checking for sched_yield in -lrt\" >&5\n+echo \"configure:3580: checking for sched_yield in -lrt\" >&5\n ac_lib_var=`echo rt'_'sched_yield | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lrt  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 3560 \"configure\"\n+#line 3588 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -3567,7 +3595,7 @@ int main() {\n sched_yield()\n ; return 0; }\n EOF\n-if { (eval echo configure:3571: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3599: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -3604,12 +3632,12 @@ done\n    for ac_func in gettimeofday time ftime\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3608: checking for $ac_func\" >&5\n+echo \"configure:3636: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3613 \"configure\"\n+#line 3641 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3632,7 +3660,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3636: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3664: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3663,12 +3691,12 @@ done\n    for ac_func in memmove\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3667: checking for $ac_func\" >&5\n+echo \"configure:3695: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3672 \"configure\"\n+#line 3700 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3691,7 +3719,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3695: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3723: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3721,12 +3749,12 @@ done\n    for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3725: checking for $ac_func\" >&5\n+echo \"configure:3753: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3730 \"configure\"\n+#line 3758 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3749,7 +3777,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3753: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3781: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3797,20 +3825,20 @@ done\n    #--------------------------------------------------------------------\n \n    echo $ac_n \"checking for socket libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:3801: checking for socket libraries\" >&5\n+echo \"configure:3829: checking for socket libraries\" >&5\n if eval \"test \\\"`echo '$''{'gcj_cv_lib_sockets'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcj_cv_lib_sockets=\n      gcj_checkBoth=0\n      unset ac_cv_func_connect\n      echo $ac_n \"checking for connect\"\"... $ac_c\" 1>&6\n-echo \"configure:3809: checking for connect\" >&5\n+echo \"configure:3837: checking for connect\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_connect'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3814 \"configure\"\n+#line 3842 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char connect(); below.  */\n@@ -3833,7 +3861,7 @@ connect();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3837: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3865: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_connect=yes\"\n else\n@@ -3856,22 +3884,22 @@ fi\n      if test \"$gcj_checkSocket\" = 1; then\n \t unset ac_cv_func_connect\n \t echo $ac_n \"checking for main in -lsocket\"\"... $ac_c\" 1>&6\n-echo \"configure:3860: checking for main in -lsocket\" >&5\n+echo \"configure:3888: checking for main in -lsocket\" >&5\n ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lsocket  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 3868 \"configure\"\n+#line 3896 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:3875: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3903: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -3898,12 +3926,12 @@ fi\n \t LIBS=\"$LIBS -lsocket -lnsl\"\n \t unset ac_cv_func_accept\n \t echo $ac_n \"checking for accept\"\"... $ac_c\" 1>&6\n-echo \"configure:3902: checking for accept\" >&5\n+echo \"configure:3930: checking for accept\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_accept'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3907 \"configure\"\n+#line 3935 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char accept(); below.  */\n@@ -3926,7 +3954,7 @@ accept();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3930: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3958: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_accept=yes\"\n else\n@@ -3953,12 +3981,12 @@ fi\n      gcj_oldLibs=$LIBS\n      LIBS=\"$LIBS $gcj_cv_lib_sockets\"\n      echo $ac_n \"checking for gethostbyname\"\"... $ac_c\" 1>&6\n-echo \"configure:3957: checking for gethostbyname\" >&5\n+echo \"configure:3985: checking for gethostbyname\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3962 \"configure\"\n+#line 3990 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char gethostbyname(); below.  */\n@@ -3981,7 +4009,7 @@ gethostbyname();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3985: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4013: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_gethostbyname=yes\"\n else\n@@ -3999,22 +4027,22 @@ if eval \"test \\\"`echo '$ac_cv_func_'gethostbyname`\\\" = yes\"; then\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for main in -lnsl\"\"... $ac_c\" 1>&6\n-echo \"configure:4003: checking for main in -lnsl\" >&5\n+echo \"configure:4031: checking for main in -lnsl\" >&5\n ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lnsl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4011 \"configure\"\n+#line 4039 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4018: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4046: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4044,17 +4072,21 @@ fi\n echo \"$ac_t\"\"$gcj_cv_lib_sockets\" 1>&6\n    SYSTEMSPEC=\"$SYSTEMSPEC $gcj_cv_lib_sockets\"\n \n+   if test \"$enable_interpreter\" = yes; then\n+      INTERPSPEC=\n+   fi\n+\n    if test \"$with_system_zlib\" = yes; then\n       echo $ac_n \"checking for deflate in -lz\"\"... $ac_c\" 1>&6\n-echo \"configure:4050: checking for deflate in -lz\" >&5\n+echo \"configure:4082: checking for deflate in -lz\" >&5\n ac_lib_var=`echo z'_'deflate | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lz  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4058 \"configure\"\n+#line 4090 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -4065,7 +4097,7 @@ int main() {\n deflate()\n ; return 0; }\n EOF\n-if { (eval echo configure:4069: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4101: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4094,22 +4126,22 @@ fi\n    # requires -ldl.\n    if test \"$GC\" = boehm; then\n       echo $ac_n \"checking for main in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:4098: checking for main in -ldl\" >&5\n+echo \"configure:4130: checking for main in -ldl\" >&5\n ac_lib_var=`echo dl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4106 \"configure\"\n+#line 4138 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4113: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4145: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4219,17 +4251,17 @@ for ac_hdr in unistd.h bstring.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:4223: checking for $ac_hdr\" >&5\n+echo \"configure:4255: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4228 \"configure\"\n+#line 4260 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:4233: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:4265: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -4259,17 +4291,17 @@ for ac_hdr in dirent.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:4263: checking for $ac_hdr\" >&5\n+echo \"configure:4295: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4268 \"configure\"\n+#line 4300 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:4273: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:4305: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -4297,16 +4329,16 @@ done\n \n \n echo $ac_n \"checking whether struct sockaddr_in6 is in netinet/in.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4301: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n+echo \"configure:4333: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4303 \"configure\"\n+#line 4335 \"configure\"\n #include \"confdefs.h\"\n #include <netinet/in.h>\n int main() {\n struct sockaddr_in6 addr6;\n ; return 0; }\n EOF\n-if { (eval echo configure:4310: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4342: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_INET6 1\n@@ -4322,16 +4354,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for socklen_t in sys/socket.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4326: checking for socklen_t in sys/socket.h\" >&5\n+echo \"configure:4358: checking for socklen_t in sys/socket.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4328 \"configure\"\n+#line 4360 \"configure\"\n #include \"confdefs.h\"\n #include <sys/socket.h>\n int main() {\n socklen_t x = 5;\n ; return 0; }\n EOF\n-if { (eval echo configure:4335: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4367: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_SOCKLEN_T 1\n@@ -4347,16 +4379,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for tm_gmtoff in struct tm\"\"... $ac_c\" 1>&6\n-echo \"configure:4351: checking for tm_gmtoff in struct tm\" >&5\n+echo \"configure:4383: checking for tm_gmtoff in struct tm\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 4353 \"configure\"\n+#line 4385 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n struct tm tim; tim.tm_gmtoff = 0;\n ; return 0; }\n EOF\n-if { (eval echo configure:4360: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4392: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define STRUCT_TM_HAS_GMTOFF 1\n@@ -4369,16 +4401,16 @@ else\n   rm -rf conftest*\n   echo \"$ac_t\"\"no\" 1>&6\n    echo $ac_n \"checking for global timezone variable\"\"... $ac_c\" 1>&6\n-echo \"configure:4373: checking for global timezone variable\" >&5\n+echo \"configure:4405: checking for global timezone variable\" >&5\n             cat > conftest.$ac_ext <<EOF\n-#line 4375 \"configure\"\n+#line 4407 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n long z2 = timezone;\n ; return 0; }\n EOF\n-if { (eval echo configure:4382: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4414: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_TIMEZONE 1\n@@ -4398,19 +4430,19 @@ rm -f conftest*\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:4402: checking for working alloca.h\" >&5\n+echo \"configure:4434: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4407 \"configure\"\n+#line 4439 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:4414: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4446: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -4431,12 +4463,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:4435: checking for alloca\" >&5\n+echo \"configure:4467: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4440 \"configure\"\n+#line 4472 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -4464,7 +4496,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:4468: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4500: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -4496,12 +4528,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:4500: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:4532: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4505 \"configure\"\n+#line 4537 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -4526,12 +4558,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4530: checking for $ac_func\" >&5\n+echo \"configure:4562: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4535 \"configure\"\n+#line 4567 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4554,7 +4586,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4558: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4590: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4581,15 +4613,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:4585: checking stack direction for C alloca\" >&5\n+echo \"configure:4617: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4593 \"configure\"\n+#line 4625 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -4608,7 +4640,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:4612: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:4644: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -4635,7 +4667,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4639: checking for $ac_word\" >&5\n+echo \"configure:4671: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_PERL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4868,6 +4900,7 @@ s%@LIBTOOL@%$LIBTOOL%g\n s%@COMPPATH@%$COMPPATH%g\n s%@TESTSUBDIR_TRUE@%$TESTSUBDIR_TRUE%g\n s%@TESTSUBDIR_FALSE@%$TESTSUBDIR_FALSE%g\n+s%@INTERPSPEC@%$INTERPSPEC%g\n s%@CPP@%$CPP%g\n s%@SYSTEMSPEC@%$SYSTEMSPEC%g\n s%@ZLIBSPEC@%$ZLIBSPEC%g"}, {"sha": "861530a2e49de56eeba400e753e57a02134566c1", "filename": "libjava/configure.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -42,6 +42,17 @@ AC_ARG_ENABLE(libgcj-debug,\n      AC_DEFINE(DEBUG)\n   fi)\n \n+dnl See if the user has the enterpreter included.\n+AC_ARG_ENABLE(interpreter,\n+[  --enable-interpreter            Enable interpreter],\n+  if test \"$enable_interpreter\" = yes; then\n+     AC_DEFINE(INTERPRETER)\n+  fi)\n+\n+dnl This becomes -lffi if the interpreter is enables\n+INTERPSPEC=\n+AC_SUBST(INTERPSPEC)\n+\n dnl If the target is an eCos system, use the appropriate eCos\n dnl I/O routines.\n dnl FIXME: this should not be a local option but a global target\n@@ -447,6 +458,10 @@ else\n    ])\n    SYSTEMSPEC=\"$SYSTEMSPEC $gcj_cv_lib_sockets\"\n \n+   if test \"$enable_interpreter\" = yes; then\n+      INTERPSPEC=\n+   fi\n+\n    if test \"$with_system_zlib\" = yes; then\n       AC_CHECK_LIB(z, deflate, ZLIBSPEC=-lz, ZLIBSPEC=-lzgcj)\n    else"}, {"sha": "09f8f47fc843ce3cb7da2b178afdaa1250f5827d", "filename": "libjava/defineclass.cc", "status": "added", "additions": 1556, "deletions": 0, "changes": 1556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,1556 @@\n+// defineclass.cc - defining a class from .class format.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* \n+   Author: Kresten Krab Thorup <krab@gnu.org> \n+\n+   Written using the online versions of Java Language Specification (1st\n+   ed.) and The Java Virtual Machine Specification (2nd ed.). \n+\n+   Future work may include reading (and handling) attributes which are\n+   currently being ignored (\"InnerClasses\", \"LineNumber\", etc...).  \n+*/\n+\n+#include <java-interp.h>\n+\n+#ifdef INTERPRETER\n+\n+#include <java-cpool.h>\n+#include <cni.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/Float.h>\n+#include <java/lang/Double.h>\n+#include <java/lang/Character.h>\n+#include <java/lang/LinkageError.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/ClassFormatError.h>\n+#include <java/lang/NoClassDefFoundError.h>\n+#include <java/lang/ClassCircularityError.h>\n+#include <java/lang/ClassNotFoundException.h>\n+#include <java/lang/IncompatibleClassChangeError.h>\n+\n+#define ClassClass _CL_Q34java4lang5Class\n+extern java::lang::Class ClassClass;\n+#define StringClass _CL_Q34java4lang6String\n+extern java::lang::Class StringClass;\n+#define ClassObject _CL_Q34java4lang6Object\n+extern java::lang::Class ClassObject;\n+\n+// we don't verify method names that match these.\n+static _Jv_Utf8Const *clinit_name = _Jv_makeUtf8Const (\"<clinit>\", 8);\n+static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n+\n+\n+// these go in some seperate functions, to avoid having _Jv_InitClass\n+// inserted all over the place.\n+static void throw_internal_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_no_class_def_found_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_no_class_def_found_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_format_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_format_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_incompatible_class_change_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_circularity_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+\n+static jdouble long_bits_to_double (jlong);\n+static jfloat int_bits_to_float (jint);\n+\n+/**\n+ * We define class reading using a class.  It is practical, since then\n+ * the entire class-reader can be a friend of class Class (it needs to\n+ * write all it's different structures); but also because this makes it\n+ * easy to make class definition reentrant, and thus two threads can be\n+ * defining classes at the same time.   This class (_Jv_ClassReader) is\n+ * never exposed outside this file, so we don't have to worry about\n+ * public or private members here.\n+ */\n+\n+struct _Jv_ClassReader {\n+\n+  // do verification?  Currently, there is no option to disable this.\n+  // This flag just controls the verificaiton done by the class loader;\n+  // i.e., checking the integrity of the constant pool; and it is\n+  // allways on.  You always want this as far as I can see, but it also\n+  // controls weither identifiers and type descriptors/signatures are\n+  // verified as legal.  This could be somewhat more expensive since it\n+  // will call Characher.isJavaIdentifier{Start,Part} for each character\n+  // in any identifier (field name or method name) it comes by.  Thus,\n+  // it might be useful to turn off this verification for classes that\n+  // come from a trusted source.  However, for GCJ, trusted classes are\n+  // most likely to be linked in.\n+\n+  bool verify;\n+\n+  // input data.\n+  unsigned char     *bytes;\n+  int                len;\n+\n+  // current input position\n+  int                pos;\n+\n+  // the constant pool data\n+  int pool_count;\n+  unsigned char     *tags;\n+  unsigned int      *offsets;\n+\n+  // the class to define (see java-interp.h)\n+  _Jv_InterpClass   *def;\n+\n+  /* check that the given number of input bytes are available */\n+  inline void check (int num)\n+  {\n+    if (pos + num > len)\n+      throw_class_format_error (\"Premature end of data\");\n+  }\n+\n+  /* skip a given number of bytes in input */\n+  inline void skip (int num)\n+  {\n+    check (num);\n+    pos += num;\n+  }\n+  \n+  /* read an unsignend 1-byte unit */\n+  inline static jint get1u (unsigned char* bytes)\n+  {\n+    return bytes[0];\n+  }\n+  \n+  /* read an unsigned 1-byte unit */\n+  inline jint read1u ()\n+  {\n+    skip (1);\n+    return get1u (bytes+pos-1);\n+  }\n+  \n+  /* read an unsigned 2-byte unit */\n+  inline static jint get2u (unsigned char *bytes)\n+  {\n+    return (((jint)bytes[0]) << 8) | ((jint)bytes[1]);\n+  }\n+  \n+  /* read an unsigned 2-byte unit */\n+  inline jint read2u ()\n+  {\n+    skip (2);  \n+    return get2u (bytes+pos-2);\n+  }\n+  \n+  /* read a 4-byte unit */\n+  static jint get4 (unsigned char *bytes)\n+  {\n+    return (((jint)bytes[0]) << 24)\n+         | (((jint)bytes[1]) << 16)\n+         | (((jint)bytes[2]) << 8)\n+         | (((jint)bytes[3]) << 0);\n+  }\n+\n+  /* read a 4-byte unit, (we don't do that quite so often) */\n+  inline jint read4 ()\n+  {\n+    skip (4);  \n+    return get4 (bytes+pos-4);\n+  }\n+\n+  /* read a 8-byte unit */\n+  static jlong get8 (unsigned char* bytes)\n+  {\n+    return (((jlong)bytes[0]) << 56)\n+         | (((jlong)bytes[1]) << 48)\n+         | (((jlong)bytes[2]) << 40)\n+         | (((jlong)bytes[3]) << 32) \n+         | (((jlong)bytes[4]) << 24)\n+         | (((jlong)bytes[5]) << 16)\n+         | (((jlong)bytes[6]) << 8)\n+         | (((jlong)bytes[7]) << 0);\n+  }\n+\n+  /* read a 8-byte unit */\n+  inline jlong read8 ()\n+  {\n+    skip (8);  \n+    return get8 (bytes+pos-8);\n+  }\n+\n+  inline void check_tag (int index, char expected_tag)\n+  {\n+    if (index < 0\n+\t|| index > pool_count\n+\t|| tags[index] != expected_tag)\n+      throw_class_format_error (\"erroneous constant pool tag\");\n+  }\n+\n+  _Jv_ClassReader (jclass klass, jbyteArray data, jint offset, jint length)\n+  {\n+    if (klass == 0 || length < 0 || offset+length > data->length)\n+      throw_internal_error (\"arguments to _Jv_DefineClass\");\n+\n+    verify = true;\n+    bytes  = (unsigned char*) (elements (data)+offset);\n+    len    = length;\n+    pos    = 0;\n+    def    = (_Jv_InterpClass*) klass;\n+  }\n+\n+  /** and here goes the parser members defined out-of-line */\n+  void parse ();\n+  void read_constpool ();\n+  void prepare_pool_entry (int index, unsigned char tag);\n+  void read_fields ();\n+  void read_methods ();\n+  void read_one_class_attribute ();\n+  void read_one_method_attribute (int method);\n+  void read_one_code_attribute (int method);\n+  void read_one_field_attribute (int field);\n+\n+  /** check an utf8 entry, without creating a Utf8Const object */\n+  bool is_attribute_name (int index, char *name);\n+\n+  /** here goes the class-loader members defined out-of-line */\n+  void handleConstantPool ();\n+  void handleClassBegin (int, int, int);\n+  void handleInterfacesBegin (int);\n+  void handleInterface (int, int);\n+  void handleFieldsBegin (int);\n+  void handleField (int, int, int, int);\n+  void handleFieldsEnd ();\n+  void handleConstantValueAttribute (int,int);\n+  void handleMethodsBegin (int);\n+  void handleMethod (int, int, int, int);\n+  void handleMethodsEnd ();\n+  void handleCodeAttribute (int, int, int, int, int, int);\n+  void handleExceptionTableEntry (int, int, int, int, int, int);\n+\n+  void checkExtends (jclass sub, jclass super);\n+  void checkImplements (jclass sub, jclass super);\n+\n+  /*\n+   * FIXME: we should keep a hash table of utf8-strings, since many will\n+   * be the same.  It's a little tricky, however, because the hash table\n+   * needs to interact gracefully with the garbage collector.  Much\n+   * memory is to be saved by this, however!  perhaps the improvement\n+   * could be implemented in prims.cc (_Jv_makeUtf8Const), since it\n+   * computes the hash value anyway.\n+   */\n+\n+  static const int PUBLIC       = 0x001;\n+  static const int PRIVATE      = 0x002;\n+  static const int PROTECTED    = 0x004;\n+  static const int STATIC       = 0x008;\n+  static const int FINAL        = 0x010;\n+  static const int SYNCHRONIZED = 0x020;\n+  static const int VOLATILE     = 0x040;\n+  static const int TRANSIENT    = 0x080;\n+  static const int NATIVE       = 0x100;\n+  static const int INTERFACE    = 0x200;\n+  static const int ABSTRACT     = 0x400;\n+  static const int ALL_FLAGS    = 0x7FF; \n+\n+};\n+\n+/* This is used for the isJavaIdentifierStart & isJavaIdentifierPart\n+   methods, so we avoid doing _Jv_InitClass all the time */\n+\n+static const java::lang::Character *character = 0;\n+static void prepare_character ();\n+\n+void\n+_Jv_DefineClass (jclass klass, jbyteArray data, jint offset, jint length)\n+{\n+  if (character == 0)\n+    prepare_character ();\n+\n+  _Jv_ClassReader reader (klass, data, offset, length);\n+  reader.parse();\n+\n+  /* that's it! */\n+}\n+\n+/** put it after _Jv_DefineClass, so it doesn't get inlined */\n+static void prepare_character ()\n+{\n+  character = new java::lang::Character ('!');\n+}\n+\n+\f\n+/** This section defines the parsing/scanning of the class data */\n+\n+void\n+_Jv_ClassReader::parse ()\n+{\n+  int magic = read4 ();\n+\n+  /* FIXME: Decide which range of version numbers to allow */\n+\n+  /* int minor_version = */ read2u ();\n+  /* int major_verson  = */ read2u ();\n+\n+  if (magic != (int) 0xCAFEBABE)\n+    throw_class_format_error (\"bad magic number\");\n+\n+  pool_count = read2u ();\n+\n+  read_constpool ();\n+\n+  int access_flags = read2u ();\n+  int this_class = read2u ();\n+  int super_class = read2u ();\n+\n+  check_tag (this_class, JV_CONSTANT_Class);\n+  if (super_class != 0) \n+    check_tag (super_class, JV_CONSTANT_Class);\n+\n+  handleClassBegin (access_flags, this_class, super_class);\n+\n+  int interfaces_count = read2u (); \n+\t\n+  handleInterfacesBegin (interfaces_count);\n+\n+  for (int i = 0; i < interfaces_count; i++)\n+    {\n+      int iface = read2u ();\n+      check_tag (iface, JV_CONSTANT_Class);\n+      handleInterface (i, iface);\n+    }\n+  \n+  read_fields ();\n+  read_methods ();\n+  \n+  int attributes_count = read2u ();\n+  \n+  for (int i = 0; i < attributes_count; i++)\n+    {\n+      read_one_class_attribute ();\n+    }\n+\n+  if (pos != len)\n+    throw_class_format_error (\"unused data before end of file\");\n+\n+  // tell everyone we're done.\n+  def->state = JV_STATE_LOADED;\n+  def->notifyAll ();\n+\n+}\n+\n+void _Jv_ClassReader::read_constpool ()\n+{\n+  tags    = (unsigned char*) _Jv_AllocBytesChecked (pool_count);\n+  offsets = (unsigned int *) _Jv_AllocBytesChecked (sizeof (int)\n+\t\t\t\t\t\t    * pool_count) ;\n+\n+  /** first, we scan the constant pool, collecting tags and offsets */\n+  tags[0]   = JV_CONSTANT_Undefined;\n+  offsets[0] = pos;\n+  for (int c = 1; c < pool_count; c++)\n+    {\n+      tags[c]    = read1u ();\n+      offsets[c] = pos;\n+\n+      switch (tags[c])\n+\t{\n+\tcase JV_CONSTANT_String:\n+\tcase JV_CONSTANT_Class:\n+\t  skip (2);\n+\t  break;\n+\n+\tcase JV_CONSTANT_Fieldref:\n+\tcase JV_CONSTANT_Methodref:\n+\tcase JV_CONSTANT_InterfaceMethodref:\n+\tcase JV_CONSTANT_NameAndType:\n+\tcase JV_CONSTANT_Integer:\n+\tcase JV_CONSTANT_Float:\n+\t  skip (4);\n+\t  break;\n+\n+\tcase JV_CONSTANT_Double:\n+\tcase JV_CONSTANT_Long:\n+\t  skip (8);\n+\t  tags[++c] = JV_CONSTANT_Undefined;\n+\t  break;\n+\t    \n+\tcase JV_CONSTANT_Utf8:\n+\t  {\t\t    \n+\t    int len = read2u ();\n+\t    skip (len);\n+\t  }\n+\t  break;\n+\n+\tcase JV_CONSTANT_Unicode:\n+\t  throw_class_format_error (\"unicode not supported\");\n+\t  break;\n+\n+\tdefault:\n+\t  throw_class_format_error (\"erroneous constant pool tag\");\n+\t}\n+    }\n+\n+  handleConstantPool ();\n+}\n+\n+\n+void _Jv_ClassReader::read_fields ()\n+{\n+  int fields_count = read2u ();\n+  handleFieldsBegin (fields_count);\n+\n+  for (int i = 0; i < fields_count; i++)\n+    {\n+      int access_flags     = read2u ();\n+      int name_index       = read2u ();\n+      int descriptor_index = read2u ();\n+      int attributes_count = read2u ();\n+      \n+      check_tag (name_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (name_index, JV_CONSTANT_Utf8);\n+\n+      check_tag (descriptor_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (descriptor_index, JV_CONSTANT_Utf8);\n+      \n+      handleField (i, access_flags, name_index, descriptor_index);\n+      \n+      for (int j = 0; j < attributes_count; j++)\n+\t{\n+\t  read_one_field_attribute (i);\n+\t}\n+    }\n+\n+  handleFieldsEnd ();\n+}\n+\n+bool\n+_Jv_ClassReader::is_attribute_name (int index, char *name)\n+{\n+  check_tag (index, JV_CONSTANT_Utf8);\n+  int len = get2u (bytes+offsets[index]);\n+  if (len != (int) strlen (name))\n+    return false;\n+  else\n+    return !memcmp (bytes+offsets[index]+2, name, len);\n+}\n+\n+void _Jv_ClassReader::read_one_field_attribute (int field_index)\n+{\n+  int name = read2u ();\n+  int length = read4 ();\n+\n+  if (is_attribute_name (name, \"ConstantValue\"))\n+    {\n+      int cv = read2u ();\n+\n+      if (cv < pool_count \n+\t  && cv > 0\n+\t  && (tags[cv] == JV_CONSTANT_Integer\n+\t      || tags[cv] == JV_CONSTANT_Float\n+\t      || tags[cv] == JV_CONSTANT_Long\n+\t      || tags[cv] == JV_CONSTANT_Double\n+\t      || tags[cv] == JV_CONSTANT_String))\n+\t  {\n+\t    handleConstantValueAttribute (field_index, cv);\n+\t  }\n+\telse\n+\t  {\n+\t    throw_class_format_error (\"erroneous ConstantValue attribute\");\n+\t  }\n+\n+\tif (length != 2) \n+\t  throw_class_format_error (\"erroneous ConstantValue attribute\");\n+      }\n+\n+    else\n+      {\n+\tskip (length);\n+      }\n+}\n+\n+void _Jv_ClassReader::read_methods ()\n+{\n+  int methods_count = read2u ();\n+  \n+  handleMethodsBegin (methods_count);\n+  \n+  for (int i = 0; i < methods_count; i++)\n+    {\n+      int access_flags     = read2u ();\n+      int name_index       = read2u ();\n+      int descriptor_index = read2u ();\n+      int attributes_count = read2u ();\n+      \n+      check_tag (name_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (descriptor_index, JV_CONSTANT_Utf8);\n+\n+      check_tag (name_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (descriptor_index, JV_CONSTANT_Utf8);\n+      \n+      handleMethod (i, access_flags, name_index,\n+\t\t    descriptor_index);\n+      \n+      for (int j = 0; j < attributes_count; j++)\n+\t{\n+\t  read_one_method_attribute (i);\n+\t}\n+    }\n+  \n+  handleMethodsEnd ();\n+}\n+\n+void _Jv_ClassReader::read_one_method_attribute (int method_index) \n+{\n+  int name = read2u ();\n+  int length = read4 ();\n+\n+  if (is_attribute_name (name, \"Exceptions\"))\n+    {\n+      /* we ignore this for now */\n+      skip (length);\n+    }\n+  \n+  else if (is_attribute_name (name, \"Code\"))\n+    {\n+      int start_off = pos;\n+      int max_stack = read2u ();\n+      int max_locals = read2u ();\n+      int code_length = read4 ();\n+\n+      int code_start = pos;\n+      skip (code_length);\n+      int exception_table_length = read2u ();\n+\n+      handleCodeAttribute (method_index, \n+\t\t\t   max_stack, max_locals,\n+\t\t\t   code_start, code_length,\n+\t\t\t   exception_table_length);\n+      \n+\n+      for (int i = 0; i < exception_table_length; i++)\n+\t{\n+\t  int start_pc   = read2u ();\n+\t  int end_pc     = read2u ();\n+\t  int handler_pc = read2u ();\n+\t  int catch_type = read2u ();\n+\n+\t  if (start_pc > end_pc\n+\t      || start_pc < 0\n+\t      || end_pc >= code_length\n+\t      || handler_pc >= code_length)\n+\t    throw_class_format_error (\"erroneous exception handler info\");\n+\n+\t  if (! (tags[catch_type] == JV_CONSTANT_Class\n+\t\t || tags[catch_type] == 0))\n+\t    {\n+\t      throw_class_format_error (\"erroneous exception handler info\");\n+\t    }\n+\n+\t  handleExceptionTableEntry (method_index,\n+\t\t\t\t     i,\n+\t\t\t\t     start_pc,\n+\t\t\t\t     end_pc,\n+\t\t\t\t     handler_pc, \n+\t\t\t\t     catch_type);\n+\n+\t}\n+\n+      int attributes_count = read2u ();\n+\n+      for (int i = 0; i < attributes_count; i++)\n+\t{\n+\t  read_one_code_attribute (method_index);\n+\t}\n+\n+      if ((pos - start_off) != length)\n+\tthrow_class_format_error (\"code attribute too short\");\n+    }\n+\n+  else\n+    {\n+      /* ignore unknown attributes */\n+      skip (length);\n+    }\n+}\n+\n+void _Jv_ClassReader::read_one_code_attribute (int /*method*/) \n+{\n+  /* ignore for now, ... later we may want to pick up\n+     line number information, for debugging purposes;\n+     in fact, the whole debugger issue is open!  */\n+\n+  /* int name = */ read2u ();\n+  int length = read4 ();\n+  skip (length);\n+\n+}\n+\n+void _Jv_ClassReader::read_one_class_attribute () \n+{\n+  /* we also ignore the class attributes, ...\n+     some day we'll add inner-classes support. */\n+\n+  /* int name = */ read2u ();\n+  int length = read4 ();\n+  skip (length);\n+}\n+\n+\n+\n+\f\n+/* this section defines the semantic actions of the parser */\n+\n+void _Jv_ClassReader::handleConstantPool ()\n+{\n+  /** now, we actually define the class' constant pool */\n+\n+  // the pool is scanned explicitly by the collector\n+  jbyte *pool_tags = (jbyte*) _Jv_AllocBytesChecked (pool_count);\n+  void **pool_data = (void**) _Jv_AllocBytesChecked (pool_count * sizeof (void*));\n+  \n+  def->constants.tags = pool_tags;\n+  def->constants.data = pool_data;\n+  def->constants.size = pool_count;\n+\n+  // Here we make a pass to collect the strings!   We do this, because\n+  // internally in the GCJ runtime, classes are encoded with .'s not /'s. \n+  // Therefore, we first collect the strings, and then translate the rest\n+  // of the utf8-entries (thus not representing strings) from /-notation\n+  // to .-notation.\n+  for (int i = 1; i < pool_count; i++)\n+    {\n+      if (tags[i] == JV_CONSTANT_String)\n+\t{\n+\t  unsigned char* str_data = bytes + offsets [i];\n+\t  int utf_index = get2u (str_data);\n+\t  check_tag (utf_index, JV_CONSTANT_Utf8);\n+\t  unsigned char *utf_data = bytes + offsets[utf_index];\n+\t  int len = get2u (utf_data);\n+\t  pool_data[i] = (void*)_Jv_makeUtf8Const ((char*)(utf_data+2), len);\n+\t  pool_tags[i] = JV_CONSTANT_String;\n+\t}\n+      else\n+\t{\n+\t  pool_tags[i] = JV_CONSTANT_Undefined;\n+\t}\n+    }\n+\n+  // and now, we scan everything else but strings & utf8-entries.  This\n+  // leaves out those utf8-entries which are not used; which will be left\n+  // with a tag of JV_CONSTANT_Undefined in the class definition.\n+  for (int index = 1; index < pool_count; index++)\n+    {\n+      switch (tags[index])\n+\t{\n+\tcase JV_CONSTANT_Undefined:\n+\tcase JV_CONSTANT_String:\n+\tcase JV_CONSTANT_Utf8:\n+\t  continue;\n+\t  \n+\tdefault:\n+\t  prepare_pool_entry (index, tags[index]);\n+\t}\n+    }  \n+  \n+}\n+\n+/* this is a recursive procedure, which will prepare pool entries as needed.\n+   Which is how we avoid initializing those entries which go unused. */\n+void\n+_Jv_ClassReader::prepare_pool_entry (int index, unsigned char this_tag)\n+{\n+  /* these two, pool_data and pool_tags, point into the class\n+     structure we are currently defining */\n+\n+  unsigned char *pool_tags = (unsigned char*) def->constants.tags;\n+  void         **pool_data = (void**) def->constants.data;\n+\n+  /* this entry was already prepared */\n+  if (pool_tags[index] == this_tag)\n+    return;\n+\n+  /* this_data points to the constant-pool information for the current\n+     constant-pool entry */\n+\n+  unsigned char *this_data = bytes + offsets[index];\n+\n+  switch (this_tag)\n+    {\n+    case JV_CONSTANT_Utf8: \n+      {\n+\t// If we came here, it is because some other tag needs this\n+\t// utf8-entry for type information!  Thus, we translate /'s to .'s in\n+\t// order to accomondate gcj's internal representation.\n+\n+\tint len = get2u (this_data);\n+\tchar *buffer = (char*) alloca (len);\n+\tchar *s = ((char*) this_data)+2;\n+\n+\t/* FIXME: avoid using a buffer here */\n+\tfor (int i = 0; i < len; i++)\n+\t  {\n+\t    if (s[i] == '/')\n+\t      buffer[i] = '.';\n+\t    else\n+\t      buffer[i] = (char) s[i];\n+\t  }\n+\t\n+\tpool_data[index] = (void*)_Jv_makeUtf8Const (buffer, len);\n+\tpool_tags[index] = JV_CONSTANT_Utf8;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_Class:      \n+      {\n+\tint utf_index = get2u (this_data);\n+\tcheck_tag (utf_index, JV_CONSTANT_Utf8);\n+\tprepare_pool_entry (utf_index, JV_CONSTANT_Utf8);\n+\n+\tif (verify)\n+\t  _Jv_VerifyClassName ((_Jv_Utf8Const*)pool_data[utf_index]);\n+\t\t\n+\tpool_data[index] = pool_data[utf_index];\n+\tpool_tags[index] = JV_CONSTANT_Class;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_String:\n+      // already handled before... \n+      break;\n+\t    \n+    case JV_CONSTANT_Fieldref:\n+    case JV_CONSTANT_Methodref:\n+    case JV_CONSTANT_InterfaceMethodref:\n+      {\n+\tint class_index = get2u (this_data);\n+\tint nat_index = get2u (this_data+2);\n+\n+\tcheck_tag (class_index, JV_CONSTANT_Class);\n+\tprepare_pool_entry (class_index, JV_CONSTANT_Class);\t    \n+\n+\tcheck_tag (nat_index, JV_CONSTANT_NameAndType);\n+\tprepare_pool_entry (nat_index, JV_CONSTANT_NameAndType);\n+\n+\t// here, verify the signature and identifier name\n+\tif (verify)\n+\t{\n+\t  _Jv_ushort name_index, type_index;\n+\t  _Jv_loadIndexes ((const void**)&pool_data[nat_index],\n+\t\t\t   name_index, type_index);\n+\n+\t  if (this_tag == JV_CONSTANT_Fieldref)\n+\t    _Jv_VerifyFieldSignature\n+\t      ((_Jv_Utf8Const*)pool_data[type_index]);\n+\t  else\n+\t    _Jv_VerifyMethodSignature\n+\t      ((_Jv_Utf8Const*)pool_data[type_index]);\n+\n+\t  _Jv_Utf8Const* name = (_Jv_Utf8Const*)pool_data[name_index];\n+\n+\t  if (this_tag != JV_CONSTANT_Fieldref\n+\t      && (   _Jv_equalUtf8Consts (name, clinit_name)\n+\t\t  || _Jv_equalUtf8Consts (name, init_name)))\n+\t    /* ignore */;\n+\t  else\n+\t    _Jv_VerifyIdentifier ((_Jv_Utf8Const*)pool_data[name_index]);\n+\t}\n+\t    \n+\t_Jv_storeIndexes (&pool_data[index], class_index, nat_index);\n+\tpool_tags[index] = this_tag;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_NameAndType:\n+      {\n+\t_Jv_ushort name_index = get2u (this_data);\n+\t_Jv_ushort type_index = get2u (this_data+2);\n+\n+\tcheck_tag (name_index, JV_CONSTANT_Utf8);\n+\tprepare_pool_entry (name_index, JV_CONSTANT_Utf8);\t    \n+\n+\tcheck_tag (type_index, JV_CONSTANT_Utf8);\n+\tprepare_pool_entry (type_index, JV_CONSTANT_Utf8);\n+\n+\t_Jv_storeIndexes (&pool_data[index], name_index, type_index);\n+\tpool_tags[index] = JV_CONSTANT_NameAndType;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_Float:\n+      {\n+\tjfloat f = int_bits_to_float ((jint) get4 (this_data));\n+\t_Jv_storeFloat (&pool_data[index], f);\n+\tpool_tags[index] = JV_CONSTANT_Float;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_Integer:\n+      {\n+\tint i = get4 (this_data);\n+\t_Jv_storeInt (&pool_data[index], i);\n+\tpool_tags[index] = JV_CONSTANT_Integer;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_Double:\n+      {\n+\tjdouble d = long_bits_to_double ((jlong) get8 (this_data));\n+\t_Jv_storeDouble (&pool_data[index], d);\n+\tpool_tags[index] = JV_CONSTANT_Double;\n+      }\n+      break;\n+\t    \n+    case JV_CONSTANT_Long:\n+      {\n+\tjlong i = get8 (this_data);\n+\t_Jv_storeLong (&pool_data[index], i);\n+\tpool_tags[index] = JV_CONSTANT_Long;\n+      }\n+      break;\n+\t    \n+    default:\n+      throw_class_format_error (\"erroneous constant pool tag\");\n+    }\n+}\n+\n+\n+void\n+_Jv_ClassReader::handleClassBegin\n+  (int access_flags, int this_class, int super_class)\n+{\n+  unsigned char *pool_tags = (unsigned char*) def->constants.tags;\n+  void         **pool_data = (void**) def->constants.data;\n+\n+  check_tag (this_class, JV_CONSTANT_Class);\n+  _Jv_Utf8Const *loadedName = (_Jv_Utf8Const*)pool_data[this_class];\n+\n+  // was ClassLoader.defineClass called with an expected class name?\n+  if (def->name == 0)\n+    {\n+      jclass orig = _Jv_FindClassInCache (loadedName, def->loader);\n+\n+      if (orig == 0)\n+\t{\n+\t  def->name = loadedName;\n+\t}\n+      else\n+\t{\n+\t  jstring msg = JvNewStringUTF (\"anonymous \"\n+\t\t\t\t\t\"class data denotes \"\n+\t\t\t\t\t\"existing class \");\n+\t  msg = msg->concat (orig->getName ());\n+\n+\t  throw_no_class_def_found_error (msg);\n+\t}\n+    }\n+\n+  // assert that the loaded class has the expected name, 5.3.5\n+  else if (! _Jv_equalUtf8Consts (loadedName, def->name))\n+    {\n+      jstring msg = JvNewStringUTF (\"loaded class \");\n+      msg = msg->concat (def->getName ());\n+      msg = msg->concat (_Jv_NewStringUTF (\" was in fact named \"));\n+      jstring klass_name = _Jv_NewStringUTF (loadedName->data);\n+      msg = msg->concat (klass_name);\n+\n+      throw_no_class_def_found_error (msg);\n+    }\n+\n+  def->accflags = access_flags;\n+  pool_data[this_class] = (void*)def;\n+  pool_tags[this_class] = JV_CONSTANT_ResolvedClass;\n+\n+  if (super_class == 0)\n+    {\n+      // interfaces have java.lang.Object as super.\n+      if (access_flags & INTERFACE)\n+\t{\n+\t  def->superclass = (jclass)&ClassObject;\n+\t}\n+\n+      // FIXME: Consider this carefully!  \n+      else if (!_Jv_equalUtf8Consts (def->name, ClassObject.name))\n+\t{\n+\t  throw_no_class_def_found_error (\"loading java.lang.Object\");\n+\t}\n+    }\n+\n+  // In the pre-loading state, it can be looked up in the\n+  // cache only by this thread!  This allows the super-class\n+  // to include references to this class.\n+\n+  def->state = JV_STATE_PRELOADING;\n+  _Jv_RegisterClass (def);\n+\n+  if (super_class != 0)\n+    {\n+      // load the super class\n+      check_tag (super_class, JV_CONSTANT_Class);\n+      _Jv_Utf8Const* super_name =\n+\t(_Jv_Utf8Const*)pool_data[super_class]; \n+\n+      // load the super class using our defining loader\n+      jclass the_super = _Jv_FindClass (super_name,\n+\t\t\t\t\tdef->loader);\n+\n+      // This will establish that we are allowed to be a subclass,\n+      // and check for class circularity error\n+      checkExtends (def, the_super);\n+\n+      def->superclass = the_super;\n+      pool_data[super_class] = (void*) the_super;\n+      pool_tags[super_class] = JV_CONSTANT_ResolvedClass;\n+    }\n+\t    \n+  // now we've come past the circularity problem, we can \n+  // now say that we're loading...\n+\n+  def->state = JV_STATE_LOADING;\n+  def->notifyAll ();\n+}\n+\n+///// implements the checks described in sect. 5.3.5.3\n+void\n+_Jv_ClassReader::checkExtends (jclass sub, jclass super)\n+{\n+  // having an interface or a final class as a superclass is no good\n+  if ((super->accflags & (INTERFACE | FINAL)) != 0)\n+    {\n+      throw_incompatible_class_change_error (sub->getName ());\n+    }\n+\n+  // if the super class is not public, we need to check some more\n+  if ((super->accflags & PUBLIC) == 0)\n+    {\n+      // With package scope, the classes must have the same\n+      // class loader.\n+      if (   sub->loader != super->loader\n+\t  || !_Jv_ClassNameSamePackage (sub->name, super->name))\n+\t{\n+\t  throw_incompatible_class_change_error (sub->getName ());\n+\t}\n+    } \n+\n+  for (; super != 0; super = super->superclass)\n+    {\n+      if (super == sub)\n+\tthrow_class_circularity_error (sub->getName ());\n+    }\n+}\n+\n+\n+\n+void _Jv_ClassReader::handleInterfacesBegin (int count)\n+{\n+  def->interfaces = (jclass*) _Jv_AllocBytesChecked (count*sizeof (jclass));\n+  def->interface_count = count;\n+}\n+\n+void _Jv_ClassReader::handleInterface (int if_number, int offset)\n+{\n+  void          ** pool_data = def->constants.data;\n+  unsigned char  * pool_tags = (unsigned char*) def->constants.tags;\n+\n+  jclass the_interface;\n+\n+  if (pool_tags[offset] == JV_CONSTANT_Class)\n+    {\n+      _Jv_Utf8Const* name = (_Jv_Utf8Const*) pool_data[offset];\n+      the_interface =  _Jv_FindClass (name, def->loader);\n+    }\n+  else if (pool_tags[offset] == JV_CONSTANT_ResolvedClass)\n+    {\n+      the_interface = (jclass)pool_data[offset];\n+    }\n+  else\n+    {\n+      throw_no_class_def_found_error (\"erroneous constant pool tag\");\n+    }\n+\n+  // checks the validity of the_interface, and that we are in fact\n+  // allowed to implement that interface.\n+  checkImplements (def, the_interface);\n+  \n+  pool_data[offset] = (void*)the_interface;\n+  pool_tags[offset] = JV_CONSTANT_ResolvedClass;\n+  \n+  def->interfaces[if_number] = the_interface;\n+}\n+\n+void\n+_Jv_ClassReader::checkImplements (jclass sub, jclass super)\n+{\n+  // well, it *must* be an interface\n+  if ((super->accflags & INTERFACE) == 0)\n+    {\n+      throw_incompatible_class_change_error (sub->getName ());\n+    }\n+\n+  // if it has package scope, it must also be defined by the \n+  // same loader.\n+  if ((super->accflags & PUBLIC) == 0)\n+    {\n+      if (    sub->loader != super->loader\n+\t  || !_Jv_ClassNameSamePackage (sub->name, super->name))\n+\t{\n+\t  throw_incompatible_class_change_error (sub->getName ());\n+\t}\n+    } \n+\n+  // FIXME: add interface circularity check here\n+  if (sub == super)\n+    {\n+      throw_class_circularity_error (sub->getName ());\n+    }\t\t\n+}\n+\n+void _Jv_ClassReader::handleFieldsBegin (int count)\n+{\n+  def->fields = (_Jv_Field*) \n+    _Jv_AllocBytesChecked (count * sizeof (_Jv_Field));\n+  def->field_count = count;\n+  def->field_initializers = (_Jv_ushort*)\n+    _Jv_AllocBytesChecked (count * sizeof (_Jv_ushort));\n+  for (int i = 0; i < count; i++)\n+    def->field_initializers[i] = (_Jv_ushort) 0;\n+}\n+\n+void _Jv_ClassReader::handleField (int field_no,\n+\t\t\t\t   int flags,\n+\t\t\t\t   int name,\n+\t\t\t\t   int desc)\n+{\n+  void **const pool_data = def->constants.data;\n+\n+  _Jv_Field *field = &def->fields[field_no];\n+  _Jv_Utf8Const *field_name = (_Jv_Utf8Const*) pool_data[name];\n+\n+#ifndef COMPACT_FIELDS\n+  field->name      = field_name;\n+#else\n+  field->nameIndex = name;\n+#endif\n+\n+  if (verify)\n+    _Jv_VerifyIdentifier (field_name);\n+\n+  // ignore flags we don't know about.  \n+  field->flags = flags & ALL_FLAGS;\n+\n+  if (verify)\n+    {\n+      if (field->flags & (SYNCHRONIZED|NATIVE|INTERFACE|ABSTRACT))\n+\tthrow_class_format_error (\"erroneous field access flags\");\n+      \n+      if (1 < ( ((field->flags & PUBLIC) ? 1 : 0)\n+\t\t+((field->flags & PRIVATE) ? 1 : 0)\n+\t\t+((field->flags & PROTECTED) ? 1 : 0)))\n+\tthrow_class_format_error (\"erroneous field access flags\");\n+    }\n+\n+  _Jv_Utf8Const* sig = (_Jv_Utf8Const*) pool_data[desc];\n+\n+  if (verify)\n+    _Jv_VerifyFieldSignature (sig);\n+\n+  // field->type is really a jclass, but while it is still\n+  // unresolved we keep an _Jv_Utf8Const* instead.\n+  field->type       = (jclass) sig;\n+  field->flags     |= _Jv_FIELD_UNRESOLVED_FLAG;\n+  field->u.boffset  = 0;\n+}\n+\n+\n+void _Jv_ClassReader::handleConstantValueAttribute (int field_index, \n+\t\t\t\t\t\t    int value)\n+{\n+  _Jv_Field *field = &def->fields[field_index];\n+\n+  if ((field->flags & (STATIC|FINAL|PRIVATE)) == 0)\n+    {\n+      // Ignore, as per vmspec #4.7.2\n+      return;\n+    }\n+\n+  // do not allow multiple constant fields!\n+  if (field->flags & _Jv_FIELD_CONSTANT_VALUE)\n+    throw_class_format_error (\"field has multiple ConstantValue attributes\");\n+\n+  field->flags |= _Jv_FIELD_CONSTANT_VALUE;\n+  def->field_initializers[field_index] = value;\n+\n+  /* type check the initializer */\n+  \n+  if (value <= 0 || value >= pool_count)\n+    throw_class_format_error (\"erroneous ConstantValue attribute\");\n+\n+  /* FIXME: do the rest */\n+}\n+\n+void _Jv_ClassReader::handleFieldsEnd ()\n+{\n+  // We need to reorganize the fields so that the static ones are first,\n+  // to conform to GCJ class layout.\n+\n+  int low            = 0;\n+  int high           = def->field_count-1;\n+  _Jv_Field  *fields = def->fields;\n+  _Jv_ushort *inits  = def->field_initializers;\n+\n+  // this is kind of a raw version of quicksort.\n+  while (low < high)\n+    {\n+      // go forward on low, while it's a static\n+      while (low < high && (fields[low].flags & STATIC) != 0)\n+\tlow++;\n+      \n+      // go backwards on high, while it's a non-static\n+      while (low < high && (fields[high].flags & STATIC) == 0)\n+\thigh--;\n+\n+      if (low==high)\n+\tbreak;\n+\n+      _Jv_Field  tmp  = fields[low];\n+      _Jv_ushort itmp = inits[low];\n+\t  \n+      fields[low] = fields[high];\n+      inits[low]  = inits[high];\n+\t  \n+      fields[high] = tmp;\n+      inits[high]  = itmp;\n+\t  \n+      high -= 1;\n+      low  += 1;\n+    }\n+  \n+  if ((fields[low].flags & STATIC) != 0) \n+    low += 1;\n+\n+  def->static_field_count = low;\n+}\n+\n+\n+\n+void _Jv_ClassReader::handleMethodsBegin (int count)\n+{\n+  def->methods = (_Jv_Method*)\n+    _Jv_AllocBytesChecked (sizeof (_Jv_Method)*count);\n+\n+  def->interpreted_methods = (_Jv_InterpMethod**)\n+    _Jv_AllocBytesChecked (sizeof (_Jv_InterpMethod*) * count);\n+\n+  for (int i = 0; i < count; i++)\n+    def->interpreted_methods[i] = 0;\n+\n+  def->method_count = count;\n+}\n+\n+\n+void _Jv_ClassReader::handleMethod \n+    (int mth_index, int accflags, int name, int desc)\n+{ \n+  void **const pool_data = def->constants.data;\n+  _Jv_Method *method = &def->methods[mth_index];\n+\n+  check_tag (name, JV_CONSTANT_Utf8);\n+  prepare_pool_entry (name, JV_CONSTANT_Utf8);\n+  method->name = (_Jv_Utf8Const*)pool_data[name];\n+\n+  check_tag (desc, JV_CONSTANT_Utf8);\n+  prepare_pool_entry (desc, JV_CONSTANT_Utf8);\n+  method->signature = (_Jv_Utf8Const*)pool_data[desc];\n+\n+  // ignore unknown flags\n+  method->accflags = accflags & ALL_FLAGS;\n+\n+  // intialize...\n+  method->ncode = 0;\n+  \n+  if (verify)\n+    {\n+      if (_Jv_equalUtf8Consts (method->name, clinit_name)\n+\t  || _Jv_equalUtf8Consts (method->name, init_name))\n+\t/* ignore */;\n+      else\n+\t_Jv_VerifyIdentifier (method->name);\n+\n+      _Jv_VerifyMethodSignature (method->signature);\n+\n+      if (method->accflags & (VOLATILE|TRANSIENT|INTERFACE))\n+\tthrow_class_format_error (\"erroneous method access flags\");\n+      \n+      if (1 < ( ((method->accflags & PUBLIC) ? 1 : 0)\n+\t\t+((method->accflags & PRIVATE) ? 1 : 0)\n+\t\t+((method->accflags & PROTECTED) ? 1 : 0)))\n+\tthrow_class_format_error (\"erroneous method access flags\");\n+    }\n+}\n+\n+void _Jv_ClassReader::handleCodeAttribute\n+  (int method_index, int max_stack, int max_locals, \n+   int code_start, int code_length, int exc_table_length)\n+{\n+  int size = _Jv_InterpMethod::size (exc_table_length, code_length);\n+  _Jv_InterpMethod *method = \n+    (_Jv_InterpMethod*) (_Jv_AllocBytesChecked (size));\n+\n+  method->max_stack      = max_stack;\n+  method->max_locals     = max_locals;\n+  method->code_length    = code_length;\n+  method->exc_count      = exc_table_length;\n+  method->defining_class = def;\n+  method->self           = &def->methods[method_index];\n+\n+  // grab the byte code!\n+  memcpy ((void*) method->bytecode (),\n+\t  (void*) (bytes+code_start),\n+\t  code_length);\n+  \n+  def->interpreted_methods[method_index] = method;\n+\n+  /* that's all we do for now */\n+}\n+\n+void _Jv_ClassReader::handleExceptionTableEntry \n+  (int method_index, int exc_index, \n+   int start_pc, int end_pc, int handler_pc, int catch_type)\n+{\n+  _Jv_InterpMethod *method = def->interpreted_methods[method_index];\n+  _Jv_InterpException *exc = method->exceptions ();\n+\n+  exc[exc_index].start_pc     = start_pc;\n+  exc[exc_index].end_pc       = end_pc;\n+  exc[exc_index].handler_pc   = handler_pc;\n+  exc[exc_index].handler_type = catch_type;\n+}\n+\n+void _Jv_ClassReader::handleMethodsEnd ()\n+{\n+  for (int i = 0; i < def->method_count; i++)\n+    {\n+      _Jv_Method *method = &def->methods[i];\n+      if (method->accflags & (NATIVE|ABSTRACT))\n+\t{\n+\t  if (def->interpreted_methods[i] != 0)\n+\t    throw_class_format_error (\"code provided \"\n+\t\t\t\t      \"for abstract or native method\");\n+\t}\n+      else\n+\t{\n+\t  if (def->interpreted_methods[i] == 0)\n+\t    throw_class_format_error (\"abstract or native method \"\n+\t\t\t\t      \"with no code\");\n+\t}\n+    }\n+\n+}\n+\n+\f\n+/** This section takes care of verifying integrity of identifiers,\n+    signatures, field ddescriptors, and class names */\n+\n+#define UTF8_PEEK(PTR, LIMIT) \\\n+  ({ unsigned char* xxkeep = (PTR); \\\n+     int xxch = UTF8_GET(PTR,LIMIT); \\\n+     PTR = xxkeep; xxch; })\n+\n+/* verify one element of a type descriptor or signature */\n+static unsigned char*\n+_Jv_VerifyOne (unsigned char* ptr, unsigned char* limit, bool void_ok)\n+{\n+  if (ptr >= limit)\n+    return 0;\n+\n+  int ch = UTF8_GET (ptr, limit);\n+\n+  switch (ch)\n+    {\n+    case 'V':\n+      if (! void_ok) return 0;\n+\n+    case 'S': case 'B': case 'I': case 'J':\n+    case 'Z': case 'C': case 'F': case 'D': \n+      break;\n+\n+    case 'L':\n+      {\n+\tunsigned char *start = ptr, *end;\n+\tdo {\n+\t  if (ptr > limit)\n+\t    return 0;\n+\t\t\n+\t  end = ptr;\n+\t\t\n+\t  if ((ch = UTF8_GET (ptr, limit)) == -1)\n+\t    return 0;\n+\t\t\n+\t} while (ch != ';');\n+\t_Jv_VerifyClassName (start, (unsigned short) (end-start));\n+      }\n+      break;\n+\n+    case '[':\n+      return _Jv_VerifyOne (ptr, limit, false);\n+      break;\n+\t\n+    default:\n+      return 0;\n+    }\n+\n+  return ptr;\n+    \n+}\n+\n+\n+/** verification and loading procedures **/\n+\n+void\n+_Jv_VerifyFieldSignature (_Jv_Utf8Const*sig)\n+{\n+  unsigned char* ptr = (unsigned char*) sig->data;\n+  unsigned char* limit = ptr + sig->length;\n+\n+  ptr = _Jv_VerifyOne (ptr, limit, false);\n+\n+  if (ptr != limit)\n+    throw_class_format_error (\"erroneous type descriptor\");\n+}\n+\n+void\n+_Jv_VerifyMethodSignature (_Jv_Utf8Const*sig)\n+{\n+  unsigned char* ptr = (unsigned char*) sig->data;\n+  unsigned char* limit = ptr + sig->length;\n+\n+  if (ptr == limit)\n+    throw_class_format_error (\"erroneous type descriptor\");\n+\n+  if (UTF8_GET(ptr,limit) != '(')\n+    throw_class_format_error (\"erroneous type descriptor\");\n+\n+  while (ptr && UTF8_PEEK (ptr, limit) != ')')\n+    ptr = _Jv_VerifyOne (ptr, limit, false);\n+    \n+  if (UTF8_GET (ptr, limit) != ')')\n+    throw_class_format_error (\"erroneous type descriptor\");\n+\n+  // get the return type\n+  ptr = _Jv_VerifyOne (ptr, limit, true);\n+\n+  if (ptr != limit)\n+    throw_class_format_error (\"erroneous type descriptor\");\n+\n+  return;\n+\n+}\n+\n+/* we try to avoid calling the Character methods all the time, \n+   in fact, they will only be called for non-standard things */\n+\n+static __inline__ int \n+is_identifier_start (int c)\n+{\n+  unsigned int ch = (unsigned)c;\n+\n+  if ((ch - 0x41U) < 29U) \t\t/* A ... Z */\n+    return 1;\n+  if ((ch - 0x61U) < 29U) \t\t/* a ... z */\n+    return 1;\n+  if (ch == 0x5FU)       \t\t/* _ */\n+    return 1;\n+\n+  return character->isJavaIdentifierStart ((jchar) ch);\n+}\n+\n+static __inline__ int \n+is_identifier_part (int c)\n+{\n+  unsigned int ch = (unsigned)c;\n+\n+  if ((ch - 0x41U) < 29U) \t\t/* A ... Z */\n+    return 1;\n+  if ((ch - 0x61U) < 29U) \t\t/* a ... z */\n+    return 1;\n+  if ((ch - 0x30) < 10U)       \t\t/* 0 .. 9 */\n+    return 1;\n+  if (ch == 0x5FU || ch == 0x24U)       /* _ $ */\n+    return 1;\n+\n+  return character->isJavaIdentifierStart ((jchar) ch);\n+}\n+\n+void \n+_Jv_VerifyIdentifier (_Jv_Utf8Const* name)\n+{\n+  unsigned char *ptr   = (unsigned char*) name->data;\n+  unsigned char *limit = ptr + name->length;\n+  int ch;\n+\n+  if ((ch = UTF8_GET (ptr, limit))==-1\n+      || ! is_identifier_start (ch))\n+    throw_class_format_error (\"erroneous identifier\");\n+\n+  while (ptr != limit)\n+    {\n+      if ((ch = UTF8_GET (ptr, limit))==-1\n+\t  || ! is_identifier_part (ch))\n+\tthrow_class_format_error (\"erroneous identifier\");\n+    }\n+}\n+\n+\n+void\n+_Jv_VerifyClassName (unsigned char* ptr, _Jv_ushort length)\n+{\n+  unsigned char *limit = ptr+length;\n+  int ch;\n+\n+ next_level:\n+  do {\n+    if ((ch = UTF8_GET (ptr, limit))==-1)\n+      throw_class_format_error (\"erroneous class name\");\n+    if (! is_identifier_start (ch))\n+      throw_class_format_error (\"erroneous class name\");\n+    do {\n+      if (ptr == limit)\n+\treturn;\n+      else if ((ch = UTF8_GET (ptr, limit))==-1)\n+\tthrow_class_format_error (\"erroneous class name\");\n+      else if (ch == '.')\n+\tgoto next_level;\n+      else if (! is_identifier_part (ch))\n+\tthrow_class_format_error (\"erroneous class name\");\n+    } while (true);\n+  } while (true);\n+\n+}\n+\n+void\n+_Jv_VerifyClassName (_Jv_Utf8Const *name)\n+{\n+    _Jv_VerifyClassName ((unsigned char*)&name->data[0],\n+\t\t\t (_Jv_ushort) name->length);\n+}\n+\n+\n+/** returns true, if name1 and name2 represents classes in the same\n+    package. */\n+    \n+bool\n+_Jv_ClassNameSamePackage (_Jv_Utf8Const *name1, _Jv_Utf8Const *name2)\n+{\n+  unsigned char* ptr1 = (unsigned char*) name1->data;\n+  unsigned char* limit1 = ptr1 + name1->length;\n+\n+  unsigned char* last1 = ptr1;\n+\n+  // scan name1, and find the last occurrence of '.'\n+  while (ptr1 < limit1) {\n+    int ch1 = UTF8_GET (ptr1, limit1);\n+\n+    if (ch1 == '.')\n+      last1 = ptr1;\n+\t\n+    else if (ch1 == -1)\n+      return false;\n+  }\n+\n+  // now the length of name1's package name is len\n+  int len = last1 - (unsigned char*) name1->data;\n+\n+  // if this is longer than name2, then we're off\n+  if (len > name2->length)\n+    return false;\n+\n+  // then compare the first len bytes for equality\n+  if (memcmp ((void*) name1->data, (void*) name2->data, len) == 0)\n+    {\n+      // check that there are no .'s after position len in name2\n+\n+      unsigned char* ptr2 = (unsigned char*) name2->data + len;\n+      unsigned char* limit2 =\n+\t(unsigned char*) name2->data + name2->length;\n+\n+      while (ptr2 < limit2)\n+\t{\n+\t  int ch2 = UTF8_GET (ptr2, limit2);\n+\t  if (ch2 == -1 || ch2 == '.')\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n+\f\n+/** Here we define the exceptions that can be thrown */\n+\n+static void\n+throw_no_class_def_found_error (jstring msg)\n+{\n+  if (msg == 0)\n+    JvThrow (new java::lang::NoClassDefFoundError);\n+  else\n+    JvThrow (new java::lang::NoClassDefFoundError (msg));\n+}\n+\n+static void\n+throw_no_class_def_found_error (char *msg)\n+{\n+  throw_no_class_def_found_error (JvNewStringLatin1 (msg));\n+}\n+\n+static void\n+throw_class_format_error (jstring msg)\n+{\n+  if (msg == 0)\n+    JvThrow (new java::lang::ClassFormatError);\n+  else\n+    JvThrow (new java::lang::ClassFormatError (msg));\n+}\n+\n+static void\n+throw_class_format_error (char *msg)\n+{\n+  throw_class_format_error (JvNewStringLatin1 (msg));\n+}\n+\n+static void\n+throw_internal_error (char *msg)\n+{\n+  JvThrow \n+    (new java::lang::InternalError (JvNewStringLatin1 (msg)));\n+}\n+\n+static jfloat int_bits_to_float (jint value)\n+{\n+  return java::lang::Float::intBitsToFloat (value);\n+}\n+\n+static jdouble long_bits_to_double (jlong value)\n+{\n+  return java::lang::Double::longBitsToDouble (value);\n+}\n+\n+static void throw_incompatible_class_change_error (jstring msg)\n+{\n+  JvThrow (new java::lang::IncompatibleClassChangeError (msg));\n+}\n+\n+static void throw_class_circularity_error (jstring msg)\n+{\n+  JvThrow (new java::lang::ClassCircularityError (msg));\n+}\n+\n+#endif /* INTERPRETER */\n+"}, {"sha": "f29e82520d1ec886a59d923746c64f2e71bebd2b", "filename": "libjava/gij.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgij.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgij.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgij.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,27 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+#include <jvm.h>\n+#include <cni.h>\n+#include <stdio.h>\n+\n+#include <java/lang/System.h>\n+#include <java/util/Properties.h>\n+\n+int main (int argc, const char **argv)\n+{\n+  if (argc < 2)\n+    {\n+      printf (\"usage: %s <class name> args\\n\", argv[0]);\n+      exit (1);\n+    }\n+\n+  JvRunMain (0, argc, argv);\n+}"}, {"sha": "d1664bae414cc34e17c1d155cede2ba9fa881d3b", "filename": "libjava/gnu/gcj/runtime/MethodInvocation.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FMethodInvocation.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,32 @@\n+// MethodInvocation.java - wrapper used by the interpreter.\n+// (the native method is implemented in interpret.cc)\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author:  Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.runtime;\n+\n+import gnu.gcj.RawData;\n+\n+final class MethodInvocation {\n+\n+  private static Throwable continue0 (RawData meth, RawData inv)\n+  {\n+    try {\n+      continue1 (meth, inv);\n+    } catch (Throwable ex) {\n+      return ex;\n+    }\n+    return null;\n+  }\n+\n+  private static native void continue1 (RawData meth, RawData inv);\n+\n+}"}, {"sha": "949200b7a29124822177d5b728488e9b6d47b0ad", "filename": "libjava/gnu/gcj/util/path/CacheEntry.java", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FCacheEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FCacheEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FCacheEntry.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,65 @@\n+// CacheEntry.java -- directory cache\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+\n+final class CacheEntry {\n+    String   dir;\n+    String[] files;\n+    long     time;\n+    \n+    CacheEntry (String d)\n+    {\n+\tdir = d;\n+\tfiles = new File(dir).list();\n+\ttime = System.currentTimeMillis ();\n+    }\n+    \n+    void touch ()\n+    {\n+\ttime = System.currentTimeMillis ();\n+    }\n+    \n+    final long EXPIRATION_TIME_MS = 1000;\n+    \n+    boolean is_old () {\n+\treturn (System.currentTimeMillis () - time) > EXPIRATION_TIME_MS;\n+    }\n+    \n+    public int hashCode () { return dir.hashCode(); }\n+    boolean contains (String file) { \n+\tif (files == null)\n+\t    return false;\n+\t\n+\tint index = file.lastIndexOf(SearchPath.file_seperator_char);\n+\tString f;\n+\t\n+\tif (index == -1)\n+\t    f = file;\n+\telse\n+\t    f = file.substring (index+1);\n+\t\n+\tfor (int i = 0; i < files.length; i++)\n+\t    {\n+\t\tif (f.equals (files[i])) return true;\n+\t    }\n+\t\n+\treturn false;\n+    }\n+}\n+"}, {"sha": "a9ca602341be61dc262ed561899985ffac28defe", "filename": "libjava/gnu/gcj/util/path/DirectoryPathEntry.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FDirectoryPathEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FDirectoryPathEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FDirectoryPathEntry.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,136 @@\n+// DirectoryPathEntry.java -- search path element for directories\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+final class DirectoryPathEntry extends PathEntry\n+{\n+  final File dir;\n+  final String base_canon;\n+\n+  public String toString () { return base_canon; }\n+\n+  DirectoryPathEntry (File f)\n+    throws java.io.IOException\n+  {\n+    if (!f.isAbsolute ())\n+      throw new IllegalArgumentException ();\n+\n+    dir = f; \n+    base_canon = dir.getCanonicalPath ();\n+  }\n+\n+  /*\n+   *  We maintain a cache of files, so that we \n+   *  can avoid many calls to stat(), which are\n+   *  very expensive.\n+   *\n+   *  seen_cache contains (as keys) the directories \n+   *  which we have visited so far.  The values are \n+   *  instances of CacheEntry, containing a time stamp,\n+   *  and a list of files in that directory.\n+   *\n+   */\n+\n+  private Hashtable seen_cache = new Hashtable ();\n+\n+  private boolean in_cache (File f)\n+  {\n+    String rel_dir = f.getParent ();\n+    CacheEntry ent;\n+\n+    if (rel_dir == null)\n+      throw new IllegalArgumentException ();\n+\n+    ent = (CacheEntry) seen_cache.get (rel_dir);\n+    if (ent == null)\n+      {\n+\tent = new CacheEntry (rel_dir);\n+\tseen_cache.put (rel_dir, ent);\n+      }\n+\n+    if (ent.contains (f.getPath ()))\n+      {\n+\treturn true;\n+      }\n+\n+    if ( ent.is_old () )\n+      {\n+\tif (f.exists ())\n+\t  {\n+\t    seen_cache.remove (rel_dir);\n+\t    return true;\n+\t  }\n+\telse\n+\t  {\n+\t    ent.touch ();\n+\t  }\n+      }\n+\n+    return false;\n+  }\n+\n+  URL getURL (String file) {\n+    try {\n+      File f = new File((new File (dir, file).getCanonicalPath ()));\n+\t    \n+      if (! f.getCanonicalPath ().startsWith (base_canon))\n+\tthrow new IllegalArgumentException (file);\n+\n+\t\t\n+      if (in_cache (f))\n+\treturn new URL (\"file\", \"\", f.getPath ());\n+      else\n+\treturn null;\n+\n+    } catch (IOException x) {\n+      return null;\n+    }\n+  }\n+\n+  InputStream getStream (String file) {\n+    try {\t\t\t\n+      File f = new File((new File (dir, file)).getCanonicalPath ());\n+\n+      if (! f.getCanonicalPath ().startsWith (base_canon))\n+\tthrow new IllegalArgumentException (file);\n+\n+      if (in_cache (f))\n+\treturn new FileInputStream (f);\n+      else\n+\treturn null;\n+    } catch (IOException x) {\n+      return null;\n+    }\n+  }\n+\n+  byte[] getBytes (String file) {\n+    File f = new File (dir, file);\n+\n+    try {\t\t\t\n+      if (in_cache (f))\n+\treturn readbytes (new FileInputStream (f),\n+\t\t\t  (int) f.length ());\n+      else\n+\treturn null;\n+    } catch (IOException x) {\n+      return null;\n+    }\n+  }\n+\n+}\n+"}, {"sha": "f83fc1701702c0e3709754934baa59ba48e5f0af", "filename": "libjava/gnu/gcj/util/path/PathEntry.java", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FPathEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FPathEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FPathEntry.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,55 @@\n+// PathEntry.java -- abstract element of search paths\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+abstract class PathEntry {\n+  abstract URL getURL (String file);\n+  abstract InputStream getStream (String file);\n+  abstract byte[] getBytes (String file);\n+\n+  /**\n+   *  Utility routine like InputStream.read(byte[], 0, len), but will\n+   *  read fully, even if all the data is not available at once.  \n+   */\n+  protected static byte[] readbytes (InputStream is, int length)\n+  {\n+    try {\n+\n+      byte[] data = new byte[length];\n+      int read; \n+      int off = 0;\n+\t    \n+      while (off != length)\n+\t{\n+\t  read = is.read (data, off, (int) (length-off));\n+\n+\t  if (read == -1) \n+\t    return null;\n+\n+\t  off += read;\n+\t}\n+\t    \n+      return data;\n+    } catch (IOException x) {\n+      return null;\n+    }\n+  }\n+\n+}\n+\n+"}, {"sha": "ffc2ca8d1789d03b0956b6ce819f4c47e31961b6", "filename": "libjava/gnu/gcj/util/path/SearchPath.java", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FSearchPath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FSearchPath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FSearchPath.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,205 @@\n+// SearchPath.java -- generic search path utility\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+final public class SearchPath {\n+\n+    final static String path_seperator\n+      = System.getProperty (\"path.separator\");\n+    final static char   path_seperator_char\n+      = path_seperator.charAt (0);\n+    final static String file_seperator\n+      = System.getProperty (\"file.separator\");\n+    final static char   file_seperator_char\n+      = file_seperator.charAt (0);\n+\n+    private Vector path;\n+\n+    /**\n+     *  Constructs a SearchPath object, given a system path.\n+     *  The system path is expected to be seperated by the string \n+     *  defined by the <code>path.seperator</code> property.  \n+     *  (<code>\":\"</code> on unix, <code>;</code> on Windows, etc.).\n+     *  The path may contain names of directories, or names of\n+     *  .zip or .jar files.  Elements that are neither of these\n+     *  are ignored.\n+     * @param sys_path the search path\n+     */\n+\n+    SearchPath (String sys_path)\n+    {\n+\tStringTokenizer st = new StringTokenizer (sys_path, path_seperator);\n+\tinit (st);\n+    }\n+\n+    /**\n+     *  Constructs a SearchPath object, given a Vector of \n+     *  <code>String</code>, <code>File</code> or <code>URL</code>\n+     *  objects.  \n+     *  The path may contain names of directories, or names of\n+     *  .zip or .jar files.  Elements that are neither of these\n+     *  are ignored.\n+     * @param p the vector of search path elements\n+     */\n+\n+    SearchPath (Vector p)\n+    {\n+\tinit (p.elements ());\n+    }\n+\n+    public URL getURL (String element)\n+    {\n+\tURL result;\n+\n+\tEnumeration e = path.elements ();\n+\twhile (e.hasMoreElements ())\n+\t    {\n+\t\tPathEntry ent = (PathEntry) e.nextElement ();\n+\n+\t\tresult = ent.getURL (element);\n+\t\t\n+\t\tif (result != null) \n+\t\t    {\n+\t\t\treturn result;\n+\t\t    }\n+\t    }\n+\n+\treturn null;\n+    }\n+    \n+\n+    public InputStream getStream (String element)\n+    {\n+\tInputStream result;\n+\n+\tEnumeration e = path.elements ();\n+\twhile (e.hasMoreElements ())\n+\t    {\n+\t\tPathEntry ent = (PathEntry) e.nextElement ();\n+\n+\t\tresult = ent.getStream (element);\n+\t\t\n+\t\tif (result != null) \n+\t\t    {\n+\t\t\treturn result;\n+\t\t    }\n+\t    }\n+\n+\treturn null;\n+    }\n+    \n+\n+    public byte[] getBytes (String element)\n+    {\n+\tbyte[] result;\n+\n+\tEnumeration e = path.elements ();\n+\twhile (e.hasMoreElements ())\n+\t    {\n+\t\tPathEntry ent = (PathEntry) e.nextElement ();\n+\t\tresult = ent.getBytes (element);\t\t\n+\t\tif (result != null) \n+\t\t    {\n+\t\t\tSystem.out.println (\"loading \" + ent \n+\t\t\t\t\t    + \"(\" + element + \")\");\n+\t\t\treturn result;\n+\t\t    }\n+\t    }\n+\n+\treturn null;\n+    }\n+    \n+\n+\n+    private void init (Enumeration st)\n+    {\n+\tpath = new Vector ();\n+\twhile (st.hasMoreElements ()) \n+\t    {  \n+\t\tObject e = st.nextElement ();\n+\n+\t\tString elem;\n+\t\tFile efile;\n+\n+\t\tif (e instanceof URL)\n+\t\t    {\n+\t\t\tpath.addElement (new URLPathEntry ((URL) e));\n+\t\t\tcontinue;\n+\t\t    }\n+\n+\t\tif (e instanceof File)\n+\t\t    {\n+\t\t\tefile = (File) e; \n+\t\t\telem = efile.getPath ();\n+\t\t    }\n+\n+\t\telse if (e instanceof String)\n+\t\t    {\n+\t\t\telem = (String) e;\n+\t\t\tefile   = new File (elem); \n+\t\t    }\n+\n+\t\telse\n+\t\t    throw new IllegalArgumentException ();\n+\n+\t\t// make sure it is absolute, so we won't get \n+\t\t// trouble if the cwd is changed...\n+\t\tif (! efile.isAbsolute ())\n+\t\t    efile = new File (efile.getAbsolutePath ());\n+\n+\t\tif (efile.isDirectory ())\n+\t\t    {\n+\t\t\ttry {\n+\t\t\t    path.addElement(new DirectoryPathEntry (efile));\n+\t\t\t} catch (IOException x) {\n+\t\t\t    /* ignore for now */\n+\t\t\t}\n+\t\t    }\n+\n+\t\telse if (efile.isFile ())\n+\t\t    {\n+\t\t\tint ext = elem.lastIndexOf ('.');\n+\t\t\tif (ext == -1)\n+\t\t\t    continue;\n+\n+\t\t\tif (!elem.substring(ext+1).equalsIgnoreCase(\"zip\"))\n+\t\t\t    continue;\n+\n+\t\t\tZipPathEntry zpe = null;\n+\t\t\ttry {\n+\t\t\t    zpe = new ZipPathEntry (efile);\n+\t\t\t} catch (ZipException zx) {\n+\t\t\t    System.err.println (\"SearchPath::ZipException\");\n+\t\t\t    zpe = null;\n+\t\t\t} catch (MalformedURLException mx) {\n+\t\t\t    System.err.println (\"SearchPath::URLException\");\n+\t\t\t    zpe = null;\n+\t\t\t} catch (IOException iox) {\n+\t\t\t    System.err.println (\"SearchPath::IOException\");\n+\t\t\t    zpe = null;\n+\t\t\t}\n+\t\t\tif (zpe != null) path.addElement (zpe);\n+\t\t    }\n+\t    }\n+\t\n+    }\n+    \n+    \n+}\n+"}, {"sha": "68f9200b555bc0449fb6f28c152d8e2233e2ca36", "filename": "libjava/gnu/gcj/util/path/URLPathEntry.java", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FURLPathEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FURLPathEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FURLPathEntry.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,67 @@\n+// URLPathEntry.java -- search path element for URL's\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+final class URLPathEntry extends PathEntry {\n+    final URL base;\n+\n+    URLPathEntry (URL f) {\n+\tbase = f;\n+    }\n+\n+    public String toString () { return base.toString (); }\n+\n+    URL getURL (String file) {\n+\n+\ttry {\n+\t    URL res = new URL (base, file);\n+\t    InputStream is = res.openStream (); // exc if not found\n+\t    is.close ();\n+\t    return res;\n+\t} catch (java.io.IOException x) {\n+\t    return null;\n+\t}\n+    }\n+\n+    InputStream getStream (String file) {\n+\n+\ttry {\n+\t    URL res = new URL (base, file);\n+\t    return res.openStream ();\n+\t} catch (java.io.IOException x) {\n+\t    return null;\n+\t}\n+\n+    }\n+\n+    byte[] getBytes (String file) {\n+\n+\ttry {\n+\t    URL res = new URL (base, file);\n+\t    URLConnection conn = res.openConnection ();\n+\t    int len = conn.getContentLength ();\n+\t    if (len == -1) return null;\n+\t    return readbytes (conn.getInputStream (), len);\n+\t} catch (java.io.IOException x) {\n+\t    return null;\n+\t}\n+\n+    }\n+\n+}\n+"}, {"sha": "ac0226290a54592cb1672138d958370616735bbc", "filename": "libjava/gnu/gcj/util/path/ZipPathEntry.java", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FZipPathEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FZipPathEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2Fpath%2FZipPathEntry.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,86 @@\n+// ZipPathEntry.java -- search path element for directories\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package gnu.gcj.util.path;\n+\n+import java.util.*;\n+import java.util.zip.*;\n+import java.io.*;\n+import java.net.*;\n+\n+\n+final class ZipPathEntry extends PathEntry {\n+    final ZipFile zip;\n+    final URL     file;\n+\n+    public String toString () { return zip.getName (); }\n+\n+    ZipPathEntry (File f) \n+\tthrows MalformedURLException, ZipException, IOException\n+    {\n+\tfile = new URL (\"file\", \"\", f.getPath ());\n+\tzip  = new ZipFile (f);\n+\tzip.readDirectory ();\n+    }\n+\n+    /* \n+       The url for a zip-file resource is,\n+\t   \n+       <code>file:///path/file.zip#name</code>\n+\t   \n+       Then, it is URLConnection's problem to handle that.\n+    */\n+\n+    URL getURL (String f) {\n+\n+\tZipEntry ent = zip.getEntry (f);\n+\n+\ttry {\n+\t    if (ent != null)\n+\t\treturn new URL (file, \"#\"+f);\n+\t    else\n+\t\treturn null;\n+\t} catch (IOException x) {\n+\t    return null;\n+\t}\n+    }\n+\n+    InputStream getStream (String f) {\n+\n+\tZipEntry ent = zip.getEntry (f);\n+\n+\ttry {\n+\t    if (ent != null)\n+\t\treturn zip.getInputStream (ent);\n+\t    else\n+\t\treturn null;\n+\t} catch (IOException x) {\n+\t    return null;\n+\t}\n+    }\n+\n+    byte[] getBytes (String f) {\n+\tZipEntry ent = zip.getEntry (f);\n+\n+\ttry {\n+\t    if (ent != null)\n+\t\treturn readbytes (zip.getInputStream (ent),\n+\t\t\t\t  (int) ent.getSize ());\n+\t    else\n+\t\treturn null;\n+\t} catch (IOException x) {\n+\t    return null;\n+\t}\n+\t    \n+    }\n+}\n+"}, {"sha": "03f51baca78ea9646e6a841ec6e4deac4658f760", "filename": "libjava/include/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fconfig.h.in?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -106,6 +106,9 @@\n #undef HAVE_GETHOSTBYNAME_R\n #undef HAVE_GETHOSTBYADDR_R\n \n+/* Define if you want a bytecode interpreter.  */\n+#undef INTERPRETER\n+\n /* Define if you have the access function.  */\n #undef HAVE_ACCESS\n "}, {"sha": "f4d7ef9910a0443a921e28f7a42e4d69b0434fac", "filename": "libjava/include/java-cpool.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-cpool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-cpool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-cpool.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,173 @@\n+// java-cpool.h - Constant pool parsing header.  -*- c++ -*-\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_CPOOL_H__\n+#define __JAVA_CPOOL_H__\n+\n+#include <javaprims.h>\n+\n+// we rename these, to avoid polluting the name space\n+#define JV_CONSTANT_Undefined (0L)\n+#define JV_CONSTANT_Utf8 (1L)\n+#define JV_CONSTANT_Unicode (2L)\n+#define JV_CONSTANT_Integer (3L)\n+#define JV_CONSTANT_Float (4L)\n+#define JV_CONSTANT_Long (5L)\n+#define JV_CONSTANT_Double (6L)\n+#define JV_CONSTANT_Class (7L)\n+#define JV_CONSTANT_String (8L)\n+#define JV_CONSTANT_Fieldref (9L)\n+#define JV_CONSTANT_Methodref (10L)\n+#define JV_CONSTANT_InterfaceMethodref (11L)\n+#define JV_CONSTANT_NameAndType (12L)\n+#define JV_CONSTANT_ResolvedFlag (16L)\n+#define JV_CONSTANT_ResolvedString (16L | 8L)\n+#define JV_CONSTANT_ResolvedClass  (16L | 7L)\n+\n+/* We use the following two operations uniformly for all put/get operations\n+ * in the runtime system (constant pool & stack), to assure that we keep\n+ * everything in the same format.  The idea is, that these should be inlined\n+ * away, into just a simple store (for small data types, and a pair of stores\n+ * if double or long has alignment greater than void *.  On an 64-bit\n+ * architecture, all operations should be simple stores; on a 32-bit\n+ * architecture it depends on the alignment requirement for the specific\n+ * type.  */\n+\n+template <class T>\n+static inline void _Jv_put (void *dst, T value)\n+{\n+#if 0\n+  if (sizeof (T) == 8 && __alignof__ (T) > __alignof__ (void*))\n+    {\n+      jint *v_dst  = (jint*)(dst);\n+      jint *v_src  = (jint*)&value;\n+\n+      v_dst[0] = v_src[0];\n+      v_dst[1] = v_src[1];\n+    }\n+  else \n+#endif\n+    {\n+      *((T*) (dst)) = value;\n+    }\n+}\n+\n+template <class T>\n+static inline T _Jv_get (void *src)\n+{\n+#if 0\n+  if (sizeof (T) == 8 && __alignof__ (T) > __alignof__ (void*))\n+    {\n+      T     value;\n+      jint *v_dst  = (jint*)&value;\n+      jint *v_src  = (jint*)src;\n+\n+      v_dst[0] = v_src[0];\n+      v_dst[1] = v_src[1];\n+\n+      return value;\n+    }\n+  else \n+#endif\n+    {\n+      return *((T*) (src));\n+    }\n+}\n+\n+/** needed to keep the CONSTANT_XXXRef & CONSTANT_NameAndType entries */\n+extern inline void \n+_Jv_storeIndexes (void **data,\n+\t\t _Jv_ushort index0,\n+\t\t _Jv_ushort index1)\n+{\n+  // accomodate 64bit machines...\n+  if (sizeof (void*) == (2 * sizeof (jint)))\n+    {\n+      ((jint*)data)[0] = index0;\n+      ((jint*)data)[1] = index0;\n+    }\n+  else\n+    {\n+      _Jv_put<jint>(data, ((jint)index0 << 16) | (jint)index1);\n+    }\n+}\n+\n+extern inline void \n+_Jv_loadIndexes (const void **data,\n+\t\t _Jv_ushort& index0,\n+\t\t _Jv_ushort& index1)\n+{\n+  if (sizeof (void*) == (2*sizeof (jint)))\n+    {\n+      index0 = ((jint*)data)[0];\n+      index0 = ((jint*)data)[1];\n+    }\n+  else\n+    {\n+      jint udata = _Jv_get<jint>(data);\n+      \n+      _Jv_uint uindex0 = ((udata >> 16) & 0xffff);\n+      _Jv_uint uindex1 = udata & 0xffff;\n+      \n+      index0 = uindex0;\n+      index1 = uindex1;\n+    }\n+}\n+\n+extern inline void\n+_Jv_storeFloat (void **data, jfloat f)\n+{\n+  _Jv_put<jfloat>(data, f);\n+}\n+\n+extern inline jfloat\n+_Jv_loadFloat (void **data)\n+{\n+  return _Jv_get<jfloat>(data);\n+}\n+\n+extern inline void\n+_Jv_storeInt (void **data, jint i)\n+{\n+  _Jv_put<jint>(data, i);\n+}\n+\n+extern inline jint\n+_Jv_loadInt (void **data)\n+{\n+  return _Jv_get<jint>(data);\n+}\n+\n+extern inline void\n+_Jv_storeLong (void **data, jlong l)\n+{\n+  return _Jv_put<jlong>(data, l);\n+}\n+\n+extern inline jlong\n+_Jv_loadLong (void **data)\n+{\n+  return _Jv_get<jlong>(data);\n+}\n+\n+extern inline void\n+_Jv_storeDouble (void **data, jdouble d)\n+{\n+  _Jv_put<jdouble>(data, d);\n+}\n+\n+extern inline jdouble\n+_Jv_loadDouble (void **data)\n+{\n+  return _Jv_get<jdouble> (data);\n+}\n+\n+\n+#endif /* __JAVA_CPOOL_H__ */"}, {"sha": "d00d9ce7726097a18e53ffe291f1ac118a5a756b", "filename": "libjava/include/java-field.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-field.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -53,7 +53,18 @@ struct _Jv_Field\n \n   jfieldID getNextInstanceField () { return this + 1; }\n \n-  jboolean isRef () { return ! isResolved () || ! type->isPrimitive (); }\n+  jboolean isRef () \n+    { \n+      if (!isResolved ()) \n+\t{\n+\t  char first = ((_Jv_Utf8Const*)type)->data[0]; \n+\t  return first == '[' || first == 'L';\n+\t}\n+      else\n+\t{\n+\t  return ! type->isPrimitive ();\n+\t}\n+    }\n \n   // FIXME - may need to mask off internal flags.\n   int getModifiers() { return flags; }"}, {"sha": "8b19abd58ad830bb0a95ab7b962b1ec19bdb0845", "filename": "libjava/include/java-insns.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-insns.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-insns.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-insns.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,247 @@\n+// java-insns.h - Instruction encodings. This is -*- c++ -*-\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+static const int op_nop = 0x00;\n+static const int op_aconst_null = 0x01;\n+static const int op_iconst_m1 = 0x02;\n+static const int op_iconst_0 = 0x03;\n+static const int op_iconst_1 = 0x04;\n+static const int op_iconst_2 = 0x05;\n+static const int op_iconst_3 = 0x06;\n+static const int op_iconst_4 = 0x07;\n+static const int op_iconst_5 = 0x08;\n+static const int op_lconst_0 = 0x09;\n+static const int op_lconst_1 = 0x0a;\n+static const int op_fconst_0 = 0x0b;\n+static const int op_fconst_1 = 0x0c;\n+static const int op_fconst_2 = 0x0d;\n+static const int op_dconst_0 = 0x0e;\n+static const int op_dconst_1 = 0x0f;\n+static const int op_bipush = 0x10;\n+static const int op_sipush = 0x11;\n+static const int op_ldc = 0x12;\n+static const int op_ldc_w = 0x13;\n+static const int op_ldc2_w = 0x14;\n+static const int op_iload = 0x15;\n+static const int op_lload = 0x16;\n+static const int op_fload = 0x17;\n+static const int op_dload = 0x18;\n+static const int op_aload = 0x19;\n+static const int op_iload_0 = 0x1a;\n+static const int op_iload_1 = 0x1b;\n+static const int op_iload_2 = 0x1c;\n+static const int op_iload_3 = 0x1d;\n+static const int op_lload_0 = 0x1e;\n+static const int op_lload_1 = 0x1f;\n+static const int op_lload_2 = 0x20;\n+static const int op_lload_3 = 0x21;\n+static const int op_fload_0 = 0x22;\n+static const int op_fload_1 = 0x23;\n+static const int op_fload_2 = 0x24;\n+static const int op_fload_3 = 0x25;\n+static const int op_dload_0 = 0x26;\n+static const int op_dload_1 = 0x27;\n+static const int op_dload_2 = 0x28;\n+static const int op_dload_3 = 0x29;\n+static const int op_aload_0 = 0x2a;\n+static const int op_aload_1 = 0x2b;\n+static const int op_aload_2 = 0x2c;\n+static const int op_aload_3 = 0x2d;\n+static const int op_iaload = 0x2e;\n+static const int op_laload = 0x2f;\n+static const int op_faload = 0x30;\n+static const int op_daload = 0x31;\n+static const int op_aaload = 0x32;\n+static const int op_baload = 0x33;\n+static const int op_caload = 0x34;\n+static const int op_saload = 0x35;\n+static const int op_istore = 0x36;\n+static const int op_lstore = 0x37;\n+static const int op_fstore = 0x38;\n+static const int op_dstore = 0x39;\n+static const int op_astore = 0x3a;\n+static const int op_istore_0 = 0x3b;\n+static const int op_istore_1 = 0x3c;\n+static const int op_istore_2 = 0x3d;\n+static const int op_istore_3 = 0x3e;\n+static const int op_lstore_0 = 0x3f;\n+static const int op_lstore_1 = 0x40;\n+static const int op_lstore_2 = 0x41;\n+static const int op_lstore_3 = 0x42;\n+static const int op_fstore_0 = 0x43;\n+static const int op_fstore_1 = 0x44;\n+static const int op_fstore_2 = 0x45;\n+static const int op_fstore_3 = 0x46;\n+static const int op_dstore_0 = 0x47;\n+static const int op_dstore_1 = 0x48;\n+static const int op_dstore_2 = 0x49;\n+static const int op_dstore_3 = 0x4a;\n+static const int op_astore_0 = 0x4b;\n+static const int op_astore_1 = 0x4c;\n+static const int op_astore_2 = 0x4d;\n+static const int op_astore_3 = 0x4e;\n+static const int op_iastore = 0x4f;\n+static const int op_lastore = 0x50;\n+static const int op_fastore = 0x51;\n+static const int op_dastore = 0x52;\n+static const int op_aastore = 0x53;\n+static const int op_bastore = 0x54;\n+static const int op_castore = 0x55;\n+static const int op_sastore = 0x56;\n+static const int op_pop = 0x57;\n+static const int op_pop2 = 0x58;\n+static const int op_dup = 0x59;\n+static const int op_dup_x1 = 0x5a;\n+static const int op_dup_x2 = 0x5b;\n+static const int op_dup2 = 0x5c;\n+static const int op_dup2_x1 = 0x5d;\n+static const int op_dup2_x2 = 0x5e;\n+static const int op_swap = 0x5f;\n+static const int op_iadd = 0x60;\n+static const int op_ladd = 0x61;\n+static const int op_fadd = 0x62;\n+static const int op_dadd = 0x63;\n+static const int op_isub = 0x64;\n+static const int op_lsub = 0x65;\n+static const int op_fsub = 0x66;\n+static const int op_dsub = 0x67;\n+static const int op_imul = 0x68;\n+static const int op_lmul = 0x69;\n+static const int op_fmul = 0x6a;\n+static const int op_dmul = 0x6b;\n+static const int op_idiv = 0x6c;\n+static const int op_ldiv = 0x6d;\n+static const int op_fdiv = 0x6e;\n+static const int op_ddiv = 0x6f;\n+static const int op_irem = 0x70;\n+static const int op_lrem = 0x71;\n+static const int op_frem = 0x72;\n+static const int op_drem = 0x73;\n+static const int op_ineg = 0x74;\n+static const int op_lneg = 0x75;\n+static const int op_fneg = 0x76;\n+static const int op_dneg = 0x77;\n+static const int op_ishl = 0x78;\n+static const int op_lshl = 0x79;\n+static const int op_ishr = 0x7a;\n+static const int op_lshr = 0x7b;\n+static const int op_iushr = 0x7c;\n+static const int op_lushr = 0x7d;\n+static const int op_iand = 0x7e;\n+static const int op_land = 0x7f;\n+static const int op_ior = 0x80;\n+static const int op_lor = 0x81;\n+static const int op_ixor = 0x82;\n+static const int op_lxor = 0x83;\n+static const int op_iinc = 0x84;\n+static const int op_i2l = 0x85;\n+static const int op_i2f = 0x86;\n+static const int op_i2d = 0x87;\n+static const int op_l2i = 0x88;\n+static const int op_l2f = 0x89;\n+static const int op_l2d = 0x8a;\n+static const int op_f2i = 0x8b;\n+static const int op_f2l = 0x8c;\n+static const int op_f2d = 0x8d;\n+static const int op_d2i = 0x8e;\n+static const int op_d2l = 0x8f;\n+static const int op_d2f = 0x90;\n+static const int op_i2b = 0x91;\n+static const int op_i2c = 0x92;\n+static const int op_i2s = 0x93;\n+static const int op_lcmp = 0x94;\n+static const int op_fcmpl = 0x95;\n+static const int op_fcmpg = 0x96;\n+static const int op_dcmpl = 0x97;\n+static const int op_dcmpg = 0x98;\n+static const int op_ifeq = 0x99;\n+static const int op_ifne = 0x9a;\n+static const int op_iflt = 0x9b;\n+static const int op_ifge = 0x9c;\n+static const int op_ifgt = 0x9d;\n+static const int op_ifle = 0x9e;\n+static const int op_if_icmpeq = 0x9f;\n+static const int op_if_icmpne = 0xa0;\n+static const int op_if_icmplt = 0xa1;\n+static const int op_if_icmpge = 0xa2;\n+static const int op_if_icmpgt = 0xa3;\n+static const int op_if_icmple = 0xa4;\n+static const int op_if_acmpeq = 0xa5;\n+static const int op_if_acmpne = 0xa6;\n+static const int op_goto = 0xa7; \n+static const int op_jsr = 0xa8;\n+static const int op_ret = 0xa9;\n+static const int op_tableswitch = 0xaa;\n+static const int op_lookupswitch = 0xab;\n+static const int op_ireturn = 0xac;\n+static const int op_lreturn = 0xad;\n+static const int op_freturn = 0xae;\n+static const int op_dreturn = 0xaf;\n+static const int op_areturn = 0xb0;\n+static const int op_return = 0xb1;\n+static const int op_getstatic = 0xb2;\n+static const int op_putstatic = 0xb3;\n+static const int op_getfield = 0xb4;\n+static const int op_putfield = 0xb5;\n+static const int op_invokevirtual = 0xb6;\n+static const int op_invokespecial = 0xb7;\n+static const int op_invokestatic = 0xb8;\n+static const int op_invokeinterface = 0xb9;\n+static const int op_xxxunusedxxx1 = 0xba;\n+static const int op_new = 0xbb;\n+static const int op_newarray = 0xbc;\n+static const int op_anewarray = 0xbd;\n+static const int op_arraylength = 0xbe;\n+static const int op_athrow = 0xbf;\n+static const int op_checkcast = 0xc0;\n+static const int op_instanceof = 0xc1;\n+static const int op_monitorenter = 0xc2;\n+static const int op_monitorexit = 0xc3;\n+static const int op_wide = 0xc4;\n+static const int op_multianewarray = 0xc5;\n+static const int op_ifnull = 0xc6;\n+static const int op_ifnonnull = 0xc7;\n+static const int op_goto_w = 0xc8;\n+static const int op_jsr_w = 0xc9;\n+\n+// new opcodes\n+\n+static const int op_putfield_1 = 0xca;\n+static const int op_putfield_2 = 0xcb;\n+static const int op_putfield_4 = 0xcd;\n+static const int op_putfield_8 = 0xce;\n+static const int op_putfield_a = 0xcf;\n+\n+static const int op_putstatic_1 = 0xd0;\n+static const int op_putstatic_2 = 0xd1;\n+static const int op_putstatic_4 = 0xd2;\n+static const int op_putstatic_8 = 0xd3;\n+static const int op_putstatic_a = 0xd4;\n+\n+static const int op_getfield_1 = 0xd5;\n+static const int op_getfield_2s = 0xd6;\n+static const int op_getfield_2u = 0xd7;\n+static const int op_getfield_4 = 0xd8;\n+static const int op_getfield_8 = 0xd9;\n+static const int op_getfield_a = 0xda;\n+\n+static const int op_getstatic_1 = 0xdb;\n+static const int op_getstatic_2s = 0xdc;\n+static const int op_getstatic_2u = 0xdd;\n+static const int op_getstatic_4 = 0xde;\n+static const int op_getstatic_8 = 0xdf;\n+static const int op_getstatic_a = 0xe0;\n+\n+static const int op_invokefinal  = 0xe1;\n+static const int op_invokevtable = 0xe2;\n+\n+\n+\n+"}, {"sha": "70feec19beb3aaeefa205845f7ce0dd70e6508de", "filename": "libjava/include/java-interp.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,172 @@\n+// java-interp.h - Header file for the bytecode interpreter.  -*- c++ -*-\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_INTERP_H__\n+#define __JAVA_INTERP_H__\n+\n+#include <config.h>\n+\n+#include <jvm.h>\n+#include <java-cpool.h>\n+\n+#ifdef INTERPRETER\n+\n+#pragma interface\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/ClassLoader.h>\n+#include <gnu/gcj/runtime/MethodInvocation.h>\n+\n+extern \"C\" {\n+#include <ffi.h>\n+}\n+\n+extern inline jboolean\n+_Jv_IsInterpretedClass (jclass c)\n+{\n+  return (c->loader != 0);\n+}\n+\n+struct _Jv_ResolvedMethod;\n+\n+void _Jv_VerifyFieldSignature (_Jv_Utf8Const*sig);\n+void _Jv_VerifyMethodSignature (_Jv_Utf8Const*sig);\n+void _Jv_VerifyClassName (unsigned char* ptr, _Jv_ushort length);\n+void _Jv_VerifyClassName (_Jv_Utf8Const *name);\n+void _Jv_VerifyIdentifier (_Jv_Utf8Const *);\n+bool _Jv_ClassNameSamePackage (_Jv_Utf8Const *name1, _Jv_Utf8Const *name2);\n+void _Jv_DefineClass (jclass, jbyteArray, jint, jint);\n+void _Jv_ResolveField (_Jv_Field *, java::lang::ClassLoader*);\n+\n+void _Jv_InitField (jobject, jclass, int);\n+void * _Jv_AllocMethodInvocation (jsize size);\n+\n+/* FIXME: this should really be defined in some more generic place */\n+#define ROUND(V, A) (((((unsigned) (V))-1) | ((A)-1))+1)\n+\n+/* the interpreter is written in C++, primarily because it makes it easy for\n+ * the entire thing to be \"friend\" with class Class. */\n+\n+class _Jv_InterpClass;\n+class _Jv_InterpMethod;\n+class _Jv_InterpMethodInvocation;\n+\n+class _Jv_InterpException {\n+  int  start_pc;\n+  int  end_pc;\n+  int  handler_pc;\n+  int  handler_type;\n+\n+  friend class _Jv_ClassReader;\n+  friend class _Jv_InterpMethod;\n+};\n+\n+class _Jv_InterpMethod {\n+\n+  _Jv_ushort       max_stack;\n+  _Jv_ushort       max_locals;\n+  int              code_length;\n+\n+  _Jv_ushort       exc_count;\n+  _Jv_ushort       args_raw_size;\n+\n+  _Jv_InterpClass *defining_class;\n+  _Jv_Method      *self;\n+\n+  unsigned char* bytecode () \n+  {\n+    return \n+      ((unsigned char*)this) \n+      + ROUND((sizeof (_Jv_InterpMethod)\n+\t       + exc_count*sizeof (_Jv_InterpException)), 4);\n+  }\n+    \n+  _Jv_InterpException * exceptions ()\n+  {\n+    return (_Jv_InterpException*) (this+1);\n+  }\n+\n+  static size_t size (int exc_count, int code_length)\n+  {\n+    return \n+      ROUND ((sizeof (_Jv_InterpMethod) \n+\t      + (exc_count * sizeof (_Jv_InterpException))), 4)\n+      + code_length;\n+  }\n+\n+  // return the method's invocation pointer (a stub).\n+  void *ncode ();\n+  void continue1 (_Jv_InterpMethodInvocation *inv);\n+\n+  static void run_normal (ffi_cif*, void*, void**, void*);\n+  static void run_synch_object (ffi_cif*, void*, void**, void*);\n+  static void run_synch_class (ffi_cif*, void*, void**, void*);\n+\n+  inline jobject run (ffi_cif*, void*, void**, \n+\t\t      _Jv_InterpMethodInvocation*);\n+\n+  bool find_exception (jobject ex,\n+\t\t       _Jv_InterpMethodInvocation *inv);\n+\n+ public:\n+  static void dump_object(jobject o);\n+\n+  friend class _Jv_ClassReader;\n+  friend class _Jv_InterpMethodInvocation;\n+  friend class gnu::gcj::runtime::MethodInvocation;\n+\n+  friend void _Jv_PrepareClass(jclass);\n+\n+  friend void _Jv_callInterpretedMethod (ffi_cif*,\n+\t\t\t\t\t void*,\n+\t\t\t\t\t void **,\n+\t\t\t\t\t void*);\n+};\n+\n+class _Jv_InterpMethodInvocation {\n+  _Jv_InterpMethod *running;\n+  void            **sp;\n+  unsigned char    *pc;\n+  void*             state[0];\n+\n+  void**            stack_base () { return &state[0]; }\n+  void**            local_base () { return &state[running->max_stack]; }\n+\n+  friend class _Jv_InterpMethod;\n+};\n+  \n+class _Jv_InterpClass : public java::lang::Class\n+{\n+  _Jv_InterpMethod **interpreted_methods;\n+  _Jv_ushort        *field_initializers;\n+\n+  friend class _Jv_ClassReader;\n+  friend class _Jv_InterpMethod;\n+  friend void  _Jv_PrepareClass(jclass);\n+  friend void  _Jv_InitField (jobject, jclass, int);\n+  friend void* _Jv_MarkObj (void *, void *, void *, void *);\n+};\n+\n+struct _Jv_ResolvedMethod {\n+  jint            stack_item_count;\t\n+  jint            vtable_index;\t\n+  jclass          klass;\n+  _Jv_Method*     method;\n+\n+  // a resolved method holds the cif in-line, so that _Jv_MarkObj just needs\n+  // to mark the resolved method to hold on to the cif.  Some memory could be\n+  // saved by keeping a cache of cif's, since many will be the same.\n+  ffi_cif         cif;\n+  ffi_type *      arg_types[0];\n+};\n+\n+#endif /* INTERPRETER */\n+\n+#endif /* __JAVA_INTERP_H__ */"}, {"sha": "9d8c0a6eab5c09f31d09d0866a5b7a1d89a229a7", "filename": "libjava/include/javaprims.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjavaprims.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -162,6 +162,7 @@ extern \"Java\"\n       class VerifyError;\n       class VirtualMachineError;\n       class Void;\n+      class VMClassLoader;\n       namespace reflect\n       {\n         class AccessibleObject;"}, {"sha": "34da0edbea9d8c6fea283185d1d53b7196cae52f", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -40,6 +40,8 @@ extern int _Jv_strLengthUtf8(char* str, int len);\n \n typedef struct _Jv_Utf8Const Utf8Const;\n _Jv_Utf8Const *_Jv_makeUtf8Const (char *s, int len);\n+_Jv_Utf8Const *_Jv_makeUtf8TypeConst (char* s, int len);\n+_Jv_Utf8Const *_Jv_makeUtf8Const (jstring string);\n extern jboolean _Jv_equalUtf8Consts (_Jv_Utf8Const *, _Jv_Utf8Const *);\n extern jboolean _Jv_equal (_Jv_Utf8Const *, jstring, jint);\n \n@@ -91,6 +93,8 @@ extern \"C\" void *_Jv_LookupInterfaceMethod (jclass klass, Utf8Const *name,\n extern \"C\" void _Jv_CheckArrayStore (jobject array, jobject obj);\n extern \"C\" void _Jv_RegisterClass (jclass klass);\n extern \"C\" void _Jv_RegisterClasses (jclass *classes);\n+extern void _Jv_UnregisterClass (_Jv_Utf8Const*, java::lang::ClassLoader*);\n+\n extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t\t     java::lang::ClassLoader *loader);\n extern jclass _Jv_FindClassFromSignature (char *,"}, {"sha": "1b9b8006da7b318d7d21e9f003f980993201feee", "filename": "libjava/interpret.cc", "status": "added", "additions": 2449, "deletions": 0, "changes": 2449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,2449 @@\n+// interpret.cc - Code for the interpreter\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+/* define this to get instruction timings.  */\n+/* #define TIME_MAINLOOP  */\n+\n+#include <config.h>\n+\n+#pragma implementation \"java-interp.h\"\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <java-field.h>\n+#include <java-cpool.h>\n+#include <java-interp.h>\n+#include <java/lang/fdlibm.h>\n+#include <java/lang/System.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Integer.h>\n+#include <java/lang/StringBuffer.h>\n+#include <java/io/PrintStream.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java/lang/ClassCastException.h>\n+#include <java/lang/VirtualMachineError.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/ArithmeticException.h>\n+#include <java/lang/IncompatibleClassChangeError.h>\n+#include <java-insns.h>\n+#include <java-signal.h>\n+#ifdef TIME_MAINLOOP\n+#include <sys/time.h>\n+#include <stdio.h>\n+#endif\n+\n+#ifndef INTERPRETER\n+\n+#include <gnu/gcj/runtime/MethodInvocation.h>\n+\n+/* this is the exception handler hack, for the interpreter */\n+void \n+gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *,\n+\t\t\t\t\t\tgnu::gcj::RawData *)\n+{\n+  JvFail (\"no interpreter\");\n+}\n+\n+#else\n+\n+#define ClassError _CL_Q34java4lang5Error\n+extern java::lang::Class ClassError;\n+\n+static const int PUBLIC       = 0x001;\n+static const int PRIVATE      = 0x002;\n+static const int PROTECTED    = 0x004;\n+static const int STATIC       = 0x008;\n+static const int FINAL        = 0x010;\n+static const int SYNCHRONIZED = 0x020;\n+static const int VOLATILE     = 0x040;\n+static const int TRANSIENT    = 0x080;\n+static const int NATIVE       = 0x100;\n+static const int INTERFACE    = 0x200;\n+static const int ABSTRACT     = 0x400;\n+static const int ALL_FLAGS    = 0x7FF; \n+\n+static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n+\n+static void throw_internal_error (char *msg)\n+  __attribute__ ((__noreturn__));\n+static void throw_incompatible_class_change_error (jstring msg)\n+  __attribute__ ((__noreturn__));\n+#if !HANDLE_SEGV\n+static void throw_null_pointer_exception ()\n+  __attribute__ ((__noreturn__));\n+#endif\n+#if !HANDLE_FPE\n+static void throw_arithmetic_exception ()\n+  __attribute__ ((__noreturn__));\n+#endif\n+\n+\n+static inline void dupx (void **&sp, int n, int x)\n+{\n+  // first \"slide\" n+x elements n to the right\n+  int top = n-1;\n+  for (int i = 0; i < n+x; i++)\n+    {\n+      sp[(top-i)] = sp[(top-i)-n];\n+    }\n+  \n+  // next, copy the n top elements, n+x down\n+  for (int i = 0; i < n; i++)\n+    {\n+      sp[top-(n+x)-i] = sp[top-i];\n+    }\n+  \n+  // the net effect\n+  sp += n;\n+};\n+\n+\n+#define PUSHA(V)  \\\n+ ({ jobject __v=(V); *(jobject*)sp++ = __v; })\n+#define PUSHI(V)  \\\n+ ({ jint __v=(V); *(jint*)sp++ = __v; })\n+#define PUSHF(V)  \\\n+ ({ jfloat __v=(V); *(jfloat*)sp++ = __v; })\n+#define PUSHL(V)  \\\n+ ({ jlong __v=(V); memcpy ((void*)sp, (void*)&__v, 8); sp+=2; })\n+#define PUSHD(V)  \\\n+ ({ jdouble __v=(V); memcpy ((void*)sp, (void*)&__v, 8); sp+=2; })\n+\n+#define POPA()    (*(jobject*)--sp)\n+#define POPI()    (*(jint*)--sp)\n+#define POPF()    (*(jfloat*)--sp)\n+#define POPL()    ({ jlong __r; sp-=2; memcpy ((void*)&__r, sp, 8); __r; })\n+#define POPD()    ({ jdouble __r; sp-=2; memcpy ((void*)&__r, sp, 8); __r; })\n+\n+#define LOADA(I)  *sp++ = locals[I]\n+#define LOADI(I)  *sp++ = locals[I]\n+#define LOADF(I)  *sp++ = locals[I]\n+#define LOADL(I)  ({ memcpy (sp, locals+(I), 8); sp+=2; })\n+#define LOADD(I)  ({ memcpy (sp, locals+(I), 8); sp+=2; })\n+\n+#define STOREA(I) locals[I] = *--sp\n+#define STOREI(I) locals[I] = *--sp\n+#define STOREF(I) locals[I] = *--sp\n+#define STOREL(I) ({ sp-=2; memcpy (locals+(I), sp, 8); })\n+#define STORED(I) ({ sp-=2; memcpy (locals+(I), sp, 8); })\n+\n+#define PEEKI(I)  (*(jint*) (locals+(I)))\n+#define PEEKA(I)  (*(jobject*) (locals+(I)))\n+\n+#define POKEI(I,V)  (*(jint*) (locals+(I)) = (V))\n+\n+\n+#define BINOPI(OP) { \\\n+   jint value2 = POPI(); \\\n+   jint value1 = POPI(); \\\n+   PUSHI(value1 OP value2); \\\n+}\n+\n+#define BINOPF(OP) { \\\n+   jfloat value2 = POPF(); \\\n+   jfloat value1 = POPF(); \\\n+   PUSHF(value1 OP value2); \\\n+}\n+\n+#define BINOPL(OP) { \\\n+   jlong value2 = POPL(); \\\n+   jlong value1 = POPL(); \\\n+   PUSHL(value1 OP value2); \\\n+}\n+\n+#define BINOPD(OP) { \\\n+   jdouble value2 = POPD(); \\\n+   jdouble value1 = POPD(); \\\n+   PUSHD(value1 OP value2); \\\n+}\n+\n+static inline jint get1s(unsigned char* loc) {\n+  return *(signed char*)loc;\n+}\n+\n+static inline jint get1u(unsigned char* loc) {\n+  return *loc;\n+}\n+\n+static inline jint get2s(unsigned char* loc) {\n+  return (((jint)*(signed char*)loc) << 8) | ((jint)*(loc+1));\n+}\n+\n+static inline jint get2u(unsigned char* loc) {\n+  return (((jint)(*loc)) << 8) | ((jint)*(loc+1));\n+}\n+\n+static jint get4(unsigned char* loc) {\n+  return (((jint)(loc[0])) << 24) \n+       | (((jint)(loc[1])) << 16) \n+       | (((jint)(loc[2])) << 8) \n+       | (((jint)(loc[3])) << 0);\n+}\n+\n+\n+#if HANDLE_SEGV\n+#define NULLCHECK(X) \n+#else\n+#define NULLCHECK(X) \\\n+  do { if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n+#endif\n+\n+#if HANDLE_FPE\n+#define ZEROCHECK(X)\n+#else\n+#define ZEROCHECK(X) \\\n+  do { if ((X) == 0) throw_arithmetic_exception (); } while (0)\n+#endif\n+\n+// this method starts the actual running of the method.  It is inlined\n+// in three different variants in the static methods run_normal,\n+// run_sync_object and run_sync_class (see below).  Those static methods\n+// are installed directly in the stub for this method (by\n+// _Jv_InterpMethod::ncode, in resolve.cc).\n+\n+inline jobject\n+_Jv_InterpMethod::run (ffi_cif* cif,\n+\t\t       void *retp,\n+\t\t       void**args,\n+\t\t       _Jv_InterpMethodInvocation *inv)\n+{\n+  inv->running  = this;\n+  inv->pc       = bytecode ();\n+  inv->sp       = inv->stack_base ();\n+  void **locals = inv->local_base ();\n+\n+  /* Go straight at it!  the ffi raw format matches the internal\n+     stack representation exactly!\n+  */\n+  memcpy ((void*) locals, (void*) args, args_raw_size);\n+\n+ next_segment:\n+  /* this will call the method _Jv_InterpMethod::continue0, see below */\n+  jobject ex = \n+    gnu::gcj::runtime::MethodInvocation::continue0\n+    ((gnu::gcj::RawData *)this, (gnu::gcj::RawData *)inv);\n+\n+  if (ex == 0)\t\t\t// no exception...\n+    {\n+      /* define sp locally, so the POP? macros will pick it up */\n+      void **sp = (void**)inv->sp;\n+      int rtype = cif->rtype->type;\n+\n+      if (rtype == FFI_TYPE_POINTER)\n+\t{\n+\t  jobject r = POPA();\n+\t  *(jobject*) retp = r;\n+\t  return 0;\n+\t}\n+      else if (rtype == FFI_TYPE_SINT32)\n+\t{\n+\t  jint r = POPI();\n+\t  *(jint*)retp = r;\n+\t  return 0;\n+\t}\n+      else if (rtype == FFI_TYPE_VOID)\n+\t{\n+\t  return 0;\n+\t}\n+      else switch (rtype)\n+\t{\n+\tcase FFI_TYPE_FLOAT:\n+\t  {\n+\t    jfloat r = POPF();\n+\t    *(jfloat*)retp = r;\n+\t    return 0;\n+\t  }\n+      \n+\tcase FFI_TYPE_DOUBLE:\n+\t  {\n+\t    jdouble r = POPD();\n+\t    *(jdouble*)retp = r;\n+\t    return 0;\n+\t  }\n+\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_SINT16:\n+\t  {\n+\t    jint r = POPI();\n+\t    *(jint*)retp = r;\n+\t    return 0;\n+\t  }\n+      \n+\tcase FFI_TYPE_SINT64:\n+\t  {\n+\t    jlong r = POPL();\n+\t    *(jlong*)retp = r;\n+\t    return 0;\n+\t  }\n+\t\n+\tdefault:\n+\t  throw_internal_error (\"unknown return type\");\n+\t}\n+\n+    }\n+\n+  /** handle an exception */\n+  if ( find_exception (ex, inv) )\n+    goto next_segment;\n+\n+  java::lang::System::out->println \n+    (_Jv_NewStringUTF (self->name->data));\n+\n+  return ex;\n+}\n+\n+bool _Jv_InterpMethod::find_exception (jobject ex,\n+\t\t\t\t       _Jv_InterpMethodInvocation *inv)\n+{\n+  int logical_pc = inv->pc - bytecode ();\n+  _Jv_InterpException *exc = exceptions ();\n+  jclass exc_class = ex->getClass ();\n+\n+  for (int i = 0; i < exc_count; i++)\n+    {\n+      if (exc[i].start_pc <= logical_pc && logical_pc < exc[i].end_pc)\n+\t{\t\n+\t  jclass handler;\n+\n+\t  if (exc[i].handler_type != 0)\n+\t    handler = (jclass)\n+\t      _Jv_ResolvePoolEntry (defining_class, \n+\t\t\t\t    exc[i].handler_type);\n+\t  else\n+\t    handler = NULL;\n+\t  \n+\t  if (handler==NULL || handler->isAssignableFrom (exc_class))\n+\t    {\n+\t      inv->pc = bytecode () + exc[i].handler_pc;\n+\t      inv->sp = inv->stack_base (); // reset stack\n+\t      *(jobject*) (inv->sp ++) = ex;\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+void _Jv_InterpMethod::run_normal (ffi_cif* cif,\n+\t\t\t\t   void* ret,\n+\t\t\t\t   void** args,\n+\t\t\t\t   void* __this)\n+{\n+  _Jv_InterpMethod* _this = (_Jv_InterpMethod*)__this;\n+\n+  // we do the alloca of the method invocation here, to allow the method\n+  // \"run\" ro be inlined.  Otherwise gcc will ignore the inline directive.\n+  int storage_size = _this->max_stack+_this->max_locals;\n+  _Jv_InterpMethodInvocation* inv = (_Jv_InterpMethodInvocation*) \n+    alloca (sizeof (_Jv_InterpMethodInvocation)\n+\t    + storage_size * sizeof (void*));\n+\n+  jobject ex = _this->run (cif, ret, args, inv);\n+  if (ex != 0) _Jv_Throw (ex);\n+}\n+\n+void _Jv_InterpMethod::run_synch_object (ffi_cif* cif,\n+\t\t\t\t\t void* ret,\n+\t\t\t\t\t void** args,\n+\t\t\t\t\t void* __this)\n+{\n+  _Jv_InterpMethod* _this = (_Jv_InterpMethod*)__this;\n+  jobject rcv = (jobject)args[0];\n+\n+  int storage_size = _this->max_stack+_this->max_locals;\n+  _Jv_InterpMethodInvocation* inv = (_Jv_InterpMethodInvocation*) \n+    alloca (sizeof (_Jv_InterpMethodInvocation)\n+\t    + storage_size * sizeof (void*));\n+\n+  _Jv_MonitorEnter (rcv);\n+  jobject ex = _this->run (cif, ret, args, inv);\n+  _Jv_MonitorExit (rcv);\n+\n+  if (ex != 0) _Jv_Throw (ex);\n+}\n+\n+void _Jv_InterpMethod::run_synch_class (ffi_cif* cif,\n+\t\t\t\t\tvoid* ret,\n+\t\t\t\t\tvoid** args,\n+\t\t\t\t\tvoid* __this)\n+{\n+  _Jv_InterpMethod* _this = (_Jv_InterpMethod*)__this;\n+  jclass  sync = _this->defining_class;\n+\n+  int storage_size = _this->max_stack+_this->max_locals;\n+  _Jv_InterpMethodInvocation* inv = (_Jv_InterpMethodInvocation*) \n+    alloca (sizeof (_Jv_InterpMethodInvocation)\n+\t    + storage_size * sizeof (void*));\n+\n+  _Jv_MonitorEnter (sync);\n+  jobject ex = _this->run (cif, ret, args, inv);\n+  _Jv_MonitorExit (sync);\n+\n+  if (ex != 0) _Jv_Throw (ex);\n+}\n+\n+/* this is the exception handler hack, for the interpreter */\n+void \n+gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *meth,\n+\t\t\t\t\t\tgnu::gcj::RawData *inv)\n+{\n+  _Jv_InterpMethod           *meth0 = (_Jv_InterpMethod*)meth;\n+  _Jv_InterpMethodInvocation *inv0  = (_Jv_InterpMethodInvocation*)inv;\n+  meth0->continue1 (inv0);\n+}\n+\n+/*\n+  This proceeds execution, as designated in \"inv\".  If an exception\n+  happens, then it is simply thrown, and handled in Java.  Thus, the pc\n+  needs to be stored in the invocation at all times, so we can figure\n+  out which handler (if any) to invoke.\n+\n+  One design issue, which I have not completely considered, is if it\n+  should be possible to have interpreted classes linked in!  Seldom used\n+  (or non-critical) classes could reasonably be interpreted.  \n+*/\n+\n+\n+#ifdef TIME_MAINLOOP\n+static jlong insn_time [256] = { 0 };\n+static jlong insn_count[256] = { 0 };\n+\n+static void\n+dump_time ()\n+{\n+  double total_all = 0;\n+  for (int i = 0; i < 256; i++)\n+    {\n+      total_all += insn_time[i];\n+    }\n+\n+  for (int i = 0; i < 256; i++)\n+    {\n+      jlong total  = insn_time[i];\n+      jlong count  = insn_count[i];\n+\n+      if (count == 0) continue;\n+\n+      jlong amount = total/count;\n+\n+      printf (\"in 0x%02x: %7Li %7Li %7Li %2.1f%%\\n\", i,\n+\t      (long long)count, (long long)total, (long long)amount,\n+\t      (float) (100.0*(double)total/total_all)\n+\t      );\n+    }\n+}\n+#endif\n+  \n+void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n+{\n+  /* for some reason, which I do not understand, the compiler on x86\n+   * allocates almost 4k stack space for this function!  Even though\n+   * there are many local variables, they are all nicely contained\n+   * within a block scope, except for the few declared right below\n+   * here.  What's going on??  It could well be, that there in fact is\n+   * on the order of 1000 local variables, including all those inlined\n+   * and expanded from macros...   Compiling with -O0, it allocates a\n+   * \"modest\" 300 bytes of stack space.   Among all those options of\n+   * gcc, why isn't there a -fpack-stack, allowing reuse of stack\n+   * locations?  */\n+  \n+  void**         sp     = inv->sp;\n+  unsigned char *pc     = inv->pc;\n+  void**         locals = inv->local_base ();\n+  int            opcode;\n+\n+  jclass defining_class = this->defining_class;\n+  void **pool_data      = defining_class->constants.data;\n+  \n+  /* these two are used in the invokeXXX instructions */\n+  void (*fun)(...);\n+  _Jv_ResolvedMethod* rmeth;\n+\n+#ifdef TIME_MAINLOOP\n+  struct timeval tv;\n+  int   last_opcode;\n+  jlong last_time;\n+  static jlong time_warp = 0;\n+\n+#define USEC(TV) \\\n+   ((jlong) (TV).tv_sec * 1000000LL + (jlong)(TV).tv_usec)\n+\n+\n+  if (time_warp == 0) \n+    {\n+      struct timeval tv2;\n+\n+      gettimeofday (&tv, 0); \n+      for (int i = 0; i < 100; i++)\n+\tgettimeofday (&tv2, 0); \n+      \n+      jlong then = USEC(tv); \n+      jlong now = USEC(tv2);\n+      time_warp = (now - then) / 100;\n+\n+      if (time_warp == 0)\n+\ttime_warp = 1;\n+    }    \n+\n+#define TIME_SUSPEND do { \\\n+  gettimeofday (&tv, 0); \\\n+  jlong now = USEC(tv); \\\n+  insn_time[last_opcode] += (now - last_time) - time_warp; \\\n+} while(0)\n+\n+#define TIME_RESUME do { \\\n+  gettimeofday (&tv, 0); \\\n+  last_time = USEC(tv); \\\n+} while(0)\n+\n+  last_opcode = 0; \n+  gettimeofday (&tv, 0); \n+  last_time = (jlong)tv.tv_sec * 1000000LL + (jlong)tv.tv_usec; \n+\n+#else\n+\n+#define TIME_SUSPEND \n+#define TIME_RESUME\n+\n+#endif\n+\n+ next_insn:\n+  inv->pc = pc;\n+\n+#ifdef TIME_MAINLOOP\n+\n+  gettimeofday (&tv, 0); \n+  jlong now = USEC(tv); \n+  insn_time[last_opcode] += (now - last_time) - time_warp; \n+  last_time = now; \n+  last_opcode = *pc; \n+  insn_count[last_opcode] += 1;\n+\n+#endif\n+  opcode = *pc++;\n+\n+  /* we special-case the single opcode aload_0 -- it makes \n+     up 10% of the time spent in the main loop. */\n+\n+  switch (opcode)\n+    {\n+    case op_aload_0:\t\t// 0x2a\n+      LOADA(0);\n+      goto next_insn;\n+\n+    case op_iload:\t\t// 0x15\n+      LOADI (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_getfield_4:\t\t// 0xd8\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHI (*(jint*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_iload_1:\t\t// 0x1b\n+      LOADI (1);\n+      goto next_insn;\n+\n+    case op_getfield_a:\t\t// 0xda\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHA(*(jobject*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_invokevirtual:\t// 0xb6\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\n+\t/* _Jv_ResolvePoolEntry returns immediately if the value already\n+\t * is resolved.  If we want to clutter up the code here to gain\n+\t * a little performance, then we can check the corresponding bit\n+\t * JV_CONSTANT_ResolvedFlag in the tag directly.  For now, I\n+\t * don't think it is worth it.  */\n+\n+\trmeth = (_Jv_ResolvedMethod*)\n+\t  _Jv_ResolvePoolEntry (defining_class, index);\n+\n+\tsp -= rmeth->stack_item_count;\n+\tNULLCHECK(sp[0]);\n+\n+\tif (rmeth->vtable_index == -1)\n+\t  {\n+\t    // final methods do not appear in the vtable,\n+\t    // if it does not appear in the superclass.\n+\t    fun = (void (*) (...)) rmeth->method->ncode;\n+\t  }\n+\telse\n+\t  {\n+\t    jobject rcv = (jobject)sp[0];\n+\t    _Jv_VTable *table = *(_Jv_VTable**)rcv;\n+\t    fun = (void (*) (...))table->method[rmeth->vtable_index];\n+\t  }\n+      }\n+      goto perform_invoke;\n+\n+    perform_invoke:\n+      {\n+\t/* here goes the magic again... */\n+\tffi_cif *cif = &rmeth->cif;\n+\tvoid **raw = sp;\n+\n+\tjdouble rvalue;\n+\n+\tTIME_SUSPEND;\n+\tffi_raw_call (cif, fun, (void*)&rvalue, (ffi_raw*) raw);\n+\tTIME_RESUME;\n+\n+\tint rtype = cif->rtype->type;\n+\n+\t/* the likelyhood of object, int, or void return is very high,\n+\t * so those are checked before the switch */\n+\tif (rtype == FFI_TYPE_POINTER)\n+\t  {\n+\t    PUSHA (*(jobject*)&rvalue);\n+\t  }\n+\telse if (rtype == FFI_TYPE_SINT32)\n+\t  {\n+\t    PUSHI (*(jint*)&rvalue);\n+\t  }\n+\telse if (rtype == FFI_TYPE_VOID)\n+\t  {\n+\t    /* skip */\n+\t  }\n+\telse switch (rtype) \n+\t  {\n+\t  case FFI_TYPE_SINT8:\n+\t    {\n+\t      jbyte value = (*(jint*)&rvalue) & 0xff;\n+\t      PUSHI (value);\n+\t    }\n+\t    break;\n+\n+\t  case FFI_TYPE_SINT16:\n+\t    {\n+\t      jshort value = (*(jint*)&rvalue) & 0xffff;\n+\t      PUSHI (value);\n+\t    }\n+\t    break;\n+\n+\t  case FFI_TYPE_UINT16:\n+\t    {\n+\t      jint value = (*(jint*)&rvalue) & 0xffff;\n+\t      PUSHI (value);\n+\t    }\n+\t    break;\n+\n+\t  case FFI_TYPE_FLOAT:\n+\t    PUSHF (*(jfloat*)&rvalue);\n+\t    break;\n+\n+\t  case FFI_TYPE_DOUBLE:\n+\t    PUSHD (rvalue);\n+\t    break;\n+\n+\t  case FFI_TYPE_SINT64:\n+\t    PUSHL (*(jlong*)&rvalue);\n+\t    break;\n+\t\n+\t  default:\n+\t    throw_internal_error (\"unknown return type in invokeXXX\");\n+\t  }\n+\t\n+      }\n+      goto next_insn;\n+\n+\n+    case op_nop:\n+      goto next_insn;\n+\n+    case op_aconst_null:\n+      PUSHA (NULL);\n+      goto next_insn;\n+\n+    case op_iconst_m1:\n+    case op_iconst_0:\n+    case op_iconst_1:\n+    case op_iconst_2:\n+    case op_iconst_3:\n+    case op_iconst_4:\n+    case op_iconst_5:\n+      PUSHI (opcode-op_iconst_0);\n+      goto next_insn;\n+\n+    case op_lconst_0:\n+    case op_lconst_1:\n+      PUSHL ((jlong) (opcode-op_lconst_0));\n+      goto next_insn;\n+      \n+    case op_fconst_0:\n+    case op_fconst_1:\n+    case op_fconst_2:\n+      PUSHF ((jfloat) (opcode-op_fconst_0));\n+      goto next_insn;\n+\n+    case op_dconst_0:\n+    case op_dconst_1:\n+      PUSHD ((jdouble) (opcode-op_dconst_0));\n+      goto next_insn;\n+\n+    case op_bipush:\n+      PUSHI (get1s(pc++));\n+      goto next_insn;\n+      \n+    case op_sipush:\n+      PUSHI (get2s(pc)); pc += 2;\n+      goto next_insn;\n+\n+    case op_ldc:\n+      {\n+\tint index = get1u (pc++);\n+\tPUSHA((jobject) pool_data[index]);\n+      }\n+      goto next_insn;\n+\n+    case op_ldc_w:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\tPUSHA((jobject) pool_data[index]);\n+      }\n+      goto next_insn;\n+\n+    case op_ldc2_w:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\tmemcpy (sp, &pool_data[index], 8);\n+\tsp += 2;\n+      }\n+      goto next_insn;\n+\n+    case op_lload:\n+      LOADL (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_fload:\n+      LOADF (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_dload:\n+      LOADD (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_aload:\n+      LOADA (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_iload_0:\n+      LOADI (0);\n+      goto next_insn;\n+\n+    case op_iload_2:\n+      LOADI (2);\n+      goto next_insn;\n+\n+    case op_iload_3:\n+      LOADI (3);\n+      goto next_insn;\n+\n+    case op_lload_0:\n+    case op_lload_1:\n+    case op_lload_2:\n+    case op_lload_3:\n+      LOADL (opcode-op_lload_0);\n+      goto next_insn;\n+\n+    case op_fload_0:\n+    case op_fload_1:\n+    case op_fload_2:\n+    case op_fload_3:\n+      LOADF (opcode-op_fload_0);\n+      goto next_insn;\n+\n+    case op_dload_0:\n+    case op_dload_1:\n+    case op_dload_2:\n+    case op_dload_3:\n+      LOADD (opcode-op_dload_0);\n+      goto next_insn;\n+\n+    case op_aload_1:\n+      LOADA(1);\n+      goto next_insn;\n+\n+    case op_aload_2:\n+      LOADA(2);\n+      goto next_insn;\n+\n+    case op_aload_3:\n+      LOADA(3);\n+      goto next_insn;\n+\n+    case op_iaload:\n+      {\n+\tjint index = POPI();\n+\tjintArray arr = (jintArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_laload:\n+      {\n+\tjint index = POPI();\n+\tjlongArray arr = (jlongArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHL( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_faload:\n+      {\n+\tjint index = POPI();\n+\tjfloatArray arr = (jfloatArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHF( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_daload:\n+      {\n+\tjint index = POPI();\n+\tjdoubleArray arr = (jdoubleArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHD( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_aaload:\n+      {\n+\tjint index = POPI();\n+\tjobjectArray arr = (jobjectArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHA( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_baload:\n+      {\n+\tjint index = POPI();\n+\tjbyteArray arr = (jbyteArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_caload:\n+      {\n+\tjint index = POPI();\n+\tjcharArray arr = (jcharArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_saload:\n+      {\n+\tjint index = POPI();\n+\tjshortArray arr = (jshortArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\tPUSHI( elements(arr)[index] );\n+      }\n+      goto next_insn;\n+\n+    case op_istore:\n+      STOREI (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_lstore:\n+      STOREL (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_fstore:\n+      STOREF (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_dstore:\n+      STORED (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_astore:\n+      STOREI (get1u (pc++));\n+      goto next_insn;\n+\n+    case op_istore_0:\n+    case op_istore_1:\n+    case op_istore_2:\n+    case op_istore_3:\n+      STOREI (opcode-op_istore_0);\n+      goto next_insn;\n+\n+    case op_lstore_0:\n+    case op_lstore_1:\n+    case op_lstore_2:\n+    case op_lstore_3:\n+      STOREL (opcode-op_lstore_0);\n+      goto next_insn;\n+\n+    case op_fstore_0:\n+    case op_fstore_1:\n+    case op_fstore_2:\n+    case op_fstore_3:\n+      STOREF (opcode-op_fstore_0);\n+      goto next_insn;\n+\n+    case op_dstore_0:\n+    case op_dstore_1:\n+    case op_dstore_2:\n+    case op_dstore_3:\n+      STORED (opcode-op_dstore_0);\n+      goto next_insn;\n+\n+    case op_astore_0:\n+    case op_astore_1:\n+    case op_astore_2:\n+    case op_astore_3:\n+      STOREA (opcode-op_astore_0);\n+      goto next_insn;\n+\n+    case op_iastore:\n+      {\n+\tjint value = POPI();\n+\tjint index  = POPI();\n+\tjintArray arr = (jintArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_lastore:\n+      {\n+\tjlong value = POPL();\n+\tjint index  = POPI();\n+\tjlongArray arr = (jlongArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_fastore:\n+      {\n+\tjfloat value = POPF();\n+\tjint index  = POPI();\n+\tjfloatArray arr = (jfloatArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_dastore:\n+      {\n+\tjdouble value = POPD();\n+\tjint index  = POPI();\n+\tjdoubleArray arr = (jdoubleArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_aastore:\n+      {\n+\tjobject value = POPA();\n+\tjint index  = POPI();\n+\tjobjectArray arr = (jobjectArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\t_Jv_CheckArrayStore (arr, value);\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_bastore:\n+      {\n+\tjbyte value = (jbyte) POPI();\n+\tjint index  = POPI();\n+\tjbyteArray arr = (jbyteArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_castore:\n+      {\n+\tjchar value = (jchar) POPI();\n+\tjint index  = POPI();\n+\tjcharArray arr = (jcharArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_sastore:\n+      {\n+\tjshort value = (jshort) POPI();\n+\tjint index  = POPI();\n+\tjshortArray arr = (jshortArray) POPA();\n+\tNULLCHECK (arr);\n+\tif (index < 0 || index >= arr->length)\n+ \t  {\n+\t    TIME_SUSPEND;\n+\t    _Jv_ThrowBadArrayIndex (index);\n+\t  }\n+\telements(arr)[index] = value;\n+      }\n+      goto next_insn;\n+\n+    case op_pop:\n+      sp -= 1;\n+      goto next_insn;\n+\n+    case op_pop2:\n+      sp -= 2;\n+      goto next_insn;\n+\n+    case op_dup:\n+      sp[0] = sp[-1];\n+      sp += 1;\n+      goto next_insn;\n+\n+    case op_dup_x1:\n+      dupx (sp, 1, 1);\n+      goto next_insn;\n+\n+    case op_dup_x2:\n+      dupx (sp, 1, 2);\n+      goto next_insn;\n+\n+    case op_dup2:\n+      sp[0] = sp[-2];\n+      sp[1] = sp[-1];\n+      sp += 2;\n+      goto next_insn;\n+\n+    case op_dup2_x1:\n+      dupx (sp, 2, 1);\n+      goto next_insn;\n+\n+    case op_dup2_x2:\n+      dupx (sp, 2, 2);\n+      goto next_insn;\n+\n+    case op_swap:\n+      {\n+\tjobject tmp1 = POPA();\n+\tjobject tmp2 = POPA();\n+\tPUSHA (tmp1);\n+\tPUSHA (tmp2);\n+      }\n+      goto next_insn;\n+\n+    case op_iadd:\n+      BINOPI(+);\n+      goto next_insn;\n+\n+    case op_ladd:\n+      BINOPL(+);\n+      goto next_insn;\n+\n+    case op_fadd:\n+      BINOPF(+);\n+      goto next_insn;\n+\n+    case op_dadd:\n+      BINOPD(+);\n+      goto next_insn;\n+\n+    case op_isub:\n+      BINOPI(-);\n+      goto next_insn;\n+\n+    case op_lsub:\n+      BINOPL(-);\n+      goto next_insn;\n+\n+    case op_fsub:\n+      BINOPF(-);\n+      goto next_insn;\n+\n+    case op_dsub:\n+      BINOPD(-);\n+      goto next_insn;\n+\n+    case op_imul:\n+      BINOPI(*);\n+      goto next_insn;\n+\n+    case op_lmul:\n+      BINOPL(*);\n+      goto next_insn;\n+\n+    case op_fmul:\n+      BINOPF(*);\n+      goto next_insn;\n+\n+    case op_dmul:\n+      BINOPD(*);\n+      goto next_insn;\n+\n+    case op_idiv:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tZEROCHECK (value2);\n+\tjint res = value1 / value2;\n+\tPUSHI (res);\n+      }\n+      goto next_insn;\n+\n+    case op_ldiv:\n+       {\n+\tjlong value2 = POPL();\n+\tjlong value1 = POPL();\n+\tZEROCHECK (value2);\n+\tjlong res = value1 / value2;\n+\tPUSHL (res);\n+      }\n+      goto next_insn;\n+\n+    case op_fdiv:\n+      {\n+\tjfloat value2 = POPF();\n+\tjfloat value1 = POPF();\n+\tZEROCHECK (value2);\n+\tjfloat res = value1 / value2;\n+\tPUSHF (res);\n+      }\n+      goto next_insn;\n+\n+    case op_ddiv:\n+      {\n+\tjdouble value2 = POPD();\n+\tjdouble value1 = POPD();\n+\tZEROCHECK (value2);\n+\tjdouble res = value1 / value2;\n+\tPUSHD (res);\n+      }\n+      goto next_insn;\n+\n+    case op_irem:\n+      {\n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tZEROCHECK (value2);\t\n+\tjint res = value1 % value2;\n+\tPUSHI (res);\n+      }\n+      goto next_insn;\n+\n+    case op_lrem:\n+       {\n+\tjlong value2 = POPL();\n+\tjlong value1 = POPL();\n+\tZEROCHECK (value2);\n+\tjlong res = value1 % value2;\n+\tPUSHL (res);\n+      }\n+      goto next_insn;\n+\n+    case op_frem:\n+      {\n+\tjfloat value2 = POPF();\n+\tjfloat value1 = POPF();\n+\tZEROCHECK (value2);\n+\tjfloat res    = __ieee754_fmod (value1, value2);\n+\tPUSHF (res);\n+      }\n+      goto next_insn;\n+\n+    case op_drem:\n+      {\n+\tjdouble value2 = POPD();\n+\tjdouble value1 = POPD();\n+\tZEROCHECK (value2);\n+\tjdouble res    = __ieee754_fmod (value1, value2);\n+\tPUSHD (res);\n+      }\n+      goto next_insn;\n+\n+    case op_ineg:\n+      *(jint*) (sp-1) *= -1;\n+      goto next_insn;\n+\n+    case op_lneg:\n+      *(jlong*) (sp-1) *= -1;\n+      goto next_insn;\n+\n+    case op_fneg:\n+      *(jfloat*) (sp-1) *= -1;\n+      goto next_insn;\n+\n+    case op_dneg:\n+      *(jdouble*) (sp-1) *= -1;\n+      goto next_insn;\n+\n+    case op_ishl:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\tjint value = POPI();\n+\tPUSHI (value << shift);\n+      }\n+      goto next_insn;\n+\n+    case op_lshl:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\tjlong value = POPL();\n+\tPUSHL (value << shift);\n+      }\n+      goto next_insn;\n+\n+    case op_ishr:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\tjint value = POPI();\n+\tPUSHI (value >> shift);\n+      }\n+      goto next_insn;\n+\n+    case op_lshr:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\tjlong value = POPL();\n+\tPUSHL (value >> shift);\n+      }\n+      goto next_insn;\n+\n+    case op_iushr:\n+      {\n+\tjint shift = (POPI() & 0x1f);\n+\tunsigned long value = POPI();\n+\tPUSHI ((jint) (value >> shift));\n+      }\n+      goto next_insn;\n+\n+    case op_lushr:\n+      {\n+\tjint shift = (POPI() & 0x3f);\n+\tUINT64 value = (UINT64) POPL();\n+\tPUSHL ((value >> shift));\n+      }\n+      goto next_insn;\n+\n+    case op_iand:\n+      BINOPI (&);\n+      goto next_insn;\n+\n+    case op_land:\n+      BINOPL (&);\n+      goto next_insn;\n+\n+    case op_ior:\n+      BINOPI (|);\n+      goto next_insn;\n+\n+    case op_lor:\n+      BINOPL (|);\n+      goto next_insn;\n+\n+    case op_ixor:\n+      BINOPI (^);\n+      goto next_insn;\n+\n+    case op_lxor:\n+      BINOPL (^);\n+      goto next_insn;\n+\n+    case op_iinc:\n+      {\n+\tjint index  = get1u (pc++);\n+\tjint amount = get1s (pc++);\n+\t*(jint*) (locals + index) += amount;\n+      }\n+      goto next_insn;\n+\n+    case op_i2l:\n+      PUSHL ((jlong)POPI ());\n+      goto next_insn;\n+\n+    case op_i2f:\n+      PUSHF ((jfloat)POPI ());\n+      goto next_insn;\n+\n+    case op_i2d:\n+      PUSHD ((jdouble)POPI ());\n+      goto next_insn;\n+\n+    case op_l2i:\n+      PUSHI ((jint)POPL ());\n+      goto next_insn;\n+\n+    case op_l2f:\n+      PUSHF ((jfloat)POPL ());\n+      goto next_insn;\n+\n+    case op_l2d:\n+      PUSHD ((jdouble)POPL ());\n+      goto next_insn;\n+\n+    case op_f2i:\n+      PUSHI ((jint)POPF ());\n+      goto next_insn;\n+\n+    case op_f2l:\n+      PUSHL ((jlong)POPF ());\n+      goto next_insn;\n+\n+    case op_f2d:\n+      PUSHD ((jdouble)POPF ());\n+      goto next_insn;\n+\n+    case op_d2i:\n+      PUSHI ((jint)POPD ());\n+      goto next_insn;\n+\n+    case op_d2l:\n+      PUSHL ((jlong)POPD ());\n+      goto next_insn;\n+\n+    case op_d2f:\n+      PUSHF ((jfloat)POPD ());\n+      goto next_insn;\n+\n+    case op_i2b:\n+      PUSHI ((jbyte)POPI ());\n+      goto next_insn;\n+\n+    case op_i2c:\n+      PUSHI ((jchar)POPI ());\n+      goto next_insn;\n+\n+    case op_i2s:\n+      PUSHI ((jshort)POPI ());\n+      goto next_insn;\n+\n+    case op_lcmp:\n+      {\n+\tjlong value2 = POPL ();\n+\tjlong value1 = POPL ();\n+\tif (value1 > value2)\n+\t  { PUSHI (1); }\n+\telse if (value1 == value2)\n+\t  { PUSHI (0); }\n+\telse\n+\t  { PUSHI (-1); }\n+      }\n+      goto next_insn;\n+\n+    case op_fcmpl:\n+    case op_fcmpg:\n+      {\n+\tjfloat value2 = POPF ();\n+\tjfloat value1 = POPF ();\n+\tif (value1 > value2)\n+\t  PUSHI (1);\n+\telse if (value1 == value2)\n+\t  PUSHI (0);\n+\telse if (value1 < value2)\n+\t  PUSHI (-1);\n+\telse if (opcode == op_fcmpg)\n+\t  PUSHI (1);\n+\telse\n+\t  PUSHI (-1);\n+      }\n+      goto next_insn;\n+\n+    case op_dcmpl:\n+    case op_dcmpg:\n+      {\n+\tjdouble value2 = POPD ();\n+\tjdouble value1 = POPD ();\n+\tif (value1 > value2)\n+\t  PUSHI (1);\n+\telse if (value1 == value2)\n+\t  PUSHI (0);\n+\telse if (value1 < value2)\n+\t  PUSHI (-1);\n+\telse if (opcode == op_dcmpg)\n+\t  PUSHI (1);\n+\telse\n+\t  PUSHI (-1);\n+      }\n+      goto next_insn;\n+\n+    case op_ifeq:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() == 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_ifne:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() != 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_iflt:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() < 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_ifge:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() >= 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_ifgt:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() > 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_ifle:\n+      {\n+\tjint offset = get2s (pc); \n+\tif (POPI() <= 0)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmpeq:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 == value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmpne:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 != value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmplt:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 < value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmpge:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 >= value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmpgt:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 > value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_icmple:\n+      {\n+\tjint offset = get2s (pc); \n+\tjint value2 = POPI();\n+\tjint value1 = POPI();\n+\tif (value1 <= value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_acmpeq:\n+      {\n+\tjint offset = get2s (pc); \n+\tjobject value2 = POPA();\n+\tjobject value1 = POPA();\n+\tif (value1 == value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_if_acmpne:\n+      {\n+\tjint offset = get2s (pc); \n+\tjobject value2 = POPA();\n+\tjobject value1 = POPA();\n+\tif (value1 != value2)\n+\t  pc = pc-1+offset;\n+\telse\n+\t  pc = pc+2;\n+      }\n+      goto next_insn;\n+\n+    case op_goto: \n+      {\n+\tjint offset = get2s (pc);\n+\tpc = pc-1+offset;\n+      }\n+      goto next_insn;\n+\n+    case op_jsr:\n+      {\n+\tunsigned char *base_pc = pc-1;\n+\tjint offset = get2s (pc); pc += 2;\n+\tPUSHA ((jobject)pc);\n+\tpc = base_pc+offset;\n+      }\n+      goto next_insn;\n+\n+    case op_ret:\n+      {\n+\tjint index = get1u (pc);\n+\tpc = (unsigned char*) PEEKA (index);\n+      }\n+      goto next_insn;\n+\n+    case op_tableswitch:\n+      {\n+\tunsigned char *base_pc = pc-1;\n+\tint index = POPI();\n+\t\n+\tunsigned char* base = bytecode ();\n+\twhile ((pc-base) % 4 != 0)\n+\t  pc++;\n+\n+\tjint def     = get4 (pc);\n+\tjint low     = get4 (pc+4);\n+\tjint high    = get4 (pc+8);\n+\n+\tif (index < low || index > high)\n+\t  pc = base_pc + def;    \n+\telse\n+\t  pc = base_pc + get4 (pc+4*(index-low+3));\n+      }\n+      goto next_insn;\n+\n+    case op_lookupswitch:\n+      {\n+\tunsigned char *base_pc = pc-1;\n+\tint index = POPI();\n+\t\n+\tunsigned char* base = bytecode ();\n+\twhile ((pc-base) % 4 != 0)\n+\t  pc++;\n+\t\n+\tjint def     = get4 (pc);\n+\tjint npairs  = get4 (pc+4);\n+\t\n+\tint max = npairs-1;\n+\tint min = 0;\n+\n+\t// simple binary search...\n+\twhile (min < max)\n+\t  {\n+\t    int half = (min+max)/2;\n+\t    int match = get4 (pc+ 4*(2 + 2*half));\n+\n+\t    if (index == match)\n+\t      min = max = half;\n+\n+\t    else if (index < match)\n+\t      max = half-1;\n+\t    \n+\t    else\n+\t      min = half+1;\n+\t  }\n+\t\n+\tif (index == get4 (pc+ 4*(2 + 2*min)))\n+\t  pc = base_pc + get4 (pc+ 4*(2 + 2*min + 1));\n+\telse\n+\t  pc = base_pc + def;    \n+      }\n+      goto next_insn;\n+\n+      /* on return, just save the sp and return to caller */\n+    case op_ireturn:\n+    case op_lreturn:\n+    case op_freturn:\n+    case op_dreturn:\n+    case op_areturn:\n+    case op_return:\n+      inv->sp = sp;\n+      TIME_SUSPEND;\n+      return;\n+\n+    case op_getstatic:\n+      {\n+\tunsigned char *base_pc = pc-1;\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\n+\tif ((field->flags & STATIC) == 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field no longer static\"));\n+\n+\tjclass type = field->type;\n+\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes)\n+\t      {\n+\t      case 1:\n+\t\t*base_pc = op_getstatic_1;\n+\t\tbreak;\n+\t    \n+\t      case 2:\n+\t\tif (type == JvPrimClass (char))\n+\t\t  *base_pc = op_getstatic_2u;\n+\t\telse\n+\t\t  *base_pc = op_getstatic_2s;\n+\t\tbreak;\n+\n+\t      case 4:\n+\t\t*base_pc = op_getstatic_4;\n+\t\tbreak;\n+\n+\t      case 8:\n+\t\t*base_pc = op_getstatic_8;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    *base_pc = op_getstatic_a;\n+\t  }\n+\t\n+\tpc = base_pc;\n+      }\n+      goto next_insn;\n+\n+    case op_getfield:\n+      {\n+\tunsigned char *base_pc = pc-1;\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\n+\tif ((field->flags & STATIC) != 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field is static\"));\n+\n+\tjclass type = field->type;\n+\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes)\n+\t      {\n+\t      case 1:\n+\t\t*base_pc = op_getfield_1;\n+\t\tbreak;\n+\t    \n+\t      case 2:\n+\t\tif (type == JvPrimClass (char))\n+\t\t  *base_pc = op_getfield_2u;\n+\t\telse\n+\t\t  *base_pc = op_getfield_2s;\n+\t\tbreak;\n+\n+\t      case 4:\n+\t\t*base_pc = op_getfield_4;\n+\t\tbreak;\n+\n+\t      case 8:\n+\t\t*base_pc = op_getfield_8;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    *base_pc = op_getfield_a;\n+\t  }\n+\t\n+\tif (field->u.boffset > 0xffff)\n+\t  JvThrow (new java::lang::VirtualMachineError);\n+\n+\tbase_pc[1] = (field->u.boffset>>8) & 0xff;\n+\tbase_pc[2] = field->u.boffset & 0xff;\n+\n+\tpc = base_pc;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\n+\tjclass type = field->type;\n+\n+\t// ResolvePoolEntry cannot check this\n+\tif ((field->flags & STATIC) == 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field no longer static\"));\n+\n+\t/* if this is patented, then maybe we could install\n+\t   a function in the constant pool, to do the right thing */\n+\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes) \n+\t      {\n+\t      case 1:\n+\t\t*base_pc = op_putstatic_1;\n+\t\tbreak;\n+\n+\t      case 2:\n+\t\t*base_pc = op_putstatic_2;\n+\t\tbreak;\n+\t\t\n+\t      case 4:\n+\t\t*base_pc = op_putstatic_4;\n+\t\tbreak;\n+\t\t\n+\t      case 8:\n+\t\t*base_pc = op_putstatic_8;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    *base_pc = op_putstatic_a;\n+\t  }\n+\n+\t// do the instruction again!\n+\tpc = base_pc;\n+      }\n+      goto next_insn;\n+\n+\n+    case op_putfield:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\n+\tjclass type = field->type;\n+\n+\tif ((field->flags & STATIC) != 0)\n+\t  throw_incompatible_class_change_error \n+\t    (JvNewStringLatin1 (\"field is static\"));\n+\n+\tif (type->isPrimitive ())\n+\t  {\n+\t    switch (type->size_in_bytes) \n+\t      {\n+\t      case 1:\n+\t\t*base_pc = op_putfield_1;\n+\t\tbreak;\n+\n+\t      case 2:\n+\t\t*base_pc = op_putfield_2;\n+\t\tbreak;\n+\n+\t      case 4:\n+\t\t*base_pc = op_putfield_4;\n+\t\tbreak;\n+\n+\t      case 8:\n+\t\t*base_pc = op_putfield_8;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    *base_pc = op_putfield_a;\n+\t  }\n+\n+\tif (field->u.boffset > 0xffff)\n+\t  JvThrow (new java::lang::VirtualMachineError);\n+\n+\tbase_pc[1] = (field->u.boffset>>8) & 0xff;\n+\tbase_pc[2] = field->u.boffset & 0xff;\n+\n+\t// do the instruction again!\n+\tpc = base_pc;\n+      }\n+      goto next_insn;\n+\n+\n+    case op_getfield_1:\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHI (*(jbyte*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_getfield_2s:\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHI (*(jshort*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_getfield_2u:\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHI (*(jchar*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_getfield_8:\n+      {\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\tPUSHL(*(jlong*) ((char*)obj + field_offset));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_1:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHI (*(jbyte*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_2s:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHI(*(jshort*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_2u:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHI(*(jchar*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_4:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHI(*(jint*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_8:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHL(*(jlong*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_getstatic_a:\n+      {\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\tPUSHA(*(jobject*) (field->u.addr));\n+      }\n+      goto next_insn;\n+\n+    case op_putfield_1:\n+      {\n+\tjint    value = POPI();\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\t*(jbyte*) ((char*)obj + field_offset) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putfield_2:\n+      {\n+\tjint    value = POPI();\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\t*(jchar*) ((char*)obj + field_offset) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putfield_4:\n+      {\n+\tjint    value = POPI();\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\t*(jint*) ((char*)obj + field_offset) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putfield_8:\n+      {\n+\tjlong   value = POPL();\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\t*(jlong*) ((char*)obj + field_offset) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putfield_a:\n+      {\n+\tjobject value = POPA();\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n+\tjint field_offset = get2u (pc); pc += 2;\n+\t*(jobject*) ((char*)obj + field_offset) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic_1:\n+      {\n+\tjint    value = POPI();\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\t*(jbyte*) (field->u.addr) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic_2:\n+      {\n+\tjint    value = POPI();\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\t*(jchar*) (field->u.addr) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic_4:\n+      {\n+\tjint    value = POPI();\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\t*(jint*) (field->u.addr) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic_8:\n+      {\n+\tjlong    value = POPL();\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\t*(jlong*) (field->u.addr) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_putstatic_a:\n+      {\n+\tjobject value = POPA();\n+\tjint fieldref_index = get2u (pc); pc += 2;\n+\t_Jv_Field *field = (_Jv_Field*) pool_data[fieldref_index];\n+\t*(jobject*) (field->u.addr) = value;\n+      }\n+      goto next_insn;\n+\n+    case op_invokespecial:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\n+\trmeth = (_Jv_ResolvedMethod*)\n+\t  _Jv_ResolvePoolEntry (defining_class, index);\n+\n+\tsp -= rmeth->stack_item_count;\n+\t\n+\tNULLCHECK(sp[0]);\n+\n+\tfun = (void (*) (...))rmeth->method->ncode;\n+      }\n+      goto perform_invoke;\n+\n+    case op_invokestatic:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\n+\trmeth = (_Jv_ResolvedMethod*)\n+\t  _Jv_ResolvePoolEntry (defining_class, index);\n+\n+\tsp -= rmeth->stack_item_count;\n+\t\n+\t_Jv_InitClass (rmeth->klass);\n+\tfun = (void (*) (...))rmeth->method->ncode;\n+      }\n+      goto perform_invoke;\n+\n+    case op_invokeinterface:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\n+\t// invokeinterface has two unused bytes...\n+\tpc += 2;\n+\n+\trmeth = (_Jv_ResolvedMethod*)\n+\t    _Jv_ResolvePoolEntry (defining_class, index);\n+\n+\tsp -= rmeth->stack_item_count;\n+\tNULLCHECK(sp[0]);\n+\t\n+\tjobject rcv = (jobject)sp[0];\n+\n+\tfun = (void (*) (...))\n+\t  _Jv_LookupInterfaceMethod (rcv->getClass (),\n+\t\t\t\t     rmeth->method->name,\n+\t\t\t\t     rmeth->method->signature);\n+      }\n+      goto perform_invoke;\n+\n+\n+    case op_new:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\tjclass klass = (jclass) _Jv_ResolvePoolEntry (defining_class,\n+\t\t\t\t\t\t      index);\n+\t_Jv_InitClass (klass);\n+\tjobject res = _Jv_AllocObject (klass, klass->size_in_bytes);\n+\tPUSHA (res);\n+      }\n+      goto next_insn;\n+\n+    case op_newarray:\n+      {\n+\tint atype = get1u (pc++);\n+\tint size  = POPI();\n+\tjobject result = _Jv_NewArray (atype, size);\n+\tPUSHA (result);\n+      }\n+      goto next_insn;\n+      \n+    case op_anewarray:\n+      {\n+\tint index = get2u (pc); pc += 2;\n+\tjclass klass = (jclass) _Jv_ResolvePoolEntry (defining_class, index);\n+\tint size  = POPI();\n+\t_Jv_InitClass (klass);\n+\tjobject result = _Jv_NewObjectArray (size, klass, 0);\n+\tPUSHA (result);\n+      }\n+      goto next_insn;\n+\n+    case op_arraylength:\n+      {\n+\t__JArray *arr = (__JArray*)POPA();\n+\tPUSHI (arr->length);\n+      }\n+      goto next_insn;\n+\n+    case op_athrow:\n+      {\n+\tjobject value = POPA();\n+\tTIME_SUSPEND;\n+\tJvThrow (value);\n+      }\n+      goto next_insn;\n+\n+    case op_checkcast:\n+      {\n+\tjobject value = POPA();\n+\tjint index = get2u (pc); pc += 2;\n+\tjclass to = (jclass)_Jv_ResolvePoolEntry (defining_class,\n+\t\t\t\t\t\t  index);\n+\n+\tif (value != NULL && ! to->isInstance (value))\n+\t  {\n+\t    TIME_SUSPEND;\n+\t    JvThrow (new java::lang::ClassCastException\n+\t\t     (to->getName()));\n+\t  }\n+\n+\tPUSHA (value);\n+      }\n+      goto next_insn;\n+\n+    case op_instanceof:\n+      {\n+\tjobject value = POPA();\n+\tjint index = get2u (pc); pc += 2;\n+\tjclass to = (jclass)_Jv_ResolvePoolEntry (defining_class,\n+\t\t\t\t\t\t  index);\n+\tPUSHI (to->isInstance (value));\n+      }\n+      goto next_insn;\n+\n+    case op_monitorenter:\n+      {\n+\tjobject value = POPA();\n+\tNULLCHECK(value);\n+\t_Jv_MonitorEnter (value);\n+      }\n+      goto next_insn;\n+\n+    case op_monitorexit:\n+      {\n+\tjobject value = POPA();\n+\tNULLCHECK(value);\n+\t_Jv_MonitorExit (value);\n+      }\n+      goto next_insn;\n+\n+    case op_ifnull:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tjint offset = get2s (pc); pc += 2;\n+\tjobject val = POPA();\n+\tif (val == NULL)\n+\t  pc = base_pc+offset;\n+      }\n+      goto next_insn;\n+\n+    case op_ifnonnull:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tjint offset = get2s (pc); pc += 2;\n+\tjobject val = POPA();\n+\tif (val != NULL)\n+\t  pc = base_pc+offset;\n+      }\n+      goto next_insn;\n+\n+    case op_wide:\n+      {\n+\tjint the_mod_op = get1u (pc++);\n+\tjint wide       = get2u (pc); pc += 2;\n+\n+\tswitch (the_mod_op)\n+\t  {\n+\t  case op_istore:\n+\t    STOREI (wide);\n+\t    goto next_insn;\n+\n+\t  case op_fstore:\n+\t    STOREF (wide);\n+\t    goto next_insn;\n+\n+\t  case op_astore:\n+\t    STOREA (wide);\n+\t    goto next_insn;\n+\n+\t  case op_lload:\n+\t    LOADL (wide);\n+\t    goto next_insn;\n+\n+\t  case op_dload:\n+\t    LOADD (wide);\n+\t    goto next_insn;\n+\n+\t  case op_iload:\n+\t    LOADI (wide);\n+\t    goto next_insn;\n+\n+\t  case op_aload:\n+\t    LOADA (wide);\n+\t    goto next_insn;\n+\n+\t  case op_lstore:\n+\t    STOREL (wide);\n+\t    goto next_insn;\n+\n+\t  case op_dstore:\n+\t    STORED (wide);\n+\t    goto next_insn;\n+\n+\t  case op_ret:\n+\t    pc = (unsigned char*) PEEKA (wide);\n+\t    goto next_insn;\n+\n+\t  case op_iinc:\n+\t    {\n+\t      jint amount = get2s (pc); pc += 2;\n+\t      jint value = PEEKI (wide);\n+\t      POKEI (wide, value+amount);\n+\t    }\n+\t    goto next_insn;\n+\n+\t  default:\n+\t    throw_internal_error (\"illegal bytecode modified by wide\");\n+\t  }\n+\n+      }\n+\n+    case op_multianewarray:\n+      {\n+\tint kind_index = get2u (pc); pc += 2;\n+\tint dim        = get1u (pc); pc += 1;\n+\n+\tjclass type    = (jclass) _Jv_ResolvePoolEntry (defining_class,\n+\t\t\t\t\t\t\tkind_index);\n+\t_Jv_InitClass (type);\n+\tjint *sizes    = (jint*) alloca (sizeof (jint)*dim);\n+\n+\tfor (int i = dim - 1; i >= 0; i--)\n+\t  {\n+\t    sizes[i] = POPI ();\n+\t  }\n+\t\n+\tjobject res    = _Jv_NewMultiArray (type,dim, sizes);\n+\t\n+\tPUSHA (res);\n+      }\n+      goto next_insn;\n+\n+    case op_goto_w:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tint offset = get4 (pc); pc += 4;\n+\tpc = base_pc+offset;\n+      }\n+      goto next_insn;\n+\n+    case op_jsr_w:\n+      {\n+\tunsigned char* base_pc = pc-1;\n+\tint offset = get4 (pc); pc += 4;\n+\tPUSHA((jobject)pc);\n+\tpc = base_pc+offset;\n+      }\n+      goto next_insn;\n+\n+    default:\n+      throw_internal_error (\"opcode not implemented\");\n+\n+    }\n+  goto next_insn;\n+}\n+\n+\n+static void\n+throw_internal_error (char *msg)\n+{\n+  JvThrow (new java::lang::InternalError (JvNewStringLatin1 (msg)));\n+}\n+\n+static void \n+throw_incompatible_class_change_error (jstring msg)\n+{\n+  JvThrow (new java::lang::IncompatibleClassChangeError (msg));\n+}\n+\n+#if !HANDLE_SEGV\n+static java::lang::NullPointerException *null_pointer_exc;\n+static void \n+throw_null_pointer_exception ()\n+{\n+  if (null_pointer_exc == NULL)\n+    null_pointer_exc = new java::lang::NullPointerException;\n+\n+  JvThrow (null_pointer_exc);\n+}\n+#endif\n+\n+#if !HANDLE_FPE\n+static java::lang::ArithmeticException *arithmetic_exc;\n+static void \n+throw_arithmetic_exception ()\n+{\n+  if (arithmetic_exc == NULL)\n+    arithmetic_exc = new java::lang::ArithmeticException\n+      (JvNewStringLatin1 (\"/ by zero\"));\n+\n+  JvThrow (arithmetic_exc);\n+}\n+#endif\n+\n+void\n+jvdump(jobject o)\n+{\n+  _Jv_InterpMethod::dump_object(o);\n+}\n+\n+/* FIXME: This is not finished! */\n+void\n+_Jv_InterpMethod::dump_object(jobject o)\n+{\n+  java::io::PrintStream *out = java::lang::System::out;\n+\n+  if (o == NULL)\n+    {\n+      out->println (JvNewStringLatin1 (\"<null>\"));\n+      return;\n+    }\n+\n+  jclass klass = o->getClass ();\n+\n+  out->print (klass->getName ());\n+  out->print (JvNewStringLatin1 (\"@0x\"));\n+  out->print (java::lang::Integer::toHexString ((jint)o));\n+  out->print (JvNewStringLatin1 (\"{\"));\n+#if 0\n+  while (klass && klass != &ObjectClass)\n+    {\n+      _Jv_Field *fields = klass->fields;\n+      int max           = klass->field_count;\n+      \n+      for (int i = 0; i < max; ++i)\n+\t{\n+\t  out->print (_Jv_NewStringUTF (field->name->data));\n+\t  out->print (JvNewStringLatin1 (\"=\"));\n+\n+\t  if (JvFieldIsRef (field))\n+\t    {\n+\t      if (field->flags & STATIC)\n+\t\tout->print (JvGetSt)\n+\t    }\n+\t  field = field->getNextInstanceField ();\n+\n+\t  if (i+1 < max && klass->getSuperclass () != null)\n+\t    out->print (JvNewStringLatin1 (\"; \"));\n+\t}\n+\n+      klass = klass->getSuperclass();\n+    }\n+#endif\n+  out->print (JvNewStringLatin1 (\"}\\n\"));\n+\n+}\n+\n+#endif // INTERPRETER"}, {"sha": "df55425daeefa6fa1352631f34cf694c18d1dc84", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -21,25 +21,30 @@ details.  */\n extern \"C\" void _Jv_InitClass (jclass klass);\n extern \"C\" void _Jv_RegisterClasses (jclass *classes);\n \n+// These are the possible values for the `state' field of the class\n+// structure.  Note that ordering is important here; in particular\n+// `resolved' must come between `nothing' and the other states.\n+// Whenever the state changes, one should notify all waiters of this\n+// class.\n+#define JV_STATE_NOTING        0 // set by compiler\n+\n+#define JV_STATE_PRELOADING    1 // can do _Jv_FindClass\n+#define JV_STATE_LOADING       3 // has super installed\n+#define JV_STATE_LOADED        5 // is complete\n+    \n+#define JV_STATE_COMPILED      6 // this was a compiled class\n+\n+#define JV_STATE_PREPARED      7 // layout & static init done\n+#define JV_STATE_LINKED        9 // strings interned\n+\n+#define JV_STATE_IN_PROGRESS  10 // <clinit> running\n+#define JV_STATE_DONE         12 // \n+\n+#define JV_STATE_ERROR        14 // must be last\n+\n struct _Jv_Field;\n struct _Jv_VTable;\n \n-#define CONSTANT_Class 7\n-#define CONSTANT_Fieldref 9\n-#define CONSTANT_Methodref 10\n-#define CONSTANT_InterfaceMethodref 11\n-#define CONSTANT_String 8\n-#define CONSTANT_Integer 3\n-#define CONSTANT_Float 4\n-#define CONSTANT_Long 5\n-#define CONSTANT_Double 6\n-#define CONSTANT_NameAndType 12\n-#define CONSTANT_Utf8 1\n-#define CONSTANT_Unicode 2\n-#define CONSTANT_ResolvedFlag 16\n-#define CONSTANT_ResolvedString    (CONSTANT_String+CONSTANT_ResolvedFlag)\n-#define CONSTANT_ResolvedClass     (CONSTANT_Class+CONSTANT_ResolvedFlag)\n-\n struct _Jv_Constants\n {\n   jint size;\n@@ -134,9 +139,11 @@ class java::lang::Class : public java::lang::Object\n       return size_in_bytes;\n     }\n \n+  // finalization\n+  void finalize ();\n+\n private:\n   void checkMemberAccess (jint flags);\n-  void resolveConstants (void);\n \n   // Various functions to handle class initialization.\n   java::lang::Throwable *hackTrampoline (jint, java::lang::Throwable *);\n@@ -147,12 +154,6 @@ class java::lang::Class : public java::lang::Object\n   friend _Jv_Method *_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t\t\t\t _Jv_Utf8Const *signature);\n   friend void _Jv_InitClass (jclass klass);\n-  friend void _Jv_RegisterClasses (jclass *classes);\n-  friend jclass _Jv_FindClassInCache (_Jv_Utf8Const *name,\n-\t\t\t\t      java::lang::ClassLoader *loader);\n-  friend jclass _Jv_FindArrayClass (jclass element);\n-  friend jclass _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n-\t\t\t      java::lang::ClassLoader *loader);\n \n   friend jfieldID JvGetFirstInstanceField (jclass);\n   friend jint JvNumInstanceFields (jclass);\n@@ -165,6 +166,41 @@ class java::lang::Class : public java::lang::Object\n \n   friend class _Jv_PrimClass;\n \n+  // Friends classes and functions to implement the ClassLoader\n+  friend class java::lang::ClassLoader;\n+\n+  friend void _Jv_WaitForState (jclass, int);\n+  friend void _Jv_RegisterClasses (jclass *classes);\n+  friend void _Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n+  friend void _Jv_UnregisterClass (jclass);\n+  friend jclass _Jv_FindClass (_Jv_Utf8Const *name,\n+\t\t\t       java::lang::ClassLoader *loader);\n+  friend jclass _Jv_FindClassInCache (_Jv_Utf8Const *name,\n+\t\t\t\t      java::lang::ClassLoader *loader);\n+  friend jclass _Jv_FindArrayClass (jclass element,\n+\t\t\t\t    java::lang::ClassLoader *loader);\n+  friend jclass _Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n+\t\t\t      java::lang::ClassLoader *loader);\n+\n+  friend void _Jv_InternClassStrings (jclass);\n+\n+#ifdef INTERPRETER\n+  friend jboolean _Jv_IsInterpretedClass (jclass);\n+  friend void _Jv_InitField (jobject, jclass, _Jv_Field*);\n+  friend _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n+\t\t\t\t\t       _Jv_Utf8Const*);\n+  friend int _Jv_DetermineVTableIndex (jclass, _Jv_Utf8Const *, \n+\t\t\t\t       _Jv_Utf8Const*);\n+  friend void _Jv_InitField (jobject, jclass, int);\n+  friend void* _Jv_ResolvePoolEntry (jclass, int);\n+  friend void _Jv_PrepareClass (jclass);\n+\n+  friend class _Jv_ClassReader;\t\n+  friend class _Jv_InterpClass;\n+  friend class _Jv_InterpMethod;\n+  friend class _Jv_InterpMethodInvocation;\n+#endif\n+\n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n #endif"}, {"sha": "bc826e9029bad8fad49f2d2c8fede33c679c6100", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -152,4 +152,7 @@ else if (what == 2)\n \n   // Initialize the class.\n   private native void initializeClass ();\n+\n+  // finalization\n+  protected native void finalize ();\n }"}, {"sha": "f0b533f6041d531a5b9bb058a8f2f0c4aa4fd070", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 367, "deletions": 59, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -9,86 +9,394 @@\n details.  */\n \n package java.lang;\n+\n import java.io.InputStream;\n-import java.util.Hashtable;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.Stack;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 28, 1998 \n+ * The class <code>ClassLoader</code> is intended to be subclassed by\n+ * applications in order to describe new ways of loading classes,\n+ * such as over the network.\n+ *\n+ * @author  Kresten Krab Thorup\n  */\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * Status: Just a stub; not useful at all.\n  */\n \n-public abstract class ClassLoader\n-{\n-  protected ClassLoader ()\n-    {\n-      cache = new Hashtable ();\n-    }\n+public abstract class ClassLoader {\n \n-  protected final Class defineClass (String className, byte[] bytecode,\n-\t\t\t\t     int offset, int length)\n-    {\n-      throw new ClassFormatError (\"defineClass unimplemented\");\n-    }\n+  static private ClassLoader system;\n+    \n+  private static native ClassLoader getVMClassLoader0 ();\n \n-  protected final Class defineClass (byte[] bytecodes,\n-\t\t\t\t     int offset, int length)\n-    {\n-      return defineClass (null, bytecodes, offset, length);\n-    }\n+  static public ClassLoader getSystemClassLoader () {\n+    if (system == null)\n+      system = getVMClassLoader0 ();\n+    return system;\n+  }\n \n-  protected final Class findLoadedClass (String className)\n-    {\n-      return (Class) cache.get(className);\n-    }\n+  /**\n+   * Creates a <code>ClassLoader</code>.   The only thing this\n+   * constructor does, is to call\n+   * <code>checkCreateClassLoader</code> on the current \n+   * security manager. \n+   * @exception java.lang.SecurityException if not allowed\n+   */\n+  protected ClassLoader() \n+  {\n+    SecurityManager security = System.getSecurityManager ();\n+    if (security != null)\n+      security.checkCreateClassLoader ();\n+  }\n \n-  protected final Class findSystemClass (String className)\n-    throws ClassNotFoundException\n-    {\n-      Class c = system.findLoadedClass(className);\n-      system.resolveClass(c);\n-      return c;\n-    }\n+  /** \n+   * Loads and link the class by the given name.\n+   * @param     name the name of the class.\n+   * @return    the class loaded.\n+   * @see       ClassLoader#loadClass(String,boolean)\n+   * @exception java.lang.ClassNotFoundException \n+   */ \n+  public Class loadClass(String name) \n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError\n+  { \n+    return loadClass (name, true);\n+  }\n \n-  // FIXME: Needs URL.\n-  // public URL getResource (String resName);\n+  /** \n+   * Loads the class by the given name.  \n+   * As per java 1.1, this has been deprecated.  Use \n+   * <code>loadClass(String)</code>\n+   * instead.\n+   * @param     name the name of the class.\n+   * @param     link if the class should be linked.\n+   * @return    the class loaded.\n+   * @exception java.lang.ClassNotFoundException \n+   * @deprecated \n+   */ \n+  protected abstract Class loadClass(String name, boolean link)\n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError;\n \n-  public InputStream getResourceAsStream (String resName)\n-    {\n-      return null;\n-    }\n+  /** \n+   * Defines a class, given the class-data.  According to the JVM, this\n+   * method should not be used; instead use the variant of this method\n+   * in which the name of the class being defined is specified\n+   * explicitly.   \n+   * <P>\n+   * If the name of the class, as specified (implicitly) in the class\n+   * data, denotes a class which has already been loaded by this class\n+   * loader, an instance of\n+   * <code>java.lang.ClassNotFoundException</code> will be thrown.\n+   *\n+   * @param     data    bytes in class file format.\n+   * @param     off     offset to start interpreting data.\n+   * @param     len     length of data in class file.\n+   * @return    the class defined.\n+   * @exception java.lang.ClassNotFoundException \n+   * @exception java.lang.LinkageError\n+   * @see ClassLoader#defineClass(String,byte[],int,int) */\n+  protected final Class defineClass(byte[] data, int off, int len) \n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError\n+  {\n+    return defineClass (null, data, off, len);\n+  }\n \n-  // FIXME: Needs URL.\n-  // public static final URL getSystemResource (String resName);\n+  /** \n+   * Defines a class, given the class-data.  This is preferable\n+   * over <code>defineClass(byte[],off,len)</code> since it is more\n+   * secure.  If the expected name does not match that of the class\n+   * file, <code>ClassNotFoundException</code> is thrown.  If\n+   * <code>name</code> denotes the name of an already loaded class, a\n+   * <code>LinkageError</code> is thrown.\n+   * <p>\n+   * \n+   * FIXME: How do we assure that the class-file data is not being\n+   * modified, simultaneously with the class loader running!?  If this\n+   * was done in some very clever way, it might break security.  \n+   * Right now I am thinking that defineclass should make sure never to\n+   * read an element of this array more than once, and that that would\n+   * assure the ``immutable'' appearance.  It is still to be determined\n+   * if this is in fact how defineClass operates.\n+   *\n+   * @param     name    the expected name.\n+   * @param     data    bytes in class file format.\n+   * @param     off     offset to start interpreting data.\n+   * @param     len     length of data in class file.\n+   * @return    the class defined.\n+   * @exception java.lang.ClassNotFoundException \n+   * @exception java.lang.LinkageError\n+   */\n+  protected final synchronized Class defineClass(String name,\n+\t\t\t\t\t\t byte[] data,\n+\t\t\t\t\t\t int off,\n+\t\t\t\t\t\t int len)\n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError\n+  {\n+    if (data==null || data.length < off+len || off<0 || len<0)\n+      throw new ClassFormatError (\"arguments to defineClass \"\n+\t\t\t\t  + \"are meaningless\");\n \n-  public static final InputStream getSystemResourceAsStream (String resName)\n-    {\n-      return null;\n-    }\n+    // as per 5.3.5.1\n+    if (name != null  &&  findLoadedClass (name) != null)\n+      throw new java.lang.LinkageError (\"class \" \n+\t\t\t\t\t+ name \n+\t\t\t\t\t+ \" already loaded\");\n \n-  protected abstract Class loadClass (String className, boolean resolve)\n-    throws ClassNotFoundException;\n-  public Class loadClass (String name) throws ClassNotFoundException\n-    {\n-      return loadClass (name, true);\n-    }\n+    try {\n+      // Since we're calling into native code here, \n+      // we better make sure that any generated\n+      // exception is to spec!\n+\n+      return defineClass0 (name, data, off, len);\n+\n+    } catch (java.lang.LinkageError x) {\n+      throw x;\t\t// rethrow\n+\n+    } catch (java.lang.ClassNotFoundException x) {\n+      throw x;\t\t// rethrow\n+\n+    } catch (java.lang.VirtualMachineError x) {\n+      throw x;\t\t// rethrow\n+\n+    } catch (java.lang.Throwable x) {\n+      // This should never happen, or we are beyond spec.  \n+      \n+      throw new InternalError (\"Unexpected exception \"\n+\t\t\t       + \"while defining class \"\n+\t\t\t       + name + \": \" \n+\t\t\t       + x.toString ());\n+     }\n+  }\n+\n+  /** This is the entry point of defineClass into the native code */\n+  private native Class defineClass0 (String name,\n+\t\t\t\t     byte[] data,\n+\t\t\t\t     int off,\n+\t\t\t\t     int len)\n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError;\n \n-  protected final void resolveClass (Class c)\n-    {\n-      // Nothing for now.\n-    }\n \n-  protected final void setSigners (Class cl, Object[] signers)\n-    {\n-      // Nothing for now.\n+  /** This is called by defineClass0, once the \"raw\" and uninitialized\n+   * class object has been created, and handles exceptions generated\n+   * while actually defining the class (_Jv_DefineClass).  defineClass0\n+   * holds the lock on the new class object, so it needs to capture\n+   * these exceptions.  */\n+\n+  private static Throwable defineClass1 (Class klass, byte[] data,\n+\t\t\t\t\t int offset, int length)\n+  {\n+    try {\n+      defineClass2 (klass, data, offset, length);\n+    } catch (Throwable x) {\n+      return x;\n     }\n+    return null;\n+  }\n+ \n+  /** This is just a wrapper for _Jv_DefineClass */\n+  private static native void defineClass2 (Class klass, byte[] data, \n+\t\t\t\t    int offset, int length)\n+    throws Throwable;\n+\n+  /** \n+   * Link the given class.  This will bring the class to a state where\n+   * the class initializer can be run.  Linking involves the following\n+   * steps: \n+   * <UL>\n+   * <LI>  Prepare (allocate and internalize) the constant strings that\n+   *       are used in this class.\n+   * <LI>  Allocate storage for static fields, and define the layout\n+   *       of instance fields.\n+   * <LI>  Perform static initialization of ``static final'' int,\n+   *       long, float, double and String fields for which there is a\n+   *       compile-time constant initializer.\n+   * <LI>  Create the internal representation of the ``vtable''.\n+   * </UL>\n+   * For <code>gcj</code>-compiled classes, only the first step is\n+   * performed.  The compiler will have done the rest already.\n+   * <P>\n+   * This is called by the system automatically,\n+   * as part of class initialization; there is no reason to ever call\n+   * this method directly.  \n+   * <P> \n+   * For historical reasons, this method has a name which is easily\n+   * misunderstood.  Java classes are never ``resolved''.  Classes are\n+   * linked; whereas method and field references are resolved.\n+   * <P>\n+   * FIXME: The JDK documentation declares this method\n+   * <code>final</code>, we declare it <code>static</code> -- any\n+   * objections?  This allows us to call it directly from native code\n+   * with less hassle. \n+   *\n+   * @param     clazz the class to link.\n+   * @exception java.lang.LinkageError\n+   */\n+  protected static void resolveClass(Class clazz)\n+    throws java.lang.LinkageError\n+  {\n+    synchronized (clazz)\n+      {\n+\ttry {\n+\t  linkClass0 (clazz);\n+\t} catch (Throwable x) {\n+\t  markClassErrorState0 (clazz);\n+\n+\t  if (x instanceof Error)\n+\t    throw (Error)x;\n+\t  else    \n+\t    throw new java.lang.InternalError\n+\t      (\"unexpected exception during linking: \" + x);\n+\t}\n+      }\n+  }\n+\n+  /** Internal method.  Calls _Jv_PrepareClass and\n+   * _Jv_InternClassStrings.  This is only called from resolveClass.  */ \n+  private static native void linkClass0(Class clazz)\n+    throws java.lang.LinkageError;\n+\n+  /** Internal method.  Marks the given clazz to be in an erroneous\n+   * state, and calls notifyAll() on the class object.  This should only\n+   * be called when the caller has the lock on the class object.  */\n+  private static native void markClassErrorState0(Class clazz);\n+\n+\n+  /** \n+   * Returns a class found in a system-specific way, typically\n+   * via the <code>java.class.path</code> system property.  \n+   *\n+   * @param     name the class to resolve.\n+   * @return    the class loaded.\n+   * @exception java.lang.LinkageError \n+   * @exception java.lang.ClassNotFoundException \n+   */\n+  protected native static Class findSystemClass(String name) \n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError;\n+\n+  /*\n+   * Does currently nothing.\n+   */ \n+  protected final void setSigners(Class claz, Object[] signers) {\n+    /* claz.setSigners (signers); */\n+  }\n+\n+  /*\n+   * If a class named <code>name</code> was previously loaded using\n+   * this <code>ClassLoader</code>, then it is returned.  Otherwise\n+   * it returns <code>null</code>.\n+   * @param     name  class to find.\n+   * @return    the class loaded, or null.\n+   */ \n+  protected native Class findLoadedClass(String name);\n \n-  // Class cache.\n-  private Hashtable cache;\n+  public static final InputStream getSystemResourceAsStream(String name) {\n+    return system.getResourceAsStream (name);\n+  }\n \n-  // The system class loader.  FIXME: should have an actual value\n-  private static final ClassLoader system = null;\n+  public static final URL getSystemResource(String name) {\n+    return system.getResource (name);\n+  }\n+\n+  public static final byte[] getSystemResourceAsBytes(String name) {\n+    return system.getResourceAsBytes (name);\n+  }\n+\n+  /**\n+   *   Return an InputStream representing the resource name.  \n+   *   This is essentially like \n+   *   <code>getResource(name).openStream()</code>, except\n+   *   it masks out any IOException and returns null on failure.\n+   * @param   name  resource to load\n+   * @return  an InputStream, or null\n+   * @see     java.lang.ClassLoader#getResource(String)\n+   * @see     java.lang.ClassLoader#getResourceAsBytes(String)\n+   * @see     java.io.InputStream\n+   */\n+  public InputStream getResourceAsStream(String name) \n+  {\n+    try {\n+      URL res = getResource (name);\n+      if (res == null) return null;\n+      return res.openStream ();\n+    } catch (java.io.IOException x) {\n+       return null;\n+     }\n+  }\n+ \n+  /**\n+   *  Return a byte array <code>byte[]</code> representing the\n+   *  resouce <code>name</code>.  This only works for resources\n+   *  that have a known <code>content-length</code>, and\n+   *  it will block while loading the resource.  Returns null\n+   *  for error conditions.<p>\n+   *  Since it is synchroneous, this is only convenient for \n+   *  resources that are \"readily\" available.  System resources\n+   *  can conveniently be loaded this way, and the runtime\n+   *  system uses this to load class files.  <p>\n+   *  To find the class data for a given class, use\n+   *  something like the following:\n+   *  <ul><code>\n+   *  String res = clazz.getName().replace ('.', '/')) + \".class\";<br>\n+   *  byte[] data = getResourceAsBytes (res);\n+   *  </code></ul>\n+   * @param   name  resource to load\n+   * @return  a byte array, or null\n+   * @see     java.lang.ClassLoader#getResource(String)\n+   * @see     java.lang.ClassLoader#getResourceAsStream(String)\n+   */\n+  public byte[] getResourceAsBytes(String name) {\n+    try {\n+      URL res = getResource (name);\n+      if (res == null) return null;\n+      URLConnection conn = res.openConnection ();\n+      int len = conn.getContentLength ();\n+      if (len == -1) return null;\n+      return readbytes (conn.getInputStream (), len);\n+    } catch (java.io.IOException x) {\n+       return null;\n+     }\n+  }\n+ \n+  /**\n+   * Return an java.io.URL representing the resouce <code>name</code>.  \n+   * @param   name  resource to load\n+   * @return  a URL, or null if there is no such resource.\n+   * @see     java.lang.ClassLoader#getResourceAsBytes(String)\n+   * @see     java.lang.ClassLoader#getResourceAsStream(String)\n+   * @see     java.io.URL\n+   */\n+  public URL getResource(String name) {\n+    return null;\n+  }\n+\n+  /**\n+   * Utility routine to read a resource fully, even if the given\n+   * InputStream only provides partial results.\n+   */\n+  private static byte[] readbytes (InputStream is, int length)\n+  {\n+    try {\n+\n+      byte[] data = new byte[length];\n+      int read; \n+      int off = 0;\n+\t    \n+      while (off != length)\n+\t{\n+\t  read = is.read (data, off, (int) (length-off));\n+\n+\t  if (read == -1) \n+\t    return null;\n+\n+\t  off += read;\n+\t}\n+\t    \n+      return data;\n+    } catch (java.io.IOException x) {\n+      return null;\n+    }\n+  }\n }"}, {"sha": "0dd5c9c67ada160f012102085d7b5a4fa1c9ba04", "filename": "libjava/java/lang/FirstThread.java", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FFirstThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FFirstThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FFirstThread.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -19,12 +19,30 @@\n \n final class FirstThread extends Thread\n {\n-  public native void run ();\n+  public native void run0 ();\n+  public void run () \n+  {\n+    try {\n+      run0 ();\n+    } catch (Throwable ex) {\n+      System.err.println (\"uncaught exception at top level\");\n+      ex.printStackTrace ();\n+    }\n+  }\n \n   public FirstThread (ThreadGroup g, Class k, Object o)\n   {\n     super (g, null, \"main\");\n     klass = k;\n+    klass_name = null;\n+    args = o;\n+  }\n+\n+  public FirstThread (ThreadGroup g, String class_name, Object o)\n+  {\n+    super (g, null, \"main\");\n+    klass = null;\n+    klass_name = class_name;\n     args = o;\n   }\n \n@@ -36,5 +54,6 @@ private static void die (String s)\n \n   // Private data.\n   private Class klass;\n+  private String klass_name;\n   private Object args;\n }"}, {"sha": "026f6d8d1fb0cd309600fa9ab74665a3e10e14c0", "filename": "libjava/java/lang/VMClassLoader.java", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,117 @@\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+package java.lang;\n+\n+import java.io.*;\n+import java.net.URL;\n+import gnu.gcj.util.path.SearchPath;\n+\n+final class VMClassLoader extends java.lang.ClassLoader\n+{\n+  private SearchPath   path;\n+  private final String path_seperator;\n+  private final String file_seperator;\n+  private final char   file_seperator_char;\n+    \n+  private VMClassLoader () {\t\n+    path_seperator = System.getProperty (\"path.separator\", \":\");\n+    file_seperator = System.getProperty (\"file.separator\", \"/\");\n+\n+    file_seperator_char = file_seperator.charAt (0);\n+\n+    String class_path = System.getProperty (\"java.class.path\", \".\");\n+    path = new SearchPath (class_path);\n+  }\n+\n+  protected Class loadClass(String name,\n+\t\t\t    boolean resolve) \n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError\n+  {\n+    return loadClassInternal (name, resolve, false);\n+  }\n+\t\n+    /** I'm a little in doubt here, if this method is \n+\tactually supposed to throw a LinkageError, or not.  \n+\tThe spec, 20.14.3, is a little unclear.  It says:\n+\n+\t`` The general contract of loadClass is that, given the name\n+\tof a class, it either returns the Class object for the class\n+\tor throws a ClassNotFoundException.''\n+\n+\tHowever, by making LinkageError a checked exception, \n+\ti.e., mention it directly in the throws clause,\n+\twe'll force caller to consider that case as well.\n+    **/\n+\n+  protected Class loadClassInternal(String name,\n+\t\t\t\t    boolean resolve, \n+\t\t\t\t    boolean fromBootLoader) \n+    throws java.lang.ClassNotFoundException, java.lang.LinkageError\n+  {\n+    Class clazz;\n+\n+    /** TODO: call _Jv_VerifyClassName **/\n+    if (   (name.indexOf ('/') != -1)\n+\t   || (name.charAt (0) == '.')\n+\t   || (name.indexOf (file_seperator) != -1)\n+\t   || (name.indexOf (\"..\") != -1))\n+\t{\n+\t    throw new IllegalArgumentException (name);\n+\t}\n+\n+    // already loaded?\n+    clazz = findLoadedClass (name);\n+\n+    // we need access to the boot class loader here\n+    if (clazz == null && !fromBootLoader)\n+      clazz = findBootClass (name);\n+\n+    if (clazz == null)\n+      {\n+\tStringBuffer res = new StringBuffer ();\n+\n+\t// here we do actually replace .'s with /'s because\n+\t// we're going to find something in the file system.\n+\tres.append (name.replace ('.', file_seperator_char));\n+\tres.append (\".class\");\n+\t\t\n+\tbyte[] data = getResourceAsBytes (res.toString ());\n+\n+\tif (data == null)\n+\t  throw new ClassNotFoundException (name);\n+\n+\tclazz = defineClass (name, data, 0, data.length);\n+\t    \n+      }\n+\n+    if (resolve && clazz != null)\n+      resolveClass (clazz);\n+\n+    return clazz;\n+  }\n+\n+  private native Class findBootClass (String name);\n+\n+  public InputStream getResourceAsStream(String name) \n+  {\n+    return path.getStream (name);\n+  }\n+\n+  public URL getResource(String name) \n+  {\n+    return path.getURL (name);\n+  }\n+\n+  public byte[] getResourceAsBytes(String name) \n+  {\n+    return path.getBytes (name);\n+  }\n+}"}, {"sha": "ee6d8e829bdfa1676ded185829328c34438ae1a5", "filename": "libjava/java/lang/VirtualMachineError.java", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FVirtualMachineError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FVirtualMachineError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVirtualMachineError.java?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -20,6 +20,11 @@\n  * Status:  Believed complete and correct.\n  */\n \n+/* FIXME: We should consider adding some special error message when this\n+ * exception is thrown, or maybe if it being caught at top-level.  Such\n+ * a message would direct the user to send a bug report to\n+ * gcj-bugs@cygnus.com, or something like that. --KKT */\n+\n public abstract class VirtualMachineError extends Error\n {\n   public VirtualMachineError ()"}, {"sha": "367f14abb0f6d2f20aeddb59a6ba0d94fdf6701f", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 109, "deletions": 277, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -39,6 +39,8 @@ details.  */\n #include <java/lang/System.h>\n #include <java/lang/SecurityManager.h>\n \n+#include <java-cpool.h>\n+\n \f\n \n #define CloneableClass _CL_Q34java4lang9Cloneable\n@@ -59,28 +61,6 @@ static _Jv_Utf8Const *void_signature = _Jv_makeUtf8Const (\"()V\", 3);\n static _Jv_Utf8Const *clinit_name = _Jv_makeUtf8Const (\"<clinit>\", 8);\n static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n \n-// These are the possible values for the `state' field.  They more or\n-// less follow the section numbers in the Java Language Spec.  Right\n-// now we don't bother to represent other interesting states, e.g. the\n-// states a class might inhabit before it is prepared.  Note that\n-// ordering is important here; in particular `resolved' must come\n-// between `nothing' and the other states.\n-#define STATE_NOTHING      0\n-#define STATE_RESOLVED     1\n-#define STATE_IN_PROGRESS  6\n-#define STATE_DONE         9\n-#define STATE_ERROR       10\n-\n-// Size of local hash table.\n-#define HASH_LEN 256\n-\n-// Hash function for Utf8Consts.\n-#define HASH_UTF(Utf) (((Utf)->hash) % HASH_LEN)\n-\n-// This is the table we use to keep track of loaded classes.  See Spec\n-// section 12.2.\n-static jclass loaded_classes[HASH_LEN];\n-\n \f\n \n jclass\n@@ -111,6 +91,9 @@ java::lang::Class::forName (jstring className)\n #endif\n   if (! klass)\n     JvThrow (new java::lang::ClassNotFoundException (className));\n+\n+  _Jv_InitClass (klass);\n+\n   return klass;\n }\n \n@@ -380,33 +363,13 @@ java::lang::Class::newInstance (void)\n   return r;\n }\n \n-// Initialize the constants.\n void\n-java::lang::Class::resolveConstants (void)\n+java::lang::Class::finalize (void)\n {\n-  for (int i = 0; i < constants.size; ++i)\n-    {\n-      if (constants.tags[i] == CONSTANT_String)\n-\t{\n-\t  jstring str;\n-\t  str = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) constants.data[i]);\n-\t  constants.data[i] = (void *) str;\n-\t  constants.tags[i] = CONSTANT_ResolvedString;\n-\t}\n-      else if (constants.tags[i] == CONSTANT_Class)\n-\t{\n-\t  _Jv_Utf8Const *name = (_Jv_Utf8Const *) constants.data[i];\n-\t  jclass klass = _Jv_FindClassFromSignature (name->data, loader);\n-\t  if (! klass)\n-\t    {\n-\t      jstring str = _Jv_NewStringUtf8Const (name);\n-\t      JvThrow (new java::lang::ClassNotFoundException (str));\n-\t    }\n-\n-\t  constants.data[i] = (void *) klass;\n-\t  constants.tags[i] = CONSTANT_ResolvedClass;\n-\t}\n-    }\n+#ifdef INTERPRETER\n+  JvAssert (_Jv_IsInterpretedClass (this));\n+  _Jv_UnregisterClass (this);\n+#endif\n }\n \n // FIXME.\n@@ -424,46 +387,60 @@ void\n java::lang::Class::initializeClass (void)\n {\n   // Short-circuit to avoid needless locking.\n-  if (state == STATE_DONE)\n+  if (state == JV_STATE_DONE)\n     return;\n \n-  // Step 1.\n-  _Jv_MonitorEnter (this);\n+  // do this before we enter the monitor below, since this can cause\n+  // exceptions.  Here we assume, that reading \"state\" is an atomic\n+  // operation, I pressume that is true? --Kresten\n+  if (state < JV_STATE_LINKED)\n+    {\n+#ifdef INTERPRETER\n+      if (_Jv_IsInterpretedClass (this))\n+\t{\n+\t  java::lang::ClassLoader::resolveClass (this);\n \n-  // FIXME: This should actually be handled by calling into the class\n-  // loader.  For now we put it here.\n-  if (state < STATE_RESOLVED)\n+\t  // Step 1.\n+\t  _Jv_MonitorEnter (this);\n+\t}\n+      else\n+#endif\n+        {\n+          // Step 1.\n+\t  _Jv_MonitorEnter (this);\n+\t  _Jv_InternClassStrings (this);\n+\t}\n+    }\n+  else\n     {\n-      // We set the state before calling resolveConstants to avoid\n-      // infinite recursion when processing String or Class.\n-      state = STATE_RESOLVED;\n-      resolveConstants ();\n+      // Step 1.\n+      _Jv_MonitorEnter (this);\n     }\n \n   // Step 2.\n   java::lang::Thread *self = java::lang::Thread::currentThread();\n   // FIXME: `self' can be null at startup.  Hence this nasty trick.\n   self = (java::lang::Thread *) ((long) self | 1);\n-  while (state == STATE_IN_PROGRESS && thread && thread != self)\n+  while (state == JV_STATE_IN_PROGRESS && thread && thread != self)\n     wait ();\n \n   // Steps 3 &  4.\n-  if (state == STATE_DONE || state == STATE_IN_PROGRESS || thread == self)\n+  if (state == JV_STATE_DONE || state == JV_STATE_IN_PROGRESS || thread == self)\n     {\n       _Jv_MonitorExit (this);\n       return;\n     }\n \n   // Step 5.\n-  if (state == STATE_ERROR)\n+  if (state == JV_STATE_ERROR)\n     {\n       _Jv_MonitorExit (this);\n       JvThrow (new java::lang::NoClassDefFoundError);\n     }\n \n   // Step 6.\n   thread = self;\n-  state = STATE_IN_PROGRESS;\n+  state = JV_STATE_IN_PROGRESS;\n   _Jv_MonitorExit (this);\n \n   // Step 7.\n@@ -477,7 +454,7 @@ java::lang::Class::initializeClass (void)\n \t{\n \t  // Caught an exception.\n \t  _Jv_MonitorEnter (this);\n-\t  state = STATE_ERROR;\n+\t  state = JV_STATE_ERROR;\n \t  notify ();\n \t  _Jv_MonitorExit (this);\n \t  JvThrow (except);\n@@ -492,7 +469,7 @@ java::lang::Class::initializeClass (void)\n   if (! except)\n     {\n       _Jv_MonitorEnter (this);\n-      state = STATE_DONE;\n+      state = JV_STATE_DONE;\n     }\n   else\n     {\n@@ -503,7 +480,7 @@ java::lang::Class::initializeClass (void)\n \t  except = hackTrampoline(2, except);\n \t}\n       _Jv_MonitorEnter (this);\n-      state = STATE_ERROR;\n+      state = JV_STATE_ERROR;\n     }\n   notify ();\n   _Jv_MonitorExit (this);\n@@ -530,6 +507,64 @@ _Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n   return NULL;\n }\n \n+#define MCACHE_SIZE 1013\n+\n+struct _Jv_mcache {\n+  jclass klass;\n+  _Jv_Method *method;\n+};\n+\n+static _Jv_mcache method_cache[MCACHE_SIZE];\n+static int method_cache_count;\n+\n+static void*\n+_Jv_FindMethodInCache (jclass klass,\n+\t\t       _Jv_Utf8Const *name,\n+\t\t       _Jv_Utf8Const *signature)\n+{\n+  for (int index = name->hash % MCACHE_SIZE;\n+       method_cache[index].klass != NULL;\n+       index = (index+1) % MCACHE_SIZE)\n+    {\n+      _Jv_mcache *mc = (method_cache+index);\n+      _Jv_Method *m  = mc->method;\n+\n+      if (mc->klass == klass\n+\t  && m != NULL\t\t// thread safe check\n+\t  && _Jv_equalUtf8Consts (m->name, name)\n+\t  && _Jv_equalUtf8Consts (m->signature, signature))\n+\t{\n+\t  return mc->method->ncode;\n+\t}\n+    }  \n+  return NULL;\n+}\n+\n+static void\n+_Jv_AddMethodToCache (jclass klass,\n+\t\t\t_Jv_Method *method)\n+{\n+  _Jv_MonitorEnter (&ClassClass); \n+\n+  if (method_cache_count > MCACHE_SIZE*2/3)\n+    {\n+      for (int i = 0; i < MCACHE_SIZE; i++)\n+\tmethod_cache[i].klass = 0;\n+    }\n+\n+  for (int index = method->name->hash % MCACHE_SIZE;\n+       method_cache[index].klass != NULL;\n+       index = (index+1) % MCACHE_SIZE)\n+    {\n+      method_cache[index].method = method;\n+      method_cache[index].klass = klass;\n+    }\n+\n+  method_cache_count += 1;\n+  \n+  _Jv_MonitorExit (&ClassClass);\n+}\n+\n void *\n _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n \t\t\t   _Jv_Utf8Const *signature)\n@@ -539,6 +574,14 @@ _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n   // call a method of a class until the class is linked.  But this\n   // captures the general idea.\n   // klass->getClassLoader()->resolveClass(klass);\n+  // \n+  // KKT: This is unnessecary, exactly for the reason you present: \n+  // _Jv_LookupInterfaceMethod is only called on object instances, and\n+  // such have already been initialized (which includes resolving).\n+\n+  void *ncode = _Jv_FindMethodInCache (klass, name, signature);\n+  if (ncode != 0)\n+    return ncode;\n \n   for (; klass; klass = klass->getSuperclass())\n     {\n@@ -553,6 +596,8 @@ _Jv_LookupInterfaceMethod (jclass klass, _Jv_Utf8Const *name,\n       if (! java::lang::reflect::Modifier::isPublic(meth->accflags))\n \tJvThrow (new java::lang::IllegalAccessError);\n \n+      _Jv_AddMethodToCache (klass, meth);\n+\n       return meth->ncode;\n     }\n   JvThrow (new java::lang::IncompatibleClassChangeError);\n@@ -565,219 +610,6 @@ _Jv_InitClass (jclass klass)\n   klass->initializeClass();\n }\n \n-// This function is called many times during startup, before main() is\n-// run.  We do our runtime initialization here the very first time we\n-// are called.  At that point in time we know for certain we are\n-// running single-threaded, so we don't need to lock when modifying\n-// `init'.  CLASSES is NULL-terminated.\n-void\n-_Jv_RegisterClasses (jclass *classes)\n-{\n-  static bool init = false;\n-\n-  if (! init)\n-    {\n-      init = true;\n-      _Jv_InitThreads ();\n-      _Jv_InitGC ();\n-      _Jv_InitializeSyncMutex ();\n-    }\n-\n-  JvSynchronize sync (&ClassClass);\n-  for (; *classes; ++classes)\n-    {\n-      jclass klass = *classes;\n-      jint hash = HASH_UTF (klass->name);\n-      klass->next = loaded_classes[hash];\n-      loaded_classes[hash] = klass;\n-    }\n-}\n-\n-void\n-_Jv_RegisterClass (jclass klass)\n-{\n-  jclass classes[2];\n-  classes[0] = klass;\n-  classes[1] = NULL;\n-  _Jv_RegisterClasses (classes);\n-}\n-\n-jclass\n-_Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n-{\n-  JvSynchronize sync (&ClassClass);\n-  jint hash = HASH_UTF (name);\n-  jclass klass;\n-  for (klass = loaded_classes[hash]; klass; klass = klass->next)\n-    {\n-      if (loader == klass->loader && _Jv_equalUtf8Consts (name, klass->name))\n-\tbreak;\n-    }\n-  return klass;\n-}\n-\n-#if 0\n-jclass\n-_Jv_FindClassInCache (jstring name, java::lang::ClassLoader *loader)\n-{\n-  JvSynchronize sync (&ClassClass);\n-  jint hash = name->hashCode();\n-  jclass klass = loaded_classes[(_Jv_ushort) hash % HASH_LEN];\n-  for ( ; klass; klass = klass->next)\n-    {\n-      if (loader == klass->loader\n-\t  && _Jv_equalUtf8Consts (klass->name, name, hash))\n-\tbreak;\n-    }\n-  return klass;\n-}\n-#endif\n-\n-jclass\n-_Jv_FindClass (_Jv_Utf8Const* name, java::lang::ClassLoader *loader)\n-{\n-  jclass klass = _Jv_FindClassInCache (name, loader);\n-  if (loader && ! klass)\n-    {\n-      klass = loader->loadClass(_Jv_NewStringUtf8Const (name));\n-      if (klass)\n-\t_Jv_RegisterClass (klass);\n-    }\n-  return klass;\n-}\n-\n-#if 0\n-jclass\n-_Jv_FindClass (jstring name, java::lang::ClassLoader *loader)\n-{\n-  jclass klass = _Jv_FindClassInCache (name, loader);\n-  if (loader && ! klass)\n-    {\n-      klass = loader->loadClass(name);\n-      if (klass)\n-\t_Jv_RegisterClass (klass);\n-    }\n-  return klass;\n-}\n-#endif\n-\n-jclass\n-_Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n-\t      java::lang::ClassLoader *loader)\n-{\n-  jclass ret = (jclass) JvAllocObject (&ClassClass);\n-\n-  ret->next = NULL;\n-  ret->name = name;\n-  ret->accflags = 0;\n-  ret->superclass = superclass;\n-  ret->constants.size = 0;\n-  ret->constants.tags = NULL;\n-  ret->constants.data = NULL;\n-  ret->methods = NULL;\n-  ret->method_count = 0;\n-  ret->vtable_method_count = 0;\n-  ret->fields = NULL;\n-  ret->size_in_bytes = 0;\n-  ret->field_count = 0;\n-  ret->static_field_count = 0;\n-  ret->vtable = NULL;\n-  ret->interfaces = NULL;\n-  ret->loader = loader;\n-  ret->interface_count = 0;\n-  ret->state = 0;\n-  ret->thread = NULL;\n-\n-  _Jv_RegisterClass (ret);\n-\n-  return ret;\n-}\n-\n-jclass\n-_Jv_FindArrayClass (jclass element)\n-{\n-  _Jv_Utf8Const *array_name;\n-  int len;\n-  if (element->isPrimitive())\n-    {\n-      // For primitive types the array is cached in the class.\n-      jclass ret = (jclass) element->methods;\n-      if (ret)\n-\treturn ret;\n-      len = 3;\n-    }\n-  else\n-    len = element->name->length + 5;\n-\n-  {\n-    char signature[len];\n-    int index = 0;\n-    signature[index++] = '[';\n-    // Compute name of array class to see if we've already cached it.\n-    if (element->isPrimitive())\n-      {\n-\tsignature[index++] = (char) element->method_count;\n-      }\n-    else\n-      {\n-\tsize_t length = element->name->length;\n-\tconst char *const name = element->name->data;\n-\tif (name[0] != '[')\n-\t  signature[index++] = 'L';\n-\tmemcpy (&signature[index], name, length);\n-\tindex += length;\n-\tif (name[0] != '[')\n-\t  signature[index++] = ';';\n-      }      \n-    array_name = _Jv_makeUtf8Const (signature, index);\n-  }\n-\n-  jclass array_class = _Jv_FindClassInCache (array_name, element->loader);\n-\n-  if (! array_class)\n-    {\n-      // Create new array class.\n-      array_class = _Jv_NewClass (array_name, &ObjectClass, element->loader);\n-\n-      // Note that `vtable_method_count' doesn't include the initial\n-      // NULL slot.\n-      int dm_count = ObjectClass.vtable_method_count + 1;\n-\n-      // Create a new vtable by copying Object's vtable (except the\n-      // class pointer, of course).  Note that we allocate this as\n-      // unscanned memory -- the vtables are handled specially by the\n-      // GC.\n-      int size = (sizeof (_Jv_VTable) +\n-\t\t  ((dm_count - 1) * sizeof (void *)));\n-      _Jv_VTable *vtable = (_Jv_VTable *) _Jv_AllocBytes (size);\n-      vtable->clas = array_class;\n-      memcpy (vtable->method, ObjectClass.vtable->method,\n-\t      dm_count * sizeof (void *));\n-      array_class->vtable = vtable;\n-      array_class->vtable_method_count = ObjectClass.vtable_method_count;\n-\n-      // Stash the pointer to the element type.\n-      array_class->methods = (_Jv_Method *) element;\n-\n-      // Register our interfaces.\n-      // FIXME: for JDK 1.2 we need Serializable.\n-      static jclass interfaces[] = { &CloneableClass };\n-      array_class->interfaces = interfaces;\n-      array_class->interface_count = 1;\n-\n-      // FIXME: initialize other Class instance variables,\n-      // e.g. `fields'.\n-\n-      array_class->state = STATE_DONE;\n-    }\n-\n-  // For primitive types, point back at this array.\n-  if (element->isPrimitive())\n-    element->methods = (_Jv_Method *) array_class;\n-\n-  return array_class;\n-}\n-\n jboolean\n _Jv_IsInstanceOf(jobject obj, jclass cl)\n {"}, {"sha": "13452eccd99ee3b4c998ec1f6aa37979b89a644c", "filename": "libjava/java/lang/natClassLoader.cc", "status": "added", "additions": 624, "deletions": 0, "changes": 624, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,624 @@\n+// natClassLoader.cc - Implementation of java.lang.ClassLoader native methods.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+#include <config.h>\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <java/lang/Character.h>\n+#include <java/lang/Thread.h>\n+#include <java/lang/ClassLoader.h>\n+#include <java/lang/VMClassLoader.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/LinkageError.h>\n+#include <java/lang/ClassFormatError.h>\n+#include <java/lang/NoClassDefFoundError.h>\n+#include <java/lang/ClassNotFoundException.h>\n+#include <java/lang/ClassCircularityError.h>\n+#include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/reflect/Modifier.h>\n+\n+#include <java-interp.h>\n+\n+#define CloneableClass _CL_Q34java4lang9Cloneable\n+extern java::lang::Class CloneableClass;\n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n+#define ClassClass _CL_Q34java4lang5Class\n+extern java::lang::Class ClassClass;\n+#define VMClassLoaderClass _CL_Q34java4lang17VMClassLoader\n+extern java::lang::Class VMClassLoader;\n+#define ClassLoaderClass _CL_Q34java4lang11ClassLoader\n+extern java::lang::Class ClassLoaderClass;\n+\n+/////////// java.lang.ClassLoader native methods ////////////\n+\n+#ifdef INTERPRETER\n+java::lang::VMClassLoader *redirect = 0;\n+#endif\n+\n+java::lang::ClassLoader*\n+java::lang::ClassLoader::getVMClassLoader0 ()\n+{\n+#ifdef INTERPRETER\n+    if (redirect == 0)\n+\tredirect = new java::lang::VMClassLoader;\n+    return redirect;\n+#else\n+    return 0;\n+#endif\n+}\n+\n+void\n+java::lang::ClassLoader::defineClass2 (jclass klass, jbyteArray data,\n+\t\t\t\t       jint offset, jint length)\n+{\n+#ifdef INTERPRETER\n+  _Jv_DefineClass (klass, data, offset, length);\n+#endif\n+}\n+\n+java::lang::Class *\n+java::lang::ClassLoader::defineClass0 (jstring name,\n+\t\t\t\t       jbyteArray data, \n+\t\t\t\t       jint offset,\n+\t\t\t\t       jint length)\n+{\n+#ifdef INTERPRETER\n+  jclass klass;\n+  klass = (jclass) JvAllocObject (&ClassClass, sizeof (_Jv_InterpClass));\n+\n+  // synchronize on the class, so that it is not\n+  // attempted initialized until we're done loading.\n+  _Jv_MonitorEnter (klass);\n+\n+  // record which is the defining loader\n+  klass->loader = this;\n+\n+  // register that we are the initiating loader...\n+  if (name != 0)\n+    {\n+      _Jv_Utf8Const *   name2 = _Jv_makeUtf8Const (name);\n+\n+      _Jv_VerifyClassName (name2);\n+\n+      klass->name = name2;\n+    }\n+\n+  // this will do the magic.  loadInto also operates\n+  // as an exception trampoline for now...\n+  Throwable *ex = defineClass1 (klass, data, offset, length);\n+    \n+  if (ex)  // we failed to load it\n+    {\n+      klass->state = JV_STATE_ERROR;\n+      klass->notifyAll ();\n+\n+      _Jv_UnregisterClass (klass);\n+\n+      _Jv_MonitorExit (klass);\n+\t  \n+      // FIXME: Here we may want to test that EX does\n+      // indeed represent a valid exception.  That is,\n+      // anything but ClassNotFoundException, \n+      // or some kind of Error.\n+\t  \n+      JvThrow (ex);\n+    }\n+    \n+  // if everything proceeded sucessfully, we're loaded.\n+  JvAssert (klass->state == JV_STATE_LOADED);\n+\n+  // if an exception is generated, this is initially missed.\n+  // however, we come back here in handleException0 below...\n+  _Jv_MonitorExit (klass);\n+\n+  return klass;\n+\n+#else // INTERPRETER\n+\n+  return 0;\n+#endif\n+}\n+\n+void\n+_Jv_WaitForState (jclass klass, int state)\n+{\n+  if (klass->state >= state)\n+    return;\n+  \n+  _Jv_MonitorEnter (klass) ;\n+\n+  if (state == JV_STATE_LINKED)\n+    {\n+      _Jv_MonitorExit (klass);\n+      _Jv_InternClassStrings (klass);\n+      return;\n+    }\n+\t\n+  java::lang::Thread *self = java::lang::Thread::currentThread();\n+\n+  // this is similar to the strategy for class initialization.\n+  // if we already hold the lock, just leave.\n+  while (klass->state <= state\n+\t && klass->thread \n+\t && klass->thread != self)\n+    klass->wait ();\n+\n+  _Jv_MonitorExit (klass);\n+\n+  if (klass->state == JV_STATE_ERROR)\n+    {\n+      _Jv_Throw (new java::lang::LinkageError ());\n+    }\n+}\n+\n+// Finish linking a class.  Only called from ClassLoader::resolveClass.\n+void\n+java::lang::ClassLoader::linkClass0 (java::lang::Class *klass)\n+{\n+  if (klass->state >= JV_STATE_LINKED)\n+    return;\n+\n+#ifdef INTERPRETER\n+  if (_Jv_IsInterpretedClass (klass))\n+    {\n+      _Jv_PrepareClass (klass);\n+    }\n+#endif\n+\n+  _Jv_InternClassStrings (klass);\n+}\n+\n+void\n+java::lang::ClassLoader::markClassErrorState0 (java::lang::Class *klass)\n+{\n+  klass->state = JV_STATE_ERROR;\n+  klass->notifyAll ();\n+}\n+\n+\n+/** this is the only native method in VMClassLoader, so \n+    we define it here. */\n+jclass\n+java::lang::VMClassLoader::findBootClass (jstring name)\n+{\n+  return _Jv_FindClassInCache (_Jv_makeUtf8Const (name), 0);\n+}\n+\n+jclass\n+java::lang::ClassLoader::findLoadedClass (jstring name)\n+{\n+  return _Jv_FindClassInCache (_Jv_makeUtf8Const (name), this);\n+}\n+\n+jclass\n+java::lang::ClassLoader::findSystemClass (jstring name)\n+{\n+  return _Jv_FindClass (_Jv_makeUtf8Const (name), 0);\n+}\n+\n+\n+/* This is the final step of linking, internalizing the constant strings\n+ * of a class.  This is called for both compiled and interpreted\n+ * classes, and it is *only* called from ClassLoader::linkClass0,\n+ * which is always in a context where the current thread has a lock on\n+ * the class in question.  We define it here, and not in resolve.cc, so that\n+ * the entire resolve.cc can be #ifdef'ed away when not using the\n+ * interpreter.   */\n+void\n+_Jv_InternClassStrings(jclass klass)\n+{\n+  if (klass->state >= JV_STATE_LINKED)\n+    return;\n+\n+  // short-circuit, so that mutually dependent classes are ok\n+  klass->state = JV_STATE_LINKED;\n+\n+  _Jv_Constants *pool = &klass->constants;\n+  for (int i = 1; i < pool->size; ++i)\n+    {\n+      if (pool->tags[i] == JV_CONSTANT_String)\n+\t{\n+\t  jstring str;\n+\t  str = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) pool->data[i]);\n+\t  pool->data[i] = (void *) str;\n+\t  pool->tags[i] |= JV_CONSTANT_ResolvedFlag;\n+\t}\n+    }\n+\n+  klass->notifyAll ();\n+}\n+\n+\n+//\n+//  A single class can have many \"initiating\" class loaders,\n+//  and a single \"defining\" class loader.  The Defining\n+//  class loader is what is returned from Class.getClassLoader()\n+//  and is used when loading dependent classes during resolution.\n+//  The set of initiating class loaders are used to ensure\n+//  safety of linking, and is maintained in the hash table\n+//  \"initiated_classes\".  A defining classloader is by definition also\n+//  initiating, so we only store classes in this table, if they have more\n+//  than one class loader associated.\n+//\n+\n+\n+// Size of local hash table.\n+#define HASH_LEN 1013\n+\n+// Hash function for Utf8Consts.\n+#define HASH_UTF(Utf) (((Utf)->hash) % HASH_LEN)\n+\n+struct _Jv_LoaderInfo {\n+    _Jv_LoaderInfo          *next;\n+    java::lang::Class       *klass;\n+    java::lang::ClassLoader *loader;\n+};\n+\n+_Jv_LoaderInfo *initiated_classes[HASH_LEN];\n+jclass loaded_classes[HASH_LEN];\n+\n+jclass\n+_Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n+{\n+  _Jv_MonitorEnter (&ClassClass);\n+  jint hash = HASH_UTF (name);\n+\n+  // first, if LOADER is a defining loader, then it is also initiating\n+  jclass klass;\n+  for (klass = loaded_classes[hash]; klass; klass = klass->next)\n+    {\n+      if (loader == klass->loader && _Jv_equalUtf8Consts (name, klass->name))\n+\tbreak;\n+    }\n+\n+  // otherwise, it may be that the class in question was defined\n+  // by some other loader, but that the loading was initiated by \n+  // the loader in question.\n+  if (!klass)\n+    {\n+      _Jv_LoaderInfo *info;\n+      for (info = initiated_classes[hash]; info; info = info->next)\n+\t{\n+\t  if (loader == info->loader\n+\t      && _Jv_equalUtf8Consts (name, info->klass->name))\n+\t    {\n+\t      klass = info->klass;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  _Jv_MonitorExit (&ClassClass);\n+\n+  return klass;\n+}\n+\n+void\n+_Jv_UnregisterClass (jclass the_class)\n+{\n+  _Jv_MonitorEnter (&ClassClass);\n+  jint hash = HASH_UTF(the_class->name);\n+\n+  jclass *klass = &(loaded_classes[hash]);\n+  for ( ; *klass; klass = &((*klass)->next))\n+    {\n+      if (*klass == the_class)\n+\t{\n+\t  *klass = (*klass)->next;\n+\t  break;\n+\t}\n+    }\n+\n+  _Jv_LoaderInfo **info = &(initiated_classes[hash]);\n+  for ( ; *info; info = &((*info)->next))\n+    {\n+      while ((*info)->klass == the_class)\n+\t{\n+\t  *info = (*info)->next;\n+\t}\n+    }\n+\n+  _Jv_MonitorExit (&ClassClass);\n+}\n+\n+void\n+_Jv_RegisterInitiatingLoader (jclass klass, java::lang::ClassLoader *loader)\n+{\n+  _Jv_LoaderInfo *info = new _Jv_LoaderInfo; // non-gc alloc!\n+  jint hash = HASH_UTF(klass->name);\n+\n+  _Jv_MonitorEnter (&ClassClass);\n+  info->loader = loader;\n+  info->klass  = klass;\n+  info->next   = initiated_classes[hash];\n+  initiated_classes[hash] = info;\n+  _Jv_MonitorExit (&ClassClass);\n+  \n+}\n+\n+// This function is called many times during startup, before main() is\n+// run.  We do our runtime initialization here the very first time we\n+// are called.  At that point in time we know for certain we are\n+// running single-threaded, so we don't need to lock when modifying\n+// `init'.  CLASSES is NULL-terminated.\n+void\n+_Jv_RegisterClasses (jclass *classes)\n+{\n+  static bool init = false;\n+\n+  if (! init)\n+    {\n+      init = true;\n+      _Jv_InitThreads ();\n+      _Jv_InitGC ();\n+      _Jv_InitializeSyncMutex ();\n+    }\n+\n+  JvSynchronize sync (&ClassClass);\n+  for (; *classes; ++classes)\n+    {\n+      jclass klass = *classes;\n+      jint hash = HASH_UTF (klass->name);\n+      klass->next = loaded_classes[hash];\n+      loaded_classes[hash] = klass;\n+\n+      // registering a compiled class causes\n+      // it to be immediately \"prepared\".  \n+      if (klass->state == JV_STATE_NOTING)\n+\tklass->state = JV_STATE_COMPILED;\n+    }\n+}\n+\n+void\n+_Jv_RegisterClass (jclass klass)\n+{\n+  jclass classes[2];\n+  classes[0] = klass;\n+  classes[1] = NULL;\n+  _Jv_RegisterClasses (classes);\n+}\n+\n+#if 0\n+// NOTE: this one is out of date with the new loader stuff...\n+jclass\n+_Jv_FindClassInCache (jstring name, java::lang::ClassLoader *loader)\n+{\n+  JvSynchronize sync (&ClassClass);\n+  jint hash = name->hashCode();\n+  jclass klass = loaded_classes[(_Jv_ushort) hash % HASH_LEN];\n+  for ( ; klass; klass = klass->next)\n+    {\n+      if (loader == klass->loader\n+\t  && _Jv_equal (klass->name, name, hash))\n+\tbreak;\n+    }\n+  _Jv_MonitorExit (&ClassClass);\n+  return klass;\n+}\n+#endif\n+\n+jclass _Jv_FindClass (_Jv_Utf8Const *name,\n+\t\t      java::lang::ClassLoader *loader)\n+{\n+  jclass klass = _Jv_FindClassInCache (name, loader);\n+\n+#ifdef INTERPRETER\n+  if (! klass)\n+    {\n+      jstring sname = _Jv_NewStringUTF (name->data);\n+\n+      if (loader)\n+\t{\n+\t  // Load using a user-defined loader, jvmspec 5.3.2\n+\t  klass = loader->loadClass(sname, false);\n+\n+\t  // if \"loader\" delegateted the loadClass operation\n+\t  // to another loader, register explicitly\n+\t  // that he is also an initiating loader of the\n+\t  // given class.  \t  \n+\n+\t  if (klass && (klass->getClassLoader () != loader))\n+\t    _Jv_RegisterInitiatingLoader (klass, 0);\n+\t}\n+      else \n+\t{\n+\t  if (redirect == NULL)\n+\t    {\n+\t      _Jv_InitClass (&ClassLoaderClass);\n+\t      java::lang::ClassLoader::getSystemClassLoader ();\n+\t    }\n+\n+\t  // Load using the bootstrap loader jmspec 5.3.1\n+\t  klass = redirect -> loadClassInternal (sname, false, true); \n+\n+\t  // register that we're an initiating loader\n+\t  if (klass)\n+\t    {\n+\t      _Jv_RegisterInitiatingLoader (klass, 0);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      // we need classes to be in the hash while\n+      // we're loading, so that they can refer to themselves. \n+      _Jv_WaitForState (klass, JV_STATE_LOADED);\n+    }\n+#endif\n+\n+  return klass;\n+}\n+\n+#if 0\n+// NOTE: this one is out of date with the new class loader stuff...\n+jclass\n+_Jv_FindClass (jstring name, java::lang::ClassLoader *loader)\n+{\n+  jclass klass = _Jv_FindClassInCache (name, loader);\n+  if (! klass)\n+    {\n+      if (loader)\n+\t{\n+\t  klass = loader->loadClass(name);\n+\t}\n+      else\n+\t{\n+\t  // jmspec 5.3.1.2\n+\t  \n+\t  // delegate to the system loader\n+\t  klass = java::lang::ClassLoader::system.loadClass (sname);\n+\t  \n+\t  // register that we're an initiating loader\n+\t  if (klass)\n+\t    _Jv_RegisterInitiatingLoader (klass, 0);\n+\t}\n+    }\n+  else\n+    {\n+      _Jv_WaitForState (klass, JV_STATE_LOADED);\n+    }\n+  \n+  return klass;\n+}\n+#endif\n+\n+jclass\n+_Jv_NewClass (_Jv_Utf8Const *name, jclass superclass,\n+\t      java::lang::ClassLoader *loader)\n+{\n+  jclass ret = (jclass) JvAllocObject (&ClassClass);\n+\n+  ret->next = NULL;\n+  ret->name = name;\n+  ret->accflags = 0;\n+  ret->superclass = superclass;\n+  ret->constants.size = 0;\n+  ret->constants.tags = NULL;\n+  ret->constants.data = NULL;\n+  ret->methods = NULL;\n+  ret->method_count = 0;\n+  ret->vtable_method_count = 0;\n+  ret->fields = NULL;\n+  ret->size_in_bytes = 0;\n+  ret->field_count = 0;\n+  ret->static_field_count = 0;\n+  ret->vtable = NULL;\n+  ret->interfaces = NULL;\n+  ret->loader = loader;\n+  ret->interface_count = 0;\n+  ret->state = 0;\n+  ret->thread = NULL;\n+\n+  _Jv_RegisterClass (ret);\n+\n+  return ret;\n+}\n+\n+jclass\n+_Jv_FindArrayClass (jclass element, java::lang::ClassLoader *loader)\n+{\n+  _Jv_Utf8Const *array_name;\n+  int len;\n+  if (element->isPrimitive())\n+    {\n+      // For primitive types the array is cached in the class.\n+      jclass ret = (jclass) element->methods;\n+      if (ret)\n+\treturn ret;\n+      len = 3;\n+    }\n+  else\n+    len = element->name->length + 5;\n+\n+  {\n+    char signature[len];\n+    int index = 0;\n+    signature[index++] = '[';\n+    // Compute name of array class to see if we've already cached it.\n+    if (element->isPrimitive())\n+      {\n+\tsignature[index++] = (char) element->method_count;\n+      }\n+    else\n+      {\n+\tsize_t length = element->name->length;\n+\tconst char *const name = element->name->data;\n+\tif (name[0] != '[')\n+\t  signature[index++] = 'L';\n+\tmemcpy (&signature[index], name, length);\n+\tindex += length;\n+\tif (name[0] != '[')\n+\t  signature[index++] = ';';\n+      }      \n+    array_name = _Jv_makeUtf8Const (signature, index);\n+  }\n+\n+  jclass array_class = _Jv_FindClassInCache (array_name, element->loader);\n+\n+  if (! array_class)\n+    {\n+      // Create new array class.\n+      array_class = _Jv_NewClass (array_name, &ObjectClass, element->loader);\n+\n+      // Note that `vtable_method_count' doesn't include the initial\n+      // NULL slot.\n+      int dm_count = ObjectClass.vtable_method_count + 1;\n+\n+      // Create a new vtable by copying Object's vtable (except the\n+      // class pointer, of course).  Note that we allocate this as\n+      // unscanned memory -- the vtables are handled specially by the\n+      // GC.\n+      int size = (sizeof (_Jv_VTable) +\n+\t\t  ((dm_count - 1) * sizeof (void *)));\n+      _Jv_VTable *vtable = (_Jv_VTable *) _Jv_AllocBytes (size);\n+      vtable->clas = array_class;\n+      memcpy (vtable->method, ObjectClass.vtable->method,\n+\t      dm_count * sizeof (void *));\n+      array_class->vtable = vtable;\n+      array_class->vtable_method_count = ObjectClass.vtable_method_count;\n+\n+      // Stash the pointer to the element type.\n+      array_class->methods = (_Jv_Method *) element;\n+\n+      // Register our interfaces.\n+      // FIXME: for JDK 1.2 we need Serializable.\n+      static jclass interfaces[] = { &CloneableClass };\n+      array_class->interfaces = interfaces;\n+      array_class->interface_count = 1;\n+\n+      // as per vmspec 5.3.3.2\n+      array_class->accflags = element->accflags;\n+\n+      // FIXME: initialize other Class instance variables,\n+      // e.g. `fields'.\n+\n+      // say this class is initialized and ready to go!\n+      array_class->state = JV_STATE_DONE;\n+\n+      // vmspec, section 5.3.3 describes this\n+      if (element->loader != loader)\n+\t_Jv_RegisterInitiatingLoader (array_class, loader);\n+    }\n+\n+  // For primitive types, point back at this array.\n+  if (element->isPrimitive())\n+    element->methods = (_Jv_Method *) array_class;\n+\n+  return array_class;\n+}\n+\n+"}, {"sha": "319e487b8abc220e0000826f5113be37df20528a", "filename": "libjava/java/lang/natFirstThread.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatFirstThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2FnatFirstThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatFirstThread.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -27,7 +27,7 @@ details.  */\n typedef void main_func (jobject);\n \n void\n-java::lang::FirstThread::run (void)\n+java::lang::FirstThread::run0 (void)\n {\n   Utf8Const* main_signature = _Jv_makeUtf8Const (\"([Ljava.lang.String;)V\", 22);\n   Utf8Const* main_name = _Jv_makeUtf8Const (\"main\", 4);\n@@ -41,6 +41,12 @@ java::lang::FirstThread::run (void)\n     DIE (\"class must be public\");\n #endif\n \n+  if (klass == NULL)\n+    {\n+      klass = java::lang::Class::forName (klass_name);\n+      if (klass != NULL) _Jv_InitClass (klass);\n+    }\n+\n   _Jv_Method *meth = _Jv_GetMethodLocal (klass, main_name, main_signature);\n \n   // Some checks from Java Spec section 12.1.4."}, {"sha": "2c951db004699b8435e5b701f8bad315b92ee2cc", "filename": "libjava/java/lang/reflect/natArray.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatArray.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -45,10 +45,11 @@ java::lang::reflect::Array::newInstance (jclass componentType, jintArray dimensi\n   if (ndims == 1)\n     return newInstance (componentType, dims[0]);\n   jclass arrayType = componentType;\n-  for (int i = 0;  i < ndims;  i++)\n-    arrayType = _Jv_FindArrayClass (arrayType);\n-  return _Jv_NewMultiArray (arrayType, ndims, dims);\n+  for (int i = 0;  i < ndims;  i++)  // FIXME 2nd arg should \n+                                     // be \"current\" loader\n+    arrayType = _Jv_FindArrayClass (arrayType, 0);\n \n+  return _Jv_NewMultiArray (arrayType, ndims, dims);\n }\n \n jint"}, {"sha": "a62d1ffeac28a706b0be9fea08d09fc1729f456d", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -378,8 +378,10 @@ java::lang::reflect::Method::getType ()\n \t  while (*ptr != ';' && ptr[1] != '\\0');\n \t  break;\n \t}\n+\n+      // FIXME: 2'nd argument should be \"current loader\"\n       while (--num_arrays >= 0)\n-\ttype = _Jv_FindArrayClass (type);\n+\ttype = _Jv_FindArrayClass (type, 0);\n       *argPtr++ = type;\n     }\n   parameter_types = args;"}, {"sha": "e652ba7d8e0ae36fc1d969c6d3dc610b851058d4", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -354,7 +354,7 @@ java::net::PlainSocketImpl::getOption (jint optID)\n         if (l_val.l_onoff)\n           return new java::lang::Integer (l_val.l_linger);\n         else\n-\t  return new java::lang::Boolean (false);\n+\t  return new java::lang::Boolean ((__java_boolean)false);\n #else\n         JvThrow (new java::lang::InternalError (\n           JvNewStringUTF (\"SO_LINGER not supported\")));      "}, {"sha": "e9ee02deb5fdb539cbaef179c8ed58921af47e33", "filename": "libjava/libgcj.spec.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Flibgcj.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Flibgcj.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flibgcj.spec.in?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -4,7 +4,7 @@\n # to link with libgcj.\n #\n %rename lib liborig\n-*lib: -lgcj -lm @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(liborig)\n+*lib: -lgcj -lm @INTERPSPEC@ @GCSPEC@ @THREADSPEC@ @ZLIBSPEC@ @SYSTEMSPEC@ %(liborig)\n \n %rename cc1 cc1orig\n *cc1:  @DIVIDESPEC@ %(cc1orig)"}, {"sha": "90fd96de9f3f01e02506f843d9a6f84fd93b6c26", "filename": "libjava/prims.cc", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -180,6 +180,24 @@ _Jv_makeUtf8Const (char* s, int len)\n   return (m);\n }\n \n+_Jv_Utf8Const *\n+_Jv_makeUtf8Const (jstring string)\n+{\n+  jint hash = string->hashCode ();\n+  jint len = _Jv_GetStringUTFLength (string);\n+\n+  Utf8Const* m = (Utf8Const*)\n+    _Jv_AllocBytesChecked (sizeof(Utf8Const) + len + 1);\n+\n+  m->hash = hash;\n+  m->length = len;\n+\n+  _Jv_GetStringUTFRegion (string, 0, string->length (), m->data);\n+  m->data[len] = 0;\n+  \n+  return m;\n+}\n+\n \f\n \n #ifdef DEBUG\n@@ -298,7 +316,10 @@ _Jv_NewObjectArray (jsize count, jclass elementClass, jobject init)\n     JvThrow (no_memory);\n \n   size_t size = count * sizeof (jobject) + sizeof (__JArray);\n-  jclass clas = _Jv_FindArrayClass (elementClass);\n+\n+  // FIXME: second argument should be \"current loader\" //\n+  jclass clas = _Jv_FindArrayClass (elementClass, 0);\n+\n   jobjectArray obj = (jobjectArray) _Jv_AllocArray (size);\n   if (! obj)\n     JvThrow (no_memory);\n@@ -338,7 +359,7 @@ _Jv_NewPrimArray (jclass eltype, jint count)\n   arr->length = count;\n   // Note that we assume we are given zeroed memory by the allocator.\n \n-  jclass klass = _Jv_FindArrayClass (eltype);\n+  jclass klass = _Jv_FindArrayClass (eltype, 0);\n   // Set the vtbl last to avoid problems if the GC happens during the\n   // window in this function between the allocation and this\n   // assignment.\n@@ -531,9 +552,11 @@ _Jv_FindClassFromSignature (char *sig, java::lang::ClassLoader *loader)\n \t  ;\n \t_Jv_Utf8Const *name = _Jv_makeUtf8Const (&sig[1], i - 1);\n \treturn _Jv_FindClass (name, loader);\n+\n       }\n     case '[':\n-      return _Jv_FindArrayClass (_Jv_FindClassFromSignature (&sig[1], loader));\n+      return _Jv_FindArrayClass (_Jv_FindClassFromSignature (&sig[1], loader),\n+\t\t\t\t loader);\n     }\n   JvFail (\"couldn't understand class signature\");\n   return NULL;\t\t\t// Placate compiler.\n@@ -588,16 +611,28 @@ JvRunMain (jclass klass, int argc, const char **argv)\n   LTDL_SET_PRELOADED_SYMBOLS ();\n #endif\n \n-  arg_vec = JvConvertArgv (argc - 1, argv + 1);\n-  main_group = new java::lang::ThreadGroup (23);\n-  main_thread = new java::lang::FirstThread (main_group, klass, arg_vec);\n+  if (klass == NULL)\n+    {\n+      arg_vec = JvConvertArgv (argc - 2, argv + 2);\n+      main_group = new java::lang::ThreadGroup (23);\n+      main_thread = new java::lang::FirstThread (main_group,\n+\t\t\t\t\t\t JvNewStringLatin1 (argv[1]),\n+\t\t\t\t\t\t arg_vec);\n+    }\n+  else\n+    {\n+      arg_vec = JvConvertArgv (argc - 1, argv + 1);\n+      main_group = new java::lang::ThreadGroup (23);\n+      main_thread = new java::lang::FirstThread (main_group, klass, arg_vec);\n+    }\n \n   main_thread->start();\n   _Jv_ThreadWait ();\n \n   java::lang::Runtime::getRuntime ()->exit (0);\n }\n \n+\n \f\n \n void *\n@@ -630,7 +665,7 @@ _Jv_divI (jint dividend, jint divisor)\n   if (divisor == 0)\n     _Jv_Throw (arithexception);\n   \n-  if (dividend == 0x80000000L && divisor == -1)\n+  if (dividend == (jint) 0x80000000L && divisor == -1)\n     return dividend;\n \n   return dividend / divisor;\n@@ -642,7 +677,7 @@ _Jv_remI (jint dividend, jint divisor)\n   if (divisor == 0)\n     _Jv_Throw (arithexception);\n   \n-  if (dividend == 0x80000000L && divisor == -1)\n+  if (dividend == (jint) 0x80000000L && divisor == -1)\n     return 0;\n \n   return dividend % divisor;\n@@ -654,7 +689,7 @@ _Jv_divJ (jlong dividend, jlong divisor)\n   if (divisor == 0)\n     _Jv_Throw (arithexception);\n   \n-  if (dividend == 0x8000000000000000LL && divisor == -1)\n+  if (dividend == (jlong) 0x8000000000000000LL && divisor == -1)\n     return dividend;\n \n   return dividend / divisor;\n@@ -666,9 +701,15 @@ _Jv_remJ (jlong dividend, jlong divisor)\n   if (divisor == 0)\n     _Jv_Throw (arithexception);\n   \n-  if (dividend == 0x8000000000000000LL && divisor == -1)\n+  if (dividend == (jlong) 0x8000000000000000LL && divisor == -1)\n     return 0;\n \n   return dividend % divisor;\n }\n \n+\n+\n+\n+\n+\n+"}, {"sha": "a2d61c96210bae0ac03cde2e495687368ac32317", "filename": "libjava/resolve.cc", "status": "added", "additions": 1101, "deletions": 0, "changes": 1101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -0,0 +1,1101 @@\n+// resolve.cc - Code for linking and resolving classes and pool entries.\n+\n+/* Copyright (C) 1999  Cygnus Solutions\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+#include <java-interp.h>\n+\n+#ifdef INTERPRETER\n+\n+#include <cni.h>\n+#include <jvm.h>\n+#include <string.h>\n+#include <java-cpool.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Thread.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/VirtualMachineError.h>\n+#include <java/lang/NoSuchFieldError.h>\n+#include <java/lang/ClassFormatError.h>\n+#include <java/lang/IllegalAccessError.h>\n+#include <java/lang/AbstractMethodError.h>\n+#include <java/lang/ClassNotFoundException.h>\n+#include <java/lang/IncompatibleClassChangeError.h>\n+\n+static void throw_internal_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_format_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_format_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+\n+#define StringClass _CL_Q34java4lang6String\n+extern java::lang::Class StringClass;\n+#define ClassObject _CL_Q34java4lang6Object\n+extern java::lang::Class ClassObject;\n+#define ObjectClass _CL_Q34java4lang6Object\n+extern java::lang::Class ObjectClass;\n+\n+\n+static int get_alignment_from_class (jclass);\n+\n+static _Jv_ResolvedMethod* \n+_Jv_BuildResolvedMethod (_Jv_Method*,\n+\t\t\t jclass,\n+\t\t\t jboolean,\n+\t\t\t jint);\n+\n+\n+static const int PUBLIC       = 0x001;\n+static const int PRIVATE      = 0x002;\n+static const int PROTECTED    = 0x004;\n+static const int STATIC       = 0x008;\n+static const int FINAL        = 0x010;\n+static const int SYNCHRONIZED = 0x020;\n+static const int VOLATILE     = 0x040;\n+static const int TRANSIENT    = 0x080;\n+static const int NATIVE       = 0x100;\n+static const int INTERFACE    = 0x200;\n+static const int ABSTRACT     = 0x400;\n+static const int ALL_FLAGS    = 0x7FF; \n+\n+// We need to know the name of a constructor.\n+static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n+\n+static void throw_incompatible_class_change_error (jstring msg)\n+{\n+  JvThrow (new java::lang::IncompatibleClassChangeError (msg));\n+}\n+\n+void*\n+_Jv_ResolvePoolEntry (jclass klass, int index)\n+{\n+  _Jv_Constants *pool = &klass->constants;\n+\n+  if ((pool->tags[index] & JV_CONSTANT_ResolvedFlag) != 0)\n+    return pool->data[index];\n+\n+  switch (pool->tags[index]) {\n+  case JV_CONSTANT_Class:\n+    {\n+      _Jv_Utf8Const *name = (_Jv_Utf8Const *) pool->data[index];\n+\n+      jclass found;\n+      if (name->data[0] == '[')\n+\tfound = _Jv_FindClassFromSignature (&name->data[0],\n+\t\t\t\t\t    klass->loader);\n+      else\n+\tfound = _Jv_FindClass (name, klass->loader);\n+\n+      if (! found)\n+\t{\n+\t  jstring str = _Jv_NewStringUTF (name->data);\n+\t  JvThrow (new java::lang::ClassNotFoundException (str));\n+\t}\n+\n+      if ((found->accflags & PUBLIC) == PUBLIC\n+\t  || (_Jv_ClassNameSamePackage (found->name,\n+\t\t\t\t\tklass->name)))\n+\t{\n+\t  pool->data[index] = (void *) found;\n+\t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\t}\n+      else\n+\t{\n+\t  JvThrow (new java::lang::IllegalAccessError (found->getName()));\n+\t}\n+    }\n+    break;\n+\n+  case JV_CONSTANT_String:\n+    {\n+      jstring str;\n+      str = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) pool->data[index]);\n+      pool->data[index] = (void *) str;\n+      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+    }\n+    break;\n+\n+  case JV_CONSTANT_Fieldref:\n+    {\n+      _Jv_ushort class_index, name_and_type_index;\n+      _Jv_loadIndexes ((const void**) &pool->data[index],\n+\t\t       class_index,\n+\t\t       name_and_type_index);\n+      jclass owner = (jclass) _Jv_ResolvePoolEntry (klass, class_index);\n+\n+      if (owner != klass)\n+\t_Jv_InitClass (owner);\n+\n+      _Jv_ushort name_index, type_index;\n+      _Jv_loadIndexes ((const void**) &pool->data[name_and_type_index],\n+\t\t       name_index,\n+\t\t       type_index);\n+\n+      _Jv_Utf8Const *field_name = (_Jv_Utf8Const*) pool->data[name_index];\n+      _Jv_Utf8Const *field_type_name =\n+\t(_Jv_Utf8Const*) pool->data[type_index];\n+\n+      // FIXME: The implementation of this function\n+      // (_Jv_FindClassFromSignature) will generate an instance of\n+      // _Jv_Utf8Const for each call if the field type is a class name\n+      // (Lxx.yy.Z;).  This may be too expensive to do for each and\n+      // every fieldref being resolved.  For now, we fix the problem by\n+      // only doing it when we have a loader different from the class\n+      // declaring the field.\n+\n+      jclass field_type = 0;\n+\n+      if (owner->loader != klass->loader)\n+\tfield_type = _Jv_FindClassFromSignature (field_type_name->data,\n+\t\t\t\t\t\t klass->loader);\n+      \n+      _Jv_Field* the_field = 0;\n+\n+      for (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n+\t{\n+\t  for (int i = 0;  i < cls->field_count;  i++)\n+\t    {\n+\t      _Jv_Field *field = &cls->fields[i];\n+\t      if (! _Jv_equalUtf8Consts (field->name, field_name))\n+\t\tcontinue;\n+\n+\t      // now, check field access. \n+\n+\t      if (   (cls == klass)\n+\t\t  || ((field->flags & PUBLIC) != 0)\n+\t\t  || (((field->flags & PROTECTED) != 0)\n+\t\t      && cls->isAssignableFrom (klass))\n+\t\t  || (((field->flags & PRIVATE) == 0)\n+\t\t      && _Jv_ClassNameSamePackage (cls->name,\n+\t\t\t\t\t\t   klass->name)))\n+\t\t{\n+\t\t  /* resove the field using the class' own loader\n+\t\t     if necessary */\n+\n+\t\t  if (!field->isResolved ())\n+\t\t    _Jv_ResolveField (field, cls->loader);\n+\n+\t\t  if (field_type != 0 && field->type != field_type)\n+\t\t    JvThrow\n+\t\t      (new java::lang::LinkageError\n+\t\t       (JvNewStringLatin1 \n+\t\t\t(\"field type mismatch with different loaders\")));\n+\n+\t\t  the_field = field;\n+\t\t  goto end_of_field_search;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  JvThrow (new java::lang::IllegalAccessError);\n+\t\t}\n+\t    }\n+\t}\n+\n+    end_of_field_search:\n+      if (the_field == 0)\n+\t{\n+\t  jstring msg = JvNewStringLatin1 (\"field \");\n+\t  msg = msg->concat (owner->getName ());\n+\t  msg = msg->concat (JvNewStringLatin1(\".\"));\n+\t  msg = msg->concat (_Jv_NewStringUTF (field_name->data));\n+\t  msg = msg->concat (JvNewStringLatin1(\" was not found.\"));\n+\t  throw_incompatible_class_change_error (msg);\n+\t}\n+\n+      pool->data[index] = (void*)the_field;\n+      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+    }\n+    break;\n+\n+  case JV_CONSTANT_Methodref:\n+  case JV_CONSTANT_InterfaceMethodref:\n+    {\n+      _Jv_ushort class_index, name_and_type_index;\n+      _Jv_loadIndexes ((const void**) &pool->data[index],\n+\t\t       class_index,\n+\t\t       name_and_type_index);\n+      jclass owner = (jclass) _Jv_ResolvePoolEntry (klass, class_index);\n+\n+      if (owner != klass)\n+\t_Jv_InitClass (owner);\n+\n+      _Jv_ushort name_index, type_index;\n+      _Jv_loadIndexes ((const void**) &pool->data[name_and_type_index],\n+\t\t       name_index,\n+\t\t       type_index);\n+\n+      _Jv_Utf8Const *method_name = (_Jv_Utf8Const*) pool->data[name_index];\n+      _Jv_Utf8Const *method_signature =\n+\t(_Jv_Utf8Const*) pool->data[type_index];\n+\n+      int vtable_index = -1;\n+      _Jv_Method *the_method = 0;\n+      jclass found_class = 0;\n+\n+      // we make a loop here, because methods are allowed to be moved to\n+      // a super class, and still be visible.. (binary compatibility).\n+\n+      for (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n+\t{\n+\t  for (int i = 0;  i < cls->method_count;  i++)\n+\t    {\n+\t      _Jv_Method *method = &cls->methods[i];\n+\t      if (   (!_Jv_equalUtf8Consts (method->name,\n+\t\t\t\t\t    method_name))\n+\t\t  || (!_Jv_equalUtf8Consts (method->signature,\n+\t\t\t\t\t    method_signature)))\n+\t\tcontinue;\n+\n+\t      if (cls == klass \n+\t\t  || ((method->accflags & PUBLIC) != 0)\n+\t\t  || (((method->accflags & PROTECTED) != 0)\n+\t\t      && cls->isAssignableFrom (klass))\n+\t\t  || (((method->accflags & PRIVATE) == 0)\n+\t\t      && _Jv_ClassNameSamePackage (cls->name,\n+\t\t\t\t\t\t   klass->name)))\n+\t\t{\n+\t\t  // FIXME: if (cls->loader != klass->loader), then we\n+\t\t  // must actually check that the types of arguments\n+\t\t  // correspond.  That is, for each argument type, and\n+\t\t  // the return type, doing _Jv_FindClassFromSignature\n+\t\t  // with either loader should produce the same result,\n+\t\t  // i.e., exactly the same jclass object. JVMS 5.4.3.3\n+\n+\t\t  the_method = method;\n+\t\t  found_class = cls;\n+\n+\t\t  \n+\t\t  if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n+\t\t    vtable_index = -1;\n+\t\t  else\n+\t\t    vtable_index = _Jv_DetermineVTableIndex\n+\t\t      (cls, method_name, method_signature);\n+\n+\t\t  if (vtable_index == 0)\n+\t\t    throw_incompatible_class_change_error\n+\t\t      (JvNewStringLatin1 (\"method not found\"));\n+\n+\t\t  goto end_of_method_search;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  JvThrow (new java::lang::IllegalAccessError);\n+\t\t}\n+\t    }\n+\t}\n+\n+    end_of_method_search:\n+      if (the_method == 0)\n+\t{\n+\t  jstring msg = JvNewStringLatin1 (\"method \");\n+\t  msg = msg->concat (owner->getName ());\n+\t  msg = msg->concat (JvNewStringLatin1(\".\"));\n+\t  msg = msg->concat (_Jv_NewStringUTF (method_name->data));\n+\t  msg = msg->concat (JvNewStringLatin1(\" was not found.\"));\n+\t  JvThrow(new java::lang::NoSuchFieldError (msg));\n+\t}\n+      \n+      pool->data[index] = (void*)\n+\t_Jv_BuildResolvedMethod(the_method,\n+\t\t\t\tfound_class,\n+\t\t\t\t((the_method->accflags & STATIC) != 0),\n+\t\t\t\tvtable_index);\n+      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+    }\n+    break;\n+\n+  }\n+\n+  return pool->data[index];\n+}\n+\n+void\n+_Jv_ResolveField (_Jv_Field *field, java::lang::ClassLoader *loader)\n+{\n+  if (! field->isResolved ())\n+    {\n+      _Jv_Utf8Const *sig = (_Jv_Utf8Const*)field->type;\n+      field->type = _Jv_FindClassFromSignature (sig->data, loader);\n+      field->flags &= ~_Jv_FIELD_UNRESOLVED_FLAG;\n+    }\n+}\n+\n+_Jv_Method*\n+_Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n+\t\t\t_Jv_Utf8Const *signature)\n+{\n+  for (; klass; klass = klass->getSuperclass())\n+    {\n+      _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n+\n+      if (meth)\n+\treturn meth;\n+    }\n+\n+  return NULL;\n+}\n+\n+/** FIXME: this is a terribly inefficient algorithm!  It would improve\n+    things if compiled classes to know vtable offset, and _Jv_Method had\n+    a field for this.\n+\n+    Returns 0  if this class does not declare the given method.\n+    Returns -1 if the given method does not appear in the vtable.\n+               i.e., it is static, private, final or a constructor.\n+    Otherwise, returns the vtable index.  */\n+int \n+_Jv_DetermineVTableIndex (jclass klass,\n+\t\t\t  _Jv_Utf8Const *name,\n+\t\t\t  _Jv_Utf8Const *signature)\n+{\n+  jclass super_class = klass->getSuperclass ();\n+\n+  if (super_class != NULL)\n+    {\n+      int prev = _Jv_DetermineVTableIndex (super_class,\n+\t\t\t\t\t   name,\n+\t\t\t\t\t   signature);\n+      if (prev != 0)\n+\treturn prev;\n+    }\n+\n+  /* at this point, we know that the super-class does not declare\n+   * the method.  Otherwise, the above call would have found it, and\n+   * determined the result of this function (-1 or some positive\n+   * number).\n+   */\n+\n+  _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n+\n+  /* now, if we do not declare this method, return zero */\n+  if (meth == NULL)\n+    return 0;\n+\n+  /* so now, we know not only that the super class does not declare the\n+   * method, but we do!  So, this is a first declaration of the method. */\n+\n+  /* now, the checks for things that are declared in this class, but do\n+   * not go into the vtable.  There are three cases.  \n+   * 1) the method is static, private or final\n+   * 2) the class itself is final, or\n+   * 3) it is the method <init>\n+   */\n+\n+  if (   (meth->accflags & (STATIC|PRIVATE|FINAL)) != 0\n+      || (klass->accflags & FINAL) != 0\n+      || _Jv_equalUtf8Consts (name, init_name))\n+    return -1;\n+\n+  /* reaching this point, we know for sure, that the method in question\n+   * will be in the vtable.  The question is where. */\n+\n+  /* the base offset, is where we will start assigning vtable\n+   * indexes for this class.  It is 1 for base classes\n+   * (vtable->method[0] is unused), and for non-base classes it is the\n+   * number of entries in the super class' vtable plus 1. */\n+\n+  int base_offset;\n+  if (super_class == 0)\n+    base_offset = 1;\n+  else\n+    base_offset = super_class->vtable_method_count+1;\n+\n+  /* we will consider methods 0..this_method_index-1.  And for each one,\n+   * determine if it is new (i.e., if it appears in the super class),\n+   * and if it should go in the vtable.  If so, increment base_offset */\n+\n+  int this_method_index = meth - (&klass->methods[0]);\n+\n+  for (int i = 0; i < this_method_index; i++)\n+    {\n+      _Jv_Method *m = &klass->methods[i];\n+\n+      /* fist some checks for things that surely do not go in the\n+       * vtable */\n+\n+      if ((m->accflags & (STATIC|PRIVATE)) != 0)\n+\tcontinue;\n+      if (_Jv_equalUtf8Consts (m->name, init_name))\n+\tcontinue;\n+      \n+      /* Then, we need to know if this method appears in the\n+         superclass. (This is where this function gets expensive) */\n+      _Jv_Method *sm = _Jv_LookupDeclaredMethod (super_class,\n+\t\t\t\t\t\t m->name,\n+\t\t\t\t\t\t m->signature);\n+      \n+      /* if it was somehow declared in the superclass, skip this */\n+      if (sm != NULL)\n+\tcontinue;\n+\n+      /* but if it is final, and not declared in the super class,\n+       * then we also skip it */\n+      if ((m->accflags & FINAL) != 0)\n+\tcontinue;\n+\n+      /* finally, we can assign the index of this method */\n+      /* m->vtable_index = base_offset */\n+      base_offset += 1;\n+    }\n+\n+  return base_offset;\n+}\n+\n+/* this is installed in place of abstract methods */\n+static void\n+_Jv_abstractMethodError ()\n+{\n+  JvThrow (new java::lang::AbstractMethodError);\n+}\n+\n+void \n+_Jv_PrepareClass(jclass klass)\n+{\n+ /*\n+  * The job of this function is to: 1) assign storage to fields, and 2)\n+  * build the vtable.  static fields are assigned real memory, instance\n+  * fields are assigned offsets.\n+  *\n+  * NOTE: we have a contract with the garbage collector here.  Static\n+  * reference fields must not be resolved, until after they have storage\n+  * assigned which is the check used by the collector to see if it\n+  * should indirect the static field reference and mark the object\n+  * pointed to. \n+  *\n+  * Most fields are resolved lazily (i.e. have their class-type\n+  * assigned) when they are accessed the first time by calling as part\n+  * of _Jv_ResolveField, which is allways called after _Jv_PrepareClass.\n+  * Static fields with initializers are resolved as part of this\n+  * function, as are fields with primitive types.\n+  */\n+\n+  if (! _Jv_IsInterpretedClass (klass))\n+    return;\n+\n+  if (klass->state >= JV_STATE_PREPARED)\n+    return;\n+\n+  // make sure super-class is linked.  This involves taking a lock on\n+  // the super class, so we use the Java method resolveClass, which will\n+  // unlock it properly, should an exception happen.\n+\n+  java::lang::ClassLoader::resolveClass (klass->superclass);\n+\n+  _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n+\n+  /************ PART ONE: OBJECT LAYOUT ***************/\n+\n+  int instance_size;\n+  int static_size;\n+\n+  // java.lang.Object is never interpreted!\n+  instance_size = clz->superclass->size ();\n+  static_size   = 0;\n+\n+  for (int i = 0; i < clz->field_count; i++)\n+    {\n+      int field_size;\n+      int field_align;\n+\n+      _Jv_Field *field = &clz->fields[i];\n+\n+      if (! field->isRef ())\n+\t{\n+\t  // it's safe to resolve the field here, since it's \n+\t  // a primitive class, which does not cause loading to happen.\n+\t  _Jv_ResolveField (field, clz->loader);\n+\n+\t  field_size = field->type->size ();\n+\t  field_align = get_alignment_from_class (field->type);\n+\t}\n+      else \n+\t{\n+\t  field_size = sizeof (jobject);\n+\t  field_align = __alignof__ (jobject);\n+\t}\n+\n+#ifndef COMPACT_FIELDS\n+      field->bsize = field_size;\n+#endif\n+\n+      if (field->flags & STATIC)\n+\t{\n+\t  /* this computes an offset into a region we'll allocate \n+\t     shortly, and then add this offset to the start address */\n+\n+\t  static_size        = ROUND (static_size, field_align);\n+\t  field->u.boffset   = static_size;\n+\t  static_size       += field_size;\n+\t}\n+      else\n+\t{\n+\t  instance_size      = ROUND (instance_size, field_align);\n+\t  field->u.boffset   = instance_size;\n+\t  instance_size     += field_size;\n+\t}\n+    }\n+\n+  // set the instance size for the class\n+  clz->size_in_bytes = instance_size;\n+    \n+  // allocate static memory\n+  if (static_size != 0)\n+    {\n+      char *static_data = (char*)_Jv_AllocBytesChecked (static_size);\n+\n+      memset (static_data, 0, static_size);\n+\n+      for (int i = 0; i < clz->field_count; i++)\n+\t{\n+\t  _Jv_Field *field = &clz->fields[i];\n+\n+\t  if ((field->flags & STATIC) != 0)\n+\t    {\n+\t      field->u.addr  = static_data + field->u.boffset;\n+\t\t\t    \n+\t      if (clz->field_initializers[i] != 0)\n+\t\t{\n+\t\t  _Jv_ResolveField (field, clz->loader);\n+\t\t  _Jv_InitField (0, clz, i);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // now we don't need the field_initializers anymore, so let the\n+      // collector get rid of it!\n+\n+      clz->field_initializers = 0;\n+    }\n+\n+  /************ PART TWO: VTABLE LAYOUT ***************/\n+\n+  /* preparation: build the vtable stubs (even interfaces can)\n+     have code -- for static constructors. */\n+  for (int i = 0; i < clz->method_count; i++)\n+    {\n+      _Jv_InterpMethod *imeth = clz->interpreted_methods[i];\n+\n+      if (imeth != 0)\t\t// it could be abstract or native\n+\t{\n+\t  clz->methods[i].ncode = imeth->ncode ();\n+\t}\n+      else\n+\t{\n+\t  if ((clz->methods[i].accflags & NATIVE) != 0)\n+\t    {\n+\t      JvThrow\n+\t\t(new java::lang::VirtualMachineError\n+\t\t (JvNewStringLatin1 \n+\t\t  (\"the interpreter does not support native methods\")));\n+\t    }\n+\t}\n+    }\n+\n+  if (clz->accflags & INTERFACE)\n+    {\n+      clz->state = JV_STATE_PREPARED;\n+      clz->notifyAll ();\n+      return;\n+    }\n+\n+  /* FIXME: native methods for interpreted classes should be handled, I\n+   * dunno exactly how, but it seems that we should try to find them at\n+   * this point, and if we fail, try again after <clinit>, since it\n+   * could have caused additional code to be loaded.  Interfaces cannot\n+   * have native methods (not even for static initialization). */\n+\n+\n+  /* Now onto the actual job: vtable layout.  First, count how many new\n+     methods we have */\n+  int new_method_count = 0;\n+\n+  jclass super_class = clz->getSuperclass ();\n+\n+  if (super_class == 0)\n+    throw_internal_error (\"cannot handle interpreted base classes\");\n+\n+  for (int i = 0; i < clz->method_count; i++)\n+    {\n+      _Jv_Method *this_meth = &clz->methods[i];\n+\n+      if ((this_meth->accflags & (STATIC|PRIVATE)) != 0\n+\t  || _Jv_equalUtf8Consts (this_meth->name, init_name))\n+\t{\n+\t  /* skip this, it doesn't go in the vtable */\n+\t  continue;\n+\t}\n+\t  \n+      _Jv_Method *orig_meth = _Jv_LookupDeclaredMethod (super_class,\n+\t\t\t\t\t\t\tthis_meth->name,\n+\t\t\t\t\t\t\tthis_meth->signature);\n+\n+      if (orig_meth == 0)\n+\t{\n+\t  // new methods that are final, also don't go in the vtable\n+\t  if ((this_meth->accflags & FINAL) != 0)\n+\t    continue;\n+\n+\t  new_method_count += 1;\n+\t  continue;\n+\t}\n+\n+      if ((orig_meth->accflags & (STATIC|PRIVATE|FINAL)) != 0\n+\t  || ((orig_meth->accflags & ABSTRACT) == 0\n+\t      && (this_meth->accflags & ABSTRACT) != 0\n+\t      && (klass->accflags & ABSTRACT) == 0))\n+\t{\n+\t  clz->state = JV_STATE_ERROR;\n+\t  clz->notifyAll ();\n+\t  JvThrow (new java::lang::IncompatibleClassChangeError \n+\t\t           (clz->getName ()));\n+\t}\n+\n+      /* FIXME: At this point, if (loader != super_class->loader), we\n+       * need to \"impose class loader constraints\" for the types\n+       * involved in the signature of this method */\n+    }\n+  \n+  /* determine size */\n+  int vtable_count = (super_class->vtable_method_count) + new_method_count;\n+  clz->vtable_method_count = vtable_count;\n+\n+  /* allocate vtable structure */\n+  _Jv_VTable *vtable = (_Jv_VTable*) \n+    _Jv_AllocBytesChecked (sizeof (_Jv_VTable) \n+\t\t\t   + (sizeof (void*) * (vtable_count)));\n+  vtable->clas = clz;\n+\n+  /* copy super class' vtable entries (index 0 goes unused). */\n+  memcpy ((void*)&vtable->method[1],\n+\t  (void*)&super_class->vtable->method[1],\n+\t  sizeof (void*) * super_class->vtable_method_count);\n+\n+  /* now, install our own vtable entries, reprise... */\n+  for (int i = 0; i < clz->method_count; i++)\n+    {\n+      _Jv_Method *this_meth = &clz->methods[i];\n+\n+      int index = _Jv_DetermineVTableIndex (clz, \n+\t\t\t\t\t    this_meth->name,\n+\t\t\t\t\t    this_meth->signature);\n+\n+      if (index == 0)\n+\tthrow_internal_error (\"method now found in own class\");\n+\n+      if (index != -1)\n+\t{\n+\t  if (index > clz->vtable_method_count+1)\n+\t    throw_internal_error (\"vtable problem...\");\n+\n+\t  if (clz->interpreted_methods[i] == 0)\n+\t    vtable->method[index] = (void*)&_Jv_abstractMethodError;\n+\t  else\n+\t    vtable->method[index] = this_meth->ncode;\n+\t}\n+    }\n+\n+  /* finally, assign the vtable! */\n+  clz->vtable = vtable;\n+\n+  /* wooha! we're done. */\n+  clz->state = JV_STATE_PREPARED;\n+  clz->notifyAll ();\n+}\n+\n+/** Do static initialization for fields with a constant initializer */\n+void\n+_Jv_InitField (jobject obj, jclass klass, int index)\n+{\n+  if (obj != 0 && klass == 0)\n+    klass = obj->getClass ();\n+\n+  if (!_Jv_IsInterpretedClass (klass))\n+    return;\n+\n+  _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n+\n+  _Jv_Field * field = (&clz->fields[0]) + index;\n+\n+  if (index > clz->field_count)\n+    throw_internal_error (\"field out of range\");\n+\n+  int init = clz->field_initializers[index];\n+  if (init == 0)\n+    return;\n+\n+  _Jv_Constants *pool = &clz->constants;\n+  int tag = pool->tags[init];\n+\n+  if (! field->isResolved ())\n+    throw_internal_error (\"initializing unresolved field\");\n+\n+  if (obj==0 && ((field->flags & STATIC) == 0))\n+    throw_internal_error (\"initializing non-static field with no object\");\n+\n+  void *addr = 0;\n+\n+  if ((field->flags & STATIC) != 0)\n+    addr = (void*) field->u.addr;\n+  else\n+    addr = (void*) (((char*)obj) + field->u.boffset);\n+\n+  switch (tag)\n+    {\n+    case JV_CONSTANT_String:\n+      {\n+\t_Jv_MonitorEnter (clz);\n+\tjstring str;\n+\tstr = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) pool->data[init]);\n+\tpool->data[init] = (void *) str;\n+\tpool->tags[init] = JV_CONSTANT_ResolvedString;\n+\t_Jv_MonitorExit (clz);\n+      }\n+      /* fall through */\n+\n+    case JV_CONSTANT_ResolvedString:\n+      if (! (field->type == &StringClass || field->type == &ObjectClass))\n+\tthrow_class_format_error (\"string initialiser to non-string field\");\n+\n+      *(jstring*)addr = *(jstring*) (pool->data + init);\n+      break;\n+\n+    case JV_CONSTANT_Integer:\n+      {\n+\tint value = *(jint*)(pool->data + init);\n+\n+\tif (field->type == JvPrimClass (boolean))\n+\t  *(jboolean*)addr = (jboolean)value;\n+\t\n+\telse if (field->type == JvPrimClass (byte))\n+\t  *(jbyte*)addr = (jbyte)value;\n+\t\n+\telse if (field->type == JvPrimClass (char))\n+\t  *(jchar*)addr = (jchar)value;\n+\n+\telse if (field->type == JvPrimClass (short))\n+\t  *(jshort*)addr = (jshort)value;\n+\t\n+\telse if (field->type == JvPrimClass (int))\n+\t  *(jint*)addr = (jint)value;\n+\n+\telse\n+\t  throw_class_format_error (\"erroneous field initializer\");\n+      }  \n+      break;\n+\n+    case JV_CONSTANT_Long:\n+      if (field->type != JvPrimClass (long))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      memcpy (addr, pool->data+init, 8);\n+      break;\n+\n+    case JV_CONSTANT_Float:\n+      if (field->type != JvPrimClass (float))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      memcpy (addr, pool->data+init, 4);\n+      break;\n+\n+    case JV_CONSTANT_Double:\n+      if (field->type != JvPrimClass (double))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      memcpy (addr, pool->data+init, 8);\n+      break;\n+\n+    default:\n+      throw_class_format_error (\"erroneous field initializer\");\n+    }\n+}\n+\n+static int\n+get_alignment_from_class (jclass klass)\n+{\n+  if (klass == JvPrimClass (byte))\n+    return  __alignof__ (jbyte);\n+  else if (klass == JvPrimClass (short))\n+    return  __alignof__ (jshort);\n+  else if (klass == JvPrimClass (int)) \n+    return  __alignof__ (jint);\n+  else if (klass == JvPrimClass (long))\n+    return  __alignof__ (jlong);\n+  else if (klass == JvPrimClass (boolean))\n+    return  __alignof__ (jboolean);\n+  else if (klass == JvPrimClass (char))\n+    return  __alignof__ (jchar);\n+  else if (klass == JvPrimClass (float))\n+    return  __alignof__ (jfloat);\n+  else if (klass == JvPrimClass (double))\n+    return  __alignof__ (jdouble);\n+  else\n+    return __alignof__ (jobject);\n+}\n+\n+\n+inline static unsigned char*\n+skip_one_type (unsigned char* ptr)\n+{\n+  int ch = *ptr++;\n+\n+  while (ch == '[')\n+    { \n+      ch = *ptr++;\n+    }\n+  \n+  if (ch == 'L')\n+    {\n+      do { ch = *ptr++; } while (ch != ';');\n+    }\n+\n+  return ptr;\n+}\n+\n+static ffi_type*\n+get_ffi_type_from_signature (unsigned char* ptr)\n+{\n+  switch (*ptr) \n+    {\n+    case 'L':\n+    case '[':\n+      return &ffi_type_pointer;\n+      break;\n+\n+    case 'Z':\n+    case 'B':\n+      return &ffi_type_sint8;\n+      break;\n+      \n+    case 'C':\n+      return &ffi_type_uint16;\n+      break;\n+\t  \n+    case 'S': \n+      return &ffi_type_sint16;\n+      break;\n+\t  \n+    case 'I':\n+      return &ffi_type_sint32;\n+      break;\n+\t  \n+    case 'J':\n+      return &ffi_type_sint64;\n+      break;\n+\t  \n+    case 'F':\n+      return &ffi_type_float;\n+      break;\n+\t  \n+    case 'D':\n+      return &ffi_type_double;\n+      break;\n+\n+    case 'V':\n+      return &ffi_type_void;\n+      break;\n+    }\n+\n+  throw_internal_error (\"unknown type in signature\");\n+}\n+\n+/* this function yields the number of actual arguments, that is, if the\n+ * function is non-static, then one is added to the number of elements\n+ * found in the signature */\n+\n+static int \n+count_arguments (_Jv_Utf8Const *signature,\n+\t\t jboolean staticp)\n+{\n+  unsigned char *ptr = (unsigned char*) signature->data;\n+  int arg_count = staticp ? 0 : 1;\n+\n+  /* first, count number of arguments */\n+\n+  // skip '('\n+  ptr++;\n+\n+  // count args\n+  while (*ptr != ')')\n+    {\n+      ptr = skip_one_type (ptr);\n+      arg_count += 1;\n+    }\n+\n+  return arg_count;\n+}\n+\n+/* This beast will build a cif, given the signature.  Memory for\n+ * the cif itself and for the argument types must be allocated by the\n+ * caller.\n+ */\n+\n+static int \n+init_cif (_Jv_Utf8Const* signature,\n+\t  int arg_count,\n+\t  jboolean staticp,\n+\t  ffi_cif *cif,\n+\t  ffi_type **arg_types)\n+{\n+  unsigned char *ptr = (unsigned char*) signature->data;\n+\n+  int arg_index = 0;\t\t// arg number\n+  int item_count = 0;\t\t// stack-item count\n+\n+  // setup receiver\n+  if (!staticp)\n+    {\n+      arg_types[arg_index++] = &ffi_type_pointer;\n+      item_count += 1;\n+    }\n+\n+  // skip '('\n+  ptr++;\n+\n+  // assign arg types\n+  while (*ptr != ')')\n+    {\n+      arg_types[arg_index++] = get_ffi_type_from_signature (ptr);\n+\n+      if (*ptr == 'J' || *ptr == 'D')\n+\titem_count += 2;\n+      else\n+\titem_count += 1;\n+\n+      ptr = skip_one_type (ptr);\n+    }\n+\n+  // skip ')'\n+  ptr++;\n+  ffi_type *rtype = get_ffi_type_from_signature (ptr);\n+\n+  ptr = skip_one_type (ptr);\n+  if (ptr != (unsigned char*)signature->data + signature->length)\n+    throw_internal_error (\"did not find end of signature\");\n+\n+  if (ffi_prep_cif (cif, FFI_DEFAULT_ABI,\n+\t\t    arg_count, rtype, arg_types) != FFI_OK)\n+    throw_internal_error (\"ffi_prep_cif failed\");\n+\n+  return item_count;\n+}\n+\n+\n+/* we put this one here, and not in interpret.cc because it\n+ * calls the utility routines count_arguments \n+ * which are static to this module.  The following struct defines the\n+ * layout we use for the stubs, it's only used in the ncode method. */\n+\n+typedef struct {\n+  ffi_raw_closure  closure;\n+  ffi_cif   cif;\n+  ffi_type *arg_types[0];\n+} ncode_closure;\n+\n+typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n+\n+void* _Jv_InterpMethod::ncode ()\n+{\n+  if (self->ncode != 0)\n+    return self->ncode;\n+\n+  jboolean staticp = (self->accflags & STATIC) != 0;\n+  int arg_count = count_arguments (self->signature, staticp);\n+\n+  ncode_closure *closure =\n+    (ncode_closure*)_Jv_AllocBytesChecked (sizeof (ncode_closure)\n+\t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n+\n+  init_cif (self->signature,\n+\t    arg_count,\n+\t    staticp,\n+\t    &closure->cif,\n+\t    &closure->arg_types[0]);\n+\n+  ffi_closure_fun fun;\n+\n+  args_raw_size = ffi_raw_size (&closure->cif);\n+\n+  if ((self->accflags & SYNCHRONIZED) != 0)\n+    {\n+      if (staticp)\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;\n+      else\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object; \n+    }\n+  else\n+    {\n+      fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;\n+    }\n+\n+  ffi_prep_raw_closure (&closure->closure,\n+\t\t     &closure->cif, \n+\t\t     fun,\n+\t\t     (void*)this);\n+\n+  self->ncode = (void*)closure;\n+  return self->ncode;\n+}\n+\n+\n+/* A _Jv_ResolvedMethod is what is put in the constant pool for a\n+ * MethodRef or InterfacemethodRef.  */\n+static _Jv_ResolvedMethod*\n+_Jv_BuildResolvedMethod (_Jv_Method* method,\n+\t\t\t jclass      klass,\n+\t\t\t jboolean staticp,\n+\t\t\t jint vtable_index)\n+{\n+  int arg_count = count_arguments (method->signature, staticp);\n+\n+  _Jv_ResolvedMethod* result = (_Jv_ResolvedMethod*)\n+    _Jv_AllocBytesChecked (sizeof (_Jv_ResolvedMethod)\n+\t\t\t   + arg_count*sizeof (ffi_type*));\n+\n+  result->stack_item_count\n+    = init_cif (method->signature,\n+\t\targ_count,\n+\t\tstaticp,\n+\t\t&result->cif,\n+\t\t&result->arg_types[0]);\n+\n+  result->vtable_index        = vtable_index;\n+  result->method              = method;\n+  result->klass               = klass;\n+\n+  return result;\n+}\n+\n+\n+static void\n+throw_class_format_error (jstring msg)\n+{\n+  if (msg == 0)\n+    JvThrow (new java::lang::ClassFormatError);\n+  else\n+    JvThrow (new java::lang::ClassFormatError (msg));\n+}\n+\n+static void\n+throw_class_format_error (char *msg)\n+{\n+  throw_class_format_error (JvNewStringLatin1 (msg));\n+}\n+\n+static void\n+throw_internal_error (char *msg)\n+{\n+  JvThrow \n+    (new java::lang::InternalError (JvNewStringLatin1 (msg)));\n+}\n+\n+\n+#endif"}, {"sha": "ac2e92d1b0d9960232141407b1219ecf5def74f2", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58eb6e7cef1cea515f8da18d24341a4aa53ccb70/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=58eb6e7cef1cea515f8da18d24341a4aa53ccb70", "patch": "@@ -71,6 +71,7 @@ COMPPATH = @COMPPATH@\n CPP = @CPP@\n CXX = @CXX@\n CXXCPP = @CXXCPP@\n+DIVIDESPEC = @DIVIDESPEC@\n DLLTOOL = @DLLTOOL@\n EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n EXEEXT = @EXEEXT@\n@@ -79,6 +80,7 @@ GCINCS = @GCINCS@\n GCLIBS = @GCLIBS@\n GCOBJS = @GCOBJS@\n GCSPEC = @GCSPEC@\n+INTERPSPEC = @INTERPSPEC@\n LD = @LD@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@"}]}