{"sha": "ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ5MTJlZWM1OGZjNzliNGY1MDBhMWExZjk0YTZiZDZiODE2OTg4Yw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-27T19:42:40Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-27T19:42:40Z"}, "message": "* Makefile.in, libgcc2.c (L_eh): some support routines for C++.\n\nFrom-SVN: r8144", "tree": {"sha": "2d3911efd6e8c2c0f0221d6c75016db125d29836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d3911efd6e8c2c0f0221d6c75016db125d29836"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad912eec58fc79b4f500a1a1f94a6bd6b816988c/comments", "author": null, "committer": null, "parents": [{"sha": "3a19bc1cdc4995407a68fcb0439026995b838a6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a19bc1cdc4995407a68fcb0439026995b838a6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a19bc1cdc4995407a68fcb0439026995b838a6a"}], "stats": {"total": 151, "additions": 150, "deletions": 1}, "files": [{"sha": "c497f6e59e5a68367965074428855357e93369fb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad912eec58fc79b4f500a1a1f94a6bd6b816988c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad912eec58fc79b4f500a1a1f94a6bd6b816988c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "patch": "@@ -505,7 +505,7 @@ LIB2FUNCS = _muldi3 _divdi3 _moddi3 _udivdi3 _umoddi3 _negdi2 \\\n     _fixxfdi _fixunsxfdi _floatdixf _fixunsxfsi \\\n     _fixtfdi _fixunstfdi _floatditf \\\n     __gcc_bcmp _varargs _eprintf _op_new _op_vnew _new_handler _op_delete \\\n-    _op_vdel _bb _shtab _clear_cache _trampoline __main _exit _ctors\n+    _op_vdel _bb _shtab _clear_cache _trampoline __main _exit _ctors _eh\n \n # Header files that are made available under the same name\n # to programs compiled with GCC."}, {"sha": "4e4668369671f910b00db4409adda1b98dd888b4", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad912eec58fc79b4f500a1a1f94a6bd6b816988c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad912eec58fc79b4f500a1a1f94a6bd6b816988c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=ad912eec58fc79b4f500a1a1f94a6bd6b816988c", "patch": "@@ -2138,3 +2138,152 @@ func_ptr __CTOR_LIST__[2];\n #include \"gbl-ctors.h\"\n func_ptr __DTOR_LIST__[2];\n #endif\n+\f\n+#ifdef L_eh\n+typedef struct {\n+  void *start;\n+  void *end;\n+  void *exception_handler;\n+} exception_table;\n+\n+struct exception_table_node {\n+  exception_table *table;\n+  void *start;\n+  void *end;\n+  struct exception_table_node *next;\n+};\n+\n+static int except_table_pos = 0;\n+static void *except_pc = (void *)0;\n+static struct exception_table_node *exception_table_list = 0;\n+\n+static exception_table *\n+find_exception_table (pc)\n+     void* pc;\n+{\n+  register struct exception_table_node *table = exception_table_list;\n+  for ( ; table != 0; table = table->next)\n+    {\n+      if (table->start <= pc && table->end > pc)\n+\treturn table->table;\n+    }\n+  return 0;\n+}\n+\n+/* this routine takes a pc, and the address of the exception handler associated\n+   with the closest exception table handler entry associated with that PC,\n+   or 0 if there are no table entries the PC fits in.  The algorithm works\n+   something like this:\n+\n+    while(current_entry exists) {\n+        if(current_entry.start < pc )\n+            current_entry = next_entry;\n+        else {\n+            if(prev_entry.start <= pc && prev_entry.end > pc) {\n+                save pointer to prev_entry;\n+                return prev_entry.exception_handler;\n+             }\n+            else return 0;\n+         }\n+     }\n+    return 0;\n+\n+   Assuming a correctly sorted table (ascending order) this routine should\n+   return the tighest match...\n+\n+   In the advent of a tie, we have to give the last entry, as it represents\n+   an inner block.\n+ */\n+\n+\n+void *\n+__find_first_exception_table_match(pc)\n+void *pc;\n+{\n+  exception_table *table = find_exception_table (pc);\n+  int pos = 0;\n+  int best = 0;\n+  if (table == 0)\n+    return (void*)0;\n+#if 0\n+  printf(\"find_first_exception_table_match(): pc = %x!\\n\",pc);\n+#endif\n+\n+  except_pc = pc;\n+\n+#if 0\n+  /* We can't do this yet, as we don't know that the table is sorted.  */\n+  do {\n+    ++pos;\n+    if (table[pos].start > except_pc)\n+      /* found the first table[pos].start > except_pc, so the previous\n+\t entry better be the one we want! */\n+      break;\n+  } while(table[pos].exception_handler != (void*)-1);\n+\n+  --pos;\n+  if (table[pos].start <= except_pc && table[pos].end > except_pc)\n+    {\n+      except_table_pos = pos;\n+#if 0\n+      printf(\"find_first_eh_table_match(): found match: %x\\n\",table[pos].exception_handler);\n+#endif\n+      return table[pos].exception_handler;\n+    }\n+#else\n+  while (table[++pos].exception_handler != (void*)-1) {\n+    if (table[pos].start <= except_pc && table[pos].end > except_pc)\n+      {\n+\t/* This can apply.  Make sure it is better or as good as the previous\n+\t   best.  */\n+\t/* The best one ends first. */\n+\tif (best == 0 || (table[pos].end <= table[best].end\n+\t\t\t  /* The best one starts last.  */\n+\t\t\t  && table[pos].start >= table[best].start))\n+\t  best = pos;\n+      }\n+  }\n+  if (best != 0)\n+    return table[best].exception_handler;\n+#endif\n+\n+#if 0\n+  printf(\"find_first_eh_table_match(): else: returning NULL!\\n\");\n+#endif\n+  return (void*)0;\n+}\n+\n+int\n+__throw_type_match (const char *catch_type, const char *throw_type)\n+{\n+#if 0\n+ printf(\"__throw_type_match (): catch_type = %s, throw_type = %s\\n\",\n+\tcatch_type, throw_type);\n+#endif\n+ return strcmp (catch_type, throw_type);\n+}\n+\n+void\n+__register_exceptions (exception_table *table)\n+{\n+  struct exception_table_node *node = (struct exception_table_node*)\n+      malloc (sizeof (struct exception_table_node));\n+  exception_table *range = table + 1;\n+  node->table = table;\n+\n+  /* This look can be optimized away either if the table\n+     is sorted, or if we pass in extra parameters. */\n+  node->start = range->start;\n+  node->end = range->end;\n+  for (range++ ; range->start != (void*)(-1); range++)\n+    {\n+      if (range->start < node->start)\n+\tnode->start = range->start;\n+      if (range->end < node->end)\n+\tnode->end = range->end;\n+    }\n+\n+  node->next = exception_table_list;\n+  exception_table_list = node;\n+}\n+#endif /* L_eh */"}]}