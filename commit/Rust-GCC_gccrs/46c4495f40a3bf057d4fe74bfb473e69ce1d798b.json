{"sha": "46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjNDQ5NWY0MGEzYmYwNTdkNGZlNzRiZmI0NzNlNjljZTFkNzk4Yg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-06-02T12:35:25Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-02T12:35:25Z"}, "message": "* tree-vrp.c (has_assert_expr, maybe_add_assert_expr): Remove.\n\nFrom-SVN: r100492", "tree": {"sha": "6b7053bed0daae25020fcbf5aa6c5e9f30352f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b7053bed0daae25020fcbf5aa6c5e9f30352f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c4495f40a3bf057d4fe74bfb473e69ce1d798b/comments", "author": null, "committer": null, "parents": [{"sha": "e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d6beb0f868d4feeefea469278b4e07ec3fee8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d6beb0f868d4feeefea469278b4e07ec3fee8f"}], "stats": {"total": 293, "additions": 4, "deletions": 289}, "files": [{"sha": "c26763b645da1b789d2542630f9e858ed5d00a95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c4495f40a3bf057d4fe74bfb473e69ce1d798b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c4495f40a3bf057d4fe74bfb473e69ce1d798b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "patch": "@@ -1,3 +1,7 @@\n+2005-06-02  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-vrp.c (has_assert_expr, maybe_add_assert_expr): Remove.\n+\n 2005-06-02  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (dump_cgraph_node): Print new flags."}, {"sha": "f712cb3f52b6e1957ea179fe5b297d66114b3024", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c4495f40a3bf057d4fe74bfb473e69ce1d798b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c4495f40a3bf057d4fe74bfb473e69ce1d798b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=46c4495f40a3bf057d4fe74bfb473e69ce1d798b", "patch": "@@ -1907,295 +1907,6 @@ infer_value_range (tree stmt, tree op, enum tree_code *comp_code_p, tree *val_p)\n }\n \n \n-#if 0\n-/* Return true if OP is the result of an ASSERT_EXPR that tests the\n-   same condition as COND.  */\n-\n-static bool\n-has_assert_expr (tree op, tree cond)\n-{\n-  tree def_stmt = SSA_NAME_DEF_STMT (op);\n-  tree assert_expr, other_cond, other_op;\n-\n-  /* If OP was not generated by an ASSERT_EXPR, return false.  */\n-  if (TREE_CODE (def_stmt) != MODIFY_EXPR\n-      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) != ASSERT_EXPR)\n-    return false;\n-\n-  assert_expr = TREE_OPERAND (def_stmt, 1);\n-  other_cond = ASSERT_EXPR_COND (assert_expr);\n-  other_op = ASSERT_EXPR_VAR (assert_expr);\n-\n-  if (TREE_CODE (cond) == TREE_CODE (other_cond))\n-    {\n-      tree t1, t2;\n-\n-      /* If COND is not a comparison predicate, something is wrong.  */\n-      gcc_assert (COMPARISON_CLASS_P (cond));\n-\n-      /* Note that we only need to compare against one of the operands\n-\t of OTHER_COND.  \n-\t \n-\t Suppose that we are about to insert the assertion ASSERT_EXPR\n-\t <x_4, x_4 != 0> and the defining statement for x_4 is x_4 =\n-\t ASSERT_EXPR <x_3, x_3 != 0>.\n-\n-\t In this case, we don't really want to insert a new\n-\t ASSERT_EXPR for x_4 because that would be redundant.  We\n-\t already know that x_4 is not 0.  So, when comparing the\n-\t conditionals 'x_3 != 0' and 'x_4 != 0', we don't want to\n-\t compare x_3 and x_4, we just want to compare the predicate's\n-\t code (!=) and the other operand (0).  */\n-      if (TREE_OPERAND (cond, 0) == op)\n-\tt1 = TREE_OPERAND (cond, 1);\n-      else\n-\tt1 = TREE_OPERAND (cond, 0);\n-\n-      if (TREE_OPERAND (other_cond, 0) == other_op)\n-\tt2 = TREE_OPERAND (other_cond, 1);\n-      else\n-\tt2 = TREE_OPERAND (other_cond, 0);\n-\n-      return (t1 == t2 || operand_equal_p (t1, t2, 0));\n-    }\n-\n-  return false;\n-}\n-\n-\n-/* Traverse all the statements in block BB looking for used variables.\n-   Variables used in BB are added to bitmap FOUND.  The algorithm\n-   works in three main parts:\n-\n-   1- For every statement S in BB, all the variables used by S are\n-      added to bitmap FOUND.\n-\n-   2- If statement S uses an operand N in a way that exposes a known\n-      value range for N, then if N was not already generated by an\n-      ASSERT_EXPR, create a new ASSERT_EXPR for N.  For instance, if N\n-      is a pointer and the statement dereferences it, we can assume\n-      that N is not NULL.\n-\n-   3- COND_EXPRs are a special case of #2.  We can derive range\n-      information from the predicate but need to insert different\n-      ASSERT_EXPRs for each of the sub-graphs rooted at the\n-      conditional block.  If the last statement of BB is a conditional\n-      expression of the form 'X op Y', then\n-\n-      a) Remove X and Y from the set FOUND.\n-\n-      b) If the conditional dominates its THEN_CLAUSE sub-graph,\n-\t recurse into it.  On return, if X and/or Y are marked in\n-\t FOUND, then an ASSERT_EXPR is added for the corresponding\n-\t variable.\n-\n-      c) Repeat step (b) on the ELSE_CLAUSE.\n-\n-      d) Mark X and Y in FOUND.\n-\n-   4- If BB does not end in a conditional expression, then we recurse\n-      into BB's dominator children.\n-   \n-   At the end of the recursive traversal, ASSERT_EXPRs will have been\n-   added to the edges of COND_EXPR blocks that have sub-graphs using\n-   one or both predicate operands.  For instance,\n-\n-   \tif (a == 9)\n-\t  b = a;\n-\telse\n-\t  b = c + 1;\n-\n-   In this case, an assertion on the THEN clause is useful to\n-   determine that 'a' is always 9 on that edge.  However, an assertion\n-   on the ELSE clause would be unnecessary.\n-\n-   On exit from this function, all the names created by the newly\n-   inserted ASSERT_EXPRs need to be added to the SSA web by rewriting\n-   the SSA names that they replace.\n-   \n-   TODO.  Handle SWITCH_EXPR.  */\n-\n-static bool\n-maybe_add_assert_expr (basic_block bb)\n-{\n-  block_stmt_iterator si;\n-  tree last;\n-  bool added;\n-\n-  /* Step 1.  Mark all the SSA names used in BB in bitmap FOUND.  */\n-  added = false;\n-  last = NULL_TREE;\n-  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-    {\n-      tree stmt, op;\n-      ssa_op_iter i;\n-      \n-      stmt = bsi_stmt (si);\n-\n-      /* Mark all the SSA names used by STMT in bitmap FOUND.  If STMT\n-\t is inside the sub-graph of a conditional block, when we\n-\t return from this recursive walk, our parent will use the\n-\t FOUND bitset to determine if one of the operands it was\n-\t looking for was present in the sub-graph.  */\n-      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-\t{\n-\t  tree cond;\n-\n-\t  /* If OP is used only once, namely in this STMT, don't\n-\t     bother inserting an ASSERT_EXPR for it.  Such an\n-\t     ASSERT_EXPR would do nothing but increase compile time.\n-\t     Experiments show that with this simple check, we can save\n-\t     more than 20% of ASSERT_EXPRs.  */\n-\t  if (has_single_use (op))\n-\t    continue;\n-\n-\t  SET_BIT (found, SSA_NAME_VERSION (op));\n-\n-\t  cond = infer_value_range (stmt, op);\n-\t  if (!cond)\n-\t    continue;\n-\n-\t  /* Step 2.  If OP is used in such a way that we can infer a\n-\t     value range for it, create a new ASSERT_EXPR for OP\n-\t     (unless OP already has an ASSERT_EXPR).  */\n-\t  gcc_assert (!is_ctrl_stmt (stmt));\n-\n-\t  if (has_assert_expr (op, cond))\n-\t    continue;\n-\n-\t  if (!stmt_ends_bb_p (stmt))\n-\t    {\n-\t      /* If STMT does not end the block, we can insert the new\n-\t\t assertion right after it.  */\n-\t      tree t = build_assert_expr_for (cond, op);\n-\t      bsi_insert_after (&si, t, BSI_NEW_STMT);\n-\t      added = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* STMT must be the last statement in BB.  We can only\n-\t\t insert new assertions on the non-abnormal edge out of\n-\t\t BB.  Note that since STMT is not control flow, there\n-\t\t may only be one non-abnormal edge out of BB.  */\n-\t      edge_iterator ei;\n-\t      edge e;\n-\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (!(e->flags & EDGE_ABNORMAL))\n-\t\t  {\n-\t\t    tree t = build_assert_expr_for (cond, op);\n-\t\t    bsi_insert_on_edge (e, t);\n-\t\t    added = true;\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-\n-      /* Remember the last statement of the block.  */\n-      last = stmt;\n-    }\n-\n-  /* Step 3.  If BB's last statement is a conditional expression\n-     involving integer operands, recurse into each of the sub-graphs\n-     rooted at BB to determine if we need to add ASSERT_EXPRs.\n-     Notice that we only care about the first operand of the\n-     conditional.  Adding assertions for both operands may actually \n-     hinder VRP.  FIXME, add example.  */\n-  if (last\n-      && TREE_CODE (last) == COND_EXPR\n-      && !fp_predicate (COND_EXPR_COND (last))\n-      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      tree op, cond;\n-      basic_block son;\n-      ssa_op_iter iter;\n-      \n-      cond = COND_EXPR_COND (last);\n-\n-      /* Get just the first use operand.  */\n-      FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tbreak;\n-      gcc_assert (op != NULL);\n-\n-      /* Do not attempt to infer anything in names that flow through\n-\t abnormal edges.  */\n-      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))\n-\treturn false;\n-\n-      /* Remove the COND_EXPR operand from the FOUND bitmap.\n-\t Otherwise, when we finish traversing each of the sub-graphs,\n-\t we won't know whether the variables were found in the\n-\t sub-graphs or if they had been found in a block upstream from\n-\t BB.  */\n-      RESET_BIT (found, SSA_NAME_VERSION (op));\n-\n-      /* Look for uses of the operands in each of the sub-graphs\n-\t rooted at BB.  We need to check each of the outgoing edges\n-\t separately, so that we know what kind of ASSERT_EXPR to\n-\t insert.  */\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  /* If BB strictly dominates the sub-graph at E->DEST,\n-\t     recurse into it.  */\n-\t  if (e->dest != bb\n-\t      && dominated_by_p (CDI_DOMINATORS, e->dest, bb))\n-\t    added |= maybe_add_assert_expr (e->dest);\n-\n-\t  /* Once we traversed the sub-graph, check if any block inside\n-\t     used either of the predicate's operands.  If so, add the\n-\t     appropriate ASSERT_EXPR.  */\n-\t  if (TEST_BIT (found, SSA_NAME_VERSION (op)))\n-\t    {\n-\t      /* We found a use of OP in the sub-graph rooted at\n-\t\t E->DEST.  Add an ASSERT_EXPR according to whether\n-\t\t E goes to THEN_CLAUSE or ELSE_CLAUSE.  */\n-\t      tree c, t;\n-\n-\t      if (e->flags & EDGE_TRUE_VALUE)\n-\t\tc = unshare_expr (cond);\n-\t      else if (e->flags & EDGE_FALSE_VALUE)\n-\t\tc = invert_truthvalue (cond);\n-\t      else\n-\t\tgcc_unreachable ();\n-\n-\t      t = build_assert_expr_for (c, op);\n-\t      bsi_insert_on_edge (e, t);\n-\t      added = true;\n-\t    }\n-\t}\n-\n-      /* Finally, mark all the COND_EXPR operands as found.  */\n-      SET_BIT (found, SSA_NAME_VERSION (op));\n-\n-      /* Recurse into the dominator children of BB that are not BB's\n-\t immediate successors.  Note that we have already visited BB's\n-\t other dominator children above.  */\n-      for (son = first_dom_son (CDI_DOMINATORS, bb);\n-\t   son;\n-\t   son = next_dom_son (CDI_DOMINATORS, son))\n-\t{\n-\t  if (find_edge (bb, son) == NULL)\n-\t    added |= maybe_add_assert_expr (son);\n-\t}\n-    }\n-  else\n-    {\n-      /* Step 4.  Recurse into the dominator children of BB.  */\n-      basic_block son;\n-\n-      for (son = first_dom_son (CDI_DOMINATORS, bb);\n-\t   son;\n-\t   son = next_dom_son (CDI_DOMINATORS, son))\n-\tadded |= maybe_add_assert_expr (son);\n-    }\n-\n-  return added;\n-}\n-#endif\n-\n-\n void dump_asserts_for (FILE *, tree);\n void debug_asserts_for (tree);\n void dump_all_asserts (FILE *);"}]}