{"sha": "ca3c102896ff2472f8c712651f6249de04ba10c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzYzEwMjg5NmZmMjQ3MmY4YzcxMjY1MWY2MjQ5ZGUwNGJhMTBjMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-03-28T07:42:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-03-28T07:42:04Z"}, "message": "sched-deps.c (sched_analyze_insn): Consolidate scheduling barrier code.\n\n        * sched-deps.c (sched_analyze_insn): Consolidate scheduling\n        barrier code.  Add a scheduling barrier if a non-call insn\n        can throw internally.\n\nFrom-SVN: r40915", "tree": {"sha": "68e10b281fed5bb38b28923673bf9706ea5225ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68e10b281fed5bb38b28923673bf9706ea5225ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca3c102896ff2472f8c712651f6249de04ba10c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3c102896ff2472f8c712651f6249de04ba10c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca3c102896ff2472f8c712651f6249de04ba10c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca3c102896ff2472f8c712651f6249de04ba10c0/comments", "author": null, "committer": null, "parents": [{"sha": "4f73495e075c5f1cc0f4c762b03b2d5a77099ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f73495e075c5f1cc0f4c762b03b2d5a77099ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f73495e075c5f1cc0f4c762b03b2d5a77099ea4"}], "stats": {"total": 89, "additions": 43, "deletions": 46}, "files": [{"sha": "09307a986854865d8e22b4a293bb621f818e2757", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3c102896ff2472f8c712651f6249de04ba10c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3c102896ff2472f8c712651f6249de04ba10c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca3c102896ff2472f8c712651f6249de04ba10c0", "patch": "@@ -1,5 +1,9 @@\n 2001-03-27  Richard Henderson  <rth@redhat.com>\n \n+\t* sched-deps.c (sched_analyze_insn): Consolidate scheduling\n+\tbarrier code.  Add a scheduling barrier if a non-call insn\n+\tcan throw internally.\n+\n \t* rtlanal.c (rtx_addr_can_trap_p): Virtual registers cannot trap.\n \tAuto-inc addresses trap only if their base register does.\n "}, {"sha": "0d13a2025e3b3d6b60c2e7ebf42fc44bb3e53750", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca3c102896ff2472f8c712651f6249de04ba10c0/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca3c102896ff2472f8c712651f6249de04ba10c0/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ca3c102896ff2472f8c712651f6249de04ba10c0", "patch": "@@ -972,6 +972,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n      rtx loop_notes;\n {\n   register RTX_CODE code = GET_CODE (x);\n+  int schedule_barrier_found = 0;\n   rtx link;\n   int i;\n \n@@ -1021,22 +1022,10 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n   if (GET_CODE (insn) == JUMP_INSN)\n     {\n-      rtx next, u, pending, pending_mem;\n+      rtx next, u;\n       next = next_nonnote_insn (insn);\n       if (next && GET_CODE (next) == BARRIER)\n-\t{\n-\t  for (i = 0; i < deps->max_reg; i++)\n-\t    {\n-\t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\n-\t      for (u = reg_last->uses; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      for (u = reg_last->sets; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t    }\n-\t}\n+\tschedule_barrier_found = 1;\n       else\n \t{\n \t  regset_head tmp;\n@@ -1054,33 +1043,19 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \n \t  CLEAR_REG_SET (&tmp);\n \t}\n-      pending = deps->pending_write_insns;\n-      pending_mem = deps->pending_write_mems;\n-      while (pending)\n-\t{\n-\t  add_dependence (insn, XEXP (pending, 0), 0);\n-\n-\t  pending = XEXP (pending, 1);\n-\t  pending_mem = XEXP (pending_mem, 1);\n-\t}\n-\n-      for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n-\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n     }\n \n   /* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic\n      block, then we must be sure that no instructions are scheduled across it.\n      Otherwise, the reg_n_refs info (which depends on loop_depth) would\n      become incorrect.  */\n-\n   if (loop_notes)\n     {\n-      int schedule_barrier_found = 0;\n       rtx link;\n \n       /* Update loop_notes with any notes from this insn.  Also determine\n \t if any of the notes on the list correspond to instruction scheduling\n-\t barriers (loop, eh & setjmp notes, but not range notes.  */\n+\t barriers (loop, eh & setjmp notes, but not range notes).  */\n       link = loop_notes;\n       while (XEXP (link, 1))\n \t{\n@@ -1095,30 +1070,48 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t}\n       XEXP (link, 1) = REG_NOTES (insn);\n       REG_NOTES (insn) = loop_notes;\n+    }\n+\n+  /* If this instruction can throw an exception, then moving it changes\n+     where block boundaries fall.  This is mighty confusing elsewhere. \n+     Therefore, prevent such an instruction from being moved.  */\n+  if (flag_non_call_exceptions && can_throw_internal (insn))\n+    schedule_barrier_found = 1;\n \n-      /* Add dependencies if a scheduling barrier was found.  */\n-      if (schedule_barrier_found)\n+  /* Add dependencies if a scheduling barrier was found.  */\n+  if (schedule_barrier_found)\n+    {\n+      rtx u, pending, pending_mem;\n+\n+      for (i = 0; i < deps->max_reg; i++)\n \t{\n-\t  for (i = 0; i < deps->max_reg; i++)\n-\t    {\n-\t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      rtx u;\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n \n-\t      for (u = reg_last->uses; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      for (u = reg_last->sets; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), 0);\n-\t      for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n-\t\tadd_dependence (insn, XEXP (u, 0), 0);\n+\t  for (u = reg_last->uses; u; u = XEXP (u, 1))\n+\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t  for (u = reg_last->sets; u; u = XEXP (u, 1))\n+\t    add_dependence (insn, XEXP (u, 0), 0);\n+\t  for (u = reg_last->clobbers; u; u = XEXP (u, 1))\n+\t    add_dependence (insn, XEXP (u, 0), 0);\n \n-\t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n-\t\tfree_INSN_LIST_list (&reg_last->uses);\n-\t    }\n-\t  reg_pending_sets_all = 1;\n+\t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t    free_INSN_LIST_list (&reg_last->uses);\n+\t}\n+      flush_pending_lists (deps, insn, 0);\n \n-\t  flush_pending_lists (deps, insn, 0);\n+      pending = deps->pending_write_insns;\n+      pending_mem = deps->pending_write_mems;\n+      while (pending)\n+\t{\n+\t  add_dependence (insn, XEXP (pending, 0), 0);\n+\t  pending = XEXP (pending, 1);\n+\t  pending_mem = XEXP (pending_mem, 1);\n \t}\n \n+      for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n+\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\n+      reg_pending_sets_all = 1;\n     }\n \n   /* Accumulate clobbers until the next set so that it will be output"}]}