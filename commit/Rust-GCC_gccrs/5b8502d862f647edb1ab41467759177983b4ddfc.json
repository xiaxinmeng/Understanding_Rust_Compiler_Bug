{"sha": "5b8502d862f647edb1ab41467759177983b4ddfc", "node_id": "C_kwDOANBUbNoAKDViODUwMmQ4NjJmNjQ3ZWRiMWFiNDE0Njc3NTkxNzc5ODNiNGRkZmM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-28T16:00:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-28T16:00:54Z"}, "message": "Remove default keyword flags in ResolveType interface\n\nThis patch also decouples handle the case where we need to resolve the full\ncanonical path of a TypeNoBounds such as:\n\n  struct Foo;\n  impl &Foo { .. }\n\nAnd te canonical path for the impl block Self type is actually\n\n  &crate_name::Foo\n\nThis is used in name mangling right now.", "tree": {"sha": "5265d279ba60160bb1609071c59920a36609d1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5265d279ba60160bb1609071c59920a36609d1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b8502d862f647edb1ab41467759177983b4ddfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8502d862f647edb1ab41467759177983b4ddfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8502d862f647edb1ab41467759177983b4ddfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8502d862f647edb1ab41467759177983b4ddfc/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76aeea68f518dba8a29bd7ad82e049ad106fe8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76aeea68f518dba8a29bd7ad82e049ad106fe8bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76aeea68f518dba8a29bd7ad82e049ad106fe8bd"}], "stats": {"total": 322, "additions": 179, "deletions": 143}, "files": [{"sha": "2087bad80845c508189ef2ddcbb1686f1d298688", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -167,7 +167,7 @@ ResolveExpr::visit (AST::NegationExpr &expr)\n void\n ResolveExpr::visit (AST::TypeCastExpr &expr)\n {\n-  ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n+  ResolveType::go (expr.get_type_to_cast_to ().get ());\n   ResolveExpr::go (expr.get_casted_expr ().get (), prefix, canonical_prefix);\n }\n "}, {"sha": "1ad91af3917c715a558d8355b296175c2b7f77f3", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -50,7 +50,7 @@ ResolveTraitItems::visit (AST::TraitItemType &type)\n \t\t\t\t   type.get_node_id (), cpath);\n \n   for (auto &bound : type.get_type_param_bounds ())\n-    ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+    ResolveTypeBound::go (bound.get ());\n }\n \n void\n@@ -79,13 +79,13 @@ ResolveTraitItems::visit (AST::TraitItemFunc &func)\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n       PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n@@ -128,7 +128,7 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // self turns into (self: Self) as a function param\n   AST::SelfParam &self_param = function.get_self_param ();\n@@ -144,14 +144,14 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n \n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n-  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  ResolveType::go (&self_type_path);\n   PatternDeclaration::go (&self_pattern);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n       PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n@@ -177,7 +177,7 @@ ResolveTraitItems::visit (AST::TraitItemConst &constant)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   constant.get_node_id (), cpath);\n \n-  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+  ResolveType::go (constant.get_type ().get ());\n \n   if (constant.has_expr ())\n     ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n@@ -218,7 +218,7 @@ ResolveItem::visit (AST::TypeAlias &alias)\n   if (alias.has_where_clause ())\n     ResolveWhereClause::Resolve (alias.get_where_clause ());\n \n-  ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n+  ResolveType::go (alias.get_type_aliased ().get ());\n \n   resolver->get_type_scope ().pop ();\n }\n@@ -291,8 +291,7 @@ ResolveItem::visit (AST::TupleStruct &struct_decl)\n \n       resolve_visibility (field.get_visibility ());\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -361,7 +360,7 @@ ResolveItem::visit (AST::EnumItemTuple &item)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n }\n \n@@ -380,7 +379,7 @@ ResolveItem::visit (AST::EnumItemStruct &item)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n }\n \n@@ -429,8 +428,7 @@ ResolveItem::visit (AST::StructStruct &struct_decl)\n \n       resolve_visibility (field.get_visibility ());\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -467,8 +465,7 @@ ResolveItem::visit (AST::Union &union_decl)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       union_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n     }\n \n   resolver->get_type_scope ().pop ();\n@@ -484,7 +481,7 @@ ResolveItem::visit (AST::StaticItem &var)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   var.get_node_id (), cpath);\n \n-  ResolveType::go (var.get_type ().get (), var.get_node_id ());\n+  ResolveType::go (var.get_type ().get ());\n   ResolveExpr::go (var.get_expr ().get (), path, cpath);\n }\n \n@@ -500,7 +497,7 @@ ResolveItem::visit (AST::ConstantItem &constant)\n \n   resolve_visibility (constant.get_visibility ());\n \n-  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+  ResolveType::go (constant.get_type ().get ());\n   ResolveExpr::go (constant.get_expr ().get (), path, cpath);\n }\n \n@@ -536,14 +533,13 @@ ResolveItem::visit (AST::Function &function)\n     ResolveWhereClause::Resolve (function.get_where_clause ());\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n       PatternDeclaration::go (param.get_pattern ().get ());\n \n       // the mutability checker needs to verify for immutable decls the number\n@@ -584,20 +580,20 @@ ResolveItem::visit (AST::InherentImpl &impl_block)\n   // FIXME this needs to be protected behind nominal type-checks see:\n   // rustc --explain E0118\n \n-  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n-  bool canonicalize_type_with_generics = false;\n-  NodeId resolved_node\n-    = ResolveType::go (impl_block.get_type ().get (),\n-\t\t       canonicalize_type_with_generics, &self_cpath);\n+  NodeId resolved_node = ResolveType::go (impl_block.get_type ().get ());\n   if (resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n-  rust_assert (!self_cpath.is_empty ());\n \n   // Setup paths\n+  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t\t    self_cpath);\n+  rust_assert (ok);\n+\n   std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n   CanonicalPath impl_type\n     = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n@@ -671,7 +667,7 @@ ResolveItem::visit (AST::Method &method)\n     ResolveWhereClause::Resolve (method.get_where_clause ());\n \n   if (method.has_return_type ())\n-    ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+    ResolveType::go (method.get_return_type ().get ());\n \n   // self turns into (self: Self) as a function param\n   AST::SelfParam &self_param = method.get_self_param ();\n@@ -687,14 +683,14 @@ ResolveItem::visit (AST::Method &method)\n \n   AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n \n-  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  ResolveType::go (&self_type_path);\n   PatternDeclaration::go (&self_pattern);\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : method.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n       PatternDeclaration::go (param.get_pattern ().get ());\n     }\n \n@@ -734,31 +730,37 @@ ResolveItem::visit (AST::TraitImpl &impl_block)\n   if (impl_block.has_where_clause ())\n     ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n-  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n-  bool canonicalize_type_with_generics = false;\n-  NodeId trait_resolved_node\n-    = ResolveType::go (&impl_block.get_trait_path (),\n-\t\t       canonicalize_type_with_generics, &canonical_trait_type);\n+  // CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  NodeId trait_resolved_node = ResolveType::go (&impl_block.get_trait_path ());\n   if (trait_resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n \n-  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n-  NodeId type_resolved_node\n-    = ResolveType::go (impl_block.get_type ().get (),\n-\t\t       canonicalize_type_with_generics, &canonical_impl_type);\n+  //   CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  NodeId type_resolved_node = ResolveType::go (impl_block.get_type ().get ());\n   if (type_resolved_node == UNKNOWN_NODEID)\n     {\n       resolver->get_type_scope ().pop ();\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n-  rust_assert (!canonical_impl_type.is_empty ());\n \n+  bool ok;\n   // setup paths\n+  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (&impl_block.get_trait_path (),\n+\t\t\t\t       canonical_trait_type);\n+  rust_assert (ok);\n+\n+  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  ok = ResolveTypeToCanonicalPath::go (impl_block.get_type ().get (),\n+\t\t\t\t       canonical_impl_type);\n+  rust_assert (ok);\n+\n+  // raw paths\n   std::string raw_impl_type_path = impl_block.get_type ()->as_string ();\n   CanonicalPath impl_type_seg\n     = CanonicalPath::new_seg (impl_block.get_type ()->get_node_id (),\n@@ -846,7 +848,7 @@ ResolveItem::visit (AST::Trait &trait)\n     {\n       for (auto &bound : trait.get_type_param_bounds ())\n \t{\n-\t  ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n+\t  ResolveTypeBound::go (bound.get ());\n \t}\n     }\n \n@@ -1096,14 +1098,13 @@ ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n     }\n \n   if (function.has_return_type ())\n-    ResolveType::go (function.get_return_type ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveType::go (function.get_return_type ().get ());\n \n   // we make a new scope so the names of parameters are resolved and shadowed\n   // correctly\n   for (auto &param : function.get_function_params ())\n     {\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n     }\n \n   // done\n@@ -1117,7 +1118,7 @@ ResolveExternItem::visit (AST::ExternalStaticItem &item)\n {\n   resolve_visibility (item.get_visibility ());\n \n-  ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+  ResolveType::go (item.get_type ().get ());\n }\n \n } // namespace Resolver"}, {"sha": "3c69b65f0e0546abd0e255624b2e2b9794c02170", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -216,10 +216,8 @@ void\n ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n {\n   AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n-  ResolveType::go (&root_segment.get_as_type_path (),\n-\t\t   root_segment.get_node_id ());\n-  ResolveType::go (root_segment.get_type ().get (),\n-\t\t   root_segment.get_node_id ());\n+  ResolveType::go (&root_segment.get_as_type_path ());\n+  ResolveType::go (root_segment.get_type ().get ());\n \n   for (auto &segment : expr->get_segments ())\n     {"}, {"sha": "202a280bb7518e861491e517d79ef311343b10c7", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -71,7 +71,7 @@ class ResolveStmt : public ResolverBase\n \trust_error_at (r, \"redefined multiple times\");\n       });\n \n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+    ResolveType::go (constant.get_type ().get ());\n     ResolveExpr::go (constant.get_expr ().get (), prefix, canonical_prefix);\n   }\n \n@@ -85,7 +85,7 @@ class ResolveStmt : public ResolverBase\n \n     PatternDeclaration::go (stmt.get_pattern ().get ());\n     if (stmt.has_type ())\n-      ResolveType::go (stmt.get_type ().get (), stmt.get_node_id ());\n+      ResolveType::go (stmt.get_type ().get ());\n   }\n \n   void visit (AST::TupleStruct &struct_decl) override\n@@ -117,8 +117,7 @@ class ResolveStmt : public ResolverBase\n       }\n \n     for (AST::TupleField &field : struct_decl.get_fields ())\n-      ResolveType::go (field.get_field_type ().get (),\n-\t\t       struct_decl.get_node_id ());\n+      ResolveType::go (field.get_field_type ().get ());\n \n     resolver->get_type_scope ().pop ();\n   }\n@@ -199,7 +198,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n   }\n \n@@ -225,7 +224,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n   }\n \n@@ -282,8 +281,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n \n     resolver->get_type_scope ().pop ();\n@@ -322,8 +320,7 @@ class ResolveStmt : public ResolverBase\n \tif (field.get_field_type ()->is_marked_for_strip ())\n \t  continue;\n \n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t union_decl.get_node_id ());\n+\tResolveType::go (field.get_field_type ().get ());\n       }\n \n     resolver->get_type_scope ().pop ();\n@@ -361,14 +358,13 @@ class ResolveStmt : public ResolverBase\n       }\n \n     if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n+      ResolveType::go (function.get_return_type ().get ());\n \n     // we make a new scope so the names of parameters are resolved and shadowed\n     // correctly\n     for (auto &param : function.get_function_params ())\n       {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tResolveType::go (param.get_type ().get ());\n \tPatternDeclaration::go (param.get_pattern ().get ());\n       }\n "}, {"sha": "5d0ceb536d5cdc351709a4abaad44aaf34844253", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 85, "deletions": 37, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -35,7 +35,7 @@ ResolveType::visit (AST::ArrayType &type)\n void\n ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n {\n-  ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n+  ResolveTypeBound::go (&type.get_trait_bound ());\n }\n \n void\n@@ -44,40 +44,20 @@ ResolveType::visit (AST::TraitObjectType &type)\n   for (auto &bound : type.get_type_param_bounds ())\n     {\n       /* NodeId bound_resolved_id = */\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+      ResolveTypeBound::go (bound.get ());\n     }\n }\n \n void\n ResolveType::visit (AST::ReferenceType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node = ResolveType::go (type.get_type_referenced ().get (),\n-\t\t\t\t   canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string ref_type_str = type.is_mut () ? \"mut\" : \"\";\n-      std::string ref_path = \"&\" + ref_type_str + \" \" + path.get ();\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), ref_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_type_referenced ().get ());\n }\n \n void\n ResolveType::visit (AST::RawPointerType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node = ResolveType::go (type.get_type_pointed_to ().get (),\n-\t\t\t\t   canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string ptr_type_str\n-\t= type.get_pointer_type () == AST::RawPointerType::CONST ? \"const\"\n-\t\t\t\t\t\t\t\t : \"mut\";\n-      std::string ptr_path = \"*\" + ptr_type_str + \" \" + path.get ();\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), ptr_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_type_pointed_to ().get ());\n }\n \n void\n@@ -95,15 +75,7 @@ ResolveType::visit (AST::NeverType &type)\n void\n ResolveType::visit (AST::SliceType &type)\n {\n-  CanonicalPath path = CanonicalPath::create_empty ();\n-  resolved_node = ResolveType::go (type.get_elem_type ().get (),\n-\t\t\t\t   canonicalize_type_with_generics, &path);\n-  if (canonical_path != nullptr)\n-    {\n-      std::string slice_path = \"[\" + path.get () + \"]\";\n-      *canonical_path = canonical_path->append (\n-\tCanonicalPath::new_seg (type.get_node_id (), slice_path));\n-    }\n+  resolved_node = ResolveType::go (type.get_elem_type ().get ());\n }\n \n // resolve relative type-paths\n@@ -159,7 +131,7 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t      {\n \t\tfor (auto &gt : s->get_generic_args ().get_type_args ())\n \t\t  {\n-\t\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+\t\t    ResolveType::go (gt.get ());\n \t\t  }\n \t      }\n \t  }\n@@ -317,15 +289,14 @@ ResolveRelativeQualTypePath::resolve_qual_seg (AST::QualifiedPathType &seg)\n     }\n \n   auto type = seg.get_type ().get ();\n-  NodeId type_resolved_node = ResolveType::go (type, seg.get_node_id ());\n+  NodeId type_resolved_node = ResolveType::go (type);\n   if (type_resolved_node == UNKNOWN_NODEID)\n     return false;\n \n   if (!seg.has_as_clause ())\n     return true;\n \n-  NodeId trait_resolved_node\n-    = ResolveType::go (&seg.get_as_type_path (), seg.get_node_id ());\n+  NodeId trait_resolved_node = ResolveType::go (&seg.get_as_type_path ());\n   if (trait_resolved_node == UNKNOWN_NODEID)\n     return false;\n \n@@ -358,5 +329,82 @@ ResolveRelativeQualTypePath::visit (AST::TypePathSegment &seg)\n     }\n }\n \n+// resolve to canonical path\n+\n+bool\n+ResolveTypeToCanonicalPath::go (AST::Type *type, CanonicalPath &result)\n+{\n+  ResolveTypeToCanonicalPath resolver;\n+  type->accept_vis (resolver);\n+  result = resolver.result;\n+  return !resolver.result.is_empty ();\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n+{\n+  NodeId resolved_node = UNKNOWN_NODEID;\n+  if (!resolver->lookup_resolved_name (path.get_node_id (), &resolved_node))\n+    {\n+      resolver->lookup_resolved_type (path.get_node_id (), &resolved_node);\n+    }\n+\n+  if (resolved_node == UNKNOWN_NODEID)\n+    return;\n+\n+  const CanonicalPath *type_path = nullptr;\n+  if (mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t       resolved_node, &type_path))\n+    {\n+      result = *type_path;\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_referenced ().get (), path);\n+  if (ok)\n+    {\n+      std::string ref_type_str = type.is_mut () ? \"mut\" : \"\";\n+      std::string ref_path = \"&\" + ref_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ref_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::RawPointerType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok\n+    = ResolveTypeToCanonicalPath::go (type.get_type_pointed_to ().get (), path);\n+  if (ok)\n+    {\n+      std::string ptr_type_str\n+\t= type.get_pointer_type () == AST::RawPointerType::CONST ? \"const\"\n+\t\t\t\t\t\t\t\t : \"mut\";\n+      std::string ptr_path = \"*\" + ptr_type_str + \" \" + path.get ();\n+      result = CanonicalPath::new_seg (type.get_node_id (), ptr_path);\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::SliceType &type)\n+{\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  bool ok = ResolveTypeToCanonicalPath::go (type.get_elem_type ().get (), path);\n+  if (ok)\n+    {\n+      std::string slice_path = \"[\" + path.get () + \"]\";\n+      result = CanonicalPath::new_seg (type.get_node_id (), slice_path);\n+    }\n+}\n+\n+ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n+  : ResolverBase (), result (CanonicalPath::create_empty ())\n+{}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "965df42e6bf54ab1c4e973818081ae57faa95640", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8502d862f647edb1ab41467759177983b4ddfc/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=5b8502d862f647edb1ab41467759177983b4ddfc", "patch": "@@ -56,11 +56,9 @@ class ResolveType : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::Type *type,\n-\t\t    bool canonicalize_type_with_generics = false,\n-\t\t    CanonicalPath *canonical_path = nullptr)\n+  static NodeId go (AST::Type *type)\n   {\n-    ResolveType resolver (canonicalize_type_with_generics, canonical_path);\n+    ResolveType resolver;\n     type->accept_vis (resolver);\n     return resolver.resolved_node;\n   }\n@@ -74,10 +72,10 @@ class ResolveType : public ResolverBase\n   void visit (AST::BareFunctionType &fntype) override\n   {\n     for (auto &param : fntype.get_function_params ())\n-      ResolveType::go (param.get_type ().get (), fntype.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n \n     if (fntype.has_return_type ())\n-      ResolveType::go (fntype.get_return_type ().get (), fntype.get_node_id ());\n+      ResolveType::go (fntype.get_return_type ().get ());\n   }\n \n   void visit (AST::TupleType &tuple) override\n@@ -89,23 +87,12 @@ class ResolveType : public ResolverBase\n       }\n \n     for (auto &elem : tuple.get_elems ())\n-      ResolveType::go (elem.get (), tuple.get_node_id ());\n+      ResolveType::go (elem.get ());\n   }\n \n   void visit (AST::TypePath &path) override\n   {\n-    if (ResolveRelativeTypePath::go (path, resolved_node))\n-      {\n-\tif (canonical_path == nullptr)\n-\t  return;\n-\n-\tconst CanonicalPath *type_path = nullptr;\n-\tif (mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t\t     resolved_node, &type_path))\n-\t  {\n-\t    *canonical_path = *type_path;\n-\t  }\n-      }\n+    ResolveRelativeTypePath::go (path, resolved_node);\n   }\n \n   void visit (AST::QualifiedPathInType &path) override\n@@ -130,43 +117,28 @@ class ResolveType : public ResolverBase\n   void visit (AST::SliceType &type) override;\n \n private:\n-  ResolveType (bool canonicalize_type_with_generics,\n-\t       CanonicalPath *canonical_path)\n-    : ResolverBase (),\n-      canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      canonical_path (canonical_path)\n-  {}\n-\n-  bool canonicalize_type_with_generics;\n-  CanonicalPath *canonical_path;\n+  ResolveType () : ResolverBase () {}\n };\n \n class ResolveTypeBound : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::TypeParamBound *type,\n-\t\t    bool canonicalize_type_with_generics = false)\n+  static NodeId go (AST::TypeParamBound *type)\n   {\n-    ResolveTypeBound resolver (canonicalize_type_with_generics);\n+    ResolveTypeBound resolver;\n     type->accept_vis (resolver);\n     return resolver.resolved_node;\n   };\n \n   void visit (AST::TraitBound &bound) override\n   {\n-    resolved_node = ResolveType::go (&bound.get_type_path (),\n-\t\t\t\t     canonicalize_type_with_generics);\n+    resolved_node = ResolveType::go (&bound.get_type_path ());\n   }\n \n private:\n-  ResolveTypeBound (bool canonicalize_type_with_generics)\n-    : ResolverBase (),\n-      canonicalize_type_with_generics (canonicalize_type_with_generics)\n-  {}\n-\n-  bool canonicalize_type_with_generics;\n+  ResolveTypeBound () : ResolverBase () {}\n };\n \n class ResolveGenericParam : public ResolverBase\n@@ -191,13 +163,13 @@ class ResolveGenericParam : public ResolverBase\n   {\n     // if it has a type lets resolve it\n     if (param.has_type ())\n-      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      ResolveType::go (param.get_type ().get ());\n \n     if (param.has_type_param_bounds ())\n       {\n \tfor (auto &bound : param.get_type_param_bounds ())\n \t  {\n-\t    ResolveTypeBound::go (bound.get (), param.get_node_id ());\n+\t    ResolveTypeBound::go (bound.get ());\n \t  }\n       }\n \n@@ -233,12 +205,12 @@ class ResolveWhereClause : public ResolverBase\n \n   void visit (AST::TypeBoundWhereClauseItem &item) override\n   {\n-    ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+    ResolveType::go (item.get_type ().get ());\n     if (item.has_type_param_bounds ())\n       {\n \tfor (auto &bound : item.get_type_param_bounds ())\n \t  {\n-\t    ResolveTypeBound::go (bound.get (), item.get_node_id ());\n+\t    ResolveTypeBound::go (bound.get ());\n \t  }\n       }\n   }\n@@ -247,6 +219,27 @@ class ResolveWhereClause : public ResolverBase\n   ResolveWhereClause () : ResolverBase () {}\n };\n \n+class ResolveTypeToCanonicalPath : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static bool go (AST::Type *type, CanonicalPath &result);\n+\n+  void visit (AST::TypePath &path) override;\n+\n+  void visit (AST::ReferenceType &type) override;\n+\n+  void visit (AST::RawPointerType &type) override;\n+\n+  void visit (AST::SliceType &type) override;\n+\n+private:\n+  ResolveTypeToCanonicalPath ();\n+\n+  CanonicalPath result;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}]}