{"sha": "0e997e7650169dbab7a431ab4191a024557e734d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5OTdlNzY1MDE2OWRiYWI3YTQzMWFiNDE5MWEwMjQ1NTdlNzM0ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-26T13:16:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-26T13:16:42Z"}, "message": "search.c (hides): Remove.\n\n\t* search.c (hides): Remove.\n\t(is_subobject_of_p): Add most_derived parameter. Use\n\tCANONICAL_BINFO.\n\t(lookup_field_queue_p): Adjust.\n\t(lookup_field_r): Adjust.\n\nFrom-SVN: r34709", "tree": {"sha": "8fabf69b12f26f163d079c3e7887ec08e9ef80a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fabf69b12f26f163d079c3e7887ec08e9ef80a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e997e7650169dbab7a431ab4191a024557e734d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e997e7650169dbab7a431ab4191a024557e734d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e997e7650169dbab7a431ab4191a024557e734d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e997e7650169dbab7a431ab4191a024557e734d/comments", "author": null, "committer": null, "parents": [{"sha": "51a5a5e0ef45835252405b53fe36c4f594c16b63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a5a5e0ef45835252405b53fe36c4f594c16b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a5a5e0ef45835252405b53fe36c4f594c16b63"}], "stats": {"total": 59, "additions": 21, "deletions": 38}, "files": [{"sha": "e9f7b5f230ad2168714be7a0914f48c4e4b04124", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e997e7650169dbab7a431ab4191a024557e734d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e997e7650169dbab7a431ab4191a024557e734d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e997e7650169dbab7a431ab4191a024557e734d", "patch": "@@ -1,3 +1,11 @@\n+2000-06-26  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* search.c (hides): Remove.\n+\t(is_subobject_of_p): Add most_derived parameter. Use\n+\tCANONICAL_BINFO.\n+\t(lookup_field_queue_p): Adjust.\n+\t(lookup_field_r): Adjust.\n+\n 2000-06-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl2.c (handle_class_head): Bash typedefs to the type's main"}, {"sha": "a5df0eccfc57950f5259d51664ff11bbd158831c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e997e7650169dbab7a431ab4191a024557e734d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e997e7650169dbab7a431ab4191a024557e734d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0e997e7650169dbab7a431ab4191a024557e734d", "patch": "@@ -89,8 +89,7 @@ static tree next_baselink PARAMS ((tree));\n static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n static int lookup_fnfields_here PARAMS ((tree, tree));\n-static int is_subobject_of_p PARAMS ((tree, tree));\n-static int hides PARAMS ((tree, tree));\n+static int is_subobject_of_p PARAMS ((tree, tree, tree));\n static tree virtual_context PARAMS ((tree, tree, tree));\n static tree dfs_check_overlap PARAMS ((tree, void *));\n static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n@@ -1223,30 +1222,23 @@ accessible_p (type, decl)\n \n /* Routine to see if the sub-object denoted by the binfo PARENT can be\n    found as a base class and sub-object of the object denoted by\n-   BINFO.  This routine relies upon binfos not being shared, except\n-   for binfos for virtual bases.  */\n+   BINFO.  MOST_DERIVED is the most derived type of the hierarchy being\n+   searched.  */\n \n static int\n-is_subobject_of_p (parent, binfo)\n-     tree parent, binfo;\n+is_subobject_of_p (parent, binfo, most_derived)\n+     tree parent, binfo, most_derived;\n {\n   tree binfos;\n   int i, n_baselinks;\n \n-  /* We want to canonicalize for comparison purposes.  But, when we\n-     iterate through basetypes later, we want the binfos from the\n-     original hierarchy.  That's why we have to calculate BINFOS\n-     first, and then canonicalize.  */\n-  binfos = BINFO_BASETYPES (binfo);\n-  parent = canonical_binfo (parent);\n-  binfo = canonical_binfo (binfo);\n-\n   if (parent == binfo)\n     return 1;\n \n+  binfos = BINFO_BASETYPES (binfo);\n   n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n-  /* Process and/or queue base types.  */\n+  /* Iterate the base types.  */\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n@@ -1255,31 +1247,14 @@ is_subobject_of_p (parent, binfo)\n \t   class there's no way to descend into it.  */\n \tcontinue;\n \n-      if (is_subobject_of_p (parent, base_binfo))\n+      if (is_subobject_of_p (parent, \n+                             CANONICAL_BINFO (base_binfo, most_derived),\n+                             most_derived))\n \treturn 1;\n     }\n   return 0;\n }\n \n-/* See if a one FIELD_DECL hides another.  This routine is meant to\n-   correspond to ANSI working paper Sept 17, 1992 10p4.  The two\n-   binfos given are the binfos corresponding to the particular places\n-   the FIELD_DECLs are found.  This routine relies upon binfos not\n-   being shared, except for virtual bases.  */\n-\n-static int\n-hides (hider_binfo, hidee_binfo)\n-     tree hider_binfo, hidee_binfo;\n-{\n-  /* hider hides hidee, if hider has hidee as a base class and\n-     the instance of hidee is a sub-object of hider.  The first\n-     part is always true is the second part is true.\n-\n-     When hider and hidee are the same (two ways to get to the exact\n-     same member) we consider either one as hiding the other.  */\n-  return is_subobject_of_p (hidee_binfo, hider_binfo);\n-}\n-\n /* Very similar to lookup_fnfields_1 but it ensures that at least one\n    function was declared inside the class given by TYPE.  It really should\n    only return functions that match the given TYPE.  */\n@@ -1344,7 +1319,7 @@ lookup_field_queue_p (binfo, data)\n   /* If this base class is hidden by the best-known value so far, we\n      don't need to look.  */\n   if (!lfi->from_dep_base_p && lfi->rval_binfo\n-      && hides (lfi->rval_binfo, binfo))\n+      && is_subobject_of_p (binfo, lfi->rval_binfo, lfi->type))\n     return NULL_TREE;\n \n   return CANONICAL_BINFO (binfo, lfi->type);\n@@ -1448,12 +1423,12 @@ lookup_field_r (binfo, data)\n \n   /* If the lookup already found a match, and the new value doesn't\n      hide the old one, we might have an ambiguity.  */\n-  if (lfi->rval_binfo && !hides (binfo, lfi->rval_binfo))\n+  if (lfi->rval_binfo && !is_subobject_of_p (lfi->rval_binfo, binfo, lfi->type))\n     {\n       if (nval == lfi->rval && SHARED_MEMBER_P (nval))\n \t/* The two things are really the same.  */\n \t;\n-      else if (hides (lfi->rval_binfo, binfo))\n+      else if (is_subobject_of_p (binfo, lfi->rval_binfo, lfi->type))\n \t/* The previous value hides the new one.  */\n \t;\n       else"}]}