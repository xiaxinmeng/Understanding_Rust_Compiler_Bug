{"sha": "64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ4MTJkMzNhYzZjMGYyM2EzZjRjMjViYzU0OTdkN2JiMDBlMGYyNA==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.vnet.ibm.com", "date": "2017-05-30T10:59:07Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-05-30T10:59:07Z"}, "message": "Vector peeling cost model 4/6\n\ngcc/ChangeLog:\n\n2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n\n\t* tree-vect-data-refs.c (vect_get_data_access_cost):\n\tWorkaround for SLP handling.\n\t(vect_enhance_data_refs_alignment):\n\tCompute costs for doing no peeling at all, compare to the best\n\tpeeling costs so far and avoid peeling if cheaper.\n\nFrom-SVN: r248678", "tree": {"sha": "75daba289c9a1b63677f831049a4b8365c298253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75daba289c9a1b63677f831049a4b8365c298253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24/comments", "author": {"login": "rdapp1", "id": 22046046, "node_id": "MDQ6VXNlcjIyMDQ2MDQ2", "avatar_url": "https://avatars.githubusercontent.com/u/22046046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp1", "html_url": "https://github.com/rdapp1", "followers_url": "https://api.github.com/users/rdapp1/followers", "following_url": "https://api.github.com/users/rdapp1/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp1/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp1/subscriptions", "organizations_url": "https://api.github.com/users/rdapp1/orgs", "repos_url": "https://api.github.com/users/rdapp1/repos", "events_url": "https://api.github.com/users/rdapp1/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e69cc8f2719f0bca87f29fa03e5a65a944ab659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e69cc8f2719f0bca87f29fa03e5a65a944ab659"}], "stats": {"total": 194, "additions": 111, "deletions": 83}, "files": [{"sha": "3d9fc12ad5c6d84802df5fbcfa3da63731233b84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "patch": "@@ -1,3 +1,11 @@\n+2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n+\n+\t* tree-vect-data-refs.c (vect_get_data_access_cost):\n+\tWorkaround for SLP handling.\n+\t(vect_enhance_data_refs_alignment):\n+\tCompute costs for doing no peeling at all, compare to the best\n+\tpeeling costs so far and avoid peeling if cheaper.\n+\n 2017-05-30  Robin Dapp  <rdapp@linux.vnet.ibm.com>\n \n \t* tree-vect-data-refs.c (vect_peeling_hash_choose_best_peeling):"}, {"sha": "1fa0386def6750726a219af5d75c6578a37969ed", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 103, "deletions": 83, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=64812d33ac6c0f23a3f4c25bc5497d7bb00e0f24", "patch": "@@ -1134,7 +1134,7 @@ vect_get_data_access_cost (struct data_reference *dr,\n   int nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  int ncopies = vf / nunits;\n+  int ncopies = MAX (1, vf / nunits); /* TODO: Handle SLP properly  */\n \n   if (DR_IS_READ (dr))\n     vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost,\n@@ -1517,10 +1517,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n   vec<data_reference_p> datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum dr_alignment_support supportable_dr_alignment;\n   struct data_reference *dr0 = NULL, *first_store = NULL;\n   struct data_reference *dr;\n-  struct data_reference *dr0_known_align = NULL;\n   unsigned int i, j;\n   bool do_peeling = false;\n   bool do_versioning = false;\n@@ -1601,7 +1599,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \tcontinue;\n \n-      supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n       do_peeling = vector_alignment_reachable_p (dr);\n       if (do_peeling)\n         {\n@@ -1690,16 +1687,6 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      if (!first_store && DR_IS_WRITE (dr))\n \t\tfirst_store = dr;\n \n-              /* If there are both known and unknown misaligned accesses in the\n-                 loop, we choose peeling amount according to the known\n-                 accesses.  */\n-              if (!supportable_dr_alignment)\n-                {\n-                  dr0 = dr;\n-                  if (!first_store && DR_IS_WRITE (dr))\n-                    first_store = dr;\n-                }\n-\n \t      one_misalignment_unknown = true;\n             }\n         }\n@@ -1721,81 +1708,85 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       || loop->inner)\n     do_peeling = false;\n \n-  unsigned int unknown_align_inside_cost = INT_MAX;\n-  unsigned int unknown_align_outside_cost = INT_MAX;\n+  struct _vect_peel_extended_info peel_for_known_alignment;\n+  struct _vect_peel_extended_info peel_for_unknown_alignment;\n+  struct _vect_peel_extended_info best_peel;\n+\n+  peel_for_unknown_alignment.inside_cost = INT_MAX;\n+  peel_for_unknown_alignment.outside_cost = INT_MAX;\n+  peel_for_unknown_alignment.peel_info.count = 0;\n \n   if (do_peeling\n-      && one_misalignment_unknown\n-      && vect_supportable_dr_alignment (dr0, false))\n+      && one_misalignment_unknown)\n     {\n       /* Check if the target requires to prefer stores over loads, i.e., if\n          misaligned stores are more expensive than misaligned loads (taking\n          drs with same alignment into account).  */\n-      if (first_store && DR_IS_READ (dr0))\n-        {\n-\t  unsigned int load_inside_cost = 0;\n-\t  unsigned int load_outside_cost = 0;\n-\t  unsigned int store_inside_cost = 0;\n-\t  unsigned int store_outside_cost = 0;\n-\t  stmt_vector_for_cost dummy;\n-\t  dummy.create (2);\n-\t  vect_get_peeling_costs_all_drs (dr0,\n-\t\t\t\t\t  &load_inside_cost,\n-\t\t\t\t\t  &load_outside_cost,\n-\t\t\t\t\t  &dummy, vf / 2, vf);\n-\t  dummy.release ();\n-\n+      unsigned int load_inside_cost = 0;\n+      unsigned int load_outside_cost = 0;\n+      unsigned int store_inside_cost = 0;\n+      unsigned int store_outside_cost = 0;\n+\n+      stmt_vector_for_cost dummy;\n+      dummy.create (2);\n+      vect_get_peeling_costs_all_drs (dr0,\n+\t\t\t\t      &load_inside_cost,\n+\t\t\t\t      &load_outside_cost,\n+\t\t\t\t      &dummy, vf / 2, vf);\n+      dummy.release ();\n+\n+      if (first_store)\n+\t{\n \t  dummy.create (2);\n \t  vect_get_peeling_costs_all_drs (first_store,\n \t\t\t\t\t  &store_inside_cost,\n \t\t\t\t\t  &store_outside_cost,\n \t\t\t\t\t  &dummy, vf / 2, vf);\n \t  dummy.release ();\n+\t}\n+      else\n+\t{\n+\t  store_inside_cost = INT_MAX;\n+\t  store_outside_cost = INT_MAX;\n+\t}\n \n-          if (load_inside_cost > store_inside_cost\n-              || (load_inside_cost == store_inside_cost\n-\t\t  && load_outside_cost > store_outside_cost))\n-\t    {\n-\t      dr0 = first_store;\n-\t      unknown_align_inside_cost = store_inside_cost;\n-\t      unknown_align_outside_cost = store_outside_cost;\n-\t    }\n-\t  else\n-\t    {\n-\t      unknown_align_inside_cost = load_inside_cost;\n-\t      unknown_align_outside_cost = load_outside_cost;\n-\t    }\n+      if (load_inside_cost > store_inside_cost\n+\t  || (load_inside_cost == store_inside_cost\n+\t      && load_outside_cost > store_outside_cost))\n+\t{\n+\t  dr0 = first_store;\n+\t  peel_for_unknown_alignment.inside_cost = store_inside_cost;\n+\t  peel_for_unknown_alignment.outside_cost = store_outside_cost;\n+\t}\n+      else\n+\t{\n+\t  peel_for_unknown_alignment.inside_cost = load_inside_cost;\n+\t  peel_for_unknown_alignment.outside_cost = load_outside_cost;\n+\t}\n \n-\t  stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n-\t  prologue_cost_vec.create (2);\n-\t  epilogue_cost_vec.create (2);\n+      stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n+      prologue_cost_vec.create (2);\n+      epilogue_cost_vec.create (2);\n \n-\t  int dummy2;\n-\t  unknown_align_outside_cost += vect_get_known_peeling_cost\n-\t    (loop_vinfo, vf / 2, &dummy2,\n-\t     &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n-\t     &prologue_cost_vec, &epilogue_cost_vec);\n+      int dummy2;\n+      peel_for_unknown_alignment.outside_cost += vect_get_known_peeling_cost\n+\t(loop_vinfo, vf / 2, &dummy2,\n+\t &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+\t &prologue_cost_vec, &epilogue_cost_vec);\n \n-\t  prologue_cost_vec.release ();\n-\t  epilogue_cost_vec.release ();\n-        }\n+      prologue_cost_vec.release ();\n+      epilogue_cost_vec.release ();\n \n-      /* Use peeling only if it may help to align other accesses in the loop or\n-\t if it may help improving load bandwith when we'd end up using\n-\t unaligned loads.  */\n-      tree dr0_vt = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr0)));\n-      if (STMT_VINFO_SAME_ALIGN_REFS\n-\t    (vinfo_for_stmt (DR_STMT (dr0))).length () == 0\n-\t  && (vect_supportable_dr_alignment (dr0, false)\n-\t      != dr_unaligned_supported\n-\t      || (DR_IS_READ (dr0)\n-\t\t  && (builtin_vectorization_cost (vector_load, dr0_vt, 0)\n-\t\t      == builtin_vectorization_cost (unaligned_load,\n-\t\t\t\t\t\t     dr0_vt, -1)))))\n-        do_peeling = false;\n+      peel_for_unknown_alignment.peel_info.count = 1\n+\t+ STMT_VINFO_SAME_ALIGN_REFS\n+\t(vinfo_for_stmt (DR_STMT (dr0))).length ();\n     }\n \n-  struct _vect_peel_extended_info peel_for_known_alignment;\n+  peel_for_unknown_alignment.peel_info.npeel = 0;\n+  peel_for_unknown_alignment.peel_info.dr = dr0;\n+\n+  best_peel = peel_for_unknown_alignment;\n+\n   peel_for_known_alignment.inside_cost = INT_MAX;\n   peel_for_known_alignment.outside_cost = INT_MAX;\n   peel_for_known_alignment.peel_info.count = 0;\n@@ -1804,24 +1795,52 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   if (do_peeling && one_misalignment_known)\n     {\n       /* Peeling is possible, but there is no data access that is not supported\n-         unless aligned. So we try to choose the best possible peeling.  */\n-\n-      /* Choose the best peeling from the hash table.  */\n+         unless aligned.  So we try to choose the best possible peeling from\n+\t the hash table.  */\n       peel_for_known_alignment = vect_peeling_hash_choose_best_peeling\n \t(&peeling_htab, loop_vinfo, &npeel, &body_cost_vec);\n-      dr0_known_align = peel_for_known_alignment.peel_info.dr;\n     }\n \n   /* Compare costs of peeling for known and unknown alignment. */\n-  if (dr0_known_align != NULL\n-      && unknown_align_inside_cost >= peel_for_known_alignment.inside_cost)\n-    {\n-      dr0 = dr0_known_align;\n-      if (!npeel)\n-\tdo_peeling = false;\n-    }\n+  if (peel_for_known_alignment.peel_info.dr != NULL\n+      && peel_for_unknown_alignment.inside_cost\n+      >= peel_for_known_alignment.inside_cost)\n+    best_peel = peel_for_known_alignment;\n+\n+  /* Calculate the penalty for no peeling, i.e. leaving everything\n+     unaligned.\n+     TODO: use something like an adapted vect_get_peeling_costs_all_drs.  */\n+  unsigned nopeel_inside_cost = 0;\n+  unsigned nopeel_outside_cost = 0;\n+\n+  stmt_vector_for_cost dummy;\n+  dummy.create (2);\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+    vect_get_data_access_cost (dr, &nopeel_inside_cost,\n+\t\t\t       &nopeel_outside_cost, &dummy);\n+  dummy.release ();\n+\n+  /* Add epilogue costs.  As we do not peel for alignment here, no prologue\n+     costs will be recorded.  */\n+  stmt_vector_for_cost prologue_cost_vec, epilogue_cost_vec;\n+  prologue_cost_vec.create (2);\n+  epilogue_cost_vec.create (2);\n+\n+  int dummy2;\n+  nopeel_outside_cost += vect_get_known_peeling_cost\n+    (loop_vinfo, 0, &dummy2,\n+     &LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n+     &prologue_cost_vec, &epilogue_cost_vec);\n+\n+  prologue_cost_vec.release ();\n+  epilogue_cost_vec.release ();\n+\n+  npeel = best_peel.peel_info.npeel;\n+  dr0 = best_peel.peel_info.dr;\n \n-  if (dr0 == NULL)\n+  /* If no peeling is not more expensive than the best peeling we\n+     have so far, don't perform any peeling.  */\n+  if (nopeel_inside_cost <= best_peel.inside_cost)\n     do_peeling = false;\n \n   if (do_peeling)\n@@ -2000,7 +2019,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      break;\n \t    }\n \n-\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n+\t  enum dr_alignment_support supportable_dr_alignment =\n+\t    vect_supportable_dr_alignment (dr, false);\n \n           if (!supportable_dr_alignment)\n             {"}]}