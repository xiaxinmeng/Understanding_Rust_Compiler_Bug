{"sha": "594a51febe0e6419db7bf30ca233da8a563301fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk0YTUxZmViZTBlNjQxOWRiN2JmMzBjYTIzM2RhOGE1NjMzMDFmYQ==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2004-11-14T20:28:58Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2004-11-14T20:28:58Z"}, "message": "Basic ABI changes for passing structs by value in 64-bit Darwin.\n\n        * config/rs6000/rs6000.c (rs6000_darwin64_abi): New flag.\n        (rs6000_override_options): Set it for 64-bit Darwin.\n        (rs6000_parse_abi_options): Add testing options to change it.\n        (rs6000_return_in_memory): Test whether the type is one\n        that can be passed in registers.\n        (darwin64_function_arg_advance): New.\n        (function_arg_advance): Call it, plus add recursion depth\n        argument and test when counting off arguments.\n        (rs6000_darwin64_function_arg): New.\n        (function_arg): Call it.\n        (setup_incoming_varargs): Add argument to function_arg_advance.\n        (rs6000_darwin64_function_value): New.\n        (rs6000_function_value): Call it.\n        * config/rs6000/rs6000.h (FUNCTION_ARG_ADVANCE): Pass depth arg.\n        * config/rs6000/rs6000-protos.h: Update decl of\n        function_arg_advance.\n\nFrom-SVN: r90629", "tree": {"sha": "c5f0272bf5c341b9e9b100e210c59c9a41ee1a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5f0272bf5c341b9e9b100e210c59c9a41ee1a0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/594a51febe0e6419db7bf30ca233da8a563301fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594a51febe0e6419db7bf30ca233da8a563301fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/594a51febe0e6419db7bf30ca233da8a563301fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/594a51febe0e6419db7bf30ca233da8a563301fa/comments", "author": null, "committer": null, "parents": [{"sha": "1e1b864906576c1e8ccd53595a727fc393fc0074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1b864906576c1e8ccd53595a727fc393fc0074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1b864906576c1e8ccd53595a727fc393fc0074"}], "stats": {"total": 381, "additions": 375, "deletions": 6}, "files": [{"sha": "4eea1edf1c456df08dcc51b22549b8702fd214ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=594a51febe0e6419db7bf30ca233da8a563301fa", "patch": "@@ -1,3 +1,23 @@\n+2004-11-14  Stan Shebs  <shebs@apple.com>\n+\n+\tBasic ABI changes for passing structs by value in 64-bit Darwin.\n+\t* config/rs6000/rs6000.c (rs6000_darwin64_abi): New flag.\n+\t(rs6000_override_options): Set it for 64-bit Darwin.\n+\t(rs6000_parse_abi_options): Add testing options to change it.\n+\t(rs6000_return_in_memory): Test whether the type is one\n+\tthat can be passed in registers.\n+\t(darwin64_function_arg_advance): New.\n+\t(function_arg_advance): Call it, plus add recursion depth\n+\targument and test when counting off arguments.\n+\t(rs6000_darwin64_function_arg): New.\n+\t(function_arg): Call it.\n+\t(setup_incoming_varargs): Add argument to function_arg_advance.\n+\t(rs6000_darwin64_function_value): New.\n+\t(rs6000_function_value): Call it.\n+\t* config/rs6000/rs6000.h (FUNCTION_ARG_ADVANCE): Pass depth arg.\n+\t* config/rs6000/rs6000-protos.h: Update decl of\n+\tfunction_arg_advance.\n+\n 2004-11-14  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c/17279"}, {"sha": "b7566936ebc8d2055a30a45b48c0d97ad76ad357", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=594a51febe0e6419db7bf30ca233da8a563301fa", "patch": "@@ -156,7 +156,7 @@ extern rtx rs6000_machopic_legitimize_pic_address (rtx orig,\n #ifdef TREE_CODE\n extern unsigned int rs6000_special_round_type_align (tree, int, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t  tree, int);\n+\t\t\t\t  tree, int, int);\n extern int function_arg_boundary (enum machine_mode, tree);\n extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t     enum machine_mode, tree, int);"}, {"sha": "a0c607fe7650a64b5d467917decbda551535597f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 353, "deletions": 4, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=594a51febe0e6419db7bf30ca233da8a563301fa", "patch": "@@ -175,6 +175,9 @@ int rs6000_spe;\n /* Nonzero if floating point operations are done in the GPRs.  */\n int rs6000_float_gprs = 0;\n \n+/* Nonzero if we want Darwin's struct-by-value-in-regs ABI.  */\n+int rs6000_darwin64_abi;\n+\n /* String from -mfloat-gprs=.  */\n const char *rs6000_float_gprs_string;\n \n@@ -746,6 +749,8 @@ static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree);\n+static rtx rs6000_darwin64_function_arg (CUMULATIVE_ARGS *,\n+\t\t\t\t\t enum machine_mode, tree, int);\n static rtx rs6000_mixed_function_arg (enum machine_mode, tree, int);\n static void rs6000_move_block_from_reg (int regno, rtx x, int nregs);\n static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n@@ -1292,6 +1297,12 @@ rs6000_override_options (const char *default_cpu)\n       rs6000_altivec_vrsave = 1;\n     }\n \n+  /* Set the Darwin64 ABI as default for 64-bit Darwin.  */\n+  if (DEFAULT_ABI == ABI_DARWIN && TARGET_64BIT)\n+    {\n+      rs6000_darwin64_abi = 1;\n+    }\n+\n   /* Handle -mabi= options.  */\n   rs6000_parse_abi_options ();\n \n@@ -1625,6 +1636,19 @@ rs6000_parse_abi_options (void)\n \terror (\"not configured for ABI: '%s'\", rs6000_abi_string);\n     }\n \n+  /* These are here for testing during development only, do not\n+     document in the manual please.  */\n+  else if (! strcmp (rs6000_abi_string, \"d64\"))\n+    {\n+      rs6000_darwin64_abi = 1;\n+      warning (\"Using darwin64 ABI\");\n+    }\n+  else if (! strcmp (rs6000_abi_string, \"d32\"))\n+    {\n+      rs6000_darwin64_abi = 0;\n+      warning (\"Using old darwin ABI\");\n+    }\n+\n   else if (! strcmp (rs6000_abi_string, \"no-spe\"))\n     rs6000_spe_abi = 0;\n   else\n@@ -4603,6 +4627,15 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n static bool\n rs6000_return_in_memory (tree type, tree fntype ATTRIBUTE_UNUSED)\n {\n+  /* In the darwin64 abi, try to use registers for larger structs\n+     if possible.  */\n+  if (AGGREGATE_TYPE_P (type)\n+      && rs6000_darwin64_abi\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) <= 32)\n+      && ((unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 0))\n+    return false;\n+\n   if (AGGREGATE_TYPE_P (type)\n       && (TARGET_AIX_STRUCT_RET\n \t  || (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8))\n@@ -4783,6 +4816,48 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n     return (size + 7) >> 3;\n }\n \f\n+/* The darwin64 ABI calls for us to recurse down through structs,\n+   applying the same rules to struct elements as if a reference to\n+   each were being passed directly.  */\n+\n+static void\n+darwin64_function_arg_advance (CUMULATIVE_ARGS *cum, tree type,\n+\t\t\t       int named, int depth)\n+{\n+  tree f, ftype;\n+  int i, tot;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+      for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+\tif (TREE_CODE (f) == FIELD_DECL)\n+\t  {\n+\t    ftype = TREE_TYPE (f);\n+\t    function_arg_advance (cum, TYPE_MODE (ftype), ftype,\n+\t\t\t\t  named, depth + 1);\n+\t  }\n+      break;\n+\n+    case ARRAY_TYPE:\n+      tot = int_size_in_bytes (type);\n+      if (tot <= 0)\n+\treturn;\n+      ftype = TREE_TYPE (type);\n+      tot /= int_size_in_bytes (ftype);\n+      \n+      for (i = 0; i < tot; ++i)\n+\t{\n+\t  function_arg_advance (cum, TYPE_MODE (ftype), ftype,\n+\t\t\t\tnamed, depth + 1);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)\n@@ -4793,9 +4868,11 @@ rs6000_arg_size (enum machine_mode mode, tree type)\n \n void\n function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t      tree type, int named)\n+\t\t      tree type, int named, int depth)\n {\n-  cum->nargs_prototype--;\n+  /* Only tick off an argument if we're not recursing.  */\n+  if (depth == 0)\n+    cum->nargs_prototype--;\n \n   if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     {\n@@ -4850,6 +4927,13 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t   && !cum->stdarg\n \t   && cum->sysv_gregno <= GP_ARG_MAX_REG)\n     cum->sysv_gregno++;\n+\n+  else if (rs6000_darwin64_abi\n+\t   && mode == BLKmode\n+\t   && (TREE_CODE (type) == RECORD_TYPE\n+\t       || TREE_CODE (type) == ARRAY_TYPE))\n+    darwin64_function_arg_advance (cum, type, named, depth);\n+\n   else if (DEFAULT_ABI == ABI_V4)\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n@@ -4925,7 +5009,8 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t   cum->words, cum->fregno);\n \t  fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s, \",\n \t\t   cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode));\n-\t  fprintf (stderr, \"named = %d, align = %d\\n\", named, align);\n+\t  fprintf (stderr, \"named = %d, align = %d, depth = %d\\n\",\n+\t\t   named, align, depth);\n \t}\n     }\n }\n@@ -5003,6 +5088,123 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n }\n \n+/* For the darwin64 ABI, we want to construct a PARALLEL consisting of\n+   the register(s) to be used for each field and subfield of a struct\n+   being passed by value, along with the offset of where the\n+   register's value may be found in the block.  */\n+\n+static rtx\n+rs6000_darwin64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t      tree type, int named)\n+{\n+  tree f, ftype, offset;\n+  rtx rvec[FIRST_PSEUDO_REGISTER], sub, suboff, roffset;\n+  int k = 0, i, j, bytepos, subbytepos, tot;\n+  CUMULATIVE_ARGS saved_cum = *cum;\n+  enum machine_mode submode;\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+      for (f = TYPE_FIELDS (type); f ; f = TREE_CHAIN (f))\n+\tif (TREE_CODE (f) == FIELD_DECL)\n+\t  {\n+\t    ftype = TREE_TYPE (f);\n+\t    offset = DECL_FIELD_OFFSET (f);\n+\t    bytepos = int_bit_position (f) / BITS_PER_UNIT;\n+\t    /* Force substructs to be handled as BLKmode even if\n+\t       they're small enough to be recorded as DImode, so we\n+\t       drill through to non-record fields.  */\n+\t    submode = TYPE_MODE (ftype);\n+\t    if (TREE_CODE (ftype) == RECORD_TYPE)\n+\t      submode = BLKmode;\n+\t    sub = function_arg (cum, submode, ftype, named);\n+\t    if (sub == NULL_RTX)\n+\t      return NULL_RTX;\n+\t    if (GET_CODE (sub) == PARALLEL)\n+\t      {\n+\t\tfor (i = 0; i < XVECLEN (sub, 0); i++)\n+\t\t  {\n+\t\t    rtx subsub = XVECEXP (sub, 0, i);\n+\t\t    suboff = XEXP (subsub, 1);\n+\t\t    subbytepos = INTVAL (suboff);\n+\t\t    subbytepos += bytepos;\n+\t\t    roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n+\t\t    subsub = XEXP (subsub, 0);\n+\t\t    rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n+\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n+\t      }\n+\t    /* Now do an arg advance to get all the cumulative arg\n+\t       stuff set correctly for the next subfield. Note that it\n+\t       has no lasting effect, because it is being done on a\n+\t       temporary copy of the cumulative arg data.  */\n+\t    function_arg_advance (cum, submode, ftype, named, 1);\n+\t  }\n+      break;\n+\n+    case ARRAY_TYPE:\n+      tot = int_size_in_bytes (type);\n+      if (tot <= 0)\n+\treturn NULL_RTX;\n+      ftype = TREE_TYPE (type);\n+      tot /= int_size_in_bytes (ftype);\n+      bytepos = 0;\n+\n+      for (j = 0; j < tot; ++j)\n+\t{\n+\t  /* Force substructs to be handled as BLKmode even if\n+\t     they're small enough to be recorded as DImode, so we\n+\t     drill through to non-record fields.  */\n+\t  submode = TYPE_MODE (ftype);\n+\t  if (TREE_CODE (ftype) == RECORD_TYPE)\n+\t    submode = BLKmode;\n+\t  sub = function_arg (cum, submode, ftype, named);\n+\t  if (sub == NULL_RTX)\n+\t    return NULL_RTX;\n+\t  if (GET_CODE (sub) == PARALLEL)\n+\t    {\n+\t      for (i = 0; i < XVECLEN (sub, 0); i++)\n+\t\t{\n+\t\t  rtx subsub = XVECEXP (sub, 0, i);\n+\n+\t\t  suboff = XEXP (subsub, 1);\n+\t\t  subbytepos = INTVAL (suboff);\n+\t\t  subbytepos += bytepos;\n+\t\t  roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n+\t\t  subsub = XEXP (subsub, 0);\n+\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      roffset = gen_rtx_CONST_INT (SImode, bytepos);\n+\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n+\t    }\n+\t    /* Now do an arg advance to get all the cumulative arg\n+\t       stuff set correctly for the next subfield. Note that it\n+\t       has no lasting effect, because it is being done on a\n+\t       temporary copy of the cumulative arg data.  */\n+\t    function_arg_advance (cum, submode, ftype, named, 1);\n+\t    bytepos += int_size_in_bytes (ftype);\n+\t}\n+      break;\n+\n+    default:\n+      abort ();\n+  }\n+\n+  *cum = saved_cum;\n+  if (k > 0)\n+    return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n+  else\n+    return NULL_RTX;\n+}\n+\n /* Determine where to place an argument in 64-bit mode with 32-bit ABI.  */\n \n static rtx\n@@ -5180,6 +5382,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t   && (SPE_VECTOR_MODE (mode)\n \t       || (TARGET_E500_DOUBLE && mode == DFmode)))\n     return rs6000_spe_function_arg (cum, mode, type);\n+\n+  else if (rs6000_darwin64_abi\n+\t   && mode == BLKmode\n+\t   && (TREE_CODE (type) == RECORD_TYPE\n+\t       || TREE_CODE (type) == ARRAY_TYPE))\n+    return rs6000_darwin64_function_arg (cum, mode, type, named);\n+\n   else if (abi == ABI_V4)\n     {\n       if (TARGET_HARD_FLOAT && TARGET_FPRS\n@@ -5454,7 +5663,7 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   /* Skip the last named argument.  */\n   next_cum = *cum;\n-  function_arg_advance (&next_cum, mode, type, 1);\n+  function_arg_advance (&next_cum, mode, type, 1, 0);\n \n   if (DEFAULT_ABI == ABI_V4)\n     {\n@@ -18127,6 +18336,128 @@ rs6000_complex_function_value (enum machine_mode mode)\n   return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r2));\n }\n \n+/* Compose a PARALLEL for a darwin64 struct being returned by\n+   value.  */\n+\n+static rtx\n+rs6000_darwin64_function_value (CUMULATIVE_ARGS *cum, tree valtype)\n+{\n+  tree f, ftype;\n+  rtx rvec[FIRST_PSEUDO_REGISTER], sub, roffset, suboff;\n+  int k = 0, bytepos, tot, elt, i, subbytepos;\n+  enum machine_mode fmode;\n+\n+  switch (TREE_CODE (valtype))\n+    {\n+    case RECORD_TYPE:\n+      for (f = TYPE_FIELDS (valtype); f ; f = TREE_CHAIN (f))\n+\tif (TREE_CODE (f) == FIELD_DECL)\n+\t  {\n+\t    ftype = TREE_TYPE (f);\n+\t    fmode = TYPE_MODE (ftype);\n+\t    bytepos = int_bit_position (f) / BITS_PER_UNIT;\n+\t    if (USE_FP_FOR_ARG_P (cum, fmode, ftype))\n+\t      {\n+\t\tsub = gen_rtx_REG (fmode, cum->fregno++);\n+\t\tcum->sysv_gregno++;\n+\t      }\n+\t    else if (USE_ALTIVEC_FOR_ARG_P (cum, fmode, ftype, 1))\n+\t      {\n+\t\tsub = gen_rtx_REG (fmode, cum->vregno++);\n+\t\tcum->sysv_gregno++;\n+\t      }\n+\t    else if (fmode == BLKmode\n+\t\t     && (TREE_CODE (ftype) == RECORD_TYPE\n+\t\t\t || TREE_CODE (ftype) == ARRAY_TYPE))\n+\t      sub = rs6000_darwin64_function_value (cum, ftype);\n+\t    else\n+\t      sub = gen_rtx_REG (fmode, cum->sysv_gregno++);\n+\t    if (sub == NULL_RTX)\n+\t      return sub;\n+\t    else if (GET_CODE (sub) == PARALLEL)\n+\t      {\n+\t\tfor (i = 0; i < XVECLEN (sub, 0); i++)\n+\t\t  {\n+\t\t    rtx subsub = XVECEXP (sub, 0, i);\n+\n+\t\t    suboff = XEXP (subsub, 1);\n+\t\t    subbytepos = INTVAL (suboff);\n+\t\t    subbytepos += bytepos;\n+\t\t    roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n+\t\t    subsub = XEXP (subsub, 0);\n+\t\t    rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n+\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n+\t      }\n+\t  }\n+      if (k > 0)\n+\treturn gen_rtx_PARALLEL (TYPE_MODE (valtype), gen_rtvec_v (k, rvec));\n+      else\n+\treturn NULL_RTX;\n+\n+    case ARRAY_TYPE:\n+      /* If passing by value won't work, give up.  */\n+      if (int_size_in_bytes (valtype) <= 0)\n+\treturn NULL_RTX;\n+      ftype = TREE_TYPE (valtype);\n+      fmode = TYPE_MODE (ftype);\n+      tot = int_size_in_bytes (valtype) / int_size_in_bytes (ftype);\n+      bytepos = 0;\n+      for (elt = 0; elt < tot; ++elt)\n+\t{\n+\t  if (USE_FP_FOR_ARG_P (cum, fmode, ftype))\n+\t    {\n+\t      sub = gen_rtx_REG (fmode, cum->fregno++);\n+\t      cum->sysv_gregno++;\n+\t    }\n+\t  else if (USE_ALTIVEC_FOR_ARG_P (cum, fmode, ftype, 1))\n+\t    {\n+\t      sub = gen_rtx_REG (fmode, cum->vregno++);\n+\t      cum->sysv_gregno++;\n+\t    }\n+\t  else if (fmode == BLKmode\n+\t\t   && (TREE_CODE (ftype) == RECORD_TYPE\n+\t\t       || TREE_CODE (ftype) == ARRAY_TYPE))\n+\t    sub = rs6000_darwin64_function_value (cum, ftype);\n+\t  else\n+\t    sub = gen_rtx_REG (fmode, cum->sysv_gregno++);\n+\t  if (sub == NULL_RTX)\n+\t    return sub;\n+\t  else if (GET_CODE (sub) == PARALLEL)\n+\t    {\n+\t      for (i = 0; i < XVECLEN (sub, 0); i++)\n+\t\t{\n+\t\t  rtx subsub = XVECEXP (sub, 0, i);\n+\n+\t\t  suboff = XEXP (subsub, 1);\n+\t\t  subbytepos = INTVAL (suboff);\n+\t\t  subbytepos += bytepos;\n+\t\t  roffset = gen_rtx_CONST_INT (SImode, subbytepos);\n+\t\t  subsub = XEXP (subsub, 0);\n+\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, subsub, roffset);\n+\t\t}\n+\t      }\n+\t    else\n+\t      {\n+\t\troffset = gen_rtx_CONST_INT (SImode, bytepos);\n+\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, sub, roffset);\n+\t      }\n+\t  bytepos += int_size_in_bytes (ftype);\n+\t}\n+      if (k > 0)\n+\treturn gen_rtx_PARALLEL (TYPE_MODE (valtype), gen_rtvec_v (k, rvec));\n+      else\n+\treturn NULL_RTX;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n@@ -18143,6 +18474,24 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   enum machine_mode mode;\n   unsigned int regno;\n \n+  /* Special handling for structs in darwin64.  */\n+  if (rs6000_darwin64_abi\n+      && TYPE_MODE (valtype) == BLKmode\n+      && (TREE_CODE (valtype) == RECORD_TYPE\n+\t  || TREE_CODE (valtype) == ARRAY_TYPE))\n+    {\n+      CUMULATIVE_ARGS valcum;\n+      rtx valret;\n+\n+      valcum.sysv_gregno = GP_ARG_RETURN;\n+      valcum.fregno = FP_ARG_MIN_REG;\n+      valcum.vregno = ALTIVEC_ARG_MIN_REG;\n+      valret = rs6000_darwin64_function_value (&valcum, valtype);\n+      if (valret)\n+\treturn valret;\n+      /* Otherwise fall through to standard ABI rules.  */\n+    }\n+\n   if (TARGET_32BIT && TARGET_POWERPC64 && TYPE_MODE (valtype) == DImode)\n     {\n       /* Long long return value need be split in -mpowerpc64, 32bit ABI.  */"}, {"sha": "1b74db8080a2dc9cbd1d7e3c482f217d05e3a52b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/594a51febe0e6419db7bf30ca233da8a563301fa/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=594a51febe0e6419db7bf30ca233da8a563301fa", "patch": "@@ -1713,7 +1713,7 @@ typedef struct rs6000_args\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+  function_arg_advance (&CUM, MODE, TYPE, NAMED, 0)\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,"}]}