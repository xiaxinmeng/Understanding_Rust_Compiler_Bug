{"sha": "f7e088e7de99b6ab31dc56d2a3ed358647207256", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlMDg4ZTdkZTk5YjZhYjMxZGM1NmQyYTNlZDM1ODY0NzIwNzI1Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-30T11:13:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-30T11:13:20Z"}, "message": "function.c (assign_parm_setup_reg): For a parameter passed by pointer and which can live in a register...\n\n\t* function.c (assign_parm_setup_reg): For a parameter passed by pointer\n\tand which can live in a register, always retrieve the value on entry.\n\t* var-tracking.c (add_stores): Treat the copy on entry for a parameter\n\tpassed by invisible reference specially.\n\t(emit_notes_in_bb) <MO_VAL_USE>: Emit notes before the instruction.\n\t(vt_add_function_parameter): Correctly deal with a parameter passed by\n\tinvisible reference.\n\nFrom-SVN: r202102", "tree": {"sha": "28d46552357ed039d57e797a50db601708d5d55e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28d46552357ed039d57e797a50db601708d5d55e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e088e7de99b6ab31dc56d2a3ed358647207256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e088e7de99b6ab31dc56d2a3ed358647207256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e088e7de99b6ab31dc56d2a3ed358647207256", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e088e7de99b6ab31dc56d2a3ed358647207256/comments", "author": null, "committer": null, "parents": [{"sha": "bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72"}], "stats": {"total": 133, "additions": 120, "deletions": 13}, "files": [{"sha": "9321385270661e8264bed12c0c1c97ae6bc24aab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -1,4 +1,14 @@\n-2013-08-29  Jan Hubicka  <jh@suse.cz>\n+2013-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* function.c (assign_parm_setup_reg): For a parameter passed by pointer\n+\tand which can live in a register, always retrieve the value on entry.\n+\t* var-tracking.c (add_stores): Treat the copy on entry for a parameter\n+\tpassed by invisible reference specially.\n+\t(emit_notes_in_bb) <MO_VAL_USE>: Emit notes before the instruction.\n+\t(vt_add_function_parameter): Correctly deal with a parameter passed by\n+\tinvisible reference.\n+\n+2013-08-30  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (set_call_expr_flags): Fix handling of TM_PURE.\n "}, {"sha": "08731e845022996a3dafddd742a421b02124569b", "filename": "gcc/function.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -3101,17 +3101,27 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n     emit_move_insn (parmreg, validated_mem);\n \n   /* If we were passed a pointer but the actual value can safely live\n-     in a register, put it in one.  */\n-  if (data->passed_pointer\n-      && TYPE_MODE (TREE_TYPE (parm)) != BLKmode\n-      /* If by-reference argument was promoted, demote it.  */\n-      && (TYPE_MODE (TREE_TYPE (parm)) != GET_MODE (DECL_RTL (parm))\n-\t  || use_register_for_decl (parm)))\n+     in a register, retrieve it and use it directly.  */\n+  if (data->passed_pointer && TYPE_MODE (TREE_TYPE (parm)) != BLKmode)\n     {\n       /* We can't use nominal_mode, because it will have been set to\n \t Pmode above.  We must use the actual mode of the parm.  */\n-      parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n-      mark_user_reg (parmreg);\n+      if (use_register_for_decl (parm))\n+\t{\n+\t  parmreg = gen_reg_rtx (TYPE_MODE (TREE_TYPE (parm)));\n+\t  mark_user_reg (parmreg);\n+\t}\n+      else\n+\t{\n+\t  int align = STACK_SLOT_ALIGNMENT (TREE_TYPE (parm),\n+\t\t\t\t\t    TYPE_MODE (TREE_TYPE (parm)),\n+\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (parm)));\n+\t  parmreg\n+\t    = assign_stack_local (TYPE_MODE (TREE_TYPE (parm)),\n+\t\t\t\t  GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parm))),\n+\t\t\t\t  align);\n+\t  set_mem_attributes (parmreg, parm, 1);\n+\t}\n \n       if (GET_MODE (parmreg) != GET_MODE (DECL_RTL (parm)))\n \t{"}, {"sha": "53aeadcd0ed4e4da09058c61ef64f01869e16dbf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -1,3 +1,8 @@\n+2013-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/guality/param-1.c: New test.\n+\t* gcc.dg/guality/param-2.c: Likewise.\n+\n 2013-08-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/58228"}, {"sha": "480ad3c13b65a6b9f5cacd9c1c73206b6be77071", "filename": "gcc/testsuite/gcc.dg/guality/param-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-1.c?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" } } */\n+\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+__attribute__((noinline, noclone)) int\n+sub (int a, int b)\n+{\n+  return a - b;\n+}\n+\n+typedef struct { uintptr_t pa; uintptr_t pb; } fatp_t\n+  __attribute__ ((aligned (2 * __alignof__ (uintptr_t))));\n+\n+__attribute__((noinline, noclone)) void\n+foo (fatp_t str, int a, int b)\n+{\n+  int i = sub (a, b);\n+  if (i == 0)           /* BREAK */\n+    i = sub (b, a);\n+}\n+\n+int\n+main (void)\n+{\n+  fatp_t ptr = { 31415927, 27182818 };\n+  foo (ptr, 1, 2);\n+  return 0;\n+}\n+\n+/* { dg-final { gdb-test 20 \"str.pa\" \"31415927\" } } */\n+/* { dg-final { gdb-test 20 \"str.pb\" \"27182818\" } } */"}, {"sha": "64678bd56997775f0b6c69908516b4fb2ef37737", "filename": "gcc/testsuite/gcc.dg/guality/param-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fparam-2.c?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g -fno-var-tracking-assignments\" } */\n+/* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O1\" } } */\n+\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+__attribute__((noinline, noclone)) int\n+sub (int a, int b)\n+{\n+  return a - b;\n+}\n+\n+typedef struct { uintptr_t pa; uintptr_t pb; } fatp_t\n+  __attribute__ ((aligned (2 * __alignof__ (uintptr_t))));\n+\n+__attribute__((noinline, noclone)) void\n+foo (fatp_t str, int a, int b)\n+{\n+  int i = sub (a, b);\n+  if (i == 0)           /* BREAK */\n+    foo (str, a - 1, b);\n+}\n+\n+int\n+main (void)\n+{\n+  fatp_t ptr = { 31415927, 27182818 };\n+  foo (ptr, 1, 2);\n+  return 0;\n+}\n+\n+/* { dg-final { gdb-test 20 \"str.pa\" \"31415927\" } } */\n+/* { dg-final { gdb-test 20 \"str.pb\" \"27182818\" } } */"}, {"sha": "cf1f08bc252cb6badf0a3ee59e0cfdd6c60a8a1b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e088e7de99b6ab31dc56d2a3ed358647207256/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f7e088e7de99b6ab31dc56d2a3ed358647207256", "patch": "@@ -5836,7 +5836,24 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t    {\n \t      rtx xexpr = gen_rtx_SET (VOIDmode, loc, src);\n \t      if (same_variable_part_p (src, REG_EXPR (loc), REG_OFFSET (loc)))\n-\t\tmo.type = MO_COPY;\n+\t\t{\n+\t\t  /* If this is an instruction copying (part of) a parameter\n+\t\t     passed by invisible reference to its register location,\n+\t\t     pretend it's a SET so that the initial memory location\n+\t\t     is discarded, as the parameter register can be reused\n+\t\t     for other purposes and we do not track locations based\n+\t\t     on generic registers.  */\n+\t\t  if (MEM_P (src)\n+\t\t      && REG_EXPR (loc)\n+\t\t      && TREE_CODE (REG_EXPR (loc)) == PARM_DECL\n+\t\t      && DECL_MODE (REG_EXPR (loc)) != BLKmode\n+\t\t      && MEM_P (DECL_INCOMING_RTL (REG_EXPR (loc)))\n+\t\t      && XEXP (DECL_INCOMING_RTL (REG_EXPR (loc)), 0)\n+\t\t\t != arg_pointer_rtx)\n+\t\t    mo.type = MO_SET;\n+\t\t  else\n+\t\t    mo.type = MO_COPY;\n+\t\t}\n \t      else\n \t\tmo.type = MO_SET;\n \t      mo.u.loc = xexpr;\n@@ -9086,7 +9103,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t      else\n \t\tvar_mem_set (set, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n \n-\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN, set->vars);\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN, set->vars);\n \t    }\n \t    break;\n \n@@ -9533,12 +9550,11 @@ vt_add_function_parameter (tree parm)\n \n   if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n     {\n-      if (REG_P (incoming) || MEM_P (incoming))\n+      if (MEM_P (incoming))\n \t{\n \t  /* This means argument is passed by invisible reference.  */\n \t  offset = 0;\n \t  decl = parm;\n-\t  incoming = gen_rtx_MEM (GET_MODE (decl_rtl), incoming);\n \t}\n       else\n \t{"}]}