{"sha": "eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIwODFmZDBlMmNiODUyYzNjZjBlZjA5ZGE0OTdlZDNmZWU3NzAyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-28T14:21:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-28T14:21:08Z"}, "message": "ipa-utils.c (ipa_merge_profiles): Be sure that all type transtions of counters are done same way.\n\n\t* ipa-utils.c (ipa_merge_profiles): Be sure that all type transtions\n\tof counters are done same way.\n\nFrom-SVN: r278809", "tree": {"sha": "d24544e52e13049f7d7c9e4f2516e10f5a68da37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24544e52e13049f7d7c9e4f2516e10f5a68da37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb081fd0e2cb852c3cf0ef09da497ed3fee77029/comments", "author": null, "committer": null, "parents": [{"sha": "2e7fd8678075ef8b2f4ae9a1f3d4923e886b0d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7fd8678075ef8b2f4ae9a1f3d4923e886b0d54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7fd8678075ef8b2f4ae9a1f3d4923e886b0d54"}], "stats": {"total": 69, "additions": 52, "deletions": 17}, "files": [{"sha": "aecc351e0fa9af5fd833caae214ef46677ac886f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb081fd0e2cb852c3cf0ef09da497ed3fee77029/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb081fd0e2cb852c3cf0ef09da497ed3fee77029/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "patch": "@@ -1,3 +1,8 @@\n+2019-11-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.c (ipa_merge_profiles): Be sure that all type transtions\n+\tof counters are done same way.\n+\n 2019-11-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-cp.c (update_profiling_info): Fix scaling."}, {"sha": "fdbecdb7b35ae8aa2f6ca494d239b315329099eb", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb081fd0e2cb852c3cf0ef09da497ed3fee77029/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb081fd0e2cb852c3cf0ef09da497ed3fee77029/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=eb081fd0e2cb852c3cf0ef09da497ed3fee77029", "patch": "@@ -398,6 +398,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n   tree oldsrcdecl = src->decl;\n   struct function *srccfun, *dstcfun;\n   bool match = true;\n+  bool copy_counts = false;\n \n   if (!src->definition\n       || !dst->definition)\n@@ -429,10 +430,26 @@ ipa_merge_profiles (struct cgraph_node *dst,\n     }\n   profile_count orig_count = dst->count;\n \n-  if (dst->count.initialized_p () && dst->count.ipa () == dst->count)\n-    dst->count += src->count.ipa ();\n-  else \n-    dst->count = src->count.ipa ();\n+  /* Either sum the profiles if both are IPA and not global0, or\n+     pick more informative one (that is nonzero IPA if other is\n+     uninitialized, guessed or global0).   */\n+\n+  if ((dst->count.ipa ().nonzero_p ()\n+       || src->count.ipa ().nonzero_p ())\n+      && dst->count.ipa ().initialized_p ()\n+      && src->count.ipa ().initialized_p ())\n+    dst->count = dst->count.ipa () + src->count.ipa ();\n+  else if (dst->count.ipa ().initialized_p ())\n+    ;\n+  else if (src->count.ipa ().initialized_p ())\n+    {\n+      copy_counts = true;\n+      dst->count = src->count.ipa ();\n+    }\n+\n+  /* If no updating needed return early.  */\n+  if (dst->count == orig_count)\n+    return;\n \n   /* First handle functions with no gimple body.  */\n   if (dst->thunk.thunk_p || dst->alias\n@@ -544,22 +561,32 @@ ipa_merge_profiles (struct cgraph_node *dst,\n       struct cgraph_edge *e, *e2;\n       basic_block srcbb, dstbb;\n \n+      /* Function and global profile may be out of sync.  First scale it same\n+\t way as fixup_cfg would.  */\n+      profile_count srcnum = src->count;\n+      profile_count srcden = ENTRY_BLOCK_PTR_FOR_FN (srccfun)->count;\n+      bool srcscale = srcnum.initialized_p () && !(srcnum == srcden);\n+      profile_count dstnum = orig_count;\n+      profile_count dstden = ENTRY_BLOCK_PTR_FOR_FN (dstcfun)->count;\n+      bool dstscale = !copy_counts\n+\t\t      && dstnum.initialized_p () && !(dstnum == dstden);\n+\n       /* TODO: merge also statement histograms.  */\n       FOR_ALL_BB_FN (srcbb, srccfun)\n \t{\n \t  unsigned int i;\n \n \t  dstbb = BASIC_BLOCK_FOR_FN (dstcfun, srcbb->index);\n \n-\t  /* Either sum the profiles if both are IPA and not global0, or\n-\t     pick more informative one (that is nonzero IPA if other is\n-\t     uninitialized, guessed or global0).   */\n-\t  if (!dstbb->count.ipa ().initialized_p ()\n-\t      || (dstbb->count.ipa () == profile_count::zero ()\n-\t\t  && (srcbb->count.ipa ().initialized_p ()\n-\t\t      && !(srcbb->count.ipa () == profile_count::zero ()))))\n+\t  profile_count srccount = srcbb->count;\n+\t  if (srcscale)\n+\t    srccount = srccount.apply_scale (srcnum, srcden);\n+\t  if (dstscale)\n+\t    dstbb->count = dstbb->count.apply_scale (dstnum, dstden);\n+\n+\t  if (copy_counts)\n \t    {\n-\t      dstbb->count = srcbb->count;\n+\t      dstbb->count = srccount;\n \t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n \t\t{\n \t\t  edge srce = EDGE_SUCC (srcbb, i);\n@@ -568,18 +595,21 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t\t    dste->probability = srce->probability;\n \t\t}\n \t    }\t\n-\t  else if (srcbb->count.ipa ().initialized_p ()\n-\t\t   && !(srcbb->count.ipa () == profile_count::zero ()))\n+\t  else \n \t    {\n \t      for (i = 0; i < EDGE_COUNT (srcbb->succs); i++)\n \t\t{\n \t\t  edge srce = EDGE_SUCC (srcbb, i);\n \t\t  edge dste = EDGE_SUCC (dstbb, i);\n \t\t  dste->probability = \n-\t\t    dste->probability * dstbb->count.probability_in (dstbb->count + srcbb->count)\n-\t\t    + srce->probability * srcbb->count.probability_in (dstbb->count + srcbb->count);\n+\t\t    dste->probability * dstbb->count.ipa ().probability_in\n+\t\t\t\t\t\t (dstbb->count.ipa ()\n+\t\t\t\t\t\t  + srccount.ipa ())\n+\t\t    + srce->probability * srcbb->count.ipa ().probability_in\n+\t\t\t\t\t\t (dstbb->count.ipa ()\n+\t\t\t\t\t\t  + srccount.ipa ());\n \t\t}\n-\t      dstbb->count += srcbb->count;\n+\t      dstbb->count = dstbb->count.ipa () + srccount.ipa ();\n \t    }\n \t}\n       push_cfun (dstcfun);"}]}