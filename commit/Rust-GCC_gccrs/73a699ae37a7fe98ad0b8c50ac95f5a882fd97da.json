{"sha": "73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhNjk5YWUzN2E3ZmU5OGFkMGI4YzUwYWM5NWY1YTg4MmZkOTdkYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:42:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:42:42Z"}, "message": "poly_int: GET_MODE_BITSIZE\n\nThis patch changes GET_MODE_BITSIZE from an unsigned short\nto a poly_uint16.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_to_bits): Return a poly_uint16 rather than an\n\tunsigned short.\n\t(GET_MODE_BITSIZE): Return a constant if ONLY_FIXED_SIZE_MODES,\n\tor if measurement_type is polynomial.\n\t* calls.c (shift_return_value): Treat GET_MODE_BITSIZE as polynomial.\n\t* combine.c (make_extraction): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t* expmed.c (store_integral_bit_field, extract_bit_field_1): Likewise.\n\t(extract_bit_field, extract_low_bits): Likewise.\n\t* expr.c (convert_move, convert_modes, emit_move_insn_1): Likewise.\n\t(optimize_bitfield_assignment_op, expand_assignment): Likewise.\n\t(store_expr_with_bounds, store_field, expand_expr_real_1): Likewise.\n\t* fold-const.c (optimize_bit_field_compare, merge_ranges): Likewise.\n\t* gimple-fold.c (optimize_atomic_compare_exchange_p): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* reload1.c (alter_reg): Likewise.\n\t* stor-layout.c (bitwise_mode_for_mode, compute_record_mode): Likewise.\n\t* targhooks.c (default_secondary_memory_needed_mode): Likewise.\n\t* tree-if-conv.c (predicate_mem_writes): Likewise.\n\t* tree-ssa-strlen.c (handle_builtin_memcmp): Likewise.\n\t* tree-vect-patterns.c (adjust_bool_pattern): Likewise.\n\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Likewise.\n\t* valtrack.c (dead_debug_insert_temp): Likewise.\n\t* varasm.c (mergeable_constant_section): Likewise.\n\t* config/sh/sh.h (LOCAL_ALIGNMENT): Use as_a <fixed_size_mode>.\n\ngcc/ada/\n\t* gcc-interface/misc.c (enumerate_modes): Treat GET_MODE_BITSIZE\n\tas polynomial.\n\ngcc/c-family/\n\t* c-ubsan.c (ubsan_instrument_shift): Treat GET_MODE_BITSIZE\n\tas polynomial.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256200", "tree": {"sha": "00d1721d088da7634f082a1092a670af7ff12469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00d1721d088da7634f082a1092a670af7ff12469"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/comments", "author": null, "committer": null, "parents": [{"sha": "79c3f1b3c7e8af1ce1b634326fafe772c4106484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c3f1b3c7e8af1ce1b634326fafe772c4106484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c3f1b3c7e8af1ce1b634326fafe772c4106484"}], "stats": {"total": 224, "additions": 159, "deletions": 65}, "files": [{"sha": "b4e536db44cf628879aa24e6c16aa38c513c88ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1,3 +1,34 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_to_bits): Return a poly_uint16 rather than an\n+\tunsigned short.\n+\t(GET_MODE_BITSIZE): Return a constant if ONLY_FIXED_SIZE_MODES,\n+\tor if measurement_type is polynomial.\n+\t* calls.c (shift_return_value): Treat GET_MODE_BITSIZE as polynomial.\n+\t* combine.c (make_extraction): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t* expmed.c (store_integral_bit_field, extract_bit_field_1): Likewise.\n+\t(extract_bit_field, extract_low_bits): Likewise.\n+\t* expr.c (convert_move, convert_modes, emit_move_insn_1): Likewise.\n+\t(optimize_bitfield_assignment_op, expand_assignment): Likewise.\n+\t(store_expr_with_bounds, store_field, expand_expr_real_1): Likewise.\n+\t* fold-const.c (optimize_bit_field_compare, merge_ranges): Likewise.\n+\t* gimple-fold.c (optimize_atomic_compare_exchange_p): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* reload1.c (alter_reg): Likewise.\n+\t* stor-layout.c (bitwise_mode_for_mode, compute_record_mode): Likewise.\n+\t* targhooks.c (default_secondary_memory_needed_mode): Likewise.\n+\t* tree-if-conv.c (predicate_mem_writes): Likewise.\n+\t* tree-ssa-strlen.c (handle_builtin_memcmp): Likewise.\n+\t* tree-vect-patterns.c (adjust_bool_pattern): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_simd_clone_call): Likewise.\n+\t* valtrack.c (dead_debug_insert_temp): Likewise.\n+\t* varasm.c (mergeable_constant_section): Likewise.\n+\t* config/sh/sh.h (LOCAL_ALIGNMENT): Use as_a <fixed_size_mode>.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "03f77b66756a47891dbca3c7bcb6456b3e3d15a4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/misc.c (enumerate_modes): Treat GET_MODE_BITSIZE\n+\tas polynomial.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3b62bb1a844d8f38b72a64dc6bb8d03595e5923a", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1301,14 +1301,14 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \t  }\n \n       /* If no predefined C types were found, register the mode itself.  */\n-      int nunits, precision;\n+      int nunits, precision, bitsize;\n       if (!skip_p\n \t  && GET_MODE_NUNITS (i).is_constant (&nunits)\n-\t  && GET_MODE_PRECISION (i).is_constant (&precision))\n+\t  && GET_MODE_PRECISION (i).is_constant (&precision)\n+\t  && GET_MODE_BITSIZE (i).is_constant (&bitsize))\n \tf (GET_MODE_NAME (i), digs, complex_p,\n \t   vector_p ? nunits : 0, float_rep,\n-\t   precision, GET_MODE_BITSIZE (i),\n-\t   GET_MODE_ALIGNMENT (i));\n+\t   precision, bitsize, GET_MODE_ALIGNMENT (i));\n     }\n }\n "}, {"sha": "0deb8889076e39a20119287c4becc16cfc1155b6", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-ubsan.c (ubsan_instrument_shift): Treat GET_MODE_BITSIZE\n+\tas polynomial.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "ae6e25043bf868681d087bd2b11dbbb62d4582e0", "filename": "gcc/c-family/c-ubsan.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fc-family%2Fc-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fc-family%2Fc-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -132,7 +132,8 @@ ubsan_instrument_shift (location_t loc, enum tree_code code,\n   /* If this is not a signed operation, don't perform overflow checks.\n      Also punt on bit-fields.  */\n   if (TYPE_OVERFLOW_WRAPS (type0)\n-      || GET_MODE_BITSIZE (TYPE_MODE (type0)) != TYPE_PRECISION (type0)\n+      || maybe_ne (GET_MODE_BITSIZE (TYPE_MODE (type0)),\n+\t\t   TYPE_PRECISION (type0))\n       || !sanitize_flags_p (SANITIZE_SHIFT_BASE))\n     ;\n "}, {"sha": "83736e18b691b7a45f73c8fa65533f4860acca73", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -3024,12 +3024,11 @@ check_sibcall_argument_overlap (rtx_insn *insn, struct arg_data *arg,\n bool\n shift_return_value (machine_mode mode, bool left_p, rtx value)\n {\n-  HOST_WIDE_INT shift;\n-\n   gcc_assert (REG_P (value) && HARD_REGISTER_P (value));\n   machine_mode value_mode = GET_MODE (value);\n-  shift = GET_MODE_BITSIZE (value_mode) - GET_MODE_BITSIZE (mode);\n-  if (shift == 0)\n+  poly_int64 shift = GET_MODE_BITSIZE (value_mode) - GET_MODE_BITSIZE (mode);\n+\n+  if (known_eq (shift, 0))\n     return false;\n \n   /* Use ashr rather than lshr for right shifts.  This is for the benefit"}, {"sha": "19cdb2d7f657ebd38101bfae5ead44654c40baf4", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -7707,8 +7707,9 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      are the same as for a register operation, since at present we don't\n      have named patterns for aligned memory structures.  */\n   struct extraction_insn insn;\n-  if (get_best_reg_extraction_insn (&insn, pattern,\n-\t\t\t\t    GET_MODE_BITSIZE (inner_mode), mode))\n+  unsigned int inner_size;\n+  if (GET_MODE_BITSIZE (inner_mode).is_constant (&inner_size)\n+      && get_best_reg_extraction_insn (&insn, pattern, inner_size, mode))\n     {\n       wanted_inner_reg_mode = insn.struct_mode.require ();\n       pos_mode = insn.pos_mode;\n@@ -7744,9 +7745,11 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t If it's a MEM we need to recompute POS relative to that.\n \t However, if we're extracting from (or inserting into) a register,\n \t we want to recompute POS relative to wanted_inner_mode.  */\n-      int width = (MEM_P (inner)\n-\t\t   ? GET_MODE_BITSIZE (is_mode)\n-\t\t   : GET_MODE_BITSIZE (wanted_inner_mode));\n+      int width;\n+      if (!MEM_P (inner))\n+\twidth = GET_MODE_BITSIZE (wanted_inner_mode);\n+      else if (!GET_MODE_BITSIZE (is_mode).is_constant (&width))\n+\treturn NULL_RTX;\n \n       if (pos_rtx == 0)\n \tpos = width - len - pos;"}, {"sha": "2f5930bbebd3f959c45cf80f12cd484f241a1cbf", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -468,7 +468,9 @@ extern const sh_atomic_model& selected_atomic_model (void);\n #define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n   ((GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_INT \\\n     || GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_FLOAT) \\\n-   ? (unsigned) MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (TYPE))) \\\n+   ? (unsigned) MIN (BIGGEST_ALIGNMENT, \\\n+\t\t     GET_MODE_BITSIZE (as_a <fixed_size_mode> \\\n+\t\t\t\t       (TYPE_MODE (TYPE)))) \\\n    : (unsigned) DATA_ALIGNMENT(TYPE, ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.  */"}, {"sha": "a0c66aa75ab470824cdf43276d5296ee4824bb10", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1734,7 +1734,7 @@ find_shift_sequence (poly_int64 access_size,\n \n       /* Try a wider mode if truncating the store mode to NEW_MODE\n \t requires a real instruction.  */\n-      if (GET_MODE_BITSIZE (new_mode) < GET_MODE_BITSIZE (store_mode)\n+      if (maybe_lt (GET_MODE_SIZE (new_mode), GET_MODE_SIZE (store_mode))\n \t  && !TRULY_NOOP_TRUNCATION_MODES_P (new_mode, store_mode))\n \tcontinue;\n "}, {"sha": "56cc454302c29da0bd6db81b6982313355865722", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -15395,7 +15395,8 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t     We output CONST_DOUBLEs as blocks.  */\n \t  if (mode == VOIDmode\n \t      || (GET_MODE (rtl) == VOIDmode\n-\t\t  && GET_MODE_BITSIZE (mode) != HOST_BITS_PER_DOUBLE_INT))\n+\t\t  && maybe_ne (GET_MODE_BITSIZE (mode),\n+\t\t\t       HOST_BITS_PER_DOUBLE_INT)))\n \t    break;\n \t  type_die = base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));\n \t  if (type_die == NULL)"}, {"sha": "ed21b277bccad374b3b7f3abb652a811c9cc0d21", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -867,7 +867,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n   if (!MEM_P (op0)\n       && !reverse\n       && lowpart_bit_field_p (bitnum, bitsize, op0_mode.require ())\n-      && bitsize == GET_MODE_BITSIZE (fieldmode)\n+      && known_eq (bitsize, GET_MODE_BITSIZE (fieldmode))\n       && optab_handler (movstrict_optab, fieldmode) != CODE_FOR_nothing)\n     {\n       struct expand_operand ops[2];\n@@ -1638,9 +1638,10 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n       if (GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode))\n \t{\n \t  scalar_mode inner_mode = GET_MODE_INNER (tmode);\n-\t  unsigned int nunits = (GET_MODE_BITSIZE (GET_MODE (op0))\n-\t\t\t\t / GET_MODE_UNIT_BITSIZE (tmode));\n-\t  if (!mode_for_vector (inner_mode, nunits).exists (&new_mode)\n+\t  poly_uint64 nunits;\n+\t  if (!multiple_p (GET_MODE_BITSIZE (GET_MODE (op0)),\n+\t\t\t   GET_MODE_UNIT_BITSIZE (tmode), &nunits)\n+\t      || !mode_for_vector (inner_mode, nunits).exists (&new_mode)\n \t      || !VECTOR_MODE_P (new_mode)\n \t      || GET_MODE_SIZE (new_mode) != GET_MODE_SIZE (GET_MODE (op0))\n \t      || GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode)\n@@ -2043,9 +2044,9 @@ extract_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n   machine_mode mode1;\n \n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n-  if (GET_MODE_BITSIZE (GET_MODE (str_rtx)) > 0)\n+  if (maybe_ne (GET_MODE_BITSIZE (GET_MODE (str_rtx)), 0))\n     mode1 = GET_MODE (str_rtx);\n-  else if (target && GET_MODE_BITSIZE (GET_MODE (target)) > 0)\n+  else if (target && maybe_ne (GET_MODE_BITSIZE (GET_MODE (target)), 0))\n     mode1 = GET_MODE (target);\n   else\n     mode1 = tmode;\n@@ -2361,7 +2362,7 @@ extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n   if (GET_MODE_CLASS (mode) == MODE_CC || GET_MODE_CLASS (src_mode) == MODE_CC)\n     return NULL_RTX;\n \n-  if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (src_mode)\n+  if (known_eq (GET_MODE_BITSIZE (mode), GET_MODE_BITSIZE (src_mode))\n       && targetm.modes_tieable_p (mode, src_mode))\n     {\n       rtx x = gen_lowpart_common (mode, src);"}, {"sha": "444a3a78a6b5a6f19b9e60deaf0856ada86c85c2", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -246,7 +246,8 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n   if (VECTOR_MODE_P (to_mode) || VECTOR_MODE_P (from_mode))\n     {\n-      gcc_assert (GET_MODE_BITSIZE (from_mode) == GET_MODE_BITSIZE (to_mode));\n+      gcc_assert (known_eq (GET_MODE_BITSIZE (from_mode),\n+\t\t\t    GET_MODE_BITSIZE (to_mode)));\n \n       if (VECTOR_MODE_P (to_mode))\n \tfrom = simplify_gen_subreg (to_mode, from, GET_MODE (from), 0);\n@@ -699,7 +700,8 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n      subreg operation.  */\n   if (VECTOR_MODE_P (mode) && GET_MODE (x) == VOIDmode)\n     {\n-      gcc_assert (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (oldmode));\n+      gcc_assert (known_eq (GET_MODE_BITSIZE (mode),\n+\t\t\t    GET_MODE_BITSIZE (oldmode)));\n       return simplify_gen_subreg (mode, x, oldmode, 0);\n     }\n \n@@ -3680,7 +3682,8 @@ emit_move_insn_1 (rtx x, rtx y)\n      only safe when simplify_subreg can convert MODE constants into integer\n      constants.  At present, it can only do this reliably if the value\n      fits within a HOST_WIDE_INT.  */\n-  if (!CONSTANT_P (y) || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+  if (!CONSTANT_P (y)\n+      || known_le (GET_MODE_BITSIZE (mode), HOST_BITS_PER_WIDE_INT))\n     {\n       rtx_insn *ret = emit_move_via_integer (mode, x, y, lra_in_progress);\n \n@@ -4642,8 +4645,9 @@ optimize_bitfield_assignment_op (poly_uint64 pbitsize,\n \t\t\t\t machine_mode mode1, rtx str_rtx,\n \t\t\t\t tree to, tree src, bool reverse)\n {\n+  /* str_mode is not guaranteed to be a scalar type.  */\n   machine_mode str_mode = GET_MODE (str_rtx);\n-  unsigned int str_bitsize = GET_MODE_BITSIZE (str_mode);\n+  unsigned int str_bitsize;\n   tree op0, op1;\n   rtx value, result;\n   optab binop;\n@@ -4657,6 +4661,7 @@ optimize_bitfield_assignment_op (poly_uint64 pbitsize,\n       || !pbitregion_start.is_constant (&bitregion_start)\n       || !pbitregion_end.is_constant (&bitregion_end)\n       || bitsize >= BITS_PER_WORD\n+      || !GET_MODE_BITSIZE (str_mode).is_constant (&str_bitsize)\n       || str_bitsize > BITS_PER_WORD\n       || TREE_SIDE_EFFECTS (to)\n       || TREE_THIS_VOLATILE (to))\n@@ -5208,7 +5213,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  else\n \t    {\n \t    concat_store_slow:;\n-\t      rtx temp = assign_stack_temp (GET_MODE (to_rtx),\n+\t      rtx temp = assign_stack_temp (to_mode,\n \t\t\t\t\t    GET_MODE_SIZE (GET_MODE (to_rtx)));\n \t      write_complex_part (temp, XEXP (to_rtx, 0), false);\n \t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n@@ -5651,8 +5656,8 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n     {\n       if (GET_MODE_CLASS (GET_MODE (target))\n \t  != GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (exp)))\n-\t  && GET_MODE_BITSIZE (GET_MODE (target))\n-\t     == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (exp))))\n+\t  && known_eq (GET_MODE_BITSIZE (GET_MODE (target)),\n+\t\t       GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (exp)))))\n \t{\n \t  rtx t = simplify_gen_subreg (GET_MODE (target), temp,\n \t\t\t\t       TYPE_MODE (TREE_TYPE (exp)), 0);\n@@ -6955,7 +6960,8 @@ store_field (rtx target, poly_int64 bitsize, poly_int64 bitpos,\n \t{\n \t  tree type = TREE_TYPE (exp);\n \t  if (INTEGRAL_TYPE_P (type)\n-\t      && TYPE_PRECISION (type) < GET_MODE_BITSIZE (TYPE_MODE (type))\n+\t      && maybe_ne (TYPE_PRECISION (type),\n+\t\t\t   GET_MODE_BITSIZE (TYPE_MODE (type)))\n \t      && known_eq (bitsize, TYPE_PRECISION (type)))\n \t    {\n \t      tree op = gimple_assign_rhs1 (nop_def);\n@@ -10286,8 +10292,8 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    if (known_eq (offset, 0)\n \t        && !reverse\n \t\t&& tree_fits_uhwi_p (TYPE_SIZE (type))\n-\t\t&& (GET_MODE_BITSIZE (DECL_MODE (base))\n-\t\t    == tree_to_uhwi (TYPE_SIZE (type))))\n+\t\t&& known_eq (GET_MODE_BITSIZE (DECL_MODE (base)),\n+\t\t\t     tree_to_uhwi (TYPE_SIZE (type))))\n \t      return expand_expr (build1 (VIEW_CONVERT_EXPR, type, base),\n \t\t\t\t  target, tmode, modifier);\n \t    if (TYPE_MODE (type) == BLKmode)"}, {"sha": "46490cad0bc29f2b3618ccc7cd918ffa933db147", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -4063,7 +4063,7 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n       || !known_size_p (plbitsize)\n       || !plbitsize.is_constant (&lbitsize)\n       || !plbitpos.is_constant (&lbitpos)\n-      || lbitsize == GET_MODE_BITSIZE (lmode)\n+      || known_eq (lbitsize, GET_MODE_BITSIZE (lmode))\n       || offset != 0\n       || TREE_CODE (linner) == PLACEHOLDER_EXPR\n       || lvolatilep)\n@@ -5190,8 +5190,9 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \t\tswitch (TREE_CODE (TREE_TYPE (low0)))\n \t\t  {\n \t\t  case ENUMERAL_TYPE:\n-\t\t    if (TYPE_PRECISION (TREE_TYPE (low0))\n-\t\t\t!= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (low0))))\n+\t\t    if (maybe_ne (TYPE_PRECISION (TREE_TYPE (low0)),\n+\t\t\t\t  GET_MODE_BITSIZE\n+\t\t\t\t    (TYPE_MODE (TREE_TYPE (low0)))))\n \t\t      break;\n \t\t    /* FALLTHROUGH */\n \t\t  case INTEGER_TYPE:\n@@ -5213,8 +5214,9 @@ merge_ranges (int *pin_p, tree *plow, tree *phigh, int in0_p, tree low0,\n \t\tswitch (TREE_CODE (TREE_TYPE (high1)))\n \t\t  {\n \t\t  case ENUMERAL_TYPE:\n-\t\t    if (TYPE_PRECISION (TREE_TYPE (high1))\n-\t\t\t!= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (high1))))\n+\t\t    if (maybe_ne (TYPE_PRECISION (TREE_TYPE (high1)),\n+\t\t\t\t  GET_MODE_BITSIZE\n+\t\t\t\t    (TYPE_MODE (TREE_TYPE (high1)))))\n \t\t      break;\n \t\t    /* FALLTHROUGH */\n \t\t  case INTEGER_TYPE:"}, {"sha": "e99a78adb73b55b3f58b461d3465119aa53b94ef", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -3786,7 +3786,8 @@ optimize_atomic_compare_exchange_p (gimple *stmt)\n       /* Don't optimize floating point expected vars, VIEW_CONVERT_EXPRs\n \t might not preserve all the bits.  See PR71716.  */\n       || SCALAR_FLOAT_TYPE_P (etype)\n-      || TYPE_PRECISION (etype) != GET_MODE_BITSIZE (TYPE_MODE (etype)))\n+      || maybe_ne (TYPE_PRECISION (etype),\n+\t\t   GET_MODE_BITSIZE (TYPE_MODE (etype))))\n     return false;\n \n   tree weak = gimple_call_arg (stmt, 3);"}, {"sha": "60c918e39c7334dfd59790d2431c31907ac8d268", "filename": "gcc/machmode.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -527,7 +527,7 @@ mode_to_bytes (machine_mode mode)\n \n /* Return the base GET_MODE_BITSIZE value for MODE.  */\n \n-ALWAYS_INLINE unsigned short\n+ALWAYS_INLINE poly_uint16\n mode_to_bits (machine_mode mode)\n {\n   return mode_to_bytes (mode) * BITS_PER_UNIT;\n@@ -600,7 +600,29 @@ mode_to_nunits (machine_mode mode)\n \n /* Get the size in bits of an object of mode MODE.  */\n \n-#define GET_MODE_BITSIZE(MODE) (mode_to_bits (MODE))\n+#if ONLY_FIXED_SIZE_MODES\n+#define GET_MODE_BITSIZE(MODE) ((unsigned short) mode_to_bits (MODE).coeffs[0])\n+#else\n+ALWAYS_INLINE poly_uint16\n+GET_MODE_BITSIZE (machine_mode mode)\n+{\n+  return mode_to_bits (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_poly<typename T::measurement_type>::type\n+GET_MODE_BITSIZE (const T &mode)\n+{\n+  return mode_to_bits (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_nonpoly<typename T::measurement_type>::type\n+GET_MODE_BITSIZE (const T &mode)\n+{\n+  return mode_to_bits (mode).coeffs[0];\n+}\n+#endif\n \n /* Get the number of value bits of an object of mode MODE.  */\n "}, {"sha": "ec0c05a13db9581750c8256253717209d100670a", "filename": "gcc/reload.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -3121,10 +3121,11 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\t   || (REG_P (operand)\n \t\t\t       && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n \t\t\t  && (WORD_REGISTER_OPERATIONS\n-\t\t\t      || ((GET_MODE_BITSIZE (GET_MODE (operand))\n-\t\t\t\t   < BIGGEST_ALIGNMENT)\n-\t\t\t\t  && paradoxical_subreg_p (operand_mode[i],\n-\t\t\t\t\t\t\t   GET_MODE (operand)))\n+\t\t\t      || (((maybe_lt\n+\t\t\t\t    (GET_MODE_BITSIZE (GET_MODE (operand)),\n+\t\t\t\t     BIGGEST_ALIGNMENT))\n+\t\t\t\t   && (paradoxical_subreg_p\n+\t\t\t\t       (operand_mode[i], GET_MODE (operand)))))\n \t\t\t      || BYTES_BIG_ENDIAN\n \t\t\t      || ((GET_MODE_SIZE (operand_mode[i])\n \t\t\t\t   <= UNITS_PER_WORD)"}, {"sha": "85936a86bde8147e2031fcb1510866ad3892460f", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -2146,7 +2146,11 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n       machine_mode wider_mode = wider_subreg_mode (mode, reg_max_ref_mode[i]);\n       poly_uint64 total_size = GET_MODE_SIZE (wider_mode);\n-      unsigned int min_align = GET_MODE_BITSIZE (reg_max_ref_mode[i]);\n+      /* ??? Seems strange to derive the minimum alignment from the size,\n+\t but that's the traditional behavior.  For polynomial-size modes,\n+\t the natural extension is to use the minimum possible size.  */\n+      unsigned int min_align\n+\t= constant_lower_bound (GET_MODE_BITSIZE (reg_max_ref_mode[i]));\n       poly_int64 adjust = 0;\n \n       something_was_spilled = true;"}, {"sha": "d64f7b7388a4baaa2c41593a8315772ad578bde7", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -411,7 +411,6 @@ opt_machine_mode\n bitwise_mode_for_mode (machine_mode mode)\n {\n   /* Quick exit if we already have a suitable mode.  */\n-  unsigned int bitsize = GET_MODE_BITSIZE (mode);\n   scalar_int_mode int_mode;\n   if (is_a <scalar_int_mode> (mode, &int_mode)\n       && GET_MODE_BITSIZE (int_mode) <= MAX_FIXED_MODE_SIZE)\n@@ -420,6 +419,8 @@ bitwise_mode_for_mode (machine_mode mode)\n   /* Reuse the sanity checks from int_mode_for_mode.  */\n   gcc_checking_assert ((int_mode_for_mode (mode), true));\n \n+  poly_int64 bitsize = GET_MODE_BITSIZE (mode);\n+\n   /* Try to replace complex modes with complex modes.  In general we\n      expect both components to be processed independently, so we only\n      care whether there is a register for the inner mode.  */\n@@ -434,7 +435,8 @@ bitwise_mode_for_mode (machine_mode mode)\n \n   /* Try to replace vector modes with vector modes.  Also try using vector\n      modes if an integer mode would be too big.  */\n-  if (VECTOR_MODE_P (mode) || bitsize > MAX_FIXED_MODE_SIZE)\n+  if (VECTOR_MODE_P (mode)\n+      || maybe_gt (bitsize, MAX_FIXED_MODE_SIZE))\n     {\n       machine_mode trial = mode;\n       if ((GET_MODE_CLASS (trial) == MODE_VECTOR_INT\n@@ -1772,7 +1774,7 @@ compute_record_mode (tree type)\n      does not apply to unions.  */\n   if (TREE_CODE (type) == RECORD_TYPE && mode != VOIDmode\n       && tree_fits_uhwi_p (TYPE_SIZE (type))\n-      && GET_MODE_BITSIZE (mode) == tree_to_uhwi (TYPE_SIZE (type)))\n+      && known_eq (GET_MODE_BITSIZE (mode), tree_to_uhwi (TYPE_SIZE (type))))\n     ;\n   else\n     mode = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1).else_blk ();"}, {"sha": "ebe43e99a6435c168da29c58697eb9cb9a7e6a3c", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -1179,7 +1179,7 @@ machine_mode\n default_secondary_memory_needed_mode (machine_mode mode)\n {\n   if (!targetm.lra_p ()\n-      && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n+      && known_lt (GET_MODE_BITSIZE (mode), BITS_PER_WORD)\n       && INTEGRAL_MODE_P (mode))\n     return mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0).require ();\n   return mode;"}, {"sha": "4f849537beef245a204336072076a12a52bacac9", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -2229,7 +2229,10 @@ predicate_mem_writes (loop_p loop)\n \t      tree ref, addr, ptr, mask;\n \t      gcall *new_stmt;\n \t      gimple_seq stmts = NULL;\n-\t      int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n+\t      machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+\t      /* We checked before setting GF_PLF_2 that an equivalent\n+\t\t integer mode exists.  */\n+\t      int bitsize = GET_MODE_BITSIZE (mode).to_constant ();\n \t      ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n \t      mark_addressable (ref);\n \t      addr = force_gimple_operand_gsi (&gsi, build_fold_addr_expr (ref),"}, {"sha": "aae242d93d6d30847bcd51f5be1d965092aea1f7", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -2690,7 +2690,7 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \t  location_t loc = gimple_location (stmt2);\n \t  tree type, off;\n \t  type = build_nonstandard_integer_type (leni, 1);\n-\t  gcc_assert (GET_MODE_BITSIZE (TYPE_MODE (type)) == leni);\n+\t  gcc_assert (known_eq (GET_MODE_BITSIZE (TYPE_MODE (type)), leni));\n \t  tree ptrtype = build_pointer_type_for_mode (char_type_node,\n \t\t\t\t\t\t      ptr_mode, true);\n \t  off = build_int_cst (ptrtype, 0);"}, {"sha": "50ddc0a86b0ac219786c5e205850690fed0bd5f6", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -3388,8 +3388,8 @@ adjust_bool_pattern (tree var, tree out_type,\n       gcc_assert (TREE_CODE_CLASS (rhs_code) == tcc_comparison);\n       if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n \t  || !TYPE_UNSIGNED (TREE_TYPE (rhs1))\n-\t  || (TYPE_PRECISION (TREE_TYPE (rhs1))\n-\t      != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs1)))))\n+\t  || maybe_ne (TYPE_PRECISION (TREE_TYPE (rhs1)),\n+\t\t       GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs1)))))\n \t{\n \t  scalar_mode mode = SCALAR_TYPE_MODE (TREE_TYPE (rhs1));\n \t  itype"}, {"sha": "341d772fe8feb38b74daaebb8d7d1df2ed9fd111", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -3595,7 +3595,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  if (simd_clone_subparts (atype)\n \t\t      < simd_clone_subparts (arginfo[i].vectype))\n \t\t    {\n-\t\t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (atype));\n+\t\t      poly_uint64 prec = GET_MODE_BITSIZE (TYPE_MODE (atype));\n \t\t      k = (simd_clone_subparts (arginfo[i].vectype)\n \t\t\t   / simd_clone_subparts (atype));\n \t\t      gcc_assert ((k & (k - 1)) == 0);\n@@ -3759,7 +3759,8 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  if (simd_clone_subparts (vectype) < nunits)\n \t    {\n \t      unsigned int k, l;\n-\t      unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (vectype));\n+\t      poly_uint64 prec = GET_MODE_BITSIZE (TYPE_MODE (vectype));\n+\t      poly_uint64 bytes = GET_MODE_SIZE (TYPE_MODE (vectype));\n \t      k = nunits / simd_clone_subparts (vectype);\n \t      gcc_assert ((k & (k - 1)) == 0);\n \t      for (l = 0; l < k; l++)\n@@ -3769,8 +3770,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    {\n \t\t      t = build_fold_addr_expr (new_temp);\n \t\t      t = build2 (MEM_REF, vectype, t,\n-\t\t\t\t  build_int_cst (TREE_TYPE (t),\n-\t\t\t\t\t\t l * prec / BITS_PER_UNIT));\n+\t\t\t\t  build_int_cst (TREE_TYPE (t), l * bytes));\n \t\t    }\n \t\t  else\n \t\t    t = build3 (BIT_FIELD_REF, vectype, new_temp,"}, {"sha": "20d1296f32b62564131397efa23fb9ed0390494e", "filename": "gcc/valtrack.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -611,10 +611,13 @@ dead_debug_insert_temp (struct dead_debug_local *debug, unsigned int uregno,\n \t  usesp = &cur->next;\n \t  *tailp = cur->next;\n \t  cur->next = NULL;\n+\t  /* \"may\" rather than \"must\" because we want (for example)\n+\t     N V4SFs to win over plain V4SF even though N might be 1.  */\n+\t  rtx candidate = *DF_REF_REAL_LOC (cur->use);\n \t  if (!reg\n-\t      || (GET_MODE_BITSIZE (GET_MODE (reg))\n-\t\t  < GET_MODE_BITSIZE (GET_MODE (*DF_REF_REAL_LOC (cur->use)))))\n-\t    reg = *DF_REF_REAL_LOC (cur->use);\n+\t      || maybe_lt (GET_MODE_BITSIZE (GET_MODE (reg)),\n+\t\t\t   GET_MODE_BITSIZE (GET_MODE (candidate))))\n+\t    reg = candidate;\n \t}\n       else\n \ttailp = &(*tailp)->next;"}, {"sha": "6f9b565bddb32c9564a73496b26c8ac64b3e56b1", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "patch": "@@ -843,12 +843,10 @@ mergeable_constant_section (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED,\n \t\t\t    unsigned int flags ATTRIBUTE_UNUSED)\n {\n-  unsigned int modesize = GET_MODE_BITSIZE (mode);\n-\n   if (HAVE_GAS_SHF_MERGE && flag_merge_constants\n       && mode != VOIDmode\n       && mode != BLKmode\n-      && modesize <= align\n+      && known_le (GET_MODE_BITSIZE (mode), align)\n       && align >= 8\n       && align <= 256\n       && (align & (align - 1)) == 0)"}]}