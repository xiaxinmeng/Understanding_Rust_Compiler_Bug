{"sha": "79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljYzUzMTI1YTAwNTBmZGQyMzkwZjJmZDUzZTk0OWU4MGZiZmUxYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-10-05T08:28:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-10-05T08:28:51Z"}, "message": "spew.c (frob_id): New static function.\n\n\t* spew.c (frob_id): New static function.\n\t(frob_opname): Use it.\n\t(yylex): Use it.\n\nFrom-SVN: r36719", "tree": {"sha": "d6b039af53fa3c00bf42e70d1750ee67bf2f76bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b039af53fa3c00bf42e70d1750ee67bf2f76bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cc53125a0050fdd2390f2fd53e949e80fbfe1b/comments", "author": null, "committer": null, "parents": [{"sha": "e88b028277a5abe49cafdcdc041751db2d0cf483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e88b028277a5abe49cafdcdc041751db2d0cf483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e88b028277a5abe49cafdcdc041751db2d0cf483"}], "stats": {"total": 97, "additions": 47, "deletions": 50}, "files": [{"sha": "508cd1eaf1efb3715b991241c7d8050e00c1638b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cc53125a0050fdd2390f2fd53e949e80fbfe1b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cc53125a0050fdd2390f2fd53e949e80fbfe1b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "patch": "@@ -1,3 +1,9 @@\n+2000-10-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* spew.c (frob_id): New static function.\n+\t(frob_opname): Use it.\n+\t(yylex): Use it.\n+\n 2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (lang_mark_false_label_stack): Remove."}, {"sha": "56a3deed86bde6d4e25a10b856cfb16e7d2e92dd", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79cc53125a0050fdd2390f2fd53e949e80fbfe1b/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79cc53125a0050fdd2390f2fd53e949e80fbfe1b/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=79cc53125a0050fdd2390f2fd53e949e80fbfe1b", "patch": "@@ -120,6 +120,7 @@ static SPEW_INLINE void feed_input PARAMS ((struct unparsed_text *));\n static SPEW_INLINE void end_input PARAMS ((void));\n static SPEW_INLINE void snarf_block PARAMS ((const char *, int));\n static tree snarf_defarg PARAMS ((void));\n+static int frob_id PARAMS ((int, int, tree *));\n \n /* The list of inline functions being held off until we reach the end of\n    the current class declaration.  */\n@@ -776,48 +777,14 @@ yylex ()\n       break;\n \n     case IDENTIFIER:\n+    {\n+      int peek;\n+      \n       scan_tokens (1);\n-      if (nth_token (1)->yychar == SCOPE)\n-\t{\n-\t  /* Don't interfere with the setting from an 'aggr' prefix.  */\n-\t  old_looking_for_typename = looking_for_typename;\n-\t  looking_for_typename = 1;\n-\t}\n-      else if (nth_token (1)->yychar == '<')\n-\tlooking_for_template = 1;\n-\n-      trrr = lookup_name (nth_token (0)->yylval.ttype, -2);\n-\n-      if (trrr)\n-\t{\n-\t  yychr = identifier_type (trrr);\n-\t  switch (yychr)\n-\t    {\n-\t    case TYPENAME:\n-\t    case SELFNAME:\n-\t    case NSNAME:\n-\t    case PTYPENAME:\n-\t      lastiddecl = trrr;\n-\n-\t      /* If this got special lookup, remember it.  In these\n-\t         cases, we know it can't be a declarator-id. */\n-\t      if (got_scope || got_object)\n-\t\tnth_token (0)->yylval.ttype = trrr;\n-\t      break;\n-\n-\t    case PFUNCNAME:\n-\t    case IDENTIFIER:\n-\t      lastiddecl = trrr;\n-\t      break;\n-\n-\t    default:\n-\t      my_friendly_abort (101);\n-\t    }\n-\t}\n-      else\n-\tlastiddecl = NULL_TREE;\n-      got_scope = NULL_TREE;\n-      /* and fall through to...  */\n+      peek = nth_token (1)->yychar;\n+      yychr = frob_id (yychr, peek, &nth_token (0)->yylval.ttype);\n+      break;\n+    }\n     case IDENTIFIER_DEFN:\n     case TYPENAME:\n     case TYPENAME_DEFN:\n@@ -938,27 +905,40 @@ yyungetc (ch, rescan)\n     }\n }\n \n-/* ID is an operator name. Duplicate the hackery in yylex to determine what\n-   it really is.  */\n+/* Lexer hackery to determine what *IDP really is.  */\n \n-tree frob_opname (id)\n-     tree id;\n+static int\n+frob_id (yyc, peek, idp)\n+     int yyc;\n+     int peek;\n+     tree *idp;\n {\n   tree trrr;\n+  int old_looking_for_typename = 0;\n   \n-  if (yychar == '<')\n+  if (peek == SCOPE)\n+    {\n+      /* Don't interfere with the setting from an 'aggr' prefix.  */\n+      old_looking_for_typename = looking_for_typename;\n+      looking_for_typename = 1;\n+    }\n+  else if (peek == '<')\n     looking_for_template = 1;\n-  trrr = lookup_name (id, -2);\n+  trrr = lookup_name (*idp, -2);\n   if (trrr)\n     {\n-      switch (identifier_type (trrr))\n+      yyc = identifier_type (trrr);\n+      switch(yyc)\n         {\n           case TYPENAME:\n           case SELFNAME:\n           case NSNAME:\n           case PTYPENAME:\n+\t    /* If this got special lookup, remember it.  In these\n+\t       cases, we know it can't be a declarator-id. */\n             if (got_scope || got_object)\n-              id = trrr;\n+              *idp = trrr;\n+            /* FALLTHROUGH */\n           case PFUNCNAME:\n           case IDENTIFIER:\n             lastiddecl = trrr;\n@@ -970,8 +950,19 @@ tree frob_opname (id)\n   else\n     lastiddecl = NULL_TREE;\n   got_scope = NULL_TREE;\n-  got_object = NULL_TREE;\n+  looking_for_typename = old_looking_for_typename;\n   looking_for_template = 0;\n+  return yyc;\n+}\n+\n+/* ID is an operator name. Duplicate the hackery in yylex to determine what\n+   it really is.  */\n+\n+tree frob_opname (id)\n+     tree id;\n+{\n+  frob_id (0, yychar, &id);\n+  got_object = NULL_TREE;\n   return id;\n }\n "}]}