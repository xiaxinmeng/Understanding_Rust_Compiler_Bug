{"sha": "6dd49eb4d3f326c487b04cc5cc15672f4576c689", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkNDllYjRkM2YzMjZjNDg3YjA0Y2M1Y2MxNTY3MmY0NTc2YzY4OQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-04T14:19:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-04T14:19:36Z"}, "message": "loop.c (scan_loop): New argument loop_cont.\n\n        * loop.c (scan_loop): New argument loop_cont.  Changed caller.\n        (strength_reduce): New argument loop_cont. Changed caller.\n        Before clearing not_every_iteration after a label, check if\n        we are not already past LOOP_CONT.\n\nFrom-SVN: r25026", "tree": {"sha": "3a1baec7480b5adc0c69d3fdd44128b7b4182c61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a1baec7480b5adc0c69d3fdd44128b7b4182c61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dd49eb4d3f326c487b04cc5cc15672f4576c689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd49eb4d3f326c487b04cc5cc15672f4576c689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd49eb4d3f326c487b04cc5cc15672f4576c689", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd49eb4d3f326c487b04cc5cc15672f4576c689/comments", "author": null, "committer": null, "parents": [{"sha": "74c9467af51e9d9b606c1592fd4cfdecbd1ddcb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74c9467af51e9d9b606c1592fd4cfdecbd1ddcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74c9467af51e9d9b606c1592fd4cfdecbd1ddcb3"}], "stats": {"total": 40, "additions": 24, "deletions": 16}, "files": [{"sha": "f94846bad92bf59ac5bb541103938b3f6cd9bea4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd49eb4d3f326c487b04cc5cc15672f4576c689/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd49eb4d3f326c487b04cc5cc15672f4576c689/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dd49eb4d3f326c487b04cc5cc15672f4576c689", "patch": "@@ -1,3 +1,10 @@\n+Thu Feb  4 15:12:41 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (scan_loop): New argument loop_cont.  Changed caller.\n+\t(strength_reduce): New argument loop_cont. Changed caller.\n+\tBefore clearing not_every_iteration after a label, check if\n+\twe are not already past LOOP_CONT.\n+\n 1999-02-04 16:04 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n \n \t* cpperror.c (cpp_print_containing_files): Fix formatting "}, {"sha": "f76293674ff259b61ef2de2895494faa4f5da618", "filename": "gcc/loop.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd49eb4d3f326c487b04cc5cc15672f4576c689/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd49eb4d3f326c487b04cc5cc15672f4576c689/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6dd49eb4d3f326c487b04cc5cc15672f4576c689", "patch": "@@ -291,7 +291,7 @@ static void count_loop_regs_set PROTO((rtx, rtx, varray_type, varray_type,\n \t\t\t\t       int *, int)); \n static void note_addr_stored PROTO((rtx, rtx));\n static int loop_reg_used_before_p PROTO((rtx, rtx, rtx, rtx, rtx));\n-static void scan_loop PROTO((rtx, rtx, int, int));\n+static void scan_loop PROTO((rtx, rtx, rtx, int, int));\n #if 0\n static void replace_call_address PROTO((rtx, rtx, rtx));\n #endif\n@@ -305,7 +305,7 @@ static int rtx_equal_for_loop_p PROTO((rtx, rtx, struct movable *));\n static void add_label_notes PROTO((rtx, rtx));\n static void move_movables PROTO((struct movable *, int, int, rtx, rtx, int));\n static int count_nonfixed_reads PROTO((rtx));\n-static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, int, int));\n+static void strength_reduce PROTO((rtx, rtx, rtx, int, rtx, rtx, rtx, int, int));\n static void find_single_use_in_loop PROTO((rtx, rtx, varray_type));\n static int valid_initial_value_p PROTO((rtx, rtx, int, rtx));\n static void find_mem_givs PROTO((rtx, rtx, int, rtx, rtx));\n@@ -563,7 +563,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   for (i = max_loop_num-1; i >= 0; i--)\n     if (! loop_invalid[i] && loop_number_loop_ends[i])\n       scan_loop (loop_number_loop_starts[i], loop_number_loop_ends[i],\n-\t\t unroll_p, bct_p);\n+\t\t loop_number_loop_cont[i], unroll_p, bct_p);\n \n   /* If debugging and unrolling loops, we must replicate the tree nodes\n      corresponding to the blocks inside the loop, so that the original one\n@@ -608,7 +608,8 @@ next_insn_in_loop (insn, start, end, loop_top)\n \n /* Optimize one loop whose start is LOOP_START and end is END.\n    LOOP_START is the NOTE_INSN_LOOP_BEG and END is the matching\n-   NOTE_INSN_LOOP_END.  */\n+   NOTE_INSN_LOOP_END.\n+   LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */\n \n /* ??? Could also move memory writes out of loops if the destination address\n    is invariant, the source is invariant, the memory write is not volatile,\n@@ -617,8 +618,8 @@ next_insn_in_loop (insn, start, end, loop_top)\n    write, then we can also mark the memory read as invariant.  */\n \n static void\n-scan_loop (loop_start, end, unroll_p, bct_p)\n-     rtx loop_start, end;\n+scan_loop (loop_start, end, loop_cont, unroll_p, bct_p)\n+     rtx loop_start, end, loop_cont;\n      int unroll_p, bct_p;\n {\n   register int i;\n@@ -1165,7 +1166,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n     {\n       the_movables = movables;\n       strength_reduce (scan_start, end, loop_top,\n-\t\t       insn_count, loop_start, end, unroll_p, bct_p);\n+\t\t       insn_count, loop_start, end, loop_cont, unroll_p, bct_p);\n     }\n \n   VARRAY_FREE (set_in_loop);\n@@ -3631,17 +3632,19 @@ static rtx addr_placeholder;\n    SCAN_START is the first instruction in the loop, as the loop would\n    actually be executed.  END is the NOTE_INSN_LOOP_END.  LOOP_TOP is\n    the first instruction in the loop, as it is layed out in the\n-   instruction stream.  LOOP_START is the NOTE_INSN_LOOP_BEG.  */\n+   instruction stream.  LOOP_START is the NOTE_INSN_LOOP_BEG.\n+   LOOP_CONT is the NOTE_INSN_LOOP_CONT.  */\n \n static void\n strength_reduce (scan_start, end, loop_top, insn_count,\n-\t\t loop_start, loop_end, unroll_p, bct_p)\n+\t\t loop_start, loop_end, loop_cont, unroll_p, bct_p)\n      rtx scan_start;\n      rtx end;\n      rtx loop_top;\n      int insn_count;\n      rtx loop_start;\n      rtx loop_end;\n+     rtx loop_cont;\n      int unroll_p, bct_p ATTRIBUTE_UNUSED;\n {\n   rtx p;\n@@ -3834,7 +3837,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t will be executed each iteration.  */\n \n       if (not_every_iteration && GET_CODE (p) == CODE_LABEL\n-\t  && no_labels_between_p (p, loop_end))\n+\t  && no_labels_between_p (p, loop_end)\n+\t  && insn_first_p (p, loop_cont))\n \tnot_every_iteration = 0;\n     }\n \n@@ -4101,8 +4105,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   first_increment_giv = max_reg_num ();\n   for (n_extra_increment = 0, bl = loop_iv_list; bl; bl = bl->next)\n     n_extra_increment += bl->biv_count - 1;\n-  /* XXX Temporary.  */\n-  if (0 && n_extra_increment)\n+  if (n_extra_increment)\n     {\n       int nregs = first_increment_giv + n_extra_increment;\n \n@@ -4391,7 +4394,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t will be executed each iteration.  */\n \n       if (not_every_iteration && GET_CODE (p) == CODE_LABEL\n-\t  && no_labels_between_p (p, loop_end))\n+\t  && no_labels_between_p (p, loop_end)\n+\t  && insn_first_p (p, loop_cont))\n \tnot_every_iteration = 0;\n     }\n \n@@ -4588,8 +4592,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t    }\n \t}\n \n-#if 0\n-      /* XXX Temporary.  */\n       /* Now that we know which givs will be reduced, try to rearrange the\n          combinations to reduce register pressure.\n          recombine_givs calls find_life_end, which needs reg_iv_type and\n@@ -4608,7 +4610,6 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  VARRAY_GROW (reg_iv_info, nregs);\n \t}\n       recombine_givs (bl, loop_start, loop_end, unroll_p);\n-#endif\n \n       /* Reduce each giv that we decided to reduce.  */\n "}]}