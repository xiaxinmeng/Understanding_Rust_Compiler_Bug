{"sha": "7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0ZjQ0Y2Q2MDRiNWU2NTVmY2RmMmE5YzU1NWNkYmNlY2M3ZmMwZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-05-01T12:32:18Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-05-01T12:32:18Z"}, "message": "re PR libfortran/48787 (Invalid UP/DOWN rounding with F editing)\n\n2011-05-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/48787\n\t* io/write_float.def (output_float): Gather up integer declarations and\n\tadd new 'p' for scale factor. Use 'p' in place of the 'dtp' reference\n\teverywhere. For ROUND_UP scan the digit string and only perform\n\trounding if something other than '0' is found.\n\nFrom-SVN: r173231", "tree": {"sha": "2ce3bb586cb57135e6779e6c0bbb3e22e80cfb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce3bb586cb57135e6779e6c0bbb3e22e80cfb83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e/comments", "author": null, "committer": null, "parents": [{"sha": "5a76c853a8dadb7c35bf0ff7d33af554ab603d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a76c853a8dadb7c35bf0ff7d33af554ab603d27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a76c853a8dadb7c35bf0ff7d33af554ab603d27"}], "stats": {"total": 48, "additions": 29, "deletions": 19}, "files": [{"sha": "5b73722581cad2fe4a959f51a129c9cd96d0597c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "patch": "@@ -1,3 +1,11 @@\n+2011-05-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/48787\n+\t* io/write_float.def (output_float): Gather up integer declarations and\n+\tadd new 'p' for scale factor. Use 'p' in place of the 'dtp' reference\n+\teverywhere. For ROUND_UP scan the digit string and only perform\n+\trounding if something other than '0' is found.\n+\n 2011-04-29  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* io/unix.c (min): New macro."}, {"sha": "7f3cedd10349b8ed9f8d8d7be824799e2c2820ab", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=7c4f44cd604b5e655fcdf2a9c555cdbcecc7fc0e", "patch": "@@ -67,11 +67,9 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n {\n   char *out;\n   char *digits;\n-  int e;\n+  int e, w, d, p, i;\n   char expchar, rchar;\n   format_token ft;\n-  int w;\n-  int d;\n   /* Number of digits before the decimal point.  */\n   int nbefore;\n   /* Number of zeros after the decimal point.  */\n@@ -82,12 +80,12 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   int nzero_real;\n   int leadzero;\n   int nblanks;\n-  int i;\n   sign_t sign;\n \n   ft = f->format;\n   w = f->u.real.w;\n   d = f->u.real.d;\n+  p = dtp->u.p.scale_factor;\n \n   rchar = '5';\n   nzero_real = -1;\n@@ -119,14 +117,14 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   switch (ft)\n     {\n     case FMT_F:\n-      if (d == 0 && e <= 0 && dtp->u.p.scale_factor == 0)\n+      if (d == 0 && e <= 0 && p == 0)\n \t{\n \t  memmove (digits + 1, digits, ndigits - 1);\n \t  digits[0] = '0';\n \t  e++;\n \t}\n \n-      nbefore = e + dtp->u.p.scale_factor;\n+      nbefore = e + p;\n       if (nbefore < 0)\n \t{\n \t  nzero = -nbefore;\n@@ -147,34 +145,34 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n     case FMT_E:\n     case FMT_D:\n       i = dtp->u.p.scale_factor;\n-      if (d <= 0 && i == 0)\n+      if (d <= 0 && p == 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Precision not \"\n \t\t\t  \"greater than zero in format specifier 'E' or 'D'\");\n \t  return FAILURE;\n \t}\n-      if (i <= -d || i >= d + 2)\n+      if (p <= -d || p >= d + 2)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_FORMAT, \"Scale factor \"\n \t\t\t  \"out of range in format specifier 'E' or 'D'\");\n \t  return FAILURE;\n \t}\n \n       if (!zero_flag)\n-\te -= i;\n-      if (i < 0)\n+\te -= p;\n+      if (p < 0)\n \t{\n \t  nbefore = 0;\n-\t  nzero = -i;\n-\t  nafter = d + i;\n+\t  nzero = -p;\n+\t  nafter = d + p;\n \t}\n-      else if (i > 0)\n+      else if (p > 0)\n \t{\n-\t  nbefore = i;\n+\t  nbefore = p;\n \t  nzero = 0;\n-\t  nafter = (d - i) + 1;\n+\t  nafter = (d - p) + 1;\n \t}\n-      else /* i == 0 */\n+      else /* p == 0 */\n \t{\n \t  nbefore = 0;\n \t  nzero = 0;\n@@ -233,7 +231,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n \tif (sign_bit)\n \t  goto skip;\n \trchar = '0';\n-\tbreak;\n+\t/* Scan for trailing zeros to see if we really need to round it.  */\n+\tfor(i = nbefore + nafter; i < ndigits; i++)\n+\t  {\n+\t    if (digits[i] != '0')\n+\t      goto do_rnd;\n+\t  }\n+\tgoto skip;\n       case ROUND_DOWN:\n \tif (!sign_bit)\n \t  goto skip;\n@@ -290,8 +294,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   else if (nbefore + nafter < ndigits)\n     {\n       i = ndigits = nbefore + nafter;\n-      if (d == 0 && digits[1] == '0')\n-\tgoto skip;\n       if (digits[i] >= rchar)\n \t{\n \t  /* Propagate the carry.  */"}]}