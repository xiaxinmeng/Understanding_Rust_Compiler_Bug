{"sha": "35648b45723a961faed4eb48ddbbc275ea11a34a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU2NDhiNDU3MjNhOTYxZmFlZDRlYjQ4ZGRiYmMyNzVlYTExYTM0YQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-04-24T14:40:29Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-04-24T14:40:29Z"}, "message": "acinclude.m4 (GLIBCXX_ENABLE_ATOMIC_BUILTINS): Check for set of all used __sync builtins, in two sizes.\n\n2008-04-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* acinclude.m4 (GLIBCXX_ENABLE_ATOMIC_BUILTINS): Check for set of\n\tall used __sync builtins, in two sizes.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* src/atomic.cc: Use  _GLIBCXX_ATOMIC_BUILTINS_1.\n\t* include/ext/atomicity.h: Use  _GLIBCXX_ATOMIC_BUILTINS_4.\n\t* libsupc++/guard.cc: Use  _GLIBCXX_ATOMIC_BUILTINS_4.\n\t* doc/xml/manual/concurrency.xm: Update docs.\n\nFrom-SVN: r134629", "tree": {"sha": "03da5aa428d1a4a4c5e6fb87e04788de9aada685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03da5aa428d1a4a4c5e6fb87e04788de9aada685"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35648b45723a961faed4eb48ddbbc275ea11a34a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35648b45723a961faed4eb48ddbbc275ea11a34a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35648b45723a961faed4eb48ddbbc275ea11a34a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35648b45723a961faed4eb48ddbbc275ea11a34a/comments", "author": null, "committer": null, "parents": [{"sha": "2aa43509aefeccdde7bc02235c8337504da07b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa43509aefeccdde7bc02235c8337504da07b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa43509aefeccdde7bc02235c8337504da07b49"}], "stats": {"total": 229, "additions": 170, "deletions": 59}, "files": [{"sha": "cdf96562862f039cf1d5435a4272678cf24a9959", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -1,3 +1,14 @@\n+2008-04-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_ATOMIC_BUILTINS): Check for set of\n+\tall used __sync builtins, in two sizes.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* src/atomic.cc: Use  _GLIBCXX_ATOMIC_BUILTINS_1.\n+\t* include/ext/atomicity.h: Use  _GLIBCXX_ATOMIC_BUILTINS_4.\n+\t* libsupc++/guard.cc: Use  _GLIBCXX_ATOMIC_BUILTINS_4.\n+\t* doc/xml/manual/concurrency.xm: Update docs.\n+\t\n 2008-04-23  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* config/os/hpux/os_defines.h: Use _GLIBCXX_BEGIN_NAMESPACE,"}, {"sha": "696e51e342958e26b012459d80ac741b7be6019c", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 67, "deletions": 24, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -2129,23 +2129,29 @@ dnl See:\n dnl http://gcc.gnu.org/onlinedocs/gcc/Atomic-Builtins.html#Atomic-Builtins\n dnl\n dnl This checks to see if the host supports the compiler-generated\n-dnl builtins for atomic operations. Note, this is intended to be an\n-dnl all-or-nothing switch, so all the atomic operations that are used\n-dnl should be checked.\n+dnl builtins for atomic operations for various integral sizes. Note, this \n+dnl is intended to be an all-or-nothing switch, so all the atomic operations\n+dnl that are used should be checked.\n dnl\n dnl Note:\n dnl libgomp and libgfortran do this with a link test, instead of an asm test.\n dnl see: CHECK_SYNC_FETCH_AND_ADD\n dnl\n dnl Defines:\n-dnl  _GLIBCXX_ATOMIC_BUILTINS if the compiler on this target supports atomics.\n+dnl  _GLIBCXX_ATOMIC_BUILTINS_1 \n+dnl  _GLIBCXX_ATOMIC_BUILTINS_4\n dnl\n AC_DEFUN([GLIBCXX_ENABLE_ATOMIC_BUILTINS], [\n-  AC_MSG_CHECKING([for atomic builtins])\n   AC_LANG_SAVE\n   AC_LANG_CPLUSPLUS\n+  old_CXXFLAGS=\"$CXXFLAGS\"\n+  \n+  # Compile unoptimized.\n+  CXXFLAGS='-O0 -S'\n+\n+  # Fake what AC_TRY_COMPILE does, without linking as this is\n+  # unnecessary for a builtins test.\n \n-  # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n [#]line __oline__ \"configure\"\n int main()\n@@ -2155,34 +2161,71 @@ int main()\n   atomic_type c1;\n   atomic_type c2;\n   const atomic_type c3(0);\n-  if (__sync_fetch_and_add(&c1, c2) == c3)\n-    {\n-      // Do something.\n-    }\n-   return 0;\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n }\n EOF\n-    old_CXXFLAGS=\"$CXXFLAGS\"\n-    CXXFLAGS='-O0 -S'\n+\n+    AC_MSG_CHECKING([for atomic builtins for int])\n     if AC_TRY_EVAL(ac_compile); then\n-      if grep __sync_fetch_and_add conftest.s >/dev/null 2>&1 ; then\n-        enable_atomic_builtins=no\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsi=no\n       else\n-      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS, 1,\n-        [Define if builtin atomic operations are supported on this host.])\n-        enable_atomic_builtins=yes\n-\tatomicity_dir=cpu/generic/atomicity_builtins\n+      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_4, 1,\n+        [Define if builtin atomic operations for int are supported on this host.])\n+        enable_atomic_builtinsi=yes\n       fi\n     fi\n-    AC_MSG_RESULT($enable_atomic_builtins)\n-    CXXFLAGS=\"$old_CXXFLAGS\"\n+    AC_MSG_RESULT($enable_atomic_builtinsi)\n     rm -f conftest*\n \n-   # Now, if still generic, set to mutex.\n+    cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+int main()\n+{\n+  typedef bool atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    AC_MSG_CHECKING([for atomic builtins for bool])\n+    if AC_TRY_EVAL(ac_compile); then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsb=no\n+      else\n+      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_1, 1,\n+      [Define if builtin atomic operations for bool are supported on this host.])\n+        enable_atomic_builtinsb=yes\n+      fi\n+    fi\n+    AC_MSG_RESULT($enable_atomic_builtinsb)\n+    rm -f conftest*\n+\n+  CXXFLAGS=\"$old_CXXFLAGS\"\n+  AC_LANG_RESTORE\n+\n+  # Set atomicity_dir to builtins if either of above tests pass.\n+  if test $enable_atomic_builtinsi = yes || test $enable_atomic_builtinsb = yes ; then\n+    atomicity_dir=cpu/generic/atomicity_builtins\n+  fi\n+\n+  # If still generic, set to mutex.\n   if test $atomicity_dir = \"cpu/generic\" ; then\n-\tatomicity_dir=cpu/generic/atomicity_mutex\n+    atomicity_dir=cpu/generic/atomicity_mutex\n   fi\n- AC_LANG_RESTORE\n+\n ])\n \n "}, {"sha": "d4eee4482ff676c4c0a679161772c2fbae1967ce", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -740,8 +740,11 @@\n /* Version number of package */\n #undef VERSION\n \n-/* Define if builtin atomic operations are supported on this host. */\n-#undef _GLIBCXX_ATOMIC_BUILTINS\n+/* Define if builtin atomic operations for bool are supported on this host. */\n+#undef _GLIBCXX_ATOMIC_BUILTINS_1\n+\n+/* Define if builtin atomic operations for int are supported on this host. */\n+#undef _GLIBCXX_ATOMIC_BUILTINS_4\n \n /* Define to use concept checking code from the boost libraries. */\n #undef _GLIBCXX_CONCEPT_CHECKS"}, {"sha": "2601fc0841483292729b54e6f8d85c77a20457e4", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -18071,8 +18071,6 @@ _ACEOF\n \n \n \n-  echo \"$as_me:$LINENO: checking for atomic builtins\" >&5\n-echo $ECHO_N \"checking for atomic builtins... $ECHO_C\" >&6\n \n \n   ac_ext=cc\n@@ -18081,59 +18079,112 @@ ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n \n+  old_CXXFLAGS=\"$CXXFLAGS\"\n+\n+  # Compile unoptimized.\n+  CXXFLAGS='-O0 -S'\n+\n+  # Fake what AC_TRY_COMPILE does, without linking as this is\n+  # unnecessary for a builtins test.\n \n-  # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.\n     cat > conftest.$ac_ext << EOF\n-#line 18087 \"configure\"\n+#line 18091 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n   typedef int atomic_type;\n   atomic_type c1;\n   atomic_type c2;\n   const atomic_type c3(0);\n-  if (__sync_fetch_and_add(&c1, c2) == c3)\n-    {\n-      // Do something.\n-    }\n-   return 0;\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n }\n EOF\n-    old_CXXFLAGS=\"$CXXFLAGS\"\n-    CXXFLAGS='-O0 -S'\n+\n+    echo \"$as_me:$LINENO: checking for atomic builtins for int\" >&5\n+echo $ECHO_N \"checking for atomic builtins for int... $ECHO_C\" >&6\n     if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; then\n-      if grep __sync_fetch_and_add conftest.s >/dev/null 2>&1 ; then\n-        enable_atomic_builtins=no\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsi=no\n       else\n \n cat >>confdefs.h <<\\_ACEOF\n-#define _GLIBCXX_ATOMIC_BUILTINS 1\n+#define _GLIBCXX_ATOMIC_BUILTINS_4 1\n _ACEOF\n \n-        enable_atomic_builtins=yes\n-\tatomicity_dir=cpu/generic/atomicity_builtins\n+        enable_atomic_builtinsi=yes\n       fi\n     fi\n-    echo \"$as_me:$LINENO: result: $enable_atomic_builtins\" >&5\n-echo \"${ECHO_T}$enable_atomic_builtins\" >&6\n-    CXXFLAGS=\"$old_CXXFLAGS\"\n+    echo \"$as_me:$LINENO: result: $enable_atomic_builtinsi\" >&5\n+echo \"${ECHO_T}$enable_atomic_builtinsi\" >&6\n     rm -f conftest*\n \n-   # Now, if still generic, set to mutex.\n-  if test $atomicity_dir = \"cpu/generic\" ; then\n-\tatomicity_dir=cpu/generic/atomicity_mutex\n-  fi\n- ac_ext=c\n+    cat > conftest.$ac_ext << EOF\n+#line 18131 \"configure\"\n+int main()\n+{\n+  typedef bool atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    echo \"$as_me:$LINENO: checking for atomic builtins for bool\" >&5\n+echo $ECHO_N \"checking for atomic builtins for bool... $ECHO_C\" >&6\n+    if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsb=no\n+      else\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define _GLIBCXX_ATOMIC_BUILTINS_1 1\n+_ACEOF\n+\n+        enable_atomic_builtinsb=yes\n+      fi\n+    fi\n+    echo \"$as_me:$LINENO: result: $enable_atomic_builtinsb\" >&5\n+echo \"${ECHO_T}$enable_atomic_builtinsb\" >&6\n+    rm -f conftest*\n+\n+  CXXFLAGS=\"$old_CXXFLAGS\"\n+  ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n+  # Set atomicity_dir to builtins if either of above tests pass.\n+  if test $enable_atomic_builtinsi = yes || test $enable_atomic_builtinsb = yes ; then\n+    atomicity_dir=cpu/generic/atomicity_builtins\n+  fi\n+\n+  # If still generic, set to mutex.\n+  if test $atomicity_dir = \"cpu/generic\" ; then\n+    atomicity_dir=cpu/generic/atomicity_mutex\n+  fi\n+\n+\n if test $atomicity_dir = cpu/generic/atomicity_mutex ; then\n   { echo \"$as_me:$LINENO: WARNING: No native atomic operations are provided for this platform.\" >&5\n echo \"$as_me: WARNING: No native atomic operations are provided for this platform.\" >&2;}"}, {"sha": "7efc29568587aa6c9ed0946e21d0a415ca777c27", "filename": "libstdc++-v3/doc/xml/manual/concurrency.xml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconcurrency.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconcurrency.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fconcurrency.xml?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -214,8 +214,11 @@ usage vary depending on the target hardware and the flags used during\n compile.\n </para>\n \n-<para> If builtins are possible, <code>_GLIBCXX_ATOMIC_BUILTINS</code>\n-will be defined.\n+<para> \n+If builtins are possible for bool-sized integral types,\n+<code>_GLIBCXX_ATOMIC_BUILTINS_1</code> will be defined.\n+If builtins are possible for int-sized integral types,\n+<code>_GLIBCXX_ATOMIC_BUILTINS_4</code> will be defined.\n </para>\n \n "}, {"sha": "82f9b0dea94ca09c741407cd955487c66e41a930", "filename": "libstdc++-v3/include/ext/atomicity.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -1,6 +1,6 @@\n // Support for atomic operations -*- C++ -*-\n \n-// Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005, 2006, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -45,7 +45,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   // To abstract locking primitives across all thread policies, use:\n   // __exchange_and_add_dispatch\n   // __atomic_add_dispatch\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS_4\n   static inline _Atomic_word \n   __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n   { return __sync_fetch_and_add(__mem, __val); }"}, {"sha": "312166201fbe0f6df99b0acf991c6125a97570e6", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2002, 2004, 2006 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004, 2006, 2008 Free Software Foundation, Inc.\n //  \n // This file is part of GCC.\n //\n@@ -36,7 +36,7 @@\n #include <ext/atomicity.h>\n #include <ext/concurrence.h>\n #if defined(__GTHREADS) && defined(__GTHREAD_HAS_COND) \\\n-    && defined(_GLIBCXX_ATOMIC_BUILTINS) && defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n+    && defined(_GLIBCXX_ATOMIC_BUILTINS_4) && defined(_GLIBCXX_HAVE_LINUX_FUTEX)\n # include <climits>\n # include <syscall.h>\n # define _GLIBCXX_USE_FUTEX"}, {"sha": "46d3f7698e90eda22bb0c8860635f4426cf10919", "filename": "libstdc++-v3/src/atomic.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35648b45723a961faed4eb48ddbbc275ea11a34a/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc?ref=35648b45723a961faed4eb48ddbbc275ea11a34a", "patch": "@@ -54,7 +54,7 @@ namespace std\n   atomic_flag_test_and_set_explicit(volatile atomic_flag* __a, \n \t\t\t\t    memory_order __x)\n   {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n     if (__x >= memory_order_acq_rel)\n       __sync_synchronize();\n     return __sync_lock_test_and_set(&(__a->_M_base._M_b), 1);\n@@ -72,7 +72,7 @@ namespace std\n   void \n   atomic_flag_clear_explicit(volatile atomic_flag* __a, memory_order __x)\n   {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n     __sync_lock_release(&(__a->_M_base._M_b));\n     if (__x >= memory_order_acq_rel)\n       __sync_synchronize();\n@@ -88,7 +88,7 @@ namespace std\n   void \n   atomic_flag_fence(const volatile atomic_flag*, memory_order)\n   {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n     __sync_synchronize(); \n #endif\n   } "}]}