{"sha": "bd994a48f6820f22dad34d060d2edd266f2d7ea0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5OTRhNDhmNjgyMGYyMmRhZDM0ZDA2MGQyZWRkMjY2ZjJkN2VhMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-03-18T22:35:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-03-18T22:35:39Z"}, "message": "array_type_info.cc: Likewise.\n\n\t* libsupc++/array_type_info.cc: Likewise.\n\t* libsupc++/bad_cast.cc: Likewise.\n\t* libsupc++/bad_typeid.cc: Likewise.\n\t* libsupc++/class_type_info.cc: Likewise.\n\t* libsupc++/dyncast.cc: Likewise.\n\t* libsupc++/enum_type_info.cc: Likewise.\n\t* libsupc++/function_type_info.cc: Likewise.\n\t* libsupc++/fundamental_type_info.cc: Likewise.\n\t* libsupc++/pbase_type_info.cc: Likewise.\n\t* libsupc++/pmem_type_info.cc: Likewise.\n\t* libsupc++/pointer_type_info.cc: Likewise.\n\t* libsupc++/si_class_type_info.cc: Likewise.\n\t* libsupc++/vmi_class_type_info.cc: Likewise.\n\t* libsupc++/tinfo.h: Move inline type_info functions here.\n\t* libsupc++/tinfo.cc: Separate type_info classes into their own\n\tfiles.\n\t* libsupc++/tinfo2.cc: Likewise.\n\t* Makefile.am (sources): Mention new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r123042", "tree": {"sha": "7f028c33262d404f400f12af277dcf03784a187b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f028c33262d404f400f12af277dcf03784a187b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd994a48f6820f22dad34d060d2edd266f2d7ea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd994a48f6820f22dad34d060d2edd266f2d7ea0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd994a48f6820f22dad34d060d2edd266f2d7ea0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd994a48f6820f22dad34d060d2edd266f2d7ea0/comments", "author": null, "committer": null, "parents": [{"sha": "d4f2728ad9bd031f9a3cfcecce0a0536288bdc2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f2728ad9bd031f9a3cfcecce0a0536288bdc2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f2728ad9bd031f9a3cfcecce0a0536288bdc2e"}], "stats": {"total": 2126, "additions": 1307, "deletions": 819}, "files": [{"sha": "1e8093796eb9d170d826c87d394299852db9dfa3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -1,3 +1,25 @@\n+2007-03-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* libsupc++/array_type_info.cc: Likewise.\n+\t* libsupc++/bad_cast.cc: Likewise.\n+\t* libsupc++/bad_typeid.cc: Likewise.\n+\t* libsupc++/class_type_info.cc: Likewise.\n+\t* libsupc++/dyncast.cc: Likewise.\n+\t* libsupc++/enum_type_info.cc: Likewise.\n+\t* libsupc++/function_type_info.cc: Likewise.\n+\t* libsupc++/fundamental_type_info.cc: Likewise.\n+\t* libsupc++/pbase_type_info.cc: Likewise.\n+\t* libsupc++/pmem_type_info.cc: Likewise.\n+\t* libsupc++/pointer_type_info.cc: Likewise.\n+\t* libsupc++/si_class_type_info.cc: Likewise.\n+\t* libsupc++/vmi_class_type_info.cc: Likewise.\n+\t* libsupc++/tinfo.h: Move inline type_info functions here.\n+\t* libsupc++/tinfo.cc: Separate type_info classes into their own\n+\tfiles.\n+\t* libsupc++/tinfo2.cc: Likewise.\n+\t* Makefile.am (sources): Mention new files.\n+\t* Makefile.in: Regenerated.\n+\n 2007-03-16  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/27_io/headers/cinttypes/types_std_c++0x.cc: Use"}, {"sha": "a30115e871317f7d15ef1181cb0b43ce028c815b", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -41,10 +41,15 @@ if GLIBCXX_HOSTED\n endif\n \n sources = \\\n+\tarray_type_info.cc \\\n+\tbad_cast.cc \\\n+\tbad_typeid.cc \\\n+\tclass_type_info.cc \\\n \tdel_op.cc \\\n \tdel_opnt.cc \\\n \tdel_opv.cc \\\n \tdel_opvnt.cc \\\n+\tdyncast.cc \\\n \teh_alloc.cc \\\n \teh_arm.cc \\\n \teh_aux_runtime.cc \\\n@@ -58,16 +63,24 @@ sources = \\\n \teh_throw.cc \\\n \teh_type.cc \\\n \teh_unex_handler.cc \\\n+\tenum_type_info.cc \\\n+\tfunction_type_info.cc \\\n+\tfundamental_type_info.cc \\\n \tguard.cc \\\n \tnew_handler.cc \\\n \tnew_op.cc \\\n \tnew_opnt.cc \\\n \tnew_opv.cc \\\n \tnew_opvnt.cc \\\n+\tpbase_type_info.cc \\\n+\tpmem_type_info.cc \\\n+\tpointer_type_info.cc \\\n \tpure.cc \\\n+\tsi_class_type_info.cc \\\n \ttinfo.cc \\\n \ttinfo2.cc \\\n \tvec.cc \\\n+\tvmi_class_type_info.cc \\\n \tvterminate.cc\n \n libsupc___la_SOURCES = $(sources) $(c_sources)"}, {"sha": "8a27bec7a4f5ff64835cac927175ec8579678bda", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -69,32 +69,46 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libsupc___la_LIBADD =\n-am__libsupc___la_SOURCES_DIST = del_op.cc del_opnt.cc del_opv.cc \\\n-\tdel_opvnt.cc eh_alloc.cc eh_arm.cc eh_aux_runtime.cc \\\n-\teh_call.cc eh_catch.cc eh_exception.cc eh_globals.cc \\\n-\teh_personality.cc eh_term_handler.cc eh_terminate.cc \\\n-\teh_throw.cc eh_type.cc eh_unex_handler.cc guard.cc \\\n-\tnew_handler.cc new_op.cc new_opnt.cc new_opv.cc new_opvnt.cc \\\n-\tpure.cc tinfo.cc tinfo2.cc vec.cc vterminate.cc cp-demangle.c\n-am__objects_1 = del_op.lo del_opnt.lo del_opv.lo del_opvnt.lo \\\n-\teh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \\\n-\teh_exception.lo eh_globals.lo eh_personality.lo \\\n-\teh_term_handler.lo eh_terminate.lo eh_throw.lo eh_type.lo \\\n-\teh_unex_handler.lo guard.lo new_handler.lo new_op.lo \\\n-\tnew_opnt.lo new_opv.lo new_opvnt.lo pure.lo tinfo.lo tinfo2.lo \\\n-\tvec.lo vterminate.lo\n+am__libsupc___la_SOURCES_DIST = array_type_info.cc bad_cast.cc \\\n+\tbad_typeid.cc class_type_info.cc del_op.cc del_opnt.cc \\\n+\tdel_opv.cc del_opvnt.cc dyncast.cc eh_alloc.cc eh_arm.cc \\\n+\teh_aux_runtime.cc eh_call.cc eh_catch.cc eh_exception.cc \\\n+\teh_globals.cc eh_personality.cc eh_term_handler.cc \\\n+\teh_terminate.cc eh_throw.cc eh_type.cc eh_unex_handler.cc \\\n+\tenum_type_info.cc function_type_info.cc \\\n+\tfundamental_type_info.cc guard.cc new_handler.cc new_op.cc \\\n+\tnew_opnt.cc new_opv.cc new_opvnt.cc pbase_type_info.cc \\\n+\tpmem_type_info.cc pointer_type_info.cc pure.cc \\\n+\tsi_class_type_info.cc tinfo.cc tinfo2.cc vec.cc \\\n+\tvmi_class_type_info.cc vterminate.cc cp-demangle.c\n+am__objects_1 = array_type_info.lo bad_cast.lo bad_typeid.lo \\\n+\tclass_type_info.lo del_op.lo del_opnt.lo del_opv.lo \\\n+\tdel_opvnt.lo dyncast.lo eh_alloc.lo eh_arm.lo \\\n+\teh_aux_runtime.lo eh_call.lo eh_catch.lo eh_exception.lo \\\n+\teh_globals.lo eh_personality.lo eh_term_handler.lo \\\n+\teh_terminate.lo eh_throw.lo eh_type.lo eh_unex_handler.lo \\\n+\tenum_type_info.lo function_type_info.lo \\\n+\tfundamental_type_info.lo guard.lo new_handler.lo new_op.lo \\\n+\tnew_opnt.lo new_opv.lo new_opvnt.lo pbase_type_info.lo \\\n+\tpmem_type_info.lo pointer_type_info.lo pure.lo \\\n+\tsi_class_type_info.lo tinfo.lo tinfo2.lo vec.lo \\\n+\tvmi_class_type_info.lo vterminate.lo\n @GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo\n am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)\n libsupc__convenience_la_LIBADD =\n-am__libsupc__convenience_la_SOURCES_DIST = del_op.cc del_opnt.cc \\\n-\tdel_opv.cc del_opvnt.cc eh_alloc.cc eh_arm.cc \\\n-\teh_aux_runtime.cc eh_call.cc eh_catch.cc eh_exception.cc \\\n-\teh_globals.cc eh_personality.cc eh_term_handler.cc \\\n-\teh_terminate.cc eh_throw.cc eh_type.cc eh_unex_handler.cc \\\n-\tguard.cc new_handler.cc new_op.cc new_opnt.cc new_opv.cc \\\n-\tnew_opvnt.cc pure.cc tinfo.cc tinfo2.cc vec.cc vterminate.cc \\\n-\tcp-demangle.c\n+am__libsupc__convenience_la_SOURCES_DIST = array_type_info.cc \\\n+\tbad_cast.cc bad_typeid.cc class_type_info.cc del_op.cc \\\n+\tdel_opnt.cc del_opv.cc del_opvnt.cc dyncast.cc eh_alloc.cc \\\n+\teh_arm.cc eh_aux_runtime.cc eh_call.cc eh_catch.cc \\\n+\teh_exception.cc eh_globals.cc eh_personality.cc \\\n+\teh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \\\n+\teh_unex_handler.cc enum_type_info.cc function_type_info.cc \\\n+\tfundamental_type_info.cc guard.cc new_handler.cc new_op.cc \\\n+\tnew_opnt.cc new_opv.cc new_opvnt.cc pbase_type_info.cc \\\n+\tpmem_type_info.cc pointer_type_info.cc pure.cc \\\n+\tsi_class_type_info.cc tinfo.cc tinfo2.cc vec.cc \\\n+\tvmi_class_type_info.cc vterminate.cc cp-demangle.c\n am_libsupc__convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libsupc__convenience_la_OBJECTS =  \\\n \t$(am_libsupc__convenience_la_OBJECTS)\n@@ -327,10 +341,15 @@ headers = \\\n @GLIBCXX_HOSTED_TRUE@\tcp-demangle.c \n \n sources = \\\n+\tarray_type_info.cc \\\n+\tbad_cast.cc \\\n+\tbad_typeid.cc \\\n+\tclass_type_info.cc \\\n \tdel_op.cc \\\n \tdel_opnt.cc \\\n \tdel_opv.cc \\\n \tdel_opvnt.cc \\\n+\tdyncast.cc \\\n \teh_alloc.cc \\\n \teh_arm.cc \\\n \teh_aux_runtime.cc \\\n@@ -344,16 +363,24 @@ sources = \\\n \teh_throw.cc \\\n \teh_type.cc \\\n \teh_unex_handler.cc \\\n+\tenum_type_info.cc \\\n+\tfunction_type_info.cc \\\n+\tfundamental_type_info.cc \\\n \tguard.cc \\\n \tnew_handler.cc \\\n \tnew_op.cc \\\n \tnew_opnt.cc \\\n \tnew_opv.cc \\\n \tnew_opvnt.cc \\\n+\tpbase_type_info.cc \\\n+\tpmem_type_info.cc \\\n+\tpointer_type_info.cc \\\n \tpure.cc \\\n+\tsi_class_type_info.cc \\\n \ttinfo.cc \\\n \ttinfo2.cc \\\n \tvec.cc \\\n+\tvmi_class_type_info.cc \\\n \tvterminate.cc\n \n libsupc___la_SOURCES = $(sources) $(c_sources)"}, {"sha": "fc334f173a5adfda5929f62a6be5f41ca7e4b00d", "filename": "libstdc++-v3/libsupc++/array_type_info.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Farray_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Farray_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Farray_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__array_type_info::\n+~__array_type_info ()\n+{}\n+\n+}"}, {"sha": "8545b12b4647eadb243eb81316a476c2d4ae28e9", "filename": "libstdc++-v3/libsupc++/bad_cast.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_cast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_cast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_cast.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <typeinfo>\n+\n+namespace std {\n+\n+bad_cast::~bad_cast() throw() { }\n+\n+const char* \n+bad_cast::what() const throw()\n+{\n+  return \"std::bad_cast\";\n+}\n+\n+} // namespace std"}, {"sha": "873a1e1975fb49c9e5006285aa6b5182053775e0", "filename": "libstdc++-v3/libsupc++/bad_typeid.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_typeid.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_typeid.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fbad_typeid.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <typeinfo>\n+\n+namespace std {\n+\n+bad_typeid::~bad_typeid() throw() { }\n+\n+const char* \n+bad_typeid::what() const throw()\n+{\n+  return \"std::bad_typeid\";\n+}\n+\n+} // namespace std"}, {"sha": "21e23737c7958652a66453c1f567fe70b9316543", "filename": "libstdc++-v3/libsupc++/class_type_info.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fclass_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fclass_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fclass_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,116 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__class_type_info::\n+~__class_type_info ()\n+{}\n+\n+bool __class_type_info::\n+__do_catch (const type_info *thr_type,\n+            void **thr_obj,\n+            unsigned outer) const\n+{\n+  if (*this == *thr_type)\n+    return true;\n+  if (outer >= 4)\n+    // Neither `A' nor `A *'.\n+    return false;\n+  return thr_type->__do_upcast (this, thr_obj);\n+}\n+\n+bool __class_type_info::\n+__do_upcast (const __class_type_info *dst_type,\n+             void **obj_ptr) const\n+{\n+  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n+  \n+  __do_upcast (dst_type, *obj_ptr, result);\n+  if (!contained_public_p (result.part2dst))\n+    return false;\n+  *obj_ptr = const_cast <void *> (result.dst_ptr);\n+  return true;\n+}\n+\n+__class_type_info::__sub_kind __class_type_info::\n+__do_find_public_src (ptrdiff_t,\n+                      const void *obj_ptr,\n+                      const __class_type_info *,\n+                      const void *src_ptr) const\n+{\n+  if (src_ptr == obj_ptr)\n+    // Must be our type, as the pointers match.\n+    return __contained_public;\n+  return __not_contained;\n+}\n+\n+bool __class_type_info::\n+__do_dyncast (ptrdiff_t,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n+{\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      result.dst2src = __not_contained;\n+      return false;\n+    }\n+  return false;\n+}\n+\n+bool __class_type_info::\n+__do_upcast (const __class_type_info *dst, const void *obj,\n+             __upcast_result &__restrict result) const\n+{\n+  if (*this == *dst)\n+    {\n+      result.dst_ptr = obj;\n+      result.base_type = nonvirtual_base_type;\n+      result.part2dst = __contained_public;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+}"}, {"sha": "efa53bc0da1a198f4a583a047fe3affdd31cb9a3", "filename": "libstdc++-v3/libsupc++/dyncast.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdyncast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdyncast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdyncast.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+\n+// this is the external interface to the dynamic cast machinery\n+extern \"C\" void *\n+__dynamic_cast (const void *src_ptr,    // object started from\n+                const __class_type_info *src_type, // type of the starting object\n+                const __class_type_info *dst_type, // desired target type\n+                ptrdiff_t src2dst) // how src and dst are related\n+{\n+  const void *vtable = *static_cast <const void *const *> (src_ptr);\n+  const vtable_prefix *prefix =\n+      adjust_pointer <vtable_prefix> (vtable, \n+\t\t\t\t      -offsetof (vtable_prefix, origin));\n+  const void *whole_ptr =\n+      adjust_pointer <void> (src_ptr, prefix->whole_object);\n+  const __class_type_info *whole_type = prefix->whole_type;\n+  __class_type_info::__dyncast_result result;\n+  \n+  whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,\n+                            dst_type, whole_ptr, src_type, src_ptr, result);\n+  if (!result.dst_ptr)\n+    return NULL;\n+  if (contained_public_p (result.dst2src))\n+    // Src is known to be a public base of dst.\n+    return const_cast <void *> (result.dst_ptr);\n+  if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))\n+    // Both src and dst are known to be public bases of whole. Found a valid\n+    // cross cast.\n+    return const_cast <void *> (result.dst_ptr);\n+  if (contained_nonvirtual_p (result.whole2src))\n+    // Src is known to be a non-public nonvirtual base of whole, and not a\n+    // base of dst. Found an invalid cross cast, which cannot also be a down\n+    // cast\n+    return NULL;\n+  if (result.dst2src == __class_type_info::__unknown)\n+    result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,\n+                                                  src_type, src_ptr);\n+  if (contained_public_p (result.dst2src))\n+    // Found a valid down cast\n+    return const_cast <void *> (result.dst_ptr);\n+  // Must be an invalid down cast, or the cross cast wasn't bettered\n+  return NULL;\n+}\n+\n+}"}, {"sha": "a59ef215695387c46cb267c0e53c8fab2877f7aa", "filename": "libstdc++-v3/libsupc++/enum_type_info.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fenum_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fenum_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fenum_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__enum_type_info::\n+~__enum_type_info ()\n+{}\n+\n+}"}, {"sha": "98ffd3fba8addf5e40546f40d7af83c94e3b7292", "filename": "libstdc++-v3/libsupc++/function_type_info.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffunction_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffunction_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffunction_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__function_type_info::\n+~__function_type_info ()\n+{}\n+\n+bool __function_type_info::\n+__is_function_p () const\n+{\n+  return true;\n+}\n+\n+}"}, {"sha": "afa673bb14aae7b42b45cb5022375bff35a3cf5d", "filename": "libstdc++-v3/libsupc++/fundamental_type_info.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffundamental_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffundamental_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ffundamental_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+// This has special meaning to the compiler, and will cause it\n+// to emit the type_info structures for the fundamental types which are\n+// mandated to exist in the runtime.\n+__fundamental_type_info::\n+~__fundamental_type_info ()\n+{}\n+\n+}"}, {"sha": "e0c29b37edb9db75b0a0e6b60999c2300b6e5b63", "filename": "libstdc++-v3/libsupc++/pbase_type_info.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpbase_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__pbase_type_info::\n+~__pbase_type_info ()\n+{}\n+\n+bool __pbase_type_info::\n+__do_catch (const type_info *thr_type,\n+            void **thr_obj,\n+            unsigned outer) const\n+{\n+  if (*this == *thr_type)\n+    return true;      // same type\n+  if (typeid (*this) != typeid (*thr_type))\n+    return false;     // not both same kind of pointers\n+  \n+  if (!(outer & 1))\n+    // We're not the same and our outer pointers are not all const qualified\n+    // Therefore there must at least be a qualification conversion involved\n+    // But for that to be valid, our outer pointers must be const qualified.\n+    return false;\n+  \n+  const __pbase_type_info *thrown_type =\n+    static_cast <const __pbase_type_info *> (thr_type);\n+  \n+  if (thrown_type->__flags & ~__flags)\n+    // We're less qualified.\n+    return false;\n+  \n+  if (!(__flags & __const_mask))\n+    outer &= ~1;\n+  \n+  return __pointer_catch (thrown_type, thr_obj, outer);\n+}\n+\n+}"}, {"sha": "4c494a666e90869a460bbc45f32ba6e8f091ac3c", "filename": "libstdc++-v3/libsupc++/pmem_type_info.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpmem_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpmem_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpmem_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__pointer_to_member_type_info::\n+~__pointer_to_member_type_info ()\n+{}\n+\n+bool __pointer_to_member_type_info::\n+__pointer_catch (const __pbase_type_info *thr_type,\n+                 void **thr_obj,\n+                 unsigned outer) const\n+{\n+  // This static cast is always valid, as our caller will have determined that\n+  // thr_type is really a __pointer_to_member_type_info.\n+  const __pointer_to_member_type_info *thrown_type =\n+    static_cast <const __pointer_to_member_type_info *> (thr_type);\n+  \n+  if (*__context != *thrown_type->__context)\n+    return false;     // not pointers to member of same class\n+  \n+  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n+}\n+\n+}"}, {"sha": "e2b1404cb99fb1a9f43986ccb5811577244f6a8d", "filename": "libstdc++-v3/libsupc++/pointer_type_info.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpointer_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpointer_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fpointer_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__pointer_type_info::\n+~__pointer_type_info ()\n+{}\n+\n+bool __pointer_type_info::\n+__is_pointer_p () const\n+{\n+  return true;\n+}\n+\n+bool __pointer_type_info::\n+__pointer_catch (const __pbase_type_info *thrown_type,\n+                 void **thr_obj,\n+                 unsigned outer) const\n+{\n+  if (outer < 2 && *__pointee == typeid (void))\n+    {\n+      // conversion to void\n+      return !thrown_type->__pointee->__is_function_p ();\n+    }\n+  \n+  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n+}\n+\n+}"}, {"sha": "5bd3db9325814a194b708819e07ae9fcda68d2f1", "filename": "libstdc++-v3/libsupc++/si_class_type_info.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fsi_class_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fsi_class_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fsi_class_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,90 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__si_class_type_info::\n+~__si_class_type_info ()\n+{}\n+\n+__class_type_info::__sub_kind __si_class_type_info::\n+__do_find_public_src (ptrdiff_t src2dst,\n+                      const void *obj_ptr,\n+                      const __class_type_info *src_type,\n+                      const void *src_ptr) const\n+{\n+  if (src_ptr == obj_ptr && *this == *src_type)\n+    return __contained_public;\n+  return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+}\n+\n+bool __si_class_type_info::\n+__do_dyncast (ptrdiff_t src2dst,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n+{\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      if (src2dst >= 0)\n+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+              ? __contained_public : __not_contained;\n+      else if (src2dst == -2)\n+        result.dst2src = __not_contained;\n+      return false;\n+    }\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n+                             src_type, src_ptr, result);\n+}\n+\n+bool __si_class_type_info::\n+__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n+             __upcast_result &__restrict result) const\n+{\n+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n+    return true;\n+  \n+  return __base_type->__do_upcast (dst, obj_ptr, result);\n+}\n+\n+}"}, {"sha": "c40c0d4da0d0d761009e372336c3268b70cb0229", "filename": "libstdc++-v3/libsupc++/tinfo.cc", "status": "modified", "additions": 0, "deletions": 675, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -32,31 +32,11 @@\n #include <bits/c++config.h>\n #include <cstddef>\n #include \"tinfo.h\"\n-#include \"new\"\t\t\t// for placement new\n-\n-// This file contains the minimal working set necessary to link with code\n-// that uses virtual functions and -frtti but does not actually use RTTI\n-// functionality.\n \n std::type_info::\n ~type_info ()\n { }\n \n-std::bad_cast::~bad_cast() throw() { }\n-std::bad_typeid::~bad_typeid() throw() { }\n-\n-const char* \n-std::bad_cast::what() const throw()\n-{\n-  return \"std::bad_cast\";\n-}\n-\n-const char* \n-std::bad_typeid::what() const throw()\n-{\n-  return \"std::bad_typeid\";\n-}\n-\n #if !__GXX_TYPEINFO_EQUALITY_INLINE\n \n // We can't rely on common symbols being shared between shared objects.\n@@ -103,658 +83,3 @@ __do_upcast (const abi::__class_type_info *, void **) const\n }\n \n }\n-\n-namespace {\n-\n-using namespace std;\n-using namespace abi;\n-\n-// Initial part of a vtable, this structure is used with offsetof, so we don't\n-// have to keep alignments consistent manually.\n-struct vtable_prefix \n-{\n-  // Offset to most derived object.\n-  ptrdiff_t whole_object;\n-\n-  // Additional padding if necessary.\n-#ifdef _GLIBCXX_VTABLE_PADDING\n-  ptrdiff_t padding1;               \n-#endif\n-\n-  // Pointer to most derived type_info.\n-  const __class_type_info *whole_type;  \n-\n-  // Additional padding if necessary.\n-#ifdef _GLIBCXX_VTABLE_PADDING\n-  ptrdiff_t padding2;               \n-#endif\n-\n-  // What a class's vptr points to.\n-  const void *origin;               \n-};\n-\n-template <typename T>\n-inline const T *\n-adjust_pointer (const void *base, ptrdiff_t offset)\n-{\n-  return reinterpret_cast <const T *>\n-    (reinterpret_cast <const char *> (base) + offset);\n-}\n-\n-// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n-// using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.\n-inline void const *\n-convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)\n-{\n-  if (is_virtual)\n-    {\n-      const void *vtable = *static_cast <const void *const *> (addr);\n-      \n-      offset = *adjust_pointer<ptrdiff_t> (vtable, offset);\n-    }\n-\n-  return adjust_pointer<void> (addr, offset);\n-}\n-\n-// some predicate functions for __class_type_info::__sub_kind\n-inline bool contained_p (__class_type_info::__sub_kind access_path)\n-{\n-  return access_path >= __class_type_info::__contained_mask;\n-}\n-inline bool public_p (__class_type_info::__sub_kind access_path)\n-{\n-  return access_path & __class_type_info::__contained_public_mask;\n-}\n-inline bool virtual_p (__class_type_info::__sub_kind access_path)\n-{\n-  return (access_path & __class_type_info::__contained_virtual_mask);\n-}\n-inline bool contained_public_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & __class_type_info::__contained_public)\n-          == __class_type_info::__contained_public);\n-}\n-inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & __class_type_info::__contained_public)\n-          == __class_type_info::__contained_mask);\n-}\n-inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)\n-{\n-  return ((access_path & (__class_type_info::__contained_mask\n-                          | __class_type_info::__contained_virtual_mask))\n-          == __class_type_info::__contained_mask);\n-}\n-\n-static const __class_type_info *const nonvirtual_base_type =\n-    static_cast <const __class_type_info *> (0) + 1;\n-\n-} // namespace\n-\n-namespace __cxxabiv1\n-{\n-\n-__class_type_info::\n-~__class_type_info ()\n-{}\n-\n-__si_class_type_info::\n-~__si_class_type_info ()\n-{}\n-\n-__vmi_class_type_info::\n-~__vmi_class_type_info ()\n-{}\n-\n-// __upcast_result is used to hold information during traversal of a class\n-// hierarchy when catch matching.\n-struct __class_type_info::__upcast_result\n-{\n-  const void *dst_ptr;        // pointer to caught object\n-  __sub_kind part2dst;        // path from current base to target\n-  int src_details;            // hints about the source type hierarchy\n-  const __class_type_info *base_type; // where we found the target,\n-                              // if in vbase the __class_type_info of vbase\n-                              // if a non-virtual base then 1\n-                              // else NULL\n-  __upcast_result (int d)\n-    :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)\n-    {}\n-};\n-\n-// __dyncast_result is used to hold information during traversal of a class\n-// hierarchy when dynamic casting.\n-struct __class_type_info::__dyncast_result\n-{\n-  const void *dst_ptr;        // pointer to target object or NULL\n-  __sub_kind whole2dst;       // path from most derived object to target\n-  __sub_kind whole2src;       // path from most derived object to sub object\n-  __sub_kind dst2src;         // path from target to sub object\n-  int whole_details;          // details of the whole class hierarchy\n-  \n-  __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)\n-    :dst_ptr (NULL), whole2dst (__unknown),\n-     whole2src (__unknown), dst2src (__unknown),\n-     whole_details (details_)\n-    {}\n-\n-protected:\n-  __dyncast_result(const __dyncast_result&);\n-  \n-  __dyncast_result&\n-  operator=(const __dyncast_result&);\n-};\n-\n-bool __class_type_info::\n-__do_catch (const type_info *thr_type,\n-            void **thr_obj,\n-            unsigned outer) const\n-{\n-  if (*this == *thr_type)\n-    return true;\n-  if (outer >= 4)\n-    // Neither `A' nor `A *'.\n-    return false;\n-  return thr_type->__do_upcast (this, thr_obj);\n-}\n-\n-bool __class_type_info::\n-__do_upcast (const __class_type_info *dst_type,\n-             void **obj_ptr) const\n-{\n-  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n-  \n-  __do_upcast (dst_type, *obj_ptr, result);\n-  if (!contained_public_p (result.part2dst))\n-    return false;\n-  *obj_ptr = const_cast <void *> (result.dst_ptr);\n-  return true;\n-}\n-\n-inline __class_type_info::__sub_kind __class_type_info::\n-__find_public_src (ptrdiff_t src2dst,\n-                   const void *obj_ptr,\n-                   const __class_type_info *src_type,\n-                   const void *src_ptr) const\n-{\n-  if (src2dst >= 0)\n-    return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-            ? __contained_public : __not_contained;\n-  if (src2dst == -2)\n-    return __not_contained;\n-  return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n-}\n-\n-__class_type_info::__sub_kind __class_type_info::\n-__do_find_public_src (ptrdiff_t,\n-                      const void *obj_ptr,\n-                      const __class_type_info *,\n-                      const void *src_ptr) const\n-{\n-  if (src_ptr == obj_ptr)\n-    // Must be our type, as the pointers match.\n-    return __contained_public;\n-  return __not_contained;\n-}\n-\n-__class_type_info::__sub_kind __si_class_type_info::\n-__do_find_public_src (ptrdiff_t src2dst,\n-                      const void *obj_ptr,\n-                      const __class_type_info *src_type,\n-                      const void *src_ptr) const\n-{\n-  if (src_ptr == obj_ptr && *this == *src_type)\n-    return __contained_public;\n-  return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n-}\n-\n-__class_type_info::__sub_kind __vmi_class_type_info::\n-__do_find_public_src (ptrdiff_t src2dst,\n-                      const void *obj_ptr,\n-                      const __class_type_info *src_type,\n-                      const void *src_ptr) const\n-{\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    return __contained_public;\n-  \n-  for (std::size_t i = __base_count; i--;)\n-    {\n-      if (!__base_info[i].__is_public_p ())\n-        continue; // Not public, can't be here.\n-      \n-      const void *base = obj_ptr;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      \n-      if (is_virtual)\n-        {\n-          if (src2dst == -3)\n-            continue; // Not a virtual base, so can't be here.\n-        }\n-      base = convert_to_base (base, is_virtual, offset);\n-      \n-      __sub_kind base_kind = __base_info[i].__base_type->__do_find_public_src\n-                              (src2dst, base, src_type, src_ptr);\n-      if (contained_p (base_kind))\n-        {\n-          if (is_virtual)\n-            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n-          return base_kind;\n-        }\n-    }\n-  \n-  return __not_contained;\n-}\n-\n-bool __class_type_info::\n-__do_dyncast (ptrdiff_t,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      result.dst2src = __not_contained;\n-      return false;\n-    }\n-  return false;\n-}\n-\n-bool __si_class_type_info::\n-__do_dyncast (ptrdiff_t src2dst,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      if (src2dst >= 0)\n-        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? __contained_public : __not_contained;\n-      else if (src2dst == -2)\n-        result.dst2src = __not_contained;\n-      return false;\n-    }\n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n-                             src_type, src_ptr, result);\n-}\n-\n-// This is a big hairy function. Although the run-time behaviour of\n-// dynamic_cast is simple to describe, it gives rise to some non-obvious\n-// behaviour. We also desire to determine as early as possible any definite\n-// answer we can get. Because it is unknown what the run-time ratio of\n-// succeeding to failing dynamic casts is, we do not know in which direction\n-// to bias any optimizations. To that end we make no particular effort towards\n-// early fail answers or early success answers. Instead we try to minimize\n-// work by filling in things lazily (when we know we need the information),\n-// and opportunisticly take early success or failure results.\n-bool __vmi_class_type_info::\n-__do_dyncast (ptrdiff_t src2dst,\n-              __sub_kind access_path,\n-              const __class_type_info *dst_type,\n-              const void *obj_ptr,\n-              const __class_type_info *src_type,\n-              const void *src_ptr,\n-              __dyncast_result &__restrict result) const\n-{\n-  if (result.whole_details & __flags_unknown_mask)\n-    result.whole_details = __flags;\n-  \n-  if (obj_ptr == src_ptr && *this == *src_type)\n-    {\n-      // The src object we started from. Indicate how we are accessible from\n-      // the most derived object.\n-      result.whole2src = access_path;\n-      return false;\n-    }\n-  if (*this == *dst_type)\n-    {\n-      result.dst_ptr = obj_ptr;\n-      result.whole2dst = access_path;\n-      if (src2dst >= 0)\n-        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? __contained_public : __not_contained;\n-      else if (src2dst == -2)\n-        result.dst2src = __not_contained;\n-      return false;\n-    }\n-\n-  bool result_ambig = false;\n-  for (std::size_t i = __base_count; i--;)\n-    {\n-      __dyncast_result result2 (result.whole_details);\n-      void const *base = obj_ptr;\n-      __sub_kind base_access = access_path;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      \n-      if (is_virtual)\n-        base_access = __sub_kind (base_access | __contained_virtual_mask);\n-      base = convert_to_base (base, is_virtual, offset);\n-\n-      if (!__base_info[i].__is_public_p ())\n-        {\n-          if (src2dst == -2 &&\n-              !(result.whole_details\n-                & (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n-            // The hierarchy has no duplicate bases (which might ambiguate\n-            // things) and where we started is not a public base of what we\n-            // want (so it cannot be a downcast). There is nothing of interest\n-            // hiding in a non-public base.\n-            continue;\n-          base_access = __sub_kind (base_access & ~__contained_public_mask);\n-        }\n-      \n-      bool result2_ambig\n-          = __base_info[i].__base_type->__do_dyncast (src2dst, base_access,\n-                                             dst_type, base,\n-                                             src_type, src_ptr, result2);\n-      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n-      if (result2.dst2src == __contained_public\n-          || result2.dst2src == __contained_ambig)\n-        {\n-          result.dst_ptr = result2.dst_ptr;\n-          result.whole2dst = result2.whole2dst;\n-          result.dst2src = result2.dst2src;\n-          // Found a downcast which can't be bettered or an ambiguous downcast\n-          // which can't be disambiguated\n-          return result2_ambig;\n-        }\n-      \n-      if (!result_ambig && !result.dst_ptr)\n-        {\n-          // Not found anything yet.\n-          result.dst_ptr = result2.dst_ptr;\n-          result.whole2dst = result2.whole2dst;\n-          result_ambig = result2_ambig;\n-          if (result.dst_ptr && result.whole2src != __unknown\n-              && !(__flags & __non_diamond_repeat_mask))\n-            // Found dst and src and we don't have repeated bases.\n-            return result_ambig;\n-        }\n-      else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)\n-        {\n-          // Found at same address, must be via virtual.  Pick the most\n-          // accessible path.\n-          result.whole2dst =\n-              __sub_kind (result.whole2dst | result2.whole2dst);\n-        }\n-      else if ((result.dst_ptr != 0 && result2.dst_ptr != 0)\n-\t       || (result.dst_ptr != 0 && result2_ambig)\n-\t       || (result2.dst_ptr != 0 && result_ambig))\n-        {\n-          // Found two different DST_TYPE bases, or a valid one and a set of\n-          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n-          // contained publicly within one of the non-ambiguous choices. If it\n-          // is in only one, then that's the choice. If it is in both, then\n-          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n-          // but don't yet fail as we might later find a third base which does\n-          // contain SRC_PTR.\n-        \n-          __sub_kind new_sub_kind = result2.dst2src;\n-          __sub_kind old_sub_kind = result.dst2src;\n-          \n-          if (contained_p (result.whole2src)\n-              && (!virtual_p (result.whole2src)\n-                  || !(result.whole_details & __diamond_shaped_mask)))\n-            {\n-              // We already found SRC_PTR as a base of most derived, and\n-              // either it was non-virtual, or the whole hierarchy is\n-              // not-diamond shaped. Therefore if it is in either choice, it\n-              // can only be in one of them, and we will already know.\n-              if (old_sub_kind == __unknown)\n-                old_sub_kind = __not_contained;\n-              if (new_sub_kind == __unknown)\n-                new_sub_kind = __not_contained;\n-            }\n-          else\n-            {\n-              if (old_sub_kind >= __not_contained)\n-                ;// already calculated\n-              else if (contained_p (new_sub_kind)\n-                       && (!virtual_p (new_sub_kind)\n-                           || !(__flags & __diamond_shaped_mask)))\n-                // Already found inside the other choice, and it was\n-                // non-virtual or we are not diamond shaped.\n-                old_sub_kind = __not_contained;\n-              else\n-                old_sub_kind = dst_type->__find_public_src\n-                                (src2dst, result.dst_ptr, src_type, src_ptr);\n-          \n-              if (new_sub_kind >= __not_contained)\n-                ;// already calculated\n-              else if (contained_p (old_sub_kind)\n-                       && (!virtual_p (old_sub_kind)\n-                           || !(__flags & __diamond_shaped_mask)))\n-                // Already found inside the other choice, and it was\n-                // non-virtual or we are not diamond shaped.\n-                new_sub_kind = __not_contained;\n-              else\n-                new_sub_kind = dst_type->__find_public_src\n-                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n-            }\n-          \n-          // Neither sub_kind can be contained_ambig -- we bail out early\n-          // when we find those.\n-          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n-            {\n-              // Only on one choice, not ambiguous.\n-              if (contained_p (new_sub_kind))\n-                {\n-                  // Only in new.\n-                  result.dst_ptr = result2.dst_ptr;\n-                  result.whole2dst = result2.whole2dst;\n-                  result_ambig = false;\n-                  old_sub_kind = new_sub_kind;\n-                }\n-              result.dst2src = old_sub_kind;\n-              if (public_p (result.dst2src))\n-                return false; // Can't be an ambiguating downcast for later discovery.\n-              if (!virtual_p (result.dst2src))\n-                return false; // Found non-virtually can't be bettered\n-            }\n-          else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))\n-            {\n-              // In both.\n-              result.dst_ptr = NULL;\n-              result.dst2src = __contained_ambig;\n-              return true;  // Fail.\n-            }\n-          else\n-            {\n-              // In neither publicly, ambiguous for the moment, but keep\n-              // looking. It is possible that it was private in one or\n-              // both and therefore we should fail, but that's just tough.\n-              result.dst_ptr = NULL;\n-              result.dst2src = __not_contained;\n-              result_ambig = true;\n-            }\n-        }\n-      \n-      if (result.whole2src == __contained_private)\n-        // We found SRC_PTR as a private non-virtual base, therefore all\n-        // cross casts will fail. We have already found a down cast, if\n-        // there is one.\n-        return result_ambig;\n-    }\n-\n-  return result_ambig;\n-}\n-\n-bool __class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj,\n-             __upcast_result &__restrict result) const\n-{\n-  if (*this == *dst)\n-    {\n-      result.dst_ptr = obj;\n-      result.base_type = nonvirtual_base_type;\n-      result.part2dst = __contained_public;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-bool __si_class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n-             __upcast_result &__restrict result) const\n-{\n-  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n-    return true;\n-  \n-  return __base_type->__do_upcast (dst, obj_ptr, result);\n-}\n-\n-bool __vmi_class_type_info::\n-__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n-             __upcast_result &__restrict result) const\n-{\n-  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n-    return true;\n-  \n-  int src_details = result.src_details;\n-  if (src_details & __flags_unknown_mask)\n-    src_details = __flags;\n-  \n-  for (std::size_t i = __base_count; i--;)\n-    {\n-      __upcast_result result2 (src_details);\n-      const void *base = obj_ptr;\n-      ptrdiff_t offset = __base_info[i].__offset ();\n-      bool is_virtual = __base_info[i].__is_virtual_p ();\n-      bool is_public = __base_info[i].__is_public_p ();\n-      \n-      if (!is_public && !(src_details & __non_diamond_repeat_mask))\n-        // original cannot have an ambiguous base, so skip private bases\n-        continue;\n-\n-      if (base)\n-        base = convert_to_base (base, is_virtual, offset);\n-      \n-      if (__base_info[i].__base_type->__do_upcast (dst, base, result2))\n-        {\n-          if (result2.base_type == nonvirtual_base_type && is_virtual)\n-            result2.base_type = __base_info[i].__base_type;\n-          if (contained_p (result2.part2dst) && !is_public)\n-            result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);\n-          \n-          if (!result.base_type)\n-            {\n-              result = result2;\n-              if (!contained_p (result.part2dst))\n-                return true; // found ambiguously\n-              \n-              if (result.part2dst & __contained_public_mask)\n-                {\n-                  if (!(__flags & __non_diamond_repeat_mask))\n-                    return true;  // cannot have an ambiguous other base\n-                }\n-              else\n-                {\n-                  if (!virtual_p (result.part2dst))\n-                    return true; // cannot have another path\n-                  if (!(__flags & __diamond_shaped_mask))\n-                    return true; // cannot have a more accessible path\n-                }\n-            }\n-          else if (result.dst_ptr != result2.dst_ptr)\n-            {\n-              // Found an ambiguity.\n-\t      result.dst_ptr = NULL;\n-\t      result.part2dst = __contained_ambig;\n-\t      return true;\n-            }\n-          else if (result.dst_ptr)\n-            {\n-              // Ok, found real object via a virtual path.\n-              result.part2dst\n-                  = __sub_kind (result.part2dst | result2.part2dst);\n-            }\n-          else\n-            {\n-              // Dealing with a null pointer, need to check vbase\n-              // containing each of the two choices.\n-              if (result2.base_type == nonvirtual_base_type\n-                  || result.base_type == nonvirtual_base_type\n-                  || !(*result2.base_type == *result.base_type))\n-                {\n-                  // Already ambiguous, not virtual or via different virtuals.\n-                  // Cannot match.\n-                  result.part2dst = __contained_ambig;\n-                  return true;\n-                }\n-              result.part2dst\n-                  = __sub_kind (result.part2dst | result2.part2dst);\n-            }\n-        }\n-    }\n-  return result.part2dst != __unknown;\n-}\n-\n-// this is the external interface to the dynamic cast machinery\n-extern \"C\" void *\n-__dynamic_cast (const void *src_ptr,    // object started from\n-                const __class_type_info *src_type, // type of the starting object\n-                const __class_type_info *dst_type, // desired target type\n-                ptrdiff_t src2dst) // how src and dst are related\n-{\n-  const void *vtable = *static_cast <const void *const *> (src_ptr);\n-  const vtable_prefix *prefix =\n-      adjust_pointer <vtable_prefix> (vtable, \n-\t\t\t\t      -offsetof (vtable_prefix, origin));\n-  const void *whole_ptr =\n-      adjust_pointer <void> (src_ptr, prefix->whole_object);\n-  const __class_type_info *whole_type = prefix->whole_type;\n-  __class_type_info::__dyncast_result result;\n-  \n-  whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,\n-                            dst_type, whole_ptr, src_type, src_ptr, result);\n-  if (!result.dst_ptr)\n-    return NULL;\n-  if (contained_public_p (result.dst2src))\n-    // Src is known to be a public base of dst.\n-    return const_cast <void *> (result.dst_ptr);\n-  if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))\n-    // Both src and dst are known to be public bases of whole. Found a valid\n-    // cross cast.\n-    return const_cast <void *> (result.dst_ptr);\n-  if (contained_nonvirtual_p (result.whole2src))\n-    // Src is known to be a non-public nonvirtual base of whole, and not a\n-    // base of dst. Found an invalid cross cast, which cannot also be a down\n-    // cast\n-    return NULL;\n-  if (result.dst2src == __class_type_info::__unknown)\n-    result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,\n-                                                  src_type, src_ptr);\n-  if (contained_public_p (result.dst2src))\n-    // Found a valid down cast\n-    return const_cast <void *> (result.dst_ptr);\n-  // Must be an invalid down cast, or the cross cast wasn't bettered\n-  return NULL;\n-}\n-\n-} // namespace __cxxabiv1"}, {"sha": "f0c9fbfdf3d04b56a2cf8170dd4becbbfdf913c4", "filename": "libstdc++-v3/libsupc++/tinfo.h", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo.h?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -34,3 +34,155 @@\n // Class declarations shared between the typeinfo implementation files.\n \n #include <cxxabi.h>\n+\n+namespace __cxxabiv1 {\n+\n+inline bool __pbase_type_info::\n+__pointer_catch (const __pbase_type_info *thrown_type,\n+                 void **thr_obj,\n+                 unsigned outer) const\n+{\n+  return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);\n+}\n+\n+namespace {\n+\n+using namespace std;\n+using namespace abi;\n+\n+// Initial part of a vtable, this structure is used with offsetof, so we don't\n+// have to keep alignments consistent manually.\n+struct vtable_prefix \n+{\n+  // Offset to most derived object.\n+  ptrdiff_t whole_object;\n+\n+  // Additional padding if necessary.\n+#ifdef _GLIBCXX_VTABLE_PADDING\n+  ptrdiff_t padding1;               \n+#endif\n+\n+  // Pointer to most derived type_info.\n+  const __class_type_info *whole_type;  \n+\n+  // Additional padding if necessary.\n+#ifdef _GLIBCXX_VTABLE_PADDING\n+  ptrdiff_t padding2;               \n+#endif\n+\n+  // What a class's vptr points to.\n+  const void *origin;               \n+};\n+\n+template <typename T>\n+inline const T *\n+adjust_pointer (const void *base, ptrdiff_t offset)\n+{\n+  return reinterpret_cast <const T *>\n+    (reinterpret_cast <const char *> (base) + offset);\n+}\n+\n+// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n+// using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.\n+inline void const *\n+convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)\n+{\n+  if (is_virtual)\n+    {\n+      const void *vtable = *static_cast <const void *const *> (addr);\n+      \n+      offset = *adjust_pointer<ptrdiff_t> (vtable, offset);\n+    }\n+\n+  return adjust_pointer<void> (addr, offset);\n+}\n+\n+// some predicate functions for __class_type_info::__sub_kind\n+inline bool contained_p (__class_type_info::__sub_kind access_path)\n+{\n+  return access_path >= __class_type_info::__contained_mask;\n+}\n+inline bool public_p (__class_type_info::__sub_kind access_path)\n+{\n+  return access_path & __class_type_info::__contained_public_mask;\n+}\n+inline bool virtual_p (__class_type_info::__sub_kind access_path)\n+{\n+  return (access_path & __class_type_info::__contained_virtual_mask);\n+}\n+inline bool contained_public_p (__class_type_info::__sub_kind access_path)\n+{\n+  return ((access_path & __class_type_info::__contained_public)\n+          == __class_type_info::__contained_public);\n+}\n+inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)\n+{\n+  return ((access_path & __class_type_info::__contained_public)\n+          == __class_type_info::__contained_mask);\n+}\n+inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)\n+{\n+  return ((access_path & (__class_type_info::__contained_mask\n+                          | __class_type_info::__contained_virtual_mask))\n+          == __class_type_info::__contained_mask);\n+}\n+\n+static const __class_type_info *const nonvirtual_base_type =\n+    static_cast <const __class_type_info *> (0) + 1;\n+\n+} // namespace\n+\n+// __upcast_result is used to hold information during traversal of a class\n+// hierarchy when catch matching.\n+struct __class_type_info::__upcast_result\n+{\n+  const void *dst_ptr;        // pointer to caught object\n+  __sub_kind part2dst;        // path from current base to target\n+  int src_details;            // hints about the source type hierarchy\n+  const __class_type_info *base_type; // where we found the target,\n+                              // if in vbase the __class_type_info of vbase\n+                              // if a non-virtual base then 1\n+                              // else NULL\n+  __upcast_result (int d)\n+    :dst_ptr (NULL), part2dst (__unknown), src_details (d), base_type (NULL)\n+    {}\n+};\n+\n+// __dyncast_result is used to hold information during traversal of a class\n+// hierarchy when dynamic casting.\n+struct __class_type_info::__dyncast_result\n+{\n+  const void *dst_ptr;        // pointer to target object or NULL\n+  __sub_kind whole2dst;       // path from most derived object to target\n+  __sub_kind whole2src;       // path from most derived object to sub object\n+  __sub_kind dst2src;         // path from target to sub object\n+  int whole_details;          // details of the whole class hierarchy\n+  \n+  __dyncast_result (int details_ = __vmi_class_type_info::__flags_unknown_mask)\n+    :dst_ptr (NULL), whole2dst (__unknown),\n+     whole2src (__unknown), dst2src (__unknown),\n+     whole_details (details_)\n+    {}\n+\n+protected:\n+  __dyncast_result(const __dyncast_result&);\n+  \n+  __dyncast_result&\n+  operator=(const __dyncast_result&);\n+};\n+\n+inline __class_type_info::__sub_kind __class_type_info::\n+__find_public_src (ptrdiff_t src2dst,\n+                   const void *obj_ptr,\n+                   const __class_type_info *src_type,\n+                   const void *src_ptr) const\n+{\n+  if (src2dst >= 0)\n+    return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+            ? __contained_public : __not_contained;\n+  if (src2dst == -2)\n+    return __not_contained;\n+  return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+}\n+\n+}"}, {"sha": "b2ae435c890797523d04bd99d29d4432ba54b757", "filename": "libstdc++-v3/libsupc++/tinfo2.cc", "status": "modified", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Ftinfo2.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -31,10 +31,6 @@\n \n #include <cstddef>\n #include \"tinfo.h\"\n-#include \"new\"\t\t\t// for placement new\n-\n-// We can't rely on having stdlib.h if we're freestanding.\n-extern \"C\" void abort ();\n \n using std::type_info;\n \n@@ -51,121 +47,3 @@ type_info::before (const type_info &arg) const\n }\n \n #endif\n-\n-#include <cxxabi.h>\n-\n-namespace __cxxabiv1 {\n-\n-using namespace std;\n-\n-// This has special meaning to the compiler, and will cause it\n-// to emit the type_info structures for the fundamental types which are\n-// mandated to exist in the runtime.\n-__fundamental_type_info::\n-~__fundamental_type_info ()\n-{}\n-\n-__array_type_info::\n-~__array_type_info ()\n-{}\n-\n-__function_type_info::\n-~__function_type_info ()\n-{}\n-\n-__enum_type_info::\n-~__enum_type_info ()\n-{}\n-\n-__pbase_type_info::\n-~__pbase_type_info ()\n-{}\n-\n-__pointer_type_info::\n-~__pointer_type_info ()\n-{}\n-\n-__pointer_to_member_type_info::\n-~__pointer_to_member_type_info ()\n-{}\n-\n-bool __pointer_type_info::\n-__is_pointer_p () const\n-{\n-  return true;\n-}\n-\n-bool __function_type_info::\n-__is_function_p () const\n-{\n-  return true;\n-}\n-\n-bool __pbase_type_info::\n-__do_catch (const type_info *thr_type,\n-            void **thr_obj,\n-            unsigned outer) const\n-{\n-  if (*this == *thr_type)\n-    return true;      // same type\n-  if (typeid (*this) != typeid (*thr_type))\n-    return false;     // not both same kind of pointers\n-  \n-  if (!(outer & 1))\n-    // We're not the same and our outer pointers are not all const qualified\n-    // Therefore there must at least be a qualification conversion involved\n-    // But for that to be valid, our outer pointers must be const qualified.\n-    return false;\n-  \n-  const __pbase_type_info *thrown_type =\n-    static_cast <const __pbase_type_info *> (thr_type);\n-  \n-  if (thrown_type->__flags & ~__flags)\n-    // We're less qualified.\n-    return false;\n-  \n-  if (!(__flags & __const_mask))\n-    outer &= ~1;\n-  \n-  return __pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-inline bool __pbase_type_info::\n-__pointer_catch (const __pbase_type_info *thrown_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);\n-}\n-\n-bool __pointer_type_info::\n-__pointer_catch (const __pbase_type_info *thrown_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  if (outer < 2 && *__pointee == typeid (void))\n-    {\n-      // conversion to void\n-      return !thrown_type->__pointee->__is_function_p ();\n-    }\n-  \n-  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-bool __pointer_to_member_type_info::\n-__pointer_catch (const __pbase_type_info *thr_type,\n-                 void **thr_obj,\n-                 unsigned outer) const\n-{\n-  // This static cast is always valid, as our caller will have determined that\n-  // thr_type is really a __pointer_to_member_type_info.\n-  const __pointer_to_member_type_info *thrown_type =\n-    static_cast <const __pointer_to_member_type_info *> (thr_type);\n-  \n-  if (*__context != *thrown_type->__context)\n-    return false;     // not pointers to member of same class\n-  \n-  return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n-}\n-\n-} // namespace std"}, {"sha": "f5245d9b63e45b68abadf6aec5afe5b6a216a162", "filename": "libstdc++-v3/libsupc++/vmi_class_type_info.cc", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvmi_class_type_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd994a48f6820f22dad34d060d2edd266f2d7ea0/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvmi_class_type_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fvmi_class_type_info.cc?ref=bd994a48f6820f22dad34d060d2edd266f2d7ea0", "patch": "@@ -0,0 +1,364 @@\n+// Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2007\n+// Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA. \n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline enums from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include \"tinfo.h\"\n+\n+namespace __cxxabiv1 {\n+\n+__vmi_class_type_info::\n+~__vmi_class_type_info ()\n+{}\n+\n+__class_type_info::__sub_kind __vmi_class_type_info::\n+__do_find_public_src (ptrdiff_t src2dst,\n+                      const void *obj_ptr,\n+                      const __class_type_info *src_type,\n+                      const void *src_ptr) const\n+{\n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    return __contained_public;\n+  \n+  for (std::size_t i = __base_count; i--;)\n+    {\n+      if (!__base_info[i].__is_public_p ())\n+        continue; // Not public, can't be here.\n+      \n+      const void *base = obj_ptr;\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n+      \n+      if (is_virtual)\n+        {\n+          if (src2dst == -3)\n+            continue; // Not a virtual base, so can't be here.\n+        }\n+      base = convert_to_base (base, is_virtual, offset);\n+      \n+      __sub_kind base_kind = __base_info[i].__base_type->__do_find_public_src\n+                              (src2dst, base, src_type, src_ptr);\n+      if (contained_p (base_kind))\n+        {\n+          if (is_virtual)\n+            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n+          return base_kind;\n+        }\n+    }\n+  \n+  return __not_contained;\n+}\n+\n+// This is a big hairy function. Although the run-time behaviour of\n+// dynamic_cast is simple to describe, it gives rise to some non-obvious\n+// behaviour. We also desire to determine as early as possible any definite\n+// answer we can get. Because it is unknown what the run-time ratio of\n+// succeeding to failing dynamic casts is, we do not know in which direction\n+// to bias any optimizations. To that end we make no particular effort towards\n+// early fail answers or early success answers. Instead we try to minimize\n+// work by filling in things lazily (when we know we need the information),\n+// and opportunisticly take early success or failure results.\n+bool __vmi_class_type_info::\n+__do_dyncast (ptrdiff_t src2dst,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n+{\n+  if (result.whole_details & __flags_unknown_mask)\n+    result.whole_details = __flags;\n+  \n+  if (obj_ptr == src_ptr && *this == *src_type)\n+    {\n+      // The src object we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2src = access_path;\n+      return false;\n+    }\n+  if (*this == *dst_type)\n+    {\n+      result.dst_ptr = obj_ptr;\n+      result.whole2dst = access_path;\n+      if (src2dst >= 0)\n+        result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n+              ? __contained_public : __not_contained;\n+      else if (src2dst == -2)\n+        result.dst2src = __not_contained;\n+      return false;\n+    }\n+\n+  bool result_ambig = false;\n+  for (std::size_t i = __base_count; i--;)\n+    {\n+      __dyncast_result result2 (result.whole_details);\n+      void const *base = obj_ptr;\n+      __sub_kind base_access = access_path;\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n+      \n+      if (is_virtual)\n+        base_access = __sub_kind (base_access | __contained_virtual_mask);\n+      base = convert_to_base (base, is_virtual, offset);\n+\n+      if (!__base_info[i].__is_public_p ())\n+        {\n+          if (src2dst == -2 &&\n+              !(result.whole_details\n+                & (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n+            // The hierarchy has no duplicate bases (which might ambiguate\n+            // things) and where we started is not a public base of what we\n+            // want (so it cannot be a downcast). There is nothing of interest\n+            // hiding in a non-public base.\n+            continue;\n+          base_access = __sub_kind (base_access & ~__contained_public_mask);\n+        }\n+      \n+      bool result2_ambig\n+          = __base_info[i].__base_type->__do_dyncast (src2dst, base_access,\n+                                             dst_type, base,\n+                                             src_type, src_ptr, result2);\n+      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n+      if (result2.dst2src == __contained_public\n+          || result2.dst2src == __contained_ambig)\n+        {\n+          result.dst_ptr = result2.dst_ptr;\n+          result.whole2dst = result2.whole2dst;\n+          result.dst2src = result2.dst2src;\n+          // Found a downcast which can't be bettered or an ambiguous downcast\n+          // which can't be disambiguated\n+          return result2_ambig;\n+        }\n+      \n+      if (!result_ambig && !result.dst_ptr)\n+        {\n+          // Not found anything yet.\n+          result.dst_ptr = result2.dst_ptr;\n+          result.whole2dst = result2.whole2dst;\n+          result_ambig = result2_ambig;\n+          if (result.dst_ptr && result.whole2src != __unknown\n+              && !(__flags & __non_diamond_repeat_mask))\n+            // Found dst and src and we don't have repeated bases.\n+            return result_ambig;\n+        }\n+      else if (result.dst_ptr && result.dst_ptr == result2.dst_ptr)\n+        {\n+          // Found at same address, must be via virtual.  Pick the most\n+          // accessible path.\n+          result.whole2dst =\n+              __sub_kind (result.whole2dst | result2.whole2dst);\n+        }\n+      else if ((result.dst_ptr != 0 && result2.dst_ptr != 0)\n+\t       || (result.dst_ptr != 0 && result2_ambig)\n+\t       || (result2.dst_ptr != 0 && result_ambig))\n+        {\n+          // Found two different DST_TYPE bases, or a valid one and a set of\n+          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n+          // contained publicly within one of the non-ambiguous choices. If it\n+          // is in only one, then that's the choice. If it is in both, then\n+          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n+          // but don't yet fail as we might later find a third base which does\n+          // contain SRC_PTR.\n+        \n+          __sub_kind new_sub_kind = result2.dst2src;\n+          __sub_kind old_sub_kind = result.dst2src;\n+          \n+          if (contained_p (result.whole2src)\n+              && (!virtual_p (result.whole2src)\n+                  || !(result.whole_details & __diamond_shaped_mask)))\n+            {\n+              // We already found SRC_PTR as a base of most derived, and\n+              // either it was non-virtual, or the whole hierarchy is\n+              // not-diamond shaped. Therefore if it is in either choice, it\n+              // can only be in one of them, and we will already know.\n+              if (old_sub_kind == __unknown)\n+                old_sub_kind = __not_contained;\n+              if (new_sub_kind == __unknown)\n+                new_sub_kind = __not_contained;\n+            }\n+          else\n+            {\n+              if (old_sub_kind >= __not_contained)\n+                ;// already calculated\n+              else if (contained_p (new_sub_kind)\n+                       && (!virtual_p (new_sub_kind)\n+                           || !(__flags & __diamond_shaped_mask)))\n+                // Already found inside the other choice, and it was\n+                // non-virtual or we are not diamond shaped.\n+                old_sub_kind = __not_contained;\n+              else\n+                old_sub_kind = dst_type->__find_public_src\n+                                (src2dst, result.dst_ptr, src_type, src_ptr);\n+          \n+              if (new_sub_kind >= __not_contained)\n+                ;// already calculated\n+              else if (contained_p (old_sub_kind)\n+                       && (!virtual_p (old_sub_kind)\n+                           || !(__flags & __diamond_shaped_mask)))\n+                // Already found inside the other choice, and it was\n+                // non-virtual or we are not diamond shaped.\n+                new_sub_kind = __not_contained;\n+              else\n+                new_sub_kind = dst_type->__find_public_src\n+                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n+            }\n+          \n+          // Neither sub_kind can be contained_ambig -- we bail out early\n+          // when we find those.\n+          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n+            {\n+              // Only on one choice, not ambiguous.\n+              if (contained_p (new_sub_kind))\n+                {\n+                  // Only in new.\n+                  result.dst_ptr = result2.dst_ptr;\n+                  result.whole2dst = result2.whole2dst;\n+                  result_ambig = false;\n+                  old_sub_kind = new_sub_kind;\n+                }\n+              result.dst2src = old_sub_kind;\n+              if (public_p (result.dst2src))\n+                return false; // Can't be an ambiguating downcast for later discovery.\n+              if (!virtual_p (result.dst2src))\n+                return false; // Found non-virtually can't be bettered\n+            }\n+          else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))\n+            {\n+              // In both.\n+              result.dst_ptr = NULL;\n+              result.dst2src = __contained_ambig;\n+              return true;  // Fail.\n+            }\n+          else\n+            {\n+              // In neither publicly, ambiguous for the moment, but keep\n+              // looking. It is possible that it was private in one or\n+              // both and therefore we should fail, but that's just tough.\n+              result.dst_ptr = NULL;\n+              result.dst2src = __not_contained;\n+              result_ambig = true;\n+            }\n+        }\n+      \n+      if (result.whole2src == __contained_private)\n+        // We found SRC_PTR as a private non-virtual base, therefore all\n+        // cross casts will fail. We have already found a down cast, if\n+        // there is one.\n+        return result_ambig;\n+    }\n+\n+  return result_ambig;\n+}\n+\n+bool __vmi_class_type_info::\n+__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n+             __upcast_result &__restrict result) const\n+{\n+  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n+    return true;\n+  \n+  int src_details = result.src_details;\n+  if (src_details & __flags_unknown_mask)\n+    src_details = __flags;\n+  \n+  for (std::size_t i = __base_count; i--;)\n+    {\n+      __upcast_result result2 (src_details);\n+      const void *base = obj_ptr;\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n+      bool is_public = __base_info[i].__is_public_p ();\n+      \n+      if (!is_public && !(src_details & __non_diamond_repeat_mask))\n+        // original cannot have an ambiguous base, so skip private bases\n+        continue;\n+\n+      if (base)\n+        base = convert_to_base (base, is_virtual, offset);\n+      \n+      if (__base_info[i].__base_type->__do_upcast (dst, base, result2))\n+        {\n+          if (result2.base_type == nonvirtual_base_type && is_virtual)\n+            result2.base_type = __base_info[i].__base_type;\n+          if (contained_p (result2.part2dst) && !is_public)\n+            result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);\n+          \n+          if (!result.base_type)\n+            {\n+              result = result2;\n+              if (!contained_p (result.part2dst))\n+                return true; // found ambiguously\n+              \n+              if (result.part2dst & __contained_public_mask)\n+                {\n+                  if (!(__flags & __non_diamond_repeat_mask))\n+                    return true;  // cannot have an ambiguous other base\n+                }\n+              else\n+                {\n+                  if (!virtual_p (result.part2dst))\n+                    return true; // cannot have another path\n+                  if (!(__flags & __diamond_shaped_mask))\n+                    return true; // cannot have a more accessible path\n+                }\n+            }\n+          else if (result.dst_ptr != result2.dst_ptr)\n+            {\n+              // Found an ambiguity.\n+\t      result.dst_ptr = NULL;\n+\t      result.part2dst = __contained_ambig;\n+\t      return true;\n+            }\n+          else if (result.dst_ptr)\n+            {\n+              // Ok, found real object via a virtual path.\n+              result.part2dst\n+                  = __sub_kind (result.part2dst | result2.part2dst);\n+            }\n+          else\n+            {\n+              // Dealing with a null pointer, need to check vbase\n+              // containing each of the two choices.\n+              if (result2.base_type == nonvirtual_base_type\n+                  || result.base_type == nonvirtual_base_type\n+                  || !(*result2.base_type == *result.base_type))\n+                {\n+                  // Already ambiguous, not virtual or via different virtuals.\n+                  // Cannot match.\n+                  result.part2dst = __contained_ambig;\n+                  return true;\n+                }\n+              result.part2dst\n+                  = __sub_kind (result.part2dst | result2.part2dst);\n+            }\n+        }\n+    }\n+  return result.part2dst != __unknown;\n+}\n+\n+}"}]}