{"sha": "c3a2ba10b272fd9581560604284da2a6283bcde0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNhMmJhMTBiMjcyZmQ5NTgxNTYwNjA0Mjg0ZGEyYTYyODNiY2RlMA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-07T14:50:46Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-07T14:50:46Z"}, "message": "d: Merge upstream dmd b0df0e982\n\nAdds a struct ParameterList to encapulate parameter and vararg\ninformation in the front-end.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11226\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd b0df0e982.\n\t* d-builtins.cc (build_frontend_type): Use VarArg for varargs_p.\n\t* d-codegen.cc (declaration_type): Call TypeFunction::create with\n\targument VARARGnone.\n\t(parameter_type): Likewise.\n\t(d_build_call): Use new field names and member functions.\n\t* d-target.cc (Target::cppParameterType): Call TypeFunction::create\n\twith argument VARARGnone.\n\t* types.cc (TypeVisitor::visit (TypeFunction *): Use new field names\n\tand member functions.", "tree": {"sha": "9ecb66c15a440f670f9cfdccbc04c2a6e76f8cef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ecb66c15a440f670f9cfdccbc04c2a6e76f8cef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3a2ba10b272fd9581560604284da2a6283bcde0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a2ba10b272fd9581560604284da2a6283bcde0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3a2ba10b272fd9581560604284da2a6283bcde0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3a2ba10b272fd9581560604284da2a6283bcde0/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aaccde3db39fac7e7f6677ceccc1eadd9c6a424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aaccde3db39fac7e7f6677ceccc1eadd9c6a424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aaccde3db39fac7e7f6677ceccc1eadd9c6a424"}], "stats": {"total": 692, "additions": 369, "deletions": 323}, "files": [{"sha": "33221ea3229c110186d3d52822ffb33fc06ec6e7", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -282,7 +282,7 @@ build_frontend_type (tree type)\n       if (dtype)\n \t{\n \t  tree parms = TYPE_ARG_TYPES (type);\n-\t  int varargs_p = 1;\n+\t  VarArg varargs_p = VARARGvariadic;\n \n \t  Parameters *args = new Parameters;\n \t  args->reserve (list_length (parms));\n@@ -293,7 +293,7 @@ build_frontend_type (tree type)\n \t      tree argtype = TREE_VALUE (parm);\n \t      if (argtype == void_type_node)\n \t\t{\n-\t\t  varargs_p = 0;\n+\t\t  varargs_p = VARARGnone;\n \t\t  break;\n \t\t}\n \n@@ -316,7 +316,7 @@ build_frontend_type (tree type)\n \n \t  /* GCC generic and placeholder built-ins are marked as variadic, yet\n \t     have no named parameters, and so can't be represented in D.  */\n-\t  if (args->length != 0 || !varargs_p)\n+\t  if (args->length != 0 || varargs_p == VARARGnone)\n \t    {\n \t      dtype = TypeFunction::create (args, dtype, varargs_p, LINKc);\n \t      return dtype->addMod (mod);"}, {"sha": "83e757d5a38a46fbc16dee6acf873c2d6ab613ca", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -144,7 +144,8 @@ declaration_type (Declaration *decl)\n   /* Lazy declarations are converted to delegates.  */\n   if (decl->storage_class & STClazy)\n     {\n-      TypeFunction *tf = TypeFunction::create (NULL, decl->type, false, LINKd);\n+      TypeFunction *tf = TypeFunction::create (NULL, decl->type,\n+\t\t\t\t\t       VARARGnone, LINKd);\n       TypeDelegate *t = TypeDelegate::create (tf);\n       return build_ctype (t->merge2 ());\n     }\n@@ -193,7 +194,8 @@ parameter_type (Parameter *arg)\n   /* Lazy parameters are converted to delegates.  */\n   if (arg->storageClass & STClazy)\n     {\n-      TypeFunction *tf = TypeFunction::create (NULL, arg->type, false, LINKd);\n+      TypeFunction *tf = TypeFunction::create (NULL, arg->type,\n+\t\t\t\t\t       VARARGnone, LINKd);\n       TypeDelegate *t = TypeDelegate::create (tf);\n       return build_ctype (t->merge2 ());\n     }\n@@ -1885,9 +1887,9 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t    }\n \t}\n \n-      size_t nparams = Parameter::dim (tf->parameters);\n+      size_t nparams = tf->parameterList.length ();\n       /* if _arguments[] is the first argument.  */\n-      size_t varargs = (tf->linkage == LINKd && tf->varargs == 1);\n+      size_t varargs = tf->isDstyleVariadic ();\n \n       /* Assumes arguments->length <= formal_args->length if (!tf->varargs).  */\n       for (size_t i = 0; i < arguments->length; ++i)\n@@ -1898,7 +1900,7 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t  if (i - varargs < nparams && i >= varargs)\n \t    {\n \t      /* Actual arguments for declared formal arguments.  */\n-\t      Parameter *parg = Parameter::getNth (tf->parameters, i - varargs);\n+\t      Parameter *parg = tf->parameterList[i - varargs];\n \t      targ = convert_for_argument (targ, parg);\n \t    }\n "}, {"sha": "71156e34a9c2e4343837a7465972c1a96df4fe3f", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -368,7 +368,7 @@ TargetCPP::parameterType (Parameter *arg)\n   else if (arg->storageClass & STClazy)\n     {\n       /* Mangle as delegate.  */\n-      Type *td = TypeFunction::create (NULL, t, 0, LINKd);\n+      Type *td = TypeFunction::create (NULL, t, VARARGnone, LINKd);\n       td = TypeDelegate::create (td);\n       t = t->merge2 ();\n     }"}, {"sha": "6ccb79c643bf0f8e887d0d2f55135ccaefce7763", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1,4 +1,4 @@\n-1831b24fffe35fd0e332c194fdf8723ba3c930a5\n+b0df0e982cc44bd09a9061acfc8160f29767334a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "3ec07e2b06825bf96850e9910a2b641110bf0f64", "filename": "gcc/d/dmd/arrayop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Farrayop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Farrayop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -66,7 +66,7 @@ FuncDeclaration *buildArrayOp(Identifier *ident, BinExp *exp, Scope *sc)\n \n     /* Construct the function\n      */\n-    TypeFunction *ftype = new TypeFunction(fparams, exp->e1->type, 0, LINKc, stc);\n+    TypeFunction *ftype = new TypeFunction(ParameterList(fparams), exp->e1->type, LINKc, stc);\n     //printf(\"fd: %s %s\\n\", ident->toChars(), ftype->toChars());\n     FuncDeclaration *fd = new FuncDeclaration(Loc(), Loc(), ident, STCundefined, ftype);\n     fd->fbody = fbody;"}, {"sha": "a704d1397fe8ed617b58afab239b4dde7a97e7d1", "filename": "gcc/d/dmd/clone.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fclone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fclone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -117,11 +117,10 @@ FuncDeclaration *hasIdentityOpAssign(AggregateDeclaration *ad, Scope *sc)\n         {\n             if (f->errors)\n                 return NULL;\n-            int varargs;\n-            Parameters *fparams = f->getParameters(&varargs);\n-            if (fparams->length >= 1)\n+            ParameterList fparams = f->getParameterList();\n+            if (fparams.length())\n             {\n-                Parameter *fparam0 = Parameter::getNth(fparams, 0);\n+                Parameter *fparam0 = fparams[0];\n                 if (fparam0->type->toDsymbol(NULL) != ad)\n                     f = NULL;\n             }\n@@ -246,7 +245,7 @@ FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n \n     Parameters *fparams = new Parameters;\n     fparams->push(new Parameter(STCnodtor, sd->type, Id::p, NULL));\n-    TypeFunction *tf = new TypeFunction(fparams, sd->handleType(), 0, LINKd, stc | STCref);\n+    TypeFunction *tf = new TypeFunction(ParameterList(fparams), sd->handleType(), LINKd, stc | STCref);\n \n     FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), Id::assign, stc, tf);\n     fop->storage_class |= STCinference;\n@@ -505,7 +504,7 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n                  */\n                 Parameters *parameters = new Parameters;\n                 parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL));\n-                tfeqptr = new TypeFunction(parameters, Type::tbool, 0, LINKd);\n+                tfeqptr = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n                 tfeqptr->mod = MODconst;\n                 tfeqptr = (TypeFunction *)tfeqptr->semantic(Loc(), &scx);\n             }\n@@ -534,7 +533,7 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n     Parameters *parameters = new Parameters;\n     parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n     parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL));\n-    TypeFunction *tf = new TypeFunction(parameters, Type::tbool, 0, LINKd);\n+    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n \n     Identifier *id = Id::xopEquals;\n     FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);\n@@ -585,7 +584,7 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n                  */\n                 Parameters *parameters = new Parameters;\n                 parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL));\n-                tfcmpptr = new TypeFunction(parameters, Type::tint32, 0, LINKd);\n+                tfcmpptr = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n                 tfcmpptr->mod = MODconst;\n                 tfcmpptr = (TypeFunction *)tfcmpptr->semantic(Loc(), &scx);\n             }\n@@ -619,7 +618,7 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n     Parameters *parameters = new Parameters;\n     parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n     parameters->push(new Parameter(STCref | STCconst, sd->type, Id::q, NULL));\n-    TypeFunction *tf = new TypeFunction(parameters, Type::tint32, 0, LINKd);\n+    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n \n     Identifier *id = Id::xopCmp;\n     FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);\n@@ -718,7 +717,7 @@ FuncDeclaration *buildXtoHash(StructDeclaration *sd, Scope *sc)\n         static TypeFunction *tftohash;\n         if (!tftohash)\n         {\n-            tftohash = new TypeFunction(NULL, Type::thash_t, 0, LINKd);\n+            tftohash = new TypeFunction(ParameterList(), Type::thash_t, LINKd);\n             tftohash->mod = MODconst;\n             tftohash = (TypeFunction *)tftohash->merge();\n         }\n@@ -740,7 +739,8 @@ FuncDeclaration *buildXtoHash(StructDeclaration *sd, Scope *sc)\n \n     Parameters *parameters = new Parameters();\n     parameters->push(new Parameter(STCref | STCconst, sd->type, Id::p, NULL));\n-    TypeFunction *tf = new TypeFunction(parameters, Type::thash_t, 0, LINKd, STCnothrow | STCtrusted);\n+    TypeFunction *tf = new TypeFunction(ParameterList(parameters), Type::thash_t,\n+                                        LINKd, STCnothrow | STCtrusted);\n \n     Identifier *id = Id::xtoHash;\n     FuncDeclaration *fop = new FuncDeclaration(declLoc, Loc(), id, STCstatic, tf);"}, {"sha": "12fef59d8207312c51c9db282a75b68f77323b2f", "filename": "gcc/d/dmd/cond.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -122,7 +122,7 @@ static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)\n \n static Expression *wrapAndCall(Loc loc, Statement *s)\n {\n-    TypeFunction *tf = new TypeFunction(new Parameters(), NULL, 0, LINKdefault, 0);\n+    TypeFunction *tf = new TypeFunction(ParameterList(), NULL, LINKdefault, 0);\n     FuncLiteralDeclaration *fd = new FuncLiteralDeclaration(loc, loc, tf, TOKreserved, NULL);\n     fd->fbody = s;\n     FuncExp *fe = new FuncExp(loc, fd);"}, {"sha": "ee19bd1932a1551a304708d2ec6e85d6434d6c87", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -657,7 +657,8 @@ class CppMangleVisitor : public Visitor\n         if (tf->linkage == LINKcpp) //Template args accept extern \"C\" symbols with special mangling\n         {\n             assert(tf->ty == Tfunction);\n-            mangleFunctionParameters(tf->parameters, tf->varargs);\n+            mangleFunctionParameters(tf->parameterList.parameters,\n+                                     tf->parameterList.varargs);\n         }\n     }\n \n@@ -982,7 +983,8 @@ class CppMangleVisitor : public Visitor\n         if (t->isref)\n             tn  = tn->referenceTo();\n         tn->accept(this);\n-        mangleFunctionParameters(t->parameters, t->varargs);\n+        mangleFunctionParameters(t->parameterList.parameters,\n+                                 t->parameterList.varargs);\n         buf->writeByte('E');\n         append(t);\n     }"}, {"sha": "ad91a65f6ad1904e9464c33c5a0fedc1452ea4ab", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -838,8 +838,8 @@ MATCH implicitConvTo(Expression *e, Type *t)\n              * and see if we can convert the function argument to the modded type\n              */\n \n-            size_t nparams = Parameter::dim(tf->parameters);\n-            size_t j = (tf->linkage == LINKd && tf->varargs == 1); // if TypeInfoArray was prepended\n+            size_t nparams = tf->parameterList.length();\n+            size_t j = tf->isDstyleVariadic(); // if TypeInfoArray was prepended\n             if (e->e1->op == TOKdotvar)\n             {\n                 /* Treat 'this' as just another function argument\n@@ -855,7 +855,7 @@ MATCH implicitConvTo(Expression *e, Type *t)\n                 Type *targ = earg->type->toBasetype();\n                 if (i - j < nparams)\n                 {\n-                    Parameter *fparam = Parameter::getNth(tf->parameters, i - j);\n+                    Parameter *fparam = tf->parameterList[i - j];\n                     if (fparam->storageClass & STClazy)\n                         return;                 // not sure what to do with this\n                     Type *tparam = fparam->type;\n@@ -1124,15 +1124,15 @@ MATCH implicitConvTo(Expression *e, Type *t)\n \n                 Expressions *args = (fd == e->allocator) ? e->newargs : e->arguments;\n \n-                size_t nparams = Parameter::dim(tf->parameters);\n-                size_t j = (tf->linkage == LINKd && tf->varargs == 1); // if TypeInfoArray was prepended\n+                size_t nparams = tf->parameterList.length();\n+                size_t j = tf->isDstyleVariadic(); // if TypeInfoArray was prepended\n                 for (size_t i = j; i < e->arguments->length; ++i)\n                 {\n                     Expression *earg = (*args)[i];\n                     Type *targ = earg->type->toBasetype();\n                     if (i - j < nparams)\n                     {\n-                        Parameter *fparam = Parameter::getNth(tf->parameters, i - j);\n+                        Parameter *fparam = tf->parameterList[i - j];\n                         if (fparam->storageClass & STClazy)\n                             return;                 // not sure what to do with this\n                         Type *tparam = fparam->type;"}, {"sha": "3d6f6227eb30dacd56a482774109920bf4a5aa1f", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -803,7 +803,7 @@ void ClassDeclaration::semantic(Scope *sc)\n         {\n             //printf(\"Creating default this(){} for class %s\\n\", toChars());\n             TypeFunction *btf = fd->type->toTypeFunction();\n-            TypeFunction *tf = new TypeFunction(NULL, NULL, 0, LINKd, fd->storage_class);\n+            TypeFunction *tf = new TypeFunction(ParameterList(), NULL, LINKd, fd->storage_class);\n             tf->mod = btf->mod;\n             tf->purity = btf->purity;\n             tf->isnothrow = btf->isnothrow;"}, {"sha": "e74106391dc725a2f26e106e7822bd7a894477a0", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -664,7 +664,7 @@ class FuncDeclaration : public Declaration\n     void buildResultVar(Scope *sc, Type *tret);\n     Statement *mergeFrequire(Statement *);\n     Statement *mergeFensure(Statement *, Identifier *oid);\n-    Parameters *getParameters(int *pvarargs);\n+    ParameterList getParameterList();\n \n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, const char *name, StorageClass stc=0);\n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, Identifier *id, StorageClass stc=0);\n@@ -866,9 +866,9 @@ class NewDeclaration : public FuncDeclaration\n {\n public:\n     Parameters *parameters;\n-    int varargs;\n+    VarArg varargs;\n \n-    NewDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *arguments, int varargs);\n+    NewDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *arguments, VarArg varargs);\n     Dsymbol *syntaxCopy(Dsymbol *);\n     void semantic(Scope *sc);\n     const char *kind() const;"}, {"sha": "3aec39372c1acaad91e9f03c70e9a49ad0013555", "filename": "gcc/d/dmd/delegatize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdelegatize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdelegatize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -39,7 +39,7 @@ Expression *toDelegate(Expression *e, Type* t, Scope *sc)\n     //printf(\"Expression::toDelegate(t = %s) %s\\n\", t->toChars(), e->toChars());\n     Loc loc = e->loc;\n \n-    TypeFunction *tf = new TypeFunction(NULL, t, 0, LINKd);\n+    TypeFunction *tf = new TypeFunction(ParameterList(), t, LINKd);\n     if (t->hasWild())\n         tf->mod = MODwild;\n     FuncLiteralDeclaration *fld ="}, {"sha": "6b4a2b73a7f0a80d8c3a4a27ddc81eacf6197a15", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -760,7 +760,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     Type *tb = fd->type->toBasetype();\n     assert(tb->ty == Tfunction);\n     TypeFunction *tf = (TypeFunction *)tb;\n-    if (tf->varargs && arguments &&\n+    if (tf->parameterList.varargs != VARARGnone && arguments &&\n         ((fd->parameters && arguments->length != fd->parameters->length) || (!fd->parameters && arguments->length)))\n     {\n         fd->error(\"C-style variadic functions are not yet implemented in CTFE\");\n@@ -795,7 +795,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     for (size_t i = 0; i < dim; i++)\n     {\n         Expression *earg = (*arguments)[i];\n-        Parameter *fparam = Parameter::getNth(tf->parameters, i);\n+        Parameter *fparam = tf->parameterList[i];\n \n         if (fparam->storageClass & (STCout | STCref))\n         {\n@@ -859,7 +859,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     for (size_t i = 0; i < dim; i++)\n     {\n         Expression *earg = eargs[i];\n-        Parameter *fparam = Parameter::getNth(tf->parameters, i);\n+        Parameter *fparam = tf->parameterList[i];\n         VarDeclaration *v = (*fd->parameters)[i];\n         ctfeStack.push(v);\n \n@@ -6554,7 +6554,7 @@ Expression *interpret_aaApply(UnionExp *pue, InterState *istate, Expression *aa,\n     size_t numParams = fd->parameters->length;\n     assert(numParams == 1 || numParams == 2);\n \n-    Parameter *fparam = Parameter::getNth(((TypeFunction *)fd->type)->parameters, numParams - 1);\n+    Parameter *fparam = ((TypeFunction *)fd->type)->parameterList[numParams - 1];\n     bool wantRefValue = 0 != (fparam->storageClass & (STCout | STCref));\n \n     Expressions args;"}, {"sha": "d6acafee5de034889b4d5375d41d4a9952389693", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -261,9 +261,9 @@ class Mangler : public Visitor\n         }\n \n         // Write argument types\n-        paramsToDecoBuffer(t->parameters);\n+        paramsToDecoBuffer(t->parameterList.parameters);\n         //if (buf->data[buf->offset - 1] == '@') halt();\n-        buf->writeByte('Z' - t->varargs);   // mark end of arg list\n+        buf->writeByte('Z' - t->parameterList.varargs);   // mark end of arg list\n         if (tret != NULL)\n             visitWithMask(tret, 0);\n "}, {"sha": "0738f4202d922be12ab631069857fe5d20a647ee", "filename": "gcc/d/dmd/doc.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -127,7 +127,7 @@ bool isCVariadicParameter(Dsymbols *a, const utf8_t *p, size_t len)\n     for (size_t i = 0; i < a->length; i++)\n     {\n         TypeFunction *tf = isTypeFunction((*a)[i]);\n-        if (tf && tf->varargs == 1 && cmp(\"...\", p, len) == 0)\n+        if (tf && tf->parameterList.varargs == VARARGvariadic && cmp(\"...\", p, len) == 0)\n             return true;\n     }\n     return false;\n@@ -138,11 +138,11 @@ bool isCVariadicParameter(Dsymbols *a, const utf8_t *p, size_t len)\n static Parameter *isFunctionParameter(Dsymbol *s, const utf8_t *p, size_t len)\n {\n     TypeFunction *tf = isTypeFunction(s);\n-    if (tf && tf->parameters)\n+    if (tf && tf->parameterList.parameters)\n     {\n-        for (size_t k = 0; k < tf->parameters->length; k++)\n+        for (size_t k = 0; k < tf->parameterList.parameters->length; k++)\n         {\n-            Parameter *fparam = (*tf->parameters)[k];\n+            Parameter *fparam = (*tf->parameterList.parameters)[k];\n             if (fparam->ident && cmp(fparam->ident->toChars(), p, len) == 0)\n             {\n                 return fparam;\n@@ -1733,7 +1733,8 @@ void ParamSection::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffe\n     TypeFunction *tf = a->length == 1 ? isTypeFunction(s) : NULL;\n     if (tf)\n     {\n-        size_t pcount = (tf->parameters ? tf->parameters->length : 0) + (int)(tf->varargs == 1);\n+        size_t pcount = (tf->parameterList.parameters ? tf->parameterList.parameters->length : 0) +\n+                        (int)(tf->parameterList.varargs == VARARGvariadic);\n         if (pcount != paramcount)\n         {\n             warning(s->loc, \"Ddoc: parameter count mismatch\");"}, {"sha": "f5a99541a678c71173107f95165f39159e81d705", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -45,7 +45,7 @@ FuncDeclaration *search_toString(StructDeclaration *sd)\n         static TypeFunction *tftostring;\n         if (!tftostring)\n         {\n-            tftostring = new TypeFunction(NULL, Type::tstring, 0, LINKd);\n+            tftostring = new TypeFunction(ParameterList(), Type::tstring, LINKd);\n             tftostring = tftostring->merge()->toTypeFunction();\n         }\n "}, {"sha": "34fd621a9f9d133cd92813ccbacd40425c7bbb2b", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -786,16 +786,16 @@ bool TemplateDeclaration::evaluateConstraint(\n \n         scx->parent = fd;\n \n-        Parameters *fparameters = tf->parameters;\n-        int fvarargs = tf->varargs;\n+        Parameters *fparameters = tf->parameterList.parameters;\n+        VarArg fvarargs = tf->parameterList.varargs;\n \n         size_t nfparams = Parameter::dim(fparameters);\n         for (size_t i = 0; i < nfparams; i++)\n         {\n             Parameter *fparam = Parameter::getNth(fparameters, i);\n             fparam->storageClass &= (STCin | STCout | STCref | STClazy | STCfinal | STC_TYPECTOR | STCnodtor);\n             fparam->storageClass |= STCparameter;\n-            if (fvarargs == 2 && i + 1 == nfparams)\n+            if (fvarargs == VARARGtypesafe && i + 1 == nfparams)\n                 fparam->storageClass |= STCvariadic;\n         }\n         for (size_t i = 0; i < fparameters->length; i++)\n@@ -943,8 +943,8 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n             fd->inferRetType = true;\n \n             // Shouldn't run semantic on default arguments and return type.\n-            for (size_t i = 0; i < tf->parameters->length; i++)\n-                (*tf->parameters)[i]->defaultArg = NULL;\n+            for (size_t i = 0; i < tf->parameterList.parameters->length; i++)\n+                (*tf->parameterList.parameters)[i]->defaultArg = NULL;\n             tf->next = NULL;\n \n             // Resolve parameter types and 'auto ref's.\n@@ -1110,8 +1110,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n     size_t fptupindex = IDX_NOTFOUND;\n     MATCH match = MATCHexact;\n     MATCH matchTiargs = MATCHexact;\n-    Parameters *fparameters;            // function parameter list\n-    int fvarargs;                       // function varargs\n+    ParameterList fparameters; // function parameter list\n     unsigned wildmatch = 0;\n     size_t inferStart = 0;\n \n@@ -1200,9 +1199,9 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n         //printf(\"tiargs matchTiargs = %d\\n\", matchTiargs);\n     }\n \n-    fparameters = fd->getParameters(&fvarargs);\n-    nfparams = Parameter::dim(fparameters);     // number of function parameters\n-    nfargs = fargs ? fargs->length : 0;            // number of function arguments\n+    fparameters = fd->getParameterList();\n+    nfparams = fparameters.length();    // number of function parameters\n+    nfargs = fargs ? fargs->length : 0; // number of function arguments\n \n     /* Check for match of function arguments with variadic template\n      * parameter, such as:\n@@ -1235,14 +1234,14 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n              */\n             for (fptupindex = 0; fptupindex < nfparams; fptupindex++)\n             {\n-                Parameter *fparam = (*fparameters)[fptupindex];\n+                Parameter *fparam = (*fparameters.parameters)[fptupindex];\n                 if (fparam->type->ty != Tident)\n                     continue;\n                 TypeIdentifier *tid = (TypeIdentifier *)fparam->type;\n                 if (!tp->ident->equals(tid->ident) || tid->idents.length)\n                     continue;\n \n-                if (fvarargs)           // variadic function doesn't\n+                if (fparameters.varargs != VARARGnone) // variadic function doesn't\n                     goto Lnomatch;      // go with variadic template\n \n                 goto L1;\n@@ -1320,7 +1319,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n     size_t nfargs2 = nfargs;    // nfargs + supplied defaultArgs\n     for (size_t parami = 0; parami < nfparams; parami++)\n     {\n-        Parameter *fparam = Parameter::getNth(fparameters, parami);\n+        Parameter *fparam = fparameters[parami];\n \n         // Apply function parameter storage classes to parameter types\n         Type *prmtype = fparam->type->addStorageClass(fparam->storageClass);\n@@ -1348,7 +1347,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 size_t rem = 0;\n                 for (size_t j = parami + 1; j < nfparams; j++)\n                 {\n-                    Parameter *p = Parameter::getNth(fparameters, j);\n+                    Parameter *p = fparameters[j];\n                     if (!reliesOnTident(p->type, parameters, inferStart))\n                     {\n                         Type *pt = p->type->syntaxCopy()->semantic(fd->loc, paramscope);\n@@ -1432,7 +1431,8 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 for (size_t j = 0; j < tt_dim; j++, ++argi)\n                 {\n                     Parameter *p = (*tt->arguments)[j];\n-                    if (j == tt_dim - 1 && fvarargs == 2 && parami + 1 == nfparams && argi < nfargs)\n+                    if (j == tt_dim - 1 && fparameters.varargs == VARARGtypesafe &&\n+                        parami + 1 == nfparams && argi < nfargs)\n                     {\n                         prmtype = p->type;\n                         goto Lvarargs;\n@@ -1629,7 +1629,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                 }\n             }\n \n-            if (fvarargs == 2 && parami + 1 == nfparams && argi + 1 < nfargs)\n+            if (fparameters.varargs == VARARGtypesafe && parami + 1 == nfparams && argi + 1 < nfargs)\n                 goto Lvarargs;\n \n             unsigned wm = 0;\n@@ -1699,7 +1699,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n         /* The following code for variadic arguments closely\n          * matches TypeFunction::callMatch()\n          */\n-        if (!(fvarargs == 2 && parami + 1 == nfparams))\n+        if (!(fparameters.varargs == VARARGtypesafe && parami + 1 == nfparams))\n             goto Lnomatch;\n \n         /* Check for match with function parameter T...\n@@ -1833,7 +1833,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n         ++argi;\n     }\n     //printf(\"-> argi = %d, nfargs = %d, nfargs2 = %d\\n\", argi, nfargs, nfargs2);\n-    if (argi != nfargs2 && !fvarargs)\n+    if (argi != nfargs2 && fparameters.varargs == VARARGnone)\n         goto Lnomatch;\n     }\n \n@@ -2681,8 +2681,8 @@ FuncDeclaration *TemplateDeclaration::doHeaderInstantiation(\n     Scope *scx = sc2->push();\n \n     // Shouldn't run semantic on default arguments and return type.\n-    for (size_t i = 0; i < tf->parameters->length; i++)\n-        (*tf->parameters)[i]->defaultArg = NULL;\n+    for (size_t i = 0; i < tf->parameterList.parameters->length; i++)\n+        (*tf->parameterList.parameters)[i]->defaultArg = NULL;\n     if (fd->isCtorDeclaration())\n     {\n         // For constructors, emitting return type is necessary for\n@@ -2755,7 +2755,7 @@ const char *TemplateDeclaration::toChars()\n         if (fd && fd->type)\n         {\n             TypeFunction *tf = (TypeFunction *)fd->type;\n-            buf.writestring(parametersTypeToChars(tf->parameters, tf->varargs));\n+            buf.writestring(parametersTypeToChars(tf->parameterList));\n         }\n     }\n \n@@ -3537,20 +3537,20 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             if (tparam && tparam->ty == Tfunction)\n             {\n                 TypeFunction *tp = (TypeFunction *)tparam;\n-                if (t->varargs != tp->varargs ||\n+                if (t->parameterList.varargs != tp->parameterList.varargs ||\n                     t->linkage != tp->linkage)\n                 {\n                     result = MATCHnomatch;\n                     return;\n                 }\n \n-                size_t nfargs = Parameter::dim(t->parameters);\n-                size_t nfparams = Parameter::dim(tp->parameters);\n+                size_t nfargs = t->parameterList.length();\n+                size_t nfparams = tp->parameterList.length();\n \n                 // bug 2579 fix: Apply function parameter storage classes to parameter types\n                 for (size_t i = 0; i < nfparams; i++)\n                 {\n-                    Parameter *fparam = Parameter::getNth(tp->parameters, i);\n+                    Parameter *fparam = tp->parameterList[i];\n                     fparam->type = fparam->type->addStorageClass(fparam->storageClass);\n                     fparam->storageClass &= ~(STC_TYPECTOR | STCin);\n                 }\n@@ -3564,7 +3564,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     /* See if 'A' of the template parameter matches 'A'\n                      * of the type of the last function parameter.\n                      */\n-                    Parameter *fparam = Parameter::getNth(tp->parameters, nfparams - 1);\n+                    Parameter *fparam = tp->parameterList[nfparams - 1];\n                     assert(fparam);\n                     assert(fparam->type);\n                     if (fparam->type->ty != Tident)\n@@ -3605,7 +3605,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                         }\n                         for (size_t i = 0; i < tuple_dim; i++)\n                         {\n-                            Parameter *arg = Parameter::getNth(t->parameters, nfparams - 1 + i);\n+                            Parameter *arg = t->parameterList[nfparams - 1 + i];\n                             if (!arg->type->equals(tup->objects[i]))\n                             {\n                                 result = MATCHnomatch;\n@@ -3620,7 +3620,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                         tup->objects.setDim(tuple_dim);\n                         for (size_t i = 0; i < tuple_dim; i++)\n                         {\n-                            Parameter *arg = Parameter::getNth(t->parameters, nfparams - 1 + i);\n+                            Parameter *arg = t->parameterList[nfparams - 1 + i];\n                             tup->objects[i] = arg->type;\n                         }\n                         (*dedtypes)[tupi] = tup;\n@@ -3638,8 +3638,8 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n             L2:\n                 for (size_t i = 0; i < nfparams; i++)\n                 {\n-                    Parameter *a = Parameter::getNth(t->parameters, i);\n-                    Parameter *ap = Parameter::getNth(tp->parameters, i);\n+                    Parameter *a = t->parameterList[i];\n+                    Parameter *ap = tp->parameterList[i];\n \n                     if (!a->isCovariant(t->isref, ap) ||\n                         !deduceType(a->type, sc, ap->type, parameters, dedtypes))\n@@ -4422,10 +4422,10 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                 TypeFunction *tf = (TypeFunction *)e->fd->type;\n                 //printf(\"\\ttof = %s\\n\", tof->toChars());\n                 //printf(\"\\ttf  = %s\\n\", tf->toChars());\n-                size_t dim = Parameter::dim(tf->parameters);\n+                size_t dim = tf->parameterList.length();\n \n-                if (Parameter::dim(tof->parameters) != dim ||\n-                    tof->varargs != tf->varargs)\n+                if (tof->parameterList.length() != dim ||\n+                    tof->parameterList.varargs != tf->parameterList.varargs)\n                     return;\n \n                 Objects *tiargs = new Objects();\n@@ -4437,15 +4437,15 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     size_t u = 0;\n                     for (; u < dim; u++)\n                     {\n-                        Parameter *p = Parameter::getNth(tf->parameters, u);\n+                        Parameter *p = tf->parameterList[u];\n                         if (p->type->ty == Tident &&\n                             ((TypeIdentifier *)p->type)->ident == tp->ident)\n                         {\n                             break;\n                         }\n                     }\n                     assert(u < dim);\n-                    Parameter *pto = Parameter::getNth(tof->parameters, u);\n+                    Parameter *pto = tof->parameterList[u];\n                     if (!pto)\n                         break;\n                     Type *t = pto->type->syntaxCopy();  // Bugzilla 11774\n@@ -4577,10 +4577,10 @@ bool reliesOnTident(Type *t, TemplateParameters *tparams, size_t iStart)\n \n         void visit(TypeFunction *t)\n         {\n-            size_t dim = Parameter::dim(t->parameters);\n+            size_t dim = t->parameterList.length();\n             for (size_t i = 0; i < dim; i++)\n             {\n-                Parameter *fparam = Parameter::getNth(t->parameters, i);\n+                Parameter *fparam = t->parameterList[i];\n                 fparam->type->accept(this);\n                 if (result)\n                     return;\n@@ -7182,7 +7182,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n          */\n         //printf(\"tp = %p, td->parameters->length = %d, tiargs->length = %d\\n\", tp, td->parameters->length, ti->tiargs->length);\n         TypeFunction *tf = (TypeFunction *)fd->type;\n-        if (size_t dim = Parameter::dim(tf->parameters))\n+        if (size_t dim = tf->parameterList.length())\n         {\n             TemplateParameter *tp = td->isVariadic();\n             if (tp && td->parameters->length > 1)\n@@ -7201,7 +7201,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n             for (size_t i = 0; i < dim; i++)\n             {\n                 // 'auto ref' needs inference.\n-                if (Parameter::getNth(tf->parameters, i)->storageClass & STCauto)\n+                if (tf->parameterList[i]->storageClass & STCauto)\n                     return 1;\n             }\n         }\n@@ -7904,11 +7904,11 @@ int TemplateInstance::compare(RootObject *o)\n     {\n         if (!fd->errors)\n         {\n-            Parameters *fparameters = fd->getParameters(NULL);\n-            size_t nfparams = Parameter::dim(fparameters);   // Num function parameters\n+            ParameterList fparameters = fd->getParameterList();\n+            size_t nfparams = fparameters.length();   // Num function parameters\n             for (size_t j = 0; j < nfparams; j++)\n             {\n-                Parameter *fparam = Parameter::getNth(fparameters, j);\n+                Parameter *fparam = fparameters[j];\n                 if (fparam->storageClass & STCautoref)       // if \"auto ref\"\n                 {\n                     if (!fargs)"}, {"sha": "b3fccd9ef467f75e1c04c19ee123cf833d41ca90", "filename": "gcc/d/dmd/escape.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -707,12 +707,12 @@ static void inferReturn(FuncDeclaration *fd, VarDeclaration *v)\n     else\n     {\n         // Perform 'return' inference on parameter\n-        if (tf->ty == Tfunction && tf->parameters)\n+        if (tf->ty == Tfunction)\n         {\n-            const size_t dim = Parameter::dim(tf->parameters);\n+            const size_t dim = tf->parameterList.length();\n             for (size_t i = 0; i < dim; i++)\n             {\n-                Parameter *p = Parameter::getNth(tf->parameters, i);\n+                Parameter *p = tf->parameterList[i];\n                 if (p->ident == v->ident)\n                 {\n                     p->storageClass |= STCreturn;\n@@ -950,14 +950,14 @@ static void escapeByValue(Expression *e, EscapeByResults *er)\n                 /* j=1 if _arguments[] is first argument,\n                  * skip it because it is not passed by ref\n                  */\n-                size_t j = (tf->linkage == LINKd && tf->varargs == 1);\n+                size_t j = tf->isDstyleVariadic();\n                 for (size_t i = j; i < e->arguments->length; ++i)\n                 {\n                     Expression *arg = (*e->arguments)[i];\n-                    size_t nparams = Parameter::dim(tf->parameters);\n+                    size_t nparams = tf->parameterList.length();\n                     if (i - j < nparams && i >= j)\n                     {\n-                        Parameter *p = Parameter::getNth(tf->parameters, i - j);\n+                        Parameter *p = tf->parameterList[i - j];\n                         const StorageClass stc = tf->parameterStorageClass(p);\n                         if ((stc & (STCscope)) && (stc & STCreturn))\n                             arg->accept(this);\n@@ -1146,15 +1146,15 @@ static void escapeByRef(Expression *e, EscapeByResults *er)\n                     /* j=1 if _arguments[] is first argument,\n                      * skip it because it is not passed by ref\n                      */\n-                    size_t j = (tf->linkage == LINKd && tf->varargs == 1);\n+                    size_t j = tf->isDstyleVariadic();\n \n                     for (size_t i = j; i < e->arguments->length; ++i)\n                     {\n                         Expression *arg = (*e->arguments)[i];\n-                        size_t nparams = Parameter::dim(tf->parameters);\n+                        size_t nparams = tf->parameterList.length();\n                         if (i - j < nparams && i >= j)\n                         {\n-                            Parameter *p = Parameter::getNth(tf->parameters, i - j);\n+                            Parameter *p = tf->parameterList[i - j];\n                             const StorageClass stc = tf->parameterStorageClass(p);\n                             if ((stc & (STCout | STCref)) && (stc & STCreturn))\n                                 arg->accept(this);"}, {"sha": "ca4a6e97d21d5b5b0992fd841b868b9e96fa4381", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1385,14 +1385,14 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n     assert(arguments);\n     assert(fd || tf->next);\n     size_t nargs = arguments ? arguments->length : 0;\n-    size_t nparams = Parameter::dim(tf->parameters);\n+    size_t nparams = tf->parameterList.length();\n     unsigned olderrors = global.errors;\n     bool err = false;\n     *prettype = Type::terror;\n     Expression *eprefix = NULL;\n     *peprefix = NULL;\n \n-    if (nargs > nparams && tf->varargs == 0)\n+    if (nargs > nparams && tf->parameterList.varargs == VARARGnone)\n     {\n         error(loc, \"expected %llu arguments, not %llu for non-variadic function type %s\", (ulonglong)nparams, (ulonglong)nargs, tf->toChars());\n         return true;\n@@ -1446,13 +1446,13 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n \n         if (i < nparams)\n         {\n-            Parameter *p = Parameter::getNth(tf->parameters, i);\n+            Parameter *p = tf->parameterList[i];\n \n             if (!arg)\n             {\n                 if (!p->defaultArg)\n                 {\n-                    if (tf->varargs == 2 && i + 1 == nparams)\n+                    if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n                         goto L2;\n                     error(loc, \"expected %llu function arguments, not %llu\", (ulonglong)nparams, (ulonglong)nargs);\n                     return true;\n@@ -1465,7 +1465,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                 nargs++;\n             }\n \n-            if (tf->varargs == 2 && i + 1 == nparams)\n+            if (tf->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n             {\n                 //printf(\"\\t\\tvarargs == 2, p->type = '%s'\\n\", p->type->toChars());\n                 {\n@@ -1620,7 +1620,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n         assert(arg);\n         if (i < nparams)\n         {\n-            Parameter *p = Parameter::getNth(tf->parameters, i);\n+            Parameter *p = tf->parameterList[i];\n \n             if (!(p->storageClass & STClazy && p->type->ty == Tvoid))\n             {\n@@ -1733,7 +1733,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                         break;\n                 }\n \n-                if (tf->varargs == 1)\n+                if (tf->parameterList.varargs == VARARGvariadic)\n                 {\n                     const char *p = tf->linkage == LINKc ? \"extern(C)\" : \"extern(C++)\";\n                     if (arg->type->ty == Tarray)\n@@ -1823,7 +1823,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                 lastthrow = i;\n             if (firstdtor == -1 && arg->type->needsDestruction())\n             {\n-                Parameter *p = (i >= (ptrdiff_t)nparams ? NULL : Parameter::getNth(tf->parameters, i));\n+                Parameter *p = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n                 if (!(p && (p->storageClass & (STClazy | STCref | STCout))))\n                     firstdtor = i;\n             }\n@@ -1853,7 +1853,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n         {\n             Expression *arg = (*arguments)[i];\n \n-            Parameter *parameter = (i >= (ptrdiff_t)nparams ? NULL : Parameter::getNth(tf->parameters, i));\n+            Parameter *parameter = (i >= (ptrdiff_t)nparams ? NULL : tf->parameterList[i]);\n             const bool isRef = (parameter && (parameter->storageClass & (STCref | STCout)));\n             const bool isLazy = (parameter && (parameter->storageClass & STClazy));\n \n@@ -1945,7 +1945,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n     //if (eprefix) printf(\"eprefix: %s\\n\", eprefix->toChars());\n \n     // If D linkage and variadic, add _arguments[] as first argument\n-    if (tf->linkage == LINKd && tf->varargs == 1)\n+    if (tf->isDstyleVariadic())\n     {\n         assert(arguments->length >= nparams);\n \n@@ -4678,10 +4678,10 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n         TypeFunction *tf = (TypeFunction *)fd->type;\n         //printf(\"\\ttof = %s\\n\", tof->toChars());\n         //printf(\"\\ttf  = %s\\n\", tf->toChars());\n-        size_t dim = Parameter::dim(tf->parameters);\n+        size_t dim = tf->parameterList.length();\n \n-        if (Parameter::dim(tof->parameters) != dim ||\n-            tof->varargs != tf->varargs)\n+        if (tof->parameterList.length() != dim ||\n+            tof->parameterList.varargs != tf->parameterList.varargs)\n             goto L1;\n \n         Objects *tiargs = new Objects();\n@@ -4693,15 +4693,15 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n             size_t u = 0;\n             for (; u < dim; u++)\n             {\n-                Parameter *p = Parameter::getNth(tf->parameters, u);\n+                Parameter *p = tf->parameterList[u];\n                 if (p->type->ty == Tident &&\n                     ((TypeIdentifier *)p->type)->ident == tp->ident)\n                 {\n                     break;\n                 }\n             }\n             assert(u < dim);\n-            Parameter *pto = Parameter::getNth(tof->parameters, u);\n+            Parameter *pto = tof->parameterList[u];\n             Type *t = pto->type;\n             if (t->ty == Terror)\n                 goto L1;\n@@ -4745,7 +4745,7 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n          */\n         convertMatch = true;\n \n-        TypeFunction *tfy = new TypeFunction(tfx->parameters, tof->next, tfx->varargs, tfx->linkage, STCundefined);\n+        TypeFunction *tfy = new TypeFunction(tfx->parameterList, tof->next, tfx->linkage, STCundefined);\n         tfy->mod = tfx->mod;\n         tfy->isnothrow  = tfx->isnothrow;\n         tfy->isnogc     = tfx->isnogc;"}, {"sha": "9112b7bc307ca6992cae3d696abc5460b7e6e64a", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1653,16 +1653,16 @@ class ExpressionSemanticVisitor : public Visitor\n             exp->td->semantic(sc);\n \n             TypeFunction *tfl = (TypeFunction *)exp->fd->type;\n-            size_t dim = Parameter::dim(tfl->parameters);\n+            size_t dim = tfl->parameterList.length();\n             if (arguments->length < dim)\n             {   // Default arguments are always typed, so they don't need inference.\n-                Parameter *p = Parameter::getNth(tfl->parameters, arguments->length);\n+                Parameter *p = tfl->parameterList[arguments->length];\n                 if (p->defaultArg)\n                     dim = arguments->length;\n             }\n \n-            if ((!tfl->varargs && arguments->length == dim) ||\n-                ( tfl->varargs && arguments->length >= dim))\n+            if ((tfl->parameterList.varargs == VARARGnone && arguments->length == dim) ||\n+                (tfl->parameterList.varargs != VARARGnone && arguments->length >= dim))\n             {\n                 Objects *tiargs = new Objects();\n                 tiargs->reserve(exp->td->parameters->length);\n@@ -1671,7 +1671,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 {\n                     TemplateParameter *tp = (*exp->td->parameters)[i];\n                     for (size_t u = 0; u < dim; u++)\n-                    {   Parameter *p = Parameter::getNth(tfl->parameters, u);\n+                    {   Parameter *p = tfl->parameterList[u];\n                         if (p->type->ty == Tident &&\n                             ((TypeIdentifier *)p->type)->ident == tp->ident)\n                         {   Expression *e = (*arguments)[u];\n@@ -2025,13 +2025,13 @@ class ExpressionSemanticVisitor : public Visitor\n                         /* Generate tuple from function parameter types.\n                         */\n                         assert(tded->ty == Tfunction);\n-                        Parameters *params = ((TypeFunction *)tded)->parameters;\n-                        size_t dim = Parameter::dim(params);\n+                        TypeFunction *tdedf = (TypeFunction *)tded;\n+                        size_t dim = tdedf->parameterList.length();\n                         Parameters *args = new Parameters;\n                         args->reserve(dim);\n                         for (size_t i = 0; i < dim; i++)\n                         {\n-                            Parameter *arg = Parameter::getNth(params, i);\n+                            Parameter *arg = tdedf->parameterList[i];\n                             assert(arg && arg->type);\n                             /* If one of the default arguments was an error,\n                                don't return an invalid tuple\n@@ -2911,7 +2911,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     // lazy paramaters can be called without violating purity and safety\n                     Type *tw = ve->var->type;\n                     Type *tc = ve->var->type->substWildTo(MODconst);\n-                    TypeFunction *tf = new TypeFunction(NULL, tc, 0, LINKd, STCsafe | STCpure);\n+                    TypeFunction *tf = new TypeFunction(ParameterList(), tc, LINKd, STCsafe | STCpure);\n                     (tf = (TypeFunction *)tf->semantic(exp->loc, sc))->next = tw;    // hack for bug7757\n                     TypeDelegate *t = new TypeDelegate(tf);\n                     ve->type = t->semantic(exp->loc, sc);\n@@ -3419,7 +3419,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n                 //printf(\"tf = %s, args = %s\\n\", tf->deco, (*exp->arguments)[0]->type->deco);\n                 ::error(exp->loc, \"%s %s %s is not callable using argument types %s\",\n-                        p, exp->e1->toChars(), parametersTypeToChars(tf->parameters, tf->varargs),\n+                        p, exp->e1->toChars(), parametersTypeToChars(tf->parameterList),\n                         buf.peekString());\n \n                 return setError();\n@@ -3492,7 +3492,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n                     //printf(\"tf = %s, args = %s\\n\", tf->deco, (*exp->arguments)[0]->type->deco);\n                     ::error(exp->loc, \"%s %s is not callable using argument types %s\",\n-                            exp->e1->toChars(), parametersTypeToChars(tf->parameters, tf->varargs),\n+                            exp->e1->toChars(), parametersTypeToChars(tf->parameterList),\n                             buf.peekString());\n \n                     exp->f = NULL;"}, {"sha": "aa09f3e7f650c42f1fba9b396a26f18edbfe92f2", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1287,7 +1287,7 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n          *   __require();\n          */\n         Loc loc = fdx->frequire->loc;\n-        TypeFunction *tf = new TypeFunction(NULL, Type::tvoid, 0, LINKd);\n+        TypeFunction *tf = new TypeFunction(ParameterList(), Type::tvoid, LINKd);\n         tf->isnothrow = f->isnothrow;\n         tf->isnogc = f->isnogc;\n         tf->purity = f->purity;\n@@ -1320,7 +1320,7 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n             p = new Parameter(STCref | STCconst, f->nextOf(), fdx->outId, NULL);\n             fparams->push(p);\n         }\n-        TypeFunction *tf = new TypeFunction(fparams, Type::tvoid, 0, LINKd);\n+        TypeFunction *tf = new TypeFunction(ParameterList(fparams), Type::tvoid, LINKd);\n         tf->isnothrow = f->isnothrow;\n         tf->isnogc = f->isnogc;\n         tf->purity = f->purity;\n@@ -1519,7 +1519,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n         //if (vthis) printf(\"\\tvthis->type = %s\\n\", vthis->type->toChars());\n \n         // Declare hidden variable _arguments[] and _argptr\n-        if (f->varargs == 1)\n+        if (f->parameterList.varargs == VARARGvariadic)\n         {\n             if (f->linkage == LINKd)\n             {\n@@ -1550,7 +1550,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 sc2->insert(_arguments);\n                 _arguments->parent = this;\n             }\n-            if (f->linkage == LINKd || (f->parameters && Parameter::dim(f->parameters)))\n+            if (f->linkage == LINKd || f->parameterList.length())\n             {\n                 // Declare _argptr\n                 Type *t = target.va_listType(loc, sc);\n@@ -1565,7 +1565,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n         /* Declare all the function parameters as variables\n          * and install them in parameters[]\n          */\n-        size_t nparams = Parameter::dim(f->parameters);\n+        size_t nparams = f->parameterList.length();\n         if (nparams)\n         {\n             /* parameters[] has all the tuples removed, as the back end\n@@ -1575,7 +1575,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n             parameters->reserve(nparams);\n             for (size_t i = 0; i < nparams; i++)\n             {\n-                Parameter *fparam = Parameter::getNth(f->parameters, i);\n+                Parameter *fparam = f->parameterList[i];\n                 Identifier *id = fparam->ident;\n                 StorageClass stc = 0;\n                 if (!id)\n@@ -1590,7 +1590,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 VarDeclaration *v = new VarDeclaration(loc, vtype, id, NULL);\n                 //printf(\"declaring parameter %s of type %s\\n\", v->toChars(), v->type->toChars());\n                 stc |= STCparameter;\n-                if (f->varargs == 2 && i + 1 == nparams)\n+                if (f->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n                     stc |= STCvariadic;\n                 if (flags & FUNCFLAGinferScope && !(fparam->storageClass & STCscope))\n                     stc |= STCmaybescope;\n@@ -1608,11 +1608,11 @@ void FuncDeclaration::semantic3(Scope *sc)\n \n         // Declare the tuple symbols and put them in the symbol table,\n         // but not in parameters[].\n-        if (f->parameters)\n+        if (f->parameterList.parameters)\n         {\n-            for (size_t i = 0; i < f->parameters->length; i++)\n+            for (size_t i = 0; i < f->parameterList.parameters->length; i++)\n             {\n-                Parameter *fparam = (*f->parameters)[i];\n+                Parameter *fparam = (*f->parameterList.parameters)[i];\n \n                 if (!fparam->ident)\n                     continue;                   // never used, so ignore\n@@ -2313,15 +2313,15 @@ void FuncDeclaration::semantic3(Scope *sc)\n     // Infer STCscope\n     if (parameters)\n     {\n-        size_t nfparams = Parameter::dim(f->parameters);\n+        size_t nfparams = f->parameterList.length();\n         assert(nfparams == parameters->length);\n         for (size_t u = 0; u < parameters->length; u++)\n         {\n             VarDeclaration *v = (*parameters)[u];\n             if (v->storage_class & STCmaybescope)\n             {\n                 //printf(\"Inferring scope for %s\\n\", v->toChars());\n-                Parameter *p = Parameter::getNth(f->parameters, u);\n+                Parameter *p = f->parameterList[u];\n                 v->storage_class &= ~STCmaybescope;\n                 v->storage_class |= STCscope | STCscopeinferred;\n                 p->storageClass |= STCscope | STCscopeinferred;\n@@ -3317,7 +3317,7 @@ MATCH FuncDeclaration::leastAsSpecialized(FuncDeclaration *g)\n \n     TypeFunction *tf = type->toTypeFunction();\n     TypeFunction *tg = g->type->toTypeFunction();\n-    size_t nfparams = Parameter::dim(tf->parameters);\n+    size_t nfparams = tf->parameterList.length();\n \n     /* If both functions have a 'this' pointer, and the mods are not\n      * the same and g's is not const, then this is less specialized.\n@@ -3342,7 +3342,7 @@ MATCH FuncDeclaration::leastAsSpecialized(FuncDeclaration *g)\n     args.setDim(nfparams);\n     for (size_t u = 0; u < nfparams; u++)\n     {\n-        Parameter *p = Parameter::getNth(tf->parameters, u);\n+        Parameter *p = tf->parameterList[u];\n         Expression *e;\n         if (p->storageClass & (STCref | STCout))\n         {\n@@ -3360,7 +3360,7 @@ MATCH FuncDeclaration::leastAsSpecialized(FuncDeclaration *g)\n         /* A variadic parameter list is less specialized than a\n          * non-variadic one.\n          */\n-        if (tf->varargs && !tg->varargs)\n+        if (tf->parameterList.varargs && !tg->parameterList.varargs)\n             goto L1;    // less specialized\n \n         return m;\n@@ -3446,7 +3446,7 @@ struct FuncCandidateWalker\n             TypeFunction *tf = (TypeFunction *)fd->type;\n \n             ::errorSupplemental(fd->loc, \"%s%s\", fd->toPrettyChars(),\n-                parametersTypeToChars(tf->parameters, tf->varargs));\n+                parametersTypeToChars(tf->parameterList));\n         }\n         else\n         {\n@@ -3590,7 +3590,7 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n                             fd->ident->toChars(), fargsBuf.peekString());\n                 else\n                     fd->error(loc, \"%s%s is not callable using argument types %s\",\n-                        parametersTypeToChars(tf->parameters, tf->varargs),\n+                        parametersTypeToChars(tf->parameterList),\n                         tf->modToChars(),\n                         fargsBuf.peekString());\n             }\n@@ -3609,8 +3609,8 @@ FuncDeclaration *resolveFuncCall(Loc loc, Scope *sc, Dsymbol *s,\n     {\n         TypeFunction *tf1 = m.lastf->type->toTypeFunction();\n         TypeFunction *tf2 = m.nextf->type->toTypeFunction();\n-        const char *lastprms = parametersTypeToChars(tf1->parameters, tf1->varargs);\n-        const char *nextprms = parametersTypeToChars(tf2->parameters, tf2->varargs);\n+        const char *lastprms = parametersTypeToChars(tf1->parameterList);\n+        const char *nextprms = parametersTypeToChars(tf2->parameterList);\n         ::error(loc, \"%s.%s called with argument types %s matches both:\\n\"\n                      \"%s:     %s%s\\nand:\\n%s:     %s%s\",\n                 s->parent->toPrettyChars(), s->ident->toChars(),\n@@ -4066,10 +4066,10 @@ bool FuncDeclaration::parametersIntersect(Type *t)\n \n     //printf(\"parametersIntersect(%s) t = %s\\n\", tf->toChars(), t->toChars());\n \n-    size_t dim = Parameter::dim(tf->parameters);\n+    size_t dim = tf->parameterList.length();\n     for (size_t i = 0; i < dim; i++)\n     {\n-        Parameter *fparam = Parameter::getNth(tf->parameters, i);\n+        Parameter *fparam = tf->parameterList[i];\n         if (!fparam->type)\n             continue;\n         Type *tprmi = (fparam->storageClass & (STClazy | STCout | STCref))\n@@ -4252,7 +4252,7 @@ FuncDeclaration *FuncDeclaration::genCfunc(Parameters *fparams, Type *treturn, I\n     }\n     else\n     {\n-        tf = new TypeFunction(fparams, treturn, 0, LINKc, stc);\n+        tf = new TypeFunction(ParameterList(fparams), treturn, LINKc, stc);\n         fd = new FuncDeclaration(Loc(), Loc(), id, STCstatic, tf);\n         fd->protection = Prot(PROTpublic);\n         fd->linkage = LINKc;\n@@ -4269,11 +4269,11 @@ FuncDeclaration *FuncDeclaration::genCfunc(Parameters *fparams, Type *treturn, I\n void FuncDeclaration::checkDmain()\n {\n     TypeFunction *tf = type->toTypeFunction();\n-    const size_t nparams = Parameter::dim(tf->parameters);\n+    const size_t nparams = tf->parameterList.length();\n     bool argerr = false;\n     if (nparams == 1)\n     {\n-        Parameter *fparam0 = Parameter::getNth(tf->parameters, 0);\n+        Parameter *fparam0 = tf->parameterList[0];\n         Type *t = fparam0->type->toBasetype();\n         if (t->ty != Tarray ||\n             t->nextOf()->ty != Tarray ||\n@@ -4288,7 +4288,7 @@ void FuncDeclaration::checkDmain()\n         error(\"must return int or void\");\n     else if (tf->nextOf()->ty != Tint32 && tf->nextOf()->ty != Tvoid)\n         error(\"must return int or void, not %s\", tf->nextOf()->toChars());\n-    else if (tf->varargs || nparams >= 2 || argerr)\n+    else if (tf->parameterList.varargs || nparams >= 2 || argerr)\n         error(\"parameters must be main() or main(string[] args)\");\n }\n \n@@ -4640,20 +4640,15 @@ bool FuncDeclaration::hasNestedFrameRefs()\n  * it is variadic or not.\n  */\n \n-Parameters *FuncDeclaration::getParameters(int *pvarargs)\n+ParameterList FuncDeclaration::getParameterList()\n {\n-    Parameters *fparameters = NULL;\n-    int fvarargs = 0;\n-\n     if (type)\n     {\n         TypeFunction *fdtype = type->toTypeFunction();\n-        fparameters = fdtype->parameters;\n-        fvarargs = fdtype->varargs;\n+        return fdtype->parameterList;\n     }\n-    if (pvarargs)\n-        *pvarargs = fvarargs;\n-    return fparameters;\n+\n+    return ParameterList();\n }\n \n \n@@ -4865,11 +4860,11 @@ void CtorDeclaration::semantic(Scope *sc)\n      */\n     if (ad && (!parent->isTemplateInstance() || parent->isTemplateMixin()))\n     {\n-        const size_t dim = Parameter::dim(tf->parameters);\n+        const size_t dim = tf->parameterList.length();\n \n         if (StructDeclaration *sd = ad->isStructDeclaration())\n         {\n-            if (dim == 0 && tf->varargs == 0) // empty default ctor w/o any varargs\n+            if (dim == 0 && tf->parameterList.varargs == VARARGnone) // empty default ctor w/o any varargs\n             {\n                 if (fbody || !(storage_class & STCdisable) || dim)\n                 {\n@@ -4880,10 +4875,10 @@ void CtorDeclaration::semantic(Scope *sc)\n                 }\n                 sd->noDefaultCtor = true;\n             }\n-            else if (dim == 0 && tf->varargs) // allow varargs only ctor\n+            else if (dim == 0 && tf->parameterList.varargs) // allow varargs only ctor\n             {\n             }\n-            else if (dim && Parameter::getNth(tf->parameters, 0)->defaultArg)\n+            else if (dim && tf->parameterList[0]->defaultArg)\n             {\n                 // if the first parameter has a default argument, then the rest does as well\n                 if (storage_class & STCdisable)\n@@ -4898,7 +4893,7 @@ void CtorDeclaration::semantic(Scope *sc)\n             }\n \n         }\n-        else if (dim == 0 && tf->varargs == 0)\n+        else if (dim == 0 && tf->parameterList.varargs == VARARGnone)\n         {\n             ad->defaultCtor = this;\n         }\n@@ -4972,7 +4967,7 @@ void PostBlitDeclaration::semantic(Scope *sc)\n     if (ident == Id::postblit && semanticRun < PASSsemantic)\n         ad->postblits.push(this);\n     if (!type)\n-        type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n \n     sc = sc->push();\n     sc->stc &= ~STCstatic;              // not static\n@@ -5048,7 +5043,7 @@ void DtorDeclaration::semantic(Scope *sc)\n     if (ident == Id::dtor && semanticRun < PASSsemantic)\n         ad->dtors.push(this);\n     if (!type)\n-        type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n \n     sc = sc->push();\n     sc->stc &= ~STCstatic;              // not a static destructor\n@@ -5135,7 +5130,7 @@ void StaticCtorDeclaration::semantic(Scope *sc)\n         return;\n     }\n     if (!type)\n-        type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n \n     /* If the static ctor appears within a template instantiation,\n      * it could get called multiple times by the module constructors\n@@ -5261,7 +5256,7 @@ void StaticDtorDeclaration::semantic(Scope *sc)\n         return;\n     }\n     if (!type)\n-        type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n \n     /* If the static ctor appears within a template instantiation,\n      * it could get called multiple times by the module constructors\n@@ -5387,7 +5382,7 @@ void InvariantDeclaration::semantic(Scope *sc)\n        )\n         ad->invs.push(this);\n     if (!type)\n-        type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n \n     sc = sc->push();\n     sc->stc &= ~STCstatic;              // not a static invariant\n@@ -5468,7 +5463,7 @@ void UnitTestDeclaration::semantic(Scope *sc)\n     if (global.params.useUnitTests)\n     {\n         if (!type)\n-            type = new TypeFunction(NULL, Type::tvoid, false, LINKd, storage_class);\n+            type = new TypeFunction(ParameterList(), Type::tvoid, LINKd, storage_class);\n         Scope *sc2 = sc->push();\n         sc2->linkage = LINKd;\n         FuncDeclaration::semantic(sc2);\n@@ -5498,7 +5493,7 @@ bool UnitTestDeclaration::addPostInvariant()\n \n /********************************* NewDeclaration ****************************/\n \n-NewDeclaration::NewDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *fparams, int varargs)\n+NewDeclaration::NewDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *fparams, VarArg varargs)\n     : FuncDeclaration(loc, endloc, Id::classNew, STCstatic | stc, NULL)\n {\n     this->parameters = fparams;\n@@ -5536,19 +5531,19 @@ void NewDeclaration::semantic(Scope *sc)\n     }\n     Type *tret = Type::tvoid->pointerTo();\n     if (!type)\n-        type = new TypeFunction(parameters, tret, varargs, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(parameters, varargs), tret, LINKd, storage_class);\n \n     type = type->semantic(loc, sc);\n \n     // Check that there is at least one argument of type size_t\n     TypeFunction *tf = type->toTypeFunction();\n-    if (Parameter::dim(tf->parameters) < 1)\n+    if (tf->parameterList.length() < 1)\n     {\n         error(\"at least one argument of type size_t expected\");\n     }\n     else\n     {\n-        Parameter *fparam = Parameter::getNth(tf->parameters, 0);\n+        Parameter *fparam = tf->parameterList[0];\n         if (!fparam->type->equals(Type::tsize_t))\n             error(\"first argument must be type size_t, not %s\", fparam->type->toChars());\n     }\n@@ -5614,19 +5609,19 @@ void DeleteDeclaration::semantic(Scope *sc)\n         return;\n     }\n     if (!type)\n-        type = new TypeFunction(parameters, Type::tvoid, 0, LINKd, storage_class);\n+        type = new TypeFunction(ParameterList(parameters), Type::tvoid, LINKd, storage_class);\n \n     type = type->semantic(loc, sc);\n \n     // Check that there is only one argument of type void*\n     TypeFunction *tf = type->toTypeFunction();\n-    if (Parameter::dim(tf->parameters) != 1)\n+    if (tf->parameterList.length() != 1)\n     {\n         error(\"one argument of type void* expected\");\n     }\n     else\n     {\n-        Parameter *fparam = Parameter::getNth(tf->parameters, 0);\n+        Parameter *fparam = tf->parameterList[0];\n         if (!fparam->type->equals(Type::tvoid->pointerTo()))\n             error(\"one argument of type void* expected, not %s\", fparam->type->toChars());\n     }"}, {"sha": "af933bd2e88d94fce383850bcbb0aeb71f11d3fc", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -918,7 +918,7 @@ class PrettyPrintVisitor : public Visitor\n         if (ident)\n             buf->writestring(ident);\n \n-        parametersToBuffer(t->parameters, t->varargs);\n+        parametersToBuffer(t->parameterList.parameters, t->parameterList.varargs);\n \n         /* Use postfix style for attributes\n          */\n@@ -988,7 +988,7 @@ class PrettyPrintVisitor : public Visitor\n             }\n             buf->writeByte(')');\n         }\n-        parametersToBuffer(t->parameters, t->varargs);\n+        parametersToBuffer(t->parameterList.parameters, t->parameterList.varargs);\n \n         t->inuse--;\n     }\n@@ -2012,7 +2012,7 @@ class PrettyPrintVisitor : public Visitor\n         // Don't print tf->mod, tf->trust, and tf->linkage\n         if (!f->inferRetType && tf->next)\n             typeToBuffer(tf->next, NULL);\n-        parametersToBuffer(tf->parameters, tf->varargs);\n+        parametersToBuffer(tf->parameterList.parameters, tf->parameterList.varargs);\n \n         CompoundStatement *cs = f->fbody->isCompoundStatement();\n         Statement *s1;\n@@ -3469,11 +3469,11 @@ void arrayObjectsToBuffer(OutBuffer *buf, Objects *objects)\n     }\n }\n \n-const char *parametersTypeToChars(Parameters *parameters, int varargs)\n+const char *parametersTypeToChars(ParameterList pl)\n {\n     OutBuffer buf;\n     HdrGenState hgs;\n     PrettyPrintVisitor v(&buf, &hgs);\n-    v.parametersToBuffer(parameters, varargs);\n+    v.parametersToBuffer(pl.parameters, pl.varargs);\n     return buf.extractString();\n }"}, {"sha": "1bad506bb2890521a33cdbf1baead55170030ab3", "filename": "gcc/d/dmd/hdrgen.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fhdrgen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fhdrgen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.h?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -46,7 +46,7 @@ void arrayObjectsToBuffer(OutBuffer *buf, Objects *objects);\n \n void moduleToBuffer(OutBuffer *buf, Module *m);\n \n-const char *parametersTypeToChars(Parameters *parameters, int varargs);\n+const char *parametersTypeToChars(ParameterList pl);\n \n bool stcToBuffer(OutBuffer *buf, StorageClass stc);\n const char *stcToChars(StorageClass& stc);"}, {"sha": "9381da46b2916d5046e877efd3ef761497b416cb", "filename": "gcc/d/dmd/initsem.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Finitsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Finitsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -182,8 +182,7 @@ class InitializerSemanticVisitor : public Visitor\n             TOK tok = (t->ty == Tdelegate) ? TOKdelegate : TOKfunction;\n             /* Rewrite as empty delegate literal { }\n             */\n-            Parameters *parameters = new Parameters;\n-            Type *tf = new TypeFunction(parameters, NULL, 0, LINKd);\n+            Type *tf = new TypeFunction(ParameterList(), NULL, LINKd);\n             FuncLiteralDeclaration *fd = new FuncLiteralDeclaration(i->loc, Loc(), tf, tok, NULL);\n             fd->fbody = new CompoundStatement(i->loc, new Statements());\n             fd->endloc = i->loc;"}, {"sha": "0c3b7b617b8904bd8aa2a1568a7ff1c1998af8c9", "filename": "gcc/d/dmd/json.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -679,7 +679,7 @@ class ToJsonVisitor : public Visitor\n \n         TypeFunction *tf = (TypeFunction *)d->type;\n         if (tf && tf->ty == Tfunction)\n-            property(\"parameters\", tf->parameters);\n+            property(\"parameters\", tf->parameterList.parameters);\n \n         property(\"endline\", \"endchar\", &d->endloc);\n "}, {"sha": "d7144879fbad71d3ad706114b30507ec9baac378", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 80, "deletions": 51, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1567,11 +1567,11 @@ Type *stripDefaultArgs(Type *t)\n     {\n         TypeFunction *tf = (TypeFunction *)t;\n         Type *tret = stripDefaultArgs(tf->next);\n-        Parameters *params = N::stripParams(tf->parameters);\n-        if (tret == tf->next && params == tf->parameters)\n+        Parameters *params = N::stripParams(tf->parameterList.parameters);\n+        if (tret == tf->next && params == tf->parameterList.parameters)\n             goto Lnot;\n         tf = (TypeFunction *)tf->copy();\n-        tf->parameters = params;\n+        tf->parameterList.parameters = params;\n         tf->next = tret;\n         //printf(\"strip %s\\n   <- %s\\n\", tf->toChars(), t->toChars());\n         t = tf;\n@@ -1985,24 +1985,25 @@ Type *TypeFunction::substWildTo(unsigned)\n \n     assert(next);\n     Type *tret = next->substWildTo(m);\n-    Parameters *params = parameters;\n+    Parameters *params = parameterList.parameters;\n     if (mod & MODwild)\n-        params = parameters->copy();\n+        params = parameterList.parameters->copy();\n     for (size_t i = 0; i < params->length; i++)\n     {\n         Parameter *p = (*params)[i];\n         Type *t = p->type->substWildTo(m);\n         if (t == p->type)\n             continue;\n-        if (params == parameters)\n-            params = parameters->copy();\n+        if (params == parameterList.parameters)\n+            params = parameterList.parameters->copy();\n         (*params)[i] = new Parameter(p->storageClass, t, NULL, NULL);\n     }\n-    if (next == tret && params == parameters)\n+    if (next == tret && params == parameterList.parameters)\n         return this;\n \n     // Similar to TypeFunction::syntaxCopy;\n-    TypeFunction *t = new TypeFunction(params, tret, varargs, linkage);\n+    TypeFunction *t = new TypeFunction(ParameterList(params, parameterList.varargs),\n+                                       tret, linkage);\n     t->mod = ((mod & MODwild) ? (mod & ~MODwild) | MODconst : mod);\n     t->isnothrow = isnothrow;\n     t->isnogc = isnogc;\n@@ -5119,14 +5120,13 @@ bool TypeReference::isZeroInit(Loc)\n \n /***************************** TypeFunction *****************************/\n \n-TypeFunction::TypeFunction(Parameters *parameters, Type *treturn, int varargs, LINK linkage, StorageClass stc)\n+TypeFunction::TypeFunction(const ParameterList &pl, Type *treturn, LINK linkage, StorageClass stc)\n     : TypeNext(Tfunction, treturn)\n {\n //if (!treturn) *(char*)0=0;\n //    assert(treturn);\n-    assert(0 <= varargs && varargs <= 2);\n-    this->parameters = parameters;\n-    this->varargs = varargs;\n+    assert(VARARGnone <= pl.varargs && pl.varargs <= VARARGtypesafe);\n+    this->parameterList = pl;\n     this->linkage = linkage;\n     this->inuse = 0;\n     this->isnothrow = false;\n@@ -5167,9 +5167,9 @@ TypeFunction::TypeFunction(Parameters *parameters, Type *treturn, int varargs, L\n         this->trust = TRUSTtrusted;\n }\n \n-TypeFunction *TypeFunction::create(Parameters *parameters, Type *treturn, int varargs, LINK linkage, StorageClass stc)\n+TypeFunction *TypeFunction::create(Parameters *parameters, Type *treturn, VarArg varargs, LINK linkage, StorageClass stc)\n {\n-    return new TypeFunction(parameters, treturn, varargs, linkage, stc);\n+    return new TypeFunction(ParameterList(parameters, varargs), treturn, linkage, stc);\n }\n \n const char *TypeFunction::kind()\n@@ -5180,8 +5180,9 @@ const char *TypeFunction::kind()\n Type *TypeFunction::syntaxCopy()\n {\n     Type *treturn = next ? next->syntaxCopy() : NULL;\n-    Parameters *params = Parameter::arraySyntaxCopy(parameters);\n-    TypeFunction *t = new TypeFunction(params, treturn, varargs, linkage);\n+    Parameters *parameters = Parameter::arraySyntaxCopy(parameterList.parameters);\n+    TypeFunction *t = new TypeFunction(ParameterList(parameters, parameterList.varargs),\n+                                       treturn, linkage);\n     t->mod = mod;\n     t->isnothrow = isnothrow;\n     t->isnogc = isnogc;\n@@ -5233,19 +5234,19 @@ int Type::covariant(Type *t, StorageClass *pstc, bool fix17349)\n     t1 = (TypeFunction *)this;\n     t2 = (TypeFunction *)t;\n \n-    if (t1->varargs != t2->varargs)\n+    if (t1->parameterList.varargs != t2->parameterList.varargs)\n         goto Ldistinct;\n \n-    if (t1->parameters && t2->parameters)\n+    if (t1->parameterList.parameters && t2->parameterList.parameters)\n     {\n-        size_t dim = Parameter::dim(t1->parameters);\n-        if (dim != Parameter::dim(t2->parameters))\n+        size_t dim = t1->parameterList.length();\n+        if (dim != t2->parameterList.length())\n             goto Ldistinct;\n \n         for (size_t i = 0; i < dim; i++)\n         {\n-            Parameter *fparam1 = Parameter::getNth(t1->parameters, i);\n-            Parameter *fparam2 = Parameter::getNth(t2->parameters, i);\n+            Parameter *fparam1 = t1->parameterList[i];\n+            Parameter *fparam2 = t2->parameterList[i];\n \n             if (!fparam1->type->equals(fparam2->type))\n             {\n@@ -5287,10 +5288,10 @@ int Type::covariant(Type *t, StorageClass *pstc, bool fix17349)\n             notcovariant |= !fparam1->isCovariant(t1->isref, fparam2);\n         }\n     }\n-    else if (t1->parameters != t2->parameters)\n+    else if (t1->parameterList.parameters != t2->parameterList.parameters)\n     {\n-        size_t dim1 = !t1->parameters ? 0 : t1->parameters->length;\n-        size_t dim2 = !t2->parameters ? 0 : t2->parameters->length;\n+        size_t dim1 = t1->parameterList.length();\n+        size_t dim2 = t2->parameterList.length();\n         if (dim1 || dim2)\n             goto Ldistinct;\n     }\n@@ -5447,14 +5448,15 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n      * as semantic() will get called again on this.\n      */\n     TypeFunction *tf = copy()->toTypeFunction();\n-    if (parameters)\n+    if (parameterList.parameters)\n     {\n-        tf->parameters = parameters->copy();\n-        for (size_t i = 0; i < parameters->length; i++)\n+        tf->parameterList.parameters = parameterList.parameters->copy();\n+        for (size_t i = 0; i < parameterList.parameters->length; i++)\n         {\n             void *pp = mem.xmalloc(sizeof(Parameter));\n-            Parameter *p = (Parameter *)memcpy(pp, (void *)(*parameters)[i], sizeof(Parameter));\n-            (*tf->parameters)[i] = p;\n+            Parameter *p = (Parameter *)memcpy(pp, (void *)(*parameterList.parameters)[i],\n+                                               sizeof(Parameter));\n+            (*tf->parameterList.parameters)[i] = p;\n         }\n     }\n \n@@ -5513,7 +5515,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n     }\n \n     unsigned char wildparams = 0;\n-    if (tf->parameters)\n+    if (tf->parameterList.parameters)\n     {\n         /* Create a scope for evaluating the default arguments for the parameters\n          */\n@@ -5522,10 +5524,10 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n         argsc->protection = Prot(PROTpublic);\n         argsc->func = NULL;\n \n-        size_t dim = Parameter::dim(tf->parameters);\n+        size_t dim = tf->parameterList.length();\n         for (size_t i = 0; i < dim; i++)\n         {\n-            Parameter *fparam = Parameter::getNth(tf->parameters, i);\n+            Parameter *fparam = tf->parameterList[i];\n             inuse++;\n             fparam->type = fparam->type->semantic(loc, argsc);\n             inuse--;\n@@ -5728,7 +5730,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n                 /* Reset number of parameters, and back up one to do this fparam again,\n                  * now that it is a tuple\n                  */\n-                dim = Parameter::dim(tf->parameters);\n+                dim = tf->parameterList.length();\n                 i--;\n                 continue;\n             }\n@@ -5770,13 +5772,13 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n     }\n     tf->iswild = wildparams;\n \n-    if (tf->isproperty && (tf->varargs || Parameter::dim(tf->parameters) > 2))\n+    if (tf->isproperty && (tf->parameterList.varargs != VARARGnone || tf->parameterList.length() > 2))\n     {\n         error(loc, \"properties can only have zero, one, or two parameter\");\n         errors = true;\n     }\n \n-    if (tf->varargs == 1 && tf->linkage != LINKd && Parameter::dim(tf->parameters) == 0)\n+    if (tf->parameterList.varargs == VARARGvariadic && tf->linkage != LINKd && tf->parameterList.length() == 0)\n     {\n         error(loc, \"variadic functions with non-D linkage must have at least one parameter\");\n         errors = true;\n@@ -5880,10 +5882,10 @@ void TypeFunction::purityLevel()\n \n     /* Evaluate what kind of purity based on the modifiers for the parameters\n      */\n-    const size_t dim = Parameter::dim(tf->parameters);\n+    const size_t dim = tf->parameterList.length();\n     for (size_t i = 0; i < dim; i++)\n     {\n-        Parameter *fparam = Parameter::getNth(tf->parameters, i);\n+        Parameter *fparam = tf->parameterList[i];\n         Type *t = fparam->type;\n         if (!t)\n             continue;\n@@ -5968,13 +5970,13 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n         }\n     }\n \n-    size_t nparams = Parameter::dim(parameters);\n+    size_t nparams = parameterList.length();\n     size_t nargs = args ? args->length : 0;\n     if (nparams == nargs)\n         ;\n     else if (nargs > nparams)\n     {\n-        if (varargs == 0)\n+        if (parameterList.varargs == VARARGnone)\n             goto Nomatch;               // too many args; no match\n         match = MATCHconvert;           // match ... with a \"conversion\" match level\n     }\n@@ -5983,7 +5985,7 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n     {\n         if (u >= nparams)\n             break;\n-        Parameter *p = Parameter::getNth(parameters, u);\n+        Parameter *p = parameterList[u];\n         Expression *arg = (*args)[u];\n         assert(arg);\n         Type *tprm = p->type;\n@@ -6016,7 +6018,7 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n     {\n         MATCH m;\n \n-        Parameter *p = Parameter::getNth(parameters, u);\n+        Parameter *p = parameterList[u];\n         assert(p);\n         if (u >= nargs)\n         {\n@@ -6107,14 +6109,14 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n         /* prefer matching the element type rather than the array\n          * type when more arguments are present with T[]...\n          */\n-        if (varargs == 2 && u + 1 == nparams && nargs > nparams)\n+        if (parameterList.varargs == VARARGtypesafe && u + 1 == nparams && nargs > nparams)\n             goto L1;\n \n         //printf(\"\\tm = %d\\n\", m);\n         if (m == MATCHnomatch)                  // if no match\n         {\n           L1:\n-            if (varargs == 2 && u + 1 == nparams)       // if last varargs param\n+            if (parameterList.varargs == VARARGtypesafe && u + 1 == nparams)       // if last varargs param\n             {\n                 Type *tb = p->type->toBasetype();\n                 TypeSArray *tsa;\n@@ -6192,16 +6194,27 @@ MATCH TypeFunction::callMatch(Type *tthis, Expressions *args, int flag)\n  */\n bool TypeFunction::hasLazyParameters()\n {\n-    size_t dim = Parameter::dim(parameters);\n+    size_t dim = parameterList.length();\n     for (size_t i = 0; i < dim; i++)\n     {\n-        Parameter *fparam = Parameter::getNth(parameters, i);\n+        Parameter *fparam = parameterList[i];\n         if (fparam->storageClass & STClazy)\n             return true;\n     }\n     return false;\n }\n \n+/*******************************\n+ * Check for `extern (D) U func(T t, ...)` variadic function type,\n+ * which has `_arguments[]` added as the first argument.\n+ * Returns:\n+ *  true if D-style variadic\n+ */\n+bool TypeFunction::isDstyleVariadic() const\n+{\n+    return linkage == LINKd && parameterList.varargs == VARARGvariadic;\n+}\n+\n /***************************\n  * Examine function signature for parameter p and see if\n  * the value of p can 'escape' the scope of the function.\n@@ -6254,10 +6267,10 @@ StorageClass TypeFunction::parameterStorageClass(Parameter *p)\n     // See if p can escape via any of the other parameters\n     if (purity == PUREweak)\n     {\n-        const size_t dim = Parameter::dim(parameters);\n+        const size_t dim = parameterList.length();\n         for (size_t i = 0; i < dim; i++)\n         {\n-            Parameter *fparam = Parameter::getNth(parameters, i);\n+            Parameter *fparam = parameterList[i];\n             Type *t = fparam->type;\n             if (!t)\n                 continue;\n@@ -6305,7 +6318,7 @@ Type *TypeFunction::addStorageClass(StorageClass stc)\n         (stc & STCsafe && t->trust < TRUSTtrusted))\n     {\n         // Klunky to change these\n-        TypeFunction *tf = new TypeFunction(t->parameters, t->next, t->varargs, t->linkage, 0);\n+        TypeFunction *tf = new TypeFunction(t->parameterList, t->next, t->linkage, 0);\n         tf->mod = t->mod;\n         tf->fargs = fargs;\n         tf->purity = t->purity;\n@@ -9298,6 +9311,22 @@ Expression *TypeNull::defaultInit(Loc)\n     return new NullExp(Loc(), Type::tnull);\n }\n \n+/***********************************************************\n+ * Encapsulate Parameters* so .length and [i] can be used on it.\n+ * https://dlang.org/spec/function.html#ParameterList\n+ */\n+\n+ParameterList::ParameterList(Parameters *parameters, VarArg varargs)\n+{\n+    this->parameters = parameters;\n+    this->varargs = varargs;\n+}\n+\n+size_t ParameterList::length()\n+{\n+    return Parameter::dim(parameters);\n+}\n+\n /***************************** Parameter *****************************/\n \n Parameter::Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg)\n@@ -9355,7 +9384,7 @@ Type *Parameter::isLazyArray()\n             TypeDelegate *td = (TypeDelegate *)tel;\n             TypeFunction *tf = td->next->toTypeFunction();\n \n-            if (!tf->varargs && Parameter::dim(tf->parameters) == 0)\n+            if (!tf->parameterList.varargs == VARARGnone && tf->parameterList.length() == 0)\n             {\n                 return tf->next;    // return type of delegate\n             }"}, {"sha": "89105d93e3ffafba6fcbbf34e63be4902a0856ed", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -126,6 +126,14 @@ extern unsigned char impcnvType2[TMAX][TMAX];\n // If !=0, give warning on implicit conversion\n extern unsigned char impcnvWarn[TMAX][TMAX];\n \n+enum VarArg\n+{\n+    VARARGnone     = 0,  /// fixed number of arguments\n+    VARARGvariadic = 1,  /// T t, ...)  can be C-style (core.stdc.stdarg) or D-style (core.vararg)\n+    VARARGtypesafe = 2   /// T t ...) typesafe https://dlang.org/spec/function.html#typesafe_variadic_functions\n+                         ///   or https://dlang.org/spec/function.html#typesafe_variadic_functions\n+};\n+\n class Type : public RootObject\n {\n public:\n@@ -587,14 +595,48 @@ enum PURE\n     PUREstrong = 4      // parameters are values or immutable\n };\n \n+class Parameter : public RootObject\n+{\n+public:\n+    StorageClass storageClass;\n+    Type *type;\n+    Identifier *ident;\n+    Expression *defaultArg;\n+\n+    Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n+    static Parameter *create(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n+    Parameter *syntaxCopy();\n+    Type *isLazyArray();\n+    // kludge for template.isType()\n+    int dyncast() const { return DYNCAST_PARAMETER; }\n+    virtual void accept(Visitor *v) { v->visit(this); }\n+\n+    static Parameters *arraySyntaxCopy(Parameters *parameters);\n+    static size_t dim(Parameters *parameters);\n+    static Parameter *getNth(Parameters *parameters, d_size_t nth, d_size_t *pn = NULL);\n+    const char *toChars();\n+    bool isCovariant(bool returnByRef, const Parameter *p) const;\n+    static bool isCovariantScope(bool returnByRef, StorageClass from, StorageClass to);\n+};\n+\n+struct ParameterList\n+{\n+    Parameters *parameters;\n+    VarArg varargs;\n+\n+    ParameterList(Parameters *parameters = NULL, VarArg varargs = VARARGnone);\n+\n+    size_t length();\n+    Parameter *operator[](size_t i) { return Parameter::getNth(parameters, i); }\n+};\n+\n class TypeFunction : public TypeNext\n {\n public:\n     // .next is the return type\n \n-    Parameters *parameters;     // function parameters\n-    int varargs;        // 1: T t, ...) style for variable number of arguments\n-                        // 2: T t ...) style for variable number of arguments\n+    ParameterList parameterList;     // function parameters\n+\n     bool isnothrow;     // true: nothrow\n     bool isnogc;        // true: is @nogc\n     bool isproperty;    // can be called without parentheses\n@@ -610,13 +652,14 @@ class TypeFunction : public TypeNext\n \n     int inuse;\n \n-    TypeFunction(Parameters *parameters, Type *treturn, int varargs, LINK linkage, StorageClass stc = 0);\n-    static TypeFunction *create(Parameters *parameters, Type *treturn, int varargs, LINK linkage, StorageClass stc = 0);\n+    TypeFunction(const ParameterList &pl, Type *treturn, LINK linkage, StorageClass stc = 0);\n+    static TypeFunction *create(Parameters *parameters, Type *treturn, VarArg varargs, LINK linkage, StorageClass stc = 0);\n     const char *kind();\n     Type *syntaxCopy();\n     Type *semantic(Loc loc, Scope *sc);\n     void purityLevel();\n     bool hasLazyParameters();\n+    bool isDstyleVariadic() const;\n     bool parameterEscapes(Parameter *p);\n     StorageClass parameterStorageClass(Parameter *p);\n     Type *addStorageClass(StorageClass stc);\n@@ -919,32 +962,5 @@ class TypeNull : public Type\n \n /**************************************************************/\n \n-//enum InOut { None, In, Out, InOut, Lazy };\n-\n-class Parameter : public RootObject\n-{\n-public:\n-    //enum InOut inout;\n-    StorageClass storageClass;\n-    Type *type;\n-    Identifier *ident;\n-    Expression *defaultArg;\n-\n-    Parameter(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n-    static Parameter *create(StorageClass storageClass, Type *type, Identifier *ident, Expression *defaultArg);\n-    Parameter *syntaxCopy();\n-    Type *isLazyArray();\n-    // kludge for template.isType()\n-    int dyncast() const { return DYNCAST_PARAMETER; }\n-    virtual void accept(Visitor *v) { v->visit(this); }\n-\n-    static Parameters *arraySyntaxCopy(Parameters *parameters);\n-    static size_t dim(Parameters *parameters);\n-    static Parameter *getNth(Parameters *parameters, d_size_t nth, d_size_t *pn = NULL);\n-    const char *toChars();\n-    bool isCovariant(bool returnByRef, const Parameter *p) const;\n-    static bool isCovariantScope(bool returnByRef, StorageClass from, StorageClass to);\n-};\n-\n bool arrayTypeCompatible(Loc loc, Type *t1, Type *t2);\n bool arrayTypeCompatibleWithoutCasting(Type *t1, Type *t2);"}, {"sha": "847cee93d3539ff0f1fadf3d1aba2bb489fa29cf", "filename": "gcc/d/dmd/opover.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fopover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fopover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1923,9 +1923,9 @@ static int inferApplyArgTypesY(TypeFunction *tf, Parameters *parameters, int fla\n {   size_t nparams;\n     Parameter *p;\n \n-    if (Parameter::dim(tf->parameters) != 1)\n+    if (tf->parameterList.length() != 1)\n         goto Lnomatch;\n-    p = Parameter::getNth(tf->parameters, 0);\n+    p = tf->parameterList[0];\n     if (p->type->ty != Tdelegate)\n         goto Lnomatch;\n     tf = (TypeFunction *)p->type->nextOf();\n@@ -1934,16 +1934,16 @@ static int inferApplyArgTypesY(TypeFunction *tf, Parameters *parameters, int fla\n     /* We now have tf, the type of the delegate. Match it against\n      * the parameters, filling in missing parameter types.\n      */\n-    nparams = Parameter::dim(tf->parameters);\n-    if (nparams == 0 || tf->varargs)\n+    nparams = tf->parameterList.length();\n+    if (nparams == 0 || tf->parameterList.varargs != VARARGnone)\n         goto Lnomatch;          // not enough parameters\n     if (parameters->length != nparams)\n         goto Lnomatch;          // not enough parameters\n \n     for (size_t u = 0; u < nparams; u++)\n     {\n         p = (*parameters)[u];\n-        Parameter *param = Parameter::getNth(tf->parameters, u);\n+        Parameter *param = tf->parameterList[u];\n         if (p->type)\n         {\n             if (!p->type->equals(param->type))"}, {"sha": "82f3aee99fdaac8f88bef56ed5f282102886129a", "filename": "gcc/d/dmd/optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -531,7 +531,7 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n                 TypeFunction *tf = (TypeFunction *)t1;\n                 for (size_t i = 0; i < e->arguments->length; i++)\n                 {\n-                    Parameter *p = Parameter::getNth(tf->parameters, i);\n+                    Parameter *p = tf->parameterList[i];\n                     bool keep = p && (p->storageClass & (STCref | STCout)) != 0;\n                     expOptimize((*e->arguments)[i], WANTvalue, keep);\n                 }"}, {"sha": "e983501bde128d43b980a5b2ab48b4e437fdfead", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -1603,10 +1603,10 @@ Dsymbol *Parser::parseCtor(PrefixAttributes *pAttrs)\n \n     /* Just a regular constructor\n      */\n-    int varargs;\n+    VarArg varargs;\n     Parameters *parameters = parseParameters(&varargs);\n     stc = parsePostfix(stc, &udas);\n-    if (varargs != 0 || Parameter::dim(parameters) != 0)\n+    if (varargs != VARARGnone || Parameter::dim(parameters) != 0)\n     {\n         if (stc & STCstatic)\n             error(loc, \"constructor cannot be static\");\n@@ -1621,7 +1621,8 @@ Dsymbol *Parser::parseCtor(PrefixAttributes *pAttrs)\n \n     Expression *constraint = tpl ? parseConstraint() : NULL;\n \n-    Type *tf = new TypeFunction(parameters, NULL, varargs, linkage, stc);   // RetrunType -> auto\n+    Type *tf = new TypeFunction(ParameterList(parameters, varargs),\n+                                NULL, linkage, stc);   // ReturnType -> auto\n     tf = tf->addSTC(stc);\n \n     CtorDeclaration *f = new CtorDeclaration(loc, Loc(), stc, tf);\n@@ -1929,7 +1930,7 @@ Dsymbol *Parser::parseNew(PrefixAttributes *pAttrs)\n \n     nextToken();\n \n-    int varargs;\n+    VarArg varargs;\n     Parameters *parameters = parseParameters(&varargs);\n     NewDeclaration *f = new NewDeclaration(loc, Loc(), stc, parameters, varargs);\n     if (pAttrs)\n@@ -1951,9 +1952,9 @@ Dsymbol *Parser::parseDelete(PrefixAttributes *pAttrs)\n \n     nextToken();\n \n-    int varargs;\n+    VarArg varargs;\n     Parameters *parameters = parseParameters(&varargs);\n-    if (varargs)\n+    if (varargs != VARARGnone)\n         error(\"... not allowed in delete function parameter list\");\n     DeleteDeclaration *f = new DeleteDeclaration(loc, Loc(), stc, parameters);\n     if (pAttrs)\n@@ -1966,10 +1967,10 @@ Dsymbol *Parser::parseDelete(PrefixAttributes *pAttrs)\n  * Parse parameter list.\n  */\n \n-Parameters *Parser::parseParameters(int *pvarargs, TemplateParameters **tpl)\n+Parameters *Parser::parseParameters(VarArg *pvarargs, TemplateParameters **tpl)\n {\n     Parameters *parameters = new Parameters();\n-    int varargs = 0;\n+    VarArg varargs = VARARGnone;\n     int hasdefault = 0;\n \n     check(TOKlparen);\n@@ -1989,7 +1990,7 @@ Parameters *Parser::parseParameters(int *pvarargs, TemplateParameters **tpl)\n                     break;\n \n                 case TOKdotdotdot:\n-                    varargs = 1;\n+                    varargs = VARARGvariadic;\n                     nextToken();\n                     break;\n \n@@ -2076,7 +2077,7 @@ Parameters *Parser::parseParameters(int *pvarargs, TemplateParameters **tpl)\n \n                         if (storageClass & (STCout | STCref))\n                             error(\"variadic argument cannot be out or ref\");\n-                        varargs = 2;\n+                        varargs = VARARGtypesafe;\n                         parameters->push(new Parameter(storageClass, at, ai, ae));\n                         nextToken();\n                         break;\n@@ -3406,11 +3407,12 @@ Type *Parser::parseBasicType2(Type *t)\n                 TOK save = token.value;\n                 nextToken();\n \n-                int varargs;\n+                VarArg varargs;\n                 Parameters *parameters = parseParameters(&varargs);\n \n                 StorageClass stc = parsePostfix(STCundefined, NULL);\n-                TypeFunction *tf = new TypeFunction(parameters, t, varargs, linkage, stc);\n+                TypeFunction *tf = new TypeFunction(ParameterList(parameters, varargs),\n+                                                    t, linkage, stc);\n                 if (stc & (STCconst | STCimmutable | STCshared | STCwild | STCreturn))\n                 {\n                     if (save == TOKfunction)\n@@ -3572,14 +3574,15 @@ Type *Parser::parseDeclarator(Type *t, int *palt, Identifier **pident,\n                     }\n                 }\n \n-                int varargs;\n+                VarArg varargs;\n                 Parameters *parameters = parseParameters(&varargs);\n \n                 /* Parse const/immutable/shared/inout/nothrow/pure/return postfix\n                  */\n                 StorageClass stc = parsePostfix(storageClass, pudas);\n                                         // merge prefix storage classes\n-                Type *tf = new TypeFunction(parameters, t, varargs, linkage, stc);\n+                Type *tf = new TypeFunction(ParameterList(parameters, varargs),\n+                                            t, linkage, stc);\n                 tf = tf->addSTC(stc);\n                 if (pdisable)\n                     *pdisable = stc & STCdisable ? 1 : 0;\n@@ -4159,7 +4162,7 @@ Dsymbol *Parser::parseFunctionLiteral()\n \n     TemplateParameters *tpl = NULL;\n     Parameters *parameters = NULL;\n-    int varargs = 0;\n+    VarArg varargs = VARARGnone;\n     Type *tret = NULL;\n     StorageClass stc = 0;\n     TOK save = TOKreserved;\n@@ -4235,7 +4238,8 @@ Dsymbol *Parser::parseFunctionLiteral()\n \n     if (!parameters)\n         parameters = new Parameters();\n-    TypeFunction *tf = new TypeFunction(parameters, tret, varargs, linkage, stc);\n+    TypeFunction *tf = new TypeFunction(ParameterList(parameters, varargs),\n+                                        tret, linkage, stc);\n     tf = (TypeFunction *)tf->addSTC(stc);\n     FuncLiteralDeclaration *fd = new FuncLiteralDeclaration(loc, Loc(), tf, save, NULL);\n "}, {"sha": "dae7b634db4d82541433b8c158af87ed44cd39cd", "filename": "gcc/d/dmd/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.h?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -103,7 +103,7 @@ class Parser : public Lexer\n     Dsymbol *parseUnitTest(PrefixAttributes *pAttrs);\n     Dsymbol *parseNew(PrefixAttributes *pAttrs);\n     Dsymbol *parseDelete(PrefixAttributes *pAttrs);\n-    Parameters *parseParameters(int *pvarargs, TemplateParameters **tpl = NULL);\n+    Parameters *parseParameters(VarArg *pvarargs, TemplateParameters **tpl = NULL);\n     EnumDeclaration *parseEnum();\n     Dsymbol *parseAggregate();\n     BaseClasses *parseBaseClasses();"}, {"sha": "33ca46729b0ba8ccc213d4b08cce1332c710a3fe", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -897,18 +897,17 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 if (FuncDeclaration *fd = sapplyOld->isFuncDeclaration())\n                 {\n-                    int fvarargs;  // ignored (opApply shouldn't take variadics)\n-                    Parameters *fparameters = fd->getParameters(&fvarargs);\n+                    ParameterList fparameters = fd->getParameterList();\n \n-                    if (Parameter::dim(fparameters) == 1)\n+                    if (fparameters.length() == 1)\n                     {\n                         // first param should be the callback function\n-                        Parameter *fparam = Parameter::getNth(fparameters, 0);\n+                        Parameter *fparam = fparameters[0];\n                         if ((fparam->type->ty == Tpointer || fparam->type->ty == Tdelegate) &&\n                             fparam->type->nextOf()->ty == Tfunction)\n                         {\n                             TypeFunction *tf = (TypeFunction *)fparam->type->nextOf();\n-                            foreachParamCount = Parameter::dim(tf->parameters);\n+                            foreachParamCount = tf->parameterList.length();\n                             foundMismatch = true;\n                         }\n                     }\n@@ -1433,9 +1432,9 @@ class StatementSemanticVisitor : public Visitor\n                             tfld = (TypeFunction *)tab->nextOf();\n                         Lget:\n                             //printf(\"tfld = %s\\n\", tfld->toChars());\n-                            if (tfld->parameters->length == 1)\n+                            if (tfld->parameterList.parameters->length == 1)\n                             {\n-                                Parameter *p = Parameter::getNth(tfld->parameters, 0);\n+                                Parameter *p = tfld->parameterList[0];\n                                 if (p->type && p->type->ty == Tdelegate)\n                                 {\n                                     Type *t = p->type->semantic(loc, sc2);\n@@ -1460,7 +1459,7 @@ class StatementSemanticVisitor : public Visitor\n                         p->type = p->type->addStorageClass(p->storageClass);\n                         if (tfld)\n                         {\n-                            Parameter *prm = Parameter::getNth(tfld->parameters, i);\n+                            Parameter *prm = tfld->parameterList[i];\n                             //printf(\"\\tprm = %s%s\\n\", (prm->storageClass&STCref?\"ref \":\"\"), prm->ident->toChars());\n                             stc = prm->storageClass & STCref;\n                             id = p->ident;    // argument copy is not need.\n@@ -1497,7 +1496,7 @@ class StatementSemanticVisitor : public Visitor\n                     }\n                     // Bugzilla 13840: Throwable nested function inside nothrow function is acceptable.\n                     StorageClass stc = mergeFuncAttrs(STCsafe | STCpure | STCnogc, fs->func);\n-                    tfld = new TypeFunction(params, Type::tint32, 0, LINKd, stc);\n+                    tfld = new TypeFunction(ParameterList(params), Type::tint32, LINKd, stc);\n                     fs->cases = new Statements();\n                     fs->gotos = new ScopeStatements();\n                     FuncLiteralDeclaration *fld = new FuncLiteralDeclaration(loc, Loc(), tfld, TOKdelegate, fs);\n@@ -1575,7 +1574,8 @@ class StatementSemanticVisitor : public Visitor\n                             dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n                             if (dim == 2)\n                                 dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n-                            fldeTy[i] = new TypeDelegate(new TypeFunction(dgparams, Type::tint32, 0, LINKd));\n+                            fldeTy[i] = new TypeDelegate(new TypeFunction(ParameterList(dgparams),\n+                                                                          Type::tint32, LINKd));\n                             params->push(new Parameter(0, fldeTy[i], NULL, NULL));\n                             fdapply[i] = FuncDeclaration::genCfunc(params, Type::tint32, name[i]);\n                         }\n@@ -1640,7 +1640,8 @@ class StatementSemanticVisitor : public Visitor\n                         dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n                         if (dim == 2)\n                             dgparams->push(new Parameter(0, Type::tvoidptr, NULL, NULL));\n-                        dgty = new TypeDelegate(new TypeFunction(dgparams, Type::tint32, 0, LINKd));\n+                        dgty = new TypeDelegate(new TypeFunction(ParameterList(dgparams),\n+                                                                 Type::tint32, LINKd));\n                         params->push(new Parameter(0, dgty, NULL, NULL));\n                         fdapply = FuncDeclaration::genCfunc(params, Type::tint32, fdname);\n "}, {"sha": "bc1e2c3c2348eb3830c1841d5423ac124eee7fa1", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -969,7 +969,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return dimError(e, 1, dim);\n \n         LINK link;\n-        int varargs;\n+        VarArg varargs;\n         RootObject *o = (*e->args)[0];\n         Type *t = isType(o);\n         TypeFunction *tf = NULL;\n@@ -985,7 +985,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         if (tf)\n         {\n             link = tf->linkage;\n-            varargs = tf->varargs;\n+            varargs = tf->parameterList.varargs;\n         }\n         else\n         {\n@@ -997,7 +997,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 return new ErrorExp();\n             }\n             link = fd->linkage;\n-            fd->getParameters(&varargs);\n+            varargs = fd->getParameterList().varargs;\n         }\n         const char *style;\n         switch (varargs)\n@@ -1034,10 +1034,10 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n                 tf = (TypeFunction *)t->nextOf();\n         }\n-        Parameters* fparams;\n+        ParameterList fparams;\n         if (tf)\n         {\n-            fparams = tf->parameters;\n+            fparams = tf->parameterList;\n         }\n         else\n         {\n@@ -1049,7 +1049,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                     o->toChars(), o1->toChars());\n                 return new ErrorExp();\n             }\n-            fparams = fd->getParameters(NULL);\n+            fparams = fd->getParameterList();\n         }\n \n         StorageClass stc;\n@@ -1064,14 +1064,14 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n         ex = ex->ctfeInterpret();\n         uinteger_t ii = ex->toUInteger();\n-        if (ii >= Parameter::dim(fparams))\n+        if (ii >= fparams.length())\n         {\n-            e->error(\"parameter index must be in range 0..%u not %s\", (unsigned)Parameter::dim(fparams), ex->toChars());\n+            e->error(\"parameter index must be in range 0..%u not %s\", (unsigned)fparams.length(), ex->toChars());\n             return new ErrorExp();\n         }\n \n         unsigned n = (unsigned)ii;\n-        Parameter *p = Parameter::getNth(fparams, n);\n+        Parameter *p = fparams[n];\n         stc = p->storageClass;\n \n         // This mirrors hdrgen.visit(Parameter p)"}, {"sha": "f3a1c473f7a40dad1891491cd753b1998787f595", "filename": "gcc/d/types.cc", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3a2ba10b272fd9581560604284da2a6283bcde0/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=c3a2ba10b272fd9581560604284da2a6283bcde0", "patch": "@@ -709,26 +709,23 @@ class TypeVisitor : public Visitor\n \n        Variadic functions with D linkage have an additional hidden argument\n        with the name _arguments passed to the function.  */\n-    if (t->varargs == 1 && t->linkage == LINKd)\n+    if (t->isDstyleVariadic ())\n       {\n \ttree type = build_ctype (Type::typeinfotypelist->type);\n \tfnparams = chainon (fnparams, build_tree_list (0, type));\n       }\n \n-    if (t->parameters)\n-      {\n-\tsize_t n_args = Parameter::dim (t->parameters);\n+    size_t n_args = t->parameterList.length ();\n \n-\tfor (size_t i = 0; i < n_args; i++)\n-\t  {\n-\t    tree type = parameter_type (Parameter::getNth (t->parameters, i));\n-\t    fnparams = chainon (fnparams, build_tree_list (0, type));\n-\t  }\n+    for (size_t i = 0; i < n_args; i++)\n+      {\n+\ttree type = parameter_type (t->parameterList[i]);\n+\tfnparams = chainon (fnparams, build_tree_list (0, type));\n       }\n \n     /* When the last parameter is void_list_node, that indicates a fixed length\n        parameter list, otherwise function is treated as variadic.  */\n-    if (t->varargs != 1)\n+    if (t->parameterList.varargs != VARARGvariadic)\n       fnparams = chainon (fnparams, void_list_node);\n \n     if (t->next != NULL)"}]}