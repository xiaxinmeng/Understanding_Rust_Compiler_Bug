{"sha": "ec0f53a3a542e762f8fc8c22b9d345f922be5867", "node_id": "C_kwDOANBUbNoAKGVjMGY1M2EzYTU0MmU3NjJmOGZjOGMyMmI5ZDM0NWY5MjJiZTU4Njc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-09T13:42:37Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-03-09T13:42:37Z"}, "message": "c++: non-constant non-dependent decltype folding [PR104823]\n\nWhen processing a non-dependent decltype operand we want to instantiate\nit even if it's non-constant, since non-dependent decltype is always\nresolved ahead of time.  But currently finish_decltype_type uses\ninstantiate_non_dependent_expr, which instantiates only potentially\nconstant expressions, and this causes us to miss diagnosing the narrowing\nconversion in S{id(v)} in the below testcase because we never instantiate\nthis non-constant non-dependent decltype operand.\n\nIn light of\n\n  > On Mon, 7 Mar 2022, Jason Merrill wrote:\n  >> On 3/7/22 14:41, Patrick Palka wrote:\n  >>> instantiate_non_dependent_expr instantiates only potentially constant\n  >>> expressions\n  >>\n  >> Hmm, that now strikes me as a problematic interface, as we don't know whether\n  >> what we get back is template or non-template trees.\n\nthis patch drops the potentially-constant check in i_n_d_e and turns\nits dependence check into a checking_assert, since most callers already\ncheck that the argument is non-dependent; thus i_n_d_e now instantiates\neven non-constant expressions and always returns non-templated trees.\nThis patch also relaxes the dependence check in i_n_d_e to use the\n_uneval version (since that's what finish_decltype_type uses) and\nstrengthens the dependence checks used by other callers accordingly.\n\nIn cp_parser_parenthesized_expression_list_elt we were calling\ninstantiate_non_dependent_expr (when parsing an attribute list) without\nfirst checking for non-dependence.  We could fix this by guarding the\ncall appropriately, but I noticed we also fold non-dependent attributes\nlater from cp_check_const_attribute, so this earlier folding is at best\nredundant.  And it currently causes us to reject constexpr-attribute4.C\nbelow due to the second folding seeing non-templated trees.  Thus the\nright solution here seems to be to remove this unguarded call to i_n_d_e\nso that we end up instantiating non-dependent attributes only once.\n\nFinally, after calling i_n_d_e in finish_decltype_type we need to keep\nprocessing_template_decl cleared for sake of the later call to\nlvalue_kind, which handles templated and non-templated COND_EXPR\ndifferently.  Otherwise we'd incorrectly reject the declaration of g in\ncpp0x/cond2.C with:\n\n  error: 'g' declared as function returning a function\n\n\tPR c++/104823\n\ngcc/cp/ChangeLog:\n\n\t* except.cc (build_noexcept_spec): Strengthen dependence check\n\tto instantiation_dependent_expression_p.\n\t* parser.cc (cp_parser_parenthesized_expression_list_elt):\n\tRemove fold_expr_p parameter, and don't call\n\tinstantiate_non_dependent_expr.\n\t(cp_parser_parenthesized_expression_list): Adjust accordingly.\n\t* pt.cc (expand_integer_pack): Strengthen dependence check\n\tto instantiation_dependent_expression_p.\n\t(instantiate_non_dependent_expr_internal): Adjust comment.\n\t(instantiate_non_dependent_expr_sfinae): Likewise.  Drop\n\tthe potentially-constant check, and relax and turn the\n\tdependence check into a checking assert.\n\t(instantiate_non_dependent_or_null): Adjust comment.\n\t* semantics.cc (finish_decltype_type): Keep\n\tprocessing_template_decl cleared after calling\n\tinstantiate_non_dependent_expr_sfinae.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/Wnarrowing19.C: New test.", "tree": {"sha": "88d4edff9617692746c9a9347b6bfc2ae02bfc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88d4edff9617692746c9a9347b6bfc2ae02bfc7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec0f53a3a542e762f8fc8c22b9d345f922be5867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0f53a3a542e762f8fc8c22b9d345f922be5867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec0f53a3a542e762f8fc8c22b9d345f922be5867", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0f53a3a542e762f8fc8c22b9d345f922be5867/comments", "author": null, "committer": null, "parents": [{"sha": "e32869a17b788bee9ca782b174a546b1db17b5ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32869a17b788bee9ca782b174a546b1db17b5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32869a17b788bee9ca782b174a546b1db17b5ea"}], "stats": {"total": 61, "additions": 35, "deletions": 26}, "files": [{"sha": "da0a65c613d3b07787034bcc95b33e19894d6268", "filename": "gcc/cp/except.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.cc?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -1253,7 +1253,7 @@ build_noexcept_spec (tree expr, tsubst_flags_t complain)\n   if (check_for_bare_parameter_packs (expr))\n     return error_mark_node;\n   if (TREE_CODE (expr) != DEFERRED_NOEXCEPT\n-      && !value_dependent_expression_p (expr))\n+      && !instantiation_dependent_expression_p (expr))\n     {\n       expr = build_converted_constant_bool_expr (expr, complain);\n       expr = instantiate_non_dependent_expr_sfinae (expr, complain);"}, {"sha": "5c342ca631b371ce5762133cd1eda259f746ebc3", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -7958,7 +7958,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n static cp_expr\n cp_parser_parenthesized_expression_list_elt (cp_parser *parser, bool cast_p,\n \t\t\t\t\t     bool allow_expansion_p,\n-\t\t\t\t\t     bool fold_expr_p,\n \t\t\t\t\t     bool *non_constant_p)\n {\n   cp_expr expr (NULL_TREE);\n@@ -7985,9 +7984,6 @@ cp_parser_parenthesized_expression_list_elt (cp_parser *parser, bool cast_p,\n   else\n     expr = cp_parser_assignment_expression (parser, /*pidk=*/NULL, cast_p);\n \n-  if (fold_expr_p)\n-    expr = instantiate_non_dependent_expr (expr);\n-\n   /* If we have an ellipsis, then this is an expression expansion.  */\n   if (allow_expansion_p\n       && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n@@ -8053,8 +8049,6 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t\t\t\t\t\t\t       false,\n \t\t\t\t\t\t\t       /*allow_exp_p=*/\n \t\t\t\t\t\t\t       true,\n-\t\t\t\t\t\t\t       /*fold_expr_p=*/\n-\t\t\t\t\t\t\t       false,\n \t\t\t\t\t\t\t       /*non_cst_p=*/\n \t\t\t\t\t\t\t       NULL);\n \n@@ -8424,7 +8418,6 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool wrap_locations_p)\n {\n   vec<tree, va_gc> *expression_list;\n-  bool fold_expr_p = is_attribute_list != non_attr;\n   tree identifier = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n \n@@ -8467,7 +8460,6 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t    expr\n \t      = cp_parser_parenthesized_expression_list_elt (parser, cast_p,\n \t\t\t\t\t\t\t     allow_expansion_p,\n-\t\t\t\t\t\t\t     fold_expr_p,\n \t\t\t\t\t\t\t     non_constant_p);\n \n \t    if (wrap_locations_p)"}, {"sha": "f7ee33a6dfd130e8c556abd436dc54c354de9210", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -3817,7 +3817,7 @@ expand_integer_pack (tree call, tree args, tsubst_flags_t complain,\n   tree hi = tsubst_copy_and_build (ohi, args, complain, in_decl,\n \t\t\t\t   false/*fn*/, true/*int_cst*/);\n \n-  if (value_dependent_expression_p (hi))\n+  if (instantiation_dependent_expression_p (hi))\n     {\n       if (hi != ohi)\n \t{\n@@ -6349,9 +6349,7 @@ redeclare_class_template (tree type, tree parms, tree cons)\n \n /* The actual substitution part of instantiate_non_dependent_expr_sfinae,\n    to be used when the caller has already checked\n-   (processing_template_decl\n-    && !instantiation_dependent_expression_p (expr)\n-    && potential_constant_expression (expr))\n+    !instantiation_dependent_uneval_expression_p (expr)\n    and cleared processing_template_decl.  */\n \n tree\n@@ -6365,25 +6363,18 @@ instantiate_non_dependent_expr_internal (tree expr, tsubst_flags_t complain)\n \t\t\t\t/*integral_constant_expression_p=*/true);\n }\n \n-/* Simplify EXPR if it is a non-dependent expression.  Returns the\n-   (possibly simplified) expression.  */\n+/* Instantiate the non-dependent expression EXPR.  */\n \n tree\n instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n {\n   if (expr == NULL_TREE)\n     return NULL_TREE;\n \n-  /* If we're in a template, but EXPR isn't value dependent, simplify\n-     it.  We're supposed to treat:\n-\n-       template <typename T> void f(T[1 + 1]);\n-       template <typename T> void f(T[2]);\n-\n-     as two declarations of the same function, for example.  */\n-  if (processing_template_decl\n-      && is_nondependent_constant_expression (expr))\n+  if (processing_template_decl)\n     {\n+      /* The caller should have checked this already.  */\n+      gcc_checking_assert (!instantiation_dependent_uneval_expression_p (expr));\n       processing_template_decl_sentinel s;\n       expr = instantiate_non_dependent_expr_internal (expr, complain);\n     }\n@@ -6396,8 +6387,8 @@ instantiate_non_dependent_expr (tree expr)\n   return instantiate_non_dependent_expr_sfinae (expr, tf_error);\n }\n \n-/* Like instantiate_non_dependent_expr, but return NULL_TREE rather than\n-   an uninstantiated expression.  */\n+/* Like instantiate_non_dependent_expr, but return NULL_TREE if the\n+   expression is dependent or non-constant.  */\n \n tree\n instantiate_non_dependent_or_null (tree expr)"}, {"sha": "799ce943279f976d42cc4c3b6611a5d50f6aaec9", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -11217,6 +11217,8 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n   /* decltype is an unevaluated context.  */\n   cp_unevaluated u;\n \n+  processing_template_decl_sentinel ptds (/*reset=*/false);\n+\n   /* Depending on the resolution of DR 1172, we may later need to distinguish\n      instantiation-dependent but not type-dependent expressions so that, say,\n      A<decltype(sizeof(T))>::U doesn't require 'typename'.  */\n@@ -11235,6 +11237,10 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n       expr = instantiate_non_dependent_expr_sfinae (expr, complain);\n       if (expr == error_mark_node)\n \treturn error_mark_node;\n+      /* Keep processing_template_decl cleared for the rest of the function\n+\t (for sake of the call to lvalue_kind below, which handles templated\n+\t and non-templated COND_EXPR differently).  */\n+      processing_template_decl = 0;\n     }\n \n   /* The type denoted by decltype(e) is defined as follows:  */"}, {"sha": "77357016502838b0067ba3d0d76dd15ee904aec3", "filename": "gcc/testsuite/g++.dg/cpp0x/Wnarrowing19.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWnarrowing19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWnarrowing19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWnarrowing19.C?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -0,0 +1,6 @@\n+// PR c++/104823\n+// { dg-do compile { target c++11 } }\n+\n+struct S { S(int); };\n+double id(double);\n+template<class> auto f(double v) -> decltype(S{id(v)}); // { dg-error \"narrowing\" }"}, {"sha": "c52d58f8d32930061aa961d6ef0f445d21ebfd20", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-attribute4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-attribute4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0f53a3a542e762f8fc8c22b9d345f922be5867/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-attribute4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-attribute4.C?ref=ec0f53a3a542e762f8fc8c22b9d345f922be5867", "patch": "@@ -0,0 +1,14 @@\n+// Verify we correctly handle the non-dependent attribute expression which\n+// which we used to reject due to double folding.\n+// { dg-do compile { target { c++11 } } }\n+\n+struct A {\n+  constexpr int f() const { return __alignof__(int); };\n+};\n+\n+template<class...>\n+void f() {\n+  int a __attribute__((aligned(A{}.f())));\n+}\n+\n+template void f();"}]}