{"sha": "30a8c2fe6e55a253ea69377c17085bfa544ba956", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBhOGMyZmU2ZTU1YTI1M2VhNjkzNzdjMTcwODViZmE1NDRiYTk1Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-06T23:28:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-06T23:28:26Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r5651", "tree": {"sha": "d2e6f4dee374f9f80e3de7f619d36b6d8f859dc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2e6f4dee374f9f80e3de7f619d36b6d8f859dc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30a8c2fe6e55a253ea69377c17085bfa544ba956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a8c2fe6e55a253ea69377c17085bfa544ba956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a8c2fe6e55a253ea69377c17085bfa544ba956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a8c2fe6e55a253ea69377c17085bfa544ba956/comments", "author": null, "committer": null, "parents": [{"sha": "e4f316dbfc784ec94dd573ce29ca9390fe6f202e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4f316dbfc784ec94dd573ce29ca9390fe6f202e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4f316dbfc784ec94dd573ce29ca9390fe6f202e"}], "stats": {"total": 673, "additions": 571, "deletions": 102}, "files": [{"sha": "206f5c62801b7fd2fe096bc692e2858e4e3962bf", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 571, "deletions": 102, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30a8c2fe6e55a253ea69377c17085bfa544ba956/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30a8c2fe6e55a253ea69377c17085bfa544ba956/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=30a8c2fe6e55a253ea69377c17085bfa544ba956", "patch": "@@ -960,8 +960,7 @@ default_conversion (exp)\n \treturn convert (unsigned_type_node, exp);\n       return convert (integer_type_node, exp);\n     }\n-  if (flag_traditional && !flag_allow_single_precision\n-      && TYPE_MAIN_VARIANT (type) == float_type_node)\n+  if (flag_traditional && TYPE_MAIN_VARIANT (type) == float_type_node)\n     return convert (double_type_node, exp);\n   if (code == VOID_TYPE)\n     {\n@@ -1034,16 +1033,11 @@ default_conversion (exp)\n   return exp;\n }\n \f\n-/* Look up component name in the structure type definition.\n-\n-   If this component name is found indirectly within an anonymous union,\n-   store in *INDIRECT the component which directly contains\n-   that anonymous union.  Otherwise, set *INDIRECT to 0.  */\n+/* Look up component name in the structure type definition.  */\n      \n static tree\n-lookup_field (type, component, indirect)\n+lookup_field (type, component)\n      tree type, component;\n-     tree *indirect;\n {\n   tree field;\n \n@@ -1072,15 +1066,11 @@ lookup_field (type, component, indirect)\n \t      /* Step through all anon unions in linear fashion.  */\n \t      while (DECL_NAME (field_array[bot]) == NULL_TREE)\n \t\t{\n-\t\t  tree anon, junk;\n-\n+\t\t  tree anon;\n \t\t  field = field_array[bot++];\n-\t\t  anon = lookup_field (TREE_TYPE (field), component, &junk);\n+\t\t  anon = lookup_field (TREE_TYPE (field), component);\n \t\t  if (anon != NULL_TREE)\n-\t\t    {\n-\t\t      *indirect = field;\n-\t\t      return anon;\n-\t\t    }\n+\t\t    return anon;\n \t\t}\n \n \t      /* Entire record is only anon unions.  */\n@@ -1111,21 +1101,16 @@ lookup_field (type, component, indirect)\n \t{\n \t  if (DECL_NAME (field) == NULL_TREE)\n \t    {\n-\t      tree junk;\n-\t      tree anon = lookup_field (TREE_TYPE (field), component, &junk);\n+\t      tree anon = lookup_field (TREE_TYPE (field), component);\n \t      if (anon != NULL_TREE)\n-\t\t{\n-\t\t  *indirect = field;\n-\t\t  return anon;\n-\t\t}\n+\t\treturn anon;\n \t    }\n \n \t  if (DECL_NAME (field) == component)\n \t    break;\n \t}\n     }\n \n-  *indirect = NULL_TREE;\n   return field;\n }\n \n@@ -1162,15 +1147,13 @@ build_component_ref (datum, component)\n \n   if (code == RECORD_TYPE || code == UNION_TYPE)\n     {\n-      tree indirect = 0;\n-\n       if (TYPE_SIZE (type) == 0)\n \t{\n \t  incomplete_type_error (NULL_TREE, type);\n \t  return error_mark_node;\n \t}\n \n-      field = lookup_field (type, component, &indirect);\n+      field = lookup_field (type, component);\n \n       if (!field)\n \t{\n@@ -1183,19 +1166,6 @@ build_component_ref (datum, component)\n       if (TREE_TYPE (field) == error_mark_node)\n \treturn error_mark_node;\n \n-      /* If FIELD was found buried within an anonymous union,\n-\t make one COMPONENT_REF to get that anonymous union,\n-\t then fall thru to make a second COMPONENT_REF to get FIELD.  */\n-      if (indirect != 0)\n-\t{\n-\t  ref = build (COMPONENT_REF, TREE_TYPE (indirect), datum, indirect);\n-\t  if (TREE_READONLY (datum) || TREE_READONLY (indirect))\n-\t    TREE_READONLY (ref) = 1;\n-\t  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (indirect))\n-\t    TREE_THIS_VOLATILE (ref) = 1;\n-\t  datum = ref;\n-\t}\n-\n       ref = build (COMPONENT_REF, TREE_TYPE (field), datum, field);\n \n       if (TREE_READONLY (datum) || TREE_READONLY (field))\n@@ -1403,6 +1373,541 @@ build_array_ref (array, index)\n   }\n }\n \f\n+/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against PARAMS.  */\n+\n+#define ISDIGIT(c)\t((c) >= '0' && (c) <= '9')\n+\n+#define T_I\t&integer_type_node\n+#define T_L\t&long_integer_type_node\n+#define T_S\t&short_integer_type_node\n+#define T_UI\t&unsigned_type_node\n+#define T_UL\t&long_unsigned_type_node\n+#define T_US\t&short_unsigned_type_node\n+#define T_F\t&float_type_node\n+#define T_D\t&double_type_node\n+#define T_LD\t&long_double_type_node\n+#define T_C\t&char_type_node\n+#define T_V\t&void_type_node\n+#define T_W\t&wchar_type_node\n+\n+typedef struct\n+{\n+  char *format_chars;\n+  int pointer_count;\n+  /* Type of argument if no length modifier is used.  */\n+  tree *nolen;\n+  /* Type of argument if length modifier for shortening is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *hlen;\n+  /* Type of argument if length modifier `l' is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *llen;\n+  /* Type of argument if length modifier `L' is used.\n+     If NULL, then this modifier is not allowed.  */\n+  tree *bigllen;\n+  /* List of other modifier characters allowed with these options.  */\n+  char *flag_chars;\n+} format_char_info;\n+\n+static format_char_info print_table[]\n+  = {\n+      { \"di\",\t\t0,\tT_I,\tT_I,\tT_L,\tNULL,\t\"-wp0 +\" },\n+      { \"oxX\",\t\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0#\" },\n+      { \"u\",\t\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0\" },\n+      { \"feEgG\",\t0,\tT_D,\tNULL,\tNULL,\tT_LD,\t\"-wp0 +#\" },\n+      { \"c\",\t\t0,\tT_I,\tNULL,\tT_W,\tNULL,\t\"-w\" },\n+      { \"C\",\t\t0,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-w\" },\n+      { \"s\",\t\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"-wp\" },\n+      { \"S\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-wp\" },\n+      { \"p\",\t\t1,\tT_V,\tNULL,\tNULL,\tNULL,\t\"-w\" },\n+      { \"n\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\" },\n+      { NULL }\n+    };\n+\n+static format_char_info scan_table[]\n+  = {\n+      { \"di\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"*\" },\n+      { \"ouxX\",\t\t1,\tT_UI,\tT_US,\tT_UL,\tNULL,\t\"*\" },\t\n+      { \"efgEG\",\t1,\tT_F,\tNULL,\tT_D,\tT_LD,\t\"*\" },\n+      { \"sc\",\t\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"*\" },\n+      { \"[\",\t\t1,\tT_C,\tNULL,\tNULL,\tNULL,\t\"*\" },\n+      { \"C\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\" },\n+      { \"S\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\" },\n+      { \"p\",\t\t2,\tT_V,\tNULL,\tNULL,\tNULL,\t\"*\" },\n+      { \"n\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\" },\n+      { NULL }\n+    };\n+\n+typedef struct\n+{\n+  tree function_ident;\t\t/* identifier such as \"printf\" */\n+  int is_scan;\t\t\t/* TRUE if *scanf */\n+  int format_num;\t\t/* number of format argument */\n+  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n+} function_info;\n+\n+static unsigned int function_info_entries = 0;\n+static function_info *function_info_table = NULL;\n+\n+/* Record information for argument format checking.  FUNCTION_IDENT is\n+   the identifier node for the name of the function to check (its decl\n+   need not exist yet).  IS_SCAN is true for scanf-type format checking;\n+   false indicates printf-style format checking.  FORMAT_NUM is the number\n+   of the argument which is the format control string (starting from 1).\n+   FIRST_ARG_NUM is the number of the first actual argument to check\n+   against teh format string, or zero if no checking is not be done\n+   (e.g. for varargs such as vfprintf).  */\n+\n+void\n+record_format_info (function_ident, is_scan, format_num, first_arg_num)\n+      tree function_ident;\n+      int is_scan;\n+      int format_num;\n+      int first_arg_num;\n+{\n+  function_info *info;\n+  \n+  function_info_entries++;\n+  if (function_info_table)\n+    function_info_table\n+      = (function_info *) xrealloc (function_info_table,\n+\t\t\t\t    function_info_entries * sizeof (function_info));\n+  else\n+    function_info_table = (function_info *) xmalloc (sizeof (function_info));\n+\n+  info = &function_info_table[function_info_entries - 1];\n+  \n+  info->function_ident = function_ident;\n+  info->is_scan = is_scan;\n+  info->format_num = format_num;\n+  info->first_arg_num = first_arg_num;\n+}\n+\n+/* Initialize the table of functions to perform format checking on.\n+   The ANSI functions are always checked (whether <stdio.h> is\n+   included or not), since it is common to call printf without\n+   including <stdio.h>.  There shouldn't be a problem with this,\n+   since ANSI reserves these function names whether you include the\n+   header file or not.  In any case, the checking is harmless.  */\n+\n+void\n+init_format_info_table ()\n+{\n+  record_format_info (get_identifier (\"printf\"), 0, 1, 2);\n+  record_format_info (get_identifier (\"fprintf\"), 0, 2, 3);\n+  record_format_info (get_identifier (\"sprintf\"), 0, 2, 3);\n+  record_format_info (get_identifier (\"scanf\"), 1, 1, 2);\n+  record_format_info (get_identifier (\"fscanf\"), 1, 2, 3);\n+  record_format_info (get_identifier (\"sscanf\"), 1, 2, 3);\n+  record_format_info (get_identifier (\"vprintf\"), 0, 1, 0);\n+  record_format_info (get_identifier (\"vfprintf\"), 0, 2, 0);\n+  record_format_info (get_identifier (\"vsprintf\"), 0, 2, 0);\n+}\n+\n+static char\ttfaff[] = \"too few arguments for format\";\n+\f\n+/* Check the argument list of a call to printf, scanf, etc.\n+   INFO points to the element of function_info_table.\n+   PARAMS is the list of argument values.  */\n+\n+static void\n+check_format (info, params)\n+     function_info *info;\n+     tree params;\n+{\n+  int i;\n+  int arg_num;\n+  int suppressed, wide, precise;\n+  int length_char;\n+  int format_char;\n+  int format_length;\n+  tree format_tree;\n+  tree cur_param;\n+  tree cur_type;\n+  tree wanted_type;\n+  char *format_chars;\n+  format_char_info *fci;\n+  static char message[132];\n+  char flag_chars[8];\n+\n+  /* Skip to format argument.  If the argument isn't available, there's\n+     no work for us to do; prototype checking will catch the problem.  */\n+  for (arg_num = 1; ; ++arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      if (arg_num == info->format_num)\n+\tbreak;\n+      params = TREE_CHAIN (params);\n+    }\n+  format_tree = TREE_VALUE (params);\n+  params = TREE_CHAIN (params);\n+  if (format_tree == 0)\n+    return;\n+  /* We can only check the format if it's a string constant.  */\n+  while (TREE_CODE (format_tree) == NOP_EXPR)\n+    format_tree = TREE_OPERAND (format_tree, 0); /* strip coercion */\n+  if (format_tree == null_pointer_node)\n+    {\n+      warning (\"null format string\");\n+      return;\n+    }\n+  if (TREE_CODE (format_tree) != ADDR_EXPR)\n+    return;\n+  format_tree = TREE_OPERAND (format_tree, 0);\n+  if (TREE_CODE (format_tree) != STRING_CST)\n+    return;\n+  format_chars = TREE_STRING_POINTER (format_tree);\n+  format_length = TREE_STRING_LENGTH (format_tree);\n+  if (format_length <= 1)\n+    warning (\"zero-length format string\");\n+  if (format_chars[--format_length] != 0)\n+    {\n+      warning (\"unterminated format string\");\n+      return;\n+    }\n+  /* Skip to first argument to check.  */\n+  while (arg_num + 1 < info->first_arg_num)\n+    {\n+      if (params == 0)\n+\treturn;\n+      params = TREE_CHAIN (params);\n+      ++arg_num;\n+    }\n+  while (1)\n+    {\n+      if (*format_chars == 0)\n+\t{\n+\t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n+\t    warning (\"embedded `\\\\0' in format\");\n+\t  if (info->first_arg_num != 0 && params != 0)\n+\t    warning (\"too many arguments for format\");\n+\t  return;\n+\t}\n+      if (*format_chars++ != '%')\n+\tcontinue;\n+      if (*format_chars == 0)\n+\t{\n+\t  warning (\"spurious trailing `%%' in format\");\n+\t  continue;\n+\t}\n+      if (*format_chars == '%')\n+\t{\n+\t  ++format_chars;\n+\t  continue;\n+\t}\n+      flag_chars[0] = 0;\n+      suppressed = wide = precise = FALSE;\n+      if (info->is_scan)\n+\t{\n+\t  suppressed = *format_chars == '*';\n+\t  if (suppressed)\n+\t    ++format_chars;\n+\t  while (ISDIGIT (*format_chars))\n+\t    ++format_chars;\n+\t}\n+      else\n+\t{\n+\t  while (*format_chars != 0 && index (\" +#0-\", *format_chars) != 0)\n+\t    {\n+\t      if (index (flag_chars, *format_chars) != 0)\n+\t\t{\n+\t\t  sprintf (message, \"repeated `%c' flag in format\",\n+\t\t\t   *format_chars);\n+\t\t  warning (message);\n+\t\t}\n+\t      i = strlen (flag_chars);\n+\t      flag_chars[i++] = *format_chars++;\n+\t      flag_chars[i] = 0;\n+\t    }\n+\t  /* \"If the space and + flags both appear, \n+\t     the space flag will be ignored.\"  */\n+\t  if (index (flag_chars, ' ') != 0\n+\t      && index (flag_chars, '+') != 0)\n+\t    warning (\"use of both ` ' and `+' flags in format\");\n+\t  /* \"If the 0 and - flags both appear,\n+\t     the 0 flag will be ignored.\"  */\n+\t  if (index (flag_chars, '0') != 0\n+\t      && index (flag_chars, '-') != 0)\n+\t    warning (\"use of both `0' and `-' flags in format\");\n+\t  if (*format_chars == '*')\n+\t    {\n+\t      wide = TRUE;\n+\t      /* \"...a field width...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the field width...\"  */\n+\t      ++format_chars;\n+\t      if (params == 0)\n+\t\t{\n+\t\t  warning (tfaff);\n+\t\t  return;\n+\t\t}\n+\t      if (info->first_arg_num != 0)\n+\t\t{\n+\t\t  cur_param = TREE_VALUE (params);\n+\t\t  params = TREE_CHAIN (params);\n+\t\t  ++arg_num;\n+\t\t  /* size_t is generally not valid here.\n+\t\t     It will work on most machines, because size_t and int\n+\t\t     have the same mode.  But might as well warn anyway,\n+\t\t     since it will fail on other machines.  */\n+\t\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t      != integer_type_node)\n+\t\t    {\n+\t\t      sprintf (message,\n+\t\t\t       \"field width is not type int (arg %d)\",\n+\t\t\t       arg_num);\n+\t\t      warning (message);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      while (ISDIGIT (*format_chars))\n+\t\t{\n+\t\t  wide = TRUE;\n+\t\t  ++format_chars;\n+\t\t}\n+\t    }\n+\t  if (*format_chars == '.')\n+\t    {\n+\t      precise = TRUE;\n+\t      ++format_chars;\n+\t      if (*format_chars != '*' && !ISDIGIT (*format_chars))\n+\t\twarning (\"`.' not followed by `*' or digit in format\");\n+\t      /* \"...a...precision...may be indicated by an asterisk.\n+\t\t In this case, an int argument supplies the...precision.\"  */\n+\t      if (*format_chars == '*')\n+\t\t{\n+\t\t  if (info->first_arg_num != 0)\n+\t\t    {\n+\t\t      ++format_chars;\n+\t\t      if (params == 0)\n+\t\t        {\n+\t\t\t  warning (tfaff);\n+\t\t\t  return;\n+\t\t\t}\n+\t\t      cur_param = TREE_VALUE (params);\n+\t\t      params = TREE_CHAIN (params);\n+\t\t      ++arg_num;\n+\t\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t\t  != integer_type_node)\n+\t\t        {\n+\t\t          sprintf (message,\n+\t\t\t\t   \"field width is not type int (arg %d)\",\n+\t\t\t\t   arg_num);\n+\t\t          warning (message);\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  while (ISDIGIT (*format_chars))\n+\t\t    ++format_chars;\n+\t\t}\n+\t    }\n+\t}\n+      if (*format_chars == 'h' || *format_chars == 'l' || *format_chars == 'L')\n+\tlength_char = *format_chars++;\n+      else\n+\tlength_char = 0;\n+      if (suppressed && length_char != 0)\n+\t{\n+\t  sprintf (message,\n+\t\t   \"use of `*' and `%c' together in format\",\n+\t\t   length_char);\n+\t  warning (message);\n+\t}\n+      format_char = *format_chars;\n+      if (format_char == 0)\n+\t{\n+\t  warning (\"conversion lacks type at end of format\");\n+\t  continue;\n+\t}\n+      format_chars++;\n+      fci = info->is_scan ? scan_table : print_table;\n+      while (1)\n+\t{\n+\t  if (fci->format_chars == 0\n+\t      || index (fci->format_chars, format_char) != 0)\n+\t    break;\n+\t  ++fci;\n+\t}\n+      if (fci->format_chars == 0)\n+\t{\n+\t  if (format_char >= 040 && format_char < 0177)\n+\t    sprintf (message,\n+\t\t     \"unknown conversion type character `%c' in format\",\n+\t\t     format_char);\n+\t  else\n+\t    sprintf (message,\n+\t\t     \"unknown conversion type character 0x%x in format\",\n+\t\t     format_char);\n+\t  warning (message);\n+\t  continue;\n+\t}\n+      if (wide && index (fci->flag_chars, 'w') == 0)\n+\t{\n+\t  sprintf (message, \"width used with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      if (precise && index (fci->flag_chars, 'p') == 0)\n+\t{\n+\t  sprintf (message, \"precision used with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      if (info->is_scan && format_char == '[')\n+\t{\n+\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n+\t  if (*format_chars == '^')\n+\t    ++format_chars;\n+\t  /* Find closing bracket; if one is hit immediately, then\n+\t     it's part of the scan set rather than a terminator.  */\n+\t  if (*format_chars == ']')\n+\t    ++format_chars;\n+\t  while (*format_chars && *format_chars != ']')\n+\t    ++format_chars;\n+\t  if (*format_chars != ']')\n+\t      /* The end of the format string was reached.  */\n+\t      warning (\"no closing `]' for `%%[' format\");\n+\t}\n+      if (suppressed)\n+\t{\n+\t  if (index (fci->flag_chars, '*') == 0)\n+\t    {\n+\t      sprintf (message,\n+\t\t       \"suppression of `%c' conversion in format\",\n+\t\t       format_char);\n+\t      warning (message);\n+\t    }\n+\t  continue;\n+\t}\n+      for (i = 0; flag_chars[i] != 0; ++i)\n+\t{\n+\t  if (index (fci->flag_chars, flag_chars[i]) == 0)\n+\t    {\n+\t      sprintf (message, \"flag `%c' used with type `%c'\",\n+\t\t       flag_chars[i], format_char);\n+\t      warning (message);\n+\t    }\n+\t}\n+      if (precise && index (flag_chars, '0') != 0\n+\t  && (format_char == 'd' || format_char == 'i'\n+\t      || format_char == 'o' || format_char == 'u'\n+\t      || format_char == 'x' || format_char == 'x'))\n+\t{\n+\t  sprintf (message,\n+\t\t   \"precision and `0' flag not both allowed with `%c' format\",\n+\t\t   format_char);\n+\t  warning (message);\n+\t}\n+      switch (length_char)\n+\t{\n+\tdefault: wanted_type = fci->nolen ? *(fci->nolen) : 0; break;\n+\tcase 'h': wanted_type = fci->hlen ? *(fci->hlen) : 0; break;\n+\tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n+\tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n+\t}\n+      if (wanted_type == 0)\n+\t{\n+\t  sprintf (message,\n+\t\t   \"use of `%c' length character with `%c' type character\",\n+\t\t   length_char, format_char);\n+\t  warning (message);\n+\t}\n+\n+      /*\n+       ** XXX -- should kvetch about stuff such as\n+       **\t{\n+       **\t\tconst int\ti;\n+       **\n+       **\t\tscanf (\"%d\", &i);\n+       **\t}\n+       */\n+\n+      /* Finally. . .check type of argument against desired type!  */\n+      if (info->first_arg_num == 0)\n+\tcontinue;\n+      if (params == 0)\n+\t{\n+\t  warning (tfaff);\n+\t  return;\n+\t}\n+      cur_param = TREE_VALUE (params);\n+      params = TREE_CHAIN (params);\n+      ++arg_num;\n+      cur_type = TREE_TYPE (cur_param);\n+\n+      /* Check the types of any additional pointer arguments\n+\t that precede the \"real\" argument.  */\n+      for (i = 0; i < fci->pointer_count; ++i)\n+\t{\n+\t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n+\t    {\n+\t      cur_type = TREE_TYPE (cur_type);\n+\t      continue;\n+\t    }\n+\t  sprintf (message,\n+\t\t   \"format argument is not a %s (arg %d)\",\n+\t\t   ((fci->pointer_count == 1) ? \"pointer\" : \"pointer to a pointer\"),\n+\t\t   arg_num);\n+\t  warning (message);\n+\t  break;\n+\t}\n+\n+      /* Check the type of the \"real\" argument, if there's a type we want.  */\n+      if (i == fci->pointer_count && wanted_type != 0\n+\t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n+\t  /* If we want `void *', allow any pointer type.\n+\t     (Anything else would already have got a warning.)  */\n+\t  && ! (wanted_type == void_type_node\n+\t\t&& fci->pointer_count > 0)\n+\t  /* Don't warn about differences merely in signedness.  */\n+\t  && !(TREE_CODE (wanted_type) == INTEGER_TYPE\n+\t       && TREE_CODE (cur_type) == INTEGER_TYPE\n+\t       && (wanted_type == (TREE_UNSIGNED (wanted_type)\n+\t\t\t\t   ? unsigned_type : signed_type) (cur_type))))\n+\t{\n+\t  register char *this;\n+\t  register char *that;\n+  \n+\t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n+\t  that = 0;\n+\t  if (TREE_CODE (cur_type) != ERROR_MARK\n+\t      && TYPE_NAME (cur_type) != 0\n+\t      && TREE_CODE (cur_type) != INTEGER_TYPE\n+\t      && !(TREE_CODE (cur_type) == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (cur_type)) == INTEGER_TYPE))\n+\t    {\n+\t      if (TREE_CODE (TYPE_NAME (cur_type)) == TYPE_DECL\n+\t\t  && DECL_NAME (TYPE_NAME (cur_type)) != 0)\n+\t\tthat = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n+\t      else\n+\t\tthat = IDENTIFIER_POINTER (TYPE_NAME (cur_type));\n+\t    }\n+\n+\t  /* A nameless type can't possibly match what the format wants.\n+\t     So there will be a warning for it.\n+\t     Make up a string to describe vaguely what it is.  */\n+\t  if (that == 0)\n+\t    {\n+\t      if (TREE_CODE (cur_type) == POINTER_TYPE)\n+\t\tthat = \"pointer\";\n+\t      else\n+\t\tthat = \"different type\";\n+\t    }\n+\n+\t  if (strcmp (this, that) != 0)\n+\t    {\n+\t      sprintf (message, \"%s format, %s arg (arg %d)\",\n+\t\t\tthis, that, arg_num);\n+\t      warning (message);\n+\t    }\n+\t}\n+    }\n+}\n+\f\n /* Build a function call to function FUNCTION with parameters PARAMS.\n    PARAMS is a list--a chain of TREE_LIST nodes--in which the\n    TREE_VALUE of each node is a parameter-expression.\n@@ -1414,7 +1919,7 @@ build_function_call (function, params)\n {\n   register tree fntype, fundecl;\n   register tree coerced_params;\n-  tree name = NULL_TREE, assembler_name = NULL_TREE;\n+  tree name = NULL_TREE;\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (function);\n@@ -1423,8 +1928,6 @@ build_function_call (function, params)\n   if (TREE_CODE (function) == FUNCTION_DECL)\n     {\n       name = DECL_NAME (function);\n-      assembler_name = DECL_ASSEMBLER_NAME (function);\n-\n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n \t needs to be separately compiled).  */\n@@ -1459,9 +1962,21 @@ build_function_call (function, params)\n     = convert_arguments (TYPE_ARG_TYPES (fntype), params, name, fundecl);\n \n   /* Check for errors in format strings.  */\n+  if (warn_format && name != 0)\n+    {\n+      unsigned int i;\n \n-  if (warn_format && (name || assembler_name))\n-    check_function_format (name, assembler_name, coerced_params);\n+      /* See if this function is a format function.  */\n+      for (i = 0; i < function_info_entries; i++)\n+\tif (function_info_table[i].function_ident == name)\n+\t  {\n+\t    register char *message;\n+\n+\t    /* If so, check it.  */\n+\t    check_format (&function_info_table[i], coerced_params);\n+\t    break;\n+\t  }\n+    }\n \n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c\n@@ -3472,8 +3987,8 @@ build_c_cast (type, expr)\n \t    }\n \t  else\n \t    name = \"\";\n-\t  return digest_init (type, build (CONSTRUCTOR, type, NULL_TREE,\n-\t\t\t\t\t   build_tree_list (field, value)),\n+\t  return digest_init (type, build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\t      build_tree_list (field, value)),\n \t\t\t      0, 0);\n \t}\n       error (\"cast to union type from type not present in union\");\n@@ -3597,13 +4112,11 @@ build_modify_expr (lhs, modifycode, rhs)\n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n       pedantic_lvalue_warning (COMPOUND_EXPR);\n-      newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n-\t\t\t\t  modifycode, rhs);\n-      if (TREE_CODE (newrhs) == ERROR_MARK)\n-\treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype,\n-\t\t    TREE_OPERAND (lhs, 0), newrhs);\n- \n+\t\t    TREE_OPERAND (lhs, 0),\n+\t\t    build_modify_expr (TREE_OPERAND (lhs, 1),\n+\t\t\t\t       modifycode, rhs));\n+\n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:\n       pedantic_lvalue_warning (COND_EXPR);\n@@ -3618,8 +4131,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t\t       modifycode, rhs),\n \t\t\t\t    build_modify_expr (TREE_OPERAND (lhs, 2),\n \t\t\t\t\t\t       modifycode, rhs));\n-\tif (TREE_CODE (cond) == ERROR_MARK)\n-\t  return cond;\n \t/* Make sure the code to compute the rhs comes out\n \t   before the split.  */\n \treturn build (COMPOUND_EXPR, TREE_TYPE (lhs),\n@@ -3662,8 +4173,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n \t\t\t\t    convert (TREE_TYPE (inner_lhs),\n \t\t\t\t\t     convert (lhstype, newrhs)));\n-\tif (TREE_CODE (result) == ERROR_MARK)\n-\t  return result;\n \tpedantic_lvalue_warning (CONVERT_EXPR);\n \treturn convert (TREE_TYPE (lhs), result);\n       }\n@@ -4271,12 +4780,9 @@ push_string (string)\n /* Push a member name on the stack.  Printed as '.' STRING.  */\n \n static void\n-push_member_name (decl)\n-     tree decl;\n-     \n+push_member_name (string)\n+     char *string;\n {\n-  char *string\n-    = DECL_NAME (decl) ? IDENTIFIER_POINTER (DECL_NAME (decl)) : \"<anonymous>\";\n   PUSH_SPELLING (SPELLING_MEMBER, string, u.s);\n }\n \n@@ -5013,7 +5519,7 @@ push_init_level (implicit)\n       else\n \t{\n \t  constructor_type = TREE_TYPE (constructor_fields);\n-\t  push_member_name (constructor_fields);\n+\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n \t}\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n@@ -5173,28 +5679,6 @@ pop_init_level (implicit)\n     }\n   else if (constructor_type == 0)\n     ;\n-  else if (TREE_CODE (constructor_type) != RECORD_TYPE\n-\t   && TREE_CODE (constructor_type) != UNION_TYPE\n-\t   && TREE_CODE (constructor_type) != ARRAY_TYPE\n-\t   && ! constructor_incremental)\n-    {\n-      /* A nonincremental scalar initializer--just return\n-\t the element, after verifying there is just one.  */\n-      if (constructor_elements == 0)\n-\t{\n-\t  error_init (\"empty scalar initializer%s\",\n-\t\t      \" for `%s'\", NULL);\n-\t  constructor = error_mark_node;\n-\t}\n-      else if (TREE_CHAIN (constructor_elements) != 0)\n-\t{\n-\t  error_init (\"extra elements in scalar initializer%s\",\n-\t\t      \" for `%s'\", NULL);\n-\t  constructor = TREE_VALUE (constructor_elements);\n-\t}\n-      else\n-\tconstructor = TREE_VALUE (constructor_elements);\n-    }\n   else if (! constructor_incremental)\n     {\n       if (constructor_erroneous)\n@@ -5209,7 +5693,6 @@ pop_init_level (implicit)\n \t    TREE_CONSTANT (constructor) = 1;\n \t  if (constructor_constant && constructor_simple)\n \t    TREE_STATIC (constructor) = 1;\n-\n \t  resume_momentary (momentary);\n \t}\n     }\n@@ -5309,20 +5792,6 @@ void\n set_init_index (first, last)\n      tree first, last;\n {\n-  while ((TREE_CODE (first) == NOP_EXPR\n-\t  || TREE_CODE (first) == CONVERT_EXPR\n-\t  || TREE_CODE (first) == NON_LVALUE_EXPR)\n-\t && (TYPE_MODE (TREE_TYPE (first))\n-\t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (first, 0)))))\n-    (first) = TREE_OPERAND (first, 0);\n-  if (last)\n-    while ((TREE_CODE (last) == NOP_EXPR\n-\t    || TREE_CODE (last) == CONVERT_EXPR\n-\t    || TREE_CODE (last) == NON_LVALUE_EXPR)\n-\t   && (TYPE_MODE (TREE_TYPE (last))\n-\t       == TYPE_MODE (TREE_TYPE (TREE_OPERAND (last, 0)))))\n-      (last) = TREE_OPERAND (last, 0);\n-\n   if (TREE_CODE (first) != INTEGER_CST)\n     error_init (\"nonconstant array index in initializer%s\", \" for `%s'\", NULL);\n   else if (last != 0 && TREE_CODE (last) != INTEGER_CST)\n@@ -5491,7 +5960,7 @@ output_init_element (value, type, field, pending)\n \t{\n \t  if (! constructor_incremental)\n \t    {\n-\t      if (field && TREE_CODE (field) == INTEGER_CST)\n+\t      if (TREE_CODE (field) == INTEGER_CST)\n \t\tfield = copy_node (field);\n \t      constructor_elements\n \t\t= tree_cons (field, digest_init (type, value, 0, 0),\n@@ -5789,7 +6258,7 @@ process_init_element (value)\n \n \t  if (value)\n \t    {\n-\t      push_member_name (constructor_fields);\n+\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n \t      output_init_element (value, fieldtype, constructor_fields, 1);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }\n@@ -5846,7 +6315,7 @@ process_init_element (value)\n \n \t  if (value)\n \t    {\n-\t      push_member_name (constructor_fields);\n+\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n \t      output_init_element (value, fieldtype, constructor_fields, 1);\n \t      RESTORE_SPELLING_DEPTH (constructor_depth);\n \t    }"}]}