{"sha": "0c27fe96f812df76ca07272d3c68765bd1f9dc08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyN2ZlOTZmODEyZGY3NmNhMDcyNzJkM2M2ODc2NWJkMWY5ZGMwOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-12T14:55:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-02-12T21:50:03Z"}, "message": "c++: Register streamed-in decls when new [PR 99040]\n\nWith modules one can have using-decls refering to their own scope.  This\nis the way to export things from the GMF or from an import.  The\nproblem was I was using current_ns == CP_DECL_CONTEXT (decl) to\ndetermine whether a decl should be registered in a namespace level or\nnot.  But that's an inadequate check and we ended up reregistering\ndecls and creating a circular list.  We should be registering the decl\nwhen first encountered -- whether we bind it is orthogonal to that.\n\n\tPR c++/99040\n\tgcc/cp/\n\t* module.cc (trees_in::decl_value): Call add_module_namespace_decl\n\tfor new namespace-scope entities.\n\t(module_state::read_cluster): Don't call add_module_decl here.\n\t* name-lookup.h (add_module_decl): Rename to ...\n\t(add_module_namespace_decl): ... this.\n\t* name-lookup.c (newbinding_bookkeeping): Move into ...\n\t(do_pushdecl): ... here.  Its only remaining caller.\n\t(add_module_decl): Rename to ...\n\t(add_module_namespace_decl): ... here.  Add checking-assert for\n\tcircularity. Don't call newbinding_bookkeeping, just extern_c\n\tchecking and incomplete var checking.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr99040_a.C: New.\n\t* g++.dg/modules/pr99040_b.C: New.\n\t* g++.dg/modules/pr99040_c.C: New.\n\t* g++.dg/modules/pr99040_d.C: New.", "tree": {"sha": "674ead99157d3d8382dd112f2bd4fd8c519972aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/674ead99157d3d8382dd112f2bd4fd8c519972aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c27fe96f812df76ca07272d3c68765bd1f9dc08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c27fe96f812df76ca07272d3c68765bd1f9dc08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c27fe96f812df76ca07272d3c68765bd1f9dc08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c27fe96f812df76ca07272d3c68765bd1f9dc08/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f93e1b892850b00bf6b9cbc5711a7d5bc367967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f93e1b892850b00bf6b9cbc5711a7d5bc367967"}], "stats": {"total": 140, "additions": 82, "deletions": 58}, "files": [{"sha": "37ccddc74a578586d550aacf455dddf5d91072e0", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -8162,6 +8162,12 @@ trees_in::decl_value ()\n \t/* Set the TEMPLATE_DECL's type.  */\n \tTREE_TYPE (decl) = TREE_TYPE (inner);\n \n+      if (NAMESPACE_SCOPE_P (decl)\n+\t  && (mk == MK_named || mk == MK_unique\n+\t      || mk == MK_enum || mk == MK_friend_spec)\n+\t  && !(VAR_OR_FUNCTION_DECL_P (decl) && DECL_LOCAL_DECL_P (decl)))\n+\tadd_module_namespace_decl (CP_DECL_CONTEXT (decl), decl);\n+\n       /* The late insertion of an alias here or an implicit member\n          (next block), is ok, because we ensured that all imports were\n          loaded up before we started this cluster.  Thus an insertion\n@@ -14893,20 +14899,6 @@ module_state::read_cluster (unsigned snum)\n \t\t\t\t     : 0,\n \t\t\t\t     decls, type, visible))\n \t      sec.set_overrun ();\n-\n-\t    if (type\n-\t\t&& CP_DECL_CONTEXT (type) == ns\n-\t\t&& !sec.is_duplicate (type))\n-\t      add_module_decl (ns, name, type);\n-\n-\t    for (ovl_iterator iter (decls); iter; ++iter)\n-\t      if (!iter.using_p ())\n-\t\t{\n-\t\t  tree decl = *iter;\n-\t\t  if (CP_DECL_CONTEXT (decl) == ns\n-\t\t      && !sec.is_duplicate (decl))\n-\t\t    add_module_decl (ns, name, decl);\n-\t\t}\n \t  }\n \t  break;\n "}, {"sha": "5aa206d40d4671321c0f6811d93c360b334a3775", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -382,7 +382,8 @@ add_decl_to_level (cp_binding_level *b, tree decl)\n \n   /* Make sure we don't create a circular list.  xref_tag can end\n      up pushing the same artificial decl more than once.  We\n-     should have already detected that in update_binding.  */\n+     should have already detected that in update_binding.  (This isn't a\n+     complete verification of non-circularity.)  */\n   gcc_assert (b->names != decl);\n \n   /* We build up the list in reverse order, and reverse it later if\n@@ -3496,41 +3497,6 @@ implicitly_export_namespace (tree ns)\n     }\n }\n \n-/* DECL has just been bound at LEVEL.  finish up the bookkeeping.  */\n-\n-static void\n-newbinding_bookkeeping (tree name, tree decl, cp_binding_level *level)\n-{\n-  if (TREE_CODE (decl) == TYPE_DECL)\n-    {\n-      tree type = TREE_TYPE (decl);\n-\n-      if (type != error_mark_node)\n-\t{\n-\t  if (TYPE_NAME (type) != decl)\n-\t    set_underlying_type (decl);\n-\n-\t  set_identifier_type_value_with_scope (name, decl, level);\n-\n-\t  if (level->kind != sk_namespace\n-\t      && !instantiating_current_function_p ())\n-\t    /* This is a locally defined typedef in a function that\n-\t       is not a template instantation, record it to implement\n-\t       -Wunused-local-typedefs.  */\n-\t    record_locally_defined_typedef (decl);\n-\t}\n-    }\n-  else\n-    {\n-      if (VAR_P (decl) && !DECL_LOCAL_DECL_P (decl))\n-\tmaybe_register_incomplete_var (decl);\n-\n-      if (VAR_OR_FUNCTION_DECL_P (decl)\n-\t  && DECL_EXTERN_C_P (decl))\n-\tcheck_extern_c_conflict (decl);\n-    }\n-}\n-\n /* DECL is a global or module-purview entity.  If it has non-internal\n    linkage, and we have a module vector, record it in the appropriate\n    slot.  We have already checked for duplicates.  */\n@@ -3839,12 +3805,38 @@ do_pushdecl (tree decl, bool hiding)\n \tdecl = old;\n       else\n \t{\n-\t  newbinding_bookkeeping (name, decl, level);\n+\t  if (TREE_CODE (decl) == TYPE_DECL)\n+\t    {\n+\t      tree type = TREE_TYPE (decl);\n+\n+\t      if (type != error_mark_node)\n+\t\t{\n+\t\t  if (TYPE_NAME (type) != decl)\n+\t\t    set_underlying_type (decl);\n \n-\t  if (VAR_OR_FUNCTION_DECL_P (decl)\n-\t      && DECL_LOCAL_DECL_P (decl)\n-\t      && TREE_CODE (CP_DECL_CONTEXT (decl)) == NAMESPACE_DECL)\n-\t    push_local_extern_decl_alias (decl);\n+\t\t  set_identifier_type_value_with_scope (name, decl, level);\n+\n+\t\t  if (level->kind != sk_namespace\n+\t\t      && !instantiating_current_function_p ())\n+\t\t    /* This is a locally defined typedef in a function that\n+\t\t       is not a template instantation, record it to implement\n+\t\t       -Wunused-local-typedefs.  */\n+\t\t    record_locally_defined_typedef (decl);\n+\t\t}\n+\t    }\n+\t  else if (VAR_OR_FUNCTION_DECL_P (decl))\n+\t    {\n+\t      if (DECL_EXTERN_C_P (decl))\n+\t\tcheck_extern_c_conflict (decl);\n+\n+\t      if (!DECL_LOCAL_DECL_P (decl)\n+\t\t  && VAR_P (decl))\n+\t\tmaybe_register_incomplete_var (decl);\n+\n+\t      if (DECL_LOCAL_DECL_P (decl)\n+\t\t  && NAMESPACE_SCOPE_P (decl))\n+\t\tpush_local_extern_decl_alias (decl);\n+\t    }\n \n \t  if (level->kind == sk_namespace\n \t      && TREE_PUBLIC (level->this_entity))\n@@ -4182,11 +4174,25 @@ load_pending_specializations (tree ns, tree name)\n }\n \n void\n-add_module_decl (tree ns, tree name, tree decl)\n+add_module_namespace_decl (tree ns, tree decl)\n {\n   gcc_assert (!DECL_CHAIN (decl));\n+  gcc_checking_assert (!(VAR_OR_FUNCTION_DECL_P (decl)\n+\t\t\t && DECL_LOCAL_DECL_P (decl)));\n+  if (CHECKING_P)\n+    /* Expensive already-there? check.  */\n+    for (auto probe = NAMESPACE_LEVEL (ns)->names; probe;\n+\t probe = DECL_CHAIN (probe))\n+      gcc_assert (decl != probe);\n+\n   add_decl_to_level (NAMESPACE_LEVEL (ns), decl);\n-  newbinding_bookkeeping (name, decl, NAMESPACE_LEVEL (ns));\n+\n+  if (VAR_P (decl))\n+    maybe_register_incomplete_var (decl);\n+\n+  if (VAR_OR_FUNCTION_DECL_P (decl)\n+      && DECL_EXTERN_C_P (decl))\n+    check_extern_c_conflict (decl);\n }\n \n /* Enter DECL into the symbol table, if that's appropriate.  Returns"}, {"sha": "cb75566d1aeb27a9c281ad086d61bc32f892db81", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -490,7 +490,7 @@ extern bool import_module_binding (tree ctx, tree name, unsigned mod,\n extern bool set_module_binding (tree ctx, tree name, unsigned mod,\n \t\t\t\tint mod_glob_flag,\n \t\t\t\ttree value, tree type, tree visible);\n-extern void add_module_decl (tree ctx, tree name, tree decl);\n+extern void add_module_namespace_decl (tree ns, tree decl);\n \n enum WMB_Flags\n {"}, {"sha": "50c61bbadb46bf79b32bb8c5d5d5fa16cf971eba", "filename": "gcc/testsuite/g++.dg/modules/pr99040_a.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_a.C?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/99040\n+// { dg-additional-options -fmodules-ts }\n+export  module  format;\n+// { dg-module-cmi format }\n+\n+export namespace NS\n+{\n+void Format ();\n+}"}, {"sha": "e9e485d81953c4ddeaba0a647e4af82ddcf90644", "filename": "gcc/testsuite/g++.dg/modules/pr99040_b.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_b.C?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -0,0 +1,5 @@\n+// { dg-additional-options -fmodules-ts }\n+export  module  hello:check;\n+// { dg-module-cmi hello:check }\n+\n+export namespace NS {}"}, {"sha": "a675d72962adc3f8e8efa108146df788000b5f61", "filename": "gcc/testsuite/g++.dg/modules/pr99040_c.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_c.C?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -0,0 +1,10 @@\n+// { dg-additional-options -fmodules-ts }\n+export  module  hello;\n+// { dg-module-cmi hello }\n+export import :check;\n+import  format;\n+\n+export namespace NS\n+{\n+using NS::Format;\n+}"}, {"sha": "ed66690f436ace20919388432c13b8a8ac0c2ef6", "filename": "gcc/testsuite/g++.dg/modules/pr99040_d.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c27fe96f812df76ca07272d3c68765bd1f9dc08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99040_d.C?ref=0c27fe96f812df76ca07272d3c68765bd1f9dc08", "patch": "@@ -0,0 +1,2 @@\n+// { dg-additional-options {-fmodules-ts -fno-module-lazy} }\n+module  hello;"}]}