{"sha": "c23f55b4932192981183ab6a3f914ef22476ec93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIzZjU1YjQ5MzIxOTI5ODExODNhYjZhM2Y5MTRlZjIyNDc2ZWM5Mw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T11:13:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-09T11:13:49Z"}, "message": "gnat1drv.adb (Adjust_Global_Switches): Suppress warnings in codepeer mode here unless -gnateC is specified.\n\ngcc/ada/\n\n2017-11-09  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Suppress warnings in codepeer\n\tmode here unless -gnateC is specified.\n\t* switch-c.adb (Scan_Front_End_Switches): Do not suppress warnings with\n\t-gnatC here.\n\n2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* lib-writ.adb (Write_ALI): Remove processing of the frontend xrefs as\n\tpart of the ALI writing; they are now processed directly from memory\n\twhen requested by the backend.\n\t* lib-xref.ads (Collect_SPARK_Xrefs): Remove.\n\t(Iterate_SPARK_Xrefs): New routine for iterating over frontend xrefs.\n\t* lib-xref-spark_specific.adb (Traverse_Compilation_Unit): Remove.\n\t(Add_SPARK_File): Remove.\n\t(Add_SPARK_Xref): Refactored from removed code; filters xref entries\n\tthat are trivially uninteresting to the SPARK backend.\n\t* spark_xrefs.ads: Remove code that is no longer needed.\n\t* spark_xrefs.adb (dspark): Adapt to use Iterate_SPARK_Xrefs.\n\n2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_elab.adb: Update the documentation on adding a new elaboration\n\tschenario. Add new hash table Recorded_Top_Level_Scenarios.\n\t(Is_Check_Emitting_Scenario): Removed.\n\t(Is_Recorded_Top_Level_Scenario): New routine.\n\t(Kill_Elaboration_Scenario): Reimplemented.\n\t(Record_Elaboration_Scenario): Mark the scenario as recorded.\n\t(Set_Is_Recorded_Top_Level_Scenario): New routine.\n\t(Update_Elaboration_Scenario): Reimplemented.\n\t* sinfo.adb (Is_Recorded_Scenario): Removed.\n\t(Set_Is_Recorded_Scenario): Removed.\n\t* sinfo.ads: Remove attribute Is_Recorded_Scenario along with\n\toccurrences in nodes.\n\t(Is_Recorded_Scenario): Removed along with pragma Inline.\n\t(Set_Is_Recorded_Scenario): Removed along with pragma Inline.\n\n2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_prag.adb (Analyze_Part_Of): Change \"designate\" to \"denote\" in\n\terror message.\n\n2017-11-09  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): Add warning messages corresponding\n\tto the allocation of an anonymous access-to-controlled object.\n\ngcc/testsuite/\n\n2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* gnat.dg/elab3.adb, gnat.dg/elab3.ads, gnat.dg/elab3_pkg.adb,\n\tgnat.dg/elab3_pkg.ads: New testcase.\n\n2017-11-09  Pierre-Marie de Rodat  <derodat@adacore.com>\n\n    * gnat.dg/controlled2.adb, gnat.dg/controlled4.adb, gnat.dg/finalized.adb:\n    Disable the new warning from GNAT.\n\nFrom-SVN: r254568", "tree": {"sha": "103afd8c4702a5f6ac0ac40f4a5922559942cb60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/103afd8c4702a5f6ac0ac40f4a5922559942cb60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c23f55b4932192981183ab6a3f914ef22476ec93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23f55b4932192981183ab6a3f914ef22476ec93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23f55b4932192981183ab6a3f914ef22476ec93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23f55b4932192981183ab6a3f914ef22476ec93/comments", "author": null, "committer": null, "parents": [{"sha": "6281f27646adc69c4b23aab23347261d39102a7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6281f27646adc69c4b23aab23347261d39102a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6281f27646adc69c4b23aab23347261d39102a7a"}], "stats": {"total": 1729, "additions": 345, "deletions": 1384}, "files": [{"sha": "2f92c29c2164fcd65742f0f1f3e7455d25b5d5fe", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1,3 +1,51 @@\n+2017-11-09  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Suppress warnings in codepeer\n+\tmode here unless -gnateC is specified.\n+\t* switch-c.adb (Scan_Front_End_Switches): Do not suppress warnings with\n+\t-gnatC here.\n+\n+2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* lib-writ.adb (Write_ALI): Remove processing of the frontend xrefs as\n+\tpart of the ALI writing; they are now processed directly from memory\n+\twhen requested by the backend.\n+\t* lib-xref.ads (Collect_SPARK_Xrefs): Remove.\n+\t(Iterate_SPARK_Xrefs): New routine for iterating over frontend xrefs.\n+\t* lib-xref-spark_specific.adb (Traverse_Compilation_Unit): Remove.\n+\t(Add_SPARK_File): Remove.\n+\t(Add_SPARK_Xref): Refactored from removed code; filters xref entries\n+\tthat are trivially uninteresting to the SPARK backend.\n+\t* spark_xrefs.ads: Remove code that is no longer needed.\n+\t* spark_xrefs.adb (dspark): Adapt to use Iterate_SPARK_Xrefs.\n+\n+2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_elab.adb: Update the documentation on adding a new elaboration\n+\tschenario. Add new hash table Recorded_Top_Level_Scenarios.\n+\t(Is_Check_Emitting_Scenario): Removed.\n+\t(Is_Recorded_Top_Level_Scenario): New routine.\n+\t(Kill_Elaboration_Scenario): Reimplemented.\n+\t(Record_Elaboration_Scenario): Mark the scenario as recorded.\n+\t(Set_Is_Recorded_Top_Level_Scenario): New routine.\n+\t(Update_Elaboration_Scenario): Reimplemented.\n+\t* sinfo.adb (Is_Recorded_Scenario): Removed.\n+\t(Set_Is_Recorded_Scenario): Removed.\n+\t* sinfo.ads: Remove attribute Is_Recorded_Scenario along with\n+\toccurrences in nodes.\n+\t(Is_Recorded_Scenario): Removed along with pragma Inline.\n+\t(Set_Is_Recorded_Scenario): Removed along with pragma Inline.\n+\n+2017-11-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Part_Of): Change \"designate\" to \"denote\" in\n+\terror message.\n+\n+2017-11-09  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Allocator): Add warning messages corresponding\n+\tto the allocation of an anonymous access-to-controlled object.\n+\n 2017-11-09  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* sigtramp-qnx.c: Fix obvious typo."}, {"sha": "fb94d86debb4d6d24e7eedb339c2f472c1d29be1", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -383,6 +383,14 @@ procedure Gnat1drv is\n \n          Relaxed_RM_Semantics := True;\n \n+         if not Generate_CodePeer_Messages then\n+            --  Suppress compiler warnings by default when generating SCIL for\n+            --  CodePeer, except when combined with -gnateC where we do want\n+            --  to emit GNAT warnings.\n+\n+            Warning_Mode := Suppress;\n+         end if;\n+\n          --  Disable all simple value propagation. This is an optimization\n          --  which is valuable for code optimization, and also for generation\n          --  of compiler warnings, but these are being turned off by default,"}, {"sha": "addc9a083c5e0968624d014c920840bd7d49a99c", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1567,13 +1567,6 @@ package body Lib.Writ is\n          SCO_Output;\n       end if;\n \n-      --  Output SPARK cross-reference information if needed\n-\n-      if Opt.Xref_Active and then GNATprove_Mode then\n-         SPARK_Specific.Collect_SPARK_Xrefs (Sdep_Table => Sdep_Table,\n-                                             Num_Sdep   => Num_Sdep);\n-      end if;\n-\n       --  Output final blank line and we are done. This final blank line is\n       --  probably junk, but we don't feel like making an incompatible change.\n "}, {"sha": "52958328b1e76e276df67713f84bf221ae7b676b", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 31, "deletions": 1044, "changes": 1075, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -27,8 +27,6 @@ with Einfo;       use Einfo;\n with Nmake;       use Nmake;\n with SPARK_Xrefs; use SPARK_Xrefs;\n \n-with GNAT.HTable;\n-\n separate (Lib.Xref)\n package body SPARK_Specific is\n \n@@ -59,9 +57,6 @@ package body SPARK_Specific is\n       's'    => True,\n       others => False);\n \n-   type Entity_Hashed_Range is range 0 .. 255;\n-   --  Size of hash table headers\n-\n    ---------------------\n    -- Local Variables --\n    ---------------------\n@@ -78,187 +73,13 @@ package body SPARK_Specific is\n    --  \"Heap\". These references are added to the regular references when\n    --  computing SPARK cross-references.\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Add_SPARK_File (Uspec, Ubody : Unit_Number_Type; Dspec : Nat);\n-   --  Add file and corresponding scopes for unit to the tables\n-   --  SPARK_File_Table and SPARK_Scope_Table. When two units are present\n-   --  for the same compilation unit, as it happens for library-level\n-   --  instantiations of generics, then Ubody is the number of the body\n-   --  unit; otherwise it is No_Unit.\n-\n-   procedure Add_SPARK_Xrefs;\n-   --  Filter table Xrefs to add all references used in SPARK to the table\n-   --  SPARK_Xref_Table.\n-\n-   function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range;\n-   --  Hash function for hash table\n-\n-   generic\n-      with procedure Process (N : Node_Id) is <>;\n-   procedure Traverse_Compilation_Unit (CU : Node_Id);\n-   --  Call Process on all declarations within compilation unit CU. Bodies\n-   --  of stubs are also traversed, but generic declarations are ignored.\n-\n-   --------------------\n-   -- Add_SPARK_File --\n-   --------------------\n-\n-   procedure Add_SPARK_File (Uspec, Ubody : Unit_Number_Type; Dspec : Nat) is\n-      File : constant Source_File_Index := Source_Index (Uspec);\n-      From : constant Scope_Index       := SPARK_Scope_Table.Last + 1;\n-\n-      Scope_Id : Pos := 1;\n-\n-      procedure Add_SPARK_Scope (N : Node_Id);\n-      --  Add scope N to the table SPARK_Scope_Table\n-\n-      procedure Detect_And_Add_SPARK_Scope (N : Node_Id);\n-      --  Call Add_SPARK_Scope on scopes\n-\n-      ---------------------\n-      -- Add_SPARK_Scope --\n-      ---------------------\n-\n-      procedure Add_SPARK_Scope (N : Node_Id) is\n-         E : constant Entity_Id := Defining_Entity (N);\n-\n-      begin\n-         --  Ignore scopes without a proper location\n-\n-         if Sloc (N) = No_Location then\n-            return;\n-         end if;\n-\n-         case Ekind (E) is\n-            when E_Entry\n-               | E_Entry_Family\n-               | E_Function\n-               | E_Generic_Function\n-               | E_Generic_Package\n-               | E_Generic_Procedure\n-               | E_Package\n-               | E_Package_Body\n-               | E_Procedure\n-               | E_Protected_Body\n-               | E_Protected_Type\n-               | E_Task_Body\n-               | E_Task_Type\n-               | E_Subprogram_Body\n-            =>\n-               null;\n-\n-            when E_Void =>\n-\n-               --  Compilation of prj-attr.adb with -gnatn creates a node with\n-               --  entity E_Void for the package defined at a-charac.ads16:13.\n-               --  ??? TBD\n-\n-               return;\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-\n-         --  File_Num and Scope_Num are filled later. From_Xref and To_Xref\n-         --  are filled even later, but are initialized to represent an empty\n-         --  range.\n-\n-         SPARK_Scope_Table.Append\n-           ((Entity    => E,\n-             Scope_Num => Scope_Id,\n-             From_Xref => 1,\n-             To_Xref   => 0));\n-\n-         Scope_Id := Scope_Id + 1;\n-      end Add_SPARK_Scope;\n-\n-      --------------------------------\n-      -- Detect_And_Add_SPARK_Scope --\n-      --------------------------------\n-\n-      procedure Detect_And_Add_SPARK_Scope (N : Node_Id) is\n-      begin\n-         --  Entries\n-\n-         if Nkind_In (N, N_Entry_Body, N_Entry_Declaration)\n-\n-           --  Packages\n-\n-           or else Nkind_In (N, N_Package_Body,\n-                                N_Package_Declaration)\n-           --  Protected units\n-\n-           or else Nkind_In (N, N_Protected_Body,\n-                                N_Protected_Type_Declaration)\n-\n-           --  Subprograms\n-\n-           or else Nkind_In (N, N_Subprogram_Body,\n-                                N_Subprogram_Declaration)\n-\n-           --  Task units\n-\n-           or else Nkind_In (N, N_Task_Body,\n-                                N_Task_Type_Declaration)\n-         then\n-            Add_SPARK_Scope (N);\n-         end if;\n-      end Detect_And_Add_SPARK_Scope;\n-\n-      procedure Traverse_Scopes is new\n-        Traverse_Compilation_Unit (Detect_And_Add_SPARK_Scope);\n-\n-   --  Start of processing for Add_SPARK_File\n-\n-   begin\n-      --  Source file could be inexistant as a result of an error, if option\n-      --  gnatQ is used.\n-\n-      if File <= No_Source_File then\n-         return;\n-      end if;\n-\n-      --  Subunits are traversed as part of the top-level unit to which they\n-      --  belong.\n-\n-      if Nkind (Unit (Cunit (Uspec))) = N_Subunit then\n-         return;\n-      end if;\n-\n-      Traverse_Scopes (CU => Cunit (Uspec));\n-\n-      --  When two units are present for the same compilation unit, as it\n-      --  happens for library-level instantiations of generics, then add all\n-      --  scopes to the same SPARK file.\n-\n-      if Ubody /= No_Unit then\n-         Traverse_Scopes (CU => Cunit (Ubody));\n-      end if;\n-\n-      SPARK_File_Table.Append (\n-        (File_Num   => Dspec,\n-         From_Scope => From,\n-         To_Scope   => SPARK_Scope_Table.Last));\n-   end Add_SPARK_File;\n-\n-   ---------------------\n-   -- Add_SPARK_Xrefs --\n-   ---------------------\n-\n-   procedure Add_SPARK_Xrefs is\n-      function Entity_Of_Scope (S : Scope_Index) return Entity_Id;\n-      --  Return the entity which maps to the input scope index\n+   -------------------------\n+   -- Iterate_SPARK_Xrefs --\n+   -------------------------\n \n-      function Get_Scope_Num (E : Entity_Id) return Nat;\n-      --  Return the scope number associated with the entity E\n+   procedure Iterate_SPARK_Xrefs is\n \n-      function Is_Future_Scope_Entity\n-        (E : Entity_Id;\n-         S : Scope_Index) return Boolean;\n-      --  Check whether entity E is in SPARK_Scope_Table at index S or higher\n+      procedure Add_SPARK_Xref (Index : Int; Xref : Xref_Entry);\n \n       function Is_SPARK_Reference\n         (E   : Entity_Id;\n@@ -270,110 +91,29 @@ package body SPARK_Specific is\n       --  Return whether the entity or reference scope meets requirements for\n       --  being a SPARK scope.\n \n-      function Lt (Op1 : Natural; Op2 : Natural) return Boolean;\n-      --  Comparison function for Sort call\n-\n-      procedure Move (From : Natural; To : Natural);\n-      --  Move procedure for Sort call\n-\n-      procedure Set_Scope_Num (E : Entity_Id; Num : Nat);\n-      --  Associate entity E with the scope number Num\n-\n-      procedure Update_Scope_Range\n-        (S    : Scope_Index;\n-         From : Xref_Index;\n-         To   : Xref_Index);\n-      --  Update the scope which maps to S with the new range From .. To\n-\n-      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-      No_Scope : constant Nat := 0;\n-      --  Initial scope counter\n-\n-      package Scopes is new GNAT.HTable.Simple_HTable\n-        (Header_Num => Entity_Hashed_Range,\n-         Element    => Nat,\n-         No_Element => No_Scope,\n-         Key        => Entity_Id,\n-         Hash       => Entity_Hash,\n-         Equal      => \"=\");\n-      --  Package used to build a correspondence between entities and scope\n-      --  numbers used in SPARK cross references.\n-\n-      Nrefs : Nat := Xrefs.Last;\n-      --  Number of references in table. This value may get reset (reduced)\n-      --  when we eliminate duplicate reference entries as well as references\n-      --  not suitable for local cross-references.\n-\n-      Nrefs_Add : constant Nat := Drefs.Last;\n-      --  Number of additional references which correspond to dereferences in\n-      --  the source code.\n-\n-      Rnums : array (0 .. Nrefs + Nrefs_Add) of Nat;\n-      --  This array contains numbers of references in the Xrefs table. This\n-      --  list is sorted in output order. The extra 0'th entry is convenient\n-      --  for the call to sort. When we sort the table, we move the indices in\n-      --  Rnums around, but we do not move the original table entries.\n-\n-      ---------------------\n-      -- Entity_Of_Scope --\n-      ---------------------\n-\n-      function Entity_Of_Scope (S : Scope_Index) return Entity_Id is\n-      begin\n-         return SPARK_Scope_Table.Table (S).Entity;\n-      end Entity_Of_Scope;\n-\n-      -------------------\n-      -- Get_Scope_Num --\n-      -------------------\n-\n-      function Get_Scope_Num (E : Entity_Id) return Nat renames Scopes.Get;\n-\n-      ----------------------------\n-      -- Is_Future_Scope_Entity --\n-      ----------------------------\n-\n-      function Is_Future_Scope_Entity\n-        (E : Entity_Id;\n-         S : Scope_Index) return Boolean\n-      is\n-         function Is_Past_Scope_Entity return Boolean;\n-         --  Check whether entity E is in SPARK_Scope_Table at index strictly\n-         --  lower than S.\n-\n-         --------------------------\n-         -- Is_Past_Scope_Entity --\n-         --------------------------\n-\n-         function Is_Past_Scope_Entity return Boolean is\n-         begin\n-            for Index in SPARK_Scope_Table.First .. S - 1 loop\n-               if SPARK_Scope_Table.Table (Index).Entity = E then\n-                  return True;\n-               end if;\n-            end loop;\n-\n-            return False;\n-         end Is_Past_Scope_Entity;\n-\n-      --  Start of processing for Is_Future_Scope_Entity\n+      --------------------\n+      -- Add_SPARK_Xref --\n+      --------------------\n \n+      procedure Add_SPARK_Xref (Index : Int; Xref : Xref_Entry) is\n+         Ref : Xref_Key renames Xref.Key;\n       begin\n-         for Index in S .. SPARK_Scope_Table.Last loop\n-            if SPARK_Scope_Table.Table (Index).Entity = E then\n-               return True;\n-            end if;\n-         end loop;\n+         --  Eliminate entries not appropriate for SPARK\n \n-         --  If this assertion fails, this means that the scope which we are\n-         --  looking for has been treated already, which reveals a problem in\n-         --  the order of cross-references.\n-\n-         pragma Assert (not Is_Past_Scope_Entity);\n+         if SPARK_Entities (Ekind (Ref.Ent))\n+           and then SPARK_References (Ref.Typ)\n+           and then Is_SPARK_Scope (Ref.Ent_Scope)\n+           and then Is_SPARK_Scope (Ref.Ref_Scope)\n+           and then Is_SPARK_Reference (Ref.Ent, Ref.Typ)\n+         then\n+            Process\n+              (Index,\n+               (Entity    => Ref.Ent,\n+                Ref_Scope => Ref.Ref_Scope,\n+                Rtype     => Ref.Typ));\n+         end if;\n \n-         return False;\n-      end Is_Future_Scope_Entity;\n+      end Add_SPARK_Xref;\n \n       ------------------------\n       -- Is_SPARK_Reference --\n@@ -411,440 +151,22 @@ package body SPARK_Specific is\n       begin\n          return Present (E)\n            and then not Is_Generic_Unit (E)\n-           and then (not Can_Be_Renamed or else No (Renamed_Entity (E)))\n-           and then Get_Scope_Num (E) /= No_Scope;\n+           and then (not Can_Be_Renamed or else No (Renamed_Entity (E)));\n       end Is_SPARK_Scope;\n \n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (Op1 : Natural; Op2 : Natural) return Boolean is\n-         T1 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op1)));\n-         T2 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op2)));\n-\n-      begin\n-         --  First test: if entity is in different unit, sort by unit. Note:\n-         --  that we use Ent_Scope_File rather than Eun, as Eun may refer to\n-         --  the file where the generic scope is defined, which may differ from\n-         --  the file where the enclosing scope is defined. It is the latter\n-         --  which matters for a correct order here.\n-\n-         if T1.Ent_Scope_File /= T2.Ent_Scope_File then\n-            return Dependency_Num (T1.Ent_Scope_File) <\n-                   Dependency_Num (T2.Ent_Scope_File);\n-\n-         --  Second test: within same unit, sort by location of the scope of\n-         --  the entity definition.\n-\n-         elsif Get_Scope_Num (T1.Key.Ent_Scope) /=\n-               Get_Scope_Num (T2.Key.Ent_Scope)\n-         then\n-            return Get_Scope_Num (T1.Key.Ent_Scope) <\n-                   Get_Scope_Num (T2.Key.Ent_Scope);\n-\n-         --  Third test: within same unit and scope, sort by location of\n-         --  entity definition.\n-\n-         elsif T1.Def /= T2.Def then\n-            return T1.Def < T2.Def;\n-\n-         else\n-            --  Both entities must be equal at this point\n-\n-            pragma Assert (T1.Key.Ent = T2.Key.Ent);\n-            pragma Assert (T1.Key.Ent_Scope = T2.Key.Ent_Scope);\n-            pragma Assert (T1.Ent_Scope_File = T2.Ent_Scope_File);\n-\n-            --  Fourth test: if reference is in same unit as entity definition,\n-            --  sort first.\n-\n-            if T1.Key.Lun /= T2.Key.Lun\n-              and then T1.Ent_Scope_File = T1.Key.Lun\n-            then\n-               return True;\n-\n-            elsif T1.Key.Lun /= T2.Key.Lun\n-              and then T2.Ent_Scope_File = T2.Key.Lun\n-            then\n-               return False;\n-\n-            --  Fifth test: if reference is in same unit and same scope as\n-            --  entity definition, sort first.\n-\n-            elsif T1.Ent_Scope_File = T1.Key.Lun\n-              and then T1.Key.Ref_Scope /= T2.Key.Ref_Scope\n-              and then T1.Key.Ent_Scope = T1.Key.Ref_Scope\n-            then\n-               return True;\n-\n-            elsif T2.Ent_Scope_File = T2.Key.Lun\n-              and then T1.Key.Ref_Scope /= T2.Key.Ref_Scope\n-              and then T2.Key.Ent_Scope = T2.Key.Ref_Scope\n-            then\n-               return False;\n-\n-            --  Sixth test: for same entity, sort by reference location unit\n-\n-            elsif T1.Key.Lun /= T2.Key.Lun then\n-               return Dependency_Num (T1.Key.Lun) <\n-                      Dependency_Num (T2.Key.Lun);\n-\n-            --  Seventh test: for same entity, sort by reference location scope\n-\n-            elsif Get_Scope_Num (T1.Key.Ref_Scope) /=\n-                  Get_Scope_Num (T2.Key.Ref_Scope)\n-            then\n-               return Get_Scope_Num (T1.Key.Ref_Scope) <\n-                      Get_Scope_Num (T2.Key.Ref_Scope);\n-\n-            --  Eighth test: order of location within referencing unit\n-\n-            elsif T1.Key.Loc /= T2.Key.Loc then\n-               return T1.Key.Loc < T2.Key.Loc;\n-\n-            --  Finally, for two locations at the same address prefer the one\n-            --  that does NOT have the type 'r', so that a modification or\n-            --  extension takes preference, when there are more than one\n-            --  reference at the same location. As a result, in the case of\n-            --  entities that are in-out actuals, the read reference follows\n-            --  the modify reference.\n-\n-            else\n-               return T2.Key.Typ = 'r';\n-            end if;\n-         end if;\n-      end Lt;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Rnums (Nat (To)) := Rnums (Nat (From));\n-      end Move;\n-\n-      -------------------\n-      -- Set_Scope_Num --\n-      -------------------\n-\n-      procedure Set_Scope_Num (E : Entity_Id; Num : Nat) renames Scopes.Set;\n-\n-      ------------------------\n-      -- Update_Scope_Range --\n-      ------------------------\n-\n-      procedure Update_Scope_Range\n-        (S    : Scope_Index;\n-         From : Xref_Index;\n-         To   : Xref_Index)\n-      is\n-      begin\n-         SPARK_Scope_Table.Table (S).From_Xref := From;\n-         SPARK_Scope_Table.Table (S).To_Xref := To;\n-      end Update_Scope_Range;\n-\n-      --  Local variables\n-\n-      From_Index : Xref_Index;\n-      Prev_Loc   : Source_Ptr;\n-      Prev_Typ   : Character;\n-      Ref_Count  : Nat;\n-      Scope_Id   : Scope_Index;\n-\n    --  Start of processing for Add_SPARK_Xrefs\n \n    begin\n-      for Index in SPARK_Scope_Table.First .. SPARK_Scope_Table.Last loop\n-         declare\n-            S : SPARK_Scope_Record renames SPARK_Scope_Table.Table (Index);\n-         begin\n-            Set_Scope_Num (S.Entity, S.Scope_Num);\n-         end;\n-      end loop;\n-\n-      declare\n-         Drefs_Table : Drefs.Table_Type\n-                         renames Drefs.Table (Drefs.First .. Drefs.Last);\n-      begin\n-         Xrefs.Append_All (Xrefs.Table_Type (Drefs_Table));\n-         Nrefs := Nrefs + Drefs_Table'Length;\n-      end;\n-\n-      --  Capture the definition Sloc values. As in the case of normal cross\n-      --  references, we have to wait until now to get the correct value.\n-\n-      for Index in 1 .. Nrefs loop\n-         Xrefs.Table (Index).Def := Sloc (Xrefs.Table (Index).Key.Ent);\n-      end loop;\n-\n-      --  Eliminate entries not appropriate for SPARK. Done prior to sorting\n-      --  cross-references, as it discards useless references which do not have\n-      --  a proper format for the comparison function (like no location).\n-\n-      Ref_Count := Nrefs;\n-      Nrefs     := 0;\n-\n-      for Index in 1 .. Ref_Count loop\n-         declare\n-            Ref : Xref_Key renames Xrefs.Table (Index).Key;\n-\n-         begin\n-            if SPARK_Entities (Ekind (Ref.Ent))\n-              and then SPARK_References (Ref.Typ)\n-              and then Is_SPARK_Scope (Ref.Ent_Scope)\n-              and then Is_SPARK_Scope (Ref.Ref_Scope)\n-              and then Is_SPARK_Reference (Ref.Ent, Ref.Typ)\n-\n-              --  Discard references from unknown scopes, e.g. generic scopes\n-\n-              and then Get_Scope_Num (Ref.Ent_Scope) /= No_Scope\n-              and then Get_Scope_Num (Ref.Ref_Scope) /= No_Scope\n-\n-              --  Discard references to loop parameters introduced within\n-              --  expression functions, as they give two references: one from\n-              --  the analysis of the expression function itself and one from\n-              --  the analysis of the expanded body. We don't lose any globals\n-              --  by discarding them, because such loop parameters can only be\n-              --  accessed locally from within the expression function body.\n-              --  Note: some loop parameters are expanded into variables; they\n-              --  also must be ignored.\n-\n-              and then not\n-                (Ekind_In (Ref.Ent, E_Loop_Parameter, E_Variable)\n-                  and then Scope_Within\n-                             (Ref.Ent, Unique_Entity (Ref.Ref_Scope))\n-                  and then Is_Expression_Function (Ref.Ref_Scope))\n-            then\n-               Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Index;\n-            end if;\n-         end;\n-      end loop;\n-\n-      --  Sort the references\n-\n-      Sorting.Sort (Integer (Nrefs));\n-\n-      --  Eliminate duplicate entries\n-\n-      --  We need this test for Ref_Count because if we force ALI file\n-      --  generation in case of errors detected, it may be the case that\n-      --  Nrefs is 0, so we should not reset it here.\n-\n-      if Nrefs >= 2 then\n-         Ref_Count := Nrefs;\n-         Nrefs     := 1;\n-\n-         for Index in 2 .. Ref_Count loop\n-            if Xrefs.Table (Rnums (Index)) /= Xrefs.Table (Rnums (Nrefs)) then\n-               Nrefs := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (Index);\n-            end if;\n-         end loop;\n-      end if;\n-\n-      --  Eliminate the reference if it is at the same location as the previous\n-      --  one, unless it is a read-reference indicating that the entity is an\n-      --  in-out actual in a call.\n-\n-      Ref_Count := Nrefs;\n-      Nrefs     := 0;\n-      Prev_Loc  := No_Location;\n-      Prev_Typ  := 'm';\n-\n-      for Index in 1 .. Ref_Count loop\n-         declare\n-            Ref : Xref_Key renames Xrefs.Table (Rnums (Index)).Key;\n-\n-         begin\n-            if Ref.Loc /= Prev_Loc\n-              or else (Prev_Typ = 'm' and then Ref.Typ = 'r')\n-            then\n-               Prev_Loc      := Ref.Loc;\n-               Prev_Typ      := Ref.Typ;\n-               Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (Index);\n-            end if;\n-         end;\n-      end loop;\n-\n-      --  The two steps have eliminated all references, nothing to do\n-\n-      if SPARK_Scope_Table.Last = 0 then\n-         return;\n-      end if;\n-\n-      Scope_Id   := 1;\n-      From_Index := 1;\n-\n-      --  Loop to output references\n+      --  Expose cross-references from private frontend tables to the backend\n \n-      for Refno in 1 .. Nrefs loop\n-         declare\n-            Ref_Entry : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n-            Ref       : Xref_Key   renames Ref_Entry.Key;\n-\n-         begin\n-            --  If this assertion fails, the scope which we are looking for is\n-            --  not in SPARK scope table, which reveals either a problem in the\n-            --  construction of the scope table, or an erroneous scope for the\n-            --  current cross-reference.\n-\n-            pragma Assert (Is_Future_Scope_Entity (Ref.Ent_Scope, Scope_Id));\n-\n-            --  Update the range of cross references to which the current scope\n-            --  refers to. This may be the empty range only for the first scope\n-            --  considered.\n-\n-            if Ref.Ent_Scope /= Entity_Of_Scope (Scope_Id) then\n-               Update_Scope_Range\n-                 (S    => Scope_Id,\n-                  From => From_Index,\n-                  To   => SPARK_Xref_Table.Last);\n-\n-               From_Index := SPARK_Xref_Table.Last + 1;\n-            end if;\n-\n-            while Ref.Ent_Scope /= Entity_Of_Scope (Scope_Id) loop\n-               Scope_Id := Scope_Id + 1;\n-               pragma Assert (Scope_Id <= SPARK_Scope_Table.Last);\n-            end loop;\n-\n-            SPARK_Xref_Table.Append (\n-              (Entity    => Unique_Entity (Ref.Ent),\n-               Ref_Scope => Ref.Ref_Scope,\n-               Rtype     => Ref.Typ));\n-         end;\n+      for Index in Drefs.First .. Drefs.Last loop\n+         Add_SPARK_Xref (Index, Drefs.Table (Index));\n       end loop;\n \n-      --  Update the range of cross references to which the scope refers to\n-\n-      Update_Scope_Range\n-        (S    => Scope_Id,\n-         From => From_Index,\n-         To   => SPARK_Xref_Table.Last);\n-   end Add_SPARK_Xrefs;\n-\n-   -------------------------\n-   -- Collect_SPARK_Xrefs --\n-   -------------------------\n-\n-   procedure Collect_SPARK_Xrefs\n-     (Sdep_Table : Unit_Ref_Table;\n-      Num_Sdep   : Nat)\n-   is\n-      Sdep      : Pos;\n-      Sdep_Next : Pos;\n-      --  Index of the current and next source dependency\n-\n-      Sdep_File : Pos;\n-      --  Index of the file to which the scopes need to be assigned; for\n-      --  library-level instances of generic units this points to the unit\n-      --  of the body, because this is where references are assigned to.\n-\n-      Ubody : Unit_Number_Type;\n-      Uspec : Unit_Number_Type;\n-      --  Unit numbers for the dependency spec and possibly its body (only in\n-      --  the case of library-level instance of a generic package).\n-\n-   begin\n-      --  Cross-references should have been computed first\n-\n-      pragma Assert (Xrefs.Last /= 0);\n-\n-      Initialize_SPARK_Tables;\n-\n-      --  Generate file and scope SPARK cross-reference information\n-\n-      Sdep := 1;\n-      while Sdep <= Num_Sdep loop\n-\n-         --  Skip dependencies with no entity node, e.g. configuration files\n-         --  with pragmas (.adc) or target description (.atp), since they\n-         --  present no interest for SPARK cross references.\n-\n-         if No (Cunit_Entity (Sdep_Table (Sdep))) then\n-            Sdep_Next := Sdep + 1;\n-\n-         --  For library-level instantiation of a generic, two consecutive\n-         --  units refer to the same compilation unit node and entity (one to\n-         --  body, one to spec). In that case, treat them as a single unit for\n-         --  the sake of SPARK cross references by passing to Add_SPARK_File.\n-\n-         else\n-            if Sdep < Num_Sdep\n-              and then Cunit_Entity (Sdep_Table (Sdep)) =\n-                       Cunit_Entity (Sdep_Table (Sdep + 1))\n-            then\n-               declare\n-                  Cunit1 : Node_Id renames Cunit (Sdep_Table (Sdep));\n-                  Cunit2 : Node_Id renames Cunit (Sdep_Table (Sdep + 1));\n-\n-               begin\n-                  --  Both Cunits point to compilation unit nodes\n-\n-                  pragma Assert\n-                    (Nkind (Cunit1) = N_Compilation_Unit\n-                      and then Nkind (Cunit2) = N_Compilation_Unit);\n-\n-                  --  Do not depend on the sorting order, which is based on\n-                  --  Unit_Name, and for library-level instances of nested\n-                  --  generic packages they are equal.\n-\n-                  --  If declaration comes before the body\n-\n-                  if Nkind (Unit (Cunit1)) = N_Package_Declaration\n-                    and then Nkind (Unit (Cunit2)) = N_Package_Body\n-                  then\n-                     Uspec := Sdep_Table (Sdep);\n-                     Ubody := Sdep_Table (Sdep + 1);\n-\n-                     Sdep_File := Sdep + 1;\n-\n-                  --  If body comes before declaration\n-\n-                  elsif Nkind (Unit (Cunit1)) = N_Package_Body\n-                    and then Nkind (Unit (Cunit2)) = N_Package_Declaration\n-                  then\n-                     Uspec := Sdep_Table (Sdep + 1);\n-                     Ubody := Sdep_Table (Sdep);\n-\n-                     Sdep_File := Sdep;\n-\n-                  --  Otherwise it is an error\n-\n-                  else\n-                     raise Program_Error;\n-                  end if;\n-\n-                  Sdep_Next := Sdep + 2;\n-               end;\n-\n-            --  ??? otherwise?\n-\n-            else\n-               Uspec := Sdep_Table (Sdep);\n-               Ubody := No_Unit;\n-\n-               Sdep_File := Sdep;\n-               Sdep_Next := Sdep + 1;\n-            end if;\n-\n-            Add_SPARK_File\n-              (Uspec => Uspec,\n-               Ubody => Ubody,\n-               Dspec => Sdep_File);\n-         end if;\n-\n-         Sdep := Sdep_Next;\n+      for Index in Xrefs.First .. Xrefs.Last loop\n+         Add_SPARK_Xref (-Index, Xrefs.Table (Index));\n       end loop;\n-\n-      --  Generate SPARK cross-reference information\n-\n-      Add_SPARK_Xrefs;\n-   end Collect_SPARK_Xrefs;\n+   end Iterate_SPARK_Xrefs;\n \n    -------------------------------------\n    -- Enclosing_Subprogram_Or_Package --\n@@ -941,16 +263,6 @@ package body SPARK_Specific is\n       return Context;\n    end Enclosing_Subprogram_Or_Library_Package;\n \n-   -----------------\n-   -- Entity_Hash --\n-   -----------------\n-\n-   function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range is\n-   begin\n-      return\n-        Entity_Hashed_Range (E mod (Entity_Id (Entity_Hashed_Range'Last) + 1));\n-   end Entity_Hash;\n-\n    --------------------------\n    -- Generate_Dereference --\n    --------------------------\n@@ -1019,329 +331,4 @@ package body SPARK_Specific is\n       end if;\n    end Generate_Dereference;\n \n-   -------------------------------\n-   -- Traverse_Compilation_Unit --\n-   -------------------------------\n-\n-   procedure Traverse_Compilation_Unit (CU : Node_Id) is\n-      procedure Traverse_Block                      (N : Node_Id);\n-      procedure Traverse_Declaration_Or_Statement   (N : Node_Id);\n-      procedure Traverse_Declarations_And_HSS       (N : Node_Id);\n-      procedure Traverse_Declarations_Or_Statements (L : List_Id);\n-      procedure Traverse_Handled_Statement_Sequence (N : Node_Id);\n-      procedure Traverse_Package_Body               (N : Node_Id);\n-      procedure Traverse_Visible_And_Private_Parts  (N : Node_Id);\n-      procedure Traverse_Protected_Body             (N : Node_Id);\n-      procedure Traverse_Subprogram_Body            (N : Node_Id);\n-      procedure Traverse_Task_Body                  (N : Node_Id);\n-\n-      --  Traverse corresponding construct, calling Process on all declarations\n-\n-      --------------------\n-      -- Traverse_Block --\n-      --------------------\n-\n-      procedure Traverse_Block (N : Node_Id) renames\n-        Traverse_Declarations_And_HSS;\n-\n-      ---------------------------------------\n-      -- Traverse_Declaration_Or_Statement --\n-      ---------------------------------------\n-\n-      procedure Traverse_Declaration_Or_Statement (N : Node_Id) is\n-         function Traverse_Stub (N : Node_Id) return Boolean;\n-         --  Returns True iff stub N should be traversed\n-\n-         function Traverse_Stub (N : Node_Id) return Boolean is\n-         begin\n-            pragma Assert (Nkind_In (N, N_Package_Body_Stub,\n-                                        N_Protected_Body_Stub,\n-                                        N_Subprogram_Body_Stub,\n-                                        N_Task_Body_Stub));\n-\n-            return Present (Library_Unit (N));\n-         end Traverse_Stub;\n-\n-      --  Start of processing for Traverse_Declaration_Or_Statement\n-\n-      begin\n-         case Nkind (N) is\n-            when N_Package_Declaration =>\n-               Traverse_Visible_And_Private_Parts (Specification (N));\n-\n-            when N_Package_Body =>\n-               Traverse_Package_Body (N);\n-\n-            when N_Package_Body_Stub =>\n-               if Traverse_Stub (N) then\n-                  Traverse_Package_Body (Get_Body_From_Stub (N));\n-               end if;\n-\n-            when N_Subprogram_Body =>\n-               Traverse_Subprogram_Body (N);\n-\n-            when N_Entry_Body =>\n-               Traverse_Subprogram_Body (N);\n-\n-            when N_Subprogram_Body_Stub =>\n-               if Traverse_Stub (N) then\n-                  Traverse_Subprogram_Body (Get_Body_From_Stub (N));\n-               end if;\n-\n-            when N_Protected_Body =>\n-               Traverse_Protected_Body (N);\n-\n-            when N_Protected_Body_Stub =>\n-               if Traverse_Stub (N) then\n-                  Traverse_Protected_Body (Get_Body_From_Stub (N));\n-               end if;\n-\n-            when N_Protected_Type_Declaration =>\n-               Traverse_Visible_And_Private_Parts (Protected_Definition (N));\n-\n-            when N_Task_Type_Declaration =>\n-\n-               --  Task type definition is optional (unlike protected type\n-               --  definition, which is mandatory).\n-\n-               declare\n-                  Task_Def : constant Node_Id := Task_Definition (N);\n-               begin\n-                  if Present (Task_Def) then\n-                     Traverse_Visible_And_Private_Parts (Task_Def);\n-                  end if;\n-               end;\n-\n-            when N_Task_Body =>\n-               Traverse_Task_Body (N);\n-\n-            when N_Task_Body_Stub =>\n-               if Traverse_Stub (N) then\n-                  Traverse_Task_Body (Get_Body_From_Stub (N));\n-               end if;\n-\n-            when N_Block_Statement =>\n-               Traverse_Block (N);\n-\n-            when N_If_Statement =>\n-\n-               --  Traverse the statements in the THEN part\n-\n-               Traverse_Declarations_Or_Statements (Then_Statements (N));\n-\n-               --  Loop through ELSIF parts if present\n-\n-               if Present (Elsif_Parts (N)) then\n-                  declare\n-                     Elif : Node_Id := First (Elsif_Parts (N));\n-\n-                  begin\n-                     while Present (Elif) loop\n-                        Traverse_Declarations_Or_Statements\n-                          (Then_Statements (Elif));\n-                        Next (Elif);\n-                     end loop;\n-                  end;\n-               end if;\n-\n-               --  Finally traverse the ELSE statements if present\n-\n-               Traverse_Declarations_Or_Statements (Else_Statements (N));\n-\n-            when N_Case_Statement =>\n-\n-               --  Process case branches\n-\n-               declare\n-                  Alt : Node_Id := First (Alternatives (N));\n-               begin\n-                  loop\n-                     Traverse_Declarations_Or_Statements (Statements (Alt));\n-                     Next (Alt);\n-                     exit when No (Alt);\n-                  end loop;\n-               end;\n-\n-            when N_Extended_Return_Statement =>\n-               Traverse_Handled_Statement_Sequence\n-                 (Handled_Statement_Sequence (N));\n-\n-            when N_Loop_Statement =>\n-               Traverse_Declarations_Or_Statements (Statements (N));\n-\n-               --  Generic declarations are ignored\n-\n-            when others =>\n-               null;\n-         end case;\n-      end Traverse_Declaration_Or_Statement;\n-\n-      -----------------------------------\n-      -- Traverse_Declarations_And_HSS --\n-      -----------------------------------\n-\n-      procedure Traverse_Declarations_And_HSS (N : Node_Id) is\n-      begin\n-         Traverse_Declarations_Or_Statements (Declarations (N));\n-         Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n-      end Traverse_Declarations_And_HSS;\n-\n-      -----------------------------------------\n-      -- Traverse_Declarations_Or_Statements --\n-      -----------------------------------------\n-\n-      procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n-         N : Node_Id;\n-\n-      begin\n-         --  Loop through statements or declarations\n-\n-         N := First (L);\n-         while Present (N) loop\n-\n-            --  Call Process on all declarations\n-\n-            if Nkind (N) in N_Declaration\n-              or else Nkind (N) in N_Later_Decl_Item\n-              or else Nkind (N) = N_Entry_Body\n-            then\n-               if Nkind (N) in N_Body_Stub then\n-                  Process (Get_Body_From_Stub (N));\n-               else\n-                  Process (N);\n-               end if;\n-            end if;\n-\n-            Traverse_Declaration_Or_Statement (N);\n-\n-            Next (N);\n-         end loop;\n-      end Traverse_Declarations_Or_Statements;\n-\n-      -----------------------------------------\n-      -- Traverse_Handled_Statement_Sequence --\n-      -----------------------------------------\n-\n-      procedure Traverse_Handled_Statement_Sequence (N : Node_Id) is\n-         Handler : Node_Id;\n-\n-      begin\n-         if Present (N) then\n-            Traverse_Declarations_Or_Statements (Statements (N));\n-\n-            if Present (Exception_Handlers (N)) then\n-               Handler := First (Exception_Handlers (N));\n-               while Present (Handler) loop\n-                  Traverse_Declarations_Or_Statements (Statements (Handler));\n-                  Next (Handler);\n-               end loop;\n-            end if;\n-         end if;\n-      end Traverse_Handled_Statement_Sequence;\n-\n-      ---------------------------\n-      -- Traverse_Package_Body --\n-      ---------------------------\n-\n-      procedure Traverse_Package_Body (N : Node_Id) is\n-         Spec_E : constant Entity_Id := Unique_Defining_Entity (N);\n-\n-      begin\n-         case Ekind (Spec_E) is\n-            when E_Package =>\n-               Traverse_Declarations_And_HSS (N);\n-\n-            when E_Generic_Package =>\n-               null;\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-      end Traverse_Package_Body;\n-\n-      -----------------------------\n-      -- Traverse_Protected_Body --\n-      -----------------------------\n-\n-      procedure Traverse_Protected_Body (N : Node_Id) is\n-      begin\n-         Traverse_Declarations_Or_Statements (Declarations (N));\n-      end Traverse_Protected_Body;\n-\n-      ------------------------------\n-      -- Traverse_Subprogram_Body --\n-      ------------------------------\n-\n-      procedure Traverse_Subprogram_Body (N : Node_Id) is\n-         Spec_E : constant Entity_Id := Unique_Defining_Entity (N);\n-\n-      begin\n-         case Ekind (Spec_E) is\n-            when Entry_Kind\n-               | E_Function\n-               | E_Procedure\n-            =>\n-               Traverse_Declarations_And_HSS (N);\n-\n-            when Generic_Subprogram_Kind =>\n-               null;\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n-      end Traverse_Subprogram_Body;\n-\n-      ------------------------\n-      -- Traverse_Task_Body --\n-      ------------------------\n-\n-      procedure Traverse_Task_Body (N : Node_Id) renames\n-        Traverse_Declarations_And_HSS;\n-\n-      ----------------------------------------\n-      -- Traverse_Visible_And_Private_Parts --\n-      ----------------------------------------\n-\n-      procedure Traverse_Visible_And_Private_Parts (N : Node_Id) is\n-      begin\n-         Traverse_Declarations_Or_Statements (Visible_Declarations (N));\n-         Traverse_Declarations_Or_Statements (Private_Declarations (N));\n-      end Traverse_Visible_And_Private_Parts;\n-\n-      --  Local variables\n-\n-      Lu : Node_Id;\n-\n-   --  Start of processing for Traverse_Compilation_Unit\n-\n-   begin\n-      --  Get Unit (checking case of subunit)\n-\n-      Lu := Unit (CU);\n-\n-      if Nkind (Lu) = N_Subunit then\n-         Lu := Proper_Body (Lu);\n-      end if;\n-\n-      --  Do not add scopes for generic units\n-\n-      if Nkind (Lu) = N_Package_Body\n-        and then Ekind (Corresponding_Spec (Lu)) in Generic_Unit_Kind\n-      then\n-         return;\n-      end if;\n-\n-      --  Call Process on all declarations\n-\n-      if Nkind (Lu) in N_Declaration\n-        or else Nkind (Lu) in N_Later_Decl_Item\n-      then\n-         Process (Lu);\n-      end if;\n-\n-      --  Traverse the unit\n-\n-      Traverse_Declaration_Or_Statement (Lu);\n-   end Traverse_Compilation_Unit;\n-\n end SPARK_Specific;"}, {"sha": "0baa896253ea7b313c0cd7bb4e693fe4a376c258", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -26,7 +26,8 @@\n --  This package contains for collecting and outputting cross-reference\n --  information.\n \n-with Einfo; use Einfo;\n+with Einfo;       use Einfo;\n+with SPARK_Xrefs;\n \n package Lib.Xref is\n \n@@ -638,12 +639,15 @@ package Lib.Xref is\n       --  This procedure is called to record a dereference. N is the location\n       --  of the dereference.\n \n-      procedure Collect_SPARK_Xrefs\n-        (Sdep_Table : Unit_Ref_Table;\n-         Num_Sdep   : Nat);\n-      --  Collect SPARK cross-reference information from library units (for\n-      --  files and scopes) and from shared cross-references. Fill in the\n-      --  tables in library package called SPARK_Xrefs.\n+      generic\n+         with procedure Process\n+           (Index : Int;\n+            Xref  : SPARK_Xrefs.SPARK_Xref_Record);\n+      procedure Iterate_SPARK_Xrefs;\n+      --  Call Process on cross-references relevant to the SPARK backend with\n+      --  parameter Xref holding the relevant subset of the xref entry and\n+      --  Index holding the position in the original tables with references\n+      --  (if positive) or dereferences (if negative).\n \n    end SPARK_Specific;\n "}, {"sha": "b3077adfbf8fe5db31c057335f3def0952cba490", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 142, "deletions": 78, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -68,7 +68,7 @@ package body Sem_Elab is\n    --    * Diagnose at compile-time or install run-time checks to prevent ABE\n    --      access to data and behaviour.\n    --\n-   --      The high level idea is to accurately diagnose ABE issues within a\n+   --      The high-level idea is to accurately diagnose ABE issues within a\n    --      single unit because the ABE mechanism can inspect the whole unit.\n    --      As soon as the elaboration graph extends to an external unit, the\n    --      diagnostics stop because the body of the unit may not be available.\n@@ -146,8 +146,8 @@ package body Sem_Elab is\n    --    the library level if it appears in a package library unit, ignoring\n    --    enclosng packages.\n    --\n-   --  * Non-library level encapsulator - A construct that cannot be elaborated\n-   --    on its own and requires elaboration by a top level scenario.\n+   --  * Non-library-level encapsulator - A construct that cannot be elaborated\n+   --    on its own and requires elaboration by a top-level scenario.\n    --\n    --  * Scenario - A construct or context which may be elaborated or executed\n    --    by elaboration code. The scenarios recognized by the ABE mechanism are\n@@ -181,7 +181,7 @@ package body Sem_Elab is\n    --\n    --      - For task activation, the target is the task body\n    --\n-   --  * Top level scenario - A scenario which appears in a non-generic main\n+   --  * Top-level scenario - A scenario which appears in a non-generic main\n    --    unit. Depending on the elaboration model is in effect, the following\n    --    addotional restrictions apply:\n    --\n@@ -198,7 +198,7 @@ package body Sem_Elab is\n    --  The Recording phase coincides with the analysis/resolution phase of the\n    --  compiler. It has the following objectives:\n    --\n-   --    * Record all top level scenarios for examination by the Processing\n+   --    * Record all top-level scenarios for examination by the Processing\n    --      phase.\n    --\n    --      Saving only a certain number of nodes improves the performance of\n@@ -231,9 +231,9 @@ package body Sem_Elab is\n    --  and/or inlining of bodies, but before the removal of Ghost code. It has\n    --  the following objectives:\n    --\n-   --    * Examine all top level scenarios saved during the Recording phase\n+   --    * Examine all top-level scenarios saved during the Recording phase\n    --\n-   --      The top level scenarios act as roots for depth-first traversal of\n+   --      The top-level scenarios act as roots for depth-first traversal of\n    --      the call/instantiation/task activation graph. The traversal stops\n    --      when an outgoing edge leaves the main unit.\n    --\n@@ -420,8 +420,7 @@ package body Sem_Elab is\n    --  The following steps describe how to add a new elaboration scenario and\n    --  preserve the existing architecture.\n    --\n-   --    1) If necessary, update predicates Is_Check_Emitting_Scenario and\n-   --       Is_Scenario.\n+   --    1) If necessary, update predicate Is_Scenario\n    --\n    --    2) Add predicate Is_Suitable_xxx. Include a call to it in predicate\n    --       Is_Suitable_Scenario.\n@@ -712,8 +711,28 @@ package body Sem_Elab is\n       Hash       => Elaboration_Context_Hash,\n       Equal      => \"=\");\n \n+   --  The following table stores a status flag for each top-level scenario\n+   --  recorded in table Top_Level_Scenarios.\n+\n+   Recorded_Top_Level_Scenarios_Max : constant := 503;\n+\n+   type Recorded_Top_Level_Scenarios_Index is\n+     range 0 .. Recorded_Top_Level_Scenarios_Max - 1;\n+\n+   function Recorded_Top_Level_Scenarios_Hash\n+     (Key : Node_Id) return Recorded_Top_Level_Scenarios_Index;\n+   --  Obtain the hash value of entity Key\n+\n+   package Recorded_Top_Level_Scenarios is new Simple_HTable\n+     (Header_Num => Recorded_Top_Level_Scenarios_Index,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Node_Id,\n+      Hash       => Recorded_Top_Level_Scenarios_Hash,\n+      Equal      => \"=\");\n+\n    --  The following table stores all active scenarios in a recursive traversal\n-   --  starting from a top level scenario. This table must be maintained in a\n+   --  starting from a top-level scenario. This table must be maintained in a\n    --  FIFO fashion.\n \n    package Scenario_Stack is new Table.Table\n@@ -724,7 +743,7 @@ package body Sem_Elab is\n       Table_Increment      => 100,\n       Table_Name           => \"Scenario_Stack\");\n \n-   --  The following table stores all top level scenario saved during the\n+   --  The following table stores all top-level scenario saved during the\n    --  Recording phase. The contents of this table act as traversal roots\n    --  later in the Processing phase. This table must be maintained in a\n    --  LIFO fashion.\n@@ -738,7 +757,7 @@ package body Sem_Elab is\n       Table_Name           => \"Top_Level_Scenarios\");\n \n    --  The following table stores the bodies of all eligible scenarios visited\n-   --  during a traversal starting from a top level scenario. The contents of\n+   --  during a traversal starting from a top-level scenario. The contents of\n    --  this table must be reset upon each new traversal.\n \n    Visited_Bodies_Max : constant := 511;\n@@ -867,7 +886,7 @@ package body Sem_Elab is\n    --  Return the code unit which contains arbitrary node or entity N. This\n    --  is the unit of the file which physically contains the related construct\n    --  denoted by N except when N is within an instantiation. In that case the\n-   --  unit is that of the top level instantiation.\n+   --  unit is that of the top-level instantiation.\n \n    procedure Find_Elaborated_Units;\n    --  Populate table Elaboration_Context with all units which have prior\n@@ -1019,11 +1038,6 @@ package body Sem_Elab is\n    pragma Inline (Is_Bodiless_Subprogram);\n    --  Determine whether subprogram Subp_Id will never have a body\n \n-   function Is_Check_Emitting_Scenario (N : Node_Id) return Boolean;\n-   pragma Inline (Is_Check_Emitting_Scenario);\n-   --  Determine whether arbitrary node N denotes a scenario which may emit a\n-   --  conditional ABE check.\n-\n    function Is_Controlled_Proc\n      (Subp_Id  : Entity_Id;\n       Subp_Nam : Name_Id) return Boolean;\n@@ -1101,6 +1115,11 @@ package body Sem_Elab is\n    --  Determine whether entity Id denotes the protected or unprotected version\n    --  of a protected subprogram.\n \n+   function Is_Recorded_Top_Level_Scenario (N : Node_Id) return Boolean;\n+   pragma Inline (Is_Recorded_Top_Level_Scenario);\n+   --  Determine whether arbitrary node is a recorded top-level scenario which\n+   --  appears in table Top_Level_Scenarios.\n+\n    function Is_Safe_Activation\n      (Call      : Node_Id;\n       Task_Decl : Node_Id) return Boolean;\n@@ -1329,14 +1348,14 @@ package body Sem_Elab is\n    --  routine.\n \n    procedure Process_Guaranteed_ABE (N : Node_Id);\n-   --  Top level dispatcher for processing of scenarios which result in a\n+   --  Top-level dispatcher for processing of scenarios which result in a\n    --  guaranteed ABE.\n \n    procedure Process_Instantiation\n      (Exp_Inst       : Node_Id;\n       In_Partial_Fin : Boolean;\n       In_Task_Body   : Boolean);\n-   --  Top level dispatcher for processing of instantiations. Perform ABE\n+   --  Top-level dispatcher for processing of instantiations. Perform ABE\n    --  checks and diagnostics for expanded instantiation Exp_Inst. Flag\n    --  In_Partial_Fin shoud be set when the processing is initiated by a\n    --  partial finalization routine. Flag In_Task_Body should be set when\n@@ -1393,14 +1412,14 @@ package body Sem_Elab is\n      (N              : Node_Id;\n       In_Partial_Fin : Boolean := False;\n       In_Task_Body   : Boolean := False);\n-   --  Top level dispatcher for processing of various elaboration scenarios.\n+   --  Top-level dispatcher for processing of various elaboration scenarios.\n    --  Perform ABE checks and diagnostics for scenario N. Flag In_Partial_Fin\n    --  shoud be set when the processing is initiated by a partial finalization\n    --  routine. Flag In_Task_Body should be set when the processing is started\n    --  from a task body.\n \n    procedure Process_Variable_Assignment (Asmt : Node_Id);\n-   --  Top level dispatcher for processing of variable assignments. Perform ABE\n+   --  Top-level dispatcher for processing of variable assignments. Perform ABE\n    --  checks and diagnostics for assignment statement Asmt.\n \n    procedure Process_Variable_Assignment_Ada\n@@ -1416,7 +1435,7 @@ package body Sem_Elab is\n    --  updates the value of variable Var_Id using the SPARK rules.\n \n    procedure Process_Variable_Reference (Ref : Node_Id);\n-   --  Top level dispatcher for processing of variable references. Perform ABE\n+   --  Top-level dispatcher for processing of variable references. Perform ABE\n    --  checks and diagnostics for variable reference Ref.\n \n    procedure Process_Variable_Reference_Read\n@@ -1432,10 +1451,16 @@ package body Sem_Elab is\n \n    function Root_Scenario return Node_Id;\n    pragma Inline (Root_Scenario);\n-   --  Return the top level scenario which started a recursive search for other\n-   --  scenarios. It is assumed that there is a valid top level scenario on the\n+   --  Return the top-level scenario which started a recursive search for other\n+   --  scenarios. It is assumed that there is a valid top-level scenario on the\n    --  active scenario stack.\n \n+   procedure Set_Is_Recorded_Top_Level_Scenario\n+     (N   : Node_Id;\n+      Val : Boolean := True);\n+   pragma Inline (Set_Is_Recorded_Top_Level_Scenario);\n+   --  Mark scenario N as being recorded in table Top_Level_Scenarios\n+\n    function Static_Elaboration_Checks return Boolean;\n    pragma Inline (Static_Elaboration_Checks);\n    --  Determine whether the static model is in effect\n@@ -1970,12 +1995,12 @@ package body Sem_Elab is\n \n       Find_Elaborated_Units;\n \n-      --  Examine each top level scenario saved during the Recording phase and\n+      --  Examine each top-level scenario saved during the Recording phase and\n       --  perform various actions depending on the elaboration model in effect.\n \n       for Index in Top_Level_Scenarios.First .. Top_Level_Scenarios.Last loop\n \n-         --  Clear the table of visited scenario bodies for each new top level\n+         --  Clear the table of visited scenario bodies for each new top-level\n          --  scenario.\n \n          Visited_Bodies.Reset;\n@@ -2046,7 +2071,7 @@ package body Sem_Elab is\n \n       Level := Find_Enclosing_Level (Call);\n \n-      --  Library level calls are always considered because they are part of\n+      --  Library-level calls are always considered because they are part of\n       --  the associated unit's elaboration actions.\n \n       if Level in Library_Level then\n@@ -3589,7 +3614,7 @@ package body Sem_Elab is\n                return Declaration_Level;\n             end if;\n \n-         --  The current construct is a declaration level encapsulator\n+         --  The current construct is a declaration-level encapsulator\n \n          elsif Nkind_In (Curr, N_Entry_Body,\n                                N_Subprogram_Body,\n@@ -3612,9 +3637,9 @@ package body Sem_Elab is\n                return Declaration_Level;\n             end if;\n \n-         --  The current construct is a non-library level encapsulator which\n+         --  The current construct is a non-library-level encapsulator which\n          --  indicates that the node cannot possibly appear at any level.\n-         --  Note that this check must come after the declaration level check\n+         --  Note that this check must come after the declaration-level check\n          --  because both predicates share certain nodes.\n \n          elsif Is_Non_Library_Level_Encapsulator (Curr) then\n@@ -4103,7 +4128,7 @@ package body Sem_Elab is\n       Nested_OK : Boolean := False) return Boolean\n    is\n       function Find_Enclosing_Context (N : Node_Id) return Node_Id;\n-      --  Return the nearest enclosing non-library level or compilation unit\n+      --  Return the nearest enclosing non-library-level or compilation unit\n       --  node which which encapsulates arbitrary node N. Return Empty is no\n       --  such context is available.\n \n@@ -4149,7 +4174,7 @@ package body Sem_Elab is\n                   return Par;\n                end if;\n \n-            --  Reaching a compilation unit node without hitting a non-library\n+            --  Reaching a compilation unit node without hitting a non-library-\n             --  level encapsulator indicates that N is at the library level in\n             --  which case the compilation unit is the context.\n \n@@ -4231,7 +4256,7 @@ package body Sem_Elab is\n \n    procedure Initialize is\n    begin\n-      --  Set the soft link which enables Atree.Rewrite to update a top level\n+      --  Set the soft link which enables Atree.Rewrite to update a top-level\n       --  scenario each time it is transformed into another node.\n \n       Set_Rewriting_Proc (Update_Elaboration_Scenario'Access);\n@@ -4837,19 +4862,6 @@ package body Sem_Elab is\n       return False;\n    end Is_Bodiless_Subprogram;\n \n-   --------------------------------\n-   -- Is_Check_Emitting_Scenario --\n-   --------------------------------\n-\n-   function Is_Check_Emitting_Scenario (N : Node_Id) return Boolean is\n-   begin\n-      return\n-        Nkind_In (N, N_Call_Marker,\n-                     N_Function_Instantiation,\n-                     N_Package_Instantiation,\n-                     N_Procedure_Instantiation);\n-   end Is_Check_Emitting_Scenario;\n-\n    ------------------------\n    -- Is_Controlled_Proc --\n    ------------------------\n@@ -5105,6 +5117,15 @@ package body Sem_Elab is\n           and then Present (Protected_Subprogram (Id));\n    end Is_Protected_Body_Subp;\n \n+   ------------------------------------\n+   -- Is_Recorded_Top_Level_Scenario --\n+   ------------------------------------\n+\n+   function Is_Recorded_Top_Level_Scenario (N : Node_Id) return Boolean is\n+   begin\n+      return Recorded_Top_Level_Scenarios.Get (N);\n+   end Is_Recorded_Top_Level_Scenario;\n+\n    ------------------------\n    -- Is_Safe_Activation --\n    ------------------------\n@@ -5568,7 +5589,7 @@ package body Sem_Elab is\n    begin\n       --  The root appears within the declaratons of a block statement, entry\n       --  body, subprogram body, or task body ignoring enclosing packages. The\n-      --  root is always within the main unit. An up level target is a notion\n+      --  root is always within the main unit. An up-level target is a notion\n       --  applicable only to the static model because scenarios are reached by\n       --  means of graph traversal started from a fixed declarative or library\n       --  level.\n@@ -5578,7 +5599,7 @@ package body Sem_Elab is\n       if Static_Elaboration_Checks\n         and then Find_Enclosing_Level (Root) = Declaration_Level\n       then\n-         --  The target is within the main unit. It acts as an up level target\n+         --  The target is within the main unit. It acts as an up-level target\n          --  when it appears within a context which encloses the root.\n \n          --    package body Main_Unit is\n@@ -5594,7 +5615,7 @@ package body Sem_Elab is\n             return not In_Same_Context (Root, Target_Decl, Nested_OK => True);\n \n          --  Otherwise the target is external to the main unit which makes it\n-         --  an up level target.\n+         --  an up-level target.\n \n          else\n             return True;\n@@ -5609,14 +5630,32 @@ package body Sem_Elab is\n    -------------------------------\n \n    procedure Kill_Elaboration_Scenario (N : Node_Id) is\n+      package Scenarios renames Top_Level_Scenarios;\n+\n    begin\n-      --  Eliminate the scenario by suppressing the generation of conditional\n-      --  ABE checks or guaranteed ABE failures. Note that other diagnostics\n-      --  must be carried out ignoring the fact that the scenario is within\n-      --  dead code.\n+      --  Eliminate a recorded top-level scenario when it appears within dead\n+      --  code because it will not be executed at elaboration time.\n \n-      if Is_Scenario (N) then\n-         Set_Is_Elaboration_Checks_OK_Node (N, False);\n+      if Is_Scenario (N)\n+        and then Is_Recorded_Top_Level_Scenario (N)\n+      then\n+         --  Performance node: list traversal\n+\n+         for Index in Scenarios.First .. Scenarios.Last loop\n+            if Scenarios.Table (Index) = N then\n+               Scenarios.Table (Index) := Empty;\n+\n+               --  The top-level scenario is no longer recorded\n+\n+               Set_Is_Recorded_Top_Level_Scenario (N, False);\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  A recorded top-level scenario must be in the table of recorded\n+         --  top-level scenarios.\n+\n+         pragma Assert (False);\n       end if;\n    end Kill_Elaboration_Scenario;\n \n@@ -8352,7 +8391,7 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Ensure that a library level call does not appear in a preelaborated\n+      --  Ensure that a library-level call does not appear in a preelaborated\n       --  unit. The check must come before ignoring scenarios within external\n       --  units or inside generics because calls in those context must also be\n       --  verified.\n@@ -8426,23 +8465,23 @@ package body Sem_Elab is\n \n          Level := Find_Enclosing_Level (N);\n \n-         --  Declaration level scenario\n+         --  Declaration-level scenario\n \n          if Declaration_Level_OK and then Level = Declaration_Level then\n             null;\n \n-         --  Library level scenario\n+         --  Library-level scenario\n \n          elsif Level in Library_Level then\n             null;\n \n-         --  Instantiation library level scenario\n+         --  Instantiation library-level scenario\n \n          elsif Level = Instantiation then\n             null;\n \n          --  Otherwise the scenario does not appear at the proper level and\n-         --  cannot possibly act as a top level scenario.\n+         --  cannot possibly act as a top-level scenario.\n \n          else\n             return;\n@@ -8459,16 +8498,21 @@ package body Sem_Elab is\n       --  later processing by the ABE phase.\n \n       Top_Level_Scenarios.Append (N);\n+      Set_Is_Recorded_Top_Level_Scenario (N);\n+   end Record_Elaboration_Scenario;\n \n-      --  Mark a scenario which may produce run-time conditional ABE checks or\n-      --  guaranteed ABE failures as recorded. The flag ensures that scenario\n-      --  rewriting performed by Atree.Rewrite will be properly reflected in\n-      --  all relevant internal data structures.\n+   ---------------------------------------\n+   -- Recorded_Top_Level_Scenarios_Hash --\n+   ---------------------------------------\n \n-      if Is_Check_Emitting_Scenario (N) then\n-         Set_Is_Recorded_Scenario (N);\n-      end if;\n-   end Record_Elaboration_Scenario;\n+   function Recorded_Top_Level_Scenarios_Hash\n+     (Key : Node_Id) return Recorded_Top_Level_Scenarios_Index\n+   is\n+   begin\n+      return\n+        Recorded_Top_Level_Scenarios_Index\n+          (Key mod Recorded_Top_Level_Scenarios_Max);\n+   end Recorded_Top_Level_Scenarios_Hash;\n \n    -------------------\n    -- Root_Scenario --\n@@ -8485,6 +8529,18 @@ package body Sem_Elab is\n       return Stack.Table (Stack.First);\n    end Root_Scenario;\n \n+   ----------------------------------------\n+   -- Set_Is_Recorded_Top_Level_Scenario --\n+   ----------------------------------------\n+\n+   procedure Set_Is_Recorded_Top_Level_Scenario\n+     (N   : Node_Id;\n+      Val : Boolean := True)\n+   is\n+   begin\n+      Recorded_Top_Level_Scenarios.Set (N, Val);\n+   end Set_Is_Recorded_Top_Level_Scenario;\n+\n    -------------------------------\n    -- Static_Elaboration_Checks --\n    -------------------------------\n@@ -8590,7 +8646,7 @@ package body Sem_Elab is\n \n             --  Save a suitable scenario in the Nested_Scenarios list of the\n             --  subprogram body. As a result any subsequent traversals of the\n-            --  subprogram body started from a different top level scenario no\n+            --  subprogram body started from a different top-level scenario no\n             --  longer need to reexamine the tree.\n \n             elsif Is_Suitable_Scenario (Nod) then\n@@ -8683,7 +8739,7 @@ package body Sem_Elab is\n       end if;\n \n       --  Nothing to do if the body was already traversed during the processing\n-      --  of the same top level scenario.\n+      --  of the same top-level scenario.\n \n       if Visited_Bodies.Get (N) then\n          return;\n@@ -8697,7 +8753,7 @@ package body Sem_Elab is\n       Nested := Nested_Scenarios (Defining_Entity (N));\n \n       --  The subprogram body was already examined as part of the elaboration\n-      --  graph starting from a different top level scenario. There is no need\n+      --  graph starting from a different top-level scenario. There is no need\n       --  to traverse the declarations and statements again because this will\n       --  yield the exact same scenarios. Use the nested scenarios collected\n       --  during the first inspection of the body.\n@@ -8721,28 +8777,36 @@ package body Sem_Elab is\n       package Scenarios renames Top_Level_Scenarios;\n \n    begin\n+      --  Nothing to do when the old and new scenarios are one and the same\n+\n+      if Old_N = New_N then\n+         return;\n+\n       --  A scenario is being transformed by Atree.Rewrite. Update all relevant\n       --  internal data structures to reflect this change. This ensures that a\n       --  potential run-time conditional ABE check or a guaranteed ABE failure\n       --  is inserted at the proper place in the tree.\n \n-      if Is_Check_Emitting_Scenario (Old_N)\n-        and then Is_Recorded_Scenario (Old_N)\n-        and then Old_N /= New_N\n+      elsif Is_Scenario (Old_N)\n+        and then Is_Recorded_Top_Level_Scenario (Old_N)\n       then\n          --  Performance note: list traversal\n \n          for Index in Scenarios.First .. Scenarios.Last loop\n             if Scenarios.Table (Index) = Old_N then\n                Scenarios.Table (Index) := New_N;\n \n-               Set_Is_Recorded_Scenario (Old_N, False);\n-               Set_Is_Recorded_Scenario (New_N);\n+               --  The old top-level scenario is no longer recorded, but the\n+               --  new one is.\n+\n+               Set_Is_Recorded_Top_Level_Scenario (Old_N, False);\n+               Set_Is_Recorded_Top_Level_Scenario (New_N);\n                return;\n             end if;\n          end loop;\n \n-         --  A recorded scenario must be in the table of recorded scenarios\n+         --  A recorded top-level scenario must be in the table of recorded\n+         --  top-level scenarios.\n \n          pragma Assert (False);\n       end if;"}, {"sha": "0f6223e158746967975a4892d9286e1d39f8314c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -3327,7 +3327,7 @@ package body Sem_Prag is\n          elsif Placement = Private_State_Space then\n             if Scope (Encap_Id) /= Pack_Id then\n                SPARK_Msg_NE\n-                 (\"indicator Part_Of must designate an abstract state of \"\n+                 (\"indicator Part_Of must denote an abstract state of \"\n                   & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                SPARK_Msg_NE"}, {"sha": "3faeb556548c98e35ca9d63e4259353384be6701", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -5161,11 +5161,11 @@ package body Sem_Res is\n                          (Parent (Associated_Node_For_Itype (Typ))))\n                   then\n                      Error_Msg_N\n-                       (\"info: coextension will not be finalized when its \"\n+                       (\"??coextension will not be finalized when its \"\n                         & \"associated owner is finalized\", N);\n                   else\n                      Error_Msg_N\n-                       (\"info: coextension will not be finalized when its \"\n+                       (\"??coextension will not be finalized when its \"\n                         & \"associated owner is deallocated\", N);\n                   end if;\n                else\n@@ -5174,12 +5174,12 @@ package body Sem_Res is\n                           (Parent (Associated_Node_For_Itype (Typ))))\n                   then\n                      Error_Msg_N\n-                       (\"info: coextension will not be deallocated when its \"\n-                        & \"associated owner is finalized\", N);\n+                       (\"??coextension will not be deallocated when \"\n+                        & \"its associated owner is finalized\", N);\n                   else\n                      Error_Msg_N\n-                       (\"info: coextension will not be deallocated when its \"\n-                        & \"associated owner is deallocated\", N);\n+                       (\"??coextension will not be deallocated when \"\n+                        & \"its associated owner is deallocated\", N);\n                   end if;\n                end if;\n             end if;\n@@ -5189,6 +5189,19 @@ package body Sem_Res is\n          else\n             Set_Is_Dynamic_Coextension (N, False);\n             Set_Is_Static_Coextension  (N, False);\n+\n+            --  ??? It seems we also do not properly finalize anonymous\n+            --  access-to-controlled objects within their declared scope and\n+            --  instead finalize them with their associated unit. Warn the\n+            --  user about it here.\n+\n+            if Ekind (Typ) = E_Anonymous_Access_Type\n+               and then Is_Controlled_Active (Desig_T)\n+            then\n+               Error_Msg_N (\"??anonymous access-to-controlled object will \"\n+                            & \"be finalized when its enclosing unit goes out \"\n+                            & \"of scope\", N);\n+            end if;\n          end if;\n       end if;\n "}, {"sha": "20ff3b26557102538166a60de6f8fe456d3f720e", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -2098,17 +2098,6 @@ package body Sinfo is\n       return Flag1 (N);\n    end Is_Read;\n \n-   function Is_Recorded_Scenario\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Call_Marker\n-        or else NT (N).Nkind = N_Function_Instantiation\n-        or else NT (N).Nkind = N_Package_Instantiation\n-        or else NT (N).Nkind = N_Procedure_Instantiation);\n-      return Flag6 (N);\n-   end Is_Recorded_Scenario;\n-\n    function Is_Source_Call\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5537,17 +5526,6 @@ package body Sinfo is\n       Set_Flag1 (N, Val);\n    end Set_Is_Read;\n \n-   procedure Set_Is_Recorded_Scenario\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Call_Marker\n-        or else NT (N).Nkind = N_Function_Instantiation\n-        or else NT (N).Nkind = N_Package_Instantiation\n-        or else NT (N).Nkind = N_Procedure_Instantiation);\n-      Set_Flag6 (N, Val);\n-   end Set_Is_Recorded_Scenario;\n-\n    procedure Set_Is_Source_Call\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "3c3c9fbf995b50e6c81e685beb7a4b4ed2c01e13", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1867,12 +1867,6 @@ package Sinfo is\n    --    Present in variable reference markers. Set when the original variable\n    --    reference constitues a read of the variable.\n \n-   --  Is_Recorded_Scenario (Flag6-Sem)\n-   --    Present in call marker and instantiation nodes. Set when the scenario\n-   --    was saved by the ABE Recording phase. This flag aids the ABE machinery\n-   --    to keep its internal data up-to-date in case the node is transformed\n-   --    by Atree.Rewrite.\n-\n    --  Is_Source_Call (Flag4-Sem)\n    --    Present in call marker nodes. Set when the related call came from\n    --    source.\n@@ -7045,7 +7039,6 @@ package Sinfo is\n       --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n       --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Is_Declaration_Level_Node (Flag5-Sem)\n-      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n \n       --  N_Procedure_Instantiation\n@@ -7059,7 +7052,6 @@ package Sinfo is\n       --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n       --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Is_Declaration_Level_Node (Flag5-Sem)\n-      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n@@ -7075,7 +7067,6 @@ package Sinfo is\n       --  Is_Elaboration_Checks_OK_Node (Flag1-Sem)\n       --  Is_SPARK_Mode_On_Node (Flag2-Sem)\n       --  Is_Declaration_Level_Node (Flag5-Sem)\n-      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Must_Override (Flag14) set if overriding indicator present\n       --  Must_Not_Override (Flag15) set if not_overriding indicator present\n       --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n@@ -7833,7 +7824,6 @@ package Sinfo is\n       --  Is_Dispatching_Call (Flag3-Sem)\n       --  Is_Source_Call (Flag4-Sem)\n       --  Is_Declaration_Level_Node (Flag5-Sem)\n-      --  Is_Recorded_Scenario (Flag6-Sem)\n       --  Is_Known_Guaranteed_ABE (Flag18-Sem)\n \n       ------------------------\n@@ -9777,9 +9767,6 @@ package Sinfo is\n    function Is_Read\n      (N : Node_Id) return Boolean;    -- Flag1\n \n-   function Is_Recorded_Scenario\n-     (N : Node_Id) return Boolean;    -- Flag6\n-\n    function Is_Source_Call\n      (N : Node_Id) return Boolean;    -- Flag4\n \n@@ -10872,9 +10859,6 @@ package Sinfo is\n    procedure Set_Is_Read\n      (N : Node_Id; Val : Boolean := True);    -- Flag1\n \n-   procedure Set_Is_Recorded_Scenario\n-     (N : Node_Id; Val : Boolean := True);    -- Flag6\n-\n    procedure Set_Is_Source_Call\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n@@ -13337,7 +13321,6 @@ package Sinfo is\n    pragma Inline (Is_Protected_Subprogram_Body);\n    pragma Inline (Is_Qualified_Universal_Literal);\n    pragma Inline (Is_Read);\n-   pragma Inline (Is_Recorded_Scenario);\n    pragma Inline (Is_Source_Call);\n    pragma Inline (Is_SPARK_Mode_On_Node);\n    pragma Inline (Is_Static_Coextension);\n@@ -13697,7 +13680,6 @@ package Sinfo is\n    pragma Inline (Set_Is_Protected_Subprogram_Body);\n    pragma Inline (Set_Is_Qualified_Universal_Literal);\n    pragma Inline (Set_Is_Read);\n-   pragma Inline (Set_Is_Recorded_Scenario);\n    pragma Inline (Set_Is_Source_Call);\n    pragma Inline (Set_Is_SPARK_Mode_On_Node);\n    pragma Inline (Set_Is_Static_Coextension);"}, {"sha": "e59114d48c739f96a8e772cdd9fb5d2cad2e2f96", "filename": "gcc/ada/spark_xrefs.adb", "status": "modified", "additions": 31, "deletions": 74, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fspark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fspark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Lib.Xref;\n with Output;   use Output;\n with Sem_Util; use Sem_Util;\n \n@@ -33,92 +34,48 @@ package body SPARK_Xrefs is\n    ------------\n \n    procedure dspark is\n-   begin\n-      --  Dump SPARK cross-reference file table\n-\n-      Write_Line (\"SPARK Xrefs File Table\");\n-      Write_Line (\"----------------------\");\n-\n-      for Index in SPARK_File_Table.First .. SPARK_File_Table.Last loop\n-         declare\n-            AFR : SPARK_File_Record renames SPARK_File_Table.Table (Index);\n-\n-         begin\n-            Write_Str (\"  \");\n-            Write_Int (Int (Index));\n-            Write_Str (\".  File_Num = \");\n-            Write_Int (Int (AFR.File_Num));\n-            Write_Str (\"  From = \");\n-            Write_Int (Int (AFR.From_Scope));\n-            Write_Str (\"  To = \");\n-            Write_Int (Int (AFR.To_Scope));\n-            Write_Eol;\n-         end;\n-      end loop;\n-\n-      --  Dump SPARK cross-reference scope table\n \n-      Write_Eol;\n-      Write_Line (\"SPARK Xrefs Scope Table\");\n-      Write_Line (\"-----------------------\");\n+      procedure Dump (Index : Nat; AXR : SPARK_Xref_Record);\n+\n+      procedure Dump_SPARK_Xrefs is new\n+        Lib.Xref.SPARK_Specific.Iterate_SPARK_Xrefs (Dump);\n+\n+      ----------\n+      -- Dump --\n+      ----------\n+\n+      procedure Dump (Index : Nat; AXR : SPARK_Xref_Record) is\n+      begin\n+         Write_Str  (\"  \");\n+         Write_Int  (Index);\n+         Write_Char ('.');\n+\n+         Write_Str  (\" Entity = \" & Unique_Name (AXR.Entity));\n+         Write_Str  (\" (\");\n+         Write_Int  (Nat (AXR.Entity));\n+         Write_Str  (\")\");\n \n-      for Index in SPARK_Scope_Table.First .. SPARK_Scope_Table.Last loop\n-         declare\n-            ASR : SPARK_Scope_Record renames SPARK_Scope_Table.Table (Index);\n+         Write_Str  (\" Scope = \" & Unique_Name (AXR.Ref_Scope));\n+         Write_Str  (\" (\");\n+         Write_Int  (Nat (AXR.Ref_Scope));\n+         Write_Str  (\")\");\n \n-         begin\n-            Write_Str (\"  \");\n-            Write_Int (Int (Index));\n-            Write_Str (\"  Scope_Name = \"\"\");\n+         Write_Str  (\" Ref_Type = '\" & AXR.Rtype & \"'\");\n \n-            Write_Str (Unique_Name (ASR.Entity));\n+         Write_Eol;\n+      end Dump;\n \n-            Write_Char ('\"');\n-            Write_Str  (\"  From = \");\n-            Write_Int  (Int (ASR.From_Xref));\n-            Write_Str  (\"  To = \");\n-            Write_Int  (Int (ASR.To_Xref));\n-            Write_Eol;\n-         end;\n-      end loop;\n+   --  Start of processing for dspark\n \n+   begin\n       --  Dump SPARK cross-reference table\n \n       Write_Eol;\n       Write_Line (\"SPARK Xref Table\");\n       Write_Line (\"----------------\");\n \n-      for Index in SPARK_Xref_Table.First .. SPARK_Xref_Table.Last loop\n-         declare\n-            AXR : SPARK_Xref_Record renames SPARK_Xref_Table.Table (Index);\n-\n-         begin\n-            Write_Str  (\"  \");\n-            Write_Int  (Int (Index));\n-            Write_Str (\".  Entity_Name = \"\"\");\n-\n-            Write_Str (Unique_Name (AXR.Entity));\n-\n-            Write_Char ('\"');\n-            Write_Str (\"  Reference_Scope = \");\n-            Write_Str (Unique_Name (AXR.Ref_Scope));\n-            Write_Char ('\"');\n-            Write_Str (\"  Type = \");\n-            Write_Char (AXR.Rtype);\n-            Write_Eol;\n-         end;\n-      end loop;\n-   end dspark;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n+      Dump_SPARK_Xrefs;\n \n-   procedure Initialize_SPARK_Tables is\n-   begin\n-      SPARK_File_Table.Init;\n-      SPARK_Scope_Table.Init;\n-      SPARK_Xref_Table.Init;\n-   end Initialize_SPARK_Tables;\n+   end dspark;\n \n end SPARK_Xrefs;"}, {"sha": "25af9024d510696fc2e09b206aeedb3414b01339", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 4, "deletions": 114, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -23,48 +23,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package defines tables used to store information needed for the SPARK\n---  mode. It is used by procedures in Lib.Xref.SPARK_Specific to build the\n---  SPARK-specific cross-reference information.\n+--  This package defines data structures used to expose frontend\n+--  cross-references to the SPARK backend.\n \n-with Table;\n with Types; use Types;\n \n package SPARK_Xrefs is\n \n-   --  SPARK cross-reference information is stored internally using three\n-   --  tables: SPARK_Xref_Table, SPARK_Scope_Table and SPARK_File_Table, which\n-   --  are defined in this unit.\n-\n-   --  Lib.Xref.SPARK_Specific is part of the compiler. It extracts SPARK\n-   --  cross-reference information from the complete set of cross-references\n-   --  generated during compilation.\n-\n-   --  -------------------------------\n-   --  -- Generated Globals Section --\n-   --  -------------------------------\n-\n-   --  The Generated Globals section is located at the end of the ALI file\n-\n-   --  All lines with information related to the Generated Globals begin with\n-   --  string \"GG\". This string should therefore not be used in the beginning\n-   --  of any line not related to Generated Globals.\n-\n-   --  The processing (reading and writing) of this section happens in package\n-   --  Flow_Generated_Globals (from the SPARK 2014 sources), for further\n-   --  information please refer there.\n-\n-   ----------------\n-   -- Xref Table --\n-   ----------------\n-\n-   --  The following table records SPARK cross-references\n-\n-   type Xref_Index is new Nat;\n-   --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed; value 0 is used temporarily\n-   --  until a proper value is determined.\n-\n    type SPARK_Xref_Record is record\n       Entity : Entity_Id;\n       --  Referenced entity\n@@ -78,80 +43,8 @@ package SPARK_Xrefs is\n       --    m = modification\n       --    s = call\n    end record;\n-\n-   package SPARK_Xref_Table is new Table.Table (\n-     Table_Component_Type => SPARK_Xref_Record,\n-     Table_Index_Type     => Xref_Index,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 2000,\n-     Table_Increment      => 300,\n-     Table_Name           => \"Xref_Table\");\n-\n-   -----------------\n-   -- Scope Table --\n-   -----------------\n-\n-   --  This table keeps track of the scopes and the corresponding starting and\n-   --  ending indexes (From, To) in the Xref table.\n-\n-   type Scope_Index is new Nat;\n-   --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed; value 0 indicates that no\n-   --  entries have been constructed and is also used until a proper value is\n-   --  determined.\n-\n-   type SPARK_Scope_Record is record\n-      Entity : Entity_Id;\n-      --  Entity that is represented by the scope\n-\n-      Scope_Num : Pos;\n-      --  Set to the scope number within the enclosing unit\n-\n-      From_Xref : Xref_Index;\n-      --  Starting index in Xref table for this scope\n-\n-      To_Xref : Xref_Index;\n-      --  Ending index in Xref table for this scope\n-   end record;\n-\n-   package SPARK_Scope_Table is new Table.Table (\n-     Table_Component_Type => SPARK_Scope_Record,\n-     Table_Index_Type     => Scope_Index,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 200,\n-     Table_Increment      => 300,\n-     Table_Name           => \"Scope_Table\");\n-\n-   ----------------\n-   -- File Table --\n-   ----------------\n-\n-   --  This table keeps track of the units and the corresponding starting and\n-   --  ending indexes (From, To) in the Scope table.\n-\n-   type File_Index is new Nat;\n-   --  Used to index values in this table. Values start at 1 and are assigned\n-   --  sequentially as entries are constructed; value 0 indicates that no\n-   --  entries have been constructed.\n-\n-   type SPARK_File_Record is record\n-      File_Num : Nat;\n-      --  Dependency number in ALI file\n-\n-      From_Scope : Scope_Index;\n-      --  Starting index in Scope table for this unit\n-\n-      To_Scope : Scope_Index;\n-      --  Ending index in Scope table for this unit\n-   end record;\n-\n-   package SPARK_File_Table is new Table.Table (\n-     Table_Component_Type => SPARK_File_Record,\n-     Table_Index_Type     => File_Index,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 20,\n-     Table_Increment      => 200,\n-     Table_Name           => \"File_Table\");\n+   --  This type holds a subset of the frontend xref entry that is needed by\n+   --  the SPARK backend.\n \n    ---------------\n    -- Constants --\n@@ -170,9 +63,6 @@ package SPARK_Xrefs is\n    -- Subprograms --\n    -----------------\n \n-   procedure Initialize_SPARK_Tables;\n-   --  Reset tables for a new compilation\n-\n    procedure dspark;\n    --  Debug routine to dump internal SPARK cross-reference tables. This is a\n    --  raw format dump showing exactly what the tables contain."}, {"sha": "c1ff88d234e5b5b15eab09e74f9a4bb7a52f0f1a", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -337,19 +337,7 @@ package body Switch.C is\n \n             when 'C' =>\n                Ptr := Ptr + 1;\n-\n-               if not CodePeer_Mode then\n-                  CodePeer_Mode := True;\n-\n-                  --  Suppress compiler warnings by default, since what we are\n-                  --  interested in here is what CodePeer can find out. Note\n-                  --  that if -gnatwxxx is specified after -gnatC on the\n-                  --  command line, we do not want to override this setting in\n-                  --  Adjust_Global_Switches, and assume that the user wants to\n-                  --  get both warnings from GNAT and CodePeer messages.\n-\n-                  Warning_Mode := Suppress;\n-               end if;\n+               CodePeer_Mode := True;\n \n             --  -gnatd (compiler debug options)\n "}, {"sha": "f3dbf601012c5da902b5054b48a3e5dd709aef56", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1,3 +1,13 @@\n+2017-11-09  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/elab3.adb, gnat.dg/elab3.ads, gnat.dg/elab3_pkg.adb,\n+\tgnat.dg/elab3_pkg.ads: New testcase.\n+\n+2017-11-09  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+    * gnat.dg/controlled2.adb, gnat.dg/controlled4.adb, gnat.dg/finalized.adb:\n+    Disable the new warning from GNAT.\n+\n 2017-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/82837"}, {"sha": "5b7eeddf7e9a98c99bce2a9f5fbb2d82bb1651b2", "filename": "gcc/testsuite/gnat.dg/controlled2.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled2.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1,5 +1,8 @@\n --  { dg-do compile }\n \n+pragma Warnings\n+  (Off, \"anonymous access-to-controlled object will be finalized when its enclosing unit goes out of scope\");\n+\n with controlled1; use controlled1;\n package body controlled2 is\n    procedure Test_Suite is"}, {"sha": "9809dc61e287dc6fbf9b96feaf7998263c030e1a", "filename": "gcc/testsuite/gnat.dg/controlled4.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fcontrolled4.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1,5 +1,8 @@\n --  { dg-do compile }\n \n+pragma Warnings\n+  (Off, \"anonymous access-to-controlled object will be finalized when its enclosing unit goes out of scope\");\n+\n package body controlled4 is\n    procedure Test_Suite is\n    begin"}, {"sha": "2c0a4b2df25b5cd8064b4f6615785841eeec442c", "filename": "gcc/testsuite/gnat.dg/elab3.adb", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -0,0 +1,9 @@\n+--  { dg-do compile }\n+\n+with Elab3_Pkg;\n+\n+package body Elab3 is\n+   package Inst is new Elab3_Pkg (False, ABE);\n+\n+   procedure ABE is begin null; end ABE;\n+end Elab3;"}, {"sha": "92fd4c3821bd33dbd569426ead6a11f795b8343b", "filename": "gcc/testsuite/gnat.dg/elab3.ads", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Felab3.ads?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -0,0 +1,3 @@\n+package Elab3 is\n+   procedure ABE;\n+end Elab3;"}, {"sha": "76616d00eafc32010cde252c41e3244e9f33aa33", "filename": "gcc/testsuite/gnat.dg/elab3_pkg.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -0,0 +1,11 @@\n+package body Elab3_Pkg is\n+   procedure Elaborator is\n+   begin\n+      Proc;\n+   end Elaborator;\n+\n+begin\n+   if Elaborate then\n+      Elaborator;\n+   end if;\n+end Elab3_Pkg;"}, {"sha": "b4abf3a6a4211c6c8e8f87af8f4c21f32959af3f", "filename": "gcc/testsuite/gnat.dg/elab3_pkg.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Felab3_pkg.ads?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -0,0 +1,7 @@\n+generic\n+   Elaborate : Boolean := True;\n+   with procedure Proc;\n+\n+package Elab3_Pkg is\n+   procedure Elaborator;\n+end Elab3_Pkg;"}, {"sha": "ebbe474277fb6bf38ac41ae2a8b0c4ec01f7e14d", "filename": "gcc/testsuite/gnat.dg/finalized.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Ffinalized.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23f55b4932192981183ab6a3f914ef22476ec93/gcc%2Ftestsuite%2Fgnat.dg%2Ffinalized.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ffinalized.adb?ref=c23f55b4932192981183ab6a3f914ef22476ec93", "patch": "@@ -1,5 +1,8 @@\n -- { dg-do compile }\n \n+pragma Warnings\n+  (Off, \"anonymous access-to-controlled object will be finalized when its enclosing unit goes out of scope\");\n+\n with Ada.Finalization; use Ada.Finalization;\n procedure finalized is\n    type Rec is new Controlled with null record;"}]}