{"sha": "cc2c4c656715397ac4f815c5b4987c03dd839cbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MyYzRjNjU2NzE1Mzk3YWM0ZjgxNWM1YjQ5ODdjMDNkZDgzOWNiZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-04-06T09:20:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:20:37Z"}, "message": "exp_ch9.ads, [...] (Family_Offset): Add new 'Cap' boolean parameter.\n\n2007-04-06  Eric Botcazou <botcazou@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch9.ads, exp_ch9.adb (Family_Offset): Add new 'Cap' boolean\n\tparameter. If it is set to true, return a result capped according to\n\tthe global upper bound for the index of an entry family.\n\t(Family_Size): Add new 'Cap' boolean parameter. Pass it to Family_Offset\n\t(Build_Find_Body_Index): Adjust for above change.\n\t(Entry_Index_Expression): Likewise.\n\t(Is_Potentially_Large_Family): New function extracted from...\n\t(Collect_Entry_Families): ...here. Call it to detect whether the family\n\tis potentially large.\n\t(Build_Entry_Count_Expression): If the family is potentially large, call\n\tFamily_Size with 'Cap' set to true.\n\t(Expand_N_Protected_Type_Declaration, Expand_N_Protected_Body): Generate\n\ta protected version of an operation declared in the private part of\n\ta protected object, because they may be invoked through a callback.\n\t(Set_Privals): If the type of a private component is an anonymous access\n\ttype, do not create a new itype for each protected body.\n\tIf the body of a protected operation creates\n\tcontrolled types (including allocators for class-widetypes), the\n\tbody of the corresponding protected subprogram must include a\n\tfinalization list.\n\t(Build_Activation_Chain_Entity): Build the chain entity for extended\n\treturn statements.\n\t(Type_Conformant_Parameters): Use common predicate Conforming_Types\n\tto determine whether operation overrides an inherited primitive.\n\t(Build_Wrapper_Spec): Add code to examine the parents while looking\n\tfor a possible overriding candidate.\n\t(Build_Simple_Entry_Call): Set No_Initialization on the object used to\n\thold an actual parameter value since its initialization is separated\n\tfrom the the declaration. Prevents errors on null-excluding access\n\tformals.\n\nFrom-SVN: r123564", "tree": {"sha": "5e652cf55de9f2dc7750f819386dfd9793ef1257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e652cf55de9f2dc7750f819386dfd9793ef1257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc2c4c656715397ac4f815c5b4987c03dd839cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2c4c656715397ac4f815c5b4987c03dd839cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2c4c656715397ac4f815c5b4987c03dd839cbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2c4c656715397ac4f815c5b4987c03dd839cbf/comments", "author": null, "committer": null, "parents": [{"sha": "afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe4375b43ca2a4b57c992ab6dc6f242ddd5e124"}], "stats": {"total": 430, "additions": 294, "deletions": 136}, "files": [{"sha": "75b9b8082b5fdac0e20cf7af400f6eb8c2c306a0", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 292, "deletions": 130, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2c4c656715397ac4f815c5b4987c03dd839cbf/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2c4c656715397ac4f815c5b4987c03dd839cbf/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=cc2c4c656715397ac4f815c5b4987c03dd839cbf", "patch": "@@ -285,21 +285,25 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id) return Node_Id;\n+      Ttyp : Entity_Id;\n+      Cap  : Boolean) return Node_Id;\n    --  Compute (Hi - Lo) for two entry family indices. Hi is the index in\n    --  an accept statement, or the upper bound in the discrete subtype of\n    --  an entry declaration. Lo is the corresponding lower bound. Ttyp is\n-   --  the concurrent type of the entry.\n+   --  the concurrent type of the entry. If Cap is true, the result is\n+   --  capped according to Entry_Family_Bound.\n \n    function Family_Size\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id) return Node_Id;\n+      Ttyp : Entity_Id;\n+      Cap  : Boolean) return Node_Id;\n    --  Compute (Hi - Lo) + 1 Max 0, to determine the number of entries in\n    --  a family, and handle properly the superflat case. This is equivalent\n    --  to the use of 'Length on the index type, but must use Family_Offset\n    --  to handle properly the case of bounds that depend on discriminants.\n+   --  If Cap is true, the result is capped according to Entry_Family_Bound.\n \n    procedure Extract_Dispatching_Call\n      (N        : Node_Id;\n@@ -339,6 +343,12 @@ package body Exp_Ch9 is\n    --       E - <<index of first family member>> +\n    --       Protected_Entry_Index (Index_Type'Pos (Index_Type'First)));\n \n+   function Is_Potentially_Large_Family\n+     (Base_Index : Entity_Id;\n+      Conctyp    : Entity_Id;\n+      Lo         : Node_Id;\n+      Hi         : Node_Id) return Boolean;\n+\n    function Parameter_Block_Pack\n      (Loc     : Source_Ptr;\n       Blk_Typ : Entity_Id;\n@@ -457,19 +467,19 @@ package body Exp_Ch9 is\n    --  Start of processing for Actual_Index_Expression\n \n    begin\n-      --  The queues of entries and entry families appear in  textual\n-      --  order in the associated record. The entry index is computed as\n-      --  the sum of the number of queues for all entries that precede the\n-      --  designated one, to which is added the index expression, if this\n-      --  expression denotes a member of a family.\n+      --  The queues of entries and entry families appear in textual order in\n+      --  the associated record. The entry index is computed as the sum of the\n+      --  number of queues for all entries that precede the designated one, to\n+      --  which is added the index expression, if this expression denotes a\n+      --  member of a family.\n \n       --  The following is a place holder for the count of simple entries\n \n       Num := Make_Integer_Literal (Sloc, 1);\n \n-      --  We construct an expression which is a series of addition\n-      --  operations. See comments in Entry_Index_Expression, which is\n-      --  identical in structure.\n+      --  We construct an expression which is a series of addition operations.\n+      --  See comments in Entry_Index_Expression, which is identical in\n+      --  structure.\n \n       if Present (Index) then\n          S := Etype (Discrete_Subtype_Definition (Declaration_Node (Ent)));\n@@ -818,7 +828,7 @@ package body Exp_Ch9 is\n \n       Set_Exception_Handlers (New_S,\n         New_List (\n-          Make_Exception_Handler (Loc,\n+          Make_Implicit_Exception_Handler (Loc,\n             Exception_Choices => New_List (Ohandle),\n \n             Statements =>  New_List (\n@@ -846,8 +856,8 @@ package body Exp_Ch9 is\n \n    procedure Build_Activation_Chain_Entity (N : Node_Id) is\n       P     : Node_Id;\n-      B     : Node_Id;\n       Decls : List_Id;\n+      Chain : Entity_Id;\n \n    begin\n       --  Loop to find enclosing construct containing activation chain variable\n@@ -859,38 +869,54 @@ package body Exp_Ch9 is\n         and then Nkind (P) /= N_Package_Body\n         and then Nkind (P) /= N_Block_Statement\n         and then Nkind (P) /= N_Task_Body\n+        and then Nkind (P) /= N_Extended_Return_Statement\n       loop\n          P := Parent (P);\n       end loop;\n \n       --  If we are in a package body, the activation chain variable is\n-      --  allocated in the corresponding spec. First, we save the package\n-      --  body node because we enter the new entity in its Declarations list.\n-\n-      B := P;\n+      --  declared in the body, but the Activation_Chain_Entity is attached to\n+      --  the spec.\n \n       if Nkind (P) = N_Package_Body then\n+         Decls := Declarations (P);\n          P := Unit_Declaration_Node (Corresponding_Spec (P));\n-         Decls := Declarations (B);\n \n       elsif Nkind (P) = N_Package_Declaration then\n-         Decls := Visible_Declarations (Specification (B));\n+         Decls := Visible_Declarations (Specification (P));\n+\n+      elsif Nkind (P) = N_Extended_Return_Statement then\n+         Decls := Return_Object_Declarations (P);\n \n       else\n-         Decls := Declarations (B);\n+         Decls := Declarations (P);\n       end if;\n \n       --  If activation chain entity not already declared, declare it\n \n-      if No (Activation_Chain_Entity (P)) then\n-         Set_Activation_Chain_Entity\n-           (P, Make_Defining_Identifier (Sloc (N), Name_uChain));\n+      if Nkind (P) = N_Extended_Return_Statement\n+        or else No (Activation_Chain_Entity (P))\n+      then\n+         Chain := Make_Defining_Identifier (Sloc (N), Name_uChain);\n+\n+         --  An extended return statement is not really a task activator, but\n+         --  it does have an activation chain on which to store the tasks\n+         --  temporarily. On successful return, the tasks on this chain are\n+         --  moved to the chain passed in by the\n+         --  caller. N_Extended_Return_Statement does not have an\n+         --  Activation_Chain_Entity, because we do not want to build a call\n+         --  to Activate_Tasks; task activation is the responsibility of the\n+         --  caller.\n+\n+         if Nkind (P) /= N_Extended_Return_Statement then\n+            Set_Activation_Chain_Entity (P, Chain);\n+         end if;\n \n          Prepend_To (Decls,\n            Make_Object_Declaration (Sloc (P),\n-             Defining_Identifier => Activation_Chain_Entity (P),\n+             Defining_Identifier => Chain,\n              Aliased_Present => True,\n-             Object_Definition   =>\n+             Object_Definition =>\n                New_Reference_To (RTE (RE_Activation_Chain), Sloc (P))));\n \n          Analyze (First (Decls));\n@@ -1111,6 +1137,7 @@ package body Exp_Ch9 is\n       Lo     : Node_Id;\n       Hi     : Node_Id;\n       Typ    : Entity_Id;\n+      Large  : Boolean;\n \n    begin\n       --  Count number of non-family entries\n@@ -1140,11 +1167,13 @@ package body Exp_Ch9 is\n             Typ := Etype (Discrete_Subtype_Definition (Parent (Ent)));\n             Hi := Type_High_Bound (Typ);\n             Lo := Type_Low_Bound  (Typ);\n-\n+            Large := Is_Potentially_Large_Family\n+                       (Base_Type (Typ), Concurrent_Type, Lo, Hi);\n             Ecount :=\n               Make_Op_Add (Loc,\n                 Left_Opnd  => Ecount,\n-                Right_Opnd => Family_Size (Loc, Hi, Lo, Concurrent_Type));\n+                Right_Opnd => Family_Size\n+                                (Loc, Hi, Lo, Concurrent_Type, Large));\n          end if;\n \n          Next_Entity (Ent);\n@@ -1440,13 +1469,12 @@ package body Exp_Ch9 is\n             while Present (Prim_Op_Param)\n               and then Present (Proc_Param)\n             loop\n-               --  The two parameters must be mode conformant and have\n-               --  the exact same types.\n+               --  The two parameters must be mode conformant\n \n-               if Ekind (Defining_Identifier (Prim_Op_Param)) /=\n-                  Ekind (Defining_Identifier (Proc_Param))\n-                 or else Etype (Parameter_Type (Prim_Op_Param)) /=\n-                         Etype (Parameter_Type (Proc_Param))\n+               if not Conforming_Types (\n+                 Etype (Parameter_Type (Prim_Op_Param)),\n+                 Etype (Parameter_Type (Proc_Param)),\n+                 Mode_Conformant)\n                then\n                   return False;\n                end if;\n@@ -1542,51 +1570,90 @@ package body Exp_Ch9 is\n       --  The mode is determined by the first parameter of the interface-level\n       --  procedure that the current entry is trying to override.\n \n-      pragma Assert (Present (Abstract_Interfaces\n-                     (Corresponding_Record_Type (Scope (Proc_Nam)))));\n-\n-      Iface_Elmt :=\n-        First_Elmt (Abstract_Interfaces\n-                    (Corresponding_Record_Type (Scope (Proc_Nam))));\n+      pragma Assert (Is_Non_Empty_List (Abstract_Interface_List (Obj_Typ)));\n \n       --  We must examine all the protected operations of the implemented\n       --  interfaces in order to discover a possible overriding candidate.\n \n-      Examine_Interfaces : while Present (Iface_Elmt) loop\n-         Iface := Node (Iface_Elmt);\n+      Iface := Etype (First (Abstract_Interface_List (Obj_Typ)));\n \n+      Examine_Parents : loop\n          if Present (Primitive_Operations (Iface)) then\n             Iface_Prim_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n             while Present (Iface_Prim_Op_Elmt) loop\n                Iface_Prim_Op := Node (Iface_Prim_Op_Elmt);\n \n-               while Present (Alias (Iface_Prim_Op)) loop\n-                  Iface_Prim_Op := Alias (Iface_Prim_Op);\n-               end loop;\n+               if not Is_Predefined_Dispatching_Operation (Iface_Prim_Op) then\n+                  while Present (Alias (Iface_Prim_Op)) loop\n+                     Iface_Prim_Op := Alias (Iface_Prim_Op);\n+                  end loop;\n \n-               --  The current primitive operation can be overriden by the\n-               --  generated entry wrapper.\n+                  --  The current primitive operation can be overriden by the\n+                  --  generated entry wrapper.\n \n-               if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n-                  First_Param :=\n-                    First (Parameter_Specifications (Parent (Iface_Prim_Op)));\n+                  if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n+                     First_Param := First  (Parameter_Specifications\n+                                             (Parent (Iface_Prim_Op)));\n \n-                  exit Examine_Interfaces;\n+                     goto Found;\n+                  end if;\n                end if;\n \n                Next_Elmt (Iface_Prim_Op_Elmt);\n             end loop;\n          end if;\n \n-         Next_Elmt (Iface_Elmt);\n-      end loop Examine_Interfaces;\n+         exit Examine_Parents when Etype (Iface) = Iface;\n \n-      --  Return if no interface primitive can be overriden\n+         Iface := Etype (Iface);\n+      end loop Examine_Parents;\n \n-      if No (First_Param) then\n-         return Empty;\n+      if Present (Abstract_Interfaces\n+                   (Corresponding_Record_Type (Scope (Proc_Nam))))\n+      then\n+         Iface_Elmt := First_Elmt\n+                         (Abstract_Interfaces\n+                           (Corresponding_Record_Type (Scope (Proc_Nam))));\n+         Examine_Interfaces : while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            if Present (Primitive_Operations (Iface)) then\n+               Iface_Prim_Op_Elmt := First_Elmt (Primitive_Operations (Iface));\n+               while Present (Iface_Prim_Op_Elmt) loop\n+                  Iface_Prim_Op := Node (Iface_Prim_Op_Elmt);\n+\n+                  if not Is_Predefined_Dispatching_Operation\n+                           (Iface_Prim_Op)\n+                  then\n+                     while Present (Alias (Iface_Prim_Op)) loop\n+                        Iface_Prim_Op := Alias (Iface_Prim_Op);\n+                     end loop;\n+\n+                     --  The current primitive operation can be overriden by\n+                     --  the generated entry wrapper.\n+\n+                     if Overriding_Possible (Iface_Prim_Op, Proc_Nam) then\n+                        First_Param := First (Parameter_Specifications\n+                                               (Parent (Iface_Prim_Op)));\n+\n+                        goto Found;\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (Iface_Prim_Op_Elmt);\n+               end loop;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop Examine_Interfaces;\n       end if;\n \n+      --  Return if no interface primitive can be overriden\n+\n+      return Empty;\n+\n+      <<Found>>\n+\n       New_Formals := Replicate_Entry_Formals (Loc, Formals);\n \n       --  ??? Certain source packages contain protected or task types that do\n@@ -1802,7 +1869,7 @@ package body Exp_Ch9 is\n                E_Typ := Etype (Discrete_Subtype_Definition (Parent (Ent)));\n                Hi := Convert_Discriminant_Ref (Type_High_Bound (E_Typ));\n                Lo := Convert_Discriminant_Ref (Type_Low_Bound  (E_Typ));\n-               Add_If_Clause (Family_Size (Loc, Hi, Lo, Typ));\n+               Add_If_Clause (Family_Size (Loc, Hi, Lo, Typ, False));\n             end if;\n \n             Next_Entity (Ent);\n@@ -2047,7 +2114,7 @@ package body Exp_Ch9 is\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => Op_Stats,\n                  Exception_Handlers => New_List (\n-                   Make_Exception_Handler (Loc,\n+                   Make_Implicit_Exception_Handler (Loc,\n                      Exception_Choices => New_List (Ohandle),\n \n                      Statements =>  New_List (\n@@ -2833,6 +2900,12 @@ package body Exp_Ch9 is\n                       Object_Definition =>\n                         New_Reference_To (Etype (Formal), Loc));\n \n+                  --  Mark the object as not needing initialization since the\n+                  --  initialization is performed separately, avoiding errors\n+                  --  on cases such as formals of null-excluding access types.\n+\n+                  Set_No_Initialization (N_Node);\n+\n                   --  We have to make an assignment statement separate for the\n                   --  case of limited type. We cannot assign it unless the\n                   --  Assignment_OK flag is set first.\n@@ -3079,7 +3152,7 @@ package body Exp_Ch9 is\n \n    begin\n       --  Get the activation chain entity. Except in the case of a package\n-      --  body, this is in the node that w as passed. For a package body, we\n+      --  body, this is in the node that was passed. For a package body, we\n       --  have to find the corresponding package declaration node.\n \n       if Nkind (N) = N_Package_Body then\n@@ -3375,15 +3448,8 @@ package body Exp_Ch9 is\n             begin\n                Get_Index_Bounds\n                  (Discrete_Subtype_Definition (Parent (Efam)), Lo, Hi);\n-               if Scope (Bas) = Standard_Standard\n-                 and then Bas = Base_Type (Standard_Integer)\n-                 and then Has_Discriminants (Conctyp)\n-                 and then Present\n-                   (Discriminant_Default_Value (First_Discriminant (Conctyp)))\n-                 and then\n-                   (Denotes_Discriminant (Lo, True)\n-                     or else Denotes_Discriminant (Hi, True))\n-               then\n+\n+               if Is_Potentially_Large_Family (Bas, Conctyp, Lo, Hi) then\n                   Bas :=\n                     Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n                   Bas_Decl :=\n@@ -3696,7 +3762,8 @@ package body Exp_Ch9 is\n                    Prefix => New_Reference_To (Base_Type (S), Sloc),\n                    Expressions => New_List (Relocate_Node (Index))),\n                  Type_Low_Bound (S),\n-                 Ttyp));\n+                 Ttyp,\n+                 False));\n       else\n          Expr := Num;\n       end if;\n@@ -3721,7 +3788,7 @@ package body Exp_Ch9 is\n             Expr :=\n               Make_Op_Add (Sloc,\n               Left_Opnd  => Expr,\n-              Right_Opnd => Family_Size (Sloc, Hi, Lo, Ttyp));\n+              Right_Opnd => Family_Size (Sloc, Hi, Lo, Ttyp, False));\n \n          --  Other components are anonymous types to be ignored\n \n@@ -5288,7 +5355,7 @@ package body Exp_Ch9 is\n             --  Create the inner block to protect the abortable part\n \n             Hdle := New_List (\n-              Make_Exception_Handler (Loc,\n+              Make_Implicit_Exception_Handler (Loc,\n                 Exception_Choices =>\n                   New_List (New_Reference_To (Stand.Abort_Signal, Loc)),\n                 Statements => New_List (\n@@ -5470,7 +5537,7 @@ package body Exp_Ch9 is\n                --  exception\n \n                  Exception_Handlers => New_List (\n-                   Make_Exception_Handler (Loc,\n+                   Make_Implicit_Exception_Handler (Loc,\n \n                --  when Abort_Signal =>\n                --     Abort_Undefer.all;\n@@ -5538,7 +5605,7 @@ package body Exp_Ch9 is\n          --  Create the inner block to protect the abortable part\n \n          Hdle :=  New_List (\n-           Make_Exception_Handler (Loc,\n+           Make_Implicit_Exception_Handler (Loc,\n              Exception_Choices =>\n                New_List (New_Reference_To (Stand.Abort_Signal, Loc)),\n              Statements => New_List (\n@@ -6421,8 +6488,8 @@ package body Exp_Ch9 is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n       Has_Entries  : Boolean := False;\n-      Op_Decl      : Node_Id;\n       Op_Body      : Node_Id;\n+      Op_Decl      : Node_Id;\n       Op_Id        : Entity_Id;\n       Disp_Op_Body : Node_Id;\n       New_Op_Body  : Node_Id;\n@@ -6556,29 +6623,47 @@ package body Exp_Ch9 is\n                   New_Op_Body :=\n                     Build_Unprotected_Subprogram_Body (Op_Body, Pid);\n \n+                  --  Propagate the finalization chain to the new body.\n+                  --  In the unlikely event that the subprogram contains a\n+                  --  declaration or allocator for an object that requires\n+                  --  finalization, the corresponding chain is created when\n+                  --  analyzing the body, and attached to its entity. This\n+                  --  entity is not further elaborated, and so the chain\n+                  --  properly belongs to the newly created subprogram body.\n+\n+                  if Present\n+                    (Finalization_Chain_Entity (Defining_Entity (Op_Body)))\n+                  then\n+                     Set_Finalization_Chain_Entity\n+                       (Protected_Body_Subprogram\n+                         (Corresponding_Spec (Op_Body)),\n+                       Finalization_Chain_Entity (Defining_Entity (Op_Body)));\n+                     Set_Analyzed\n+                         (Handled_Statement_Sequence (New_Op_Body), False);\n+                  end if;\n+\n                   Insert_After (Current_Node, New_Op_Body);\n                   Current_Node := New_Op_Body;\n                   Analyze (New_Op_Body);\n \n                   Update_Prival_Subtypes (New_Op_Body);\n \n-                  --  Build the corresponding protected operation only if\n-                  --  this is a visible operation of the type, or if it is\n-                  --  an interrupt handler. Otherwise it is only callable\n-                  --  from within the object, and the unprotected version\n-                  --  is sufficient.\n+                  --  Build the corresponding protected operation. It may\n+                  --  appear that this is needed only this is a visible\n+                  --  operation of the type, or if it is an interrupt handler,\n+                  --  and this was the strategy used previously in GNAT.\n+                  --  However, the operation may be exported through a\n+                  --  'Access to an external caller. This is the common idiom\n+                  --  in code that uses the Ada 2005 Timing_Events package\n+                  --  As a result we need to produce the protected body for\n+                  --  both visible and private operations.\n \n                   if Present (Corresponding_Spec (Op_Body)) then\n                      Op_Decl :=\n-                       Unit_Declaration_Node (Corresponding_Spec (Op_Body));\n-\n-                     if Nkind (Parent (Op_Decl)) = N_Protected_Definition\n-                       and then\n-                         (List_Containing (Op_Decl) =\n-                                  Visible_Declarations (Parent (Op_Decl))\n-                           or else\n-                            Is_Interrupt_Handler\n-                              (Corresponding_Spec (Op_Body)))\n+                        Unit_Declaration_Node (Corresponding_Spec (Op_Body));\n+\n+                     if\n+                       Nkind (Parent (Op_Decl)) = N_Protected_Definition\n                      then\n                         New_Op_Body :=\n                            Build_Protected_Subprogram_Body (\n@@ -6591,7 +6676,7 @@ package body Exp_Ch9 is\n \n                         --  Generate an overriding primitive operation body for\n                         --  this subprogram if the protected type implements\n-                        --  an inerface.\n+                        --  an interface.\n \n                         if Ada_Version >= Ada_05\n                           and then Present (Abstract_Interfaces (\n@@ -7093,19 +7178,19 @@ package body Exp_Ch9 is\n \n                Current_Node := Sub;\n \n+               Sub :=\n+                 Make_Subprogram_Declaration (Loc,\n+                   Specification =>\n+                     Build_Protected_Sub_Specification\n+                       (Priv, Prottyp, Protected_Mode));\n+\n+               Insert_After (Current_Node, Sub);\n+               Analyze (Sub);\n+               Current_Node := Sub;\n+\n                if Is_Interrupt_Handler\n                  (Defining_Unit_Name (Specification (Priv)))\n                then\n-                  Sub :=\n-                    Make_Subprogram_Declaration (Loc,\n-                      Specification =>\n-                        Build_Protected_Sub_Specification\n-                          (Priv, Prottyp, Protected_Mode));\n-\n-                  Insert_After (Current_Node, Sub);\n-                  Analyze (Sub);\n-                  Current_Node := Sub;\n-\n                   if not Restricted_Profile then\n                      Register_Handler;\n                   end if;\n@@ -8331,7 +8416,7 @@ package body Exp_Ch9 is\n       --  and the parameter references have already been expanded to be direct\n       --  references to Ann (see Exp_Ch2.Expand_Entry_Parameter). Furthermore,\n       --  any embedded tasking statements (which would normally be illegal in\n-      --  procedures, have been converted to calls to the tasking runtime so\n+      --  procedures), have been converted to calls to the tasking runtime so\n       --  there is no problem in putting them into procedures.\n \n       --  The original accept statement has been expanded into a block in\n@@ -9173,11 +9258,37 @@ package body Exp_Ch9 is\n          Ent_Stack := Make_Defining_Identifier (Loc, Name_uStack);\n \n          if Present (Taskdef) and then Has_Storage_Size_Pragma (Taskdef) then\n-            Task_Size := Relocate_Node (\n-              Expression (First (\n-                Pragma_Argument_Associations (\n-                  Find_Task_Or_Protected_Pragma\n-                    (Taskdef, Name_Storage_Size)))));\n+            declare\n+               Expr_N : constant Node_Id :=\n+                          Expression (First (\n+                            Pragma_Argument_Associations (\n+                              Find_Task_Or_Protected_Pragma\n+                                (Taskdef, Name_Storage_Size))));\n+               Etyp   : constant Entity_Id := Etype (Expr_N);\n+               P      : constant Node_Id   := Parent (Expr_N);\n+\n+            begin\n+               --  The stack is defined inside the corresponding record.\n+               --  Therefore if the size of the stack is set by means of\n+               --  a discriminant, we must reference the discriminant of the\n+               --  corresponding record type.\n+\n+               if Nkind (Expr_N) in N_Has_Entity\n+                 and then Present (Discriminal_Link (Entity (Expr_N)))\n+               then\n+                  Task_Size :=\n+                    New_Reference_To\n+                      (CR_Discriminant (Discriminal_Link (Entity (Expr_N))),\n+                       Loc);\n+                  Set_Parent   (Task_Size, P);\n+                  Set_Etype    (Task_Size, Etyp);\n+                  Set_Analyzed (Task_Size);\n+\n+               else\n+                  Task_Size := Relocate_Node (Expr_N);\n+               end if;\n+            end;\n+\n          else\n             Task_Size :=\n               New_Reference_To (RTE (RE_Default_Stack_Size), Loc);\n@@ -10050,23 +10161,15 @@ package body Exp_Ch9 is\n \n    function External_Subprogram (E : Entity_Id) return Entity_Id is\n       Subp : constant Entity_Id := Protected_Body_Subprogram (E);\n-      Decl : constant Node_Id   := Unit_Declaration_Node (E);\n \n    begin\n-      --  If the protected operation is defined in the visible part of the\n-      --  protected type, or if it is an interrupt handler, the internal and\n-      --  external subprograms follow each other on the entity chain. If the\n-      --  operation is defined in the private part of the type, there is no\n-      --  need for a separate locking version of the operation, and internal\n-      --  calls use the protected_body_subprogram directly.\n-\n-      if List_Containing (Decl) = Visible_Declarations (Parent (Decl))\n-        or else Is_Interrupt_Handler (E)\n-      then\n-         return Next_Entity (Subp);\n-      else\n-         return (Subp);\n-      end if;\n+      --  The internal and external subprograms follow each other on the\n+      --  entity chain. Note that previously private operations had no\n+      --  separate external subprogram. We now create one in all cases,\n+      --  because a private operation may actually appear in an external\n+      --  call, through a 'Access reference used for a callback.\n+\n+      return Next_Entity (Subp);\n    end External_Subprogram;\n \n    ------------------------------\n@@ -10160,14 +10263,19 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id) return Node_Id\n+      Ttyp : Entity_Id;\n+      Cap  : Boolean) return Node_Id\n    is\n+      Ityp : Entity_Id;\n+      Real_Hi : Node_Id;\n+      Real_Lo : Node_Id;\n+\n       function Convert_Discriminant_Ref (Bound : Node_Id) return Node_Id;\n       --  If one of the bounds is a reference to a discriminant, replace with\n       --  corresponding discriminal of type. Within the body of a task retrieve\n       --  the renamed discriminant by simple visibility, using its generated\n-      --  name. Within a protected object, find the original dis- criminant and\n-      --  replace it with the discriminal of the current prot- ected operation.\n+      --  name. Within a protected object, find the original discriminant and\n+      --  replace it with the discriminal of the current protected operation.\n \n       ------------------------------\n       -- Convert_Discriminant_Ref --\n@@ -10217,10 +10325,34 @@ package body Exp_Ch9 is\n    --  Start of processing for Family_Offset\n \n    begin\n-      return\n-        Make_Op_Subtract (Loc,\n-          Left_Opnd  => Convert_Discriminant_Ref (Hi),\n-          Right_Opnd => Convert_Discriminant_Ref (Lo));\n+      Real_Hi := Convert_Discriminant_Ref (Hi);\n+      Real_Lo := Convert_Discriminant_Ref (Lo);\n+\n+      if Cap then\n+         if Is_Task_Type (Ttyp) then\n+            Ityp := RTE (RE_Task_Entry_Index);\n+         else\n+            Ityp := RTE (RE_Protected_Entry_Index);\n+         end if;\n+\n+         Real_Hi :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Ityp, Loc),\n+             Attribute_Name => Name_Min,\n+             Expressions    => New_List (\n+               Real_Hi,\n+               Make_Integer_Literal (Loc, Entry_Family_Bound - 1)));\n+\n+         Real_Lo :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Ityp, Loc),\n+             Attribute_Name => Name_Max,\n+             Expressions    => New_List (\n+               Real_Lo,\n+               Make_Integer_Literal (Loc, -Entry_Family_Bound)));\n+      end if;\n+\n+      return Make_Op_Subtract (Loc, Real_Hi, Real_Lo);\n    end Family_Offset;\n \n    -----------------\n@@ -10231,7 +10363,8 @@ package body Exp_Ch9 is\n      (Loc  : Source_Ptr;\n       Hi   : Node_Id;\n       Lo   : Node_Id;\n-      Ttyp : Entity_Id) return Node_Id\n+      Ttyp : Entity_Id;\n+      Cap  : Boolean) return Node_Id\n    is\n       Ityp : Entity_Id;\n \n@@ -10249,7 +10382,7 @@ package body Exp_Ch9 is\n           Expressions    => New_List (\n             Make_Op_Add (Loc,\n               Left_Opnd  =>\n-                Family_Offset (Loc, Hi, Lo, Ttyp),\n+                Family_Offset (Loc, Hi, Lo, Ttyp, Cap),\n               Right_Opnd =>\n                 Make_Integer_Literal (Loc, 1)),\n             Make_Integer_Literal (Loc, 0)));\n@@ -10328,6 +10461,27 @@ package body Exp_Ch9 is\n       return First_Op;\n    end First_Protected_Operation;\n \n+   ---------------------------------\n+   -- Is_Potentially_Large_Family --\n+   ---------------------------------\n+\n+   function Is_Potentially_Large_Family\n+     (Base_Index : Entity_Id;\n+      Conctyp    : Entity_Id;\n+      Lo         : Node_Id;\n+      Hi         : Node_Id) return Boolean\n+   is\n+   begin\n+      return Scope (Base_Index) = Standard_Standard\n+        and then Base_Index = Base_Type (Standard_Integer)\n+        and then Has_Discriminants (Conctyp)\n+        and then Present\n+          (Discriminant_Default_Value (First_Discriminant (Conctyp)))\n+        and then\n+          (Denotes_Discriminant (Lo, True)\n+            or else Denotes_Discriminant (Hi, True));\n+   end Is_Potentially_Large_Family;\n+\n    --------------------------------\n    -- Index_Constant_Declaration --\n    --------------------------------\n@@ -11219,8 +11373,16 @@ package body Exp_Ch9 is\n                --  new itype for the corresponding prival in each protected\n                --  operation, to avoid scoping problems. We create new itypes\n                --  by copying the tree for the component definition.\n-\n-               if Is_Itype (Etype (P_Id)) then\n+               --  (Ada 2005) If the itype is an anonymous access type created\n+               --  for an access definition for a component, it is declared in\n+               --  the enclosing scope, and we do no create a local version of\n+               --  it, to prevent scoping anomalies in gigi.\n+\n+               if Is_Itype (Etype (P_Id))\n+                  and then not\n+                    (Is_Access_Type (Etype (P_Id))\n+                      and then Is_Local_Anonymous_Access (Etype (P_Id)))\n+               then\n                   Append_Elmt (P_Id, Assoc_L);\n                   Append_Elmt (Priv, Assoc_L);\n "}, {"sha": "819e80640879f94a29e3556f7793c63f468ac7b3", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc2c4c656715397ac4f815c5b4987c03dd839cbf/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc2c4c656715397ac4f815c5b4987c03dd839cbf/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=cc2c4c656715397ac4f815c5b4987c03dd839cbf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -77,11 +77,7 @@ package Exp_Ch9 is\n    --  (other than allocators to tasks) this routine ensures that an activation\n    --  chain has been declared in the appropriate scope, building the required\n    --  declaration for the chain variable if not. The name of this variable\n-   --  is always _Chain and it is accessed by name. This procedure also adds\n-   --  an appropriate call to Activate_Tasks to activate the tasks for this\n-   --  activation chain. It does not however deal with the call needed in the\n-   --  case of allocators to Expunge_Unactivated_Tasks, this is separately\n-   --  handled in the Expand_Task_Allocator routine.\n+   --  is always _Chain and it is accessed by name.\n \n    function Build_Call_With_Task (N : Node_Id; E : Entity_Id) return Node_Id;\n    --  N is a node representing the name of a task or an access to a task."}]}