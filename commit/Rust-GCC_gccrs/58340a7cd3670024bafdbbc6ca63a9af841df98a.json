{"sha": "58340a7cd3670024bafdbbc6ca63a9af841df98a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzNDBhN2NkMzY3MDAyNGJhZmRiYmM2Y2E2M2E5YWY4NDFkZjk4YQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-08-03T23:21:16Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2021-08-11T14:36:55Z"}, "message": "Fortran: Fix c_float128 and c_float128_complex definitions.\n\ngfc_float128_type_node is only non-NULL on targets that support a\n128-bit type that is not long double.  Use float128_type_node instead\nwhen computing the value of the kind constants c_float128 and\nc_float128_complex from the ISO_C_BINDING intrinsic module; this also\nensures it actually corresponds to __float128 (the IEEE encoding) and\nnot some other 128-bit floating-point type.\n\n2021-08-11  Sandra Loosemore  <sandra@codesourcery.com>\n\ngcc/fortran/\n\t* iso-c-binding.def (c_float128, c_float128_complex): Check\n\tfloat128_type_node instead of gfc_float128_type_node.\n\t* trans-types.c (gfc_init_kinds, gfc_build_real_type):\n\tUpdate comments re supported 128-bit floating-point types.", "tree": {"sha": "a96a3c8677e30e3d5d7a5391f20fdcb9bd94b743", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a96a3c8677e30e3d5d7a5391f20fdcb9bd94b743"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58340a7cd3670024bafdbbc6ca63a9af841df98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58340a7cd3670024bafdbbc6ca63a9af841df98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58340a7cd3670024bafdbbc6ca63a9af841df98a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58340a7cd3670024bafdbbc6ca63a9af841df98a/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba64d855df581cc26fa487162027138aef4dbe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba64d855df581cc26fa487162027138aef4dbe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba64d855df581cc26fa487162027138aef4dbe5"}], "stats": {"total": 27, "additions": 21, "deletions": 6}, "files": [{"sha": "e65c750faca7f29be728acf598ed2fb091aa0eb4", "filename": "gcc/fortran/iso-c-binding.def", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58340a7cd3670024bafdbbc6ca63a9af841df98a/gcc%2Ffortran%2Fiso-c-binding.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58340a7cd3670024bafdbbc6ca63a9af841df98a/gcc%2Ffortran%2Fiso-c-binding.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-c-binding.def?ref=58340a7cd3670024bafdbbc6ca63a9af841df98a", "patch": "@@ -114,19 +114,26 @@ NAMED_REALCST (ISOCBINDING_DOUBLE, \"c_double\", \\\n                get_real_kind_from_node (double_type_node), GFC_STD_F2003)\n NAMED_REALCST (ISOCBINDING_LONG_DOUBLE, \"c_long_double\", \\\n                get_real_kind_from_node (long_double_type_node), GFC_STD_F2003)\n+\n+/* GNU Extension.  Note that the equivalence here is specifically to\n+   the IEEE 128-bit type __float128; if that does not map onto a type\n+   otherwise supported by the Fortran front end, get_real_kind_from_node\n+   will reject it as unsupported.  */\n NAMED_REALCST (ISOCBINDING_FLOAT128, \"c_float128\", \\\n-\t       gfc_float128_type_node == NULL_TREE \\\n-\t\t  ? -4 : get_real_kind_from_node (gfc_float128_type_node), \\\n+\t\t(float128_type_node == NULL_TREE \\\n+\t\t ? -4 : get_real_kind_from_node (float128_type_node)), \\\n \t       GFC_STD_GNU)\n NAMED_CMPXCST (ISOCBINDING_FLOAT_COMPLEX, \"c_float_complex\", \\\n                get_real_kind_from_node (float_type_node), GFC_STD_F2003)\n NAMED_CMPXCST (ISOCBINDING_DOUBLE_COMPLEX, \"c_double_complex\", \\\n                get_real_kind_from_node (double_type_node), GFC_STD_F2003)\n NAMED_CMPXCST (ISOCBINDING_LONG_DOUBLE_COMPLEX, \"c_long_double_complex\", \\\n                get_real_kind_from_node (long_double_type_node), GFC_STD_F2003)\n+\n+/* GNU Extension.  Similar issues to c_float128 above.  */\n NAMED_CMPXCST (ISOCBINDING_FLOAT128_COMPLEX, \"c_float128_complex\", \\\n-\t       gfc_float128_type_node == NULL_TREE \\\n-\t\t  ? -4 : get_real_kind_from_node (gfc_float128_type_node), \\\n+\t\t(float128_type_node == NULL_TREE \\\n+\t\t ? -4 : get_real_kind_from_node (float128_type_node)), \\\n \t       GFC_STD_GNU)\n \n NAMED_LOGCST (ISOCBINDING_BOOL, \"c_bool\", \\"}, {"sha": "1c78a9063970374514a8e88ea88cb14d0529afff", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58340a7cd3670024bafdbbc6ca63a9af841df98a/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58340a7cd3670024bafdbbc6ca63a9af841df98a/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=58340a7cd3670024bafdbbc6ca63a9af841df98a", "patch": "@@ -446,7 +446,7 @@ gfc_init_kinds (void)\n       if (!targetm.scalar_mode_supported_p (mode))\n \tcontinue;\n \n-      /* Only let float, double, long double and __float128 go through.\n+      /* Only let float, double, long double and TFmode go through.\n \t Runtime support for others is not provided, so they would be\n \t useless.  */\n       if (!targetm.libgcc_floating_mode_supported_p (mode))\n@@ -471,7 +471,14 @@ gfc_init_kinds (void)\n \t We round up so as to handle IA-64 __floatreg (RFmode), which is an\n \t 82 bit type.  Not to be confused with __float80 (XFmode), which is\n \t an 80 bit type also supported by IA-64.  So XFmode should come out\n-\t to be kind=10, and RFmode should come out to be kind=11.  Egads.  */\n+\t to be kind=10, and RFmode should come out to be kind=11.  Egads.\n+\n+\t TODO: The kind calculation has to be modified to support all\n+\t three 128-bit floating-point modes on PowerPC as IFmode, KFmode,\n+\t and TFmode since the following line would all map to kind=16.\n+\t However, currently only float, double, long double, and TFmode\n+\t reach this code.\n+      */\n \n       kind = (GET_MODE_PRECISION (mode) + 7) / 8;\n \n@@ -851,6 +858,7 @@ gfc_build_real_type (gfc_real_info *info)\n     info->c_long_double = 1;\n   if (mode_precision != LONG_DOUBLE_TYPE_SIZE && mode_precision == 128)\n     {\n+      /* TODO: see PR101835.  */\n       info->c_float128 = 1;\n       gfc_real16_is_float128 = true;\n     }"}]}