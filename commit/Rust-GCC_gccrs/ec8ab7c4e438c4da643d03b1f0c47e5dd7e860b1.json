{"sha": "ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4YWI3YzRlNDM4YzRkYTY0M2QwM2IxZjBjNDdlNWRkN2U4NjBiMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-10-24T00:19:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-10-24T00:19:56Z"}, "message": "re PR libstdc++/50834 (Documentation about STL thread safety is ambiguous)\n\n\tPR libstdc++/50834\n\t* doc/xml/manual/using.xml: Update thread safety docs w.r.t. C++11.\n\nFrom-SVN: r180359", "tree": {"sha": "35b6db19f8a4cce0d4ea46f3c065378952374949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35b6db19f8a4cce0d4ea46f3c065378952374949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0d90b97f03b63c808922c20bf6c931535bb5ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d90b97f03b63c808922c20bf6c931535bb5ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0d90b97f03b63c808922c20bf6c931535bb5ea9"}], "stats": {"total": 111, "additions": 95, "deletions": 16}, "files": [{"sha": "0aba8f3b186c8b82f5fa099596380e601958da85", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "patch": "@@ -1,3 +1,8 @@\n+2011-10-22  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/50834\n+\t* doc/xml/manual/using.xml: Update thread safety docs w.r.t. C++11.\n+\n 2011-10-22  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/50196"}, {"sha": "495411658681313a47de2bd93e77c7aca7b65582", "filename": "libstdc++-v3/doc/xml/manual/using.xml", "status": "modified", "additions": 90, "deletions": 16, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fusing.xml?ref=ec8ab7c4e438c4da643d03b1f0c47e5dd7e860b1", "patch": "@@ -1281,9 +1281,16 @@ A quick read of the relevant part of the GCC\n     <section xml:id=\"manual.intro.using.concurrency.thread_safety\" xreflabel=\"Thread Safety\"><info><title>Thread Safety</title></info>\n       \n \n-\n <para>\n-We currently use the <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.sgi.com/tech/stl/thread_safety.html\">SGI STL</link> definition of thread safety.\n+In the terms of the 2011 C++ standard a thread-safe program is one which\n+does not perform any conflicting non-atomic operations on memory locations\n+and so does not contain any data races.\n+The standard places requirements on the library to ensure that no data\n+races are caused by the library itself or by programs which use the\n+library correctly (as described below).\n+The C++11 memory model and library requirements are a more formal version\n+of the <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.sgi.com/tech/stl/thread_safety.html\">SGI STL</link> definition of thread safety, which the library used\n+prior to the 2011 standard.\n </para>\n \n \n@@ -1329,43 +1336,110 @@ gcc version 4.1.2 20070925 (Red Hat 4.1.2-33)\n        </listitem>\n \n       </itemizedlist>\n-      <para>The user-code must guard against concurrent method calls which may\n-\t access any particular library object's state.  Typically, the\n-\t application programmer may infer what object locks must be held\n-\t based on the objects referenced in a method call.  Without getting\n+\n+      <para>The user code must guard against concurrent function calls which\n+         access any particular library object's state when one or more of\n+         those accesses modifies the state. An object will be modified by\n+         invoking a non-const member function on it or passing it as a\n+         non-const argument to a library function. An object will not be\n+         modified by invoking a const member function on it or passing it to\n+         a function as a pointer- or reference-to-const.\n+         Typically, the application\n+         programmer may infer what object locks must be held based on the\n+         objects referenced in a function call and whether the objects are\n+         accessed as const or non-const.  Without getting\n \t into great detail, here is an example which requires user-level\n \t locks:\n       </para>\n       <programlisting>\n      library_class_a shared_object_a;\n \n-     thread_main () {\n+     void thread_main () {\n        library_class_b *object_b = new library_class_b;\n        shared_object_a.add_b (object_b);   // must hold lock for shared_object_a\n        shared_object_a.mutate ();          // must hold lock for shared_object_a\n      }\n \n      // Multiple copies of thread_main() are started in independent threads.</programlisting>\n       <para>Under the assumption that object_a and object_b are never exposed to\n-\t another thread, here is an example that should not require any\n+\t another thread, here is an example that does not require any\n \t user-level locks:\n       </para>\n       <programlisting>\n-     thread_main () {\n+     void thread_main () {\n        library_class_a object_a;\n        library_class_b *object_b = new library_class_b;\n        object_a.add_b (object_b);\n        object_a.mutate ();\n      } </programlisting>\n-      <para>All library objects are safe to use in a multithreaded program as\n-\t long as each thread carefully locks out access by any other\n-\t thread while it uses any object visible to another thread, i.e.,\n-\t treat library objects like any other shared resource.  In general,\n-\t this requirement includes both read and write access to objects;\n-\t unless otherwise documented as safe, do not assume that two threads\n-\t may access a shared standard library object at the same time.\n+\n+      <para>All library types are safe to use in a multithreaded program\n+         if objects are not shared between threads or as\n+\t long each thread carefully locks out access by any other\n+\t thread while it modifies any object visible to another thread.\n+\t Unless otherwise documented, the only exceptions to these rules\n+         are atomic operations on the types in\n+         <filename class=\"headerfile\">&lt;atomic&gt;</filename>\n+         and lock/unlock operations on the standard mutex types in\n+         <filename class=\"headerfile\">&lt;mutex&gt;</filename>. These\n+         atomic operations allow concurrent accesses to the same object\n+         without introducing data races.\n+      </para>\n+\n+      <para>The following member functions of standard containers can be\n+         considered to be const for the purposes of avoiding data races:\n+         <code>begin</code>, <code>end</code>, <code>rbegin</code>, <code>rend</code>,\n+         <code>front</code>, <code>back</code>, <code>data</code>,\n+         <code>find</code>, <code>lower_bound</code>, <code>upper_bound</code>,\n+         <code>equal_range</code>, <code>at</code> \n+         and, except in associative or unordered associative containers,\n+         <code>operator[]</code>. In other words, although they are non-const\n+         so that they can return mutable iterators, those member functions\n+         will not modify the container.\n+         Accessing an iterator might cause a non-modifying access to\n+         the container the iterator refers to (for example incrementing a\n+         list iterator must access the pointers between nodes, which are part\n+         of the container and so conflict with other accesses to the container).\n       </para>\n \n+      <para>Programs which follow the rules above will not encounter data\n+         races in library code, even when using library types which share\n+         state between distinct objects.  In the example below the\n+         <code>shared_ptr</code> objects share a reference count, but\n+         because the code does not perform any non-const operations on the\n+         globally-visible object, the library ensures that the reference\n+         count updates are atomic and do not introduce data races:\n+      </para>\n+      <programlisting>\n+    std::shared_ptr&lt;int&gt; global_sp;\n+\n+    void thread_main() {\n+      auto local_sp = global_sp;  // OK, copy constructor's parameter is reference-to-const\n+\n+      int i = *global_sp;         // OK, operator* is const\n+      int j = *local_sp;          // OK, does not operate on global_sp\n+\n+      // *global_sp = 2;          // NOT OK, modifies int visible to other threads      \n+      // *local_sp = 2;           // NOT OK, modifies int visible to other threads      \n+\n+      // global_sp.reset();       // NOT OK, reset is non-const\n+      local_sp.reset();           // OK, does not operate on global_sp\n+    }\n+\n+    int main() {\n+      global_sp.reset(new int(1));\n+      std::thread t1(thread_main);\n+      std::thread t2(thread_main);\n+      t1.join();\n+      t2.join();\n+    }\n+      </programlisting>\n+\n+      <para>For further details of the C++11 memory model see Hans-J. Boehm's\n+      <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/user-faq.html\">Threads\n+      and memory model for C++</link> pages, particularly the <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/threadsintro.html\">introduction</link> \n+      and <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/user-faq.html\">FAQ</link>.\n+      </para>\n \n   </section>\n   <section xml:id=\"manual.intro.using.concurrency.atomics\" xreflabel=\"Atomics\"><info><title>Atomics</title></info>"}]}