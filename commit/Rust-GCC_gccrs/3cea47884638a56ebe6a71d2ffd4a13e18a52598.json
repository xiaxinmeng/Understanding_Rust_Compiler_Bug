{"sha": "3cea47884638a56ebe6a71d2ffd4a13e18a52598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NlYTQ3ODg0NjM4YTU2ZWJlNmE3MWQyZmZkNGExM2UxOGE1MjU5OA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-29T07:35:40Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-29T07:35:40Z"}, "message": "avr.h: Remove target-independent comments about target macros.\n\n\t* config/avr/avr.h: Remove target-independent comments about\n\ttarget macros.\n\nFrom-SVN: r76850", "tree": {"sha": "080003a0f8324a519b82babc112b23a7a218607e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/080003a0f8324a519b82babc112b23a7a218607e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cea47884638a56ebe6a71d2ffd4a13e18a52598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cea47884638a56ebe6a71d2ffd4a13e18a52598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cea47884638a56ebe6a71d2ffd4a13e18a52598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cea47884638a56ebe6a71d2ffd4a13e18a52598/comments", "author": null, "committer": null, "parents": [{"sha": "75e853f2c323b373396cd795a31ad7516dbcbb9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e853f2c323b373396cd795a31ad7516dbcbb9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e853f2c323b373396cd795a31ad7516dbcbb9b"}], "stats": {"total": 1511, "additions": 7, "deletions": 1504}, "files": [{"sha": "faa3c9a13762c94f50e6b74a83af8b2fa73368b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cea47884638a56ebe6a71d2ffd4a13e18a52598/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cea47884638a56ebe6a71d2ffd4a13e18a52598/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cea47884638a56ebe6a71d2ffd4a13e18a52598", "patch": "@@ -1,3 +1,8 @@\n+2004-01-29  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/avr/avr.h: Remove target-independent comments about\n+\ttarget macros.\n+\n 2004-01-28  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* timevar.c (timevar_print): Mention when checking is enabled."}, {"sha": "2c50d204d8d8c8f2a570aaf43aed603ff095dab3", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 2, "deletions": 1504, "changes": 1506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cea47884638a56ebe6a71d2ffd4a13e18a52598/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cea47884638a56ebe6a71d2ffd4a13e18a52598/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3cea47884638a56ebe6a71d2ffd4a13e18a52598", "patch": "@@ -103,42 +103,13 @@ extern int avr_asm_only_p;\n  { \"mcu=\", &avr_mcu_name, N_(\"Specify the MCU name\"), 0} }\n \n #define TARGET_VERSION fprintf (stderr, \" (GNU assembler syntax)\");\n-/* This macro is a C statement to print on `stderr' a string\n-   describing the particular machine description choice.  Every\n-   machine description should define `TARGET_VERSION'.  For example:\n-\n-   #ifdef MOTOROLA\n-   #define TARGET_VERSION \\\n-   fprintf (stderr, \" (68k, Motorola syntax)\");\n-   #else\n-   #define TARGET_VERSION \\\n-   fprintf (stderr, \" (68k, MIT syntax)\");\n-   #endif  */\n \n #define OVERRIDE_OPTIONS avr_override_options ()\n-/* `OVERRIDE_OPTIONS'\n-   Sometimes certain combinations of command options do not make\n-   sense on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-\n-   Don't use this macro to turn on various extra optimizations for\n-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n #define CAN_DEBUG_WITHOUT_FP\n-/* Define this macro if debugging can be performed even without a\n-   frame pointer.  If this macro is defined, GCC will turn on the\n-   `-fomit-frame-pointer' option whenever `-O' is specified.  */\n \n-/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n #define WORDS_BIG_ENDIAN 0\n \n #ifdef IN_LIBGCC2\n@@ -149,126 +120,42 @@ extern int avr_asm_only_p;\n #define UNITS_PER_WORD 1\n #endif\n \n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n #define POINTER_SIZE 16\n \n \n /* Maximum sized of reasonable data type\n    DImode or Dfmode ...  */\n #define MAX_FIXED_MODE_SIZE 32\n \n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY 8\n \n-/* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 8\n \n-/* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 8\n \n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 8\n \n \n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n \n-/* A C expression for the size in bits of the type `int' on the\n-     target machine.  If you don't define this, the default is one word.  */\n #define INT_TYPE_SIZE (TARGET_INT8 ? 8 : 16)\n-\n-\n-/* A C expression for the size in bits of the type `short' on the\n-   target machine.  If you don't define this, the default is half a\n-   word.  (If this would be less than one storage unit, it is rounded\n-   up to one unit.)  */\n #define SHORT_TYPE_SIZE (INT_TYPE_SIZE == 8 ? INT_TYPE_SIZE : 16)\n-\n-/* A C expression for the size in bits of the type `long' on the\n-   target machine.  If you don't define this, the default is one word.  */\n #define LONG_TYPE_SIZE (INT_TYPE_SIZE == 8 ? 16 : 32)\n-\n #define MAX_LONG_TYPE_SIZE 32\n-/* Maximum number for the size in bits of the type `long' on the\n-   target machine.  If this is undefined, the default is\n-   `LONG_TYPE_SIZE'.  Otherwise, it is the constant value that is the\n-   largest value that `LONG_TYPE_SIZE' can have at run-time.  This is\n-   used in `cpp'.  */\n-\n-\n #define LONG_LONG_TYPE_SIZE 64\n-/* A C expression for the size in bits of the type `long long' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  If you want to support GNU Ada on your machine, the value\n-   of macro must be at least 64.  */\n-\n-\n #define FLOAT_TYPE_SIZE 32\n-/* A C expression for the size in bits of the type `float' on the\n-   target machine.  If you don't define this, the default is one word.  */\n-\n #define DOUBLE_TYPE_SIZE 32\n-/* A C expression for the size in bits of the type `double' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  */\n-\n-\n #define LONG_DOUBLE_TYPE_SIZE 32\n-/* A C expression for the size in bits of the type `long double' on\n-   the target machine.  If you don't define this, the default is two\n-   words.  */\n \n #define DEFAULT_SIGNED_CHAR 1\n-/* An expression whose value is 1 or 0, according to whether the type\n-   `char' should be signed or unsigned by default.  The user can\n-   always override this default with the options `-fsigned-char' and\n-   `-funsigned-char'.  */\n-\n-/* `DEFAULT_SHORT_ENUMS'\n-   A C expression to determine whether to give an `enum' type only as\n-   many bytes as it takes to represent the range of possible values\n-   of that type.  A nonzero value means to do that; a zero value\n-   means all `enum' types should be allocated like `int'.\n-\n-   If you don't define the macro, the default is 0.  */\n \n #define SIZE_TYPE (INT_TYPE_SIZE == 8 ? \"long unsigned int\" : \"unsigned int\")\n-/* A C expression for a string describing the name of the data type\n-   to use for size values.  The typedef name `size_t' is defined\n-   using the contents of the string.\n-\n-   The string can contain more than one keyword.  If so, separate\n-   them with spaces, and write first any length keyword, then\n-   `unsigned' if appropriate, and finally `int'.  The string must\n-   exactly match one of the data type names defined in the function\n-   `init_decl_processing' in the file `c-decl.c'.  You may not omit\n-   `int' or change the order--that would cause the compiler to crash\n-   on startup.\n-\n-   If you don't define this macro, the default is `\"long unsigned\n-   int\"'.  */\n-\n #define PTRDIFF_TYPE (INT_TYPE_SIZE == 8 ? \"long int\" :\"int\")\n-/* A C expression for a string describing the name of the data type\n-   to use for the result of subtracting two pointers.  The typedef\n-   name `ptrdiff_t' is defined using the contents of the string.  See\n-   `SIZE_TYPE' above for more information.\n-\n-   If you don't define this macro, the default is `\"long int\"'.  */\n-\n \n #define WCHAR_TYPE_SIZE 16\n-/* A C expression for the size in bits of the data type for wide\n-   characters.  This is used in `cpp', which cannot make use of\n-   `WCHAR_TYPE'.  */\n \n #define FIRST_PSEUDO_REGISTER 36\n-/* Number of hardware registers known to the compiler.  They receive\n-   numbers 0 through `FIRST_PSEUDO_REGISTER-1'; thus, the first\n-   pseudo register's number really is assigned the number\n-   `FIRST_PSEUDO_REGISTER'.  */\n \n #define FIXED_REGISTERS {\\\n   1,1,/* r0 r1 */\\\n@@ -289,24 +176,6 @@ extern int avr_asm_only_p;\n   0,0,/* r30 r31 */\\\n   1,1,/*  STACK */\\\n   1,1 /* arg pointer */  }\n-/* An initializer that says which registers are used for fixed\n-   purposes all throughout the compiled code and are therefore not\n-   available for general allocation.  These would include the stack\n-   pointer, the frame pointer (except on machines where that can be\n-   used as a general register when no frame pointer is needed), the\n-   program counter on machines where that is considered one of the\n-   addressable registers, and any other numbered register with a\n-   standard use.\n-\n-   This information is expressed as a sequence of numbers, separated\n-   by commas and surrounded by braces.  The Nth number is 1 if\n-   register N is fixed, 0 otherwise.\n-\n-   The table initialized from this macro, and the table initialized by\n-   the following one, may be overridden at run time either\n-   automatically, by the actions of the macro\n-   `CONDITIONAL_REGISTER_USAGE', or by the user with the command\n-   options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.  */\n \n #define CALL_USED_REGISTERS {\t\t\t\\\n   1,1,/* r0 r1 */\t\t\t\t\\\n@@ -327,22 +196,8 @@ extern int avr_asm_only_p;\n     1,1,/* r30 r31 */\t\t\t\t\\\n     1,1,/*  STACK */\t\t\t\t\\\n     1,1 /* arg pointer */  }\n-/* Like `FIXED_REGISTERS' but has 1 for each register that is\n-   clobbered (in general) by function calls as well as for fixed\n-   registers.  This macro therefore identifies the registers that are\n-   not available for general allocation of values that must live\n-   across function calls.\n-\n-   If a register has 0 in `CALL_USED_REGISTERS', the compiler\n-   automatically saves it on function entry and restores it on\n-   function exit, if the register is used within the function.  */\n \n #define NON_SAVING_SETJMP 0\n-/* If this macro is defined and has a nonzero value, it means that\n-   `setjmp' and related functions fail to save the registers, or that\n-   `longjmp' fails to restore them.  To compensate, the compiler\n-   avoids putting variables in registers in functions that use\n-   `setjmp'.  */\n \n #define REG_ALLOC_ORDER {\t\t\t\\\n     24,25,\t\t\t\t\t\\\n@@ -356,117 +211,15 @@ extern int avr_asm_only_p;\n     0,1,\t\t\t\t\t\\\n     32,33,34,35\t\t\t\t\t\\\n     }\n-/* If defined, an initializer for a vector of integers, containing the\n-   numbers of hard registers in the order in which GCC should\n-   prefer to use them (from most preferred to least).\n-\n-   If this macro is not defined, registers are used lowest numbered\n-   first (all else being equal).\n-\n-   One use of this macro is on machines where the highest numbered\n-   registers must always be saved and the save-multiple-registers\n-   instruction supports only sequences of consecutive registers.  On\n-   such machines, define `REG_ALLOC_ORDER' to be an initializer that\n-   lists the highest numbered allocatable register first.  */\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n-/* ORDER_REGS_FOR_LOCAL_ALLOC'\n-   A C statement (sans semicolon) to choose the order in which to\n-   allocate hard registers for pseudo-registers local to a basic\n-   block.\n-\n-   Store the desired register order in the array `reg_alloc_order'.\n-   Element 0 should be the register to allocate first; element 1, the\n-   next register; and so on.\n-\n-   The macro body should not assume anything about the contents of\n-   `reg_alloc_order' before execution of the macro.\n-\n-   On most machines, it is not necessary to define this macro.  */\n \n \n #define HARD_REGNO_NREGS(REGNO, MODE) ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of mode\n-   MODE.\n-\n-   On a machine where all registers are exactly one word, a suitable\n-   definition of this macro is\n-\n-   #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-   / UNITS_PER_WORD))  */\n-\n #define HARD_REGNO_MODE_OK(REGNO, MODE) avr_hard_regno_mode_ok(REGNO, MODE)\n-/* A C expression that is nonzero if it is permissible to store a\n-   value of mode MODE in hard register number REGNO (or in several\n-   registers starting with that one).  For a machine where all\n-   registers are equivalent, a suitable definition is\n-\n-   #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-   It is not necessary for this macro to check for the numbers of\n-   fixed registers, because the allocation mechanism considers them\n-   to be always occupied.\n-\n-   On some machines, double-precision values must be kept in even/odd\n-   register pairs.  The way to implement that is to define this macro\n-   to reject odd register numbers for such modes.\n-\n-   The minimum requirement for a mode to be OK in a register is that\n-   the `movMODE' instruction pattern support moves between the\n-   register and any other hard register for which the mode is OK; and\n-   that moving a value into the register and back out not alter it.\n-\n-   Since the same instruction used to move `SImode' will work for all\n-   narrower integer modes, it is not necessary on any machine for\n-   `HARD_REGNO_MODE_OK' to distinguish between these modes, provided\n-   you define patterns `movhi', etc., to take advantage of this.  This\n-   is useful because of the interaction between `HARD_REGNO_MODE_OK'\n-   and `MODES_TIEABLE_P'; it is very desirable for all integer modes\n-   to be tieable.\n-\n-   Many machines have special registers for floating point arithmetic.\n-   Often people assume that floating point machine modes are allowed\n-   only in floating point registers.  This is not true.  Any\n-   registers that can hold integers can safely *hold* a floating\n-   point machine mode, whether or not floating arithmetic can be done\n-   on it in those registers.  Integer move instructions can be used\n-   to move the values.\n-\n-   On some machines, though, the converse is true: fixed-point machine\n-   modes may not go in floating registers.  This is true if the\n-   floating registers normalize any value stored in them, because\n-   storing a non-floating value there would garble it.  In this case,\n-   `HARD_REGNO_MODE_OK' should reject fixed-point machine modes in\n-   floating registers.  But if the floating registers do not\n-   automatically normalize, if you can store any bit pattern in one\n-   and retrieve it unchanged without a trap, then any machine mode\n-   may go in a floating register, so you can define this macro to say\n-   so.\n-\n-   The primary significance of special floating registers is rather\n-   that they are the registers acceptable in floating point arithmetic\n-   instructions.  However, this is of no concern to\n-   `HARD_REGNO_MODE_OK'.  You handle it by writing the proper\n-   constraints for those instructions.\n-\n-   On some machines, the floating registers are especially slow to\n-   access, so that it is better to store a value in a stack frame\n-   than in such a register if floating point arithmetic is not being\n-   done.  As long as the floating registers are not in class\n-   `GENERAL_REGS', they will not be used unless some pattern's\n-   constraint asks for one.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2) 0\n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n \n enum reg_class {\n   NO_REGS,\n@@ -484,21 +237,9 @@ enum reg_class {\n   GENERAL_REGS,\t\t\t/* r0 - r31 */\n   ALL_REGS, LIM_REG_CLASSES\n };\n-/* An enumeral type that must be defined with all the register class\n-   names as enumeral values.  `NO_REGS' must be first.  `ALL_REGS'\n-   must be the last register class, followed by one more enumeral\n-   value, `LIM_REG_CLASSES', which is not a register class but rather\n-   tells how many classes there are.\n-\n-   Each register class has a number, which is the value of casting\n-   the class name to type `int'.  The number serves as an index in\n-   many of the tables described below.  */\n \n \n #define N_REG_CLASSES (int)LIM_REG_CLASSES\n-/* The number of distinct register classes, defined as follows:\n-\n-   #define N_REG_CLASSES (int) LIM_REG_CLASSES  */\n \n #define REG_CLASS_NAMES {\t\t\t\t\t\\\n \t\t \"NO_REGS\",\t\t\t\t\t\\\n@@ -515,9 +256,6 @@ enum reg_class {\n                    \"NO_LD_REGS\", /* r0 - r15 */                 \\\n \t\t   \"GENERAL_REGS\", /* r0 - r31 */\t\t\\\n \t\t   \"ALL_REGS\" }\n-/* An initializer containing the names of the register classes as C\n-   string constants.  These names are used in writing some of the\n-   debugging dumps.  */\n \n #define REG_X 26\n #define REG_Y 28\n@@ -544,41 +282,14 @@ enum reg_class {\n   {0xffffffff,0x00000000},\t/* GENERAL_REGS, r0 - r31 */\t\t\\\n   {0xffffffff,0x00000003}\t/* ALL_REGS */\t\t\t\t\\\n }\n-/* An initializer containing the contents of the register classes, as\n-   integers which are bit masks.  The Nth integer specifies the\n-   contents of class N.  The way the integer MASK is interpreted is\n-   that register R is in the class if `MASK & (1 << R)' is 1.\n-\n-   When the machine has more than 32 registers, an integer does not\n-   suffice.  Then the integers are replaced by sub-initializers,\n-   braced groupings containing several integers.  Each\n-   sub-initializer must be suitable as an initializer for the type\n-   `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */\n \n #define REGNO_REG_CLASS(R) avr_regno_reg_class(R)\n-/* A C expression whose value is a register class containing hard\n-   register REGNO.  In general there is more than one such class;\n-   choose a class which is \"minimal\", meaning that no smaller class\n-   also contains the register.  */\n \n #define BASE_REG_CLASS (reload_completed ? BASE_POINTER_REGS : POINTER_REGS)\n-/* A macro whose definition is the name of the class to which a valid\n-   base register must belong.  A base register is one used in an\n-   address which is the register value plus a displacement.  */\n \n #define INDEX_REG_CLASS NO_REGS\n-/* A macro whose definition is the name of the class to which a valid\n-   index register must belong.  An index register is one used in an\n-   address where its value is either multiplied by a scale factor or\n-   added to another register (as well as added to a displacement).  */\n \n #define REG_CLASS_FROM_LETTER(C) avr_reg_class_from_letter(C)\n-/* A C expression which defines the machine-dependent operand\n-   constraint letters for register classes.  If CHAR is such a\n-   letter, the value should be the register class corresponding to\n-   it.  Otherwise, the value should be `NO_REGS'.  The register\n-   letter `r', corresponding to class `GENERAL_REGS', will not be\n-   passed to this macro; you do not need to handle it.  */\n \n #define REGNO_OK_FOR_BASE_P(r) (((r) < FIRST_PSEUDO_REGISTER\t\t\\\n \t\t\t\t && ((r) == REG_X\t\t\t\\\n@@ -591,206 +302,16 @@ enum reg_class {\n \t\t\t\t\t|| reg_renumber[r] == REG_Z\t\\\n \t\t\t\t\t|| (reg_renumber[r]\t\t\\\n \t\t\t\t\t    == ARG_POINTER_REGNUM))))\n-/* A C expression which is nonzero if register number NUM is suitable\n-   for use as a base register in operand addresses.  It may be either\n-   a suitable hard register or a pseudo register that has been\n-   allocated such a hard register.  */\n-\n-/* #define REGNO_MODE_OK_FOR_BASE_P(r, m) regno_mode_ok_for_base_p(r, m)\n-   A C expression that is just like `REGNO_OK_FOR_BASE_P', except that\n-   that expression may examine the mode of the memory reference in\n-   MODE.  You should define this macro if the mode of the memory\n-   reference affects whether a register may be used as a base\n-   register.  If you define this macro, the compiler will use it\n-   instead of `REGNO_OK_FOR_BASE_P'.  */\n \n #define REGNO_OK_FOR_INDEX_P(NUM) 0\n-/* A C expression which is nonzero if register number NUM is suitable\n-   for use as an index register in operand addresses.  It may be\n-   either a suitable hard register or a pseudo register that has been\n-   allocated such a hard register.\n-\n-   The difference between an index register and a base register is\n-   that the index register may be scaled.  If an address involves the\n-   sum of two registers, neither one of them scaled, then either one\n-   may be labeled the \"base\" and the other the \"index\"; but whichever\n-   labeling is used must fit the machine's constraints of which\n-   registers may serve in each capacity.  The compiler will try both\n-   labelings, looking for one that is valid, and will reload one or\n-   both registers only if neither labeling works.  */\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) preferred_reload_class(X,CLASS)\n-/* A C expression that places additional restrictions on the register\n-   class to use when it is necessary to copy value X into a register\n-   in class CLASS.  The value is a register class; perhaps CLASS, or\n-   perhaps another, smaller class.  On many machines, the following\n-   definition is safe:\n-\n-   #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n-\n-   Sometimes returning a more restrictive class makes better code.\n-   For example, on the 68000, when X is an integer constant that is\n-   in range for a `moveq' instruction, the value of this macro is\n-   always `DATA_REGS' as long as CLASS includes the data registers.\n-   Requiring a data register guarantees that a `moveq' will be used.\n-\n-   If X is a `const_double', by returning `NO_REGS' you can force X\n-   into a memory constant.  This is useful on certain machines where\n-   immediate floating values cannot be loaded into certain kinds of\n-   registers.  */\n-/* `PREFERRED_OUTPUT_RELOAD_CLASS (X, CLASS)'\n-   Like `PREFERRED_RELOAD_CLASS', but for output reloads instead of\n-   input reloads.  If you don't define this macro, the default is to\n-   use CLASS, unchanged.  */\n-\n-/* `LIMIT_RELOAD_CLASS (MODE, CLASS)'\n-   A C expression that places additional restrictions on the register\n-   class to use when it is necessary to be able to hold a value of\n-   mode MODE in a reload register for which class CLASS would\n-   ordinarily be used.\n-\n-   Unlike `PREFERRED_RELOAD_CLASS', this macro should be used when\n-   there are certain modes that simply can't go in certain reload\n-   classes.\n-\n-   The value is a register class; perhaps CLASS, or perhaps another,\n-   smaller class.\n-\n-   Don't define this macro unless the target machine has limitations\n-   which require the macro to do something nontrivial.  */\n-\n-/* SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\n-   `SECONDARY_RELOAD_CLASS (CLASS, MODE, X)'\n-   `SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X)'\n-   Many machines have some registers that cannot be copied directly\n-   to or from memory or even from other types of registers.  An\n-   example is the `MQ' register, which on most machines, can only be\n-   copied to or from general registers, but not memory.  Some\n-   machines allow copying all registers to and from memory, but\n-   require a scratch register for stores to some memory locations\n-   (e.g., those with symbolic address on the RT, and those with\n-   certain symbolic address on the SPARC when compiling PIC).  In\n-   some cases, both an intermediate and a scratch register are\n-   required.\n-\n-   You should define these macros to indicate to the reload phase\n-   that it may need to allocate at least one register for a reload in\n-   addition to the register to contain the data.  Specifically, if\n-   copying X to a register CLASS in MODE requires an intermediate\n-   register, you should define `SECONDARY_INPUT_RELOAD_CLASS' to\n-   return the largest register class all of whose registers can be\n-   used as intermediate registers or scratch registers.\n-\n-   If copying a register CLASS in MODE to X requires an intermediate\n-   or scratch register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be\n-   defined to return the largest register class required.  If the\n-   requirements for input and output reloads are the same, the macro\n-   `SECONDARY_RELOAD_CLASS' should be used instead of defining both\n-   macros identically.\n-\n-   The values returned by these macros are often `GENERAL_REGS'.\n-   Return `NO_REGS' if no spare register is needed; i.e., if X can be\n-   directly copied to or from a register of CLASS in MODE without\n-   requiring a scratch register.  Do not define this macro if it\n-   would always return `NO_REGS'.\n-\n-   If a scratch register is required (either with or without an\n-   intermediate register), you should define patterns for\n-   `reload_inM' or `reload_outM', as required (*note Standard\n-   Names::..  These patterns, which will normally be implemented with\n-   a `define_expand', should be similar to the `movM' patterns,\n-   except that operand 2 is the scratch register.\n-\n-   Define constraints for the reload register and scratch register\n-   that contain a single register class.  If the original reload\n-   register (whose class is CLASS) can meet the constraint given in\n-   the pattern, the value returned by these macros is used for the\n-   class of the scratch register.  Otherwise, two additional reload\n-   registers are required.  Their classes are obtained from the\n-   constraints in the insn pattern.\n-\n-   X might be a pseudo-register or a `subreg' of a pseudo-register,\n-   which could either be in a hard register or in memory.  Use\n-   `true_regnum' to find out; it will return -1 if the pseudo is in\n-   memory and the hard register number if it is in a register.\n-\n-   These macros should not be used in the case where a particular\n-   class of registers can only be copied to memory and not to another\n-   class of registers.  In that case, secondary reload registers are\n-   not needed and would not be helpful.  Instead, a stack location\n-   must be used to perform the copy and the `movM' pattern should use\n-   memory as an intermediate storage.  This case often occurs between\n-   floating-point and general registers.  */\n-\n-/* `SECONDARY_MEMORY_NEEDED (CLASS1, CLASS2, M)'\n-   Certain machines have the property that some registers cannot be\n-   copied to some other registers without using memory.  Define this\n-   macro on those machines to be a C expression that is nonzero if\n-   objects of mode M in registers of CLASS1 can only be copied to\n-   registers of class CLASS2 by storing a register of CLASS1 into\n-   memory and loading that memory location into a register of CLASS2.\n-\n-   Do not define this macro if its value would always be zero.\n-\n-   `SECONDARY_MEMORY_NEEDED_RTX (MODE)'\n-   Normally when `SECONDARY_MEMORY_NEEDED' is defined, the compiler\n-   allocates a stack slot for a memory location needed for register\n-   copies.  If this macro is defined, the compiler instead uses the\n-   memory location defined by this macro.\n-\n-   Do not define this macro if you do not define\n-   `SECONDARY_MEMORY_NEEDED'.  */\n \n #define SMALL_REGISTER_CLASSES 1\n-/* Normally the compiler avoids choosing registers that have been\n-   explicitly mentioned in the rtl as spill registers (these\n-   registers are normally those used to pass parameters and return\n-   values).  However, some machines have so few registers of certain\n-   classes that there would not be enough registers to use as spill\n-   registers if this were done.\n-\n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero\n-   value on these machines.  When this macro has a nonzero value, the\n-   compiler allows registers explicitly used in the rtl to be used as\n-   spill registers but avoids extending the lifetime of these\n-   registers.\n-\n-   It is always safe to define this macro with a nonzero value, but\n-   if you unnecessarily define it, you will reduce the amount of\n-   optimizations that can be performed in some cases.  If you do not\n-   define this macro with a nonzero value when it is required, the\n-   compiler will run out of spill registers and print a fatal error\n-   message.  For most machines, you should not define this macro at\n-   all.  */\n \n #define CLASS_LIKELY_SPILLED_P(c) class_likely_spilled_p(c)\n-/* A C expression whose value is nonzero if pseudos that have been\n-   assigned to registers of class CLASS would likely be spilled\n-   because registers of CLASS are needed for spill registers.\n-\n-   The default value of this macro returns 1 if CLASS has exactly one\n-   register and zero otherwise.  On most machines, this default\n-   should be used.  Only define this macro to some other expression\n-   if pseudo allocated by `local-alloc.c' end up in memory because\n-   their hard registers were needed for spill registers.  If this\n-   macro returns nonzero for those classes, those pseudos will only\n-   be allocated by `global.c', which knows how to reallocate the\n-   pseudo to another register.  If there would not be another\n-   register available for reallocation, you should not change the\n-   definition of this macro since the only effect of such a\n-   definition would be to slow down register allocation.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE)   class_max_nregs (CLASS, MODE)\n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact,\n-   the value of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be\n-   the maximum value of `HARD_REGNO_NREGS (REGNO, MODE)' for all\n-   REGNO values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n   ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 63 :\t\t\t\\\n@@ -803,476 +324,90 @@ enum reg_class {\n    (C) == 'P' ? (VALUE) == 1 :\t\t\t\t\t\\\n    0)\n \n-/* A C expression that defines the machine-dependent operand\n-   constraint letters (`I', `J', `K', ... `P') that specify\n-   particular ranges of integer values.  If C is one of those\n-   letters, the expression should check that VALUE, an integer, is in\n-   the appropriate range and return 1 if so, 0 otherwise.  If C is\n-   not one of those letters, the value should be 0 regardless of\n-   VALUE.  */\n-\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n   ((C) == 'G' ? (VALUE) == CONST0_RTX (SFmode)\t\\\n    : 0)\n-/* `CONST_DOUBLE_OK_FOR_LETTER_P (VALUE, C)'\n-   A C expression that defines the machine-dependent operand\n-   constraint letters that specify particular ranges of\n-   `const_double' values (`G' or `H').\n-\n-   If C is one of those letters, the expression should check that\n-   VALUE, an RTX of code `const_double', is in the appropriate range\n-   and return 1 if so, 0 otherwise.  If C is not one of those\n-   letters, the value should be 0 regardless of VALUE.\n-\n-   `const_double' is used for all floating-point constants and for\n-   `DImode' fixed-point constants.  A given letter can accept either\n-   or both kinds of values.  It can use `GET_MODE' to distinguish\n-   between these kinds.  */\n \n #define EXTRA_CONSTRAINT(x, c) extra_constraint(x, c)\n-/* A C expression that defines the optional machine-dependent\n-   constraint letters (``Q', `R', `S', `T', `U') that can'\n-   be used to segregate specific types of operands, usually memory\n-   references, for the target machine.  Normally this macro will not\n-   be defined.  If it is required for a particular target machine, it\n-   should return 1 if VALUE corresponds to the operand type\n-   represented by the constraint letter C.  If C is not defined as an\n-   extra constraint, the value returned should be 0 regardless of\n-   VALUE.\n-\n-   For example, on the ROMP, load instructions cannot have their\n-   output in r0 if the memory reference contains a symbolic address.\n-   Constraint letter `Q' is defined as representing a memory address\n-   that does *not* contain a symbolic address.  An alternative is\n-   specified with a `Q' constraint on the input and `r' on the\n-   output.  The next alternative specifies `m' on the input and a\n-   register class that does not include r0 on the output.  */\n-\n-/*  This is an undocumented variable which describes\n-    how GCC will push a data */\n+\n #define STACK_PUSH_CODE POST_DEC\n \n #define STACK_GROWS_DOWNWARD\n-/* Define this macro if pushing a word onto the stack moves the stack\n-   pointer to a smaller address.\n-\n-   When we say, \"define this macro if ...,\" it means that the\n-   compiler checks this macro only with `#ifdef' so the precise\n-   definition used does not matter.  */\n \n #define STARTING_FRAME_OFFSET 1\n-/* Offset from the frame pointer to the first local variable slot to\n-   be allocated.\n-\n-   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by\n-   subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n-   Otherwise, it is found by adding the length of the first slot to\n-   the value `STARTING_FRAME_OFFSET'.  */\n \n #define STACK_POINTER_OFFSET 1\n-/* Offset from the stack pointer register to the first location at\n-   which outgoing arguments are placed.  If not specified, the\n-   default value of zero is used.  This is the proper value for most\n-   machines.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above\n-   the first location at which outgoing arguments are placed.  */\n \n #define FIRST_PARM_OFFSET(FUNDECL) 0\n-/* Offset from the argument pointer register to the first argument's\n-   address.  On some machines it may depend on the data type of the\n-   function.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above\n-   the first argument's address.  */\n-\n-/* `STACK_DYNAMIC_OFFSET (FUNDECL)'\n-   Offset from the stack pointer register to an item dynamically\n-   allocated on the stack, e.g., by `alloca'.\n-\n-   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n-   length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.  */\n \n #define STACK_BOUNDARY 8\n-/* Define this macro if there is a guaranteed alignment for the stack\n-   pointer on this machine.  The definition is a C expression for the\n-   desired alignment (measured in bits).  This value is used as a\n-   default if PREFERRED_STACK_BOUNDARY is not defined.  */\n \n #define STACK_POINTER_REGNUM 32\n-/* The register number of the stack pointer register, which must also\n-   be a fixed register according to `FIXED_REGISTERS'.  On most\n-   machines, the hardware determines which register this is.  */\n \n #define FRAME_POINTER_REGNUM REG_Y\n-/* The register number of the frame pointer register, which is used to\n-   access automatic variables in the stack frame.  On some machines,\n-   the hardware determines which register this is.  On other\n-   machines, you can choose any register you wish for this purpose.  */\n \n #define ARG_POINTER_REGNUM 34\n-/* The register number of the arg pointer register, which is used to\n-   access the function's argument list.  On some machines, this is\n-   the same as the frame pointer register.  On some machines, the\n-   hardware determines which register this is.  On other machines,\n-   you can choose any register you wish for this purpose.  If this is\n-   not the same register as the frame pointer register, then you must\n-   mark it as a fixed register according to `FIXED_REGISTERS', or\n-   arrange to be able to eliminate it (*note Elimination::.).  */\n \n #define STATIC_CHAIN_REGNUM 2\n-/* Register numbers used for passing a function's static chain\n-   pointer.  If register windows are used, the register number as\n-   seen by the called function is `STATIC_CHAIN_INCOMING_REGNUM',\n-   while the register number as seen by the calling function is\n-   `STATIC_CHAIN_REGNUM'.  If these registers are the same,\n-   `STATIC_CHAIN_INCOMING_REGNUM' need not be defined.\n-\n-   The static chain register need not be a fixed register.\n-\n-   If the static chain is passed in memory, these macros should not be\n-   defined; instead, the next two macros should be defined.  */\n \n #define FRAME_POINTER_REQUIRED frame_pointer_required_p()\n-/* A C expression which is nonzero if a function must have and use a\n-   frame pointer.  This expression is evaluated  in the reload pass.\n-   If its value is nonzero the function will have a frame pointer.\n-\n-   The expression can in principle examine the current function and\n-   decide according to the facts, but on most machines the constant 0\n-   or the constant 1 suffices.  Use 0 when the machine allows code to\n-   be generated with no frame pointer, and doing so saves some time\n-   or space.  Use 1 when there is no possible advantage to avoiding a\n-   frame pointer.\n-\n-   In certain cases, the compiler does not know how to produce valid\n-   code without a frame pointer.  The compiler recognizes those cases\n-   and automatically gives the function a frame pointer regardless of\n-   what `FRAME_POINTER_REQUIRED' says.  You don't need to worry about\n-   them.\n-\n-   In a function that does not require a frame pointer, the frame\n-   pointer register can be allocated for ordinary usage, unless you\n-   mark it as a fixed register.  See `FIXED_REGISTERS' for more\n-   information.  */\n \n #define ELIMINABLE_REGS {\t\t\t\t\t\\\n       {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n \t{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\\\n        ,{FRAME_POINTER_REGNUM+1,STACK_POINTER_REGNUM+1}}\n-/* If defined, this macro specifies a table of register pairs used to\n-   eliminate unneeded registers that point into the stack frame.  If\n-   it is not defined, the only elimination attempted by the compiler\n-   is to replace references to the frame pointer with references to\n-   the stack pointer.\n-\n-   The definition of this macro is a list of structure\n-   initializations, each of which specifies an original and\n-   replacement register.\n-\n-   On some machines, the position of the argument pointer is not\n-   known until the compilation is completed.  In such a case, a\n-   separate hard register must be used for the argument pointer.\n-   This register can be eliminated by replacing it with either the\n-   frame pointer or the argument pointer, depending on whether or not\n-   the frame pointer has been eliminated.\n-\n-   In this case, you might specify:\n-   #define ELIMINABLE_REGS  \\\n-   {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n-   {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n-   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-   Note that the elimination of the argument pointer with the stack\n-   pointer is specified first since that is the preferred elimination.  */\n \n #define CAN_ELIMINATE(FROM, TO) (((FROM) == ARG_POINTER_REGNUM\t\t   \\\n \t\t\t\t  && (TO) == FRAME_POINTER_REGNUM)\t   \\\n \t\t\t\t || (((FROM) == FRAME_POINTER_REGNUM\t   \\\n \t\t\t\t      || (FROM) == FRAME_POINTER_REGNUM+1) \\\n \t\t\t\t     && ! FRAME_POINTER_REQUIRED\t   \\\n \t\t\t\t     ))\n-/* A C expression that returns nonzero if the compiler is allowed to\n-   try to replace register number FROM-REG with register number\n-   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n-   defined, and will usually be the constant 1, since most of the\n-   cases preventing register elimination are things that the compiler\n-   already knows about.  */\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n      OFFSET = initial_elimination_offset (FROM, TO)\n-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n-   specifies the initial difference between the specified pair of\n-   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n-   defined.  */\n \n #define RETURN_ADDR_RTX(count, x) \\\n   gen_rtx_MEM (Pmode, memory_address (Pmode, plus_constant (tem, 1)))\n \n #define PUSH_ROUNDING(NPUSHED) (NPUSHED)\n-/* A C expression that is the number of bytes actually pushed onto the\n-   stack when an instruction attempts to push NPUSHED bytes.\n-\n-   If the target machine does not have a push instruction, do not\n-   define this macro.  That directs GCC to use an alternate\n-   strategy: to allocate the entire argument block and then store the\n-   arguments into it.\n-\n-   On some machines, the definition\n-\n-   #define PUSH_ROUNDING(BYTES) (BYTES)\n-\n-   will suffice.  But on other machines, instructions that appear to\n-   push one byte actually push two bytes in an attempt to maintain\n-   alignment.  Then the definition should be\n-\n-   #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)  */\n \n #define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n-/* A C expression that should indicate the number of bytes of its own\n-   arguments that a function pops on returning, or 0 if the function\n-   pops no arguments and the caller must therefore pop them all after\n-   the function returns.\n-\n-   FUNDECL is a C variable whose value is a tree node that describes\n-   the function in question.  Normally it is a node of type\n-   `FUNCTION_DECL' that describes the declaration of the function.\n-   From this you can obtain the DECL_ATTRIBUTES of the\n-   function.\n-\n-   FUNTYPE is a C variable whose value is a tree node that describes\n-   the function in question.  Normally it is a node of type\n-   `FUNCTION_TYPE' that describes the data type of the function.\n-   From this it is possible to obtain the data types of the value and\n-   arguments (if known).\n-\n-   When a call to a library function is being considered, FUNDECL\n-   will contain an identifier node for the library function.  Thus, if\n-   you need to distinguish among various library functions, you can\n-   do so by their names.  Note that \"library function\" in this\n-   context means a function used to perform arithmetic, whose name is\n-   known specially in the compiler and was not mentioned in the C\n-   code being compiled.\n-\n-   STACK-SIZE is the number of bytes of arguments passed on the\n-   stack.  If a variable number of bytes is passed, it is zero, and\n-   argument popping will always be the responsibility of the calling\n-   function.\n-\n-   On the VAX, all functions always pop their arguments, so the\n-   definition of this macro is STACK-SIZE.  On the 68000, using the\n-   standard calling convention, no functions pop their arguments, so\n-   the value of the macro is always 0 in this case.  But an\n-   alternative calling convention is available in which functions\n-   that take a fixed number of arguments pop them but other functions\n-   (such as `printf') pop nothing (the caller pops all).  When this\n-   convention is in use, FUNTYPE is examined to determine whether a\n-   function takes a fixed number of arguments.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) (function_arg (&(CUM), MODE, TYPE, NAMED))\n-/* A C expression that controls whether a function argument is passed\n-   in a register, and which register.\n-\n-   The arguments are CUM, which summarizes all the previous\n-   arguments; MODE, the machine mode of the argument; TYPE, the data\n-   type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED, which\n-   is 1 for an ordinary argument and 0 for nameless arguments that\n-   correspond to `...' in the called function's prototype.\n-\n-   The value of the expression is usually either a `reg' RTX for the\n-   hard register in which to pass the argument, or zero to pass the\n-   argument on the stack.\n-\n-   For machines like the VAX and 68000, where normally all arguments\n-   are pushed, zero suffices as a definition.\n-\n-   The value of the expression can also be a `parallel' RTX.  This is\n-   used when an argument is passed in multiple locations.  The mode\n-   of the of the `parallel' should be the mode of the entire\n-   argument.  The `parallel' holds any number of `expr_list' pairs;\n-   each one describes where part of the argument is passed.  In each\n-   `expr_list', the first operand can be either a `reg' RTX for the\n-   hard register in which to pass this part of the argument, or zero\n-   to pass the argument on the stack.  If this operand is a `reg',\n-   then the mode indicates how large this part of the argument is.\n-   The second operand of the `expr_list' is a `const_int' which gives\n-   the offset in bytes into the entire argument where this part\n-   starts.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine\n-   where some arguments are usually passed in registers, is to cause\n-   nameless arguments to be passed on the stack instead.  This is done\n-   by making `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the\n-   definition of this macro to determine if this argument is of a\n-   type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'\n-   is not defined and `FUNCTION_ARG' returns nonzero for such an\n-   argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is\n-   defined, the argument will be computed in the stack and then\n-   loaded into a register.  */\n \n typedef struct avr_args {\n   int nregs;\t\t\t/* # registers available for passing */\n   int regno;\t\t\t/* next available register number */\n } CUMULATIVE_ARGS;\n-/* A C type for declaring a variable that is used as the first\n-   argument of `FUNCTION_ARG' and other related values.  For some\n-   target machines, the type `int' suffices and can hold the number\n-   of bytes of argument so far.\n-\n-   There is no need to record in `CUMULATIVE_ARGS' anything about the\n-   arguments that have been passed on the stack.  The compiler has\n-   other variables to keep track of that.  For target machines on\n-   which all arguments are passed on the stack, there is no need to\n-   store anything in `CUMULATIVE_ARGS'; however, the data structure\n-   must exist and should not be empty, so use `int'.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL) init_cumulative_args (&(CUM), FNTYPE, LIBNAME, FNDECL)\n \n-/* A C statement (sans semicolon) for initializing the variable CUM\n-   for the state at the beginning of the argument list.  The variable\n-   has type `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node\n-   for the data type of the function which will receive the args, or 0\n-   if the args are to a compiler support library function.  The value\n-   of INDIRECT is nonzero when processing an indirect call, for\n-   example a call through a function pointer.  The value of INDIRECT\n-   is zero for a call to an explicitly named function, a library\n-   function call, or when `INIT_CUMULATIVE_ARGS' is used to find\n-   arguments for the function being compiled.\n-\n-   When processing a call to a compiler support library function,\n-   LIBNAME identifies which one.  It is a `symbol_ref' rtx which\n-   contains the name of the function, as a string.  LIBNAME is 0 when\n-   an ordinary C function call is being processed.  Thus, each time\n-   this macro is called, either LIBNAME or FNTYPE is nonzero, but\n-   never both of them at once.  */\n-\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n   (function_arg_advance (&CUM, MODE, TYPE, NAMED))\n \n-/* A C statement (sans semicolon) to update the summarizer variable\n-   CUM to advance past an argument in the argument list.  The values\n-   MODE, TYPE and NAMED describe that argument.  Once this is done,\n-   the variable CUM is suitable for analyzing the *following*\n-   argument with `FUNCTION_ARG', etc.\n-\n-   This macro need not do anything if the argument in question was\n-   passed on the stack.  The compiler knows how to track the amount\n-   of stack space used for arguments without any special help.  */\n-\n #define FUNCTION_ARG_REGNO_P(r) function_arg_regno_p(r)\n-/* A C expression that is nonzero if REGNO is the number of a hard\n-   register in which function arguments are sometimes passed.  This\n-   does *not* include implicit arguments such as the static chain and\n-   the structure-value address.  On many machines, no registers can be\n-   used for this purpose since all function arguments are pushed on\n-   the stack.  */\n \n extern int avr_reg_order[];\n \n #define RET_REGISTER avr_ret_register ()\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) avr_function_value (VALTYPE, FUNC)\n-/* A C expression to create an RTX representing the place where a\n-   function returns a value of data type VALTYPE.  VALTYPE is a tree\n-   node representing a data type.  Write `TYPE_MODE (VALTYPE)' to get\n-   the machine mode used to represent that type.  On many machines,\n-   only the mode is relevant.  (Actually, on most machines, scalar\n-   values are returned in the same place regardless of mode).\n-\n-   The value of the expression is usually a `reg' RTX for the hard\n-   register where the return value is stored.  The value can also be a\n-   `parallel' RTX, if the return value is in multiple places.  See\n-   `FUNCTION_ARG' for an explanation of the `parallel' form.\n-\n-   If `TARGET_PROMOTE_FUNCTION_RETURN' is defined to return true, you\n-   must apply the same promotion rules specified in `PROMOTE_MODE' if\n-   VALTYPE is a scalar type.\n-\n-   If the precise function being called is known, FUNC is a tree node\n-   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This\n-   makes it possible to use a different value-returning convention\n-   for specific functions when all their calls are known.\n-\n-   `FUNCTION_VALUE' is not used for return vales with aggregate data\n-   types, because these are returned in another way.  See\n-   `STRUCT_VALUE_REGNUM' and related macros, below.  */\n \n #define LIBCALL_VALUE(MODE)  avr_libcall_value (MODE)\n-/* A C expression to create an RTX representing the place where a\n-   library function returns a value of mode MODE.  If the precise\n-   function being called is known, FUNC is a tree node\n-   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This\n-   makes it possible to use a different value-returning convention\n-   for specific functions when all their calls are known.\n-\n-   Note that \"library function\" in this context means a compiler\n-   support routine, used to perform arithmetic, whose name is known\n-   specially by the compiler and was not mentioned in the C code being\n-   compiled.\n-\n-   The definition of `LIBRARY_VALUE' need not be concerned aggregate\n-   data types, because none of the library functions returns such\n-   types.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) ((int) (N) == RET_REGISTER)\n-/* A C expression that is nonzero if REGNO is the number of a hard\n-   register in which the values of called function may come back.\n-\n-   A register whose use for returning values is limited to serving as\n-   the second of a pair (for a value of type `double', say) need not\n-   be recognized by this macro.  So for most machines, this definition\n-   suffices:\n-\n-   #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-   If the machine has register windows, so that the caller and the\n-   called function use different registers for the return value, this\n-   macro should recognize only the caller's register numbers.  */\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n-/* Define this macro to be 1 if all structure and union return values\n-   must be in memory.  Since this results in slower code, this should\n-   be defined only if needed for compatibility with other compilers\n-   or with an ABI.  If you define this macro to be 0, then the\n-   conventions used for structure and union return values are decided\n-   by the `RETURN_IN_MEMORY' macro.\n-\n-   If not defined, this defaults to the value 1.  */\n \n #define EPILOGUE_USES(REGNO) 0\n-/* Define this macro as a C expression that is nonzero for registers\n-   are used by the epilogue or the `return' pattern.  The stack and\n-   frame pointer registers are already be assumed to be used as\n-   needed.  */\n-\n \n #define HAVE_POST_INCREMENT 1\n-/* Define this macro if the machine supports post-increment\n-   addressing.  */\n-\n #define HAVE_PRE_DECREMENT 1\n-/* Similar for other kinds of addressing.  */\n \n #define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n-/* A C expression that is 1 if the RTX X is a constant which is a\n-   valid address.  On most machines, this can be defined as\n-   `CONSTANT_P (X)', but a few machines are more restrictive in which\n-   constant addresses are supported.\n-\n-   `CONSTANT_P' accepts integer-values expressions whose values are\n-   not explicitly known, such as `symbol_ref', `label_ref', and\n-   `high' expressions and `const' arithmetic expressions, in addition\n-   to `const_int' and `const_double' expressions.  */\n \n #define MAX_REGS_PER_ADDRESS 1\n-/* A number, the maximum number of registers that can appear in a\n-   valid memory address.  Note that it is up to you to specify a\n-   value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'\n-   would ever accept.  */\n \n #ifdef REG_OK_STRICT\n #  define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR)\t\\\n@@ -1287,18 +422,6 @@ extern int avr_reg_order[];\n     goto ADDR;\t\t\t\t\t\t\\\n }\n #endif\n-/* A C compound statement with a conditional `goto LABEL;' executed\n-   if X (an RTX) is a legitimate memory address on the target machine\n-   for a memory operand of mode MODE.  */\n-\n-/* `REG_OK_FOR_BASE_P (X)'\n-   A C expression that is nonzero if X (assumed to be a `reg' RTX) is\n-   valid for use as a base register.  For hard registers, it should\n-   always accept those which the hardware permits and reject the\n-   others.  Whether the macro accepts or rejects pseudo registers\n-   must be controlled by `REG_OK_STRICT' as described above.  This\n-   usually requires two variant definitions, of which `REG_OK_STRICT'\n-   controls the one actually used.  */\n \n #define REG_OK_FOR_BASE_NOSTRICT_P(X) \\\n   (REGNO (X) >= FIRST_PSEUDO_REGISTER || REG_OK_FOR_BASE_STRICT_P(X))\n@@ -1311,51 +434,14 @@ extern int avr_reg_order[];\n #  define REG_OK_FOR_BASE_P(X) REG_OK_FOR_BASE_NOSTRICT_P (X)\n #endif\n \n-/* A C expression that is just like `REG_OK_FOR_BASE_P', except that\n-   that expression may examine the mode of the memory reference in\n-   MODE.  You should define this macro if the mode of the memory\n-   reference affects whether a register may be used as a base\n-   register.  If you define this macro, the compiler will use it\n-   instead of `REG_OK_FOR_BASE_P'.  */\n #define REG_OK_FOR_INDEX_P(X) 0\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is\n-   valid for use as an index register.\n-\n-   The difference between an index register and a base register is\n-   that the index register may be scaled.  If an address involves the\n-   sum of two registers, neither one of them scaled, then either one\n-   may be labeled the \"base\" and the other the \"index\"; but whichever\n-   labeling is used must fit the machine's constraints of which\n-   registers may serve in each capacity.  The compiler will try both\n-   labelings, looking for one that is valid, and will reload one or\n-   both registers only if neither labeling works.  */\n \n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   (X) = legitimize_address (X, OLDX, MODE);\t\t\t\t\\\n   if (memory_address_p (MODE, X))\t\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n }\n-/* A C compound statement that attempts to replace X with a valid\n-   memory address for an operand of mode MODE.  WIN will be a C\n-   statement label elsewhere in the code; the macro definition may use\n-\n-   GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n-\n-   to avoid further processing if the address has become legitimate.\n-\n-   X will always be the result of a call to `break_out_memory_refs',\n-   and OLDX will be the operand that was given to that function to\n-   produce X.\n-\n-   The code generated by this macro should not alter the substructure\n-   of X.  If it transforms X into a more legitimate form, it should\n-   assign X (which will always be a C variable) a new value.\n-\n-   It is not necessary for this macro to come up with a legitimate\n-   address.  The compiler has standard ways of doing so in all cases.\n-   In fact, it is safe for this macro to do nothing.  But often a\n-   machine-dependent strategy can generate better code.  */\n \n #define XEXP_(X,Y) (X)\n #define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)    \\\n@@ -1401,177 +487,35 @@ do {\t\t\t\t\t\t\t\t\t    \\\n \t}\t\t\t\t\t\t\t\t    \\\n     }\t\t\t\t\t\t\t\t\t    \\\n } while(0)\n-/* A C compound statement that attempts to replace X, which is an\n-   address that needs reloading, with a valid memory address for an\n-   operand of mode MODE.  WIN will be a C statement label elsewhere\n-   in the code.  It is not necessary to define this macro, but it\n-   might be useful for performance reasons.\n-\n-   For example, on the i386, it is sometimes possible to use a single\n-   reload register instead of two by reloading a sum of two pseudo\n-   registers into a register.  On the other hand, for number of RISC\n-   processors offsets are limited so that often an intermediate\n-   address needs to be generated in order to address a stack slot.\n-   By defining LEGITIMIZE_RELOAD_ADDRESS appropriately, the\n-   intermediate addresses generated for adjacent some stack slots can\n-   be made identical, and thus be shared.\n-\n-   *Note*: This macro should be used with caution.  It is necessary\n-   to know something of how reload works in order to effectively use\n-   this, and it is quite easy to produce macros that build in too\n-   much knowledge of reload internals.\n-\n-   *Note*: This macro must be able to reload an address created by a\n-   previous invocation of this macro.  If it fails to handle such\n-   addresses then the compiler may generate incorrect code or abort.\n-\n-   The macro definition should use `push_reload' to indicate parts\n-   that need reloading; OPNUM, TYPE and IND_LEVELS are usually\n-   suitable to be passed unaltered to `push_reload'.\n-\n-   The code generated by this macro must not alter the substructure of\n-   X.  If it transforms X into a more legitimate form, it should\n-   assign X (which will always be a C variable) a new value.  This\n-   also applies to parts that you change indirectly by calling\n-   `push_reload'.\n-\n-   The macro definition may use `strict_memory_address_p' to test if\n-   the address has become legitimate.\n-\n-   If you want to change only a part of X, one standard way of doing\n-   this is to use `copy_rtx'.  Note, however, that is unshares only a\n-   single level of rtl.  Thus, if the part to be changed is not at the\n-   top level, you'll need to replace first the top leve It is not\n-   necessary for this macro to come up with a legitimate address;\n-   but often a machine-dependent strategy can generate better code.  */\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\t\\\n       if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n         goto LABEL\n-/* A C statement or compound statement with a conditional `goto\n-   LABEL;' executed if memory address X (an RTX) can have different\n-   meanings depending on the machine mode of the memory reference it\n-   is used for or if the address is valid for some modes but not\n-   others.\n-\n-   Autoincrement and autodecrement addresses typically have\n-   mode-dependent effects because the amount of the increment or\n-   decrement is the size of the operand being addressed.  Some\n-   machines have other mode-dependent addresses.  Many RISC machines\n-   have no mode-dependent addresses.\n-\n-   You may assume that ADDR is a valid address for the machine.  */\n \n #define LEGITIMATE_CONSTANT_P(X) 1\n-/* A C expression that is nonzero if X is a legitimate constant for\n-   an immediate operand on the target machine.  You can assume that X\n-   satisfies `CONSTANT_P', so you need not check this.  In fact, `1'\n-   is a suitable definition for this macro on machines where anything\n-   `CONSTANT_P' is valid.  */\n \n #define REGISTER_MOVE_COST(MODE, FROM, TO) ((FROM) == STACK_REG ? 6 \\\n \t\t\t\t\t    : (TO) == STACK_REG ? 12 \\\n \t\t\t\t\t    : 2)\n-/* A C expression for the cost of moving data from a register in class\n-   FROM to one in class TO.  The classes are expressed using the\n-   enumeration values such as `GENERAL_REGS'.  A value of 2 is the\n-   default; other values are interpreted relative to that.\n-\n-   It is not required that the cost always equal 2 when FROM is the\n-   same as TO; on some machines it is expensive to move between\n-   registers if they are not general registers.\n-\n-   If reload sees an insn consisting of a single `set' between two\n-   hard registers, and if `REGISTER_MOVE_COST' applied to their\n-   classes returns a value of 2, reload does not check to ensure that\n-   the constraints of the insn are met.  Setting a cost of other than\n-   2 will allow reload to verify that the constraints are met.  You\n-   should do this if the `movM' pattern's constraints do not allow\n-   such copying.  */\n \n #define MEMORY_MOVE_COST(MODE,CLASS,IN) ((MODE)==QImode ? 2 :\t\\\n \t\t\t\t\t (MODE)==HImode ? 4 :\t\\\n \t\t\t\t\t (MODE)==SImode ? 8 :\t\\\n \t\t\t\t\t (MODE)==SFmode ? 8 : 16)\n-/* A C expression for the cost of moving data of mode M between a\n-   register and memory.  A value of 4 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.  */\n \n #define BRANCH_COST 0\n-/* A C expression for the cost of a branch instruction.  A value of 1\n-   is the default; other values are interpreted relative to that.\n-\n-   Here are additional macros which do not specify precise relative\n-   costs, but only that certain actions are more expensive than GCC would\n-   ordinarily expect.  */\n \n #define SLOW_BYTE_ACCESS 0\n-/* Define this macro as a C expression which is nonzero if accessing\n-   less than a word of memory (i.e. a `char' or a `short') is no\n-   faster than accessing a word of memory, i.e., if such access\n-   require more than one instruction or if there is no difference in\n-   cost between byte and (aligned) word loads.\n-\n-   When this macro is not defined, the compiler will access a field by\n-   finding the smallest containing object; when it is defined, a\n-   fullword load will be used if alignment permits.  Unless bytes\n-   accesses are faster than word accesses, using word accesses is\n-   preferable since it may eliminate subsequent memory access if\n-   subsequent accesses occur to other fields in the same word of the\n-   structure, but to different bytes.\n-\n-   `SLOW_UNALIGNED_ACCESS'\n-   Define this macro to be the value 1 if unaligned accesses have a\n-   cost many times greater than aligned accesses, for example if they\n-   are emulated in a trap handler.\n-\n-   When this macro is nonzero, the compiler will act as if\n-   `STRICT_ALIGNMENT' were nonzero when generating code for block\n-   moves.  This can cause significantly more instructions to be\n-   produced.  Therefore, do not set this macro nonzero if unaligned\n-   accesses only add a cycle or two to the time for a memory access.\n-\n-   If the value of this macro is always zero, it need not be defined.\n-\n-   `MOVE_RATIO'\n-   The number of scalar move insns which should be generated instead\n-   of a string move insn or a library call.  Increasing the value\n-   will always make code faster, but eventually incurs high cost in\n-   increased code size.\n-\n-   If you don't define this, a reasonable default is used.  */\n \n #define NO_FUNCTION_CSE\n-/* Define this macro if it is as good or better to call a constant\n-   function address than to call an address kept in a register.  */\n \n #define NO_RECURSIVE_FUNCTION_CSE\n-/* Define this macro if it is as good or better for a function to call\n-   itself with an explicit address than to call an address kept in a\n-   register.  */\n \n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n-/* A C expression whose value is a string containing the assembler\n-   operation that should precede instructions and read-only data.\n-   Normally `\"\\t.text\"' is right.  */\n \n #define DATA_SECTION_ASM_OP \"\\t.data\"\n-/* A C expression whose value is a string containing the assembler\n-   operation to identify the following data as writable initialized\n-   data.  Normally `\"\\t.data\"' is right.  */\n \n #define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n-/* If defined, a C expression whose value is a string, including\n-   spacing, containing the assembler operation to identify the\n-   following data as uninitialized global data.  If not defined, and\n-   neither `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,\n-   uninitialized global data will be output in the data section if\n-   `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be\n-   used.  */\n \n /* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n    There are no shared libraries on this target, and these sections are\n@@ -1584,17 +528,10 @@ do {\t\t\t\t\t\t\t\t\t    \\\n #define DTORS_SECTION_ASM_OP \"\\t.section .dtors,\\\"a\\\",@progbits\"\n \n #define TARGET_ASM_CONSTRUCTOR avr_asm_out_ctor\n-/* If defined, a function that outputs assembler code to arrange to\n-   call the function referenced by SYMBOL at initialization time.  */\n \n #define TARGET_ASM_DESTRUCTOR avr_asm_out_dtor\n-/* This is like `TARGET_ASM_CONSTRUCTOR' but used for termination\n-   functions rather than initialization functions.  */\n \n #define EXTRA_SECTIONS in_progmem\n-/* A list of names for sections other than the standard two, which are\n-   `in_text' and `in_data'.  You need not define this macro on a\n-   system with no other sections (that GCC needs to use).  */\n \n #define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t      \\\n \t\t\t\t\t\t\t\t\t      \\\n@@ -1611,125 +548,44 @@ progmem_section (void)\t\t\t\t\t\t\t      \\\n       in_section = in_progmem;\t\t\t\t\t\t      \\\n     }\t\t\t\t\t\t\t\t\t      \\\n }\n-/* `EXTRA_SECTION_FUNCTIONS'\n-   One or more functions to be defined in `varasm.c'.  These\n-   functions should do jobs analogous to those of `text_section' and\n-   `data_section', for your additional sections.  Do not define this\n-   macro if you do not define `EXTRA_SECTIONS'.  */\n \n #define READONLY_DATA_SECTION data_section\n-/* On most machines, read-only variables, constants, and jump tables\n-   are placed in the text section.  If this is not the case on your\n-   machine, this macro should be defined to be the name of a function\n-   (either `data_section' or a function defined in `EXTRA_SECTIONS')\n-   that switches to the section to be used for read-only items.\n-\n-   If these items should be placed in the text section, this macro\n-   should not be defined.  */\n \n #define JUMP_TABLES_IN_TEXT_SECTION 0\n-/* Define this macro if jump tables (for `tablejump' insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.\n-\n-   This macro is irrelevant if there is no separate readonly data\n-   section.  */\n \n #define ASM_COMMENT_START \" ; \"\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  The compiler assumes that the comment will\n-   end at the end of the line.  */\n \n #define ASM_APP_ON \"/* #APP */\\n\"\n-/* A C string constant for text to be output before each `asm'\n-   statement or group of consecutive ones.  Normally this is\n-   `\"#APP\"', which is a comment that has no effect on most assemblers\n-   but tells the GNU assembler that it must check the lines that\n-   follow for all valid assembler constructs.  */\n \n #define ASM_APP_OFF \"/* #NOAPP */\\n\"\n-/* A C string constant for text to be output after each `asm'\n-   statement or group of consecutive ones.  Normally this is\n-   `\"#NO_APP\"', which tells the GNU assembler to resume making the\n-   time-saving assumptions that are valid for ordinary compiler\n-   output.  */\n \n #define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) \\\n   fprintf (STREAM,\"/* line: %d */\\n\",LINE)\n-/* A C statement to output DBX or SDB debugging information before\n-   code for line number LINE of the current source file to the stdio\n-   stream STREAM.\n-\n-   This macro need not be defined if the standard form of debugging\n-   information for the debugger in use is appropriate.  */\n \n /* Switch into a generic section.  */\n #define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n \n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)\t gas_output_ascii (FILE,P,SIZE)\n-/* `ASM_OUTPUT_ASCII (STREAM, PTR, LEN)'\n-   output_ascii (FILE, P, SIZE)\n-   A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble a string constant containing the LEN bytes\n-   at PTR.  PTR will be a C expression of type `char *' and LEN a C\n-   expression of type `int'.\n-\n-   If the assembler has a `.ascii' pseudo-op as found in the Berkeley\n-   Unix assembler, do not define the macro `ASM_OUTPUT_ASCII'.  */\n \n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '\\n'\t\t\t \\\n \t\t\t\t\t  || ((C) == '$'))\n-/* Define this macro as a C expression which is nonzero if C is used\n-   as a logical line separator by the assembler.\n-\n-   If you do not define this macro, the default is that only the\n-   character `;' is treated as a logical line separator.  */\n-\n-/* These macros are provided by `real.h' for writing the definitions of\n-   `ASM_OUTPUT_DOUBLE' and the like:  */\n \n #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\t\t   \\\n do {\t\t\t\t\t\t\t\t\t   \\\n      fputs (\"\\t.comm \", (STREAM));\t\t\t\t\t   \\\n      assemble_name ((STREAM), (NAME));\t\t\t\t\t   \\\n      fprintf ((STREAM), \",%lu,1\\n\", (unsigned long)(SIZE));\t\t   \\\n } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM the assembler definition of a common-label named NAME whose\n-   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n-   to whatever alignment the caller wants.\n-\n-   Use the expression `assemble_name (STREAM, NAME)' to output the\n-   name itself; before and after that, output the additional\n-   assembler syntax for defining the name, and a newline.\n-\n-   This macro controls how the assembler definitions of uninitialized\n-   common global variables are output.  */\n \n #define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED)\t\t\t\\\n   asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED))\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM the assembler definition of uninitialized global DECL named\n-   NAME whose size is SIZE bytes.  The variable ROUNDED is the size\n-   rounded up to whatever alignment the caller wants.  */\n \n #define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n      fputs (\"\\t.lcomm \", (STREAM));\t\t\t\t\t\\\n      assemble_name ((STREAM), (NAME));\t\t\t\t\t\\\n      fprintf ((STREAM), \",%d\\n\", (int)(SIZE));\t\t\t\t\\\n } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM the assembler definition of a local-common-label named NAME\n-   whose size is SIZE bytes.  The variable ROUNDED is the size\n-   rounded up to whatever alignment the caller wants.\n-\n-   Use the expression `assemble_name (STREAM, NAME)' to output the\n-   name itself; before and after that, output the additional\n-   assembler syntax for defining the name, and a newline.\n-\n-   This macro controls how the assembler definitions of uninitialized\n-   static variables are output.  */\n \n #undef TYPE_ASM_OP\n #undef SIZE_ASM_OP\n@@ -1758,29 +614,11 @@ do {\t\t\t\t\t\t\t\t\\\n      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n } while (0)\n \n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM any text necessary for declaring the name NAME of a\n-   function which is being defined.  This macro is responsible for\n-   outputting the label definition (perhaps using\n-   `ASM_OUTPUT_LABEL').  The argument DECL is the `FUNCTION_DECL'\n-   tree node representing the function.\n-\n-   If this macro is not defined, then the function name is defined in\n-   the usual manner as a label (by means of `ASM_OUTPUT_LABEL').  */\n-\n #define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n       ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\t\\\n   } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM any text necessary for declaring the size of a function\n-   which is being defined.  The argument NAME is the name of the\n-   function.  The argument DECL is the `FUNCTION_DECL' tree node\n-   representing the function.\n-\n-   If this macro is not defined, then the function size is not\n-   defined.  */\n \n #define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -1794,15 +632,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\t\\\n } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM any text necessary for declaring the name NAME of an\n-   initialized variable which is being defined.  This macro must\n-   output the label definition (perhaps using `ASM_OUTPUT_LABEL').\n-   The argument DECL is the `VAR_DECL' tree node representing the\n-   variable.\n-\n-   If this macro is not defined, then the variable name is defined in\n-   the usual manner as a label (by means of `ASM_OUTPUT_LABEL').  */\n \n #undef ASM_FINISH_DECLARE_OBJECT\n #define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n@@ -1820,15 +649,6 @@ do {\t\t\t\t\t\t\t\t\t \\\n        }\t\t\t\t\t\t\t\t \\\n    } while (0)\n \n-/* A C statement (sans semicolon) to finish up declaring a variable\n-   name once the compiler has processed its initializer fully and\n-   thus has had a chance to determine the size of an array when\n-   controlled by an initializer.  This is used on systems where it's\n-   necessary to declare something about the size of the object.\n-\n-   If you don't define this macro, that is equivalent to defining it\n-   to do nothing.  */\n-\n \n #define ESCAPES \\\n \"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n@@ -1878,330 +698,79 @@ do {\t\t\t\t\t\t\t\t\t \\\n     }\t\t\t\t\t\\\n   while (0)\n \n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM some commands that will make the label NAME weak; that is,\n-   available for reference from other files but only used if no other\n-   definition is available.  Use the expression `assemble_name\n-   (STREAM, NAME)' to output the name itself; before and after that,\n-   output the additional assembler syntax for making that name weak,\n-   and a newline.\n-\n-   If you don't define this macro, GCC will not support weak\n-   symbols and you should not define the `SUPPORTS_WEAK' macro.\n-*/\n-\n #define SUPPORTS_WEAK 1\n-/* A C expression which evaluates to true if the target supports weak\n-   symbols.\n-\n-   If you don't define this macro, `defaults.h' provides a default\n-   definition.  If `ASM_WEAKEN_LABEL' is defined, the default\n-   definition is `1'; otherwise, it is `0'.  Define this macro if you\n-   want to control weak symbol support with a compiler flag such as\n-   `-melf'.\n-\n-   `MAKE_DECL_ONE_ONLY'\n-   A C statement (sans semicolon) to mark DECL to be emitted as a\n-   public symbol such that extra copies in multiple translation units\n-   will be discarded by the linker.  Define this macro if your object\n-   file format provides support for this concept, such as the `COMDAT'\n-   section flags in the Microsoft Windows PE/COFF format, and this\n-   support requires changes to DECL, such as putting it in a separate\n-   section.\n-\n-   `SUPPORTS_WEAK'\n-   A C expression which evaluates to true if the target supports\n-   one-only semantics.\n-\n-   If you don't define this macro, `varasm.c' provides a default\n-   definition.  If `MAKE_DECL_ONE_ONLY' is defined, the default\n-   definition is `1'; otherwise, it is `0'.  Define this macro if you\n-   want to control weak symbol support with a compiler flag, or if\n-   setting the `DECL_ONE_ONLY' flag is enough to mark a declaration to\n-   be emitted as one-only.  */\n \n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)\t\\\n sprintf (STRING, \"*.%s%lu\", PREFIX, (unsigned long)(NUM))\n-/* A C statement to store into the string STRING a label whose name\n-   is made from the string PREFIX and the number NUM.\n-\n-   This string, when output subsequently by `assemble_name', should\n-   produce the output that `(*targetm.asm_out.internal_label)' would produce\n-   with the same PREFIX and NUM.\n-\n-   If the string begins with `*', then `assemble_name' will output\n-   the rest of the string unchanged.  It is often convenient for\n-   `ASM_GENERATE_INTERNAL_LABEL' to use `*' in this way.  If the\n-   string doesn't start with `*', then `ASM_OUTPUT_LABELREF' gets to\n-   output the string, and may change it.  (Of course,\n-   `ASM_OUTPUT_LABELREF' is also part of your machine description, so\n-   you should know what it does on your machine.)  */\n-\n-/* `ASM_OUTPUT_WEAK_ALIAS (STREAM, NAME, VALUE)'\n-   A C statement to output to the stdio stream STREAM assembler code\n-   which defines (equates) the weak symbol NAME to have the value\n-   VALUE.\n-\n-   Define this macro if the target only supports weak aliases; define\n-   ASM_OUTPUT_DEF instead if possible.  */\n \n #define HAS_INIT_SECTION 1\n-/* If defined, `main' will not call `__main' as described above.\n-   This macro should be defined for systems that control the contents\n-   of the init section on a symbol-by-symbol basis, such as OSF/1,\n-   and should not be defined explicitly for systems that support\n-   `INIT_SECTION_ASM_OP'.  */\n \n #define REGISTER_NAMES {\t\t\t\t\\\n   \"r0\",\"r1\",\"r2\",\"r3\",\"r4\",\"r5\",\"r6\",\"r7\",\t\t\\\n     \"r8\",\"r9\",\"r10\",\"r11\",\"r12\",\"r13\",\"r14\",\"r15\",\t\\\n     \"r16\",\"r17\",\"r18\",\"r19\",\"r20\",\"r21\",\"r22\",\"r23\",\t\\\n     \"r24\",\"r25\",\"r26\",\"r27\",\"r28\",\"r29\",\"r30\",\"r31\",\t\\\n     \"__SPL__\",\"__SPH__\",\"argL\",\"argH\"}\n-/* A C initializer containing the assembler's names for the machine\n-   registers, each one as a C string constant.  This is what\n-   translates register numbers in the compiler into assembler\n-   language.  */\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n-/* If defined, a C statement to be executed just prior to the output\n-   of assembler code for INSN, to modify the extracted operands so\n-   they will be output differently.\n-\n-   Here the argument OPVEC is the vector containing the operands\n-   extracted from INSN, and NOPERANDS is the number of elements of\n-   the vector which contain meaningful data for this insn.  The\n-   contents of this vector are what will be used to convert the insn\n-   template into assembler code, so you can change the assembler\n-   output by changing the contents of the vector.\n-\n-   This macro is useful when various assembler syntaxes share a single\n-   file of instruction patterns; by defining this macro differently,\n-   you can cause a large class of instructions to be output\n-   differently (such as with rearranged operands).  Naturally,\n-   variations in assembler syntax affecting individual insn patterns\n-   ought to be handled by writing conditional output routines in\n-   those patterns.\n-\n-   If this macro is not defined, it is equivalent to a null statement.  */\n \n #define PRINT_OPERAND(STREAM, X, CODE) print_operand (STREAM, X, CODE)\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n-\n-   CODE is a value that can be used to specify one of several ways of\n-   printing the operand.  It is used when identical operands must be\n-   printed differently depending on the context.  CODE comes from the\n-   `%' specification that was used to request printing of the\n-   operand.  If the specification was just `%DIGIT' then CODE is 0;\n-   if the specification was `%LTR DIGIT' then CODE is the ASCII code\n-   for LTR.\n-\n-   If X is a register, this macro should print the register's name.\n-   The names can be found in an array `reg_names' whose type is `char\n-   *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%'\n-   followed by a punctuation character), this macro is called with a\n-   null pointer for X and the punctuation character for CODE.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '~')\n-/* A C expression which evaluates to true if CODE is a valid\n-   punctuation character for use in the `PRINT_OPERAND' macro.  If\n-   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no\n-   punctuation characters (except for the standard one, `%') are used\n-   in this way.  */\n \n #define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand that is a memory\n-   reference whose address is X.  X is an RTL expression.  */\n \n #define USER_LABEL_PREFIX \"\"\n-/* `LOCAL_LABEL_PREFIX'\n-   `REGISTER_PREFIX'\n-   `IMMEDIATE_PREFIX'\n-   If defined, C string expressions to be used for the `%R', `%L',\n-   `%U', and `%I' options of `asm_fprintf' (see `final.c').  These\n-   are useful when a single `md' file must support multiple assembler\n-   formats.  In that case, the various `tm.h' files can define these\n-   macros differently.  */\n \n #define ASSEMBLER_DIALECT AVR_ENHANCED\n-/* If your target supports multiple dialects of assembler language\n-  (such as different opcodes), define this macro as a C expression\n-  that gives the numeric index of the assembler language dialect to\n-  use, with zero as the first variant.\n-\n-  If this macro is defined, you may use constructs of the form\n-  `{option0|option1|option2...}' in the output templates of patterns\n-  (*note Output Template::.) or in the first argument of\n-  `asm_fprintf'.  This construct outputs `option0', `option1' or\n-  `option2', etc., if the value of `ASSEMBLER_DIALECT' is zero, one\n-  or two, etc.  Any special characters within these strings retain\n-  their usual meaning.\n-\n-  If you do not define this macro, the characters `{', `|' and `}'\n-  do not have any special meaning when used in templates or operands\n-  to `asm_fprintf'.\n-\n-  Define the macros `REGISTER_PREFIX', `LOCAL_LABEL_PREFIX',\n-  `USER_LABEL_PREFIX' and `IMMEDIATE_PREFIX' if you can express the\n-  variations in assembler language syntax with that mechanism.\n-  Define `ASSEMBLER_DIALECT' and use the `{option0|option1}' syntax\n-  if the syntax variant are larger and involve such things as\n-  different opcodes or operand order.  */\n \n #define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)\t\\\n {\t\t\t\t\t\t\\\n   if (REGNO > 31)\t\t\t\t\\\n     abort ();\t\t\t\t\t\\\n   fprintf (STREAM, \"\\tpush\\tr%d\", REGNO);\t\\\n }\n-/* A C expression to output to STREAM some assembler code which will\n-   push hard register number REGNO onto the stack.  The code need not\n-   be optimal, since this macro is used only when profiling.  */\n \n #define ASM_OUTPUT_REG_POP(STREAM, REGNO)\t\\\n {\t\t\t\t\t\t\\\n   if (REGNO > 31)\t\t\t\t\\\n     abort ();\t\t\t\t\t\\\n   fprintf (STREAM, \"\\tpop\\tr%d\", REGNO);\t\\\n }\n-/* A C expression to output to STREAM some assembler code which will\n-   pop hard register number REGNO off of the stack.  The code need\n-   not be optimal, since this macro is used only when profiling.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\\\n   avr_output_addr_vec_elt(STREAM, VALUE)\n-/* This macro should be provided on machines where the addresses in a\n-   dispatch table are absolute.\n-\n-   The definition should be a C statement to output to the stdio\n-   stream STREAM an assembler pseudo-instruction to generate a\n-   reference to a label.  VALUE is the number of an internal label\n-   whose definition is output using `(*targetm.asm_out.internal_label)'.  For\n-   example,\n-\n-   fprintf (STREAM, \"\\t.word L%d\\n\", VALUE)  */\n \n #define ASM_OUTPUT_CASE_LABEL(STREAM, PREFIX, NUM, TABLE) \\\n   progmem_section (), (*targetm.asm_out.internal_label) (STREAM, PREFIX, NUM)\n \n-/* `ASM_OUTPUT_CASE_LABEL (STREAM, PREFIX, NUM, TABLE)'\n-   Define this if the label before a jump-table needs to be output\n-   specially.  The first three arguments are the same as for\n-   `(*targetm.asm_out.internal_label)'; the fourth argument is the jump-table\n-   which follows (a `jump_insn' containing an `addr_vec' or\n-   `addr_diff_vec').\n-\n-   This feature is used on system V to output a `swbeg' statement for\n-   the table.\n-\n-   If this macro is not defined, these labels are output with\n-   `(*targetm.asm_out.internal_label)'.  */\n-\n-/* `ASM_OUTPUT_CASE_END (STREAM, NUM, TABLE)'\n-   Define this if something special must be output at the end of a\n-   jump-table.  The definition should be a C statement to be executed\n-   after the assembler code for the table is written.  It should write\n-   the appropriate code to stdio stream STREAM.  The argument TABLE\n-   is the jump-table insn, and NUM is the label-number of the\n-   preceding label.\n-\n-   If this macro is not defined, nothing special is output at the end\n-   of the jump-table.  */\n-\n #define ASM_OUTPUT_SKIP(STREAM, N)\t\t\\\n fprintf (STREAM, \"\\t.skip %lu,0\\n\", (unsigned long)(N))\n-/* A C statement to output to the stdio stream STREAM an assembler\n-   instruction to advance the location counter by NBYTES bytes.\n-   Those bytes should be zero when loaded.  NBYTES will be a C\n-   expression of type `int'.  */\n \n #define ASM_OUTPUT_ALIGN(STREAM, POWER)\n-/* A C statement to output to the stdio stream STREAM an assembler\n-   command to advance the location counter to a multiple of 2 to the\n-   POWER bytes.  POWER will be a C expression of type `int'.  */\n \n #define CASE_VECTOR_MODE HImode\n-/* An alias for a machine mode name.  This is the machine mode that\n-   elements of a jump-table should have.  */\n \n extern int avr_case_values_threshold;\n \n #define CASE_VALUES_THRESHOLD avr_case_values_threshold\n-/* `CASE_VALUES_THRESHOLD'\n-   Define this to be the smallest number of different values for\n-   which it is best to use a jump-table instead of a tree of\n-   conditional branches.  The default is four for machines with a\n-   `casesi' instruction and five otherwise.  This is best for most\n-   machines.  */\n \n #undef WORD_REGISTER_OPERATIONS\n-/* Define this macro if operations between registers with integral\n-   mode smaller than a word are always performed on the entire\n-   register.  Most RISC machines have this property and most CISC\n-   machines do not.  */\n \n #define MOVE_MAX 4\n-/* The maximum number of bytes that a single instruction can move\n-   quickly between memory and registers or between two memory\n-   locations.  */\n \n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-/* A C expression which is nonzero if on this machine it is safe to\n-   \"convert\" an integer of INPREC bits to one of OUTPREC bits (where\n-   OUTPREC is smaller than INPREC) by merely operating on it as if it\n-   had only OUTPREC bits.\n-\n-   On many machines, this expression can be 1.\n-\n-   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for\n-   modes for which `MODES_TIEABLE_P' is 0, suboptimal code can result.\n-   If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in\n-   such cases may improve things.  */\n \n #define Pmode HImode\n-/* An alias for the machine mode for pointers.  On most machines,\n-   define this to be the integer mode corresponding to the width of a\n-   hardware pointer; `SImode' on 32-bit machine or `DImode' on 64-bit\n-   machines.  On some machines you must define this to be one of the\n-   partial integer modes, such as `PSImode'.\n-\n-   The width of `Pmode' must be at least as large as the value of\n-   `POINTER_SIZE'.  If it is not equal, you must define the macro\n-   `POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to\n-   `Pmode'.  */\n \n #define FUNCTION_MODE HImode\n-/* An alias for the machine mode used for memory references to\n-   functions being called, in `call' RTL expressions.  On most\n-   machines this should be `QImode'.  */\n+\n      /*                            1        3 */\n #define INTEGRATE_THRESHOLD(DECL) (1 + (3 * list_length (DECL_ARGUMENTS (DECL)) / 2))\n \n-/* A C expression for the maximum number of instructions above which\n-   the function DECL should not be inlined.  DECL is a\n-   `FUNCTION_DECL' node.\n-\n-   The default definition of this macro is 64 plus 8 times the number\n-   of arguments that the function accepts.  Some people think a larger\n-   threshold should be used on RISC machines.  */\n-\n #define DOLLARS_IN_IDENTIFIERS 0\n-/* Define this macro to control use of the character `$' in identifier\n-   names.  0 means `$' is not allowed by default; 1 means it is\n-   allowed.  1 is the default; there is no need to define this macro\n-   in that case.  This macro controls the compiler proper; it does\n-   not affect the preprocessor.  */\n \n #define NO_DOLLAR_IN_LABEL 1\n-/* Define this macro if the assembler does not accept the character\n-   `$' in label names.  By default constructors and destructors in\n-   G++ have `$' in the identifiers.  If this macro is defined, `.' is\n-   used instead.  */\n \n #define GIV_SORT_CRITERION(X, Y)\t\\\n   if (GET_CODE ((X)->add_val) == CONST_INT\t\t\\\n@@ -2220,14 +789,8 @@ extern int avr_case_values_threshold;\n #define TRAMPOLINE_TEMPLATE(FILE) \\\n   internal_error (\"trampolines not supported\")\n \n-/* Length in units of the trampoline for entering a nested function.  */\n-\n #define TRAMPOLINE_SIZE 4\n \n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t      \\\n {\t\t\t\t\t\t\t\t\t      \\\n   emit_move_insn (gen_rtx (MEM, HImode, plus_constant ((TRAMP), 2)), CXT);    \\\n@@ -2258,36 +821,12 @@ extern int avr_case_values_threshold;\n \n #define ADJUST_INSN_LENGTH(INSN, LENGTH) (LENGTH =\\\n \t\t\t\t\t  adjust_insn_length (INSN, LENGTH))\n-/* If defined, modifies the length assigned to instruction INSN as a\n-   function of the context in which it is used.  LENGTH is an lvalue\n-   that contains the initially computed length of the insn and should\n-   be updated with the correct length of the insn.  If updating is\n-   required, INSN must not be a varying-length insn.\n-\n-   This macro will normally not be required.  A case in which it is\n-   required is the ROMP.  On this machine, the size of an `addr_vec'\n-   insn must be increased by two to compensate for the fact that\n-   alignment may be required.  */\n \n #define TARGET_MEM_FUNCTIONS\n-/* Define this macro if GCC should generate calls to the System V\n-   (and ANSI C) library functions `memcpy' and `memset' rather than\n-   the BSD functions `bcopy' and `bzero'.  */\n \n #define CPP_SPEC \"%{posix:-D_POSIX_SOURCE}\"\n \n-/* A C string constant that tells the GCC driver program options to\n-   pass to CPP.  It can also specify how to translate options you\n-   give to GCC into options for GCC to pass to the CPP.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-\n #define CC1_SPEC \"%{profile:-p}\"\n-/* A C string constant that tells the GCC driver program options to\n-   pass to `cc1'.  It can also specify how to translate options you\n-   give to GCC into options for GCC to pass to the `cc1'.\n-\n-   Do not define this macro if it does not need to do anything.  */\n \n #define CC1PLUS_SPEC \"%{!frtti:-fno-rtti} \\\n     %{!fenforce-eh-specs:-fno-enforce-eh-specs} \\\n@@ -2296,12 +835,6 @@ extern int avr_case_values_threshold;\n    pass to `cc1plus'.  */\n \n #define ASM_SPEC \"%{mmcu=*:-mmcu=%*}\"\n-/* A C string constant that tells the GCC driver program how to\n-   run any programs which cleanup after the normal assembler.\n-   Normally, this is not needed.  See the file `mips.h' for an\n-   example of this.\n-\n-   Do not define this macro if it does not need to do anything.  */\n \n #define LINK_SPEC \" %{!mmcu*:-m avr2}\\\n %{mmcu=at90s1200|mmcu=attiny1*|mmcu=attiny28:-m avr1} \\\n@@ -2311,49 +844,18 @@ extern int avr_case_values_threshold;\n %{mmcu=atmega16*|mmcu=atmega32*|mmcu=atmega64|mmcu=atmega128|mmcu=at94k:-m avr5}\\\n %{mmcu=atmega64|mmcu=atmega128|mmcu=atmega162|mmcu=atmega169: -Tdata 0x800100} \"\n \n-/* A C string constant that tells the GCC driver program options to\n-   pass to the linker.  It can also specify how to translate options\n-   you give to GCC into options for GCC to pass to the linker.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-\n #define LIB_SPEC \\\n   \"%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lc }}}\"\n-/* Another C string constant used much like `LINK_SPEC'.  The\n-   difference between the two is that `LIB_SPEC' is used at the end\n-   of the command given to the linker.\n-\n-   If this macro is not defined, a default is provided that loads the\n-   standard C library from the usual place.  See `gcc.c'.  */\n \n #define LIBSTDCXX \"-lgcc\"\n /* No libstdc++ for now.  Empty string doesn't work.  */\n \n #define LIBGCC_SPEC \\\n   \"%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}\"\n-/* Another C string constant that tells the GCC driver program how\n-   and when to place a reference to `libgcc.a' into the linker\n-   command line.  This constant is placed both before and after the\n-   value of `LIB_SPEC'.\n-\n-   If this macro is not defined, the GCC driver provides a default\n-   that passes the string `-lgcc' to the linker unless the `-shared'\n-   option is specified.  */\n \n #define STARTFILE_SPEC \"%(crt_binutils)\"\n-/* Another C string constant used much like `LINK_SPEC'.  The\n-   difference between the two is that `STARTFILE_SPEC' is used at the\n-   very beginning of the command given to the linker.\n-\n-   If this macro is not defined, a default is provided that loads the\n-   standard C startup file from the usual place.  See `gcc.c'.  */\n \n #define ENDFILE_SPEC \"\"\n-/* Another C string constant used much like `LINK_SPEC'.  The\n-   difference between the two is that `ENDFILE_SPEC' is used at the\n-   very end of the command given to the linker.\n-\n-   Do not define this macro if it does not need to do anything.  */\n \n #define CRT_BINUTILS_SPECS \"\\\n %{mmcu=at90s1200|mmcu=avr1:crts1200.o%s} \\\n@@ -2395,10 +897,6 @@ extern int avr_case_values_threshold;\n \n #define EXTRA_SPECS {\"crt_binutils\", CRT_BINUTILS_SPECS},\n \n-/* Define this macro to provide additional specifications to put in\n-   the `specs' file that can be used in various specifications like\n-   `CC1_SPEC'.  */\n-\n /* This is the default without any -mmcu=* option (AT90S*).  */\n #define MULTILIB_DEFAULTS { \"mmcu=avr2\" }\n "}]}