{"sha": "a2369ed310098b1f200e68cca7b14376912528d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIzNjllZDMxMDA5OGIxZjIwMGU2OGNjYTdiMTQzNzY5MTI1MjhkMg==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2003-09-12T19:00:45Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2003-09-12T19:00:45Z"}, "message": "Use ISO C90 prototypes.\n\nFrom-SVN: r71336", "tree": {"sha": "303c3e3ac91f58b8cf1ef4215691ccba31e396ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/303c3e3ac91f58b8cf1ef4215691ccba31e396ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2369ed310098b1f200e68cca7b14376912528d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2369ed310098b1f200e68cca7b14376912528d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2369ed310098b1f200e68cca7b14376912528d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2369ed310098b1f200e68cca7b14376912528d2/comments", "author": null, "committer": null, "parents": [{"sha": "4ca0d6d449a0884cbd24bcc87c91253ba093487c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca0d6d449a0884cbd24bcc87c91253ba093487c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca0d6d449a0884cbd24bcc87c91253ba093487c"}], "stats": {"total": 1486, "additions": 530, "deletions": 956}, "files": [{"sha": "60e7bd91f6080a10d106808ff60a4e053c00fb6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2369ed310098b1f200e68cca7b14376912528d2", "patch": "@@ -1,3 +1,9 @@\n+2003-09-12  Dale Johannesen  <dale@apple.com>\n+\t* config/rs6000/rs6000-protos.h:  Use C90 prototypes.\n+\t* config/rs6000/rs6000-c.c:  Ditto. \n+\t* config/rs6000/rs6000.c:  Ditto.\n+\t* config/rs6000/ sysv4.h:  Ditto.\n+\n 2003-09-12  Chris Lattner <sabre@nondot.org>\n \n \t* loop.c: Move comments describing BIV's and GIV's to top of file"}, {"sha": "a47afee59b3892127e9f27112a42f004a411b52b", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=a2369ed310098b1f200e68cca7b14376912528d2", "patch": "@@ -48,8 +48,7 @@\n } while (0)\n \n void\n-rs6000_pragma_longcall (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+rs6000_pragma_longcall (cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   tree x, n;\n \n@@ -80,8 +79,7 @@ rs6000_pragma_longcall (pfile)\n #define builtin_assert(TXT) cpp_assert (pfile, TXT)\n \n void\n-rs6000_cpu_cpp_builtins (pfile)\n-     cpp_reader *pfile;\n+rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n {\n   if (TARGET_POWER2)\n     builtin_define (\"_ARCH_PWR2\");"}, {"sha": "8340c2b59314b55d385a0cf6aa167af455c9efa7", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 156, "deletions": 159, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a2369ed310098b1f200e68cca7b14376912528d2", "patch": "@@ -27,185 +27,182 @@\n #ifdef RTX_CODE\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx, int, int));\n-extern void rs6000_va_start PARAMS ((tree, rtx));\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int);\n+extern void rs6000_va_start (tree, rtx);\n #endif /* TREE_CODE */\n \n-extern struct rtx_def *rs6000_got_register PARAMS ((rtx));\n-extern struct rtx_def *find_addr_reg PARAMS ((rtx));\n-extern int any_operand PARAMS ((rtx, enum machine_mode));\n-extern int short_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int u_short_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int non_short_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int exact_log2_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int gpc_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int cc_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int cc_reg_not_cr0_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_short_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_neg_short_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_aligned_short_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_u_short_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_arith_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_add_cint64_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_sub_cint64_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int got_operand PARAMS ((rtx, enum machine_mode));\n-extern int got_no_const_operand PARAMS ((rtx, enum machine_mode));\n-extern int num_insns_constant PARAMS ((rtx, enum machine_mode));\n-extern int easy_fp_constant PARAMS ((rtx, enum machine_mode));\n-extern int easy_vector_constant PARAMS ((rtx, enum machine_mode));\n-extern const char *output_vec_const_move PARAMS ((rtx *));\n-extern int zero_fp_constant PARAMS ((rtx, enum machine_mode));\n-extern int zero_constant PARAMS ((rtx, enum machine_mode));\n-extern int volatile_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int offsettable_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int mem_or_easy_const_operand PARAMS ((rtx, enum machine_mode));\n-extern int add_operand PARAMS ((rtx, enum machine_mode));\n-extern int non_add_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int non_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int logical_operand PARAMS ((rtx, enum machine_mode));\n-extern int mask_operand PARAMS ((rtx, enum machine_mode));\n-extern int mask_operand_wrap PARAMS ((rtx, enum machine_mode));\n-extern int mask64_operand PARAMS ((rtx, enum machine_mode));\n-extern int mask64_2_operand PARAMS ((rtx, enum machine_mode));\n-extern void build_mask64_2_operands PARAMS ((rtx, rtx *));\n-extern int and64_operand PARAMS ((rtx, enum machine_mode));\n-extern int and64_2_operand PARAMS ((rtx, enum machine_mode));\n-extern int and_operand PARAMS ((rtx, enum machine_mode));\n-extern int count_register_operand PARAMS ((rtx, enum machine_mode));\n-extern int xer_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int lwa_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_operand PARAMS ((rtx, enum machine_mode));\n-extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n-extern int input_operand PARAMS ((rtx, enum machine_mode));\n-extern int small_data_operand PARAMS ((rtx, enum machine_mode));\n-extern int s8bit_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern bool legitimate_constant_pool_address_p PARAMS ((rtx));\n-extern int expand_block_move PARAMS ((rtx[]));\n-extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern const char * rs6000_output_load_multiple PARAMS ((rtx[]));\n-extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n-extern int branch_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int branch_positive_comparison_operator \n-  PARAMS ((rtx, enum machine_mode));\n-extern int scc_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int trap_comparison_operator PARAMS ((rtx, enum machine_mode));\n-extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n-extern int boolean_or_operator PARAMS ((rtx, enum machine_mode));\n-extern int min_max_operator PARAMS ((rtx, enum machine_mode));\n-extern int includes_lshift_p PARAMS ((rtx, rtx));\n-extern int includes_rshift_p PARAMS ((rtx, rtx));\n-extern int includes_rldic_lshift_p PARAMS ((rtx, rtx));\n-extern int includes_rldicr_lshift_p PARAMS ((rtx, rtx));\n-extern int registers_ok_for_quad_peep PARAMS ((rtx, rtx));\n-extern int addrs_ok_for_quad_peep PARAMS ((rtx, rtx));\n+extern struct rtx_def *rs6000_got_register (rtx);\n+extern struct rtx_def *find_addr_reg (rtx);\n+extern int any_operand (rtx, enum machine_mode);\n+extern int short_cint_operand (rtx, enum machine_mode);\n+extern int u_short_cint_operand (rtx, enum machine_mode);\n+extern int non_short_cint_operand (rtx, enum machine_mode);\n+extern int exact_log2_cint_operand (rtx, enum machine_mode);\n+extern int gpc_reg_operand (rtx, enum machine_mode);\n+extern int cc_reg_operand (rtx, enum machine_mode);\n+extern int cc_reg_not_cr0_operand (rtx, enum machine_mode);\n+extern int reg_or_short_operand (rtx, enum machine_mode);\n+extern int reg_or_neg_short_operand (rtx, enum machine_mode);\n+extern int reg_or_aligned_short_operand (rtx, enum machine_mode);\n+extern int reg_or_u_short_operand (rtx, enum machine_mode);\n+extern int reg_or_cint_operand (rtx, enum machine_mode);\n+extern int reg_or_arith_cint_operand (rtx, enum machine_mode);\n+extern int reg_or_add_cint64_operand (rtx, enum machine_mode);\n+extern int reg_or_sub_cint64_operand (rtx, enum machine_mode);\n+extern int reg_or_logical_cint_operand (rtx, enum machine_mode);\n+extern int got_operand (rtx, enum machine_mode);\n+extern int got_no_const_operand (rtx, enum machine_mode);\n+extern int num_insns_constant (rtx, enum machine_mode);\n+extern int easy_fp_constant (rtx, enum machine_mode);\n+extern int easy_vector_constant (rtx, enum machine_mode);\n+extern const char *output_vec_const_move (rtx *);\n+extern int zero_fp_constant (rtx, enum machine_mode);\n+extern int zero_constant (rtx, enum machine_mode);\n+extern int volatile_mem_operand (rtx, enum machine_mode);\n+extern int offsettable_mem_operand (rtx, enum machine_mode);\n+extern int mem_or_easy_const_operand (rtx, enum machine_mode);\n+extern int add_operand (rtx, enum machine_mode);\n+extern int non_add_cint_operand (rtx, enum machine_mode);\n+extern int non_logical_cint_operand (rtx, enum machine_mode);\n+extern int logical_operand (rtx, enum machine_mode);\n+extern int mask_operand (rtx, enum machine_mode);\n+extern int mask_operand_wrap (rtx, enum machine_mode);\n+extern int mask64_operand (rtx, enum machine_mode);\n+extern int mask64_2_operand (rtx, enum machine_mode);\n+extern void build_mask64_2_operands (rtx, rtx *);\n+extern int and64_operand (rtx, enum machine_mode);\n+extern int and64_2_operand (rtx, enum machine_mode);\n+extern int and_operand (rtx, enum machine_mode);\n+extern int count_register_operand (rtx, enum machine_mode);\n+extern int xer_operand (rtx, enum machine_mode);\n+extern int reg_or_mem_operand (rtx, enum machine_mode);\n+extern int lwa_operand (rtx, enum machine_mode);\n+extern int call_operand (rtx, enum machine_mode);\n+extern int current_file_function_operand (rtx, enum machine_mode);\n+extern int input_operand (rtx, enum machine_mode);\n+extern int small_data_operand (rtx, enum machine_mode);\n+extern int s8bit_cint_operand (rtx, enum machine_mode);\n+extern bool legitimate_constant_pool_address_p (rtx);\n+extern int expand_block_move (rtx[]);\n+extern int load_multiple_operation (rtx, enum machine_mode);\n+extern const char * rs6000_output_load_multiple (rtx[]);\n+extern int store_multiple_operation (rtx, enum machine_mode);\n+extern int branch_comparison_operator (rtx, enum machine_mode);\n+extern int branch_positive_comparison_operator (rtx, enum machine_mode);\n+extern int scc_comparison_operator (rtx, enum machine_mode);\n+extern int trap_comparison_operator (rtx, enum machine_mode);\n+extern int boolean_operator (rtx, enum machine_mode);\n+extern int boolean_or_operator (rtx, enum machine_mode);\n+extern int min_max_operator (rtx, enum machine_mode);\n+extern int includes_lshift_p (rtx, rtx);\n+extern int includes_rshift_p (rtx, rtx);\n+extern int includes_rldic_lshift_p (rtx, rtx);\n+extern int includes_rldicr_lshift_p (rtx, rtx);\n+extern int registers_ok_for_quad_peep (rtx, rtx);\n+extern int addrs_ok_for_quad_peep (rtx, rtx);\n extern int altivec_in_gprs_p (rtx, rtx);\n-extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode, rtx));\n-extern int ccr_bit PARAMS ((rtx, int));\n-extern int extract_MB PARAMS ((rtx));\n-extern int extract_ME PARAMS ((rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern enum rtx_code rs6000_reverse_condition PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t       enum rtx_code));\n-extern void rs6000_emit_sCOND PARAMS ((enum rtx_code, rtx));\n-extern void rs6000_emit_cbranch PARAMS ((enum rtx_code, rtx));\n-extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n-extern rtx rs6000_emit_set_const PARAMS ((rtx, enum machine_mode, rtx, int));\n-extern int rs6000_emit_cmove PARAMS ((rtx, rtx, rtx, rtx));\n-extern void rs6000_emit_minmax PARAMS ((rtx, enum rtx_code, rtx, rtx));\n-extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));\n-extern void rs6000_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-extern struct rtx_def *rs6000_longcall_ref PARAMS ((rtx));\n-extern void rs6000_fatal_bad_address PARAMS ((rtx));\n-extern int stmw_operation PARAMS ((rtx, enum machine_mode));\n-extern int mfcr_operation PARAMS ((rtx, enum machine_mode));\n-extern int mtcrf_operation PARAMS ((rtx, enum machine_mode));\n-extern int lmw_operation PARAMS ((rtx, enum machine_mode));\n-extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n+extern enum reg_class secondary_reload_class (enum reg_class,\n+\t\t\t\t\t\t      enum machine_mode, rtx);\n+extern int ccr_bit (rtx, int);\n+extern int extract_MB (rtx);\n+extern int extract_ME (rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void print_operand_address (FILE *, rtx);\n+extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n+\t\t\t\t\t\t       enum rtx_code);\n+extern void rs6000_emit_sCOND (enum rtx_code, rtx);\n+extern void rs6000_emit_cbranch (enum rtx_code, rtx);\n+extern char * output_cbranch (rtx, const char *, int, rtx);\n+extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n+extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n+extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);\n+extern void output_toc (FILE *, rtx, int, enum machine_mode);\n+extern void rs6000_initialize_trampoline (rtx, rtx, rtx);\n+extern struct rtx_def *rs6000_longcall_ref (rtx);\n+extern void rs6000_fatal_bad_address (rtx);\n+extern int stmw_operation (rtx, enum machine_mode);\n+extern int mfcr_operation (rtx, enum machine_mode);\n+extern int mtcrf_operation (rtx, enum machine_mode);\n+extern int lmw_operation (rtx, enum machine_mode);\n+extern struct rtx_def *create_TOC_reference (rtx);\n extern void rs6000_split_altivec_in_gprs (rtx *);\n-extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n-extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n-extern rtx rs6000_legitimize_reload_address PARAMS ((rtx, enum machine_mode,\n-\t\t\t    int, int, int, int *));\n-extern int rs6000_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n-extern bool rs6000_mode_dependent_address PARAMS ((rtx));\n-extern rtx rs6000_return_addr PARAMS ((int, rtx));\n-extern void rs6000_output_symbol_ref PARAMS ((FILE*, rtx));\n-\n-extern rtx rs6000_machopic_legitimize_pic_address PARAMS ((rtx orig, enum machine_mode mode, rtx reg));\n+extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n+extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n+extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n+\t\t\t    int, int, int, int *);\n+extern int rs6000_legitimate_address (enum machine_mode, rtx, int);\n+extern bool rs6000_mode_dependent_address (rtx);\n+extern rtx rs6000_return_addr (int, rtx);\n+extern void rs6000_output_symbol_ref (FILE*, rtx);\n+\n+extern rtx rs6000_machopic_legitimize_pic_address (rtx orig, \n+                            enum machine_mode mode, rtx reg);\n \n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t\t  tree, int));\n-extern int function_arg_boundary PARAMS ((enum machine_mode, tree));\n-extern struct rtx_def *function_arg PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode, tree, int));\n-extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode, tree, int));\n-extern int function_arg_pass_by_reference PARAMS ((CUMULATIVE_ARGS *,\n+extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t\t  tree, int);\n+extern int function_arg_boundary (enum machine_mode, tree);\n+extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n+\t\t\t\t\t     enum machine_mode, tree, int);\n+extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n+\t\t\t\t\t       enum machine_mode, tree, int);\n+extern int function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n \t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t   tree, int));\n-extern void setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *,\n+\t\t\t\t\t\t   tree, int);\n+extern void setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t\t    enum machine_mode, tree,\n-\t\t\t\t\t    int *, int));\n+\t\t\t\t\t    int *, int);\n extern rtx rs6000_function_value (tree, tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n-extern struct rtx_def *rs6000_va_arg PARAMS ((tree, tree));\n-extern int function_ok_for_sibcall PARAMS ((tree));\n-extern void rs6000_elf_declare_function_name\n-  PARAMS ((FILE *, const char *, tree));\n+extern struct rtx_def *rs6000_va_arg (tree, tree);\n+extern int function_ok_for_sibcall (tree);\n+extern void rs6000_elf_declare_function_name (FILE *, const char *, tree);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n+extern enum direction function_arg_padding (enum machine_mode, tree);\n #endif /* ARGS_SIZE_RTX */\n \n #endif /* TREE_CODE */\n \n-extern void optimization_options PARAMS ((int, int));\n-extern void rs6000_override_options PARAMS ((const char *));\n-extern int direct_return PARAMS ((void));\n-extern union tree_node *rs6000_build_va_list PARAMS ((void));\n-extern int first_reg_to_save PARAMS ((void));\n-extern int first_fp_reg_to_save PARAMS ((void));\n-extern rs6000_stack_t *rs6000_stack_info PARAMS ((void));\n-extern void output_ascii PARAMS ((FILE *, const char *, int));\n-extern void rs6000_gen_section_name PARAMS ((char **, const char *,\n-\t\t\t\t\t     const char *));\n-extern void output_function_profiler PARAMS ((FILE *, int));\n-extern void output_profile_hook  PARAMS ((int));\n-extern int rs6000_trampoline_size PARAMS ((void));\n-extern void toc_section PARAMS ((void));\n-extern void sdata_section PARAMS ((void));\n-extern void sdata2_section PARAMS ((void));\n-extern void sbss_section PARAMS ((void));\n-extern void private_data_section PARAMS ((void));\n-extern void read_only_data_section PARAMS ((void));\n-extern void read_only_private_data_section PARAMS ((void));\n-extern int get_TOC_alias_set PARAMS ((void));\n-extern int uses_TOC PARAMS ((void));\n-extern void rs6000_emit_prologue PARAMS ((void));\n-extern void rs6000_emit_load_toc_table PARAMS ((int));\n-extern void rs6000_aix_emit_builtin_unwind_init PARAMS ((void));\n-extern void rs6000_emit_epilogue PARAMS ((int));\n-extern void debug_stack_info PARAMS ((rs6000_stack_t *));\n-extern const char * output_isel PARAMS ((rtx *));\n-extern int vrsave_operation PARAMS ((rtx, enum machine_mode));\n-extern int rs6000_register_move_cost PARAMS ((enum machine_mode,\n-\t\t\t\t\t      enum reg_class, enum reg_class));\n-extern int rs6000_memory_move_cost PARAMS ((enum machine_mode,\n-\t\t\t\t\t    enum reg_class, int));\n-extern bool rs6000_tls_referenced_p PARAMS ((rtx));\n-extern int rs6000_tls_symbol_ref PARAMS ((rtx, enum machine_mode));\n+extern void optimization_options (int, int);\n+extern void rs6000_override_options (const char *);\n+extern int direct_return (void);\n+extern union tree_node *rs6000_build_va_list (void);\n+extern int first_reg_to_save (void);\n+extern int first_fp_reg_to_save (void);\n+extern rs6000_stack_t *rs6000_stack_info (void);\n+extern void output_ascii (FILE *, const char *, int);\n+extern void rs6000_gen_section_name (char **, const char *, const char *);\n+extern void output_function_profiler (FILE *, int);\n+extern void output_profile_hook  (int);\n+extern int rs6000_trampoline_size (void);\n+extern void toc_section (void);\n+extern void sdata_section (void);\n+extern void sdata2_section (void);\n+extern void sbss_section (void);\n+extern void private_data_section (void);\n+extern void read_only_data_section (void);\n+extern void read_only_private_data_section (void);\n+extern int get_TOC_alias_set (void);\n+extern int uses_TOC (void);\n+extern void rs6000_emit_prologue (void);\n+extern void rs6000_emit_load_toc_table (int);\n+extern void rs6000_aix_emit_builtin_unwind_init (void);\n+extern void rs6000_emit_epilogue (int);\n+extern void debug_stack_info (rs6000_stack_t *);\n+extern const char * output_isel (rtx *);\n+extern int vrsave_operation (rtx, enum machine_mode);\n+extern int rs6000_register_move_cost (enum machine_mode,\n+\t\t\t\t\t      enum reg_class, enum reg_class);\n+extern int rs6000_memory_move_cost (enum machine_mode, enum reg_class, int);\n+extern bool rs6000_tls_referenced_p (rtx);\n+extern int rs6000_tls_symbol_ref (rtx, enum machine_mode);\n \n /* Declare functions in rs6000-c.c */\n \n-extern void rs6000_pragma_longcall PARAMS ((struct cpp_reader *));\n-extern void rs6000_cpu_cpp_builtins PARAMS ((struct cpp_reader *));\n+extern void rs6000_pragma_longcall (struct cpp_reader *);\n+extern void rs6000_cpu_cpp_builtins (struct cpp_reader *);\n \n #endif  /* rs6000-protos.h */"}, {"sha": "ac2a17f31197dee6a082873c85106d714179a9ca", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 365, "deletions": 792, "changes": 1157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a2369ed310098b1f200e68cca7b14376912528d2", "patch": "@@ -198,129 +198,126 @@ struct builtin_description\n   const enum rs6000_builtins code;\n };\n \n-static bool rs6000_function_ok_for_sibcall PARAMS ((tree, tree));\n-static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n-static void validate_condition_mode \n-  PARAMS ((enum rtx_code, enum machine_mode));\n-static rtx rs6000_generate_compare PARAMS ((enum rtx_code));\n-static void rs6000_maybe_dead PARAMS ((rtx));\n-static void rs6000_emit_stack_tie PARAMS ((void));\n-static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n-static rtx spe_synthesize_frame_save PARAMS ((rtx));\n-static bool spe_func_has_64bit_regs_p PARAMS ((void));\n-static void emit_frame_save PARAMS ((rtx, rtx, enum machine_mode,\n-\t\t\t\t     unsigned int, int, int));\n-static rtx gen_frame_mem_offset PARAMS ((enum machine_mode, rtx, int));\n-static void rs6000_emit_allocate_stack PARAMS ((HOST_WIDE_INT, int));\n-static unsigned rs6000_hash_constant PARAMS ((rtx));\n-static unsigned toc_hash_function PARAMS ((const void *));\n-static int toc_hash_eq PARAMS ((const void *, const void *));\n-static int constant_pool_expr_1 PARAMS ((rtx, int *, int *));\n-static bool constant_pool_expr_p PARAMS ((rtx));\n-static bool toc_relative_expr_p PARAMS ((rtx));\n-static bool legitimate_small_data_p PARAMS ((enum machine_mode, rtx));\n-static bool legitimate_offset_address_p PARAMS ((enum machine_mode, rtx, int));\n-static bool legitimate_indexed_address_p PARAMS ((rtx, int));\n-static bool legitimate_indirect_address_p PARAMS ((rtx, int));\n-static bool legitimate_lo_sum_address_p PARAMS ((enum machine_mode, rtx, int));\n-static struct machine_function * rs6000_init_machine_status PARAMS ((void));\n-static bool rs6000_assemble_integer PARAMS ((rtx, unsigned int, int));\n+static bool rs6000_function_ok_for_sibcall (tree, tree);\n+static int num_insns_constant_wide (HOST_WIDE_INT);\n+static void validate_condition_mode (enum rtx_code, enum machine_mode);\n+static rtx rs6000_generate_compare (enum rtx_code);\n+static void rs6000_maybe_dead (rtx);\n+static void rs6000_emit_stack_tie (void);\n+static void rs6000_frame_related (rtx, rtx, HOST_WIDE_INT, rtx, rtx);\n+static rtx spe_synthesize_frame_save (rtx);\n+static bool spe_func_has_64bit_regs_p (void);\n+static void emit_frame_save (rtx, rtx, enum machine_mode,\n+\t\t\t\t     unsigned int, int, int);\n+static rtx gen_frame_mem_offset (enum machine_mode, rtx, int);\n+static void rs6000_emit_allocate_stack (HOST_WIDE_INT, int);\n+static unsigned rs6000_hash_constant (rtx);\n+static unsigned toc_hash_function (const void *);\n+static int toc_hash_eq (const void *, const void *);\n+static int constant_pool_expr_1 (rtx, int *, int *);\n+static bool constant_pool_expr_p (rtx);\n+static bool toc_relative_expr_p (rtx);\n+static bool legitimate_small_data_p (enum machine_mode, rtx);\n+static bool legitimate_offset_address_p (enum machine_mode, rtx, int);\n+static bool legitimate_indexed_address_p (rtx, int);\n+static bool legitimate_indirect_address_p (rtx, int);\n+static bool legitimate_lo_sum_address_p (enum machine_mode, rtx, int);\n+static struct machine_function * rs6000_init_machine_status (void);\n+static bool rs6000_assemble_integer (rtx, unsigned int, int);\n #ifdef HAVE_GAS_HIDDEN\n-static void rs6000_assemble_visibility PARAMS ((tree, int));\n+static void rs6000_assemble_visibility (tree, int);\n #endif\n-static int rs6000_ra_ever_killed PARAMS ((void));\n-static tree rs6000_handle_longcall_attribute PARAMS ((tree *, tree, tree, int, bool *));\n+static int rs6000_ra_ever_killed (void);\n+static tree rs6000_handle_longcall_attribute (tree *, tree, tree, int, bool *);\n extern const struct attribute_spec rs6000_attribute_table[];\n-static void rs6000_set_default_type_attributes PARAMS ((tree));\n-static void rs6000_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void rs6000_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void rs6000_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t    HOST_WIDE_INT, tree));\n-static rtx rs6000_emit_set_long_const PARAMS ((rtx,\n-  HOST_WIDE_INT, HOST_WIDE_INT));\n-static void rs6000_file_start PARAMS ((void));\n+static void rs6000_set_default_type_attributes (tree);\n+static void rs6000_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void rs6000_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void rs6000_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t\t    HOST_WIDE_INT, tree);\n+static rtx rs6000_emit_set_long_const (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+static void rs6000_file_start (void);\n #if TARGET_ELF\n-static unsigned int rs6000_elf_section_type_flags PARAMS ((tree, const char *,\n-\t\t\t\t\t\t\t   int));\n-static void rs6000_elf_asm_out_constructor PARAMS ((rtx, int));\n-static void rs6000_elf_asm_out_destructor PARAMS ((rtx, int));\n-static void rs6000_elf_select_section PARAMS ((tree, int,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT));\n-static void rs6000_elf_unique_section PARAMS ((tree, int));\n-static void rs6000_elf_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t   unsigned HOST_WIDE_INT));\n-static void rs6000_elf_encode_section_info PARAMS ((tree, rtx, int))\n+static unsigned int rs6000_elf_section_type_flags (tree, const char *, int);\n+static void rs6000_elf_asm_out_constructor (rtx, int);\n+static void rs6000_elf_asm_out_destructor (rtx, int);\n+static void rs6000_elf_select_section (tree, int, unsigned HOST_WIDE_INT);\n+static void rs6000_elf_unique_section (tree, int);\n+static void rs6000_elf_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t\t   unsigned HOST_WIDE_INT);\n+static void rs6000_elf_encode_section_info (tree, rtx, int))\n      ATTRIBUTE_UNUSED;\n-static bool rs6000_elf_in_small_data_p PARAMS ((tree));\n+static bool rs6000_elf_in_small_data_p (tree);\n #endif\n #if TARGET_XCOFF\n-static void rs6000_xcoff_asm_globalize_label PARAMS ((FILE *, const char *));\n-static void rs6000_xcoff_asm_named_section PARAMS ((const char *, unsigned int));\n-static void rs6000_xcoff_select_section PARAMS ((tree, int,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT));\n-static void rs6000_xcoff_unique_section PARAMS ((tree, int));\n-static void rs6000_xcoff_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-static const char * rs6000_xcoff_strip_name_encoding PARAMS ((const char *));\n-static unsigned int rs6000_xcoff_section_type_flags PARAMS ((tree, const char *, int));\n-static void rs6000_xcoff_file_start PARAMS ((void));\n-static void rs6000_xcoff_file_end PARAMS ((void));\n+static void rs6000_xcoff_asm_globalize_label (FILE *, const char *);\n+static void rs6000_xcoff_asm_named_section (const char *, unsigned int);\n+static void rs6000_xcoff_select_section (tree, int, unsigned HOST_WIDE_INT);\n+static void rs6000_xcoff_unique_section (tree, int);\n+static void rs6000_xcoff_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t\t     unsigned HOST_WIDE_INT);\n+static const char * rs6000_xcoff_strip_name_encoding (const char *);\n+static unsigned int rs6000_xcoff_section_type_flags (tree, const char *, int);\n+static void rs6000_xcoff_file_start (void);\n+static void rs6000_xcoff_file_end (void);\n #endif\n #if TARGET_MACHO\n-static bool rs6000_binds_local_p PARAMS ((tree));\n+static bool rs6000_binds_local_p (tree);\n #endif\n-static int rs6000_use_dfa_pipeline_interface PARAMS ((void));\n-static int rs6000_variable_issue PARAMS ((FILE *, int, rtx, int));\n-static bool rs6000_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int rs6000_adjust_priority PARAMS ((rtx, int));\n-static int rs6000_issue_rate PARAMS ((void));\n-static int rs6000_use_sched_lookahead PARAMS ((void));\n-\n-static void rs6000_init_builtins PARAMS ((void));\n-static rtx rs6000_expand_unop_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx rs6000_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx rs6000_expand_ternop_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx rs6000_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-static void altivec_init_builtins PARAMS ((void));\n-static void rs6000_common_init_builtins PARAMS ((void));\n-\n-static void enable_mask_for_builtins PARAMS ((struct builtin_description *,\n+static int rs6000_use_dfa_pipeline_interface (void);\n+static int rs6000_variable_issue (FILE *, int, rtx, int);\n+static bool rs6000_rtx_costs (rtx, int, int, int *);\n+static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n+static int rs6000_adjust_priority (rtx, int);\n+static int rs6000_issue_rate (void);\n+static int rs6000_use_sched_lookahead (void);\n+\n+static void rs6000_init_builtins (void);\n+static rtx rs6000_expand_unop_builtin (enum insn_code, tree, rtx);\n+static rtx rs6000_expand_binop_builtin (enum insn_code, tree, rtx);\n+static rtx rs6000_expand_ternop_builtin (enum insn_code, tree, rtx);\n+static rtx rs6000_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static void altivec_init_builtins (void);\n+static void rs6000_common_init_builtins (void);\n+\n+static void enable_mask_for_builtins (struct builtin_description *,\n \t\t\t\t\t      int, enum rs6000_builtins,\n-\t\t\t\t\t      enum rs6000_builtins));\n-static void spe_init_builtins PARAMS ((void));\n-static rtx spe_expand_builtin PARAMS ((tree, rtx, bool *));\n-static rtx spe_expand_predicate_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx spe_expand_evsel_builtin PARAMS ((enum insn_code, tree, rtx));\n-static int rs6000_emit_int_cmove PARAMS ((rtx, rtx, rtx, rtx));\n-\n-static rtx altivec_expand_builtin PARAMS ((tree, rtx, bool *));\n-static rtx altivec_expand_ld_builtin PARAMS ((tree, rtx, bool *));\n-static rtx altivec_expand_st_builtin PARAMS ((tree, rtx, bool *));\n-static rtx altivec_expand_dst_builtin PARAMS ((tree, rtx, bool *));\n-static rtx altivec_expand_abs_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx altivec_expand_predicate_builtin PARAMS ((enum insn_code, const char *, tree, rtx));\n-static rtx altivec_expand_stv_builtin PARAMS ((enum insn_code, tree));\n-static void rs6000_parse_abi_options PARAMS ((void));\n-static void rs6000_parse_alignment_option PARAMS ((void));\n-static void rs6000_parse_tls_size_option PARAMS ((void));\n+\t\t\t\t\t      enum rs6000_builtins);\n+static void spe_init_builtins (void);\n+static rtx spe_expand_builtin (tree, rtx, bool *);\n+static rtx spe_expand_predicate_builtin (enum insn_code, tree, rtx);\n+static rtx spe_expand_evsel_builtin (enum insn_code, tree, rtx);\n+static int rs6000_emit_int_cmove (rtx, rtx, rtx, rtx);\n+\n+static rtx altivec_expand_builtin (tree, rtx, bool *);\n+static rtx altivec_expand_ld_builtin (tree, rtx, bool *);\n+static rtx altivec_expand_st_builtin (tree, rtx, bool *);\n+static rtx altivec_expand_dst_builtin (tree, rtx, bool *);\n+static rtx altivec_expand_abs_builtin (enum insn_code, tree, rtx);\n+static rtx altivec_expand_predicate_builtin (enum insn_code, \n+\t\t\t\t\t    const char *, tree, rtx);\n+static rtx altivec_expand_stv_builtin (enum insn_code, tree);\n+static void rs6000_parse_abi_options (void);\n+static void rs6000_parse_alignment_option (void);\n+static void rs6000_parse_tls_size_option (void);\n static void rs6000_parse_yes_no_option (const char *, const char *, int *);\n-static int first_altivec_reg_to_save PARAMS ((void));\n-static unsigned int compute_vrsave_mask PARAMS ((void));\n-static void is_altivec_return_reg PARAMS ((rtx, void *));\n-static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *, int));\n-int easy_vector_constant PARAMS ((rtx, enum machine_mode));\n-static int easy_vector_same PARAMS ((rtx, enum machine_mode));\n-static bool is_ev64_opaque_type PARAMS ((tree));\n-static rtx rs6000_dwarf_register_span PARAMS ((rtx));\n-static rtx rs6000_legitimize_tls_address PARAMS ((rtx, enum tls_model));\n-static rtx rs6000_tls_get_addr PARAMS ((void));\n-static rtx rs6000_got_sym PARAMS ((void));\n-static inline int rs6000_tls_symbol_ref_1 PARAMS ((rtx *, void *));\n-static const char *rs6000_get_some_local_dynamic_name PARAMS ((void));\n-static int rs6000_get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n+static int first_altivec_reg_to_save (void);\n+static unsigned int compute_vrsave_mask (void);\n+static void is_altivec_return_reg (rtx, void *);\n+static rtx generate_set_vrsave (rtx, rs6000_stack_t *, int);\n+int easy_vector_constant (rtx, enum machine_mode);\n+static int easy_vector_same (rtx, enum machine_mode);\n+static bool is_ev64_opaque_type (tree);\n+static rtx rs6000_dwarf_register_span (rtx);\n+static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n+static rtx rs6000_tls_get_addr (void);\n+static rtx rs6000_got_sym (void);\n+static inline int rs6000_tls_symbol_ref_1 (rtx *, void *);\n+static const char *rs6000_get_some_local_dynamic_name (void);\n+static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n-static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree);\n+static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *, \n+\t\t\t\t    enum machine_mode, tree);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -501,8 +498,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n    type and sometimes adjust other TARGET_ options.  */\n \n void\n-rs6000_override_options (default_cpu)\n-     const char *default_cpu;\n+rs6000_override_options (const char *default_cpu);\n {\n   size_t i, j;\n   struct rs6000_cpu_select *ptr;\n@@ -941,9 +937,7 @@ rs6000_parse_tls_size_option ()\n }\n \n void\n-optimization_options (level, size)\n-     int level ATTRIBUTE_UNUSED;\n-     int size ATTRIBUTE_UNUSED;\n+optimization_options (int level ATTRIBUTE_UNUSED, int size ATTRIBUTE_UNUSED)\n {\n }\n \f\n@@ -1028,18 +1022,15 @@ direct_return ()\n /* Returns 1 always.  */\n \n int\n-any_operand (op, mode)\n-     rtx op ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+any_operand (rtx op ATTRIBUTE_UNUSED, \n+\t     enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n \n /* Returns 1 if op is the count register.  */\n int\n-count_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+count_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != REG)\n     return 0;\n@@ -1055,9 +1046,7 @@ count_register_operand (op, mode)\n \n /* Returns 1 if op is an altivec register.  */\n int\n-altivec_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+altivec_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   \n   return (register_operand (op, mode)\n@@ -1067,9 +1056,7 @@ altivec_register_operand (op, mode)\n }\n \n int\n-xer_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+xer_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != REG)\n     return 0;\n@@ -1084,9 +1071,7 @@ xer_operand (op, mode)\n    by such constants completes more quickly.  */\n \n int\n-s8bit_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+s8bit_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return ( GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) >= -128 && INTVAL (op) <= 127));\n@@ -1095,9 +1080,7 @@ s8bit_cint_operand (op, mode)\n /* Return 1 if OP is a constant that can fit in a D field.  */\n \n int\n-short_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && CONST_OK_FOR_LETTER_P (INTVAL (op), 'I'));\n@@ -1106,9 +1089,7 @@ short_cint_operand (op, mode)\n /* Similar for an unsigned D field.  */\n \n int\n-u_short_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+u_short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && CONST_OK_FOR_LETTER_P (INTVAL (op) & GET_MODE_MASK (mode), 'K'));\n@@ -1117,9 +1098,7 @@ u_short_cint_operand (op, mode)\n /* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */\n \n int\n-non_short_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+non_short_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) >= 0x10000);\n@@ -1129,9 +1108,7 @@ non_short_cint_operand (op, mode)\n    and an exact power of 2.  */\n \n int\n-exact_log2_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+exact_log2_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && INTVAL (op) > 0\n@@ -1142,9 +1119,7 @@ exact_log2_cint_operand (op, mode)\n    ctr, or lr).  */\n \n int\n-gpc_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+gpc_reg_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n@@ -1157,9 +1132,7 @@ gpc_reg_operand (op, mode)\n    CR field.  */\n \n int\n-cc_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cc_reg_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n@@ -1171,9 +1144,7 @@ cc_reg_operand (op, mode)\n    CR field that isn't CR0.  */\n \n int\n-cc_reg_not_cr0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+cc_reg_not_cr0_operand (rtx op, enum machine_mode mode)\n {\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n@@ -1186,9 +1157,7 @@ cc_reg_not_cr0_operand (op, mode)\n    mode unless MODE is VOIDmode.  */\n \n int\n-reg_or_short_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+reg_or_short_operand (rtx op, enum machine_mode mode)\n {\n   return short_cint_operand (op, mode) || gpc_reg_operand (op, mode);\n }\n@@ -1197,9 +1166,7 @@ reg_or_short_operand (op, mode)\n    valid for a D-field.  */\n \n int\n-reg_or_neg_short_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+reg_or_neg_short_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return CONST_OK_FOR_LETTER_P (INTVAL (op), 'P');\n@@ -1212,9 +1179,7 @@ reg_or_neg_short_operand (op, mode)\n    mode unless MODE is VOIDmode.  */\n \n int\n-reg_or_aligned_short_operand (op, mode)\n-      rtx op;\n-      enum machine_mode mode;\n+reg_or_aligned_short_operand (rtx op, enum machine_mode mode)\n {\n   if (gpc_reg_operand (op, mode))\n     return 1;\n@@ -1229,9 +1194,7 @@ reg_or_aligned_short_operand (op, mode)\n    high-order 16 bits are zero.  */\n \n int\n-reg_or_u_short_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_u_short_operand (rtx op, enum machine_mode mode)\n {\n   return u_short_cint_operand (op, mode) || gpc_reg_operand (op, mode);\n }\n@@ -1240,9 +1203,7 @@ reg_or_u_short_operand (op, mode)\n    constant integer.  */\n \n int\n-reg_or_cint_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+reg_or_cint_operand (rtx op, enum machine_mode mode)\n {\n   return (GET_CODE (op) == CONST_INT || gpc_reg_operand (op, mode));\n }\n@@ -1251,9 +1212,7 @@ reg_or_cint_operand (op, mode)\n    32-bit signed constant integer.  */\n \n int\n-reg_or_arith_cint_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+reg_or_arith_cint_operand (rtx op, enum machine_mode mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n@@ -1268,9 +1227,7 @@ reg_or_arith_cint_operand (op, mode)\n    signed constant integer valid for 64-bit addition.  */\n \n int\n-reg_or_add_cint64_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+reg_or_add_cint64_operand (rtx op, enum machine_mode mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n@@ -1287,9 +1244,7 @@ reg_or_add_cint64_operand (op, mode)\n    signed constant integer valid for 64-bit subtraction.  */\n \n int\n-reg_or_sub_cint64_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+reg_or_sub_cint64_operand (rtx op, enum machine_mode mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n@@ -1306,9 +1261,7 @@ reg_or_sub_cint64_operand (op, mode)\n    32-bit unsigned constant integer.  */\n \n int\n-reg_or_logical_cint_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+reg_or_logical_cint_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -1339,9 +1292,7 @@ reg_or_logical_cint_operand (op, mode)\n /* Return 1 if the operand is an operand that can be loaded via the GOT.  */\n \n int\n-got_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+got_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF\n \t  || GET_CODE (op) == CONST\n@@ -1352,9 +1303,7 @@ got_operand (op, mode)\n    the GOT (labels involving addition aren't allowed).  */\n \n int\n-got_no_const_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+got_no_const_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF);\n }\n@@ -1363,8 +1312,7 @@ got_no_const_operand (op, mode)\n    integer register.  */\n \n static int\n-num_insns_constant_wide (value)\n-     HOST_WIDE_INT value;\n+num_insns_constant_wide (HOST_WIDE_INT value)\n {\n   /* signed constant loadable with {cal|addi} */\n   if (CONST_OK_FOR_LETTER_P (value, 'I'))\n@@ -1398,9 +1346,7 @@ num_insns_constant_wide (value)\n }\n \n int\n-num_insns_constant (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+num_insns_constant (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -1477,9 +1423,7 @@ num_insns_constant (op, mode)\n    safely read CONST_DOUBLE_{LOW,HIGH}.  */\n \n int\n-easy_fp_constant (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+easy_fp_constant (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != CONST_DOUBLE\n       || GET_MODE (op) != mode\n@@ -1553,9 +1497,7 @@ easy_fp_constant (op, mode)\n /* Return nonzero if all elements of a vector have the same value.  */\n \n static int\n-easy_vector_same (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+easy_vector_same (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int units, i, cst;\n \n@@ -1574,9 +1516,7 @@ easy_vector_same (op, mode)\n    register without using memory.  */\n \n int\n-easy_vector_constant (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+easy_vector_constant (rtx op, enum machine_mode mode)\n {\n   int cst, cst2;\n \n@@ -1625,9 +1565,7 @@ easy_vector_constant (op, mode)\n /* Same as easy_vector_constant but only for EASY_VECTOR_15_ADD_SELF.  */\n \n int\n-easy_vector_constant_add_self (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+easy_vector_constant_add_self (rtx op, enum machine_mode mode)\n {\n   int cst;\n \n@@ -1640,8 +1578,7 @@ easy_vector_constant_add_self (op, mode)\n }\n \n const char *\n-output_vec_const_move (operands)\n-     rtx *operands;\n+output_vec_const_move (rtx *operands)\n {\n   int cst, cst2;\n   enum machine_mode mode;\n@@ -1701,18 +1638,14 @@ output_vec_const_move (operands)\n /* Return 1 if the operand is the constant 0.  This works for scalars\n    as well as vectors.  */\n int\n-zero_constant (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+zero_constant (rtx op, enum machine_mode mode)\n {\n   return op == CONST0_RTX (mode);\n }\n \n /* Return 1 if the operand is 0.0.  */\n int\n-zero_fp_constant (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+zero_fp_constant (rtx op, enum machine_mode mode)\n {\n   return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n }\n@@ -1723,9 +1656,7 @@ zero_fp_constant (op, mode)\n    recognize volatile references where its safe.  */\n \n int\n-volatile_mem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+volatile_mem_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != MEM)\n     return 0;\n@@ -1748,9 +1679,7 @@ volatile_mem_operand (op, mode)\n /* Return 1 if the operand is an offsettable memory operand.  */\n \n int\n-offsettable_mem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+offsettable_mem_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == MEM)\n \t  && offsettable_address_p (reload_completed || reload_in_progress,\n@@ -1761,9 +1690,7 @@ offsettable_mem_operand (op, mode)\n    memory.  */\n \n int\n-mem_or_easy_const_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mem_or_easy_const_operand (rtx op, enum machine_mode mode)\n {\n   return memory_operand (op, mode) || easy_fp_constant (op, mode);\n }\n@@ -1772,9 +1699,7 @@ mem_or_easy_const_operand (op, mode)\n    that can be used as the operand of a `mode' add insn.  */\n \n int\n-add_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+add_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     return (CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n@@ -1786,9 +1711,7 @@ add_operand (op, mode)\n /* Return 1 if OP is a constant but not a valid add_operand.  */\n \n int\n-non_add_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+non_add_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && !CONST_OK_FOR_LETTER_P (INTVAL (op), 'I')\n@@ -1799,9 +1722,7 @@ non_add_cint_operand (op, mode)\n    can be used as the operand of an OR or XOR insn on the RS/6000.  */\n \n int\n-logical_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+logical_operand (rtx op, enum machine_mode mode)\n {\n   HOST_WIDE_INT opl, oph;\n \n@@ -1838,9 +1759,7 @@ logical_operand (op, mode)\n    above), but could be split into one.  */\n \n int\n-non_logical_cint_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+non_logical_cint_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n \t  && ! logical_operand (op, mode)\n@@ -1853,9 +1772,7 @@ non_logical_cint_operand (op, mode)\n    away and confuse the making of MB and ME.  */\n \n int\n-mask_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mask_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT c, lsb;\n \n@@ -1897,9 +1814,7 @@ mask_operand (op, mode)\n /* Return 1 for the PowerPC64 rlwinm corner case.  */\n \n int\n-mask_operand_wrap (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mask_operand_wrap (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT c, lsb;\n \n@@ -1928,9 +1843,7 @@ mask_operand_wrap (op, mode)\n    confuses the making of MB and ME.  */\n \n int\n-mask64_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mask64_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -1961,9 +1874,7 @@ mask64_operand (op, mode)\n    rldicr machine insns.  */\n \n int\n-mask64_2_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mask64_2_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n@@ -2010,9 +1921,7 @@ mask64_2_operand (op, mode)\n /* Generates shifts and masks for a pair of rldicl or rldicr insns to\n    implement ANDing by the mask IN.  */\n void\n-build_mask64_2_operands (in, out)\n-     rtx in;\n-     rtx *out;\n+build_mask64_2_operands (rtx in, rtx *out)\n {\n #if HOST_BITS_PER_WIDE_INT >= 64\n   unsigned HOST_WIDE_INT c, lsb, m1, m2;\n@@ -2083,9 +1992,7 @@ build_mask64_2_operands (in, out)\n    that can be used as the operand of a PowerPC64 logical AND insn.  */\n \n int\n-and64_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+and64_operand (rtx op, enum machine_mode mode)\n {\n   if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n     return (gpc_reg_operand (op, mode) || mask64_operand (op, mode));\n@@ -2097,9 +2004,7 @@ and64_operand (op, mode)\n    with two rldicl or rldicr insns.  */\n \n int\n-and64_2_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+and64_2_operand (rtx op, enum machine_mode mode)\n {\n   if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis. */\n     return gpc_reg_operand (op, mode) || mask64_2_operand (op, mode);\n@@ -2111,9 +2016,7 @@ and64_2_operand (op, mode)\n    constant that can be used as the operand of an RS/6000 logical AND insn.  */\n \n int\n-and_operand (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+and_operand (rtx op, enum machine_mode mode)\n {\n   if (fixed_regs[CR0_REGNO])\t/* CR0 not available, don't do andi./andis.  */\n     return (gpc_reg_operand (op, mode) || mask_operand (op, mode));\n@@ -2124,9 +2027,7 @@ and_operand (op, mode)\n /* Return 1 if the operand is a general register or memory operand.  */\n \n int\n-reg_or_mem_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+reg_or_mem_operand (rtx op, enum machine_mode mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || memory_operand (op, mode)\n@@ -2138,9 +2039,7 @@ reg_or_mem_operand (op, mode)\n    instruction.  */\n \n int\n-lwa_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+lwa_operand (rtx op, enum machine_mode mode)\n {\n   rtx inner = op;\n \n@@ -2159,9 +2058,7 @@ lwa_operand (op, mode)\n /* Return 1 if the operand, used inside a MEM, is a SYMBOL_REF.  */\n \n int\n-symbol_ref_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+symbol_ref_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n@@ -2174,9 +2071,7 @@ symbol_ref_operand (op, mode)\n    to CALL.  This is a SYMBOL_REF, a pseudo-register, LR or CTR.  */\n \n int\n-call_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+call_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n@@ -2192,9 +2087,8 @@ call_operand (op, mode)\n    this file.  */\n \n int\n-current_file_function_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+current_file_function_operand (rtx op, \n+                              enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF\n \t  && (DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\n@@ -2205,9 +2099,7 @@ current_file_function_operand (op, mode)\n /* Return 1 if this operand is a valid input for a move insn.  */\n \n int\n-input_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+input_operand (rtx op, enum machine_mode mode)\n {\n   /* Memory is always valid.  */\n   if (memory_operand (op, mode))\n@@ -2267,9 +2159,8 @@ input_operand (op, mode)\n /* Return 1 for an operand in small memory on V.4/eabi.  */\n \n int\n-small_data_operand (op, mode)\n-     rtx op ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+small_data_operand (rtx op ATTRIBUTE_UNUSED, \n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n #if TARGET_ELF\n   rtx sym_ref;\n@@ -2327,10 +2218,7 @@ altivec_in_gprs_p (rtx op0, rtx op1)\n /* Subroutines of rs6000_legitimize_address and rs6000_legitimate_address.  */\n \n static int \n-constant_pool_expr_1 (op, have_sym, have_toc) \n-    rtx op;\n-    int *have_sym;\n-    int *have_toc;\n+constant_pool_expr_1 (rtx op, int *have_sym, int *have_toc) \n {\n   switch (GET_CODE(op)) \n     {\n@@ -2368,17 +2256,15 @@ constant_pool_expr_1 (op, have_sym, have_toc)\n }\n \n static bool\n-constant_pool_expr_p (op)\n-    rtx op;\n+constant_pool_expr_p (rtx op)\n {\n   int have_sym = 0;\n   int have_toc = 0;\n   return constant_pool_expr_1 (op, &have_sym, &have_toc) && have_sym;\n }\n \n static bool\n-toc_relative_expr_p (op)\n-    rtx op;\n+toc_relative_expr_p (rtx op)\n {\n   int have_sym = 0;\n   int have_toc = 0;\n@@ -2389,8 +2275,7 @@ toc_relative_expr_p (op)\n #define SPE_CONST_OFFSET_OK(x) (((x) & ~0xf8) == 0)\n \n bool\n-legitimate_constant_pool_address_p (x)\n-     rtx x;\n+legitimate_constant_pool_address_p (rtx x)\n {\n   return (TARGET_TOC\n \t  && GET_CODE (x) == PLUS\n@@ -2400,9 +2285,7 @@ legitimate_constant_pool_address_p (x)\n }\n \n static bool\n-legitimate_small_data_p (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+legitimate_small_data_p (enum machine_mode mode, rtx x)\n {\n   return (DEFAULT_ABI == ABI_V4\n \t  && !flag_pic && !TARGET_TOC\n@@ -2411,10 +2294,7 @@ legitimate_small_data_p (mode, x)\n }\n \n static bool\n-legitimate_offset_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   unsigned HOST_WIDE_INT offset, extra;\n \n@@ -2473,9 +2353,7 @@ legitimate_offset_address_p (mode, x, strict)\n }\n \n static bool\n-legitimate_indexed_address_p (x, strict)\n-     rtx x;\n-     int strict;\n+legitimate_indexed_address_p (rtx x, int strict)\n {\n   rtx op0, op1;\n \n@@ -2494,18 +2372,13 @@ legitimate_indexed_address_p (x, strict)\n }\n \n static inline bool\n-legitimate_indirect_address_p (x, strict)\n-     rtx x;\n-     int strict;\n+legitimate_indirect_address_p (rtx x, int strict)\n {\n   return GET_CODE (x) == REG && INT_REG_OK_FOR_BASE_P (x, strict);\n }\n \n static bool\n-legitimate_lo_sum_address_p (mode, x, strict)\n-     enum machine_mode mode;\n-     rtx x;\n-     int strict;\n+legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n {\n   if (GET_CODE (x) != LO_SUM)\n     return false;\n@@ -2558,10 +2431,8 @@ legitimate_lo_sum_address_p (mode, x, strict)\n    load the other things into a register and return the sum.  */\n \n rtx\n-rs6000_legitimize_address (x, oldx, mode)\n-     rtx x;\n-     rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n+rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode)\n {\n   if (GET_CODE (x) == SYMBOL_REF)\n     {\n@@ -2702,9 +2573,7 @@ rs6000_got_sym ()\n    this (thread-local) address.  */\n \n static rtx\n-rs6000_legitimize_tls_address (addr, model)\n-     rtx addr;\n-     enum tls_model model;\n+rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n {\n   rtx dest, insn;\n \n@@ -2890,18 +2759,15 @@ rs6000_legitimize_tls_address (addr, model)\n    instruction definitions.  */\n \n int\n-rs6000_tls_symbol_ref (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+rs6000_tls_symbol_ref (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return RS6000_SYMBOL_REF_TLS_P (x);\n }\n \n /* Return 1 if X contains a thread-local symbol.  */\n \n bool\n-rs6000_tls_referenced_p (x)\n-     rtx x;\n+rs6000_tls_referenced_p (rtx x)\n {\n   return for_each_rtx (&x, &rs6000_tls_symbol_ref_1, 0);\n }\n@@ -2910,9 +2776,7 @@ rs6000_tls_referenced_p (x)\n    rs6000_tls_symbol_ref except for the type of the unused argument.  */\n \n static inline int\n-rs6000_tls_symbol_ref_1 (x, data)\n-     rtx *x;\n-     void *data ATTRIBUTE_UNUSED;\n+rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n {\n   return RS6000_SYMBOL_REF_TLS_P (*x);\n }\n@@ -2938,13 +2802,8 @@ rs6000_tls_symbol_ref_1 (x, data)\n    The Darwin code is inside #if TARGET_MACHO because only then is\n    machopic_function_base_name() defined.  */\n rtx\n-rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n-    rtx x;\n-    enum machine_mode mode;\n-    int opnum;\n-    int type;\n-    int ind_levels ATTRIBUTE_UNUSED;\n-    int *win;\n+rs6000_legitimize_reload_address (rtx x, enum machine_mode mode, \n+\tint opnum, int type, int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n   /* We must recognize output that we have already generated ourselves.  */ \n   if (GET_CODE (x) == PLUS\n@@ -3080,10 +2939,7 @@ rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n    adjacent memory cells are accessed by adding word-sized offsets\n    during assembly output.  */\n int\n-rs6000_legitimate_address (mode, x, reg_ok_strict)\n-    enum machine_mode mode;\n-    rtx x;\n-    int reg_ok_strict;\n+rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n {\n   if (RS6000_SYMBOL_REF_TLS_P (x))\n     return 0;\n@@ -3132,8 +2988,7 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n    sub-words of a TFmode operand, which is what we had before.  */\n \n bool\n-rs6000_mode_dependent_address (addr)\n-     rtx addr;\n+rs6000_mode_dependent_address (rtx addr)\n {\n   switch (GET_CODE (addr))\n     {\n@@ -3166,10 +3021,8 @@ rs6000_mode_dependent_address (addr)\n    insns, zero is returned and no insns and emitted.  */\n \n rtx\n-rs6000_emit_set_const (dest, mode, source, n)\n-     rtx dest, source;\n-     enum machine_mode mode;\n-     int n ATTRIBUTE_UNUSED;\n+rs6000_emit_set_const (rtx dest, enum machine_mode mode, \n+\t\t       rtx source, int n ATTRIBUTE_UNUSED)\n {\n   rtx result, insn, set;\n   HOST_WIDE_INT c0, c1;\n@@ -3231,9 +3084,7 @@ rs6000_emit_set_const (dest, mode, source, n)\n    exponential run times encountered when looking for longer sequences\n    with rs6000_emit_set_const.  */\n static rtx\n-rs6000_emit_set_long_const (dest, c1, c2)\n-     rtx dest;\n-     HOST_WIDE_INT c1, c2;\n+rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n {\n   if (!TARGET_POWERPC64)\n     {\n@@ -3317,10 +3168,7 @@ rs6000_emit_set_long_const (dest, c1, c2)\n \n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n-rs6000_emit_move (dest, source, mode)\n-     rtx dest;\n-     rtx source;\n-     enum machine_mode mode;\n+rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n {\n   rtx operands[2];\n   operands[0] = dest;\n@@ -3669,12 +3517,8 @@ rs6000_emit_move (dest, source, mode)\n    so we never return a PARALLEL.  */\n \n void\n-init_cumulative_args (cum, fntype, libname, incoming, libcall)\n-     CUMULATIVE_ARGS *cum;\n-     tree fntype;\n-     rtx libname ATTRIBUTE_UNUSED;\n-     int incoming;\n-     int libcall;\n+init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype, \n+\trtx libname ATTRIBUTE_UNUSED, int incoming, int libcall)\n {\n   static CUMULATIVE_ARGS zero_cumulative;\n \n@@ -3736,9 +3580,7 @@ init_cumulative_args (cum, fntype, libname, incoming, libcall)\n    argument slot.  */\n \n enum direction\n-function_arg_padding (mode, type)\n-     enum machine_mode mode;\n-     tree type;\n+function_arg_padding (enum machine_mode mode, tree type)\n {\n #ifndef AGGREGATE_PADDING_FIXED\n #define AGGREGATE_PADDING_FIXED 0\n@@ -3799,9 +3641,7 @@ function_arg_padding (mode, type)\n    V.4 wants long longs to be double word aligned.  */\n \n int\n-function_arg_boundary (mode, type)\n-     enum machine_mode mode;\n-     tree type ATTRIBUTE_UNUSED;\n+function_arg_boundary (enum machine_mode mode, tree type ATTRIBUTE_UNUSED)\n {\n   if (DEFAULT_ABI == ABI_V4 && (mode == DImode || mode == DFmode))\n     return 64;\n@@ -3818,11 +3658,8 @@ function_arg_boundary (mode, type)\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n void\n-function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t\t      tree type, int named)\n {\n   cum->nargs_prototype--;\n \n@@ -3917,7 +3754,8 @@ function_arg_advance (cum, mode, type, named)\n \n /* Determine where to put a SIMD argument on the SPE.  */\n static rtx\n-rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type)\n+rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t\t\t tree type)\n {\n   if (cum->stdarg)\n     {\n@@ -3975,11 +3813,8 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type\n    doesn't support PARALLEL anyway.  */\n \n struct rtx_def *\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t      tree type, int named)\n {\n   enum rs6000_abi abi = DEFAULT_ABI;\n \n@@ -4102,11 +3937,8 @@ function_arg (cum, mode, type, named)\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t\t\t    tree type, int named ATTRIBUTE_UNUSED)\n {\n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n@@ -4143,11 +3975,9 @@ function_arg_partial_nregs (cum, mode, type, named)\n    reference.  */\n \n int\n-function_arg_pass_by_reference (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED, \n+\t\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED, \n+'\t\t\t\ttree type, int named ATTRIBUTE_UNUSED)\n {\n   if (DEFAULT_ABI == ABI_V4\n       && ((type && AGGREGATE_TYPE_P (type))\n@@ -4176,13 +4006,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n void\n-setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int *pretend_size ATTRIBUTE_UNUSED;\n-     int no_rtl;\n-\n+setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n+\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS next_cum;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n@@ -4318,9 +4143,7 @@ rs6000_build_va_list ()\n /* Implement va_start.  */\n \n void\n-rs6000_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+rs6000_va_start (tree valist, rtx nextarg)\n {\n   HOST_WIDE_INT words, n_gpr, n_fpr;\n   tree f_gpr, f_fpr, f_res, f_ovf, f_sav;\n@@ -4384,8 +4207,7 @@ rs6000_va_start (valist, nextarg)\n /* Implement va_arg.  */\n \n rtx\n-rs6000_va_arg (valist, type)\n-     tree valist, type;\n+rs6000_va_arg (tree valist, tree type)\n {\n   tree f_gpr, f_fpr, f_res, f_ovf, f_sav;\n   tree gpr, fpr, ovf, sav, reg, t, u;\n@@ -5016,10 +4838,7 @@ static struct builtin_description bdesc_1arg[] =\n };\n \n static rtx\n-rs6000_expand_unop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+rs6000_expand_unop_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   tree arg0 = TREE_VALUE (arglist);\n@@ -5068,10 +4887,7 @@ rs6000_expand_unop_builtin (icode, arglist, target)\n }\n \n static rtx\n-altivec_expand_abs_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+altivec_expand_abs_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat, scratch1, scratch2;\n   tree arg0 = TREE_VALUE (arglist);\n@@ -5103,10 +4919,7 @@ altivec_expand_abs_builtin (icode, arglist, target)\n }\n \n static rtx\n-rs6000_expand_binop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+rs6000_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   tree arg0 = TREE_VALUE (arglist);\n@@ -5178,11 +4991,8 @@ rs6000_expand_binop_builtin (icode, arglist, target)\n }\n \n static rtx\n-altivec_expand_predicate_builtin (icode, opcode, arglist, target)\n-     enum insn_code icode;\n-     const char *opcode;\n-     tree arglist;\n-     rtx target;\n+altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode, \n+\t\t\t\t  tree arglist, rtx target)\n {\n   rtx pat, scratch;\n   tree cr6_form = TREE_VALUE (arglist);\n@@ -5259,9 +5069,7 @@ altivec_expand_predicate_builtin (icode, opcode, arglist, target)\n }\n \n static rtx\n-altivec_expand_stv_builtin (icode, arglist)\n-     enum insn_code icode;\n-     tree arglist;\n+altivec_expand_stv_builtin (enum insn_code icode, tree arglist)\n {\n   tree arg0 = TREE_VALUE (arglist);\n   tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n@@ -5294,10 +5102,7 @@ altivec_expand_stv_builtin (icode, arglist)\n }\n \n static rtx\n-rs6000_expand_ternop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+rs6000_expand_ternop_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat;\n   tree arg0 = TREE_VALUE (arglist);\n@@ -5357,10 +5162,7 @@ rs6000_expand_ternop_builtin (icode, arglist, target)\n \n /* Expand the lvx builtins.  */\n static rtx\n-altivec_expand_ld_builtin (exp, target, expandedp)\n-     tree exp;\n-     rtx target;\n-     bool *expandedp;\n+altivec_expand_ld_builtin (tree exp, rtx target, bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5413,10 +5215,8 @@ altivec_expand_ld_builtin (exp, target, expandedp)\n \n /* Expand the stvx builtins.  */\n static rtx\n-altivec_expand_st_builtin (exp, target, expandedp)\n-     tree exp;\n-     rtx target ATTRIBUTE_UNUSED;\n-     bool *expandedp;\n+altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED, \n+\t\t\t   bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5467,10 +5267,8 @@ altivec_expand_st_builtin (exp, target, expandedp)\n \n /* Expand the dst builtins.  */\n static rtx\n-altivec_expand_dst_builtin (exp, target, expandedp)\n-     tree exp;\n-     rtx target ATTRIBUTE_UNUSED;\n-     bool *expandedp;\n+altivec_expand_dst_builtin (tree exp, rtx target ATTRIBUTE_UNUSED, \n+\t\t\t    bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5530,10 +5328,7 @@ altivec_expand_dst_builtin (exp, target, expandedp)\n /* Expand the builtin in EXP and store the result in TARGET.  Store\n    true in *EXPANDEDP if we found a builtin to expand.  */\n static rtx\n-altivec_expand_builtin (exp, target, expandedp)\n-     tree exp;\n-     rtx target;\n-     bool *expandedp;\n+altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n {\n   struct builtin_description *d;\n   struct builtin_description_predicates *dp;\n@@ -5713,10 +5508,7 @@ static struct builtin_description bdesc_2arg_spe[] =\n    This expands the SPE builtins that are not simple unary and binary\n    operations.  */\n static rtx\n-spe_expand_builtin (exp, target, expandedp)\n-     tree exp;\n-     rtx target;\n-     bool *expandedp;\n+spe_expand_builtin (tree exp, rtx target, bool *expandedp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -5849,10 +5641,7 @@ spe_expand_builtin (exp, target, expandedp)\n }\n \n static rtx\n-spe_expand_predicate_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+spe_expand_predicate_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat, scratch, tmp;\n   tree form = TREE_VALUE (arglist);\n@@ -5961,10 +5750,7 @@ spe_expand_predicate_builtin (icode, arglist, target)\n */\n \n static rtx\n-spe_expand_evsel_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n+spe_expand_evsel_builtin (enum insn_code icode, tree arglist, rtx target)\n {\n   rtx pat, scratch;\n   tree arg0 = TREE_VALUE (arglist);\n@@ -6021,12 +5807,9 @@ spe_expand_evsel_builtin (icode, arglist, target)\n    IGNORE is nonzero if the value is to be ignored.  */\n \n static rtx\n-rs6000_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore ATTRIBUTE_UNUSED;\n+rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t      enum machine_mode mode ATTRIBUTE_UNUSED, \n+\t\t      int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -6097,10 +5880,9 @@ rs6000_init_builtins ()\n    START is the builtin enum at which to start.\n    END is the builtin enum at which to end.  */\n static void\n-enable_mask_for_builtins (desc, size, start, end)\n-     struct builtin_description *desc;\n-     int size;\n-     enum rs6000_builtins start, end;\n+enable_mask_for_builtins (struct builtin_description *desc, int size,\n+\t\t\t  enum rs6000_builtins start, \n+\t\t\t  enum rs6000_builtins end)\n {\n   int i;\n \n@@ -7009,8 +6791,7 @@ rs6000_common_init_builtins ()\n #define MAX_MOVE_REG 4\n \n int\n-expand_block_move (operands)\n-     rtx operands[];\n+expand_block_move (rtx operands[])\n {\n   rtx orig_dest = operands[0];\n   rtx orig_src\t= operands[1];\n@@ -7046,8 +6827,8 @@ expand_block_move (operands)\n   for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n     {\n       union {\n-\trtx (*movstrsi) PARAMS ((rtx, rtx, rtx, rtx));\n-\trtx (*mov) PARAMS ((rtx, rtx));\n+\trtx (*movstrsi) (rtx, rtx, rtx, rtx);\n+\trtx (*mov) (rtx, rtx);\n       } gen_func;\n       enum machine_mode mode = BLKmode;\n       rtx src, dest;\n@@ -7177,9 +6958,7 @@ expand_block_move (operands)\n    PARALLEL and the first section will be tested.  */\n \n int\n-load_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int dest_regno;\n@@ -7220,9 +6999,7 @@ load_multiple_operation (op, mode)\n    is a CLOBBER.  It will be tested later.  */\n \n int\n-store_multiple_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0) - 1;\n   unsigned int src_regno;\n@@ -7265,8 +7042,7 @@ store_multiple_operation (op, mode)\n    operands[2] is the first destination register.  */\n \n const char *\n-rs6000_output_load_multiple (operands)\n-     rtx operands[3];\n+rs6000_output_load_multiple (rtx operands[3])\n {\n   /* We have to handle the case where the pseudo used to contain the address\n      is assigned to one of the output registers.  */\n@@ -7320,9 +7096,7 @@ rs6000_output_load_multiple (operands)\n /* Return 1 for a parallel vrsave operation.  */\n \n int\n-vrsave_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+vrsave_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int dest_regno, src_regno;\n@@ -7356,9 +7130,7 @@ vrsave_operation (op, mode)\n /* Return 1 for an PARALLEL suitable for mfcr.  */\n \n int\n-mfcr_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mfcr_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   int i;\n@@ -7406,9 +7178,7 @@ mfcr_operation (op, mode)\n /* Return 1 for an PARALLEL suitable for mtcrf.  */\n \n int\n-mtcrf_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mtcrf_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   int i;\n@@ -7455,9 +7225,7 @@ mtcrf_operation (op, mode)\n /* Return 1 for an PARALLEL suitable for lmw.  */\n \n int\n-lmw_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+lmw_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int dest_regno;\n@@ -7533,9 +7301,7 @@ lmw_operation (op, mode)\n /* Return 1 for an PARALLEL suitable for stmw.  */\n \n int\n-stmw_operation (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+stmw_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   int count = XVECLEN (op, 0);\n   unsigned int src_regno;\n@@ -7613,9 +7379,7 @@ stmw_operation (op, mode)\n    never be generated.  */\n \n static void\n-validate_condition_mode (code, mode)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n+validate_condition_mode (enum rtx_code code, enum machine_mode mode)\n {\n   if (GET_RTX_CLASS (code) != '<' \n       || GET_MODE_CLASS (mode) != MODE_CC)\n@@ -7656,9 +7420,7 @@ validate_condition_mode (code, mode)\n    We only check the opcode against the mode of the CC value here.  */\n \n int\n-branch_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+branch_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n   enum machine_mode cc_mode;\n@@ -7680,13 +7442,11 @@ branch_comparison_operator (op, mode)\n    is set.  */\n \n int\n-branch_positive_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+branch_positive_comparison_operator (rtx op, enum machine_mode mode)\n {\n   enum rtx_code code;\n \n-  if (! branch_comparison_operator (op, mode))\n+  if (! branch_comparison_operator (rtx op, enum machine_mode mode))\n     return 0;\n \n   code = GET_CODE (op);\n@@ -7700,45 +7460,35 @@ branch_positive_comparison_operator (op, mode)\n    insn: it must be a positive comparison.  */\n \n int\n-scc_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+scc_comparison_operator (rtx op, enum machine_mode mode)\n {\n   return branch_positive_comparison_operator (op, mode);\n }\n \n int\n-trap_comparison_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode;\n+trap_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n   return GET_RTX_CLASS (GET_CODE (op)) == '<';\n }\n \n int\n-boolean_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+boolean_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n   return (code == AND || code == IOR || code == XOR);\n }\n \n int\n-boolean_or_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+boolean_or_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n   return (code == IOR || code == XOR);\n }\n \n int\n-min_max_operator (op, mode)\n-    rtx op;\n-    enum machine_mode mode ATTRIBUTE_UNUSED;\n+min_max_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n   return (code == SMIN || code == SMAX || code == UMIN || code == UMAX);\n@@ -7749,9 +7499,7 @@ min_max_operator (op, mode)\n    left insn of SHIFTOP bits.  Both are known to be SImode CONST_INT.  */\n \n int\n-includes_lshift_p (shiftop, andop)\n-     rtx shiftop;\n-     rtx andop;\n+includes_lshift_p (rtx shiftop, rtx andop)\n {\n   unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n \n@@ -7763,9 +7511,7 @@ includes_lshift_p (shiftop, andop)\n /* Similar, but for right shift.  */\n \n int\n-includes_rshift_p (shiftop, andop)\n-     rtx shiftop;\n-     rtx andop;\n+includes_rshift_p (rtx shiftop, rtx andop)\n {\n   unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n \n@@ -7779,9 +7525,7 @@ includes_rshift_p (shiftop, andop)\n    significant 0's, then one or more 1's, then zero or more 0's.  */\n \n int\n-includes_rldic_lshift_p (shiftop, andop)\n-     rtx shiftop;\n-     rtx andop;\n+includes_rldic_lshift_p (rtx shiftop, rtx andop)\n {\n   if (GET_CODE (andop) == CONST_INT)\n     {\n@@ -7874,9 +7618,7 @@ includes_rldic_lshift_p (shiftop, andop)\n    significant 0's, with the remainder of the word 1's.  */\n \n int\n-includes_rldicr_lshift_p (shiftop, andop)\n-     rtx shiftop;\n-     rtx andop;\n+includes_rldicr_lshift_p (rtx shiftop, rtx andop)\n {\n   if (GET_CODE (andop) == CONST_INT)\n     {\n@@ -7948,8 +7690,7 @@ includes_rldicr_lshift_p (shiftop, andop)\n    abort if we are passed pseudo registers.  */\n \n int\n-registers_ok_for_quad_peep (reg1, reg2)\n-     rtx reg1, reg2;\n+registers_ok_for_quad_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n@@ -7963,9 +7704,7 @@ registers_ok_for_quad_peep (reg1, reg2)\n    (addr2 == addr1 + 8).  */\n \n int\n-addrs_ok_for_quad_peep (addr1, addr2)\n-     rtx addr1;\n-     rtx addr2;\n+addrs_ok_for_quad_peep (rtx addr1, rtx addr2)\n {\n   unsigned int reg1;\n   int offset1;\n@@ -7994,9 +7733,9 @@ addrs_ok_for_quad_peep (addr1, addr2)\n       offset1 = 0;\n     }\n \n-/* Make sure the second address is a (mem (plus (reg) (const_int)))\n-    or if it is (mem (reg)) then make sure that offset1 is -8 and the same \n-    register as addr1.  */\n+  /* Make sure the second address is a (mem (plus (reg) (const_int)))\n+      or if it is (mem (reg)) then make sure that offset1 is -8 and the same \n+      register as addr1.  */\n   if (offset1 == -8 && GET_CODE (addr2) == REG && reg1 == REGNO (addr2))\n    return 1;\n   if (GET_CODE (addr2) != PLUS)\n@@ -8023,10 +7762,8 @@ addrs_ok_for_quad_peep (addr1, addr2)\n    NO_REGS is returned.  */\n \n enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx in;\n+secondary_reload_class (enum reg_class class, \n+\t\tenum machine_mode mode ATTRIBUTE_UNUSED, rtx in)\n {\n   int regno;\n \n@@ -8104,9 +7841,7 @@ secondary_reload_class (class, mode, in)\n    Return -1 if OP isn't a valid comparison for some reason.  */\n \n int\n-ccr_bit (op, scc_p)\n-     rtx op;\n-     int scc_p;\n+ccr_bit (rtx op, int scc_p)\n {\n   enum rtx_code code = GET_CODE (op);\n   enum machine_mode cc_mode;\n@@ -8171,8 +7906,7 @@ ccr_bit (op, scc_p)\n /* Return the GOT register.  */\n \n struct rtx_def *\n-rs6000_got_register (value)\n-     rtx value ATTRIBUTE_UNUSED;\n+rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n {\n   /* The second flow pass currently (June 1999) can't update\n      regs_ever_live without disturbing other parts of the compiler, so\n@@ -8204,8 +7938,7 @@ rs6000_init_machine_status ()\n   (GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))\n \n int\n-extract_MB (op)\n-     rtx op;\n+extract_MB (rtx op)\n {\n   int i;\n   unsigned long val = INT_LOWPART (op);\n@@ -8238,8 +7971,7 @@ extract_MB (op)\n }\n \n int\n-extract_ME (op)\n-     rtx op;\n+extract_ME (rtx op)\n {\n   int i;\n   unsigned long val = INT_LOWPART (op);\n@@ -8295,9 +8027,7 @@ rs6000_get_some_local_dynamic_name ()\n /* Helper function for rs6000_get_some_local_dynamic_name.  */\n \n static int\n-rs6000_get_some_local_dynamic_name_1 (px, data)\n-     rtx *px;\n-     void *data ATTRIBUTE_UNUSED;\n+rs6000_get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n {\n   rtx x = *px;\n \n@@ -8325,10 +8055,7 @@ rs6000_get_some_local_dynamic_name_1 (px, data)\n #endif\n \n void\n-print_operand (file, x, code)\n-    FILE *file;\n-    rtx x;\n-    int code;\n+print_operand (FILE *file, rtx x, int code)\n {\n   int i;\n   HOST_WIDE_INT val;\n@@ -8946,9 +8673,7 @@ print_operand (file, x, code)\n /* Print the address of an operand.  */\n \n void\n-print_operand_address (file, x)\n-     FILE *file;\n-     rtx x;\n+print_operand_address (FILE *file, rtx x)\n {\n   if (GET_CODE (x) == REG)\n     fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n@@ -9037,16 +8762,13 @@ print_operand_address (file, x)\n    targets.  */\n \n static bool\n-rs6000_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+rs6000_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n #ifdef RELOCATABLE_NEEDS_FIXUP\n   /* Special handling for SI values.  */\n   if (size == 4 && aligned_p)\n     {\n-      extern int in_toc_section PARAMS ((void));\n+      extern int in_toc_section (void);\n       static int recurse = 0;\n       \n       /* For -mrelocatable, we mark all addresses that need to be fixed up\n@@ -9100,9 +8822,7 @@ rs6000_assemble_integer (x, size, aligned_p)\n    VISIBILITY_TYPE.  */\n \n static void\n-rs6000_assemble_visibility (decl, vis)\n-     tree decl;\n-     int vis;\n+rs6000_assemble_visibility (tree decl, int vis)\n {\n   /* Functions need to have their entry point symbol visibility set as\n      well as their descriptor symbol visibility.  */\n@@ -9127,9 +8847,7 @@ rs6000_assemble_visibility (decl, vis)\n #endif\n \f\n enum rtx_code\n-rs6000_reverse_condition (mode, code)\n-     enum machine_mode mode;\n-     enum rtx_code code;\n+rs6000_reverse_condition (enum machine_mode mode, enum rtx_code code)\n {\n   /* Reversal of FP compares takes care -- an ordered compare\n      becomes an unordered compare and vice versa.  */\n@@ -9146,8 +8864,7 @@ rs6000_reverse_condition (mode, code)\n    represents the result of the compare.  */\n \n static rtx\n-rs6000_generate_compare (code)\n-     enum rtx_code code;\n+rs6000_generate_compare (enum rtx_code code)\n {\n   enum machine_mode comp_mode;\n   rtx compare_result;\n@@ -9331,9 +9048,7 @@ rs6000_generate_compare (code)\n /* Emit the RTL for an sCOND pattern.  */\n \n void\n-rs6000_emit_sCOND (code, result)\n-     enum rtx_code code;\n-     rtx result;\n+rs6000_emit_sCOND (enum rtx_code code, rtx result)\n {\n   rtx condition_rtx;\n   enum machine_mode op_mode;\n@@ -9379,9 +9094,7 @@ rs6000_emit_sCOND (code, result)\n /* Emit a branch of kind CODE to location LOC.  */\n \n void\n-rs6000_emit_cbranch (code, loc)\n-     enum rtx_code code;\n-     rtx loc;\n+rs6000_emit_cbranch (enum rtx_code code, rtx loc)\n {\n   rtx condition_rtx, loc_ref;\n \n@@ -9405,11 +9118,7 @@ rs6000_emit_cbranch (code, loc)\n    INSN is the insn.  */\n \n char *\n-output_cbranch (op, label, reversed, insn)\n-     rtx op;\n-     const char * label;\n-     int reversed;\n-     rtx insn;\n+output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n {\n   static char string[64];\n   enum rtx_code code = GET_CODE (op);\n@@ -9531,11 +9240,7 @@ output_cbranch (op, label, reversed, insn)\n    is zero/false.  Return 0 if the hardware has no such operation.  */\n \n int\n-rs6000_emit_cmove (dest, op, true_cond, false_cond)\n-     rtx dest;\n-     rtx op;\n-     rtx true_cond;\n-     rtx false_cond;\n+rs6000_emit_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   enum rtx_code code = GET_CODE (op);\n   rtx op0 = rs6000_compare_op0;\n@@ -9700,11 +9405,7 @@ rs6000_emit_cmove (dest, op, true_cond, false_cond)\n /* Same as above, but for ints (isel).  */\n \n static int\n-rs6000_emit_int_cmove (dest, op, true_cond, false_cond)\n-     rtx dest;\n-     rtx op;\n-     rtx true_cond;\n-     rtx false_cond;\n+rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   rtx condition_rtx, cr;\n \n@@ -9729,8 +9430,7 @@ rs6000_emit_int_cmove (dest, op, true_cond, false_cond)\n }\n \n const char *\n-output_isel (operands)\n-     rtx *operands;\n+output_isel (rtx *operands)\n {\n   enum rtx_code code;\n \n@@ -9745,11 +9445,7 @@ output_isel (operands)\n }\n \n void\n-rs6000_emit_minmax (dest, code, op0, op1)\n-     rtx dest;\n-     enum rtx_code code;\n-     rtx op0;\n-     rtx op1;\n+rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n {\n   enum machine_mode mode = GET_MODE (op0);\n   enum rtx_code c;\n@@ -9950,9 +9646,7 @@ compute_vrsave_mask ()\n }\n \n static void\n-is_altivec_return_reg (reg, xyes)\n-     rtx reg;\n-     void *xyes;\n+is_altivec_return_reg (rtx reg, void *xyes)\n {\n   bool *yes = (bool *) xyes;\n   if (REGNO (reg) == ALTIVEC_ARG_RETURN)\n@@ -10397,8 +10091,7 @@ spe_func_has_64bit_regs_p ()\n }\n \n void\n-debug_stack_info (info)\n-     rs6000_stack_t *info;\n+debug_stack_info (rs6000_stack_t *info)\n {\n   const char *abi_string;\n \n@@ -10542,9 +10235,7 @@ debug_stack_info (info)\n }\n \n rtx\n-rs6000_return_addr (count, frame)\n-     int count;\n-     rtx frame;\n+rs6000_return_addr (int count, rtx frame)\n {\n   /* Currently we don't optimize very well between prolog and body\n      code and for PIC code the code can be actually quite bad, so\n@@ -10576,9 +10267,7 @@ rs6000_return_addr (count, frame)\n    type info must be available here.  (The tail recursion case can work\n    with vector parameters, but there's no way to distinguish here.) */\n static bool\n-rs6000_function_ok_for_sibcall (decl, exp)\n-    tree decl;\n-    tree exp ATTRIBUTE_UNUSED;\n+rs6000_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   tree type;\n   if (decl)\n@@ -10659,8 +10348,7 @@ rs6000_ra_ever_killed ()\n \f\n /* Add a REG_MAYBE_DEAD note to the insn.  */\n static void\n-rs6000_maybe_dead (insn)\n-     rtx insn;\n+rs6000_maybe_dead (rtx insn)\n {\n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n \t\t\t\t\tconst0_rtx,\n@@ -10672,8 +10360,7 @@ rs6000_maybe_dead (insn)\n    a constant pool; or for SVR4 -fpic.  */\n \n void\n-rs6000_emit_load_toc_table (fromprolog)\n-     int fromprolog;\n+rs6000_emit_load_toc_table (int fromprolog)\n {\n   rtx dest, insn;\n   dest = gen_rtx_REG (Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n@@ -10813,8 +10500,7 @@ uses_TOC ()\n }\n \n rtx\n-create_TOC_reference (symbol) \n-    rtx symbol;\n+create_TOC_reference (rtx symbol) \n {\n   return gen_rtx_PLUS (Pmode, \n \t   gen_rtx_REG (Pmode, TOC_REGISTER),\n@@ -10876,9 +10562,7 @@ rs6000_emit_stack_tie ()\n    The generated code may use hard register 0 as a temporary.  */\n \n static void\n-rs6000_emit_allocate_stack (size, copy_r12)\n-     HOST_WIDE_INT size;\n-     int copy_r12;\n+rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n {\n   rtx insn;\n   rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n@@ -10966,12 +10650,8 @@ rs6000_emit_allocate_stack (size, copy_r12)\n    its hand so much.  */\n \n static void\n-rs6000_frame_related (insn, reg, val, reg2, rreg)\n-     rtx insn;\n-     rtx reg;\n-     HOST_WIDE_INT val;\n-     rtx reg2;\n-     rtx rreg;\n+rs6000_frame_related (rtx insn, rtx reg, HOST_WIDE_INT val, \n+\t\t      rtx reg2, rtx rreg)\n {\n   rtx real, temp;\n \n@@ -11053,8 +10733,7 @@ rs6000_frame_related (insn, reg, val, reg2, rreg)\n    original note, plus a synthetic register save.  */\n \n static rtx\n-spe_synthesize_frame_save (real)\n-     rtx real;\n+spe_synthesize_frame_save (rtx real)\n {\n   rtx synth, offset, reg, real2;\n \n@@ -11117,10 +10796,7 @@ spe_synthesize_frame_save (real)\n    appropriate CLOBBERs.  */\n \n static rtx\n-generate_set_vrsave (reg, info, epiloguep)\n-     rtx reg;\n-     rs6000_stack_t *info;\n-     int epiloguep;\n+generate_set_vrsave (rtx reg, rs6000_stack_t *info, int epiloguep)\n {\n   int nclobs, i;\n   rtx insn, clobs[TOTAL_ALTIVEC_REGS + 1];\n@@ -11179,13 +10855,8 @@ generate_set_vrsave (reg, info, epiloguep)\n    Save REGNO into [FRAME_REG + OFFSET] in mode MODE.  */\n \n static void\n-emit_frame_save (frame_reg, frame_ptr, mode, regno, offset, total_size)\n-     rtx frame_reg;\n-     rtx frame_ptr;\n-     enum machine_mode mode;\n-     unsigned int regno;\n-     int offset;\n-     int total_size;\n+emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode, \n+\t\t unsigned int regno, int offset, int total_size)\n {\n   rtx reg, offset_rtx, insn, mem, addr, int_rtx;\n   rtx replacea, replaceb;\n@@ -11227,10 +10898,7 @@ emit_frame_save (frame_reg, frame_ptr, mode, regno, offset, total_size)\n    converting to a valid addressing mode.  */\n \n static rtx\n-gen_frame_mem_offset (mode, reg, offset)\n-     enum machine_mode mode;\n-     rtx reg;\n-     int offset;\n+gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n {\n   rtx int_rtx, offset_rtx;\n \n@@ -11642,9 +11310,8 @@ rs6000_emit_prologue ()\n /* Write function prologue.  */\n \n static void\n-rs6000_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+rs6000_output_function_prologue (FILE *file, \n+\t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n \n@@ -11710,8 +11377,7 @@ rs6000_output_function_prologue (file, size)\n    need special notes to explain where r11 is in relation to the stack.  */\n \n void\n-rs6000_emit_epilogue (sibcall)\n-     int sibcall;\n+rs6000_emit_epilogue (int sibcall)\n {\n   rs6000_stack_t *info;\n   int restoring_FPRs_inline;\n@@ -12091,9 +11757,8 @@ rs6000_emit_epilogue (sibcall)\n /* Write function epilogue.  */\n \n static void\n-rs6000_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+rs6000_output_function_epilogue (FILE *file, \n+\t\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n \n@@ -12412,12 +12077,9 @@ rs6000_output_function_epilogue (file, size)\n    not support varargs.  */\n \n static void\n-rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset;\n-     tree function;\n+rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED, \n+\t\t\tHOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset, \n+\t\t\ttree function)\n {\n   rtx this, insn, funexp;\n \n@@ -12544,8 +12206,7 @@ rs6000_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n /* Hash functions for the hash table.  */\n \n static unsigned\n-rs6000_hash_constant (k)\n-     rtx k;\n+rs6000_hash_constant (rtx k)\n {\n   enum rtx_code code = GET_CODE (k);\n   enum machine_mode mode = GET_MODE (k);\n@@ -12618,8 +12279,7 @@ rs6000_hash_constant (k)\n }\n \n static unsigned\n-toc_hash_function (hash_entry)\n-     const void * hash_entry;\n+toc_hash_function (const void *hash_entry)\n {\n   const struct toc_hash_struct *thc = \n     (const struct toc_hash_struct *) hash_entry;\n@@ -12629,9 +12289,7 @@ toc_hash_function (hash_entry)\n /* Compare H1 and H2 for equivalence.  */\n \n static int\n-toc_hash_eq (h1, h2)\n-     const void * h1;\n-     const void * h2;\n+toc_hash_eq (const void *h1, const void *h2)\n {\n   rtx r1 = ((const struct toc_hash_struct *) h1)->key;\n   rtx r2 = ((const struct toc_hash_struct *) h2)->key;\n@@ -12655,9 +12313,7 @@ toc_hash_eq (h1, h2)\n   || strncmp (\"_ZTC\", name, strlen (\"_ZTC\")) == 0) \n \n void\n-rs6000_output_symbol_ref (file, x)\n-     FILE *file;\n-     rtx x;\n+rs6000_output_symbol_ref (FILE *file, rtx x)\n {\n   /* Currently C++ toc references to vtables can be emitted before it\n      is decided whether the vtable is public or private.  If this is\n@@ -12679,11 +12335,7 @@ rs6000_output_symbol_ref (file, x)\n    written.  */\n \n void\n-output_toc (file, x, labelno, mode)\n-     FILE *file;\n-     rtx x;\n-     int labelno;\n-     enum machine_mode mode;\n+output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n {\n   char buf[256];\n   const char *name = buf;\n@@ -12983,10 +12635,7 @@ output_toc (file, x, labelno, mode)\n    so we must artificially break them up early.  */\n \n void\n-output_ascii (file, p, n)\n-     FILE *file;\n-     const char *p;\n-     int n;\n+output_ascii (FILE *file, const char *p, int n)\n {\n   char c;\n   int i, count_string;\n@@ -13057,10 +12706,8 @@ output_ascii (file, p, n)\n    the name.  */\n \n void\n-rs6000_gen_section_name (buf, filename, section_desc)\n-     char **buf;\n-     const char *filename;\n-     const char *section_desc;\n+rs6000_gen_section_name (char **buf, const char *filename, \n+\t\t         const char *section_desc)\n {\n   const char *q, *after_last_slash, *last_period = 0;\n   char *p;\n@@ -13103,8 +12750,7 @@ rs6000_gen_section_name (buf, filename, section_desc)\n /* Emit profile function.  */\n \n void\n-output_profile_hook (labelno)\n-     int labelno ATTRIBUTE_UNUSED;\n+output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n {\n   if (TARGET_PROFILE_KERNEL)\n     return;\n@@ -13157,9 +12803,7 @@ output_profile_hook (labelno)\n /* Write function profiler code.  */\n \n void\n-output_function_profiler (file, labelno)\n-  FILE *file;\n-  int labelno;\n+output_function_profiler (FILE *file, int labelno)\n {\n   char buf[100];\n   int save_lr = 8;\n@@ -13261,11 +12905,9 @@ rs6000_use_dfa_pipeline_interface ()\n    instructions to issue in this cycle.  */\n \n static int\n-rs6000_variable_issue (stream, verbose, insn, more)\n-  FILE *stream ATTRIBUTE_UNUSED;\n-  int verbose ATTRIBUTE_UNUSED;\n-  rtx insn;\n-  int more;\n+rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED, \n+\t\t       int verbose ATTRIBUTE_UNUSED, \n+\t\t       rtx insn, int more)\n {\n   if (GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n@@ -13296,11 +12938,8 @@ rs6000_variable_issue (stream, verbose, insn, more)\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n \n static int\n-rs6000_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link;\n-     rtx dep_insn ATTRIBUTE_UNUSED;\n-     int cost;\n+rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn ATTRIBUTE_UNUSED, \n+\t\t    int cost)\n {\n   if (! recog_memoized (insn))\n     return 0;\n@@ -13360,9 +12999,7 @@ rs6000_adjust_cost (insn, link, dep_insn, cost)\n    priorities of insns.  */\n \n static int\n-rs6000_adjust_priority (insn, priority)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int priority;\n+rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n {\n   /* On machines (like the 750) which have asymmetric integer units,\n      where one integer unit can do multiply and divides and the other\n@@ -13472,10 +13109,7 @@ rs6000_trampoline_size ()\n    CXT is an RTX for the static chain value for the function.  */\n \n void\n-rs6000_initialize_trampoline (addr, fnaddr, cxt)\n-     rtx addr;\n-     rtx fnaddr;\n-     rtx cxt;\n+rs6000_initialize_trampoline (rtx addr, rtx fnaddr, rtx cxt)\n {\n   enum machine_mode pmode = Pmode;\n   int regsize = (TARGET_32BIT) ? 4 : 8;\n@@ -13534,12 +13168,10 @@ const struct attribute_spec rs6000_attribute_table[] =\n    struct attribute_spec.handler.  */\n \n static tree\n-rs6000_handle_longcall_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+rs6000_handle_longcall_attribute (tree *node, tree name, \n+\t\t\t\t  tree args ATTRIBUTE_UNUSED, \n+\t\t\t\t  int flags ATTRIBUTE_UNUSED, \n+\t\t\t\t  bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_TYPE\n       && TREE_CODE (*node) != FIELD_DECL\n@@ -13556,8 +13188,7 @@ rs6000_handle_longcall_attribute (node, name, args, flags, no_add_attrs)\n /* Set longcall attributes on all functions declared when\n    rs6000_default_long_calls is true.  */\n static void\n-rs6000_set_default_type_attributes (type)\n-     tree type;\n+rs6000_set_default_type_attributes (tree type)\n {\n   if (rs6000_default_long_calls\n       && (TREE_CODE (type) == FUNCTION_TYPE\n@@ -13571,8 +13202,7 @@ rs6000_set_default_type_attributes (type)\n    longcall attribute.  */\n \n struct rtx_def *\n-rs6000_longcall_ref (call_ref)\n-     rtx call_ref;\n+rs6000_longcall_ref (rtx call_ref)\n {\n   const char *call_name;\n   tree node;\n@@ -13606,10 +13236,8 @@ rs6000_longcall_ref (call_ref)\n    data section.  */\n \n static void\n-rs6000_elf_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align;\n+rs6000_elf_select_rtx_section (enum machine_mode mode, rtx x, \n+\t\t\t       unsigned HOST_WIDE_INT align)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n     toc_section ();\n@@ -13623,10 +13251,8 @@ rs6000_elf_select_rtx_section (mode, x, align)\n    the initial value of DECL requires link-time relocations.  */\n \n static void\n-rs6000_elf_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align;\n+rs6000_elf_select_section (tree decl, int reloc, \n+\t\t\t   unsigned HOST_WIDE_INT align)\n {\n   /* Pretend that we're always building for a shared library when\n      ABI_AIX, because otherwise we end up with dynamic relocations\n@@ -13645,9 +13271,7 @@ rs6000_elf_select_section (decl, reloc, align)\n    initialized data and functions.  */\n \n static void\n-rs6000_elf_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc;\n+rs6000_elf_unique_section (tree decl, int reloc)\n {\n   /* As above, pretend that we're always building for a shared library\n      when ABI_AIX, to avoid dynamic relocations in read-only sections.  */\n@@ -13664,10 +13288,7 @@ rs6000_elf_unique_section (decl, reloc)\n    read the prefixes.  */\n \n static void\n-rs6000_elf_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+rs6000_elf_encode_section_info (tree decl, rtx rtl, int first)\n {\n   default_encode_section_info (decl, rtl, first);\n \n@@ -13686,8 +13307,7 @@ rs6000_elf_encode_section_info (decl, rtl, first)\n }\n \n static bool\n-rs6000_elf_in_small_data_p (decl)\n-     tree decl;\n+rs6000_elf_in_small_data_p (tree decl)\n {\n   if (rs6000_sdata == SDATA_NONE)\n     return false;\n@@ -13729,8 +13349,7 @@ rs6000_elf_in_small_data_p (decl)\n    increment the returned register via an \"la\" instruction.  */\n \n struct rtx_def *\n-find_addr_reg (addr)\n-     rtx addr;\n+find_addr_reg (rtx addr)\n {\n   while (GET_CODE (addr) == PLUS)\n     {\n@@ -13753,8 +13372,7 @@ find_addr_reg (addr)\n }\n \n void\n-rs6000_fatal_bad_address (op)\n-  rtx op;\n+rs6000_fatal_bad_address (rtx op)\n {\n   fatal_insn (\"bad address\", op);\n }\n@@ -13766,8 +13384,7 @@ rs6000_fatal_bad_address (op)\n    reference and a constant.  */\n \n int\n-symbolic_operand (op)\n-     rtx op;\n+symbolic_operand (rtx op)\n {\n   switch (GET_CODE (op))\n     {\n@@ -13794,10 +13411,7 @@ static tree stub_list = 0;\n    procedure calls to the linked list.  */\n \n void \n-add_compiler_stub (label_name, function_name, line_number)\n-     tree label_name;\n-     tree function_name;\n-     int line_number;\n+add_compiler_stub (tree label_name, tree function_name, int line_number)\n {\n   tree stub = build_tree_list (function_name, label_name);\n   TREE_TYPE (stub) = build_int_2 (line_number, 0);\n@@ -13861,8 +13475,7 @@ output_compiler_stub ()\n    already there or not.  */\n \n int\n-no_previous_def (function_name)\n-     tree function_name;\n+no_previous_def (tree function_name)\n {\n   tree stub;\n   for (stub = stub_list; stub; stub = TREE_CHAIN (stub))\n@@ -13875,8 +13488,7 @@ no_previous_def (function_name)\n    the function.  */\n \n tree\n-get_prev_label (function_name)\n-     tree function_name;\n+get_prev_label (tree function_name)\n {\n   tree stub;\n   for (stub = stub_list; stub; stub = TREE_CHAIN (stub))\n@@ -13891,10 +13503,7 @@ get_prev_label (function_name)\n    CALL_DEST is the routine we are calling.  */\n \n char *\n-output_call (insn, call_dest, operand_number)\n-     rtx insn;\n-     rtx call_dest;\n-     int operand_number;\n+output_call (rtx insn, rtx call_dest, int operand_number)\n {\n   static char buf[256];\n   if (GET_CODE (call_dest) == SYMBOL_REF && TARGET_LONG_BRANCH && !flag_pic)\n@@ -13954,9 +13563,7 @@ output_call (insn, call_dest, operand_number)\n /* Generate PIC and indirect symbol stubs.  */\n \n void\n-machopic_output_stub (file, symb, stub)\n-     FILE *file;\n-     const char *symb, *stub;\n+machopic_output_stub (FILE *file, const char *symb, const char *stub)\n {\n   unsigned int length;\n   char *symbol_name, *lazy_ptr_name;\n@@ -14022,10 +13629,8 @@ machopic_output_stub (file, symb, stub)\n #define SMALL_INT(X) ((unsigned) (INTVAL(X) + 0x8000) < 0x10000)\n \n rtx\n-rs6000_machopic_legitimize_pic_address (orig, mode, reg)\n-     rtx orig;\n-     enum machine_mode mode;\n-     rtx reg;\n+rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, \n+\t\t\t\t\trtx reg)\n {\n   rtx base, offset;\n \n@@ -14083,10 +13688,7 @@ toc_section ()\n \n #if TARGET_ELF\n static unsigned int\n-rs6000_elf_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+rs6000_elf_section_type_flags (tree decl, const char *name, int reloc)\n {\n   unsigned int flags\n     = default_section_type_flags_1 (decl, name, reloc,\n@@ -14106,9 +13708,7 @@ rs6000_elf_section_type_flags (decl, name, reloc)\n    that we have special handling for -mrelocatable.  */\n \n static void\n-rs6000_elf_asm_out_constructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+rs6000_elf_asm_out_constructor (rtx symbol, int priority)\n {\n   const char *section = \".ctors\";\n   char buf[16];\n@@ -14137,9 +13737,7 @@ rs6000_elf_asm_out_constructor (symbol, priority)\n }\n \n static void\n-rs6000_elf_asm_out_destructor (symbol, priority)\n-     rtx symbol;\n-     int priority;\n+rs6000_elf_asm_out_destructor (rtx symbol, int priority)\n {\n   const char *section = \".dtors\";\n   char buf[16];\n@@ -14168,10 +13766,7 @@ rs6000_elf_asm_out_destructor (symbol, priority)\n }\n \n void\n-rs6000_elf_declare_function_name (file, name, decl)\n-     FILE *file;\n-     const char *name;\n-     tree decl;\n+rs6000_elf_declare_function_name (FILE *file, const char *name, tree decl)\n {\n   if (TARGET_64BIT)\n     {\n@@ -14243,19 +13838,15 @@ rs6000_elf_declare_function_name (file, name, decl)\n \n #if TARGET_XCOFF\n static void\n-rs6000_xcoff_asm_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n+rs6000_xcoff_asm_globalize_label (FILE *stream, const char *name)\n {\n   fputs (GLOBAL_ASM_OP, stream);\n   RS6000_OUTPUT_BASENAME (stream, name);\n   putc ('\\n', stream);\n }\n \n static void\n-rs6000_xcoff_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n+rs6000_xcoff_asm_named_section (const char *name, unsigned int flags)\n {\n   int smclass;\n   static const char * const suffix[3] = { \"PR\", \"RO\", \"RW\" };\n@@ -14273,10 +13864,8 @@ rs6000_xcoff_asm_named_section (name, flags)\n }\n \n static void\n-rs6000_xcoff_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+rs6000_xcoff_select_section (tree decl, int reloc, \n+\t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (decl_readonly_section_1 (decl, reloc, 1))\n     {\n@@ -14295,9 +13884,7 @@ rs6000_xcoff_select_section (decl, reloc, align)\n }\n \n static void\n-rs6000_xcoff_unique_section (decl, reloc)\n-     tree decl;\n-     int reloc ATTRIBUTE_UNUSED;\n+rs6000_xcoff_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n {\n   const char *name;\n \n@@ -14322,10 +13909,8 @@ rs6000_xcoff_unique_section (decl, reloc)\n    toc entry.  */\n \n static void\n-rs6000_xcoff_select_rtx_section (mode, x, align)\n-     enum machine_mode mode;\n-     rtx x;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n+rs6000_xcoff_select_rtx_section (enum machine_mode mode, rtx x, \n+\t\t\t\tunsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n     toc_section ();\n@@ -14336,8 +13921,7 @@ rs6000_xcoff_select_rtx_section (mode, x, align)\n /* Remove any trailing [DS] or the like from the symbol name.  */\n \n static const char *\n-rs6000_xcoff_strip_name_encoding (name)\n-     const char *name;\n+rs6000_xcoff_strip_name_encoding (const char *name)\n {\n   size_t len;\n   if (*name == '*')\n@@ -14352,10 +13936,7 @@ rs6000_xcoff_strip_name_encoding (name)\n /* Section attributes.  AIX is always PIC.  */\n \n static unsigned int\n-rs6000_xcoff_section_type_flags (decl, name, reloc)\n-     tree decl;\n-     const char *name;\n-     int reloc;\n+rs6000_xcoff_section_type_flags (tree decl, const char *name, int reloc)\n {\n   unsigned int align;\n   unsigned int flags = default_section_type_flags_1 (decl, name, reloc, 1);\n@@ -14426,8 +14007,7 @@ rs6000_xcoff_file_end ()\n    functions at dynamic-link time.  */\n \n static bool\n-rs6000_binds_local_p (decl)\n-     tree decl;\n+rs6000_binds_local_p (tree decl)\n {\n   return default_binds_local_p_1 (decl, 0);\n }\n@@ -14438,10 +14018,8 @@ rs6000_binds_local_p (decl)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-rs6000_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n+rs6000_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, \n+\t\t  int *total)\n {\n   switch (code)\n     {\n@@ -14662,9 +14240,8 @@ rs6000_rtx_costs (x, code, outer_code, total)\n    CLASS1 to one of CLASS2.  */\n \n int\n-rs6000_register_move_cost (mode, from, to)\n-     enum machine_mode mode;\n-     enum reg_class from, to;\n+rs6000_register_move_cost (enum machine_mode mode, \n+\t\t\t   enum reg_class from, enum reg_class to)\n {\n   /*  Moves from/to GENERAL_REGS.  */\n   if (reg_classes_intersect_p (to, GENERAL_REGS)\n@@ -14700,10 +14277,8 @@ rs6000_register_move_cost (mode, from, to)\n    or from memory.  */\n \n int\n-rs6000_memory_move_cost (mode, class, in)\n-  enum machine_mode mode;\n-  enum reg_class class;\n-  int in ATTRIBUTE_UNUSED;\n+rs6000_memory_move_cost (enum machine_mode mode, enum reg_class class, \n+\t\t\t int in ATTRIBUTE_UNUSED)\n {\n   if (reg_classes_intersect_p (class, GENERAL_REGS))\n     return 4 * HARD_REGNO_NREGS (0, mode);\n@@ -14803,8 +14378,7 @@ rs6000_libcall_value (enum machine_mode mode)\n /* Return true if TYPE is of type __ev64_opaque__.  */\n \n static bool\n-is_ev64_opaque_type (type)\n-     tree type;\n+is_ev64_opaque_type (tree type)\n {\n   return (TARGET_SPE\n \t  && (type == opaque_V2SI_type_node\n@@ -14813,8 +14387,7 @@ is_ev64_opaque_type (type)\n }\n \n static rtx\n-rs6000_dwarf_register_span (reg)\n-     rtx reg;\n+rs6000_dwarf_register_span (rtx reg)\n {\n   unsigned regno;\n "}, {"sha": "39174effe0c00e1fc46e0de7a20cbc15e82e9f1f", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2369ed310098b1f200e68cca7b14376912528d2/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=a2369ed310098b1f200e68cca7b14376912528d2", "patch": "@@ -494,7 +494,7 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-extern int in_toc_section PARAMS ((void));\t\t\t\t\\\n+extern int in_toc_section (void);\t\t\t\t\t\\\n int in_toc_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   return in_section == in_toc;\t\t\t\t\t\t\\"}]}