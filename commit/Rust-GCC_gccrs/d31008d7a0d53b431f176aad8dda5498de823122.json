{"sha": "d31008d7a0d53b431f176aad8dda5498de823122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMxMDA4ZDdhMGQ1M2I0MzFmMTc2YWFkOGRkYTU0OThkZTgyMzEyMg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-12-03T19:47:00Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-12-03T19:47:00Z"}, "message": "re PR libstdc++/13631 (Problems in messages)\n\n2014-12-03  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/13631\n\t* include/bits/codecvt.h (codecvt<char, char, mbstate_t>): friend class\n\tstd::messages<char>.\n\t(codecvt<wchar_t, char, mbstate_t>): friend class\n\tstd::messages<wchar_t>.\n\t* config/locale/gnu/messages_member.h\n\t(messages<char>::do_open): Specialized.\n\t(messages<char>::do_close): Likewise.\n\t(messages<wchar_t>::do_open): Likewise.\n\t(messages<wchar_t>::do_close): Likewise.\n\t* config/locale/gnu/messages_member.cc:\n\t(messages<char>::do_open): Implement. Use bind_textdomain_codeset based\n\ton codecvt<char, char, mbstate_t>._M_c_locale_codecvt code set. Use\n\tinternal cache to keep opened domain name with locale information.\n\t(messages<wchar_t>::do_open): Likewise with\n\tcodecvt<wchar_t, char, mbstate_t>.\n\t(messages<char>::do_close): Implement. Clean cache information.\n\t(messages<wchar_t>::do_close): Likewise.\n\t(get_glibc_msg): New. Use dgettext rather than gettext using cached\n\tdomain name associated to catalog id.\n\t(messages<char>::do_get): Use latter.\n\t(messages<wchar_t>::do_get): Likewise and use also cached locale\n\tcodecvt<wchar_t, char, mbstate_t> facet to convert wchar_t default\n\tvalue to char and the result back to wchar_t.\n\t* testsuite/22_locale/messages/13631.cc: New.\n\t* testsuite/22_locale/messages/members/char/2.cc: Use also fr_FR locale\n\tfor charset conversion to get the expected accented character.\n\nFrom-SVN: r218329", "tree": {"sha": "dc940f51b00c0ea19e058fb1a6003428315b179b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc940f51b00c0ea19e058fb1a6003428315b179b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d31008d7a0d53b431f176aad8dda5498de823122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31008d7a0d53b431f176aad8dda5498de823122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d31008d7a0d53b431f176aad8dda5498de823122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d31008d7a0d53b431f176aad8dda5498de823122/comments", "author": null, "committer": null, "parents": [{"sha": "61a1a73ecbc18c92bda1f240c8cd2ee4f5d2d6fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a1a73ecbc18c92bda1f240c8cd2ee4f5d2d6fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a1a73ecbc18c92bda1f240c8cd2ee4f5d2d6fe"}], "stats": {"total": 532, "additions": 441, "deletions": 91}, "files": [{"sha": "3d09b0314897709d62de66c8fdec5609ff2f33a1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -1,3 +1,33 @@\n+2014-12-03  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/13631\n+\t* include/bits/codecvt.h (codecvt<char, char, mbstate_t>): friend class\n+\tstd::messages<char>.\n+\t(codecvt<wchar_t, char, mbstate_t>): friend class\n+\tstd::messages<wchar_t>.\n+\t* config/locale/gnu/messages_member.h\n+\t(messages<char>::do_open): Specialized.\n+\t(messages<char>::do_close): Likewise.\n+\t(messages<wchar_t>::do_open): Likewise.\n+\t(messages<wchar_t>::do_close): Likewise.\n+\t* config/locale/gnu/messages_member.cc:\n+\t(messages<char>::do_open): Implement. Use bind_textdomain_codeset based\n+\ton codecvt<char, char, mbstate_t>._M_c_locale_codecvt code set. Use\n+\tinternal cache to keep opened domain name with locale information.\n+\t(messages<wchar_t>::do_open): Likewise with\n+\tcodecvt<wchar_t, char, mbstate_t>.\n+\t(messages<char>::do_close): Implement. Clean cache information.\n+\t(messages<wchar_t>::do_close): Likewise.\n+\t(get_glibc_msg): New. Use dgettext rather than gettext using cached\n+\tdomain name associated to catalog id.\n+\t(messages<char>::do_get): Use latter.\n+\t(messages<wchar_t>::do_get): Likewise and use also cached locale\n+\tcodecvt<wchar_t, char, mbstate_t> facet to convert wchar_t default\n+\tvalue to char and the result back to wchar_t.\n+\t* testsuite/22_locale/messages/13631.cc: New.\n+\t* testsuite/22_locale/messages/members/char/2.cc: Use also fr_FR locale\n+\tfor charset conversion to get the expected accented character.\n+\n 2014-12-03  Marek Polacek  <polacek@redhat.com>\n \n \t* include/bits/regex_compiler.h (_S_cache_size): Multiply the"}, {"sha": "0134f0f0df188944734f9473c86a62bb9c7d77ef", "filename": "libstdc++-v3/config/locale/gnu/messages_members.cc", "status": "modified", "additions": 227, "deletions": 28, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.cc?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -31,54 +31,253 @@\n #include <locale>\n #include <bits/c++locale_internal.h>\n \n-namespace std _GLIBCXX_VISIBILITY(default)\n+#include <limits>\n+#include <algorithm>\n+#include <vector>\n+\n+#include <backward/auto_ptr.h>\n+#include <ext/concurrence.h>\n+\n+namespace\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  using namespace std;\n \n-  // Specializations.\n-  template<>\n-    string\n-    messages<char>::do_get(catalog, int, int, const string& __dfault) const\n+  typedef messages_base::catalog catalog;\n+\n+  struct Catalog_info\n+    {\n+    Catalog_info(catalog __id, const string& __domain, locale __loc)\n+      : _M_id(__id), _M_domain(__domain), _M_locale(__loc)\n+    { }\n+\n+    catalog _M_id;\n+    string _M_domain;\n+    locale _M_locale;\n+  };\n+\n+  class Catalogs\n+  {\n+  public:\n+    Catalogs() : _M_catalog_counter(0) { }\n+\n+    ~Catalogs()\n+    {\n+      for (vector<Catalog_info*>::iterator __it = _M_infos.begin();\n+\t   __it != _M_infos.end(); ++__it)\n+\tdelete *__it;\n+    }\n+\n+    catalog\n+    _M_add(const string& __domain, locale __l)\n+    {\n+      __gnu_cxx::__scoped_lock lock(_M_mutex);\n+\n+      // The counter is not likely to roll unless catalogs keep on being\n+      // opened/closed which is consider as an application mistake for the\n+      // moment.\n+      if (_M_catalog_counter == numeric_limits<catalog>::max())\n+\treturn -1;\n+\n+      std::auto_ptr<Catalog_info> info(new Catalog_info(_M_catalog_counter++,\n+\t\t\t\t\t\t\t__domain, __l));\n+      _M_infos.push_back(info.get());\n+      return info.release()->_M_id;\n+    }\n+\n+    void\n+    _M_erase(catalog __c)\n     {\n+      __gnu_cxx::__scoped_lock lock(_M_mutex);\n+\n+      vector<Catalog_info*>::iterator __res =\n+\tlower_bound(_M_infos.begin(), _M_infos.end(), __c, _Comp());\n+      if (__res == _M_infos.end() || (*__res)->_M_id != __c)\n+\treturn;\n+\n+      delete *__res;\n+      _M_infos.erase(__res);\n+\n+      // Just in case closed catalog was the last open.\n+      if (__c == _M_catalog_counter - 1)\n+\t--_M_catalog_counter;\n+    }\n+\n+    const Catalog_info*\n+    _M_get(catalog __c) const\n+    {\n+      __gnu_cxx::__scoped_lock lock(_M_mutex);\n+\n+      vector<Catalog_info*>::const_iterator __res =\n+\tlower_bound(_M_infos.begin(), _M_infos.end(), __c, _Comp());\n+\n+      if (__res != _M_infos.end() && (*__res)->_M_id == __c)\n+\treturn *__res;\n+\n+      return 0;\n+    }\n+\n+  private:\n+    struct _Comp\n+    {\n+      bool operator()(catalog __cat, const Catalog_info* __info) const\n+      { return __cat < __info->_M_id; }\n+\n+      bool operator()(const Catalog_info* __info, catalog __cat) const\n+      { return __info->_M_id < __cat; }\n+    };\n+\n+    mutable __gnu_cxx::__mutex _M_mutex;\n+    catalog _M_catalog_counter;\n+    std::vector<Catalog_info*> _M_infos;\n+  };\n+\n+  Catalogs&\n+  get_catalogs()\n+  {\n+    static Catalogs __catalogs;\n+    return __catalogs;\n+  }\n+\n+  const char*\n+  get_glibc_msg(__c_locale __attribute__((unused)) __locale_messages,\n+\t\tconst char* __domainname,\n+\t\tconst char* __dfault)\n+  {\n #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n-      __c_locale __old = __uselocale(_M_c_locale_messages);\n-      const char* __msg = const_cast<const char*>(gettext(__dfault.c_str()));\n+    std::__c_locale __old = __uselocale(__locale_messages);\n+    const char* __msg =\n+      const_cast<const char*>(dgettext(__domainname, __dfault));\n       __uselocale(__old);\n-      return string(__msg);\n #else\n       char* __old = setlocale(LC_ALL, 0);\n       const size_t __len = strlen(__old) + 1;\n       char* __sav = new char[__len];\n       memcpy(__sav, __old, __len);\n       setlocale(LC_ALL, _M_name_messages);\n-      const char* __msg = gettext(__dfault.c_str());\n+    const char* __msg = dgettext(__domainname, __dfault);\n       setlocale(LC_ALL, __sav);\n       delete [] __sav;\n-      return string(__msg);\n #endif\n+\n+    return __msg;\n+    }\n+}\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  // Specializations.\n+  template<>\n+    typename messages<char>::catalog\n+    messages<char>::do_open(const basic_string<char>& __s,\n+\t\t\t    const locale& __l) const\n+  {\n+    typedef codecvt<char, char, mbstate_t> __codecvt_t;\n+    const __codecvt_t& __codecvt = use_facet<__codecvt_t>(__l);\n+\n+    bind_textdomain_codeset(__s.c_str(),\n+\t__nl_langinfo_l(CODESET, __codecvt._M_c_locale_codecvt));\n+    return get_catalogs()._M_add(__s, __l);\n+  }\n+\n+  template<>\n+    void\n+    messages<char>::do_close(catalog __c) const\n+    { get_catalogs()._M_erase(__c); }\n+\n+  template<>\n+    string\n+    messages<char>::do_get(catalog __c, int, int,\n+\t\t\t   const string& __dfault) const\n+    {\n+      if (__c < 0 || __dfault.empty())\n+\treturn __dfault;\n+\n+      const Catalog_info* __cat_info = get_catalogs()._M_get(__c);\n+\n+      if (!__cat_info)\n+\treturn __dfault;\n+\n+      return get_glibc_msg(_M_c_locale_messages,\n+\t\t\t   __cat_info->_M_domain.c_str(),\n+\t\t\t   __dfault.c_str());\n     }\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    typename messages<wchar_t>::catalog\n+    messages<wchar_t>::do_open(const basic_string<char>& __s,\n+\t\t\t       const locale& __l) const\n+  {\n+    typedef codecvt<wchar_t, char, mbstate_t> __codecvt_t;\n+    const __codecvt_t& __codecvt = use_facet<__codecvt_t>(__l);\n+\n+    bind_textdomain_codeset(__s.c_str(),\n+\t__nl_langinfo_l(CODESET, __codecvt._M_c_locale_codecvt));\n+\n+    return get_catalogs()._M_add(__s, __l);\n+  }\n+\n+  template<>\n+    void\n+    messages<wchar_t>::do_close(catalog __c) const\n+    { get_catalogs()._M_erase(__c); }\n+\n   template<>\n     wstring\n-    messages<wchar_t>::do_get(catalog, int, int, const wstring& __dfault) const\n+    messages<wchar_t>::do_get(catalog __c, int, int,\n+\t\t\t      const wstring& __wdfault) const\n     {\n-# if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2)\n-      __c_locale __old = __uselocale(_M_c_locale_messages);\n-      char* __msg = gettext(_M_convert_to_char(__dfault));\n-      __uselocale(__old);\n-      return _M_convert_from_char(__msg);\n-# else\n-      char* __old = setlocale(LC_ALL, 0);\n-      const size_t __len = strlen(__old) + 1;\n-      char* __sav = new char[__len];\n-      memcpy(__sav, __old, __len);\n-      setlocale(LC_ALL, _M_name_messages);\n-      char* __msg = gettext(_M_convert_to_char(__dfault));\n-      setlocale(LC_ALL, __sav);\n-      delete [] __sav;\n-      return _M_convert_from_char(__msg);\n-# endif\n+      if (__c < 0 || __wdfault.empty())\n+\treturn __wdfault;\n+\n+      const Catalog_info* __cat_info = get_catalogs()._M_get(__c);\n+\n+      if (!__cat_info)\n+\treturn __wdfault;\n+\n+      typedef codecvt<wchar_t, char, mbstate_t> __codecvt_t;\n+      const __codecvt_t& __conv =\n+\tuse_facet<__codecvt_t>(__cat_info->_M_locale);\n+\n+      const char* __translation;\n+      mbstate_t __state;\n+      __builtin_memset(&__state, 0, sizeof(mbstate_t));\n+      {\n+\tconst wchar_t* __wdfault_next;\n+\tsize_t __mb_size = __wdfault.size() * __conv.max_length();;\n+\tchar* __dfault =\n+\t  static_cast<char*>(__builtin_alloca(sizeof(char) * (__mb_size + 1)));\n+\tchar* __dfault_next;\n+\t__conv.out(__state,\n+\t\t   __wdfault.data(), __wdfault.data() + __wdfault.size(),\n+\t\t   __wdfault_next,\n+\t\t   __dfault, __dfault + __mb_size, __dfault_next);\n+\n+\t// Make sure string passed to dgettext is \\0 terminated.\n+\t*__dfault_next = '\\0';\n+\t__translation\n+\t  = get_glibc_msg(_M_c_locale_messages,\n+\t\t\t  __cat_info->_M_domain.c_str(), __dfault);\n+\n+\t// If we end up getting default value back we can simply return original\n+\t// default value.\n+\tif (__translation == __dfault)\n+\t  return __wdfault;\n+    }\n+\n+      __builtin_memset(&__state, 0, sizeof(mbstate_t));\n+      size_t __size = __builtin_strlen(__translation);\n+      const char* __translation_next;\n+      wchar_t* __wtranslation =\n+\tstatic_cast<wchar_t*>(__builtin_alloca(sizeof(wchar_t) * (__size + 1)));\n+      wchar_t* __wtranslation_next;\n+      __conv.in(__state, __translation, __translation + __size,\n+\t\t__translation_next,\n+\t\t__wtranslation, __wtranslation + __size,\n+\t\t__wtranslation_next);\n+      return wstring(__wtranslation, __wtranslation_next);\n     }\n #endif\n "}, {"sha": "cb3fd670b980b649936ee59cf79b3c66a38da389", "filename": "libstdc++-v3/config/locale/gnu/messages_members.h", "status": "modified", "additions": 79, "deletions": 58, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -41,90 +41,111 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Non-virtual member functions.\n   template<typename _CharT>\n-     messages<_CharT>::messages(size_t __refs)\n-     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()), \n-       _M_name_messages(_S_get_c_name())\n-     { }\n+    messages<_CharT>::messages(size_t __refs)\n+    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),\n+      _M_name_messages(_S_get_c_name())\n+    { }\n \n   template<typename _CharT>\n-     messages<_CharT>::messages(__c_locale __cloc, const char* __s, \n-\t\t\t\tsize_t __refs) \n-     : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)\n-     {\n-       if (__builtin_strcmp(__s, _S_get_c_name()) != 0)\n-\t {\n-\t   const size_t __len = __builtin_strlen(__s) + 1;\n-\t   char* __tmp = new char[__len];\n-\t   __builtin_memcpy(__tmp, __s, __len);\n-\t   _M_name_messages = __tmp;\n-\t }\n-       else\n-\t _M_name_messages = _S_get_c_name();\n-\n-       // Last to avoid leaking memory if new throws.\n-       _M_c_locale_messages = _S_clone_c_locale(__cloc);\n-     }\n+    messages<_CharT>::messages(__c_locale __cloc, const char* __s,\n+\t\t\t       size_t __refs)\n+    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)\n+    {\n+      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)\n+\t{\n+\t  const size_t __len = __builtin_strlen(__s) + 1;\n+\t  char* __tmp = new char[__len];\n+\t  __builtin_memcpy(__tmp, __s, __len);\n+\t  _M_name_messages = __tmp;\n+\t}\n+      else\n+\t_M_name_messages = _S_get_c_name();\n+\n+      // Last to avoid leaking memory if new throws.\n+      _M_c_locale_messages = _S_clone_c_locale(__cloc);\n+    }\n \n   template<typename _CharT>\n-    typename messages<_CharT>::catalog \n-    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc, \n+    typename messages<_CharT>::catalog\n+    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,\n \t\t\t   const char* __dir) const\n-    { \n+    {\n       bindtextdomain(__s.c_str(), __dir);\n-      return this->do_open(__s, __loc); \n+      return this->do_open(__s, __loc);\n     }\n \n   // Virtual member functions.\n   template<typename _CharT>\n     messages<_CharT>::~messages()\n-    { \n+    {\n       if (_M_name_messages != _S_get_c_name())\n \tdelete [] _M_name_messages;\n-      _S_destroy_c_locale(_M_c_locale_messages); \n+      _S_destroy_c_locale(_M_c_locale_messages);\n     }\n \n   template<typename _CharT>\n-    typename messages<_CharT>::catalog \n-    messages<_CharT>::do_open(const basic_string<char>& __s, \n+    typename messages<_CharT>::catalog\n+    messages<_CharT>::do_open(const basic_string<char>& __s,\n \t\t\t      const locale&) const\n-    { \n+    {\n       // No error checking is done, assume the catalog exists and can\n       // be used.\n       textdomain(__s.c_str());\n       return 0;\n     }\n \n   template<typename _CharT>\n-    void    \n-    messages<_CharT>::do_close(catalog) const \n+    void\n+    messages<_CharT>::do_close(catalog) const\n     { }\n \n-   // messages_byname\n-   template<typename _CharT>\n-     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)\n-     : messages<_CharT>(__refs) \n-     { \n-       if (this->_M_name_messages != locale::facet::_S_get_c_name())\n-\t {\n-\t   delete [] this->_M_name_messages;\n-\t   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)\n-\t     {\n-\t       const size_t __len = __builtin_strlen(__s) + 1;\n-\t       char* __tmp = new char[__len];\n-\t       __builtin_memcpy(__tmp, __s, __len);\n-\t       this->_M_name_messages = __tmp;\n-\t     }\n-\t   else\n-\t     this->_M_name_messages = locale::facet::_S_get_c_name();\n-\t }\n-\n-       if (__builtin_strcmp(__s, \"C\") != 0\n-\t   && __builtin_strcmp(__s, \"POSIX\") != 0)\n-\t {\n-\t   this->_S_destroy_c_locale(this->_M_c_locale_messages);\n-\t   this->_S_create_c_locale(this->_M_c_locale_messages, __s); \n-\t }\n-     }\n+  // messages_byname\n+  template<typename _CharT>\n+    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)\n+    : messages<_CharT>(__refs)\n+    {\n+      if (this->_M_name_messages != locale::facet::_S_get_c_name())\n+\t{\n+\t  delete [] this->_M_name_messages;\n+\t  if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)\n+\t    {\n+\t      const size_t __len = __builtin_strlen(__s) + 1;\n+\t      char* __tmp = new char[__len];\n+\t      __builtin_memcpy(__tmp, __s, __len);\n+\t      this->_M_name_messages = __tmp;\n+\t    }\n+\t  else\n+\t    this->_M_name_messages = locale::facet::_S_get_c_name();\n+\t}\n+\n+      if (__builtin_strcmp(__s, \"C\") != 0\n+\t  && __builtin_strcmp(__s, \"POSIX\") != 0)\n+\t{\n+\t  this->_S_destroy_c_locale(this->_M_c_locale_messages);\n+\t  this->_S_create_c_locale(this->_M_c_locale_messages, __s);\n+\t}\n+    }\n+\n+   //Specializations.\n+  template<>\n+    typename messages<char>::catalog\n+    messages<char>::do_open(const basic_string<char>&,\n+\t\t\t    const locale&) const;\n+\n+  template<>\n+    void\n+    messages<char>::do_close(catalog) const;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  template<>\n+    typename messages<wchar_t>::catalog\n+    messages<wchar_t>::do_open(const basic_string<char>&,\n+\t\t\t       const locale&) const;\n+\n+  template<>\n+    void\n+    messages<wchar_t>::do_close(catalog) const;\n+#endif\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "1098917f7fb4cc3d164b3c88a64dd9744cd882b1", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -263,8 +263,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       do_max_length() const throw() = 0;\n     };\n \n-\n-\n   /**\n    *  @brief  Primary class template codecvt.\n    *  @ingroup locales\n@@ -340,6 +338,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class codecvt<char, char, mbstate_t>\n     : public __codecvt_abstract_base<char, char, mbstate_t>\n     {\n+      friend class messages<char>;\n+\n     public:\n       // Types:\n       typedef char\t\t\tintern_type;\n@@ -398,6 +398,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class codecvt<wchar_t, char, mbstate_t>\n     : public __codecvt_abstract_base<wchar_t, char, mbstate_t>\n     {\n+      friend class messages<wchar_t>;\n+\n     public:\n       // Types:\n       typedef wchar_t\t\t\tintern_type;"}, {"sha": "107531e43394f5275bbb679f9e2222b5ab63878a", "filename": "libstdc++-v3/testsuite/22_locale/messages/13631.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2F13631.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2F13631.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2F13631.cc?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -0,0 +1,99 @@\n+// { dg-require-namedlocale \"fr_FR\" }\n+\n+// Copyright (C) 2014 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // This is defined through CXXFLAGS in scripts/testsuite_flags[.in].\n+  const char* dir = LOCALEDIR;\n+\n+  std::locale l(\"fr_FR\");\n+\n+  typedef std::messages<char> messages;\n+\n+  const messages &msgs_facet = std::use_facet<messages>(l);\n+\n+  messages::catalog msgs = msgs_facet.open(\"libstdc++\", l, dir);\n+  VERIFY( msgs >= 0 );\n+\n+  const char msgid[] = \"please\";\n+  std::string translation1 = msgs_facet.get(msgs, 0, 0, msgid);\n+\n+  // Without a real translation this test doesn't mean anything:\n+  VERIFY( translation1 != msgid );\n+\n+  // Opening another catalog was enough to show the problem, even a fake\n+  // catalog.\n+  messages::catalog fake_msgs = msgs_facet.open(\"fake\", l);\n+\n+  std::string translation2 = msgs_facet.get(msgs, 0, 0, msgid);\n+\n+  // Close catalogs before doing the check to avoid leaks.\n+  msgs_facet.close(fake_msgs);\n+  msgs_facet.close(msgs);\n+\n+  VERIFY( translation1 == translation2 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // This is defined through CXXFLAGS in scripts/testsuite_flags[.in].\n+  const char* dir = LOCALEDIR;\n+\n+  std::locale l(\"fr_FR\");\n+\n+  typedef std::messages<wchar_t> messages;\n+\n+  const messages &msgs_facet = std::use_facet<messages>(l);\n+\n+  messages::catalog msgs = msgs_facet.open(\"libstdc++\", l, dir);\n+  VERIFY( msgs >= 0 );\n+\n+  const wchar_t msgid[] = L\"please\";\n+  std::wstring translation1 = msgs_facet.get(msgs, 0, 0, msgid);\n+\n+  // Without a real translation this test doesn't mean anything:\n+  VERIFY( !translation1.empty() );\n+  VERIFY( translation1 != msgid );\n+\n+  // Opening another catalog was enough to show the problem, even a fake\n+  // catalog.\n+  messages::catalog fake_msgs = msgs_facet.open(\"fake\", l);\n+\n+  std::wstring translation2 = msgs_facet.get(msgs, 0, 0, msgid);\n+\n+  // Close catalogs before doing the check to avoid leaks.\n+  msgs_facet.close(fake_msgs);\n+  msgs_facet.close(msgs);\n+\n+  VERIFY( translation1 == translation2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "c3989c0b64cc858ec611bcac8ca0aa55c6fc68e6", "filename": "libstdc++-v3/testsuite/22_locale/messages/members/char/2.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2Fmembers%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d31008d7a0d53b431f176aad8dda5498de823122/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2Fmembers%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmessages%2Fmembers%2Fchar%2F2.cc?ref=d31008d7a0d53b431f176aad8dda5498de823122", "patch": "@@ -35,9 +35,8 @@ void test02()\n   const char* dir = LOCALEDIR;\n \n   // basic construction\n-  locale loc_c = locale::classic();\n   locale loc_fr = locale(\"fr_FR\");\n-  VERIFY( loc_c != loc_fr );\n+  VERIFY( locale::classic() != loc_fr );\n \n   // cache the messages facets\n   const messages<char>& mssg_fr = use_facet<messages<char> >(loc_fr); \n@@ -47,7 +46,7 @@ void test02()\n   // void close(catalog) const;\n \n   // Check French (fr_FR) locale.\n-  catalog cat_fr = mssg_fr.open(\"libstdc++\", loc_c, dir);\n+  catalog cat_fr = mssg_fr.open(\"libstdc++\", loc_fr, dir);\n   string s01 = mssg_fr.get(cat_fr, 0, 0, \"please\");\n   string s02 = mssg_fr.get(cat_fr, 0, 0, \"thank you\");\n   VERIFY ( s01 == \"s'il vous pla\ufffdt\" );"}]}