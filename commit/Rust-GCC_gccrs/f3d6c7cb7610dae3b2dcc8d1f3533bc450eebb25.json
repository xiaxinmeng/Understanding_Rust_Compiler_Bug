{"sha": "f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkNmM3Y2I3NjEwZGFlM2IyZGNjOGQxZjM1MzNiYzQ1MGVlYmIyNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-04-08T08:23:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-04-08T08:23:56Z"}, "message": "re PR ada/60411 (Ada bootstrap failure on ARM)\n\n\tPR ada/60411\n\t* gcc-interface/Makefile.in (arm% linux-android): Switch to EHABI.\n\t* s-linux-android.ads: New file.\n\t* s-intman-android.adb: Likewise.\n\nFrom-SVN: r209210", "tree": {"sha": "d8322e4da4cd977cc4a9604039de2c7dc2271ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8322e4da4cd977cc4a9604039de2c7dc2271ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/comments", "author": null, "committer": null, "parents": [{"sha": "0439a9476743c79bffeff4571695f74cf0f8e2e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0439a9476743c79bffeff4571695f74cf0f8e2e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0439a9476743c79bffeff4571695f74cf0f8e2e0"}], "stats": {"total": 462, "additions": 458, "deletions": 4}, "files": [{"sha": "a832775c65cfcc1f0f4efda813bb40cb2b92a595", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "patch": "@@ -1,3 +1,10 @@\n+2014-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/60411\n+\t* gcc-interface/Makefile.in (arm% linux-android): Switch to EHABI.\n+\t* s-linux-android.ads: New file.\n+\t* s-intman-android.adb: Likewise.\n+\n 2014-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in (alpha-vms): Add missing line."}, {"sha": "d36c6daf685805c048239fba56914600e372a9ec", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "patch": "@@ -1045,15 +1045,17 @@ ifeq ($(strip $(filter-out arm% linux-androideabi,$(target_cpu) $(target_os))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-intnam.ads<a-intnam-linux.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n+  s-intman.adb<s-intman-android.adb \\\n+  s-linux.ads<s-linux-android.ads \\\n   s-osinte.adb<s-osinte-android.adb \\\n   s-osinte.ads<s-osinte-android.ads \\\n   s-osprim.adb<s-osprim-posix.adb \\\n   s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   system.ads<system-linux-armel.ads \\\n+  a-exexpr.adb<a-exexpr-gcc.adb \\\n+  s-excmac.ads<s-excmac-arm.ads \\\n   $(DUMMY_SOCKETS_TARGET_PAIRS)\n \n   TOOLS_TARGET_PAIRS =  \\\n@@ -1062,7 +1064,9 @@ ifeq ($(strip $(filter-out arm% linux-androideabi,$(target_cpu) $(target_os))),)\n \n   GNATRTL_SOCKETS_OBJS =\n   EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=\n+  EXTRA_LIBGNAT_OBJS+=raise-gcc.o\n+  EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o s-excmac.o\n+  EH_MECHANISM=-arm\n   THREADSLIB =\n   GNATLIB_SHARED = gnatlib-shared-dual\n   LIBRARY_VERSION := $(LIB_VERSION)"}, {"sha": "30a980e3e3b64424fcffed18b1c575b9f6e72289", "filename": "gcc/ada/s-intman-android.adb", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fs-intman-android.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fs-intman-android.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-android.adb?ref=f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "patch": "@@ -0,0 +1,331 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Android version of this package\n+\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n+--  the lookout for special signals that may be used by the thread library.\n+\n+--  Since this is a multi target file, the signal <-> exception mapping\n+--  is simple minded. If you need a more precise and target specific\n+--  signal handling, create a new s-intman.adb that will fit your needs.\n+\n+--  This file assumes that:\n+\n+--    SIGFPE, SIGILL, SIGSEGV and SIGBUS exist. They are mapped as follows:\n+--      SIGPFE  => Constraint_Error\n+--      SIGILL  => Program_Error\n+--      SIGSEGV => Storage_Error\n+--      SIGBUS  => Storage_Error\n+\n+--    SIGINT exists and will be kept unmasked unless the pragma\n+--     Unreserve_All_Interrupts is specified anywhere in the application.\n+\n+--    System.OS_Interface contains the following:\n+--      SIGADAABORT: the signal that will be used to abort tasks.\n+--      Unmasked: the OS specific set of signals that should be unmasked in\n+--                all the threads. SIGADAABORT is unmasked by\n+--                default\n+--      Reserved: the OS specific set of signals that are reserved.\n+\n+with System.Task_Primitives;\n+\n+package body System.Interrupt_Management is\n+\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGFPE, SIGILL, SIGSEGV, SIGBUS);\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Signal_Trampoline\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address;\n+      handler  : System.Address);\n+   pragma Import (C, Signal_Trampoline, \"__gnat_sigtramp\");\n+   --  Pass the real handler to a speical function that handles unwinding by\n+   --  skipping over the kernel signal frame (which doesn't contain any unwind\n+   --  information).\n+\n+   function State (Int : Interrupt_ID) return Character;\n+   pragma Import (C, State, \"__gnat_get_interrupt_state\");\n+   --  Get interrupt state. Defined in init.c The input argument is the\n+   --  interrupt number, and the result is one of the following:\n+\n+   procedure Map_Signal\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n+   --  This function identifies the Ada exception to be raised using the\n+   --  information when the system received a synchronous signal.\n+\n+----------------\n+-- Map_Signal --\n+----------------\n+\n+   procedure Map_Signal\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address)\n+   is\n+      pragma Unreferenced (siginfo);\n+      pragma Unreferenced (ucontext);\n+\n+   begin\n+\n+      --  Check that treatment of exception propagation here is consistent with\n+      --  treatment of the abort signal in System.Task_Primitives.Operations.\n+\n+      case signo is\n+         when SIGFPE =>\n+            raise Constraint_Error;\n+         when SIGILL =>\n+            raise Program_Error;\n+         when SIGSEGV =>\n+            raise Storage_Error;\n+         when SIGBUS =>\n+            raise Storage_Error;\n+         when others =>\n+            null;\n+      end case;\n+   end Map_Signal;\n+\n+----------------------\n+-- Notify_Exception --\n+----------------------\n+\n+   User    : constant Character := 'u';\n+   Runtime : constant Character := 'r';\n+   Default : constant Character := 's';\n+   --    'n'   this interrupt not set by any Interrupt_State pragma\n+   --    'u'   Interrupt_State pragma set state to User\n+   --    'r'   Interrupt_State pragma set state to Runtime\n+   --    's'   Interrupt_State pragma set state to System (use \"default\"\n+   --           system handler)\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address);\n+   --  This function is the signal handler and calls a trampoline subprogram\n+   --  that adjusts the unwind information so the ARM unwinder can find it's\n+   --  way back to the context of the originating subprogram. Compare with\n+   --  __gnat_error_handler for non-tasking programs.\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   Signal_Mask : aliased sigset_t;\n+   --  The set of signals handled by Notify_Exception\n+\n+   procedure Notify_Exception\n+     (signo    : Signal;\n+      siginfo  : System.Address;\n+      ucontext : System.Address)\n+   is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  With the __builtin_longjmp, the signal mask is not restored, so we\n+      --  need to restore it explicitly.  ??? We don't use __builtin_longjmp\n+      --  anymore, so do we still need this?   */\n+\n+      Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n+      pragma Assert (Result = 0);\n+\n+      --  Perform the necessary context adjustments prior to calling the\n+      --  trampoline subprogram with the \"real\" signal handler.\n+\n+      Adjust_Context_For_Raise (signo, ucontext);\n+\n+      Signal_Trampoline (signo, siginfo, ucontext, Map_Signal'Address);\n+   end Notify_Exception;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   Initialized : Boolean := False;\n+\n+   procedure Initialize is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Result  : System.OS_Interface.int;\n+\n+      Use_Alternate_Stack : constant Boolean :=\n+                              System.Task_Primitives.Alternate_Stack_Size /= 0;\n+      --  Whether to use an alternate signal stack for stack overflows\n+\n+   begin\n+      if Initialized then\n+         return;\n+      end if;\n+\n+      Initialized := True;\n+\n+      --  Need to call pthread_init very early because it is doing signal\n+      --  initializations.\n+\n+      pthread_init;\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      act.sa_handler := Notify_Exception'Address;\n+\n+      --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n+      --  number argument to the handler when it is called. The set of extra\n+      --  parameters includes a pointer to the interrupted context, which the\n+      --  ZCX propagation scheme needs.\n+\n+      --  Most man pages for sigaction mention that sa_sigaction should be set\n+      --  instead of sa_handler when SA_SIGINFO is on.  In practice, the two\n+      --  fields are actually union'ed and located at the same offset.\n+\n+      --  On some targets, we set sa_flags to SA_NODEFER so that during the\n+      --  handler execution we do not change the Signal_Mask to be masked for\n+      --  the Signal.\n+\n+      --  This is a temporary fix to the problem that the Signal_Mask is not\n+      --  restored after the exception (longjmp) from the handler. The right\n+      --  fix should be made in sigsetjmp so that we save the Signal_Set and\n+      --  restore it after a longjmp.\n+\n+      --  We set SA_NODEFER to be compatible with what is done in\n+      --  __gnat_error_handler.\n+\n+      Result := sigemptyset (Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      --  Add signals that map to Ada exceptions to the mask\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= Default  then\n+            Result :=\n+              sigaddset\n+                (Signal_Mask'Access, Signal (Exception_Interrupts (J)));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      act.sa_mask := Signal_Mask;\n+\n+      pragma Assert (Keep_Unmasked = (Interrupt_ID'Range => False));\n+      pragma Assert (Reserve = (Interrupt_ID'Range => False));\n+\n+      --  Process state of exception signals\n+\n+      for J in Exception_Interrupts'Range loop\n+         if State (Exception_Interrupts (J)) /= User then\n+            Keep_Unmasked (Exception_Interrupts (J)) := True;\n+            Reserve (Exception_Interrupts (J)) := True;\n+\n+            if State (Exception_Interrupts (J)) /= Default then\n+               act.sa_flags := SA_NODEFER + SA_RESTART + SA_SIGINFO;\n+\n+               if Use_Alternate_Stack\n+                 and then Exception_Interrupts (J) = SIGSEGV\n+               then\n+                  act.sa_flags := act.sa_flags + SA_ONSTACK;\n+               end if;\n+\n+               Result :=\n+                 sigaction\n+                   (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+                    old_act'Unchecked_Access);\n+               pragma Assert (Result = 0);\n+            end if;\n+         end if;\n+      end loop;\n+\n+      if State (Abort_Task_Interrupt) /= User then\n+         Keep_Unmasked (Abort_Task_Interrupt) := True;\n+         Reserve (Abort_Task_Interrupt) := True;\n+      end if;\n+\n+      --  Set SIGINT to unmasked state as long as it is not in \"User\" state.\n+      --  Check for Unreserve_All_Interrupts last.\n+\n+      if State (SIGINT) /= User then\n+         Keep_Unmasked (SIGINT) := True;\n+         Reserve (SIGINT) := True;\n+      end if;\n+\n+      --  Check all signals for state that requires keeping them unmasked and\n+      --  reserved.\n+\n+      for J in Interrupt_ID'Range loop\n+         if State (J) = Default or else State (J) = Runtime then\n+            Keep_Unmasked (J) := True;\n+            Reserve (J) := True;\n+         end if;\n+      end loop;\n+\n+      --  Add the set of signals that must always be unmasked for this target\n+\n+      for J in Unmasked'Range loop\n+         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n+         Reserve (Interrupt_ID (Unmasked (J))) := True;\n+      end loop;\n+\n+      --  Add target-specific reserved signals\n+\n+      for J in Reserved'Range loop\n+         Reserve (Interrupt_ID (Reserved (J))) := True;\n+      end loop;\n+\n+      --  Process pragma Unreserve_All_Interrupts. This overrides any settings\n+      --  due to pragma Interrupt_State:\n+\n+      if Unreserve_All_Interrupts /= 0 then\n+         Keep_Unmasked (SIGINT) := False;\n+         Reserve (SIGINT) := False;\n+      end if;\n+\n+      --  We do not really have Signal 0. We just use this value to identify\n+      --  non-existent signals (see s-intnam.ads). Therefore, Signal should not\n+      --  be used in all signal related operations hence mark it as reserved.\n+\n+      Reserve (0) := True;\n+   end Initialize;\n+\n+end System.Interrupt_Management;"}, {"sha": "3e5f136319466ffc348473652617901dcd57d568", "filename": "gcc/ada/s-linux-android.ads", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fs-linux-android.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25/gcc%2Fada%2Fs-linux-android.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-linux-android.ads?ref=f3d6c7cb7610dae3b2dcc8d1f3533bc450eebb25", "patch": "@@ -0,0 +1,112 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                          S Y S T E M .  L I N U X                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--            Copyright (C) 2014, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- In particular,  you can freely  distribute your programs  built with the --\n+-- GNAT Pro compiler, including any required library run-time units,  using --\n+-- any licensing terms  of your choosing.  See the AdaCore Software License --\n+-- for full details.                                                        --\n+--                                                                          --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Android version of this package\n+\n+--  This package encapsulates cpu specific differences between implementations\n+--  of GNU/Linux, in order to share s-osinte-linux.ads.\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package\n+\n+package System.Linux is\n+   pragma Preelaborate;\n+\n+   ------------\n+   -- time_t --\n+   ------------\n+\n+   type time_t is new Long_Integer;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 110;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 7; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 10; --  user defined signal 1\n+   SIGUSR2    : constant := 12; --  user defined signal 2\n+   SIGCLD     : constant := 17; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 17; --  child status change\n+   SIGPWR     : constant := 30; --  power-fail restart\n+   SIGWINCH   : constant := 28; --  window size change\n+   SIGURG     : constant := 23; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 29; --  pollable event occurred\n+   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)\n+   SIGLOST    : constant := 29; --  File lock lost\n+   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 20; --  user stop requested from tty\n+   SIGCONT    : constant := 18; --  stopped process has been continued\n+   SIGTTIN    : constant := 21; --  background tty read attempted\n+   SIGTTOU    : constant := 22; --  background tty write attempted\n+   SIGVTALRM  : constant := 26; --  virtual timer expired\n+   SIGPROF    : constant := 27; --  profiling timer expired\n+   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n+   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n+   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (Linux)\n+   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal\n+   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal\n+   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal\n+\n+   --  struct_sigaction offsets\n+\n+   sa_handler_pos : constant := 0;\n+   sa_mask_pos    : constant := Standard'Address_Size / 8;\n+   sa_flags_pos   : constant := 4 + sa_mask_pos;\n+\n+   SA_SIGINFO  : constant := 16#00000004#;\n+   SA_ONSTACK  : constant := 16#08000000#;\n+   SA_RESTART  : constant := 16#10000000#;\n+   SA_NODEFER  : constant := 16#40000000#;\n+\n+end System.Linux;"}]}