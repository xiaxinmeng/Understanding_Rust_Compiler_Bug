{"sha": "339a28b96a306cb323a66e9142ab090d36f42ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM5YTI4Yjk2YTMwNmNiMzIzYTY2ZTkxNDJhYjA5MGQzNmY0MmJhOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-04-11T04:26:55Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-04-11T04:26:55Z"}, "message": "c-decl.c (struct binding_level): Add shadowed_tags and function_body...\n\n\n2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n\n\t* c-decl.c (struct binding_level): Add shadowed_tags and\n\tfunction_body; remove this_block, tag_transparent, and\n\tsubblocks_tag_transparent; update comments.\n\t(clear_binding_level, lookup_tag_reverse): Kill.\n\t(make_binding_level): Use ggc_alloc_cleared or memset.\n\t(lookup_tag): Remove struct binding_level* parameter.  All\n\tcallers changed. Just look at IDENTIFIER_TAG_VALUE, and\n\tcurrent_binding_level->tags if asked for thislevel_only or if\n\twe might have to diagnose \"struct foo; union foo;\"\n\t(pushlevel): Ignore argument.  Do not push another binding\n\tlevel on the transition from the parameters to the top level\n\tof the function body; just tweak the flags and proceed.\n\t(poplevel): Overhaul.  Clear IDENTIFIER_TAG_VALUEs; on exiting\n\ta function body, separate the parameter list from the\n\ttop-level local variables.\n\t(set_block): Do nothing.\n\t(pushtag): Set IDENTIFIER_TAG_VALUE and add an entry to\n\tshadowed_tags if necessary.\n\t(warn_if_shadowing): Nuke the special case for local shadowing\n\tparameter.\n\t(pushdecl): Do not create a shadow entry if we are replacing\n\tan older decl in the same binding level.\n\t(pushdecl_function_level): Tweak for new way of indicating\n\tfunction scope.\n\t(shadow_tag_warned): Use TYPE_NAME, not\tlookup_tag_reverse.\n\t(start_function): Don't set subblocks_tag_transparent.\n\t(finish_function): Fix up the binding_level stack for totally\n\tempty functions.  Otherwise, don't call poplevel.\n\n\t* c-common.c (shadow_warning): MANDATORY argument is no longer\n\tnecessary.  Always use plain warning.\n\t* c-common.h: Update to match.\n\n\t* cfglayout.c (scope_to_insns_initialize): Clear block when we\n\thit the FUNCTION_DECL.\n\t* function.c: Do not create cyclic tree structure.\n\n2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n\n\t* c-tree.h (struct lang_identifier): Replace global_value,\n\tlocal_value members with symbol_value, tag_value.  Kill\n\timplicit_decl and limbo_value.\n\t(IDENTIFIER_GLOBAL_VALUE, IDENTIFIER_LOCAL_VALUE,\n\tIDENTIFIER_LIMBO_VALUE, IDENTIFIER_IMPLICIT_DECL,\n\tC_MISSING_PROTOTYPE_WARNED): Kill.\n\t(IDENTIFIER_SYMBOL_VALUE, IDENTIFIER_TAG_VALUE,\n\tC_DECL_IMPLICIT, C_DECL_ISNT_PROTOTYPE): New.\n\t(C_DECL_ANTICIPATED): Rename to C_DECL_INVISIBLE.\n\t(implicit_decl_warning, lookup_name_current_level,\n\trecord_function_scope_shadow): Don't prototype.\n\t(pushdecl_function_level): Prototype.\n\n\t* c-decl.c (truly_local_externals): New variable.\n\t(struct binding_level): Adjust commentary.\n\t(get_function_binding_level, clear_limbo_values,\n\trecord_function_scope_shadow): Kill.\n\t(lookup_name_current_level, implicit_decl_warning): Are\tnow static.\n\t(any_external_decl, record_external_decl): New static functions.\n\t(clone_underlying type): Split out of pushdecl.\n\t(c_print_identifier): Update to match changes to struct\n\tlang_identifier.\n\t(poplevel): Delete #if 0 block.  Make externals invisible\n\tinstead of clearing their IDENTIFIER_SYMBOL_VALUEs.  Don't\n\tcall clear_limbo_values.  Refer to IDENTIFIER_SYMBOL_VALUE not\n\tIDENTIFIER_GLOBAL_VALUE or IDENTIFIER_LOCAL_VALUE.\n\t(duplicate-decls): For real parm decl after a forward decl,\n\tset TREE_ASM_WRITTEN here.  Allow void foo(...) followed by\n\tfoo(...) { } with only a warning.  Say whether a previous\n\tdeclaration was implicit.\n\t(warn_if_shadowing): Now handles all shadowing, not just\n\tlocal-over-local.  Clarify comments.\n\t(pushdecl): Rewritten.  There is no longer a distinction\n\tbetween global and local symbol values; they're all\n\tIDENTIFIER_SYMBOL_VALUE.  Call record_external_decl on all\n\tDECL_EXTERNAL decls, and use any_external_decl to check\n\tagainst previous externals.  Kill #if 0 blocks.  Don't\n\ttolerate error_mark_node being NULL.\n\t(pushdecl_top_level): Handle only those cases which\n\tObjective C (the only user) needs.\n\t(pushdecl_function_level): New function.\n\t(implicitly_declare): Create ordinary decls with\n\tC_DECL_IMPLICIT set.  Recycle old decls, however they got\n\tcreated.\n\t(lookup_name): It's always IDENTIFIER_SYMBOL_VALUE. Return 0\n\tfor C_DECL_INVISIBLE symbols.\n\t(lookup_name_current_level): Likewise.  Use chain_member.\n\t(c_make_fname_decl): Don't muck with DECL_CONTEXT.\n\tUse pushdecl_function_level.\n\t(builtin_function): Use C_DECL_INVISIBLE.\n\t(start_function): Don't muck with IDENTIFIER_IMPLICIT_DECL.\n\tUse C_DECL_ISNT_PROTOTYPE and C_DECL_IMPLICIT.\n\t(store_parm_decls): It's IDENTIFIER_SYMBOL_VALUE now.\n\t(identifier_global_value): Same.  Must scan\n\tglobal_binding_level in extremis.\n\n\t* c-typeck.c (undeclared_variable): New static function, split\n\tfrom build_external_ref.\n\t(build_external_ref): Use DECL_CONTEXT, not\n\tIDENTIFIER_LOCAL_VALUE, to decide whether a local hides\n\tan instance variable.  Restructure for clarity.\n\t* objc/objc-act.c: Use identifier_global_value, not\n\tIDENTIFIER_GLOBAL_VALUE.\n\ncp:\n\t* decl.c: Update all calls to shadow_warning.\n\ntestsuite:\n\t* gcc.c-torture/execute/builtin-noret-2.c: New.\n\t* gcc.c-torture/execute/builtin-noret-2.x: New.\n\tXFAIL builtin-noret-2.c at -O1 and above.\n\t* gcc.dg/redecl.c: New.\n\t* gcc.dg/Wshadow-1.c: Update error regexps.\n\nFrom-SVN: r65460", "tree": {"sha": "17de84c82d5527a115d97db14a145ae19c48be07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17de84c82d5527a115d97db14a145ae19c48be07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/339a28b96a306cb323a66e9142ab090d36f42ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339a28b96a306cb323a66e9142ab090d36f42ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/339a28b96a306cb323a66e9142ab090d36f42ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339a28b96a306cb323a66e9142ab090d36f42ba8/comments", "author": null, "committer": null, "parents": [{"sha": "b1e0a93ee513ccd9fa7d32947f2f568d379f358e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1e0a93ee513ccd9fa7d32947f2f568d379f358e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1e0a93ee513ccd9fa7d32947f2f568d379f358e"}], "stats": {"total": 1843, "additions": 962, "deletions": 881}, "files": [{"sha": "25ecc0616595f40f5c6371ddf5231b85b5605e97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,3 +1,108 @@\n+2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (struct binding_level): Add shadowed_tags and\n+\tfunction_body; remove this_block, tag_transparent, and\n+\tsubblocks_tag_transparent; update comments.\n+\t(clear_binding_level, lookup_tag_reverse): Kill.\n+\t(make_binding_level): Use ggc_alloc_cleared or memset.\n+\t(lookup_tag): Remove struct binding_level* parameter.  All\n+\tcallers changed. Just look at IDENTIFIER_TAG_VALUE, and\n+\tcurrent_binding_level->tags if asked for thislevel_only or if\n+\twe might have to diagnose \"struct foo; union foo;\"\n+\t(pushlevel): Ignore argument.  Do not push another binding\n+\tlevel on the transition from the parameters to the top level\n+\tof the function body; just tweak the flags and proceed.\n+\t(poplevel): Overhaul.  Clear IDENTIFIER_TAG_VALUEs; on exiting\n+\ta function body, separate the parameter list from the\n+\ttop-level local variables.\n+\t(set_block): Do nothing.\n+\t(pushtag): Set IDENTIFIER_TAG_VALUE and add an entry to\n+\tshadowed_tags if necessary.\n+\t(warn_if_shadowing): Nuke the special case for local shadowing\n+\tparameter.\n+\t(pushdecl): Do not create a shadow entry if we are replacing\n+\tan older decl in the same binding level.\n+\t(pushdecl_function_level): Tweak for new way of indicating\n+\tfunction scope.\n+\t(shadow_tag_warned): Use TYPE_NAME, not\tlookup_tag_reverse.\n+\t(start_function): Don't set subblocks_tag_transparent.\n+\t(finish_function): Fix up the binding_level stack for totally\n+\tempty functions.  Otherwise, don't call poplevel.\n+\n+\t* c-common.c (shadow_warning): MANDATORY argument is no longer\n+\tnecessary.  Always use plain warning.\n+\t* c-common.h: Update to match.\n+\n+\t* cfglayout.c (scope_to_insns_initialize): Clear block when we\n+\thit the FUNCTION_DECL.\n+\t* function.c: Do not create cyclic tree structure.\n+\n+2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-tree.h (struct lang_identifier): Replace global_value,\n+\tlocal_value members with symbol_value, tag_value.  Kill\n+\timplicit_decl and limbo_value.\n+\t(IDENTIFIER_GLOBAL_VALUE, IDENTIFIER_LOCAL_VALUE,\n+\tIDENTIFIER_LIMBO_VALUE, IDENTIFIER_IMPLICIT_DECL,\n+\tC_MISSING_PROTOTYPE_WARNED): Kill.\n+\t(IDENTIFIER_SYMBOL_VALUE, IDENTIFIER_TAG_VALUE,\n+\tC_DECL_IMPLICIT, C_DECL_ISNT_PROTOTYPE): New.\n+\t(C_DECL_ANTICIPATED): Rename to C_DECL_INVISIBLE.\n+\t(implicit_decl_warning, lookup_name_current_level,\n+\trecord_function_scope_shadow): Don't prototype.\n+\t(pushdecl_function_level): Prototype.\n+\n+\t* c-decl.c (truly_local_externals): New variable.\n+\t(struct binding_level): Adjust commentary.\n+\t(get_function_binding_level, clear_limbo_values,\n+\trecord_function_scope_shadow): Kill.\n+\t(lookup_name_current_level, implicit_decl_warning): Are\tnow static.\n+\t(any_external_decl, record_external_decl): New static functions.\n+\t(clone_underlying type): Split out of pushdecl.\n+\t(c_print_identifier): Update to match changes to struct\n+\tlang_identifier.\n+\t(poplevel): Delete #if 0 block.  Make externals invisible\n+\tinstead of clearing their IDENTIFIER_SYMBOL_VALUEs.  Don't\n+\tcall clear_limbo_values.  Refer to IDENTIFIER_SYMBOL_VALUE not\n+\tIDENTIFIER_GLOBAL_VALUE or IDENTIFIER_LOCAL_VALUE.\n+\t(duplicate-decls): For real parm decl after a forward decl,\n+\tset TREE_ASM_WRITTEN here.  Allow void foo(...) followed by\n+\tfoo(...) { } with only a warning.  Say whether a previous\n+\tdeclaration was implicit.\n+\t(warn_if_shadowing): Now handles all shadowing, not just\n+\tlocal-over-local.  Clarify comments.\n+\t(pushdecl): Rewritten.  There is no longer a distinction\n+\tbetween global and local symbol values; they're all\n+\tIDENTIFIER_SYMBOL_VALUE.  Call record_external_decl on all\n+\tDECL_EXTERNAL decls, and use any_external_decl to check\n+\tagainst previous externals.  Kill #if 0 blocks.  Don't\n+\ttolerate error_mark_node being NULL.\n+\t(pushdecl_top_level): Handle only those cases which\n+\tObjective C (the only user) needs.\n+\t(pushdecl_function_level): New function.\n+\t(implicitly_declare): Create ordinary decls with\n+\tC_DECL_IMPLICIT set.  Recycle old decls, however they got\n+\tcreated.\n+\t(lookup_name): It's always IDENTIFIER_SYMBOL_VALUE. Return 0\n+\tfor C_DECL_INVISIBLE symbols.\n+\t(lookup_name_current_level): Likewise.  Use chain_member.\n+\t(c_make_fname_decl): Don't muck with DECL_CONTEXT.\n+\tUse pushdecl_function_level.\n+\t(builtin_function): Use C_DECL_INVISIBLE.\n+\t(start_function): Don't muck with IDENTIFIER_IMPLICIT_DECL.\n+\tUse C_DECL_ISNT_PROTOTYPE and C_DECL_IMPLICIT.\n+\t(store_parm_decls): It's IDENTIFIER_SYMBOL_VALUE now.\n+\t(identifier_global_value): Same.  Must scan\n+\tglobal_binding_level in extremis.\n+\n+\t* c-typeck.c (undeclared_variable): New static function, split\n+\tfrom build_external_ref.\n+\t(build_external_ref): Use DECL_CONTEXT, not\n+\tIDENTIFIER_LOCAL_VALUE, to decide whether a local hides\n+\tan instance variable.  Restructure for clarity.\n+\t* objc/objc-act.c: Use identifier_global_value, not\n+\tIDENTIFIER_GLOBAL_VALUE.\n+\n 2003-04-08  Jonathan Wakely  <redi@gcc.gnu.org>\n \n \t* doc/extend.texi (Template Instantiation): Refer to ISO standard,"}, {"sha": "a2cad23392772ad1b8b9382c6949c8a13b8c1477", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -4778,12 +4778,10 @@ c_common_insert_default_attributes (decl)\n }\n \n /* Output a -Wshadow warning MSGCODE about NAME, and give the location\n-   of the previous declaration DECL.  MANDATORY says whether this is a\n-   mandatory warning (i.e. use pedwarn).  */\n+   of the previous declaration DECL.  */\n void\n-shadow_warning (msgcode, mandatory, name, decl)\n+shadow_warning (msgcode, name, decl)\n      enum sw_kind msgcode;\n-     int mandatory;  /* really bool */\n      const char *name;\n      tree decl;\n {\n@@ -4793,7 +4791,7 @@ shadow_warning (msgcode, mandatory, name, decl)\n     /* SW_GLOBAL */ N_(\"declaration of \\\"%s\\\" shadows a global declaration\")\n   };\n \n-  (mandatory ? pedwarn : warning) (msgs[msgcode], name);\n+  warning (msgs[msgcode], name);\n   warning_with_file_and_line (DECL_SOURCE_FILE (decl),\n \t\t\t      DECL_SOURCE_LINE (decl),\n \t\t\t      \"shadowed declaration is here\");"}, {"sha": "432b351da50ea65cdb87ad09fa90a8c17bce1ff1", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -335,7 +335,7 @@ extern tree c_begin_while_stmt\t\t\tPARAMS ((void));\n extern void c_finish_while_stmt_cond\t\tPARAMS ((tree, tree));\n \n enum sw_kind { SW_PARAM = 0, SW_LOCAL, SW_GLOBAL };\n-extern void shadow_warning\t\t\tPARAMS ((enum sw_kind, int,\n+extern void shadow_warning\t\t\tPARAMS ((enum sw_kind,\n \t\t\t\t\t\t\t const char *, tree));\n \n /* Extra information associated with a DECL.  Other C dialects extend"}, {"sha": "4b2e6e13c8aaba07c430dfea3932c5da796139e0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 543, "deletions": 766, "changes": 1309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for C compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002 Free Software Foundation, Inc.\n+   2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -122,6 +122,10 @@ static GTY(()) tree named_labels;\n \n static GTY(()) tree shadowed_labels;\n \n+/* A list of external DECLs that appeared at block scope when there was\n+   some other global meaning for that identifier.  */\n+static GTY(()) tree truly_local_externals;\n+\n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n \n@@ -159,9 +163,6 @@ static int current_extern_inline;\n  * the current one out to the global one.\n  */\n \n-/* Note that the information in the `names' component of the global contour\n-   is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n-\n struct binding_level GTY(())\n   {\n     /* A chain of _DECL nodes for all variables, constants, functions,\n@@ -177,35 +178,34 @@ struct binding_level GTY(())\n      */\n     tree tags;\n \n-    /* For each level, a list of shadowed outer-level local definitions\n+    /* For each level, a list of shadowed outer-level definitions\n        to be restored when this level is popped.\n        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */\n     tree shadowed;\n \n+    /* For each level, a list of shadowed outer-level tag definitions\n+       to be restored when this level is popped.\n+       Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and\n+       whose TREE_VALUE is its old definition (a kind of ..._TYPE node).  */\n+    tree shadowed_tags;\n+\n     /* For each level (except not the global one),\n        a chain of BLOCK nodes for all the levels\n        that were entered and exited one level down.  */\n     tree blocks;\n \n-    /* The BLOCK node for this level, if one has been preallocated.\n-       If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n-    tree this_block;\n-\n     /* The binding level which this one is contained in (inherits from).  */\n     struct binding_level *level_chain;\n \n-    /* Nonzero for the level that holds the parameters of a function.  */\n+    /* Nonzero if we are currently filling this level with parameter\n+       declarations.  */\n     char parm_flag;\n \n-    /* Nonzero if this level \"doesn't exist\" for tags.  */\n-    char tag_transparent;\n-\n-    /* Nonzero if sublevels of this level \"don't exist\" for tags.\n-       This is set in the parm level of a function definition\n-       while reading the function body, so that the outermost block\n-       of the function body will be tag-transparent.  */\n-    char subblocks_tag_transparent;\n+    /* Nonzero if this is the outermost block scope of a function body.\n+       This scope contains both the parameters and the local variables\n+       declared in the outermost block.  */\n+    char function_body;\n \n     /* Nonzero means make a BLOCK for this level regardless of all else.  */\n     char keep;\n@@ -239,12 +239,6 @@ static GTY((deletable (\"\"))) struct binding_level *free_binding_level;\n \n static GTY(()) struct binding_level *global_binding_level;\n \n-/* Binding level structures are initialized by copying this one.  */\n-\n-static struct binding_level clear_binding_level\n-  = {NULL, NULL, NULL, NULL, NULL, NULL_BINDING_LEVEL, 0, 0, 0, 0, 0, NULL,\n-     NULL};\n-\n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n \n static int keep_next_level_flag;\n@@ -269,23 +263,24 @@ tree static_ctors, static_dtors;\n /* Forward declarations.  */\n \n static struct binding_level *make_binding_level\t\tPARAMS ((void));\n-static struct binding_level *get_function_binding_level PARAMS ((void));\n static void pop_binding_level\t\tPARAMS ((struct binding_level **));\n-static void clear_limbo_values\t\tPARAMS ((tree));\n static int duplicate_decls\t\tPARAMS ((tree, tree, int));\n static int redeclaration_error_message\tPARAMS ((tree, tree));\n+static void implicit_decl_warning       PARAMS ((tree));\n static void storedecls\t\t\tPARAMS ((tree));\n static void storetags\t\t\tPARAMS ((tree));\n-static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree,\n-\t\t\t\t\t\t struct binding_level *, int));\n-static tree lookup_tag_reverse\t\tPARAMS ((tree));\n+static tree lookup_tag\t\t\tPARAMS ((enum tree_code, tree, int));\n+static tree lookup_name_current_level\tPARAMS ((tree));\n static tree grokdeclarator\t\tPARAMS ((tree, tree, enum decl_context,\n \t\t\t\t\t\t int));\n static tree grokparms\t\t\tPARAMS ((tree, int));\n static void layout_array_type\t\tPARAMS ((tree));\n static tree c_make_fname_decl           PARAMS ((tree, int));\n static void c_expand_body_1             PARAMS ((tree, int));\n+static tree any_external_decl\t\tPARAMS ((tree));\n+static void record_external_decl\tPARAMS ((tree));\n static void warn_if_shadowing\t\tPARAMS ((tree, tree));\n+static void clone_underlying_type\tPARAMS ((tree));\n static bool flexible_array_type_p\tPARAMS ((tree));\n \f\n /* States indicating how grokdeclarator() should handle declspecs marked\n@@ -306,11 +301,9 @@ c_print_identifier (file, node, indent)\n      tree node;\n      int indent;\n {\n-  print_node (file, \"global\", IDENTIFIER_GLOBAL_VALUE (node), indent + 4);\n-  print_node (file, \"local\", IDENTIFIER_LOCAL_VALUE (node), indent + 4);\n+  print_node (file, \"symbol\", IDENTIFIER_SYMBOL_VALUE (node), indent + 4);\n+  print_node (file, \"tag\", IDENTIFIER_TAG_VALUE (node), indent + 4);\n   print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n-  print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n-  print_node (file, \"limbo value\", IDENTIFIER_LIMBO_VALUE (node), indent + 4);\n   if (C_IS_RESERVED_WORD (node))\n     {\n       tree rid = ridpointers[C_RID_CODE (node)];\n@@ -350,25 +343,18 @@ c_finish_incomplete_decl (decl)\n static struct binding_level *\n make_binding_level ()\n {\n+  struct binding_level *result;\n   if (free_binding_level)\n     {\n-      struct binding_level *result = free_binding_level;\n+      result = free_binding_level;\n       free_binding_level = result->level_chain;\n-      return result;\n+      memset (result, 0, sizeof(struct binding_level));\n     }\n   else\n-    return (struct binding_level *) ggc_alloc (sizeof (struct binding_level));\n-}\n+    result = (struct binding_level *)\n+      ggc_alloc_cleared (sizeof (struct binding_level));\n \n-/* Return the outermost binding level for the current function.  */\n-static struct binding_level *\n-get_function_binding_level ()\n-{\n-  struct binding_level *b = current_binding_level;\n-\n-  while (b->level_chain->parm_flag == 0)\n-    b = b->level_chain;\n-  return b;\n+  return result;\n }\n \n /* Remove a binding level from a list and add it to the level chain.  */\n@@ -408,8 +394,7 @@ kept_level_p ()\n \t   && current_binding_level->blocks != 0)\n \t  || current_binding_level->keep\n \t  || current_binding_level->names != 0\n-\t  || (current_binding_level->tags != 0\n-\t      && !current_binding_level->tag_transparent));\n+\t  || current_binding_level->tags != 0);\n }\n \n /* Identify this binding level as a level of parameters.\n@@ -432,57 +417,45 @@ in_parm_level_p ()\n   return current_binding_level->parm_flag;\n }\n \n-/* Enter a new binding level.\n-   If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,\n-   not for that of tags.  */\n+/* Enter a new binding level.  */\n \n void\n-pushlevel (tag_transparent)\n-     int tag_transparent;\n+pushlevel (dummy)\n+     int dummy ATTRIBUTE_UNUSED;\n {\n-  struct binding_level *newlevel = NULL_BINDING_LEVEL;\n-\n-  /* If this is the top level of a function,\n-     just make sure that NAMED_LABELS is 0.  */\n+  /* If this is the top level of a function, make sure that\n+     NAMED_LABELS is 0.  */\n \n   if (current_binding_level == global_binding_level)\n+    named_labels = 0;\n+\n+  if (keep_next_if_subblocks)\n     {\n-      named_labels = 0;\n+      /* This is the transition from the parameters to the top level\n+\t of the function body.  These are the same scope\n+\t (C99 6.2.1p4,6) so we do not push another binding level.\n+\n+\t XXX Note kludge - keep_next_if_subblocks is set only by\n+\t store_parm_decls, which in turn is called when and only\n+\t when we are about to encounter the opening curly brace for\n+\t the function body.  */\n+      current_binding_level->parm_flag = 0;\n+      current_binding_level->function_body = 1;\n+      current_binding_level->keep |= keep_next_level_flag;\n+      current_binding_level->keep_if_subblocks = 1;\n+\n+      keep_next_level_flag = 0;\n+      keep_next_if_subblocks = 0;\n     }\n+  else\n+    {\n+      struct binding_level *newlevel = make_binding_level ();\n \n-  newlevel = make_binding_level ();\n-\n-  /* Add this level to the front of the chain (stack) of levels that\n-     are active.  */\n-\n-  *newlevel = clear_binding_level;\n-  newlevel->tag_transparent\n-    = (tag_transparent\n-       || (current_binding_level\n-\t   ? current_binding_level->subblocks_tag_transparent\n-\t   : 0));\n-  newlevel->level_chain = current_binding_level;\n-  current_binding_level = newlevel;\n-  newlevel->keep = keep_next_level_flag;\n-  keep_next_level_flag = 0;\n-  newlevel->keep_if_subblocks = keep_next_if_subblocks;\n-  keep_next_if_subblocks = 0;\n-}\n-\n-/* Clear the limbo values of all identifiers defined in BLOCK or a subblock.  */\n-\n-static void\n-clear_limbo_values (block)\n-     tree block;\n-{\n-  tree tem;\n-\n-  for (tem = BLOCK_VARS (block); tem; tem = TREE_CHAIN (tem))\n-    if (DECL_NAME (tem) != 0)\n-      IDENTIFIER_LIMBO_VALUE (DECL_NAME (tem)) = 0;\n-\n-  for (tem = BLOCK_SUBBLOCKS (block); tem; tem = TREE_CHAIN (tem))\n-    clear_limbo_values (tem);\n+      newlevel->keep              = keep_next_level_flag;\n+      newlevel->level_chain       = current_binding_level;\n+      current_binding_level = newlevel;\n+      keep_next_level_flag = 0;\n+    }\n }\n \n /* Exit a binding level.\n@@ -507,146 +480,135 @@ poplevel (keep, reverse, functionbody)\n      int functionbody;\n {\n   tree link;\n-  /* The chain of decls was accumulated in reverse order.\n-     Put it into forward order, just for cleanliness.  */\n-  tree decls;\n+  tree block;\n+  tree decl;\n+  tree decls = current_binding_level->names;\n   tree tags = current_binding_level->tags;\n   tree subblocks = current_binding_level->blocks;\n-  tree block = 0;\n-  tree decl;\n-  int block_previously_created;\n \n-  keep |= current_binding_level->keep;\n+  functionbody |= current_binding_level->function_body;\n+  keep |= (current_binding_level->keep || functionbody\n+\t   || (current_binding_level->keep_if_subblocks && subblocks != 0));\n \n-  /* This warning is turned off because it causes warnings for\n-     declarations like `extern struct foo *x'.  */\n-#if 0\n-  /* Warn about incomplete structure types in this level.  */\n+  /* We used to warn about unused variables in expand_end_bindings,\n+     i.e. while generating RTL.  But in function-at-a-time mode we may\n+     choose to never expand a function at all (e.g. auto inlining), so\n+     we do this explicitly now.  */\n+  warn_about_unused_variables (decls);\n+\n+  /* Clear out the name-meanings declared on this level.\n+     Propagate TREE_ADDRESSABLE from nested functions to their\n+     containing functions.  */\n+  for (link = decls; link; link = TREE_CHAIN (link))\n+    {\n+      if (DECL_NAME (link) != 0)\n+\t{\n+\t  if (DECL_EXTERNAL (link))\n+\t    /* External decls stay in the symbol-value slot but are\n+\t       inaccessible.  */\n+\t    C_DECL_INVISIBLE (link) = 1;\n+\t  else\n+\t    IDENTIFIER_SYMBOL_VALUE (DECL_NAME (link)) = 0;\n+\t}\n+\n+      if (TREE_CODE (link) == FUNCTION_DECL\n+\t  && ! TREE_ASM_WRITTEN (link)\n+\t  && DECL_INITIAL (link) != 0\n+\t  && TREE_ADDRESSABLE (link)\n+\t  && DECL_ABSTRACT_ORIGIN (link) != 0\n+\t  && DECL_ABSTRACT_ORIGIN (link) != link)\n+\tTREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (link)) = 1;\n+    }\n+\n+  /* Clear out the tag-meanings declared on this level.  */\n   for (link = tags; link; link = TREE_CHAIN (link))\n-    if (!COMPLETE_TYPE_P (TREE_VALUE (link)))\n-      {\n-\ttree type = TREE_VALUE (link);\n-\ttree type_name = TYPE_NAME (type);\n-\tchar *id = IDENTIFIER_POINTER (TREE_CODE (type_name) == IDENTIFIER_NODE\n-\t\t\t\t       ? type_name\n-\t\t\t\t       : DECL_NAME (type_name));\n-\tswitch (TREE_CODE (type))\n-\t  {\n-\t  case RECORD_TYPE:\n-\t    error (\"`struct %s' incomplete in scope ending here\", id);\n-\t    break;\n-\t  case UNION_TYPE:\n-\t    error (\"`union %s' incomplete in scope ending here\", id);\n-\t    break;\n-\t  case ENUMERAL_TYPE:\n-\t    error (\"`enum %s' incomplete in scope ending here\", id);\n-\t    break;\n-\t  }\n-      }\n-#endif /* 0 */\n+    if (TREE_PURPOSE (link))\n+      IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = 0;\n+\n+  /* Restore all name-meanings of the outer levels\n+     that were shadowed by this level.  */\n+\n+  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n+    IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\n+  /* Restore all tag-meanings of the outer levels\n+     that were shadowed by this level.  */\n+\n+  for (link = current_binding_level->shadowed_tags; link;\n+       link = TREE_CHAIN (link))\n+    IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\n+  /* If this is the top level block of a function, remove all\n+     PARM_DECLs from current_binding_level->names; they are already\n+     stored in DECL_ARGUMENTS of cfun->decl in proper order, should\n+     not be put in BLOCK_VARS, and furthermore reversing them will\n+     cause trouble later.  They are all together at the end of the\n+     list.  */\n+  if (functionbody && decls)\n+    {\n+      if (TREE_CODE (decls) == PARM_DECL)\n+\tdecls = 0;\n+      else\n+\t{\n+\t  link = decls;\n+\t  while (TREE_CHAIN (link)\n+\t\t && TREE_CODE (TREE_CHAIN (link)) != PARM_DECL)\n+\t    link = TREE_CHAIN (link);\n+\n+\t  TREE_CHAIN (link) = 0;\n+\t}\n+    }\n \n   /* Get the decls in the order they were written.\n      Usually current_binding_level->names is in reverse order.\n      But parameter decls were previously put in forward order.  */\n \n   if (reverse)\n-    current_binding_level->names\n-      = decls = nreverse (current_binding_level->names);\n-  else\n-    decls = current_binding_level->names;\n-\n-  /* Output any nested inline functions within this block\n-     if they weren't already output.  */\n-\n-  for (decl = decls; decl; decl = TREE_CHAIN (decl))\n-    if (TREE_CODE (decl) == FUNCTION_DECL\n-\t&& ! TREE_ASM_WRITTEN (decl)\n-\t&& DECL_INITIAL (decl) != 0\n-\t&& TREE_ADDRESSABLE (decl))\n-      {\n-\t/* If this decl was copied from a file-scope decl\n-\t   on account of a block-scope extern decl,\n-\t   propagate TREE_ADDRESSABLE to the file-scope decl.\n-\n-\t   DECL_ABSTRACT_ORIGIN can be set to itself if warn_return_type is\n-\t   true, since then the decl goes through save_for_inline_copying.  */\n-\tif (DECL_ABSTRACT_ORIGIN (decl) != 0\n-\t    && DECL_ABSTRACT_ORIGIN (decl) != decl)\n-\t  TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (decl)) = 1;\n-      }\n-\n-  /* We used to warn about unused variables in expand_end_bindings,\n-     i.e. while generating RTL.  But in function-at-a-time mode we may\n-     choose to never expand a function at all (e.g. auto inlining), so\n-     we do this explicitly now.  */\n-  warn_about_unused_variables (getdecls ());\n+    decls = nreverse (decls);\n \n   /* If there were any declarations or structure tags in that level,\n      or if this level is a function body,\n      create a BLOCK to record them for the life of this function.  */\n \n   block = 0;\n-  block_previously_created = (current_binding_level->this_block != 0);\n-  if (block_previously_created)\n-    block = current_binding_level->this_block;\n-  else if (keep || functionbody\n-\t   || (current_binding_level->keep_if_subblocks && subblocks != 0))\n-    block = make_node (BLOCK);\n-  if (block != 0)\n+  if (keep)\n     {\n+      block = make_node (BLOCK);\n       BLOCK_VARS (block) = decls;\n       BLOCK_SUBBLOCKS (block) = subblocks;\n+      TREE_USED (block) = 1;\n     }\n \n   /* In each subblock, record that this is its superior.  */\n \n   for (link = subblocks; link; link = TREE_CHAIN (link))\n     BLOCK_SUPERCONTEXT (link) = block;\n \n-  /* Clear out the meanings of the local variables of this level.  */\n-\n-  for (link = decls; link; link = TREE_CHAIN (link))\n-    {\n-      if (DECL_NAME (link) != 0)\n-\t{\n-\t  /* If the ident. was used or addressed via a local extern decl,\n-\t     don't forget that fact.  */\n-\t  if (DECL_EXTERNAL (link))\n-\t    {\n-\t      if (TREE_USED (link))\n-\t\tTREE_USED (DECL_NAME (link)) = 1;\n-\t      if (TREE_ADDRESSABLE (link))\n-\t\tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (link)) = 1;\n-\t    }\n-\t  IDENTIFIER_LOCAL_VALUE (DECL_NAME (link)) = 0;\n-\t}\n-    }\n+  /* Set the TYPE_CONTEXTs for all of the tagged types belonging to this\n+     binding contour so that they point to the appropriate construct, i.e.\n+     either to the current FUNCTION_DECL node, or else to the BLOCK node\n+     we just constructed.\n \n-  /* Restore all name-meanings of the outer levels\n-     that were shadowed by this level.  */\n+     Note that for tagged types whose scope is just the formal parameter\n+     list for some function type specification, we can't properly set\n+     their TYPE_CONTEXTs here, because we don't have a pointer to the\n+     appropriate FUNCTION_TYPE node readily available to us.  For those\n+     cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set\n+     in `grokdeclarator' as soon as we have created the FUNCTION_TYPE\n+     node which will represent the \"scope\" for these \"parameter list local\"\n+     tagged types.  */\n \n-  for (link = current_binding_level->shadowed; link; link = TREE_CHAIN (link))\n-    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  decl = functionbody ? current_function_decl : block;\n+  if (decl)\n+    for (link = tags; link; link = TREE_CHAIN (link))\n+      TYPE_CONTEXT (TREE_VALUE (link)) = decl;\n \n-  /* If the level being exited is the top level of a function,\n-     check over all the labels, and clear out the current\n-     (function local) meanings of their names.  */\n+  /* If the level being exited is the top level of a function, check\n+     over all the labels, and clear out the current (function local)\n+     meanings of their names. Then add them to BLOCK_VARS.  */\n \n   if (functionbody)\n     {\n-      clear_limbo_values (block);\n-\n-      /* If this is the top level block of a function,\n-\t the vars are the function's parameters.\n-\t Don't leave them in the BLOCK because they are\n-\t found in the FUNCTION_DECL instead.  */\n-\n-      BLOCK_VARS (block) = 0;\n-\n-      /* Clear out the definitions of all label names,\n-\t since their scopes end here,\n-\t and add them to BLOCK_VARS.  */\n-\n       for (link = named_labels; link; link = TREE_CHAIN (link))\n \t{\n \t  tree label = TREE_VALUE (link);\n@@ -677,11 +639,8 @@ poplevel (keep, reverse, functionbody)\n   if (functionbody)\n     DECL_INITIAL (current_function_decl) = block;\n   else if (block)\n-    {\n-      if (!block_previously_created)\n-\tcurrent_binding_level->blocks\n-\t  = chainon (current_binding_level->blocks, block);\n-    }\n+    current_binding_level->blocks\n+      = chainon (current_binding_level->blocks, block);\n   /* If we did not make a block for the level just exited,\n      any blocks made for inner levels\n      (since they cannot be recorded as subblocks in that level)\n@@ -691,30 +650,6 @@ poplevel (keep, reverse, functionbody)\n     current_binding_level->blocks\n       = chainon (current_binding_level->blocks, subblocks);\n \n-  /* Set the TYPE_CONTEXTs for all of the tagged types belonging to this\n-     binding contour so that they point to the appropriate construct, i.e.\n-     either to the current FUNCTION_DECL node, or else to the BLOCK node\n-     we just constructed.\n-\n-     Note that for tagged types whose scope is just the formal parameter\n-     list for some function type specification, we can't properly set\n-     their TYPE_CONTEXTs here, because we don't have a pointer to the\n-     appropriate FUNCTION_TYPE node readily available to us.  For those\n-     cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set\n-     in `grokdeclarator' as soon as we have created the FUNCTION_TYPE\n-     node which will represent the \"scope\" for these \"parameter list local\"\n-     tagged types.  */\n-\n-  if (functionbody)\n-    for (link = tags; link; link = TREE_CHAIN (link))\n-      TYPE_CONTEXT (TREE_VALUE (link)) = current_function_decl;\n-  else if (block)\n-    for (link = tags; link; link = TREE_CHAIN (link))\n-      TYPE_CONTEXT (TREE_VALUE (link)) = block;\n-\n-  if (block)\n-    TREE_USED (block) = 1;\n-\n   return block;\n }\n \n@@ -731,18 +666,14 @@ insert_block (block)\n     = chainon (current_binding_level->blocks, block);\n }\n \n-/* Set the BLOCK node for the innermost scope\n-   (the one we are currently in).  */\n+/* Set the BLOCK node for the innermost scope (the one we are\n+   currently in).  The RTL expansion machinery requires us to provide\n+   this hook, but it is not useful in function-at-a-time mode.  */\n \n void\n set_block (block)\n-     tree block;\n+     tree block ATTRIBUTE_UNUSED;\n {\n-  current_binding_level->this_block = block;\n-  current_binding_level->names = chainon (current_binding_level->names,\n-\t\t\t\t\t  BLOCK_VARS (block));\n-  current_binding_level->blocks = chainon (current_binding_level->blocks,\n-\t\t\t\t\t   BLOCK_SUBBLOCKS (block));\n }\n \f\n void\n@@ -826,19 +757,19 @@ void\n pushtag (name, type)\n      tree name, type;\n {\n-  struct binding_level *b;\n-\n-  /* Find the proper binding level for this type tag.  */\n-\n-  for (b = current_binding_level; b->tag_transparent; b = b->level_chain)\n-    continue;\n+  struct binding_level *b = current_binding_level;\n \n   if (name)\n     {\n       /* Record the identifier as the type's name if it has none.  */\n \n       if (TYPE_NAME (type) == 0)\n \tTYPE_NAME (type) = name;\n+\n+      if (IDENTIFIER_TAG_VALUE (name))\n+\tb->shadowed_tags = tree_cons (name, IDENTIFIER_TAG_VALUE (name),\n+\t\t\t\t      b->shadowed_tags);\n+      IDENTIFIER_TAG_VALUE (name) = type;\n     }\n \n   b->tags = tree_cons (name, type, b->tags);\n@@ -966,11 +897,14 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n       return 0;\n     }\n \n-  /* For real parm decl following a forward decl,\n-     return 1 so old decl will be reused.  */\n+  /* For real parm decl following a forward decl, return 1 so old decl\n+     will be reused.  Only allow this to happen once.  */\n   if (types_match && TREE_CODE (newdecl) == PARM_DECL\n       && TREE_ASM_WRITTEN (olddecl) && ! TREE_ASM_WRITTEN (newdecl))\n-    return 1;\n+    {\n+      TREE_ASM_WRITTEN (olddecl) = 0;\n+      return 1;\n+    }\n \n   /* The new declaration is the same kind of object as the old one.\n      The declarations may partially match.  Print warnings if they don't\n@@ -1107,6 +1041,20 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t we will come back here again.  */\n       DECL_IN_SYSTEM_HEADER (newdecl) = 1;\n     }\n+  /* Permit void foo (...) to match int foo (...) if the latter is the\n+     definition and implicit int was used.  See c-torture/compile/920625-2.c.  */\n+  else if (!types_match\t&& new_is_definition\n+\t   && TREE_CODE (olddecl) == FUNCTION_DECL\n+\t   && TREE_CODE (newdecl) == FUNCTION_DECL\n+\t   && TYPE_MAIN_VARIANT (TREE_TYPE (oldtype)) == void_type_node\n+\t   && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n+\t   && C_FUNCTION_IMPLICIT_INT (newdecl))\n+    {\n+      pedwarn_with_decl (newdecl, \"conflicting types for `%s'\");\n+      /* Make sure we keep void as the return type.  */\n+      TREE_TYPE (newdecl) = newtype = oldtype;\n+      C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n+    }\n   else if (!types_match\n \t   /* Permit char *foo (int, ...); followed by char *foo ();\n \t      if not pedantic.  */\n@@ -1151,7 +1099,10 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t\t}\n \t    }\n \t}\n-      error_with_decl (olddecl, \"previous declaration of `%s'\");\n+      if (C_DECL_IMPLICIT (olddecl))\n+\terror_with_decl (olddecl, \"previous implicit declaration of `%s'\");\n+      else\n+\terror_with_decl (olddecl, \"previous declaration of `%s'\");\n \n       /* This is safer because the initializer might contain references\n \t to variables that were declared between olddecl and newdecl. This\n@@ -1592,58 +1543,137 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   return 1;\n }\n \n+/* Return any external DECL associated with ID, whether or not it is\n+   currently in scope.  */\n+static tree\n+any_external_decl (id)\n+     tree id;\n+{\n+  tree decl = IDENTIFIER_SYMBOL_VALUE (id);\n+  tree t;\n+\n+  if (decl && TREE_CODE (decl) != TYPE_DECL && DECL_EXTERNAL (decl))\n+    return decl;\n+\n+  t = purpose_member (id, truly_local_externals);\n+  if (t)\n+    return TREE_VALUE (t);\n+\n+  return 0;\n+}\n+\n+/* Record an external decl DECL.  This only does something if a\n+   shadowing decl already exists.  */\n+static void\n+record_external_decl (decl)\n+     tree decl;\n+{\n+  tree name = DECL_NAME (decl);\n+  if (!IDENTIFIER_SYMBOL_VALUE (name))\n+    return;\n+\n+  truly_local_externals = tree_cons (name, decl, truly_local_externals);\n+}\n+\n /* Check whether decl-node X shadows an existing declaration.\n-   OLDLOCAL is the old IDENTIFIER_LOCAL_VALUE of the DECL_NAME of X,\n+   OLD is the old IDENTIFIER_SYMBOL_VALUE of the DECL_NAME of X,\n    which might be a NULL_TREE.  */\n static void\n-warn_if_shadowing (x, oldlocal)\n-     tree x, oldlocal;\n+warn_if_shadowing (x, old)\n+     tree x, old;\n {\n-  tree sym;\n   const char *name;\n \n-  if (DECL_EXTERNAL (x))\n+  /* Nothing to shadow?  */\n+  if (old == 0\n+      /* Shadow warnings not wanted?  */\n+      || !warn_shadow\n+      /* No shadow warnings for internally generated vars.  */\n+      || DECL_SOURCE_LINE (x) == 0\n+      /* No shadow warnings for vars made for inlining.  */\n+      || DECL_FROM_INLINE (x)\n+      /* Don't warn about the parm names in function declarator\n+\t within a function declarator.\n+\t It would be nice to avoid warning in any function\n+\t declarator in a declaration, as opposed to a definition,\n+\t but there is no way to tell it's not a definition.  */\n+      || (TREE_CODE (x) == PARM_DECL\n+\t  && current_binding_level->level_chain->parm_flag))\n     return;\n \n-  sym = DECL_NAME (x);\n-  name = IDENTIFIER_POINTER (sym);\n-\n-  /* Warn if shadowing an argument at the top level of the body.  */\n-  if (oldlocal != 0\n-      /* This warning doesn't apply to the parms of a nested fcn.  */\n-      && ! current_binding_level->parm_flag\n-      /* Check that this is one level down from the parms.  */\n-      && current_binding_level->level_chain->parm_flag\n-      /* Check that the decl being shadowed\n-\t comes from the parm level, one level up.  */\n-      && chain_member (oldlocal, current_binding_level->level_chain->names))\n-    shadow_warning (SW_PARAM, true, name, oldlocal);\n-  /* Maybe warn if shadowing something else.  */\n-  else if (warn_shadow\n-\t   /* No shadow warnings for internally generated vars.  */\n-\t   && DECL_SOURCE_LINE (x) != 0\n-\t   /* No shadow warnings for vars made for inlining.  */\n-\t   && ! DECL_FROM_INLINE (x))\n+  name = IDENTIFIER_POINTER (DECL_NAME (x));\n+\n+  if (TREE_CODE (old) == PARM_DECL)\n+    shadow_warning (SW_PARAM, name, old);\n+  else if (DECL_CONTEXT (old) == 0)\n+    shadow_warning (SW_GLOBAL, name, old);\n+  else\n+    shadow_warning (SW_LOCAL, name, old);\n+}\n+\n+\n+/* Subroutine of pushdecl.\n+\n+   X is a TYPE_DECL for a typedef statement.  Create a brand new\n+   ..._TYPE node (which will be just a variant of the existing\n+   ..._TYPE node with identical properties) and then install X\n+   as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n+\n+   The whole point here is to end up with a situation where each\n+   and every ..._TYPE node the compiler creates will be uniquely\n+   associated with AT MOST one node representing a typedef name.\n+   This way, even though the compiler substitutes corresponding\n+   ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n+   early on, later parts of the compiler can always do the reverse\n+   translation and get back the corresponding typedef name.  For\n+   example, given:\n+\n+        typedef struct S MY_TYPE;\n+\tMY_TYPE object;\n+\n+   Later parts of the compiler might only know that `object' was of\n+   type `struct S' if it were not for code just below.  With this\n+   code however, later parts of the compiler see something like:\n+\n+\tstruct S' == struct S\n+\ttypedef struct S' MY_TYPE;\n+\tstruct S' object;\n+\n+    And they can then deduce (from the node for type struct S') that\n+    the original object declaration was:\n+\n+\t\tMY_TYPE object;\n+\n+    Being able to do this is important for proper support of protoize,\n+    and also for generating precise symbolic debugging information\n+    which takes full account of the programmer's (typedef) vocabulary.\n+\n+    Obviously, we don't want to generate a duplicate ..._TYPE node if\n+    the TYPE_DECL node that we are now processing really represents a\n+    standard built-in type.\n+\n+    Since all standard types are effectively declared at line zero\n+    in the source file, we can easily check to see if we are working\n+    on a standard type by checking the current value of lineno.  */\n+\n+static void\n+clone_underlying_type (x)\n+     tree x;\n+{\n+  if (DECL_SOURCE_LINE (x) == 0)\n     {\n-      if (TREE_CODE (x) == PARM_DECL\n-\t  && current_binding_level->level_chain->parm_flag)\n-\t/* Don't warn about the parm names in function declarator\n-\t   within a function declarator.\n-\t   It would be nice to avoid warning in any function\n-\t   declarator in a declaration, as opposed to a definition,\n-\t   but there is no way to tell it's not a definition.  */\n-\t;\n-      else if (oldlocal)\n-\t{\n-\t  if (TREE_CODE (oldlocal) == PARM_DECL)\n-\t    shadow_warning (SW_PARAM, false, name, oldlocal);\n-\t  else\n-\t    shadow_warning (SW_LOCAL, false, name, oldlocal);\n-\t}\n-      else if (IDENTIFIER_GLOBAL_VALUE (sym) != 0\n-\t       && IDENTIFIER_GLOBAL_VALUE (sym) != error_mark_node)\n-\tshadow_warning (SW_GLOBAL, false, name,\n-\t\t\tIDENTIFIER_GLOBAL_VALUE (sym));\n+      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n+\tTYPE_NAME (TREE_TYPE (x)) = x;\n+    }\n+  else if (TREE_TYPE (x) != error_mark_node\n+\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n+    {\n+      tree tt = TREE_TYPE (x);\n+      DECL_ORIGINAL_TYPE (x) = tt;\n+      tt = build_type_copy (tt);\n+      TYPE_NAME (tt) = x;\n+      TREE_USED (tt) = TREE_USED (x);\n+      TREE_TYPE (x) = tt;\n     }\n }\n \n@@ -1659,343 +1689,79 @@ tree\n pushdecl (x)\n      tree x;\n {\n-  tree t;\n   tree name = DECL_NAME (x);\n-  struct binding_level *b = current_binding_level;\n+  struct binding_level *scope = current_binding_level;\n+\n+#ifdef ENABLE_CHECKING\n+  if (error_mark_node == 0)\n+    /* Called too early.  */\n+    abort ();\n+#endif\n \n   /* Functions need the lang_decl data.  */\n   if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_LANG_SPECIFIC (x))\n     DECL_LANG_SPECIFIC (x) = (struct lang_decl *)\n       ggc_alloc_cleared (sizeof (struct lang_decl));\n \n-  DECL_CONTEXT (x) = current_function_decl;\n   /* A local extern declaration for a function doesn't constitute nesting.\n      A local auto declaration does, since it's a forward decl\n      for a nested function coming later.  */\n   if ((TREE_CODE (x) == FUNCTION_DECL || TREE_CODE (x) == VAR_DECL)\n       && DECL_INITIAL (x) == 0 && DECL_EXTERNAL (x))\n     DECL_CONTEXT (x) = 0;\n+  else\n+    DECL_CONTEXT (x) = current_function_decl;\n \n   if (name)\n     {\n-      int different_binding_level = 0;\n+      tree old;\n \n       if (warn_nested_externs\n+\t  && scope != global_binding_level\n \t  && DECL_EXTERNAL (x)\n-\t  && b != global_binding_level\n-\t  && x != IDENTIFIER_IMPLICIT_DECL (name)\n-\t  /* No error messages for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n \twarning (\"nested extern declaration of `%s'\",\n \t\t IDENTIFIER_POINTER (name));\n \n-      t = lookup_name_current_level (name);\n-      if (! t && DECL_EXTERNAL (x) && TREE_PUBLIC (x))\n-\t{\n-\t  t = IDENTIFIER_GLOBAL_VALUE (name);\n-\t  /* Type decls at global scope don't conflict with externs declared\n-\t     inside lexical blocks.  */\n-\t  if (! t || TREE_CODE (t) == TYPE_DECL)\n-\t    /* If there's no visible global declaration, try for an\n-               invisible one.  */\n-\t    t = IDENTIFIER_LIMBO_VALUE (name);\n-\t  different_binding_level = 1;\n-\t}\n-      if (t != 0 && t == error_mark_node)\n-\t/* error_mark_node is 0 for a while during initialization!  */\n-\t{\n-\t  t = 0;\n-\t  error_with_decl (x, \"`%s' used prior to declaration\");\n-\t}\n-\n-      /* If this decl is `static' and an implicit decl was seen previously,\n-\t warn.  */\n-      if (TREE_PUBLIC (name)\n-\t  /* Don't test for DECL_EXTERNAL, because grokdeclarator\n-\t     sets this for all functions.  */\n-\t  && ! TREE_PUBLIC (x)\n-\t  && (TREE_CODE (x) == FUNCTION_DECL || b == global_binding_level)\n-\t  /* We used to warn also for explicit extern followed by static,\n-\t     but sometimes you need to do it that way.  */\n-\t  && IDENTIFIER_IMPLICIT_DECL (name) != 0)\n-\t{\n-\t  pedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n-\t\t   IDENTIFIER_POINTER (name));\n-\t  pedwarn_with_file_and_line\n-\t    (DECL_SOURCE_FILE (IDENTIFIER_IMPLICIT_DECL (name)),\n-\t     DECL_SOURCE_LINE (IDENTIFIER_IMPLICIT_DECL (name)),\n-\t     \"previous declaration of `%s'\",\n-\t     IDENTIFIER_POINTER (name));\n-\t  TREE_THIS_VOLATILE (name) = 1;\n-\t}\n-\n-      if (t != 0 && duplicate_decls (x, t, different_binding_level))\n-\t{\n-\t  if (TREE_CODE (t) == PARM_DECL)\n-\t    {\n-\t      /* Don't allow more than one \"real\" duplicate\n-\t\t of a forward parm decl.  */\n-\t      TREE_ASM_WRITTEN (t) = TREE_ASM_WRITTEN (x);\n-\t      return t;\n-\t    }\n-\t  return t;\n-\t}\n-\n-      /* If we are processing a typedef statement, generate a whole new\n-\t ..._TYPE node (which will be just a variant of the existing\n-\t ..._TYPE node with identical properties) and then install the\n-\t TYPE_DECL node generated to represent the typedef name as the\n-\t TYPE_NAME of this brand new (duplicate) ..._TYPE node.\n-\n-\t The whole point here is to end up with a situation where each\n-\t and every ..._TYPE node the compiler creates will be uniquely\n-\t associated with AT MOST one node representing a typedef name.\n-\t This way, even though the compiler substitutes corresponding\n-\t ..._TYPE nodes for TYPE_DECL (i.e. \"typedef name\") nodes very\n-\t early on, later parts of the compiler can always do the reverse\n-\t translation and get back the corresponding typedef name.  For\n-\t example, given:\n-\n-\t\ttypedef struct S MY_TYPE;\n-\t\tMY_TYPE object;\n-\n-\t Later parts of the compiler might only know that `object' was of\n-\t type `struct S' if it were not for code just below.  With this\n-\t code however, later parts of the compiler see something like:\n-\n-\t\tstruct S' == struct S\n-\t\ttypedef struct S' MY_TYPE;\n-\t\tstruct S' object;\n-\n-\t And they can then deduce (from the node for type struct S') that\n-\t the original object declaration was:\n-\n-\t\tMY_TYPE object;\n-\n-\t Being able to do this is important for proper support of protoize,\n-\t and also for generating precise symbolic debugging information\n-\t which takes full account of the programmer's (typedef) vocabulary.\n-\n-         Obviously, we don't want to generate a duplicate ..._TYPE node if\n-\t the TYPE_DECL node that we are now processing really represents a\n-\t standard built-in type.\n-\n-         Since all standard types are effectively declared at line zero\n-         in the source file, we can easily check to see if we are working\n-         on a standard type by checking the current value of lineno.  */\n-\n-      if (TREE_CODE (x) == TYPE_DECL)\n+      old = lookup_name_current_level (name);\n+      if (old && duplicate_decls (x, old, 0))\n+\treturn old;\n+      if (DECL_EXTERNAL (x) || scope == global_binding_level)\n \t{\n-\t  if (DECL_SOURCE_LINE (x) == 0)\n+\t  /* Find and check against a previous, not-in-scope, external\n+\t     decl for this identifier.  (C99 s???: If two declarations\n+\t     with external linkage, referring to the same object, have\n+\t     incompatible types, the behavior is undefined).  */\n+\t  tree ext = any_external_decl (name);\n+\t  if (ext)\n \t    {\n-\t      if (TYPE_NAME (TREE_TYPE (x)) == 0)\n-\t\tTYPE_NAME (TREE_TYPE (x)) = x;\n+\t      if (duplicate_decls (x, ext, scope != global_binding_level))\n+\t\tx = copy_node (ext);\n \t    }\n-\t  else if (TREE_TYPE (x) != error_mark_node\n-\t\t   && DECL_ORIGINAL_TYPE (x) == NULL_TREE)\n-\t    {\n-\t      tree tt = TREE_TYPE (x);\n-\t      DECL_ORIGINAL_TYPE (x) = tt;\n-\t      tt = build_type_copy (tt);\n-\t      TYPE_NAME (tt) = x;\n-\t      TREE_USED (tt) = TREE_USED (x);\n-\t      TREE_TYPE (x) = tt;\n-\t    }\n-\t}\n-\n-      /* Multiple external decls of the same identifier ought to match.\n-\t We get warnings about inline functions where they are defined.\n-\t Avoid duplicate warnings where they are used.  */\n-      if (TREE_PUBLIC (x)\n-\t  && ! (TREE_CODE (x) == FUNCTION_DECL && DECL_INLINE (x)))\n-\t{\n-\t  tree decl;\n-\n-\t  if (IDENTIFIER_LIMBO_VALUE (name) != 0)\n-\t    /* Decls in limbo are always extern, so no need to check that.  */\n-\t    decl = IDENTIFIER_LIMBO_VALUE (name);\n \t  else\n-\t    decl = 0;\n-\n-\t  if (decl && ! comptypes (TREE_TYPE (x), TREE_TYPE (decl))\n-\t      /* If old decl is built-in, we already warned if we should.  */\n-\t      && !DECL_BUILT_IN (decl))\n-\t    {\n-\t      pedwarn_with_decl (x,\n-\t\t\t\t \"type mismatch with previous external decl\");\n-\t      pedwarn_with_decl (decl, \"previous external decl of `%s'\");\n-\t    }\n-\t}\n-\n-      /* If a function has had an implicit declaration, and then is defined,\n-\t make sure they are compatible.  */\n-\n-      if (IDENTIFIER_IMPLICIT_DECL (name) != 0\n-\t  && IDENTIFIER_GLOBAL_VALUE (name) == 0\n-\t  && TREE_CODE (x) == FUNCTION_DECL\n-\t  && ! comptypes (TREE_TYPE (x),\n-\t\t\t  TREE_TYPE (IDENTIFIER_IMPLICIT_DECL (name))))\n-\t{\n-\t  warning_with_decl (x, \"type mismatch with previous implicit declaration\");\n-\t  warning_with_decl (IDENTIFIER_IMPLICIT_DECL (name),\n-\t\t\t     \"previous implicit declaration of `%s'\");\n+\t    record_external_decl (x);\n \t}\n-\n-      /* This name is new in its binding level.\n-\t Install the new declaration and return it.  */\n-      if (b == global_binding_level)\n+\t  \n+      if (TREE_CODE (x) == TYPE_DECL)\n+\tclone_underlying_type (x);\n+\n+      /* If storing a local value, there may already be one\n+\t (inherited).  If so, record it for restoration when this\n+\t binding level ends.  Take care not to do this if we are\n+\t replacing an older decl in the same binding level (i.e.\n+\t duplicate_decls returned false, above).  */\n+      if (scope != global_binding_level\n+\t  && IDENTIFIER_SYMBOL_VALUE (name)\n+\t  && IDENTIFIER_SYMBOL_VALUE (name) != old)\n \t{\n-\t  /* Install a global value.  */\n-\n-\t  /* If the first global decl has external linkage,\n-\t     warn if we later see static one.  */\n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) == 0 && TREE_PUBLIC (x))\n-\t    TREE_PUBLIC (name) = 1;\n-\n-\t  IDENTIFIER_GLOBAL_VALUE (name) = x;\n-\n-\t  /* We no longer care about any previous block level declarations.  */\n-\t  IDENTIFIER_LIMBO_VALUE (name) = 0;\n-\n-\t  /* Don't forget if the function was used via an implicit decl.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n-\t      && TREE_USED (IDENTIFIER_IMPLICIT_DECL (name)))\n-\t    TREE_USED (x) = 1, TREE_USED (name) = 1;\n-\n-\t  /* Don't forget if its address was taken in that way.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name)\n-\t      && TREE_ADDRESSABLE (IDENTIFIER_IMPLICIT_DECL (name)))\n-\t    TREE_ADDRESSABLE (x) = 1;\n-\n-\t  /* Warn about mismatches against previous implicit decl.  */\n-\t  if (IDENTIFIER_IMPLICIT_DECL (name) != 0\n-\t      /* If this real decl matches the implicit, don't complain.  */\n-\t      && ! (TREE_CODE (x) == FUNCTION_DECL\n-\t\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (x)))\n-\t\t\t== integer_type_node)))\n-\t    pedwarn (\"`%s' was previously implicitly declared to return `int'\",\n-\t\t     IDENTIFIER_POINTER (name));\n-\n-\t  /* If this decl is `static' and an `extern' was seen previously,\n-\t     that is erroneous.  */\n-\t  if (TREE_PUBLIC (name)\n-\t      && ! TREE_PUBLIC (x) && ! DECL_EXTERNAL (x))\n-\t    {\n-\t      /* Okay to redeclare an ANSI built-in as static.  */\n-\t      if (t != 0 && DECL_BUILT_IN (t))\n-\t\t;\n-\t      /* Okay to declare a non-ANSI built-in as anything.  */\n-\t      else if (t != 0 && DECL_BUILT_IN_NONANSI (t))\n-\t\t;\n-\t      /* Okay to have global type decl after an earlier extern\n-\t\t declaration inside a lexical block.  */\n-\t      else if (TREE_CODE (x) == TYPE_DECL)\n-\t\t;\n-\t      else if (IDENTIFIER_IMPLICIT_DECL (name))\n-\t\t{\n-\t\t  if (! TREE_THIS_VOLATILE (name))\n-\t\t    pedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n-\t\t\t     IDENTIFIER_POINTER (name));\n-\t\t}\n-\t      else\n-\t\tpedwarn (\"`%s' was declared `extern' and later `static'\",\n-\t\t\t IDENTIFIER_POINTER (name));\n-\t    }\n+\t  warn_if_shadowing (x, IDENTIFIER_SYMBOL_VALUE (name));\n+\t  scope->shadowed = tree_cons (name, IDENTIFIER_SYMBOL_VALUE (name),\n+\t\t\t\t       scope->shadowed);\n \t}\n-      else\n-\t{\n-\t  /* Here to install a non-global value.  */\n-\t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n-\t  tree oldglobal = IDENTIFIER_GLOBAL_VALUE (name);\n-\n-\t  IDENTIFIER_LOCAL_VALUE (name) = x;\n-\n-\t  /* If this is an extern function declaration, see if we\n-\t     have a global definition or declaration for the function.  */\n-\t  if (oldlocal == 0\n-\t      && oldglobal != 0\n-\t      && TREE_CODE (x) == FUNCTION_DECL\n-\t      && TREE_CODE (oldglobal) == FUNCTION_DECL\n-\t      && DECL_EXTERNAL (x)\n-\t      && ! DECL_DECLARED_INLINE_P (x))\n-\t    {\n-\t      /* We have one.  Their types must agree.  */\n-\t      if (! comptypes (TREE_TYPE (x),\n-\t\t\t       TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (name))))\n-\t\tpedwarn_with_decl (x, \"extern declaration of `%s' doesn't match global one\");\n-\t      else\n-\t\t{\n-\t\t  /* Inner extern decl is inline if global one is.\n-\t\t     Copy enough to really inline it.  */\n-\t\t  if (DECL_DECLARED_INLINE_P (oldglobal))\n-\t\t    {\n-\t\t      DECL_DECLARED_INLINE_P (x)\n-\t\t        = DECL_DECLARED_INLINE_P (oldglobal);\n-\t\t      DECL_INLINE (x) = DECL_INLINE (oldglobal);\n-\t\t      DECL_INITIAL (x) = (current_function_decl == oldglobal\n-\t\t\t\t\t  ? 0 : DECL_INITIAL (oldglobal));\n-\t\t      DECL_SAVED_INSNS (x) = DECL_SAVED_INSNS (oldglobal);\n-\t\t      DECL_NUM_STMTS (x) = DECL_NUM_STMTS (oldglobal);\n-\t\t      DECL_ARGUMENTS (x) = DECL_ARGUMENTS (oldglobal);\n-\t\t      DECL_RESULT (x) = DECL_RESULT (oldglobal);\n-\t\t      TREE_ASM_WRITTEN (x) = TREE_ASM_WRITTEN (oldglobal);\n-\t\t      DECL_ABSTRACT_ORIGIN (x)\n-\t\t\t= DECL_ABSTRACT_ORIGIN (oldglobal);\n-\t\t    }\n-\t\t  /* Inner extern decl is built-in if global one is.  */\n-\t\t  if (DECL_BUILT_IN (oldglobal))\n-\t\t    {\n-\t\t      DECL_BUILT_IN_CLASS (x) = DECL_BUILT_IN_CLASS (oldglobal);\n-\t\t      DECL_FUNCTION_CODE (x) = DECL_FUNCTION_CODE (oldglobal);\n-\t\t    }\n-\t\t  /* Keep the arg types from a file-scope fcn defn.  */\n-\t\t  if (TYPE_ARG_TYPES (TREE_TYPE (oldglobal)) != 0\n-\t\t      && DECL_INITIAL (oldglobal)\n-\t\t      && TYPE_ARG_TYPES (TREE_TYPE (x)) == 0)\n-\t\t    TREE_TYPE (x) = TREE_TYPE (oldglobal);\n-\t\t}\n-\t    }\n-\n-#if 0\n-\t  /* This case is probably sometimes the right thing to do.  */\n-\t  /* If we have a local external declaration,\n-\t     then any file-scope declaration should not\n-\t     have been static.  */\n-\t  if (oldlocal == 0 && oldglobal != 0\n-\t      && !TREE_PUBLIC (oldglobal)\n-\t      && DECL_EXTERNAL (x) && TREE_PUBLIC (x))\n-\t    warning (\"`%s' locally external but globally static\",\n-\t\t     IDENTIFIER_POINTER (name));\n-#endif\n-\n-\t  /* If we have a local external declaration,\n-\t     and no file-scope declaration has yet been seen,\n-\t     then if we later have a file-scope decl it must not be static.  */\n-\t  if (oldlocal == 0\n-\t      && DECL_EXTERNAL (x)\n-\t      && TREE_PUBLIC (x))\n-\t    {\n-\t      if (oldglobal == 0)\n-\t\tTREE_PUBLIC (name) = 1;\n-\n-\t      /* Save this decl, so that we can do type checking against\n-\t\t other decls after it falls out of scope.\n-\n-\t\t Only save it once.  This prevents temporary decls created in\n-\t\t expand_inline_function from being used here, since this\n-\t\t will have been set when the inline function was parsed.\n-\t\t It also helps give slightly better warnings.  */\n-\t      if (IDENTIFIER_LIMBO_VALUE (name) == 0)\n-\t\tIDENTIFIER_LIMBO_VALUE (name) = x;\n-\t    }\n-\n-\t  warn_if_shadowing (x, oldlocal);\n \n-\t  /* If storing a local value, there may already be one (inherited).\n-\t     If so, record it for restoration when this binding level ends.  */\n-\t  if (oldlocal != 0)\n-\t    b->shadowed = tree_cons (name, oldlocal, b->shadowed);\n-\t}\n+      /* Install the new declaration in the requested binding level.  */\n+      IDENTIFIER_SYMBOL_VALUE (name) = x;\n+      C_DECL_INVISIBLE (x) = 0;\n \n       /* Keep list of variables in this level with incomplete type.\n \t If the input is erroneous, we can have error_mark in the type\n@@ -2010,96 +1776,131 @@ pushdecl (x)\n \t    element = TREE_TYPE (element);\n \t  if (TREE_CODE (element) == RECORD_TYPE\n \t      || TREE_CODE (element) == UNION_TYPE)\n-\t    b->incomplete_list = tree_cons (NULL_TREE, x, b->incomplete_list);\n+\t    scope->incomplete_list = tree_cons (NULL_TREE, x,\n+\t\t\t\t\t\tscope->incomplete_list);\n \t}\n     }\n \n   /* Put decls on list in reverse order.\n      We will reverse them later if necessary.  */\n-  TREE_CHAIN (x) = b->names;\n-  b->names = x;\n+  TREE_CHAIN (x) = scope->names;\n+  scope->names = x;\n \n   return x;\n }\n \n-/* Record that the local value of NAME is shadowed at function scope.\n-   This is used by build_external_ref in c-typeck.c.  */\n-void\n-record_function_scope_shadow (name)\n-     tree name;\n+/* Record X as belonging to the global scope (C99 \"file scope\").\n+   This is used only internally by the Objective C front end,\n+   and is limited to its needs.  It will hork if there is _any_\n+   visible binding for X (not just a global one).  */\n+tree\n+pushdecl_top_level (x)\n+     tree x;\n {\n-  struct binding_level *b = get_function_binding_level ();\n-  b->shadowed = tree_cons (name, IDENTIFIER_LOCAL_VALUE (name),\n-\t\t\t   b->shadowed);\n-}\n+  tree name, old;\n+\n+  if (TREE_CODE (x) != VAR_DECL)\n+    abort ();\n+\n+  name = DECL_NAME (x);\n+  old = IDENTIFIER_SYMBOL_VALUE (name);\n+\n+  if (old)\n+    {\n+      if (DECL_CONTEXT (old))\n+\tabort ();\n+\n+      if (!duplicate_decls (x, old, 0))\n+\tabort ();\n+\n+      return old;\n+    }\n \n-/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */\n+  DECL_CONTEXT (x) = 0;\n+  IDENTIFIER_SYMBOL_VALUE (name) = x;\n+  TREE_CHAIN (x) = global_binding_level->names;\n+  global_binding_level->names = x;\n+  return x;\n+}\n \n+/* Record X as belonging to the outermost scope of the current\n+   function.  This is used only internally, by c_make_fname_decl and\n+   build_external_ref, and is limited to their needs.  The NAME is\n+   provided as a separate argument because build_external_ref wants to\n+   use error_mark_node for X.  For VAR_DECLs, duplicate_decls is not\n+   called; if there is any preexisting decl for this identifier, it is\n+   an ICE.  */\n tree\n-pushdecl_top_level (x)\n+pushdecl_function_level (x, name)\n      tree x;\n+     tree name;\n {\n-  tree t;\n-  struct binding_level *b = current_binding_level;\n+  struct binding_level *scope;\n+\n+  scope = current_binding_level;\n+  while (scope->function_body == 0)\n+    scope = scope->level_chain;\n+  if (!scope)\n+    abort ();\n+\n+  if (x == error_mark_node)\n+    scope->shadowed = tree_cons (name, IDENTIFIER_SYMBOL_VALUE (name),\n+\t\t\t\t scope->shadowed);\n+  else if (TREE_CODE (x) == VAR_DECL)\n+    {\n+      if (name != DECL_NAME (x))\n+\tabort ();\n+      if (IDENTIFIER_SYMBOL_VALUE (name))\n+\tabort ();\n \n-  current_binding_level = global_binding_level;\n-  t = pushdecl (x);\n-  current_binding_level = b;\n-  return t;\n+      DECL_CONTEXT (x) = current_function_decl;\n+      TREE_CHAIN (x) = scope->names;\n+      scope->names = x;\n+    }\n+\n+  IDENTIFIER_SYMBOL_VALUE (name) = x;\n+  return x;\n }\n \f\n-/* Generate an implicit declaration for identifier FUNCTIONID\n-   as a function of type int ().  Print a warning if appropriate.  */\n+/* Generate an implicit declaration for identifier FUNCTIONID as a\n+   function of type int ().  */\n \n tree\n implicitly_declare (functionid)\n      tree functionid;\n {\n-  tree decl;\n-  int traditional_warning = 0;\n-  /* Only one \"implicit declaration\" warning per identifier.  */\n-  int implicit_warning;\n+  tree decl = any_external_decl (functionid);\n \n-  /* We used to reuse an old implicit decl here,\n-     but this loses with inline functions because it can clobber\n-     the saved decl chains.  */\n-#if 0\n-  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)\n-    decl = IDENTIFIER_IMPLICIT_DECL (functionid);\n-  else\n-#endif\n-    decl = build_decl (FUNCTION_DECL, functionid, default_function_type);\n-\n-  /* Warn of implicit decl following explicit local extern decl.\n-     This is probably a program designed for traditional C.  */\n-  if (TREE_PUBLIC (functionid) && IDENTIFIER_GLOBAL_VALUE (functionid) == 0)\n-    traditional_warning = 1;\n-\n-  /* Warn once of an implicit declaration.  */\n-  implicit_warning = (IDENTIFIER_IMPLICIT_DECL (functionid) == 0);\n+  if (decl && decl != error_mark_node)\n+    {\n+      /* Implicit declaration of a function already declared\n+\t (somehow) in a different scope, or as a built-in.\n+\t If this is the first time this has happened, warn;\n+\t then recycle the old declaration.  */\n+      if (!C_DECL_IMPLICIT (decl))\n+\t{\n+\t  implicit_decl_warning (DECL_NAME (decl));\n+\t  if (DECL_CONTEXT (decl))\n+\t    warning_with_decl (decl, \"previous declaration of `%s'\");\n+\t  C_DECL_IMPLICIT (decl) = 1;\n+\t}\n+      return pushdecl (decl);\n+    }\n \n+  /* Not seen before.  */\n+  decl = build_decl (FUNCTION_DECL, functionid, default_function_type);\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n-\n-  /* Record that we have an implicit decl and this is it.  */\n-  IDENTIFIER_IMPLICIT_DECL (functionid) = decl;\n+  C_DECL_IMPLICIT (decl) = 1;\n+  implicit_decl_warning (functionid);\n \n   /* ANSI standard says implicit declarations are in the innermost block.\n      So we record the decl in the standard fashion.  */\n-  pushdecl (decl);\n-\n-  /* This is a no-op in c-lang.c or something real in objc-act.c.  */\n-  if (flag_objc)\n-    objc_check_decl (decl);\n+  decl = pushdecl (decl);\n \n+  /* No need to call objc_check_decl here - it's a function type.  */\n   rest_of_decl_compilation (decl, NULL, 0, 0);\n \n-  if (implicit_warning)\n-    implicit_decl_warning (functionid);\n-  else if (warn_traditional && traditional_warning)\n-    warning (\"function `%s' was previously declared within a block\",\n-\t     IDENTIFIER_POINTER (functionid));\n-\n   /* Write a record describing this implicit function declaration to the\n      prototypes file (if requested).  */\n \n@@ -2111,7 +1912,7 @@ implicitly_declare (functionid)\n   return decl;\n }\n \n-void\n+static void\n implicit_decl_warning (id)\n      tree id;\n {\n@@ -2353,55 +2154,50 @@ storetags (tags)\n \f\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n-   Searches binding levels from BINDING_LEVEL up to the global level.\n-   If THISLEVEL_ONLY is nonzero, searches only the specified context\n-   (but skips any tag-transparent contexts to find one that is\n-   meaningful for tags).\n+   If THISLEVEL_ONLY is nonzero, searches only the current_binding_level.\n    CODE says which kind of type the caller wants;\n    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n    If the wrong kind of type is found, an error is reported.  */\n \n static tree\n-lookup_tag (code, name, binding_level, thislevel_only)\n+lookup_tag (code, name, thislevel_only)\n      enum tree_code code;\n-     struct binding_level *binding_level;\n      tree name;\n      int thislevel_only;\n {\n-  struct binding_level *level;\n-  int thislevel = 1;\n+  tree tag = IDENTIFIER_TAG_VALUE (name);\n+  int thislevel = 0;\n \n-  for (level = binding_level; level; level = level->level_chain)\n+  if (!tag)\n+    return 0;\n+\n+  /* We only care about whether it's in this level if\n+     thislevel_only was set or it might be a type clash.  */\n+  if (thislevel_only || TREE_CODE (tag) != code)\n     {\n-      tree tail;\n-      for (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n-\t{\n-\t  if (TREE_PURPOSE (tail) == name)\n-\t    {\n-\t      if (TREE_CODE (TREE_VALUE (tail)) != code)\n-\t\t{\n-\t\t  /* Definition isn't the kind we were looking for.  */\n-\t\t  pending_invalid_xref = name;\n-\t\t  pending_invalid_xref_file = input_filename;\n-\t\t  pending_invalid_xref_line = lineno;\n-\t\t  /* If in the same binding level as a declaration as a tag\n-\t\t     of a different type, this must not be allowed to\n-\t\t     shadow that tag, so give the error immediately.\n-\t\t     (For example, \"struct foo; union foo;\" is invalid.)  */\n-\t\t  if (thislevel)\n-\t\t    pending_xref_error ();\n-\t\t}\n-\t      return TREE_VALUE (tail);\n-\t    }\n-\t}\n-      if (! level->tag_transparent)\n-\t{\n-\t  if (thislevel_only)\n-\t    return NULL_TREE;\n-\t  thislevel = 0;\n-\t}\n+      if (current_binding_level == global_binding_level\n+\t  || purpose_member (name, current_binding_level->tags))\n+\tthislevel = 1;\n     }\n-  return NULL_TREE;\n+\n+  if (thislevel_only && !thislevel)\n+    return 0;\n+\n+  if (TREE_CODE (tag) != code)\n+    {\n+      /* Definition isn't the kind we were looking for.  */\n+      pending_invalid_xref = name;\n+      pending_invalid_xref_file = input_filename;\n+      pending_invalid_xref_line = lineno;\n+\n+      /* If in the same binding level as a declaration as a tag\n+\t of a different type, this must not be allowed to\n+\t shadow that tag, so give the error immediately.\n+\t (For example, \"struct foo; union foo;\" is invalid.)  */\n+      if (thislevel)\n+\tpending_xref_error ();\n+    }\n+  return tag;\n }\n \n /* Print an error message now\n@@ -2420,26 +2216,6 @@ pending_xref_error ()\n   pending_invalid_xref = 0;\n }\n \n-/* Given a type, find the tag that was defined for it and return the tag name.\n-   Otherwise return 0.  */\n-\n-static tree\n-lookup_tag_reverse (type)\n-     tree type;\n-{\n-  struct binding_level *level;\n-\n-  for (level = current_binding_level; level; level = level->level_chain)\n-    {\n-      tree tail;\n-      for (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n-\t{\n-\t  if (TREE_VALUE (tail) == type)\n-\t    return TREE_PURPOSE (tail);\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n \f\n /* Look up NAME in the current binding level and its superiors\n    in the namespace of variables, functions and typedefs.\n@@ -2450,35 +2226,33 @@ tree\n lookup_name (name)\n      tree name;\n {\n-  tree val;\n-\n-  if (current_binding_level != global_binding_level\n-      && IDENTIFIER_LOCAL_VALUE (name))\n-    val = IDENTIFIER_LOCAL_VALUE (name);\n-  else\n-    val = IDENTIFIER_GLOBAL_VALUE (name);\n-  return val;\n+  tree decl = IDENTIFIER_SYMBOL_VALUE (name);\n+  if (decl == 0 || decl == error_mark_node)\n+    return decl;\n+  if (C_DECL_INVISIBLE (decl))\n+    return 0;\n+  return decl;\n }\n \n-/* Similar to `lookup_name' but look only at current binding level.  */\n+/* Similar to `lookup_name' but look only at the current binding level.  */\n \n-tree\n+static tree\n lookup_name_current_level (name)\n      tree name;\n {\n-  tree t;\n+  tree decl = IDENTIFIER_SYMBOL_VALUE (name);\n \n-  if (current_binding_level == global_binding_level)\n-    return IDENTIFIER_GLOBAL_VALUE (name);\n-\n-  if (IDENTIFIER_LOCAL_VALUE (name) == 0)\n+  if (decl == 0 || decl == error_mark_node || C_DECL_INVISIBLE (decl))\n     return 0;\n \n-  for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n-    if (DECL_NAME (t) == name)\n-      break;\n+  if (current_binding_level == global_binding_level)\n+    return decl;\n \n-  return t;\n+  /* Scan the current scope for a decl with name NAME.  */\n+  if (chain_member (decl, current_binding_level->names))\n+    return decl;\n+\n+  return 0;\n }\n \f\n /* Create the predefined scalar types of C,\n@@ -2558,8 +2332,6 @@ c_make_fname_decl (id, type_dep)\n \t   build_index_type (size_int (length)));\n \n   decl = build_decl (VAR_DECL, id, type);\n-  /* We don't push the decl, so have to set its context here.  */\n-  DECL_CONTEXT (decl) = current_function_decl;\n   \n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n@@ -2572,14 +2344,8 @@ c_make_fname_decl (id, type_dep)\n   TREE_USED (decl) = 1;\n \n   if (current_function_decl)\n-    {\n-      /* Add the decls to the outermost block.  */\n-      struct binding_level *old = current_binding_level;\n-      current_binding_level = get_function_binding_level ();\n-      pushdecl (decl);\n-      current_binding_level = old;\n-    }\t\n-  \n+    pushdecl_function_level (decl, DECL_NAME (decl));\n+\n   finish_decl (decl, init, NULL_TREE);\n \n   return decl;\n@@ -2616,7 +2382,7 @@ builtin_function (name, type, function_code, class, library_name, attrs)\n   /* Warn if a function in the namespace for users\n      is used without an occasion to consider it declared.  */\n   if (name[0] != '_' || name[1] != '_')\n-    C_DECL_ANTICIPATED (decl) = 1;\n+    C_DECL_INVISIBLE (decl) = 1;\n \n   /* Possibly apply some default attributes to this built-in function.  */\n   if (attrs)\n@@ -2680,7 +2446,7 @@ shadow_tag_warned (declspecs, warned)\n \t/* Used to test also that TYPE_SIZE (value) != 0.\n \t   That caused warning for `struct foo;' at top level in the file.  */\n \t{\n-\t  tree name = lookup_tag_reverse (value);\n+\t  tree name = TYPE_NAME (value);\n \t  tree t;\n \n \t  found_tag++;\n@@ -2696,7 +2462,7 @@ shadow_tag_warned (declspecs, warned)\n \t    }\n \t  else\n \t    {\n-\t      t = lookup_tag (code, name, current_binding_level, 1);\n+\t      t = lookup_tag (code, name, 1);\n \n \t      if (t == 0)\n \t\t{\n@@ -4950,7 +4716,7 @@ xref_tag (code, name)\n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n \n-  tree ref = lookup_tag (code, name, current_binding_level, 0);\n+  tree ref = lookup_tag (code, name, 0);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -5004,7 +4770,7 @@ start_struct (code, name)\n   tree ref = 0;\n \n   if (name != 0)\n-    ref = lookup_tag (code, name, current_binding_level, 1);\n+    ref = lookup_tag (code, name, 1);\n   if (ref && TREE_CODE (ref) == code)\n     {\n       if (TYPE_FIELDS (ref))\n@@ -5432,7 +5198,7 @@ start_enum (name)\n      forward reference.  */\n \n   if (name != 0)\n-    enumtype = lookup_tag (ENUMERAL_TYPE, name, current_binding_level, 1);\n+    enumtype = lookup_tag (ENUMERAL_TYPE, name, 1);\n \n   if (enumtype == 0 || TREE_CODE (enumtype) != ENUMERAL_TYPE)\n     {\n@@ -5750,27 +5516,16 @@ start_function (declspecs, declarator, attributes)\n       current_function_prototype_line = DECL_SOURCE_LINE (old_decl);\n     }\n \n-  /* If there is no explicit declaration, look for any out-of-scope implicit\n-     declarations.  */\n-  if (old_decl == 0)\n-    old_decl = IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1));\n-\n   /* Optionally warn of old-fashioned def with no previous prototype.  */\n   if (warn_strict_prototypes\n       && TYPE_ARG_TYPES (TREE_TYPE (decl1)) == 0\n-      && !(old_decl != 0\n-\t   && (TYPE_ARG_TYPES (TREE_TYPE (old_decl)) != 0\n-\t       || (DECL_BUILT_IN (old_decl)\n-\t\t   && ! C_DECL_ANTICIPATED (old_decl)))))\n+      && C_DECL_ISNT_PROTOTYPE (old_decl))\n     warning (\"function declaration isn't a prototype\");\n   /* Optionally warn of any global def with no previous prototype.  */\n   else if (warn_missing_prototypes\n \t   && TREE_PUBLIC (decl1)\n-\t   && !(old_decl != 0\n-\t\t&& (TYPE_ARG_TYPES (TREE_TYPE (old_decl)) != 0\n-\t\t    || (DECL_BUILT_IN (old_decl)\n-\t\t\t&& ! C_DECL_ANTICIPATED (old_decl))))\n-\t   && ! MAIN_NAME_P (DECL_NAME (decl1)))\n+\t   && ! MAIN_NAME_P (DECL_NAME (decl1))\n+\t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n     warning_with_decl (decl1, \"no previous prototype for `%s'\");\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n@@ -5789,7 +5544,7 @@ start_function (declspecs, declarator, attributes)\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0 && TREE_USED (old_decl)\n-\t   && old_decl == IDENTIFIER_IMPLICIT_DECL (DECL_NAME (decl1)))\n+\t   && C_DECL_IMPLICIT (old_decl))\n     warning_with_decl (decl1,\n \t\t       \"`%s' was used with no declaration before its definition\");\n \n@@ -5872,7 +5627,6 @@ start_function (declspecs, declarator, attributes)\n \n   pushlevel (0);\n   declare_parm_level (1);\n-  current_binding_level->subblocks_tag_transparent = 1;\n \n   make_decl_rtl (current_function_decl, NULL);\n \n@@ -5965,10 +5719,10 @@ store_parm_decls ()\n \t  for (decl = current_binding_level->names;\n \t       decl; decl = TREE_CHAIN (decl))\n \t    if (DECL_NAME (decl))\n-\t      IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) = 0;\n+\t      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = 0;\n \t  for (link = current_binding_level->shadowed;\n \t       link; link = TREE_CHAIN (link))\n-\t    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\t    IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n \t  current_binding_level->names = 0;\n \t  current_binding_level->shadowed = 0;\n \t}\n@@ -6347,13 +6101,27 @@ finish_function (nested, can_defer_p)\n {\n   tree fndecl = current_function_decl;\n \n+  /* When a function declaration is totally empty, e.g.\n+        void foo(void) { }\n+     (the argument list is irrelevant) the compstmt rule will not\n+     bother calling pushlevel/poplevel, which means we get here with\n+     the binding_level stack out of sync.  Detect this situation by\n+     noticing that the current_binding_level is still as\n+     store_parm_decls left it, and do a dummy push/pop to get back to\n+     consistency.  Note that the call to pushlevel does not actually\n+     push another binding level - see there for details.  */\n+  if (current_binding_level->parm_flag && keep_next_if_subblocks)\n+    {\n+      pushlevel (0);\n+      poplevel (1, 0, 1);\n+    }\n+\n #if 0\n   /* This caused &foo to be of type ptr-to-const-function which then\n      got a warning when stored in a ptr-to-function variable.  */\n   TREE_READONLY (fndecl) = 1;\n #endif\n \n-  poplevel (1, 0, 1);\n   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;\n \n   /* Must mark the RESULT_DECL as being in this function.  */\n@@ -6918,14 +6686,23 @@ c_expand_decl_stmt (t)\n     c_expand_body_1 (decl, 1);\n }\n \n-/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since\n-   the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */\n+/* Return the global value of T as a symbol.  */\n \n tree\n identifier_global_value\t(t)\n      tree t;\n {\n-  return IDENTIFIER_GLOBAL_VALUE (t);\n+  tree decl = IDENTIFIER_SYMBOL_VALUE (t);\n+  if (decl == 0 || DECL_CONTEXT (decl) == 0)\n+    return decl;\n+\n+  /* Shadowed by something else; find the true global value.  */\n+  for (decl = global_binding_level->names; decl; decl = TREE_CHAIN (decl))\n+    if (DECL_NAME (decl) == t)\n+      return decl;\n+\n+  /* Only local values for this decl.  */\n+  return 0;\n }\n \n /* Record a builtin type for C.  If NAME is non-NULL, it is the name used;"}, {"sha": "368c970557e37f735c239a7229b29429cd1ba4cd", "filename": "gcc/c-tree.h", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for C parsing and type checking.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -37,11 +37,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n struct lang_identifier GTY(())\n {\n   struct c_common_identifier common_id;\n-  tree global_value;\n-  tree local_value;\n+  tree symbol_value;\n+  tree tag_value;\n   tree label_value;\n-  tree implicit_decl;\n-  tree limbo_value;\n };\n \n /* The resulting tree type.  */\n@@ -70,26 +68,17 @@ struct lang_decl GTY(())\n /* Macros for access to language-specific slots in an identifier.  */\n /* Each of these slots contains a DECL node or null.  */\n \n-/* This represents the value which the identifier has in the\n-   file-scope namespace.  */\n-#define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *) (NODE))->global_value)\n-/* This represents the value which the identifier has in the current\n-   scope.  */\n-#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *) (NODE))->local_value)\n-/* This represents the value which the identifier has as a label in\n-   the current label scope.  */\n+/* The value of the identifier in the namespace of \"ordinary identifiers\"\n+   (data objects, enum constants, functions, typedefs).  */\n+#define IDENTIFIER_SYMBOL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *) (NODE))->symbol_value)\n+/* The value of the identifier in the namespace of struct, union,\n+   and enum tags.  */\n+#define IDENTIFIER_TAG_VALUE(NODE)\t\\\n+  (((struct lang_identifier *) (NODE))->tag_value)\n+/* The value of the identifier in the namespace of labels.  */\n #define IDENTIFIER_LABEL_VALUE(NODE)\t\\\n   (((struct lang_identifier *) (NODE))->label_value)\n-/* This records the extern decl of this identifier, if it has had one\n-   at any point in this compilation.  */\n-#define IDENTIFIER_LIMBO_VALUE(NODE)\t\\\n-  (((struct lang_identifier *) (NODE))->limbo_value)\n-/* This records the implicit function decl of this identifier, if it\n-   has had one at any point in this compilation.  */\n-#define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n-  (((struct lang_identifier *) (NODE))->implicit_decl)\n \n /* In identifiers, C uses the following fields in a special way:\n    TREE_PUBLIC        to record that there was a previous local extern decl.\n@@ -129,13 +118,6 @@ struct lang_type GTY(())\n #define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n #define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n \n-#if 0 /* Not used.  */\n-/* Record whether a decl for a function or function pointer has\n-   already been mentioned (in a warning) because it was called\n-   but didn't have a prototype.  */\n-#define C_MISSING_PROTOTYPE_WARNED(DECL) DECL_LANG_FLAG_2 (DECL)\n-#endif\n-\n /* Store a value in that field.  */\n #define C_SET_EXP_ORIGINAL_CODE(EXP, CODE) \\\n   (TREE_COMPLEXITY (EXP) = (int) (CODE))\n@@ -147,10 +129,22 @@ struct lang_type GTY(())\n    return type.  */\n #define C_FUNCTION_IMPLICIT_INT(EXP) DECL_LANG_FLAG_1 (EXP)\n \n-/* Nonzero for a declaration of a built in function if there has been no\n-   occasion that would declare the function in ordinary C.\n-   Using the function draws a pedantic warning in this case.  */\n-#define C_DECL_ANTICIPATED(EXP) DECL_LANG_FLAG_3 (EXP)\n+/* For a FUNCTION_DECL, nonzero if it was an implicit declaration.  */\n+#define C_DECL_IMPLICIT(EXP) DECL_LANG_FLAG_2 (EXP)\n+\n+/* Nonzero for a declaration of an external object which is not\n+   currently in scope.  This is either a built-in declaration of\n+   a library function, before a real declaration has been seen,\n+   or a declaration that appeared in an inner scope that has ended.  */\n+#define C_DECL_INVISIBLE(EXP) DECL_LANG_FLAG_3 (EXP)\n+\n+/* Nonzero for a decl which either doesn't exist or isn't a prototype.\n+   N.B. Could be simplified if all built-in decls had complete prototypes\n+   (but this is presently difficult because some of them need FILE*).  */\n+#define C_DECL_ISNT_PROTOTYPE(EXP)\t\t\t\\\n+       (EXP == 0\t\t\t\t\t\\\n+\t|| (TYPE_ARG_TYPES (TREE_TYPE (EXP)) == 0\t\\\n+\t    && !DECL_BUILT_IN (EXP)))\n \n /* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n    TYPE_ARG_TYPES for functions with prototypes, but created for functions\n@@ -207,11 +201,9 @@ extern tree grokfield                           PARAMS ((const char *, int, tree\n extern tree groktypename                        PARAMS ((tree));\n extern tree groktypename_in_parm_context        PARAMS ((tree));\n extern tree implicitly_declare                  PARAMS ((tree));\n-extern void implicit_decl_warning               PARAMS ((tree));\n extern int  in_parm_level_p                     PARAMS ((void));\n extern void keep_next_level                     PARAMS ((void));\n extern tree lookup_name                         PARAMS ((tree));\n-extern tree lookup_name_current_level\t\tPARAMS ((tree));\n extern void parmlist_tags_warning               PARAMS ((void));\n extern void pending_xref_error                  PARAMS ((void));\n extern void c_push_function_context             PARAMS ((struct function *));\n@@ -220,8 +212,8 @@ extern void pop_label_level                     PARAMS ((void));\n extern void push_label_level                    PARAMS ((void));\n extern void push_parm_decl                      PARAMS ((tree));\n extern tree pushdecl_top_level                  PARAMS ((tree));\n+extern tree pushdecl_function_level\t\tPARAMS ((tree, tree));\n extern void pushtag                             PARAMS ((tree, tree));\n-extern void record_function_scope_shadow\tPARAMS ((tree));\n extern tree set_array_declarator_type           PARAMS ((tree, tree, int));\n extern tree shadow_label                        PARAMS ((tree));\n extern void shadow_tag                          PARAMS ((tree));"}, {"sha": "ec9418bdc84471eedd103a403632264c533d104f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C compiler.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -59,6 +59,7 @@ static int type_lists_compatible_p\tPARAMS ((tree, tree));\n static tree decl_constant_value_for_broken_optimization PARAMS ((tree));\n static tree default_function_array_conversion\tPARAMS ((tree));\n static tree lookup_field\t\tPARAMS ((tree, tree));\n+static void undeclared_variable\t\tPARAMS ((tree));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n static tree pointer_diff\t\tPARAMS ((tree, tree));\n static tree unary_complex_lvalue\tPARAMS ((enum tree_code, tree, int));\n@@ -1375,6 +1376,38 @@ build_array_ref (array, index)\n   }\n }\n \f\n+/* Issue an error message for a reference to an undeclared variable ID,\n+   including a reference to a builtin outside of function-call context.\n+   Arrange to suppress further errors for the same identifier.  */\n+static void\n+undeclared_variable (id)\n+     tree id;\n+{\n+  if (current_function_decl == 0)\n+    {\n+      error (\"`%s' undeclared here (not in a function)\",\n+\t     IDENTIFIER_POINTER (id));\n+      IDENTIFIER_SYMBOL_VALUE (id) = error_mark_node;\n+    }\n+  else\n+    {\n+      error (\"`%s' undeclared (first use in this function)\",\n+\t     IDENTIFIER_POINTER (id));\n+\n+      if (! undeclared_variable_notice)\n+\t{\n+\t  error (\"(Each undeclared identifier is reported only once\");\n+\t  error (\"for each function it appears in.)\");\n+\t  undeclared_variable_notice = 1;\n+\t}\n+\n+      /* Set IDENTIFIER_SYMBOL_VALUE (id) to error_mark_node\n+\t at function scope.  This suppresses further warnings\n+\t about this undeclared identifier in this function.  */\n+      pushdecl_function_level (error_mark_node, id);\n+    }\n+}\n+\n /* Build an external reference to identifier ID.  FUN indicates\n    whether this will be used for a function call.  */\n tree\n@@ -1386,70 +1419,12 @@ build_external_ref (id, fun)\n   tree decl = lookup_name (id);\n   tree objc_ivar = lookup_objc_ivar (id);\n \n-  if (decl && TREE_DEPRECATED (decl))\n-    warn_deprecated_use (decl);\n-\n-  if (!decl || decl == error_mark_node || C_DECL_ANTICIPATED (decl))\n-    {\n-      if (objc_ivar)\n-\tref = objc_ivar;\n-      else if (fun)\n-\t{\n-\t  if (!decl || decl == error_mark_node)\n-\t    /* Ordinary implicit function declaration.  */\n-\t    ref = implicitly_declare (id);\n-\t  else\n-\t    {\n-\t      /* Implicit declaration of built-in function.  Don't\n-\t\t change the built-in declaration, but don't let this\n-\t\t go by silently, either.  */\n-\t      implicit_decl_warning (id);\n-\n-\t      /* only issue this warning once */\n-\t      C_DECL_ANTICIPATED (decl) = 0;\n-\t      ref = decl;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Don't complain about something that's already been\n-\t     complained about.  */\n-\t  if (decl == error_mark_node)\n-\t    return error_mark_node;\n-\n-\t  /* Reference to undeclared variable, including reference to\n-\t     builtin outside of function-call context.  */\n-\t  if (current_function_decl == 0)\n-\t    error (\"`%s' undeclared here (not in a function)\",\n-\t\t   IDENTIFIER_POINTER (id));\n-\t  else\n-\t    {\n-\t      error (\"`%s' undeclared (first use in this function)\",\n-\t\t     IDENTIFIER_POINTER (id));\n-\n-\t      if (! undeclared_variable_notice)\n-\t\t{\n-\t\t  error (\"(Each undeclared identifier is reported only once\");\n-\t\t  error (\"for each function it appears in.)\");\n-\t\t  undeclared_variable_notice = 1;\n-\t\t}\n-\n-\t      /* Set IDENTIFIER_LOCAL_VALUE (id) to error_mark_node and\n-\t\t add a function-scope shadow entry which will undo that.\n-\t\t This suppresses further warnings about this undeclared\n-\t\t identifier in this function.  */\n-\t      record_function_scope_shadow (id);\n-\t      IDENTIFIER_LOCAL_VALUE (id) = error_mark_node;\n-\t    }\n-\t  return error_mark_node;\n-\t}\n-    }\n-  else\n+  if (decl && decl != error_mark_node)\n     {\n       /* Properly declared variable or function reference.  */\n       if (!objc_ivar)\n \tref = decl;\n-      else if (decl != objc_ivar && IDENTIFIER_LOCAL_VALUE (id))\n+      else if (decl != objc_ivar && DECL_CONTEXT (decl) != 0)\n \t{\n \t  warning (\"local declaration of `%s' hides instance variable\",\n \t\t   IDENTIFIER_POINTER (id));\n@@ -1458,10 +1433,27 @@ build_external_ref (id, fun)\n       else\n \tref = objc_ivar;\n     }\n+  else if (objc_ivar)\n+    ref = objc_ivar;\n+  else if (fun)\n+    /* Implicit function declaration.  */\n+    ref = implicitly_declare (id);\n+  else if (decl == error_mark_node)\n+    /* Don't complain about something that's already been\n+       complained about.  */\n+    return error_mark_node;\n+  else\n+    {\n+      undeclared_variable (id);\n+      return error_mark_node;\n+    }\n \n   if (TREE_TYPE (ref) == error_mark_node)\n     return error_mark_node;\n \n+  if (TREE_DEPRECATED (ref))\n+    warn_deprecated_use (ref);\n+\n   if (!skip_evaluation)\n     assemble_external (ref);\n   TREE_USED (ref) = 1;"}, {"sha": "9c5b85aec16144d3005db6e118739f34cbb5acd8", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -239,6 +239,8 @@ scope_to_insns_initialize ()\n \t      break;\n \t    case NOTE_INSN_BLOCK_END:\n \t      block = BLOCK_SUPERCONTEXT (block);\n+\t      if (block && TREE_CODE (block) == FUNCTION_DECL)\n+\t\tblock = 0;\n \t      delete_insn (insn);\n \t      break;\n \t    default:"}, {"sha": "a272d5e3eb0845d0a1d933a7c3f46d8ea31f75b4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,3 +1,7 @@\n+2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* decl.c: Update all calls to shadow_warning.\n+\n 2003-04-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_class_type): Correct handling for overlong"}, {"sha": "28d1493f88328231b1c5840687ad8c3d6e733ad7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -4001,7 +4001,7 @@ pushdecl (tree x)\n \t\t}\n \n \t      if (warn_shadow && !err)\n-\t\tshadow_warning (SW_PARAM, false,\n+\t\tshadow_warning (SW_PARAM,\n \t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n \t    }\n \n@@ -4019,12 +4019,12 @@ pushdecl (tree x)\n \t\t\t    IDENTIFIER_POINTER (name));\n \t      else if (oldlocal != NULL_TREE\n \t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n-\t\tshadow_warning (SW_LOCAL, false,\n+\t\tshadow_warning (SW_LOCAL,\n \t\t\t\tIDENTIFIER_POINTER (name), oldlocal);\n \t      else if (oldglobal != NULL_TREE\n \t\t       && TREE_CODE (oldglobal) == VAR_DECL)\n \t\t/* XXX shadow warnings in outer-more namespaces */\n-\t\tshadow_warning (SW_GLOBAL, false,\n+\t\tshadow_warning (SW_GLOBAL,\n \t\t\t\tIDENTIFIER_POINTER (name), oldglobal);\n \t    }\n \t}"}, {"sha": "1f2ed4401afe61e73611e4ff6ed099f81d19cab0", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -6000,10 +6000,16 @@ reorder_blocks_1 (insns, current_block, p_block_stack)\n \n \t      BLOCK_SUBBLOCKS (block) = 0;\n \t      TREE_ASM_WRITTEN (block) = 1;\n-\t      BLOCK_SUPERCONTEXT (block) = current_block;\n-\t      BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n-\t      BLOCK_SUBBLOCKS (current_block) = block;\n-\t      current_block = block;\n+\t      /* When there's only one block for the entire function,\n+\t\t current_block == block and we mustn't do this, it\n+\t\t will cause infinite recursion.  */\n+\t      if (block != current_block)\n+\t\t{\n+\t\t  BLOCK_SUPERCONTEXT (block) = current_block;\n+\t\t  BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n+\t\t  BLOCK_SUBBLOCKS (current_block) = block;\n+\t\t  current_block = block;\n+\t\t}\n \t      VARRAY_PUSH_TREE (*p_block_stack, block);\n \t    }\n \t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)"}, {"sha": "b9ac3150c1e9e011bc1410f3b9aefd8e64ce4646", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -5298,8 +5298,8 @@ build_protocol_reference (p)\n \t\t\t\t\t\t      objc_protocol_template),\n \t\t\t\t     NULL_TREE));\n \n-  if (IDENTIFIER_GLOBAL_VALUE (ident))\n-    decl = IDENTIFIER_GLOBAL_VALUE (ident); /* Set by pushdecl.  */\n+  if (identifier_global_value (ident))\n+    decl = identifier_global_value (ident); /* Set by pushdecl.  */\n   else\n     {\n       decl = build_decl (VAR_DECL, ident, ptype);"}, {"sha": "7b23832937e073c8ff77a65607848856b73d0d35", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -1,3 +1,11 @@\n+2003-04-10  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.c-torture/execute/builtin-noret-2.c: New.\n+\t* gcc.c-torture/execute/builtin-noret-2.x: New.\n+\tXFAIL builtin-noret-2.c at -O1 and above.\n+\t* gcc.dg/redecl.c: New.\n+\t* gcc.dg/Wshadow-1.c: Update error regexps.\n+\n 2003-04-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/abi/bitfield10.C: New test."}, {"sha": "077153b1cb9384526fe466322548ceef0a248a23", "filename": "gcc/testsuite/gcc.c-torture/execute/builtin-noret-2.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -0,0 +1,84 @@\n+/* Test for builtin noreturn attributes when the visible declarations\n+   are function-local.  Doesn't presently work.  Modified from\n+   builtin-noret-1.c by Zack Weinberg <zack@codesourcery.com>.  */\n+\n+extern void tabort (void);\n+extern void texit (void);\n+extern void t_exit (void);\n+extern void t_Exit (void);\n+\n+extern void link_failure (void);\n+\n+int\n+main (void)\n+{\n+  volatile int i = 0;\n+  /* The real test here is that the program links.  */\n+  if (i)\n+    tabort ();\n+  if (i)\n+    texit ();\n+  if (i)\n+    t_exit ();\n+  if (i)\n+    t_Exit ();\n+  exit (0);\n+}\n+\n+void\n+tabort (void)\n+{\n+  extern void abort (void);\n+  abort ();\n+  link_failure ();\n+}\n+\n+void\n+texit (void)\n+{\n+  extern void exit (int);\n+  exit (1);\n+  link_failure ();\n+}\n+\n+void\n+t_exit (void)\n+{\n+  extern void _exit (int);\n+  _exit (1);\n+  link_failure ();\n+}\n+\n+/* Some non-Unix libcs might not have _exit.  This version should never\n+   get called.  */\n+static void\n+_exit (int i)\n+{\n+  abort ();\n+}\n+\n+void\n+t_Exit (void)\n+{\n+  extern void _Exit (int);\n+  _Exit (1);\n+  link_failure ();\n+}\n+\n+/* Some libcs might not have _Exit.  This version should never get called.  */\n+static void\n+_Exit (int i)\n+{\n+  abort ();\n+}\n+\n+/* When optimizing, no calls to link_failure should remain.  In any case,\n+   link_failure should not be called.  */\n+\n+#ifndef __OPTIMIZE__\n+void\n+link_failure (void)\n+{\n+  abort ();\n+}\n+#endif"}, {"sha": "7926a94f78186b04664d9150469b7a2e278c88c5", "filename": "gcc/testsuite/gcc.c-torture/execute/builtin-noret-2.x", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltin-noret-2.x?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -0,0 +1,12 @@\n+# This test fails at -O1 and higher.\n+set torture_eval_before_compile {\n+    global compiler_conditional_xfail_data\n+    set compiler_conditional_xfail_data {\n+        \"Fails at all optimization levels but -O0, see PR10375.\" \\\n+        { \"*-*-*\" } \\\n+        { \"-O*\" } \\\n+        { \"-O0\" }\n+    }\n+}\n+\n+return 0"}, {"sha": "c9c3acb98c908e282997ac62ebbb50893c8a238b", "filename": "gcc/testsuite/gcc.dg/Wshadow-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-1.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -10,10 +10,10 @@ void foo (double decl1)\t\t/* { dg-warning \"shadows a global decl\" } */\n {\t\t\t\t\n }\n \n-void foo1 (int d)\t\t/* { dg-warning \"shadowed declaration\" } */\n+void foo1 (int d)\t\t/* { dg-warning \"previous declaration\" } */\n {\n   double d;\t /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-  /* { dg-error \"shadows a parameter\" \"\" { target *-*-* } 15 } */\n+  /* { dg-error \"redeclared as different\" \"\" { target *-*-* } 15 } */\n }\n \n void foo2 (int d)\t\t/* { dg-warning \"shadowed declaration\" } */"}, {"sha": "d2355ba7aa298a734d7731a816cadddd4147837b", "filename": "gcc/testsuite/gcc.dg/redecl-1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339a28b96a306cb323a66e9142ab090d36f42ba8/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fredecl-1.c?ref=339a28b96a306cb323a66e9142ab090d36f42ba8", "patch": "@@ -0,0 +1,101 @@\n+/* Test for various situations where a new declaration of an\n+   identifier conflicts with an earlier declaration which isn't in the\n+   same scope.  These are all undefined behavior per C89 sections\n+   6.1.2.2p7, 6.1.2.6p2, and 6.3.2.2p2/footnote 38 (C99 6.2.2p7 and\n+   6.2.7p2 - implicit declarations are invalid in C99).  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c89 -pedantic -Wall -Wno-unused\" } */\n+\n+/* Extern at function scope, clashing with extern at file scope */\n+\n+extern int foo1;\t\t/* { dg-error \"previous\" } */\n+extern int bar1(int);\t\t/* { dg-error \"previous\" } */\n+\n+void test1(void)\n+{\n+  extern double foo1;\t\t/* { dg-error \"conflict\" } */\n+  extern double bar1(double);\t/* { dg-error \"conflict\" } */\n+}\n+\n+/* Extern at file scope, clashing with extern at function scope */\n+\n+void test2(void)\n+{\n+  extern double foo2;\t\t/* { dg-error \"previous\" } */\n+  extern double bar2(double);\t/* { dg-error \"previous\" } */\n+}\n+\n+extern int foo2;\t\t/* { dg-error \"conflict\" } */\n+extern int bar2(int);\t\t/* { dg-error \"conflict\" } */\n+\n+/* Extern at function scope, clashing with extern at earlier function\n+   scope.  Also, don't be fooled by a typedef at file scope.  */\n+\n+typedef float baz3;\t\t/* { dg-bogus } */\n+\n+void prime3(void)\n+{\n+  extern int foo3;\t\t/* { dg-error \"previous\" } */\n+  extern int bar3(int);\t\t/* { dg-error \"previous\" } */\n+  extern int baz3;\t\t/* { dg-error \"previous\" } */\n+}\n+\n+void test3(void)\n+{\n+  extern double foo3;\t\t/* { dg-error \"conflict\" } */\n+  extern double bar3(double);\t/* { dg-error \"conflict\" } */\n+  extern double baz3;\t\t/* { dg-error \"conflict\" } */\n+}\n+\n+/* Extern at function scope, clashing with previous implicit decl.  */\n+\n+void prime4(void)\n+{\n+  bar4();\t\t\t/* { dg-error \"previous|implicit\" } */\n+}\n+\n+void test4(void)\n+{\n+  extern double bar4(double);\t/* { dg-error \"conflict\" } */\n+}\n+\n+/* Implicit decl, clashing with extern at previous function scope.  */\n+\n+void prime5(void)\n+{\n+  extern double bar5(double);\t/* { dg-error \"previous\" \"\" { xfail *-*-* } } */\n+}\n+\n+void test5(void)\n+{\n+  bar5(1);\t\t\t/* { dg-error \"implicit\" } */\n+}\n+\n+/* Extern then static, both at file scope.  */\n+\n+extern int test6(int);\t\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+static int test6(int x)\t\t\t\n+{ return x; }\t\t\t/* { dg-warning \"follows non-static\" } */\n+\n+\n+/* Extern then static, extern at previous function scope.  */\n+\n+void prime7(void)\n+{\n+  extern int test7(int);\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+}\n+\n+static int test7(int x)\n+{ return x; }\t\t\t/* { dg-warning \"follows non-static\" } */\n+\n+/* Implicit decl then static.  */\n+\n+void prime8(void)\n+{\n+  test8();\t\t\t/* { dg-warning \"previous\" \"\" { xfail *-*-* } } */\n+                                /* { dg-warning \"implicit\" \"\" { target *-*-* } 96 } */\n+}\n+\n+static int test8(int x)\n+{ return x; }\t\t\t/* { dg-warning \"follows non-static\" } */"}]}