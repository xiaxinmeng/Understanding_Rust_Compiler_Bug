{"sha": "af21714c7bac20c348d544a285a2dc95fe271a5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyMTcxNGM3YmFjMjBjMzQ4ZDU0NGEyODVhMmRjOTVmZTI3MWE1ZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2015-03-29T15:38:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-29T15:38:52Z"}, "message": "re PR ipa/65478 (crafty performance regression)\n\n\n\tPR ipa/65478\n\t* params.def (PARAM_IPA_CP_RECURSION_PENALTY) : New.\n\t(PARAM_IPA_CP_SINGLE_CALL_PENALTY): Likewise.\n\t* ipa-prop.h (ipa_node_params): New flags node_within_scc and\n\tnode_calling_single_call.\n\t* ipa-cp.c (count_callers): New function.\n\t(set_single_call_flag): Likewise.\n\t(initialize_node_lattices): Count callers and set single_flag_call if\n\tnecessary.\n\t(incorporate_penalties): New function.\n\t(good_cloning_opportunity_p): Use it, dump new flags.\n\t(propagate_constants_topo): Set node_within_scc flag if appropriate.\n\t* doc/invoke.texi (ipa-cp-recursion-penalty,\n\tipa-cp-single-call-pentalty): Document.\n\nFrom-SVN: r221763", "tree": {"sha": "e453ad69e49ea0bba2b3abce3f4a11b1b1315dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e453ad69e49ea0bba2b3abce3f4a11b1b1315dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af21714c7bac20c348d544a285a2dc95fe271a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af21714c7bac20c348d544a285a2dc95fe271a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af21714c7bac20c348d544a285a2dc95fe271a5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af21714c7bac20c348d544a285a2dc95fe271a5d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1bff765cbff0bdab0c25bcf25b737c511c7f2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bff765cbff0bdab0c25bcf25b737c511c7f2d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bff765cbff0bdab0c25bcf25b737c511c7f2d7"}], "stats": {"total": 131, "additions": 123, "deletions": 8}, "files": [{"sha": "9baf88b1471f949481915b5eda8e63afefd282b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af21714c7bac20c348d544a285a2dc95fe271a5d", "patch": "@@ -1,3 +1,20 @@\n+2015-03-27  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/65478\n+\t* params.def (PARAM_IPA_CP_RECURSION_PENALTY) : New.\n+\t(PARAM_IPA_CP_SINGLE_CALL_PENALTY): Likewise.\n+\t* ipa-prop.h (ipa_node_params): New flags node_within_scc and\n+\tnode_calling_single_call.\n+\t* ipa-cp.c (count_callers): New function.\n+\t(set_single_call_flag): Likewise.\n+\t(initialize_node_lattices): Count callers and set single_flag_call if\n+\tnecessary.\n+\t(incorporate_penalties): New function.\n+\t(good_cloning_opportunity_p): Use it, dump new flags.\n+\t(propagate_constants_topo): Set node_within_scc flag if appropriate.\n+\t* doc/invoke.texi (ipa-cp-recursion-penalty,\n+\tipa-cp-single-call-pentalty): Document.\n+\n 2015-03-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65588"}, {"sha": "bf8afadfb942ff7c6f1baf504dded054366e90ee", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=af21714c7bac20c348d544a285a2dc95fe271a5d", "patch": "@@ -10834,6 +10834,15 @@ IPA-CP calculates its own score of cloning profitability heuristics\n and performs those cloning opportunities with scores that exceed\n @option{ipa-cp-eval-threshold}.\n \n+@item ipa-cp-recursion-penalty\n+Percentage penalty the recursive functions will receive when they\n+are evaluated for cloning.\n+\n+@item ipa-cp-single-call-penalty\n+Percentage penalty functions containg a single call to another\n+function will receive when they are evaluated for cloning.\n+\n+\n @item ipa-max-agg-items\n IPA-CP is also capable to propagate a number of scalar values passed\n in an aggregate. @option{ipa-max-agg-items} controls the maximum"}, {"sha": "d9aa92ed5b5a74950a6e3dbdfe880e272dbff7a4", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=af21714c7bac20c348d544a285a2dc95fe271a5d", "patch": "@@ -811,6 +811,41 @@ set_all_contains_variable (struct ipcp_param_lattices *plats)\n   return ret;\n }\n \n+/* Worker of call_for_symbol_thunks_and_aliases, increment the integer DATA\n+   points to by the number of callers to NODE.  */\n+\n+static bool\n+count_callers (cgraph_node *node, void *data)\n+{\n+  int *caller_count = (int *) data;\n+\n+  for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n+    /* Local thunks can be handled transparently, but if the thunk can not\n+       be optimized out, count it as a real use.  */\n+    if (!cs->caller->thunk.thunk_p || !cs->caller->local.local)\n+      ++*caller_count;\n+  return false;\n+}\n+\n+/* Worker of call_for_symbol_thunks_and_aliases, it is supposed to be called on\n+   the one caller of some other node.  Set the caller's corresponding flag.  */\n+\n+static bool\n+set_single_call_flag (cgraph_node *node, void *)\n+{\n+  cgraph_edge *cs = node->callers;\n+  /* Local thunks can be handled transparently, skip them.  */\n+  while (cs && cs->caller->thunk.thunk_p && cs->caller->local.local)\n+    cs = cs->next_caller;\n+  if (cs)\n+    {\n+      gcc_assert (!cs->next_caller);\n+      IPA_NODE_REF (cs->caller)->node_calling_single_call = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Initialize ipcp_lattices.  */\n \n static void\n@@ -822,7 +857,17 @@ initialize_node_lattices (struct cgraph_node *node)\n   int i;\n \n   gcc_checking_assert (node->has_gimple_body_p ());\n-  if (!cgraph_local_p (node))\n+  if (cgraph_local_p (node))\n+    {\n+      int caller_count = 0;\n+      node->call_for_symbol_thunks_and_aliases (count_callers, &caller_count,\n+\t\t\t\t\t\ttrue);\n+      gcc_checking_assert (caller_count > 0);\n+      if (caller_count == 1)\n+\tnode->call_for_symbol_thunks_and_aliases (set_single_call_flag,\n+\t\t\t\t\t\t  NULL, true);\n+    }\n+  else\n     {\n       /* When cloning is allowed, we can assume that externally visible\n \t functions are not called.  We will compensate this by cloning\n@@ -2105,6 +2150,24 @@ hint_time_bonus (inline_hints hints)\n   return result;\n }\n \n+/* If there is a reason to penalize the function described by INFO in the\n+   cloning goodness evaluation, do so.  */\n+\n+static inline int64_t\n+incorporate_penalties (ipa_node_params *info, int64_t evaluation)\n+{\n+  if (info->node_within_scc)\n+    evaluation = (evaluation\n+\t\t  * (100 - PARAM_VALUE (PARAM_IPA_CP_RECURSION_PENALTY))) / 100;\n+\n+  if (info->node_calling_single_call)\n+    evaluation = (evaluation\n+\t\t  * (100 - PARAM_VALUE (PARAM_IPA_CP_SINGLE_CALL_PENALTY)))\n+      / 100;\n+\n+  return evaluation;\n+}\n+\n /* Return true if cloning NODE is a good idea, given the estimated TIME_BENEFIT\n    and SIZE_COST and with the sum of frequencies of incoming edges to the\n    potential new clone in FREQUENCIES.  */\n@@ -2120,18 +2183,22 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \n   gcc_assert (size_cost > 0);\n \n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n   if (max_count)\n     {\n       int factor = (count_sum * 1000) / max_count;\n       int64_t evaluation = (((int64_t) time_benefit * factor)\n \t\t\t\t    / size_cost);\n+      evaluation = incorporate_penalties (info, evaluation);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n \t\t \"size: %i, count_sum: \" HOST_WIDE_INT_PRINT_DEC\n-\t\t \") -> evaluation: \" \"%\"PRId64\n+\t\t \"%s%s) -> evaluation: \" \"%\"PRId64\n \t\t \", threshold: %i\\n\",\n \t\t time_benefit, size_cost, (HOST_WIDE_INT) count_sum,\n+\t\t info->node_within_scc ? \", scc\" : \"\",\n+\t\t info->node_calling_single_call ? \", single_call\" : \"\",\n \t\t evaluation, PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n \n       return evaluation >= PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD);\n@@ -2140,13 +2207,16 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n     {\n       int64_t evaluation = (((int64_t) time_benefit * freq_sum)\n \t\t\t\t    / size_cost);\n+      evaluation = incorporate_penalties (info, evaluation);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"     good_cloning_opportunity_p (time: %i, \"\n-\t\t \"size: %i, freq_sum: %i) -> evaluation: \"\n+\t\t \"size: %i, freq_sum: %i%s%s) -> evaluation: \"\n \t\t \"%\"PRId64 \", threshold: %i\\n\",\n-\t\t time_benefit, size_cost, freq_sum, evaluation,\n-\t\t PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n+\t\t time_benefit, size_cost, freq_sum,\n+\t\t info->node_within_scc ? \", scc\" : \"\",\n+\t\t info->node_calling_single_call ? \", single_call\" : \"\",\n+\t\t evaluation, PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n \n       return evaluation >= PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD);\n     }\n@@ -2637,9 +2707,12 @@ propagate_constants_topo (struct ipa_topo_info *topo)\n \t  struct cgraph_edge *cs;\n \n \t  for (cs = v->callees; cs; cs = cs->next_callee)\n-\t    if (ipa_edge_within_scc (cs)\n-\t\t&& propagate_constants_accross_call (cs))\n-\t      push_node_to_stack (topo, cs->callee->function_symbol ());\n+\t    if (ipa_edge_within_scc (cs))\n+\t      {\n+\t\tIPA_NODE_REF (v)->node_within_scc = true;\n+\t\tif (propagate_constants_accross_call (cs))\n+\t\t  push_node_to_stack (topo, cs->callee->function_symbol ());\n+\t      }\n \t  v = pop_node_from_stack (topo);\n \t}\n "}, {"sha": "0488254492acb6b5763c21c818b211a8ee16601d", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=af21714c7bac20c348d544a285a2dc95fe271a5d", "patch": "@@ -330,6 +330,10 @@ struct ipa_node_params\n   /* Node has been completely replaced by clones and will be removed after\n      ipa-cp is finished.  */\n   unsigned node_dead : 1;\n+  /* Node is involved in a recursion, potentionally indirect.  */\n+  unsigned node_within_scc : 1;\n+  /* Node is calling a private function called only once.  */\n+  unsigned node_calling_single_call : 1;\n };\n \n /* ipa_node_params access functions.  Please use these to access fields that"}, {"sha": "5e2c7695865672649570e71fbbbfa991210f4258", "filename": "gcc/params.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af21714c7bac20c348d544a285a2dc95fe271a5d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=af21714c7bac20c348d544a285a2dc95fe271a5d", "patch": "@@ -999,6 +999,18 @@ DEFPARAM (PARAM_IPA_CP_EVAL_THRESHOLD,\n \t  \"beneficial to clone.\",\n \t  500, 0, 0)\n \n+DEFPARAM (PARAM_IPA_CP_RECURSION_PENALTY,\n+\t  \"ipa-cp-recursion-penalty\",\n+\t  \"Percentage penalty the recursive functions will receive when they \"\n+\t  \"are evaluated for cloning.\",\n+\t  40, 0, 100)\n+\n+DEFPARAM (PARAM_IPA_CP_SINGLE_CALL_PENALTY,\n+\t  \"ipa-cp-single-call-penalty\",\n+\t  \"Percentage penalty functions containg a single call to another \"\n+\t  \"function will receive when they are evaluated for cloning.\",\n+\t  15, 0, 100)\n+\n DEFPARAM (PARAM_IPA_MAX_AGG_ITEMS,\n \t  \"ipa-max-agg-items\",\n \t  \"Maximum number of aggregate content items for a parameter in \""}]}