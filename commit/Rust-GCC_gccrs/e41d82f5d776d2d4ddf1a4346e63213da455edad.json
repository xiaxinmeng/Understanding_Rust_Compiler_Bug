{"sha": "e41d82f5d776d2d4ddf1a4346e63213da455edad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQxZDgyZjVkNzc2ZDJkNGRkZjFhNDM0NmU2MzIxM2RhNDU1ZWRhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-09T07:43:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-09T07:43:40Z"}, "message": "re PR tree-optimization/20610 (Real by complex multiplications perform unnecessary operations)\n\n        PR tree-opt/20610\n        * tree.h (DECL_COMPLEX_GIMPLE_REG_P): New.\n        (struct tree_decl): Add gimple_reg_flag.\n        * integrate.c (copy_decl_for_inlining): Copy it.\n        * gimplify.c (internal_get_tmp_var): Set it.\n        (gimplify_bind_expr): Likewise.\n        (gimplify_function_tree): Likewise.\n        (gimplify_modify_expr_complex_part): New.\n        (gimplify_modify_expr): Use it.\n        * tree-gimple.c (is_gimple_reg_type): Allow complex.\n        (is_gimple_reg): Allow complex with DECL_COMPLEX_GIMPLE_REG_P set.\n\n        * tree-complex.c (complex_lattice_t): New.\n        (complex_lattice_values, complex_variable_components): New.\n        (some_nonzerop, find_lattice_value, is_complex_reg,\n        init_parameter_lattice_values, init_dont_simulate_again,\n        complex_visit_stmt, complex_visit_phi, create_components,\n        update_complex_components, update_parameter_components,\n        update_phi_components, update_all_vops, expand_complex_move): New.\n        (extract_component): Handle INDIRECT_REF, COMPONENT_REF, ARRAY_REF,\n        SSA_NAME.\n        (update_complex_assignment): Use update_complex_components;\n        handle updates of return_expr properly.\n        (expand_complex_addition): Use complex lattice values.\n        (expand_complex_multiplication): Likewise.\n        (expand_complex_division): Likewise.\n        (expand_complex_libcall): Use update_complex_components.\n        (expand_complex_comparison): Use update_stmt.\n        (expand_complex_operations_1): Use expand_complex_move, retrieve\n        lattice values.\n        (tree_lower_complex): Compute lattice values.\n        (tree_lower_complex_O0): Duplicate from tree_lower_complex.\n        (pass_lower_complex_O0): Rename from pass_lower_complex.\n        (pass_lower_complex, gate_no_optimization): New.\n        * tree-optimize.c (init_tree_optimization_passes): Update for\n        complex pass changes.\n        * tree-pass.h (pass_lower_complex_O0): Declare.\n\nFrom-SVN: r100793", "tree": {"sha": "003bf598fc6be666e758e157426518abcb2fef62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/003bf598fc6be666e758e157426518abcb2fef62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e41d82f5d776d2d4ddf1a4346e63213da455edad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41d82f5d776d2d4ddf1a4346e63213da455edad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e41d82f5d776d2d4ddf1a4346e63213da455edad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e41d82f5d776d2d4ddf1a4346e63213da455edad/comments", "author": null, "committer": null, "parents": [{"sha": "31920d83c2940d00b1c91d820016c6c67523cf60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31920d83c2940d00b1c91d820016c6c67523cf60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31920d83c2940d00b1c91d820016c6c67523cf60"}], "stats": {"total": 1079, "additions": 999, "deletions": 80}, "files": [{"sha": "672bb8f96a8e3dbc24487574e9b7e9b6e4f6341d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -1,3 +1,43 @@\n+2005-06-09  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/20610\n+\t* tree.h (DECL_COMPLEX_GIMPLE_REG_P): New.\n+\t(struct tree_decl): Add gimple_reg_flag.\n+\t* integrate.c (copy_decl_for_inlining): Copy it.\n+\t* gimplify.c (internal_get_tmp_var): Set it.\n+\t(gimplify_bind_expr): Likewise.\n+\t(gimplify_function_tree): Likewise.\n+\t(gimplify_modify_expr_complex_part): New.\n+\t(gimplify_modify_expr): Use it.\n+\t* tree-gimple.c (is_gimple_reg_type): Allow complex.\n+\t(is_gimple_reg): Allow complex with DECL_COMPLEX_GIMPLE_REG_P set.\n+\n+\t* tree-complex.c (complex_lattice_t): New.\n+\t(complex_lattice_values, complex_variable_components): New.\n+\t(some_nonzerop, find_lattice_value, is_complex_reg,\n+\tinit_parameter_lattice_values, init_dont_simulate_again, \n+\tcomplex_visit_stmt, complex_visit_phi, create_components,\n+\tupdate_complex_components, update_parameter_components, \n+\tupdate_phi_components, update_all_vops, expand_complex_move): New.\n+\t(extract_component): Handle INDIRECT_REF, COMPONENT_REF, ARRAY_REF,\n+\tSSA_NAME.\n+\t(update_complex_assignment): Use update_complex_components;\n+\thandle updates of return_expr properly.\n+\t(expand_complex_addition): Use complex lattice values.\n+\t(expand_complex_multiplication): Likewise.\n+\t(expand_complex_division): Likewise.\n+\t(expand_complex_libcall): Use update_complex_components.\n+\t(expand_complex_comparison): Use update_stmt.\n+\t(expand_complex_operations_1): Use expand_complex_move, retrieve\n+\tlattice values.\n+\t(tree_lower_complex): Compute lattice values.\n+\t(tree_lower_complex_O0): Duplicate from tree_lower_complex.\n+\t(pass_lower_complex_O0): Rename from pass_lower_complex.\n+\t(pass_lower_complex, gate_no_optimization): New.\n+\t* tree-optimize.c (init_tree_optimization_passes): Update for\n+\tcomplex pass changes.\n+\t* tree-pass.h (pass_lower_complex_O0): Declare.\n+\n 2005-06-08  Dale Johannesen  <dalej@apple.com>\n \n         * config/darwin.c (darwin_binds_local_p):  New."}, {"sha": "df93bc5dde88fdd39a1dd7bc1e03331e65db75ff", "filename": "gcc/gimplify.c", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -470,6 +470,9 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n \n   t = lookup_tmp_var (val, is_formal);\n \n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n+    DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n+\n   mod = build (MODIFY_EXPR, TREE_TYPE (t), t, val);\n \n   if (EXPR_HAS_LOCATION (val))\n@@ -856,7 +859,18 @@ gimplify_bind_expr (tree *expr_p, tree temp, tree *pre_p)\n \n   /* Mark variables seen in this bind expr.  */\n   for (t = BIND_EXPR_VARS (bind_expr); t ; t = TREE_CHAIN (t))\n-    DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n+    {\n+      DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n+\n+      /* Preliminarily mark non-addressed complex variables as eligible\n+\t for promotion to gimple registers.  We'll transform their uses\n+\t as we find them.  */\n+      if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+\t  && !TREE_THIS_VOLATILE (t)\n+\t  && (TREE_CODE (t) == VAR_DECL && !DECL_HARD_REGISTER (t))\n+\t  && !needs_to_live_in_memory (t))\n+\tDECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n+    }\n \n   gimple_push_bind_expr (bind_expr);\n   gimplify_ctxp->save_stack = false;\n@@ -3009,6 +3023,45 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n   return ret;\n }\n \n+/* Promote partial stores to COMPLEX variables to total stores.  *EXPR_P is\n+   a MODIFY_EXPR with a lhs of a REAL/IMAGPART_EXPR of a variable with\n+   DECL_COMPLEX_GIMPLE_REG_P set.  */\n+\n+static enum gimplify_status\n+gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n+{\n+  enum tree_code code, ocode;\n+  tree lhs, rhs, new_rhs, other, realpart, imagpart;\n+\n+  lhs = TREE_OPERAND (*expr_p, 0);\n+  rhs = TREE_OPERAND (*expr_p, 1);\n+  code = TREE_CODE (lhs);\n+  lhs = TREE_OPERAND (lhs, 0);\n+\n+  ocode = code == REALPART_EXPR ? IMAGPART_EXPR : REALPART_EXPR;\n+  other = build1 (ocode, TREE_TYPE (rhs), lhs);\n+  other = get_formal_tmp_var (other, pre_p);\n+\n+  realpart = code == REALPART_EXPR ? rhs : other;\n+  imagpart = code == REALPART_EXPR ? other : rhs;\n+\n+  if (TREE_CONSTANT (realpart) && TREE_CONSTANT (imagpart))\n+    new_rhs = build_complex (TREE_TYPE (lhs), realpart, imagpart);\n+  else\n+    new_rhs = build2 (COMPLEX_EXPR, TREE_TYPE (lhs), realpart, imagpart);\n+\n+  TREE_OPERAND (*expr_p, 0) = lhs;\n+  TREE_OPERAND (*expr_p, 1) = new_rhs;\n+\n+  if (want_value)\n+    {\n+      append_to_statement_list (*expr_p, pre_p);\n+      *expr_p = rhs;\n+    }\n+\n+  return GS_ALL_DONE;\n+}\n+\n /* Gimplify the MODIFY_EXPR node pointed by EXPR_P.\n \n       modify_expr\n@@ -3084,6 +3137,14 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \t}\n     }\n \n+  /* Transform partial stores to non-addressable complex variables into\n+     total stores.  This allows us to use real instead of virtual operands\n+     for these variables, which improves optimization.  */\n+  if ((TREE_CODE (*to_p) == REALPART_EXPR\n+       || TREE_CODE (*to_p) == IMAGPART_EXPR)\n+      && is_gimple_reg (TREE_OPERAND (*to_p, 0)))\n+    return gimplify_modify_expr_complex_part (expr_p, pre_p, want_value);\n+\n   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n     {\n       /* If we've somehow already got an SSA_NAME on the LHS, then\n@@ -4668,14 +4729,30 @@ gimplify_body (tree *body_p, tree fndecl, bool do_parms)\n void\n gimplify_function_tree (tree fndecl)\n {\n-  tree oldfn;\n+  tree oldfn, parm, ret;\n \n   oldfn = current_function_decl;\n   current_function_decl = fndecl;\n   cfun = DECL_STRUCT_FUNCTION (fndecl);\n   if (cfun == NULL)\n     allocate_struct_function (fndecl);\n \n+  for (parm = DECL_ARGUMENTS (fndecl); parm ; parm = TREE_CHAIN (parm))\n+    {\n+      /* Preliminarily mark non-addressed complex variables as eligible\n+         for promotion to gimple registers.  We'll transform their uses\n+         as we find them.  */\n+      if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n+          && !TREE_THIS_VOLATILE (parm)\n+          && !needs_to_live_in_memory (parm))\n+        DECL_COMPLEX_GIMPLE_REG_P (parm) = 1;\n+    }\n+\n+  ret = DECL_RESULT (fndecl);\n+  if (TREE_CODE (TREE_TYPE (ret)) == COMPLEX_TYPE\n+      && !needs_to_live_in_memory (ret))\n+    DECL_COMPLEX_GIMPLE_REG_P (ret) = 1;\n+\n   gimplify_body (&DECL_SAVED_TREE (fndecl), fndecl, true);\n \n   /* If we're instrumenting function entry/exit, then prepend the call to"}, {"sha": "e6e0867d6bcbc553c99e1fcd223c6d578f912fbd", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -107,6 +107,7 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n       TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n       TREE_READONLY (copy) = TREE_READONLY (decl);\n       TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n+      DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n     }\n   else\n     {"}, {"sha": "e3e6741cf5f8cfdeed6e9bf37a634d04818d3012", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 857, "deletions": 71, "changes": 928, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -21,70 +21,586 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tree.h\"\n #include \"tm.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"insn-codes.h\"\n-#include \"diagnostic.h\"\n-#include \"optabs.h\"\n-#include \"machmode.h\"\n-#include \"langhooks.h\"\n+#include \"real.h\"\n+#include \"flags.h\"\n #include \"tree-flow.h\"\n #include \"tree-gimple.h\"\n #include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n+#include \"tree-ssa-propagate.h\"\n+\n+\n+/* For each complex ssa name, a lattice value.  We're interested in finding\n+   out whether a complex number is degenerate in some way, having only real\n+   or only complex parts.  */\n+\n+typedef enum\n+{\n+  UNINITIALIZED = 0,\n+  ONLY_REAL = 1,\n+  ONLY_IMAG = 2,\n+  VARYING = 3\n+} complex_lattice_t;\n+\n+#define PAIR(a, b)  ((a) << 2 | (b))\n+\n+DEF_VEC_I(complex_lattice_t);\n+DEF_VEC_ALLOC_I(complex_lattice_t, heap);\n+\n+static VEC(complex_lattice_t, heap) *complex_lattice_values;\n+\n+/* For each complex variable, a pair of variables for the components.  */\n+static VEC(tree, heap) *complex_variable_components;\n+\n+\n+/* Return true if T is not a zero constant.  In the case of real values,\n+   we're only interested in +0.0.  */\n+\n+static int\n+some_nonzerop (tree t)\n+{\n+  int zerop = false;\n+\n+  if (TREE_CODE (t) == REAL_CST)\n+    zerop = REAL_VALUES_IDENTICAL (TREE_REAL_CST (t), dconst0);\n+  else if (TREE_CODE (t) == INTEGER_CST)\n+    zerop = integer_zerop (t);\n+\n+  return !zerop;\n+}\n+\n+/* Compute a lattice value from T.  It may be a gimple_val, or, as a \n+   special exception, a COMPLEX_EXPR.  */\n \n+static complex_lattice_t\n+find_lattice_value (tree t)\n+{\n+  tree real, imag;\n+  int r, i;\n+  complex_lattice_t ret;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case SSA_NAME:\n+      return VEC_index (complex_lattice_t, complex_lattice_values,\n+\t\t\tSSA_NAME_VERSION (t));\n+\n+    case COMPLEX_CST:\n+      real = TREE_REALPART (t);\n+      imag = TREE_IMAGPART (t);\n+      break;\n+\n+    case COMPLEX_EXPR:\n+      real = TREE_OPERAND (t, 0);\n+      imag = TREE_OPERAND (t, 1);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  r = some_nonzerop (real);\n+  i = some_nonzerop (imag);\n+  ret = r*ONLY_REAL + i*ONLY_IMAG;\n+\n+  /* ??? On occasion we could do better than mapping 0+0i to real, but we\n+     certainly don't want to leave it UNINITIALIZED, which eventually gets\n+     mapped to VARYING.  */\n+  if (ret == UNINITIALIZED)\n+    ret = ONLY_REAL;\n+\n+  return ret;\n+}\n+\n+/* Determine if LHS is something for which we're interested in seeing\n+   simulation results.  */\n+\n+static bool\n+is_complex_reg (tree lhs)\n+{\n+  return TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE && is_gimple_reg (lhs);\n+}\n+\n+/* Mark the incoming parameters to the function as VARYING.  */\n+\n+static void\n+init_parameter_lattice_values (void)\n+{\n+  tree parm;\n+\n+  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = TREE_CHAIN (parm))\n+    if (is_complex_reg (parm) && var_ann (parm) != NULL)\n+      {\n+\ttree ssa_name = default_def (parm);\n+\tVEC_replace (complex_lattice_t, complex_lattice_values,\n+\t\t     SSA_NAME_VERSION (ssa_name), VARYING);\n+      }\n+}\n+\n+/* Initialize DONT_SIMULATE_AGAIN for each stmt and phi.  Return false if\n+   we found no statements we want to simulate, and thus there's nothing for\n+   the entire pass to do.  */\n+\n+static bool\n+init_dont_simulate_again (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  tree phi;\n+  bool saw_a_complex_value = false;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tDONT_SIMULATE_AGAIN (phi) = !is_complex_reg (PHI_RESULT (phi));\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  bool dsa = true;\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR\n+\t      && is_complex_reg (TREE_OPERAND (stmt, 0)))\n+\t    {\n+\t      dsa = false;\n+\t      saw_a_complex_value = true;\n+\t    }\n+\n+\t  DONT_SIMULATE_AGAIN (stmt) = dsa;\n+\t}\n+    }\n+\n+  return saw_a_complex_value;\n+}\n+\n+\n+/* Evaluate statement STMT against the complex lattice defined above.  */\n+\n+static enum ssa_prop_result\n+complex_visit_stmt (tree stmt, edge *taken_edge_p ATTRIBUTE_UNUSED,\n+\t\t    tree *result_p)\n+{\n+  complex_lattice_t new_l, old_l, op1_l, op2_l;\n+  unsigned int ver;\n+  tree lhs, rhs;\n+\n+  /* These conditions should be satisfied due to the initial filter\n+     set up in init_dont_simulate_again.  */\n+  gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n+\n+  lhs = TREE_OPERAND (stmt, 0);\n+  rhs = TREE_OPERAND (stmt, 1);\n+\n+  gcc_assert (TREE_CODE (lhs) == SSA_NAME);\n+  gcc_assert (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE);\n+\n+  *result_p = lhs;\n+  ver = SSA_NAME_VERSION (lhs);\n+  old_l = VEC_index (complex_lattice_t, complex_lattice_values, ver);\n+\n+  switch (TREE_CODE (rhs))\n+    {\n+    case SSA_NAME:\n+    case COMPLEX_EXPR:\n+    case COMPLEX_CST:\n+      new_l = find_lattice_value (rhs);\n+      break;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      op1_l = find_lattice_value (TREE_OPERAND (rhs, 0));\n+      op2_l = find_lattice_value (TREE_OPERAND (rhs, 1));\n+\n+      /* We've set up the lattice values such that IOR neatly\n+\t models addition.  */\n+      new_l = op1_l | op2_l;\n+      break;\n+\n+    case MULT_EXPR:\n+    case RDIV_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+      op1_l = find_lattice_value (TREE_OPERAND (rhs, 0));\n+      op2_l = find_lattice_value (TREE_OPERAND (rhs, 1));\n+\n+      /* Obviously, if either varies, so does the result.  */\n+      if (op1_l == VARYING || op2_l == VARYING)\n+\tnew_l = VARYING;\n+      /* Don't prematurely promote variables if we've not yet seen\n+\t their inputs.  */\n+      else if (op1_l == UNINITIALIZED)\n+\tnew_l = op2_l;\n+      else if (op2_l == UNINITIALIZED)\n+\tnew_l = op1_l;\n+      else\n+\t{\n+\t  /* At this point both numbers have only one component. If the\n+\t     numbers are of opposite kind, the result is imaginary,\n+\t     otherwise the result is real. The add/subtract translates\n+\t     the real/imag from/to 0/1; the ^ performs the comparison.  */\n+\t  new_l = ((op1_l - ONLY_REAL) ^ (op2_l - ONLY_REAL)) + ONLY_REAL;\n+\n+\t  /* Don't allow the lattice value to flip-flop indefinitely.  */\n+\t  new_l |= old_l;\n+\t}\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case CONJ_EXPR:\n+      new_l = find_lattice_value (TREE_OPERAND (rhs, 0));\n+      break;\n+\n+    default:\n+      new_l = VARYING;\n+      break;\n+    }\n+\n+  /* If nothing changed this round, let the propagator know.  */\n+  if (new_l == old_l)\n+    return SSA_PROP_NOT_INTERESTING;\n+\n+  VEC_replace (complex_lattice_t, complex_lattice_values, ver, new_l);\n+  return new_l == VARYING ? SSA_PROP_VARYING : SSA_PROP_INTERESTING;\n+}\n+\n+/* Evaluate a PHI node against the complex lattice defined above.  */\n+\n+static enum ssa_prop_result\n+complex_visit_phi (tree phi)\n+{\n+  complex_lattice_t new_l, old_l;\n+  unsigned int ver;\n+  tree lhs;\n+  int i;\n+\n+  lhs = PHI_RESULT (phi);\n+\n+  /* This condition should be satisfied due to the initial filter\n+     set up in init_dont_simulate_again.  */\n+  gcc_assert (TREE_CODE (TREE_TYPE (lhs)) == COMPLEX_TYPE);\n+\n+  /* We've set up the lattice values such that IOR neatly models PHI meet.  */\n+  new_l = UNINITIALIZED;\n+  for (i = PHI_NUM_ARGS (phi) - 1; i >= 0; --i)\n+    new_l |= find_lattice_value (PHI_ARG_DEF (phi, i));\n+\n+  ver = SSA_NAME_VERSION (lhs);\n+  old_l = VEC_index (complex_lattice_t, complex_lattice_values, ver);\n+\n+  if (new_l == old_l)\n+    return SSA_PROP_NOT_INTERESTING;\n+\n+  VEC_replace (complex_lattice_t, complex_lattice_values, ver, new_l);\n+  return new_l == VARYING ? SSA_PROP_VARYING : SSA_PROP_INTERESTING;\n+}\n+\n+/* For each referenced complex gimple register, set up a pair of registers\n+   to hold the components of the complex value.  */\n+\n+static void\n+create_components (void)\n+{\n+  size_t k, n;\n+\n+  n = num_referenced_vars;\n+  complex_variable_components = VEC_alloc (tree, heap, 2*n);\n+  VEC_safe_grow (tree, heap, complex_variable_components, 2*n);\n+\n+  for (k = 0; k < n; ++k)\n+    {\n+      tree var = referenced_var (k);\n+      tree r = NULL, i = NULL;\n+\n+      if (var != NULL\n+\t  && TREE_CODE (TREE_TYPE (var)) == COMPLEX_TYPE\n+\t  && is_gimple_reg (var))\n+\t{\n+\t  tree inner_type = TREE_TYPE (TREE_TYPE (var));\n+\n+\t  r = make_rename_temp (inner_type, \"CR\");\n+\t  i = make_rename_temp (inner_type, \"CI\");\n+\t  DECL_SOURCE_LOCATION (r) = DECL_SOURCE_LOCATION (var);\n+\t  DECL_SOURCE_LOCATION (i) = DECL_SOURCE_LOCATION (var);\n+\t  DECL_ARTIFICIAL (r) = 1;\n+\t  DECL_ARTIFICIAL (i) = 1;\n+\n+\t  if (DECL_NAME (var) && !DECL_IGNORED_P (var))\n+\t    {\n+\t      const char *name = IDENTIFIER_POINTER (DECL_NAME (var));\n+\n+\t      DECL_NAME (r) = get_identifier (ACONCAT ((name, \"$real\", NULL)));\n+\t      DECL_NAME (i) = get_identifier (ACONCAT ((name, \"$imag\", NULL)));\n+\n+\t      SET_DECL_DEBUG_EXPR (r, build1 (REALPART_EXPR, inner_type, var));\n+\t      SET_DECL_DEBUG_EXPR (i, build1 (IMAGPART_EXPR, inner_type, var));\n+\t      DECL_DEBUG_EXPR_IS_FROM (r) = 1;\n+\t      DECL_DEBUG_EXPR_IS_FROM (i) = 1;\n+\n+\t      DECL_IGNORED_P (r) = 0;\n+\t      DECL_IGNORED_P (i) = 0;\n+\n+\t      TREE_NO_WARNING (r) = TREE_NO_WARNING (var);\n+\t      TREE_NO_WARNING (i) = TREE_NO_WARNING (var);\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_IGNORED_P (r) = 1;\n+\t      DECL_IGNORED_P (i) = 1;\n+\t      TREE_NO_WARNING (r) = 1;\n+\t      TREE_NO_WARNING (i) = 1;\n+\t    }\n+\t}\n+\n+      VEC_replace (tree, complex_variable_components, 2*k, r);\n+      VEC_replace (tree, complex_variable_components, 2*k + 1, i);\n+    }\n+}\n \n /* Extract the real or imaginary part of a complex variable or constant.\n    Make sure that it's a proper gimple_val and gimplify it if not.\n    Emit any new code before BSI.  */\n \n static tree\n-extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p)\n+extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p,\n+\t\t   bool gimple_p)\n {\n-  tree ret, inner_type;\n-\n-  inner_type = TREE_TYPE (TREE_TYPE (t));\n   switch (TREE_CODE (t))\n     {\n     case COMPLEX_CST:\n-      ret = (imagpart_p ? TREE_IMAGPART (t) : TREE_REALPART (t));\n-      break;\n+      return imagpart_p ? TREE_IMAGPART (t) : TREE_REALPART (t);\n \n     case COMPLEX_EXPR:\n-      ret = TREE_OPERAND (t, imagpart_p);\n-      break;\n+      return TREE_OPERAND (t, imagpart_p);\n \n     case VAR_DECL:\n     case PARM_DECL:\n-      ret = build1 ((imagpart_p ? IMAGPART_EXPR : REALPART_EXPR),\n-\t\t    inner_type, t);\n-      break;\n+    case INDIRECT_REF:\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+      {\n+\ttree inner_type = TREE_TYPE (TREE_TYPE (t));\n+\n+\tt = build1 ((imagpart_p ? IMAGPART_EXPR : REALPART_EXPR),\n+\t\t    inner_type, unshare_expr (t));\n+\n+\tif (gimple_p)\n+\t  t = gimplify_val (bsi, inner_type, t);\n+\n+\treturn t;\n+      }\n+\n+    case SSA_NAME:\n+      {\n+\ttree def = SSA_NAME_DEF_STMT (t);\n+\n+\tif (TREE_CODE (def) == MODIFY_EXPR)\n+\t  {\n+\t    def = TREE_OPERAND (def, 1);\n+\t    if (TREE_CODE (def) == COMPLEX_CST)\n+\t      return imagpart_p ? TREE_IMAGPART (def) : TREE_REALPART (def);\n+\t    if (TREE_CODE (def) == COMPLEX_EXPR)\n+\t      {\n+\t\tdef = TREE_OPERAND (def, imagpart_p);\n+\t\tif (TREE_CONSTANT (def))\n+\t\t  return def;\n+\t      }\n+\t  }\n+\n+\treturn VEC_index (tree, complex_variable_components,\n+\t\t\t  var_ann (SSA_NAME_VAR (t))->uid * 2 + imagpart_p);\n+      }\n \n     default:\n       gcc_unreachable ();\n     }\n+}\n+\n+/* Update the complex components of the ssa name on the lhs of STMT.  */\n \n-  return gimplify_val (bsi, inner_type, ret);\n+static void\n+update_complex_components (block_stmt_iterator *bsi, tree stmt, tree r, tree i)\n+{\n+  unsigned int uid = var_ann (SSA_NAME_VAR (TREE_OPERAND (stmt, 0)))->uid;\n+  tree v, x;\n+\n+  v = VEC_index (tree, complex_variable_components, 2*uid);\n+  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, r);\n+  SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n+  TREE_BLOCK (x) = TREE_BLOCK (stmt);\n+  bsi_insert_after (bsi, x, BSI_NEW_STMT);\n+\n+  v = VEC_index (tree, complex_variable_components, 2*uid + 1);\n+  x = build2 (MODIFY_EXPR, TREE_TYPE (v), v, i);\n+  SET_EXPR_LOCUS (x, EXPR_LOCUS (stmt));\n+  TREE_BLOCK (x) = TREE_BLOCK (stmt);\n+  bsi_insert_after (bsi, x, BSI_NEW_STMT);\n }\n \n /* Update an assignment to a complex variable in place.  */\n \n static void\n update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n {\n-  tree stmt = bsi_stmt (*bsi);\n+  tree stmt, mod;\n   tree type;\n \n+  mod = stmt = bsi_stmt (*bsi);\n   if (TREE_CODE (stmt) == RETURN_EXPR)\n-    stmt = TREE_OPERAND (stmt, 0);\n+    mod = TREE_OPERAND (mod, 0);\n+  else if (in_ssa_p)\n+    update_complex_components (bsi, stmt, r, i);\n   \n-  type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n-  TREE_OPERAND (stmt, 1) = build (COMPLEX_EXPR, type, r, i);\n-  mark_stmt_modified (stmt);\n+  type = TREE_TYPE (TREE_OPERAND (mod, 1));\n+  TREE_OPERAND (mod, 1) = build (COMPLEX_EXPR, type, r, i);\n+  update_stmt (stmt);\n+}\n+\n+/* Generate code at the entry point of the function to initialize the\n+   component variables for a complex parameter.  */\n+\n+static void\n+update_parameter_components (void)\n+{\n+  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);\n+  tree parm;\n+\n+  for (parm = DECL_ARGUMENTS (cfun->decl); parm ; parm = TREE_CHAIN (parm))\n+    {\n+      tree type = TREE_TYPE (parm);\n+      tree ssa_name, x, y;\n+      unsigned int uid;\n+\n+      if (TREE_CODE (type) != COMPLEX_TYPE || !is_gimple_reg (parm))\n+\tcontinue;\n+\n+      type = TREE_TYPE (type);\n+      ssa_name = default_def (parm);\n+      uid = var_ann (parm)->uid;\n+\n+      x = VEC_index (tree, complex_variable_components, 2*uid);\n+      y = build1 (REALPART_EXPR, type, ssa_name);\n+      bsi_insert_on_edge (entry_edge, build2 (MODIFY_EXPR, type, x, y));\n+\n+      x = VEC_index (tree, complex_variable_components, 2*uid + 1);\n+      y = build1 (IMAGPART_EXPR, type, ssa_name);\n+      bsi_insert_on_edge (entry_edge, build2 (MODIFY_EXPR, type, x, y));\n+    }\n+}\n+\n+/* Generate code to set the component variables of a complex variable\n+   to match the PHI statements in block BB.  */\n+\n+static void\n+update_phi_components (basic_block bb)\n+{\n+  tree phi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    if (is_complex_reg (PHI_RESULT (phi)))\n+      {\n+\tunsigned int i, n, uid;\n+\ttree real, imag, type;\n+\n+\tuid = var_ann (SSA_NAME_VAR (PHI_RESULT (phi)))->uid;\n+\treal = VEC_index (tree, complex_variable_components, 2*uid);\n+\timag = VEC_index (tree, complex_variable_components, 2*uid + 1);\n+\ttype = TREE_TYPE (real);\n+\n+\tfor (i = 0, n = PHI_NUM_ARGS (phi); i < n; ++i)\n+\t  {\n+\t    edge e = PHI_ARG_EDGE (phi, i);\n+\t    tree arg = PHI_ARG_DEF (phi, i);\n+\t    tree x;\n+\n+\t    x = extract_component (NULL, arg, 0, false);\n+\t    if (real != x)\n+\t      bsi_insert_on_edge (e, build2 (MODIFY_EXPR, type, real, x));\n+\n+\t    x = extract_component (NULL, arg, 1, false);\n+\t    if (imag != x)\n+\t      bsi_insert_on_edge (e, build2 (MODIFY_EXPR, type, imag, x));\n+\t  }\n+      }\n+}\n+\n+/* Mark each virtual op in STMT for ssa update.  */\n+\n+static void\n+update_all_vops (tree stmt)\n+{\n+  ssa_op_iter iter;\n+  tree sym;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (sym, stmt, iter, SSA_OP_ALL_VIRTUALS)\n+    {\n+      if (TREE_CODE (sym) == SSA_NAME)\n+\tsym = SSA_NAME_VAR (sym);\n+      mark_sym_for_renaming (sym);\n+    }\n+}\n+\n+/* Expand a complex move to scalars.  */\n+\n+static void\n+expand_complex_move (block_stmt_iterator *bsi, tree stmt, tree type,\n+\t\t     tree lhs, tree rhs)\n+{\n+  tree inner_type = TREE_TYPE (type);\n+  tree r, i;\n+\n+  if (TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      if (TREE_CODE (rhs) == CALL_EXPR || TREE_SIDE_EFFECTS (rhs))\n+\t{\n+\t  r = build1 (REALPART_EXPR, inner_type, unshare_expr (lhs));\n+\t  i = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n+\t  update_complex_components (bsi, stmt, r, i);\n+\t}\n+      else\n+\t{\n+\t  update_all_vops (bsi_stmt (*bsi));\n+\t  r = extract_component (bsi, rhs, 0, true);\n+\t  i = extract_component (bsi, rhs, 1, true);\n+\t  update_complex_assignment (bsi, r, i);\n+\t}\n+    }\n+  else if (TREE_CODE (rhs) == SSA_NAME && !TREE_SIDE_EFFECTS (lhs))\n+    {\n+      tree x;\n+\n+      r = extract_component (bsi, rhs, 0, false);\n+      i = extract_component (bsi, rhs, 1, false);\n+\n+      x = build1 (REALPART_EXPR, inner_type, unshare_expr (lhs));\n+      x = build2 (MODIFY_EXPR, inner_type, x, r);\n+      bsi_insert_before (bsi, x, BSI_SAME_STMT);\n+\n+      if (stmt == bsi_stmt (*bsi))\n+\t{\n+\t  x = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n+\t  TREE_OPERAND (stmt, 0) = x;\n+\t  TREE_OPERAND (stmt, 1) = i;\n+\t  TREE_TYPE (stmt) = inner_type;\n+\t}\n+      else\n+\t{\n+\t  x = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n+\t  x = build2 (MODIFY_EXPR, inner_type, x, i);\n+\t  bsi_insert_before (bsi, x, BSI_SAME_STMT);\n+\n+\t  stmt = bsi_stmt (*bsi);\n+\t  gcc_assert (TREE_CODE (stmt) == RETURN_EXPR);\n+\t  TREE_OPERAND (stmt, 0) = lhs;\n+\t}\n+\n+      update_all_vops (stmt);\n+      update_stmt (stmt);\n+    }\n }\n \n /* Expand complex addition to scalars:\n@@ -95,12 +611,72 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n static void\n expand_complex_addition (block_stmt_iterator *bsi, tree inner_type,\n \t\t\t tree ar, tree ai, tree br, tree bi,\n-\t\t\t enum tree_code code)\n+\t\t\t enum tree_code code,\n+\t\t\t complex_lattice_t al, complex_lattice_t bl)\n {\n   tree rr, ri;\n \n-  rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n-  ri = gimplify_build2 (bsi, code, inner_type, ai, bi);\n+  switch (PAIR (al, bl))\n+    {\n+    case PAIR (ONLY_REAL, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = ai;\n+      break;\n+\n+    case PAIR (ONLY_REAL, ONLY_IMAG):\n+      rr = ar;\n+      if (code == MINUS_EXPR)\n+\tri = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, bi);\n+      else\n+\tri = bi;\n+      break;\n+\n+    case PAIR (ONLY_IMAG, ONLY_REAL):\n+      if (code == MINUS_EXPR)\n+\trr = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ar, br);\n+      else\n+\trr = br;\n+      ri = ai;\n+      break;\n+\n+    case PAIR (ONLY_IMAG, ONLY_IMAG):\n+      rr = ar;\n+      ri = gimplify_build2 (bsi, code, inner_type, ai, bi);\n+      break;\n+\n+    case PAIR (VARYING, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = ai;\n+      break;\n+\n+    case PAIR (VARYING, ONLY_IMAG):\n+      rr = ar;\n+      ri = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, bi);\n+      break;\n+\n+    case PAIR (ONLY_REAL, VARYING):\n+      if (code == MINUS_EXPR)\n+\tgoto general;\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = bi;\n+      break;\n+\n+    case PAIR (ONLY_IMAG, VARYING):\n+      if (code == MINUS_EXPR)\n+\tgoto general;\n+      rr = br;\n+      ri = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, bi);\n+      break;\n+\n+    case PAIR (VARYING, VARYING):\n+    general:\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = gimplify_build2 (bsi, code, inner_type, ai, bi);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -137,6 +713,14 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n   TREE_OPERAND (stmt, 1)\n     = build3 (CALL_EXPR, type, build_fold_addr_expr (fn), args, NULL);\n   update_stmt (stmt);\n+\n+  if (in_ssa_p)\n+    {\n+      tree lhs = TREE_OPERAND (stmt, 0);\n+      update_complex_components (bsi, stmt,\n+\t\t\t\t build1 (REALPART_EXPR, type, lhs),\n+\t\t\t\t build1 (IMAGPART_EXPR, type, lhs));\n+    }\n }\n \n /* Expand complex multiplication to scalars:\n@@ -145,29 +729,81 @@ expand_complex_libcall (block_stmt_iterator *bsi, tree ar, tree ai,\n \n static void\n expand_complex_multiplication (block_stmt_iterator *bsi, tree inner_type,\n-\t\t\t       tree ar, tree ai, tree br, tree bi)\n+\t\t\t       tree ar, tree ai, tree br, tree bi,\n+\t\t\t       complex_lattice_t al, complex_lattice_t bl)\n {\n-  tree t1, t2, t3, t4, rr, ri;\n+  tree rr, ri;\n \n-  if (flag_complex_method == 2 && SCALAR_FLOAT_TYPE_P (inner_type))\n+  if (al < bl)\n     {\n-      expand_complex_libcall (bsi, ar, ai, br, bi, MULT_EXPR);\n-      return;\n+      complex_lattice_t tl;\n+      rr = ar, ar = br, br = rr;\n+      ri = ai, ai = bi, bi = ri;\n+      tl = al, al = bl, bl = tl;\n     }\n \n-  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n-  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n-  t3 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n+  switch (PAIR (al, bl))\n+    {\n+    case PAIR (ONLY_REAL, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n+      ri = ai;\n+      break;\n \n-  /* Avoid expanding redundant multiplication for the common\n-     case of squaring a complex number.  */\n-  if (ar == br && ai == bi)\n-    t4 = t3;\n-  else\n-    t4 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n+    case PAIR (ONLY_IMAG, ONLY_REAL):\n+      rr = ar;\n+      if (TREE_CODE (ai) == REAL_CST\n+\t  && REAL_VALUES_IDENTICAL (TREE_REAL_CST (ai), dconst1))\n+\tri = br;\n+      else\n+\tri = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n+      break;\n \n-  rr = gimplify_build2 (bsi, MINUS_EXPR, inner_type, t1, t2);\n-  ri = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t3, t4);\n+    case PAIR (ONLY_IMAG, ONLY_IMAG):\n+      rr = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n+      rr = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, rr);\n+      ri = ar;\n+      break;\n+\n+    case PAIR (VARYING, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n+      ri = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n+      break;\n+\n+    case PAIR (VARYING, ONLY_IMAG):\n+      rr = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n+      rr = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, rr);\n+      ri = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n+      break;\n+\n+    case PAIR (VARYING, VARYING):\n+      if (flag_complex_method == 2 && SCALAR_FLOAT_TYPE_P (inner_type))\n+\t{\n+\t  expand_complex_libcall (bsi, ar, ai, br, bi, MULT_EXPR);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  tree t1, t2, t3, t4;\n+\n+\t  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n+\t  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n+\t  t3 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n+\n+\t  /* Avoid expanding redundant multiplication for the common\n+\t     case of squaring a complex number.  */\n+\t  if (ar == br && ai == bi)\n+\t    t4 = t3;\n+\t  else\n+\t    t4 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n+\n+\t  rr = gimplify_build2 (bsi, MINUS_EXPR, inner_type, t1, t2);\n+\t  ri = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t3, t4);\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -349,31 +985,77 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n static void\n expand_complex_division (block_stmt_iterator *bsi, tree inner_type,\n \t\t\t tree ar, tree ai, tree br, tree bi,\n-\t\t\t enum tree_code code)\n+\t\t\t enum tree_code code,\n+\t\t\t complex_lattice_t al, complex_lattice_t bl)\n {\n-  switch (flag_complex_method)\n+  tree rr, ri;\n+\n+  switch (PAIR (al, bl))\n     {\n-    case 0:\n-      /* straightforward implementation of complex divide acceptable.  */\n-      expand_complex_div_straight (bsi, inner_type, ar, ai, br, bi, code);\n+    case PAIR (ONLY_REAL, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = ai;\n       break;\n \n-    case 2:\n-      if (SCALAR_FLOAT_TYPE_P (inner_type))\n-\t{\n-\t  expand_complex_libcall (bsi, ar, ai, br, bi, code);\n-\t  return;\n-\t}\n-      /* FALLTHRU */\n+    case PAIR (ONLY_REAL, ONLY_IMAG):\n+      rr = ai;\n+      ri = gimplify_build2 (bsi, code, inner_type, ar, bi);\n+      ri = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, ri);\n+      break;\n+\n+    case PAIR (ONLY_IMAG, ONLY_REAL):\n+      rr = ar;\n+      ri = gimplify_build2 (bsi, code, inner_type, ai, br);\n+      break;\n \n-    case 1:\n-      /* wide ranges of inputs must work for complex divide.  */\n-      expand_complex_div_wide (bsi, inner_type, ar, ai, br, bi, code);\n+    case PAIR (ONLY_IMAG, ONLY_IMAG):\n+      rr = gimplify_build2 (bsi, code, inner_type, ai, bi);\n+      ri = ar;\n       break;\n \n+    case PAIR (VARYING, ONLY_REAL):\n+      rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+      ri = gimplify_build2 (bsi, code, inner_type, ai, br);\n+      break;\n+\n+    case PAIR (VARYING, ONLY_IMAG):\n+      rr = gimplify_build2 (bsi, code, inner_type, ai, bi);\n+      ri = gimplify_build2 (bsi, code, inner_type, ar, bi);\n+      ri = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, ri);\n+\n+    case PAIR (ONLY_REAL, VARYING):\n+    case PAIR (ONLY_IMAG, VARYING):\n+    case PAIR (VARYING, VARYING):\n+      switch (flag_complex_method)\n+\t{\n+\tcase 0:\n+\t  /* straightforward implementation of complex divide acceptable.  */\n+\t  expand_complex_div_straight (bsi, inner_type, ar, ai, br, bi, code);\n+\t  break;\n+\n+\tcase 2:\n+\t  if (SCALAR_FLOAT_TYPE_P (inner_type))\n+\t    {\n+\t      expand_complex_libcall (bsi, ar, ai, br, bi, code);\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n+\n+\tcase 1:\n+\t  /* wide ranges of inputs must work for complex divide.  */\n+\t  expand_complex_div_wide (bsi, inner_type, ar, ai, br, bi, code);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      return;\n+\n     default:\n       gcc_unreachable ();\n     }\n+\n+  update_complex_assignment (bsi, rr, ri);\n }\n \n /* Expand complex negation to scalars:\n@@ -439,7 +1121,7 @@ expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n       gcc_unreachable ();\n     }\n \n-  mark_stmt_modified (stmt);\n+  update_stmt (stmt);\n }\n \n /* Process one statement.  If we identify a complex operation, expand it.  */\n@@ -450,6 +1132,7 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n   tree stmt = bsi_stmt (*bsi);\n   tree rhs, type, inner_type;\n   tree ac, ar, ai, bc, br, bi;\n+  complex_lattice_t al, bl;\n   enum tree_code code;\n \n   switch (TREE_CODE (stmt))\n@@ -503,14 +1186,30 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n       break;\n \n     default:\n+      {\n+\ttree lhs = TREE_OPERAND (stmt, 0);\n+\ttree rhs = TREE_OPERAND (stmt, 1);\n+\n+\tif (TREE_CODE (type) == COMPLEX_TYPE)\n+\t  expand_complex_move (bsi, stmt, type, lhs, rhs);\n+\telse if ((TREE_CODE (rhs) == REALPART_EXPR\n+\t\t  || TREE_CODE (rhs) == IMAGPART_EXPR)\n+\t\t && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n+\t  {\n+\t    TREE_OPERAND (stmt, 1)\n+\t      = extract_component (bsi, TREE_OPERAND (rhs, 0),\n+\t\t\t\t   TREE_CODE (rhs) == IMAGPART_EXPR, false);\n+\t    update_stmt (stmt);\n+\t  }\n+      }\n       return;\n     }\n \n   /* Extract the components of the two complex values.  Make sure and\n      handle the common case of the same value used twice specially.  */\n   ac = TREE_OPERAND (rhs, 0);\n-  ar = extract_component (bsi, ac, 0);\n-  ai = extract_component (bsi, ac, 1);\n+  ar = extract_component (bsi, ac, 0, true);\n+  ai = extract_component (bsi, ac, 1, true);\n \n   if (TREE_CODE_CLASS (code) == tcc_unary)\n     bc = br = bi = NULL;\n@@ -521,28 +1220,48 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n \tbr = ar, bi = ai;\n       else\n \t{\n-\t  br = extract_component (bsi, bc, 0);\n-\t  bi = extract_component (bsi, bc, 1);\n+\t  br = extract_component (bsi, bc, 0, true);\n+\t  bi = extract_component (bsi, bc, 1, true);\n \t}\n     }\n \n+  if (in_ssa_p)\n+    {\n+      al = find_lattice_value (ac);\n+      if (al == UNINITIALIZED)\n+\tal = VARYING;\n+\n+      if (TREE_CODE_CLASS (code) == tcc_unary)\n+\tbl = UNINITIALIZED;\n+      else if (ac == bc)\n+\tbl = al;\n+      else\n+\t{\n+\t  bl = find_lattice_value (bc);\n+\t  if (bl == UNINITIALIZED)\n+\t    bl = VARYING;\n+\t}\n+    }\n+  else\n+    al = bl = VARYING;\n+\n   switch (code)\n     {\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      expand_complex_addition (bsi, inner_type, ar, ai, br, bi, code);\n+      expand_complex_addition (bsi, inner_type, ar, ai, br, bi, code, al, bl);\n       break;\n \n     case MULT_EXPR:\n-      expand_complex_multiplication (bsi, inner_type, ar, ai, br, bi);\n+      expand_complex_multiplication (bsi, inner_type, ar, ai, br, bi, al, bl);\n       break;\n \n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case RDIV_EXPR:\n-      expand_complex_division (bsi, inner_type, ar, ai, br, bi, code);\n+      expand_complex_division (bsi, inner_type, ar, ai, br, bi, code, al, bl);\n       break;\n       \n     case NEGATE_EXPR:\n@@ -561,25 +1280,48 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n     default:\n       gcc_unreachable ();\n     }\n-  update_stmt_if_modified (stmt);\n }\n \n+\f\n+/* Entry point for complex operation lowering during optimization.  */\n+\n static void\n tree_lower_complex (void)\n {\n-  int old_last_basic_block = last_basic_block;\n+  int old_last_basic_block;\n   block_stmt_iterator bsi;\n   basic_block bb;\n \n+  if (!init_dont_simulate_again ())\n+    return;\n+\n+  complex_lattice_values = VEC_alloc (complex_lattice_t, heap, num_ssa_names);\n+  VEC_safe_grow (complex_lattice_t, heap,\n+\t\t complex_lattice_values, num_ssa_names);\n+  memset (VEC_address (complex_lattice_t, complex_lattice_values), 0,\n+\t  num_ssa_names * sizeof(complex_lattice_t));\n+  init_parameter_lattice_values ();\n+\n+  ssa_propagate (complex_visit_stmt, complex_visit_phi);\n+\n+  create_components ();\n+  update_parameter_components ();\n+\n+  old_last_basic_block = last_basic_block;\n   FOR_EACH_BB (bb)\n     {\n       if (bb->index >= old_last_basic_block)\n \tcontinue;\n+      update_phi_components (bb);\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \texpand_complex_operations_1 (&bsi);\n     }\n-}\n \n+  bsi_commit_edge_inserts ();\n+\n+  VEC_free (tree, heap, complex_variable_components);\n+  VEC_free (complex_lattice_t, heap, complex_lattice_values);\n+}\n \n struct tree_opt_pass pass_lower_complex = \n {\n@@ -590,6 +1332,50 @@ struct tree_opt_pass pass_lower_complex =\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   0,\t\t\t\t\t/* tv_id */\n+  PROP_ssa,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect\n+    | TODO_update_ssa\n+    | TODO_verify_stmts,\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+\f\n+/* Entry point for complex operation lowering without optimization.  */\n+\n+static void\n+tree_lower_complex_O0 (void)\n+{\n+  int old_last_basic_block = last_basic_block;\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->index >= old_last_basic_block)\n+\tcontinue;\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\texpand_complex_operations_1 (&bsi);\n+    }\n+}\n+\n+static bool\n+gate_no_optimization (void)\n+{\n+  return optimize == 0;\n+}\n+\n+struct tree_opt_pass pass_lower_complex_O0 = \n+{\n+  \"cplxlower0\",\t\t\t\t/* name */\n+  gate_no_optimization,\t\t\t/* gate */\n+  tree_lower_complex_O0,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n   PROP_cfg,\t\t\t\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */"}, {"sha": "3bf773b23ea85ef4bbbceffe625f56bcd89edafa", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -260,12 +260,10 @@ is_gimple_id (tree t)\n bool\n is_gimple_reg_type (tree type)\n {\n-  return (!AGGREGATE_TYPE_P (type)\n-          && TREE_CODE (type) != COMPLEX_TYPE);\n+  return !AGGREGATE_TYPE_P (type);\n }\n \n-\n-/* Return true if T is a scalar register variable.  */\n+/* Return true if T is a non-aggregate register variable.  */\n \n bool\n is_gimple_reg (tree t)\n@@ -275,6 +273,7 @@ is_gimple_reg (tree t)\n \n   if (!is_gimple_variable (t))\n     return false;\n+\n   if (!is_gimple_reg_type (TREE_TYPE (t)))\n     return false;\n \n@@ -301,6 +300,11 @@ is_gimple_reg (tree t)\n   if (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t))\n     return false;\n \n+  /* Complex values must have been put into ssa form.  That is, no \n+     assignments to the individual components.  */\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n+    return DECL_COMPLEX_GIMPLE_REG_P (t);\n+\n   return true;\n }\n "}, {"sha": "4284a58b8fc863b661e9d7c5824d0c92f774d70a", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -375,7 +375,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_lower_cf); \n   NEXT_PASS (pass_lower_eh); \n   NEXT_PASS (pass_build_cfg); \n-  NEXT_PASS (pass_lower_complex);\n+  NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_tree_profile);\n@@ -417,6 +417,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_profile);\n   NEXT_PASS (pass_ch);\n   NEXT_PASS (pass_stdarg);\n+  NEXT_PASS (pass_lower_complex);\n   NEXT_PASS (pass_sra);\n   /* FIXME: SRA may generate arbitrary gimple code, exposing new\n      aliased and call-clobbered variables.  As mentioned below,"}, {"sha": "0d2d8b808cc9bbc5f38c4c68bb6561f2488bd4d6", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -192,6 +192,7 @@ extern struct tree_opt_pass pass_may_alias;\n extern struct tree_opt_pass pass_split_crit_edges;\n extern struct tree_opt_pass pass_pre;\n extern struct tree_opt_pass pass_profile;\n+extern struct tree_opt_pass pass_lower_complex_O0;\n extern struct tree_opt_pass pass_lower_complex;\n extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;"}, {"sha": "e2e646fa54f40e63ec348d3682fd37a0f0da7d63", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e41d82f5d776d2d4ddf1a4346e63213da455edad/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e41d82f5d776d2d4ddf1a4346e63213da455edad", "patch": "@@ -2353,6 +2353,14 @@ extern void decl_value_expr_insert (tree, tree);\n #define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n   DECL_CHECK (DECL)->decl.gimple_formal_temp\n \n+/* For function local variables of COMPLEX type, indicates that the\n+   variable is not aliased, and that all modifications to the variable\n+   have been adjusted so that they are killing assignments.  Thus the\n+   variable may now be treated as a GIMPLE register, and use real\n+   instead of virtual ops in SSA form.  */\n+#define DECL_COMPLEX_GIMPLE_REG_P(DECL) \\\n+  DECL_CHECK (DECL)->decl.gimple_reg_flag\n+\n /* Enumerate visibility settings.  */\n #ifndef SYMBOL_VISIBILITY_DEFINED\n #define SYMBOL_VISIBILITY_DEFINED\n@@ -2424,8 +2432,9 @@ struct tree_decl GTY(())\n   unsigned returns_twice_flag : 1;\n   unsigned seen_in_bind_expr : 1;\n   unsigned novops_flag : 1;\n-  unsigned has_value_expr:1;\n-  /* 8 unused bits.  */\n+  unsigned has_value_expr : 1;\n+  unsigned gimple_reg_flag : 1;\n+  /* 7 unused bits.  */\n \n   union tree_decl_u1 {\n     /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is"}]}