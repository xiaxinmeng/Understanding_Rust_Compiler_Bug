{"sha": "fd13313fdb19c5dd5a5229b87fe856bda8a40166", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQxMzMxM2ZkYjE5YzVkZDVhNTIyOWI4N2ZlODU2YmRhOGE0MDE2Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-07T13:32:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-07T13:32:59Z"}, "message": "* cse.c (fold_rtx): Handle unordered comparisons.\n\nFrom-SVN: r38773", "tree": {"sha": "c33cd0ca854fa7416702c0e6062037dbea235f6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c33cd0ca854fa7416702c0e6062037dbea235f6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd13313fdb19c5dd5a5229b87fe856bda8a40166", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd13313fdb19c5dd5a5229b87fe856bda8a40166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd13313fdb19c5dd5a5229b87fe856bda8a40166", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd13313fdb19c5dd5a5229b87fe856bda8a40166/comments", "author": null, "committer": null, "parents": [{"sha": "91b2d1199a36e4799d1a238a6ec52ecb36893661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b2d1199a36e4799d1a238a6ec52ecb36893661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b2d1199a36e4799d1a238a6ec52ecb36893661"}], "stats": {"total": 61, "additions": 38, "deletions": 23}, "files": [{"sha": "8e73d81e1450c9df9a2d917bcb269cda3ca3e0a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd13313fdb19c5dd5a5229b87fe856bda8a40166/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd13313fdb19c5dd5a5229b87fe856bda8a40166/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd13313fdb19c5dd5a5229b87fe856bda8a40166", "patch": "@@ -1,3 +1,7 @@\n+Sun Jan  7 14:31:57 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cse.c (fold_rtx): Handle unordered comparisons.\n+\n Sun Jan  7 13:49:19 MET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* rtlanal.c (set_of_1): New static function."}, {"sha": "d6c2025a0c26c272d5bad3091e04dc5848618743", "filename": "gcc/cse.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd13313fdb19c5dd5a5229b87fe856bda8a40166/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd13313fdb19c5dd5a5229b87fe856bda8a40166/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=fd13313fdb19c5dd5a5229b87fe856bda8a40166", "patch": "@@ -3812,7 +3812,9 @@ fold_rtx (x, insn)\n \t    if (validate_change (insn, &XEXP (x, i), replacements[j], 0))\n \t      break;\n \n-\t    if (code == NE || code == EQ || GET_RTX_CLASS (code) == 'c')\n+\t    if (code == NE || code == EQ || GET_RTX_CLASS (code) == 'c'\n+\t\t|| code == LTGT || code == UNEQ || code == ORDERED\n+\t\t|| code == UNORDERED)\n \t      {\n \t\tvalidate_change (insn, &XEXP (x, i), XEXP (x, 1 - i), 1);\n \t\tvalidate_change (insn, &XEXP (x, 1 - i), replacements[j], 1);\n@@ -3844,7 +3846,9 @@ fold_rtx (x, insn)\n      operand unless the first operand is also a constant integer.  Otherwise,\n      place any constant second unless the first operand is also a constant.  */\n \n-  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c')\n+  if (code == EQ || code == NE || GET_RTX_CLASS (code) == 'c'\n+      || code == LTGT || code == UNEQ || code == ORDERED\n+      || code == UNORDERED)\n     {\n       if (must_swap || (const_arg0\n \t  \t\t&& (const_arg1 == 0\n@@ -3952,27 +3956,34 @@ fold_rtx (x, insn)\n \t\t    return true;\n \t\t}\n \n-\t      /* See if the two operands are the same.  We don't do this\n-\t\t for IEEE floating-point since we can't assume x == x\n-\t\t since x might be a NaN.  */\n-\n-\t      if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t   || ! FLOAT_MODE_P (mode_arg0) || flag_fast_math)\n-\t\t  && (folded_arg0 == folded_arg1\n-\t\t      || (GET_CODE (folded_arg0) == REG\n-\t\t\t  && GET_CODE (folded_arg1) == REG\n-\t\t\t  && (REG_QTY (REGNO (folded_arg0))\n-\t\t\t      == REG_QTY (REGNO (folded_arg1))))\n-\t\t      || ((p0 = lookup (folded_arg0,\n-\t\t\t\t\t(safe_hash (folded_arg0, mode_arg0)\n-\t\t\t\t\t & HASH_MASK), mode_arg0))\n-\t\t\t  && (p1 = lookup (folded_arg1,\n-\t\t\t\t\t   (safe_hash (folded_arg1, mode_arg0)\n-\t\t\t\t\t    & HASH_MASK), mode_arg0))\n-\t\t\t  && p0->first_same_value == p1->first_same_value)))\n-\t\treturn ((code == EQ || code == LE || code == GE\n-\t\t\t || code == LEU || code == GEU)\n-\t\t\t? true : false);\n+\t      /* See if the two operands are the same.  */\n+\n+\t      if (folded_arg0 == folded_arg1\n+\t\t  || (GET_CODE (folded_arg0) == REG\n+\t\t      && GET_CODE (folded_arg1) == REG\n+\t\t      && (REG_QTY (REGNO (folded_arg0))\n+\t\t\t  == REG_QTY (REGNO (folded_arg1))))\n+\t\t  || ((p0 = lookup (folded_arg0,\n+\t\t\t\t    (safe_hash (folded_arg0, mode_arg0)\n+\t\t\t\t     & HASH_MASK), mode_arg0))\n+\t\t      && (p1 = lookup (folded_arg1,\n+\t\t\t\t       (safe_hash (folded_arg1, mode_arg0)\n+\t\t\t\t\t& HASH_MASK), mode_arg0))\n+\t\t      && p0->first_same_value == p1->first_same_value))\n+\t\t{\n+\t\t   /* Sadly two equal NaNs are not equivalent.  */\n+\t\t   if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n+\t\t       || ! FLOAT_MODE_P (mode_arg0) || flag_fast_math)\n+\t\t      return ((code == EQ || code == LE || code == GE\n+\t\t\t       || code == LEU || code == GEU || code == UNEQ\n+\t\t\t       || code == UNLE || code == UNGE || code == ORDERED)\n+\t\t\t      ? true : false);\n+\t\t   /* Take care for the FP compares we can resolve.  */\n+\t\t   if (code == UNEQ || code == UNLE || code == UNGE)\n+\t\t     return true;\n+\t\t   if (code == LTGT || code == LT || code == GT)\n+\t\t     return false;\n+\t\t}\n \n \t      /* If FOLDED_ARG0 is a register, see if the comparison we are\n \t\t doing now is either the same as we did before or the reverse"}]}