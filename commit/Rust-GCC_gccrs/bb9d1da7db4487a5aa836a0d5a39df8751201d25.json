{"sha": "bb9d1da7db4487a5aa836a0d5a39df8751201d25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5ZDFkYTdkYjQ0ODdhNWFhODM2YTBkNWEzOWRmODc1MTIwMWQyNQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2007-07-06T16:47:47Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-07-06T16:47:47Z"}, "message": "convert-dfp-round-thread.c: New test.\n\n2007-07-06  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* gcc.dg/dfp/convert-dfp-round-thread.c: New test.\n\nFrom-SVN: r126421", "tree": {"sha": "f64ff88a89cd21a26c079610876d8e09141aabda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f64ff88a89cd21a26c079610876d8e09141aabda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb9d1da7db4487a5aa836a0d5a39df8751201d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9d1da7db4487a5aa836a0d5a39df8751201d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9d1da7db4487a5aa836a0d5a39df8751201d25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9d1da7db4487a5aa836a0d5a39df8751201d25/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb83237562576ca1561164715c5787c261b9fffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb83237562576ca1561164715c5787c261b9fffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb83237562576ca1561164715c5787c261b9fffe"}], "stats": {"total": 498, "additions": 498, "deletions": 0}, "files": [{"sha": "e5486e9d1778d9abd23b3cdb9d7570980b032336", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9d1da7db4487a5aa836a0d5a39df8751201d25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9d1da7db4487a5aa836a0d5a39df8751201d25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb9d1da7db4487a5aa836a0d5a39df8751201d25", "patch": "@@ -1,3 +1,7 @@\n+2007-07-06  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.dg/dfp/convert-dfp-round-thread.c: New test.\n+\n 2007-07-06  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* gfortran.dg/save_parameter.f90: New test."}, {"sha": "d288ac70c826f64519d6081b8b8f8fce6901bc5b", "filename": "gcc/testsuite/gcc.dg/dfp/convert-dfp-round-thread.c", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9d1da7db4487a5aa836a0d5a39df8751201d25/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-dfp-round-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9d1da7db4487a5aa836a0d5a39df8751201d25/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-dfp-round-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fconvert-dfp-round-thread.c?ref=bb9d1da7db4487a5aa836a0d5a39df8751201d25", "patch": "@@ -0,0 +1,494 @@\n+/* { dg-options \"-std=gnu99 -D_GNU_SOURCE -pthread\" } */\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* } } */\n+\n+/* N1150 5.2: Conversions among decimal floating types and between\n+   decimal floating types and generic floating types.\n+   C99 6.3.1.5(3) New.\n+\n+   Perform conversions between DFP types in which the assigned value\n+   cannot be represented exactly in the result and must be rounded\n+   correctly according to the current rounding mode.\n+\n+   Normally this would not be part of compiler testing, but conversions\n+   are currently handled in libgcc via decNumber.  */\n+\n+#include <pthread.h>\n+#include <error.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <stddef.h>\n+#include \"dfp-round.h\"\n+\n+extern void abort (void);\n+static __thread int failcnt = 0;\n+\n+/* Support compiling the test to report individual failures; default is\n+   to abort as soon as a check fails.  */\n+#ifdef DBG\n+#include <stdio.h>\n+#define FAILURE { printf (\"failed at line %d\\n\", __LINE__); failcnt++; }\n+#else\n+#define FAILURE abort ();\n+#endif\n+\n+pthread_mutex_t mut1 = PTHREAD_MUTEX_INITIALIZER;\n+pthread_mutex_t mut2 = PTHREAD_MUTEX_INITIALIZER;\n+pthread_mutex_t mut3 = PTHREAD_MUTEX_INITIALIZER;\n+pthread_mutex_t mut4 = PTHREAD_MUTEX_INITIALIZER;\n+pthread_mutex_t mut5 = PTHREAD_MUTEX_INITIALIZER;\n+pthread_cond_t cond1 = PTHREAD_COND_INITIALIZER;\n+pthread_cond_t cond2 = PTHREAD_COND_INITIALIZER;\n+pthread_cond_t cond3 = PTHREAD_COND_INITIALIZER;\n+pthread_cond_t cond4 = PTHREAD_COND_INITIALIZER;\n+pthread_cond_t cond5 = PTHREAD_COND_INITIALIZER;\n+pthread_barrier_t bar1;\n+pthread_barrier_t bar2;\n+pthread_barrier_t bar3;\n+pthread_barrier_t bar4;\n+pthread_barrier_t bar5;\n+\n+__thread _Decimal32 d32;\n+__thread _Decimal64 d64;\n+__thread _Decimal128 d128;\n+\n+_Decimal32 d64_to_d32 (_Decimal64 d) { return d; }\n+_Decimal64 d128_to_d64 (_Decimal128 d) { return d; }\n+_Decimal32 d128_to_d32 (_Decimal128 d) { return d; }\n+\n+int\n+do_d64_to_d32 (_Decimal64 orig, _Decimal32 exp)\n+{\n+  d64 = orig;\n+  d32 = d64_to_d32 (d64);\n+  return (d32 == exp);\n+}\n+\n+int\n+do_d128_to_d32 (_Decimal128 orig, _Decimal32 exp)\n+{\n+  d128 = orig;\n+  d32 = d128_to_d32 (d128);\n+  return (d32 == exp);\n+}\n+\n+int\n+do_d128_to_d64 (_Decimal128 orig, _Decimal64 exp)\n+{\n+  d128 = orig;\n+  d64 = d128_to_d64 (d128);\n+  return (d64 == exp);\n+}\n+\n+void *\n+downward (void *arg)\n+{\n+  int err;\n+\n+  DFP_SETROUND (FE_DEC_DOWNWARD);\n+\n+  err = pthread_mutex_lock (&mut1);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"downward: failed to lock\");\n+\n+  err = pthread_barrier_wait (&bar1);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"downward: barrier_wait failed\");\n+      exit (1);\n+    } \n+\n+  err = pthread_cond_wait (&cond1, &mut1);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"downward: failed to wait\");\n+\n+  err = pthread_mutex_unlock (&mut1);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"downward: failed to unlock\");\n+\n+  if (!do_d64_to_d32 (1.1111125dd, 1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (1.1111135dd, 1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111125dd, -1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111135dd, -1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111125dl, 1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111135dl, 1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111125dl, -1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111135dl, -1.111114df)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111125dl, 1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111135dl, 1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111125dl, -1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111135dl, -1.111111111111114dd)) FAILURE\n+  \n+#ifdef DBG\n+  if (failcnt)\n+    printf (\"downward: %d fails\\n\", failcnt);\n+#endif\n+  return (void *) (ptrdiff_t) failcnt;\n+}\n+\n+void *\n+tonearest (void *arg)\n+{\n+  int err;\n+  DFP_SETROUND (FE_DEC_TONEAREST);\n+\n+  err = pthread_mutex_lock (&mut2);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"tonearest: failed to lock\");\n+\n+  err = pthread_barrier_wait (&bar2);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"tonearest: barrier_wait failed\");\n+      exit (1);\n+    } \n+\n+  err = pthread_cond_wait (&cond2, &mut2);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"tonearest: failed to wait\");\n+\n+  err = pthread_mutex_unlock (&mut2);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"tonearest: failed to unlock\");\n+\n+  if (!do_d64_to_d32 (1.1111125dd, 1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (1.1111135dd, 1.111114df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111125dd, -1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111135dd, -1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111125dl, 1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111135dl, 1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111125dl, -1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111135dl, -1.111114df)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111125dl, 1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111135dl, 1.111111111111114dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111125dl, -1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111135dl, -1.111111111111114dd)) FAILURE\n+  \n+#ifdef DBG\n+  if (failcnt)\n+    printf (\"tonearest: %d fails\\n\", failcnt);\n+#endif\n+  return (void *) (ptrdiff_t) failcnt;\n+} \n+\n+void *\n+toneareastfromzero (void *arg)\n+{\n+  int err;\n+  DFP_SETROUND (FE_DEC_TONEARESTFROMZERO);\n+\n+  err = pthread_mutex_lock (&mut3);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"toneareastfromzero: failed to lock\");\n+\n+  err = pthread_barrier_wait (&bar3);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"toneareastfromzero: barrier_wait failed\");\n+      exit (1);\n+    } \n+\n+  err = pthread_cond_wait (&cond3, &mut3);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"toneareastfromzero: failed to wait\");\n+\n+  err = pthread_mutex_unlock (&mut3);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"toneareastfromzero: failed to unlock\");\n+\n+  if (!do_d64_to_d32 (1.1111125dd, 1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (1.1111135dd, 1.111114df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111125dd, -1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111135dd, -1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111125dl, 1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111135dl, 1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111125dl, -1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111135dl, -1.111114df)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111125dl, 1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111135dl, 1.111111111111114dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111125dl, -1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111135dl, -1.111111111111114dd)) FAILURE\n+  \n+#ifdef DBG\n+  if (failcnt)\n+    printf (\"toneareastfromzero: %d fails\\n\", failcnt);\n+#endif\n+  return (void *) (ptrdiff_t) failcnt;\n+} \n+  \n+void *\n+towardzero (void *arg)\n+{\n+  int err;\n+  DFP_SETROUND (FE_DEC_TOWARDZERO);\n+\n+  err = pthread_mutex_lock (&mut4);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"towardzero: failed to lock\");\n+\n+  err = pthread_barrier_wait (&bar4);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"towardzero: barrier_wait failed\");\n+      exit (1);\n+    } \n+\n+  err = pthread_cond_wait (&cond4, &mut4);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"towardzero: failed to wait\");\n+\n+  err = pthread_mutex_unlock (&mut4);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"towardzero: failed to unlock\");\n+\n+  if (!do_d64_to_d32 (1.1111125dd, 1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (1.1111135dd, 1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111125dd, -1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111135dd, -1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111125dl, 1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111135dl, 1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111125dl, -1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111135dl, -1.111113df)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111125dl, 1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111135dl, 1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111125dl, -1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111135dl, -1.111111111111113dd)) FAILURE\n+\n+#ifdef DBG\n+  if (failcnt)\n+    printf (\"towardzero: %d fails\\n\", failcnt);\n+#endif\n+  return (void *) (ptrdiff_t) failcnt;\n+} \n+\n+void *\n+upward (void *arg)\n+{\n+  int err;\n+  DFP_SETROUND (FE_DEC_UPWARD);\n+\n+  err = pthread_mutex_lock (&mut5);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"upward: failed to lock\");\n+\n+  err = pthread_barrier_wait (&bar5);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"upward: barrier_wait failed\");\n+      exit (1);\n+    } \n+\n+  err = pthread_cond_wait (&cond5, &mut5);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"upward: failed to wait\");\n+\n+  err = pthread_mutex_unlock (&mut5);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"upward: failed to unlock\");\n+\n+  if (!do_d64_to_d32 (1.1111125dd, 1.111113df)) FAILURE\n+  if (!do_d64_to_d32 (1.1111135dd, 1.111114df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111125dd, -1.111112df)) FAILURE\n+  if (!do_d64_to_d32 (-1.1111135dd, -1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111125dl, 1.111113df)) FAILURE\n+  if (!do_d128_to_d32 (1.1111135dl, 1.111114df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111125dl, -1.111112df)) FAILURE\n+  if (!do_d128_to_d32 (-1.1111135dl, -1.111113df)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111125dl, 1.111111111111113dd)) FAILURE\n+  if (!do_d128_to_d64 (1.1111111111111135dl, 1.111111111111114dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111125dl, -1.111111111111112dd)) FAILURE\n+  if (!do_d128_to_d64 (-1.1111111111111135dl, -1.111111111111113dd)) FAILURE\n+  \n+#ifdef DBG\n+  if (failcnt)\n+    printf (\"upward: %d fails\\n\", failcnt);\n+#endif\n+  return (void *) (ptrdiff_t) failcnt;\n+}\n+\n+int\n+main (void)\n+{\n+  int err;\n+  int count = 0;\n+  void *ret;\n+  pthread_t down, up, tozero, fromzero, nearest;\n+\n+  if (pthread_barrier_init (&bar1, NULL, 2) != 0\n+      || pthread_barrier_init (&bar2, NULL, 2) != 0\n+      || pthread_barrier_init (&bar3, NULL, 2) != 0\n+      || pthread_barrier_init (&bar4, NULL, 2) != 0\n+      || pthread_barrier_init (&bar5, NULL, 2) != 0)\n+    {\n+      puts (\"parent: failed to init barrier\");\n+      return 1;\n+    }\n+\n+  if (pthread_create (&down, NULL, downward, NULL) != 0)\n+    {\n+      puts (\"parent: failed to create\");\n+      return 1;\n+    }\n+\n+  if (pthread_create (&nearest, NULL, tonearest, NULL) != 0)\n+    {\n+      puts (\"create failed\");\n+      return 1;\n+    }\n+\n+  if (pthread_create (&fromzero, NULL, toneareastfromzero, NULL) != 0)\n+    {\n+      puts (\"create failed\");\n+      return 1;\n+    }\n+\n+  if (pthread_create (&up, NULL, upward, NULL) != 0)\n+    {\n+      puts (\"create failed\");\n+      return 1;\n+    }\n+\n+  if (pthread_create (&tozero, NULL, towardzero, NULL) != 0)\n+    {\n+      puts (\"create failed\");\n+      return 1;\n+    }\n+\n+  err = pthread_barrier_wait (&bar1);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"parent: failed to wait barrier 1\");\n+      return 1;\n+    }\n+  err = pthread_barrier_wait (&bar2);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"parent: failed to wait barrier 2\");\n+      return 1;\n+    }\n+  err = pthread_barrier_wait (&bar3);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"parent: failed to wait barrier 3\");\n+      return 1;\n+    }\n+  err = pthread_barrier_wait (&bar4);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"parent: failed to wait barrier 4\");\n+      return 1;\n+    }\n+  err = pthread_barrier_wait (&bar5);\n+  if (err != 0 && err != PTHREAD_BARRIER_SERIAL_THREAD)\n+    {\n+      puts (\"parent: failed to wait barrier 5\");\n+      return 1;\n+    }\n+\n+  err = pthread_mutex_lock (&mut1);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: lock failed\");\n+  err = pthread_mutex_lock (&mut2);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: lock failed\");\n+  err = pthread_mutex_lock (&mut3);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: lock failed\");\n+  err = pthread_mutex_lock (&mut4);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: lock failed\");\n+  err = pthread_mutex_lock (&mut5);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: lock failed\");\n+\n+  err = pthread_cond_signal(&cond1);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: broadcast failed\");\n+  err = pthread_cond_signal(&cond2);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: broadcast failed\");\n+  err = pthread_cond_signal(&cond3);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: broadcast failed\");\n+  err = pthread_cond_signal(&cond4);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: broadcast failed\");\n+  err = pthread_cond_signal(&cond5);\n+  if (err != 0)\n+    error (EXIT_FAILURE, err, \"parent: broadcast failed\");\n+\n+  err = pthread_mutex_unlock (&mut1);\n+  if (err != 0)\n+    {\n+      puts (\"parent: failed to unlock\");\n+      return 1;\n+    }\n+  err = pthread_mutex_unlock (&mut2);\n+  if (err != 0)\n+    {\n+      puts (\"parent: failed to unlock\");\n+      return 1;\n+    }\n+  err = pthread_mutex_unlock (&mut3);\n+  if (err != 0)\n+    {\n+      puts (\"parent: failed to unlock\");\n+      return 1;\n+    }\n+  err = pthread_mutex_unlock (&mut4);\n+  if (err != 0)\n+    {\n+      puts (\"parent: failed to unlock\");\n+      return 1;\n+    }\n+  err = pthread_mutex_unlock (&mut5);\n+  if (err != 0)\n+    {\n+      puts (\"parent: failed to unlock\");\n+      return 1;\n+    }\n+\n+  if (pthread_join (down, &ret) != 0)\n+    {\n+      puts (\"pthread_join failed\");\n+      return 1;\n+    }\n+  count += (int) (ptrdiff_t) ret;\n+\n+  if (pthread_join (up, &ret) != 0)\n+    {\n+      puts (\"pthread_join failed\");\n+      return 1;\n+    }\n+  count += (int) (ptrdiff_t) ret;\n+\n+  if (pthread_join (tozero, &ret) != 0)\n+    {\n+      puts (\"pthread_join failed\");\n+      return 1;\n+    }\n+  count += (int) (ptrdiff_t) ret;\n+\n+  if (pthread_join (fromzero, &ret) != 0)\n+    {\n+      puts (\"pthread_join failed\");\n+      return 1;\n+    }\n+  count += (int) (ptrdiff_t) ret;\n+\n+  if (pthread_join (nearest, &ret) != 0)\n+    {\n+      puts (\"pthread_join failed\");\n+      return 1;\n+    }\n+  count += (int) (ptrdiff_t) ret;\n+\n+  if (count)\n+    {\n+#ifdef DBG\n+      printf (\"Total: %d fails\\n\", count);\n+#endif\n+      abort ();\n+    }\n+\n+  return 0;\n+}"}]}