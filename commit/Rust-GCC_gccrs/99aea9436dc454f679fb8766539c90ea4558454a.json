{"sha": "99aea9436dc454f679fb8766539c90ea4558454a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlhZWE5NDM2ZGM0NTRmNjc5ZmI4NzY2NTM5YzkwZWE0NTU4NDU0YQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2012-05-18T09:10:36Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2012-05-18T09:10:36Z"}, "message": "arm-protos.h (arm_emit_coreregs_64bit_shift): New prototype.\n\n2012-05-18  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm-protos.h (arm_emit_coreregs_64bit_shift): New\n\tprototype.\n\t* config/arm/arm.c (arm_emit_coreregs_64bit_shift): New function.\n\t* config/arm/arm.md (ashldi3): Use arm_emit_coreregs_64bit_shift.\n\t(ashrdi3,lshrdi3): Likewise.\n\t(arm_cond_branch): Remove '*' to enable gen_arm_cond_branch.\n\nFrom-SVN: r187649", "tree": {"sha": "3c1d6411be8aca3514eb0c6e55d1beddb6ca4efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c1d6411be8aca3514eb0c6e55d1beddb6ca4efc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99aea9436dc454f679fb8766539c90ea4558454a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99aea9436dc454f679fb8766539c90ea4558454a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99aea9436dc454f679fb8766539c90ea4558454a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99aea9436dc454f679fb8766539c90ea4558454a/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7cb6668a1f251a35f26875398992eb4b1ae78f30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cb6668a1f251a35f26875398992eb4b1ae78f30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cb6668a1f251a35f26875398992eb4b1ae78f30"}], "stats": {"total": 368, "additions": 340, "deletions": 28}, "files": [{"sha": "dd9f3f5bf86f20eb5ab095a61a1cb698c1974c52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99aea9436dc454f679fb8766539c90ea4558454a", "patch": "@@ -1,3 +1,12 @@\n+2012-05-18  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/arm/arm-protos.h (arm_emit_coreregs_64bit_shift): New\n+\tprototype.\n+\t* config/arm/arm.c (arm_emit_coreregs_64bit_shift): New function.\n+\t* config/arm/arm.md (ashldi3): Use arm_emit_coreregs_64bit_shift.\n+\t(ashrdi3,lshrdi3): Likewise.\n+\t(arm_cond_branch): Remove '*' to enable gen_arm_cond_branch.\n+\n 2012-05-18  Meador Inge  <meadori@codesourcery.com>\n \n \tPR rtl-optimization/53352"}, {"sha": "b3384701f0b19a9386b7d2e6941b7872bd071cb0", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=99aea9436dc454f679fb8766539c90ea4558454a", "patch": "@@ -245,6 +245,9 @@ struct tune_params\n \n extern const struct tune_params *current_tune;\n extern int vfp3_const_double_for_fract_bits (rtx);\n+\n+extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n+\t\t\t\t\t   rtx);\n #endif /* RTX_CODE */\n \n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);"}, {"sha": "3ad4c752ac8a2b8de4b416c8f57cf290b441d340", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=99aea9436dc454f679fb8766539c90ea4558454a", "patch": "@@ -25933,4 +25933,256 @@ arm_autoinc_modes_ok_p (enum machine_mode mode, enum arm_auto_incmodes code)\n   return false;\n }\n \n+/* The default expansion of general 64-bit shifts in core-regs is suboptimal,\n+   on ARM, since we know that shifts by negative amounts are no-ops.\n+   Additionally, the default expansion code is not available or suitable\n+   for post-reload insn splits (this can occur when the register allocator\n+   chooses not to do a shift in NEON).\n+   \n+   This function is used in both initial expand and post-reload splits, and\n+   handles all kinds of 64-bit shifts.\n+\n+   Input requirements:\n+    - It is safe for the input and output to be the same register, but\n+      early-clobber rules apply for the shift amount and scratch registers.\n+    - Shift by register requires both scratch registers.  Shift by a constant\n+      less than 32 in Thumb2 mode requires SCRATCH1 only.  In all other cases\n+      the scratch registers may be NULL.\n+    - Ashiftrt by a register also clobbers the CC register.  */\n+void\n+arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n+\t\t\t       rtx amount, rtx scratch1, rtx scratch2)\n+{\n+  rtx out_high = gen_highpart (SImode, out);\n+  rtx out_low = gen_lowpart (SImode, out);\n+  rtx in_high = gen_highpart (SImode, in);\n+  rtx in_low = gen_lowpart (SImode, in);\n+\n+  /* Terminology:\n+\tin = the register pair containing the input value.\n+\tout = the destination register pair.\n+\tup = the high- or low-part of each pair.\n+\tdown = the opposite part to \"up\".\n+     In a shift, we can consider bits to shift from \"up\"-stream to\n+     \"down\"-stream, so in a left-shift \"up\" is the low-part and \"down\"\n+     is the high-part of each register pair.  */\n+\n+  rtx out_up   = code == ASHIFT ? out_low : out_high;\n+  rtx out_down = code == ASHIFT ? out_high : out_low;\n+  rtx in_up   = code == ASHIFT ? in_low : in_high;\n+  rtx in_down = code == ASHIFT ? in_high : in_low;\n+\n+  gcc_assert (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n+  gcc_assert (out\n+\t      && (REG_P (out) || GET_CODE (out) == SUBREG)\n+\t      && GET_MODE (out) == DImode);\n+  gcc_assert (in\n+\t      && (REG_P (in) || GET_CODE (in) == SUBREG)\n+\t      && GET_MODE (in) == DImode);\n+  gcc_assert (amount\n+\t      && (((REG_P (amount) || GET_CODE (amount) == SUBREG)\n+\t\t   && GET_MODE (amount) == SImode)\n+\t\t  || CONST_INT_P (amount)));\n+  gcc_assert (scratch1 == NULL\n+\t      || (GET_CODE (scratch1) == SCRATCH)\n+\t      || (GET_MODE (scratch1) == SImode\n+\t\t  && REG_P (scratch1)));\n+  gcc_assert (scratch2 == NULL\n+\t      || (GET_CODE (scratch2) == SCRATCH)\n+\t      || (GET_MODE (scratch2) == SImode\n+\t\t  && REG_P (scratch2)));\n+  gcc_assert (!REG_P (out) || !REG_P (amount)\n+\t      || !HARD_REGISTER_P (out)\n+\t      || (REGNO (out) != REGNO (amount)\n+\t\t  && REGNO (out) + 1 != REGNO (amount)));\n+\n+  /* Macros to make following code more readable.  */\n+  #define SUB_32(DEST,SRC) \\\n+\t    gen_addsi3 ((DEST), (SRC), gen_rtx_CONST_INT (VOIDmode, -32))\n+  #define RSB_32(DEST,SRC) \\\n+\t    gen_subsi3 ((DEST), gen_rtx_CONST_INT (VOIDmode, 32), (SRC))\n+  #define SUB_S_32(DEST,SRC) \\\n+\t    gen_addsi3_compare0 ((DEST), (SRC), \\\n+\t\t\t\t gen_rtx_CONST_INT (VOIDmode, -32))\n+  #define SET(DEST,SRC) \\\n+\t    gen_rtx_SET (SImode, (DEST), (SRC))\n+  #define SHIFT(CODE,SRC,AMOUNT) \\\n+\t    gen_rtx_fmt_ee ((CODE), SImode, (SRC), (AMOUNT))\n+  #define LSHIFT(CODE,SRC,AMOUNT) \\\n+\t    gen_rtx_fmt_ee ((CODE) == ASHIFT ? ASHIFT : LSHIFTRT, \\\n+\t\t\t    SImode, (SRC), (AMOUNT))\n+  #define REV_LSHIFT(CODE,SRC,AMOUNT) \\\n+\t    gen_rtx_fmt_ee ((CODE) == ASHIFT ? LSHIFTRT : ASHIFT, \\\n+\t\t\t    SImode, (SRC), (AMOUNT))\n+  #define ORR(A,B) \\\n+\t    gen_rtx_IOR (SImode, (A), (B))\n+  #define BRANCH(COND,LABEL) \\\n+\t    gen_arm_cond_branch ((LABEL), \\\n+\t\t\t\t gen_rtx_ ## COND (CCmode, cc_reg, \\\n+\t\t\t\t\t\t   const0_rtx), \\\n+\t\t\t\t cc_reg)\n+\n+  /* Shifts by register and shifts by constant are handled separately.  */\n+  if (CONST_INT_P (amount))\n+    {\n+      /* We have a shift-by-constant.  */\n+\n+      /* First, handle out-of-range shift amounts.\n+\t In both cases we try to match the result an ARM instruction in a\n+\t shift-by-register would give.  This helps reduce execution\n+\t differences between optimization levels, but it won't stop other\n+         parts of the compiler doing different things.  This is \"undefined\n+         behaviour, in any case.  */\n+      if (INTVAL (amount) <= 0)\n+\temit_insn (gen_movdi (out, in));\n+      else if (INTVAL (amount) >= 64)\n+\t{\n+\t  if (code == ASHIFTRT)\n+\t    {\n+\t      rtx const31_rtx = gen_rtx_CONST_INT (VOIDmode, 31);\n+\t      emit_insn (SET (out_down, SHIFT (code, in_up, const31_rtx)));\n+\t      emit_insn (SET (out_up, SHIFT (code, in_up, const31_rtx)));\n+\t    }\n+\t  else\n+\t    emit_insn (gen_movdi (out, const0_rtx));\n+\t}\n+\n+      /* Now handle valid shifts. */\n+      else if (INTVAL (amount) < 32)\n+\t{\n+\t  /* Shifts by a constant less than 32.  */\n+\t  rtx reverse_amount = gen_rtx_CONST_INT (VOIDmode,\n+\t\t\t\t\t\t  32 - INTVAL (amount));\n+\n+\t  emit_insn (SET (out_down, LSHIFT (code, in_down, amount)));\n+\t  emit_insn (SET (out_down,\n+\t\t\t  ORR (REV_LSHIFT (code, in_up, reverse_amount),\n+\t\t\t       out_down)));\n+\t  emit_insn (SET (out_up, SHIFT (code, in_up, amount)));\n+\t}\n+      else\n+\t{\n+\t  /* Shifts by a constant greater than 31.  */\n+\t  rtx adj_amount = gen_rtx_CONST_INT (VOIDmode, INTVAL (amount) - 32);\n+\n+\t  emit_insn (SET (out_down, SHIFT (code, in_up, adj_amount)));\n+\t  if (code == ASHIFTRT)\n+\t    emit_insn (gen_ashrsi3 (out_up, in_up,\n+\t\t\t\t    gen_rtx_CONST_INT (VOIDmode, 31)));\n+\t  else\n+\t    emit_insn (SET (out_up, const0_rtx));\n+\t}\n+    }\n+  else\n+    {\n+      /* We have a shift-by-register.  */\n+      rtx cc_reg = gen_rtx_REG (CC_NOOVmode, CC_REGNUM);\n+\n+      /* This alternative requires the scratch registers.  */\n+      gcc_assert (scratch1 && REG_P (scratch1));\n+      gcc_assert (scratch2 && REG_P (scratch2));\n+\n+      /* We will need the values \"amount-32\" and \"32-amount\" later.\n+         Swapping them around now allows the later code to be more general. */\n+      switch (code)\n+\t{\n+\tcase ASHIFT:\n+\t  emit_insn (SUB_32 (scratch1, amount));\n+\t  emit_insn (RSB_32 (scratch2, amount));\n+\t  break;\n+\tcase ASHIFTRT:\n+\t  emit_insn (RSB_32 (scratch1, amount));\n+\t  /* Also set CC = amount > 32.  */\n+\t  emit_insn (SUB_S_32 (scratch2, amount));\n+\t  break;\n+\tcase LSHIFTRT:\n+\t  emit_insn (RSB_32 (scratch1, amount));\n+\t  emit_insn (SUB_32 (scratch2, amount));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      /* Emit code like this:\n+\n+\t arithmetic-left:\n+\t    out_down = in_down << amount;\n+\t    out_down = (in_up << (amount - 32)) | out_down;\n+\t    out_down = ((unsigned)in_up >> (32 - amount)) | out_down;\n+\t    out_up = in_up << amount;\n+\n+\t arithmetic-right:\n+\t    out_down = in_down >> amount;\n+\t    out_down = (in_up << (32 - amount)) | out_down;\n+\t    if (amount < 32)\n+\t      out_down = ((signed)in_up >> (amount - 32)) | out_down;\n+\t    out_up = in_up << amount;\n+\n+\t logical-right:\n+\t    out_down = in_down >> amount;\n+\t    out_down = (in_up << (32 - amount)) | out_down;\n+\t    if (amount < 32)\n+\t      out_down = ((unsigned)in_up >> (amount - 32)) | out_down;\n+\t    out_up = in_up << amount;\n+\n+\t  The ARM and Thumb2 variants are the same but implemented slightly\n+\t  differently.  If this were only called during expand we could just\n+\t  use the Thumb2 case and let combine do the right thing, but this\n+\t  can also be called from post-reload splitters.  */\n+\n+      emit_insn (SET (out_down, LSHIFT (code, in_down, amount)));\n+\n+      if (!TARGET_THUMB2)\n+\t{\n+\t  /* Emit code for ARM mode.  */\n+\t  emit_insn (SET (out_down,\n+\t\t\t  ORR (SHIFT (ASHIFT, in_up, scratch1), out_down)));\n+\t  if (code == ASHIFTRT)\n+\t    {\n+\t      rtx done_label = gen_label_rtx ();\n+\t      emit_jump_insn (BRANCH (LT, done_label));\n+\t      emit_insn (SET (out_down, ORR (SHIFT (ASHIFTRT, in_up, scratch2),\n+\t\t\t\t\t     out_down)));\n+\t      emit_label (done_label);\n+\t    }\n+\t  else\n+\t    emit_insn (SET (out_down, ORR (SHIFT (LSHIFTRT, in_up, scratch2),\n+\t\t\t\t\t   out_down)));\n+\t}\n+      else\n+\t{\n+\t  /* Emit code for Thumb2 mode.\n+\t     Thumb2 can't do shift and or in one insn.  */\n+\t  emit_insn (SET (scratch1, SHIFT (ASHIFT, in_up, scratch1)));\n+\t  emit_insn (gen_iorsi3 (out_down, out_down, scratch1));\n+\n+\t  if (code == ASHIFTRT)\n+\t    {\n+\t      rtx done_label = gen_label_rtx ();\n+\t      emit_jump_insn (BRANCH (LT, done_label));\n+\t      emit_insn (SET (scratch2, SHIFT (ASHIFTRT, in_up, scratch2)));\n+\t      emit_insn (SET (out_down, ORR (out_down, scratch2)));\n+\t      emit_label (done_label);\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (SET (scratch2, SHIFT (LSHIFTRT, in_up, scratch2)));\n+\t      emit_insn (gen_iorsi3 (out_down, out_down, scratch2));\n+\t    }\n+\t}\n+\n+      emit_insn (SET (out_up, SHIFT (code, in_up, amount)));\n+    }\n+\n+  #undef SUB_32\n+  #undef RSB_32\n+  #undef SUB_S_32\n+  #undef SET\n+  #undef SHIFT\n+  #undef LSHIFT\n+  #undef REV_LSHIFT\n+  #undef ORR\n+  #undef BRANCH\n+}\n+\n #include \"gt-arm.h\""}, {"sha": "bc97a4a3f783640cc5edbe20295921ffd581949d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 76, "deletions": 28, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99aea9436dc454f679fb8766539c90ea4558454a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=99aea9436dc454f679fb8766539c90ea4558454a", "patch": "@@ -3520,21 +3520,37 @@\n                    (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (!CONST_INT_P (operands[2])\n+      && (TARGET_REALLY_IWMMXT || (TARGET_HARD_FLOAT && TARGET_MAVERICK)))\n+    ; /* No special preparation statements; expand pattern as above.  */\n+  else\n     {\n-      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+      rtx scratch1, scratch2;\n+\n+      if (CONST_INT_P (operands[2])\n+\t  && (HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n         {\n           emit_insn (gen_arm_ashldi3_1bit (operands[0], operands[1]));\n           DONE;\n         }\n-        /* Ideally we shouldn't fail here if we could know that operands[1] \n-           ends up already living in an iwmmxt register. Otherwise it's\n-           cheaper to have the alternate code being generated than moving\n-           values to iwmmxt regs and back.  */\n-        FAIL;\n+\n+      /* Ideally we should use iwmmxt here if we could know that operands[1]\n+         ends up already living in an iwmmxt register. Otherwise it's\n+         cheaper to have the alternate code being generated than moving\n+         values to iwmmxt regs and back.  */\n+\n+      /* If we're optimizing for size, we prefer the libgcc calls.  */\n+      if (optimize_function_for_size_p (cfun))\n+\tFAIL;\n+\n+      /* Expand operation using core-registers.\n+\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n+      scratch1 = gen_reg_rtx (SImode);\n+      scratch2 = gen_reg_rtx (SImode);\n+      arm_emit_coreregs_64bit_shift (ASHIFT, operands[0], operands[1],\n+\t\t\t\t     operands[2], scratch1, scratch2);\n+      DONE;\n     }\n-  else if (!TARGET_REALLY_IWMMXT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK))\n-    FAIL;\n   \"\n )\n \n@@ -3579,21 +3595,37 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (!CONST_INT_P (operands[2])\n+      && (TARGET_REALLY_IWMMXT || (TARGET_HARD_FLOAT && TARGET_MAVERICK)))\n+    ; /* No special preparation statements; expand pattern as above.  */\n+  else\n     {\n-      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+      rtx scratch1, scratch2;\n+\n+      if (CONST_INT_P (operands[2])\n+\t  && (HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n         {\n           emit_insn (gen_arm_ashrdi3_1bit (operands[0], operands[1]));\n           DONE;\n         }\n-        /* Ideally we shouldn't fail here if we could know that operands[1] \n-           ends up already living in an iwmmxt register. Otherwise it's\n-           cheaper to have the alternate code being generated than moving\n-           values to iwmmxt regs and back.  */\n-        FAIL;\n+\n+      /* Ideally we should use iwmmxt here if we could know that operands[1]\n+         ends up already living in an iwmmxt register. Otherwise it's\n+         cheaper to have the alternate code being generated than moving\n+         values to iwmmxt regs and back.  */\n+\n+      /* If we're optimizing for size, we prefer the libgcc calls.  */\n+      if (optimize_function_for_size_p (cfun))\n+\tFAIL;\n+\n+      /* Expand operation using core-registers.\n+\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n+      scratch1 = gen_reg_rtx (SImode);\n+      scratch2 = gen_reg_rtx (SImode);\n+      arm_emit_coreregs_64bit_shift (ASHIFTRT, operands[0], operands[1],\n+\t\t\t\t     operands[2], scratch1, scratch2);\n+      DONE;\n     }\n-  else if (!TARGET_REALLY_IWMMXT)\n-    FAIL;\n   \"\n )\n \n@@ -3636,21 +3668,37 @@\n                      (match_operand:SI 2 \"reg_or_int_operand\" \"\")))]\n   \"TARGET_32BIT\"\n   \"\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (!CONST_INT_P (operands[2])\n+      && (TARGET_REALLY_IWMMXT || (TARGET_HARD_FLOAT && TARGET_MAVERICK)))\n+    ; /* No special preparation statements; expand pattern as above.  */\n+  else\n     {\n-      if ((HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n+      rtx scratch1, scratch2;\n+\n+      if (CONST_INT_P (operands[2])\n+\t  && (HOST_WIDE_INT) INTVAL (operands[2]) == 1)\n         {\n           emit_insn (gen_arm_lshrdi3_1bit (operands[0], operands[1]));\n           DONE;\n         }\n-        /* Ideally we shouldn't fail here if we could know that operands[1] \n-           ends up already living in an iwmmxt register. Otherwise it's\n-           cheaper to have the alternate code being generated than moving\n-           values to iwmmxt regs and back.  */\n-        FAIL;\n+\n+      /* Ideally we should use iwmmxt here if we could know that operands[1]\n+         ends up already living in an iwmmxt register. Otherwise it's\n+         cheaper to have the alternate code being generated than moving\n+         values to iwmmxt regs and back.  */\n+\n+      /* If we're optimizing for size, we prefer the libgcc calls.  */\n+      if (optimize_function_for_size_p (cfun))\n+\tFAIL;\n+\n+      /* Expand operation using core-registers.\n+\t 'FAIL' would achieve the same thing, but this is a bit smarter.  */\n+      scratch1 = gen_reg_rtx (SImode);\n+      scratch2 = gen_reg_rtx (SImode);\n+      arm_emit_coreregs_64bit_shift (LSHIFTRT, operands[0], operands[1],\n+\t\t\t\t     operands[2], scratch1, scratch2);\n+      DONE;\n     }\n-  else if (!TARGET_REALLY_IWMMXT)\n-    FAIL;\n   \"\n )\n \n@@ -7755,7 +7803,7 @@\n ;; Patterns to match conditional branch insns.\n ;;\n \n-(define_insn \"*arm_cond_branch\"\n+(define_insn \"arm_cond_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 1 \"arm_comparison_operator\"\n \t\t       [(match_operand 2 \"cc_register\" \"\") (const_int 0)])"}]}