{"sha": "243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "node_id": "C_kwDOANBUbNoAKDI0M2I1Mzk2MTA2YzRiMWViODEzZmQwNmMyYmM2ZjBhMzAwOWJhZTg", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-27T16:40:23Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-28T12:43:01Z"}, "message": "Remove legacy EVRP code.\n\nWith DOM converted to ranger, there are no longer any uses of the EVRP\nengine.  For that matter, we haven't used the legacy mode in quite a\nwhile, so I think it's safe to remove any associated code.\n\nThere are some methods in vr_values which should now be private, but I\ndidn't bother changing them, as most of the vr_values class will be\nremoved when VRP1 is converted to ranger.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* Makefile.in: Remove gimple-ssa-evrp.o and gimple-ssa-evrp-analyze.o.\n\t* flag-types.h (enum evrp_mode): Remove.\n\t* params.opt: Remove --param=evrp-mode.\n\t* tree-vrp.cc (make_pass_early_vrp): New.\n\t(pass_vrp::execute): Call early VRP instance.\n\t* gimple-ssa-evrp-analyze.cc: Removed.\n\t* gimple-ssa-evrp-analyze.h: Removed.\n\t* gimple-ssa-evrp.cc: Removed.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/pr100774.C: Remove --param=evrp-mode.\n\t* gcc.dg/pr100781.c: Same.", "tree": {"sha": "36c41b120684b77a49dfff0eb7a0094f53a0b07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36c41b120684b77a49dfff0eb7a0094f53a0b07e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabd44a02529f7921a4997240aaaefb15f1ef81f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eabd44a02529f7921a4997240aaaefb15f1ef81f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eabd44a02529f7921a4997240aaaefb15f1ef81f"}], "stats": {"total": 977, "additions": 31, "deletions": 946}, "files": [{"sha": "a82909dafe5a7f04076290e87e174f9a4cc5770f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -1417,8 +1417,6 @@ OBJS = \\\n \tgimple-range-infer.o \\\n \tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n-\tgimple-ssa-evrp.o \\\n-\tgimple-ssa-evrp-analyze.o \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-nonnull-compare.o \\\n \tgimple-ssa-split-paths.o \\"}, {"sha": "a11f99af88749db189ff06f70e24072433272e4b", "filename": "gcc/flag-types.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -479,15 +479,6 @@ enum threader_debug\n   THREADER_DEBUG_ALL = 1\n };\n \n-/* EVRP mode.  */\n-enum evrp_mode\n-{\n-  EVRP_MODE_RVRP_ONLY,\n-  EVRP_MODE_EVRP_ONLY,\n-  EVRP_MODE_EVRP_FIRST,\n-  EVRP_MODE_RVRP_FIRST\n-};\n-\n /* VRP modes.  */\n enum vrp_mode\n {"}, {"sha": "82142db7976c453ab53d860eb9c780fab2898780", "filename": "gcc/gimple-ssa-evrp-analyze.cc", "status": "removed", "additions": 0, "deletions": 456, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp-analyze.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp-analyze.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.cc?ref=eabd44a02529f7921a4997240aaaefb15f1ef81f", "patch": "@@ -1,456 +0,0 @@\n-/* Support routines for Value Range Propagation (VRP).\n-   Copyright (C) 2005-2022 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"tree-pass.h\"\n-#include \"ssa.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"cfganal.h\"\n-#include \"gimple-iterator.h\"\n-#include \"gimple-fold.h\"\n-#include \"tree-eh.h\"\n-#include \"tree-cfg.h\"\n-#include \"tree-ssa-loop-manip.h\"\n-#include \"tree-ssa-loop.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"tree-ssa-propagate.h\"\n-#include \"alloc-pool.h\"\n-#include \"domwalk.h\"\n-#include \"tree-cfgcleanup.h\"\n-#include \"vr-values.h\"\n-#include \"gimple-ssa-evrp-analyze.h\"\n-\n-evrp_range_analyzer::evrp_range_analyzer (bool update_global_ranges)\n-  : stack (10), m_update_global_ranges (update_global_ranges)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bb->flags &= ~BB_VISITED;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-        e->flags |= EDGE_EXECUTABLE;\n-    }\n-}\n-\n-/* Push an unwinding marker onto the unwinding stack.  */\n-\n-void\n-evrp_range_analyzer::push_marker ()\n-{\n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range_equiv *)NULL));\n-}\n-\n-/* Analyze ranges as we enter basic block BB.  */\n-\n-void\n-evrp_range_analyzer::enter (basic_block bb)\n-{\n-  if (!optimize)\n-    return;\n-  push_marker ();\n-  record_ranges_from_incoming_edge (bb);\n-  record_ranges_from_phis (bb);\n-  bb->flags |= BB_VISITED;\n-}\n-\n-/* Find new range for NAME such that (OP CODE LIMIT) is true.  */\n-value_range_equiv *\n-evrp_range_analyzer::try_find_new_range (tree name,\n-\t\t\t\t\t tree op, tree_code code, tree limit)\n-{\n-  value_range_equiv vr;\n-  const value_range_equiv *old_vr = get_value_range (name);\n-\n-  /* Discover VR when condition is true.  */\n-  extract_range_for_var_from_comparison_expr (name, code, op, limit, &vr);\n-  /* If we found any usable VR, set the VR to ssa_name and create a\n-     PUSH old value in the stack with the old VR.  */\n-  if (!vr.undefined_p () && !vr.varying_p ())\n-    {\n-      if (old_vr->equal_p (vr, /*ignore_equivs=*/true))\n-\treturn NULL;\n-      value_range_equiv *new_vr = allocate_value_range_equiv ();\n-      new_vr->move (&vr);\n-      return new_vr;\n-    }\n-  return NULL;\n-}\n-\n-/* For LHS record VR in the SSA info.  */\n-void\n-evrp_range_analyzer::set_ssa_range_info (tree lhs, value_range_equiv *vr)\n-{\n-  gcc_assert (m_update_global_ranges);\n-\n-  /* Set the SSA with the value range.  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-    {\n-      if (!vr->varying_p () && vr->constant_p ())\n-\tset_range_info (lhs, *vr);\n-    }\n-  else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t   && range_includes_zero_p (vr) == 0)\n-    set_ptr_nonnull (lhs);\n-}\n-\n-/* Return true if all uses of NAME are dominated by STMT or feed STMT\n-   via a chain of single immediate uses.  */\n-\n-static bool\n-all_uses_feed_or_dominated_by_stmt (tree name, gimple *stmt)\n-{\n-  use_operand_p use_p, use2_p;\n-  imm_use_iterator iter;\n-  basic_block stmt_bb = gimple_bb (stmt);\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n-    {\n-      gimple *use_stmt = USE_STMT (use_p), *use_stmt2;\n-      if (use_stmt == stmt\n-\t  || is_gimple_debug (use_stmt)\n-\t  || (gimple_bb (use_stmt) != stmt_bb\n-\t      && dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t gimple_bb (use_stmt), stmt_bb)))\n-\tcontinue;\n-      while (use_stmt != stmt\n-\t     && is_gimple_assign (use_stmt)\n-\t     && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n-\t     && single_imm_use (gimple_assign_lhs (use_stmt),\n-\t\t\t\t&use2_p, &use_stmt2))\n-\tuse_stmt = use_stmt2;\n-      if (use_stmt != stmt)\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-void\n-evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n-{\n-  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n-  if (pred_e)\n-    {\n-      gimple *stmt = last_stmt (pred_e->src);\n-      tree op0 = NULL_TREE;\n-\n-      if (stmt\n-\t  && gimple_code (stmt) == GIMPLE_COND\n-\t  && (op0 = gimple_cond_lhs (stmt))\n-\t  && TREE_CODE (op0) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n-\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Visiting controlling predicate \");\n-\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t    }\n-\t  /* Entering a new scope.  Try to see if we can find a VR\n-\t     here.  */\n-\t  tree op1 = gimple_cond_rhs (stmt);\n-\t  if (TREE_OVERFLOW_P (op1))\n-\t    op1 = drop_tree_overflow (op1);\n-\t  tree_code code = gimple_cond_code (stmt);\n-\n-\t  auto_vec<assert_info, 8> asserts;\n-\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n-\n-\t  auto_vec<std::pair<tree, value_range_equiv *>, 8> vrs;\n-\t  for (unsigned i = 0; i < asserts.length (); ++i)\n-\t    {\n-\t      value_range_equiv *vr\n-\t\t= try_find_new_range (asserts[i].name,\n-\t\t\t\t      asserts[i].expr,\n-\t\t\t\t      asserts[i].comp_code,\n-\t\t\t\t      asserts[i].val);\n-\t      if (vr)\n-\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n-\t    }\n-\n-\t  /* If pred_e is really a fallthru we can record value ranges\n-\t     in SSA names as well.  */\n-\t  bool is_fallthru = assert_unreachable_fallthru_edge_p (pred_e);\n-\n-\t  /* Push updated ranges only after finding all of them to avoid\n-\t     ordering issues that can lead to worse ranges.  */\n-\t  for (unsigned i = 0; i < vrs.length (); ++i)\n-\t    {\n-\t      /* But make sure we do not weaken ranges like when\n-\t         getting first [64, +INF] and then ~[0, 0] from\n-\t\t conditions like (s & 0x3cc0) == 0).  */\n-\t      const value_range_equiv *old_vr\n-\t\t= get_value_range (vrs[i].first);\n-\t      value_range tem (*old_vr);\n-\t      tem.legacy_verbose_intersect (vrs[i].second);\n-\t      if (tem.equal_p (*old_vr))\n-\t\t{\n-\t\t  free_value_range (vrs[i].second);\n-\t\t  continue;\n-\t\t}\n-\t      push_value_range (vrs[i].first, vrs[i].second);\n-\t      if (is_fallthru\n-\t\t  && m_update_global_ranges\n-\t\t  && all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt)\n-\t\t  /* The condition must post-dominate the definition point.  */\n-\t\t  && (SSA_NAME_IS_DEFAULT_DEF (vrs[i].first)\n-\t\t      || (gimple_bb (SSA_NAME_DEF_STMT (vrs[i].first))\n-\t\t\t  == pred_e->src)))\n-\t\t{\n-\t\t  set_ssa_range_info (vrs[i].first, vrs[i].second);\n-\t\t  maybe_set_nonzero_bits (pred_e, vrs[i].first);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-void\n-evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n-{\n-  /* Visit PHI stmts and discover any new VRs possible.  */\n-  bool has_unvisited_preds = false;\n-  edge_iterator ei;\n-  edge e;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_EXECUTABLE\n-\t&& !(e->src->flags & BB_VISITED))\n-      {\n-\thas_unvisited_preds = true;\n-\tbreak;\n-      }\n-\n-  for (gphi_iterator gpi = gsi_start_phis (bb);\n-       !gsi_end_p (gpi); gsi_next (&gpi))\n-    {\n-      gphi *phi = gpi.phi ();\n-      tree lhs = PHI_RESULT (phi);\n-      if (virtual_operand_p (lhs))\n-\tcontinue;\n-\n-      /* Skips floats and other things we can't represent in a\n-\t range.  */\n-      if (!value_range_equiv::supports_p (TREE_TYPE (lhs)))\n-\tcontinue;\n-\n-      value_range_equiv vr_result;\n-      bool interesting = stmt_interesting_for_vrp (phi);\n-      if (!has_unvisited_preds && interesting)\n-\textract_range_from_phi_node (phi, &vr_result);\n-      else\n-\t{\n-\t  vr_result.set_varying (TREE_TYPE (lhs));\n-\t  /* When we have an unvisited executable predecessor we can't\n-\t     use PHI arg ranges which may be still UNDEFINED but have\n-\t     to use VARYING for them.  But we can still resort to\n-\t     SCEV for loop header PHIs.  */\n-\t  class loop *l;\n-\t  if (scev_initialized_p ()\n-\t      && interesting\n-\t      && (l = loop_containing_stmt (phi))\n-\t      && l->header == gimple_bb (phi))\n-\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n-\t}\n-      update_value_range (lhs, &vr_result);\n-\n-      /* Set the SSA with the value range.  */\n-      if (m_update_global_ranges)\n-\tset_ssa_range_info (lhs, &vr_result);\n-    }\n-}\n-\n-/* Record ranges from STMT into our VR_VALUES class.  If TEMPORARY is\n-   true, then this is a temporary equivalence and should be recorded\n-   into the unwind table.  Othewise record the equivalence into the\n-   global table.  */\n-\n-void\n-evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n-{\n-  tree output = NULL_TREE;\n-\n-  if (!optimize)\n-    return;\n-\n-  if (dyn_cast <gcond *> (stmt))\n-    ;\n-  else if (stmt_interesting_for_vrp (stmt))\n-    {\n-      edge taken_edge;\n-      value_range_equiv vr;\n-      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n-      if (output)\n-\t{\n-\t  /* Set the SSA with the value range.  There are two cases to\n-\t     consider.  First (the the most common) is we are processing\n-\t     STMT in a context where its resulting range globally holds\n-\t     and thus it can be reflected into the global ranges and need\n-\t     not be unwound as we leave scope.\n-\n-\t     The second case occurs if we are processing a statement in\n-\t     a context where the resulting range must not be reflected\n-\t     into the global tables and must be unwound as we leave\n-\t     the current context.  This happens in jump threading for\n-\t     example.  */\n-\t  if (!temporary)\n-\t    {\n-\t      /* Case one.  We can just update the underlying range\n-\t\t information as well as the global information.  */\n-\t      update_value_range (output, &vr);\n-\t      if (m_update_global_ranges)\n-\t\tset_ssa_range_info (output, &vr);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We're going to need to unwind this range.  We cannot\n-\t\t use VR as that's a stack object.  We have to allocate\n-\t\t a new range and push the old range onto the stack.  We\n-\t\t also have to be very careful about sharing the underlying\n-\t\t bitmaps.  Ugh.  */\n-\t      value_range_equiv *new_vr = allocate_value_range_equiv ();\n-\t      new_vr->set (vr.min (), vr.max (), NULL, vr.kind ());\n-\t      vr.equiv_clear ();\n-\t      push_value_range (output, new_vr);\n-\t    }\n-\t}\n-      else\n-\tset_defs_to_varying (stmt);\n-    }\n-  else\n-    set_defs_to_varying (stmt);\n-\n-  /* See if we can derive a range for any of STMT's operands.  */\n-  tree op;\n-  ssa_op_iter i;\n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-    {\n-      tree value;\n-      enum tree_code comp_code;\n-\n-      /* If OP is used in such a way that we can infer a value\n-         range for it, and we don't find a previous assertion for\n-         it, create a new assertion location node for OP.  */\n-      if (infer_value_range (stmt, op, &comp_code, &value))\n-\t{\n-\t  /* If we are able to infer a nonzero value range for OP,\n-\t     then walk backwards through the use-def chain to see if OP\n-\t     was set via a typecast.\n-\t     If so, then we can also infer a nonzero value range\n-\t     for the operand of the NOP_EXPR.  */\n-\t  if (comp_code == NE_EXPR && integer_zerop (value))\n-\t    {\n-\t      tree t = op;\n-\t      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n-\t      while (is_gimple_assign (def_stmt)\n-\t\t     && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n-\t\t     && TREE_CODE\n-\t\t\t  (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n-\t\t     && POINTER_TYPE_P\n-\t\t\t  (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n-\t\t{\n-\t\t  t = gimple_assign_rhs1 (def_stmt);\n-\t\t  def_stmt = SSA_NAME_DEF_STMT (t);\n-\n-\t\t  /* Add VR when (T COMP_CODE value) condition is\n-\t\t     true.  */\n-\t\t  value_range_equiv *op_range\n-\t\t    = try_find_new_range (t, t, comp_code, value);\n-\t\t  if (op_range)\n-\t\t    push_value_range (t, op_range);\n-\t\t}\n-\t    }\n-\t  /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t  value_range_equiv *op_range = try_find_new_range (op, op,\n-\t\t\t\t\t\t\t    comp_code, value);\n-\t  if (op_range)\n-\t    push_value_range (op, op_range);\n-\t}\n-    }\n-}\n-\n-/* Unwind recorded ranges to their most recent state.  */\n-\n-void\n-evrp_range_analyzer::pop_to_marker (void)\n-{\n-  gcc_checking_assert (!stack.is_empty ());\n-  while (stack.last ().first != NULL_TREE)\n-    pop_value_range ();\n-  stack.pop ();\n-}\n-\n-/* Restore/pop VRs valid only for BB when we leave BB.  */\n-\n-void\n-evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  if (!optimize)\n-    return;\n-  pop_to_marker ();\n-}\n-\n-\n-/* Push the Value Range of VAR to the stack and update it with new VR.  */\n-\n-void\n-evrp_range_analyzer::push_value_range (tree var, value_range_equiv *vr)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"pushing new range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \": \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  value_range_equiv *old_vr = swap_vr_value (var, vr);\n-  stack.safe_push (std::make_pair (var, old_vr));\n-}\n-\n-/* Pop a Value Range from the vrp_stack.  */\n-\n-void\n-evrp_range_analyzer::pop_value_range ()\n-{\n-  std::pair<tree, value_range_equiv *> e = stack.pop ();\n-  tree var = e.first;\n-  value_range_equiv *vr = e.second;\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"popping range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \", restoring \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  /* We saved off a lattice entry, now give it back and release\n-     the one we popped.  */\n-  value_range_equiv *popped_vr = swap_vr_value (var, vr);\n-  if (popped_vr)\n-    free_value_range (popped_vr);\n-}"}, {"sha": "51c32099dc52bc125e8c16af981255c270318cb0", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=eabd44a02529f7921a4997240aaaefb15f1ef81f", "patch": "@@ -1,58 +0,0 @@\n-/* Support routines for Value Range Propagation (VRP).\n-   Copyright (C) 2016-2022 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n-#define GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n-\n-class evrp_range_analyzer : public vr_values\n-{\n- public:\n-  evrp_range_analyzer (bool update_global_ranges);\n-  ~evrp_range_analyzer (void)\n-  {\n-    stack.release ();\n-  }\n-\n-  void enter (basic_block);\n-  void push_marker (void);\n-  void pop_to_marker (void);\n-  void leave (basic_block);\n-  void record_ranges_from_stmt (gimple *, bool);\n-\n-  /* Record a new unwindable range.  */\n-  void push_value_range (tree var, value_range_equiv *vr);\n-\n- private:\n-  DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n-\n-  void pop_value_range ();\n-  value_range_equiv *try_find_new_range (tree, tree op, tree_code code,\n-\t\t\t\t\t tree limit);\n-  void record_ranges_from_incoming_edge (basic_block);\n-  void record_ranges_from_phis (basic_block);\n-  void set_ssa_range_info (tree, value_range_equiv *);\n-\n-  /* STACK holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range_equiv *> > stack;\n-\n-  /* True if we are updating global ranges, false otherwise.  */\n-  bool m_update_global_ranges;\n-};\n-\n-#endif /* GCC_GIMPLE_SSA_EVRP_ANALYZE_H */"}, {"sha": "793a3ea1f1928ac0dc00e47b61791322edcb9eb0", "filename": "gcc/gimple-ssa-evrp.cc", "status": "removed", "additions": 0, "deletions": 395, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eabd44a02529f7921a4997240aaaefb15f1ef81f/gcc%2Fgimple-ssa-evrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.cc?ref=eabd44a02529f7921a4997240aaaefb15f1ef81f", "patch": "@@ -1,395 +0,0 @@\n-/* Support routines for Value Range Propagation (VRP).\n-   Copyright (C) 2005-2022 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"tree-pass.h\"\n-#include \"ssa.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"cfganal.h\"\n-#include \"gimple-iterator.h\"\n-#include \"gimple-fold.h\"\n-#include \"tree-eh.h\"\n-#include \"tree-cfg.h\"\n-#include \"tree-ssa-loop-manip.h\"\n-#include \"tree-ssa-loop.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"tree-ssa-propagate.h\"\n-#include \"alloc-pool.h\"\n-#include \"domwalk.h\"\n-#include \"tree-cfgcleanup.h\"\n-#include \"vr-values.h\"\n-#include \"gimple-ssa-evrp-analyze.h\"\n-#include \"gimple-range.h\"\n-#include \"fold-const.h\"\n-#include \"value-pointer-equiv.h\"\n-#include \"tree-vrp.h\"\n-\n-// This is the classic EVRP folder which uses a dominator walk and pushes\n-// ranges into the next block if it is a single predecessor block.\n-\n-class evrp_folder : public substitute_and_fold_engine\n-{\n-public:\n-  evrp_folder () :\n-    substitute_and_fold_engine (),\n-    m_range_analyzer (/*update_global_ranges=*/true),\n-    simplifier (&m_range_analyzer)\n-  { }\n-\n-  ~evrp_folder ()\n-  {\n-    if (dump_file)\n-      {\n-\tfprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-\tm_range_analyzer.dump (dump_file);\n-\tfprintf (dump_file, \"\\n\");\n-      }\n-  }\n-\n-  tree value_of_expr (tree name, gimple *stmt) override\n-  {\n-    return m_range_analyzer.value_of_expr (name, stmt);\n-  }\n-\n-  void pre_fold_bb (basic_block bb) override\n-  {\n-    if (dump_file && (dump_flags & TDF_DETAILS))\n-      fprintf (dump_file, \"evrp visiting BB%d\\n\", bb->index);\n-    m_range_analyzer.enter (bb);\n-  }\n-\n-  void pre_fold_stmt (gimple *stmt) override\n-  {\n-    if (dump_file && (dump_flags & TDF_DETAILS))\n-      {\n-\tfprintf (dump_file, \"evrp visiting stmt \");\n-\tprint_gimple_stmt (dump_file, stmt, 0);\n-      }\n-    m_range_analyzer.record_ranges_from_stmt (stmt, false);\n-  }\n-\n-  bool fold_stmt (gimple_stmt_iterator *gsi) override\n-  {\n-    return simplifier.simplify (gsi);\n-  }\n-\n-  void post_fold_bb (basic_block bb) override\n-  {\n-    m_range_analyzer.leave (bb);\n-  }\n-\n-  void post_new_stmt (gimple *stmt) override\n-  {\n-    m_range_analyzer.set_defs_to_varying (stmt);\n-  }\n-\n-protected:\n-  DISABLE_COPY_AND_ASSIGN (evrp_folder);\n-  evrp_range_analyzer m_range_analyzer;\n-  simplify_using_ranges simplifier;\n-};\n-\n-// In a hybrid folder, start with an EVRP folder, and add the required\n-// fold_stmt bits to either try the ranger first or second.\n-//\n-// The 3 value_* routines will always query both EVRP and the ranger for\n-// a result, and ensure they return the same value.  If either returns a value\n-// when the other doesn't, it is flagged in the listing, and the discoverd\n-// value is returned.\n-//\n-// The simplifier is unable to process 2 different sources, thus we try to \n-// use one engine, and if it fails to simplify, try using the other engine.\n-// It is reported when the first attempt fails and the second succeeds.\n-\n-class hybrid_folder : public evrp_folder\n-{\n-public:\n-  hybrid_folder (bool evrp_first)\n-  {\n-    m_ranger = enable_ranger (cfun);\n-\n-    if (evrp_first)\n-      {\n-\tfirst = &m_range_analyzer;\n-\tfirst_exec_flag = 0;\n-\tsecond = m_ranger;\n-\tsecond_exec_flag = m_ranger->non_executable_edge_flag;\n-      }\n-     else\n-      {\n-\tfirst = m_ranger;\n-\tfirst_exec_flag = m_ranger->non_executable_edge_flag;\n-\tsecond = &m_range_analyzer;\n-\tsecond_exec_flag = 0;\n-      }\n-    m_pta = new pointer_equiv_analyzer (m_ranger);\n-  }\n-\n-  ~hybrid_folder ()\n-  {\n-    if (dump_file && (dump_flags & TDF_DETAILS))\n-      m_ranger->dump (dump_file);\n-\n-    m_ranger->export_global_ranges ();\n-    disable_ranger (cfun);\n-    delete m_pta;\n-  }\n-\n-  bool fold_stmt (gimple_stmt_iterator *gsi) override\n-    {\n-      simplifier.set_range_query (first, first_exec_flag);\n-      if (simplifier.simplify (gsi))\n-\treturn true;\n-\n-      simplifier.set_range_query (second, second_exec_flag);\n-      if (simplifier.simplify (gsi))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"EVRP:hybrid: Second query simplifed stmt\\n\");\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  void pre_fold_stmt (gimple *stmt) override\n-  {\n-    evrp_folder::pre_fold_stmt (stmt);\n-    m_pta->visit_stmt (stmt);\n-  }\n-\n-  void pre_fold_bb (basic_block bb) override\n-  {\n-    evrp_folder::pre_fold_bb (bb);\n-    m_pta->enter (bb);\n-  }\n-\n-  void post_fold_bb (basic_block bb) override\n-  {\n-    evrp_folder::post_fold_bb (bb);\n-    m_pta->leave (bb);\n-  }\n-\n-  tree value_of_expr (tree name, gimple *) override;\n-  tree value_on_edge (edge, tree name) override;\n-  tree value_of_stmt (gimple *, tree name) override;\n-\n-private:\n-  DISABLE_COPY_AND_ASSIGN (hybrid_folder);\n-  gimple_ranger *m_ranger;\n-  range_query *first;\n-  int first_exec_flag;\n-  range_query *second;\n-  int second_exec_flag;\n-  pointer_equiv_analyzer *m_pta;\n-  tree choose_value (tree evrp_val, tree ranger_val);\n-};\n-\n-\n-tree\n-hybrid_folder::value_of_expr (tree op, gimple *stmt)\n-{\n-  tree evrp_ret = evrp_folder::value_of_expr (op, stmt);\n-  tree ranger_ret;\n-  if (TREE_CODE (op) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))\n-    ranger_ret = NULL;\n-  else\n-    {\n-      ranger_ret = m_ranger->value_of_expr (op, stmt);\n-      if (!ranger_ret && supported_pointer_equiv_p (op))\n-\tranger_ret = m_pta->get_equiv (op);\n-    }\n-  return choose_value (evrp_ret, ranger_ret);\n-}\n-\n-tree\n-hybrid_folder::value_on_edge (edge e, tree op)\n-{\n-  // Call evrp::value_of_expr directly.  Otherwise another dual call is made\n-  // via hybrid_folder::value_of_expr, but without an edge.\n-  tree evrp_ret = evrp_folder::value_of_expr (op, NULL);\n-  tree ranger_ret;\n-  if (TREE_CODE (op) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))\n-    ranger_ret = NULL;\n-  else\n-    {\n-      ranger_ret = m_ranger->value_on_edge (e, op);\n-      if (!ranger_ret && supported_pointer_equiv_p (op))\n-\tranger_ret = m_pta->get_equiv (op);\n-    }\n-  return choose_value (evrp_ret, ranger_ret);\n-}\n-\n-tree\n-hybrid_folder::value_of_stmt (gimple *stmt, tree op) \n-{\n-  // Call evrp::value_of_expr directly.  Otherwise another dual call is made\n-  // via hybrid_folder::value_of_expr, but without a stmt.\n-  tree evrp_ret;\n-  if (op)\n-    evrp_ret = evrp_folder::value_of_expr (op, NULL);\n-  else\n-    evrp_ret = NULL_TREE;\n-\n-  tree ranger_ret;\n-  if (op && TREE_CODE (op) == SSA_NAME && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))\n-    ranger_ret = NULL;\n-  else\n-    ranger_ret = m_ranger->value_of_stmt (stmt, op);\n-  return choose_value (evrp_ret, ranger_ret);\n-}\n-\n-// Given trees returned by EVRP and Ranger, choose/report the value to use\n-// by the folder.\n-\n-tree\n-hybrid_folder::choose_value (tree evrp_val, tree ranger_val)\n-{\n-  // If both found the same value, just return it.\n-  if (evrp_val && ranger_val && !compare_values (evrp_val, ranger_val))\n-    return evrp_val;\n-\n-  // If neither returned a value, return NULL_TREE.\n-  if (!ranger_val && !evrp_val)\n-    return NULL_TREE;\n-\n-  // Otherwise there is a discrepancy to flag.\n-  if (dump_file)\n-    {\n-      if (evrp_val && ranger_val)\n-\tfprintf (dump_file, \"EVRP:hybrid: Disagreement\\n\");\n-      if (evrp_val)\n-\t{\n-\t  fprintf (dump_file, \"EVRP:hybrid: EVRP found singleton \");\n-\t  print_generic_expr (dump_file, evrp_val);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      if (ranger_val)\n-\t{\n-\t  fprintf (dump_file, \"EVRP:hybrid: RVRP found singleton \");\n-\t  print_generic_expr (dump_file, ranger_val);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-    }\n-\n-  // If one value was found, return it.\n-  if (!evrp_val)\n-    return ranger_val;\n-  if (!ranger_val)\n-    return evrp_val;\n-\n-  // If values are different, return the first calculated value.\n-  if (param_evrp_mode == EVRP_MODE_RVRP_FIRST)\n-    return ranger_val;\n-  return evrp_val;\n-}\n-\n-/* Main entry point for the early vrp pass which is a simplified non-iterative\n-   version of vrp where basic blocks are visited in dominance order.  Value\n-   ranges discovered in early vrp will also be used by ipa-vrp.  */\n-\n-static unsigned int\n-execute_early_vrp ()\n-{\n-  if (param_evrp_mode == EVRP_MODE_RVRP_ONLY)\n-    return execute_ranger_vrp (cfun, false);\n-\n-  /* Ideally this setup code would move into the ctor for the folder\n-     However, this setup can change the number of blocks which\n-     invalidates the internal arrays that are set up by the dominator\n-     walker in substitute_and_fold_engine.  */\n-  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-  scev_initialize ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n-  // Only the last 2 bits matter for choosing the folder.\n-  switch (param_evrp_mode)\n-    {\n-    case EVRP_MODE_EVRP_ONLY:\n-      {\n-\tevrp_folder folder;\n-\tfolder.substitute_and_fold ();\n-\tbreak;\n-      }\n-    case EVRP_MODE_EVRP_FIRST:\n-      {\n-\thybrid_folder folder (true);\n-\tfolder.substitute_and_fold ();\n-\tbreak;\n-      }\n-    case EVRP_MODE_RVRP_FIRST:\n-      {\n-\thybrid_folder folder (false);\n-\tfolder.substitute_and_fold ();\n-\tbreak;\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  scev_finalize ();\n-  loop_optimizer_finalize ();\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_early_vrp =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"evrp\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_EARLY_VRP, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_update_ssa | TODO_verify_all ),\n-};\n-\n-class pass_early_vrp : public gimple_opt_pass\n-{\n-public:\n-  pass_early_vrp (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_early_vrp, ctxt)\n-    {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () final override { return new pass_early_vrp (m_ctxt); }\n-  bool gate (function *) final override\n-    {\n-      return flag_tree_vrp != 0;\n-    }\n-  unsigned int execute (function *) final override\n-    { return execute_early_vrp (); }\n-\n-}; // class pass_vrp\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_early_vrp (gcc::context *ctxt)\n-{\n-  return new pass_early_vrp (ctxt);\n-}"}, {"sha": "2f9c9cf27dd22cdb4d575243f53c31e265a009b7", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -134,25 +134,6 @@ Maximum number of basic blocks before EVRP uses a sparse cache.\n Common Joined UInteger Var(param_evrp_switch_limit) Init(50) Optimization Param\n Maximum number of outgoing edges in a switch before EVRP will not process it.\n \n--param=evrp-mode=\n-Common Joined Var(param_evrp_mode) Enum(evrp_mode) Init(EVRP_MODE_RVRP_ONLY) Param Optimization\n---param=evrp-mode=[legacy|ranger|legacy-first|ranger-first] Specifies the mode Early VRP should operate in.\n-\n-Enum\n-Name(evrp_mode) Type(enum evrp_mode) UnknownError(unknown evrp mode %qs)\n-\n-EnumValue\n-Enum(evrp_mode) String(legacy) Value(EVRP_MODE_EVRP_ONLY)\n-\n-EnumValue\n-Enum(evrp_mode) String(ranger) Value(EVRP_MODE_RVRP_ONLY)\n-\n-EnumValue\n-Enum(evrp_mode) String(legacy-first) Value(EVRP_MODE_EVRP_FIRST)\n-\n-EnumValue\n-Enum(evrp_mode) String(ranger-first) Value(EVRP_MODE_RVRP_FIRST)\n-\n -param=fsm-scale-path-blocks=\n Common Joined UInteger Var(param_fsm_scale_path_blocks) Init(3) IntegerRange(1, 10) Param Optimization\n Scale factor to apply to the number of blocks in a threading path when comparing to the number of (scaled) statements."}, {"sha": "63320ef73fca98b216230db1b9f9970bf58d0302", "filename": "gcc/testsuite/g++.dg/pr100774.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100774.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100774.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr100774.C?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-forwprop --param=evrp-mode=ranger -fcompare-debug  \" } */\n+/* { dg-options \"-O2 -fno-tree-forwprop -fcompare-debug  \" } */\n \n extern void __attribute__((noreturn)) error();\n "}, {"sha": "96f0a7a6012c9c2b707ac2186010aa9737c813a0", "filename": "gcc/testsuite/gcc.dg/pr100781.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100781.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100781.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100781.c?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 --param=evrp-mode=ranger -fcompare-debug  \" } */\n+/* { dg-options \"-O2 -fcompare-debug  \" } */\n \n struct a {\n   int b;"}, {"sha": "2d15bb5a6505c5234ba21b7b3ff77dcb19bf4f70", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243b5396106c4b1eb813fd06c2bc6f0a3009bae8/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "patch": "@@ -4388,17 +4388,30 @@ const pass_data pass_data_vrp =\n   ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */\n };\n \n+const pass_data pass_data_early_vrp =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"evrp\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_TREE_EARLY_VRP, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_cleanup_cfg | TODO_update_ssa | TODO_verify_all ),\n+};\n+\n static int vrp_pass_num = 0;\n class pass_vrp : public gimple_opt_pass\n {\n public:\n-  pass_vrp (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_vrp, ctxt), warn_array_bounds_p (false),\n-      my_pass (++vrp_pass_num)\n+  pass_vrp (gcc::context *ctxt, const pass_data &data_)\n+    : gimple_opt_pass (data_, ctxt), data (data_), warn_array_bounds_p (false),\n+      my_pass (vrp_pass_num++)\n   {}\n \n   /* opt_pass methods: */\n-  opt_pass * clone () final override { return new pass_vrp (m_ctxt); }\n+  opt_pass * clone () final override { return new pass_vrp (m_ctxt, data); }\n   void set_pass_param (unsigned int n, bool param) final override\n     {\n       gcc_assert (n == 0);\n@@ -4407,13 +4420,18 @@ class pass_vrp : public gimple_opt_pass\n   bool gate (function *) final override { return flag_tree_vrp != 0; }\n   unsigned int execute (function *fun) final override\n     {\n+      // Early VRP pass.\n+      if (my_pass == 0)\n+\treturn execute_ranger_vrp (fun, /*warn_array_bounds_p=*/false);\n+\n       if ((my_pass == 1 && param_vrp1_mode == VRP_MODE_RANGER)\n \t  || (my_pass == 2 && param_vrp2_mode == VRP_MODE_RANGER))\n \treturn execute_ranger_vrp (fun, warn_array_bounds_p);\n       return execute_vrp (fun, warn_array_bounds_p);\n     }\n \n  private:\n+  const pass_data &data;\n   bool warn_array_bounds_p;\n   int my_pass;\n }; // class pass_vrp\n@@ -4423,5 +4441,11 @@ class pass_vrp : public gimple_opt_pass\n gimple_opt_pass *\n make_pass_vrp (gcc::context *ctxt)\n {\n-  return new pass_vrp (ctxt);\n+  return new pass_vrp (ctxt, pass_data_vrp);\n+}\n+\n+gimple_opt_pass *\n+make_pass_early_vrp (gcc::context *ctxt)\n+{\n+  return new pass_vrp (ctxt, pass_data_early_vrp);\n }"}]}