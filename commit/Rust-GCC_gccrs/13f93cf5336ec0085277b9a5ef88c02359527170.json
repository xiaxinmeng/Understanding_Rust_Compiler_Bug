{"sha": "13f93cf5336ec0085277b9a5ef88c02359527170", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNmOTNjZjUzMzZlYzAwODUyNzdiOWE1ZWY4OGMwMjM1OTUyNzE3MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-24T16:23:55Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-24T16:31:03Z"}, "message": "preprocessor: Add deferred macros\n\nDeferred macros are needed for C++ modules.  Header units may export\nmacro definitions and undefinitions.  These are resolved lazily at the\npoint of (potential) use.  (The language specifies that, it's not just\na useful optimization.)  Thus, identifier nodes grow a 'deferred'\nfield, which fortunately doesn't expand the structure on 64-bit\nsystems as there was padding there.  This is non-zero on NT_MACRO\nnodes, if the macro is deferred.  When such an identifier is lexed, it\nis resolved via a callback that I added recently.  That will either\nprovide the macro definition, or discover it there was an overriding\nundef.  Either way the identifier is no longer a deferred macro.\nNotice it is now possible for NT_MACRO nodes to have a NULL macro\nexpansion.\n\n\tlibcpp/\n\t* include/cpplib.h (struct cpp_hashnode): Add deferred field.\n\t(cpp_set_deferred_macro): Define.\n\t(cpp_get_deferred_macro): Declare.\n\t(cpp_macro_definition): Reformat, add overload.\n\t(cpp_macro_definition_location): Deal with deferred macro.\n\t(cpp_alloc_token_string, cpp_compare_macro): Declare.\n\t* internal.h (_cpp_notify_macro_use): Return bool\n\t(_cpp_maybe_notify_macro_use): Likewise.\n\t* directives.c (do_undef): Check macro is not undef before\n\twarning.\n\t(do_ifdef, do_ifndef): Deal with deferred macro.\n\t* expr.c (parse_defined): Likewise.\n\t* lex.c (cpp_allocate_token_string): Break out of ...\n\t(create_literal): ... here.  Call it.\n\t(cpp_maybe_module_directive): Deal with deferred macro.\n\t* macro.c (cpp_get_token_1): Deal with deferred macro.\n\t(warn_of_redefinition): Deal with deferred macro.\n\t(compare_macros): Rename to ...\n\t(cpp_compare_macro): ... here.  Make extern.\n\t(cpp_get_deferred_macro): New.\n\t(_cpp_notify_macro_use): Deal with deferred macro, return bool\n\tindicating definedness.\n\t(cpp_macro_definition): Deal with deferred macro.", "tree": {"sha": "21dd731e4de98eaab84f2e61d5bc54debf9c9851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21dd731e4de98eaab84f2e61d5bc54debf9c9851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13f93cf5336ec0085277b9a5ef88c02359527170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f93cf5336ec0085277b9a5ef88c02359527170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f93cf5336ec0085277b9a5ef88c02359527170", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f93cf5336ec0085277b9a5ef88c02359527170/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "489be3119e6cd092bf7f30880a5d641f0bf0672f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/489be3119e6cd092bf7f30880a5d641f0bf0672f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/489be3119e6cd092bf7f30880a5d641f0bf0672f"}], "stats": {"total": 174, "additions": 123, "deletions": 51}, "files": [{"sha": "fa66b5c5f71260882aab66836fafd090f3d7fdb9", "filename": "libcpp/directives.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -667,7 +667,8 @@ do_undef (cpp_reader *pfile)\n \t\t\t\t   pfile->directive_line, 0,\n \t\t\t\t   \"undefining \\\"%s\\\"\", NODE_NAME (node));\n \n-\t  if (CPP_OPTION (pfile, warn_unused_macros))\n+\t  if (node->value.macro\n+\t      && CPP_OPTION (pfile, warn_unused_macros))\n \t    _cpp_warn_if_unused_macro (pfile, node, NULL);\n \n \t  _cpp_free_definition (node);\n@@ -1981,8 +1982,10 @@ do_ifdef (cpp_reader *pfile)\n       if (node)\n \t{\n \t  skip = !_cpp_defined_macro_p (node);\n+\t  if (!_cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line))\n+\t    /* It wasn't a macro after all.  */\n+\t    skip = true;\n \t  _cpp_mark_macro_used (node);\n-\t  _cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);\n@@ -2006,8 +2009,10 @@ do_ifndef (cpp_reader *pfile)\n       if (node)\n \t{\n \t  skip = _cpp_defined_macro_p (node);\n+\t  if (!_cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line))\n+\t    /* It wasn't a macro after all.  */\n+\t    skip = false;\n \t  _cpp_mark_macro_used (node);\n-\t  _cpp_maybe_notify_macro_use (pfile, node, pfile->directive_line);\n \t  if (pfile->cb.used)\n \t    pfile->cb.used (pfile, pfile->directive_line, node);\n \t  check_eol (pfile, false);"}, {"sha": "2ba7726d61c4679edca4270eb5d1d4e02cf566be", "filename": "libcpp/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -1068,16 +1068,19 @@ parse_defined (cpp_reader *pfile)\n \t}\n     }\n \n+  bool is_defined = false;\n   if (node)\n     {\n       if ((pfile->context != initial_context\n \t   || initial_context != &pfile->base_context)\n \t  && CPP_OPTION (pfile, warn_expansion_to_defined))\n         cpp_pedwarning (pfile, CPP_W_EXPANSION_TO_DEFINED,\n \t\t        \"this use of \\\"defined\\\" may not be portable\");\n-\n+      is_defined = _cpp_defined_macro_p (node);\n+      if (!_cpp_maybe_notify_macro_use (pfile, node, token->src_loc))\n+\t/* It wasn't a macro after all.  */\n+\tis_defined = false;\n       _cpp_mark_macro_used (node);\n-      _cpp_maybe_notify_macro_use (pfile, node, token->src_loc);\n \n       /* A possible controlling macro of the form #if !defined ().\n \t _cpp_parse_expr checks there was no other junk on the line.  */\n@@ -1093,7 +1096,7 @@ parse_defined (cpp_reader *pfile)\n   result.unsignedp = false;\n   result.high = 0;\n   result.overflow = false;\n-  result.low = node && _cpp_defined_macro_p (node);\n+  result.low = is_defined;\n   return result;\n }\n "}, {"sha": "2becd2e8e545e76525f38ffbf7afea48117ad251", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -901,7 +901,7 @@ enum cpp_builtin_type\n union GTY(()) _cpp_hashnode_value {\n   /* Assert (maybe NULL) */\n   cpp_macro * GTY((tag (\"NT_VOID\"))) answers;\n-  /* Macro (never NULL) */\n+  /* Macro (maybe NULL) */\n   cpp_macro * GTY((tag (\"NT_USER_MACRO\"))) macro;\n   /* Code for a builtin macro.  */\n   enum cpp_builtin_type GTY ((tag (\"NT_BUILTIN_MACRO\"))) builtin;\n@@ -919,7 +919,11 @@ struct GTY(()) cpp_hashnode {\n   unsigned int flags : 9;\t\t/* CPP flags.  */\n   ENUM_BITFIELD(node_type) type : 2;\t/* CPP node type.  */\n \n-  /* 5 bits spare (plus another 32 on 64-bit hosts).  */\n+  /* 5 bits spare.  */\n+\n+  /* On a 64-bit system there would be 32-bits of padding to the value\n+     field.  So placing the deferred index here is not costly.   */\n+  unsigned deferred;\t\t\t/* Deferred index, (unless zero).  */\n \n   union _cpp_hashnode_value GTY ((desc (\"%1.type\"))) value;\n };\n@@ -1061,18 +1065,32 @@ inline bool cpp_macro_p (const cpp_hashnode *node)\n {\n   return node->type & NT_MACRO_MASK;\n }\n+inline cpp_macro *cpp_set_deferred_macro (cpp_hashnode *node,\n+\t\t\t\t\t  cpp_macro *forced = NULL)\n+{\n+  cpp_macro *old = node->value.macro;\n+\n+  node->value.macro = forced;\n+  node->type = NT_USER_MACRO;\n+  node->flags &= ~NODE_USED;\n+\n+  return old;\n+}\n+cpp_macro *cpp_get_deferred_macro (cpp_reader *, cpp_hashnode *, location_t);\n \n /* Returns true if NODE is a function-like user macro.  */\n inline bool cpp_fun_like_macro_p (cpp_hashnode *node)\n {\n   return cpp_user_macro_p (node) && node->value.macro->fun_like;\n }\n \n-extern const unsigned char *cpp_macro_definition (cpp_reader *,\n-\t\t\t\t\t\t  cpp_hashnode *);\n+extern const unsigned char *cpp_macro_definition (cpp_reader *, cpp_hashnode *);\n+extern const unsigned char *cpp_macro_definition (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t\t  const cpp_macro *);\n inline location_t cpp_macro_definition_location (cpp_hashnode *node)\n {\n-  return node->value.macro->line;\n+  const cpp_macro *macro = node->value.macro;\n+  return macro ? macro->line : 0;\n }\n /* Return an idempotent time stamp (possibly from SOURCE_DATE_EPOCH).  */\n enum class CPP_time_kind \n@@ -1266,6 +1284,8 @@ extern int cpp_ideq (const cpp_token *, const char *);\n extern void cpp_output_line (cpp_reader *, FILE *);\n extern unsigned char *cpp_output_line_to_string (cpp_reader *,\n \t\t\t\t\t\t const unsigned char *);\n+extern const unsigned char *cpp_alloc_token_string\n+  (cpp_reader *, const unsigned char *, unsigned);\n extern void cpp_output_token (const cpp_token *, FILE *);\n extern const char *cpp_type2name (enum cpp_ttype, unsigned char flags);\n /* Returns the value of an escape sequence, truncated to the correct\n@@ -1321,6 +1341,8 @@ extern void cpp_scan_nooutput (cpp_reader *);\n extern int  cpp_sys_macro_p (cpp_reader *);\n extern unsigned char *cpp_quote_string (unsigned char *, const unsigned char *,\n \t\t\t\t\tunsigned int);\n+extern bool cpp_compare_macros (const cpp_macro *macro1,\n+\t\t\t\tconst cpp_macro *macro2);\n \n /* In files.c */\n extern bool cpp_included (cpp_reader *, const char *);"}, {"sha": "45bbbddf2684428c2e1ec0e085bb344012b7016d", "filename": "libcpp/internal.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -662,13 +662,14 @@ inline bool _cpp_defined_macro_p (cpp_hashnode *node)\n }\n \n /* In macro.c */\n-extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n-\t\t\t\t   location_t loc);\n-inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n+extern bool _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\t\t   location_t);\n+inline bool _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n \t\t\t\t\t location_t loc)\n {\n   if (!(node->flags & NODE_USED))\n-    _cpp_notify_macro_use (pfile, node, loc);\n+    return _cpp_notify_macro_use (pfile, node, loc);\n+  return true;\n }\n extern cpp_macro *_cpp_new_macro (cpp_reader *, cpp_macro_kind, void *);\n extern void _cpp_free_definition (cpp_hashnode *);"}, {"sha": "07d5a4ff4668853a230c00f53dd48b0691276b09", "filename": "libcpp/lex.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -1577,13 +1577,20 @@ static void\n create_literal (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \t\tunsigned int len, enum cpp_ttype type)\n {\n-  uchar *dest = _cpp_unaligned_alloc (pfile, len + 1);\n-\n-  memcpy (dest, base, len);\n-  dest[len] = '\\0';\n   token->type = type;\n   token->val.str.len = len;\n-  token->val.str.text = dest;\n+  token->val.str.text = cpp_alloc_token_string (pfile, base, len);\n+}\n+\n+const uchar *\n+cpp_alloc_token_string (cpp_reader *pfile,\n+\t\t\tconst unsigned char *ptr, unsigned len)\n+{\n+  uchar *dest = _cpp_unaligned_alloc (pfile, len + 1);\n+\n+  dest[len] = 0;\n+  memcpy (dest, ptr, len);\n+  return dest;\n }\n \n /* A pair of raw buffer pointers.  The currently open one is [1], the\n@@ -2712,6 +2719,7 @@ cpp_maybe_module_directive (cpp_reader *pfile, cpp_token *result)\n \t  /* Don't attempt to expand the token.  */\n \t  tok->flags |= NO_EXPAND;\n \t  if (_cpp_defined_macro_p (node)\n+\t      && _cpp_maybe_notify_macro_use (pfile, node, tok->src_loc)\n \t      && !cpp_fun_like_macro_p (node))\n \t    cpp_error_with_line (pfile, CPP_DL_ERROR, tok->src_loc, 0, \n \t\t\t\t \"module control-line \\\"%s\\\" cannot be\""}, {"sha": "05755859cd68d1782d9fdb28cc8e953cf845c008", "filename": "libcpp/macro.c", "status": "modified", "additions": 64, "deletions": 31, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f93cf5336ec0085277b9a5ef88c02359527170/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=13f93cf5336ec0085277b9a5ef88c02359527170", "patch": "@@ -268,6 +268,8 @@ class vaopt_state {\n \n /* Macro expansion.  */\n \n+static cpp_macro *get_deferred_or_lazy_macro (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t      location_t);\n static int enter_macro_context (cpp_reader *, cpp_hashnode *,\n \t\t\t\tconst cpp_token *, location_t);\n static int builtin_macro (cpp_reader *, cpp_hashnode *,\n@@ -338,10 +340,6 @@ static cpp_macro *create_iso_definition (cpp_reader *);\n /* #define directive parsing and handling.  */\n \n static cpp_macro *lex_expansion_token (cpp_reader *, cpp_macro *);\n-static bool warn_of_redefinition (cpp_reader *, cpp_hashnode *,\n-\t\t\t\t  const cpp_macro *);\n-static bool compare_macros (const cpp_macro *, const cpp_macro *);\n-\n static bool parse_params (cpp_reader *, unsigned *, bool *);\n static void check_trad_stringification (cpp_reader *, const cpp_macro *,\n \t\t\t\t\tconst cpp_string *);\n@@ -353,8 +351,6 @@ static const cpp_token* cpp_get_token_1 (cpp_reader *, location_t *);\n \n static cpp_hashnode* macro_of_context (cpp_context *context);\n \n-static bool in_macro_expansion_p (cpp_reader *pfile);\n-\n /* Statistical counter tracking the number of macros that got\n    expanded.  */\n unsigned num_expanded_macros_counter = 0;\n@@ -2878,6 +2874,12 @@ cpp_get_token_1 (cpp_reader *pfile, location_t *location)\n       if (node->type == NT_VOID || (result->flags & NO_EXPAND))\n \tbreak;\n \n+      if (!(node->flags & NODE_USED)\n+\t  && node->type == NT_USER_MACRO\n+\t  && !node->value.macro\n+\t  && !cpp_get_deferred_macro (pfile, node, result->src_loc))\n+\tbreak;\n+\n       if (!(node->flags & NODE_DISABLED))\n \t{\n \t  int ret = 0;\n@@ -3216,22 +3218,15 @@ warn_of_redefinition (cpp_reader *pfile, cpp_hashnode *node,\n   if (node->flags & NODE_CONDITIONAL)\n     return false;\n \n-  cpp_macro *macro1 = node->value.macro;\n-  if (macro1->lazy)\n-    {\n-      /* We don't want to mark MACRO as used, but do need to finalize\n-\t its laziness.  */\n-      pfile->cb.user_lazy_macro (pfile, macro1, macro1->lazy - 1);\n-      macro1->lazy = 0;\n-    }\n-\n-  return compare_macros (macro1, macro2);\n+  if (cpp_macro *macro1 = get_deferred_or_lazy_macro (pfile, node, macro2->line))\n+    return cpp_compare_macros (macro1, macro2);\n+  return false;\n }\n \n /* Return TRUE if MACRO1 and MACRO2 differ.  */\n \n-static bool\n-compare_macros (const cpp_macro *macro1, const cpp_macro *macro2)\n+bool\n+cpp_compare_macros (const cpp_macro *macro1, const cpp_macro *macro2)\n {\n   /* Redefinition of a macro is allowed if and only if the old and new\n      definitions are the same.  (6.10.3 paragraph 2).  */\n@@ -3790,26 +3785,55 @@ cpp_define_lazily (cpp_reader *pfile, cpp_hashnode *node, unsigned num)\n   macro->lazy = num + 1;\n }\n \n+/* NODE is a deferred macro, resolve it, returning the definition\n+   (which may be NULL).  */\n+cpp_macro *\n+cpp_get_deferred_macro (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\tlocation_t loc)\n+{\n+  node->value.macro = pfile->cb.user_deferred_macro (pfile, loc, node);\n+\n+  if (!node->value.macro)\n+    node->type = NT_VOID;\n+\n+  return node->value.macro;\n+}\n+\n+static cpp_macro *\n+get_deferred_or_lazy_macro (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t\t    location_t loc)\n+{\n+  cpp_macro *macro = node->value.macro;\n+  if (!macro)\n+    {\n+      macro = cpp_get_deferred_macro (pfile, node, loc);\n+      if (!macro)\n+\treturn NULL;\n+    }\n+\n+  if (macro->lazy)\n+    {\n+      pfile->cb.user_lazy_macro (pfile, macro, macro->lazy - 1);\n+      macro->lazy = 0;\n+    }\n+\n+  return macro;\n+}\n+\n /* Notify the use of NODE in a macro-aware context (i.e. expanding it,\n    or testing its existance).  Also applies any lazy definition.\n    Return FALSE if the macro isn't really there.  */\n \n-extern void\n+extern bool\n _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n \t\t       location_t loc)\n {\n   node->flags |= NODE_USED;\n   switch (node->type)\n     {\n     case NT_USER_MACRO:\n-      {\n-\tcpp_macro *macro = node->value.macro;\n-\tif (macro->lazy)\n-\t  {\n-\t    pfile->cb.user_lazy_macro (pfile, macro, macro->lazy - 1);\n-\t    macro->lazy = 0;\n-\t  }\n-      }\n+      if (!get_deferred_or_lazy_macro (pfile, node, loc))\n+\treturn false;\n       /* FALLTHROUGH.  */\n \n     case NT_BUILTIN_MACRO:\n@@ -3825,6 +3849,8 @@ _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node,\n     default:\n       abort ();\n     }\n+\n+  return true;\n }\n \n /* Warn if a token in STRING matches one of a function-like MACRO's\n@@ -3877,12 +3903,19 @@ check_trad_stringification (cpp_reader *pfile, const cpp_macro *macro,\n const unsigned char *\n cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n {\n-  unsigned int i, len;\n-  unsigned char *buffer;\n-\n   gcc_checking_assert (cpp_user_macro_p (node));\n \n-  const cpp_macro *macro = node->value.macro;\n+  if (const cpp_macro *macro = get_deferred_or_lazy_macro (pfile, node, 0))\n+    return cpp_macro_definition (pfile, node, macro);\n+  return NULL;\n+}\n+\n+const unsigned char *\n+cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t      const cpp_macro *macro)\n+{\n+  unsigned int i, len;\n+  unsigned char *buffer;\n \n   /* Calculate length.  */\n   len = NODE_LEN (node) * 10 + 2;\t\t/* ' ' and NUL.  */"}]}