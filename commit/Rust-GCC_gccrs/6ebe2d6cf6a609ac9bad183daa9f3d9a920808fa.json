{"sha": "6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmViZTJkNmNmNmE2MDlhYzliYWQxODNkYWE5ZjNkOWE5MjA4MDhmYQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-22T09:55:13Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-22T09:55:13Z"}, "message": "re PR target/50447 ([avr] Better support of AND, OR, XOR and PLUS with constant integers for 16- and 32-bit values)\n\n\tPR target/50447\n\tPR target/50465\n\t* config/avr/avr-protos.h (avr_out_bitop): New prototype.\n\t(avr_popcount_each_byte): New prototype.\n\t* config/avr/avr.c (avr_popcount): New static function.\n\t(avr_popcount_each_byte): New function.\n\t(avr_out_bitop): New function.\n\t(adjust_insn_length): ADJUST_LEN_OUT_BITOP dispatches to\n\tavr_out_bitop.  Cleanup code.\n\t* config/avr/constraints.md (Ca2, Co2, Cx2): New constraints.\n\t(Ca4, Co4, Cx4): New constraints.\n\t* config/avr/avr.md (adjust_len): Add \"out_bitop\" insn attribute\n\talternative.\n\t(andhi3, iorhi3, xorhi3): Rewrite insns using avr_out_bitop.\n\t(andsi3, iorsi3, xorsi3): Ditto.\n\t(*iorhi3_clobber, *iorsi3_clobber): Remove insns.\n\nFrom-SVN: r179081", "tree": {"sha": "770568b4ef21417ee8cb8c1fbb5cbaee1f91f68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/770568b4ef21417ee8cb8c1fbb5cbaee1f91f68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58c1ae3667e753a492bfa224ff9194b9e2ae01ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c1ae3667e753a492bfa224ff9194b9e2ae01ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c1ae3667e753a492bfa224ff9194b9e2ae01ff"}], "stats": {"total": 516, "additions": 336, "deletions": 180}, "files": [{"sha": "973376c65f3d17065820601b6cde2a3e1444033f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "patch": "@@ -1,3 +1,22 @@\n+2011-09-22  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50447\n+\tPR target/50465\n+\t* config/avr/avr-protos.h (avr_out_bitop): New prototype.\n+\t(avr_popcount_each_byte): New prototype.\n+\t* config/avr/avr.c (avr_popcount): New static function.\n+\t(avr_popcount_each_byte): New function.\n+\t(avr_out_bitop): New function.\n+\t(adjust_insn_length): ADJUST_LEN_OUT_BITOP dispatches to\n+\tavr_out_bitop.  Cleanup code.\n+\t* config/avr/constraints.md (Ca2, Co2, Cx2): New constraints.\n+\t(Ca4, Co4, Cx4): New constraints.\n+\t* config/avr/avr.md (adjust_len): Add \"out_bitop\" insn attribute\n+\talternative.\n+\t(andhi3, iorhi3, xorhi3): Rewrite insns using avr_out_bitop.\n+\t(andsi3, iorsi3, xorsi3): Ditto.\n+\t(*iorhi3_clobber, *iorsi3_clobber): Remove insns.\n+\n 2011-09-22  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/50451"}, {"sha": "215fd834c3f9447d68fee0a0182ca0f954fac5fd", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "patch": "@@ -81,6 +81,8 @@ extern int avr_epilogue_uses (int regno);\n extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n+extern const char* avr_out_bitop (rtx, rtx*, int*);\n+extern bool avr_popcount_each_byte (rtx, int, int);\n \n extern int extra_constraint_Q (rtx x);\n extern int adjust_insn_length (rtx insn, int len);"}, {"sha": "9c8b43d9a3735a719f2a4ac2d3bb4f8ea3ee3a4b", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 195, "deletions": 30, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "patch": "@@ -303,6 +303,46 @@ avr_replace_prefix (const char *old_str,\n   return (const char*) new_str;\n }\n \n+\n+/* Custom function to count number of set bits.  */\n+\n+static inline int\n+avr_popcount (unsigned int val)\n+{\n+  int pop = 0;\n+\n+  while (val)\n+    {\n+      val &= val-1;\n+      pop++;\n+    }\n+\n+  return pop;\n+}\n+\n+\n+/* Constraint helper function.  XVAL is an CONST_INT.  Return true if the least\n+   significant N_BYTES bytes of XVAL all have a popcount in POP_MASK and false,\n+   otherwise.  POP_MASK represents a subset of integers which contains an\n+   integer N iff bit N of POP_MASK is set.  */\n+   \n+bool\n+avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n+{\n+  int i;\n+\n+  for (i = 0; i < n_bytes; i++)\n+    {\n+      rtx xval8 = simplify_gen_subreg (QImode, xval, SImode, i);\n+      unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n+\n+      if (0 == (pop_mask & (1 << avr_popcount (val8))))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n static void\n avr_option_override (void)\n {\n@@ -4462,6 +4502,157 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n   return \"\";\n }\n \n+\n+/* Output bit operation (IOR, AND, XOR) with register XOP[0] and compile\n+   time constant XOP[2]:\n+\n+      XOP[0] = XOP[0] <op> XOP[2]\n+\n+   and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n+   operation; otherwise, set *PLEN to the length of the instruction sequence\n+   (in words) printed with PLEN == NULL.  XOP[3] is either an 8-bit clobber\n+   register or SCRATCH if no clobber register is needed for the operation.  */\n+\n+const char*\n+avr_out_bitop (rtx insn, rtx *xop, int *plen)\n+{\n+  /* CODE and MODE of the operation.  */\n+  enum rtx_code code = GET_CODE (SET_SRC (single_set (insn)));\n+  enum machine_mode mode = GET_MODE (xop[0]);\n+\n+  /* Number of bytes to operate on.  */\n+  int i, n_bytes = GET_MODE_SIZE (mode);\n+\n+  /* Value of T-flag (0 or 1) or -1 if unknow.  */\n+  int set_t = -1;\n+\n+  /* Value (0..0xff) held in clobber register op[3] or -1 if unknown.  */\n+  int clobber_val = -1;\n+\n+  /* op[0]: 8-bit destination register\n+     op[1]: 8-bit const int\n+     op[2]: 8-bit clobber register or SCRATCH\n+     op[3]: 8-bit register containing 0xff or NULL_RTX  */\n+  rtx op[4];\n+\n+  op[2] = xop[3];\n+  op[3] = NULL_RTX;\n+\n+  if (plen)\n+    *plen = 0;\n+\n+  for (i = 0; i < n_bytes; i++)\n+    {\n+      /* We operate byte-wise on the destination.  */\n+      rtx reg8 = simplify_gen_subreg (QImode, xop[0], mode, i);\n+      rtx xval8 = simplify_gen_subreg (QImode, xop[2], mode, i);\n+\n+      /* 8-bit value to operate with this byte. */\n+      unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n+\n+      /* Number of bits set in the current byte of the constant.  */\n+      int pop8 = avr_popcount (val8);\n+\n+      /* Registers R16..R31 can operate with immediate.  */\n+      bool ld_reg_p = test_hard_reg_class (LD_REGS, reg8);\n+\n+      op[0] = reg8;\n+      op[1] = GEN_INT (val8);\n+    \n+      switch (code)\n+        {\n+        case IOR:\n+\n+          if (0 == pop8)\n+            continue;\n+          else if (ld_reg_p)\n+            avr_asm_len (\"ori %0,%1\", op, plen, 1);\n+          else if (1 == pop8)\n+            {\n+              if (set_t != 1)\n+                avr_asm_len (\"set\", op, plen, 1);\n+              set_t = 1;\n+              \n+              op[1] = GEN_INT (exact_log2 (val8));\n+              avr_asm_len (\"bld %0,%1\", op, plen, 1);\n+            }\n+          else if (8 == pop8)\n+            {\n+              if (op[3] != NULL_RTX)\n+                avr_asm_len (\"mov %0,%3\", op, plen, 1);\n+              else\n+                avr_asm_len (\"clr %0\" CR_TAB\n+                             \"dec %0\", op, plen, 2);\n+\n+              op[3] = op[0];\n+            }\n+          else\n+            {\n+              if (clobber_val != (int) val8)\n+                avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n+              clobber_val = (int) val8;\n+              \n+              avr_asm_len (\"or %0,%2\", op, plen, 1);\n+            }\n+\n+          continue; /* IOR */\n+\n+        case AND:\n+\n+          if (8 == pop8)\n+            continue;\n+          else if (0 == pop8)\n+            avr_asm_len (\"clr %0\", op, plen, 1);\n+          else if (ld_reg_p)\n+            avr_asm_len (\"andi %0,%1\", op, plen, 1);\n+          else if (7 == pop8)\n+            {\n+              if (set_t != 0)\n+                avr_asm_len (\"clt\", op, plen, 1);\n+              set_t = 0;\n+              \n+              op[1] = GEN_INT (exact_log2 (GET_MODE_MASK (QImode) & ~val8));\n+              avr_asm_len (\"bld %0,%1\", op, plen, 1);\n+            }\n+          else\n+            {\n+              if (clobber_val != (int) val8)\n+                avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n+              clobber_val = (int) val8;\n+              \n+              avr_asm_len (\"and %0,%2\", op, plen, 1);\n+            }\n+\n+          continue; /* AND */\n+          \n+        case XOR:\n+\n+          if (0 == pop8)\n+            continue;\n+          else if (8 == pop8)\n+            avr_asm_len (\"com %0\", op, plen, 1);\n+          else if (ld_reg_p && val8 == (1 << 7))\n+            avr_asm_len (\"subi %0,%1\", op, plen, 1);\n+          else\n+            {\n+              if (clobber_val != (int) val8)\n+                avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n+              clobber_val = (int) val8;\n+              \n+              avr_asm_len (\"eor %0,%2\", op, plen, 1);\n+            }\n+\n+          continue; /* XOR */\n+          \n+        default:\n+          /* Unknown rtx_code */\n+          gcc_unreachable();\n+        }\n+    } /* for all sub-bytes */\n+\n+  return \"\";\n+}\n+\n /* Create RTL split patterns for byte sized rotate expressions.  This\n   produces a series of move instructions and considers overlap situations.\n   Overlapping non-HImode operands need a scratch register.  */\n@@ -4656,6 +4847,10 @@ adjust_insn_length (rtx insn, int len)\n           output_reload_insisf (insn, op, op[2], &len);\n           break;\n           \n+        case ADJUST_LEN_OUT_BITOP:\n+          avr_out_bitop (insn, op, &len);\n+          break;\n+\n         default:\n           gcc_unreachable();\n         }\n@@ -4700,36 +4895,6 @@ adjust_insn_length (rtx insn, int len)\n \t    default: break;\n \t    }\n \t}\n-      else if (GET_CODE (op[1]) == AND)\n-\t{\n-\t  if (GET_CODE (XEXP (op[1],1)) == CONST_INT)\n-\t    {\n-\t      HOST_WIDE_INT mask = INTVAL (XEXP (op[1],1));\n-\t      if (GET_MODE (op[1]) == SImode)\n-\t\tlen = (((mask & 0xff) != 0xff)\n-\t\t       + ((mask & 0xff00) != 0xff00)\n-\t\t       + ((mask & 0xff0000L) != 0xff0000L)\n-\t\t       + ((mask & 0xff000000L) != 0xff000000L));\n-\t      else if (GET_MODE (op[1]) == HImode)\n-\t\tlen = (((mask & 0xff) != 0xff)\n-\t\t       + ((mask & 0xff00) != 0xff00));\n-\t    }\n-\t}\n-      else if (GET_CODE (op[1]) == IOR)\n-\t{\n-\t  if (GET_CODE (XEXP (op[1],1)) == CONST_INT)\n-\t    {\n-\t      HOST_WIDE_INT mask = INTVAL (XEXP (op[1],1));\n-\t      if (GET_MODE (op[1]) == SImode)\n-\t\tlen = (((mask & 0xff) != 0)\n-\t\t       + ((mask & 0xff00) != 0)\n-\t\t       + ((mask & 0xff0000L) != 0)\n-\t\t       + ((mask & 0xff000000L) != 0));\n-\t      else if (GET_MODE (op[1]) == HImode)\n-\t\tlen = (((mask & 0xff) != 0)\n-\t\t       + ((mask & 0xff00) != 0));\n-\t    }\n-\t}\n     }\n   set = single_set (insn);\n   if (set)"}, {"sha": "ab17104453e8c1ab750e1396f84b692f153945b8", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 90, "deletions": 150, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "patch": "@@ -136,7 +136,7 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"yes,no,reload_in32\"\n+  \"yes,no,reload_in32,out_bitop\"\n   (const_string \"yes\"))\n \n ;; Define mode iterators\n@@ -2238,71 +2238,41 @@\n    (set_attr \"cc\" \"set_zn,set_zn\")])\n \n (define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,d,r\")\n-\t  (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n-\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,i,M\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n+  [(set (match_operand:HI 0 \"register_operand\"         \"=r,d,d,r  ,r\")\n+        (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0  ,0\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"r,s,n,Ca2,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X,X,X  ,&d\"))]\n   \"\"\n-{\n-  if (which_alternative==0)\n-    return (\"and %A0,%A2\" CR_TAB\n-\t    \"and %B0,%B2\");\n-  else if (which_alternative==1)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-        {\n-\t  int mask = INTVAL (operands[2]);\n-\t  if ((mask & 0xff) != 0xff)\n-\t    output_asm_insn (AS2 (andi,%A0,lo8(%2)), operands);\n-\t  if ((mask & 0xff00) != 0xff00)\n-\t    output_asm_insn (AS2 (andi,%B0,hi8(%2)), operands);\n-\t  return \"\";\n-        }\n-        return (AS2 (andi,%A0,lo8(%2)) CR_TAB\n-\t        AS2 (andi,%B0,hi8(%2)));\n-     }\n-  return (AS2 (ldi,%3,lo8(%2)) CR_TAB\n-          \"and %A0,%3\"         CR_TAB\n-          AS1 (clr,%B0));\n-}\n-  [(set_attr \"length\" \"2,2,3\")\n-   (set_attr \"cc\" \"set_n,clobber,set_n\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"and %A0,%A2\\;and %B0,%B2\";\n+    else if (which_alternative == 1)\n+      return \"andi %A0,lo8(%2)\\;andi %B0,hi8(%2)\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"2,2,2,4,4\")\n+   (set_attr \"adjust_len\" \"no,no,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,set_n,clobber,clobber,clobber\")])\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,d,r  ,r\")\n+        (and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0  ,0\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"r,n,Ca4,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X,X  ,&d\"))]\n   \"\"\n-{\n-  if (which_alternative==0)\n-    return (\"and %0,%2\"   CR_TAB\n-            \"and %B0,%B2\" CR_TAB\n-            \"and %C0,%C2\" CR_TAB\n-            \"and %D0,%D2\");\n-  else if (which_alternative==1)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-        {\n-\t  HOST_WIDE_INT mask = INTVAL (operands[2]);\n-\t  if ((mask & 0xff) != 0xff)\n-\t    output_asm_insn (AS2 (andi,%A0,lo8(%2)), operands);\n-\t  if ((mask & 0xff00) != 0xff00)\n-\t    output_asm_insn (AS2 (andi,%B0,hi8(%2)), operands);\n-\t  if ((mask & 0xff0000L) != 0xff0000L)\n-\t    output_asm_insn (AS2 (andi,%C0,hlo8(%2)), operands);\n-\t  if ((mask & 0xff000000L) != 0xff000000L)\n-\t    output_asm_insn (AS2 (andi,%D0,hhi8(%2)), operands);\n-\t  return \"\";\n-        }\n-      return (AS2 (andi, %A0,lo8(%2))  CR_TAB\n-              AS2 (andi, %B0,hi8(%2)) CR_TAB\n-\t      AS2 (andi, %C0,hlo8(%2)) CR_TAB\n-\t      AS2 (andi, %D0,hhi8(%2)));\n-    }\n-  return \"bug\";\n-}\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"cc\" \"set_n,clobber\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"and %0,%2\"   CR_TAB\n+             \"and %B0,%B2\" CR_TAB\n+             \"and %C0,%C2\" CR_TAB\n+             \"and %D0,%D2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"4,4,8,8\")\n+   (set_attr \"adjust_len\" \"no,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber,clobber\")])\n \n (define_peephole2 ; andi\n   [(set (match_operand:QI 0 \"d_register_operand\" \"\")\n@@ -2332,84 +2302,41 @@\n    (set_attr \"cc\" \"set_zn,set_zn\")])\n \n (define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,d\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"r,i\")))]\n+  [(set (match_operand:HI 0 \"register_operand\"         \"=r,d,d,r  ,r\")\n+        (ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0  ,0\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"r,s,n,Co2,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X,X,X  ,&d\"))]\n   \"\"\n-{\n-  if (which_alternative==0)\n-    return (\"or %A0,%A2\" CR_TAB\n-\t    \"or %B0,%B2\");\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-     {\n-\tint mask = INTVAL (operands[2]);\n-\tif (mask & 0xff)\n-\t  output_asm_insn (AS2 (ori,%A0,lo8(%2)), operands);\n-\tif (mask & 0xff00)\n-\t  output_asm_insn (AS2 (ori,%B0,hi8(%2)), operands);\n-\treturn \"\";\n-      }\n-   return (AS2 (ori,%0,lo8(%2)) CR_TAB\n-\t   AS2 (ori,%B0,hi8(%2)));\n-}\n-  [(set_attr \"length\" \"2,2\")\n-   (set_attr \"cc\" \"set_n,clobber\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"or %A0,%A2\\;or %B0,%B2\";\n+    else if (which_alternative == 1)\n+      return \"ori %A0,lo8(%2)\\;ori %B0,hi8(%2)\";\n \n-(define_insn \"*iorhi3_clobber\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"immediate_operand\" \"M,i\")))\n-   (clobber (match_scratch:QI 3 \"=&d,&d\"))]\n-  \"\"\n-  \"@\n-\tldi %3,lo8(%2)\\;or %A0,%3\n-\tldi %3,lo8(%2)\\;or %A0,%3\\;ldi %3,hi8(%2)\\;or %B0,%3\"\n-  [(set_attr \"length\" \"2,4\")\n-   (set_attr \"cc\" \"clobber,set_n\")])\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"2,2,2,4,4\")\n+   (set_attr \"adjust_len\" \"no,no,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,set_n,clobber,clobber,clobber\")])\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"        \"=r,d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,d,r  ,r\")\n+        (ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0  ,0\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"r,n,Co4,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X,X  ,&d\"))]\n   \"\"\n-{\n-  if (which_alternative==0)\n-    return (\"or %0,%2\"   CR_TAB\n-\t    \"or %B0,%B2\" CR_TAB\n-\t    \"or %C0,%C2\" CR_TAB\n-\t    \"or %D0,%D2\");\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-     {\n-\tHOST_WIDE_INT mask = INTVAL (operands[2]);\n-\tif (mask & 0xff)\n-\t  output_asm_insn (AS2 (ori,%A0,lo8(%2)), operands);\n-\tif (mask & 0xff00)\n-\t  output_asm_insn (AS2 (ori,%B0,hi8(%2)), operands);\n-\tif (mask & 0xff0000L)\n-\t  output_asm_insn (AS2 (ori,%C0,hlo8(%2)), operands);\n-\tif (mask & 0xff000000L)\n-\t  output_asm_insn (AS2 (ori,%D0,hhi8(%2)), operands);\n-\treturn \"\";\n-      }\n-  return (AS2 (ori, %A0,lo8(%2))  CR_TAB\n-\t  AS2 (ori, %B0,hi8(%2)) CR_TAB\n-\t  AS2 (ori, %C0,hlo8(%2)) CR_TAB\n-\t  AS2 (ori, %D0,hhi8(%2)));\n-}\n-  [(set_attr \"length\" \"4,4\")\n-   (set_attr \"cc\" \"set_n,clobber\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"or %0,%2\"   CR_TAB\n+             \"or %B0,%B2\" CR_TAB\n+             \"or %C0,%C2\" CR_TAB\n+             \"or %D0,%D2\";\n \n-(define_insn \"*iorsi3_clobber\"\n-  [(set (match_operand:SI 0 \"register_operand\"        \"=r,r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"immediate_operand\" \"M,i\")))\n-   (clobber (match_scratch:QI 3 \"=&d,&d\"))]\n-  \"\"\n-  \"@\n-\tldi %3,lo8(%2)\\;or %A0,%3\n-\tldi %3,lo8(%2)\\;or %A0,%3\\;ldi %3,hi8(%2)\\;or %B0,%3\\;ldi %3,hlo8(%2)\\;or %C0,%3\\;ldi %3,hhi8(%2)\\;or %D0,%3\"\n-  [(set_attr \"length\" \"2,8\")\n-   (set_attr \"cc\" \"clobber,set_n\")])\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"4,4,8,8\")\n+   (set_attr \"adjust_len\" \"no,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber,clobber\")])\n \n ;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ;; xor\n@@ -2424,26 +2351,39 @@\n    (set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (xor:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n-                (match_operand:HI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:HI 0 \"register_operand\"         \"=r,r  ,r\")\n+        (xor:HI (match_operand:HI 1 \"register_operand\" \"%0,0  ,0\")\n+                (match_operand:HI 2 \"nonmemory_operand\" \"r,Cx2,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X  ,&d\"))]\n   \"\"\n-  \"eor %0,%2\n-\teor %B0,%B2\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_n\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"eor %A0,%A2\\;eor %B0,%B2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"2,2,4\")\n+   (set_attr \"adjust_len\" \"no,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber\")])\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-                (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"         \"=r,r  ,r\")\n+        (xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0  ,0\")\n+                (match_operand:SI 2 \"nonmemory_operand\" \"r,Cx4,n\")))\n+   (clobber (match_scratch:QI 3                        \"=X,X  ,&d\"))]\n   \"\"\n-  \"eor %0,%2\n-\teor %B0,%B2\n-\teor %C0,%C2\n-\teor %D0,%D2\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_n\")])\n+  {\n+    if (which_alternative == 0)\n+      return \"eor %0,%2\"   CR_TAB\n+             \"eor %B0,%B2\" CR_TAB\n+             \"eor %C0,%C2\" CR_TAB\n+             \"eor %D0,%D2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"4,8,8\")\n+   (set_attr \"adjust_len\" \"no,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber\")])\n \n ;; swap swap swap swap swap swap swap swap swap swap swap swap swap swap swap\n ;; swap"}, {"sha": "d6c172f86e29a46dd1619e9764d836ef97b4b66b", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=6ebe2d6cf6a609ac9bad183daa9f3d9a920808fa", "patch": "@@ -112,3 +112,33 @@\n   \"Constant integer 4.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival == 4\")))\n+\n+(define_constraint \"Ca2\"\n+  \"Constant 2-byte integer that allows AND without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<7) | (1<<8))\")))\n+\n+(define_constraint \"Ca4\"\n+  \"Constant 4-byte integer that allows AND without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 4, (1<<0) | (1<<7) | (1<<8))\")))\n+\n+(define_constraint \"Co2\"\n+  \"Constant 2-byte integer that allows OR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<1) | (1<<8))\")))\n+\n+(define_constraint \"Co4\"\n+  \"Constant 4-byte integer that allows OR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 4, (1<<0) | (1<<1) | (1<<8))\")))\n+\n+(define_constraint \"Cx2\"\n+  \"Constant 2-byte integer that allows XOR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<8))\")))\n+\n+(define_constraint \"Cx4\"\n+  \"Constant 4-byte integer that allows XOR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 4, (1<<0) | (1<<8))\")))"}]}