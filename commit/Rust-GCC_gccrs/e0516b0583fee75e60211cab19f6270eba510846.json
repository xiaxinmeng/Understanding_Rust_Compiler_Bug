{"sha": "e0516b0583fee75e60211cab19f6270eba510846", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA1MTZiMDU4M2ZlZTc1ZTYwMjExY2FiMTlmNjI3MGViYTUxMDg0Ng==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-11-29T09:57:40Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-11-29T09:57:40Z"}, "message": "re PR fortran/51306 (MOVE_ALLOC: Make more middle end friendlier)\n\n2011-11-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/51306\n        PR fortran/48700\n        * check.c (gfc_check_move_alloc): Make sure that from/to\n        are both polymorphic or neither.\n        * trans-intrinsic.c (conv_intrinsic_move_alloc): Cleanup,\n        generate inline code.\n\n2011-11-29  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/51306\n        PR fortran/48700\n        * gfortran.dg/move_alloc_5.f90: Add dg-error.\n        * gfortran.dg/select_type_23.f03: Add dg-error.\n        * gfortran.dg/move_alloc_6.f90: New.\n        * gfortran.dg/move_alloc_7.f90: New.\n\nFrom-SVN: r181801", "tree": {"sha": "93cae4dfa48822ec55cc80035cf832c0303452b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93cae4dfa48822ec55cc80035cf832c0303452b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0516b0583fee75e60211cab19f6270eba510846", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0516b0583fee75e60211cab19f6270eba510846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0516b0583fee75e60211cab19f6270eba510846", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0516b0583fee75e60211cab19f6270eba510846/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "825298c450a51d78c311e1b629c520aa3f1688a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825298c450a51d78c311e1b629c520aa3f1688a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825298c450a51d78c311e1b629c520aa3f1688a6"}], "stats": {"total": 274, "additions": 236, "deletions": 38}, "files": [{"sha": "280c35e43312767ba3893142d02087454f73e30e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -1,3 +1,12 @@\n+2011-11-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/51306\n+\tPR fortran/48700\n+\t* check.c (gfc_check_move_alloc): Make sure that from/to\n+\tare both polymorphic or neither.\n+\t* trans-intrinsic.c (conv_intrinsic_move_alloc): Cleanup,\n+\tgenerate inline code.\n+\n 2011-11-28  Tobias Burnus  <burnus@net-b.de>\n \t    Steven G. Kargl  <kargl@gcc.gnu.org>\n "}, {"sha": "832eb6486ec1ceb07e562cd62fbb6a0be15f6fde", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -2691,6 +2691,14 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n   if (same_type_check (to, 1, from, 0) == FAILURE)\n     return FAILURE;\n \n+  if (to->ts.type != from->ts.type)\n+    {\n+      gfc_error (\"The FROM and TO arguments in MOVE_ALLOC call at %L must be \"\n+\t\t \"either both polymorphic or both nonpolymorphic\",\n+\t\t &from->where);\n+      return FAILURE;\n+    }\n+\n   if (to->rank != from->rank)\n     {\n       gfc_error (\"the '%s' and '%s' arguments of '%s' intrinsic at %L must \""}, {"sha": "d055275614ba2cad764440952851844155a1d5ce", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 108, "deletions": 35, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -5892,7 +5892,7 @@ gfc_conv_intrinsic_si_kind (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Generate code for SELECTED_REAL_KIND (P, R) intrinsic function.  */\n+/* Generate code for SELECTED_REAL_KIND (P, R, RADIX) intrinsic function.  */\n \n static void\n gfc_conv_intrinsic_sr_kind (gfc_se *se, gfc_expr *expr)\n@@ -7182,50 +7182,123 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n static tree\n conv_intrinsic_move_alloc (gfc_code *code)\n {\n-  if (code->ext.actual->expr->rank == 0)\n-    {\n-      /* Scalar arguments: Generate pointer assignments.  */\n-      gfc_expr *from, *to, *deal;\n-      stmtblock_t block;\n-      tree tmp;\n-      gfc_se se;\n+  stmtblock_t block;\n+  gfc_expr *from_expr, *to_expr;\n+  gfc_expr *to_expr2, *from_expr2;\n+  gfc_se from_se, to_se;\n+  gfc_ss *from_ss, *to_ss;\n+  tree tmp;\n \n-      from = code->ext.actual->expr;\n-      to = code->ext.actual->next->expr;\n+  gfc_start_block (&block);\n \n-      gfc_start_block (&block);\n+  from_expr = code->ext.actual->expr;\n+  to_expr = code->ext.actual->next->expr;\n \n-      /* Deallocate 'TO' argument.  */\n-      gfc_init_se (&se, NULL);\n-      se.want_pointer = 1;\n-      deal = gfc_copy_expr (to);\n-      if (deal->ts.type == BT_CLASS)\n-\tgfc_add_data_component (deal);\n-      gfc_conv_expr (&se, deal);\n-      tmp = gfc_deallocate_scalar_with_status (se.expr, NULL, true,\n-\t\t\t\t\t       deal, deal->ts);\n-      gfc_add_expr_to_block (&block, tmp);\n-      gfc_free_expr (deal);\n+  gfc_init_se (&from_se, NULL);\n+  gfc_init_se (&to_se, NULL);\n \n-      if (to->ts.type == BT_CLASS)\n-\ttmp = gfc_trans_class_assign (to, from, EXEC_POINTER_ASSIGN);\n+  if (from_expr->rank == 0)\n+    {\n+      if (from_expr->ts.type != BT_CLASS)\n+\t{\n+\t  from_expr2 = to_expr;\n+\t  to_expr2 = to_expr;\n+\t}\n       else\n-\ttmp = gfc_trans_pointer_assignment (to, from);\n-      gfc_add_expr_to_block (&block, tmp);\n+\t{\n+\t  to_expr2 = gfc_copy_expr (to_expr);\n+\t  from_expr2 = gfc_copy_expr (from_expr);\n+\t  gfc_add_data_component (from_expr2);\n+\t  gfc_add_data_component (to_expr2);\n+\t}\n \n-      if (from->ts.type == BT_CLASS)\n-\ttmp = gfc_trans_class_assign (from, gfc_get_null_expr (NULL),\n-\t\t\t\t      EXEC_POINTER_ASSIGN);\n-      else\n-\ttmp = gfc_trans_pointer_assignment (from,\n-\t\t\t\t\t    gfc_get_null_expr (NULL));\n+      from_se.want_pointer = 1;\n+      to_se.want_pointer = 1;\n+      gfc_conv_expr (&from_se, from_expr2);\n+      gfc_conv_expr (&to_se, to_expr2);\n+      gfc_add_block_to_block (&block, &from_se.pre);\n+      gfc_add_block_to_block (&block, &to_se.pre);\n+\n+      /* Deallocate \"to\".  */\n+      tmp = gfc_deallocate_scalar_with_status (to_se.expr, NULL_TREE, true,\n+\t\t\t\t\t       to_expr2, to_expr->ts);\n       gfc_add_expr_to_block (&block, tmp);\n \n+      /* Assign (_data) pointers.  */\n+      gfc_add_modify_loc (input_location, &block, to_se.expr,\n+\t\t\t  fold_convert (TREE_TYPE (to_se.expr), from_se.expr));\n+\n+      /* Set \"from\" to NULL.  */\n+      gfc_add_modify_loc (input_location, &block, from_se.expr,\n+\t\t\t  fold_convert (TREE_TYPE (from_se.expr), null_pointer_node));\n+\n+      gfc_add_block_to_block (&block, &from_se.post);\n+      gfc_add_block_to_block (&block, &to_se.post);\n+\n+      /* Set _vptr.  */\n+      if (from_expr->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_free_expr (from_expr2);\n+          gfc_free_expr (to_expr2);\n+\n+\t  gfc_init_se (&from_se, NULL);\n+\t  gfc_init_se (&to_se, NULL);\n+\t  from_se.want_pointer = 1;\n+\t  to_se.want_pointer = 1;\n+\t  gfc_add_vptr_component (from_expr);\n+\t  gfc_add_vptr_component (to_expr);\n+\n+\t  gfc_conv_expr (&from_se, from_expr);\n+\t  gfc_conv_expr (&to_se, to_expr);\n+\t  gfc_add_modify_loc (input_location, &block, to_se.expr,\n+\t\t\t      fold_convert (TREE_TYPE (to_se.expr), from_se.expr));\n+\t}\n+\n       return gfc_finish_block (&block);\n     }\n-  else\n-    /* Array arguments: Generate library code.  */\n-    return gfc_trans_call (code, false, NULL_TREE, NULL_TREE, false);\n+\n+  /* Update _vptr component.  */\n+  if (from_expr->ts.type == BT_CLASS)\n+    {\n+      from_se.want_pointer = 1;\n+      to_se.want_pointer = 1;\n+\n+      from_expr2 = gfc_copy_expr (from_expr);\n+      to_expr2 = gfc_copy_expr (to_expr);\n+      gfc_add_vptr_component (from_expr2);\n+      gfc_add_vptr_component (to_expr2);\n+\n+      gfc_conv_expr (&from_se, from_expr2);\n+      gfc_conv_expr (&to_se, to_expr2);\n+\n+      gfc_add_modify_loc (input_location, &block, to_se.expr,\n+\t\t\t  fold_convert (TREE_TYPE (to_se.expr), from_se.expr));\n+      gfc_free_expr (to_expr2);\n+      gfc_free_expr (from_expr2);\n+\n+      gfc_init_se (&from_se, NULL);\n+      gfc_init_se (&to_se, NULL);\n+    }\n+\n+  /* Deallocate \"to\".  */\n+  to_ss = gfc_walk_expr (to_expr);\n+  from_ss = gfc_walk_expr (from_expr);\n+  gfc_conv_expr_descriptor (&to_se, to_expr, to_ss);\n+  gfc_conv_expr_descriptor (&from_se, from_expr, from_ss);\n+\n+  tmp = gfc_conv_descriptor_data_get (to_se.expr);\n+  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, true, to_expr);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  /* Move the pointer and update the array descriptor data.  */\n+  gfc_add_modify_loc (input_location, &block, to_se.expr, from_se.expr);\n+\n+  /* Set \"to\" to NULL.  */\n+  tmp = gfc_conv_descriptor_data_get (from_se.expr);\n+  gfc_add_modify_loc (input_location, &block, tmp,\n+\t\t      fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+\n+  return gfc_finish_block (&block);\n }\n \n "}, {"sha": "246823cd2a5c7e3e6615724fded79a41688689b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -1,3 +1,12 @@\n+2011-11-29  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/51306\n+\tPR fortran/48700\n+\t* gfortran.dg/move_alloc_5.f90: Add dg-error.\n+\t* gfortran.dg/select_type_23.f03: Add dg-error.\n+\t* gfortran.dg/move_alloc_6.f90: New.\n+\t* gfortran.dg/move_alloc_7.f90: New.\n+\n 2011-11-29  Ira Rosen  <ira.rosen@linaro.org>\n \n \tPR tree-optimization/51301"}, {"sha": "7663275263efad88790355ea16ddf903e895612a", "filename": "gcc/testsuite/gfortran.dg/move_alloc_5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_5.f90?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -1,4 +1,4 @@\n-! { dg-do run }\n+! { dg-do compile }\n !\n ! PR 48699: [4.6/4.7 Regression] [OOP] MOVE_ALLOC inside SELECT TYPE\n !\n@@ -16,7 +16,7 @@ program testmv1\n   type(bar2), allocatable :: sm2\n \n   allocate (sm2)\n-  call move_alloc (sm2,sm)\n+  call move_alloc (sm2,sm) ! { dg-error \"must be either both polymorphic or both nonpolymorphic\" }\n \n   if (allocated(sm2)) call abort()\n   if (.not. allocated(sm)) call abort()"}, {"sha": "b62a023a9eabb60b502193d6cfc2981852b28c83", "filename": "gcc/testsuite/gfortran.dg/move_alloc_6.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_6.f90?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+!\n+! Test move_alloc for polymorphic scalars\n+!\n+!\n+module myalloc\n+  implicit none\n+\n+  type :: base_type\n+     integer :: i  =2\n+  end type base_type\n+\n+  type, extends(base_type) :: extended_type\n+     integer :: j = 77\n+  end type extended_type\n+contains\n+  subroutine myallocate (a)\n+    class(base_type), allocatable, intent(inout) :: a\n+    class(base_type), allocatable :: tmp\n+\n+    allocate (extended_type :: tmp)\n+\n+    select type(tmp)\n+      type is(base_type)\n+        call abort ()\n+      type is(extended_type)\n+        if (tmp%i /= 2 .or. tmp%j /= 77) call abort()\n+        tmp%i = 5\n+        tmp%j = 88\n+    end select\n+\n+    select type(a)\n+      type is(base_type)\n+        if (a%i /= -44) call abort()\n+        a%i = -99\n+      class default\n+        call abort ()\n+    end select\n+\n+    call move_alloc (from=tmp, to=a)\n+\n+    select type(a)\n+      type is(extended_type)\n+        if (a%i /= 5) call abort()\n+        if (a%j /= 88) call abort()\n+        a%i = 123\n+        a%j = 9498\n+      class default\n+        call abort ()\n+    end select\n+\n+    if (allocated (tmp)) call abort()\n+  end subroutine myallocate\n+end module myalloc\n+\n+program main\n+  use myalloc\n+  implicit none\n+  class(base_type), allocatable :: a\n+\n+  allocate (a)\n+\n+  select type(a)\n+    type is(base_type)\n+      if (a%i /= 2) call abort()\n+      a%i = -44\n+    class default\n+      call abort ()\n+  end select\n+\n+  call myallocate (a)\n+\n+  select type(a)\n+    type is(extended_type)\n+      if (a%i /= 123) call abort()\n+      if (a%j /= 9498) call abort()\n+    class default\n+      call abort ()\n+  end select\n+end program main"}, {"sha": "d2bc82c7ca0fa41cac732ed1ea203bed161ca00b", "filename": "gcc/testsuite/gfortran.dg/move_alloc_7.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmove_alloc_7.f90?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+!\n+! Check that move alloc handles different, type compatible\n+! declared types\n+!\n+type t\n+end type t\n+type, extends(t) :: t2\n+end type t2\n+\n+class(t), allocatable :: x\n+class(t2), allocatable :: y\n+allocate(y)\n+call move_alloc (y, x)\n+end"}, {"sha": "2479f1d144d2762e0a5f63ae461b68a70bafc26a", "filename": "gcc/testsuite/gfortran.dg/select_type_23.f03", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_23.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0516b0583fee75e60211cab19f6270eba510846/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_23.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_23.f03?ref=e0516b0583fee75e60211cab19f6270eba510846", "patch": "@@ -3,6 +3,10 @@\n ! PR 48699: [OOP] MOVE_ALLOC inside SELECT TYPE\n !\n ! Contributed by Salvatore Filippone <sfilippone@uniroma2.it>\n+!\n+! Note that per Fortran 2008, 8.1.9.2, \"within the block following\n+! a TYPE IS type guard statement, the associating entity (16.5.5) is not polymorphic\"\n+!\n \n program testmv2\n \n@@ -16,7 +20,7 @@ program testmv2\n \n   select type(sm2) \n   type is (bar)\n-    call move_alloc(sm2,sm)\n+    call move_alloc(sm2,sm) ! { dg-error \"must be either both polymorphic or both nonpolymorphic\" }\n   end select\n \n end program testmv2"}]}