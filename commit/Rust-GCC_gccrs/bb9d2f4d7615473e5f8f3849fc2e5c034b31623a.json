{"sha": "bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5ZDJmNGQ3NjE1NDczZTVmOGYzODQ5ZmMyZTVjMDM0YjMxNjIzYQ==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-08-20T12:12:06Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-08-20T12:12:06Z"}, "message": "tree-vrp.c (vrp_visit_assignment_or_call): Changed to Return VR.\n\ngcc/ChangeLog:\n\n2016-08-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* tree-vrp.c (vrp_visit_assignment_or_call): Changed to Return VR.\n\t(vrp_visit_cond_stmt): Just sets TAKEN_EDGE_P.\n\t(vrp_visit_switch_stmt): Likewise.\n\t(extract_range_from_stmt): Factored out from vrp_visit_stmt.\n\t(extract_range_from_phi_node): Factored out from vrp_visit_phi_stmt.\n\t(vrp_visit_stmt): Use extract_range_from_stmt.\n\t(vrp_visit_phi_node): Use extract_range_from_phi_node.\n\nFrom-SVN: r239639", "tree": {"sha": "742fb51214fbcc2b4279524064ed38f840b6431a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/742fb51214fbcc2b4279524064ed38f840b6431a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a/comments", "author": null, "committer": null, "parents": [{"sha": "f90aa46c0f97bb69a4d6004f74f6fbcb7818431d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90aa46c0f97bb69a4d6004f74f6fbcb7818431d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90aa46c0f97bb69a4d6004f74f6fbcb7818431d"}], "stats": {"total": 345, "additions": 185, "deletions": 160}, "files": [{"sha": "2c27cb55fc9b518d0a0d3ce5f947c94e8dd52bb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "patch": "@@ -1,3 +1,13 @@\n+2016-08-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* tree-vrp.c (vrp_visit_assignment_or_call): Changed to Return VR.\n+\t(vrp_visit_cond_stmt): Just sets TAKEN_EDGE_P.\n+\t(vrp_visit_switch_stmt): Likewise.\n+\t(extract_range_from_stmt): Factored out from vrp_visit_stmt.\n+\t(extract_range_from_phi_node): Factored out from vrp_visit_phi_stmt.\n+\t(vrp_visit_stmt): Use extract_range_from_stmt.\n+\t(vrp_visit_phi_node): Use extract_range_from_phi_node.\n+\n 2016-08-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* Makefile.in: Add tree-vrp.h to GTFILES."}, {"sha": "86f2a8ff3d3cd5093518123fa232004e8c1ba9bd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 175, "deletions": 160, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9d2f4d7615473e5f8f3849fc2e5c034b31623a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=bb9d2f4d7615473e5f8f3849fc2e5c034b31623a", "patch": "@@ -7044,15 +7044,15 @@ vrp_valueize_1 (tree name)\n }\n \n /* Visit assignment STMT.  If it produces an interesting range, record\n-   the SSA name in *OUTPUT_P.  */\n+   the range in VR and set LHS to OUTPUT_P.  */\n \n-static enum ssa_prop_result\n-vrp_visit_assignment_or_call (gimple *stmt, tree *output_p)\n+static void\n+vrp_visit_assignment_or_call (gimple *stmt, tree *output_p, value_range *vr)\n {\n-  tree def, lhs;\n-  ssa_op_iter iter;\n+  tree lhs;\n   enum gimple_code code = gimple_code (stmt);\n   lhs = gimple_get_lhs (stmt);\n+  *output_p = NULL_TREE;\n \n   /* We only keep track of ranges in integral and pointer types.  */\n   if (TREE_CODE (lhs) == SSA_NAME\n@@ -7063,114 +7063,18 @@ vrp_visit_assignment_or_call (gimple *stmt, tree *output_p)\n \t   && TYPE_MAX_VALUE (TREE_TYPE (lhs)))\n \t  || POINTER_TYPE_P (TREE_TYPE (lhs))))\n     {\n-      value_range new_vr = VR_INITIALIZER;\n-\n       /* Try folding the statement to a constant first.  */\n       tree tem = gimple_fold_stmt_to_constant_1 (stmt, vrp_valueize,\n \t\t\t\t\t\t vrp_valueize_1);\n       if (tem && is_gimple_min_invariant (tem))\n-\tset_value_range_to_value (&new_vr, tem, NULL);\n+\tset_value_range_to_value (vr, tem, NULL);\n       /* Then dispatch to value-range extracting functions.  */\n       else if (code == GIMPLE_CALL)\n-\textract_range_basic (&new_vr, stmt);\n+\textract_range_basic (vr, stmt);\n       else\n-\textract_range_from_assignment (&new_vr, as_a <gassign *> (stmt));\n-\n-      if (update_value_range (lhs, &new_vr))\n-\t{\n-\t  *output_p = lhs;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Found new range for \");\n-\t      print_generic_expr (dump_file, lhs, 0);\n-\t      fprintf (dump_file, \": \");\n-\t      dump_value_range (dump_file, &new_vr);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\n-\t  if (new_vr.type == VR_VARYING)\n-\t    return SSA_PROP_VARYING;\n-\n-\t  return SSA_PROP_INTERESTING;\n-\t}\n-\n-      return SSA_PROP_NOT_INTERESTING;\n+\textract_range_from_assignment (vr, as_a <gassign *> (stmt));\n+      *output_p = lhs;\n     }\n-  else if (is_gimple_call (stmt) && gimple_call_internal_p (stmt))\n-    switch (gimple_call_internal_fn (stmt))\n-      {\n-      case IFN_ADD_OVERFLOW:\n-      case IFN_SUB_OVERFLOW:\n-      case IFN_MUL_OVERFLOW:\n-\t/* These internal calls return _Complex integer type,\n-\t   which VRP does not track, but the immediate uses\n-\t   thereof might be interesting.  */\n-\tif (lhs && TREE_CODE (lhs) == SSA_NAME)\n-\t  {\n-\t    imm_use_iterator iter;\n-\t    use_operand_p use_p;\n-\t    enum ssa_prop_result res = SSA_PROP_VARYING;\n-\n-\t    set_value_range_to_varying (get_value_range (lhs));\n-\n-\t    FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n-\t      {\n-\t\tgimple *use_stmt = USE_STMT (use_p);\n-\t\tif (!is_gimple_assign (use_stmt))\n-\t\t  continue;\n-\t\tenum tree_code rhs_code = gimple_assign_rhs_code (use_stmt);\n-\t\tif (rhs_code != REALPART_EXPR && rhs_code != IMAGPART_EXPR)\n-\t\t  continue;\n-\t\ttree rhs1 = gimple_assign_rhs1 (use_stmt);\n-\t\ttree use_lhs = gimple_assign_lhs (use_stmt);\n-\t\tif (TREE_CODE (rhs1) != rhs_code\n-\t\t    || TREE_OPERAND (rhs1, 0) != lhs\n-\t\t    || TREE_CODE (use_lhs) != SSA_NAME\n-\t\t    || !stmt_interesting_for_vrp (use_stmt)\n-\t\t    || (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))\n-\t\t\t|| !TYPE_MIN_VALUE (TREE_TYPE (use_lhs))\n-\t\t\t|| !TYPE_MAX_VALUE (TREE_TYPE (use_lhs))))\n-\t\t  continue;\n-\n-\t\t/* If there is a change in the value range for any of the\n-\t\t   REALPART_EXPR/IMAGPART_EXPR immediate uses, return\n-\t\t   SSA_PROP_INTERESTING.  If there are any REALPART_EXPR\n-\t\t   or IMAGPART_EXPR immediate uses, but none of them have\n-\t\t   a change in their value ranges, return\n-\t\t   SSA_PROP_NOT_INTERESTING.  If there are no\n-\t\t   {REAL,IMAG}PART_EXPR uses at all,\n-\t\t   return SSA_PROP_VARYING.  */\n-\t\tvalue_range new_vr = VR_INITIALIZER;\n-\t\textract_range_basic (&new_vr, use_stmt);\n-\t\tvalue_range *old_vr = get_value_range (use_lhs);\n-\t\tif (old_vr->type != new_vr.type\n-\t\t    || !vrp_operand_equal_p (old_vr->min, new_vr.min)\n-\t\t    || !vrp_operand_equal_p (old_vr->max, new_vr.max)\n-\t\t    || !vrp_bitmap_equal_p (old_vr->equiv, new_vr.equiv))\n-\t\t  res = SSA_PROP_INTERESTING;\n-\t\telse\n-\t\t  res = SSA_PROP_NOT_INTERESTING;\n-\t\tBITMAP_FREE (new_vr.equiv);\n-\t\tif (res == SSA_PROP_INTERESTING)\n-\t\t  {\n-\t\t    *output_p = lhs;\n-\t\t    return res;\n-\t\t  }\n-\t      }\n-\n-\t    return res;\n-\t  }\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n-\n-  /* Every other statement produces no useful ranges.  */\n-  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n-    set_value_range_to_varying (get_value_range (def));\n-\n-  return SSA_PROP_VARYING;\n }\n \n /* Helper that gets the value range of the SSA_NAME with version I\n@@ -7542,10 +7446,9 @@ vrp_evaluate_conditional (tree_code code, tree op0, tree op1, gimple *stmt)\n \n /* Visit conditional statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n-   *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n-   SSA_PROP_VARYING.  */\n+   *TAKEN_EDGE_P.  Otherwise, set *TAKEN_EDGE_P to NULL.  */\n \n-static enum ssa_prop_result\n+static void\n vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n {\n   tree val;\n@@ -7643,8 +7546,6 @@ vrp_visit_cond_stmt (gcond *stmt, edge *taken_edge_p)\n       else\n \tprint_generic_stmt (dump_file, val, 0);\n     }\n-\n-  return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n /* Searches the case label vector VEC for the index *IDX of the CASE_LABEL\n@@ -7841,10 +7742,9 @@ find_case_label_ranges (gswitch *stmt, value_range *vr, size_t *min_idx1,\n \n /* Visit switch statement STMT.  If we can determine which edge\n    will be taken out of STMT's basic block, record it in\n-   *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n-   SSA_PROP_VARYING.  */\n+   *TAKEN_EDGE_P.  Otherwise, *TAKEN_EDGE_P set to NULL.  */\n \n-static enum ssa_prop_result\n+static void\n vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n {\n   tree op, val;\n@@ -7855,7 +7755,7 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n   *taken_edge_p = NULL;\n   op = gimple_switch_index (stmt);\n   if (TREE_CODE (op) != SSA_NAME)\n-    return SSA_PROP_VARYING;\n+    return;\n \n   vr = get_value_range (op);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -7870,7 +7770,7 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n   if ((vr->type != VR_RANGE\n        && vr->type != VR_ANTI_RANGE)\n       || symbolic_range_p (vr))\n-    return SSA_PROP_VARYING;\n+    return;\n \n   /* Find the single edge that is taken from the switch expression.  */\n   take_default = !find_case_label_ranges (stmt, vr, &i, &j, &k, &l);\n@@ -7895,7 +7795,7 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  not a single destination for this \"\n \t\t     \"range\\n\");\n-          return SSA_PROP_VARYING;\n+\t  return;\n \t}\n       for (++i; i <= j; ++i)\n         {\n@@ -7904,7 +7804,7 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"  not a single destination for this \"\n \t\t\t \"range\\n\");\n-\t      return SSA_PROP_VARYING;\n+\t      return;\n \t    }\n         }\n       for (; k <= l; ++k)\n@@ -7914,7 +7814,7 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"  not a single destination for this \"\n \t\t\t \"range\\n\");\n-\t      return SSA_PROP_VARYING;\n+\t      return;\n \t    }\n         }\n     }\n@@ -7927,11 +7827,36 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n       fprintf (dump_file, \"  will take edge to \");\n       print_generic_stmt (dump_file, CASE_LABEL (val), 0);\n     }\n-\n-  return SSA_PROP_INTERESTING;\n }\n \n \n+/* Evaluate statement STMT.  If the statement produces a useful range,\n+   set VR and corepsponding OUTPUT_P.\n+\n+   If STMT is a conditional branch and we can determine its truth\n+   value, the taken edge is recorded in *TAKEN_EDGE_P.  */\n+\n+static void\n+extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+\t\t\t tree *output_p, value_range *vr)\n+{\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n+      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+    }\n+\n+  if (!stmt_interesting_for_vrp (stmt))\n+    gcc_assert (stmt_ends_bb_p (stmt));\n+  else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n+    vrp_visit_assignment_or_call (stmt, output_p, vr);\n+  else if (gimple_code (stmt) == GIMPLE_COND)\n+    vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n+  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n+    vrp_visit_switch_stmt (as_a <gswitch *> (stmt), taken_edge_p);\n+}\n+\n /* Evaluate statement STMT.  If the statement produces a useful range,\n    return SSA_PROP_INTERESTING and record the SSA name with the\n    interesting range into *OUTPUT_P.\n@@ -7944,30 +7869,108 @@ vrp_visit_switch_stmt (gswitch *stmt, edge *taken_edge_p)\n static enum ssa_prop_result\n vrp_visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n {\n+  value_range vr = VR_INITIALIZER;\n+  tree lhs = gimple_get_lhs (stmt);\n   tree def;\n   ssa_op_iter iter;\n+  extract_range_from_stmt (stmt, taken_edge_p, output_p, &vr);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (*output_p)\n     {\n-      fprintf (dump_file, \"\\nVisiting statement:\\n\");\n-      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+      if (update_value_range (*output_p, &vr))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Found new range for \");\n+\t      print_generic_expr (dump_file, *output_p, 0);\n+\t      fprintf (dump_file, \": \");\n+\t      dump_value_range (dump_file, &vr);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  if (vr.type == VR_VARYING)\n+\t    return SSA_PROP_VARYING;\n+\n+\t  return SSA_PROP_INTERESTING;\n+\t}\n+      return SSA_PROP_NOT_INTERESTING;\n     }\n \n-  if (!stmt_interesting_for_vrp (stmt))\n-    gcc_assert (stmt_ends_bb_p (stmt));\n-  else if (is_gimple_assign (stmt) || is_gimple_call (stmt))\n-    return vrp_visit_assignment_or_call (stmt, output_p);\n-  else if (gimple_code (stmt) == GIMPLE_COND)\n-    return vrp_visit_cond_stmt (as_a <gcond *> (stmt), taken_edge_p);\n-  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    return vrp_visit_switch_stmt (as_a <gswitch *> (stmt), taken_edge_p);\n+  if (is_gimple_call (stmt) && gimple_call_internal_p (stmt))\n+    switch (gimple_call_internal_fn (stmt))\n+      {\n+      case IFN_ADD_OVERFLOW:\n+      case IFN_SUB_OVERFLOW:\n+      case IFN_MUL_OVERFLOW:\n+\t/* These internal calls return _Complex integer type,\n+\t   which VRP does not track, but the immediate uses\n+\t   thereof might be interesting.  */\n+\tif (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t  {\n+\t    imm_use_iterator iter;\n+\t    use_operand_p use_p;\n+\t    enum ssa_prop_result res = SSA_PROP_VARYING;\n+\n+\t    set_value_range_to_varying (get_value_range (lhs));\n+\n+\t    FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)\n+\t      {\n+\t\tgimple *use_stmt = USE_STMT (use_p);\n+\t\tif (!is_gimple_assign (use_stmt))\n+\t\t  continue;\n+\t\tenum tree_code rhs_code = gimple_assign_rhs_code (use_stmt);\n+\t\tif (rhs_code != REALPART_EXPR && rhs_code != IMAGPART_EXPR)\n+\t\t  continue;\n+\t\ttree rhs1 = gimple_assign_rhs1 (use_stmt);\n+\t\ttree use_lhs = gimple_assign_lhs (use_stmt);\n+\t\tif (TREE_CODE (rhs1) != rhs_code\n+\t\t    || TREE_OPERAND (rhs1, 0) != lhs\n+\t\t    || TREE_CODE (use_lhs) != SSA_NAME\n+\t\t    || !stmt_interesting_for_vrp (use_stmt)\n+\t\t    || (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))\n+\t\t\t|| !TYPE_MIN_VALUE (TREE_TYPE (use_lhs))\n+\t\t\t|| !TYPE_MAX_VALUE (TREE_TYPE (use_lhs))))\n+\t\t  continue;\n+\n+\t\t/* If there is a change in the value range for any of the\n+\t\t   REALPART_EXPR/IMAGPART_EXPR immediate uses, return\n+\t\t   SSA_PROP_INTERESTING.  If there are any REALPART_EXPR\n+\t\t   or IMAGPART_EXPR immediate uses, but none of them have\n+\t\t   a change in their value ranges, return\n+\t\t   SSA_PROP_NOT_INTERESTING.  If there are no\n+\t\t   {REAL,IMAG}PART_EXPR uses at all,\n+\t\t   return SSA_PROP_VARYING.  */\n+\t\tvalue_range new_vr = VR_INITIALIZER;\n+\t\textract_range_basic (&new_vr, use_stmt);\n+\t\tvalue_range *old_vr = get_value_range (use_lhs);\n+\t\tif (old_vr->type != new_vr.type\n+\t\t    || !vrp_operand_equal_p (old_vr->min, new_vr.min)\n+\t\t    || !vrp_operand_equal_p (old_vr->max, new_vr.max)\n+\t\t    || !vrp_bitmap_equal_p (old_vr->equiv, new_vr.equiv))\n+\t\t  res = SSA_PROP_INTERESTING;\n+\t\telse\n+\t\t  res = SSA_PROP_NOT_INTERESTING;\n+\t\tBITMAP_FREE (new_vr.equiv);\n+\t\tif (res == SSA_PROP_INTERESTING)\n+\t\t  {\n+\t\t    *output_p = lhs;\n+\t\t    return res;\n+\t\t  }\n+\t      }\n+\n+\t    return res;\n+\t  }\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n \n   /* All other statements produce nothing of interest for VRP, so mark\n      their outputs varying and prevent further simulation.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_DEF)\n     set_value_range_to_varying (get_value_range (def));\n \n-  return SSA_PROP_VARYING;\n+  return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n /* Union the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and\n@@ -8692,15 +8695,14 @@ vrp_meet (value_range *vr0, const value_range *vr1)\n \n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n-   value ranges, set a new range for the LHS of PHI.  */\n+   value ranges, set a new range in VR_RESULT.  */\n \n-static enum ssa_prop_result\n-vrp_visit_phi_node (gphi *phi)\n+static void\n+extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n {\n   size_t i;\n   tree lhs = PHI_RESULT (phi);\n   value_range *lhs_vr = get_value_range (lhs);\n-  value_range vr_result = VR_INITIALIZER;\n   bool first = true;\n   int edges, old_edges;\n   struct loop *l;\n@@ -8793,19 +8795,19 @@ vrp_visit_phi_node (gphi *phi)\n \t    }\n \n \t  if (first)\n-\t    copy_value_range (&vr_result, &vr_arg);\n+\t    copy_value_range (vr_result, &vr_arg);\n \t  else\n-\t    vrp_meet (&vr_result, &vr_arg);\n+\t    vrp_meet (vr_result, &vr_arg);\n \t  first = false;\n \n-\t  if (vr_result.type == VR_VARYING)\n+\t  if (vr_result->type == VR_VARYING)\n \t    break;\n \t}\n     }\n \n-  if (vr_result.type == VR_VARYING)\n+  if (vr_result->type == VR_VARYING)\n     goto varying;\n-  else if (vr_result.type == VR_UNDEFINED)\n+  else if (vr_result->type == VR_UNDEFINED)\n     goto update_range;\n \n   old_edges = vr_phi_edge_counts[SSA_NAME_VERSION (lhs)];\n@@ -8826,16 +8828,16 @@ vrp_visit_phi_node (gphi *phi)\n     {\n       /* Compare old and new ranges, fall back to varying if the\n          values are not comparable.  */\n-      int cmp_min = compare_values (lhs_vr->min, vr_result.min);\n+      int cmp_min = compare_values (lhs_vr->min, vr_result->min);\n       if (cmp_min == -2)\n \tgoto varying;\n-      int cmp_max = compare_values (lhs_vr->max, vr_result.max);\n+      int cmp_max = compare_values (lhs_vr->max, vr_result->max);\n       if (cmp_max == -2)\n \tgoto varying;\n \n       /* For non VR_RANGE or for pointers fall back to varying if\n \t the range changed.  */\n-      if ((lhs_vr->type != VR_RANGE || vr_result.type != VR_RANGE\n+      if ((lhs_vr->type != VR_RANGE || vr_result->type != VR_RANGE\n \t   || POINTER_TYPE_P (TREE_TYPE (lhs)))\n \t  && (cmp_min != 0 || cmp_max != 0))\n \tgoto varying;\n@@ -8849,23 +8851,23 @@ vrp_visit_phi_node (gphi *phi)\n \t iteration compute whether there will be any overflow, at the\n \t expense of one additional iteration.  */\n       if (cmp_min < 0)\n-\tvr_result.min = lhs_vr->min;\n+\tvr_result->min = lhs_vr->min;\n       else if (cmp_min > 0\n-\t       && !vrp_val_is_min (vr_result.min))\n-\tvr_result.min\n+\t       && !vrp_val_is_min (vr_result->min))\n+\tvr_result->min\n \t  = int_const_binop (PLUS_EXPR,\n-\t\t\t     vrp_val_min (TREE_TYPE (vr_result.min)),\n-\t\t\t     build_int_cst (TREE_TYPE (vr_result.min), 1));\n+\t\t\t     vrp_val_min (TREE_TYPE (vr_result->min)),\n+\t\t\t     build_int_cst (TREE_TYPE (vr_result->min), 1));\n \n       /* Similarly for the maximum value.  */\n       if (cmp_max > 0)\n-\tvr_result.max = lhs_vr->max;\n+\tvr_result->max = lhs_vr->max;\n       else if (cmp_max < 0\n-\t       && !vrp_val_is_max (vr_result.max))\n-\tvr_result.max\n+\t       && !vrp_val_is_max (vr_result->max))\n+\tvr_result->max\n \t  = int_const_binop (MINUS_EXPR,\n-\t\t\t     vrp_val_max (TREE_TYPE (vr_result.min)),\n-\t\t\t     build_int_cst (TREE_TYPE (vr_result.min), 1));\n+\t\t\t     vrp_val_max (TREE_TYPE (vr_result->min)),\n+\t\t\t     build_int_cst (TREE_TYPE (vr_result->min), 1));\n \n       /* If we dropped either bound to +-INF then if this is a loop\n \t PHI node SCEV may known more about its value-range.  */\n@@ -8879,7 +8881,7 @@ vrp_visit_phi_node (gphi *phi)\n   goto update_range;\n \n varying:\n-  set_value_range_to_varying (&vr_result);\n+  set_value_range_to_varying (vr_result);\n \n scev_check:\n   /* If this is a loop PHI node SCEV may known more about its value-range.\n@@ -8888,22 +8890,35 @@ vrp_visit_phi_node (gphi *phi)\n      avoid infinite simulation.  */\n   if ((l = loop_containing_stmt (phi))\n       && l->header == gimple_bb (phi))\n-    adjust_range_with_scev (&vr_result, l, phi, lhs);\n+    adjust_range_with_scev (vr_result, l, phi, lhs);\n \n infinite_check:\n   /* If we will end up with a (-INF, +INF) range, set it to\n      VARYING.  Same if the previous max value was invalid for\n      the type and we end up with vr_result.min > vr_result.max.  */\n-  if ((vr_result.type == VR_RANGE || vr_result.type == VR_ANTI_RANGE)\n-      && !((vrp_val_is_max (vr_result.max) && vrp_val_is_min (vr_result.min))\n-\t   || compare_values (vr_result.min, vr_result.max) > 0))\n+  if ((vr_result->type == VR_RANGE || vr_result->type == VR_ANTI_RANGE)\n+      && !((vrp_val_is_max (vr_result->max) && vrp_val_is_min (vr_result->min))\n+\t   || compare_values (vr_result->min, vr_result->max) > 0))\n     ;\n   else\n-    set_value_range_to_varying (&vr_result);\n+    set_value_range_to_varying (vr_result);\n \n   /* If the new range is different than the previous value, keep\n      iterating.  */\n update_range:\n+  return;\n+}\n+\n+/* Visit all arguments for PHI node PHI that flow through executable\n+   edges.  If a valid value range can be derived from all the incoming\n+   value ranges, set a new range for the LHS of PHI.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_phi_node (gphi *phi)\n+{\n+  tree lhs = PHI_RESULT (phi);\n+  value_range vr_result = VR_INITIALIZER;\n+  extract_range_from_phi_node (phi, &vr_result);\n   if (update_value_range (lhs, &vr_result))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))"}]}