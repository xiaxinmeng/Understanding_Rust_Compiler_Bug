{"sha": "8a35e18d02fd52813f21072ef8d664806b97a349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzNWUxOGQwMmZkNTI4MTNmMjEwNzJlZjhkNjY0ODA2Yjk3YTM0OQ==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-01-24T22:49:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-24T22:49:06Z"}, "message": "compiler: Use backend interface for unary expressions.\n\n\t* go-gcc.cc (Gcc_backend::unary_expression): New function.\n\nFrom-SVN: r207063", "tree": {"sha": "068ef35f26bbcc80832ef93e80c3a72c61be0d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/068ef35f26bbcc80832ef93e80c3a72c61be0d26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a35e18d02fd52813f21072ef8d664806b97a349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a35e18d02fd52813f21072ef8d664806b97a349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a35e18d02fd52813f21072ef8d664806b97a349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a35e18d02fd52813f21072ef8d664806b97a349/comments", "author": null, "committer": null, "parents": [{"sha": "8adcc78b5fcd47320c710bfe768f1cee9d094e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8adcc78b5fcd47320c710bfe768f1cee9d094e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8adcc78b5fcd47320c710bfe768f1cee9d094e1d"}], "stats": {"total": 380, "additions": 246, "deletions": 134}, "files": [{"sha": "c571d4d5a4b0767ada40ee05259b18da7f4bbdce", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=8a35e18d02fd52813f21072ef8d664806b97a349", "patch": "@@ -1,3 +1,7 @@\n+2014-01-24  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::unary_expression): New function.\n+\n 2014-01-16  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Gcc_backend::conditional_expression): Add btype"}, {"sha": "b2760f131d84f8a0c2b021deeda55727e5c61e01", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=8a35e18d02fd52813f21072ef8d664806b97a349", "patch": "@@ -253,6 +253,9 @@ class Gcc_backend : public Backend\n   conditional_expression(Btype*, Bexpression*, Bexpression*, Bexpression*,\n                          Location);\n \n+  Bexpression*\n+  unary_expression(Operator, Bexpression*, Location);\n+\n   Bexpression*\n   binary_expression(Operator, Bexpression*, Bexpression*, Location);\n \n@@ -1081,6 +1084,47 @@ Gcc_backend::conditional_expression(Btype* btype, Bexpression* condition,\n   return this->make_expression(ret);\n }\n \n+// Return an expression for the unary operation OP EXPR.\n+\n+Bexpression*\n+Gcc_backend::unary_expression(Operator op, Bexpression* expr, Location location)\n+{\n+  tree expr_tree = expr->get_tree();\n+  if (expr_tree == error_mark_node\n+      || TREE_TYPE(expr_tree) == error_mark_node)\n+    return this->error_expression();\n+\n+  tree type_tree = TREE_TYPE(expr_tree);\n+  enum tree_code code;\n+  switch (op)\n+    {\n+    case OPERATOR_MINUS:\n+      {\n+        tree computed_type = excess_precision_type(type_tree);\n+        if (computed_type != NULL_TREE)\n+          {\n+            expr_tree = convert(computed_type, expr_tree);\n+            type_tree = computed_type;\n+          }\n+        code = NEGATE_EXPR;\n+        break;\n+      }\n+    case OPERATOR_NOT:\n+      code = TRUTH_NOT_EXPR;\n+      break;\n+    case OPERATOR_XOR:\n+      code = BIT_NOT_EXPR;\n+      break;\n+    default:\n+      gcc_unreachable();\n+      break;\n+    }\n+\n+  tree ret = fold_build1_loc(location.gcc_location(), code, type_tree,\n+                             expr_tree);\n+  return this->make_expression(ret);\n+}\n+\n // Convert a gofrontend operator to an equivalent tree_code.\n \n static enum tree_code"}, {"sha": "cbe5f22b6add5e42a9a624594c84c5021d59c85c", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=8a35e18d02fd52813f21072ef8d664806b97a349", "patch": "@@ -298,6 +298,12 @@ class Backend\n                          Bexpression* then_expr, Bexpression* else_expr,\n                          Location) = 0;\n \n+  // Return an expression for the unary operation OP EXPR.\n+  // Supported values of OP are (from operators.h):\n+  //    MINUS, NOT, XOR.\n+  virtual Bexpression*\n+  unary_expression(Operator op, Bexpression* expr, Location) = 0;\n+\n   // Return an expression for the binary operation LEFT OP RIGHT.\n   // Supported values of OP are (from operators.h):\n   //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,"}, {"sha": "5bc6a87e5c5050bd3cda657c0af0be3a2fa22e10", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 178, "deletions": 134, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8a35e18d02fd52813f21072ef8d664806b97a349", "patch": "@@ -1464,6 +1464,10 @@ class Func_code_reference_expression : public Expression\n   do_traverse(Traverse*)\n   { return TRAVERSE_CONTINUE; }\n \n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n   Type*\n   do_type()\n   { return Type::make_pointer_type(Type::make_void_type()); }\n@@ -2941,6 +2945,10 @@ class Nil_expression : public Expression\n   do_is_constant() const\n   { return true; }\n \n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n   Type*\n   do_type()\n   { return Type::make_nil_type(); }\n@@ -3682,9 +3690,16 @@ class Unary_expression : public Expression\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   bool\n   do_is_constant() const;\n \n+  bool\n+  do_is_immutable() const\n+  { return this->expr_->is_immutable(); }\n+\n   bool\n   do_numeric_constant_value(Numeric_constant*) const;\n \n@@ -3806,6 +3821,45 @@ Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n   return this;\n }\n \n+// Flatten expression if a nil check must be performed and create temporary\n+// variables if necessary.\n+\n+Expression*\n+Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n+                             Statement_inserter* inserter)\n+{\n+  Location location = this->location();\n+  if (this->op_ == OPERATOR_MULT\n+      && !this->expr_->is_variable())\n+    {\n+      go_assert(this->expr_->type()->points_to() != NULL);\n+      Type* ptype = this->expr_->type()->points_to();\n+      if (!ptype->is_void_type())\n+        {\n+          Btype* pbtype = ptype->get_backend(gogo);\n+          size_t s = gogo->backend()->type_size(pbtype);\n+          if (s >= 4096 || this->issue_nil_check_)\n+            {\n+              Temporary_statement* temp =\n+                  Statement::make_temporary(NULL, this->expr_, location);\n+              inserter->insert(temp);\n+              this->expr_ =\n+                  Expression::make_temporary_reference(temp, location);\n+            }\n+        }\n+    }\n+\n+  if (this->create_temp_ && !this->expr_->is_variable())\n+    {\n+      Temporary_statement* temp =\n+          Statement::make_temporary(NULL, this->expr_, location);\n+      inserter->insert(temp);\n+      this->expr_ = Expression::make_temporary_reference(temp, location);\n+    }\n+\n+  return this;\n+}\n+\n // Return whether a unary expression is a constant.\n \n bool\n@@ -3821,8 +3875,8 @@ Unary_expression::do_is_constant() const\n   else if (this->op_ == OPERATOR_AND)\n     {\n       // Taking the address of a variable is constant if it is a\n-      // global variable, not constant otherwise.  In other cases\n-      // taking the address is probably not a constant.\n+      // global variable, not constant otherwise.  In other cases taking the\n+      // address is probably not a constant.\n       Var_expression* ve = this->expr_->var_expression();\n       if (ve != NULL)\n \t{\n@@ -4151,58 +4205,40 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t{\n \t  Temporary_statement* temp = sut->temporary();\n \t  Bvariable* bvar = temp->get_backend_variable(context);\n-\t  tree var_tree = var_to_tree(bvar);\n-\t  Expression* val = sut->expression();\n-\t  tree val_tree = val->get_tree(context);\n-\t  if (var_tree == error_mark_node || val_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  tree addr_tree = build_fold_addr_expr_loc(loc.gcc_location(),\n-\t\t\t\t\t\t    var_tree);\n-\t  return build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-\t\t\t    TREE_TYPE(addr_tree),\n-\t\t\t    build2_loc(sut->location().gcc_location(),\n-\t\t\t\t       MODIFY_EXPR, void_type_node,\n-\t\t\t\t       var_tree, val_tree),\n-\t\t\t    addr_tree);\n+          Bexpression* bvar_expr = gogo->backend()->var_expression(bvar, loc);\n+\n+          Expression* val = sut->expression();\n+          Bexpression* bval = tree_to_expr(val->get_tree(context));\n+\n+          Bstatement* bassign =\n+              gogo->backend()->assignment_statement(bvar_expr, bval, loc);\n+          Bexpression* bvar_addr =\n+              gogo->backend()->address_expression(bvar_expr, loc);\n+          Bexpression* ret =\n+              gogo->backend()->compound_expression(bassign, bvar_addr, loc);\n+          return expr_to_tree(ret);\n \t}\n     }\n \n+  Bexpression* ret;\n   tree expr = this->expr_->get_tree(context);\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-\n+  Bexpression* bexpr = tree_to_expr(expr);\n+  Btype* btype = this->expr_->type()->get_backend(gogo);\n   switch (this->op_)\n     {\n     case OPERATOR_PLUS:\n-      return expr;\n+      ret = bexpr;\n+      break;\n \n     case OPERATOR_MINUS:\n-      {\n-\ttree type = TREE_TYPE(expr);\n-\ttree compute_type = excess_precision_type(type);\n-\tif (compute_type != NULL_TREE)\n-\t  expr = ::convert(compute_type, expr);\n-\ttree ret = fold_build1_loc(loc.gcc_location(), NEGATE_EXPR,\n-\t\t\t\t   (compute_type != NULL_TREE\n-\t\t\t\t    ? compute_type\n-\t\t\t\t    : type),\n-\t\t\t\t   expr);\n-\tif (compute_type != NULL_TREE)\n-\t  ret = ::convert(type, ret);\n-\treturn ret;\n-      }\n+      ret = gogo->backend()->unary_expression(this->op_, bexpr, loc);\n+      ret = gogo->backend()->convert_expression(btype, ret, loc);\n+      break;\n \n     case OPERATOR_NOT:\n-      if (TREE_CODE(TREE_TYPE(expr)) == BOOLEAN_TYPE)\n-\treturn fold_build1_loc(loc.gcc_location(), TRUTH_NOT_EXPR,\n-                               TREE_TYPE(expr), expr);\n-      else\n-\treturn fold_build2_loc(loc.gcc_location(), NE_EXPR, boolean_type_node,\n-                               expr, build_int_cst(TREE_TYPE(expr), 0));\n-\n     case OPERATOR_XOR:\n-      return fold_build1_loc(loc.gcc_location(), BIT_NOT_EXPR, TREE_TYPE(expr),\n-                             expr);\n+      ret = gogo->backend()->unary_expression(this->op_, bexpr, loc);\n+      break;\n \n     case OPERATOR_AND:\n       if (!this->create_temp_)\n@@ -4211,127 +4247,91 @@ Unary_expression::do_get_tree(Translate_context* context)\n \t  // where we would see one should have been moved onto the\n \t  // heap at parse time.  Taking the address of a nonconstant\n \t  // constructor will not do what the programmer expects.\n-\t  go_assert(TREE_CODE(expr) != CONSTRUCTOR || TREE_CONSTANT(expr));\n-\t  go_assert(TREE_CODE(expr) != ADDR_EXPR);\n+\n+          go_assert(!this->expr_->is_composite_literal()\n+                    || this->expr_->is_immutable());\n+          Unary_expression* ue = static_cast<Unary_expression*>(this->expr_);\n+          go_assert(ue == NULL || ue->op() != OPERATOR_AND);\n \t}\n \n       // Build a decl for a constant constructor.\n-      if (TREE_CODE(expr) == CONSTRUCTOR && TREE_CONSTANT(expr))\n-\t{\n-\t  tree decl = build_decl(this->location().gcc_location(), VAR_DECL,\n-\t\t\t\t create_tmp_var_name(\"C\"), TREE_TYPE(expr));\n-\t  DECL_EXTERNAL(decl) = 0;\n-\t  TREE_PUBLIC(decl) = 0;\n-\t  TREE_READONLY(decl) = 1;\n-\t  TREE_CONSTANT(decl) = 1;\n-\t  TREE_STATIC(decl) = 1;\n-\t  TREE_ADDRESSABLE(decl) = 1;\n-\t  DECL_ARTIFICIAL(decl) = 1;\n-\t  DECL_INITIAL(decl) = expr;\n-\t  rest_of_decl_compilation(decl, 1, 0);\n-\t  expr = decl;\n-\t}\n-\n-      if (this->create_temp_\n-\t  && !TREE_ADDRESSABLE(TREE_TYPE(expr))\n-\t  && (TREE_CODE(expr) == CONST_DECL || !DECL_P(expr))\n-\t  && TREE_CODE(expr) != INDIRECT_REF\n-\t  && TREE_CODE(expr) != COMPONENT_REF)\n-\t{\n-\t  if (current_function_decl != NULL)\n-\t    {\n-\t      tree tmp = create_tmp_var(TREE_TYPE(expr), get_name(expr));\n-\t      DECL_IGNORED_P(tmp) = 1;\n-\t      DECL_INITIAL(tmp) = expr;\n-\t      TREE_ADDRESSABLE(tmp) = 1;\n-\t      return build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-\t\t\t\tbuild_pointer_type(TREE_TYPE(expr)),\n-\t\t\t\tbuild1_loc(loc.gcc_location(), DECL_EXPR,\n-\t\t\t\t\t   void_type_node, tmp),\n-\t\t\t\tbuild_fold_addr_expr_loc(loc.gcc_location(),\n-\t\t\t\t\t\t\t tmp));\n-\t    }\n-\t  else\n-\t    {\n-\t      tree tmp = build_decl(loc.gcc_location(), VAR_DECL,\n-\t\t\t\t    create_tmp_var_name(\"A\"), TREE_TYPE(expr));\n-\t      DECL_EXTERNAL(tmp) = 0;\n-\t      TREE_PUBLIC(tmp) = 0;\n-\t      TREE_STATIC(tmp) = 1;\n-\t      DECL_ARTIFICIAL(tmp) = 1;\n-\t      TREE_ADDRESSABLE(tmp) = 1;\n-\t      tree make_tmp;\n-\t      if (!TREE_CONSTANT(expr))\n-\t\tmake_tmp = fold_build2_loc(loc.gcc_location(), INIT_EXPR,\n-\t\t\t\t\t   void_type_node, tmp, expr);\n-\t      else\n-\t\t{\n-\t\t  TREE_READONLY(tmp) = 1;\n-\t\t  TREE_CONSTANT(tmp) = 1;\n-\t\t  DECL_INITIAL(tmp) = expr;\n-\t\t  make_tmp = NULL_TREE;\n-\t\t}\n-\t      rest_of_decl_compilation(tmp, 1, 0);\n-\t      tree addr = build_fold_addr_expr_loc(loc.gcc_location(), tmp);\n-\t      if (make_tmp == NULL_TREE)\n-\t\treturn addr;\n-\t      return build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-\t\t\t\tTREE_TYPE(addr), make_tmp, addr);\n-\t    }\n-\t}\n+      if ((this->expr_->is_composite_literal()\n+           || this->expr_->string_expression() != NULL)\n+          && this->expr_->is_immutable())\n+        {\n+          static unsigned int counter;\n+          char buf[100];\n+          snprintf(buf, sizeof buf, \"C%u\", counter);\n+          ++counter;\n+\n+          Bvariable* decl =\n+              gogo->backend()->immutable_struct(buf, true, false, btype, loc);\n+          gogo->backend()->immutable_struct_set_init(decl, buf, true, false,\n+                                                     btype, loc, bexpr);\n+          bexpr = gogo->backend()->var_expression(decl, loc);\n+        }\n \n-      return build_fold_addr_expr_loc(loc.gcc_location(), expr);\n+      go_assert(!this->create_temp_ || this->expr_->is_variable());\n+      ret = gogo->backend()->address_expression(bexpr, loc);\n+      break;\n \n     case OPERATOR_MULT:\n       {\n-\tgo_assert(POINTER_TYPE_P(TREE_TYPE(expr)));\n+        go_assert(this->expr_->type()->points_to() != NULL);\n \n \t// If we are dereferencing the pointer to a large struct, we\n \t// need to check for nil.  We don't bother to check for small\n \t// structs because we expect the system to crash on a nil\n \t// pointer dereference.\t However, if we know the address of this\n \t// expression is being taken, we must always check for nil.\n-\ttree target_type_tree = TREE_TYPE(TREE_TYPE(expr));\n-\tif (!VOID_TYPE_P(target_type_tree))\n+\n+        Type* ptype = this->expr_->type()->points_to();\n+        Btype* pbtype = ptype->get_backend(gogo);\n+        if (!ptype->is_void_type())\n \t  {\n-\t    HOST_WIDE_INT s = int_size_in_bytes(target_type_tree);\n-\t    if (s == -1 || s >= 4096 || this->issue_nil_check_)\n+            size_t s = gogo->backend()->type_size(pbtype);\n+\t    if (s >= 4096 || this->issue_nil_check_)\n \t      {\n-\t\tif (!DECL_P(expr))\n-\t\t  expr = save_expr(expr);\n-\t\ttree compare = fold_build2_loc(loc.gcc_location(), EQ_EXPR,\n-\t\t\t\t\t       boolean_type_node,\n-\t\t\t\t\t       expr,\n-\t\t\t\t\t       fold_convert(TREE_TYPE(expr),\n-\t\t\t\t\t\t\t    null_pointer_node));\n+                go_assert(this->expr_->is_variable());\n+\n+                Expression* nil_expr = Expression::make_nil(loc);\n+                Bexpression* nil = tree_to_expr(nil_expr->get_tree(context));\n+                Bexpression* compare =\n+                    gogo->backend()->binary_expression(OPERATOR_EQEQ, bexpr,\n+                                                       nil, loc);\n+\n \t\tExpression* crash_expr =\n \t\t    gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n-\t\ttree crash = crash_expr->get_tree(context);\n-\t\texpr = fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-\t\t\t\t       TREE_TYPE(expr), build3(COND_EXPR,\n-\t\t\t\t\t\t\t       void_type_node,\n-\t\t\t\t\t\t\t       compare, crash,\n-\t\t\t\t\t\t\t       NULL_TREE),\n-\t\t\t\t       expr);\n+                Bexpression* crash =\n+                    tree_to_expr(crash_expr->get_tree(context));\n+                bexpr = gogo->backend()->conditional_expression(btype, compare,\n+                                                                crash, bexpr,\n+                                                                loc);\n+\n \t      }\n \t  }\n \n \t// If the type of EXPR is a recursive pointer type, then we\n \t// need to insert a cast before indirecting.\n-\tif (VOID_TYPE_P(target_type_tree))\n-\t  {\n-\t    Type* pt = this->expr_->type()->points_to();\n-\t    tree ind = type_to_tree(pt->get_backend(gogo));\n-\t    expr = fold_convert_loc(loc.gcc_location(),\n+        tree expr = expr_to_tree(bexpr);\n+        tree target_type_tree = TREE_TYPE(TREE_TYPE(expr));\n+        if (VOID_TYPE_P(target_type_tree))\n+          {\n+            tree ind = type_to_tree(pbtype);\n+            expr = fold_convert_loc(loc.gcc_location(),\n                                     build_pointer_type(ind), expr);\n-\t  }\n+            bexpr = tree_to_expr(expr);\n+          }\n \n-\treturn build_fold_indirect_ref_loc(loc.gcc_location(), expr);\n+        ret = gogo->backend()->indirect_expression(bexpr, false, loc);\n       }\n+      break;\n \n     default:\n       go_unreachable();\n     }\n+\n+  return expr_to_tree(ret);\n }\n \n // Export a unary expression.\n@@ -12232,6 +12232,9 @@ class Struct_construction_expression : public Expression\n   int\n   do_traverse(Traverse* traverse);\n \n+  bool\n+  do_is_immutable() const;\n+\n   Type*\n   do_type()\n   { return this->type_; }\n@@ -12334,6 +12337,23 @@ Struct_construction_expression::is_constant_struct() const\n   return true;\n }\n \n+// Return whether this struct is immutable.\n+\n+bool\n+Struct_construction_expression::do_is_immutable() const\n+{\n+  if (this->vals_ == NULL)\n+    return true;\n+  for (Expression_list::const_iterator pv = this->vals_->begin();\n+       pv != this->vals_->end();\n+       ++pv)\n+    {\n+      if (*pv != NULL && !(*pv)->is_immutable())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n // Final type determination.\n \n void\n@@ -12546,6 +12566,9 @@ class Array_construction_expression : public Expression\n   int\n   do_traverse(Traverse* traverse);\n \n+  bool\n+  do_is_immutable() const;\n+\n   Type*\n   do_type()\n   { return this->type_; }\n@@ -12624,6 +12647,23 @@ Array_construction_expression::is_constant_array() const\n   return true;\n }\n \n+// Return whether this is an immutable array initializer.\n+\n+bool\n+Array_construction_expression::do_is_immutable() const\n+{\n+  if (this->vals_ == NULL)\n+    return true;\n+  for (Expression_list::const_iterator pv = this->vals_->begin();\n+       pv != this->vals_->end();\n+       ++pv)\n+    {\n+      if (*pv != NULL && !(*pv)->is_immutable())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n // Final type determination.\n \n void\n@@ -14390,6 +14430,10 @@ class Type_descriptor_expression : public Expression\n   do_type()\n   { return Type::make_type_descriptor_ptr_type(); }\n \n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n   void\n   do_determine_type(const Type_context*)\n   { }"}, {"sha": "575df0f08ee92d99642db6fc1a1a8f5671c8e316", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a35e18d02fd52813f21072ef8d664806b97a349/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=8a35e18d02fd52813f21072ef8d664806b97a349", "patch": "@@ -403,6 +403,11 @@ class Expression\n   is_constant() const\n   { return this->do_is_constant(); }\n \n+  // Return whether this is an immutable expression.\n+  bool\n+  is_immutable() const\n+  { return this->do_is_immutable(); }\n+\n   // If this is not a numeric constant, return false.  If it is one,\n   // return true, and set VAL to hold the value.\n   bool\n@@ -758,6 +763,11 @@ class Expression\n   do_is_constant() const\n   { return false; }\n \n+  // Return whether this is an immutable expression.\n+  virtual bool\n+  do_is_immutable() const\n+  { return false; }\n+\n   // Return whether this is a constant expression of numeric type, and\n   // set the Numeric_constant to the value.\n   virtual bool\n@@ -1195,6 +1205,10 @@ class String_expression : public Expression\n   do_is_constant() const\n   { return true; }\n \n+  bool\n+  do_is_immutable() const\n+  { return true; }\n+\n   bool\n   do_string_constant_value(std::string* val) const\n   {"}]}