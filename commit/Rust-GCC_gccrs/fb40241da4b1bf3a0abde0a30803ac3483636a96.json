{"sha": "fb40241da4b1bf3a0abde0a30803ac3483636a96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0MDI0MWRhNGIxYmYzYTBhYmRlMGEzMDgwM2FjMzQ4MzYzNmE5Ng==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-04-30T13:41:49Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-04-30T13:41:49Z"}, "message": "2012-04-24 Ian Bolton <ian.bolton at arm.com> Sameera Deshpande...\n\n2012-04-24  Ian Bolton  <ian.bolton at arm.com>\n            Sameera Deshpande  <sameera.deshpande at arm.com>\n            Greta Yorsh  <greta.yorsh at arm.com>\n\n        * config/arm/arm-protos.h (ldm_stm_operation_p): New parameters.\n        * config/arm/arm.c (ldm_stm_operation_p): New parameters.\n        * config/arm/predicates.md (load_multiple_operation): Add arguments.\n        (store_multiple_operation): Likewise.\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r186981", "tree": {"sha": "a5b10dd89be2705840d4e03f2c40fac4cf9b1991", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5b10dd89be2705840d4e03f2c40fac4cf9b1991"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb40241da4b1bf3a0abde0a30803ac3483636a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb40241da4b1bf3a0abde0a30803ac3483636a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb40241da4b1bf3a0abde0a30803ac3483636a96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb40241da4b1bf3a0abde0a30803ac3483636a96/comments", "author": null, "committer": null, "parents": [{"sha": "5991e1568cd0d505ae3646c3178b1676cc70bc13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5991e1568cd0d505ae3646c3178b1676cc70bc13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5991e1568cd0d505ae3646c3178b1676cc70bc13"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "7da2ecf5e0851b347f94b8fd6152325915a9cca7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb40241da4b1bf3a0abde0a30803ac3483636a96", "patch": "@@ -7,6 +7,11 @@\n \t* config/arm/predicates.md (load_multiple_operation): Update predicate.\n \t(store_multiple_operation): Likewise.\n \n+\t* config/arm/arm-protos.h (ldm_stm_operation_p): New parameters.\n+\t* config/arm/arm.c (ldm_stm_operation_p): New parameters.\n+\t* config/arm/predicates.md (load_multiple_operation): Add arguments.\n+\t(store_multiple_operation): Likewise.\t\n+\n 2012-04-30  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (and<mode>3): Expand masking operations with"}, {"sha": "efb5b9fe553942e399d313805f6b501d28d900ed", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=fb40241da4b1bf3a0abde0a30803ac3483636a96", "patch": "@@ -62,7 +62,8 @@ extern bool arm_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,\n \t\t\t\t\t    int);\n extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);\n-extern bool ldm_stm_operation_p (rtx, bool);\n+extern bool ldm_stm_operation_p (rtx, bool, enum machine_mode mode,\n+                                 bool, bool);\n extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern int vfp3_const_double_rtx (rtx);"}, {"sha": "54b07c5aafaf99fe8fe687445b7d276bde837c6f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fb40241da4b1bf3a0abde0a30803ac3483636a96", "patch": "@@ -10167,7 +10167,9 @@ adjacent_mem_locations (rtx a, rtx b)\n }\n \n /* Return true if OP is a valid load or store multiple operation.  LOAD is true\n-   for load operations, false for store operations.\n+   for load operations, false for store operations.  CONSECUTIVE is true\n+   if the register numbers in the operation must be consecutive in the register\n+   bank. RETURN_PC is true if value is to be loaded in PC.\n    The pattern we are trying to match for load is:\n      [(SET (R_d0) (MEM (PLUS (addr) (offset))))\n       (SET (R_d1) (MEM (PLUS (addr) (offset + <reg_increment>))))\n@@ -10182,20 +10184,31 @@ adjacent_mem_locations (rtx a, rtx b)\n          REGNO (R_dk) = REGNO (R_d0) + k.\n    The pattern for store is similar.  */\n bool\n-ldm_stm_operation_p (rtx op, bool load)\n+ldm_stm_operation_p (rtx op, bool load, enum machine_mode mode,\n+                     bool consecutive, bool return_pc)\n {\n   HOST_WIDE_INT count = XVECLEN (op, 0);\n   rtx reg, mem, addr;\n   unsigned regno;\n+  unsigned first_regno;\n   HOST_WIDE_INT i = 1, base = 0, offset = 0;\n   rtx elt;\n   bool addr_reg_in_reglist = false;\n   bool update = false;\n   int reg_increment;\n   int offset_adj;\n+  int regs_per_val;\n \n-  reg_increment = 4;\n-  offset_adj = 0;\n+  /* If not in SImode, then registers must be consecutive\n+     (e.g., VLDM instructions for DFmode).  */\n+  gcc_assert ((mode == SImode) || consecutive);\n+  /* Setting return_pc for stores is illegal.  */\n+  gcc_assert (!return_pc || load);\n+\n+  /* Set up the increments and the regs per val based on the mode.  */\n+  reg_increment = GET_MODE_SIZE (mode);\n+  regs_per_val = reg_increment / 4;\n+  offset_adj = return_pc ? 1 : 0;\n \n   if (count <= 1\n       || GET_CODE (XVECEXP (op, 0, offset_adj)) != SET\n@@ -10223,9 +10236,11 @@ ldm_stm_operation_p (rtx op, bool load)\n \n   i = i + offset_adj;\n   base = base + offset_adj;\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= i)\n-    return false;\n+  /* Perform a quick check so we don't blow up below. If only one reg is loaded,\n+     success depends on the type: VLDM can do just one reg,\n+     LDM must do at least two.  */\n+  if ((count <= i) && (mode == SImode))\n+      return false;\n \n   elt = XVECEXP (op, 0, i - 1);\n   if (GET_CODE (elt) != SET)\n@@ -10246,6 +10261,7 @@ ldm_stm_operation_p (rtx op, bool load)\n     return false;\n \n   regno = REGNO (reg);\n+  first_regno = regno;\n   addr = XEXP (mem, 0);\n   if (GET_CODE (addr) == PLUS)\n     {\n@@ -10277,10 +10293,13 @@ ldm_stm_operation_p (rtx op, bool load)\n         }\n \n       if (!REG_P (reg)\n-          || GET_MODE (reg) != SImode\n+          || GET_MODE (reg) != mode\n           || REGNO (reg) <= regno\n+          || (consecutive\n+              && (REGNO (reg) !=\n+                  (unsigned int) (first_regno + regs_per_val * (i - base))))\n           || !MEM_P (mem)\n-          || GET_MODE (mem) != SImode\n+          || GET_MODE (mem) != mode\n           || ((GET_CODE (XEXP (mem, 0)) != PLUS\n \t       || !rtx_equal_p (XEXP (XEXP (mem, 0), 0), addr)\n \t       || !CONST_INT_P (XEXP (XEXP (mem, 0), 1))"}, {"sha": "428f9e053beb86ec65b277dd2eccdcb917cdf32b", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb40241da4b1bf3a0abde0a30803ac3483636a96/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=fb40241da4b1bf3a0abde0a30803ac3483636a96", "patch": "@@ -380,13 +380,17 @@\n (define_special_predicate \"load_multiple_operation\"\n   (match_code \"parallel\")\n {\n- return ldm_stm_operation_p (op, /*load=*/true);\n+ return ldm_stm_operation_p (op, /*load=*/true, SImode,\n+                                 /*consecutive=*/false,\n+                                 /*return_pc=*/false);\n })\n \n (define_special_predicate \"store_multiple_operation\"\n   (match_code \"parallel\")\n {\n- return ldm_stm_operation_p (op, /*load=*/false);\n+ return ldm_stm_operation_p (op, /*load=*/false, SImode,\n+                                 /*consecutive=*/false,\n+                                 /*return_pc=*/false);\n })\n \n (define_special_predicate \"multi_register_push\""}]}