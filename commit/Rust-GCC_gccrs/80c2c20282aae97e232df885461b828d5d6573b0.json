{"sha": "80c2c20282aae97e232df885461b828d5d6573b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBjMmMyMDI4MmFhZTk3ZTIzMmRmODg1NDYxYjgyOGQ1ZDY1NzNiMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:35:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:35:36Z"}, "message": "[multiple changes]\n\n2014-02-25  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.adb: Various changes for better msgs for anonmous access\n\tsubprogram types.\n\t* erroutc.ads, erroutc.adb (Buffer_Ends_With): Version with character\n\targument.\n\t(Buffer_Remove): Version with character argument.\n\t* sem_attr.adb (Resolve_Attribute, case Access): Better handling\n\tof mismatching conventions for access-to-subprogram case.\n\t* sem_prag.adb (Set_Convention_From_Pragma): Deal with anonymous\n\taccess types in record.\n\t* sem_util.ads, sem_util.adb (Set_Convention): Handle anonymous access\n\ttypes, including in records.\n\n2014-02-25  Doug Rupp  <rupp@adacore.com>\n\n\t* sigtramp-ppcvxw.c, sigtramp.h, sigtramp-armvxw.c: Comment\n\tenhancements and corrections.\n\n2014-02-25  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: New section \"Conventions and Anonymous Access Types\"\n\nFrom-SVN: r208143", "tree": {"sha": "80193eba32d9e6b7b50591ca71a891de016291d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80193eba32d9e6b7b50591ca71a891de016291d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80c2c20282aae97e232df885461b828d5d6573b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c2c20282aae97e232df885461b828d5d6573b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c2c20282aae97e232df885461b828d5d6573b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c2c20282aae97e232df885461b828d5d6573b0/comments", "author": null, "committer": null, "parents": [{"sha": "7b27e18398d1feefb4d30dbc127258b703676a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b27e18398d1feefb4d30dbc127258b703676a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b27e18398d1feefb4d30dbc127258b703676a17"}], "stats": {"total": 306, "additions": 248, "deletions": 58}, "files": [{"sha": "d401ee557bd3a90d2f8ead42135cbf540e22e0be", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -1,3 +1,26 @@\n+2014-02-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.adb: Various changes for better msgs for anonmous access\n+\tsubprogram types.\n+\t* erroutc.ads, erroutc.adb (Buffer_Ends_With): Version with character\n+\targument.\n+\t(Buffer_Remove): Version with character argument.\n+\t* sem_attr.adb (Resolve_Attribute, case Access): Better handling\n+\tof mismatching conventions for access-to-subprogram case.\n+\t* sem_prag.adb (Set_Convention_From_Pragma): Deal with anonymous\n+\taccess types in record.\n+\t* sem_util.ads, sem_util.adb (Set_Convention): Handle anonymous access\n+\ttypes, including in records.\n+\n+2014-02-25  Doug Rupp  <rupp@adacore.com>\n+\n+\t* sigtramp-ppcvxw.c, sigtramp.h, sigtramp-armvxw.c: Comment\n+\tenhancements and corrections.\n+\n+2014-02-25  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: New section \"Conventions and Anonymous Access Types\"\n+\n 2014-02-25  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: First set of documentation additions for"}, {"sha": "99f100b9b6f5d5c947f656411d50d8aead6afc45", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -642,9 +642,6 @@ package body Errout is\n \n    procedure Error_Msg_PT (Typ : Node_Id; Subp : Node_Id) is\n    begin\n-      --  Error message below needs rewording (remember comma in -gnatj\n-      --  mode) ???\n-\n       Error_Msg_NE\n         (\"first formal of & must be of mode `OUT`, `IN OUT` or \" &\n          \"access-to-variable\", Typ, Subp);\n@@ -2318,6 +2315,12 @@ package body Errout is\n          Set_Msg_Blank;\n          Set_Msg_Str (\"procedure name\");\n \n+      elsif Nkind (Error_Msg_Node_1) in N_Entity\n+        and then Ekind (Error_Msg_Node_1) = E_Anonymous_Access_Subprogram_Type\n+      then\n+         Set_Msg_Blank;\n+         Set_Msg_Str (\"access to subprogram\");\n+\n       else\n          Set_Msg_Blank_Conditional;\n \n@@ -2334,7 +2337,7 @@ package body Errout is\n            or else K = N_Operator_Symbol\n            or else K = N_Defining_Operator_Symbol\n            or else ((K = N_Identifier or else K = N_Defining_Identifier)\n-                       and then Is_Operator_Name (Chars (Error_Msg_Node_1)))\n+                      and then Is_Operator_Name (Chars (Error_Msg_Node_1)))\n          then\n             Set_Msg_Node (Error_Msg_Node_1);\n \n@@ -2456,6 +2459,7 @@ package body Errout is\n          Get_Unqualified_Decoded_Name_String\n            (Unit_Name (Get_Source_Unit (Ent)));\n          Name_Len := Name_Len - 2;\n+         Set_Msg_Blank_Conditional;\n          Set_Msg_Quote;\n          Set_Casing (Mixed_Case);\n          Set_Msg_Name_Buffer;\n@@ -2474,11 +2478,11 @@ package body Errout is\n          Set_Msg_Node (Ent);\n          Add_Class;\n \n-         --  If Ent is an anonymous subprogram type, there is no name to print,\n-         --  so remove enclosing quotes.\n+         --  If we did not print a name (e.g. in the case of an anonymous\n+         --  subprogram type), there is no name to print, so remove quotes.\n \n-         if Buffer_Ends_With (\"\"\"\") then\n-            Buffer_Remove (\"\"\"\");\n+         if Buffer_Ends_With ('\"') then\n+            Buffer_Remove ('\"');\n          else\n             Set_Msg_Quote;\n          end if;\n@@ -2607,10 +2611,13 @@ package body Errout is\n          end if;\n \n          --  If the type is the designated type of an access_to_subprogram,\n-         --  there is no name to provide in the call.\n+         --  then there is no name to provide in the call.\n \n          if Ekind (Ent) = E_Subprogram_Type then\n             return;\n+\n+         --  Otherwise, we will be able to find some kind of name to output\n+\n          else\n             Unwind_Internal_Type (Ent);\n             Nam := Chars (Ent);\n@@ -3053,34 +3060,14 @@ package body Errout is\n                   if Buffer_Ends_With (\"type \") then\n                      Buffer_Remove (\"type \");\n                   end if;\n+               end if;\n \n-                  if Is_Itype (Ent) then\n-                     declare\n-                        Assoc : constant Node_Id :=\n-                          Associated_Node_For_Itype (Ent);\n-\n-                     begin\n-                        if Nkind (Assoc) in N_Subprogram_Specification then\n-\n-                           --  Anonymous access to subprogram in a signature.\n-                           --  Indicate the enclosing subprogram.\n-\n-                           Ent :=\n-                             Defining_Unit_Name\n-                               (Associated_Node_For_Itype (Ent));\n-                           Set_Msg_Str\n-                             (\"access to subprogram declared in profile of \");\n-\n-                        else\n-                           Set_Msg_Str (\"access to subprogram with profile \");\n-                        end if;\n-                     end;\n-                  end if;\n-\n-               elsif Ekind (Ent) = E_Function then\n+               if Ekind (Ent) = E_Function then\n                   Set_Msg_Str (\"access to function \");\n-               else\n+               elsif Ekind (Ent) = E_Procedure then\n                   Set_Msg_Str (\"access to procedure \");\n+               else\n+                  Set_Msg_Str (\"access to subprogram\");\n                end if;\n \n                exit Find;"}, {"sha": "e44d5f6c0cb322da7ba9abcc047a1f11d1aa2c95", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -64,19 +64,30 @@ package body Erroutc is\n    -- Buffer_Ends_With --\n    ----------------------\n \n+   function Buffer_Ends_With (C : Character) return Boolean is\n+   begin\n+      return Msglen > 0 and then Msg_Buffer (Msglen) = C;\n+   end Buffer_Ends_With;\n+\n    function Buffer_Ends_With (S : String) return Boolean is\n       Len : constant Natural := S'Length;\n    begin\n-      return\n-        Msglen > Len\n-          and then Msg_Buffer (Msglen - Len) = ' '\n-          and then Msg_Buffer (Msglen - Len + 1 .. Msglen) = S;\n+      return Msglen > Len\n+        and then Msg_Buffer (Msglen - Len) = ' '\n+        and then Msg_Buffer (Msglen - Len + 1 .. Msglen) = S;\n    end Buffer_Ends_With;\n \n    -------------------\n    -- Buffer_Remove --\n    -------------------\n \n+   procedure Buffer_Remove (C : Character) is\n+   begin\n+      if Buffer_Ends_With (C) then\n+         Msglen := Msglen - 1;\n+      end if;\n+   end Buffer_Remove;\n+\n    procedure Buffer_Remove (S : String) is\n    begin\n       if Buffer_Ends_With (S) then"}, {"sha": "75bc208649f3bd2a848cf988363b2591e49f40ac", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -344,12 +344,18 @@ package Erroutc is\n    procedure Add_Class;\n    --  Add 'Class to buffer for class wide type case (Class_Flag set)\n \n+   function Buffer_Ends_With (C : Character) return Boolean;\n+   --  Tests if message buffer ends with given character\n+\n    function Buffer_Ends_With (S : String) return Boolean;\n    --  Tests if message buffer ends with given string preceded by a space\n \n+   procedure Buffer_Remove (C : Character);\n+   --  Remove given character fron end of buffer if it is present\n+\n    procedure Buffer_Remove (S : String);\n-   --  Removes given string from end of buffer if it is present\n-   --  at end of buffer, and preceded by a space.\n+   --  Removes given string from end of buffer if it is present at end of\n+   --  buffer, and preceded by a space.\n \n    function Compilation_Errors return Boolean;\n    --  Returns true if errors have been detected, or warnings in -gnatwe"}, {"sha": "a815b3b03dd21e66297930a639cd96d8b6758b22", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -13865,6 +13865,7 @@ source file location.\n * Enumeration Clauses::\n * Address Clauses::\n * Effect of Convention on Representation::\n+* Conventions and Anonymous Access Types::\n * Determining the Representations chosen by GNAT::\n @end menu\n \n@@ -15635,6 +15636,78 @@ code. size clause specifying 64-bits must be used to obtain a 64-bit pointer.\n \n @end itemize\n \n+@node Conventions and Anonymous Access Types\n+@section Conventions and Anonymous Access Types\n+@cindex Anonymous access types\n+@cindex Convention for anonymous access types\n+\n+The RM is not entirely clear on convention handling in a number of cases,\n+and in particular, it is not clear on the convention to be given to\n+anonymous access types in general, and in particular what is to be\n+done for the case of anonymous access-to-subprogram.\n+\n+In GNAT, we decide that if an explicit Convention is applied\n+to an object or component, and its type is such an anonymous type,\n+then the convention will apply to this anonymous type as well. This\n+seems to make sense since it is anomolous in any case to have a\n+different convention for an object and its type, and there is clearly\n+no way to explicitly specify a convention for an anonymous type, since\n+it doesn't have a name to specify!\n+\n+Furthermore, we decide that if a convention is applied to a record type,\n+then this convention is inherited by any of its components that are of an\n+anonymous access type which do not have an explicitly specified convention.\n+\n+The following program shows these conventions in action:\n+\n+@smallexample @c ada\n+package ConvComp is\n+   type Foo is range 1 .. 10;\n+   type T1 is record\n+      A : access function (X : Foo) return Integer;\n+      B : Integer;\n+   end record;\n+   pragma Convention (C, T1);\n+\n+   type T2 is record\n+      A : access function (X : Foo) return Integer;\n+      pragma Convention  (C, A);\n+      B : Integer;\n+   end record;\n+   pragma Convention (COBOL, T2);\n+\n+   type T3 is record\n+      A : access function (X : Foo) return Integer;\n+      pragma Convention  (COBOL, A);\n+      B : Integer;\n+   end record;\n+   pragma Convention (C, T3);\n+\n+   type T4 is record\n+      A : access function (X : Foo) return Integer;\n+      B : Integer;\n+   end record;\n+   pragma Convention (COBOL, T4);\n+\n+   function F (X : Foo) return Integer;\n+   pragma Convention (C, F);\n+\n+   function F (X : Foo) return Integer is (13);\n+\n+   TV1 : T1 := (F'Access, 12);  -- OK\n+   TV2 : T2 := (F'Access, 13);  -- OK\n+\n+   TV3 : T3 := (F'Access, 13);  -- ERROR\n+                |\n+>>> subprogram \"F\" has wrong convention\n+>>> does not match access to subprogram declared at line 17\n+     38.    TV4 : T4 := (F'Access, 13);  -- ERROR\n+                |\n+>>> subprogram \"F\" has wrong convention\n+>>> does not match access to subprogram declared at line 24\n+     39. end ConvComp;\n+@end smallexample\n+\n @node Determining the Representations chosen by GNAT\n @section Determining the Representations chosen by GNAT\n @cindex Representation, determination of"}, {"sha": "4924878fdd27f601b1ad9435a65e0990f840c232", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -9755,11 +9755,12 @@ package body Sem_Attr is\n                   then\n                      Error_Msg_FE\n                        (\"subprogram & has wrong convention\", P, Entity (P));\n-                     Error_Msg_FE\n-                       (\"\\does not match convention of access type &\",\n-                        P, Btyp);\n+                     Error_Msg_Sloc := Sloc (Btyp);\n+                     Error_Msg_FE (\"\\does not match & declared#\", P, Btyp);\n \n-                     if not Has_Convention_Pragma (Btyp) then\n+                     if not Is_Itype (Btyp)\n+                       and then not Has_Convention_Pragma (Btyp)\n+                     then\n                         Error_Msg_FE\n                           (\"\\probable missing pragma Convention for &\",\n                            P, Btyp);"}, {"sha": "ad6167b4cbf01dd2cbebbaf3d0daa8b27997b34b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -6749,6 +6749,34 @@ package body Sem_Prag is\n             Set_Convention (E, C);\n             Set_Has_Convention_Pragma (E);\n \n+            --  For the case of a record base type, also set the convention of\n+            --  any anonymous access types declared in the record which do not\n+            --  currently have a specified convention.\n+\n+            if Is_Record_Type (E) and then Is_Base_Type (E) then\n+               declare\n+                  Comp : Node_Id;\n+\n+               begin\n+                  Comp := First_Component (E);\n+                  while Present (Comp) loop\n+                     if Present (Etype (Comp))\n+                       and then Ekind_In (Etype (Comp),\n+                                          E_Anonymous_Access_Type,\n+                                          E_Anonymous_Access_Subprogram_Type)\n+                       and then not Has_Convention_Pragma (Comp)\n+                     then\n+                        Set_Convention (Comp, C);\n+                     end if;\n+\n+                     Next_Component (Comp);\n+                  end loop;\n+               end;\n+            end if;\n+\n+            --  Deal with incomplete/private type case, where underlying type\n+            --  is available, so set convention of that underlying type.\n+\n             if Is_Incomplete_Or_Private_Type (E)\n               and then Present (Underlying_Type (E))\n             then"}, {"sha": "791bc2ebcba4140dc5a047b1ae4b9e8580d66301", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -15631,6 +15631,52 @@ package body Sem_Util is\n       then\n          Set_Can_Use_Internal_Rep (E, False);\n       end if;\n+\n+      --  If E is an object or component, and the type of E is an anonymous\n+      --  access type with no convention set, then also set the convention of\n+      --  the anonymous access type. We do not do this for anonymous protected\n+      --  types, since protected types always have the default convention.\n+\n+      if Present (Etype (E))\n+        and then (Is_Object (E)\n+                   or else Ekind (E) = E_Component\n+\n+                   --  Allow E_Void (happens for pragma Convention appearing\n+                   --  in the middle of a record applying to a component)\n+\n+                   or else Ekind (E) = E_Void)\n+      then\n+         declare\n+            Typ : constant Entity_Id := Etype (E);\n+\n+         begin\n+            if Ekind_In (Typ, E_Anonymous_Access_Type,\n+                              E_Anonymous_Access_Subprogram_Type)\n+              and then not Has_Convention_Pragma (Typ)\n+            then\n+               Basic_Set_Convention (Typ, Val);\n+               Set_Has_Convention_Pragma (Typ);\n+\n+               --  And for the access subprogram type, deal similarly with the\n+               --  designated E_Subprogram_Type if it is also internal (which\n+               --  it always is?)\n+\n+               if Ekind (Typ) = E_Anonymous_Access_Subprogram_Type then\n+                  declare\n+                     Dtype : constant Entity_Id := Designated_Type (Typ);\n+                  begin\n+                     if Ekind (Dtype) = E_Subprogram_Type\n+                       and then Is_Itype (Dtype)\n+                       and then not Has_Convention_Pragma (Dtype)\n+                     then\n+                        Basic_Set_Convention (Dtype, Val);\n+                        Set_Has_Convention_Pragma (Dtype);\n+                     end if;\n+                  end;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n    end Set_Convention;\n \n    ------------------------"}, {"sha": "0578ca32cf41ce698bf73f370c220986cc376c2d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -1749,6 +1749,8 @@ package Sem_Util is\n    --  Same as Basic_Set_Convention, but with an extra check for access types.\n    --  In particular, if E is an access-to-subprogram type, and Val is a\n    --  foreign convention, then we set Can_Use_Internal_Rep to False on E.\n+   --  Also, if the Etype of E is set and is an anonymous access type with\n+   --  no convention set, this anonymous type inherits the convention of E.\n \n    procedure Set_Current_Entity (E : Entity_Id);\n    pragma Inline (Set_Current_Entity);"}, {"sha": "fbd58b789f496110cf7b63d32a851fe09c93881e", "filename": "gcc/ada/sigtramp-armvxw.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp-armvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp-armvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-armvxw.c?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -34,6 +34,7 @@\n  ******************************************************/\n \n #include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n \n #include <vxWorks.h>\n #include <arch/../regs.h>\n@@ -125,7 +126,7 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n \n #define REGNO_G_REG_OFFSET(N) (N)\n \n-#define REGNO_PC_OFFSET  15  /* ARG_POINTER_REGNUM  */\n+#define REGNO_PC_OFFSET  15  /* PC_REGNUM  */\n \n /* asm string construction helpers.  */\n \n@@ -153,10 +154,8 @@ void __gnat_sigtramp (int signo, void *si, void *sc,\n    Only non-volatile registers are suitable for a CFA base. These are the\n    only ones we can expect to be able retrieve from the unwinding context\n    while walking up the chain, saved by at least the bottom-most exception\n-   propagation services.  We use r15 here and set it to the value we need\n-   in stub body that follows.  Note that r14 is inappropriate here, even\n-   though it is non-volatile according to the ABI, because GCC uses it as\n-   an extra SCRATCH on SPE targets.  */\n+   propagation services. We use r8 here and set it to the value we need\n+   in stub body that follows. Any of r4-r8 should work.  */\n \n #define CFA_REG 8\n \n@@ -168,13 +167,8 @@ CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n    Rules to find registers of interest from the CFA. This should comprise\n    all the non-volatile registers relevant to the interrupted context.\n \n-   Note that we include r1 in this set, unlike the libgcc unwinding\n-   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n-   expressions and the absence of rule for r1 gets compensated by using the\n-   target CFA instead.  We don't need the expression facility here and\n-   setup a fake CFA to allow very simple offset expressions, so having a\n-   rule for r1 is the proper thing to do.  We for sure have observed\n-   crashes in some cases without it.  */\n+   ??? Note that r0 was excluded for consistency with the PPC version of\n+   this file, not sure if that's right.  */\n \n #define COMMON_CFI(REG) \\\n   \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)"}, {"sha": "1a9ba6a3f553ade218150718c3d88a199ce0d7ec", "filename": "gcc/ada/sigtramp-ppcvxw.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp-ppcvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp-ppcvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-ppcvxw.c?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -34,6 +34,7 @@\n  **********************************************************/\n \n #include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n \n #include <vxWorks.h>\n #include <arch/../regs.h>"}, {"sha": "59287f157fee850013319678ebf16d8e566a939f", "filename": "gcc/ada/sigtramp.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80c2c20282aae97e232df885461b828d5d6573b0/gcc%2Fada%2Fsigtramp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp.h?ref=80c2c20282aae97e232df885461b828d5d6573b0", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *            Copyright (C) 2011, Free Software Foundation, Inc.            *\n+ *          Copyright (C) 2011-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -49,7 +49,25 @@ extern \"C\" {\n   /* To be called from an established signal handler.  Setup the DWARF CFI\n      bits letting unwinders walk through the signal frame up into the\n      interrupted application code, and then call HANDLER (SIGNO, SIGINFO,\n-     SIGCONTEXT).  */\n+     SIGCONTEXT).\n+\n+     The sigtramp construct makes it so that the unwinder jumps over it + the\n+     signal handler + the kernel frame. For a typical backtrace from the raise\n+     function:\n+\n+     #0  __gnat_Unwind_RaiseException\n+     #1  Raise_From_Signal_Handler\n+     #2  __gnat_map_signal\n+     #3  __gnat_sigtramp\n+     #4  __gnat_error_handler\n+     #5  <kernel frame>\n+     #6  interrupted function\n+\n+     The unwinder will unwind frames 0, 1 and 2 as usual. But the CFI of frame\n+     3 is set up as if the caller of frame 3 was frame 6 so, when frame 3 is\n+     unwound, the unwinder ends up in frame 6 directly. It's possible to do so\n+     since the kernel has saved the context of frame 3 and passed it on to\n+     __gnat_sigtramp.  */\n \n #ifdef __cplusplus\n }"}]}