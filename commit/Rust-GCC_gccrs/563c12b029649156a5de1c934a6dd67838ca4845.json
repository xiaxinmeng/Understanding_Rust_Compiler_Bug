{"sha": "563c12b029649156a5de1c934a6dd67838ca4845", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYzYzEyYjAyOTY0OTE1NmE1ZGUxYzkzNGE2ZGQ2NzgzOGNhNDg0NQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-02-04T18:16:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-02-04T18:16:07Z"}, "message": "combine.c (force_to_mode): Remove STACK_BIAS code.\n\n        * combine.c (force_to_mode): Remove STACK_BIAS code.\n        (nonzero_bits): Likewise.  Replace sp/fp special case with\n        REGNO_POINTER_ALIGN.\n\n        * config/sparc/sparc.h (FRAME_POINTER_REGNUM): Change to SFP.\n        (HARD_FRAME_POINTER_REGNUM): New.\n        (FIRST_PSEUDO_REGISTER, REG_CLASS_CONTENTS): Update.\n        (FIXED_REGS, CALL_USED_REGS): Update.\n        (REG_ALLOC_ORDER, REGISTER_NAMES): Update.\n        (CONDITIONAL_REGISTER_USAGE): Update for HFP.\n        (HARD_REGNO_NREGS): Update for SFP.\n        (STACK_POINTER_OFFSET): Include bias here ...\n        (FIRST_PARM_OFFSET): ... not here.\n        (STACK_BIAS): Remove.\n        (INIT_EXPANDERS): New.\n        (STARTING_FRAME_OFFSET): Do not include bias.\n        (ELIMINABLE_REGS, CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): New.\n        (REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P): Update for SFP.\n        (REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P): Likewise.\n        * config/sparc/aout.h (DBX_REGISTER_NUMBER): Update for HFP.\n        * config/sparc/litecoff.h, config/sparc/sol2.h: Likewise.\n        * config/sparc/sparc.c (mem_min_alignment): Update for HFP.\n        (sparc_nonflat_function_prologue, epilogue_renumber): Likewise.\n        (MUST_SAVE_REGISTER): Likewise.\n        (sparc_flat_function_prologue): Likewise.\n        (sparc_flat_function_epilogue): Likewise.\n        (HARD_FRAME_POINTER_MASK): Rename from FRAME_POINTER_MASK.\n        (sparc_init_modes): SFP is GENERAL_REGS.\n        (sparc_builtin_saveregs): SFP does not have bias applied.\n\nFrom-SVN: r49486", "tree": {"sha": "10416672c97e3811caed6a63b80b29c22958ea6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10416672c97e3811caed6a63b80b29c22958ea6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/563c12b029649156a5de1c934a6dd67838ca4845", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563c12b029649156a5de1c934a6dd67838ca4845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/563c12b029649156a5de1c934a6dd67838ca4845", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563c12b029649156a5de1c934a6dd67838ca4845/comments", "author": null, "committer": null, "parents": [{"sha": "ca56cd301e2c135d4ca5571a7b091564a508adfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca56cd301e2c135d4ca5571a7b091564a508adfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca56cd301e2c135d4ca5571a7b091564a508adfa"}], "stats": {"total": 302, "additions": 153, "deletions": 149}, "files": [{"sha": "e55ca94e7e8b0706eefa389d06d64259a4e8eb98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -1,3 +1,35 @@\n+2002-02-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* combine.c (force_to_mode): Remove STACK_BIAS code.\n+\t(nonzero_bits): Likewise.  Replace sp/fp special case with\n+\tREGNO_POINTER_ALIGN.\n+\n+\t* config/sparc/sparc.h (FRAME_POINTER_REGNUM): Change to SFP.\n+\t(HARD_FRAME_POINTER_REGNUM): New.\n+\t(FIRST_PSEUDO_REGISTER, REG_CLASS_CONTENTS): Update.\n+\t(FIXED_REGS, CALL_USED_REGS): Update.\n+\t(REG_ALLOC_ORDER, REGISTER_NAMES): Update.\n+\t(CONDITIONAL_REGISTER_USAGE): Update for HFP.\n+\t(HARD_REGNO_NREGS): Update for SFP.\n+\t(STACK_POINTER_OFFSET): Include bias here ...\n+\t(FIRST_PARM_OFFSET): ... not here.\n+\t(STACK_BIAS): Remove.\n+\t(INIT_EXPANDERS): New.\n+\t(STARTING_FRAME_OFFSET): Do not include bias.\n+\t(ELIMINABLE_REGS, CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): New.\n+\t(REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P): Update for SFP.\n+\t(REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P): Likewise.\n+\t* config/sparc/aout.h (DBX_REGISTER_NUMBER): Update for HFP.\n+\t* config/sparc/litecoff.h, config/sparc/sol2.h: Likewise.\n+\t* config/sparc/sparc.c (mem_min_alignment): Update for HFP.\n+\t(sparc_nonflat_function_prologue, epilogue_renumber): Likewise.\n+\t(MUST_SAVE_REGISTER): Likewise.\n+\t(sparc_flat_function_prologue): Likewise.\n+\t(sparc_flat_function_epilogue): Likewise.\n+\t(HARD_FRAME_POINTER_MASK): Rename from FRAME_POINTER_MASK.\n+\t(sparc_init_modes): SFP is GENERAL_REGS.\n+\t(sparc_builtin_saveregs): SFP does not have bias applied.\n+\n 2002-02-04  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (current_function_is_thunk): Don't check"}, {"sha": "7662b9b69087028db46d5f11be593332a09cd813", "filename": "gcc/combine.c", "status": "modified", "additions": 19, "deletions": 73, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -6753,33 +6753,12 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t  smask |= (HOST_WIDE_INT) -1 << width;\n \n \tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t    && exact_log2 (- smask) >= 0)\n-\t  {\n-#ifdef STACK_BIAS\n-\t    if (STACK_BIAS\n-\t        && (XEXP (x, 0) == stack_pointer_rtx\n-\t            || XEXP (x, 0) == frame_pointer_rtx))\n-\t      {\n-\t\tint sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n-\t\tunsigned HOST_WIDE_INT sp_mask = GET_MODE_MASK (mode);\n-\n-\t\tsp_mask &= ~(sp_alignment - 1);\n-\t\tif ((sp_mask & ~smask) == 0\n-\t\t    && ((INTVAL (XEXP (x, 1)) - STACK_BIAS) & ~smask) != 0)\n-\t\t  return force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t\t\t\t\t       ((INTVAL (XEXP (x, 1)) -\n-\t\t\t\t\t\t\t STACK_BIAS) & smask)\n-\t\t\t\t\t\t       + STACK_BIAS),\n-\t\t\t\t\tmode, smask, reg, next_select);\n-\t      }\n-#endif\n-\t    if ((nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n-\t\t&& (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n-\t      return force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t\t\t\t\t   (INTVAL (XEXP (x, 1))\n-\t\t\t\t\t\t    & smask)),\n-\t\t\t\t    mode, smask, reg, next_select);\n-\t  }\n+\t    && exact_log2 (- smask) >= 0\n+\t    && (nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n+\t    && (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n+\t  return force_to_mode (plus_constant (XEXP (x, 0),\n+\t\t\t\t\t       (INTVAL (XEXP (x, 1)) & smask)),\n+\t\t\t\tmode, smask, reg, next_select);\n       }\n \n       /* ... fall through ...  */\n@@ -7916,40 +7895,23 @@ nonzero_bits (x, mode)\n \tnonzero &= GET_MODE_MASK (ptr_mode);\n #endif\n \n-#ifdef STACK_BOUNDARY\n-      /* If this is the stack pointer, we may know something about its\n-\t alignment.  If PUSH_ROUNDING is defined, it is possible for the\n-\t stack to be momentarily aligned only to that amount, so we pick\n-\t the least alignment.  */\n-\n-      /* We can't check for arg_pointer_rtx here, because it is not\n-\t guaranteed to have as much alignment as the stack pointer.\n-\t In particular, in the Irix6 n64 ABI, the stack has 128 bit\n-\t alignment but the argument pointer has only 64 bit alignment.  */\n-\n-      if ((x == frame_pointer_rtx\n-\t   || x == stack_pointer_rtx\n-\t   || x == hard_frame_pointer_rtx\n-\t   || (REGNO (x) >= FIRST_VIRTUAL_REGISTER\n-\t       && REGNO (x) <= LAST_VIRTUAL_REGISTER))\n-#ifdef STACK_BIAS\n-\t  && !STACK_BIAS\n-#endif\n-\t      )\n+      /* Include declared information about alignment of pointers.  */\n+\n+      if (REG_POINTER (x) && REGNO_POINTER_ALIGN (REGNO (x)))\n \t{\n-\t  int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+\t  unsigned HOST_WIDE_INT alignment\n+\t    = REGNO_POINTER_ALIGN (REGNO (x)) / BITS_PER_UNIT;\n \n #ifdef PUSH_ROUNDING\n-\t  if (REGNO (x) == STACK_POINTER_REGNUM && PUSH_ARGS)\n-\t    sp_alignment = MIN (PUSH_ROUNDING (1), sp_alignment);\n+\t  /* If PUSH_ROUNDING is defined, it is possible for the\n+\t     stack to be momentarily aligned only to that amount,\n+\t     so we pick the least alignment.  */\n+\t  if (x == stack_pointer_rtx && PUSH_ARGS)\n+\t    alignment = MIN (PUSH_ROUNDING (1), alignment);\n #endif\n \n-\t  /* We must return here, otherwise we may get a worse result from\n-\t     one of the choices below.  There is nothing useful below as\n-\t     far as the stack pointer is concerned.  */\n-\t  return nonzero &= ~(sp_alignment - 1);\n+\t  nonzero &= ~(alignment - 1);\n \t}\n-#endif\n \n       /* If X is a register whose nonzero bits value is current, use it.\n \t Otherwise, if X is a register whose value we can find, use that\n@@ -7964,7 +7926,7 @@ nonzero_bits (x, mode)\n \t\t  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n-\treturn reg_last_set_nonzero_bits[REGNO (x)];\n+\treturn reg_last_set_nonzero_bits[REGNO (x)] & nonzero;\n \n       tem = get_last_value (x);\n \n@@ -7990,7 +7952,7 @@ nonzero_bits (x, mode)\n \t\t\t   | ((HOST_WIDE_INT) (-1)\n \t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n #endif\n-\t  return nonzero_bits (tem, mode);\n+\t  return nonzero_bits (tem, mode) & nonzero;\n \t}\n       else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n \t{\n@@ -8128,22 +8090,6 @@ nonzero_bits (x, mode)\n \tswitch (code)\n \t  {\n \t  case PLUS:\n-#ifdef STACK_BIAS\n-\t    if (STACK_BIAS\n-\t\t&& (XEXP (x, 0) == stack_pointer_rtx\n-\t\t    || XEXP (x, 0) == frame_pointer_rtx)\n-\t\t&& GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t      {\n-\t\tint sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n-\n-\t\tnz0 = (GET_MODE_MASK (mode) & ~(sp_alignment - 1));\n-\t\tnz1 = INTVAL (XEXP (x, 1)) - STACK_BIAS;\n-\t\twidth0 = floor_log2 (nz0) + 1;\n-\t\twidth1 = floor_log2 (nz1) + 1;\n-\t\tlow0 = floor_log2 (nz0 & -nz0);\n-\t\tlow1 = floor_log2 (nz1 & -nz1);\n-\t      }\n-#endif\n \t    result_width = MAX (width0, width1) + 1;\n \t    result_low = MIN (low0, low1);\n \t    break;"}, {"sha": "3a2273f488bfa4fac90df0e4dc5a9ddae6bd9e02", "filename": "gcc/config/sparc/aout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Faout.h?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -88,7 +88,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    pointer is really %i7.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && REGNO == FRAME_POINTER_REGNUM ? 31 : REGNO)\n+  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)\n \n /* This is how to output a note to DBX telling it the line number\n    to which the following sequence of instructions corresponds."}, {"sha": "ad0e1225db41fd3004476650ee3b7989740cf6a1", "filename": "gcc/config/sparc/litecoff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Flitecoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Flitecoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flitecoff.h?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -73,4 +73,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n    pointer is really %i7.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && REGNO == FRAME_POINTER_REGNUM ? 31 : REGNO)\n+  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)"}, {"sha": "a387dc24a1885a09f7fa20367c4e1465814ed902", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -83,7 +83,7 @@ Boston, MA 02111-1307, USA.  */\n #undef DBX_REGISTER_NUMBER\n /* Same as sparc.h */\n #define DBX_REGISTER_NUMBER(REGNO) \\\n-  (TARGET_FLAT && REGNO == FRAME_POINTER_REGNUM ? 31 : REGNO)\n+  (TARGET_FLAT && (REGNO) == HARD_FRAME_POINTER_REGNUM ? 31 : REGNO)\n \n /* We use stabs-in-elf for debugging, because that is what the native\n    toolchain uses.  */"}, {"sha": "4017ae7af8df0d92aa6da3c4620643e88b625f1d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -83,10 +83,9 @@ static rtx leaf_label;\n \n #ifdef LEAF_REGISTERS\n \n-/* Vector to say how input registers are mapped to output\n-   registers.  FRAME_POINTER_REGNUM cannot be remapped by\n-   this function to eliminate it.  You must use -fomit-frame-pointer\n-   to get that.  */\n+/* Vector to say how input registers are mapped to output registers.\n+   HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to\n+   eliminate it.  You must use -fomit-frame-pointer to get that.  */\n const char leaf_reg_remap[] =\n { 0, 1, 2, 3, 4, 5, 6, 7,\n   -1, -1, -1, -1, -1, -1, 14, -1,\n@@ -2988,8 +2987,7 @@ mem_min_alignment (mem, desired)\n     {\n       int regno = REGNO (base);\n \n-      if (regno != FRAME_POINTER_REGNUM\n-\t  && regno != STACK_POINTER_REGNUM)\n+      if (regno != HARD_FRAME_POINTER_REGNUM && regno != STACK_POINTER_REGNUM)\n \t{\n \t  /* Check if the compiler has recorded some information\n \t     about the alignment of the base REG.  If reload has\n@@ -3206,7 +3204,7 @@ sparc_init_modes ()\n     {\n       if (i < 16 && TARGET_V8PLUS)\n \tsparc_regno_reg_class[i] = I64_REGS;\n-      else if (i < 32)\n+      else if (i < 32 || i == FRAME_POINTER_REGNUM)\n \tsparc_regno_reg_class[i] = GENERAL_REGS;\n       else if (i < 64)\n \tsparc_regno_reg_class[i] = FP_REGS;\n@@ -3554,7 +3552,7 @@ sparc_nonflat_function_prologue (file, size, leaf_function)\n \n       /* The canonical frame address refers to the top of the frame.  */\n       dwarf2out_def_cfa (label, (leaf_function ? STACK_POINTER_REGNUM\n-\t\t\t\t : FRAME_POINTER_REGNUM),\n+\t\t\t\t : HARD_FRAME_POINTER_REGNUM),\n \t\t\t frame_base_offset);\n \n       if (! leaf_function)\n@@ -4862,15 +4860,15 @@ sparc_builtin_saveregs ()\n     emit_move_insn (gen_rtx_MEM (word_mode,\n \t\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t\t       frame_pointer_rtx,\n-\t\t\t\t\t       GEN_INT (STACK_POINTER_OFFSET\n+\t\t\t\t\t       GEN_INT (FIRST_PARM_OFFSET (0)\n \t\t\t\t\t\t\t+ (UNITS_PER_WORD\n \t\t\t\t\t\t\t   * regno)))),\n \t\t    gen_rtx_REG (word_mode,\n \t\t\t\t BASE_INCOMING_ARG_REG (word_mode) + regno));\n \n   address = gen_rtx_PLUS (Pmode,\n \t\t\t  frame_pointer_rtx,\n-\t\t\t  GEN_INT (STACK_POINTER_OFFSET\n+\t\t\t  GEN_INT (FIRST_PARM_OFFSET (0)\n \t\t\t\t   + UNITS_PER_WORD * first_reg));\n \n   return address;\n@@ -5483,7 +5481,7 @@ epilogue_renumber (where, test)\n \t are in the return delayed slot.  */\n     case PLUS:\n       if (GET_CODE (XEXP (*where, 0)) == REG\n-\t  && REGNO (XEXP (*where, 0)) == FRAME_POINTER_REGNUM\n+\t  && REGNO (XEXP (*where, 0)) == HARD_FRAME_POINTER_REGNUM\n \t  && (GET_CODE (XEXP (*where, 1)) != CONST_INT\n \t      || INTVAL (XEXP (*where, 1)) < SPARC_STACK_BIAS))\n \treturn 1;\n@@ -5492,7 +5490,7 @@ epilogue_renumber (where, test)\n     case MEM:\n       if (SPARC_STACK_BIAS\n \t  && GET_CODE (XEXP (*where, 0)) == REG\n-\t  && REGNO (XEXP (*where, 0)) == FRAME_POINTER_REGNUM)\n+\t  && REGNO (XEXP (*where, 0)) == HARD_FRAME_POINTER_REGNUM)\n \treturn 1;\n       break;\n \n@@ -6437,12 +6435,12 @@ struct sparc_frame_info zero_frame_info;\n /* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n \n #define RETURN_ADDR_REGNUM 15\n-#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n+#define HARD_FRAME_POINTER_MASK (1 << (HARD_FRAME_POINTER_REGNUM))\n #define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n \n #define MUST_SAVE_REGISTER(regno) \\\n- ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\\\n-  || (regno == FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n+ ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\t\\\n+  || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n   || (regno == RETURN_ADDR_REGNUM && regs_ever_live[RETURN_ADDR_REGNUM]))\n \n /* Return the bytes needed to compute the frame pointer from the current\n@@ -6715,7 +6713,7 @@ sparc_flat_function_prologue (file, size)\n   if (size > 0)\n     {\n       unsigned int reg_offset = current_frame_info.reg_offset;\n-      const char *const fp_str = reg_names[FRAME_POINTER_REGNUM];\n+      const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n       static const char *const t1_str = \"%g1\";\n \n       /* Things get a little tricky if local variables take up more than ~4096\n@@ -6736,7 +6734,7 @@ sparc_flat_function_prologue (file, size)\n \t    {\n \t      fprintf (file, \"\\tadd\\t%s, %d, %s\\n\",\n \t\t       sp_str, (int) -size, sp_str);\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n \t\t\t   fp_str, sp_str, reg_offset);\n@@ -6751,7 +6749,7 @@ sparc_flat_function_prologue (file, size)\n \t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, size);\n \t      fprintf (file, \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n \t\t       t1_str, sp_str, t1_str, sp_str);\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n \t\t\t   fp_str, sp_str, reg_offset);\n@@ -6763,11 +6761,11 @@ sparc_flat_function_prologue (file, size)\n \t  if (dwarf2out_do_frame ())\n \t    {\n \t      char *l = dwarf2out_cfi_label ();\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n-\t\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM,\n+\t\t  dwarf2out_reg_save (l, HARD_FRAME_POINTER_REGNUM,\n \t\t\t\t      reg_offset - 4 - size);\n-\t\t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, 0);\n+\t\t  dwarf2out_def_cfa (l, HARD_FRAME_POINTER_REGNUM, 0);\n \t\t}\n \t      else\n \t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size);\n@@ -6781,7 +6779,7 @@ sparc_flat_function_prologue (file, size)\n \t      reg_offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, reg_offset,\n-\t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t\t   gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t\t   current_frame_info.fmask,\n \t\t\t\t   \"st\", \"std\", -size);\n \t}\n@@ -6798,7 +6796,7 @@ sparc_flat_function_prologue (file, size)\n \t    {\n \t      fprintf (file, \"\\tadd\\t%s, %d, %s\\n\",\n \t\t       sp_str, (int) -size1, sp_str);\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\\tsub\\t%s, %d, %s\\t%s# set up frame pointer\\n\",\n \t\t\t   fp_str, sp_str, (int) offset, sp_str, (int) -size1,\n@@ -6812,7 +6810,7 @@ sparc_flat_function_prologue (file, size)\n \t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, size1);\n \t      fprintf (file, \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n \t\t       t1_str, sp_str, t1_str, sp_str);\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n \t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\\tadd\\t%s, %s, %s\\t%s# set up frame pointer\\n\",\n \t\t\t   fp_str, sp_str, (int) offset, sp_str, t1_str,\n@@ -6823,11 +6821,11 @@ sparc_flat_function_prologue (file, size)\n \t  if (dwarf2out_do_frame ())\n \t    {\n \t      char *l = dwarf2out_cfi_label ();\n-\t      if (gmask & FRAME_POINTER_MASK)\n+\t      if (gmask & HARD_FRAME_POINTER_MASK)\n \t\t{\n-\t\t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM,\n+\t\t  dwarf2out_reg_save (l, HARD_FRAME_POINTER_REGNUM,\n \t\t\t\t      offset - 4 - size1);\n-\t\t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, 0);\n+\t\t  dwarf2out_def_cfa (l, HARD_FRAME_POINTER_REGNUM, 0);\n \t\t}\n \t      else\n \t\tdwarf2out_def_cfa (l, STACK_POINTER_REGNUM, size1);\n@@ -6843,15 +6841,15 @@ sparc_flat_function_prologue (file, size)\n \t      offset += 4;\n \t    }\n \t  sparc_flat_save_restore (file, sp_str, offset,\n-\t\t\t\t   gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t\t   gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t\t   current_frame_info.fmask,\n \t\t\t\t   \"st\", \"std\", -size1);\n \t  fprintf (file, \"\\tset\\t\");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, size - size1);\n \t  fprintf (file, \", %s\\n\\tsub\\t%s, %s, %s\\n\",\n \t\t   t1_str, sp_str, t1_str, sp_str);\n \t  if (dwarf2out_do_frame ())\n-\t    if (! (gmask & FRAME_POINTER_MASK))\n+\t    if (! (gmask & HARD_FRAME_POINTER_MASK))\n \t      dwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, size);\n \t}\n     }\n@@ -6900,7 +6898,7 @@ sparc_flat_function_epilogue (file, size)\n       unsigned HOST_WIDE_INT reg_offset = current_frame_info.reg_offset;\n       unsigned HOST_WIDE_INT size1;\n       const char *const sp_str = reg_names[STACK_POINTER_REGNUM];\n-      const char *const fp_str = reg_names[FRAME_POINTER_REGNUM];\n+      const char *const fp_str = reg_names[HARD_FRAME_POINTER_REGNUM];\n       static const char *const t1_str = \"%g1\";\n \n       /* In the reload sequence, we don't need to fill the load delay\n@@ -6946,7 +6944,7 @@ sparc_flat_function_epilogue (file, size)\n \n       /* We must restore the frame pointer and return address reg first\n \t because they are treated specially by the prologue output code.  */\n-      if (current_frame_info.gmask & FRAME_POINTER_MASK)\n+      if (current_frame_info.gmask & HARD_FRAME_POINTER_MASK)\n \t{\n \t  fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n \t\t   sp_str, (int) reg_offset, fp_str);\n@@ -6961,7 +6959,7 @@ sparc_flat_function_epilogue (file, size)\n \n       /* Restore any remaining saved registers.  */\n       sparc_flat_save_restore (file, sp_str, reg_offset,\n-\t\t\t       current_frame_info.gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n+\t\t\t       current_frame_info.gmask & ~(HARD_FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n \t\t\t       current_frame_info.fmask,\n \t\t\t       \"ld\", \"ldd\", 0);\n "}, {"sha": "7b793234b1ddbb63126499b7b0f0694c39e9561a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/563c12b029649156a5de1c934a6dd67838ca4845/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=563c12b029649156a5de1c934a6dd67838ca4845", "patch": "@@ -894,9 +894,10 @@ if (TARGET_ARCH64\t\t\t\t\\\n    accessible.  We still account for them to simplify register computations\n    (eg: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n    32+32+32+4 == 100.\n-   Register 100 is used as the integer condition code register.  */\n+   Register 100 is used as the integer condition code register.\n+   Register 101 is used as the soft frame pointer register.  */\n \n-#define FIRST_PSEUDO_REGISTER 101\n+#define FIRST_PSEUDO_REGISTER 102\n \n #define SPARC_FIRST_FP_REG     32\n /* Additional V9 fp regs.  */\n@@ -962,7 +963,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n \t\t\t\t\\\n-  0, 0, 0, 0, 0}\n+  0, 0, 0, 0, 0, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -987,7 +988,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n \t\t\t\t\\\n-  1, 1, 1, 1, 1}\n+  1, 1, 1, 1, 1, 1}\n \n /* If !TARGET_FPU, then make the fp registers and fp cc regs fixed so that\n    they won't be allocated.  */\n@@ -1042,7 +1043,7 @@ do\t\t\t\t\t\t\t\t\\\n \t/* Let the compiler believe the frame pointer is still\t\\\n \t   %fp, but output it as %i7.  */\t\t\t\\\n \tfixed_regs[31] = 1;\t\t\t\t\t\\\n-\treg_names[FRAME_POINTER_REGNUM] = \"%i7\";\t\t\\\n+\treg_names[HARD_FRAME_POINTER_REGNUM] = \"%i7\";\t\t\\\n \t/* Disable leaf functions */\t\t\t\t\\\n \tmemset (sparc_leaf_regs, 0, FIRST_PSEUDO_REGISTER);\t\\\n       }\t\t\t\t\t\t\t\t\\\n@@ -1062,9 +1063,9 @@ while (0)\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n   (TARGET_ARCH64\t\t\t\t\t\t\t\\\n-   ?  ((REGNO) < 32\t\t\t\t\t\t\t\\\n-       ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n-       : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n+   ? ((REGNO) < 32 || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\\\n+      ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n+      : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Due to the ARCH64 descrepancy above we must override this next\n@@ -1107,27 +1108,32 @@ extern int sparc_mode_class[];\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM 14\n \n+/* The stack bias (amount by which the hardware register is offset by).  */\n+#define SPARC_STACK_BIAS ((TARGET_ARCH64 && TARGET_STACK_BIAS) ? 2047 : 0)\n+\n /* Actual top-of-stack address is 92/176 greater than the contents of the\n    stack pointer register for !v9/v9.  That is:\n    - !v9: 64 bytes for the in and local registers, 4 bytes for structure return\n      address, and 6*4 bytes for the 6 register parameters.\n    - v9: 128 bytes for the in and local registers + 6*8 bytes for the integer\n      parameter regs.  */\n-#define STACK_POINTER_OFFSET FIRST_PARM_OFFSET(0)\n-\n-/* The stack bias (amount by which the hardware register is offset by).  */\n-#define SPARC_STACK_BIAS ((TARGET_ARCH64 && TARGET_STACK_BIAS) ? 2047 : 0)\n-\n-/* Is stack biased? */\n-#define STACK_BIAS SPARC_STACK_BIAS\n+#define STACK_POINTER_OFFSET (FIRST_PARM_OFFSET(0) + SPARC_STACK_BIAS)\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 30\n-\n-#if 0\n-/* Register that is used for the return address for the flat model.  */\n-#define RETURN_ADDR_REGNUM 15\n-#endif\n+#define HARD_FRAME_POINTER_REGNUM 30\n+\n+/* The soft frame pointer does not have the stack bias applied.  */\n+#define FRAME_POINTER_REGNUM 101\n+\n+/* Given the stack bias, the stack pointer isn't actually aligned.  */\n+#define INIT_EXPANDERS\t\t\t\t\t\t\t \\\n+  do {\t\t\t\t\t\t\t\t\t \\\n+    if (cfun && cfun->emit->regno_pointer_align && SPARC_STACK_BIAS)\t \\\n+      {\t\t\t\t\t\t\t\t\t \\\n+\tREGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = BITS_PER_UNIT;\t \\\n+\tREGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = BITS_PER_UNIT; \\\n+      }\t\t\t\t\t\t\t\t\t \\\n+  } while (0)\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -1138,9 +1144,11 @@ extern int sparc_mode_class[];\n    Being a non-leaf function does not mean a frame pointer is needed in the\n    flat window model.  However, the debugger won't be able to backtrace through\n    us with out it.  */\n-#define FRAME_POINTER_REQUIRED \\\n-  (TARGET_FLAT ? (current_function_calls_alloca || current_function_varargs \\\n-\t\t  || !leaf_function_p ()) \\\n+#define FRAME_POINTER_REQUIRED\t\t\t\t\\\n+  (TARGET_FLAT\t\t\t\t\t\t\\\n+   ? (current_function_calls_alloca\t\t\t\\\n+      || current_function_varargs\t\t\t\\\n+      || !leaf_function_p ())\t\t\t\t\\\n    : ! (leaf_function_p () && only_leaf_regs_used ()))\n \n /* C statement to store the difference between the frame pointer\n@@ -1275,10 +1283,16 @@ enum reg_class { NO_REGS, FPCC_REGS, I64_REGS, GENERAL_REGS, FP_REGS,\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS \\\n-  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {0xffff, 0, 0, 0}, \\\n-   {-1, 0, 0, 0}, {0, -1, 0, 0}, {0, -1, -1, 0}, \\\n-   {-1, -1, 0, 0}, {-1, -1, -1, 0}, {-1, -1, -1, 0x1f}}\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+  {{0, 0, 0, 0},\t/* NO_REGS */\t\t\t\\\n+   {0, 0, 0, 0xf},\t/* FPCC_REGS */\t\t\t\\\n+   {0xffff, 0, 0, 0},\t/* I64_REGS */\t\t\t\\\n+   {-1, 0, 0, 0x20},\t/* GENERAL_REGS */\t\t\\\n+   {0, -1, 0, 0},\t/* FP_REGS */\t\t\t\\\n+   {0, -1, -1, 0},\t/* EXTRA_FP_REGS */\t\t\\\n+   {-1, -1, 0, 0x20},\t/* GENERAL_OR_FP_REGS */\t\\\n+   {-1, -1, -1, 0x20},\t/* GENERAL_OR_EXTRA_FP_REGS */\t\\\n+   {-1, -1, -1, 0x3f}}\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -1310,7 +1324,7 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n   88, 89, 90, 91, 92, 93, 94, 95,\t/* %f56-%f63 */ \\\n   32, 33,\t\t\t\t/* %f0,%f1 */   \\\n   96, 97, 98, 99, 100,\t\t\t/* %fcc0-3, %icc */ \\\n-  1, 4, 5, 6, 7, 0, 14, 30}\n+  1, 4, 5, 6, 7, 0, 14, 30, 101}\n \n /* This is the order in which to allocate registers for\n    leaf functions.  If all registers can fit in the \"gi\" registers,\n@@ -1331,7 +1345,7 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n   88, 89, 90, 91, 92, 93, 94, 95,\t\\\n   32, 33,\t\t\t\t\\\n   96, 97, 98, 99, 100,\t\t\t\\\n-  0, 14, 30, 31}\n+  0, 14, 30, 31, 101}\n   \n #define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n@@ -1535,7 +1549,7 @@ extern const char leaf_reg_remap[];\n    of the first local allocated.  */\n /* This allows space for one TFmode floating point value.  */\n #define STARTING_FRAME_OFFSET \\\n-  (TARGET_ARCH64 ? (SPARC_STACK_BIAS - 16) \\\n+  (TARGET_ARCH64 ? -16 \\\n    : (-SPARC_STACK_ALIGN (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)))\n \n /* If we generate an insn to push BYTES bytes,\n@@ -1548,13 +1562,11 @@ extern const char leaf_reg_remap[];\n    even if this function isn't going to use it.\n    v9: This is 128 for the ins and locals.  */\n #define FIRST_PARM_OFFSET(FNDECL) \\\n-  (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 16 * UNITS_PER_WORD) \\\n-   : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n+  (TARGET_ARCH64 ? 16 * UNITS_PER_WORD : STRUCT_VALUE_OFFSET + UNITS_PER_WORD)\n \n /* Offset from the argument pointer register value to the CFA.\n    This is different from FIRST_PARM_OFFSET because the register window\n    comes between the CFA and the arguments.  */\n-\n #define ARG_POINTER_CFA_OFFSET(FNDECL)  SPARC_STACK_BIAS\n \n /* When a parameter is passed in a register, stack space is still\n@@ -1568,6 +1580,17 @@ extern const char leaf_reg_remap[];\n    all 6 slots even for v9.  */\n #define REG_PARM_STACK_SPACE(DECL) (6 * UNITS_PER_WORD)\n \n+/* Definitions for register elimination.  */\n+/* ??? In TARGET_FLAT mode we needn't have a hard frame pointer.  */\n+   \n+#define ELIMINABLE_REGS \\\n+  {{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  ((OFFSET) = SPARC_STACK_BIAS)\n+\n /* Keep the stack pointer constant throughout the function.\n    This is both an optimization and a necessity: longjmp\n    doesn't behave itself when the stack pointer moves within\n@@ -1996,9 +2019,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n    has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < (unsigned)32)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < (unsigned)32)\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < (unsigned)32\t\\\n+ || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\t\\\n+ || reg_renumber[REGNO] == FRAME_POINTER_REGNUM)\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)  REGNO_OK_FOR_INDEX_P (REGNO)\n+\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n   (((unsigned) (REGNO) - 32 < (TARGET_V9 ? (unsigned)64 : (unsigned)32)) \\\n    || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? (unsigned)64 : (unsigned)32)))\n@@ -2092,11 +2118,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32))\n+  (REGNO (X) < 32\t\t\t\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32))\n+#define REG_OK_FOR_BASE_P(X)  REG_OK_FOR_INDEX_P (X)\n \n /* 'T', 'U' are for aligned memory loads which aren't needed for arch64.  */\n \n@@ -2675,7 +2703,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n  \"%f40\", \"%f41\", \"%f42\", \"%f43\", \"%f44\", \"%f45\", \"%f46\", \"%f47\",\t\\\n  \"%f48\", \"%f49\", \"%f50\", \"%f51\", \"%f52\", \"%f53\", \"%f54\", \"%f55\",\t\\\n  \"%f56\", \"%f57\", \"%f58\", \"%f59\", \"%f60\", \"%f61\", \"%f62\", \"%f63\",\t\\\n- \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\", \"%icc\"}\n+ \"%fcc0\", \"%fcc1\", \"%fcc2\", \"%fcc3\", \"%icc\", \"%sfp\" }\n \n /* Define additional names for use in asm clobbers and asm declarations.  */\n "}]}