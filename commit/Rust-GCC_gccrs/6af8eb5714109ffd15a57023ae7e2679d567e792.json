{"sha": "6af8eb5714109ffd15a57023ae7e2679d567e792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFmOGViNTcxNDEwOWZmZDE1YTU3MDIzYWU3ZTI2NzlkNTY3ZTc5Mg==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-05-19T06:26:21Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-05-19T06:26:21Z"}, "message": "Expanders cleanups after tree-ssa merge, part 1.\n\n2004-05-19  Steven Bosscher  <stevenb@suse.de>\n\n\tExpanders cleanups after tree-ssa merge, part 1.\n\n\t* expr.c (store_constructor): Build loop start and end by hand\n\tinstead of via loop functions from stmt.c.\n\t(expand_expr_real_1): Abort if we see an EXIT_EXPR or a LOOP_EXPR.\n\tRemove the code to expand them.\n\n\t* stmt.c (loop_stack): Remove this and everything related.\n\t(struct nesting, enum nesting_desc): Update.\n\t(expand_fixup): Likewise.\n\t(expand_loop_start, expand_start_loop_continue_elsewhere,\n\texpand_start_null_loop, expand_loop_continue_here, expand_end_loop,\n\texpand_end_null_loop, expand_continue_loop, expand_exit_loop,\n\texpand_exit_loop_if_false, expand_exit_loop_top_cond,\n\texpand_exit_something): Remove.\n\t* tree.h: Remove prototypes.\n\nFrom-SVN: r82018", "tree": {"sha": "902804b9e4bd40a0c8043ddf341af0b4f0981e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/902804b9e4bd40a0c8043ddf341af0b4f0981e9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6af8eb5714109ffd15a57023ae7e2679d567e792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af8eb5714109ffd15a57023ae7e2679d567e792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6af8eb5714109ffd15a57023ae7e2679d567e792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af8eb5714109ffd15a57023ae7e2679d567e792/comments", "author": null, "committer": null, "parents": [{"sha": "cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc52902d97894d218cf6acfd2aa1b904cb4c62e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc52902d97894d218cf6acfd2aa1b904cb4c62e8"}], "stats": {"total": 473, "additions": 46, "deletions": 427}, "files": [{"sha": "5627bcc62a74f390223899b7c164ee49aca56f56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6af8eb5714109ffd15a57023ae7e2679d567e792", "patch": "@@ -1,3 +1,20 @@\n+2004-05-19  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* expr.c (store_constructor): Build loop start and end by hand\n+\tinstead of via loop functions from stmt.c.\n+\t(expand_expr_real_1): Abort if we see an EXIT_EXPR or a LOOP_EXPR.\n+\tRemove the code to expand them.\n+\n+\t* stmt.c (loop_stack): Remove this and everything related.\n+\t(struct nesting, enum nesting_desc): Update.\n+\t(expand_fixup): Likewise.\n+\t(expand_loop_start, expand_start_loop_continue_elsewhere,\n+\texpand_start_null_loop, expand_loop_continue_here, expand_end_loop,\n+\texpand_end_null_loop, expand_continue_loop, expand_exit_loop,\n+\texpand_exit_loop_if_false, expand_exit_loop_top_cond,\n+\texpand_exit_something): Remove.\n+\t* tree.h: Remove prototypes.\n+\n 2004-05-18  Mike Stump  <mrs@apple.com>\n \t    Devang Patel  <dpatel@apple.com>\n "}, {"sha": "dd0725811edd4931ba952c9fad27d206ec9d7db5", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6af8eb5714109ffd15a57023ae7e2679d567e792", "patch": "@@ -4963,8 +4963,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    {\n \t      tree lo_index = TREE_OPERAND (index, 0);\n \t      tree hi_index = TREE_OPERAND (index, 1);\n-\t      rtx index_r, pos_rtx, loop_end;\n-\t      struct nesting *loop;\n+\t      rtx index_r, pos_rtx;\n \t      HOST_WIDE_INT lo, hi, count;\n \t      tree position;\n \n@@ -5005,9 +5004,11 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t}\n \t      else\n \t\t{\n-\t\t  expand_expr (hi_index, NULL_RTX, VOIDmode, 0);\n-\t\t  loop_end = gen_label_rtx ();\n+\t\t  rtx loop_start = gen_label_rtx ();\n+\t\t  rtx loop_end = gen_label_rtx ();\n+\t\t  tree exit_cond;\n \n+\t\t  expand_expr (hi_index, NULL_RTX, VOIDmode, 0);\n \t\t  unsignedp = TYPE_UNSIGNED (domain);\n \n \t\t  index = build_decl (VAR_DECL, NULL_TREE, domain);\n@@ -5025,7 +5026,11 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t      emit_queue ();\n \t\t    }\n \t\t  store_expr (lo_index, index_r, 0);\n-\t\t  loop = expand_start_loop (0);\n+\n+\t\t  /* Build the head of the loop.  */\n+\t\t  do_pending_stack_adjust ();\n+\t\t  emit_queue ();\n+\t\t  emit_label (loop_start);\n \n \t\t  /* Assign value to element index.  */\n \t\t  position\n@@ -5046,14 +5051,19 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  else\n \t\t    store_expr (value, xtarget, 0);\n \n-\t\t  expand_exit_loop_if_false (loop,\n-\t\t\t\t\t     build (LT_EXPR, integer_type_node,\n-\t\t\t\t\t\t    index, hi_index));\n+\t\t  /* Generate a conditional jump to exit the loop.  */\n+\t\t  exit_cond = build (LT_EXPR, integer_type_node,\n+\t\t\t\t     index, hi_index);\n+\t\t  jumpif (exit_cond, loop_end);\n \n+\t\t  /* Update the loop counter, and jump to the head of\n+\t\t     the loop.  */\n \t\t  expand_increment (build (PREINCREMENT_EXPR,\n \t\t\t\t\t   TREE_TYPE (index),\n \t\t\t\t\t   index, integer_one_node), 0, 0);\n-\t\t  expand_end_loop ();\n+\t\t  emit_jump (loop_start);\n+\n+\t\t  /* Build the end of the loop.  */\n \t\t  emit_label (loop_end);\n \t\t}\n \t    }\n@@ -6804,10 +6814,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \texpand_computed_goto (TREE_OPERAND (exp, 0));\n       return const0_rtx;\n \n+    /* These are lowered during gimplification, so we should never ever\n+       see them here.  */\n+    case LOOP_EXPR:\n     case EXIT_EXPR:\n-      expand_exit_loop_if_false (NULL,\n-\t\t\t\t invert_truthvalue (TREE_OPERAND (exp, 0)));\n-      return const0_rtx;\n+      abort ();\n \n     case LABELED_BLOCK_EXPR:\n       if (LABELED_BLOCK_BODY (exp))\n@@ -6823,15 +6834,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       expand_goto (LABELED_BLOCK_LABEL (EXIT_BLOCK_LABELED_BLOCK (exp)));\n       return const0_rtx;\n \n-    case LOOP_EXPR:\n-      push_temp_slots ();\n-      expand_start_loop (1);\n-      expand_expr_stmt_value (TREE_OPERAND (exp, 0), 0, 1);\n-      expand_end_loop ();\n-      pop_temp_slots ();\n-\n-      return const0_rtx;\n-\n     case BIND_EXPR:\n       {\n \ttree block = BIND_EXPR_BLOCK (exp);"}, {"sha": "330ae5f2b539709ab8dfce262d1799f76d4c56f7", "filename": "gcc/stmt.c", "status": "modified", "additions": 6, "deletions": 395, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6af8eb5714109ffd15a57023ae7e2679d567e792", "patch": "@@ -124,7 +124,7 @@ static int cost_table_initialized;\n    The position of an entry on `nesting_stack' is in its `depth' field.\n \n    Each type of construct has its own individual stack.\n-   For example, loops have `loop_stack'.  Each object points to the\n+   For example, loops have `cond_stack'.  Each object points to the\n    next object of the same type through the `next' field.\n \n    Some constructs are visible to `break' exit-statements and others\n@@ -142,7 +142,6 @@ struct nesting GTY(())\n   rtx exit_label;\n   enum nesting_desc {\n     COND_NESTING,\n-    LOOP_NESTING,\n     BLOCK_NESTING,\n     CASE_NESTING\n   } desc;\n@@ -159,17 +158,6 @@ struct nesting GTY(())\n \t     This may be the end of the if or the next else/elseif.  */\n \t  rtx next_label;\n \t} GTY ((tag (\"COND_NESTING\"))) cond;\n-      /* For loops.  */\n-      struct nesting_loop\n-\t{\n-\t  /* Label at the top of the loop; place to loop back to.  */\n-\t  rtx start_label;\n-\t  /* Label at the end of the whole construct.  */\n-\t  rtx end_label;\n-\t  /* Label for `continue' statement to jump to;\n-\t     this is in front of the stepper of the loop.  */\n-\t  rtx continue_label;\n-\t} GTY ((tag (\"LOOP_NESTING\"))) loop;\n       /* For variable binding contours.  */\n       struct nesting_block\n \t{\n@@ -259,8 +247,6 @@ struct nesting GTY(())\n do { struct nesting *target = STACK;\t\t\t\\\n      struct nesting *this;\t\t\t\t\\\n      do { this = nesting_stack;\t\t\t\t\\\n-\t  if (loop_stack == this)\t\t\t\\\n-\t    loop_stack = loop_stack->next;\t\t\\\n \t  if (cond_stack == this)\t\t\t\\\n \t    cond_stack = cond_stack->next;\t\t\\\n \t  if (block_stack == this)\t\t\t\\\n@@ -336,9 +322,6 @@ struct stmt_status GTY(())\n   /* Chain of all pending conditional statements.  */\n   struct nesting * x_cond_stack;\n \n-  /* Chain of all pending loops.  */\n-  struct nesting * x_loop_stack;\n-\n   /* Chain of all pending case or switch statements.  */\n   struct nesting * x_case_stack;\n \n@@ -372,7 +355,6 @@ struct stmt_status GTY(())\n #define block_stack (cfun->stmt->x_block_stack)\n #define stack_block_stack (cfun->stmt->x_stack_block_stack)\n #define cond_stack (cfun->stmt->x_cond_stack)\n-#define loop_stack (cfun->stmt->x_loop_stack)\n #define case_stack (cfun->stmt->x_case_stack)\n #define nesting_stack (cfun->stmt->x_nesting_stack)\n #define nesting_depth (cfun->stmt->x_nesting_depth)\n@@ -708,14 +690,6 @@ expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n       && (rtl_label == cond_stack->data.cond.endif_label\n \t  || rtl_label == cond_stack->data.cond.next_label))\n     end_block = cond_stack;\n-  /* If we are in a loop, recognize certain labels which\n-     are likely targets.  This reduces the number of fixups\n-     we need to create.  */\n-  else if (loop_stack\n-      && (rtl_label == loop_stack->data.loop.start_label\n-\t  || rtl_label == loop_stack->data.loop.end_label\n-\t  || rtl_label == loop_stack->data.loop.continue_label))\n-    end_block = loop_stack;\n   else\n     end_block = 0;\n \n@@ -774,9 +748,8 @@ expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n \t `SUPERBLOCK') of any other BLOCK nodes which we might create\n \t later on when we are expanding the fixup code.\n \n-\t Note that optimization passes (including expand_end_loop)\n-\t might move the *_BLOCK notes away, so we use a NOTE_INSN_DELETED\n-\t as a placeholder.  */\n+\t Note that optimization passes might move the *_BLOCK notes away,\n+\t so we use a NOTE_INSN_DELETED as a placeholder.  */\n \n       {\n \trtx original_before_jump\n@@ -2472,384 +2445,22 @@ expand_end_cond (void)\n   clear_last_expr ();\n }\n \f\n-/* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this\n-   loop should be exited by `exit_something'.  This is a loop for which\n-   `expand_continue' will jump to the top of the loop.\n-\n-   Make an entry on loop_stack to record the labels associated with\n-   this loop.  */\n-\n-struct nesting *\n-expand_start_loop (int exit_flag)\n-{\n-  struct nesting *thisloop = ALLOC_NESTING ();\n-\n-  /* Make an entry on loop_stack for the loop we are entering.  */\n-\n-  thisloop->desc = LOOP_NESTING;\n-  thisloop->next = loop_stack;\n-  thisloop->all = nesting_stack;\n-  thisloop->depth = ++nesting_depth;\n-  thisloop->data.loop.start_label = gen_label_rtx ();\n-  thisloop->data.loop.end_label = gen_label_rtx ();\n-  thisloop->data.loop.continue_label = thisloop->data.loop.start_label;\n-  thisloop->exit_label = exit_flag ? thisloop->data.loop.end_label : 0;\n-  loop_stack = thisloop;\n-  nesting_stack = thisloop;\n-\n-  do_pending_stack_adjust ();\n-  emit_queue ();\n-  emit_label (thisloop->data.loop.start_label);\n-\n-  return thisloop;\n-}\n-\n-/* Like expand_start_loop but for a loop where the continuation point\n-   (for expand_continue_loop) will be specified explicitly.  */\n-\n-struct nesting *\n-expand_start_loop_continue_elsewhere (int exit_flag)\n-{\n-  struct nesting *thisloop = expand_start_loop (exit_flag);\n-  loop_stack->data.loop.continue_label = gen_label_rtx ();\n-  return thisloop;\n-}\n-\n-/* Begin a null, aka do { } while (0) \"loop\".  But since the contents\n-   of said loop can still contain a break, we must frob the loop nest.  */\n-\n-struct nesting *\n-expand_start_null_loop (void)\n-{\n-  struct nesting *thisloop = ALLOC_NESTING ();\n-\n-  /* Make an entry on loop_stack for the loop we are entering.  */\n-\n-  thisloop->desc = LOOP_NESTING;\n-  thisloop->next = loop_stack;\n-  thisloop->all = nesting_stack;\n-  thisloop->depth = ++nesting_depth;\n-  thisloop->data.loop.start_label = emit_note (NOTE_INSN_DELETED);\n-  thisloop->data.loop.end_label = gen_label_rtx ();\n-  thisloop->data.loop.continue_label = thisloop->data.loop.end_label;\n-  thisloop->exit_label = thisloop->data.loop.end_label;\n-  loop_stack = thisloop;\n-  nesting_stack = thisloop;\n-\n-  return thisloop;\n-}\n-\n-/* Specify the continuation point for a loop started with\n-   expand_start_loop_continue_elsewhere.\n-   Use this at the point in the code to which a continue statement\n-   should jump.  */\n-\n-void\n-expand_loop_continue_here (void)\n-{\n-  do_pending_stack_adjust ();\n-  emit_label (loop_stack->data.loop.continue_label);\n-}\n-\n-/* Finish a loop.  Generate a jump back to the top and the loop-exit label.\n-   Pop the block off of loop_stack.  */\n-\n-void\n-expand_end_loop (void)\n-{\n-  rtx start_label = loop_stack->data.loop.start_label;\n-  rtx etc_note;\n-  int eh_regions, debug_blocks;\n-  bool empty_test;\n-\n-  do_pending_stack_adjust ();\n-\n-  /* If the loop starts with a loop exit, roll that to the end where\n-     it will optimize together with the jump back.\n-\n-     If the loop presently looks like this (in pseudo-C):\n-\n-\tstart_label:\n-\t  if (test) goto end_label;\n-\tLOOP_END_TOP_COND\n-\t  body;\n-\t  goto start_label;\n-\tend_label:\n-\n-     transform it to look like:\n-\n-\t  goto start_label;\n-\ttop_label:\n-\t  body;\n-\tstart_label:\n-\t  if (test) goto end_label;\n-\t  goto top_label;\n-\tend_label:\n-\n-     We rely on the presence of NOTE_INSN_LOOP_END_TOP_COND to mark\n-     the end of the entry conditional.  Without this, our lexical scan\n-     can't tell the difference between an entry conditional and a\n-     body conditional that exits the loop.  Mistaking the two means\n-     that we can misplace the NOTE_INSN_LOOP_CONT note, which can\n-     screw up loop unrolling.\n-\n-     Things will be oh so much better when loop optimization is done\n-     off of a proper control flow graph...  */\n-\n-  /* Scan insns from the top of the loop looking for the END_TOP_COND note.  */\n-\n-  empty_test = true;\n-  eh_regions = debug_blocks = 0;\n-  for (etc_note = start_label; etc_note ; etc_note = NEXT_INSN (etc_note))\n-    if (GET_CODE (etc_note) == NOTE)\n-      {\n-\tif (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_LOOP_END_TOP_COND)\n-\t  break;\n-\n-\tif (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_LOOP_BEG)\n-\t  abort ();\n-\n-\t/* At the same time, scan for EH region notes, as we don't want\n-\t   to scrog region nesting.  This shouldn't happen, but...  */\n-\tif (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_EH_REGION_BEG)\n-\t  eh_regions++;\n-\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_EH_REGION_END)\n-\t  {\n-\t    if (--eh_regions < 0)\n-\t      /* We've come to the end of an EH region, but never saw the\n-\t\t beginning of that region.  That means that an EH region\n-\t\t begins before the top of the loop, and ends in the middle\n-\t\t of it.  The existence of such a situation violates a basic\n-\t\t assumption in this code, since that would imply that even\n-\t\t when EH_REGIONS is zero, we might move code out of an\n-\t\t exception region.  */\n-\t      abort ();\n-\t  }\n-\n-\t/* Likewise for debug scopes.  In this case we'll either (1) move\n-\t   all of the notes if they are properly nested or (2) leave the\n-\t   notes alone and only rotate the loop at high optimization\n-\t   levels when we expect to scrog debug info.  */\n-\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_BLOCK_BEG)\n-\t  debug_blocks++;\n-\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_BLOCK_END)\n-\t  debug_blocks--;\n-      }\n-    else if (INSN_P (etc_note))\n-      empty_test = false;\n-\n-  if (etc_note\n-      && optimize\n-      && ! empty_test\n-      && eh_regions == 0\n-      && (debug_blocks == 0 || optimize >= 2)\n-      && NEXT_INSN (etc_note) != NULL_RTX\n-      && ! any_condjump_p (get_last_insn ()))\n-    {\n-      /* We found one.  Move everything from START to ETC to the end\n-\t of the loop, and add a jump from the top of the loop.  */\n-      rtx top_label = gen_label_rtx ();\n-      rtx start_move = start_label;\n-\n-      emit_label_before (top_label, start_move);\n-\n-      /* Actually move the insns.  If the debug scopes are nested, we\n-\t can move everything at once.  Otherwise we have to move them\n-\t one by one and squeeze out the block notes.  */\n-      if (debug_blocks == 0)\n-\treorder_insns (start_move, etc_note, get_last_insn ());\n-      else\n-\t{\n-\t  rtx insn, next_insn;\n-\t  for (insn = start_move; insn; insn = next_insn)\n-\t    {\n-\t      /* Figure out which insn comes after this one.  We have\n-\t\t to do this before we move INSN.  */\n-\t      next_insn = (insn == etc_note ? NULL : NEXT_INSN (insn));\n-\n-\t      if (GET_CODE (insn) == NOTE\n-\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t\tcontinue;\n-\n-\t      reorder_insns (insn, insn, get_last_insn ());\n-\t    }\n-\t}\n-\n-      /* Add the jump from the top of the loop.  */\n-      emit_jump_insn_before (gen_jump (start_label), top_label);\n-      emit_barrier_before (top_label);\n-      start_label = top_label;\n-    }\n-\n-  if (etc_note)\n-    delete_insn (etc_note);\n-\n-  emit_jump (start_label);\n-  emit_label (loop_stack->data.loop.end_label);\n-\n-  POPSTACK (loop_stack);\n-\n-  clear_last_expr ();\n-}\n-\n-/* Finish a null loop, aka do { } while (0).  */\n-\n-void\n-expand_end_null_loop (void)\n-{\n-  do_pending_stack_adjust ();\n-  emit_label (loop_stack->data.loop.end_label);\n-\n-  POPSTACK (loop_stack);\n-\n-  clear_last_expr ();\n-}\n-\n-/* Generate a jump to the current loop's continue-point.\n-   This is usually the top of the loop, but may be specified\n-   explicitly elsewhere.  If not currently inside a loop,\n-   return 0 and do nothing; caller will print an error message.  */\n-\n-int\n-expand_continue_loop (struct nesting *whichloop)\n-{\n-  /* Emit information for branch prediction.  */\n-  rtx note;\n-\n-  if (flag_guess_branch_prob)\n-    {\n-      note = emit_note (NOTE_INSN_PREDICTION);\n-      NOTE_PREDICTION (note) = NOTE_PREDICT (PRED_CONTINUE, IS_TAKEN);\n-    }\n-  clear_last_expr ();\n-  if (whichloop == 0)\n-    whichloop = loop_stack;\n-  if (whichloop == 0)\n-    return 0;\n-  expand_goto_internal (NULL_TREE, whichloop->data.loop.continue_label,\n-\t\t\tNULL_RTX);\n-  return 1;\n-}\n-\n-/* Generate a jump to exit the current loop.  If not currently inside a loop,\n-   return 0 and do nothing; caller will print an error message.  */\n-\n-int\n-expand_exit_loop (struct nesting *whichloop)\n-{\n-  clear_last_expr ();\n-  if (whichloop == 0)\n-    whichloop = loop_stack;\n-  if (whichloop == 0)\n-    return 0;\n-  expand_goto_internal (NULL_TREE, whichloop->data.loop.end_label, NULL_RTX);\n-  return 1;\n-}\n-\n-/* Generate a conditional jump to exit the current loop if COND\n-   evaluates to zero.  If not currently inside a loop,\n-   return 0 and do nothing; caller will print an error message.  */\n-\n-int\n-expand_exit_loop_if_false (struct nesting *whichloop, tree cond)\n-{\n-  rtx label;\n-  clear_last_expr ();\n-\n-  if (whichloop == 0)\n-    whichloop = loop_stack;\n-  if (whichloop == 0)\n-    return 0;\n-\n-  if (integer_nonzerop (cond))\n-    return 1;\n-  if (integer_zerop (cond))\n-    return expand_exit_loop (whichloop);\n-\n-  /* Check if we definitely won't need a fixup.  */\n-  if (whichloop == nesting_stack)\n-    {\n-      jumpifnot (cond, whichloop->data.loop.end_label);\n-      return 1;\n-    }\n-\n-  /* In order to handle fixups, we actually create a conditional jump\n-     around an unconditional branch to exit the loop.  If fixups are\n-     necessary, they go before the unconditional branch.  */\n-\n-  label = gen_label_rtx ();\n-  jumpif (cond, label);\n-  expand_goto_internal (NULL_TREE, whichloop->data.loop.end_label,\n-\t\t\tNULL_RTX);\n-  emit_label (label);\n-\n-  return 1;\n-}\n-\n-/* Like expand_exit_loop_if_false except also emit a note marking\n-   the end of the conditional.  Should only be used immediately\n-   after expand_loop_start.  */\n-\n-int\n-expand_exit_loop_top_cond (struct nesting *whichloop, tree cond)\n-{\n-  if (! expand_exit_loop_if_false (whichloop, cond))\n-    return 0;\n-\n-  emit_note (NOTE_INSN_LOOP_END_TOP_COND);\n-  return 1;\n-}\n-\n /* Return nonzero if we should preserve sub-expressions as separate\n    pseudos.  We never do so if we aren't optimizing.  We always do so\n-   if -fexpensive-optimizations.\n-\n-   Otherwise, we only do so if we are in the \"early\" part of a loop.  I.e.,\n-   the loop may still be a small one.  */\n+   if -fexpensive-optimizations.  */\n \n int\n preserve_subexpressions_p (void)\n {\n-  rtx insn;\n-\n   if (flag_expensive_optimizations)\n     return 1;\n \n-  if (optimize == 0 || cfun == 0 || cfun->stmt == 0 || loop_stack == 0)\n+  if (optimize == 0 || cfun == 0 || cfun->stmt == 0)\n     return 0;\n \n-  insn = get_last_insn_anywhere ();\n-\n-  return (insn\n-\t  && (INSN_UID (insn) - INSN_UID (loop_stack->data.loop.start_label)\n-\t      < n_non_fixed_regs * 3));\n-\n+  return 1;\n }\n \n-/* Generate a jump to exit the current loop, conditional, binding contour\n-   or case statement.  Not all such constructs are visible to this function,\n-   only those started with EXIT_FLAG nonzero.  Individual languages use\n-   the EXIT_FLAG parameter to control which kinds of constructs you can\n-   exit this way.\n-\n-   If not currently inside anything that can be exited,\n-   return 0 and do nothing; caller will print an error message.  */\n-\n-int\n-expand_exit_something (void)\n-{\n-  struct nesting *n;\n-  clear_last_expr ();\n-  for (n = nesting_stack; n; n = n->all)\n-    if (n->exit_label != 0)\n-      {\n-\texpand_goto_internal (NULL_TREE, n->exit_label, NULL_RTX);\n-\treturn 1;\n-      }\n-\n-  return 0;\n-}\n \f\n /* Generate RTL to return from the current function, with no value.\n    (That is, we do not do anything about returning any value.)  */"}, {"sha": "feebe7351e8a0810201c916e4cd1d343470e1609", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6af8eb5714109ffd15a57023ae7e2679d567e792/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6af8eb5714109ffd15a57023ae7e2679d567e792", "patch": "@@ -3392,17 +3392,6 @@ extern void expand_start_cond (tree, int);\n extern void expand_end_cond (void);\n extern void expand_start_else (void);\n extern void expand_start_elseif (tree);\n-extern struct nesting *expand_start_loop (int);\n-extern struct nesting *expand_start_loop_continue_elsewhere (int);\n-extern struct nesting *expand_start_null_loop (void);\n-extern void expand_loop_continue_here (void);\n-extern void expand_end_loop (void);\n-extern void expand_end_null_loop (void);\n-extern int expand_continue_loop (struct nesting *);\n-extern int expand_exit_loop (struct nesting *);\n-extern int expand_exit_loop_if_false (struct nesting *,tree);\n-extern int expand_exit_loop_top_cond (struct nesting *, tree);\n-extern int expand_exit_something (void);\n \n extern void expand_stack_alloc (tree, tree);\n extern rtx expand_stack_save (void);"}]}