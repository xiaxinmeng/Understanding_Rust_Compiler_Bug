{"sha": "6a4bb1fae14bd504287a10bec02dafe2a455d1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0YmIxZmFlMTRiZDUwNDI4N2ExMGJlYzAyZGFmZTJhNDU1ZDFkZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-08T22:24:29Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-08T22:24:29Z"}, "message": "Cosmetic changes only.  Just reordered code a little.\n\nFrom-SVN: r5292", "tree": {"sha": "94e599908e95b1811163e7e246dd8a08c4da6945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94e599908e95b1811163e7e246dd8a08c4da6945"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a4bb1fae14bd504287a10bec02dafe2a455d1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4bb1fae14bd504287a10bec02dafe2a455d1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a4bb1fae14bd504287a10bec02dafe2a455d1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4bb1fae14bd504287a10bec02dafe2a455d1de/comments", "author": null, "committer": null, "parents": [{"sha": "25b5c537ba1004ab5b522b24e60ae6e003b2cf1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b5c537ba1004ab5b522b24e60ae6e003b2cf1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b5c537ba1004ab5b522b24e60ae6e003b2cf1c"}], "stats": {"total": 511, "additions": 257, "deletions": 254}, "files": [{"sha": "9f0fb34634fbba94b4f2babf129466cac86a3410", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6a4bb1fae14bd504287a10bec02dafe2a455d1de", "patch": "@@ -62,6 +62,7 @@ char leaf_reg_remap[] =\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63};\n \n+#if 0 /* not used anymore */\n char leaf_reg_backmap[] =\n { 0, 1, 2, 3, 4, 5, 6, 7,\n   24, 25, 26, 27, 28, 29, 14, 31,\n@@ -73,12 +74,13 @@ char leaf_reg_backmap[] =\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63};\n #endif\n+#endif\n \n /* Global variables set by FUNCTION_PROLOGUE.  */\n /* Size of frame.  Need to know this to emit return insns from\n    leaf procedures.  */\n-int apparent_fsize;\n-int actual_fsize;\n+static int apparent_fsize;\n+static int actual_fsize;\n \n /* Name of where we pretend to think the frame pointer points.\n    Normally, this is \"%fp\", but if we are in a leaf procedure,\n@@ -271,46 +273,6 @@ move_pic_label (op, mode)\n     return 1;\n   return 0;\n }\n-\f\n-/* The rtx for the global offset table which is a special form\n-   that *is* a position independent symbolic constant.  */\n-rtx pic_pc_rtx;\n-\n-/* Ensure that we are not using patterns that are not OK with PIC.  */\n-\n-int\n-check_pic (i)\n-     int i;\n-{\n-  switch (flag_pic)\n-    {\n-    case 1:\n-      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n-\t  || (GET_CODE (recog_operand[i]) == CONST\n-\t      && ! rtx_equal_p (pic_pc_rtx, recog_operand[i])))\n-\tabort ();\n-    case 2:\n-    default:\n-      return 1;\n-    }\n-}\n-\n-/* Return true if X is an address which needs a temporary register when \n-   reloaded while generating PIC code.  */\n-\n-int\n-pic_address_needs_scratch (x)\n-     rtx x;\n-{\n-  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))\n-    return 1;\n-\n-  return 0;\n-}\n \n int\n memop (op, mode)\n@@ -621,6 +583,46 @@ reg_unused_after (reg, insn)\n   return 1;\n }\n \f\n+/* The rtx for the global offset table which is a special form\n+   that *is* a position independent symbolic constant.  */\n+static rtx pic_pc_rtx;\n+\n+/* Ensure that we are not using patterns that are not OK with PIC.  */\n+\n+int\n+check_pic (i)\n+     int i;\n+{\n+  switch (flag_pic)\n+    {\n+    case 1:\n+      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n+\t  || (GET_CODE (recog_operand[i]) == CONST\n+\t      && ! rtx_equal_p (pic_pc_rtx, recog_operand[i])))\n+\tabort ();\n+    case 2:\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Return true if X is an address which needs a temporary register when \n+   reloaded while generating PIC code.  */\n+\n+int\n+pic_address_needs_scratch (x)\n+     rtx x;\n+{\n+  /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Legitimize PIC addresses.  If the address is already position-independent,\n    we return ORIG.  Newly generated position-independent addresses go into a\n    reg.  This is REG if non zero, otherwise we allocate register(s) as\n@@ -1526,6 +1528,8 @@ find_addr_reg (addr)\n   abort ();\n }\n \n+#if 0 /* not currently used */\n+\n void\n output_sized_memop (opname, mode, signedp)\n      char *opname;\n@@ -1560,6 +1564,7 @@ output_move_with_extension (operands)\n   else\n     abort ();\n }\n+#endif /* not currently used */\n \f\n #if 0\n /* ??? These are only used by the movstrsi pattern, but we get better code"}, {"sha": "473180487e9af9b330b87a608f1846e7eee3c80e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=6a4bb1fae14bd504287a10bec02dafe2a455d1de", "patch": "@@ -519,7 +519,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    normally.  \n    \n    We put %f0/%f1 last among the float registers, so as to make it more\n-   likely that a pseduo-register which dies in the float return register\n+   likely that a pseudo-register which dies in the float return register\n    will get allocated to the float return register, thus saving a move\n    instruction at the end of the function.  */\n #define REG_ALLOC_ORDER \\\n@@ -886,10 +886,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n } while (0)\n \n-/* Two views of the size of the current frame.  */\n-extern int actual_fsize;\n-extern int apparent_fsize;\n-\n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n    SIZE is an int: how many units of temporary storage to allocate.\n@@ -978,7 +974,7 @@ extern union tree_node *current_function_decl;\n #define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled)\t\\\n   (TARGET_FRW ? sparc_frw_eligible_for_epilogue_delay (trial, slots_filled) \\\n    : eligible_for_epilogue_delay (trial, slots_filled))\n-\n+\f\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n@@ -1040,7 +1036,7 @@ extern union tree_node *current_function_decl;\n   emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\t\t\t\\\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), low_cxt);\\\n }\n-\n+\f\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n extern struct rtx_def *sparc_builtin_saveregs ();"}, {"sha": "dcb96e9eb9b9c789d1a2e5887b4845a5fc7f6f0f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 207, "deletions": 205, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4bb1fae14bd504287a10bec02dafe2a455d1de/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=6a4bb1fae14bd504287a10bec02dafe2a455d1de", "patch": "@@ -772,6 +772,88 @@\n \f\n ;; Move instructions\n \n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n+\t(match_operand:QI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\n+   || operands[1] == const0_rtx\"\n+  \"@\n+   mov %1,%0\n+   sethi %%hi(%a1),%0\n+   ldub %1,%0\n+   stb %r1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"*,1,*,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t\t      (match_operand 2 \"immediate_operand\" \"in\")) 0))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t(match_operand:QI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;stb %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n+\t(match_operand:HI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\n+   || operands[1] == const0_rtx\"\n+  \"@\n+   mov %1,%0\n+   sethi %%hi(%a1),%0\n+   lduh %1,%0\n+   sth %r1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   (set_attr \"length\" \"*,1,*,1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand 2 \"immediate_operand\" \"in\")))]\n+  \"\"\n+  \"or %1,%%lo(%a2),%0\"\n+  [(set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:HI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t(match_operand:HI 1 \"reg_or_0_operand\" \"rJ\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"sethi %%hi(%a0),%2\\;sth %r1,[%2+%%lo(%a0)]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"2\")])\n+\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n@@ -883,23 +965,6 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:DI 2 \"immediate_operand\" \"in\")))]\n-  \"\"\n-  \"*\n-{\n-  /* Don't output a 64 bit constant, since we can't trust the assembler to\n-     handle it correctly.  */\n-  if (GET_CODE (operands[2]) == CONST_DOUBLE)\n-    operands[2] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (operands[2]));\n-  return \\\"or %R1,%%lo(%a2),%R0\\\";\n-}\"\n-  ;; Need to set length for this arith insn because operand2\n-  ;; is not an \"arith_operand\".\n-  [(set_attr \"length\" \"1\")])\n-\n ;; For PIC, symbol_refs are put inside unspec so that the optimizer won't\n ;; confuse them with real addresses.\n (define_insn \"\"\n@@ -912,6 +977,8 @@\n   ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n+;; ??? Can the next two be moved above the PIC stuff?\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -931,87 +998,51 @@\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"2\")])\n \n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, HImode))\n+  if (emit_move_sequence (operands, DImode))\n     DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n-\t(match_operand:HI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q,r,r,?f,?f,?Q\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,r,Q,i,f,Q,f\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\n    || operands[1] == const0_rtx\"\n-  \"@\n-   mov %1,%0\n-   sethi %%hi(%a1),%0\n-   lduh %1,%0\n-   sth %r1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")\n-   (set_attr \"length\" \"*,1,*,1\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand 2 \"immediate_operand\" \"in\")))]\n-  \"\"\n-  \"or %1,%%lo(%a2),%0\"\n-  [(set_attr \"length\" \"1\")])\n-\n-(define_insn \"\"\n-  [(set (mem:HI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n-\t(match_operand:HI 1 \"reg_or_0_operand\" \"rJ\"))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"\"\n-  \"sethi %%hi(%a0),%2\\;sth %r1,[%2+%%lo(%a0)]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n+  \"*\n {\n-  if (emit_move_sequence (operands, QImode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,Q\")\n-\t(match_operand:QI 1 \"move_operand\" \"rI,K,Q,rJ\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\n-   || operands[1] == const0_rtx\"\n-  \"@\n-   mov %1,%0\n-   sethi %%hi(%a1),%0\n-   ldub %1,%0\n-   stb %r1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")\n-   (set_attr \"length\" \"*,1,*,1\")])\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"move,store,load,multi,fp,fpload,fpstore\")\n+   (set_attr \"length\" \"2,3,3,3,2,3,3\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n-\t\t\t      (match_operand 2 \"immediate_operand\" \"in\")) 0))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:DI 2 \"immediate_operand\" \"in\")))]\n   \"\"\n-  \"or %1,%%lo(%a2),%0\"\n+  \"*\n+{\n+  /* Don't output a 64 bit constant, since we can't trust the assembler to\n+     handle it correctly.  */\n+  if (GET_CODE (operands[2]) == CONST_DOUBLE)\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_LOW (operands[2]));\n+  return \\\"or %R1,%%lo(%a2),%R0\\\";\n+}\"\n+  ;; Need to set length for this arith insn because operand2\n+  ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n-(define_insn \"\"\n-  [(set (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n-\t(match_operand:QI 1 \"reg_or_0_operand\" \"rJ\"))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n-  \"\"\n-  \"sethi %%hi(%a0),%2\\;stb %r1,[%2+%%lo(%a0)]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"2\")])\n+;; ??? There's no symbolic (set (mem:DI ...) ...).\n+\f\n+;; Block move insns.\n \n ;; ??? We get better code without it.  See output_block_move in sparc.c.\n \n@@ -1062,91 +1093,78 @@\n \f\n ;; Floating point move insns\n \n-;; This pattern forces (set (reg:TF ...) (const_double ...))\n+;; This pattern forces (set (reg:SF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory.\n-;; It must come before the more general movtf pattern.\n+;; It must come before the more general movsf pattern.\n (define_insn \"\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=?r,f,o\")\n-\t(match_operand:TF 1 \"\" \"?E,m,G\"))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m\")\n+\t(match_operand:SF 1 \"\" \"?E,m,G\"))]\n   \"TARGET_FPU && GET_CODE (operands[1]) == CONST_DOUBLE\"\n   \"*\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      return output_move_quad (operands);\n+      return singlemove_string (operands);\n     case 1:\n-      return output_fp_move_quad (operands);\n+      return \\\"ld %1,%0\\\";\n     case 2:\n-      operands[1] = adj_offsettable_operand (operands[0], 4);\n-      operands[2] = adj_offsettable_operand (operands[0], 8);\n-      operands[3] = adj_offsettable_operand (operands[0], 12);\n-      return \\\"st %%g0,%0\\;st %%g0,%1\\;st %%g0,%2\\;st %%g0,%3\\\";\n+      return \\\"st %%g0,%0\\\";\n     }\n }\"\n   [(set_attr \"type\" \"load,fpload,store\")\n-   (set_attr \"length\" \"5,5,5\")])\n+   (set_attr \"length\" \"2,1,1\")])\n \n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t(match_operand:TF 1 \"general_operand\" \"\"))]\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, TFmode))\n+  if (emit_move_sequence (operands, SFmode))\n     DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,Q,Q,f,&r\")\n-\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,f,r,Q,Q\"))]\n+  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,f,r,Q,Q\")\n+\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,Q,Q,f,r\"))]\n   \"TARGET_FPU\n-   && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_quad (operands);\n-  return output_move_quad (operands);\n-}\"\n-  [(set_attr \"type\" \"fp,move,fpstore,store,fpload,load\")\n-   (set_attr \"length\" \"4,4,5,5,5,5\")])\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   fmovs %1,%0\n+   mov %1,%0\n+   ld %1,%0\n+   ld %1,%0\n+   st %r1,%0\n+   st %r1,%0\"\n+  [(set_attr \"type\" \"fp,move,fpload,load,fpstore,store\")])\n \n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n ;; when -mno-fpu.\n \n (define_insn \"\"\n-  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q,&r\")\n-\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"r,r,Q\"))]\n+  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n+\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"r,Q,r\"))]\n   \"! TARGET_FPU\n-   && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_quad (operands);\n-  return output_move_quad (operands);\n-}\"\n-  [(set_attr \"type\" \"move,store,load\")\n-   (set_attr \"length\" \"4,5,5\")])\n+   && (register_operand (operands[0], SFmode)\n+       || register_operand (operands[1], SFmode))\"\n+  \"@\n+   mov %1,%0\n+   ld %1,%0\n+   st %r1,%0\"\n+  [(set_attr \"type\" \"move,load,store\")])\n \n (define_insn \"\"\n-  [(set (mem:TF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n-\t(match_operand:TF 1 \"reg_or_0_operand\" \"rf,G\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n+  [(set (mem:SF (match_operand:SI 0 \"symbolic_operand\" \"i\"))\n+\t(match_operand:SF 1 \"reg_or_0_operand\" \"rfG\"))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n   \"\"\n-  \"*\n-{\n-  output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n-  if (which_alternative == 0)\n-    return \\\"std %1,[%2+%%lo(%a0)]\\;std %S1,[%2+%%lo(%a0+8)]\\\";\n-  else\n-    return \\\"st %%g0,[%2+%%lo(%a0)]\\;st %%g0,[%2+%%lo(%a0+4)]\\; st %%g0,[%2+%%lo(%a0+8)]\\;st %%g0,[%2+%%lo(%a0+12)]\\\";\n-}\"\n+  \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n   [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"5\")])\n-\f\n+   (set_attr \"length\" \"2\")])\n+\n ;; This pattern forces (set (reg:DF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory.\n ;; It must come before the more general movdf pattern.\n@@ -1237,107 +1255,91 @@\n }\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"3\")])\n-\f\n-;; Double-word move insns.\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, DImode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q,r,r,?f,?f,?Q\")\n-\t(match_operand:DI 1 \"general_operand\" \"r,r,Q,i,f,Q,f\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\n-   || operands[1] == const0_rtx\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\"\n-  [(set_attr \"type\" \"move,store,load,multi,fp,fpload,fpstore\")\n-   (set_attr \"length\" \"2,3,3,3,2,3,3\")])\n-\n-;; Floating-point move insns.\n \n-;; This pattern forces (set (reg:SF ...) (const_double ...))\n+;; This pattern forces (set (reg:TF ...) (const_double ...))\n ;; to be reloaded by putting the constant into memory.\n-;; It must come before the more general movsf pattern.\n+;; It must come before the more general movtf pattern.\n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m\")\n-\t(match_operand:SF 1 \"\" \"?E,m,G\"))]\n+  [(set (match_operand:TF 0 \"general_operand\" \"=?r,f,o\")\n+\t(match_operand:TF 1 \"\" \"?E,m,G\"))]\n   \"TARGET_FPU && GET_CODE (operands[1]) == CONST_DOUBLE\"\n   \"*\n {\n   switch (which_alternative)\n     {\n     case 0:\n-      return singlemove_string (operands);\n+      return output_move_quad (operands);\n     case 1:\n-      return \\\"ld %1,%0\\\";\n+      return output_fp_move_quad (operands);\n     case 2:\n-      return \\\"st %%g0,%0\\\";\n+      operands[1] = adj_offsettable_operand (operands[0], 4);\n+      operands[2] = adj_offsettable_operand (operands[0], 8);\n+      operands[3] = adj_offsettable_operand (operands[0], 12);\n+      return \\\"st %%g0,%0\\;st %%g0,%1\\;st %%g0,%2\\;st %%g0,%3\\\";\n     }\n }\"\n   [(set_attr \"type\" \"load,fpload,store\")\n-   (set_attr \"length\" \"2,1,1\")])\n+   (set_attr \"length\" \"5,5,5\")])\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SFmode))\n+  if (emit_move_sequence (operands, TFmode))\n     DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,f,r,Q,Q\")\n-\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,Q,Q,f,r\"))]\n+  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,Q,Q,f,&r\")\n+\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,f,r,Q,Q\"))]\n   \"TARGET_FPU\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"@\n-   fmovs %1,%0\n-   mov %1,%0\n-   ld %1,%0\n-   ld %1,%0\n-   st %r1,%0\n-   st %r1,%0\"\n-  [(set_attr \"type\" \"fp,move,fpload,load,fpstore,store\")])\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode))\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_quad (operands);\n+  return output_move_quad (operands);\n+}\"\n+  [(set_attr \"type\" \"fp,move,fpstore,store,fpload,load\")\n+   (set_attr \"length\" \"4,4,5,5,5,5\")])\n \n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n ;; when -mno-fpu.\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q\")\n-\t(match_operand:SF 1 \"reg_or_nonsymb_mem_operand\" \"r,Q,r\"))]\n+  [(set (match_operand:TF 0 \"reg_or_nonsymb_mem_operand\" \"=r,Q,&r\")\n+\t(match_operand:TF 1 \"reg_or_nonsymb_mem_operand\" \"r,r,Q\"))]\n   \"! TARGET_FPU\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"@\n-   mov %1,%0\n-   ld %1,%0\n-   st %r1,%0\"\n-  [(set_attr \"type\" \"move,load,store\")])\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode))\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_quad (operands);\n+  return output_move_quad (operands);\n+}\"\n+  [(set_attr \"type\" \"move,store,load\")\n+   (set_attr \"length\" \"4,5,5\")])\n \n (define_insn \"\"\n-  [(set (mem:SF (match_operand:SI 0 \"symbolic_operand\" \"i\"))\n-\t(match_operand:SF 1 \"reg_or_0_operand\" \"rfG\"))\n-   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  [(set (mem:TF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n+\t(match_operand:TF 1 \"reg_or_0_operand\" \"rf,G\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r\"))]\n   \"\"\n-  \"sethi %%hi(%a0),%2\\;st %r1,[%2+%%lo(%a0)]\"\n+  \"*\n+{\n+  output_asm_insn (\\\"sethi %%hi(%a0),%2\\\", operands);\n+  if (which_alternative == 0)\n+    return \\\"std %1,[%2+%%lo(%a0)]\\;std %S1,[%2+%%lo(%a0+8)]\\\";\n+  else\n+    return \\\"st %%g0,[%2+%%lo(%a0)]\\;st %%g0,[%2+%%lo(%a0+4)]\\; st %%g0,[%2+%%lo(%a0+8)]\\;st %%g0,[%2+%%lo(%a0+12)]\\\";\n+}\"\n   [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"2\")])\n+   (set_attr \"length\" \"5\")])\n \f\n ;;- zero extension instructions\n \n@@ -1913,8 +1915,8 @@\n   \"TARGET_V8\"\n   \"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udivcc %1,%2,%0\"\n   [(set_attr \"length\" \"5\")])\n-\n-;;- and instructions\n+\f\n+;;- Boolean instructions\n ;; We define DImode `and` so with DImode `not` we can get\n ;; DImode `andn`.  Other combinations are possible.\n "}]}