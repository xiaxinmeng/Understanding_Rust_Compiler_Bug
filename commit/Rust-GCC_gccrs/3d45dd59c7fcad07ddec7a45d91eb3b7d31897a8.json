{"sha": "3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0NWRkNTljN2ZjYWQwN2RkZWM3YTQ1ZDkxZWIzYjdkMzE4OTdhOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-14T14:52:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-14T14:52:07Z"}, "message": "re PR tree-optimization/34043 (Missed optimization causing extra loads and stores when using x86_64 builtin function together with aggregate types.)\n\n2008-03-14  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/34043\n\tPR tree-optimization/33989\n\t* tree-ssa-pre.c (execute_pre): Allow SCCVN to do insertion\n\twhen doing FRE.\n\t(bitmap_find_leader): Use extra argument to verify dominance\n\trelationship inside a basic-block.\n\t(can_PRE_operation): Add VIEW_CONVERT_EXPR.\n\t(find_leader_in_sets): Adjust.\n\t(create_component_ref_by_pieces): Take extra argument for\n\tdominance check, handle lookup failures.\n\t(find_or_generate_expression): Likewise.\n\t(create_expression_by_pieces): Likewise.\n\t(insert_into_preds_of_block): Adjust.\n\t(create_value_expr_from): If asked for, verify all operands\n\tare in the blocks AVAIL_OUT set.\n\t(make_values_for_stmt): Check for SSA_NAMEs that are life\n\tover an abnormal edge.\n\t(compute_avail): Remove such check.\n\t(do_SCCVN_insertion): New function.\n\t(eliminate): If we do not find a leader suitable for replacement\n\tinsert a replacement expression from SCCVN if available.\n\t* tree-ssa-sccvn.h (run_scc_vn): Update prototype.\n\t(struct vn_ssa_aux): Add needs_insertion flag.\n\t* tree-ssa-sccvn.c (may_insert): New global flag.\n\t(copy_reference_ops_from_ref): Value-number union member access\n\tbased on its size, not type and member if insertion is allowed.\n\t(visit_reference_op_load): For a weak match from union type\n\tpunning lookup a view-converted value and insert a SSA_NAME\n\tfor that value if that is not found.\n\t(visit_use): Make dumps shorter.  Do not disallow value numbering\n\tSSA_NAMEs that are life over an abnormal edge to constants.\n\t(free_scc_vn): Release inserted SSA_NAMEs.\n\t(run_scc_vn): New flag to specify whether insertion is allowed.\n\tProcess SSA_NAMEs in forward order.\n\t* tree-ssa-loop-im.c (for_each_index): Handle invariant\n\tADDR_EXPRs inside VIEW_CONVERT_EXPR.\n\t* fold-const.c (fold_unary): Fold VIEW_CONVERT_EXPRs from/to\n\tpointer type to/from integral types that do not change the\n\tprecision to regular conversions.\n\n\t* gcc.dg/tree-ssa/ssa-fre-7.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-8.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-9.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-10.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-17.c: Likewise.\n\nFrom-SVN: r133218", "tree": {"sha": "0508ac0fafc550eb92cb66bcb48ef0d5a3af1d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0508ac0fafc550eb92cb66bcb48ef0d5a3af1d88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c539732f969e784725ca51dd9ff66b32a2c198cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c539732f969e784725ca51dd9ff66b32a2c198cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c539732f969e784725ca51dd9ff66b32a2c198cd"}], "stats": {"total": 502, "additions": 442, "deletions": 60}, "files": [{"sha": "3178dae1b9bb1c277800f3585539f00a4323a8d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -1,3 +1,45 @@\n+2008-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34043\n+\tPR tree-optimization/33989\n+\t* tree-ssa-pre.c (execute_pre): Allow SCCVN to do insertion\n+\twhen doing FRE.\n+\t(bitmap_find_leader): Use extra argument to verify dominance\n+\trelationship inside a basic-block.\n+\t(can_PRE_operation): Add VIEW_CONVERT_EXPR.\n+\t(find_leader_in_sets): Adjust.\n+\t(create_component_ref_by_pieces): Take extra argument for\n+\tdominance check, handle lookup failures.\n+\t(find_or_generate_expression): Likewise.\n+\t(create_expression_by_pieces): Likewise.\n+\t(insert_into_preds_of_block): Adjust.\n+\t(create_value_expr_from): If asked for, verify all operands\n+\tare in the blocks AVAIL_OUT set.\n+\t(make_values_for_stmt): Check for SSA_NAMEs that are life\n+\tover an abnormal edge.\n+\t(compute_avail): Remove such check.\n+\t(do_SCCVN_insertion): New function.\n+\t(eliminate): If we do not find a leader suitable for replacement\n+\tinsert a replacement expression from SCCVN if available.\n+\t* tree-ssa-sccvn.h (run_scc_vn): Update prototype.\n+\t(struct vn_ssa_aux): Add needs_insertion flag.\n+\t* tree-ssa-sccvn.c (may_insert): New global flag.\n+\t(copy_reference_ops_from_ref): Value-number union member access\n+\tbased on its size, not type and member if insertion is allowed.\n+\t(visit_reference_op_load): For a weak match from union type\n+\tpunning lookup a view-converted value and insert a SSA_NAME\n+\tfor that value if that is not found.\n+\t(visit_use): Make dumps shorter.  Do not disallow value numbering\n+\tSSA_NAMEs that are life over an abnormal edge to constants.\n+\t(free_scc_vn): Release inserted SSA_NAMEs.\n+\t(run_scc_vn): New flag to specify whether insertion is allowed.\n+\tProcess SSA_NAMEs in forward order.\n+\t* tree-ssa-loop-im.c (for_each_index): Handle invariant\n+\tADDR_EXPRs inside VIEW_CONVERT_EXPR.\n+\t* fold-const.c (fold_unary): Fold VIEW_CONVERT_EXPRs from/to\n+\tpointer type to/from integral types that do not change the\n+\tprecision to regular conversions.\n+\n 2008-03-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/extend.texi (X86 Built-in Functions) [__builtin_ia32_psll?,"}, {"sha": "4dc4ad72e3cf3a9ace81943fbbc0cca87f8f74f5", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -7961,19 +7961,24 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \n       /* For integral conversions with the same precision or pointer\n \t conversions use a NOP_EXPR instead.  */\n-      if ((INTEGRAL_TYPE_P (type) && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t   && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0))\n-\t   /* Do not muck with VIEW_CONVERT_EXPRs that convert from\n-\t      a sub-type to its base type as generated by the Ada FE.  */\n-\t   && !TREE_TYPE (TREE_TYPE (op0)))\n-\t  || (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE (op0))))\n+      if ((INTEGRAL_TYPE_P (type)\n+\t   || POINTER_TYPE_P (type))\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t      || POINTER_TYPE_P (TREE_TYPE (op0)))\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0))\n+\t  /* Do not muck with VIEW_CONVERT_EXPRs that convert from\n+\t     a sub-type to its base type as generated by the Ada FE.  */\n+\t  && !(INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t       && TREE_TYPE (TREE_TYPE (op0))))\n \treturn fold_convert (type, op0);\n \n       /* Strip inner integral conversions that do not change the precision.  */\n       if ((TREE_CODE (op0) == NOP_EXPR\n \t   || TREE_CODE (op0) == CONVERT_EXPR)\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n+\t      || POINTER_TYPE_P (TREE_TYPE (op0)))\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t      || POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (op0, 0))))\n \t  && (TYPE_PRECISION (TREE_TYPE (op0))\n \t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op0, 0)))))\n \treturn fold_build1 (VIEW_CONVERT_EXPR, type, TREE_OPERAND (op0, 0));"}, {"sha": "fde203efb177cbfb03cacc14e3b2c1871b092ea9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -1,3 +1,13 @@\n+2008-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34043\n+\tPR tree-optimization/33989\n+\t* gcc.dg/tree-ssa/ssa-fre-7.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-8.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-10.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-17.c: Likewise.\n+\n 2008-03-14  H.J. Lu  <hongjiu.lu@intel.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "0e59df53ee12d2f00e72e7ae7e576478044d4b51", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-10.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+union loc {  unsigned reg; signed offset; };\n+void __frame_state_for (volatile char *state_in, int x)\n+{\n+    union loc fs;\n+    int reg;\n+    for (;;)     {\n+        switch (x)  {\n+\t    case 0:\n+\t\t*state_in = fs.reg;\n+\t    case 1:\n+\t\t*state_in = fs.offset;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Insertions: 0\" \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "a66adeb8c999b21b0d0b6a80883d8f361b8a4a4c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-7.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-7.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-details -fdump-tree-optimized\" } */\n+\n+struct X {\n+  int i;\n+  union {\n+    int j;\n+    int k;\n+    float f;\n+  } u;\n+};\n+\n+int foo(int j)\n+{\n+  struct X a;\n+\n+  a.u.j = j;\n+  a.u.f = a.u.f;\n+  a.u.f = a.u.f;\n+  a.u.j = a.u.j;\n+  a.u.f = a.u.f;\n+  return a.u.k;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Inserted pretmp\" 1 \"fre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced a.u.f with pretmp\" 3 \"fre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Replaced a.u.k with j\" 1 \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"= VIEW_CONVERT_EXPR<float>\\\\\\(j_\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"return j\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "84a9aeb60ee9f5220c82b82ffce5645fb70224b1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-8.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n+\n+union U {\n+  int i;\n+  float f;\n+};\n+int foo(int i, int b)\n+{\n+  union U u;\n+  if (b)\n+    {\n+      i = i << 2;\n+      u.i = i;\n+      return u.f;\n+    }\n+  else\n+    {\n+      i = i << 2;\n+      u.i = i;\n+      return u.f;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Replaced u.f with pretmp\" 2 \"fre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Inserted pretmp\" 2 \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "18595ed6fe5150ee96adda165f946dfb22ff31d6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-9.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-9.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-stats\" } */\n+\n+union loc {\n+    unsigned reg;\n+    signed offset;\n+};\n+void __frame_state_for2 (volatile char *state_in)\n+{\n+    union loc fs;\n+    {\n+\t*state_in = fs.reg;\n+\t*state_in = fs.offset;\n+    }\n+}\n+void __frame_state_for1 (volatile char *state_in)\n+{\n+    union loc fs;\n+    for (;;)\n+    {\n+\t*state_in = fs.offset;\n+\t*state_in = fs.reg;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 2 \"fre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Insertions: 1\" 2 \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "d4274dbe0815b63cb6b0f182f7a5ab048caac12d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+typedef union {\n+  int i;\n+  float f;\n+} U;\n+\n+int foo(U *u, int b, int i)\n+{\n+  u->i = 0;\n+  if (b)\n+    u->i = i;\n+  return u->i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Eliminated: 1\" \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "91c18174bc091d0f419eef2412c7d581d9a956fd", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -208,6 +208,10 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \tcase CONSTRUCTOR:\n \t  return true;\n \n+\tcase ADDR_EXPR:\n+\t  gcc_assert (is_gimple_min_invariant (*addr_p));\n+\t  return true;\n+\n \tcase TARGET_MEM_REF:\n \t  idx = &TMR_BASE (*addr_p);\n \t  if (*idx"}, {"sha": "9a5fa4444074b0c83f8e584c1bce092729b62a3c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 150, "deletions": 46, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -376,15 +376,15 @@ static struct\n } pre_stats;\n \n static bool do_partial_partial;\n-static tree bitmap_find_leader (bitmap_set_t, tree);\n+static tree bitmap_find_leader (bitmap_set_t, tree, tree);\n static void bitmap_value_insert_into_set (bitmap_set_t, tree);\n static void bitmap_value_replace_in_set (bitmap_set_t, tree);\n static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n static bool bitmap_set_contains_value (bitmap_set_t, tree);\n static void bitmap_insert_into_set (bitmap_set_t, tree);\n static bitmap_set_t bitmap_set_new (void);\n-static tree create_expression_by_pieces (basic_block, tree, tree);\n-static tree find_or_generate_expression (basic_block, tree, tree);\n+static tree create_expression_by_pieces (basic_block, tree, tree, tree);\n+static tree find_or_generate_expression (basic_block, tree, tree, tree);\n \n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n@@ -954,9 +954,9 @@ find_leader_in_sets (tree expr, bitmap_set_t set1, bitmap_set_t set2)\n {\n   tree result;\n \n-  result = bitmap_find_leader (set1, expr);\n+  result = bitmap_find_leader (set1, expr, NULL_TREE);\n   if (!result && set2)\n-    result = bitmap_find_leader (set2, expr);\n+    result = bitmap_find_leader (set2, expr, NULL_TREE);\n   return result;\n }\n \n@@ -1394,11 +1394,12 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n }\n \n /* Find the leader for a value (i.e., the name representing that\n-   value) in a given set, and return it.  Return NULL if no leader is\n-   found.  */\n+   value) in a given set, and return it.  If STMT is non-NULL it\n+   makes sure the defining statement for the leader dominates it.\n+   Return NULL if no leader is found.  */\n \n static tree\n-bitmap_find_leader (bitmap_set_t set, tree val)\n+bitmap_find_leader (bitmap_set_t set, tree val, tree stmt)\n {\n   if (val == NULL)\n     return NULL;\n@@ -1425,7 +1426,17 @@ bitmap_find_leader (bitmap_set_t set, tree val)\n \n       EXECUTE_IF_AND_IN_BITMAP (exprset->expressions,\n \t\t\t\tset->expressions, 0, i, bi)\n-\treturn expression_for_id (i);\n+\t{\n+\t  tree val = expression_for_id (i);\n+\t  if (stmt)\n+\t    {\n+\t      tree def_stmt = SSA_NAME_DEF_STMT (val);\n+\t      if (bb_for_stmt (def_stmt) == bb_for_stmt (stmt)\n+\t\t  && stmt_ann (def_stmt)->uid >= stmt_ann (stmt)->uid)\n+\t\tcontinue;\n+\t    }\n+\t  return val;\n+\t}\n     }\n   return NULL;\n }\n@@ -2107,6 +2118,7 @@ can_PRE_operation (tree op)\n     || COMPARISON_CLASS_P (op)\n     || TREE_CODE (op) == INDIRECT_REF\n     || TREE_CODE (op) == COMPONENT_REF\n+    || TREE_CODE (op) == VIEW_CONVERT_EXPR\n     || TREE_CODE (op) == CALL_EXPR\n     || TREE_CODE (op) == ARRAY_REF;\n }\n@@ -2136,14 +2148,15 @@ static VEC(tree, heap) *need_creation;\n    are doing.\n */\n static tree\n-create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n+create_component_ref_by_pieces (basic_block block, tree expr, tree stmts,\n+\t\t\t\ttree domstmt)\n {\n   tree genop = expr;\n   tree folded;\n \n   if (TREE_CODE (genop) == VALUE_HANDLE)\n     {\n-      tree found = bitmap_find_leader (AVAIL_OUT (block), expr);\n+      tree found = bitmap_find_leader (AVAIL_OUT (block), expr, domstmt);\n       if (found)\n \treturn found;\n     }\n@@ -2163,16 +2176,18 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n \ttree op1, op2, op3;\n \top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n-\t\t\t\t\t      stmts);\n+\t\t\t\t\t      stmts, domstmt);\n \top1 = TREE_OPERAND (genop, 1);\n \tif (TREE_CODE (op1) == VALUE_HANDLE)\n-\t  op1 = find_or_generate_expression (block, op1, stmts);\n+\t  op1 = find_or_generate_expression (block, op1, stmts, domstmt);\n \top2 = TREE_OPERAND (genop, 2);\n \tif (op2 && TREE_CODE (op2) == VALUE_HANDLE)\n-\t  op2 = find_or_generate_expression (block, op2, stmts);\n+\t  op2 = find_or_generate_expression (block, op2, stmts, domstmt);\n \top3 = TREE_OPERAND (genop, 3);\n \tif (op3 && TREE_CODE (op3) == VALUE_HANDLE)\n-\t  op3 = find_or_generate_expression (block, op3, stmts);\n+\t  op3 = find_or_generate_expression (block, op3, stmts, domstmt);\n+\tif (!op0 || !op1)\n+\t  return NULL_TREE;\n \tfolded = build4 (ARRAY_REF, TREE_TYPE (genop), op0, op1,\n \t\t\t      op2, op3);\n \treturn folded;\n@@ -2183,7 +2198,9 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n \ttree op1;\n \top0 = create_component_ref_by_pieces (block,\n \t\t\t\t\t      TREE_OPERAND (genop, 0),\n-\t\t\t\t\t      stmts);\n+\t\t\t\t\t      stmts, domstmt);\n+\tif (!op0)\n+\t  return NULL_TREE;\n \t/* op1 should be a FIELD_DECL, which are represented by\n \t   themselves.  */\n \top1 = TREE_OPERAND (genop, 1);\n@@ -2195,7 +2212,9 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n     case INDIRECT_REF:\n       {\n \ttree op1 = TREE_OPERAND (genop, 0);\n-\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts, domstmt);\n+\tif (!genop1)\n+\t  return NULL_TREE;\n \n \tfolded = fold_build1 (TREE_CODE (genop), TREE_TYPE (genop),\n \t\t\t      genop1);\n@@ -2222,12 +2241,17 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n    EXPR is the expression to find a leader or generate for.\n    STMTS is the statement list to put the inserted expressions on.\n    Returns the SSA_NAME of the LHS of the generated expression or the\n-   leader.  */\n+   leader.\n+   DOMSTMT if non-NULL is a statement that should be dominated by\n+   all uses in the generated expression.  If DOMSTMT is non-NULL this\n+   routine can fail and return NULL_TREE.  Otherwise it will assert\n+   on failure.  */\n \n static tree\n-find_or_generate_expression (basic_block block, tree expr, tree stmts)\n+find_or_generate_expression (basic_block block, tree expr, tree stmts,\n+\t\t\t     tree domstmt)\n {\n-  tree genop = bitmap_find_leader (AVAIL_OUT (block), expr);\n+  tree genop = bitmap_find_leader (AVAIL_OUT (block), expr, domstmt);\n \n   /* If it's still NULL, it must be a complex expression, so generate\n      it recursively.  */\n@@ -2247,10 +2271,14 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n \t  if (can_PRE_operation (genop))\n \t    {\n \t      handled = true;\n-\t      genop = create_expression_by_pieces (block, genop, stmts);\n+\t      genop = create_expression_by_pieces (block, genop, stmts,\n+\t\t\t\t\t\t   domstmt);\n \t      break;\n \t    }\n \t}\n+      if (!handled && domstmt)\n+\treturn NULL_TREE;\n+\n       gcc_assert (handled);\n     }\n   return genop;\n@@ -2269,10 +2297,15 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n    partially or fully redundant.  Those that are will be either made\n    fully redundant during the next iteration of insert (for partially\n    redundant ones), or eliminated by eliminate (for fully redundant\n-   ones).  */\n+   ones).\n+\n+   If DOMSTMT is non-NULL then we make sure that all uses in the\n+   expressions dominate that statement.  In this case the function\n+   can return NULL_TREE to signal failure.  */\n \n static tree\n-create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n+create_expression_by_pieces (basic_block block, tree expr, tree stmts,\n+\t\t\t     tree domstmt)\n {\n   tree temp, name;\n   tree folded, forced_stmts, newexpr;\n@@ -2293,21 +2326,30 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tfn = CALL_EXPR_FN (expr);\n \tsc = CALL_EXPR_STATIC_CHAIN (expr);\n \n-\tgenfn = find_or_generate_expression (block, fn, stmts);\n+\tgenfn = find_or_generate_expression (block, fn, stmts, domstmt);\n+\tif (!genfn)\n+\t  return NULL_TREE;\n \n \tnargs = call_expr_nargs (expr);\n \tbuffer = (tree*) alloca (nargs * sizeof (tree));\n \n \tfor (i = 0; i < nargs; i++)\n \t  {\n \t    tree arg = CALL_EXPR_ARG (expr, i);\n-\t    buffer[i] = find_or_generate_expression (block, arg, stmts);\n+\t    buffer[i] = find_or_generate_expression (block, arg, stmts,\n+\t\t\t\t\t\t     domstmt);\n+\t    if (!buffer[i])\n+\t      return NULL_TREE;\n \t  }\n \n \tfolded = build_call_array (TREE_TYPE (expr), genfn, nargs, buffer);\n \tif (sc)\n-\t  CALL_EXPR_STATIC_CHAIN (folded) =\n-\t    find_or_generate_expression (block, sc, stmts);\n+\t  {\n+\t    CALL_EXPR_STATIC_CHAIN (folded) =\n+\t      find_or_generate_expression (block, sc, stmts, domstmt);\n+\t    if (!CALL_EXPR_STATIC_CHAIN (folded))\n+\t      return NULL_TREE;\n+\t  }\n \tfolded = fold (folded);\n \tbreak;\n       }\n@@ -2317,12 +2359,18 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tif (TREE_CODE (expr) == COMPONENT_REF\n \t    || TREE_CODE (expr) == ARRAY_REF)\n \t  {\n-\t    folded = create_component_ref_by_pieces (block, expr, stmts);\n+\t    folded = create_component_ref_by_pieces (block, expr, stmts,\n+\t\t\t\t\t\t     domstmt);\n+\t    if (!folded)\n+\t      return NULL_TREE;\n \t  }\n \telse\n \t  {\n \t    tree op1 = TREE_OPERAND (expr, 0);\n-\t    tree genop1 = find_or_generate_expression (block, op1, stmts);\n+\t    tree genop1 = find_or_generate_expression (block, op1, stmts,\n+\t\t\t\t\t\t       domstmt);\n+\t    if (!genop1)\n+\t      return NULL_TREE;\n \n \t    folded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t\t  genop1);\n@@ -2335,8 +2383,10 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree op2 = TREE_OPERAND (expr, 1);\n-\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n-\ttree genop2 = find_or_generate_expression (block, op2, stmts);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts, domstmt);\n+\ttree genop2 = find_or_generate_expression (block, op2, stmts, domstmt);\n+\tif (!genop1 || !genop2)\n+\t  return NULL_TREE;\n \tfolded = fold_build2 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      genop1, genop2);\n \tbreak;\n@@ -2345,7 +2395,9 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n     case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n-\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts, domstmt);\n+\tif (!genop1)\n+\t  return NULL_TREE;\n \tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n \t\t\t      genop1);\n \tbreak;\n@@ -2421,7 +2473,8 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   vn_add (name, v);\n   VN_INFO_GET (name)->valnum = name;\n   get_or_alloc_expression_id (name);\n-  bitmap_value_replace_in_set (NEW_SETS (block), name);\n+  if (!in_fre)\n+    bitmap_value_replace_in_set (NEW_SETS (block), name);\n   bitmap_value_replace_in_set (AVAIL_OUT (block), name);\n \n   pre_stats.insertions++;\n@@ -2497,7 +2550,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t{\n \t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t   eprime,\n-\t\t\t\t\t\t   stmts);\n+\t\t\t\t\t\t   stmts, NULL_TREE);\n \t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  bsi_insert_on_edge (pred, stmts);\n \t  avail[bprime->index] = builtexpr;\n@@ -2659,7 +2712,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t      vprime = get_value_handle (eprime);\n \t      gcc_assert (vprime);\n \t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t vprime);\n+\t\t\t\t\t\t vprime, NULL_TREE);\n \t      if (edoubleprime == NULL)\n \t\t{\n \t\t  avail[bprime->index] = eprime;\n@@ -2788,7 +2841,7 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t      vprime = get_value_handle (eprime);\n \t      gcc_assert (vprime);\n \t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t vprime);\n+\t\t\t\t\t\t vprime, NULL_TREE);\n \t      if (edoubleprime == NULL)\n \t\t{\n \t\t  by_all = false;\n@@ -2970,10 +3023,14 @@ find_existing_value_expr (tree t, VEC (tree, gc) *vuses)\n    replaced with the value handles of each of the operands of EXPR.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n-   any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n+   any).  Insert EXPR's operands into the EXP_GEN set for BLOCK.\n+\n+   If CHECK_AVAIL is true, checks availability of each operand in\n+   BLOCKs AVAIL_OUT set.  */\n \n static inline tree\n-create_value_expr_from (tree expr, basic_block block, VEC (tree, gc) *vuses)\n+create_value_expr_from (tree expr, basic_block block, VEC (tree, gc) *vuses,\n+\t\t\tbool check_avail)\n {\n   int i;\n   enum tree_code code = TREE_CODE (expr);\n@@ -3021,7 +3078,7 @@ create_value_expr_from (tree expr, basic_block block, VEC (tree, gc) *vuses)\n       /* Recursively value-numberize reference ops and tree lists.  */\n       if (REFERENCE_CLASS_P (op))\n \t{\n-\t  tree tempop = create_value_expr_from (op, block, vuses);\n+\t  tree tempop = create_value_expr_from (op, block, vuses, check_avail);\n \t  op = tempop ? tempop : op;\n \t  val = vn_lookup_or_add_with_vuses (op, vuses);\n \t  set_expression_vuses (op, vuses);\n@@ -3037,6 +3094,11 @@ create_value_expr_from (tree expr, basic_block block, VEC (tree, gc) *vuses)\n \tTREE_TYPE (val) = TREE_TYPE (TREE_OPERAND (vexpr, i));\n \n       TREE_OPERAND (vexpr, i) = val;\n+\n+      if (check_avail\n+\t  && TREE_CODE (val) == VALUE_HANDLE\n+\t  && !bitmap_set_contains_value (AVAIL_OUT (block), val))\n+\treturn NULL_TREE;\n     }\n   efi = find_existing_value_expr (vexpr, vuses);\n   if (efi)\n@@ -3271,12 +3333,13 @@ make_values_for_stmt (tree stmt, basic_block block)\n   vuses = copy_vuses_from_stmt (stmt);\n   STRIP_USELESS_TYPE_CONVERSION (rhs);\n   if (can_value_number_operation (rhs)\n-      && (!lhsval || !is_gimple_min_invariant (lhsval)))\n+      && (!lhsval || !is_gimple_min_invariant (lhsval))\n+      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n     {\n       /* For value numberable operation, create a\n \t duplicate expression with the operands replaced\n \t with the value handles of the original RHS.  */\n-      tree newt = create_value_expr_from (rhs, block, vuses);\n+      tree newt = create_value_expr_from (rhs, block, vuses, false);\n       if (newt)\n \t{\n \t  set_expression_vuses (newt, vuses);\n@@ -3480,8 +3543,6 @@ compute_avail (void)\n \t  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n \t\t   && !ann->has_volatile_ops\n \t\t   && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n-\t\t   && (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI\n-\t\t       (GIMPLE_STMT_OPERAND (stmt, 0)))\n \t\t   && !tree_could_throw_p (stmt))\n \t    {\n \t      if (make_values_for_stmt (stmt, block))\n@@ -3510,6 +3571,36 @@ compute_avail (void)\n   free (worklist);\n }\n \n+/* Insert the expression for SSA_VN that SCCVN thought would be simpler\n+   than the available expressions for it.  The insertion point is\n+   right before the first use in STMT.  Returns the SSA_NAME that should\n+   be used for replacement.  */\n+\n+static tree\n+do_SCCVN_insertion (tree stmt, tree ssa_vn)\n+{\n+  basic_block bb = bb_for_stmt (stmt);\n+  block_stmt_iterator bsi;\n+  tree expr, stmts;\n+\n+  /* First create a value expression from the expression we want\n+     to insert and associate it with the value handle for SSA_VN.  */\n+  expr = create_value_expr_from (VN_INFO (ssa_vn)->expr, bb, NULL, true);\n+  if (expr == NULL_TREE)\n+    return NULL_TREE;\n+  set_value_handle (expr, get_value_handle (ssa_vn));\n+\n+  /* Then use create_expression_by_pieces to generate a valid\n+     expression to insert at this point of the IL stream.  */\n+  stmts = alloc_stmt_list ();\n+  expr = create_expression_by_pieces (bb, expr, stmts, stmt);\n+  if (expr == NULL_TREE)\n+    return NULL_TREE;\n+  bsi = bsi_for_stmt (stmt);\n+  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\n+  return expr;\n+}\n \n /* Eliminate fully redundant computations.  */\n \n@@ -3540,7 +3631,20 @@ eliminate (void)\n \t      tree sprime;\n \n \t      sprime = bitmap_find_leader (AVAIL_OUT (b),\n-\t\t\t\t\t   get_value_handle (lhs));\n+\t\t\t\t\t   get_value_handle (lhs), NULL_TREE);\n+\n+\t      /* If there is no existing usable leader but SCCVN thinks\n+\t\t it has an expression it wants to use as replacement,\n+\t\t insert that.  */\n+\t      if (!sprime\n+\t\t  || sprime == lhs)\n+\t\t{\n+\t\t  tree val = VN_INFO (lhs)->valnum;\n+\t\t  if (val != VN_TOP\n+\t\t      && VN_INFO (val)->needs_insertion\n+\t\t      && can_PRE_operation (VN_INFO (val)->expr))\n+\t\t    sprime = do_SCCVN_insertion (stmt, val);\n+\t\t}\n \n \t      if (sprime\n \t\t  && sprime != lhs\n@@ -3837,7 +3941,7 @@ execute_pre (bool do_fre)\n     insert_fake_stores ();\n \n   /* Collect and value number expressions computed in each basic block.  */\n-  if (!run_scc_vn ())\n+  if (!run_scc_vn (do_fre))\n     {\n       if (!do_fre)\n \tremove_dead_inserted_code ();\n@@ -3885,8 +3989,8 @@ execute_pre (bool do_fre)\n     }\n   bsi_commit_edge_inserts ();\n \n-  free_scc_vn ();\n   clear_expression_ids ();\n+  free_scc_vn ();\n   if (!do_fre)\n     {\n       remove_dead_inserted_code ();"}, {"sha": "20d1498a2c994365436004a491b26a3c1ffe3e4e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -221,6 +221,9 @@ tree VN_TOP;\n static unsigned int next_dfs_num;\n static VEC (tree, heap) *sccstack;\n \n+static bool may_insert;\n+\n+\n DEF_VEC_P(vn_ssa_aux_t);\n DEF_VEC_ALLOC_P(vn_ssa_aux_t, heap);\n \n@@ -525,8 +528,21 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t  temp.op1 = TREE_OPERAND (ref, 2);\n \t  break;\n \tcase COMPONENT_REF:\n-\t  /* Record field as operand.  */\n-\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  /* If this is a reference to a union member, record the union\n+\t     member size as operand.  Do so only if we are doing\n+\t     expression insertion (during FRE), as PRE currently gets\n+\t     confused with this.  */\n+\t  if (may_insert\n+\t      && TREE_CODE (DECL_CONTEXT (TREE_OPERAND (ref, 1))) == UNION_TYPE\n+\t      && integer_zerop (DECL_FIELD_OFFSET (TREE_OPERAND (ref, 1)))\n+\t      && integer_zerop (DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1))))\n+\t    {\n+\t      temp.type = NULL_TREE;\n+\t      temp.op0 = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)));\n+\t    }\n+\t  else\n+\t    /* Record field as operand.  */\n+\t    temp.op0 = TREE_OPERAND (ref, 1);\n \t  break;\n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n@@ -1017,6 +1033,9 @@ defs_to_varying (tree stmt)\n   return changed;\n }\n \n+static tree\n+try_to_simplify (tree stmt, tree rhs);\n+\n /* Visit a copy between LHS and RHS, return true if the value number\n    changed.  */\n \n@@ -1089,6 +1108,64 @@ visit_reference_op_load (tree lhs, tree op, tree stmt)\n   bool changed = false;\n   tree result = vn_reference_lookup (op, shared_vuses_from_stmt (stmt));\n \n+  /* We handle type-punning through unions by value-numbering based\n+     on offset and size of the access.  Be prepared to handle a\n+     type-mismatch here via creating a VIEW_CONVERT_EXPR.  */\n+  if (result\n+      && !useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (op)))\n+    {\n+      /* We will be setting the value number of lhs to the value number\n+\t of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).\n+\t So first simplify and lookup this expression to see if it\n+\t is already available.  */\n+      tree val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (op), result);\n+      if (stmt\n+\t  && !is_gimple_min_invariant (val)\n+\t  && TREE_CODE (val) != SSA_NAME)\n+        {\n+\t  tree tem = try_to_simplify (stmt, val);\n+\t  if (tem)\n+\t    val = tem;\n+\t}\n+      result = val;\n+      if (!is_gimple_min_invariant (val)\n+\t  && TREE_CODE (val) != SSA_NAME)\n+\tresult = vn_nary_op_lookup (val);\n+      /* If the expression is not yet available, value-number lhs to\n+\t a new SSA_NAME we create.  */\n+      if (!result && may_insert)\n+        {\n+\t  result = make_ssa_name (SSA_NAME_VAR (lhs), NULL_TREE);\n+\t  /* Initialize value-number information properly.  */\n+\t  VN_INFO_GET (result)->valnum = result;\n+\t  VN_INFO (result)->expr = val;\n+\t  VN_INFO (result)->needs_insertion = true;\n+\t  /* As all \"inserted\" statements are singleton SCCs, insert\n+\t     to the valid table.  This is strictly needed to\n+\t     avoid re-generating new value SSA_NAMEs for the same\n+\t     expression during SCC iteration over and over (the\n+\t     optimistic table gets cleared after each iteration).\n+\t     We do not need to insert into the optimistic table, as\n+\t     lookups there will fall back to the valid table.  */\n+\t  if (current_info == optimistic_info)\n+\t    {\n+\t      current_info = valid_info;\n+\t      vn_nary_op_insert (val, result);\n+\t      current_info = optimistic_info;\n+\t    }\n+\t  else\n+\t    vn_nary_op_insert (val, result);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Inserting name \");\n+\t      print_generic_expr (dump_file, result, 0);\n+\t      fprintf (dump_file, \" for expression \");\n+\t      print_generic_expr (dump_file, val, 0);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+\n   if (result)\n     {\n       changed = set_ssa_val_to (lhs, result);\n@@ -1496,7 +1573,8 @@ visit_use (tree use)\n   VN_INFO (use)->use_processed = true;\n \n   gcc_assert (!SSA_NAME_IN_FREE_LIST (use));\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && !IS_EMPTY_STMT (stmt))\n     {\n       fprintf (dump_file, \"Value numbering \");\n       print_generic_expr (dump_file, use, 0);\n@@ -1607,6 +1685,9 @@ visit_use (tree use)\n \t    }\n \n \t  if (TREE_CODE (lhs) == SSA_NAME\n+\t      /* We can substitute SSA_NAMEs that are live over\n+\t\t abnormal edges with their constant value.  */\n+\t      && !is_gimple_min_invariant (rhs)\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n \t    changed = defs_to_varying (stmt);\n \t  else if (REFERENCE_CLASS_P (lhs) || DECL_P (lhs))\n@@ -1985,6 +2066,9 @@ free_scc_vn (void)\n \t  && SSA_NAME_VALUE (name)\n \t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n \tSSA_NAME_VALUE (name) = NULL;\n+      if (name\n+\t  && VN_INFO (name)->needs_insertion)\n+\trelease_ssa_name (name);\n     }\n   obstack_free (&vn_ssa_aux_obstack, NULL);\n   VEC_free (vn_ssa_aux_t, heap, vn_ssa_aux_table);\n@@ -2005,11 +2089,13 @@ free_scc_vn (void)\n    due to ressource constraints.  */\n \n bool\n-run_scc_vn (void)\n+run_scc_vn (bool may_insert_arg)\n {\n   size_t i;\n   tree param;\n \n+  may_insert = may_insert_arg;\n+\n   init_scc_vn ();\n   current_info = valid_info;\n \n@@ -2024,7 +2110,7 @@ run_scc_vn (void)\n \t}\n     }\n \n-  for (i = num_ssa_names - 1; i > 0; i--)\n+  for (i = 1; i < num_ssa_names; ++i)\n     {\n       tree name = ssa_name (i);\n       if (name\n@@ -2033,6 +2119,7 @@ run_scc_vn (void)\n \tif (!DFS (name))\n \t  {\n \t    free_scc_vn ();\n+\t    may_insert = false;\n \t    return false;\n \t  }\n     }\n@@ -2058,5 +2145,6 @@ run_scc_vn (void)\n \t}\n     }\n \n+  may_insert = false;\n   return true;\n }"}, {"sha": "55d9831f504be1a18cbb085487a76f757f4a599e", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=3d45dd59c7fcad07ddec7a45d91eb3b7d31897a8", "patch": "@@ -44,12 +44,17 @@ typedef struct vn_ssa_aux\n      once.  It cannot be used to avoid visitation for SSA_NAME's\n      involved in non-singleton SCC's.  */\n   unsigned use_processed : 1;\n+\n+  /* Whether the SSA_NAME has no defining statement and thus an\n+     insertion of such with EXPR as definition is required before\n+     a use can be created of it.  */\n+  unsigned needs_insertion : 1;\n } *vn_ssa_aux_t;\n \n /* Return the value numbering info for an SSA_NAME.  */\n extern vn_ssa_aux_t VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO_GET (tree);\n-bool run_scc_vn (void);\n+bool run_scc_vn (bool);\n void free_scc_vn (void);\n void switch_to_PRE_table (void);\n tree vn_nary_op_lookup (tree);"}]}