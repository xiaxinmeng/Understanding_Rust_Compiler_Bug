{"sha": "1524f80b1ceeda3c293142f4e370616be6dcf2cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyNGY4MGIxY2VlZGEzYzI5MzE0MmY0ZTM3MDYxNmJlNmRjZjJjZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-12-13T05:23:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-12-13T05:23:12Z"}, "message": "Make-lang.in (fortran/trans-resolve.o): Depend on fortran/dependency.h.\n\ngcc/fortran/\n\t* Make-lang.in (fortran/trans-resolve.o): Depend on\n\tfortran/dependency.h.\n\t* gfortran.h (gfc_expr): Add an \"inline_noncopying_intrinsic\" flag.\n\t* dependency.h (gfc_get_noncopying_intrinsic_argument): Declare.\n\t(gfc_check_fncall_dependency): Change prototype.\n\t* dependency.c (gfc_get_noncopying_intrinsic_argument): New function.\n\t(gfc_check_argument_var_dependency): New function, split from\n\tgfc_check_fncall_dependency.\n\t(gfc_check_argument_dependency): New function.\n\t(gfc_check_fncall_dependency): Replace the expression parameter with\n\tseparate symbol and argument list parameters.  Generalize the function\n\tto handle dependencies for any type of expression, not just variables.\n\tAccept a further argument giving the intent of the expression being\n\ttested.  Ignore\tintent(in) arguments if that expression is also\n\tintent(in).\n\t* resolve.c: Include dependency.h.\n\t(find_noncopying_intrinsics): New function.\n\t(resolve_function, resolve_call): Call it on success.\n\t* trans-array.h (gfc_conv_array_transpose): Declare.\n\t(gfc_check_fncall_dependency): Remove prototype.\n\t* trans-array.c (gfc_conv_array_transpose): New function.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Don't use the\n\tlibcall handling if the expression is to be evaluated inline.\n\tAdd a case for handling inline transpose()s.\n\t* trans-expr.c (gfc_trans_arrayfunc_assign): Adjust for the new\n\tinterface provided by gfc_check_fncall_dependency.\n\nlibgfortran/\n\t* m4/matmul.m4: Use a different order in the special case of a\n\ttransposed first argument.\n\t* generated/matmul_c4.c, generated/matmul_c8.c, generated/matmul_c10.c,\n\t* generated/matmul_c16.c, generated/matmul_i4.c, generated/matmul_i8.c,\n\t* generated/matmul_i10.c, generated/matmul_r4.c, generated/matmul_r8.c\n\t* generated/matmul_r10.c, generated/matmul_r16.c: Regenerated.\n\nCo-Authored-By: Victor Leikehman <LEI@il.ibm.com>\n\nFrom-SVN: r108459", "tree": {"sha": "8b430f1a509f3fecd45aafac44d2707a38eb02d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b430f1a509f3fecd45aafac44d2707a38eb02d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1524f80b1ceeda3c293142f4e370616be6dcf2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1524f80b1ceeda3c293142f4e370616be6dcf2cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1524f80b1ceeda3c293142f4e370616be6dcf2cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1524f80b1ceeda3c293142f4e370616be6dcf2cf/comments", "author": null, "committer": null, "parents": [{"sha": "264c41eda5b1d3b073053da88f7e757635269cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/264c41eda5b1d3b073053da88f7e757635269cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/264c41eda5b1d3b073053da88f7e757635269cc3"}], "stats": {"total": 1197, "additions": 1051, "deletions": 146}, "files": [{"sha": "ea1afe18cef1ad0d0487ac9ead58b422bcc7bcc0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -1,3 +1,32 @@\n+2005-12-13  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* Make-lang.in (fortran/trans-resolve.o): Depend on\n+\tfortran/dependency.h.\n+\t* gfortran.h (gfc_expr): Add an \"inline_noncopying_intrinsic\" flag.\n+\t* dependency.h (gfc_get_noncopying_intrinsic_argument): Declare.\n+\t(gfc_check_fncall_dependency): Change prototype.\n+\t* dependency.c (gfc_get_noncopying_intrinsic_argument): New function.\n+\t(gfc_check_argument_var_dependency): New function, split from\n+\tgfc_check_fncall_dependency.\n+\t(gfc_check_argument_dependency): New function.\n+\t(gfc_check_fncall_dependency): Replace the expression parameter with\n+\tseparate symbol and argument list parameters.  Generalize the function\n+\tto handle dependencies for any type of expression, not just variables.\n+\tAccept a further argument giving the intent of the expression being\n+\ttested.  Ignore\tintent(in) arguments if that expression is also\n+\tintent(in).\n+\t* resolve.c: Include dependency.h.\n+\t(find_noncopying_intrinsics): New function.\n+\t(resolve_function, resolve_call): Call it on success.\n+\t* trans-array.h (gfc_conv_array_transpose): Declare.\n+\t(gfc_check_fncall_dependency): Remove prototype.\n+\t* trans-array.c (gfc_conv_array_transpose): New function.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Don't use the\n+\tlibcall handling if the expression is to be evaluated inline.\n+\tAdd a case for handling inline transpose()s.\n+\t* trans-expr.c (gfc_trans_arrayfunc_assign): Adjust for the new\n+\tinterface provided by gfc_check_fncall_dependency.\n+\n 2005-12-12  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/25078"}, {"sha": "4be0f7cc99b44ace6c017c8715040757d615f8e0", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -286,4 +286,5 @@ fortran/trans-intrinsic.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   gt-fortran-trans-intrinsic.h\n fortran/dependency.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-common.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/resolve.o: fortran/dependency.h\n "}, {"sha": "d3a486e28f607495ec7f77bcde78d0d02952d618", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 104, "deletions": 28, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -175,6 +175,32 @@ gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n }\n \n \n+/* Some array-returning intrinsics can be implemented by reusing the\n+   data from one of the array arguments.  For example, TRANPOSE does\n+   not necessarily need to allocate new data: it can be implemented\n+   by copying the original array's descriptor and simply swapping the\n+   two dimension specifications.\n+\n+   If EXPR is a call to such an intrinsic, return the argument\n+   whose data can be reused, otherwise return NULL.  */\n+\n+gfc_expr *\n+gfc_get_noncopying_intrinsic_argument (gfc_expr * expr)\n+{\n+  if (expr->expr_type != EXPR_FUNCTION || !expr->value.function.isym)\n+    return NULL;\n+\n+  switch (expr->value.function.isym->generic_id)\n+    {\n+    case GFC_ISYM_TRANSPOSE:\n+      return expr->value.function.actual->expr;\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+\n /* Return true if the result of reference REF can only be constructed\n    using a temporary array.  */\n \n@@ -214,47 +240,97 @@ gfc_ref_needs_temporary_p (gfc_ref *ref)\n }\n \n \n-/* Dependency checking for direct function return by reference.\n-   Returns true if the arguments of the function depend on the\n-   destination.  This is considerably less conservative than other\n-   dependencies because many function arguments will already be\n-   copied into a temporary.  */\n+/* Return true if array variable VAR could be passed to the same function\n+   as argument EXPR without interfering with EXPR.  INTENT is the intent\n+   of VAR.\n+\n+   This is considerably less conservative than other dependencies\n+   because many function arguments will already be copied into a\n+   temporary.  */\n+\n+static int\n+gfc_check_argument_var_dependency (gfc_expr * var, sym_intent intent,\n+\t\t\t\t   gfc_expr * expr)\n+{\n+  gcc_assert (var->expr_type == EXPR_VARIABLE);\n+  gcc_assert (var->rank > 0);\n+\n+  switch (expr->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      return (gfc_ref_needs_temporary_p (expr->ref)\n+\t      || gfc_check_dependency (var, expr, NULL, 0));\n+\n+    case EXPR_ARRAY:\n+      return gfc_check_dependency (var, expr, NULL, 0);\n+\n+    case EXPR_FUNCTION:\n+      if (intent != INTENT_IN && expr->inline_noncopying_intrinsic)\n+\t{\n+\t  expr = gfc_get_noncopying_intrinsic_argument (expr);\n+\t  return gfc_check_argument_var_dependency (var, intent, expr);\n+\t}\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+  \n+  \n+/* Like gfc_check_argument_var_dependency, but extended to any\n+   array expression OTHER, not just variables.  */\n+\n+static int\n+gfc_check_argument_dependency (gfc_expr * other, sym_intent intent,\n+\t\t\t       gfc_expr * expr)\n+{\n+  switch (other->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      return gfc_check_argument_var_dependency (other, intent, expr);\n+\n+    case EXPR_FUNCTION:\n+      if (other->inline_noncopying_intrinsic)\n+\t{\n+\t  other = gfc_get_noncopying_intrinsic_argument (other);\n+\t  return gfc_check_argument_dependency (other, INTENT_IN, expr);\n+\t}\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+\n+/* Like gfc_check_argument_dependency, but check all the arguments in ACTUAL.\n+   FNSYM is the function being called, or NULL if not known.  */\n \n int\n-gfc_check_fncall_dependency (gfc_expr * dest, gfc_expr * fncall)\n+gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n+\t\t\t     gfc_symbol * fnsym, gfc_actual_arglist * actual)\n {\n-  gfc_actual_arglist *actual;\n+  gfc_formal_arglist *formal;\n   gfc_expr *expr;\n \n-  gcc_assert (dest->expr_type == EXPR_VARIABLE\n-\t  && fncall->expr_type == EXPR_FUNCTION);\n-  gcc_assert (fncall->rank > 0);\n-\n-  for (actual = fncall->value.function.actual; actual; actual = actual->next)\n+  formal = fnsym ? fnsym->formal : NULL;\n+  for (; actual; actual = actual->next, formal = formal ? formal->next : NULL)\n     {\n       expr = actual->expr;\n \n       /* Skip args which are not present.  */\n       if (!expr)\n \tcontinue;\n \n-      /* Non-variable expressions will be allocated temporaries anyway.  */\n-      switch (expr->expr_type)\n-\t{\n-\tcase EXPR_VARIABLE:\n-\t  if (!gfc_ref_needs_temporary_p (expr->ref)\n-\t      && gfc_check_dependency (dest, expr, NULL, 0))\n-\t    return 1;\n-\t  break;\n-\n-\tcase EXPR_ARRAY:\n-\t  if (gfc_check_dependency (dest, expr, NULL, 0))\n-\t    return 1;\n-\t  break;\n+      /* Skip intent(in) arguments if OTHER itself is intent(in).  */\n+      if (formal\n+\t  && intent == INTENT_IN\n+\t  && formal->sym->attr.intent == INTENT_IN)\n+\tcontinue;\n \n-\tdefault:\n-\t  break;\n-\t}\n+      if (gfc_check_argument_dependency (other, intent, expr))\n+\treturn 1;\n     }\n \n   return 0;"}, {"sha": "7ef2edd97e5080a619908b530224690b5194a836", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -22,7 +22,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n \n bool gfc_ref_needs_temporary_p (gfc_ref *);\n-int gfc_check_fncall_dependency (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n+int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n+\t\t\t\t gfc_actual_arglist *);\n int gfc_check_dependency (gfc_expr *, gfc_expr *, gfc_expr **, int);\n int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_dep_compare_expr (gfc_expr *, gfc_expr *);"}, {"sha": "7d0c725cb3bf4a625e022587541eeba1b687aa8f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -1129,6 +1129,9 @@ typedef struct gfc_expr\n \n   /* True if it is converted from Hollerith constant.  */\n   unsigned int from_H : 1;\n+  /* True if the expression is a call to a function that returns an array,\n+     and if we have decided not to allocate temporary data for that array.  */\n+  unsigned int inline_noncopying_intrinsic : 1;\n \n   union\n   {"}, {"sha": "e363763096dec35b7b93f02f30092ebecb7b70d7", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -24,6 +24,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor,Boston, MA\n #include \"system.h\"\n #include \"gfortran.h\"\n #include \"arith.h\"  /* For gfc_compare_expr().  */\n+#include \"dependency.h\"\n \n /* Types used in equivalence statements.  */\n \n@@ -804,6 +805,24 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n }\n \n \n+/* Go through each actual argument in ACTUAL and see if it can be\n+   implemented as an inlined, non-copying intrinsic.  FNSYM is the\n+   function being called, or NULL if not known.  */\n+\n+static void\n+find_noncopying_intrinsics (gfc_symbol * fnsym, gfc_actual_arglist * actual)\n+{\n+  gfc_actual_arglist *ap;\n+  gfc_expr *expr;\n+\n+  for (ap = actual; ap; ap = ap->next)\n+    if (ap->expr\n+\t&& (expr = gfc_get_noncopying_intrinsic_argument (ap->expr))\n+\t&& !gfc_check_fncall_dependency (expr, INTENT_IN, fnsym, actual))\n+      ap->expr->inline_noncopying_intrinsic = 1;\n+}\n+\n+\n /************* Function resolution *************/\n \n /* Resolve a function call known to be generic.\n@@ -1150,6 +1169,9 @@ resolve_function (gfc_expr * expr)\n \t}\n     }\n \n+  if (t == SUCCESS)\n+    find_noncopying_intrinsics (expr->value.function.esym,\n+\t\t\t\texpr->value.function.actual);\n   return t;\n }\n \n@@ -1372,27 +1394,28 @@ resolve_call (gfc_code * c)\n   if (resolve_actual_arglist (c->ext.actual) == FAILURE)\n     return FAILURE;\n \n-  if (c->resolved_sym != NULL)\n-    return SUCCESS;\n-\n-  switch (procedure_kind (c->symtree->n.sym))\n-    {\n-    case PTYPE_GENERIC:\n-      t = resolve_generic_s (c);\n-      break;\n+  t = SUCCESS;\n+  if (c->resolved_sym == NULL)\n+    switch (procedure_kind (c->symtree->n.sym))\n+      {\n+      case PTYPE_GENERIC:\n+\tt = resolve_generic_s (c);\n+\tbreak;\n \n-    case PTYPE_SPECIFIC:\n-      t = resolve_specific_s (c);\n-      break;\n+      case PTYPE_SPECIFIC:\n+\tt = resolve_specific_s (c);\n+\tbreak;\n \n-    case PTYPE_UNKNOWN:\n-      t = resolve_unknown_s (c);\n-      break;\n+      case PTYPE_UNKNOWN:\n+\tt = resolve_unknown_s (c);\n+\tbreak;\n \n-    default:\n-      gfc_internal_error (\"resolve_subroutine(): bad function type\");\n-    }\n+      default:\n+\tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n+      }\n \n+  if (t == SUCCESS)\n+    find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);\n   return t;\n }\n "}, {"sha": "45c8351c3414b6370632693b59d00945fe163f57", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -673,6 +673,95 @@ gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n }\n \n \n+/* Generate code to tranpose array EXPR by creating a new descriptor\n+   in which the dimension specifications have been reversed.  */\n+\n+void\n+gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n+{\n+  tree dest, src, dest_index, src_index;\n+  gfc_loopinfo *loop;\n+  gfc_ss_info *dest_info, *src_info;\n+  gfc_ss *dest_ss, *src_ss;\n+  gfc_se src_se;\n+  int n;\n+\n+  loop = se->loop;\n+\n+  src_ss = gfc_walk_expr (expr);\n+  dest_ss = se->ss;\n+\n+  src_info = &src_ss->data.info;\n+  dest_info = &dest_ss->data.info;\n+\n+  /* Get a descriptor for EXPR.  */\n+  gfc_init_se (&src_se, NULL);\n+  gfc_conv_expr_descriptor (&src_se, expr, src_ss);\n+  gfc_add_block_to_block (&se->pre, &src_se.pre);\n+  gfc_add_block_to_block (&se->post, &src_se.post);\n+  src = src_se.expr;\n+\n+  /* Allocate a new descriptor for the return value.  */\n+  dest = gfc_create_var (TREE_TYPE (src), \"atmp\");\n+  dest_info->descriptor = dest;\n+  se->expr = dest;\n+\n+  /* Copy across the dtype field.  */\n+  gfc_add_modify_expr (&se->pre,\n+\t\t       gfc_conv_descriptor_dtype (dest),\n+\t\t       gfc_conv_descriptor_dtype (src));\n+\n+  /* Copy the dimension information, renumbering dimension 1 to 0 and\n+     0 to 1.  */\n+  gcc_assert (dest_info->dimen == 2);\n+  gcc_assert (src_info->dimen == 2);\n+  for (n = 0; n < 2; n++)\n+    {\n+      dest_info->delta[n] = integer_zero_node;\n+      dest_info->start[n] = integer_zero_node;\n+      dest_info->stride[n] = integer_one_node;\n+      dest_info->dim[n] = n;\n+\n+      dest_index = gfc_rank_cst[n];\n+      src_index = gfc_rank_cst[1 - n];\n+\n+      gfc_add_modify_expr (&se->pre,\n+\t\t\t   gfc_conv_descriptor_stride (dest, dest_index),\n+\t\t\t   gfc_conv_descriptor_stride (src, src_index));\n+\n+      gfc_add_modify_expr (&se->pre,\n+\t\t\t   gfc_conv_descriptor_lbound (dest, dest_index),\n+\t\t\t   gfc_conv_descriptor_lbound (src, src_index));\n+\n+      gfc_add_modify_expr (&se->pre,\n+\t\t\t   gfc_conv_descriptor_ubound (dest, dest_index),\n+\t\t\t   gfc_conv_descriptor_ubound (src, src_index));\n+\n+      if (!loop->to[n])\n+        {\n+\t  gcc_assert (integer_zerop (loop->from[n]));\n+\t  loop->to[n] = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\tgfc_conv_descriptor_ubound (dest, dest_index),\n+\t\t\t\tgfc_conv_descriptor_lbound (dest, dest_index));\n+        }\n+    }\n+\n+  /* Copy the data pointer.  */\n+  dest_info->data = gfc_conv_descriptor_data_get (src);\n+  gfc_conv_descriptor_data_set (&se->pre, dest, dest_info->data);\n+\n+  /* Copy the offset.  This is not changed by transposition: the top-left\n+     element is still at the same offset as before.  */\n+  dest_info->offset = gfc_conv_descriptor_offset (src);\n+  gfc_add_modify_expr (&se->pre,\n+\t\t       gfc_conv_descriptor_offset (dest),\n+\t\t       dest_info->offset);\n+\n+  if (dest_info->dimen > loop->temp_dim)\n+    loop->temp_dim = dest_info->dimen;\n+}\n+\n+\n /* Return the number of iterations in a loop that starts at START,\n    ends at END, and has step STEP.  */\n "}, {"sha": "8ceced9f9e35351dfaa2dbb86708166b3a3b4524", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -91,6 +91,8 @@ void gfc_conv_tmp_ref (gfc_se *);\n void gfc_conv_expr_descriptor (gfc_se *, gfc_expr *, gfc_ss *);\n /* Convert an array for passing as an actual function parameter.  */\n void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, int);\n+/* Evaluate and transpose a matrix expression.  */\n+void gfc_conv_array_transpose (gfc_se *, gfc_expr *);\n \n /* These work with both descriptors and descriptorless arrays.  */\n tree gfc_conv_array_data (tree);\n@@ -112,8 +114,6 @@ tree gfc_conv_descriptor_ubound (tree, tree);\n \n /* Dependency checking for WHERE and FORALL.  */\n int gfc_check_dependency (gfc_expr *, gfc_expr *, gfc_expr **, int);\n-/* Dependency checking for function calls.  */\n-int gfc_check_fncall_dependency (gfc_expr *, gfc_expr *);\n \n /* Add pre-loop scalarization code for intrinsic functions which require\n    special handling.  */"}, {"sha": "5e1535e7ea369c1fd5df3b750bb24f3d85424e9e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -2627,7 +2627,9 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n     }\n \n   /* Check for a dependency.  */\n-  if (gfc_check_fncall_dependency (expr1, expr2))\n+  if (gfc_check_fncall_dependency (expr1, INTENT_OUT,\n+\t\t\t\t   expr2->value.function.esym,\n+\t\t\t\t   expr2->value.function.actual))\n     return NULL;\n \n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic"}, {"sha": "0a61cd447ebc7ee0606efe640b819554fccfbd56", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -2894,7 +2894,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \n   name = &expr->value.function.name[2];\n \n-  if (expr->rank > 0)\n+  if (expr->rank > 0 && !expr->inline_noncopying_intrinsic)\n     {\n       lib = gfc_is_intrinsic_libcall (expr);\n       if (lib != 0)\n@@ -3119,6 +3119,16 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bound (se, expr, 0);\n       break;\n \n+    case GFC_ISYM_TRANSPOSE:\n+      if (se->ss && se->ss->useflags)\n+\t{\n+\t  gfc_conv_tmp_array_ref (se);\n+\t  gfc_advance_se_ss_chain (se);\n+\t}\n+      else\n+\tgfc_conv_array_transpose (se, expr->value.function.actual->expr);\n+      break;\n+\n     case GFC_ISYM_LEN:\n       gfc_conv_intrinsic_len (se, expr);\n       break;"}, {"sha": "5b8942776cbd7d5bf82fa2febbb23cb6f99ea244", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -1,3 +1,13 @@\n+2005-12-13  Richard Sandiford  <richard@codesourcery.com>\n+\t    Victor Leikehman  <LEI@il.ibm.com>\n+\n+\t* m4/matmul.m4: Use a different order in the special case of a\n+\ttransposed first argument.\n+\t* generated/matmul_c4.c, generated/matmul_c8.c, generated/matmul_c10.c,\n+\t* generated/matmul_c16.c, generated/matmul_i4.c, generated/matmul_i8.c,\n+\t* generated/matmul_i10.c, generated/matmul_r4.c, generated/matmul_r8.c\n+\t* generated/matmul_r10.c, generated/matmul_r16.c: Regenerated.\n+\n 2005-12-10  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* Makefile.am: Enable loop unrolling for matmul."}, {"sha": "edbd1e6becceb08a9cffaa3d105ed7c0c829f4ae", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_10)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_c10 (gfc_array_c10 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_COMPLEX_10 *restrict abase_x;\n+      const GFC_COMPLEX_10 *restrict bbase_y;\n+      GFC_COMPLEX_10 *restrict dest_y;\n+      GFC_COMPLEX_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "c04146be821990b1365662c5a60f9122e6402b4d", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_16)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_c16 (gfc_array_c16 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_COMPLEX_16 *restrict abase_x;\n+      const GFC_COMPLEX_16 *restrict bbase_y;\n+      GFC_COMPLEX_16 *restrict dest_y;\n+      GFC_COMPLEX_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "a01de37bc74a593829073b48570266518c0451b3", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_4)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_c4 (gfc_array_c4 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_COMPLEX_4 *restrict abase_x;\n+      const GFC_COMPLEX_4 *restrict bbase_y;\n+      GFC_COMPLEX_4 *restrict dest_y;\n+      GFC_COMPLEX_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "75ec4fc101c1a32ee73b6a84d796ec271b46f688", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_COMPLEX_8)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_c8 (gfc_array_c8 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_COMPLEX_8 *restrict abase_x;\n+      const GFC_COMPLEX_8 *restrict bbase_y;\n+      GFC_COMPLEX_8 *restrict dest_y;\n+      GFC_COMPLEX_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "eacc47ff8cd1d8e88f4eb42ddd847b3efb9f9a72", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_16)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_i16 (gfc_array_i16 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_INTEGER_16 *restrict abase_x;\n+      const GFC_INTEGER_16 *restrict bbase_y;\n+      GFC_INTEGER_16 *restrict dest_y;\n+      GFC_INTEGER_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "6166bf18c29115a95f68b034c2954328df19a322", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_4)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_i4 (gfc_array_i4 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_INTEGER_4 *restrict abase_x;\n+      const GFC_INTEGER_4 *restrict bbase_y;\n+      GFC_INTEGER_4 *restrict dest_y;\n+      GFC_INTEGER_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "b83ded04ebf02698974720302237075be5b62be8", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_INTEGER_8)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_i8 (gfc_array_i8 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_INTEGER_8 *restrict abase_x;\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 *restrict dest_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_INTEGER_8 *restrict abase_x;\n+      const GFC_INTEGER_8 *restrict bbase_y;\n+      GFC_INTEGER_8 *restrict dest_y;\n+      GFC_INTEGER_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_INTEGER_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "6702209bd228789f71f799b6def56e0b94b85fd3", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_10)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_r10 (gfc_array_r10 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_REAL_10 *restrict abase_x;\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 *restrict dest_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_REAL_10 *restrict abase_x;\n+      const GFC_REAL_10 *restrict bbase_y;\n+      GFC_REAL_10 *restrict dest_y;\n+      GFC_REAL_10 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_10) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "c095cbdb747a4ef8dd30dc9ef1c985a3c7a4df83", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_16)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_r16 (gfc_array_r16 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_REAL_16 *restrict abase_x;\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 *restrict dest_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_REAL_16 *restrict abase_x;\n+      const GFC_REAL_16 *restrict bbase_y;\n+      GFC_REAL_16 *restrict dest_y;\n+      GFC_REAL_16 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_16) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "dedc5a3496162d51a35da08700156aa559028b36", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_4)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_r4 (gfc_array_r4 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_REAL_4 *restrict abase_x;\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 *restrict dest_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_REAL_4 *restrict abase_x;\n+      const GFC_REAL_4 *restrict bbase_y;\n+      GFC_REAL_4 *restrict dest_y;\n+      GFC_REAL_4 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_4) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "926a860e386e5677dd7acd004392555d368895e2", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -36,16 +36,29 @@ Boston, MA 02110-1301, USA.  */\n \n #if defined (HAVE_GFC_REAL_8)\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_r8 (gfc_array_r8 * const restrict retarray, \n@@ -204,7 +217,28 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const GFC_REAL_8 *restrict abase_x;\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 *restrict dest_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -216,6 +250,27 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const GFC_REAL_8 *restrict abase_x;\n+      const GFC_REAL_8 *restrict bbase_y;\n+      GFC_REAL_8 *restrict dest_y;\n+      GFC_REAL_8 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_8) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}, {"sha": "f488f5ed38eb0492ea936e3b656e722e1cb73ab0", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1524f80b1ceeda3c293142f4e370616be6dcf2cf/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=1524f80b1ceeda3c293142f4e370616be6dcf2cf", "patch": "@@ -37,16 +37,29 @@ include(iparm.m4)dnl\n \n `#if defined (HAVE_'rtype_name`)'\n \n-/* This is a C version of the following fortran pseudo-code. The key\n-   point is the loop order -- we access all arrays column-first, which\n-   improves the performance enough to boost galgel spec score by 50%.\n+/* The order of loops is different in the case of plain matrix\n+   multiplication C=MATMUL(A,B), and in the frequent special case where\n+   the argument A is the temporary result of a TRANSPOSE intrinsic:\n+   C=MATMUL(TRANSPOSE(A),B).  Transposed temporaries are detected by\n+   looking at their strides.\n+\n+   The equivalent Fortran pseudo-code is:\n \n    DIMENSION A(M,COUNT), B(COUNT,N), C(M,N)\n-   C = 0\n-   DO J=1,N\n-     DO K=1,COUNT\n+   IF (.NOT.IS_TRANSPOSED(A)) THEN\n+     C = 0\n+     DO J=1,N\n+       DO K=1,COUNT\n+         DO I=1,M\n+           C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+   ELSE\n+     DO J=1,N\n        DO I=1,M\n-         C(I,J) = C(I,J)+A(I,K)*B(K,J)\n+         S = 0\n+         DO K=1,COUNT\n+           S = S+A(I,K)+B(K,J)\n+         C(I,J) = S\n+   ENDIF\n */\n \n extern void matmul_`'rtype_code (rtype * const restrict retarray, \n@@ -206,7 +219,28 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n \t    }\n \t}\n     }\n-  else\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      const rtype_name *restrict abase_x;\n+      const rtype_name *restrict bbase_y;\n+      rtype_name *restrict dest_y;\n+      rtype_name s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (rtype_name) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n] * bbase_y[n];\n+\t      dest_y[x] = s;\n+\t    }\n+\t}\n+    }\n+  else if (axstride < aystride)\n     {\n       for (y = 0; y < ycount; y++)\n \tfor (x = 0; x < xcount; x++)\n@@ -218,6 +252,27 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n \t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n     }\n+  else\n+    {\n+      const rtype_name *restrict abase_x;\n+      const rtype_name *restrict bbase_y;\n+      rtype_name *restrict dest_y;\n+      rtype_name s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (rtype_name) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n }\n \n #endif"}]}