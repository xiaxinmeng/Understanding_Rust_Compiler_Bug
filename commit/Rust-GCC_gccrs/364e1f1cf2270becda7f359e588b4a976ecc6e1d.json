{"sha": "364e1f1cf2270becda7f359e588b4a976ecc6e1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY0ZTFmMWNmMjI3MGJlY2RhN2YzNTllNTg4YjRhOTc2ZWNjNmUxZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-24T19:41:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-24T19:41:37Z"}, "message": "(type_list_equal, simple_cst_list_equal, index_type_equal):\n\nCheck for simple_cst_equal return value of -1.\n\nFrom-SVN: r9802", "tree": {"sha": "58482bf700357a578aae81b5e5af1c53d074ab3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58482bf700357a578aae81b5e5af1c53d074ab3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/364e1f1cf2270becda7f359e588b4a976ecc6e1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/364e1f1cf2270becda7f359e588b4a976ecc6e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/364e1f1cf2270becda7f359e588b4a976ecc6e1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/364e1f1cf2270becda7f359e588b4a976ecc6e1d/comments", "author": null, "committer": null, "parents": [{"sha": "1180eb10426d15d188cdfca38495035f48b1dfd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1180eb10426d15d188cdfca38495035f48b1dfd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1180eb10426d15d188cdfca38495035f48b1dfd2"}], "stats": {"total": 49, "additions": 25, "deletions": 24}, "files": [{"sha": "e74cff435b6f86498e6a764cb7c00ee0408aa6ab", "filename": "gcc/tree.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364e1f1cf2270becda7f359e588b4a976ecc6e1d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364e1f1cf2270becda7f359e588b4a976ecc6e1d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=364e1f1cf2270becda7f359e588b4a976ecc6e1d", "patch": "@@ -3259,12 +3259,14 @@ type_hash_lookup (hashcode, type)\n \t&& (TYPE_MIN_VALUE (h->type) == TYPE_MIN_VALUE (type)\n \t    || tree_int_cst_equal (TYPE_MIN_VALUE (h->type),\n \t\t\t\t   TYPE_MIN_VALUE (type)))\n+\t/* Note that TYPE_DOMAIN is TYPE_ARG_TYPES for FUNCTION_TYPE.  */\n \t&& (TYPE_DOMAIN (h->type) == TYPE_DOMAIN (type)\n \t    || (TYPE_DOMAIN (h->type)\n \t\t&& TREE_CODE (TYPE_DOMAIN (h->type)) == TREE_LIST\n \t\t&& TYPE_DOMAIN (type)\n \t\t&& TREE_CODE (TYPE_DOMAIN (type)) == TREE_LIST\n-\t\t&& type_list_equal (TYPE_DOMAIN (h->type), TYPE_DOMAIN (type)))))\n+\t\t&& type_list_equal (TYPE_DOMAIN (h->type),\n+\t\t\t\t    TYPE_DOMAIN (type)))))\n       return h->type;\n   return 0;\n }\n@@ -3386,7 +3388,8 @@ attribute_list_contained (l1, l2)\n \n   for (; t2; t2 = TREE_CHAIN (t2))\n     {\n-      tree attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n+      tree attr\n+\t= lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n \n       if (attr == NULL_TREE)\n \treturn 0;\n@@ -3407,21 +3410,15 @@ type_list_equal (l1, l2)\n      tree l1, l2;\n {\n   register tree t1, t2;\n+\n   for (t1 = l1, t2 = l2; t1 && t2; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-    {\n-      if (TREE_VALUE (t1) != TREE_VALUE (t2))\n-\treturn 0;\n-      if (TREE_PURPOSE (t1) != TREE_PURPOSE (t2))\n-\t{\n-\t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-\t  if (cmp < 0)\n-\t    abort ();\n-\t  if (cmp == 0\n-\t      || TREE_TYPE (TREE_PURPOSE (t1))\n-\t         != TREE_TYPE (TREE_PURPOSE (t2)))\n-\t    return 0;\n-\t}\n-    }\n+    if (TREE_VALUE (t1) != TREE_VALUE (t2)\n+\t|| (TREE_PURPOSE (t1) != TREE_PURPOSE (t2)\n+\t    && ! ((TREE_TYPE (TREE_PURPOSE (t1))\n+\t\t   == TREE_TYPE (TREE_PURPOSE (t2)))\n+\t\t  && 1 == simple_cst_equal (TREE_PURPOSE (t1),\n+\t\t\t\t\t    TREE_PURPOSE (t2)))))\n+      return 0;\n \n   return t1 == t2;\n }\n@@ -3478,21 +3475,22 @@ tree_int_cst_sgn (t)\n     return 1;\n }\n \n-/* Compare two constructor-element-type constants.  */\n+/* Compare two constructor-element-type constants.  Return 1 if the lists\n+   are known to be equal; otherwise return 0.  */\n+\n int\n simple_cst_list_equal (l1, l2)\n      tree l1, l2;\n {\n   while (l1 != NULL_TREE && l2 != NULL_TREE)\n     {\n-      int cmp = simple_cst_equal (TREE_VALUE (l1), TREE_VALUE (l2));\n-      if (cmp < 0)\n-\tabort ();\n-      if (cmp == 0)\n+      if (simple_cst_equal (TREE_VALUE (l1), TREE_VALUE (l2)) != 1)\n \treturn 0;\n+\n       l1 = TREE_CHAIN (l1);\n       l2 = TREE_CHAIN (l2);\n     }\n+\n   return (l1 == l2);\n }\n \n@@ -3745,13 +3743,16 @@ index_type_equal (itype1, itype2)\n     {\n       if (TYPE_PRECISION (itype1) != TYPE_PRECISION (itype2)\n \t  || TYPE_MODE (itype1) != TYPE_MODE (itype2)\n-\t  || ! simple_cst_equal (TYPE_SIZE (itype1), TYPE_SIZE (itype2))\n+\t  || simple_cst_equal (TYPE_SIZE (itype1), TYPE_SIZE (itype2)) != 1\n \t  || TYPE_ALIGN (itype1) != TYPE_ALIGN (itype2))\n \treturn 0;\n-      if (simple_cst_equal (TYPE_MIN_VALUE (itype1), TYPE_MIN_VALUE (itype2))\n-\t  && simple_cst_equal (TYPE_MAX_VALUE (itype1), TYPE_MAX_VALUE (itype2)))\n+      if (1 == simple_cst_equal (TYPE_MIN_VALUE (itype1),\n+\t\t\t\t TYPE_MIN_VALUE (itype2))\n+\t  && 1 == simple_cst_equal (TYPE_MAX_VALUE (itype1),\n+\t\t\t\t    TYPE_MAX_VALUE (itype2)))\n \treturn 1;\n     }\n+\n   return 0;\n }\n "}]}