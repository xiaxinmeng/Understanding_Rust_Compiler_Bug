{"sha": "0384674ecf6f70a9aab02476619e02972ea6a661", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4NDY3NGVjZjZmNzBhOWFhYjAyNDc2NjE5ZTAyOTcyZWE2YTY2MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-04-29T22:48:55Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-04-29T22:48:55Z"}, "message": "stor-layout.c (mode_for_size_tree): Use tree_low_cst.\n\n\t* stor-layout.c (mode_for_size_tree): Use tree_low_cst.\n\t(layout_decl, place_field): Likewise.\n\tAlso make minor type and whitespace changes.\n\nFrom-SVN: r66268", "tree": {"sha": "0604df65f510f92fd4a32992a4f35775b6f99afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0604df65f510f92fd4a32992a4f35775b6f99afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0384674ecf6f70a9aab02476619e02972ea6a661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0384674ecf6f70a9aab02476619e02972ea6a661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0384674ecf6f70a9aab02476619e02972ea6a661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0384674ecf6f70a9aab02476619e02972ea6a661/comments", "author": null, "committer": null, "parents": [{"sha": "7f78b6caa0a03fd3af6f122cac7d0143673ae11e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f78b6caa0a03fd3af6f122cac7d0143673ae11e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f78b6caa0a03fd3af6f122cac7d0143673ae11e"}], "stats": {"total": 76, "additions": 42, "deletions": 34}, "files": [{"sha": "70b69cc2fd35bc46c7ebc797ae7828c26006dc85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0384674ecf6f70a9aab02476619e02972ea6a661/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0384674ecf6f70a9aab02476619e02972ea6a661/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0384674ecf6f70a9aab02476619e02972ea6a661", "patch": "@@ -10,6 +10,10 @@\n \n 2003-04-29  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* stor-layout.c (mode_for_size_tree): Use tree_low_cst.\n+\t(layout_decl, place_field): Likewise.\n+\tAlso make minor type and whitespace changes.\n+\n \t* tree.c (save_expr): Don't fold a COMPONENT_REF.\n \n 2003-04-29  Olivier Hainque <hainque@act-europe.fr>"}, {"sha": "0df34bd5a437dcd18c05ed0a4ea7cda43ba2e6dc", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0384674ecf6f70a9aab02476619e02972ea6a661/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0384674ecf6f70a9aab02476619e02972ea6a661/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0384674ecf6f70a9aab02476619e02972ea6a661", "patch": "@@ -249,7 +249,7 @@ mode_for_size_tree (size, class, limit)\n       || compare_tree_int (size, 1000) > 0)\n     return BLKmode;\n   else\n-    return mode_for_size (TREE_INT_CST_LOW (size), class, limit);\n+    return mode_for_size (tree_low_cst (size, 1), class, limit);\n }\n \n /* Similar, but never return BLKmode; return the narrowest mode that\n@@ -533,7 +533,7 @@ layout_decl (decl, known_align)\n       if (size != 0 && TREE_CODE (size) == INTEGER_CST\n \t  && compare_tree_int (size, larger_than_size) > 0)\n \t{\n-\t  unsigned int size_as_int = TREE_INT_CST_LOW (size);\n+\t  int size_as_int = TREE_INT_CST_LOW (size);\n \n \t  if (compare_tree_int (size, size_as_int) == 0)\n \t    warning_with_decl (decl, \"size of `%s' is %d bytes\", size_as_int);\n@@ -1074,25 +1074,28 @@ place_field (rli, field)\n \t  if (DECL_BIT_FIELD_TYPE (field)\n \t      && !integer_zerop (DECL_SIZE (field))\n \t      && !integer_zerop (DECL_SIZE (rli->prev_field))\n+\t      && host_integerp (DECL_SIZE (rli->prev_field), 0)\n+\t      && host_integerp (TYPE_SIZE (type), 0)\n \t      && simple_cst_equal (TYPE_SIZE (type),\n-\t\t   TYPE_SIZE (TREE_TYPE (rli->prev_field))) )\n+\t\t\t\t   TYPE_SIZE (TREE_TYPE (rli->prev_field))))\n \t    {\n \t      /* We're in the middle of a run of equal type size fields; make\n \t\t sure we realign if we run out of bits.  (Not decl size,\n \t\t type size!) */\n-\t      int bitsize = TREE_INT_CST_LOW (DECL_SIZE (field));\n-\t      tree type_size = TYPE_SIZE(TREE_TYPE(rli->prev_field));\n+\t      HOST_WIDE_INT bitsize = tree_low_cst (DECL_SIZE (field), 0);\n \n \t      if (rli->remaining_in_alignment < bitsize)\n \t\t{\n \t\t  /* out of bits; bump up to next 'word'.  */\n \t\t  rli->offset = DECL_FIELD_OFFSET (rli->prev_field);\n-\t\t  rli->bitpos = size_binop (PLUS_EXPR,\n-\t\t\t\t      type_size,\n-\t\t\t\t      DECL_FIELD_BIT_OFFSET(rli->prev_field));\n+\t\t  rli->bitpos\n+\t\t    = size_binop (PLUS_EXPR, TYPE_SIZE (type),\n+\t\t\t\t  DECL_FIELD_BIT_OFFSET (rli->prev_field));\n \t\t  rli->prev_field = field;\n-\t\t  rli->remaining_in_alignment = TREE_INT_CST_LOW (type_size);\n+\t\t  rli->remaining_in_alignment\n+\t\t    = tree_low_cst (TYPE_SIZE (type), 0);\n \t\t}\n+\n \t      rli->remaining_in_alignment -= bitsize;\n \t    }\n \t  else\n@@ -1108,26 +1111,24 @@ place_field (rli, field)\n \n \t      if (!integer_zerop (DECL_SIZE (rli->prev_field)))\n \t\t{\n-\t\t  tree type_size = TYPE_SIZE(TREE_TYPE(rli->prev_field));\n-\t\t  rli->bitpos = size_binop (PLUS_EXPR,\n-\t\t\t\t      type_size,\n-\t\t\t\t      DECL_FIELD_BIT_OFFSET(rli->prev_field));\n+\t\t  tree type_size = TYPE_SIZE (TREE_TYPE (rli->prev_field));\n+\n+\t\t  rli->bitpos\n+\t\t    = size_binop (PLUS_EXPR, type_size,\n+\t\t\t\t  DECL_FIELD_BIT_OFFSET (rli->prev_field));\n \t\t}\n \t      else\n-\t\t{\n-\t\t  /* We \"use up\" size zero fields; the code below should behave\n-\t\t     as if the prior field was not a bitfield.  */\n-\t\t  prev_saved = NULL;\n-\t\t}\n+\t\t/* We \"use up\" size zero fields; the code below should behave\n+\t\t   as if the prior field was not a bitfield.  */\n+\t\tprev_saved = NULL;\n \n \t      /* Cause a new bitfield to be captured, either this time (if\n \t\t currently a bitfield) or next time we see one.  */\n \t      if (!DECL_BIT_FIELD_TYPE(field)\n \t\t || integer_zerop (DECL_SIZE (field)))\n-\t\t{\n-\t\t  rli->prev_field = NULL;\n-\t\t}\n+\t\trli->prev_field = NULL;\n \t    }\n+\n \t  normalize_rli (rli);\n         }\n \n@@ -1146,24 +1147,26 @@ place_field (rli, field)\n       if (!DECL_BIT_FIELD_TYPE (field)\n \t  || ( prev_saved != NULL\n \t       ? !simple_cst_equal (TYPE_SIZE (type),\n-\t              TYPE_SIZE (TREE_TYPE (prev_saved)))\n-\t       : !integer_zerop (DECL_SIZE (field)) ))\n+\t\t\t\t    TYPE_SIZE (TREE_TYPE (prev_saved)))\n+\t      : !integer_zerop (DECL_SIZE (field)) ))\n \t{\n-\t  unsigned int type_align = 8;  /* Never below 8 for compatibility */\n+\t  /* Never smaller than a byte for compatibility.  */\n+\t  unsigned int type_align = BITS_PER_UNIT;\n \n \t  /* (When not a bitfield), we could be seeing a flex array (with\n \t     no DECL_SIZE).  Since we won't be using remaining_in_alignment\n \t     until we see a bitfield (and come by here again) we just skip\n \t     calculating it.  */\n-\n-\t  if (DECL_SIZE (field) != NULL)\n-\t      rli->remaining_in_alignment\n-\t\t  = TREE_INT_CST_LOW (TYPE_SIZE(TREE_TYPE(field)))\n-\t\t    - TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t  if (DECL_SIZE (field) != NULL\n+\t      && host_integerp (TYPE_SIZE (TREE_TYPE (field)), 0)\n+\t      && host_integerp (DECL_SIZE (field), 0))\n+\t    rli->remaining_in_alignment\n+\t      = tree_low_cst (TYPE_SIZE (TREE_TYPE(field)), 0)\n+\t\t- tree_low_cst (DECL_SIZE (field), 0);\n \n \t  /* Now align (conventionally) for the new type.  */\n \t  if (!DECL_PACKED(field))\n-\t      type_align = MAX(TYPE_ALIGN (type), type_align);\n+\t    type_align = MAX(TYPE_ALIGN (type), type_align);\n \n \t  if (prev_saved\n \t      && DECL_BIT_FIELD_TYPE (prev_saved)\n@@ -1178,6 +1181,7 @@ place_field (rli, field)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n \n \t  rli->bitpos = round_up (rli->bitpos, type_align);\n+\n           /* If we really aligned, don't allow subsequent bitfields\n \t     to undo that.  */\n \t  rli->prev_field = NULL;\n@@ -1860,10 +1864,10 @@ layout_type (type)\n #endif\n \t  unsigned int alignment\n \t    = set_alignment ? set_alignment : SET_WORD_SIZE;\n-\t  int size_in_bits\n-\t    = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t       - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);\n-\t  int rounded_size\n+\t  HOST_WIDE_INT size_in_bits\n+\t    = (tree_low_cst (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), 0)\n+\t       - tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), 0) + 1);\n+\t  HOST_WIDE_INT rounded_size\n \t    = ((size_in_bits + alignment - 1) / alignment) * alignment;\n \n \t  if (rounded_size > (int) alignment)"}]}