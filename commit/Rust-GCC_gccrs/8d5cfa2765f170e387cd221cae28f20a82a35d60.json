{"sha": "8d5cfa2765f170e387cd221cae28f20a82a35d60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ1Y2ZhMjc2NWYxNzBlMzg3Y2QyMjFjYWUyOGYyMGE4MmEzNWQ2MA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-12-12T20:27:02Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-12-12T20:27:02Z"}, "message": "re PR fortran/16222 (non-integral DO loop variables are unsupported.)\n\n2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n\tPaul Brook  <paul@codesourcery.com>\n\n\tPR fortran/16222\n\t* resolve.c (gfc_resolve_iterator_expr): New function.\n\t(gfc_resolve_iterator): Use it.  Add real_ok argument.  Convert\n\tstart, end and stride to correct type.\n\t(resolve_code): Pass extra argument.\n\t* array.c (resolve_array_list): Pass extra argument.\n\t* gfortran.h (gfc_resolve): Add prototype.\n\t* trans-stmt.c (gfc_trans_do): Remove redundant type conversions.\n\tHandle real type iterators.\ntestsuite/\n\t* gfortran.dg/real_do_1.f90: New test.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r92057", "tree": {"sha": "e2fd9e2cb7716c7282cc9fde4e0730ebf784736d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2fd9e2cb7716c7282cc9fde4e0730ebf784736d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d5cfa2765f170e387cd221cae28f20a82a35d60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d5cfa2765f170e387cd221cae28f20a82a35d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d5cfa2765f170e387cd221cae28f20a82a35d60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d5cfa2765f170e387cd221cae28f20a82a35d60/comments", "author": null, "committer": null, "parents": [{"sha": "973cb10b2d39d34d44fed8ffc12700ab3eca2ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973cb10b2d39d34d44fed8ffc12700ab3eca2ece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973cb10b2d39d34d44fed8ffc12700ab3eca2ece"}], "stats": {"total": 179, "additions": 130, "deletions": 49}, "files": [{"sha": "f8038837bdf13470b0eb2748d3a548c08e821973", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -1,3 +1,16 @@\n+2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/16222\n+\t* resolve.c (gfc_resolve_iterator_expr): New function.\n+\t(gfc_resolve_iterator): Use it.  Add real_ok argument.  Convert\n+\tstart, end and stride to correct type.\n+\t(resolve_code): Pass extra argument.\n+\t* array.c (resolve_array_list): Pass extra argument.\n+\t* gfortran.h (gfc_resolve): Add prototype.\n+\t* trans-stmt.c (gfc_trans_do): Remove redundant type conversions.\n+\tHandle real type iterators.\n+\n 2004-12-11  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/17175"}, {"sha": "936681304038a49d1dc4869557c639e0888997ba", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -1490,7 +1490,7 @@ resolve_array_list (gfc_constructor * p)\n   for (; p; p = p->next)\n     {\n       if (p->iterator != NULL\n-\t  && gfc_resolve_iterator (p->iterator) == FAILURE)\n+\t  && gfc_resolve_iterator (p->iterator, false) == FAILURE)\n \tt = FAILURE;\n \n       if (gfc_resolve_expr (p->expr) == FAILURE)"}, {"sha": "5d6e24fff01c71519875108469efd4923c142de5", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -1743,7 +1743,7 @@ void gfc_resolve (gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n-try gfc_resolve_iterator (gfc_iterator *);\n+try gfc_resolve_iterator (gfc_iterator *, bool);\n try gfc_resolve_index (gfc_expr *, int);\n \n /* array.c */"}, {"sha": "c7d3c61e9e5fd9b3dbb2d06866b73833689776cb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -2173,67 +2173,94 @@ gfc_resolve_expr (gfc_expr * e)\n }\n \n \n-/* Resolve the expressions in an iterator structure and require that they all\n-   be of integer type.  */\n+/* Resolve an expression from an iterator.  They must be scalar and have\n+   INTEGER or (optionally) REAL type.  */\n \n-try\n-gfc_resolve_iterator (gfc_iterator * iter)\n+static try\n+gfc_resolve_iterator_expr (gfc_expr * expr, bool real_ok, const char * name)\n {\n-\n-  if (gfc_resolve_expr (iter->var) == FAILURE)\n+  if (gfc_resolve_expr (expr) == FAILURE)\n     return FAILURE;\n \n-  if (iter->var->ts.type != BT_INTEGER || iter->var->rank != 0)\n+  if (expr->rank != 0)\n     {\n-      gfc_error (\"Loop variable at %L must be a scalar INTEGER\",\n-\t\t &iter->var->where);\n+      gfc_error (\"%s at %L must be a scalar\", name, &expr->where);\n       return FAILURE;\n     }\n \n-  if (gfc_pure (NULL) && gfc_impure_variable (iter->var->symtree->n.sym))\n+  if (!(expr->ts.type == BT_INTEGER\n+\t|| (expr->ts.type == BT_REAL && real_ok)))\n     {\n-      gfc_error (\"Cannot assign to loop variable in PURE procedure at %L\",\n-\t\t &iter->var->where);\n+      gfc_error (\"%s at %L must be INTEGER%s\",\n+\t\t name,\n+\t\t &expr->where,\n+\t\t real_ok ? \" or REAL\" : \"\");\n       return FAILURE;\n     }\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve the expressions in an iterator structure.  If REAL_OK is\n+   false allow only INTEGER type iterators, otherwise allow REAL types.  */\n+\n+try\n+gfc_resolve_iterator (gfc_iterator * iter, bool real_ok)\n+{\n \n-  if (gfc_resolve_expr (iter->start) == FAILURE)\n+  if (iter->var->ts.type == BT_REAL)\n+    gfc_notify_std (GFC_STD_F95_DEL,\n+\t\t    \"Obsolete: REAL DO loop iterator at %L\",\n+\t\t    &iter->var->where);\n+\n+  if (gfc_resolve_iterator_expr (iter->var, real_ok, \"Loop variable\")\n+      == FAILURE)\n     return FAILURE;\n \n-  if (iter->start->ts.type != BT_INTEGER || iter->start->rank != 0)\n+  if (gfc_pure (NULL) && gfc_impure_variable (iter->var->symtree->n.sym))\n     {\n-      gfc_error (\"Start expression in DO loop at %L must be a scalar INTEGER\",\n-\t\t &iter->start->where);\n+      gfc_error (\"Cannot assign to loop variable in PURE procedure at %L\",\n+\t\t &iter->var->where);\n       return FAILURE;\n     }\n \n-  if (gfc_resolve_expr (iter->end) == FAILURE)\n+  if (gfc_resolve_iterator_expr (iter->start, real_ok,\n+\t\t\t\t \"Start expression in DO loop\") == FAILURE)\n     return FAILURE;\n \n-  if (iter->end->ts.type != BT_INTEGER || iter->end->rank != 0)\n-    {\n-      gfc_error (\"End expression in DO loop at %L must be a scalar INTEGER\",\n-\t\t &iter->end->where);\n-      return FAILURE;\n-    }\n+  if (gfc_resolve_iterator_expr (iter->end, real_ok,\n+\t\t\t\t \"End expression in DO loop\") == FAILURE)\n+    return FAILURE;\n \n-  if (gfc_resolve_expr (iter->step) == FAILURE)\n+  if (gfc_resolve_iterator_expr (iter->step, real_ok,\n+\t\t\t\t \"Step expression in DO loop\") == FAILURE)\n     return FAILURE;\n \n-  if (iter->step->ts.type != BT_INTEGER || iter->step->rank != 0)\n+  if (iter->step->expr_type == EXPR_CONSTANT)\n     {\n-      gfc_error (\"Step expression in DO loop at %L must be a scalar INTEGER\",\n-\t\t &iter->step->where);\n-      return FAILURE;\n+      if ((iter->step->ts.type == BT_INTEGER\n+\t   && mpz_cmp_ui (iter->step->value.integer, 0) == 0)\n+\t  || (iter->step->ts.type == BT_REAL\n+\t      && mpfr_sgn (iter->step->value.real) == 0))\n+\t{\n+\t  gfc_error (\"Step expression in DO loop at %L cannot be zero\",\n+\t\t     &iter->step->where);\n+\t  return FAILURE;\n+\t}\n     }\n \n-  if (iter->step->expr_type == EXPR_CONSTANT\n-      && mpz_cmp_ui (iter->step->value.integer, 0) == 0)\n-    {\n-      gfc_error (\"Step expression in DO loop at %L cannot be zero\",\n-\t\t &iter->step->where);\n-      return FAILURE;\n-    }\n+  /* Convert start, end, and step to the same type as var.  */\n+  if (iter->start->ts.kind != iter->var->ts.kind\n+      || iter->start->ts.type != iter->var->ts.type)\n+    gfc_convert_type (iter->start, &iter->var->ts, 2);\n+\n+  if (iter->end->ts.kind != iter->var->ts.kind\n+      || iter->end->ts.type != iter->var->ts.type)\n+    gfc_convert_type (iter->end, &iter->var->ts, 2);\n+\n+  if (iter->step->ts.kind != iter->var->ts.kind\n+      || iter->step->ts.type != iter->var->ts.type)\n+    gfc_convert_type (iter->step, &iter->var->ts, 2);\n \n   return SUCCESS;\n }\n@@ -3728,7 +3755,7 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \n \tcase EXEC_DO:\n \t  if (code->ext.iterator != NULL)\n-\t    gfc_resolve_iterator (code->ext.iterator);\n+\t    gfc_resolve_iterator (code->ext.iterator, true);\n \t  break;\n \n \tcase EXEC_DO_WHILE:\n@@ -4360,7 +4387,7 @@ resolve_data_variables (gfc_data_variable * d)\n \t}\n       else\n \t{\n-\t  if (gfc_resolve_iterator (&d->iter) == FAILURE)\n+\t  if (gfc_resolve_iterator (&d->iter, false) == FAILURE)\n \t    return FAILURE;\n \n \t  if (d->iter.start->expr_type != EXPR_CONSTANT"}, {"sha": "e0c9f75e8c5e39873b11c10bf50b9424ca98fafa", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -617,8 +617,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n    TODO: Large loop counts\n    The code above assumes the loop count fits into a signed integer kind,\n    i.e. Does not work for loop counts > 2^31 for integer(kind=4) variables\n-   We must support the full range.\n-   TODO: Real type do variables.  */\n+   We must support the full range.  */\n \n tree\n gfc_trans_do (gfc_code * code)\n@@ -629,6 +628,7 @@ gfc_trans_do (gfc_code * code)\n   tree to;\n   tree step;\n   tree count;\n+  tree count_one;\n   tree type;\n   tree cond;\n   tree cycle_label;\n@@ -647,17 +647,17 @@ gfc_trans_do (gfc_code * code)\n   type = TREE_TYPE (dovar);\n \n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_type (&se, code->ext.iterator->start, type);\n+  gfc_conv_expr_val (&se, code->ext.iterator->start);\n   gfc_add_block_to_block (&block, &se.pre);\n   from = gfc_evaluate_now (se.expr, &block);\n \n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_type (&se, code->ext.iterator->end, type);\n+  gfc_conv_expr_val (&se, code->ext.iterator->end);\n   gfc_add_block_to_block (&block, &se.pre);\n   to = gfc_evaluate_now (se.expr, &block);\n \n   gfc_init_se (&se, NULL);\n-  gfc_conv_expr_type (&se, code->ext.iterator->step, type);\n+  gfc_conv_expr_val (&se, code->ext.iterator->step);\n   gfc_add_block_to_block (&block, &se.pre);\n   step = gfc_evaluate_now (se.expr, &block);\n \n@@ -672,11 +672,24 @@ gfc_trans_do (gfc_code * code)\n \n   tmp = fold (build2 (MINUS_EXPR, type, step, from));\n   tmp = fold (build2 (PLUS_EXPR, type, to, tmp));\n-  tmp = fold (build2 (TRUNC_DIV_EXPR, type, tmp, step));\n-\n-  count = gfc_create_var (type, \"count\");\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      tmp = fold (build2 (TRUNC_DIV_EXPR, type, tmp, step));\n+      count = gfc_create_var (type, \"count\");\n+    }\n+  else\n+    {\n+      /* TODO: We could use the same width as the real type.\n+\t This would probably cause more problems that it solves\n+\t when we implement \"long double\" types.  */\n+      tmp = fold (build2 (RDIV_EXPR, type, tmp, step));\n+      tmp = fold (build1 (FIX_TRUNC_EXPR, gfc_array_index_type, tmp));\n+      count = gfc_create_var (gfc_array_index_type, \"count\");\n+    }\n   gfc_add_modify_expr (&block, count, tmp);\n \n+  count_one = convert (TREE_TYPE (count), integer_one_node);\n+\n   /* Initialize the DO variable: dovar = from.  */\n   gfc_add_modify_expr (&block, dovar, from);\n \n@@ -688,7 +701,8 @@ gfc_trans_do (gfc_code * code)\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start with the loop condition.  Loop until count <= 0.  */\n-  cond = build2 (LE_EXPR, boolean_type_node, count, integer_zero_node);\n+  cond = build2 (LE_EXPR, boolean_type_node, count,\n+\t\tconvert (TREE_TYPE (count), integer_zero_node));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n@@ -717,7 +731,7 @@ gfc_trans_do (gfc_code * code)\n   gfc_add_modify_expr (&body, dovar, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = build2 (MINUS_EXPR, type, count, gfc_index_one_node);\n+  tmp = build2 (MINUS_EXPR, TREE_TYPE (count), count, count_one);\n   gfc_add_modify_expr (&body, count, tmp);\n \n   /* End of loop body.  */"}, {"sha": "1777427a0fd55da2d4a7da4dd84db371eff94c42", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -1,3 +1,9 @@\n+2004-12-12  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/16222\n+\t* gfortran.dg/real_do_1.f90: New test.\n+\n 2004-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/18040"}, {"sha": "89a9d1b9b5999a8015b6e5f0e9ef55346b526536", "filename": "gcc/testsuite/gfortran.dg/real_do_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_do_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d5cfa2765f170e387cd221cae28f20a82a35d60/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_do_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freal_do_1.f90?ref=8d5cfa2765f170e387cd221cae28f20a82a35d60", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! Test REAL type iterators in DO loops\n+program real_do_1\n+  real x, y\n+  integer n\n+\n+  n = 0\n+  y = 1.0\n+  do x = 1.0, 2.05, 0.1 ! { dg-warning \"REAL DO loop\" \"\" }\n+    call check (x, y)\n+    y = y + 0.1\n+    n = n + 1\n+  end do\n+  if (n .ne. 11) call abort()\n+contains\n+subroutine check (a, b)\n+  real, intent(in) :: a, b\n+\n+  if (abs (a - b) .gt. 0.00001) call abort()\n+end subroutine\n+end program"}]}