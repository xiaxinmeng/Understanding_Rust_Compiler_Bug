{"sha": "03b256e4c6ea84c37bac51a4026d18eda387d6f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiMjU2ZTRjNmVhODRjMzdiYWM1MWE0MDI2ZDE4ZWRhMzg3ZDZmMg==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1999-09-18T10:46:07Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "1999-09-18T10:46:07Z"}, "message": "typeck.c (get_member_function_from_ptrfunc): Always consider virtuality inside member pointer.\n\n\t* typeck.c (get_member_function_from_ptrfunc): Always consider\n\tvirtuality inside member pointer.\n\nFrom-SVN: r29494", "tree": {"sha": "8385f07e410845cfe125cc31acb1c6e8fa3efd67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8385f07e410845cfe125cc31acb1c6e8fa3efd67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03b256e4c6ea84c37bac51a4026d18eda387d6f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b256e4c6ea84c37bac51a4026d18eda387d6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03b256e4c6ea84c37bac51a4026d18eda387d6f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03b256e4c6ea84c37bac51a4026d18eda387d6f2/comments", "author": null, "committer": null, "parents": [{"sha": "e9013db2047dcc0eded38e19ce55a4a409436ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9013db2047dcc0eded38e19ce55a4a409436ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9013db2047dcc0eded38e19ce55a4a409436ebf"}], "stats": {"total": 118, "additions": 61, "deletions": 57}, "files": [{"sha": "00038b54ae8719d4a8dfe783908dd5ca2f15a7e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b256e4c6ea84c37bac51a4026d18eda387d6f2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b256e4c6ea84c37bac51a4026d18eda387d6f2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03b256e4c6ea84c37bac51a4026d18eda387d6f2", "patch": "@@ -1,3 +1,8 @@\n+1999-09-18  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Always consider\n+\tvirtuality inside member pointer.\n+\n 1999-09-17  Mark Mitchell  <mark@codesourcery.com>\n \n         Turn on function-at-a-time processing.  "}, {"sha": "400e4ea951c8605c12f9d55cf81bf74cd387a59e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03b256e4c6ea84c37bac51a4026d18eda387d6f2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03b256e4c6ea84c37bac51a4026d18eda387d6f2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=03b256e4c6ea84c37bac51a4026d18eda387d6f2", "patch": "@@ -2821,67 +2821,66 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t\t\t\t\t       NULL_TREE, 0));\n       e3 = PFN_FROM_PTRMEMFUNC (function);\n \n-      if (TYPE_SIZE (basetype) != NULL_TREE\n-\t  && ! TYPE_VIRTUAL_P (basetype))\n-\t/* If basetype doesn't have virtual functions, don't emit code to\n-\t   handle that case.  */\n-\te1 = e3;\n-      else\n+      /* This used to avoid checking for virtual functions if basetype\n+\t has no virtual functions, according to an earlier ANSI draft.\n+\t With the final ISO C++ rules, such an optimization is\n+\t incorrect: A pointer to a derived member can be static_cast\n+\t to pointer-to-base-member, as long as the dynamic object\n+\t later has the right member. */\n+\n+      /* Promoting idx before saving it improves performance on RISC\n+\t targets.  Without promoting, the first compare used\n+\t load-with-sign-extend, while the second used normal load then\n+\t shift to sign-extend.  An optimizer flaw, perhaps, but it's\n+\t easier to make this change.  */\n+      idx = save_expr (default_conversion\n+\t\t       (build_component_ref (function,\n+\t\t\t\t\t     index_identifier,\n+\t\t\t\t\t     NULL_TREE, 0)));\n+      e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n+\n+      /* Convert down to the right base, before using the instance.  */\n+      instance = convert_pointer_to_real (basetype, instance_ptr);\n+      if (instance == error_mark_node && instance_ptr != error_mark_node)\n+\treturn instance;\n+\n+      vtbl = convert_pointer_to (ptr_type_node, instance);\n+      delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n+      vtbl = build\n+\t(PLUS_EXPR,\n+\t build_pointer_type (build_pointer_type (vtable_entry_type)),\n+\t vtbl, cp_convert (ptrdiff_type_node, delta2));\n+      vtbl = build_indirect_ref (vtbl, NULL_PTR);\n+      aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\t     idx,\n+\t\t\t\t\t\t     integer_one_node));\n+      if (! flag_vtable_thunks)\n \t{\n-\t  /* Promoting idx before saving it improves performance on RISC\n-\t     targets.  Without promoting, the first compare used\n-\t     load-with-sign-extend, while the second used normal load then\n-\t     shift to sign-extend.  An optimizer flaw, perhaps, but it's\n-\t     easier to make this change.  */\n-\t  idx = save_expr (default_conversion\n-\t\t\t   (build_component_ref (function,\n-\t\t\t\t\t\t index_identifier,\n-\t\t\t\t\t\t NULL_TREE, 0)));\n-\t  e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n-\n-\t  /* Convert down to the right base, before using the instance.  */\n-\t  instance = convert_pointer_to_real (basetype, instance_ptr);\n-\t  if (instance == error_mark_node && instance_ptr != error_mark_node)\n-\t    return instance;\n-\n-\t  vtbl = convert_pointer_to (ptr_type_node, instance);\n-\t  delta2 = DELTA2_FROM_PTRMEMFUNC (function);\n-\t  vtbl = build\n+\t  aref = save_expr (aref);\n+\t  \n+\t  delta = build_binary_op\n \t    (PLUS_EXPR,\n-\t     build_pointer_type (build_pointer_type (vtable_entry_type)),\n-\t     vtbl, cp_convert (ptrdiff_type_node, delta2));\n-\t  vtbl = build_indirect_ref (vtbl, NULL_PTR);\n-\t  aref = build_array_ref (vtbl, build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t\t\t idx,\n-\t\t\t\t\t\t\t integer_one_node));\n-\t  if (! flag_vtable_thunks)\n-\t    {\n-\t      aref = save_expr (aref);\n-\n-\t      delta = build_binary_op\n-\t\t(PLUS_EXPR,\n-\t\t build_conditional_expr (e1,\n-\t\t\t\t\t build_component_ref (aref,\n-\t\t\t\t\t\t\t      delta_identifier,\n-\t\t\t\t\t\t\t      NULL_TREE, 0),\n-\t\t\t\t\t integer_zero_node),\n-\t\t delta);\n-\t    }\n-\n-\t  if (flag_vtable_thunks)\n-\t    e2 = aref;\n-\t  else\n-\t    e2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n-\t  TREE_TYPE (e2) = TREE_TYPE (e3);\n-\t  e1 = build_conditional_expr (e1, e2, e3);\n-\n-\t  /* Make sure this doesn't get evaluated first inside one of the\n-\t     branches of the COND_EXPR.  */\n-\t  if (TREE_CODE (instance_ptr) == SAVE_EXPR)\n-\t    e1 = build (COMPOUND_EXPR, TREE_TYPE (e1),\n-\t\t\tinstance_ptr, e1);\n+\t     build_conditional_expr (e1,\n+\t\t\t\t     build_component_ref (aref,\n+\t\t\t\t\t\t\t  delta_identifier,\n+\t\t\t\t\t\t\t  NULL_TREE, 0),\n+\t\t\t\t     integer_zero_node),\n+\t     delta);\n \t}\n \n+      if (flag_vtable_thunks)\n+\te2 = aref;\n+      else\n+\te2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n+      TREE_TYPE (e2) = TREE_TYPE (e3);\n+      e1 = build_conditional_expr (e1, e2, e3);\n+      \n+      /* Make sure this doesn't get evaluated first inside one of the\n+\t branches of the COND_EXPR.  */\n+      if (TREE_CODE (instance_ptr) == SAVE_EXPR)\n+\te1 = build (COMPOUND_EXPR, TREE_TYPE (e1),\n+\t\t    instance_ptr, e1);\n+\n       *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n \t\t\t\tinstance_ptr, delta);\n "}]}