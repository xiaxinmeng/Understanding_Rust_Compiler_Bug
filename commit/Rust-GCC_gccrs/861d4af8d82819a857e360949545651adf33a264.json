{"sha": "861d4af8d82819a857e360949545651adf33a264", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYxZDRhZjhkODI4MTlhODU3ZTM2MDk0OTU0NTY1MWFkZjMzYTI2NA==", "commit": {"author": {"name": "Andrew Sutton", "email": "asutton@lock3software.com", "date": "2019-11-27T15:23:02Z"}, "committer": {"name": "Andrew Sutton", "email": "asutton@gcc.gnu.org", "date": "2019-11-27T15:23:02Z"}, "message": "re PR c++/92236 ([concepts] Explain non-satisfaction in static_assert)\n\n2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n\n\tPR c++/92236\n\tDefer evaluation of concept checks so that static assertions can\n\temit more detailed diagnostics.\n\ngcc/cp/\n\t* constexpr.c (cxx_eval_call_expression): Handle concept checks.\n\t(cxx_eval_constant_expression): Diagnose misuse of function concepts\n\tas template-id expressions. Follow the usual return path for results.\n\t(cxx_eval_outermost_constant_expr): Avoid calling\n\tcp_get_callee_fndecl_nofold for function concepts.\n\t* constraint.cc (build_function_check): Fully type the concept check\n\tso that we don't ICE in conversions.\n\t* cp-gimplify.c (cp_genericize_r) [CALL_EXPR]: Handle concept checks.\n\t[TEMPLATE_ID_EXPR] Likewise.\n\t* cvt.c (convert_to_void): Always evaluate concept checks so we don't\n\taccidentally ignore them. Substitution during satisfaction can make\n\ta program ill-formed (example in g++.dg/cpp2a/concepts6.C).\n\t* pt.c (tsubst_copy_and_build): [CALL_EXPR]: Don't evaluate concepts.\n\t[TEMPLATE_ID_EXPR]: Likewise.\n\t* semantics.c (finish_call_expr): Don't evaluate concepts.\n\t(finish_id_expression_1): Likewise.\n\t(finish_static_assert): Preserve the original condition so we can\n\tdiagnose concept errors when a check returns false.\n\ngcc/testsuite/\n\t* g++.dg/cpp2a/concepts-iconv1.C: Update diagnostics.\n\t* g++.dg/cpp2a/concepts-requires5.C: Likewise.\n\t* g++.dg/cpp2a/concepts6.C: New test.\n\nFrom-SVN: r278775", "tree": {"sha": "231f0fe9b111f132f4b47a343e458ff6be85c9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/231f0fe9b111f132f4b47a343e458ff6be85c9f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/861d4af8d82819a857e360949545651adf33a264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861d4af8d82819a857e360949545651adf33a264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861d4af8d82819a857e360949545651adf33a264", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861d4af8d82819a857e360949545651adf33a264/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50e0c6e429e7cc664f6fcea59db22826f005ca19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e0c6e429e7cc664f6fcea59db22826f005ca19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e0c6e429e7cc664f6fcea59db22826f005ca19"}], "stats": {"total": 136, "additions": 99, "deletions": 37}, "files": [{"sha": "c3e66d4e40fb58bf26a4115defe932b8e398e392", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1,3 +1,27 @@\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92236\n+\tDefer evaluation of concept checks so that static assertions can\n+\temit more detailed diagnostics.\n+\t* constexpr.c (cxx_eval_call_expression): Handle concept checks.\n+\t(cxx_eval_constant_expression): Diagnose misuse of function concepts\n+\tas template-id expressions. Follow the usual return path for results.\n+\t(cxx_eval_outermost_constant_expr): Avoid calling\n+\tcp_get_callee_fndecl_nofold for function concepts.\n+\t* constraint.cc (build_function_check): Fully type the concept check\n+\tso that we don't ICE in conversions.\n+\t* cp-gimplify.c (cp_genericize_r) [CALL_EXPR]: Handle concept checks.\n+\t[TEMPLATE_ID_EXPR] Likewise.\n+\t* cvt.c (convert_to_void): Always evaluate concept checks so we don't\n+\taccidentally ignore them. Substitution during satisfaction can make\n+\ta program ill-formed (example in g++.dg/cpp2a/concepts6.C).\n+\t* pt.c (tsubst_copy_and_build): [CALL_EXPR]: Don't evaluate concepts.\n+\t[TEMPLATE_ID_EXPR]: Likewise.\n+\t* semantics.c (finish_call_expr): Don't evaluate concepts.\n+\t(finish_id_expression_1): Likewise.\n+\t(finish_static_assert): Preserve the original condition so we can\n+\tdiagnose concept errors when a check returns false.\n+\n 2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/92439"}, {"sha": "ee3ccb9691cafe20dc61e7ec9c3364a8dc71ab80", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1672,6 +1672,10 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t  bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n+  /* Handle concept checks separately.  */\n+  if (concept_check_p (t))\n+    return evaluate_concept_check (t, tf_warning_or_error);\n+\n   location_t loc = cp_expr_loc_or_input_loc (t);\n   tree fun = get_function_named_in_call (t);\n   constexpr_call new_call\n@@ -5645,14 +5649,26 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       {\n         /* We can evaluate template-id that refers to a concept only if\n \t   the template arguments are non-dependent.  */\n-\tif (!concept_definition_p (TREE_OPERAND (t, 0)))\n+\ttree id = unpack_concept_check (t);\n+\ttree tmpl = TREE_OPERAND (id, 0);\n+\tif (!concept_definition_p (tmpl))\n \t  internal_error (\"unexpected template-id %qE\", t);\n \n+\tif (function_concept_p (tmpl))\n+\t  {\n+\t    if (!ctx->quiet)\n+\t      error_at (cp_expr_loc_or_input_loc (t),\n+\t\t\t\"function concept must be called\");\n+\t    r = error_mark_node;\n+\t    break;\n+\t  }\n+\n \tif (!processing_template_decl)\n-\t  return evaluate_concept_check (t, tf_warning_or_error);\n+\t  r = evaluate_concept_check (t, tf_warning_or_error);\n \telse\n \t  *non_constant_p = true;\n-\treturn t;\n+\n+\tbreak;\n       }\n \n     case ASM_EXPR:\n@@ -5809,12 +5825,16 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t       || TREE_CODE (t) == AGGR_INIT_EXPR\n \t       || TREE_CODE (t) == TARGET_EXPR))\n     {\n-      tree x = t;\n-      if (TREE_CODE (x) == TARGET_EXPR)\n-\tx = TARGET_EXPR_INITIAL (x);\n-      tree fndecl = cp_get_callee_fndecl_nofold (x);\n-      if (fndecl && DECL_IMMEDIATE_FUNCTION_P (fndecl))\n-\tis_consteval = true;\n+      /* For non-concept checks, determine if it is consteval.  */\n+      if (!concept_check_p (t))\n+\t{\n+\t  tree x = t;\n+\t  if (TREE_CODE (x) == TARGET_EXPR)\n+\t    x = TARGET_EXPR_INITIAL (x);\n+\t  tree fndecl = cp_get_callee_fndecl_nofold (x);\n+\t  if (fndecl && DECL_IMMEDIATE_FUNCTION_P (fndecl))\n+\t    is_consteval = true;\n+\t}\n     }\n   if (AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n     {"}, {"sha": "fadbe7c8ac0a221662be4e24c3d45a13f0cbe6de", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1263,6 +1263,7 @@ build_function_check (tree tmpl, tree args, tsubst_flags_t /*complain*/)\n   ++processing_template_decl;\n   vec<tree, va_gc> *fargs = make_tree_vector ();\n   tree call = build_min_nt_call_vec (id, fargs);\n+  TREE_TYPE (call) = boolean_type_node;\n   release_tree_vector (fargs);\n   --processing_template_decl;\n \n@@ -1397,6 +1398,7 @@ build_constrained_parameter (tree cnc, tree proto, tree args)\n \n    Note that the constraints are neither reduced nor decomposed. That is\n    done only after the requires clause has been parsed (or not).  */\n+\n tree\n finish_shorthand_constraint (tree decl, tree constr)\n {"}, {"sha": "7942afa7ecead609f6114574d93bf5f80f4bc317", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1622,6 +1622,15 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       break;\n \n     case CALL_EXPR:\n+      /* Evaluate function concept checks instead of treating them as\n+\t normal functions.  */\n+      if (concept_check_p (stmt))\n+\t{\n+\t  *stmt_p = evaluate_concept_check (stmt, tf_warning_or_error);\n+\t  * walk_subtrees = 0;\n+\t  break;\n+\t}\n+\n       if (!wtd->no_sanitize_p\n \t  && sanitize_flags_p ((SANITIZE_NULL\n \t\t\t\t| SANITIZE_ALIGNMENT | SANITIZE_VPTR)))\n@@ -1679,6 +1688,13 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \tTARGET_EXPR_NO_ELIDE (stmt) = 1;\n       break;\n \n+    case TEMPLATE_ID_EXPR:\n+      gcc_assert (concept_check_p (stmt));\n+      /* Emit the value of the concept check.  */\n+      *stmt_p = evaluate_concept_check (stmt, tf_warning_or_error);\n+      walk_subtrees = 0;\n+      break;\n+\n     default:\n       if (IS_TYPE_OR_DECL_P (stmt))\n \t*walk_subtrees = 0;"}, {"sha": "d916e39ee9035cd1e420b9bf41b8e13e731b9bec", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1135,6 +1135,12 @@ convert_to_void (tree expr, impl_conv_void implicit, tsubst_flags_t complain)\n         error_at (loc, \"pseudo-destructor is not called\");\n       return error_mark_node;\n     }\n+\n+  /* Explicitly evaluate void-converted concept checks since their\n+     satisfaction may produce ill-formed programs.  */\n+   if (concept_check_p (expr))\n+     expr = evaluate_concept_check (expr, tf_warning_or_error);\n+\n   if (VOID_TYPE_P (TREE_TYPE (expr)))\n     return expr;\n   switch (TREE_CODE (expr))"}, {"sha": "3eed27bb4265c9a4d3b5fec0e20c98dec45b0a14", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -18860,12 +18860,6 @@ tsubst_copy_and_build (tree t,\n \t    if (function_concept_p (TREE_OPERAND (id, 0)))\n \t      RETURN (id);\n \n-\t    /* Evaluate the concept, if needed.  */\n-\t    tree args = TREE_OPERAND (id, 1);\n-\t    if (!uses_template_parms (args)\n-\t\t&& !processing_constraint_expression_p ())\n-\t      RETURN (evaluate_concept_check (check, complain));\n-\n \t    RETURN (check);\n \t  }\n \n@@ -19650,11 +19644,6 @@ tsubst_copy_and_build (tree t,\n \n \t    /* Ensure the result is wrapped as a call expression.  */\n \t    ret = build_concept_check (tmpl, args, tf_warning_or_error);\n-\n-\t    /* Possibly evaluate the check if it is non-dependent.   */\n-\t    if (!uses_template_parms (args)\n-\t\t&& !processing_constraint_expression_p ())\n-\t      ret = evaluate_concept_check (ret, complain);\n \t  }\n \telse\n \t  ret = finish_call_expr (function, &call_args,"}, {"sha": "4a5479cb4b4eba13330a844d0b848c672d672808", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -2605,10 +2605,6 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n \n       /* Ensure the result is wrapped as a call expression.  */\n       result = build_concept_check (tmpl, args, tf_warning_or_error);\n-\n-      /* Evaluate the check if it is non-dependent.   */\n-      if (!uses_template_parms (args))\n-\tresult = evaluate_concept_check (result, complain);\n     }\n   else if (is_overloaded_fn (fn))\n     {\n@@ -3890,13 +3886,8 @@ finish_id_expression_1 (tree id_expression,\n \t}\n       else if (concept_check_p (decl))\n \t{\n-\t  /* If this is a standard or variable concept check, potentially\n-\t     evaluate it. Function concepts need to be called as functions,\n-\t     so don't try evaluating them here.  */\n-\t  tree tmpl = TREE_OPERAND (decl, 0);\n-\t  tree args = TREE_OPERAND (decl, 1);\n-\t  if (!function_concept_p (tmpl) && !uses_template_parms (args))\n-\t    decl = evaluate_concept_check (decl, tf_warning_or_error);\n+\t  /* Nothing more to do. All of the analysis for concept checks\n+\t     is done by build_conept_id, called from the parser.  */\n \t}\n       else if (scope)\n \t{\n@@ -9564,6 +9555,9 @@ finish_static_assert (tree condition, tree message, location_t location,\n       return;\n     }\n \n+  /* Save the condition in case it was a concept check.  */\n+  tree orig_condition = condition;\n+\n   /* Fold the expression and convert it to a boolean value. */\n   condition = perform_implicit_conversion_flags (boolean_type_node, condition,\n \t\t\t\t\t\t complain, LOOKUP_NORMAL);\n@@ -9590,6 +9584,10 @@ finish_static_assert (tree condition, tree message, location_t location,\n \t  else\n             error (\"static assertion failed: %s\",\n \t\t   TREE_STRING_POINTER (message));\n+\n+\t  /* Actually explain the failure if this is a concept check.  */\n+\t  if (concept_check_p (orig_condition))\n+\t    diagnose_constraints (location, orig_condition, NULL_TREE);\n \t}\n       else if (condition && condition != error_mark_node)\n \t{"}, {"sha": "aca3864b184d6d0e45880f4409378bad20fe5d3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -1,3 +1,10 @@\n+2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92236\n+\t* g++.dg/cpp2a/concepts-iconv1.C: Update diagnostics.\n+\t* g++.dg/cpp2a/concepts-requires5.C: Likewise.\n+\t* g++.dg/cpp2a/concepts6.C: New test.\n+\n 2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/92439"}, {"sha": "4d521c30748f6b31cb2d58bfa156d34d08183ddc", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-iconv1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-iconv1.C?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -7,16 +7,16 @@ int foo(int x)\n {\n     return x;\n }\n- \n+\n template <typename T>\n concept C1 = requires (T x) {\n-    {foo(x)} -> Same<int&>;\n+    {foo(x)} -> Same<int&>; // { dg-error \"placeholder constraints\" }\n };\n \n template <typename T>\n concept C2 = requires (T x) {\n-    {foo(x)} -> Same<void>;\n+    {foo(x)} -> Same<void>; // { dg-error \"placeholder constraints\" }\n };\n- \n+\n static_assert( C1<int> );\t// { dg-error \"assert\" }\n static_assert( C2<int> );\t// { dg-error \"assert\" }"}, {"sha": "133d29e45a439b5ca3c676d00caefd6d7e30b38f", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/861d4af8d82819a857e360949545651adf33a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires5.C?ref=861d4af8d82819a857e360949545651adf33a264", "patch": "@@ -33,13 +33,13 @@ int driver_1()\n // Test implicit conversion requirements\n \n template<typename T, typename U>\n-concept ConvertibleTo = requires(T& t) { {t} -> U&; };\n+concept ConvertibleTo = requires(T& t) { {t} -> U&; }; // { dg-error \"inaccessible\" }\n \n struct B { };\n class D : /*private*/ B { };\n \n void driver_2()\n {\n-  static_assert(ConvertibleTo<D, B>()); // { dg-error \"cannot be used as a function\" }\n+  static_assert(ConvertibleTo<D, B>()); // { dg-error \"cannot call\" }\n   static_assert(ConvertibleTo<D, B>); // { dg-error \"static assertion failed\" }\n }"}]}