{"sha": "ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "node_id": "C_kwDOANBUbNoAKGVjMWI5YmEyZDc5MTNmZTVlOWRlYWNjOGU1NWU3NTM5MjYyZjUxMjQ", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-02-28T21:43:50Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2022-02-28T21:44:57Z"}, "message": "[PR104637] LRA: Split hard regs as many as possible on one subpass\n\nLRA hard reg split subpass is a small subpass used as the last\nresort for LRA when it can not assign a hard reg to a reload\npseudo by other ways (e.g. by spilling non-reload pseudos).  For\nsimplicity the subpass works on one split base (as each split\nchanges pseudo live range info).  In this case it results in\nreaching maximal possible number of subpasses.  The patch\nimplements as many non-overlapping hard reg splits\nsplits as possible on each subpass.\n\ngcc/ChangeLog:\n\n\tPR rtl-optimization/104637\n\t* lra-assigns.cc (lra_split_hard_reg_for): Split hard regs as many\n\tas possible on one subpass.\n\ngcc/testsuite/ChangeLog:\n\n\tPR rtl-optimization/104637\n\t* gcc.target/i386/pr104637.c: New.", "tree": {"sha": "10d05113e76081a88da4ae120a40c18314dd2873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10d05113e76081a88da4ae120a40c18314dd2873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1027dc459204894f4503f713a3d73826e4bbab15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1027dc459204894f4503f713a3d73826e4bbab15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1027dc459204894f4503f713a3d73826e4bbab15"}], "stats": {"total": 64, "additions": 57, "deletions": 7}, "files": [{"sha": "ab3a6e6e9cc2ac994e3dd333477e11796c594335", "filename": "gcc/lra-assigns.cc", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124/gcc%2Flra-assigns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124/gcc%2Flra-assigns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.cc?ref=ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "patch": "@@ -1774,8 +1774,8 @@ lra_split_hard_reg_for (void)\n      iterations.  Either it's an asm and something is wrong with the\n      constraints, or we have run out of spill registers; error out in\n      either case.  */\n-  bool asm_p = false;\n-  bitmap_head failed_reload_insns, failed_reload_pseudos;\n+  bool asm_p = false, spill_p = false;\n+  bitmap_head failed_reload_insns, failed_reload_pseudos, over_split_insns;\n   \n   if (lra_dump_file != NULL)\n     fprintf (lra_dump_file,\n@@ -1786,21 +1786,49 @@ lra_split_hard_reg_for (void)\n   bitmap_ior (&non_reload_pseudos, &lra_inheritance_pseudos, &lra_split_regs);\n   bitmap_ior_into (&non_reload_pseudos, &lra_subreg_reload_pseudos);\n   bitmap_ior_into (&non_reload_pseudos, &lra_optional_reload_pseudos);\n+  bitmap_initialize (&over_split_insns, &reg_obstack);\n   for (i = lra_constraint_new_regno_start; i < max_regno; i++)\n     if (reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0\n \t&& (rclass = lra_get_allocno_class (i)) != NO_REGS\n \t&& ! bitmap_bit_p (&non_reload_pseudos, i))\n       {\n \tif (! find_reload_regno_insns (i, first, last))\n \t  continue;\n-\tif (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last)\n-\t    && spill_hard_reg_in_range (i, rclass, first, last))\n+\tif (BLOCK_FOR_INSN (first) == BLOCK_FOR_INSN (last))\n \t  {\n-\t    bitmap_clear (&failed_reload_pseudos);\n-\t    return true;\n+\t    /* Check that we are not trying to split over the same insn\n+\t       requiring reloads to avoid splitting the same hard reg twice or\n+\t       more.  If we need several hard regs splitting over the same insn\n+\t       it can be finished on the next iterations.\n+\n+\t       The following loop iteration number is small as we split hard\n+\t       reg in a very small range.  */\n+\t    for (insn = first;\n+\t\t insn != NEXT_INSN (last);\n+\t\t insn = NEXT_INSN (insn))\n+\t      if (bitmap_bit_p (&over_split_insns, INSN_UID (insn)))\n+\t\tbreak;\n+\t    if (insn != NEXT_INSN (last)\n+\t\t|| !spill_hard_reg_in_range (i, rclass, first, last))\n+\t      {\n+\t\tbitmap_set_bit (&failed_reload_pseudos, i);\n+\t      }\n+\t    else\n+\t      {\n+\t\tfor (insn = first;\n+\t\t     insn != NEXT_INSN (last);\n+\t\t     insn = NEXT_INSN (insn))\n+\t\t  bitmap_set_bit (&over_split_insns, INSN_UID (insn));\n+\t\tspill_p = true;\n+\t      }\n \t  }\n-\tbitmap_set_bit (&failed_reload_pseudos, i);\n       }\n+  bitmap_clear (&over_split_insns);\n+  if (spill_p)\n+    {\n+      bitmap_clear (&failed_reload_pseudos);\n+      return true;\n+    }\n   bitmap_clear (&non_reload_pseudos);\n   bitmap_initialize (&failed_reload_insns, &reg_obstack);\n   EXECUTE_IF_SET_IN_BITMAP (&failed_reload_pseudos, 0, u, bi)"}, {"sha": "65e8635d55e7d633429fac92eda5988930ac3b60", "filename": "gcc/testsuite/gcc.target/i386/pr104637.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104637.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec1b9ba2d7913fe5e9deacc8e55e7539262f5124/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104637.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr104637.c?ref=ec1b9ba2d7913fe5e9deacc8e55e7539262f5124", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Og -fno-forward-propagate -mavx\" } */\n+\n+typedef short __attribute__((__vector_size__ (64))) U;\n+typedef unsigned long long __attribute__((__vector_size__ (32))) V;\n+typedef long double __attribute__((__vector_size__ (64))) F;\n+\n+int i;\n+U u;\n+F f;\n+\n+void\n+foo (char a, char b, _Complex char c, V v)\n+{\n+  u = (U) { u[0] / 0, u[1] / 0, u[2] / 0, u[3] / 0, u[4] / 0, u[5] / 0, u[6] / 0, u[7] / 0,\n+\t    u[8] / 0, u[0] / 0, u[9] / 0, u[10] / 0, u[11] / 0, u[12] / 0, u[13] / 0, u[14] / 0, u[15] / 0,\n+\t    u[16] / 0, u[17] / 0, u[18] / 0, u[19] / 0, u[20] / 0, u[21] / 0, u[22] / 0, u[23] / 0,\n+\t    u[24] / 0, u[25] / 0, u[26] / 0, u[27] / 0, u[28] / 0, u[29] / 0, u[30] / 0, u[31] / 0 };\n+  c += i;\n+  f = (F) { v[0], v[1], v[2], v[3] };\n+  i = (char) (__imag__ c + i);\n+}"}]}