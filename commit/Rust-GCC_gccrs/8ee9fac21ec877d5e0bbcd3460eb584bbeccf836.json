{"sha": "8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVlOWZhYzIxZWM4NzdkNWUwYmJjZDM0NjBlYjU4NGJiZWNjZjgzNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-09T19:51:49Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-09T19:51:49Z"}, "message": "libitm: Avoid non-portable x86 branch prediction mnemonic.\n\nFrom-SVN: r181233", "tree": {"sha": "5eb7fbe12a188f836f5b73e1ad1f49fdf125139c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eb7fbe12a188f836f5b73e1ad1f49fdf125139c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836/comments", "author": null, "committer": null, "parents": [{"sha": "a5b3d713ccade591a3dd972f5586912f8ef5cb48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b3d713ccade591a3dd972f5586912f8ef5cb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b3d713ccade591a3dd972f5586912f8ef5cb48"}], "stats": {"total": 11, "additions": 8, "deletions": 3}, "files": [{"sha": "0501d168a23e1b08497b9f19c64d71c36dccb861", "filename": "libitm/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "patch": "@@ -1,5 +1,8 @@\n 2011-11-09  Richard Henderson  <rth@redhat.com>\n \n+\t* config/x86/cacheline.h (gtm_cacheline::store_mask): Use .byte\n+\tto emit branch prediction hint.\n+\n \t* config/x86/sjlj.S: Protect elf directives with __ELF__.\n \tProtect .note.GNU-stack with __linux__.\n "}, {"sha": "f91d7ccb8020235973a5aca1b320d489176d4caf", "filename": "libitm/config/x86/cacheline.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836/libitm%2Fconfig%2Fx86%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836/libitm%2Fconfig%2Fx86%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fcacheline.h?ref=8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "patch": "@@ -144,7 +144,7 @@ gtm_cacheline::operator= (const gtm_cacheline & __restrict s)\n }\n #endif\n \n-// ??? Support masked integer stores more efficiently with an unlocked cmpxchg\n+// Support masked integer stores more efficiently with an unlocked cmpxchg\n // insn.  My reasoning is that while we write to locations that we do not wish\n // to modify, we do it in an uninterruptable insn, and so we either truely\n // write back the original data or the insn fails -- unlike with a\n@@ -171,7 +171,8 @@ gtm_cacheline::store_mask (uint32_t *d, uint32_t s, uint8_t m)\n \t\t\"and\t%[m], %[n]\\n\\t\"\n \t\t\"or\t%[s], %[n]\\n\\t\"\n \t\t\"cmpxchg %[n], %[d]\\n\\t\"\n-\t\t\"jnz,pn\t0b\"\n+\t\t\".byte\t0x2e\\n\\t\"\t// predict not-taken, aka jnz,pn\n+\t\t\"jnz\t0b\"\n \t\t: [d] \"+m\"(*d), [n] \"=&r\" (n), [o] \"+a\"(o)\n \t\t: [s] \"r\" (s & bm), [m] \"r\" (~bm));\n \t}\n@@ -198,7 +199,8 @@ gtm_cacheline::store_mask (uint64_t *d, uint64_t s, uint8_t m)\n \t\t\"and\t%[m], %[n]\\n\\t\"\n \t\t\"or\t%[s], %[n]\\n\\t\"\n \t\t\"cmpxchg %[n], %[d]\\n\\t\"\n-\t\t\"jnz,pn\t0b\"\n+\t\t\".byte\t0x2e\\n\\t\"\t// predict not-taken, aka jnz,pn\n+\t\t\"jnz\t0b\"\n \t\t: [d] \"+m\"(*d), [n] \"=&r\" (n), [o] \"+a\"(o)\n \t\t: [s] \"r\" (s & bm), [m] \"r\" (~bm));\n #else"}]}