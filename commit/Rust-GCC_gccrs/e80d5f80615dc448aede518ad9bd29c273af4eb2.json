{"sha": "e80d5f80615dc448aede518ad9bd29c273af4eb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwZDVmODA2MTVkYzQ0OGFlZGU1MThhZDliZDI5YzI3M2FmNGViMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-08-16T22:13:39Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-08-16T22:13:39Z"}, "message": "sparc-protos.h: Don't use the PARAMS macro.\n\n\t* config/sparc/sparc-protos.h: Don't use the PARAMS macro.\n\t* config/sparc/sparc.c: Likewise.\n\nFrom-SVN: r70509", "tree": {"sha": "d32e3f051d7049432ef485e38b88fe1008545886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d32e3f051d7049432ef485e38b88fe1008545886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e80d5f80615dc448aede518ad9bd29c273af4eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d5f80615dc448aede518ad9bd29c273af4eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80d5f80615dc448aede518ad9bd29c273af4eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d5f80615dc448aede518ad9bd29c273af4eb2/comments", "author": null, "committer": null, "parents": [{"sha": "ae7a543957fe07a61cb75aca311c723148597dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7a543957fe07a61cb75aca311c723148597dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae7a543957fe07a61cb75aca311c723148597dd8"}], "stats": {"total": 302, "additions": 146, "deletions": 156}, "files": [{"sha": "274567513b00d3caeac11676e2de1aaba9e85176", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e80d5f80615dc448aede518ad9bd29c273af4eb2", "patch": "@@ -1,3 +1,8 @@\n+2003-08-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* config/sparc/sparc-protos.h: Don't use the PARAMS macro.\n+\t* config/sparc/sparc.c: Likewise.\n+\n 2003-08-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/11512"}, {"sha": "1b5af3058851266c779507d92219c4277cd30f2a", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=e80d5f80615dc448aede518ad9bd29c273af4eb2", "patch": "@@ -27,99 +27,95 @@ Boston, MA 02111-1307, USA.  */\n extern bool sparc_emitting_epilogue;\n \n #ifdef TREE_CODE\n-extern struct rtx_def *function_value PARAMS ((tree, enum machine_mode, int));\n-extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t  enum machine_mode, tree, int));\n-extern struct rtx_def *function_arg PARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t     tree, int, int));\n-extern int function_arg_partial_nregs  PARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t\tenum machine_mode,\n-\t\t\t\t\t\ttree, int));\n-extern int function_arg_pass_by_reference PARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t   tree, int));\n-extern struct rtx_def *sparc_builtin_saveregs PARAMS ((void));\n+extern struct rtx_def *function_value (tree, enum machine_mode, int);\n+extern void function_arg_advance (CUMULATIVE_ARGS *,\n+\t\t\t\t  enum machine_mode, tree, int);\n+extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n+\t\t\t\t     enum machine_mode, tree, int, int);\n+extern int function_arg_partial_nregs (const CUMULATIVE_ARGS *,\n+\t\t\t\t       enum machine_mode, tree, int);\n+extern int function_arg_pass_by_reference (const CUMULATIVE_ARGS *,\n+\t\t\t\t\t   enum machine_mode, tree, int);\n+extern struct rtx_def *sparc_builtin_saveregs (void);\n #ifdef RTX_CODE\n-extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx, tree));\n-extern void sparc_va_start PARAMS ((tree, rtx));\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n+extern void sparc_va_start (tree, rtx);\n #endif\n-extern struct rtx_def *sparc_va_arg PARAMS ((tree, tree));\n-extern unsigned long sparc_type_code PARAMS ((tree));\n+extern struct rtx_def *sparc_va_arg (tree, tree);\n+extern unsigned long sparc_type_code (tree);\n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n-extern enum direction function_arg_padding PARAMS ((enum machine_mode, tree));\n+extern enum direction function_arg_padding (enum machine_mode, tree);\n #endif /* ARGS_SIZE_RTX */\n #endif /* TREE_CODE */\n \n-extern void load_pic_register PARAMS ((void));\n-extern void order_regs_for_local_alloc PARAMS ((void));\n-extern int compute_frame_size PARAMS ((int, int));\n-extern int check_pic PARAMS ((int));\n-extern int short_branch PARAMS ((int, int));\n-extern int sparc_flat_epilogue_delay_slots PARAMS ((void));\n-extern unsigned long sparc_flat_compute_frame_size PARAMS ((int));\n-extern void sparc_profile_hook PARAMS ((int));\n-extern void sparc_override_options PARAMS ((void));\n-extern int leaf_return_peephole_ok PARAMS ((void));\n-extern void sparc_output_scratch_registers PARAMS ((FILE *));\n-extern void sparc_flat_save_restore PARAMS ((FILE *, const char *,\n-\t\t\t\t\t     unsigned int, unsigned long,\n-\t\t\t\t\t     unsigned long, const char *,\n-\t\t\t\t\t     const char *, unsigned long));\n+extern void load_pic_register (void);\n+extern void order_regs_for_local_alloc (void);\n+extern int compute_frame_size (int, int);\n+extern int check_pic (int);\n+extern int short_branch (int, int);\n+extern int sparc_flat_epilogue_delay_slots (void);\n+extern unsigned long sparc_flat_compute_frame_size (int);\n+extern void sparc_profile_hook (int);\n+extern void sparc_override_options (void);\n+extern int leaf_return_peephole_ok (void);\n+extern void sparc_output_scratch_registers (FILE *);\n+extern void sparc_flat_save_restore (FILE *, const char *,\n+\t\t\t\t     unsigned int, unsigned long,\n+\t\t\t\t     unsigned long, const char *,\n+\t\t\t\t     const char *, unsigned long);\n \n #ifdef RTX_CODE\n-extern enum machine_mode select_cc_mode PARAMS ((enum rtx_code, rtx, rtx));\n+extern enum machine_mode select_cc_mode (enum rtx_code, rtx, rtx);\n /* Define the function that build the compare insn for scc and bcc.  */\n-extern rtx gen_compare_reg PARAMS ((enum rtx_code code, rtx, rtx));\n-extern void sparc_emit_float_lib_cmp PARAMS ((rtx, rtx, enum rtx_code));\n-extern void sparc_emit_floatunsdi PARAMS ((rtx [2]));\n-extern void emit_tfmode_binop PARAMS ((enum rtx_code, rtx *));\n-extern void emit_tfmode_unop PARAMS ((enum rtx_code, rtx *));\n-extern void emit_tfmode_cvt PARAMS ((enum rtx_code, rtx *));\n+extern rtx gen_compare_reg (enum rtx_code code, rtx, rtx);\n+extern void sparc_emit_float_lib_cmp (rtx, rtx, enum rtx_code);\n+extern void sparc_emit_floatunsdi (rtx [2]);\n+extern void emit_tfmode_binop (enum rtx_code, rtx *);\n+extern void emit_tfmode_unop (enum rtx_code, rtx *);\n+extern void emit_tfmode_cvt (enum rtx_code, rtx *);\n /* This function handles all v9 scc insns */\n-extern int gen_v9_scc PARAMS ((enum rtx_code, rtx *));\n-extern void sparc_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-extern void sparc64_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n-extern void sparc_defer_case_vector PARAMS ((rtx, rtx, int));\n-extern void sparc_emit_set_const32 PARAMS ((rtx, rtx));\n-extern void sparc_emit_set_const64 PARAMS ((rtx, rtx));\n-extern void sparc_emit_set_symbolic_const64 PARAMS ((rtx, rtx, rtx));\n-extern int sparc_splitdi_legitimate PARAMS ((rtx, rtx));\n-extern int sparc_absnegfloat_split_legitimate PARAMS ((rtx, rtx));\n-extern char *output_cbranch PARAMS ((rtx, rtx, int, int, int, int, rtx));\n-extern const char *output_sibcall PARAMS ((rtx, rtx));\n-extern char *output_v9branch PARAMS ((rtx, rtx, int, int, int, int, int,\n-\t\t\t\t      rtx));\n-extern void emit_v9_brxx_insn PARAMS ((enum rtx_code, rtx, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern int mems_ok_for_ldd_peep PARAMS ((rtx, rtx, rtx));\n-extern int arith_double_4096_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_4096_operand PARAMS ((rtx, enum machine_mode));\n-extern int zero_operand PARAMS ((rtx, enum machine_mode));\n-extern int fp_zero_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int empty_delay_slot PARAMS ((rtx));\n-extern int eligible_for_epilogue_delay PARAMS ((rtx, int));\n-extern int eligible_for_sibcall_delay PARAMS ((rtx));\n-extern int emit_move_sequence PARAMS ((rtx, enum machine_mode));\n-extern int fp_sethi_p PARAMS ((rtx));\n-extern int fp_mov_p PARAMS ((rtx));\n-extern int fp_high_losum_p PARAMS ((rtx));\n-extern int mem_min_alignment PARAMS ((rtx, int));\n-extern int pic_address_needs_scratch PARAMS ((rtx));\n-extern int reg_unused_after PARAMS ((rtx, rtx));\n-extern int register_ok_for_ldd PARAMS ((rtx));\n-extern int registers_ok_for_ldd_peep PARAMS ((rtx, rtx));\n-extern int sparc_flat_eligible_for_epilogue_delay PARAMS ((rtx, int));\n-extern int v9_regcmp_p PARAMS ((enum rtx_code));\n-extern char *sparc_v8plus_shift PARAMS ((rtx *, rtx, const char *));\n+extern int gen_v9_scc (enum rtx_code, rtx *);\n+extern void sparc_initialize_trampoline (rtx, rtx, rtx);\n+extern void sparc64_initialize_trampoline (rtx, rtx, rtx);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern void sparc_defer_case_vector (rtx, rtx, int);\n+extern void sparc_emit_set_const32 (rtx, rtx);\n+extern void sparc_emit_set_const64 (rtx, rtx);\n+extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n+extern int sparc_splitdi_legitimate (rtx, rtx);\n+extern int sparc_absnegfloat_split_legitimate (rtx, rtx);\n+extern char *output_cbranch (rtx, rtx, int, int, int, int, rtx);\n+extern const char *output_sibcall (rtx, rtx);\n+extern char *output_v9branch (rtx, rtx, int, int, int, int, int, rtx);\n+extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n+extern int arith_double_4096_operand (rtx, enum machine_mode);\n+extern int arith_4096_operand (rtx, enum machine_mode);\n+extern int zero_operand (rtx, enum machine_mode);\n+extern int fp_zero_operand (rtx, enum machine_mode);\n+extern int reg_or_0_operand (rtx, enum machine_mode);\n+extern int empty_delay_slot (rtx);\n+extern int eligible_for_epilogue_delay (rtx, int);\n+extern int eligible_for_sibcall_delay (rtx);\n+extern int emit_move_sequence (rtx, enum machine_mode);\n+extern int fp_sethi_p (rtx);\n+extern int fp_mov_p (rtx);\n+extern int fp_high_losum_p (rtx);\n+extern int mem_min_alignment (rtx, int);\n+extern int pic_address_needs_scratch (rtx);\n+extern int reg_unused_after (rtx, rtx);\n+extern int register_ok_for_ldd (rtx);\n+extern int registers_ok_for_ldd_peep (rtx, rtx);\n+extern int sparc_flat_eligible_for_epilogue_delay (rtx, int);\n+extern int v9_regcmp_p (enum rtx_code);\n+extern char *sparc_v8plus_shift (rtx *, rtx, const char *);\n /* Function used for V8+ code generation.  Returns 1 if the high\n    32 bits of REG are 0 before INSN.  */   \n-extern int sparc_check_64 PARAMS ((rtx, rtx));\n-extern rtx gen_df_reg PARAMS ((rtx, int));\n-extern int sparc_extra_constraint_check PARAMS ((rtx, int, int));\n+extern int sparc_check_64 (rtx, rtx);\n+extern rtx gen_df_reg (rtx, int);\n+extern int sparc_extra_constraint_check (rtx, int, int);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "4ff06c802b1936b5fb3e94f939fc2a4e7560cd22", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 65, "deletions": 76, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d5f80615dc448aede518ad9bd29c273af4eb2/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e80d5f80615dc448aede518ad9bd29c273af4eb2", "patch": "@@ -128,60 +128,55 @@ char sparc_leaf_regs[] =\n static const char *frame_base_name;\n static int frame_base_offset;\n \n-static void sparc_init_modes\tPARAMS ((void));\n-static int save_regs\t\tPARAMS ((FILE *, int, int, const char *,\n-\t\t\t\t       int, int, int));\n-static int restore_regs\t\tPARAMS ((FILE *, int, int, const char *, int, int));\n-static void build_big_number\tPARAMS ((FILE *, int, const char *));\n-static int function_arg_slotno\tPARAMS ((const CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int, int,\n-\t\t\t\t       int *, int *));\n-\n-static int supersparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int hypersparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-\n-static void sparc_output_addr_vec PARAMS ((rtx));\n-static void sparc_output_addr_diff_vec PARAMS ((rtx));\n-static void sparc_output_deferred_case_vectors PARAMS ((void));\n-static int check_return_regs PARAMS ((rtx));\n-static int epilogue_renumber PARAMS ((rtx *, int));\n-static bool sparc_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static int set_extends PARAMS ((rtx));\n-static void output_restore_regs PARAMS ((FILE *, int));\n-static void sparc_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void sparc_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void sparc_flat_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void sparc_flat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void sparc_nonflat_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT,\n-\t\t\t\t\t\t     int));\n-static void sparc_nonflat_function_prologue PARAMS ((FILE *, HOST_WIDE_INT,\n-\t\t\t\t\t\t     int));\n+static void sparc_init_modes (void);\n+static int save_regs (FILE *, int, int, const char *, int, int, int);\n+static int restore_regs (FILE *, int, int, const char *, int, int);\n+static void build_big_number (FILE *, int, const char *);\n+static int function_arg_slotno (const CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\ttree, int, int, int *, int *);\n+\n+static int supersparc_adjust_cost (rtx, rtx, rtx, int);\n+static int hypersparc_adjust_cost (rtx, rtx, rtx, int);\n+\n+static void sparc_output_addr_vec (rtx);\n+static void sparc_output_addr_diff_vec (rtx);\n+static void sparc_output_deferred_case_vectors (void);\n+static int check_return_regs (rtx);\n+static int epilogue_renumber (rtx *, int);\n+static bool sparc_assemble_integer (rtx, unsigned int, int);\n+static int set_extends (rtx);\n+static void output_restore_regs (FILE *, int);\n+static void sparc_output_function_prologue (FILE *, HOST_WIDE_INT);\n+static void sparc_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void sparc_flat_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void sparc_flat_function_prologue (FILE *, HOST_WIDE_INT);\n+static void sparc_nonflat_function_epilogue (FILE *, HOST_WIDE_INT, int);\n+static void sparc_nonflat_function_prologue (FILE *, HOST_WIDE_INT, int);\n #ifdef OBJECT_FORMAT_ELF\n-static void sparc_elf_asm_named_section PARAMS ((const char *, unsigned int));\n+static void sparc_elf_asm_named_section (const char *, unsigned int);\n #endif\n-static void sparc_aout_select_section PARAMS ((tree, int,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT))\n+static void sparc_aout_select_section (tree, int, unsigned HOST_WIDE_INT)\n      ATTRIBUTE_UNUSED;\n-static void sparc_aout_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t   unsigned HOST_WIDE_INT))\n+static void sparc_aout_select_rtx_section (enum machine_mode, rtx,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT)\n      ATTRIBUTE_UNUSED;\n \n-static int sparc_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int sparc_issue_rate PARAMS ((void));\n-static void sparc_sched_init PARAMS ((FILE *, int, int));\n-static int sparc_use_dfa_pipeline_interface PARAMS ((void));\n-static int sparc_use_sched_lookahead PARAMS ((void));\n-\n-static void emit_soft_tfmode_libcall PARAMS ((const char *, int, rtx *));\n-static void emit_soft_tfmode_binop PARAMS ((enum rtx_code, rtx *));\n-static void emit_soft_tfmode_unop PARAMS ((enum rtx_code, rtx *));\n-static void emit_soft_tfmode_cvt PARAMS ((enum rtx_code, rtx *));\n-static void emit_hard_tfmode_operation PARAMS ((enum rtx_code, rtx *));\n-\n-static bool sparc_function_ok_for_sibcall PARAMS ((tree, tree));\n-static void sparc_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\t   HOST_WIDE_INT, tree));\n-static bool sparc_rtx_costs PARAMS ((rtx, int, int, int *));\n+static int sparc_adjust_cost (rtx, rtx, rtx, int);\n+static int sparc_issue_rate (void);\n+static void sparc_sched_init (FILE *, int, int);\n+static int sparc_use_dfa_pipeline_interface (void);\n+static int sparc_use_sched_lookahead (void);\n+\n+static void emit_soft_tfmode_libcall (const char *, int, rtx *);\n+static void emit_soft_tfmode_binop (enum rtx_code, rtx *);\n+static void emit_soft_tfmode_unop (enum rtx_code, rtx *);\n+static void emit_soft_tfmode_cvt (enum rtx_code, rtx *);\n+static void emit_hard_tfmode_operation (enum rtx_code, rtx *);\n+\n+static bool sparc_function_ok_for_sibcall (tree, tree);\n+static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n+\t\t\t\t   HOST_WIDE_INT, tree);\n+static bool sparc_rtx_costs (rtx, int, int, int *);\n \f\n /* Option handling.  */\n \n@@ -1571,10 +1566,10 @@ sparc_emit_set_symbolic_const64 (op0, op1, temp1)\n /* These avoid problems when cross compiling.  If we do not\n    go through all this hair then the optimizer will see\n    invalid REG_EQUAL notes or in some cases none at all.  */\n-static void sparc_emit_set_safe_HIGH64 PARAMS ((rtx, HOST_WIDE_INT));\n-static rtx gen_safe_SET64 PARAMS ((rtx, HOST_WIDE_INT));\n-static rtx gen_safe_OR64 PARAMS ((rtx, HOST_WIDE_INT));\n-static rtx gen_safe_XOR64 PARAMS ((rtx, HOST_WIDE_INT));\n+static void sparc_emit_set_safe_HIGH64 (rtx, HOST_WIDE_INT);\n+static rtx gen_safe_SET64 (rtx, HOST_WIDE_INT);\n+static rtx gen_safe_OR64 (rtx, HOST_WIDE_INT);\n+static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n \n #if HOST_BITS_PER_WIDE_INT == 64\n #define GEN_HIGHINT64(__x)\t\tGEN_INT ((__x) & ~(HOST_WIDE_INT)0x3ff)\n@@ -1632,8 +1627,8 @@ gen_safe_XOR64 (src, val)\n    Without doing this, the optimizer cannot see such\n    opportunities.  */\n \n-static void sparc_emit_set_const64_quick1\n-\tPARAMS ((rtx, rtx, unsigned HOST_WIDE_INT, int));\n+static void sparc_emit_set_const64_quick1 (rtx, rtx,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT, int);\n \n static void\n sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n@@ -1675,9 +1670,8 @@ sparc_emit_set_const64_quick1 (op0, temp, low_bits, is_neg)\n     }\n }\n \n-static void sparc_emit_set_const64_quick2\n-\tPARAMS ((rtx, rtx, unsigned HOST_WIDE_INT,\n-\t       unsigned HOST_WIDE_INT, int));\n+static void sparc_emit_set_const64_quick2 (rtx, rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT, int);\n \n static void\n sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n@@ -1716,8 +1710,8 @@ sparc_emit_set_const64_quick2 (op0, temp, high_bits, low_immediate, shift_count)\n \t\t\t    gen_safe_OR64 (op0, low_immediate)));\n }\n \n-static void sparc_emit_set_const64_longway\n-\tPARAMS ((rtx, rtx, unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT));\n+static void sparc_emit_set_const64_longway (rtx, rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT);\n \n /* Full 64-bit constant decomposition.  Even though this is the\n    'worst' case, we still optimize a few things away.  */\n@@ -1824,10 +1818,9 @@ sparc_emit_set_const64_longway (op0, temp, high_bits, low_bits)\n }\n \n /* Analyze a 64-bit constant for certain properties.  */\n-static void analyze_64bit_constant\n-\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t       unsigned HOST_WIDE_INT,\n-\t       int *, int *, int *));\n+static void analyze_64bit_constant (unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    int *, int *, int *);\n \n static void\n analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n@@ -1893,8 +1886,7 @@ analyze_64bit_constant (high_bits, low_bits, hbsp, lbsp, abbasp)\n   *abbasp = all_bits_between_are_set;\n }\n \n-static int const64_is_2insns\n-\tPARAMS ((unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT));\n+static int const64_is_2insns (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n \n static int\n const64_is_2insns (high_bits, low_bits)\n@@ -1921,9 +1913,9 @@ const64_is_2insns (high_bits, low_bits)\n   return 0;\n }\n \n-static unsigned HOST_WIDE_INT create_simple_focus_bits\n-\tPARAMS ((unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t       int, int));\n+static unsigned HOST_WIDE_INT create_simple_focus_bits (unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t\tint, int);\n \n static unsigned HOST_WIDE_INT\n create_simple_focus_bits (high_bits, low_bits, lowest_bit_set, shift)\n@@ -4549,15 +4541,12 @@ struct function_arg_record_value_parms\n };\n \n static void function_arg_record_value_3\n-\tPARAMS ((HOST_WIDE_INT, struct function_arg_record_value_parms *));\n+ (HOST_WIDE_INT, struct function_arg_record_value_parms *);\n static void function_arg_record_value_2\n-\tPARAMS ((tree, HOST_WIDE_INT,\n-\t\t struct function_arg_record_value_parms *));\n+ (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *);\n static void function_arg_record_value_1\n-        PARAMS ((tree, HOST_WIDE_INT,\n-\t\t struct function_arg_record_value_parms *));\n-static rtx function_arg_record_value\n-\tPARAMS ((tree, enum machine_mode, int, int, int));\n+ (tree, HOST_WIDE_INT, struct function_arg_record_value_parms *);\n+static rtx function_arg_record_value (tree, enum machine_mode, int, int, int);\n \n /* A subroutine of function_arg_record_value.  Traverse the structure\n    recursively and determine how many registers will be required.  */"}]}