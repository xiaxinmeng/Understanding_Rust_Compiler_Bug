{"sha": "0425ae780fb2b055d985b5719af5edfaaad5e980", "node_id": "C_kwDOANBUbNoAKDA0MjVhZTc4MGZiMmIwNTVkOTg1YjU3MTlhZjVlZGZhYWFkNWU5ODA", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2023-01-03T17:46:02Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2023-01-03T17:49:23Z"}, "message": "OpenMP: GC unused SIMD clones\n\nSIMD clones are created during the IPA phase when it is not known whether\nor not the vectorizer can use them.  Clones for functions with external\nlinkage are part of the ABI, but local clones can be GC'ed if no calls are\nfound in the compilation unit after vectorization.\n\ngcc/ChangeLog\n\t* cgraph.h (struct cgraph_node): Add gc_candidate bit, modify\n\tdefault constructor to initialize it.\n\t* cgraphunit.cc (expand_all_functions): Save gc_candidate functions\n\tfor last and iterate to handle recursive calls.  Delete leftover\n\tcandidates at the end.\n\t* omp-simd-clone.cc (simd_clone_create): Set gc_candidate bit\n\ton local clones.\n\t* tree-vect-stmts.cc (vectorizable_simd_clone_call): Clear\n\tgc_candidate bit when a clone is used.\n\ngcc/testsuite/ChangeLog\n\t* g++.dg/gomp/target-simd-clone-1.C: Tweak to test\n\tthat the unused clone is GC'ed.\n\t* gcc.dg/gomp/target-simd-clone-1.c: Likewise.", "tree": {"sha": "147cec247d54aa4c199df4074534f686fd8b42c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/147cec247d54aa4c199df4074534f686fd8b42c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0425ae780fb2b055d985b5719af5edfaaad5e980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0425ae780fb2b055d985b5719af5edfaaad5e980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0425ae780fb2b055d985b5719af5edfaaad5e980", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0425ae780fb2b055d985b5719af5edfaaad5e980/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fdef16cd5d1b89359db3cd9a9768ab2d1b5081f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdef16cd5d1b89359db3cd9a9768ab2d1b5081f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdef16cd5d1b89359db3cd9a9768ab2d1b5081f"}], "stats": {"total": 77, "additions": 66, "deletions": 11}, "files": [{"sha": "5d3ced1b5d5eb8e1e761952a936f952b8d1785d3", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -891,7 +891,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n       versionable (false), can_change_signature (false),\n       redefined_extern_inline (false), tm_may_enter_irr (false),\n       ipcp_clone (false), declare_variant_alt (false),\n-      calls_declare_variant_alt (false), m_uid (uid), m_summary_id (-1)\n+      calls_declare_variant_alt (false), gc_candidate (false),\n+      m_uid (uid), m_summary_id (-1)\n   {}\n \n   /* Remove the node from cgraph and all inline clones inlined into it.\n@@ -1490,6 +1491,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   unsigned declare_variant_alt : 1;\n   /* True if the function calls declare_variant_alt functions.  */\n   unsigned calls_declare_variant_alt : 1;\n+  /* True if the function should only be emitted if it is used.  This flag\n+     is set for local SIMD clones when they are created and cleared if the\n+     vectorizer uses them.  */\n+  unsigned gc_candidate : 1;\n \n private:\n   /* Unique id of the node.  */"}, {"sha": "59ce2708b7be00cc36d450aa3f8e374c0054e5b1", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -1996,19 +1996,52 @@ expand_all_functions (void)\n \n   /* Output functions in RPO so callees get optimized before callers.  This\n      makes ipa-ra and other propagators to work.\n-     FIXME: This is far from optimal code layout.  */\n-  for (i = new_order_pos - 1; i >= 0; i--)\n-    {\n-      node = order[i];\n+     FIXME: This is far from optimal code layout.\n+     Make multiple passes over the list to defer processing of gc\n+     candidates until all potential uses are seen.  */\n+  int gc_candidates = 0;\n+  int prev_gc_candidates = 0;\n \n-      if (node->process)\n+  while (1)\n+    {\n+      for (i = new_order_pos - 1; i >= 0; i--)\n \t{\n-\t  expanded_func_count++;\n-\t  node->process = 0;\n-\t  node->expand ();\n+\t  node = order[i];\n+\n+\t  if (node->gc_candidate)\n+\t    gc_candidates++;\n+\t  else if (node->process)\n+\t    {\n+\t      expanded_func_count++;\n+\t      node->process = 0;\n+\t      node->expand ();\n+\t    }\n \t}\n+      if (!gc_candidates || gc_candidates == prev_gc_candidates)\n+\tbreak;\n+      prev_gc_candidates = gc_candidates;\n+      gc_candidates = 0;\n     }\n \n+  /* Free any unused gc_candidate functions.  */\n+  if (gc_candidates)\n+    for (i = new_order_pos - 1; i >= 0; i--)\n+      {\n+\tnode = order[i];\n+\tif (node->gc_candidate)\n+\t  {\n+\t    struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+\t    if (symtab->dump_file)\n+\t      fprintf (symtab->dump_file,\n+\t\t       \"Deleting unused function %s\\n\",\n+\t\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n+\t    node->process = false;\n+\t    free_dominance_info (fn, CDI_DOMINATORS);\n+\t    free_dominance_info (fn, CDI_POST_DOMINATORS);\n+\t    node->release_body (false);\n+\t  }\n+      }\n+\n   if (dump_file)\n     fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n \t     main_input_filename, profiled_func_count, expanded_func_count);"}, {"sha": "92b629b1021c744e40ece399fb16de294da29981", "filename": "gcc/omp-simd-clone.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fomp-simd-clone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Fomp-simd-clone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.cc?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -702,6 +702,11 @@ simd_clone_create (struct cgraph_node *old_node, bool force_local)\n \t= old_node->calls_declare_variant_alt;\n     }\n \n+  /* Mark clones with internal linkage as gc'able, so they will not be\n+     emitted unless the vectorizer can actually use them.  */\n+  if (!TREE_PUBLIC (new_node->decl))\n+    new_node->gc_candidate = true;\n+\n   return new_node;\n }\n "}, {"sha": "b96473642bbe53392dd5a08f6823bf6b939b794d", "filename": "gcc/testsuite/g++.dg/gomp/target-simd-clone-1.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-simd-clone-1.C?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -1,5 +1,5 @@\n /* { dg-options \"-fopenmp -O2\" } */\n-/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details -fdump-ipa-cgraph\" } */\n \n /* Test that simd clones are generated for functions with \"declare target\".  */\n \n@@ -23,3 +23,8 @@ void callit (int *a, int *b, int *c)\n \n /* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*N.*__Z5additii\" \"simdclone\" { target x86_64-*-* } } } */\n /* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*M.*__Z5additii\" \"simdclone\" { target x86_64-*-* } } } */\n+\n+/* Only the \"N\" clone is used.  The other one should be GC'ed.  */\n+\n+/* { dg-final { scan-ipa-dump \"Deleting unused function _ZGV.*M.*__Z5additii\" \"cgraph\" { target x86_64-*-* } } } */\n+"}, {"sha": "0d74aa971f93dff49499a54e6f1fbe966f4f10de", "filename": "gcc/testsuite/gcc.dg/gomp/target-simd-clone-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-simd-clone-1.c?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -1,5 +1,5 @@\n /* { dg-options \"-fopenmp -O2\" } */\n-/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details\" } */\n+/* { dg-additional-options \"-fopenmp-target-simd-clone=any -fdump-ipa-simdclone-details -fdump-ipa-cgraph\" } */\n \n /* Test that simd clones are generated for functions with \"declare target\".  */\n \n@@ -23,3 +23,7 @@ void callit (int *a, int *b, int *c)\n \n /* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*N.*_addit\" \"simdclone\" { target x86_64-*-* } } } */\n /* { dg-final { scan-ipa-dump \"Generated local clone _ZGV.*M.*_addit\" \"simdclone\" { target x86_64-*-* } } } */\n+\n+/* Only the \"N\" clone is used.  The other one should be GC'ed.  */\n+\n+/* { dg-final { scan-ipa-dump \"Deleting unused function _ZGV.*M.*_addit\" \"cgraph\" { target x86_64-*-* } } } */"}, {"sha": "6ddd41fb4733dfb86db62c1a29f965944c9370bf", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0425ae780fb2b055d985b5719af5edfaaad5e980/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=0425ae780fb2b055d985b5719af5edfaaad5e980", "patch": "@@ -4620,6 +4620,9 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n     }\n   vargs.release ();\n \n+  /* Mark the clone as no longer being a candidate for GC.  */\n+  bestn->gc_candidate = false;\n+\n   /* The call in STMT might prevent it from being removed in dce.\n      We however cannot remove it here, due to the way the ssa name\n      it defines is mapped to the new definition.  So just replace"}]}