{"sha": "268e16e89b2fe7ed6f9f03c877e05714464a704a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4ZTE2ZTg5YjJmZTdlZDZmOWYwM2M4NzdlMDU3MTQ0NjRhNzA0YQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-23T11:25:28Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-23T11:25:28Z"}, "message": "rs6000: Generate rl*imi for memory some more\n\nAn rl<wd>imi instruction is often written like \"(a << 8) | (b & 255)\".\nIf \"b\" now is a byte in memory, combine will combine the load with the\nmasking (with 255 in the example), since that is a single instruction;\nand then the rl*imi isn't combined from the remaining pieces.\n\nThis patch adds a splitter to make combine handle this case.\n\n\n\t* config/rs6000/rs6000.md (splitters for rldimi and rlwimi with the\n\tzero_extend argument from memory): New.\n\nFrom-SVN: r262929", "tree": {"sha": "f5a539fe7e1768deaa804abae7352d145b1fe4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5a539fe7e1768deaa804abae7352d145b1fe4ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268e16e89b2fe7ed6f9f03c877e05714464a704a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268e16e89b2fe7ed6f9f03c877e05714464a704a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268e16e89b2fe7ed6f9f03c877e05714464a704a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268e16e89b2fe7ed6f9f03c877e05714464a704a/comments", "author": null, "committer": null, "parents": [{"sha": "315aa691f486bfe71bae0a5fc8828db26daebb56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/315aa691f486bfe71bae0a5fc8828db26daebb56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/315aa691f486bfe71bae0a5fc8828db26daebb56"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "7dc5e0bfdd102fb8ae8c789bc72173e0539708df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268e16e89b2fe7ed6f9f03c877e05714464a704a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268e16e89b2fe7ed6f9f03c877e05714464a704a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=268e16e89b2fe7ed6f9f03c877e05714464a704a", "patch": "@@ -1,7 +1,12 @@\n+2018-07-23  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.md (splitters for rldimi and rlwimi with the\n+\tzero_extend argument from memory): New.\n+\n 2018-07-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR bootstrap/86621\n-\t* gcc/gimple-ssa-warn-alloca.c (alloca_call_type_by_arg): Avoid\n+\t* gimple-ssa-warn-alloca.c (alloca_call_type_by_arg): Avoid\n \tdiagnosing calls with unknown arguments unless -Walloca-larger-than\n \tis restricted to less than PTRDIFF_MAX bytes.\n "}, {"sha": "68ba5fded8c13ec6ad74b0ad1d2dc7fa60ac53ad", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268e16e89b2fe7ed6f9f03c877e05714464a704a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268e16e89b2fe7ed6f9f03c877e05714464a704a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=268e16e89b2fe7ed6f9f03c877e05714464a704a", "patch": "@@ -4065,6 +4065,47 @@\n    (set_attr \"length\" \"8\")])\n \n \n+; Yet another case is an rldimi with the second value coming from memory.\n+; The zero_extend that should become part of the rldimi is merged into the\n+; load from memory instead.  Split things properly again.\n+(define_split\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\")\n+\t(ior:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(zero_extend:DI (match_operand:QHSI 3 \"memory_operand\"))))]\n+  \"INTVAL (operands[2]) == <bits>\"\n+  [(set (match_dup 4)\n+\t(zero_extend:DI (match_dup 3)))\n+   (set (match_dup 0)\n+\t(ior:DI (and:DI (match_dup 4)\n+\t\t\t(match_dup 5))\n+\t\t(ashift:DI (match_dup 1)\n+\t\t\t   (match_dup 2))))]\n+{\n+  operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << <bits>) - 1);\n+})\n+\n+; rlwimi, too.\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"gpc_reg_operand\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\"))\n+\t\t(zero_extend:SI (match_operand:QHI 3 \"memory_operand\"))))]\n+  \"INTVAL (operands[2]) == <bits>\"\n+  [(set (match_dup 4)\n+\t(zero_extend:SI (match_dup 3)))\n+   (set (match_dup 0)\n+\t(ior:SI (and:SI (match_dup 4)\n+\t\t\t(match_dup 5))\n+\t\t(ashift:SI (match_dup 1)\n+\t\t\t   (match_dup 2))))]\n+{\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = GEN_INT ((HOST_WIDE_INT_1U << <bits>) - 1);\n+})\n+\n+\n ;; Now the simple shifts.\n \n (define_insn \"rotl<mode>3\""}]}