{"sha": "ee3bf4ae586b6bf6320336999e6e8fd778975b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUzYmY0YWU1ODZiNmJmNjMyMDMzNjk5OWU2ZThmZDc3ODk3NWI3MQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-07-26T10:38:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-07-26T10:38:40Z"}, "message": "re PR c++/57101 (-fcompare-debug failure with <type error>)\n\n2013-07-26  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/57101\n\t* g++.dg/cpp0x/pr57101.C: New.\n\nFrom-SVN: r201262", "tree": {"sha": "0e60eb2fbe90e40b7732d21fd17b8bc62989f5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e60eb2fbe90e40b7732d21fd17b8bc62989f5e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee3bf4ae586b6bf6320336999e6e8fd778975b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3bf4ae586b6bf6320336999e6e8fd778975b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee3bf4ae586b6bf6320336999e6e8fd778975b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3bf4ae586b6bf6320336999e6e8fd778975b71/comments", "author": null, "committer": null, "parents": [{"sha": "040d8a1c3739e5e6120efadf4295be39c82bd5e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040d8a1c3739e5e6120efadf4295be39c82bd5e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040d8a1c3739e5e6120efadf4295be39c82bd5e5"}], "stats": {"total": 225, "additions": 225, "deletions": 0}, "files": [{"sha": "a95bc4989b9ffc4e7d52ba79364ec89d801e7a66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3bf4ae586b6bf6320336999e6e8fd778975b71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3bf4ae586b6bf6320336999e6e8fd778975b71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee3bf4ae586b6bf6320336999e6e8fd778975b71", "patch": "@@ -1,3 +1,8 @@\n+2013-07-26  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/57101\n+\t* g++.dg/cpp0x/pr57101.C: New.\n+\n 2013-07-26  Ian Bolton  <ian.bolton@arm.com>\n \n \t* gcc.target/aarch64/neg_1.c: New test."}, {"sha": "a5c4a3c11a6f2cbab16cca64233c29e6a2965a6b", "filename": "gcc/testsuite/g++.dg/cpp0x/pr57101.C", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3bf4ae586b6bf6320336999e6e8fd778975b71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3bf4ae586b6bf6320336999e6e8fd778975b71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr57101.C?ref=ee3bf4ae586b6bf6320336999e6e8fd778975b71", "patch": "@@ -0,0 +1,220 @@\n+// { dg-options \"-std=c++11 -fcompare-debug\" }\n+\n+typedef long unsigned size_t;\n+namespace\n+{\n+  template < typename _Tp, _Tp __v > struct integral_constant\n+  {\n+    static const _Tp value = __v;\n+  };\n+  typedef integral_constant < bool, false > false_type;\n+  template < typename > struct remove_cv;\n+  template < typename > struct __is_void_helper:false_type\n+  {\n+  };\n+  template\n+    <\n+    typename\n+    _Tp\n+    >\n+    struct\n+    is_void:integral_constant\n+    < bool, (__is_void_helper < typename remove_cv < _Tp >::type >::value) >\n+  {\n+  };\n+  template < typename > struct is_function:false_type\n+  {\n+  };\n+  template < typename _Tp > struct remove_const\n+  {\n+    typedef _Tp type;\n+  };\n+  template < typename _Tp > struct remove_volatile\n+  {\n+    typedef _Tp type;\n+  };\n+  template < typename _Tp > struct remove_cv\n+  {\n+    typedef\n+      typename\n+      remove_const < typename remove_volatile < _Tp >::type >::type type;\n+  };\n+  template < typename > struct is_lvalue_reference:false_type\n+  {\n+  };\n+  template < typename _Tp, bool = is_void < _Tp >::value > struct __add_rvalue_reference_helper\n+  {\n+    typedef _Tp type;\n+  };\n+  template\n+    <\n+    typename\n+    _Tp > struct add_rvalue_reference:__add_rvalue_reference_helper < _Tp >\n+  {\n+  };\n+  template\n+    < typename _Tp > typename add_rvalue_reference < _Tp >::type declval ();\n+  template\n+    <\n+    typename,\n+    typename\n+    _To, bool = (is_function < _To >::value) > struct __is_convertible_helper;\n+  template\n+    <\n+    typename\n+    _From, typename _To > struct __is_convertible_helper <_From, _To, false >\n+  {\n+    static const bool __value = sizeof ((declval < _From > ()));\n+  };\n+  template\n+    <\n+    typename\n+    _From,\n+    typename\n+    _To\n+    >\n+    struct\n+    is_convertible:integral_constant\n+    < bool, __is_convertible_helper < _From, _To >::__value >\n+  {\n+  };\n+  template < bool, typename _Tp = void >struct enable_if\n+  {\n+    typedef _Tp type;\n+  };\n+  template < typename _Tp > struct identity\n+  {\n+    typedef _Tp type;\n+  };\n+  template\n+    <\n+    typename\n+    _Tp\n+    >\n+    typename\n+    enable_if\n+    <\n+    is_lvalue_reference\n+    < _Tp >::value, _Tp >::type forward (typename identity < _Tp >::type)\n+  {\n+    return 0;\n+\n+  }\n+  template < class _T1, class > struct pair\n+  {\n+    _T1 first;\n+    template < class _U1, class = typename enable_if < is_convertible < _U1, _T1 >::value >::type > pair (_U1 __x):\n+    first\n+      (forward < _U1 > (__x))\n+    {\n+    }\n+  };\n+}\n+\n+namespace __gnu_cxx\n+{\n+  template < typename > class new_allocator\n+  {\n+  };\n+}\n+\n+namespace std\n+{\n+  template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp >\n+  {\n+  public:\n+    template < typename > struct rebind\n+    {\n+      typedef allocator other;\n+    };\n+  };\n+  template < typename, typename > struct unary_function;\n+  template < typename, typename, typename > struct binary_function\n+  {\n+  };\n+  template < typename _Tp > struct less:binary_function < _Tp, _Tp, bool >\n+  {\n+  };\n+  template\n+    <\n+    typename\n+    _Pair\n+    > struct _Select1st:unary_function < _Pair, typename _Pair::first_type >\n+  {\n+  };\n+  template < typename > struct _Rb_tree_node;\n+  template\n+    <\n+    typename,\n+    typename\n+    _Val,\n+    typename,\n+    typename _Compare, typename _Alloc = allocator < _Val > >class _Rb_tree\n+  {\n+    typedef\n+      typename\n+      _Alloc::template\n+      rebind < _Rb_tree_node < _Val > >::other _Node_allocator;\n+  public:\n+    typedef _Alloc allocator_type;\n+    template < typename _Key_compare > struct _Rb_tree_impl\n+    {\n+      _Rb_tree_impl (_Key_compare, _Node_allocator);\n+    };\n+    _Rb_tree_impl < _Compare > _M_impl;\n+  _Rb_tree (_Compare __comp, allocator_type __a):\n+    _M_impl (__comp, __a)\n+    {\n+    }\n+  };\n+  template < class _E > class initializer_list\n+  {\n+    typedef size_t size_type;\n+    typedef _E *iterator;\n+    iterator _M_array;\n+    size_type _M_len;\n+  };\n+  template\n+    <\n+    typename\n+    _Key,\n+    typename\n+    _Tp,\n+    typename\n+    _Compare\n+    =\n+    less\n+    <\n+    _Key >, typename _Alloc = allocator < pair < _Key, _Tp > > >class multimap\n+  {\n+    typedef _Key key_type;\n+    typedef pair < _Key, _Tp > value_type;\n+    typedef _Compare key_compare;\n+    typedef _Alloc allocator_type;\n+    typedef\n+      _Rb_tree\n+      <\n+      key_type,\n+      value_type, _Select1st < value_type >, key_compare > _Rep_type;\n+    _Rep_type _M_t;\n+  public:\n+  multimap (initializer_list < value_type >, _Compare __comp = _Compare (), allocator_type __a = allocator_type ()):\n+    _M_t\n+      (__comp, __a)\n+    {\n+    }\n+  };\n+}\n+\n+using namespace std;\n+void\n+test01 ()\n+{\n+  typedef multimap < int, double >Container;\n+  Container (\n+\t      {\n+\t      {\n+\t      1}\n+\t      }\n+  );\n+}"}]}