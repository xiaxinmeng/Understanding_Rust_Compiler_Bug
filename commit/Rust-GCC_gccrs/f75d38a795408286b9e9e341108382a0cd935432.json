{"sha": "f75d38a795408286b9e9e341108382a0cd935432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1ZDM4YTc5NTQwODI4NmI5ZTllMzQxMTA4MzgyYTBjZDkzNTQzMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-06T13:42:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-06T13:42:58Z"}, "message": "Add prototypes in forward declarations.\n\nAdd some missing parameters to a few calls.\n\nFrom-SVN: r3669", "tree": {"sha": "d3cd763d405b5414c2aed69307fe87d5b6c6629f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3cd763d405b5414c2aed69307fe87d5b6c6629f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f75d38a795408286b9e9e341108382a0cd935432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75d38a795408286b9e9e341108382a0cd935432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75d38a795408286b9e9e341108382a0cd935432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75d38a795408286b9e9e341108382a0cd935432/comments", "author": null, "committer": null, "parents": [{"sha": "7a03f4b4f83f6aa9114f3315cf6372bdc5fda428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a03f4b4f83f6aa9114f3315cf6372bdc5fda428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a03f4b4f83f6aa9114f3315cf6372bdc5fda428"}], "stats": {"total": 288, "additions": 150, "deletions": 138}, "files": [{"sha": "8e4798383adf93a48675368dc3fe44379bbca75e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 150, "deletions": 138, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75d38a795408286b9e9e341108382a0cd935432/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75d38a795408286b9e9e341108382a0cd935432/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=f75d38a795408286b9e9e341108382a0cd935432", "patch": "@@ -235,7 +235,7 @@ struct function_unit\n   struct function_unit_op *ops;\t/* Pointer to first operation type.  */\n   int needs_conflict_function;\t/* Nonzero if a conflict function required.  */\n   int needs_blockage_function;\t/* Nonzero if a blockage function required.  */\n-  int needs_range_function;\t/* Nonzero if a blockage range function required.  */\n+  int needs_range_function;\t/* Nonzero if blockage range function needed.*/\n   rtx default_cost;\t\t/* Conflict cost, if constant.  */\n   struct range issue_delay;\t/* Range of issue delay values.  */\n   int max_blockage;\t\t/* Maximum time an insn blocks the unit.  */\n@@ -250,6 +250,49 @@ static struct insn_def *defs;\n static struct delay_desc *delays;\n static struct function_unit *units;\n \n+/* An expression where all the unknown terms are EQ_ATTR tests can be\n+   rearranged into a COND provided we can enumerate all possible\n+   combinations of the unknown values.  The set of combinations become the\n+   tests of the COND; the value of the expression given that combination is\n+   computed and becomes the corresponding value.  To do this, we must be\n+   able to enumerate all values for each attribute used in the expression\n+   (currently, we give up if we find a numeric attribute).\n+   \n+   If the set of EQ_ATTR tests used in an expression tests the value of N\n+   different attributes, the list of all possible combinations can be made\n+   by walking the N-dimensional attribute space defined by those\n+   attributes.  We record each of these as a struct dimension.\n+\n+   The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an\n+   expression are the same, the will also have the same address.  We find\n+   all the EQ_ATTR nodes by marking them MEM_VOLATILE_P.  This bit later\n+   represents the value of an EQ_ATTR node, so once all nodes are marked,\n+   they are also given an initial value of FALSE.\n+\n+   We then separate the set of EQ_ATTR nodes into dimensions for each\n+   attribute and put them on the VALUES list.  Terms are added as needed by\n+   `add_values_to_cover' so that all possible values of the attribute are\n+   tested.\n+\n+   Each dimension also has a current value.  This is the node that is\n+   currently considered to be TRUE.  If this is one of the nodes added by\n+   `add_values_to_cover', all the EQ_ATTR tests in the original expression\n+   will be FALSE.  Otherwise, only the CURRENT_VALUE will be true.\n+\n+   NUM_VALUES is simply the length of the VALUES list and is there for\n+   convenience.\n+\n+   Once the dimensions are created, the algorithm enumerates all possible\n+   values and computes the current value of the given expression.  */\n+\n+struct dimension \n+{\n+  struct attr_desc *attr;\t/* Attribute for this dimension.  */\n+  rtx values;\t\t\t/* List of attribute values used.  */\n+  rtx current_value;\t\t/* Position in the list for the TRUE value.  */\n+  int num_values;\t\t/* Length of the values list.  */\n+};\n+\n /* Other variables. */\n \n static int insn_code_number;\n@@ -310,83 +353,91 @@ static char *alternative_name;\n \n rtx frame_pointer_rtx, stack_pointer_rtx, arg_pointer_rtx;\n \n+#if 0\n+static rtx attr_rtx\t\tPROTO((enum rtx_code, ...));\n+static char *attr_printf\tPROTO((int, char *, ...));\n+#else\n static rtx attr_rtx ();\n static char *attr_printf ();\n-static char *attr_string ();\n-static rtx check_attr_test ();\n-static rtx check_attr_value ();\n-static rtx convert_set_attr_alternative ();\n-static rtx convert_set_attr ();\n-static void check_defs ();\n-static rtx convert_const_symbol_ref ();\n-static rtx make_canonical ();\n-static struct attr_value *get_attr_value ();\n-static rtx copy_rtx_unchanging ();\n-static rtx copy_boolean ();\n-static void expand_delays ();\n-static rtx operate_exp ();\n-static void expand_units ();\n-static rtx simplify_knowing ();\n-static rtx encode_units_mask ();\n-static void fill_attr ();\n-static rtx substitute_address ();\n-static void make_length_attrs ();\n-static rtx identity_fn ();\n-static rtx zero_fn ();\n-static rtx one_fn ();\n-static rtx max_fn ();\n-static rtx simplify_cond ();\n-static rtx simplify_by_alternatives ();\n-static rtx simplify_by_exploding ();\n-static int find_and_mark_used_attributes ();\n-static void unmark_used_attributes ();\n-static int add_values_to_cover ();\n-static int increment_current_value ();\n-static rtx test_for_current_value ();\n-static rtx simplify_with_current_value ();\n-static rtx simplify_with_current_value_aux ();\n-static void remove_insn_ent ();\n-static void insert_insn_ent ();\n-static rtx insert_right_side ();\n-static rtx make_alternative_compare ();\n-static int compute_alternative_mask ();\n-static rtx evaluate_eq_attr ();\n-static rtx simplify_and_tree ();\n-static rtx simplify_or_tree ();\n-static rtx simplify_test_exp ();\n-static void optimize_attrs ();\n-static void gen_attr ();\n-static int count_alternatives ();\n-static int compares_alternatives_p ();\n-static int contained_in_p ();\n-static void gen_insn ();\n-static void gen_delay ();\n-static void gen_unit ();\n-static void write_test_expr ();\n-static int max_attr_value ();\n-static void walk_attr_value ();\n-static void write_attr_get ();\n-static rtx eliminate_known_true ();\n-static void write_attr_set ();\n-static void write_attr_case ();\n-static void write_attr_value ();\n-static void write_attr_valueq ();\n-static void write_upcase ();\n-static void write_indent ();\n-static void write_eligible_delay ();\n-static void write_function_unit_info ();\n-static void write_complex_function ();\n-static int n_comma_elts ();\n-static char *next_comma_elt ();\n-static struct attr_desc *find_attr ();\n-static void make_internal_attr ();\n-static struct attr_value *find_most_used ();\n-static rtx find_single_value ();\n-static rtx make_numeric_value ();\n-static void extend_range ();\n-char *xrealloc ();\n-char *xmalloc ();\n-static void fatal ();\n+#endif\n+\n+static char *attr_string        PROTO((char *, int));\n+static rtx check_attr_test\tPROTO((rtx, int));\n+static rtx check_attr_value\tPROTO((rtx, struct attr_desc *));\n+static rtx convert_set_attr_alternative PROTO((rtx, int, int, int));\n+static rtx convert_set_attr\tPROTO((rtx, int, int, int));\n+static void check_defs\t\tPROTO((void));\n+static rtx convert_const_symbol_ref PROTO((rtx, struct attr_desc *));\n+static rtx make_canonical\tPROTO((struct attr_desc *, rtx));\n+static struct attr_value *get_attr_value PROTO((rtx, struct attr_desc *, int));\n+static rtx copy_rtx_unchanging\tPROTO((rtx));\n+static rtx copy_boolean\t\tPROTO((rtx));\n+static void expand_delays\tPROTO((void));\n+static rtx operate_exp\t\tPROTO((enum operator, rtx, rtx));\n+static void expand_units\tPROTO((void));\n+static rtx simplify_knowing\tPROTO((rtx, rtx));\n+static rtx encode_units_mask\tPROTO((rtx));\n+static void fill_attr\t\tPROTO((struct attr_desc *));\n+static rtx substitute_address\tPROTO((rtx, rtx (*) (rtx), rtx (*) (rtx)));\n+static void make_length_attrs\tPROTO((void));\n+static rtx identity_fn\t\tPROTO((rtx));\n+static rtx zero_fn\t\tPROTO((rtx));\n+static rtx one_fn\t\tPROTO((rtx));\n+static rtx max_fn\t\tPROTO((rtx));\n+static rtx simplify_cond\tPROTO((rtx, int, int));\n+static rtx simplify_by_alternatives PROTO((rtx, int, int));\n+static rtx simplify_by_exploding PROTO((rtx));\n+static int find_and_mark_used_attributes PROTO((rtx, rtx *, int *));\n+static void unmark_used_attributes PROTO((rtx, struct dimension *, int));\n+static int add_values_to_cover\tPROTO((struct dimension *));\n+static int increment_current_value PROTO((struct dimension *, int));\n+static rtx test_for_current_value PROTO((struct dimension *, int));\n+static rtx simplify_with_current_value PROTO((rtx, struct dimension *, int));\n+static rtx simplify_with_current_value_aux PROTO((rtx));\n+static void remove_insn_ent  PROTO((struct attr_value *, struct insn_ent *));\n+static void insert_insn_ent  PROTO((struct attr_value *, struct insn_ent *));\n+static rtx insert_right_side\tPROTO((enum rtx_code, rtx, rtx, int, int));\n+static rtx make_alternative_compare PROTO((int));\n+static int compute_alternative_mask PROTO((rtx, enum rtx_code));\n+static rtx evaluate_eq_attr\tPROTO((rtx, rtx, int, int));\n+static rtx simplify_and_tree\tPROTO((rtx, rtx *, int, int));\n+static rtx simplify_or_tree\tPROTO((rtx, rtx *, int, int));\n+static rtx simplify_test_exp\tPROTO((rtx, int, int));\n+static void optimize_attrs\tPROTO((void));\n+static void gen_attr\t\tPROTO((rtx));\n+static int count_alternatives\tPROTO((rtx));\n+static int compares_alternatives_p PROTO((rtx));\n+static int contained_in_p\tPROTO((rtx, rtx));\n+static void gen_insn\t\tPROTO((rtx));\n+static void gen_delay\t\tPROTO((rtx));\n+static void gen_unit\t\tPROTO((rtx));\n+static void write_test_expr\tPROTO((rtx, int));\n+static int max_attr_value\tPROTO((rtx));\n+static void walk_attr_value\tPROTO((rtx));\n+static void write_attr_get\tPROTO((struct attr_desc *));\n+static rtx eliminate_known_true PROTO((rtx, rtx, int, int));\n+static void write_attr_set\tPROTO((struct attr_desc *, int, rtx, char *,\n+\t\t\t\t       char *, rtx, int, int));\n+static void write_attr_case\tPROTO((struct attr_desc *, struct attr_value *,\n+\t\t\t\t       int, char *, char *, int, rtx));\n+static void write_attr_valueq\tPROTO((struct attr_desc *, char *));\n+static void write_attr_value\tPROTO((struct attr_desc *, rtx));\n+static void write_upcase\tPROTO((char *));\n+static void write_indent\tPROTO((int));\n+static void write_eligible_delay PROTO((char *));\n+static void write_function_unit_info PROTO((void));\n+static void write_complex_function PROTO((struct function_unit *, char *,\n+\t\t\t\t\t  char *));\n+static int n_comma_elts\t\tPROTO((char *));\n+static char *next_comma_elt\tPROTO((char **));\n+static struct attr_desc *find_attr PROTO((char *, int));\n+static void make_internal_attr\tPROTO((char *, rtx, int));\n+static struct attr_value *find_most_used  PROTO((struct attr_desc *));\n+static rtx find_single_value\tPROTO((struct attr_desc *));\n+static rtx make_numeric_value\tPROTO((int));\n+static void extend_range\tPROTO((struct range *, int, int));\n+char *xrealloc\t\t\tPROTO((char *, unsigned));\n+char *xmalloc\t\t\tPROTO((unsigned));\n \n #define oballoc(size) obstack_alloc (hash_obstack, size)\n \n@@ -936,7 +987,7 @@ check_attr_test (exp, is_const)\n \t  while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t    {\n \t      newexp = attr_eq (XSTR (exp, 0), p);\n-\t      orexp = insert_right_side (IOR, orexp, newexp, -2);\n+\t      orexp = insert_right_side (IOR, orexp, newexp, -2, -2);\n \t    }\n \n \t  return check_attr_test (orexp, is_const);\n@@ -1865,7 +1916,7 @@ expand_units ()\n \t      if (op->ready <= 1)\n \t\tbreak;\n \t      else if (op->ready == value)\n-\t\torexp = insert_right_side (IOR, orexp, op->condexp, -2);\n+\t\torexp = insert_right_side (IOR, orexp, op->condexp, -2, -2);\n \t      else\n \t\t{\n \t\t  XVECEXP (readycost, 0, nvalues * 2) = orexp;\n@@ -2250,8 +2301,8 @@ make_length_attrs ()\n   static char *new_names[] = {\"*insn_default_length\",\n \t\t\t      \"*insn_variable_length_p\",\n \t\t\t      \"*insn_current_length\"};\n-  static rtx (*no_address_fn[]) () = {identity_fn, zero_fn, zero_fn};\n-  static rtx (*address_fn[]) () = {max_fn, one_fn, identity_fn};\n+  static rtx (*no_address_fn[]) PROTO((rtx)) = {identity_fn, zero_fn, zero_fn};\n+  static rtx (*address_fn[]) PROTO((rtx)) = {max_fn, one_fn, identity_fn};\n   int i;\n   struct attr_desc *length_attr, *new_attr;\n   struct attr_value *av, *new_av;\n@@ -2495,7 +2546,7 @@ insert_insn_ent (av, ie)\n \n static rtx\n insert_right_side (code, exp, term, insn_code, insn_index)\n-     RTX_CODE code;\n+     enum rtx_code code;\n      rtx exp;\n      rtx term;\n      int insn_code, insn_index;\n@@ -2557,13 +2608,12 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n    If so, we can optimize.  Similarly for IOR's of EQ_ATTR.\n \n    This routine is passed an expression and either AND or IOR.  It returns a\n-   bitmask indicating which alternatives are present.\n-   ??? What does \"present\" mean?  */\n+   bitmask indicating which alternatives are mentioned within EXP.  */\n \n static int\n compute_alternative_mask (exp, code)\n      rtx exp;\n-     RTX_CODE code;\n+     enum rtx_code code;\n {\n   char *string;\n   if (GET_CODE (exp) == code)\n@@ -2611,9 +2661,10 @@ make_alternative_compare (mask)\n    of \"attr\" for this insn code.  From that value, we can compute a test\n    showing when the EQ_ATTR will be true.  This routine performs that\n    computation.  If a test condition involves an address, we leave the EQ_ATTR\n-   intact because addresses are only valid for the `length' attribute.  */\n+   intact because addresses are only valid for the `length' attribute. \n \n-/* ??? Kenner, document the meanings of the arguments!!!  */\n+   EXP is the EQ_ATTR expression and VALUE is the value of that attribute\n+   for the insn corresponding to INSN_CODE and INSN_INDEX.  */\n \n static rtx\n evaluate_eq_attr (exp, value, insn_code, insn_index)\n@@ -2663,8 +2714,10 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \t  right = insert_right_side (AND, andexp, this,\n \t\t\t\t     insn_code, insn_index);\n \t  right = insert_right_side (AND, right,\n-\t\t\tevaluate_eq_attr (exp, XVECEXP (value, 0, i + 1),\n-\t\t\t\t\t   insn_code, insn_index),\n+\t\t\t\t     evaluate_eq_attr (exp,\n+\t\t\t\t\t\t       XVECEXP (value, 0,\n+\t\t\t\t\t\t\t\ti + 1),\n+\t\t\t\t\t\t       insn_code, insn_index),\n \t\t\t\t     insn_code, insn_index);\n \t  orexp = insert_right_side (IOR, orexp, right,\n \t\t\t\t     insn_code, insn_index);\n@@ -2678,7 +2731,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n       /* Handle the default case.  */\n       right = insert_right_side (AND, andexp,\n \t\t\t\t evaluate_eq_attr (exp, XEXP (value, 1),\n-\t\t\t\t\t\t    insn_code, insn_index),\n+\t\t\t\t\t\t   insn_code, insn_index),\n \t\t\t\t insn_code, insn_index);\n       newexp = insert_right_side (IOR, orexp, right, insn_code, insn_index);\n     }\n@@ -3340,49 +3393,6 @@ simplify_by_alternatives (exp, insn_code, insn_index)\n }\n #endif\n \f\n-/* An expression where all the unknown terms are EQ_ATTR tests can be\n-   rearranged into a COND provided we can enumerate all possible\n-   combinations of the unknown values.  The set of combinations become the\n-   tests of the COND; the value of the expression given that combination is\n-   computed and becomes the corresponding value.  To do this, we must be\n-   able to enumerate all values for each attribute used in the expression\n-   (currently, we give up if we find a numeric attribute).\n-   \n-   If the set of EQ_ATTR tests used in an expression tests the value of N\n-   different attributes, the list of all possible combinations can be made\n-   by walking the N-dimensional attribute space defined by those\n-   attributes.  We record each of these as a struct dimension.\n-\n-   The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an\n-   expression are the same, the will also have the same address.  We find\n-   all the EQ_ATTR nodes by marking them MEM_VOLATILE_P.  This bit later\n-   represents the value of an EQ_ATTR node, so once all nodes are marked,\n-   they are also given an initial value of FALSE.\n-\n-   We then separate the set of EQ_ATTR nodes into dimensions for each\n-   attribute and put them on the VALUES list.  Terms are added as needed by\n-   `add_values_to_cover' so that all possible values of the attribute are\n-   tested.\n-\n-   Each dimension also has a current value.  This is the node that is\n-   currently considered to be TRUE.  If this is one of the nodes added by\n-   `add_values_to_cover', all the EQ_ATTR tests in the original expression\n-   will be FALSE.  Otherwise, only the CURRENT_VALUE will be true.\n-\n-   NUM_VALUES is simply the length of the VALUES list and is there for\n-   convenience.\n-\n-   Once the dimensions are created, the algorithm enumerates all possible\n-   values and computes the current value of the given expression.  */\n-\n-struct dimension \n-{\n-  struct attr_desc *attr;\t/* Attribute for this dimension.  */\n-  rtx values;\t\t\t/* List of attribute values used.  */\n-  rtx current_value;\t\t/* Position in the list for the TRUE value.  */\n-  int num_values;\t\t/* Length of the values list.  */\n-};\n-\n /* If EXP is a suitable expression, reorganize it by constructing an\n    equivalent expression that is a COND with the tests being all combinations\n    of attribute values and the values being simple constants.  */\n@@ -3656,7 +3666,7 @@ add_values_to_cover (dim)\n       prev = &dim->values;\n       for (link = dim->values; link; link = *prev)\n \t{\n-\t  orexp = insert_right_side (IOR, orexp, XEXP (link, 0), -2);\n+\t  orexp = insert_right_side (IOR, orexp, XEXP (link, 0), -2, -2);\n \t  prev = &XEXP (link, 1);\n \t}\n       link = rtx_alloc (EXPR_LIST);\n@@ -3700,7 +3710,8 @@ test_for_current_value (space, ndim)\n   rtx exp = true_rtx;\n \n   for (i = 0; i < ndim; i++)\n-    exp = insert_right_side (AND, exp, XEXP (space[i].current_value, 0), -2);\n+    exp = insert_right_side (AND, exp, XEXP (space[i].current_value, 0),\n+\t\t\t     -2, -2);\n \n   return exp;\n }\n@@ -4215,7 +4226,7 @@ gen_unit (def)\n       int i;\n \n       for (i = 0; i < XVECLEN (def, 6); i++)\n-\torexp = insert_right_side (IOR, orexp, XVECEXP (def, 6, i), -2);\n+\torexp = insert_right_side (IOR, orexp, XVECEXP (def, 6, i), -2, -2);\n \n       op->conflict_exp = orexp;\n       extend_range (&unit->issue_delay, 1, issue_delay);\n@@ -4228,7 +4239,7 @@ gen_unit (def)\n \n   /* Merge our conditional into that of the function unit so we can determine\n      which insns are used by the function unit.  */\n-  unit->condexp = insert_right_side (IOR, unit->condexp, op->condexp, -2);\n+  unit->condexp = insert_right_side (IOR, unit->condexp, op->condexp, -2, -2);\n }\n \f\n /* Given a piece of RTX, print a C expression to test it's truth value.\n@@ -4746,7 +4757,8 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n /* Write out the computation for one attribute value.  */\n \n static void\n-write_attr_case (attr, av, write_case_lines, prefix, suffix, indent, known_true)\n+write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n+\t\t known_true)\n      struct attr_desc *attr;\n      struct attr_value *av;\n      int write_case_lines;\n@@ -5137,7 +5149,7 @@ write_complex_function (unit, name, connection)\n       /* If single value, just write it.  */\n       value = find_single_value (attr);\n       if (value)\n-\twrite_attr_set (attr, 6, value, \"return\", \";\\n\", true_rtx, -2);\n+\twrite_attr_set (attr, 6, value, \"return\", \";\\n\", true_rtx, -2, -2);\n       else\n \t{\n \t  common_av = find_most_used (attr);"}]}