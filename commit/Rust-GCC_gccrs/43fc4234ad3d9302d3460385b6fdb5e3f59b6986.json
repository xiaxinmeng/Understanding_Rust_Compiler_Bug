{"sha": "43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmYzQyMzRhZDNkOTMwMmQzNDYwMzg1YjZmZGI1ZTNmNTliNjk4Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-16T07:49:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-16T09:28:03Z"}, "message": "tree-optimization/101088 - fix SM invalidation issue\n\nWhen we face a sm_ord vs sm_unord for the same ref during\nstore sequence merging we assert that the ref is already marked\nunsupported.  But it can be that it will only be marked so\nduring the ongoing merging so instead of asserting mark it here.\n\nAlso apply some optimization to not waste resources to search\nfor already unsupported refs.\n\n2021-06-16  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101088\n\t* tree-ssa-loop-im.c (sm_seq_valid_bb): Only look for\n\tsupported refs on edges.  Do not assert same ref but\n\tdifferent kind stores are unsuported but mark them so.\n\t(hoist_memory_references): Only look for supported refs\n\ton exits.\n\n\t* gcc.dg/torture/pr101088.c: New testcase.", "tree": {"sha": "661666162ff00d6b54731fe458f1acb69077775f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/661666162ff00d6b54731fe458f1acb69077775f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43fc4234ad3d9302d3460385b6fdb5e3f59b6986/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3155d51bfd1de8b6c4645dcb2292248a8d7cc3c9"}], "stats": {"total": 66, "additions": 61, "deletions": 5}, "files": [{"sha": "00fce39d2f4f9522e5a31eed3aff39dd66827a3e", "filename": "gcc/testsuite/gcc.dg/torture/pr101088.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43fc4234ad3d9302d3460385b6fdb5e3f59b6986/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101088.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43fc4234ad3d9302d3460385b6fdb5e3f59b6986/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101088.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101088.c?ref=43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+\n+int bh, on, h0;\n+\n+void\n+qw (int n2)\n+{\n+  int *e5;\n+\n+  if (n2 == 0)\n+    {\n+      n2 = 1;\n+      while (n2 != 0)\n+\tfor (n2 = 0; n2 < 1; ++n2)\n+\t  {\n+\t  }\n+\n+      e5 = &n2;\n+    }\n+  else\n+    e5 = &on;\n+\n+  while (h0 < 1)\n+    {\n+      if (on == 0)\n+\t{\n+\t  ++*e5;\n+\t  bh = 0;\n+\t}\n+      else\n+\t{\n+\t  bh = 0;\n+\t  ++on;\n+\t  *e5 = on;\n+\t  h0 = *e5;\n+\t  if (h0 == 0)\n+\t    {\n+\t      *e5 = 0;\n+\t      ++h0;\n+\t    }\n+\t}\n+\n+      ++h0;\n+    }\n+}"}, {"sha": "7de47edbcb303a22eca4b6951121f2d57810acb4", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43fc4234ad3d9302d3460385b6fdb5e3f59b6986/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43fc4234ad3d9302d3460385b6fdb5e3f59b6986/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=43fc4234ad3d9302d3460385b6fdb5e3f59b6986", "patch": "@@ -2340,7 +2340,13 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t      tree vuse = gimple_phi_arg_def (phi, i);\n \t      edge e = gimple_phi_arg_edge (phi, i);\n \t      auto_vec<seq_entry> edge_seq;\n-\t      bitmap_copy (tem_refs_not_in_seq, refs_not_in_seq);\n+\t      bitmap_and_compl (tem_refs_not_in_seq,\n+\t\t\t\trefs_not_in_seq, refs_not_supported);\n+\t      /* If we've marked all refs we search for as unsupported\n+\t\t we can stop processing and use the sequence as before\n+\t\t the PHI.  */\n+\t      if (bitmap_empty_p (tem_refs_not_in_seq))\n+\t\treturn 1;\n \t      eret = sm_seq_valid_bb (loop, e->src, vuse, edge_seq,\n \t\t\t\t      tem_refs_not_in_seq, refs_not_supported,\n \t\t\t\t      true, fully_visited);\n@@ -2379,9 +2385,9 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t\t  /* sm_other prevails.  */\n \t\t  else if (first_edge_seq[i].second != edge_seq[i].second)\n \t\t    {\n-\t\t      /* This is just an optimization.  */\n-\t\t      gcc_assert (bitmap_bit_p (refs_not_supported,\n-\t\t\t\t\t\tfirst_edge_seq[i].first));\n+\t\t      /* Make sure the ref is marked as not supported.  */\n+\t\t      bitmap_set_bit (refs_not_supported,\n+\t\t\t\t      first_edge_seq[i].first);\n \t\t      first_edge_seq[i].second = sm_other;\n \t\t      first_edge_seq[i].from = NULL_TREE;\n \t\t    }\n@@ -2533,7 +2539,12 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n       vec<seq_entry> seq;\n       seq.create (4);\n       auto_bitmap refs_not_in_seq (&lim_bitmap_obstack);\n-      bitmap_copy (refs_not_in_seq, mem_refs);\n+      bitmap_and_compl (refs_not_in_seq, mem_refs, refs_not_supported);\n+      if (bitmap_empty_p (refs_not_in_seq))\n+\t{\n+\t  seq.release ();\n+\t  break;\n+\t}\n       auto_bitmap fully_visited;\n       int res = sm_seq_valid_bb (loop, e->src, NULL_TREE,\n \t\t\t\t seq, refs_not_in_seq,"}]}