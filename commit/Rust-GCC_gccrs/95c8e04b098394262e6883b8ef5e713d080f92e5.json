{"sha": "95c8e04b098394262e6883b8ef5e713d080f92e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjOGUwNGIwOTgzOTQyNjJlNjg4M2I4ZWY1ZTcxM2QwODBmOTJlNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@redhat.com", "date": "2000-11-17T22:18:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-11-17T22:18:25Z"}, "message": "Fix miscompilation of linux kernel ia64_do_signal routine.\n\n\t* config/ia64/ia64.c (emit_insn_group_barriers, case CALL_INSN):\n\tDon't clear need_barrier is next_insn is a CALL_INSN, or has\n\tinstruction type B or UNKNOWN.\n\nFrom-SVN: r37528", "tree": {"sha": "c8bc91dc4827b16086b98c856986594bf4c3b47b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8bc91dc4827b16086b98c856986594bf4c3b47b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95c8e04b098394262e6883b8ef5e713d080f92e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c8e04b098394262e6883b8ef5e713d080f92e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c8e04b098394262e6883b8ef5e713d080f92e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c8e04b098394262e6883b8ef5e713d080f92e5/comments", "author": null, "committer": null, "parents": [{"sha": "4f21aedbf4c7661626f49e7ca74ecc2a80892262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f21aedbf4c7661626f49e7ca74ecc2a80892262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f21aedbf4c7661626f49e7ca74ecc2a80892262"}], "stats": {"total": 31, "additions": 29, "deletions": 2}, "files": [{"sha": "bd36ead404206c3b119be1af41549762ed4b21d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c8e04b098394262e6883b8ef5e713d080f92e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c8e04b098394262e6883b8ef5e713d080f92e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95c8e04b098394262e6883b8ef5e713d080f92e5", "patch": "@@ -1,3 +1,9 @@\n+2000-11-17  Jim Wilson  <wilson@redhat.com>\n+\n+\t* config/ia64/ia64.c (emit_insn_group_barriers, case CALL_INSN): \n+\tDon't clear need_barrier is next_insn is a CALL_INSN, or has\n+\tinstruction type B or UNKNOWN.\n+\n 2000-11-17  Neil Booth  <neilb@earthling.net>\n \n         * cpperror.c (print_file_and_line): Don't display line number"}, {"sha": "e523eef160f118323146515a3a430a4402d47978", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c8e04b098394262e6883b8ef5e713d080f92e5/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c8e04b098394262e6883b8ef5e713d080f92e5/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=95c8e04b098394262e6883b8ef5e713d080f92e5", "patch": "@@ -4460,24 +4460,45 @@ emit_insn_group_barriers (insns)\n \t      memcpy (rws_sum, rws_insn, sizeof (rws_sum));\n \t    }\n \n-\t  /* A call must end a group, otherwise the assembler might pack\n+\t  /* A call must end a bundle, otherwise the assembler might pack\n \t     it in with a following branch and then the function return\n \t     goes to the wrong place.  Do this unconditionally for \n \t     unconditional calls, simply because it (1) looks nicer and\n \t     (2) keeps the data structures more accurate for the insns\n \t     following the call.  */\n+\t  /* ??? A call doesn't have to end a bundle if it is followed by\n+\t     a mutex call or branch.  Two mutex calls/branches can be put in\n+\t     the same bundle.  */\n \n \t  need_barrier = 1;\n \t  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n \t    {\n \t      rtx next_insn = insn;\n+\t      enum attr_type type = TYPE_A;\n+\n \t      do\n \t\tnext_insn = next_nonnote_insn (next_insn);\n \t      while (next_insn\n \t\t     && GET_CODE (next_insn) == INSN\n \t\t     && (GET_CODE (PATTERN (next_insn)) == USE\n \t\t\t || GET_CODE (PATTERN (next_insn)) == CLOBBER));\n-\t      if (next_insn && GET_CODE (next_insn) != JUMP_INSN)\n+\n+\t      /* A call ends a bundle if there is a stop bit after it,\n+\t\t or if it is followed by a non-B-type instruction.\n+\t\t In the later case, we can elide the stop bit, and get faster\n+\t\t code when the predicate is false.  */\n+\t      /* ??? The proper solution for this problem is to make gcc\n+\t\t explicitly bundle instructions.  Then we don't need to\n+\t\t emit stop bits to force the assembler to start a new\n+\t\t bundle.  */\n+\n+\t      /* Check the instruction type if it is not a branch or call.  */\n+\t      if (next_insn && GET_CODE (next_insn) == INSN)\n+\t\ttype = get_attr_type (next_insn);\n+\n+\t      if (next_insn && GET_CODE (next_insn) != JUMP_INSN\n+\t\t  && GET_CODE (next_insn) != CALL_INSN\n+\t\t  && type != TYPE_B && type != TYPE_UNKNOWN)\n \t\tneed_barrier = 0;\n \t    }\n \t  if (need_barrier)"}]}