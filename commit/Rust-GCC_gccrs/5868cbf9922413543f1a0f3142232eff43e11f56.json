{"sha": "5868cbf9922413543f1a0f3142232eff43e11f56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg2OGNiZjk5MjI0MTM1NDNmMWEwZjMxNDIyMzJlZmY0M2UxMWY1Ng==", "commit": {"author": {"name": "Bud Davis", "email": "bdavis9659@sbcglobal.net", "date": "2006-11-15T05:10:22Z"}, "committer": {"name": "Bud Davis", "email": "bdavis@gcc.gnu.org", "date": "2006-11-15T05:10:22Z"}, "message": "re PR fortran/28974 (Extremely slow compilation of enumerated DATA statements.)\n\n2006-11-15  Bud Davis <bdavis9659@sbcglobal.net>\n\n        PR fortran/28974\n        * gfortran.h (gfc_expr): Add element which holds a splay-tree\n        for the exclusive purpose of quick access to a constructor by\n        offset.\n        * data.c (find_con_by_offset): Use the splay tree for the search.\n        (gfc_assign_data_value): Use the splay tree.\n        (gfc_assign_data_value_range): ditto.\n        * expr.c (gfc_get_expr): Initialize new element to null.\n        (gfc_free_expr): Delete splay tree when deleting gfc_expr.\n\nFrom-SVN: r118844", "tree": {"sha": "60df5eb822d32866683ff7c963603250f4e57df4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60df5eb822d32866683ff7c963603250f4e57df4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5868cbf9922413543f1a0f3142232eff43e11f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5868cbf9922413543f1a0f3142232eff43e11f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5868cbf9922413543f1a0f3142232eff43e11f56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5868cbf9922413543f1a0f3142232eff43e11f56/comments", "author": null, "committer": null, "parents": [{"sha": "12c789666901a1e60b362e7ddd05429aa44e1554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12c789666901a1e60b362e7ddd05429aa44e1554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12c789666901a1e60b362e7ddd05429aa44e1554"}], "stats": {"total": 164, "additions": 119, "deletions": 45}, "files": [{"sha": "3206979dd591df21c37420dc4fea4694b6715531", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5868cbf9922413543f1a0f3142232eff43e11f56", "patch": "@@ -1,3 +1,15 @@\n+2006-11-15  Bud Davis <bdavis9659@sbcglobal.net>\n+\n+\tPR fortran/28974\n+\t* gfortran.h (gfc_expr): Add element which holds a splay-tree\n+\tfor the exclusive purpose of quick access to a constructor by\n+\toffset.\n+\t* data.c (find_con_by_offset): Use the splay tree for the search.\n+\t(gfc_assign_data_value): Use the splay tree.\n+\t(gfc_assign_data_value_range): ditto.\n+\t* expr.c (gfc_get_expr): Initialize new element to null.\n+\t(gfc_free_expr): Delete splay tree when deleting gfc_expr.\n+\n 2006-11-14  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR fortran/29702"}, {"sha": "5af3bd779cae60126c8a8b88558cdb8a474d3652", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 101, "deletions": 42, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=5868cbf9922413543f1a0f3142232eff43e11f56", "patch": "@@ -80,41 +80,48 @@ get_array_index (gfc_array_ref * ar, mpz_t * offset)\n /* Find if there is a constructor which offset is equal to OFFSET.  */\n \n static gfc_constructor *\n-find_con_by_offset (mpz_t offset, gfc_constructor *con)\n+find_con_by_offset (splay_tree spt, mpz_t offset)\n {\n   mpz_t tmp;\n   gfc_constructor *ret = NULL;\n+  gfc_constructor *con;\n+  splay_tree_node sptn;\n \n-  mpz_init (tmp);\n+/* The complexity is due to needing quick access to the linked list of\n+   constructors.  Both a linked list and a splay tree are used, and both are\n+   kept up to date if they are array elements (which is the only time that\n+   a specific constructor has to be found).  */  \n \n-  for (; con; con = con->next)\n-    {\n-      int cmp = mpz_cmp (offset, con->n.offset);\n-\n-      /* We retain a sorted list, so if we're too large, we're done.  */\n-      if (cmp < 0)\n-\tbreak;\n+  gcc_assert (spt != NULL);\n+  mpz_init (tmp);\n \n-      /* Yaye for exact matches.  */\n-      if (cmp == 0)\n-\t{\n-          ret = con;\n-\t  break;\n-\t}\n+  sptn = splay_tree_lookup (spt, (splay_tree_key) mpz_get_si(offset));\n \n-      /* If the constructor element is a range, match any element.  */\n-      if (mpz_cmp_ui (con->repeat, 1) > 0)\n-\t{\n-\t  mpz_add (tmp, con->n.offset, con->repeat);\n-\t  if (mpz_cmp (offset, tmp) < 0)\n-\t    {\n-\t      ret = con;\n-\t      break;\n-\t    }\n-\t}\n+  if (sptn)\n+    ret = (gfc_constructor*) sptn->value;  \n+  else\n+    {\n+       /* Need to check and see if we match a range, so we will pull\n+          the next lowest index and see if the range matches.  */\n+       sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n+       if (sptn)\n+         {\n+            con = (gfc_constructor*) sptn->value;\n+            if (mpz_cmp_ui (con->repeat, 1) > 0)\n+              {\n+                 mpz_init (tmp);\n+                 mpz_add (tmp, con->n.offset, con->repeat);\n+                 if (mpz_cmp (offset, tmp) < 0)\n+                   ret = con;\n+                 mpz_clear (tmp);\n+              }\n+            else \n+              ret = NULL; /* The range did not match.  */\n+         }\n+      else\n+        ret = NULL; /* No pred, so no match.  */\n     }\n \n-  mpz_clear (tmp);\n   return ret;\n }\n \n@@ -230,9 +237,12 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n   gfc_expr *expr;\n   gfc_constructor *con;\n   gfc_constructor *last_con;\n+  gfc_constructor *pred;\n   gfc_symbol *symbol;\n   gfc_typespec *last_ts;\n   mpz_t offset;\n+  splay_tree spt;\n+  splay_tree_node sptn;\n \n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n@@ -279,16 +289,38 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t  else\n \t    mpz_set (offset, index);\n \n-\t  /* Find the same element in the existing constructor.  */\n-\t  con = expr->value.constructor;\n-\t  con = find_con_by_offset (offset, con);\n+          /* Splay tree containing offset and gfc_constructor.  */\n+          spt = expr->con_by_offset;\n+\n+          if (spt == NULL)\n+            {\n+               spt = splay_tree_new (splay_tree_compare_ints,NULL,NULL);\n+               expr->con_by_offset = spt; \n+               con = NULL;\n+            }\n+         else\n+\t  con = find_con_by_offset (spt, offset);\n \n \t  if (con == NULL)\n \t    {\n \t      /* Create a new constructor.  */\n \t      con = gfc_get_constructor ();\n \t      mpz_set (con->n.offset, offset);\n-\t      gfc_insert_constructor (expr, con);\n+              sptn = splay_tree_insert (spt, (splay_tree_key) mpz_get_si(offset),\n+                                       (splay_tree_value) con);\n+              /* Fix up the linked list.  */\n+              sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n+              if (sptn == NULL)\n+                {  /* Insert at the head.  */\n+                   con->next = expr->value.constructor;\n+                   expr->value.constructor = con;\n+                }\n+              else\n+                {  /* Insert in the chain.  */\n+                   pred = (gfc_constructor*) sptn->value;\n+                   con->next = pred->next;\n+                   pred->next = con;\n+                }\n \t    }\n \t  break;\n \n@@ -379,9 +411,12 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n   gfc_ref *ref;\n   gfc_expr *init, *expr;\n   gfc_constructor *con, *last_con;\n+  gfc_constructor *pred;\n   gfc_symbol *symbol;\n   gfc_typespec *last_ts;\n   mpz_t offset;\n+  splay_tree spt;\n+  splay_tree_node sptn;\n \n   symbol = lvalue->symtree->n.sym;\n   init = symbol->value;\n@@ -435,19 +470,43 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \t    }\n \n \t  /* Find the same element in the existing constructor.  */\n-\t  con = expr->value.constructor;\n-\t  con = find_con_by_offset (offset, con);\n \n-\t  /* Create a new constructor.  */\n-\t  if (con == NULL)\n-\t    {\n-\t      con = gfc_get_constructor ();\n-\t      mpz_set (con->n.offset, offset);\n-\t      if (ref->next == NULL)\n-\t\tmpz_set (con->repeat, repeat);\n-\t      gfc_insert_constructor (expr, con);\n-\t    }\n-\t  else\n+          /* Splay tree containing offset and gfc_constructor.  */\n+          spt = expr->con_by_offset;\n+\n+          if (spt == NULL)\n+            {\n+               spt = splay_tree_new (splay_tree_compare_ints,NULL,NULL);\n+               expr->con_by_offset = spt;\n+               con = NULL;\n+            }\n+          else \n+            con = find_con_by_offset (spt, offset);\n+\n+          if (con == NULL)\n+            {\n+              /* Create a new constructor.  */\n+              con = gfc_get_constructor ();\n+              mpz_set (con->n.offset, offset);\n+              if (ref->next == NULL)\n+                mpz_set (con->repeat, repeat);\n+              sptn = splay_tree_insert (spt, (splay_tree_key) mpz_get_si(offset),\n+                                       (splay_tree_value) con);\n+              /* Fix up the linked list.  */\n+              sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n+              if (sptn == NULL)\n+                {  /* Insert at the head.  */\n+                   con->next = expr->value.constructor;\n+                   expr->value.constructor = con;\n+                }\n+              else\n+                {  /* Insert in the chain.  */\n+                   pred = (gfc_constructor*) sptn->value;\n+                   con->next = pred->next;\n+                   pred->next = con;\n+                }\n+            }\n+          else\n \t    gcc_assert (ref->next != NULL);\n \t  break;\n "}, {"sha": "96f39c87c8d595a0bd54a18813df55836464601a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=5868cbf9922413543f1a0f3142232eff43e11f56", "patch": "@@ -39,7 +39,7 @@ gfc_get_expr (void)\n   e->shape = NULL;\n   e->ref = NULL;\n   e->symtree = NULL;\n-\n+  e->con_by_offset = NULL;\n   return e;\n }\n \n@@ -226,7 +226,8 @@ gfc_free_expr (gfc_expr * e)\n \n   if (e == NULL)\n     return;\n-\n+  if (e->con_by_offset)\n+    splay_tree_delete (e->con_by_offset); \n   free_expr0 (e);\n   gfc_free (e);\n }"}, {"sha": "dbba22e240764e652f715bd90425db92d6315824", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5868cbf9922413543f1a0f3142232eff43e11f56/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5868cbf9922413543f1a0f3142232eff43e11f56", "patch": "@@ -33,7 +33,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"intl.h\"\n #include \"coretypes.h\"\n #include \"input.h\"\n-\n+#include \"splay-tree.h\"\n /* The following ifdefs are recommended by the autoconf documentation\n    for any code using alloca.  */\n \n@@ -1245,6 +1245,8 @@ typedef struct gfc_expr\n   /* True if the expression is a call to a function that returns an array,\n      and if we have decided not to allocate temporary data for that array.  */\n   unsigned int inline_noncopying_intrinsic : 1;\n+  /* Used to quickly find a given constructor by it's offset.  */\n+  splay_tree con_by_offset;\n \n   union\n   {"}]}