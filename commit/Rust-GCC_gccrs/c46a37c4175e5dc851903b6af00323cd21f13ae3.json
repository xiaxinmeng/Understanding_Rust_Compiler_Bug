{"sha": "c46a37c4175e5dc851903b6af00323cd21f13ae3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ2YTM3YzQxNzVlNWRjODUxOTAzYjZhZjAwMzIzY2QyMWYxM2FlMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-10T23:45:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-10T23:45:27Z"}, "message": "haifa-sched.c (sched_reg_n_calls_crossed): Delete.\n\n        * haifa-sched.c (sched_reg_n_calls_crossed): Delete.\n        (sched_reg_live_length, sched_reg_basic_block): Delete.\n        (current_block_num, bb_live_regs, old_live_regs): Delete.\n        (dead_notes, struct sometimes): Delete.\n        (sched_note_set, birthing_insn_p): Delete.\n        (adjust_priority): Gut useless reg lifetime code.\n        (create_reg_dead_note, attach_deaths): Delete.\n        (attach_deaths_insn, new_sometimes_live): Delete.\n        (finish_sometimes_live): Delete.\n        (find_pre_sched_live, find_post_sched_live): Delete.\n        (update_reg_usage): Delete.\n        (find_insn_reg_weight): New, from corpse of find_pre_sched_live.\n        (schedule_insns): Delete reg lifetime code.\n        (sched_analyze): Use REG_SAVE_NOTE to stuff NOTE_INSN notes away.\n        (unlink_other_notes): Adjust REG_NOTE commentary.\n        (reemit_notes): Use REG_SAVE_NOTE.\n        (schedule_block): Likewise.\n        (schedule_region): Allocate bitmap of blocks in region.  Use\n        count_or_remove_death_notes.  Use update_life_info.\n\n        * rtl.h (REG_SAVE_NOTE): New.\n        * rtl.c (reg_note_name): Update.\n\nFrom-SVN: r29894", "tree": {"sha": "2288001767de55cd13118a18d6c1d5ef87b07b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2288001767de55cd13118a18d6c1d5ef87b07b50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c46a37c4175e5dc851903b6af00323cd21f13ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46a37c4175e5dc851903b6af00323cd21f13ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c46a37c4175e5dc851903b6af00323cd21f13ae3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c46a37c4175e5dc851903b6af00323cd21f13ae3/comments", "author": null, "committer": null, "parents": [{"sha": "715e7fbc831af02e80acc60be2fa19208ab62dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715e7fbc831af02e80acc60be2fa19208ab62dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/715e7fbc831af02e80acc60be2fa19208ab62dfc"}], "stats": {"total": 1172, "additions": 107, "deletions": 1065}, "files": [{"sha": "0b52bb628f6f37cb02c91dea17820b1c06022efa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c46a37c4175e5dc851903b6af00323cd21f13ae3", "patch": "@@ -1,3 +1,28 @@\n+Sun Oct 10 16:37:01 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (sched_reg_n_calls_crossed): Delete.\n+\t(sched_reg_live_length, sched_reg_basic_block): Delete.\n+\t(current_block_num, bb_live_regs, old_live_regs): Delete.\n+\t(dead_notes, struct sometimes): Delete.\n+\t(sched_note_set, birthing_insn_p): Delete.\n+\t(adjust_priority): Gut useless reg lifetime code.\n+\t(create_reg_dead_note, attach_deaths): Delete.\n+\t(attach_deaths_insn, new_sometimes_live): Delete.\n+\t(finish_sometimes_live): Delete.\n+\t(find_pre_sched_live, find_post_sched_live): Delete.\n+\t(update_reg_usage): Delete.\n+\t(find_insn_reg_weight): New, from corpse of find_pre_sched_live.\n+\t(schedule_insns): Delete reg lifetime code.\n+\t(sched_analyze): Use REG_SAVE_NOTE to stuff NOTE_INSN notes away.\n+\t(unlink_other_notes): Adjust REG_NOTE commentary.\n+\t(reemit_notes): Use REG_SAVE_NOTE.\n+\t(schedule_block): Likewise.\n+\t(schedule_region): Allocate bitmap of blocks in region.  Use\n+\tcount_or_remove_death_notes.  Use update_life_info.\n+\n+\t* rtl.h (REG_SAVE_NOTE): New.\n+\t* rtl.c (reg_note_name): Update.\n+\t\n Sun Oct 10 16:14:16 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* combine.c (refresh_blocks, need_refresh): New."}, {"sha": "3d1bd297255e40cbb912f57650ce269e93ee90c8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 75, "deletions": 1059, "changes": 1134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c46a37c4175e5dc851903b6af00323cd21f13ae3", "patch": "@@ -232,22 +232,6 @@ fix_sched_param (param, val)\n }\n \n \n-/* Arrays set up by scheduling for the same respective purposes as\n-   similar-named arrays set up by flow analysis.  We work with these\n-   arrays during the scheduling pass so we can compare values against\n-   unscheduled code.\n-\n-   Values of these arrays are copied at the end of this pass into the\n-   arrays set up by flow analysis.  */\n-static int *sched_reg_n_calls_crossed;\n-static int *sched_reg_live_length;\n-static int *sched_reg_basic_block;\n-\n-/* We need to know the current block number during the post scheduling\n-   update of live register information so that we can also update\n-   REG_BASIC_BLOCK if a register changes blocks.  */\n-static int current_block_num;\n-\n /* Element N is the next insn that sets (hard or pseudo) register\n    N within the current basic block; or zero, if there is no\n    such insn.  Needed for new registers which may be introduced\n@@ -338,23 +322,6 @@ static rtx *line_note_head;\n    last element in the list.  */\n static rtx note_list;\n \n-/* Regsets telling whether a given register is live or dead before the last\n-   scheduled insn.  Must scan the instructions once before scheduling to\n-   determine what registers are live or dead at the end of the block.  */\n-static regset bb_live_regs;\n-\n-/* Regset telling whether a given register is live after the insn currently\n-   being scheduled.  Before processing an insn, this is equal to bb_live_regs\n-   above.  This is used so that we can find registers that are newly born/dead\n-   after processing an insn.  */\n-static regset old_live_regs;\n-\n-/* The chain of REG_DEAD notes.  REG_DEAD notes are removed from all insns\n-   during the initial scan and reused later.  If there are not exactly as\n-   many REG_DEAD notes in the post scheduled code as there were in the\n-   prescheduled code then we trigger an abort because this indicates a bug.  */\n-static rtx dead_notes;\n-\n /* Queues, etc.  */\n \n /* An instruction is ready to be scheduled when all insns preceding it\n@@ -414,16 +381,6 @@ static int q_size = 0;\n static int *insn_tick;\n #define INSN_TICK(INSN) (insn_tick[INSN_UID (INSN)])\n \n-/* Data structure for keeping track of register information\n-   during that register's life.  */\n-\n-struct sometimes\n-  {\n-    int regno;\n-    int live_length;\n-    int calls_crossed;\n-  };\n-\n /* Forward declarations.  */\n static void add_dependence PROTO ((rtx, rtx, enum reg_note));\n static void remove_dependence PROTO ((rtx, rtx));\n@@ -444,20 +401,14 @@ static void sched_analyze_1 PROTO ((rtx, rtx));\n static void sched_analyze_2 PROTO ((rtx, rtx));\n static void sched_analyze_insn PROTO ((rtx, rtx, rtx));\n static void sched_analyze PROTO ((rtx, rtx));\n-static void sched_note_set PROTO ((rtx, int));\n static int rank_for_schedule PROTO ((const PTR, const PTR));\n static void swap_sort PROTO ((rtx *, int));\n static void queue_insn PROTO ((rtx, int));\n static int schedule_insn PROTO ((rtx, rtx *, int, int));\n-static void create_reg_dead_note PROTO ((rtx, rtx));\n-static void attach_deaths PROTO ((rtx, rtx, int));\n-static void attach_deaths_insn PROTO ((rtx));\n-static int new_sometimes_live PROTO ((struct sometimes *, int, int));\n-static void finish_sometimes_live PROTO ((struct sometimes *, int));\n+static void find_insn_reg_weight PROTO ((int));\n static int schedule_block PROTO ((int, int));\n static char *safe_concat PROTO ((char *, char *, const char *));\n static int insn_issue_delay PROTO ((rtx));\n-static int birthing_insn_p PROTO ((rtx));\n static void adjust_priority PROTO ((rtx));\n \n /* Mapping of insns to their original block prior to scheduling.  */\n@@ -736,9 +687,6 @@ static rtx reemit_notes PROTO ((rtx, rtx));\n \n static void get_block_head_tail PROTO ((int, rtx *, rtx *));\n \n-static void find_pre_sched_live PROTO ((int));\n-static void find_post_sched_live PROTO ((int));\n-static void update_reg_usage PROTO ((void));\n static int queue_to_ready PROTO ((rtx [], int));\n \n static void debug_ready_list PROTO ((rtx[], int));\n@@ -3867,13 +3815,13 @@ sched_analyze (head, tail)\n \t\t}\n \t      reg_pending_sets_all = 1;\n \n-\t      /* Add a pair of fake REG_NOTEs which we will later\n+\t      /* Add a pair of REG_SAVE_NOTEs which we will later\n \t\t convert back into a NOTE_INSN_SETJMP note.  See\n \t\t reemit_notes for why we use a pair of NOTEs.  */\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_DEAD,\n+\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\t\t  GEN_INT (0),\n \t\t\t\t\t\t  REG_NOTES (insn));\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_DEAD,\n+\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t    }\n@@ -3926,9 +3874,9 @@ sched_analyze (head, tail)\n \t       && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_START\n \t\t   || NOTE_LINE_NUMBER (insn) == NOTE_INSN_RANGE_END))\n \t{\n-\t  loop_notes = alloc_EXPR_LIST (REG_DEAD, NOTE_RANGE_INFO (insn),\n+\t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE, NOTE_RANGE_INFO (insn),\n \t\t\t\t\tloop_notes);\n-\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n \t\t\t\t\tloop_notes);\n \t}\n@@ -3948,10 +3896,10 @@ sched_analyze (head, tail)\n \t  else\n \t    rtx_region = GEN_INT (0);\n \n-\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\trtx_region,\n \t\t\t\t\tloop_notes);\n-\t  loop_notes = alloc_EXPR_LIST (REG_DEAD,\n+\t  loop_notes = alloc_EXPR_LIST (REG_SAVE_NOTE,\n \t\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)),\n \t\t\t\t\tloop_notes);\n \t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n@@ -3963,102 +3911,6 @@ sched_analyze (head, tail)\n   abort ();\n }\n \f\n-/* Called when we see a set of a register.  If death is true, then we are\n-   scanning backwards.  Mark that register as unborn.  If nobody says\n-   otherwise, that is how things will remain.  If death is false, then we\n-   are scanning forwards.  Mark that register as being born.  */\n-\n-static void\n-sched_note_set (x, death)\n-     rtx x;\n-     int death;\n-{\n-  register int regno;\n-  register rtx reg = SET_DEST (x);\n-  int subreg_p = 0;\n-\n-  if (reg == 0)\n-    return;\n-\n-  if (GET_CODE (reg) == PARALLEL\n-      && GET_MODE (reg) == BLKmode)\n-    {\n-      register int i;\n-      for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tsched_note_set (XVECEXP (reg, 0, i), death);\n-      return;\n-    }\n-\n-  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == STRICT_LOW_PART\n-\t || GET_CODE (reg) == SIGN_EXTRACT || GET_CODE (reg) == ZERO_EXTRACT)\n-    {\n-      /* Must treat modification of just one hardware register of a multi-reg\n-         value or just a byte field of a register exactly the same way that\n-         mark_set_1 in flow.c does, i.e. anything except a paradoxical subreg\n-         does not kill the entire register.  */\n-      if (GET_CODE (reg) != SUBREG\n-\t  || REG_SIZE (SUBREG_REG (reg)) > REG_SIZE (reg))\n-\tsubreg_p = 1;\n-\n-      reg = SUBREG_REG (reg);\n-    }\n-\n-  if (GET_CODE (reg) != REG)\n-    return;\n-\n-  /* Global registers are always live, so the code below does not apply\n-     to them.  */\n-\n-  regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER || !global_regs[regno])\n-    {\n-      if (death)\n-\t{\n-\t  /* If we only set part of the register, then this set does not\n-\t     kill it.  */\n-\t  if (subreg_p)\n-\t    return;\n-\n-\t  /* Try killing this register.  */\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t      while (--j >= 0)\n-\t\t{\n-\t\t  CLEAR_REGNO_REG_SET (bb_live_regs, regno + j);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Recompute REG_BASIC_BLOCK as we update all the other\n-\t\t dataflow information.  */\n-\t      if (sched_reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n-\t\tsched_reg_basic_block[regno] = current_block_num;\n-\t      else if (sched_reg_basic_block[regno] != current_block_num)\n-\t\tsched_reg_basic_block[regno] = REG_BLOCK_GLOBAL;\n-\n-\t      CLEAR_REGNO_REG_SET (bb_live_regs, regno);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Make the register live again.  */\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      int j = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t      while (--j >= 0)\n-\t\t{\n-\t\t  SET_REGNO_REG_SET (bb_live_regs, regno + j);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      SET_REGNO_REG_SET (bb_live_regs, regno);\n-\t    }\n-\t}\n-    }\n-}\n-\f\n /* Macros and functions for keeping the priority queue sorted, and\n    dealing with queueing and dequeueing of instructions.  */\n \n@@ -4209,104 +4061,21 @@ queue_insn (insn, n_cycles)\n \n }\n \n-/* Return nonzero if PAT is the pattern of an insn which makes a\n-   register live.  */\n-\n-HAIFA_INLINE static int\n-birthing_insn_p (pat)\n-     rtx pat;\n-{\n-  int j;\n-\n-  if (reload_completed == 1)\n-    return 0;\n-\n-  if (GET_CODE (pat) == SET\n-      && (GET_CODE (SET_DEST (pat)) == REG\n-\t  || (GET_CODE (SET_DEST (pat)) == PARALLEL\n-\t      && GET_MODE (SET_DEST (pat)) == BLKmode)))\n-    {\n-      rtx dest = SET_DEST (pat);\n-      int i;\n-\n-      /* It would be more accurate to use refers_to_regno_p or\n-\t reg_mentioned_p to determine when the dest is not live before this\n-\t insn.  */\n-      if (GET_CODE (dest) == REG)\n-\t{\n-\t  i = REGNO (dest);\n-\t  if (REGNO_REG_SET_P (bb_live_regs, i))\n-\t    return (REG_N_SETS (i) == 1);\n-\t}\n-      else\n-\t{\n-\t  for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n-\t    {\n-\t      int regno = REGNO (SET_DEST (XVECEXP (dest, 0, i)));\n-\t      if (REGNO_REG_SET_P (bb_live_regs, regno))\n-\t\treturn (REG_N_SETS (regno) == 1);\n-\t    }\n-\t}\n-      return 0;\n-    }\n-  if (GET_CODE (pat) == PARALLEL)\n-    {\n-      for (j = 0; j < XVECLEN (pat, 0); j++)\n-\tif (birthing_insn_p (XVECEXP (pat, 0, j)))\n-\t  return 1;\n-    }\n-  return 0;\n-}\n-\n /* PREV is an insn that is ready to execute.  Adjust its priority if that\n-   will help shorten register lifetimes.  */\n+   will help shorten or lengthen register lifetimes as appropriate.  Also\n+   provide a hook for the target to tweek itself.  */\n \n HAIFA_INLINE static void\n adjust_priority (prev)\n-     rtx prev;\n+     rtx prev ATTRIBUTE_UNUSED;\n {\n-  /* Trying to shorten register lives after reload has completed\n-     is useless and wrong.  It gives inaccurate schedules.  */\n-  if (reload_completed == 0)\n-    {\n-      rtx note;\n-      int n_deaths = 0;\n-\n-      /* ??? This code has no effect, because REG_DEAD notes are removed\n-\t before we ever get here.  */\n-      for (note = REG_NOTES (prev); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD)\n-\t  n_deaths += 1;\n-\n-      /* Defer scheduling insns which kill registers, since that\n-\t shortens register lives.  Prefer scheduling insns which\n-\t make registers live for the same reason.  */\n-      switch (n_deaths)\n-\t{\n-\tdefault:\n-\t  INSN_PRIORITY (prev) >>= 3;\n-\t  break;\n-\tcase 3:\n-\t  INSN_PRIORITY (prev) >>= 2;\n-\t  break;\n-\tcase 2:\n-\tcase 1:\n-\t  INSN_PRIORITY (prev) >>= 1;\n-\t  break;\n-\tcase 0:\n-\t  if (birthing_insn_p (PATTERN (prev)))\n-\t    {\n-\t      int max = max_priority;\n+  /* ??? There used to be code here to try and estimate how an insn\n+     affected register lifetimes, but it did it by looking at REG_DEAD\n+     notes, which we removed in schedule_region.  Nor did it try to \n+     take into account register pressure or anything useful like that.\n \n-\t      if (max > INSN_PRIORITY (prev))\n-\t\tINSN_PRIORITY (prev) = max;\n-\t    }\n-\t  break;\n-\t}\n-    }\n+     Revisit when we have a machine model to work with and not before.  */\n \n-  /* That said, a target might have it's own reasons for adjusting\n-     priority after reload.  */\n #ifdef ADJUST_PRIORITY\n   ADJUST_PRIORITY (prev);\n #endif\n@@ -4415,334 +4184,6 @@ schedule_insn (insn, ready, n_ready, clock)\n   return n_ready;\n }\n \n-\n-/* Add a REG_DEAD note for REG to INSN, reusing a REG_DEAD note from the\n-   dead_notes list.  */\n-\n-static void\n-create_reg_dead_note (reg, insn)\n-     rtx reg, insn;\n-{\n-  rtx link;\n-\n-  /* The number of registers killed after scheduling must be the same as the\n-     number of registers killed before scheduling.  The number of REG_DEAD\n-     notes may not be conserved, i.e. two SImode hard register REG_DEAD notes\n-     might become one DImode hard register REG_DEAD note, but the number of\n-     registers killed will be conserved.\n-\n-     We carefully remove REG_DEAD notes from the dead_notes list, so that\n-     there will be none left at the end.  If we run out early, then there\n-     is a bug somewhere in flow, combine and/or sched.  */\n-\n-  if (dead_notes == 0)\n-    {\n-      if (current_nr_blocks <= 1)\n-\tabort ();\n-      else\n-\tlink = alloc_EXPR_LIST (REG_DEAD, NULL_RTX, NULL_RTX);\n-    }\n-  else\n-    {\n-      /* Number of regs killed by REG.  */\n-      int regs_killed = (REGNO (reg) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t : HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)));\n-      /* Number of regs killed by REG_DEAD notes taken off the list.  */\n-      int reg_note_regs;\n-\n-      link = dead_notes;\n-      reg_note_regs = (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t       : HARD_REGNO_NREGS (REGNO (XEXP (link, 0)),\n-\t\t\t\t\t   GET_MODE (XEXP (link, 0))));\n-      while (reg_note_regs < regs_killed)\n-\t{\n-\t  link = XEXP (link, 1);\n-\n-\t  /* LINK might be zero if we killed more registers after scheduling\n-\t     than before, and the last hard register we kill is actually\n-\t     multiple hard regs. \n-\n-\t     This is normal for interblock scheduling, so deal with it in\n-\t     that case, else abort.  */\n-\t  if (link == NULL_RTX && current_nr_blocks <= 1)\n-\t    abort ();\n-\t  else if (link == NULL_RTX)\n-\t    link = alloc_EXPR_LIST (REG_DEAD, gen_rtx_REG (word_mode, 0),\n-\t\t\t\t    NULL_RTX);\n-\t     \n-\t  reg_note_regs += (REGNO (XEXP (link, 0)) >= FIRST_PSEUDO_REGISTER ? 1\n-\t\t\t    : HARD_REGNO_NREGS (REGNO (XEXP (link, 0)),\n-\t\t\t\t\t\tGET_MODE (XEXP (link, 0))));\n-\t}\n-      dead_notes = XEXP (link, 1);\n-\n-      /* If we took too many regs kills off, put the extra ones back.  */\n-      while (reg_note_regs > regs_killed)\n-\t{\n-\t  rtx temp_reg, temp_link;\n-\n-\t  temp_reg = gen_rtx_REG (word_mode, 0);\n-\t  temp_link = alloc_EXPR_LIST (REG_DEAD, temp_reg, dead_notes);\n-\t  dead_notes = temp_link;\n-\t  reg_note_regs--;\n-\t}\n-    }\n-\n-  XEXP (link, 0) = reg;\n-  XEXP (link, 1) = REG_NOTES (insn);\n-  REG_NOTES (insn) = link;\n-}\n-\n-/* Subroutine on attach_deaths_insn--handles the recursive search\n-   through INSN.  If SET_P is true, then x is being modified by the insn.  */\n-\n-static void\n-attach_deaths (x, insn, set_p)\n-     rtx x;\n-     rtx insn;\n-     int set_p;\n-{\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n-\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-      /* Get rid of the easy cases first.  */\n-      return;\n-\n-    case REG:\n-      {\n-\t/* If the register dies in this insn, queue that note, and mark\n-\t   this register as needing to die.  */\n-\t/* This code is very similar to mark_used_1 (if set_p is false)\n-\t   and mark_set_1 (if set_p is true) in flow.c.  */\n-\n-\tregister int regno;\n-\tint some_needed;\n-\tint all_needed;\n-\n-\tif (set_p)\n-\t  return;\n-\n-\tregno = REGNO (x);\n-\tall_needed = some_needed = REGNO_REG_SET_P (old_live_regs, regno);\n-\tif (regno < FIRST_PSEUDO_REGISTER)\n-\t  {\n-\t    int n;\n-\n-\t    n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t    while (--n > 0)\n-\t      {\n-\t\tint needed = (REGNO_REG_SET_P (old_live_regs, regno + n));\n-\t\tsome_needed |= needed;\n-\t\tall_needed &= needed;\n-\t      }\n-\t  }\n-\n-\t/* If it wasn't live before we started, then add a REG_DEAD note.\n-\t   We must check the previous lifetime info not the current info,\n-\t   because we may have to execute this code several times, e.g.\n-\t   once for a clobber (which doesn't add a note) and later\n-\t   for a use (which does add a note).\n-\n-\t   Always make the register live.  We must do this even if it was\n-\t   live before, because this may be an insn which sets and uses\n-\t   the same register, in which case the register has already been\n-\t   killed, so we must make it live again.\n-\n-\t   Global registers are always live, and should never have a REG_DEAD\n-\t   note added for them, so none of the code below applies to them.  */\n-\n-\tif (regno >= FIRST_PSEUDO_REGISTER || ! global_regs[regno])\n-\t  {\n-\t    /* Never add REG_DEAD notes for STACK_POINTER_REGNUM\n-\t       since it's always considered to be live.  Similarly\n-\t       for FRAME_POINTER_REGNUM if a frame pointer is needed\n-\t       and for ARG_POINTER_REGNUM if it is fixed.  */\n-\t    if (! (regno == FRAME_POINTER_REGNUM\n-\t\t   && (! reload_completed || frame_pointer_needed))\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t&& ! (regno == HARD_FRAME_POINTER_REGNUM\n-\t\t      && (! reload_completed || frame_pointer_needed))\n-#endif\n-#if ARG_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t\t&& ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-\t\t&& regno != STACK_POINTER_REGNUM)\n-\t      {\n-\t\tif (! all_needed && ! dead_or_set_p (insn, x))\n-\t\t  {\n-\t\t    /* Check for the case where the register dying partially\n-\t\t       overlaps the register set by this insn.  */\n-\t\t    if (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t&& HARD_REGNO_NREGS (regno, GET_MODE (x)) > 1)\n-\t\t      {\n-\t\t\tint n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t\t\twhile (--n >= 0)\n-\t\t\t  some_needed |= dead_or_set_regno_p (insn, regno + n);\n-\t\t      }\n-\n-\t\t    /* If none of the words in X is needed, make a REG_DEAD\n-\t\t       note.  Otherwise, we must make partial REG_DEAD\n-\t\t       notes.  */\n-\t\t    if (! some_needed)\n-\t\t      create_reg_dead_note (x, insn);\n-\t\t    else\n-\t\t      {\n-\t\t\tint i;\n-\n-\t\t\t/* Don't make a REG_DEAD note for a part of a\n-\t\t\t   register that is set in the insn.  */\n-\t\t\tfor (i = HARD_REGNO_NREGS (regno, GET_MODE (x)) - 1;\n-\t\t\t     i >= 0; i--)\n-\t\t\t  if (! REGNO_REG_SET_P (old_live_regs, regno+i)\n-\t\t\t      && ! dead_or_set_regno_p (insn, regno + i))\n-\t\t\t    create_reg_dead_note (gen_rtx_REG (reg_raw_mode[regno + i],\n-\t\t\t\t\t\t\t       regno + i),\n-\t\t\t\t\t\t  insn);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n-\t    if (regno < FIRST_PSEUDO_REGISTER)\n-\t      {\n-\t\tint j = HARD_REGNO_NREGS (regno, GET_MODE (x));\n-\t\twhile (--j >= 0)\n-\t\t  {\n-\t\t    SET_REGNO_REG_SET (bb_live_regs, regno + j);\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Recompute REG_BASIC_BLOCK as we update all the other\n-\t\t   dataflow information.  */\n-\t\tif (sched_reg_basic_block[regno] == REG_BLOCK_UNKNOWN)\n-\t\t  sched_reg_basic_block[regno] = current_block_num;\n-\t\telse if (sched_reg_basic_block[regno] != current_block_num)\n-\t\t  sched_reg_basic_block[regno] = REG_BLOCK_GLOBAL;\n-\n-\t\tSET_REGNO_REG_SET (bb_live_regs, regno);\n-\t      }\n-\t  }\n-\treturn;\n-      }\n-\n-    case MEM:\n-      /* Handle tail-recursive case.  */\n-      attach_deaths (XEXP (x, 0), insn, 0);\n-      return;\n-\n-    case SUBREG:\n-      attach_deaths (SUBREG_REG (x), insn,\n-\t\t     set_p && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t\t\t\t<= UNITS_PER_WORD)\n-\t\t\t       || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n-\t\t\t\t   == GET_MODE_SIZE (GET_MODE ((x))))));\n-      return;\n-\n-    case STRICT_LOW_PART:\n-      attach_deaths (XEXP (x, 0), insn, 0);\n-      return;\n-\n-    case ZERO_EXTRACT:\n-    case SIGN_EXTRACT:\n-      attach_deaths (XEXP (x, 0), insn, 0);\n-      attach_deaths (XEXP (x, 1), insn, 0);\n-      attach_deaths (XEXP (x, 2), insn, 0);\n-      return;\n-\n-    case PARALLEL:\n-      if (set_p\n-\t  && GET_MODE (x) == BLKmode)\n-\t{\n-\t  for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t    attach_deaths (SET_DEST (XVECEXP (x, 0, i)), insn, 1);\n-\t  return;\n-\t}\n-\n-      /* Fallthrough.  */\n-    default:\n-      /* Other cases: walk the insn.  */\n-      fmt = GET_RTX_FORMAT (code);\n-      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t{\n-\t  if (fmt[i] == 'e')\n-\t    attach_deaths (XEXP (x, i), insn, 0);\n-\t  else if (fmt[i] == 'E')\n-\t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      attach_deaths (XVECEXP (x, i, j), insn, 0);\n-\t}\n-    }\n-}\n-\n-/* After INSN has executed, add register death notes for each register\n-   that is dead after INSN.  */\n-\n-static void\n-attach_deaths_insn (insn)\n-     rtx insn;\n-{\n-  rtx x = PATTERN (insn);\n-  register RTX_CODE code = GET_CODE (x);\n-  rtx link;\n-\n-  if (code == SET)\n-    {\n-      attach_deaths (SET_SRC (x), insn, 0);\n-\n-      /* A register might die here even if it is the destination, e.g.\n-         it is the target of a volatile read and is otherwise unused.\n-         Hence we must always call attach_deaths for the SET_DEST.  */\n-      attach_deaths (SET_DEST (x), insn, 1);\n-    }\n-  else if (code == PARALLEL)\n-    {\n-      register int i;\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\t{\n-\t  code = GET_CODE (XVECEXP (x, 0, i));\n-\t  if (code == SET)\n-\t    {\n-\t      attach_deaths (SET_SRC (XVECEXP (x, 0, i)), insn, 0);\n-\n-\t      attach_deaths (SET_DEST (XVECEXP (x, 0, i)), insn, 1);\n-\t    }\n-\t  /* Flow does not add REG_DEAD notes to registers that die in\n-\t     clobbers, so we can't either.  */\n-\t  else if (code != CLOBBER)\n-\t    attach_deaths (XVECEXP (x, 0, i), insn, 0);\n-\t}\n-    }\n-  /* If this is a CLOBBER, only add REG_DEAD notes to registers inside a\n-     MEM being clobbered, just like flow.  */\n-  else if (code == CLOBBER && GET_CODE (XEXP (x, 0)) == MEM)\n-    attach_deaths (XEXP (XEXP (x, 0), 0), insn, 0);\n-  /* Otherwise don't add a death note to things being clobbered.  */\n-  else if (code != CLOBBER)\n-    attach_deaths (x, insn, 0);\n-\n-  /* Make death notes for things used in the called function.  */\n-  if (GET_CODE (insn) == CALL_INSN)\n-    for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-      attach_deaths (XEXP (XEXP (link, 0), 0), insn,\n-\t\t     GET_CODE (XEXP (link, 0)) == CLOBBER);\n-}\n-\n /* Functions for handling of notes.  */\n \n /* Delete notes beginning with INSN and put them in the chain\n@@ -4764,10 +4205,7 @@ unlink_other_notes (insn, tail)\n       if (next)\n \tPREV_INSN (next) = prev;\n \n-      /* Don't save away NOTE_INSN_SETJMPs, because they must remain\n-         immediately after the call they follow.  We use a fake\n-         (REG_DEAD (const_int -1)) note to remember them.\n-         Likewise with NOTE_INSN_{LOOP,EHREGION}_{BEG, END}.  */\n+      /* See sched_analyze to see how these are handled.  */\n       if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n@@ -5081,459 +4519,55 @@ rm_other_notes (head, tail)\n     }\n }\n \n-/* Constructor for `sometimes' data structure.  */\n-\n-static int\n-new_sometimes_live (regs_sometimes_live, regno, sometimes_max)\n-     struct sometimes *regs_sometimes_live;\n-     int regno;\n-     int sometimes_max;\n-{\n-  register struct sometimes *p;\n-\n-  /* There should never be a register greater than max_regno here.  If there\n-     is, it means that a define_split has created a new pseudo reg.  This\n-     is not allowed, since there will not be flow info available for any\n-     new register, so catch the error here.  */\n-  if (regno >= max_regno)\n-    abort ();\n-\n-  p = &regs_sometimes_live[sometimes_max];\n-  p->regno = regno;\n-  p->live_length = 0;\n-  p->calls_crossed = 0;\n-  sometimes_max++;\n-  return sometimes_max;\n-}\n-\n-/* Count lengths of all regs we are currently tracking,\n-   and find new registers no longer live.  */\n-\n-static void\n-finish_sometimes_live (regs_sometimes_live, sometimes_max)\n-     struct sometimes *regs_sometimes_live;\n-     int sometimes_max;\n-{\n-  int i;\n-\n-  for (i = 0; i < sometimes_max; i++)\n-    {\n-      register struct sometimes *p = &regs_sometimes_live[i];\n-      int regno = p->regno;\n-\n-      sched_reg_live_length[regno] += p->live_length;\n-      sched_reg_n_calls_crossed[regno] += p->calls_crossed;\n-    }\n-}\n-\n /* Functions for computation of registers live/usage info.  */\n \n-/* It is assumed that prior to scheduling BASIC_BLOCK (b)->global_live_at_start\n-   contains the registers that are alive at the entry to b.\n-\n-   Two passes follow: The first pass is performed before the scheduling\n-   of a region. It scans each block of the region forward, computing\n-   the set of registers alive at the end of the basic block and\n-   discard REG_DEAD notes (done by find_pre_sched_live ()).\n-\n-   The second path is invoked after scheduling all region blocks.\n-   It scans each block of the region backward, a block being traversed\n-   only after its succesors in the region. When the set of registers\n-   live at the end of a basic block may be changed by the scheduling\n-   (this may happen for multiple blocks region), it is computed as\n-   the union of the registers live at the start of its succesors.\n-   The last-use information is updated by inserting REG_DEAD notes.\n-   (done by find_post_sched_live ()) */\n-\n-/* Scan all the insns to be scheduled, removing register death notes.\n-   Register death notes end up in DEAD_NOTES.\n-   Recreate the register life information for the end of this basic\n-   block.  */\n+/* Calculate INSN_REG_WEIGHT for all insns of a block.  */\n \n static void\n-find_pre_sched_live (bb)\n-     int bb;\n+find_insn_reg_weight (bb)\n+    int bb;\n {\n   rtx insn, next_tail, head, tail;\n-  int b = BB_TO_BLOCK (bb);\n \n   get_block_head_tail (bb, &head, &tail);\n-  COPY_REG_SET (bb_live_regs, BASIC_BLOCK (b)->global_live_at_start);\n   next_tail = NEXT_INSN (tail);\n \n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx prev, next, link;\n       int reg_weight = 0;\n+      rtx x;\n \n       /* Handle register life information.  */\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t{\n-\t  /* See if the register gets born here.  */\n-\t  /* We must check for registers being born before we check for\n-\t     registers dying.  It is possible for a register to be born and\n-\t     die in the same insn, e.g. reading from a volatile memory\n-\t     location into an otherwise unused register.  Such a register\n-\t     must be marked as dead after this insn.  */\n-\t  if (GET_CODE (PATTERN (insn)) == SET\n-\t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\t    {\n-\t      sched_note_set (PATTERN (insn), 0);\n-\t      reg_weight++;\n-\t    }\n-\n-\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t    {\n-\t      int j;\n-\t      for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n-\t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n-\t\t    || GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t\t  {\n-\t\t    sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n-\t\t    reg_weight++;\n-\t\t  }\n-\n-\t      /* ??? This code is obsolete and should be deleted.  It\n-\t         is harmless though, so we will leave it in for now.  */\n-\t      for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n-\t\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == USE)\n-\t\t  sched_note_set (XVECEXP (PATTERN (insn), 0, j), 0);\n-\t    }\n-\n-\t  /* Each call cobbers (makes live) all call-clobbered regs\n-\t     that are not global or fixed.  Note that the function-value\n-\t     reg is a call_clobbered reg.  */\n-\t  if (GET_CODE (insn) == CALL_INSN)\n-\t    {\n-\t      int j;\n-\t      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\t\tif (call_used_regs[j] && !global_regs[j]\n-\t\t    && ! fixed_regs[j])\n-\t\t  {\n-\t\t    SET_REGNO_REG_SET (bb_live_regs, j);\n-\t\t  }\n-\t    }\n-\n-\t  /* Need to know what registers this insn kills.  */\n-\t  for (prev = 0, link = REG_NOTES (insn); link; link = next)\n-\t    {\n-\t      next = XEXP (link, 1);\n-\t      if ((REG_NOTE_KIND (link) == REG_DEAD\n-\t\t   || REG_NOTE_KIND (link) == REG_UNUSED)\n-\t      /* Verify that the REG_NOTE has a valid value.  */\n-\t\t  && GET_CODE (XEXP (link, 0)) == REG)\n-\t\t{\n-\t\t  register int regno = REGNO (XEXP (link, 0));\n-\n-\t\t  reg_weight--;\n-\n-\t\t  /* Only unlink REG_DEAD notes; leave REG_UNUSED notes\n-\t\t     alone.  */\n-\t\t  if (REG_NOTE_KIND (link) == REG_DEAD)\n-\t\t    {\n-\t\t      if (prev)\n-\t\t\tXEXP (prev, 1) = next;\n-\t\t      else\n-\t\t\tREG_NOTES (insn) = next;\n-\t\t      XEXP (link, 1) = dead_notes;\n-\t\t      dead_notes = link;\n-\t\t    }\n-\t\t  else\n-\t\t    prev = link;\n-\n-\t\t  if (regno < FIRST_PSEUDO_REGISTER)\n-\t\t    {\n-\t\t      int j = HARD_REGNO_NREGS (regno,\n-\t\t\t\t\t\tGET_MODE (XEXP (link, 0)));\n-\t\t      while (--j >= 0)\n-\t\t\t{\n-\t\t\t  CLEAR_REGNO_REG_SET (bb_live_regs, regno+j);\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      CLEAR_REGNO_REG_SET (bb_live_regs, regno);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tprev = link;\n-\t    }\n-\t}\n-\n-      INSN_REG_WEIGHT (insn) = reg_weight;\n-    }\n-}\n-\n-/* Update register life and usage information for block bb\n-   after scheduling.  Put register dead notes back in the code.  */\n-\n-static void\n-find_post_sched_live (bb)\n-     int bb;\n-{\n-  int sometimes_max;\n-  int j, i;\n-  int b;\n-  rtx insn;\n-  rtx head, tail, prev_head, next_tail;\n-\n-  register struct sometimes *regs_sometimes_live;\n-\n-  b = BB_TO_BLOCK (bb);\n-\n-  /* Compute live regs at the end of bb as a function of its successors.  */\n-  if (current_nr_blocks > 1)\n-    {\n-      int e;\n-      int first_edge;\n-\n-      first_edge = e = OUT_EDGES (b);\n-      CLEAR_REG_SET (bb_live_regs);\n-\n-      if (e)\n-\tdo\n-\t  {\n-\t    int b_succ;\n-\n-\t    b_succ = TO_BLOCK (e);\n-\t    IOR_REG_SET (bb_live_regs,\n-\t\t\t BASIC_BLOCK (b_succ)->global_live_at_start);\n-\t    e = NEXT_OUT (e);\n-\t  }\n-\twhile (e != first_edge);\n-    }\n-\n-  get_block_head_tail (bb, &head, &tail);\n-  next_tail = NEXT_INSN (tail);\n-  prev_head = PREV_INSN (head);\n-\n-  EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, FIRST_PSEUDO_REGISTER, i,\n-\t\t\t     {\n-\t\t\t       sched_reg_basic_block[i] = REG_BLOCK_GLOBAL;\n-\t\t\t     });\n-\n-  /* If the block is empty, same regs are alive at its end and its start.\n-     since this is not guaranteed after interblock scheduling, make sure they\n-     are truly identical.  */\n-  if (NEXT_INSN (prev_head) == tail\n-      && (GET_RTX_CLASS (GET_CODE (tail)) != 'i'))\n-    {\n-      if (current_nr_blocks > 1)\n-\tCOPY_REG_SET (BASIC_BLOCK (b)->global_live_at_start, bb_live_regs);\n-\n-      return;\n-    }\n-\n-  b = BB_TO_BLOCK (bb);\n-  current_block_num = b;\n-\n-  /* Keep track of register lives.  */\n-  old_live_regs = ALLOCA_REG_SET ();\n-  regs_sometimes_live\n-    = (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n-  sometimes_max = 0;\n-\n-  /* Initiate \"sometimes\" data, starting with registers live at end.  */\n-  sometimes_max = 0;\n-  COPY_REG_SET (old_live_regs, bb_live_regs);\n-  EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, 0, j,\n-\t\t\t     {\n-\t\t\t       sometimes_max\n-\t\t\t\t = new_sometimes_live (regs_sometimes_live,\n-\t\t\t\t\t\t       j, sometimes_max);\n-\t\t\t     });\n-\n-  /* Scan insns back, computing regs live info.  */\n-  for (insn = tail; insn != prev_head; insn = PREV_INSN (insn))\n-    {\n-      /* First we kill registers set by this insn, and then we\n-         make registers used by this insn live.  This is the opposite\n-         order used above because we are traversing the instructions\n-         backwards.  */\n-\n-      /* Strictly speaking, we should scan REG_UNUSED notes and make\n-         every register mentioned there live, however, we will just\n-         kill them again immediately below, so there doesn't seem to\n-         be any reason why we bother to do this.  */\n-\n-      /* See if this is the last notice we must take of a register.  */\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n \n-      if (GET_CODE (PATTERN (insn)) == SET\n-\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\tsched_note_set (PATTERN (insn), 1);\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+      /* Increment weight for each register born here.  */\n+      x = PATTERN (insn);\n+      if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n+\t  && register_operand (SET_DEST (x), VOIDmode))\n+\treg_weight++;\n+      else if (GET_CODE (x) == PARALLEL)\n \t{\n-\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n-\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n-\t\t|| GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == CLOBBER)\n-\t      sched_note_set (XVECEXP (PATTERN (insn), 0, j), 1);\n+\t  int j;\n+\t  for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+\t    {\n+\t      x = XVECEXP (PATTERN (insn), 0, j);\n+\t      if ((GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n+\t\t  && register_operand (SET_DEST (x), VOIDmode))\n+\t\treg_weight++;\n+\t    }\n \t}\n \n-      /* This code keeps life analysis information up to date.  */\n-      if (GET_CODE (insn) == CALL_INSN)\n+      /* Decrement weight for each register that dies here.  */\n+      for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n \t{\n-\t  register struct sometimes *p;\n-\n-\t  /* A call kills all call used registers that are not\n-\t     global or fixed, except for those mentioned in the call\n-\t     pattern which will be made live again later.  */\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (call_used_regs[i] && ! global_regs[i]\n-\t\t&& ! fixed_regs[i])\n-\t      {\n-\t\tCLEAR_REGNO_REG_SET (bb_live_regs, i);\n-\t      }\n-\n-\t  /* Regs live at the time of a call instruction must not\n-\t     go in a register clobbered by calls.  Record this for\n-\t     all regs now live.  Note that insns which are born or\n-\t     die in a call do not cross a call, so this must be done\n-\t     after the killings (above) and before the births\n-\t     (below).  */\n-\t  p = regs_sometimes_live;\n-\t  for (i = 0; i < sometimes_max; i++, p++)\n-\t    if (REGNO_REG_SET_P (bb_live_regs, p->regno))\n-\t      p->calls_crossed += 1;\n+\t  if (REG_NOTE_KIND (x) == REG_DEAD\n+\t      || REG_NOTE_KIND (x) == REG_UNUSED)\n+\t    reg_weight--;\n \t}\n \n-      /* Make every register used live, and add REG_DEAD notes for\n-         registers which were not live before we started.  */\n-      attach_deaths_insn (insn);\n-\n-      /* Find registers now made live by that instruction.  */\n-      EXECUTE_IF_AND_COMPL_IN_REG_SET (bb_live_regs, old_live_regs, 0, j,\n-\t\t\t\t {\n-\t\t\t\t   sometimes_max\n-\t\t\t\t     = new_sometimes_live (regs_sometimes_live,\n-\t\t\t\t\t\t\t   j, sometimes_max);\n-\t\t\t\t });\n-      IOR_REG_SET (old_live_regs, bb_live_regs);\n-\n-      /* Count lengths of all regs we are worrying about now,\n-         and handle registers no longer live.  */\n-\n-      for (i = 0; i < sometimes_max; i++)\n-\t{\n-\t  register struct sometimes *p = &regs_sometimes_live[i];\n-\t  int regno = p->regno;\n-\n-\t  p->live_length += 1;\n-\n-\t  if (!REGNO_REG_SET_P (bb_live_regs, regno))\n-\t    {\n-\t      /* This is the end of one of this register's lifetime\n-\t         segments.  Save the lifetime info collected so far,\n-\t         and clear its bit in the old_live_regs entry.  */\n-\t      sched_reg_live_length[regno] += p->live_length;\n-\t      sched_reg_n_calls_crossed[regno] += p->calls_crossed;\n-\t      CLEAR_REGNO_REG_SET (old_live_regs, p->regno);\n-\n-\t      /* Delete the reg_sometimes_live entry for this reg by\n-\t         copying the last entry over top of it.  */\n-\t      *p = regs_sometimes_live[--sometimes_max];\n-\t      /* ...and decrement i so that this newly copied entry\n-\t         will be processed.  */\n-\t      i--;\n-\t    }\n-\t}\n+      INSN_REG_WEIGHT (insn) = reg_weight;\n     }\n-\n-  finish_sometimes_live (regs_sometimes_live, sometimes_max);\n-\n-  /* In interblock scheduling, global_live_at_start may have changed.  */\n-  if (current_nr_blocks > 1)\n-    COPY_REG_SET (BASIC_BLOCK (b)->global_live_at_start, bb_live_regs);\n-\n-\n-  FREE_REG_SET (old_live_regs);\n-}\t\t\t\t/* find_post_sched_live */\n-\n-/* After scheduling the subroutine, restore information about uses of\n-   registers.  */\n-\n-static void\n-update_reg_usage ()\n-{\n-  int regno;\n-\n-  if (n_basic_blocks > 0)\n-    EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, FIRST_PSEUDO_REGISTER, regno,\n-\t\t\t       {\n-\t\t\t\t sched_reg_basic_block[regno]\n-\t\t\t\t   = REG_BLOCK_GLOBAL;\n-\t\t\t       });\n-\n-  for (regno = 0; regno < max_regno; regno++)\n-    if (sched_reg_live_length[regno])\n-      {\n-\tif (sched_verbose)\n-\t  {\n-\t    if (REG_LIVE_LENGTH (regno) > sched_reg_live_length[regno])\n-\t      fprintf (dump,\n-\t\t       \";; register %d life shortened from %d to %d\\n\",\n-\t\t       regno, REG_LIVE_LENGTH (regno),\n-\t\t       sched_reg_live_length[regno]);\n-\t    /* Negative values are special; don't overwrite the current\n-\t       reg_live_length value if it is negative.  */\n-\t    else if (REG_LIVE_LENGTH (regno) < sched_reg_live_length[regno]\n-\t\t     && REG_LIVE_LENGTH (regno) >= 0)\n-\t      fprintf (dump,\n-\t\t       \";; register %d life extended from %d to %d\\n\",\n-\t\t       regno, REG_LIVE_LENGTH (regno),\n-\t\t       sched_reg_live_length[regno]);\n-\n-\t    if (!REG_N_CALLS_CROSSED (regno)\n-\t\t&& sched_reg_n_calls_crossed[regno])\n-\t      fprintf (dump,\n-\t\t       \";; register %d now crosses calls\\n\", regno);\n-\t    else if (REG_N_CALLS_CROSSED (regno)\n-\t\t     && !sched_reg_n_calls_crossed[regno]\n-\t\t     && REG_BASIC_BLOCK (regno) != REG_BLOCK_GLOBAL)\n-\t      fprintf (dump,\n-\t\t       \";; register %d no longer crosses calls\\n\", regno);\n-\n-\t    if (REG_BASIC_BLOCK (regno) != sched_reg_basic_block[regno]\n-\t\t&& sched_reg_basic_block[regno] != REG_BLOCK_UNKNOWN\n-\t\t&& REG_BASIC_BLOCK(regno) != REG_BLOCK_UNKNOWN)\n-\t      fprintf (dump,\n-\t\t       \";; register %d changed basic block from %d to %d\\n\",\n-\t\t\tregno, REG_BASIC_BLOCK(regno),\n-\t\t\tsched_reg_basic_block[regno]);\n-\n-\t  }\n-\t/* Negative values are special; don't overwrite the current\n-\t   reg_live_length value if it is negative.  */\n-\tif (REG_LIVE_LENGTH (regno) >= 0)\n-\t  REG_LIVE_LENGTH (regno) = sched_reg_live_length[regno];\n-\n-\tif (sched_reg_basic_block[regno] != REG_BLOCK_UNKNOWN\n-\t    && REG_BASIC_BLOCK(regno) != REG_BLOCK_UNKNOWN)\n-\t  REG_BASIC_BLOCK(regno) = sched_reg_basic_block[regno];\n-\n-\t/* We can't change the value of reg_n_calls_crossed to zero for\n-\t   pseudos which are live in more than one block.\n-\n-\t   This is because combine might have made an optimization which\n-\t   invalidated global_live_at_start and reg_n_calls_crossed,\n-\t   but it does not update them.  If we update reg_n_calls_crossed\n-\t   here, the two variables are now inconsistent, and this might\n-\t   confuse the caller-save code into saving a register that doesn't\n-\t   need to be saved.  This is only a problem when we zero calls\n-\t   crossed for a pseudo live in multiple basic blocks.\n-\n-\t   Alternatively, we could try to correctly update basic block live\n-\t   at start here in sched, but that seems complicated.\n-\n-\t   Note: it is possible that a global register became local,\n-\t   as result of interblock motion, but will remain marked as a\n-\t   global register.  */\n-\tif (sched_reg_n_calls_crossed[regno]\n-\t    || REG_BASIC_BLOCK (regno) != REG_BLOCK_GLOBAL)\n-\t  REG_N_CALLS_CROSSED (regno) = sched_reg_n_calls_crossed[regno];\n-\n-      }\n }\n \n /* Scheduling clock, modified in schedule_block() and queue_to_ready ().  */\n@@ -6500,10 +5534,10 @@ move_insn1 (insn, last)\n   return insn;\n }\n \n-/* Search INSN for fake REG_DEAD note pairs for NOTE_INSN_SETJMP,\n+/* Search INSN for REG_SAVE_NOTE note pairs for NOTE_INSN_SETJMP,\n    NOTE_INSN_{LOOP,EHREGION}_{BEG,END}; and convert them back into\n-   NOTEs.  The REG_DEAD note following first one is contains the saved\n-   value for NOTE_BLOCK_NUMBER which is useful for\n+   NOTEs.  The REG_SAVE_NOTE note following first one is contains the\n+   saved value for NOTE_BLOCK_NUMBER which is useful for\n    NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  LAST is the last instruction\n    output by the instruction scheduler.  Return the new value of LAST.  */\n \n@@ -6517,8 +5551,7 @@ reemit_notes (insn, last)\n   retval = last;\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     {\n-      if (REG_NOTE_KIND (note) == REG_DEAD\n-\t  && GET_CODE (XEXP (note, 0)) == CONST_INT)\n+      if (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n \t{\n \t  int note_type = INTVAL (XEXP (note, 0));\n \t  if (note_type == NOTE_INSN_SETJMP)\n@@ -6671,8 +5704,7 @@ schedule_block (bb, rgn_n_insns)\n       rtx note;\n \n       for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_DEAD\n-\t    && GET_CODE (XEXP (note, 0)) == CONST_INT)\n+\tif (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n \t  remove_note (head, note);\n     }\n \n@@ -7566,6 +6598,8 @@ schedule_region (rgn)\n   int bb;\n   int rgn_n_insns = 0;\n   int sched_rgn_n_insns = 0;\n+  int initial_deaths;\n+  sbitmap blocks;\n \n   /* Set variables for the current region.  */\n   current_nr_blocks = RGN_NR_BLOCKS (rgn);\n@@ -7575,6 +6609,13 @@ schedule_region (rgn)\n   reg_pending_clobbers = ALLOCA_REG_SET ();\n   reg_pending_sets_all = 0;\n \n+  /* Create a bitmap of the blocks in this region.  */\n+  blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (blocks);\n+\n+  for (bb = current_nr_blocks - 1; bb >= 0; --bb)\n+    SET_BIT (blocks, BB_TO_BLOCK (bb));\n+\n   /* Initializations for region data dependence analyisis.  */\n   if (current_nr_blocks > 1)\n     {\n@@ -7624,13 +6665,16 @@ schedule_region (rgn)\n   for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n     compute_block_forward_dependences (bb);\n \n-  /* Delete line notes, compute live-regs at block end, and set priorities.  */\n-  dead_notes = 0;\n+  /* Compute INSN_REG_WEIGHT.  */\n+  for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n+    find_insn_reg_weight (bb);\n+\n+  /* Remove death notes.  */\n+  initial_deaths = count_or_remove_death_notes (blocks, 1);\n+\n+  /* Delete line notes and set priorities.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n-      if (reload_completed == 0)\n-\tfind_pre_sched_live (bb);\n-\n       if (write_symbols != NO_DEBUG)\n \t{\n \t  save_line_notes (bb);\n@@ -7704,20 +6748,18 @@ schedule_region (rgn)\n   if (sched_rgn_n_insns != rgn_n_insns)\n     abort ();\n \n-  /* Update register life and usage information.  */\n-  if (reload_completed == 0)\n+  /* Update register life and usage information.  Scheduling a multi-block\n+     region requires a global update.  */\n+  if (current_nr_blocks > 1)\n+    update_life_info (blocks, UPDATE_LIFE_GLOBAL);\n+  else\n     {\n-      for (bb = current_nr_blocks - 1; bb >= 0; bb--)\n-\tfind_post_sched_live (bb);\n-\n-      if (current_nr_blocks <= 1)\n-\t/* Sanity check.  There should be no REG_DEAD notes leftover\n-\t   at the end.  In practice, this can occur as the result of\n-\t   bugs in flow, combine.c, and/or sched.c.  The values of the\n-\t   REG_DEAD notes remaining are meaningless, because\n-\t   dead_notes is just used as a free list.  */\n-\tif (dead_notes != 0)\n-\t  abort ();\n+      update_life_info (blocks, UPDATE_LIFE_LOCAL);\n+\n+      /* In the single block case, the count of registers that died should\n+\t not have changed during the schedule.  */\n+      if (count_or_remove_death_notes (blocks, 0) != initial_deaths)\n+        abort (); \n     }\n \n   /* Restore line notes.  */\n@@ -7732,6 +6774,7 @@ schedule_region (rgn)\n \n   FREE_REG_SET (reg_pending_sets);\n   FREE_REG_SET (reg_pending_clobbers);\n+  sbitmap_free (blocks);\n }\n \n /* The one entry point in this file.  DUMP_FILE is the dump file for\n@@ -7920,26 +6963,6 @@ schedule_insns (dump_file)\n   insn_dep_count = (int *) xcalloc (max_uid, sizeof (int));\n   insn_depend = (rtx *) xcalloc (max_uid, sizeof (rtx));\n \n-  if (reload_completed == 0)\n-    {\n-      int i;\n-\n-      sched_reg_n_calls_crossed = (int *) alloca (max_regno * sizeof (int));\n-      sched_reg_live_length = (int *) alloca (max_regno * sizeof (int));\n-      sched_reg_basic_block = (int *) alloca (max_regno * sizeof (int));\n-      bb_live_regs = ALLOCA_REG_SET ();\n-      bzero ((char *) sched_reg_n_calls_crossed, max_regno * sizeof (int));\n-      bzero ((char *) sched_reg_live_length, max_regno * sizeof (int));\n-\n-      for (i = 0; i < max_regno; i++)\n-\tsched_reg_basic_block[i] = REG_BLOCK_UNKNOWN;\n-    }\n-  else\n-    {\n-      sched_reg_n_calls_crossed = 0;\n-      sched_reg_live_length = 0;\n-      bb_live_regs = 0;\n-    }\n   init_alias_analysis ();\n \n   if (write_symbols != NO_DEBUG)\n@@ -8001,10 +7024,6 @@ schedule_insns (dump_file)\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n \n-  /* Update information about uses of registers in the subroutine.  */\n-  if (reload_completed == 0)\n-    update_reg_usage ();\n-\n   if (sched_verbose)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)\n@@ -8040,9 +7059,6 @@ schedule_insns (dump_file)\n   if (write_symbols != NO_DEBUG)\n     free (line_note);\n \n-  if (bb_live_regs)\n-    FREE_REG_SET (bb_live_regs);\n-\n   if (edge_table)\n     {\n       free (edge_table);"}, {"sha": "a20d9e5e1906172df665c6bbbb87944bab6407cc", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c46a37c4175e5dc851903b6af00323cd21f13ae3", "patch": "@@ -257,7 +257,7 @@ const char * const reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"\n \t\t\t  \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\",\n \t\t\t  \"REG_BR_PRED\", \"REG_EH_CONTEXT\",\n \t\t\t  \"REG_FRAME_RELATED_EXPR\", \"REG_EH_REGION\",\n-\t\t\t  \"REG_EH_RETHROW\" };\n+\t\t\t  \"REG_EH_RETHROW\", \"REG_SAVE_NOTE\" };\n \n static void dump_and_abort\tPROTO((int, int, FILE *)) ATTRIBUTE_NORETURN;\n static void read_name\t\tPROTO((char *, FILE *));"}, {"sha": "99802374928d5243190b13999fc5e00ec31fb79b", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c46a37c4175e5dc851903b6af00323cd21f13ae3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c46a37c4175e5dc851903b6af00323cd21f13ae3", "patch": "@@ -456,17 +456,18 @@ extern void rtvec_check_failed_bounds PROTO((rtvec, int,\n    flags computed by get_jump_flags() after dbr scheduling is complete.\n      REG_FRAME_RELATED_EXPR is attached to insns that are RTX_FRAME_RELATED_P,\n    but are too complex for DWARF to interpret what they imply.  The attached\n-   rtx is used instead of intuition.  */\n-/*   REG_EH_REGION is used to indicate what exception region an INSN\n+   rtx is used instead of intuition.\n+     REG_EH_REGION is used to indicate what exception region an INSN\n    belongs in.  This can be used to indicate what region a call may throw\n    to. a REGION of 0 indicates that a call cannot throw at all.\n    a REGION  of -1 indicates that it cannot throw, nor will it execute\n    a non-local goto.\n      REG_EH_RETHROW is used to indicate that a call is actually a\n    call to rethrow, and specifies the rethrow symbol for the region \n    the rethrow is targetting.  This provides a way to generate the \n-   non standard flow edges required for a rethrow. */\n-   \n+   non standard flow edges required for a rethrow.\n+     REG_SAVE_NOTE is used by haifa-sched to save NOTE_INSN notes \n+   across scheduling.  */\n \n #define REG_NOTES(INSN)\tXEXP(INSN, 6)\n \n@@ -481,7 +482,7 @@ enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_EXEC_COUNT = 17, REG_NOALIAS = 18, REG_SAVE_AREA = 19,\n \t\tREG_BR_PRED = 20, REG_EH_CONTEXT = 21,\n \t\tREG_FRAME_RELATED_EXPR = 22, REG_EH_REGION = 23,\n-\t\tREG_EH_RETHROW = 24 };\n+\t\tREG_EH_RETHROW = 24, REG_SAVE_NOTE = 25 };\n /* The base value for branch probability notes.  */\n #define REG_BR_PROB_BASE  10000\n "}]}