{"sha": "07814743cf9b934c94d540a7820a3683abacfb38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc4MTQ3NDNjZjliOTM0Yzk0ZDU0MGE3ODIwYTM2ODNhYmFjZmIzOA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-02-08T01:34:41Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-02-08T01:34:41Z"}, "message": "std_fstream.h (filebuf::__file_type): Change to __basic_file<char>.\n\n\n2002-02-07  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tlibstdc++/5286\n\tlibstdc++/3860\n\t* include/std/std_fstream.h (filebuf::__file_type): Change to\n\t__basic_file<char>.\n\t(filebuf::_M_convert_to_external): Declare.\n\t* include/bits/fstream.tcc (filebuf::_M_convert_to_external): Define\n\tcodecvt bits for wide streams.\n\t(filebuf::_M_really_overflow): Use it.\n\t(filebuf::underflow): Use codecvt.\n\t* config/locale/codecvt_specializations_ieee_1003.1-200x.h:\n\t(codecvt<__enc_traits>::do_out): Deal with partial.\n\t(codecvt<__enc_traits>::do_encoding): Return something useful.\n\t* src/codecvt.cc (codecvt<wchar_t>::do_encoding): Return sizeof\n\twchar_t.\n\t* testsuite/22_locale/codecvt_members_unicode_char.cc (test01):\n\tChange expected encoding output.\n\t(test02): Same.\n\t* testsuite/22_locale/codecvt_members_wchar_t_char.cc (test01): Same.\n\t(test02): Same.\n\nFrom-SVN: r49601", "tree": {"sha": "ab0d7819903ce7ebf7d475215e87568a03291ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab0d7819903ce7ebf7d475215e87568a03291ff6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07814743cf9b934c94d540a7820a3683abacfb38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07814743cf9b934c94d540a7820a3683abacfb38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07814743cf9b934c94d540a7820a3683abacfb38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07814743cf9b934c94d540a7820a3683abacfb38/comments", "author": null, "committer": null, "parents": [{"sha": "e291c8db1b74ed014d827441325ff81103b149e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e291c8db1b74ed014d827441325ff81103b149e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e291c8db1b74ed014d827441325ff81103b149e2"}], "stats": {"total": 281, "additions": 180, "deletions": 101}, "files": [{"sha": "485d5d0ae275c9a2339db286d074ddde7e7d533b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -1,3 +1,25 @@\n+2002-02-07  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tlibstdc++/5286\n+\tlibstdc++/3860\n+\t* include/std/std_fstream.h (filebuf::__file_type): Change to\n+\t__basic_file<char>.\n+\t(filebuf::_M_convert_to_external): Declare.\n+\t* include/bits/fstream.tcc (filebuf::_M_convert_to_external): Define\n+\tcodecvt bits for wide streams.\n+\t(filebuf::_M_really_overflow): Use it.\n+\t(filebuf::underflow): Use codecvt.\n+\t* config/locale/codecvt_specializations_ieee_1003.1-200x.h: \n+\t(codecvt<__enc_traits>::do_out): Deal with partial.\n+\t(codecvt<__enc_traits>::do_encoding): Return something useful.\n+\t* src/codecvt.cc (codecvt<wchar_t>::do_encoding): Return sizeof\n+\twchar_t.\n+\t* testsuite/22_locale/codecvt_members_unicode_char.cc (test01):\n+\tChange expected encoding output.\n+\t(test02): Same.\n+\t* testsuite/22_locale/codecvt_members_wchar_t_char.cc (test01): Same.\n+\t(test02): Same.\n+\n 2002-02-07  Benjamin Kosnik  <bkoz@redhat.com>\n             Wolfgang Bangerth  <wolfgang.bangerth@iwr.uni-heidelberg.de>\n \t"}, {"sha": "8cac2995d48f430171af56bcbc7189a5757cdf67", "filename": "libstdc++-v3/config/locale/codecvt_specializations_ieee_1003.1-200x.h", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fcodecvt_specializations_ieee_1003.1-200x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fcodecvt_specializations_ieee_1003.1-200x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fcodecvt_specializations_ieee_1003.1-200x.h?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -263,14 +263,14 @@\n \n   // This adaptor works around the signature problems of the second\n   // argument to iconv():  SUSv2 and others use 'const char**', but glibc 2.2\n-  // uses 'char**', which is what the standard is (apparently) due to use\n-  // in the future.  Using this adaptor, g++ will do the work for us.\n+  // uses 'char**', which matches the POSIX 1003.1-2001 standard.\n+  // Using this adaptor, g++ will do the work for us.\n   template<typename _T>\n     inline size_t\n-    __iconv_adaptor(size_t(*iconv_func)(iconv_t, _T, size_t*, char**, size_t*),\n-                    iconv_t cd, char** inbuf, size_t* inbytesleft,\n-                    char** outbuf, size_t* outbytesleft)\n-    { return iconv_func(cd, (_T)inbuf, inbytesleft, outbuf, outbytesleft); }\n+    __iconv_adaptor(size_t(*__func)(iconv_t, _T, size_t*, char**, size_t*),\n+                    iconv_t __cd, char** __inbuf, size_t* __inbytes,\n+                    char** __outbuf, size_t* __outbytes)\n+    { return __func(__cd, (_T)__inbuf, __inbytes, __outbuf, __outbytes); }\n \n   template<typename _InternT, typename _ExternT>\n     codecvt_base::result\n@@ -286,9 +286,9 @@\n \t  typedef state_type::__desc_type\t__desc_type;\n \t  const __desc_type* __desc = __state._M_get_out_descriptor();\n \t  const size_t __fmultiple = sizeof(intern_type) / sizeof(char);\n-\t  size_t __flen = __fmultiple * (__from_end - __from);\n+\t  size_t __fbytes = __fmultiple * (__from_end - __from);\n \t  const size_t __tmultiple = sizeof(extern_type) / sizeof(char);\n-\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  size_t __tbytes = __tmultiple * (__to_end - __to); \n \t  \n \t  // Argument list for iconv specifies a byte sequence. Thus,\n \t  // all to/from arrays must be brutally casted to char*.\n@@ -310,14 +310,14 @@\n \t      char_traits<intern_type>::copy(__cfixed + 1, __from, __size);\n \t      __cfrom = reinterpret_cast<char*>(__cfixed);\n \t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n-                                        &__flen, &__cto, &__tlen); \n+                                        &__fbytes, &__cto, &__tbytes); \n \t    }\n \t  else\n \t    {\n \t      intern_type* __cfixed = const_cast<intern_type*>(__from);\n \t      __cfrom = reinterpret_cast<char*>(__cfixed);\n-\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom,\n-                                       &__flen, &__cto, &__tlen); \n+\t      __conv = __iconv_adaptor(iconv, *__desc, &__cfrom, &__fbytes, \n+\t\t\t\t       &__cto, &__tbytes); \n \t    }\n \n \t  if (__conv != size_t(-1))\n@@ -328,7 +328,7 @@\n \t    }\n \t  else \n \t    {\n-\t      if (__flen < static_cast<size_t>(__from_end - __from))\n+\t      if (__fbytes < __fmultiple * (__from_end - __from))\n \t\t{\n \t\t  __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n \t\t  __to_next = reinterpret_cast<extern_type*>(__cto);\n@@ -451,7 +451,12 @@\n     int \n     codecvt<_InternT, _ExternT, __enc_traits>::\n     do_encoding() const throw()\n-    { return 0; }\n+    {\n+      int __ret = 0;\n+      if (sizeof(_ExternT) <= sizeof(_InternT))\n+\t__ret = sizeof(_InternT)/sizeof(_ExternT);\n+      return __ret; \n+    }\n   \n   template<typename _InternT, typename _ExternT>\n     bool "}, {"sha": "4ef0bcccecceb361c393b0fece1a786918c1a16b", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 115, "deletions": 68, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -246,7 +246,6 @@ namespace std\n       bool __testin = _M_mode & ios_base::in;\n       bool __testout = _M_mode & ios_base::out;\n \n-      // XXX Should re-enable codecvt bits disabled after 2.90.8.\n       if (__testin)\n \t{\n \t  // Check for pback madness, and if so swich back to the\n@@ -259,10 +258,10 @@ namespace std\n \t\treturn traits_type::to_int_type(*_M_in_cur);\n \t    }\n \n-\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n-\t  bool __testinit = _M_is_indeterminate();\n \t  // Sync internal and external buffers.\n \t  // NB: __testget -> __testput as _M_buf_unified here.\n+\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n+\t  bool __testinit = _M_is_indeterminate();\n \t  if (__testget)\n \t    {\n \t      if (__testout)\n@@ -278,26 +277,51 @@ namespace std\n \n \t  if (__testinit || __testget)\n \t    {\n-\t      // Assume buffered case, need to refill internal buffers.\n-\t      streamsize __size = _M_file->xsgetn(_M_in_beg, _M_buf_size);\n-\t      if (0 < __size)\n+\t      typedef codecvt<char_type, char, __state_type> __codecvt_type;\n+\t      const locale __loc = this->getloc();\n+\t      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc); \n+\n+\t      streamsize __elen = 0;\n+\t      streamsize __ilen = 0;\n+\t      if (__cvt.always_noconv())\n+\t\t{\n+\t\t  __elen = _M_file->xsgetn(reinterpret_cast<char*>(_M_in_beg), \n+\t\t\t\t\t   _M_buf_size);\n+\t\t  __ilen = __elen;\n+\t\t}\n+\t      else\n \t\t{\n-\t\t  _M_set_determinate(__size);\n+\t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size));\n+\t\t  __elen = _M_file->xsgetn(__buf, _M_buf_size);\n+\n+\t\t  const char* __eend;\n+\t\t  char_type* __iend;\n+\t\t  __res_type __r = __cvt.in(_M_state_cur, __buf, \n+\t\t\t\t\t    __buf + __elen, __eend, _M_in_beg, \n+\t\t\t\t\t    _M_in_beg + _M_buf_size, __iend);\n+\t\t  if (__r == codecvt_base::ok)\n+\t\t    __ilen = __iend - _M_in_beg;\n+\t\t  else \n+\t\t    {\n+\t\t      // Unwind.\n+\t\t      __ilen = 0;\n+\t\t      _M_file->seekoff(-__elen, ios_base::cur, ios_base::in);\n+\t\t    }\n+\t\t}\n+\n+\t      if (0 < __ilen)\n+\t\t{\n+\t\t  _M_set_determinate(__ilen);\n \t\t  if (__testout)\n \t\t    _M_out_cur = _M_in_cur;\n \t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n #if _GLIBCPP_AVOID_FSEEK\n-\t\t  if (__size == 1)\n+\t\t  if (__elen == 1)\n \t\t    _M_file->sys_ungetc(*_M_in_cur);\n \t\t  else\n \t\t    {\n #endif\n-\t\t  streamoff __p = _M_file->seekoff(0 - __size, ios_base::cur, \n-\t\t\t\t\t\t   ios_base::in);\n-\t\t  if (__p == -1)\n-\t\t    {\n-\t\t      // XXX Something is wrong, do error checking.\n-\t\t    }\n+\t\t      _M_file->seekoff(-__elen, ios_base::cur, ios_base::in);\n #if _GLIBCPP_AVOID_FSEEK\n \t\t    }\n #endif\n@@ -401,6 +425,66 @@ namespace std\n       return __ret;\n     }\n   \n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen,\n+\t\t\t   streamsize& __elen, streamsize& __plen)\n+    {\n+      typedef codecvt<char_type, char, __state_type> __codecvt_type;\n+      const locale __loc = this->getloc();\n+      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc);\n+      \n+      if (__cvt.always_noconv() && __ilen)\n+\t{\n+\t  __elen += _M_file->xsputn(reinterpret_cast<char*>(__ibuf), __ilen);\n+\t  __plen += __ilen;\n+\t}\n+      else\n+\t{\n+\t  // Worst-case number of external bytes needed.\n+\t  int __ext_multiplier = __cvt.encoding();\n+\t  if (__ext_multiplier ==  -1 || __ext_multiplier == 0)\n+\t    __ext_multiplier = sizeof(char_type);\n+\t  streamsize __blen = __ilen * __ext_multiplier;\n+\t  char* __buf = static_cast<char*>(__builtin_alloca(__blen));\n+\t  char* __bend;\n+\t  const char_type* __iend;\n+\t  __res_type __r = __cvt.out(_M_state_cur, __ibuf, __ibuf + __ilen, \n+\t\t \t\t     __iend, __buf, __buf + __blen, __bend);\n+\t  // Result == ok, partial, noconv\n+\t  if (__r != codecvt_base::error)\n+\t    __blen = __bend - __buf;\n+\t  // Result == error\n+\t  else \n+\t    __blen = 0;\n+\t  \n+\t  if (__blen)\n+\t    {\n+\t      __elen += _M_file->xsputn(__buf, __blen);\n+\t      __plen += __blen;\n+\t    }\n+\n+\t  // Try once more for partial conversions.\n+\t  if (__r == codecvt_base::partial)\n+\t    {\n+\t      const char_type* __iresume = __iend;\n+\t      streamsize __rlen = _M_out_end - __iend;\n+\t      __r = __cvt.out(_M_state_cur, __iresume, __iresume + __rlen, \n+\t\t\t      __iend, __buf, __buf + __blen, __bend);\n+\t      if (__r != codecvt_base::error)\n+\t\t__rlen = __bend - __buf;\n+\t      else \n+\t\t__rlen = 0;\n+\t      if (__rlen)\n+\t\t{\n+\t\t  __elen += _M_file->xsputn(__buf, __rlen);\n+\t\t  __plen += __rlen;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n@@ -412,68 +496,31 @@ namespace std\n \n       if (__testput || __testunbuffered)\n \t{\n-#if 1\n-\t  int __plen = _M_out_end - _M_out_beg;\n-\t  streamsize __len = 0;\n-\n-\t  if (__plen)\n-\t    __len = _M_file->xsputn(_M_out_beg, __plen);\n-\n-\t  if (__c != traits_type::eof())\n+\t  // Sizes of external and pending output.\n+\t  streamsize __elen = 0;\n+\t  streamsize __plen = 0;\n+\n+\t  // Convert internal buffer to external representation, output.\n+\t  // NB: In the unbuffered case, no internal buffer exists. \n+\t  if (!__testunbuffered)\n+\t    _M_convert_to_external(_M_out_beg,  _M_out_end - _M_out_beg, \n+\t\t\t\t   __elen, __plen);\n+\n+\t  // Convert pending sequence to external representation, output.\n+\t  if (!traits_type::eq_int_type(__c, traits_type::eof()))\n \t    {\n- \t      char_type __pending = traits_type::to_char_type(__c);\n- \t      __len += _M_file->xsputn(&__pending, 1);\n-  \t      ++__plen;\n+\t      char_type __pending = traits_type::to_char_type(__c);\n+\t      _M_convert_to_external(&__pending, 1, __elen, __plen);\n \t    }\n \n+\t  // Last, sync internal and external buffers.\n \t  // NB: Need this so that external byte sequence reflects\n-\t  // internal buffer.\n-\t  if (__len == __plen && !_M_file->sync())\n+\t  // internal buffer plus pending sequence.\n+\t  if (__elen == __plen && !_M_file->sync())\n \t    {\n \t      _M_set_indeterminate();\n \t      __ret = traits_type::not_eof(__c);\n \t    }\n-#else\n-\t  // Part one: Allocate temporary conversion buffer on\n-\t  // stack. Convert internal buffer plus __c (ie,\n-\t  // \"pending sequence\") to temporary conversion buffer.\n-\t  int __plen = _M_out_end - _M_out_beg;\n-\t  char_type* __pbuf = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __plen + 1));\n-\t  traits_type::copy(__pbuf, this->pbase(), __plen);\n-\t  if (!__testeof)\n-\t    {\n-\t      __pbuf[__plen] = traits_type::to_char_type(__c);\n-\t      ++__plen;\n-\t    }\n-\n-\t  char_type* __pend;\n-\t  char* __conv_buf = static_cast<char*>(__builtin_alloca(__plen));\n-\t  char* __conv_end;\n-\t  _M_state_beg = _M_state_cur;\n-\n-\t  __res_type __r = _M_fcvt->out(_M_state_cur, \n-\t\t\t\t\t__pbuf, __pbuf + __plen,\n-\t\t\t\t\tconst_cast<const char_type*&>(__pend),\n-\t\t\t\t\t__conv_buf, __conv_buf + __plen,\n-\t\t\t\t\t__conv_end);\n-\t  \n-\t  // Part two: (Re)spill converted \"pending sequence\"\n-\t  // contents (now in temporary conversion buffer) to\n-\t  // external buffer (_M_file->_IO_*) using\n-\t  // _M_file->sys_write(), and do error (minimal) checking.\n-\t  if (__r != codecvt_base::error)\n-\t    {\n-\t      streamsize __len = _M_file->xsputn(__conv_buf, __plen);\n-\t      // NB: Need this so that external byte sequence reflects\n-\t      // internal buffer.\n-\t      _M_file->sync(); // XXX error check\n-\t      if (__len == __plen)\n-\t\t{\n-\t\t  _M_set_indeterminate();\n-\t\t  __ret = traits_type::not_eof(__c);\n-\t\t}\n-\t    }\n-#endif\n \t}\t      \n       _M_last_overflowed = true;\t\n       return __ret;"}, {"sha": "92839753bd6f0ca7995776cc1ce15694961af60a", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -64,7 +64,7 @@ namespace std\n       // Non-standard Types:\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef basic_filebuf<char_type, traits_type>     __filebuf_type;\n-      typedef __basic_file<char_type>\t\t        __file_type;\n+      typedef __basic_file<char>\t\t        __file_type;\n       typedef typename traits_type::state_type          __state_type;\n       typedef codecvt<char_type, char, __state_type>    __codecvt_type;\n       typedef typename __codecvt_type::result \t        __res_type;\n@@ -111,13 +111,13 @@ namespace std\n \n       // Members:\n       bool\n-      is_open(void) const { return _M_file ? _M_file->is_open() : false; }\n+      is_open() const { return _M_file ? _M_file->is_open() : false; }\n \n       __filebuf_type*\n       open(const char* __s, ios_base::openmode __mode);\n \n       __filebuf_type*\n-      close(void);\n+      close();\n \n     protected:\n       void\n@@ -135,14 +135,14 @@ namespace std\n \n       // Overridden virtual functions:\n       virtual streamsize\n-      showmanyc(void);\n+      showmanyc();\n \n       // Stroustrup, 1998, p. 628\n       // underflow() and uflow() functions are called to get the next\n       // charater from the real input source when the buffer is empty.\n       // Buffered input uses underflow()\n       virtual int_type\n-      underflow(void);\n+      underflow();\n \n       virtual int_type\n       pbackfail(int_type __c = _Traits::eof());\n@@ -168,6 +168,11 @@ namespace std\n       int_type\n       _M_really_overflow(int_type __c = _Traits::eof());\n \n+      // Convert internal byte sequence to external, char-based\n+      // sequence via codecvt.\n+      void\n+      _M_convert_to_external(char_type*, streamsize, streamsize&, streamsize&);\n+\n       virtual __streambuf_type*\n       setbuf(char_type* __s, streamsize __n);\n \n@@ -180,7 +185,7 @@ namespace std\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n       virtual int\n-      sync(void)\n+      sync()\n       {\n \tbool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n \n@@ -296,7 +301,7 @@ namespace std\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       bool\n-      is_open(void) { return _M_filebuf.is_open(); }\n+      is_open() { return _M_filebuf.is_open(); }\n \n       void\n       open(const char* __s, ios_base::openmode __mode = ios_base::in)\n@@ -307,7 +312,7 @@ namespace std\n \n       /** Close the file.  */\n       void\n-      close(void)\n+      close()\n       {\n \tif (!_M_filebuf.close())\n \t  this->setstate(ios_base::failbit);\n@@ -370,15 +375,15 @@ namespace std\n        *  @return Pointer to basic_filebuf.\n       */\n       __filebuf_type*\n-      rdbuf(void) const\n+      rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       /**\n        *  @brief Query to see if file stream is open.\n        *  @return True if stream is open.\n       */\n       bool\n-      is_open(void) { return _M_filebuf.is_open(); }\n+      is_open() { return _M_filebuf.is_open(); }\n \n       /**\n        *  @brief Specify a file to open for output.\n@@ -398,7 +403,7 @@ namespace std\n \n       /** Close the file stream.  */\n       void\n-      close(void)\n+      close()\n       {\n \tif (!_M_filebuf.close())\n \t  this->setstate(ios_base::failbit);\n@@ -462,15 +467,15 @@ namespace std\n        *  @return Pointer to basic_filebuf.\n       */\n       __filebuf_type*\n-      rdbuf(void) const\n+      rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       /**\n        *  @brief Query to see if file stream is open.\n        *  @return True if stream is open.\n       */\n       bool\n-      is_open(void) { return _M_filebuf.is_open(); }\n+      is_open() { return _M_filebuf.is_open(); }\n \n       /**\n        *  @brief Specify a file to open for input and/or output.\n@@ -490,7 +495,7 @@ namespace std\n \n       /** Close the file stream.  */\n       void\n-      close(void)\n+      close()\n       {\n \tif (!_M_filebuf.close())\n \t  setstate(ios_base::failbit);"}, {"sha": "032667e3f13307f047b73357a70beedd34c2e1e4", "filename": "libstdc++-v3/src/codecvt.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fcodecvt.cc?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -181,7 +181,7 @@ namespace std\n   int \n   codecvt<wchar_t, char, mbstate_t>::\n   do_encoding() const throw()\n-  { return 0; }\n+  { return sizeof(wchar_t); }\n   \n   bool \n   codecvt<wchar_t, char, mbstate_t>::"}, {"sha": "026e6091397eb1327cec71a50e2290f0a8fca85f", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_members_unicode_char.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -1,6 +1,6 @@\n // 2000-08-22 Benjamin Kosnik <bkoz@cygnus.com>\n \n-// Copyright (C) 2000, 2001 Free Software Foundation\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -124,7 +124,7 @@ void test01()\n   VERIFY( eto_next == e_arr );\n \n   int i = cvt.encoding();\n-  VERIFY( i == 0 );\n+  VERIFY( i == 2 ); // Target-dependent.\n \n   VERIFY( !cvt.always_noconv() );\n \n@@ -210,7 +210,7 @@ void test02()\n   VERIFY( eto_next == e_arr );\n \n   int i = cvt.encoding();\n-  VERIFY( i == 0 );\n+  VERIFY( i == 2 ); // Target-dependent.\n \n   VERIFY( !cvt.always_noconv() );\n "}, {"sha": "45655b7a6011af63ea699b29a257ee40205b3d7a", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_members_wchar_t_char.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_wchar_t_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07814743cf9b934c94d540a7820a3683abacfb38/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_wchar_t_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_wchar_t_char.cc?ref=07814743cf9b934c94d540a7820a3683abacfb38", "patch": "@@ -95,7 +95,7 @@ void test01()\n   VERIFY( eto_next == e_arr );\n \n   int i = cvt->encoding();\n-  VERIFY( i == 0 );\n+  VERIFY( i == 4 ); // Target-dependent.\n \n   VERIFY( !cvt->always_noconv() );\n "}]}