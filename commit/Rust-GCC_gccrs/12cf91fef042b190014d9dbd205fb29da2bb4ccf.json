{"sha": "12cf91fef042b190014d9dbd205fb29da2bb4ccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjZjkxZmVmMDQyYjE5MDAxNGQ5ZGJkMjA1ZmIyOWRhMmJiNGNjZg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-04T04:38:01Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-04T04:38:01Z"}, "message": "cpphash.h (U): New define, to correct type of string constants.\n\ngcc:\n\t* cpphash.h (U): New define, to correct type of string constants.\n\t(ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr): New wrapper\n\troutines, to do casts when passing unsigned strings to libc.\n\t* cppexp.c, cppfiles.c, cpphash.c, cppinit.c, cpplib.c: Use them.\n\n\t* cppfiles.c (_cpp_execute_include): Make filename an U_CHAR *.\n\t* cpphash.c (_cpp_quote_string): Make string an U_CHAR *.\n\t* cppinit.c (dump_special_to_buffer): Make macro name an U_CHAR *.\n\t* cpplex.c (parse_ifdef, parse_include, validate_else): Make\n\tsecond argument an U_CHAR *.\n\n\t* cppinit.c (builtin_array): Make name and value U_CHAR *, add\n\tlength field, clean up initializer.\n\t(ISTABLE): Add __extension__ to designated-\n\tinitializers version.\n\t* cpplex.c (CHARTAB): Likewise.\n\n\t* mbchar.c: Add dummy external declaration to the !MULTIBYTE_CHARS\n\tcase so the file won't be empty.\n\ninclude:\n\t* symcat.h: Remove #endif label.\n\nFrom-SVN: r33657", "tree": {"sha": "32af1382b7b6344ab51affdb8e243e9ecedf4e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32af1382b7b6344ab51affdb8e243e9ecedf4e69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12cf91fef042b190014d9dbd205fb29da2bb4ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cf91fef042b190014d9dbd205fb29da2bb4ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12cf91fef042b190014d9dbd205fb29da2bb4ccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cf91fef042b190014d9dbd205fb29da2bb4ccf/comments", "author": null, "committer": null, "parents": [{"sha": "22a8784041d6222be1e1fbdbb81054d16ed5e092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a8784041d6222be1e1fbdbb81054d16ed5e092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a8784041d6222be1e1fbdbb81054d16ed5e092"}], "stats": {"total": 319, "additions": 199, "deletions": 120}, "files": [{"sha": "eb4ea28cb7e61d2ae21e39d0f92e950eed997012", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -1,3 +1,25 @@\n+2000-05-03  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.h (U): New define, to correct type of string constants.\n+\t(ustrcmp, ustrncmp, ustrlen, uxstrdup, ustrchr): New wrapper\n+\troutines, to do casts when passing unsigned strings to libc.\n+\t* cppexp.c, cppfiles.c, cpphash.c, cppinit.c, cpplib.c: Use them.\n+\n+\t* cppfiles.c (_cpp_execute_include): Make filename an U_CHAR *.\n+\t* cpphash.c (_cpp_quote_string): Make string an U_CHAR *.\n+\t* cppinit.c (dump_special_to_buffer): Make macro name an U_CHAR *.\n+\t* cpplex.c (parse_ifdef, parse_include, validate_else): Make\n+\tsecond argument an U_CHAR *.\n+\n+\t* cppinit.c (builtin_array): Make name and value U_CHAR *, add\n+\tlength field, clean up initializer.\n+\t(ISTABLE): Add __extension__ to designated-\n+\tinitializers version.\n+\t* cpplex.c (CHARTAB): Likewise.\n+\n+\t* mbchar.c: Add dummy external declaration to the !MULTIBYTE_CHARS\n+\tcase so the file won't be empty.\n+\n Wed May  3 21:01:46 2000  Jason Eckhardt  <jle@cygnus.com>\n \n         * bb-reorder.c (struct reorder_block_def): Member succ removed.\n@@ -175,7 +197,6 @@ Wed May  3 12:40:53 2000  Clinton Popetz  <cpopetz@cygnus.com>\n \t* rtl.def (define_insn_and_split): New DEF_RTL_EXPR.\n \t* md.texi (Insn Splitting): Document define_insn_and_split.\n \n->>>>>>> 1.6464\n Tue May  2 00:20:30 2000  Jason Eckhardt  <jle@cygnus.com>\n \n \t* flow.c (verify_flow_info): Added two more sanity checks. The"}, {"sha": "00eaea73aa251e6784be98131e6c10a8d093cbcb", "filename": "gcc/cppexp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -313,7 +313,7 @@ parse_charconst (pfile, start, end)\n   /* If char type is signed, sign-extend the constant.  */\n   num_bits = num_chars * width;\n       \n-  if (cpp_defined (pfile, (const U_CHAR *)\"__CHAR_UNSIGNED__\",\n+  if (cpp_defined (pfile, U\"__CHAR_UNSIGNED__\",\n \t\t   sizeof (\"__CHAR_UNSIGNED__\")-1)\n       || ((result >> (num_bits - 1)) & 1) == 0)\n     op.value = result & ((unsigned HOST_WIDEST_INT) ~0\n@@ -439,7 +439,7 @@ lex (pfile, skip_evaluation)\n       return parse_charconst (pfile, tok_start, tok_end);\n \n     case CPP_NAME:\n-      if (!strncmp (tok_start, \"defined\", 7))\n+      if (!ustrncmp (tok_start, U\"defined\", 7))\n \treturn parse_defined (pfile);\n \n       op.op = INT;"}, {"sha": "395976fa3301a9b2a6bea53118f599f220288d11", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -74,8 +74,8 @@ eq_IHASH (x, y)\n      const void *x;\n      const void *y;\n {\n-  const U_CHAR *a = ((const IHASH *)x)->nshort;\n-  const U_CHAR *b = ((const IHASH *)y)->nshort;\n+  const char *a = ((const IHASH *)x)->nshort;\n+  const char *b = ((const IHASH *)y)->nshort;\n   return !strcmp (a, b);\n }\n \n@@ -132,7 +132,7 @@ redundant_include_p (pfile, ihash, ilist)\n \t return (i->control_macro\n \t\t && (i->control_macro[0] == '\\0'\n \t\t     || cpp_defined (pfile, i->control_macro, \n-\t\t\t\t     strlen (i->control_macro))))\n+\t\t\t\t     ustrlen (i->control_macro))))\n \t     ? (IHASH *)-1 : i;\n \n   return 0;\n@@ -147,7 +147,7 @@ cpp_included (pfile, fname)\n {\n   IHASH dummy, *ptr;\n   dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n   ptr = htab_find_with_hash (pfile->all_include_files,\n \t\t\t     (const void *)&dummy, dummy.hash);\n   return (ptr != NULL);\n@@ -237,7 +237,7 @@ find_include_file (pfile, fname, search_start, ihash, before)\n   char *name;\n \n   dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n   path = (fname[0] == '/') ? ABSOLUTE_PATH : search_start;\n   slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n \t\t\t\t\t      (const void *) &dummy,\n@@ -308,7 +308,7 @@ _cpp_fake_ihash (pfile, fname)\n   IHASH dummy;\n \n   dummy.nshort = fname;\n-  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n   slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n \t\t\t\t\t      (const void *) &dummy,\n \t\t\t\t\t      dummy.hash, INSERT);\n@@ -515,14 +515,15 @@ remap_filename (pfile, name, loc)\n \n \n void\n-_cpp_execute_include (pfile, fname, len, no_reinclude, search_start)\n+_cpp_execute_include (pfile, f, len, no_reinclude, search_start)\n      cpp_reader *pfile;\n-     char *fname;\n+     U_CHAR *f;\n      unsigned int len;\n      int no_reinclude;\n      struct file_name_list *search_start;\n {\n   IHASH *ihash;\n+  char *fname = (char *)f;\n   int fd;\n   int angle_brackets = fname[0] == '<';\n   int before;\n@@ -615,7 +616,7 @@ _cpp_execute_include (pfile, fname, len, no_reinclude, search_start)\n \n   /* Actually process the file.  */\n   if (no_reinclude)\n-    ihash->control_macro = (const U_CHAR *) \"\";\n+    ihash->control_macro = U\"\";\n   \n   if (read_include_file (pfile, fd, ihash))\n     {\n@@ -644,7 +645,7 @@ cpp_read_file (pfile, fname)\n   if (*fname == 0)\n     dummy.hash = 0;\n   else\n-    dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+    dummy.hash = _cpp_calc_hash ((const U_CHAR *)fname, strlen (fname));\n   slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n \t\t\t\t\t      (const void *) &dummy,\n \t\t\t\t\t      dummy.hash, INSERT);\n@@ -743,7 +744,7 @@ read_include_file (pfile, fd, ihash)\n   if (length < 0)\n     goto fail;\n   if (length == 0)\n-    ihash->control_macro = (const U_CHAR *) \"\";  /* never re-include */\n+    ihash->control_macro = U\"\";  /* never re-include */\n \n   close (fd);\n   fp->rlimit = fp->buf + length;"}, {"sha": "49bc1b5b0fc0e13c93f263c59e4ca2b12d371ae4", "filename": "gcc/cpphash.c", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -225,7 +225,7 @@ eq_HASHNODE (x, y)\n   const HASHNODE *b = (const HASHNODE *)y;\n \n   return (a->length == b->length\n-\t  && !strncmp (a->name, b->name, a->length));\n+\t  && !ustrncmp (a->name, b->name, a->length));\n }\n \n /* Destroy a HASHNODE.  */\n@@ -377,7 +377,7 @@ warn_trad_stringify (pfile, p, len, argc, argv)\n \tbreak;\n \n       for (i = 0; i < argc; i++)\n-\tif (!strncmp (p, argv[i].name, argv[i].len)\n+\tif (!ustrncmp (p, argv[i].name, argv[i].len)\n \t    && ! is_idchar (p[argv[i].len]))\n \t  {\n \t    cpp_warning (pfile,\n@@ -416,7 +416,7 @@ trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n \tbreak;\n \n       for (i = 0; i < argc; i++)\n-\tif (!strncmp (p, argv[i].name, argv[i].len)\n+\tif (!ustrncmp (p, argv[i].name, argv[i].len)\n \t    && ! is_idchar (p[argv[i].len]))\n \t  {\n \t    if (CPP_WTRADITIONAL (pfile))\n@@ -618,11 +618,11 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n \t\twarn_trad_stringify (pfile, tok, len, argc, argv);\n \t      goto norm;\n \t    }\n-\t  \n+\n \tcase CPP_NAME:\n \t  for (j = 0; j < argc; j++)\n \t    if (argv[j].len == len\n-\t\t&& !strncmp (tok, argv[j].name, argv[j].len))\n+\t\t&& !ustrncmp (tok, argv[j].name, argv[j].len))\n \t      goto addref;\n \n \t  /* fall through */\n@@ -683,12 +683,12 @@ static int\n duplicate_arg_p (args, new)\n      U_CHAR *args, *new;\n {\n-  size_t newlen = strlen (new) + 1;\n+  size_t newlen = ustrlen (new) + 1;\n   size_t oldlen;\n \n   while (args < new)\n     {\n-      oldlen = strlen (args) + 1;\n+      oldlen = ustrlen (args) + 1;\n       if (!memcmp (args, new, MIN (oldlen, newlen)))\n \treturn 1;\n       args += oldlen;\n@@ -795,7 +795,7 @@ collect_params (pfile, list, arglist)\n \t  }\n \tif (CPP_PEDANTIC (pfile) && CPP_OPTION (pfile, c99)\n \t    && len == sizeof \"__VA_ARGS__\" - 1\n-\t    && !strcmp (p, \"__VA_ARGS__\"))\n+\t    && !ustrcmp (p, U\"__VA_ARGS__\"))\n \t  cpp_pedwarn (pfile,\n \t\"C99 does not permit use of __VA_ARGS__ as a macro argument name\");\n \targv[a].len = len;\n@@ -817,7 +817,7 @@ collect_params (pfile, list, arglist)\n \t    argv[a].len = sizeof \"__VA_ARGS__\" - 1;\n \t    argv[a].name = p;\n \t    argv[a].rest_arg = 1;\n-\t    strcpy (p, \"__VA_ARGS__\");\n+\t    strcpy ((char *)p, \"__VA_ARGS__\");\n \t  }\n \telse\n \t  {\n@@ -868,8 +868,8 @@ _cpp_create_definition (pfile, list, hp)\n     ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n   else if (list->tokens_used == 3 && TOK_TYPE (list, 1) == CPP_NAME\n \t   && TOK_LEN (list, 0) == TOK_LEN (list, 1)\n-\t   && !strncmp (TOK_NAME (list, 0), TOK_NAME (list, 1),\n-\t\t\tTOK_LEN (list, 0)))\n+\t   && !ustrncmp (TOK_NAME (list, 0), TOK_NAME (list, 1),\n+\t\t\t TOK_LEN (list, 0)))\n     ntype = T_IDENTITY;  /* Object like macro defined to itself.  */\n \n   /* The macro is function-like only if the next character,\n@@ -926,8 +926,8 @@ _cpp_create_definition (pfile, list, hp)\n     case T_MACRO:\n       ok = (ntype == hp->type\n \t    && odefn->length == hp->value.odefn->length\n-\t    && !strncmp (odefn->expansion, hp->value.odefn->expansion,\n-\t\t\t odefn->length));\n+\t    && !ustrncmp (odefn->expansion, hp->value.odefn->expansion,\n+\t\t\t  odefn->length));\n       break;\n     case T_FMACRO:\n       ok = (ntype == hp->type\n@@ -1050,7 +1050,7 @@ static const char * const monthnames[] =\n void\n _cpp_quote_string (pfile, src)\n      cpp_reader *pfile;\n-     const char *src;\n+     const U_CHAR *src;\n {\n   U_CHAR c;\n \n@@ -1091,8 +1091,9 @@ special_symbol (pfile, hp)\n      cpp_reader *pfile;\n      HASHNODE *hp;\n {\n-  const char *buf;\n+  const U_CHAR *buf;\n   cpp_buffer *ip;\n+  size_t len;\n \n   switch (hp->type)\n     {\n@@ -1108,8 +1109,9 @@ special_symbol (pfile, hp)\n \twhile (CPP_PREV_BUFFER (ip) != NULL)\n \t  ip = CPP_PREV_BUFFER (ip);\n \n-      buf = ip->nominal_fname;\n-      CPP_RESERVE (pfile, 3 + 4 * strlen (buf));\n+      buf = (const U_CHAR *) ip->nominal_fname;\n+      len = ustrlen (buf);\n+      CPP_RESERVE (pfile, 3 + 4 * len);\n       _cpp_quote_string (pfile, buf);\n       return;\n \n@@ -1124,8 +1126,9 @@ special_symbol (pfile, hp)\n \t  }\n \n \tCPP_RESERVE (pfile, 10);\n-\tsprintf (CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n-\tCPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n+\tsprintf ((char *)CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n+\tlen = ustrlen (CPP_PWRITTEN (pfile));\n+\tCPP_ADJUST_WRITTEN (pfile, len);\n \treturn;\n       }\n \n@@ -1144,7 +1147,8 @@ special_symbol (pfile, hp)\n       if (!buf || *buf == '\\0')\n \treturn;\n \n-      CPP_PUTS (pfile, buf, strlen (buf));\n+      len = ustrlen (buf);\n+      CPP_PUTS (pfile, buf, len);\n       return;\n \n     case T_SPECLINE:\n@@ -1155,8 +1159,9 @@ special_symbol (pfile, hp)\n \t  return;\n \t}\n       CPP_RESERVE (pfile, 10);\n-      sprintf (CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (ip));\n-      CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n+      sprintf ((char *)CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (ip));\n+      len = ustrlen (CPP_PWRITTEN (pfile));\n+      CPP_ADJUST_WRITTEN (pfile, len);\n       return;\n \n     case T_DATE:\n@@ -1231,7 +1236,7 @@ _cpp_macroexpand (pfile, hp)\n     {\n       const U_CHAR *cpval = hp->value.cpval;\n       if (cpval && *cpval != '\\0')\n-\tpush_macro_expansion (pfile, cpval, strlen (cpval), hp);\n+\tpush_macro_expansion (pfile, cpval, ustrlen (cpval), hp);\n       return;\n     }\n \n@@ -1782,7 +1787,7 @@ compare_defs (pfile, d1, d2)\n \n   if (d1->nargs != d2->nargs)\n     return 1;\n-  if (strcmp (d1->expansion, d2->expansion))\n+  if (ustrcmp (d1->expansion, d2->expansion))\n     return 1;\n   if (CPP_PEDANTIC (pfile)\n       && d1->argnames && d2->argnames)\n@@ -1793,8 +1798,8 @@ compare_defs (pfile, d1, d2)\n       int i = d1->nargs;\n       while (i--)\n \t{\n-\t  len = strlen (arg1) + 1;\n-\t  if (strcmp (arg1, arg2))\n+\t  len = ustrlen (arg1) + 1;\n+\t  if (ustrcmp (arg1, arg2))\n \t    return 1;\n \t  arg1 += len;\n \t  arg2 += len;\n@@ -1871,7 +1876,7 @@ dump_funlike_macro (pfile, defn)\n   for (i = 0; i < defn->nargs; i++)\n     {\n       argv[i] = x;\n-      argl[i] = strlen (x);\n+      argl[i] = ustrlen (x);\n       x += argl[i] + 1;\n     }\n       \n@@ -1881,7 +1886,7 @@ dump_funlike_macro (pfile, defn)\n     {\n       CPP_RESERVE (pfile, argl[i] + 2);\n       if (!(i == defn->nargs-1 && defn->rest_args\n-\t    && !strcmp (argv[i], \"__VA_ARGS__\")))\n+\t    && !ustrcmp (argv[i], U\"__VA_ARGS__\")))\n \tCPP_PUTS_Q (pfile, argv[i], argl[i]);\n       if (i < defn->nargs-1)\n \tCPP_PUTS_Q (pfile, \", \", 2);"}, {"sha": "3c9ae38ce6cf3844caa6652a838bb3439cdb14b6", "filename": "gcc/cpphash.h", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -23,6 +23,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define __GCC_CPPHASH__\n \n typedef unsigned char U_CHAR;\n+#define U (const U_CHAR *)  /* Intended use: U\"string\" */\n \n /* The structure of a node in the hash table.  The hash table\n    has entries for all tokens defined by #define commands (type T_MACRO),\n@@ -60,7 +61,7 @@ struct hashnode\n   char disabled;\t\t\t/* macro turned off for rescan? */\n \n   union {\n-    const char *cpval;\t\t\t/* some predefined macros */\n+    const U_CHAR *cpval;\t\t/* some predefined macros */\n     const struct object_defn *odefn;\t/* #define foo bar */\n     const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n     struct hashnode *aschain;\t\t/* #assert */\n@@ -217,14 +218,14 @@ extern void _cpp_free_definition\tPARAMS ((HASHNODE *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t cpp_toklist *, HASHNODE *));\n extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, HASHNODE *));\n-extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const char *));\n+extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, HASHNODE *));\n extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n-extern void _cpp_execute_include\tPARAMS ((cpp_reader *, char *,\n+extern void _cpp_execute_include\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t unsigned int, int,\n \t\t\t\t\t\t struct file_name_list *));\n extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n@@ -254,6 +255,43 @@ extern void _cpp_scan_line\t\tPARAMS ((cpp_reader *, cpp_toklist *));\n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n extern void _cpp_unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n-extern void _cpp_check_directive        PARAMS((cpp_toklist *, cpp_token *));\n+extern void _cpp_check_directive        PARAMS ((cpp_toklist *, cpp_token *));\n+\n+/* These are inline functions (if __GNUC__) instead of macros so we\n+   can get type checking.  */\n+#if GCC_VERSION >= 2007 && defined __OPTIMIZE__\n+extern inline int ustrcmp (const U_CHAR *, const U_CHAR *);\n+extern inline int ustrncmp (const U_CHAR *, const U_CHAR *, size_t);\n+extern inline size_t ustrlen (const U_CHAR *);\n+extern inline U_CHAR *uxstrdup (const U_CHAR *);\n+extern inline U_CHAR *ustrchr (const U_CHAR *, int);\n+\n+extern inline int\n+ustrcmp (const U_CHAR *s1, const U_CHAR *s2)\n+{ return strcmp ((const char *)s1, (const char *)s2); }\n+\n+extern inline int\n+ustrncmp (const U_CHAR *s1, const U_CHAR *s2, size_t n)\n+{ return strncmp ((const char *)s1, (const char *)s2, n); }\n+\n+extern inline size_t\n+ustrlen (const U_CHAR *s1)\n+{ return strlen ((const char *)s1); }\n+\n+extern inline U_CHAR *\n+uxstrdup (const U_CHAR *s1)\n+{ return (U_CHAR *) xstrdup ((const char *)s1); }\n+\n+extern inline U_CHAR *\n+ustrchr (const U_CHAR *s1, int c)\n+{ return (U_CHAR *) strchr ((const char *)s1, c); }\n+\n+#else\n+#define ustrcmp(s1_, s2_) strcmp((const char *)s1_, (const char *)s2_)\n+#define ustrncmp(s1_, s2_, n_) strncmp((const char *)s1_, (const char *)s2_, n_)\n+#define ustrlen(s1_) strlen((const char *)s1_)\n+#define uxstrdup(s1_) (U_CHAR *) xstrdup((const char *)s1_)\n+#define ustrchr(s1_, c_) (U_CHAR *) strchr((const char *)s1_, c_)\n+#endif\n \n #endif"}, {"sha": "3f477360c850659027d883fc03daa9465586e2e9", "filename": "gcc/cppinit.c", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -214,7 +214,8 @@ static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t char *, int, int));\n static void merge_include_chains\tPARAMS ((cpp_reader *));\n \n-static void dump_special_to_buffer\tPARAMS ((cpp_reader *, const char *));\n+static void dump_special_to_buffer\tPARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t\t size_t));\n static void initialize_dependency_output PARAMS ((cpp_reader *));\n static void initialize_standard_includes PARAMS ((cpp_reader *));\n static void new_pending_directive\t\tPARAMS ((struct cpp_pending *,\n@@ -229,13 +230,13 @@ static int handle_option\t\tPARAMS ((cpp_reader *, int, char **));\n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n \n-/* If we have designated initializers (GCC >2.7, or C99) this table\n-   can be initialized, constant data.  Otherwise, it has to be filled\n-   in at runtime.  */\n+/* If we have designated initializers (GCC >2.7) this table can be\n+   initialized, constant data.  Otherwise, it has to be filled in at\n+   runtime.  */\n \n-#if (GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L)\n+#if (GCC_VERSION >= 2007)\n #define init_IStable()  /* nothing */\n-#define ISTABLE const unsigned char _cpp_IStable[256] = {\n+#define ISTABLE __extension__ const unsigned char _cpp_IStable[256] = {\n #define END };\n #define s(p, v) [p] = v,\n #else\n@@ -514,17 +515,17 @@ merge_include_chains (pfile)\n    to PFILE's token_buffer.  */\n \n static void\n-dump_special_to_buffer (pfile, macro_name)\n+dump_special_to_buffer (pfile, macro_name, macro_len)\n      cpp_reader *pfile;\n-     const char *macro_name;\n+     const U_CHAR *macro_name;\n+     size_t macro_len;\n {\n   static const char define_directive[] = \"#define \";\n-  int macro_name_length = strlen (macro_name);\n-  CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n+  CPP_RESERVE (pfile, sizeof(define_directive) + macro_len);\n   CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n-  CPP_PUTS_Q (pfile, macro_name, macro_name_length);\n+  CPP_PUTS_Q (pfile, macro_name, macro_len);\n   CPP_PUTC_Q (pfile, ' ');\n-  _cpp_expand_to_buffer (pfile, macro_name, macro_name_length);\n+  _cpp_expand_to_buffer (pfile, macro_name, macro_len);\n   CPP_PUTC (pfile, '\\n');\n }\n \n@@ -617,39 +618,46 @@ cpp_cleanup (pfile)\n \n struct builtin\n {\n-  const char *name;\n-  const char *value;\n+  const U_CHAR *name;\n+  const U_CHAR *value;\n   unsigned short type;\n   unsigned short flags;\n+  unsigned int len;\n };\n #define DUMP 0x01\n #define VERS 0x02\n #define ULP  0x04\n \n+#define B(n, t)       { U n,   0, t,       0,      sizeof n - 1 }\n+#define C(n, v)       { U n, U v, T_CONST, DUMP,   sizeof n - 1 }\n+#define X(n, v, t, f) { U n, U v, t,       DUMP|f, sizeof n - 1 }\n static const struct builtin builtin_array[] =\n {\n-  { \"__TIME__\",\t\t\t0, T_TIME,\t\t0 },\n-  { \"__DATE__\",\t\t\t0, T_DATE,\t\t0 },\n-  { \"__FILE__\",\t\t\t0, T_FILE,\t\t0 },\n-  { \"__BASE_FILE__\",\t\t0, T_BASE_FILE,\t\t0 },\n-  { \"__LINE__\",\t\t\t0, T_SPECLINE,\t\t0 },\n-  { \"__INCLUDE_LEVEL__\",\t0, T_INCLUDE_LEVEL,\t0 },\n-\n-  { \"__VERSION__\",\t\t0,\t\t T_XCONST, DUMP|VERS },\n-  { \"__USER_LABEL_PREFIX__\",\t0,\t\t T_CONST,  DUMP|ULP  },\n-  { \"__STDC__\",\t\t\t\"1\",\t\t T_STDC,   DUMP },\n-  { \"__REGISTER_PREFIX__\",\tREGISTER_PREFIX, T_CONST,  DUMP },\n-  { \"__HAVE_BUILTIN_SETJMP__\",\t\"1\",\t\t T_CONST,  DUMP },\n+  B(\"__TIME__\",\t\t T_TIME),\n+  B(\"__DATE__\",\t\t T_DATE),\n+  B(\"__FILE__\",\t\t T_FILE),\n+  B(\"__BASE_FILE__\",\t T_BASE_FILE),\n+  B(\"__LINE__\",\t\t T_SPECLINE),\n+  B(\"__INCLUDE_LEVEL__\", T_INCLUDE_LEVEL),\n+\n+  X(\"__VERSION__\",\t\t0,   T_XCONST, VERS),\n+  X(\"__USER_LABEL_PREFIX__\",\t0,   T_CONST,  ULP),\n+  X(\"__STDC__\",\t\t\t\"1\", T_STDC,   0),\n+  C(\"__REGISTER_PREFIX__\",\tREGISTER_PREFIX),\n+  C(\"__HAVE_BUILTIN_SETJMP__\",\t\"1\"),\n #ifndef NO_BUILTIN_SIZE_TYPE\n-  { \"__SIZE_TYPE__\",\t\tSIZE_TYPE,\t T_CONST,  DUMP },\n+  C(\"__SIZE_TYPE__\",\t\tSIZE_TYPE),\n #endif\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-  { \"__PTRDIFF_TYPE__\",\t\tPTRDIFF_TYPE,\t T_CONST,  DUMP },\n+  C(\"__PTRDIFF_TYPE__\",\t\tPTRDIFF_TYPE),\n #endif\n #ifndef NO_BUILTIN_WCHAR_TYPE\n-  { \"__WCHAR_TYPE__\",\t\tWCHAR_TYPE,\t T_CONST,  DUMP },\n+  C(\"__WCHAR_TYPE__\",\t\tWCHAR_TYPE),\n #endif\n };\n+#undef B\n+#undef C\n+#undef X\n #define builtin_array_end \\\n  builtin_array + sizeof(builtin_array)/sizeof(struct builtin)\n \n@@ -659,32 +667,30 @@ static void\n initialize_builtins (pfile)\n      cpp_reader *pfile;\n {\n-  int len;\n   const struct builtin *b;\n-  const char *val;\n+  const U_CHAR *val;\n   HASHNODE *hp;\n   for(b = builtin_array; b < builtin_array_end; b++)\n     {\n       if (b->type == T_STDC && CPP_TRADITIONAL (pfile))\n \tcontinue;\n \n       if (b->flags & ULP)\n-\tval = user_label_prefix;\n+\tval = (const U_CHAR *) user_label_prefix;\n       else if (b->flags & VERS)\n \t{\n-\t  val = xmalloc (strlen (version_string) + 3);\n+\t  val = (const U_CHAR *) xmalloc (strlen (version_string) + 3);\n \t  sprintf ((char *)val, \"\\\"%s\\\"\", version_string);\n \t}\n       else\n \tval = b->value;\n \n-      len = strlen (b->name);\n-      hp = _cpp_lookup (pfile, b->name, len);\n+      hp = _cpp_lookup (pfile, b->name, b->len);\n       hp->value.cpval = val;\n       hp->type = b->type;\n \n       if ((b->flags & DUMP) && CPP_OPTION (pfile, debug_output))\n-\tdump_special_to_buffer (pfile, b->name);\n+\tdump_special_to_buffer (pfile, b->name, b->len);\n     }\n }\n #undef DUMP"}, {"sha": "9e068a3203d33aaea0dcf7257b824f4c0d4d5cb9", "filename": "gcc/cpplex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -1720,13 +1720,13 @@ find_position (start, limit, linep)\n #define UCHAR_MAX 255\t/* assume 8-bit bytes */\n #endif\n \n-#if (GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L)\n+#if (GCC_VERSION >= 2007)\n #define init_chartab()  /* nothing */\n-#define CHARTAB static const unsigned char chartab[UCHAR_MAX + 1] = {\n+#define CHARTAB __extension__ static const U_CHAR chartab[UCHAR_MAX + 1] = {\n #define END };\n #define s(p, v) [p] = v,\n #else\n-#define CHARTAB static unsigned char chartab[UCHAR_MAX + 1] = { 0 }; \\\n+#define CHARTAB static U_CHAR chartab[UCHAR_MAX + 1] = { 0 }; \\\n  static void init_chartab PARAMS ((void)) { \\\n  unsigned char *x = chartab;\n #define END }"}, {"sha": "ae5e2c0a1c332bf8a5e16e53a937b55918ced3e8", "filename": "gcc/cpplib.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -32,7 +32,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n struct directive\n {\n   directive_handler func;\t/* Function to handle directive.  */\n-  const char *name;\t\t/* Name of directive.  */\n+  const U_CHAR *name;\t\t/* Name of directive.  */\n   unsigned short length;\t/* Length of name.  */\n   unsigned short flags;\t        /* Flags describing this directive.  */\n };\n@@ -52,9 +52,9 @@ typedef struct if_stack IF_STACK;\n \n /* Forward declarations.  */\n \n-static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n-static int parse_ifdef\t\t\tPARAMS ((cpp_reader *, const char *));\n-static unsigned int parse_include\tPARAMS ((cpp_reader *, const char *));\n+static void validate_else\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static int parse_ifdef\t\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n+static unsigned int parse_include\tPARAMS ((cpp_reader *, const U_CHAR *));\n static int conditional_skip\t\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t\t U_CHAR *));\n static int skip_if_group\t\tPARAMS ((cpp_reader *));\n@@ -140,7 +140,8 @@ enum\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n #define D(name, t, flags) \\\n-{ CONCAT2(do_,name), STRINGX(name), sizeof STRINGX(name) - 1, flags },\n+{ CONCAT2(do_,name), (const U_CHAR *) STRINGX(name), \\\n+  sizeof STRINGX(name) - 1, flags },\n static const struct directive dtable[] =\n {\n DIRECTIVE_TABLE\n@@ -155,15 +156,15 @@ _cpp_check_directive (list, token)\n      cpp_toklist *list;\n      cpp_token *token;\n {\n-  const char *name = list->namebuf + token->val.name.offset;\n+  const U_CHAR *name = list->namebuf + token->val.name.offset;\n   size_t len = token->val.name.len;\n   unsigned int i;\n \n   list->dir_handler = 0;\n   list->dir_flags = 0;\n \n   for (i = 0; i < N_DIRECTIVES; i++)\n-    if (dtable[i].length == len && !strncmp (dtable[i].name, name, len)) \n+    if (dtable[i].length == len && !ustrncmp (dtable[i].name, name, len)) \n       {\n \tlist->dir_handler = dtable[i].func;\n \tlist->dir_flags = dtable[i].flags;\n@@ -237,7 +238,7 @@ _cpp_handle_directive (pfile)\n       for (i = 0; i < N_DIRECTIVES; i++)\n \t{\n \t  if (dtable[i].length == len\n-\t      && !strncmp (dtable[i].name, ident, len)) \n+\t      && !ustrncmp (dtable[i].name, ident, len)) \n \t    goto real_directive;\n \t}\n       /* Don't complain about invalid directives in assembly source,\n@@ -361,7 +362,7 @@ do_define (pfile)\n \n   /* That NAME is not allowed to be \"defined\".  (Not clear if the\n      standard requires this.)  */\n-  if (len == 7 && !strncmp (sym, \"defined\", 7))\n+  if (len == 7 && !ustrncmp (sym, U\"defined\", 7))\n     {\n       cpp_error_with_line (pfile, list->line, TOK_COL (list, 0),\n \t\t\t   \"\\\"defined\\\" is not a legal macro name\");\n@@ -398,7 +399,7 @@ do_define (pfile)\n static unsigned int\n parse_include (pfile, name)\n      cpp_reader *pfile;\n-     const char *name;\n+     const U_CHAR *name;\n {\n   long old_written = CPP_WRITTEN (pfile);\n   enum cpp_ttype token;\n@@ -457,12 +458,12 @@ do_include (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  char *token;\n+  U_CHAR *token;\n \n   len = parse_include (pfile, dtable[T_INCLUDE].name);\n   if (len == 0)\n     return 0;\n-  token = alloca (len + 1);\n+  token = (U_CHAR *) alloca (len + 1);\n   memcpy (token, CPP_PWRITTEN (pfile), len);\n   token[len] = '\\0';\n   \n@@ -478,7 +479,7 @@ do_import (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  char *token;\n+  U_CHAR *token;\n \n   if (CPP_OPTION (pfile, warn_import)\n       && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n@@ -491,7 +492,7 @@ do_import (pfile)\n   len = parse_include (pfile, dtable[T_IMPORT].name);\n   if (len == 0)\n     return 0;\n-  token = alloca (len + 1);\n+  token = (U_CHAR *) alloca (len + 1);\n   memcpy (token, CPP_PWRITTEN (pfile), len);\n   token[len] = '\\0';\n   \n@@ -507,13 +508,13 @@ do_include_next (pfile)\n      cpp_reader *pfile;\n {\n   unsigned int len;\n-  char *token;\n+  U_CHAR *token;\n   struct file_name_list *search_start = 0;\n \n   len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name);\n   if (len == 0)\n     return 0;\n-  token = alloca (len + 1);\n+  token = (U_CHAR *) alloca (len + 1);\n   memcpy (token, CPP_PWRITTEN (pfile), len);\n   token[len] = '\\0';\n   \n@@ -590,7 +591,8 @@ do_line (pfile)\n     }\n \n   CPP_PUTC (pfile, '\\0');  /* not terminated for us */\n-  new_lineno = strtoul (pfile->token_buffer + old_written, &x, 10);\n+  new_lineno = strtoul ((const char *) (pfile->token_buffer + old_written),\n+\t\t\t&x, 10);\n   if (x[0] != '\\0')\n     {\n       cpp_error (pfile, \"token after `#line' is not an integer\");\n@@ -643,12 +645,12 @@ do_line (pfile)\n       \n       *end_name = '\\0';\n       \n-      if (strcmp (fname, ip->nominal_fname))\n+      if (strcmp ((const char *)fname, ip->nominal_fname))\n \t{\n-\t  if (!strcmp (fname, ip->ihash->name))\n+\t  if (!strcmp ((const char *)fname, ip->ihash->name))\n \t    ip->nominal_fname = ip->ihash->name;\n \t  else\n-\t    ip->nominal_fname = _cpp_fake_ihash (pfile, fname);\n+\t    ip->nominal_fname = _cpp_fake_ihash (pfile, (const char *)fname);\n \t}\n     }\n   else if (token != CPP_VSPACE && token != CPP_EOF)\n@@ -888,7 +890,7 @@ do_pragma_once (pfile)\n   if (CPP_PREV_BUFFER (ip) == NULL)\n     cpp_warning (pfile, \"`#pragma once' outside include file\");\n   else\n-    ip->ihash->control_macro = (const U_CHAR *) \"\";  /* never repeat */\n+    ip->ihash->control_macro = U\"\";  /* never repeat */\n \n   return 1;\n }\n@@ -902,7 +904,7 @@ do_pragma_implementation (pfile)\n   enum cpp_ttype token;\n   long written = CPP_WRITTEN (pfile);\n   U_CHAR *name;\n-  U_CHAR *copy;\n+  char *copy;\n   size_t len;\n \n   token = _cpp_get_directive_token (pfile);\n@@ -917,7 +919,7 @@ do_pragma_implementation (pfile)\n   /* Trim the leading and trailing quote marks from the string.  */\n   name = pfile->token_buffer + written + 1;\n   len = CPP_PWRITTEN (pfile) - name;\n-  copy = (U_CHAR *) alloca (len);\n+  copy = alloca (len);\n   memcpy (copy, name, len - 1);\n   copy[len - 1] = '\\0';\n   \n@@ -1026,7 +1028,7 @@ detect_if_not_defined (pfile)\n   token = _cpp_get_directive_token (pfile);\n   if (token != CPP_NAME)\n     goto restore;\n-  if (strncmp (pfile->token_buffer + token_offset, \"defined\", 7))\n+  if (ustrncmp (pfile->token_buffer + token_offset, U\"defined\", 7))\n     goto restore;\n \n   /* ...then an optional '(' and the name, */\n@@ -1122,7 +1124,7 @@ do_elif (pfile)\n static int\n parse_ifdef (pfile, name)\n      cpp_reader *pfile;\n-     const char *name;\n+     const U_CHAR *name;\n {\n   U_CHAR *ident;\n   unsigned int len;\n@@ -1194,7 +1196,7 @@ do_ifndef (pfile)\n   skip = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n \n   if (start_of_file && !skip)\n-    control_macro = (U_CHAR *) xstrdup (CPP_PWRITTEN (pfile));\n+    control_macro = uxstrdup (CPP_PWRITTEN (pfile));\n \n   return conditional_skip (pfile, skip, T_IFNDEF, control_macro);\n }\n@@ -1256,7 +1258,7 @@ consider_directive_while_skipping (pfile, stack)\n   for (i = 0; i < N_DIRECTIVES; i++)\n     {\n       if (dtable[i].length == len\n-\t  && !strncmp (dtable[i].name, pfile->token_buffer + ident, len)) \n+\t  && !ustrncmp (dtable[i].name, pfile->token_buffer + ident, len)) \n \tgoto real_directive;\n     }\n   return 0;\n@@ -1446,7 +1448,7 @@ do_endif (pfile)\n static void\n validate_else (pfile, directive)\n      cpp_reader *pfile;\n-     const char *directive;\n+     const U_CHAR *directive;\n {\n   long old_written;\n   if (! CPP_PEDANTIC (pfile))\n@@ -1520,7 +1522,7 @@ do_assert (pfile)\n       goto error;\n     }\n       \n-  blen = (U_CHAR *) strchr (sym, '(') - sym;\n+  blen = ustrchr (sym, '(') - sym;\n   base = _cpp_lookup (pfile, sym, blen);\n   if (base->type == T_VOID)\n     {\n@@ -1581,7 +1583,7 @@ do_unassert (pfile)\n     }\n   else\n     {\n-      baselen = (U_CHAR *) strchr (sym, '(') - sym;\n+      baselen = ustrchr (sym, '(') - sym;\n       base = _cpp_lookup (pfile, sym, baselen);\n       if (base->type == T_VOID) goto out;\n       this = _cpp_lookup (pfile, sym, thislen);\n@@ -1644,7 +1646,7 @@ cpp_define (pfile, str)\n       strcpy (&buf[count-4], \" 1\\n\");\n     }\n \n-  if (cpp_push_buffer (pfile, buf, count - 1) != NULL)\n+  if (cpp_push_buffer (pfile, (U_CHAR *)buf, count - 1) != NULL)\n     {\n       do_define (pfile);\n       cpp_pop_buffer (pfile);\n@@ -1663,7 +1665,7 @@ cpp_undef (pfile, macro)\n   memcpy (buf, macro, len);\n   buf[len]     = '\\n';\n   buf[len + 1] = '\\0';\n-  if (cpp_push_buffer (pfile, buf, len + 1) != NULL)\n+  if (cpp_push_buffer (pfile, (U_CHAR *)buf, len + 1) != NULL)\n     {\n       do_undef (pfile);\n       cpp_pop_buffer (pfile);\n@@ -1676,7 +1678,7 @@ cpp_assert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n+  if (cpp_push_buffer (pfile, (const U_CHAR *)str, strlen (str)) != NULL)\n     {\n       do_assert (pfile);\n       cpp_pop_buffer (pfile);\n@@ -1689,7 +1691,7 @@ cpp_unassert (pfile, str)\n      cpp_reader *pfile;\n      const char *str;\n {\n-  if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n+  if (cpp_push_buffer (pfile, (const U_CHAR *)str, strlen (str)) != NULL)\n     {\n       do_unassert (pfile);\n       cpp_pop_buffer (pfile);"}, {"sha": "71cc99c230a25069409ac8e0193313d13fb95863", "filename": "gcc/mbchar.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fmbchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/gcc%2Fmbchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.c?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -329,4 +329,6 @@ local_mb_cur_max ()\n   return 1; /* default */\n #endif\n }\n+#else  /* MULTIBYTE_CHARS */\n+extern int dummy;  /* silence 'ANSI C forbids an empty source file' warning */\n #endif /* MULTIBYTE_CHARS */"}, {"sha": "1329b0fce7231654c5897fe29add6eaf1fe9eba7", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -1,3 +1,7 @@\n+2000-05-03  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* symcat.h: Remove #endif label.\n+\n 2000-04-28  Kenneth Block  <block@zk3.dec.com>\n \t    Jason Merrill  <jason@casey.cygnus.com>\n "}, {"sha": "ed4c00e10d355b2501dc3fda4fb9ba49d02f2d1f", "filename": "include/symcat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf91fef042b190014d9dbd205fb29da2bb4ccf/include%2Fsymcat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf91fef042b190014d9dbd205fb29da2bb4ccf/include%2Fsymcat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsymcat.h?ref=12cf91fef042b190014d9dbd205fb29da2bb4ccf", "patch": "@@ -46,4 +46,4 @@\n    to \"foo\".  */\n #define XSTRING(s) STRINGX(s) \n \n-#endif SYM_CAT_H\n+#endif"}]}