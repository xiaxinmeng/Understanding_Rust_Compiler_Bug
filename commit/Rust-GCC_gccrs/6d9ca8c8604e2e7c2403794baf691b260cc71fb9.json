{"sha": "6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ5Y2E4Yzg2MDRlMmU3YzI0MDM3OTRiYWY2OTFiMjYwY2M3MWZiOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-28T11:07:18Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-09T20:58:13Z"}, "message": "analyzer: reimplement on_transition in terms of get_state/set_next_state\n\nThis patch is further preliminary work towards generalizing sm-malloc.cc\nbeyond just malloc/free.\n\nReimplement sm_context's on_transition vfunc in terms of new get_state\nand set_next_state vfuncs, so that in followup patches we can implement\nricher transitions (e.g. where the states are parametrized by\nallocator).\n\ngcc/analyzer/ChangeLog:\n\t* diagnostic-manager.cc\n\t(null_assignment_sm_context::null_assignment_sm_context): Add old_state\n\tand ext_state params, initializing m_old_state and m_ext_state.\n\t(null_assignment_sm_context::on_transition): Split into...\n\t(null_assignment_sm_context::get_state): ...this new vfunc\n\timplementation and...\n\t(null_assignment_sm_context::set_next_state): ...this new vfunc\n\timplementation.\n\t(null_assignment_sm_context::m_old_state): New field.\n\t(null_assignment_sm_context::m_ext_state): New field.\n\t(diagnostic_manager::add_events_for_eedge): Pass in old state and\n\text_state when creating sm_ctxt.\n\t* engine.cc (impl_sm_context::on_transition): Split into...\n\t(impl_sm_context::get_state): ...this new vfunc\n\timplementation and...\n\t(impl_sm_context::set_next_state): ...this new vfunc\n\timplementation.\n\t* sm.h (sm_context::get_state): New pure virtual function.\n\t(sm_context::set_next_state): Likewise.\n\t(sm_context::on_transition): Convert from a pure virtual function\n\tto a regular function implemented in terms of get_state and\n\tset_next_state.", "tree": {"sha": "542b2ef585bc007f0cacb7ad6145a0e66659ebe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/542b2ef585bc007f0cacb7ad6145a0e66659ebe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10fc42a8396072912e9d9d940fba25950b3fdfc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10fc42a8396072912e9d9d940fba25950b3fdfc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10fc42a8396072912e9d9d940fba25950b3fdfc5"}], "stats": {"total": 113, "additions": 80, "deletions": 33}, "files": [{"sha": "6fd15c21962b43ea5ee58321b109332d64fb9643", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "patch": "@@ -754,12 +754,15 @@ struct null_assignment_sm_context : public sm_context\n {\n   null_assignment_sm_context (int sm_idx,\n \t\t\t      const state_machine &sm,\n+\t\t\t      const program_state *old_state,\n \t\t\t      const program_state *new_state,\n \t\t\t      const gimple *stmt,\n \t\t\t      const program_point *point,\n-\t\t\t      checker_path *emission_path)\n-  : sm_context (sm_idx, sm), m_new_state (new_state),\n-    m_stmt (stmt), m_point (point), m_emission_path (emission_path)\n+\t\t\t      checker_path *emission_path,\n+\t\t\t      const extrinsic_state &ext_state)\n+  : sm_context (sm_idx, sm), m_old_state (old_state), m_new_state (new_state),\n+    m_stmt (stmt), m_point (point), m_emission_path (emission_path),\n+    m_ext_state (ext_state)\n   {\n   }\n \n@@ -768,13 +771,25 @@ struct null_assignment_sm_context : public sm_context\n     return NULL_TREE;\n   }\n \n-  void on_transition (const supernode *node ATTRIBUTE_UNUSED,\n-\t\t      const gimple *stmt ATTRIBUTE_UNUSED,\n-\t\t      tree var,\n-\t\t      state_machine::state_t from,\n-\t\t      state_machine::state_t to,\n-\t\t      tree origin ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  state_machine::state_t get_state (const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t    tree var) FINAL OVERRIDE\n   {\n+    const svalue *var_old_sval\n+      = m_old_state->m_region_model->get_rvalue (var, NULL);\n+    const sm_state_map *old_smap = m_old_state->m_checker_states[m_sm_idx];\n+\n+    state_machine::state_t current\n+      = old_smap->get_state (var_old_sval, m_ext_state);\n+\n+    return current;\n+  }\n+\n+  void set_next_state (const gimple *stmt,\n+\t\t       tree var,\n+\t\t       state_machine::state_t to,\n+\t\t       tree origin ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+    state_machine::state_t from = get_state (stmt, var);\n     if (from != m_sm.get_start_state ())\n       return;\n \n@@ -791,7 +806,6 @@ struct null_assignment_sm_context : public sm_context\n \t\t\t\t\t\t\tfrom, to,\n \t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t*m_new_state));\n-\n   }\n \n   void warn_for_state (const supernode *, const gimple *,\n@@ -833,11 +847,13 @@ struct null_assignment_sm_context : public sm_context\n     return NULL_TREE;\n   }\n \n+  const program_state *m_old_state;\n   const program_state *m_new_state;\n   const gimple *m_stmt;\n   const program_point *m_point;\n   state_change_visitor *m_visitor;\n   checker_path *m_emission_path;\n+  const extrinsic_state &m_ext_state;\n };\n \n /* Subroutine of diagnostic_manager::build_emission_path.\n@@ -943,15 +959,18 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n \t\tif (const gassign *assign = dyn_cast<const gassign *> (stmt))\n \t\t  {\n \t\t    const extrinsic_state &ext_state = pb.get_ext_state ();\n+\t\t    program_state old_state (iter_state);\n \t\t    iter_state.m_region_model->on_assignment (assign, NULL);\n \t\t    for (unsigned i = 0; i < ext_state.get_num_checkers (); i++)\n \t\t      {\n \t\t\tconst state_machine &sm = ext_state.get_sm (i);\n \t\t\tnull_assignment_sm_context sm_ctxt (i, sm,\n+\t\t\t\t\t\t\t    &old_state,\n \t\t\t\t\t\t\t    &iter_state,\n \t\t\t\t\t\t\t    stmt,\n \t\t\t\t\t\t\t    &iter_point,\n-\t\t\t\t\t\t\t    emission_path);\n+\t\t\t\t\t\t\t    emission_path,\n+\t\t\t\t\t\t\t    pb.get_ext_state ());\n \t\t\tsm.on_stmt (&sm_ctxt, dst_point.get_supernode (), stmt);\n \t\t\t// TODO: what about phi nodes?\n \t\t      }"}, {"sha": "07b1b15d195e2026095a2ae8030bbb7a06acba91", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "patch": "@@ -205,12 +205,26 @@ class impl_sm_context : public sm_context\n     return model->get_fndecl_for_call (call, &old_ctxt);\n   }\n \n-  void on_transition (const supernode *node  ATTRIBUTE_UNUSED,\n-\t\t      const gimple *stmt,\n-\t\t      tree var,\n-\t\t      state_machine::state_t from,\n-\t\t      state_machine::state_t to,\n-\t\t      tree origin) FINAL OVERRIDE\n+  state_machine::state_t get_state (const gimple *stmt,\n+\t\t\t\t    tree var)\n+  {\n+    logger * const logger = get_logger ();\n+    LOG_FUNC (logger);\n+    impl_region_model_context old_ctxt\n+      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n+       stmt);\n+    const svalue *var_old_sval\n+      = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n+\n+    state_machine::state_t current\n+      = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n+    return current;\n+  }\n+\n+  void set_next_state (const gimple *stmt,\n+\t\t       tree var,\n+\t\t       state_machine::state_t to,\n+\t\t       tree origin)\n   {\n     logger * const logger = get_logger ();\n     LOG_FUNC (logger);\n@@ -230,17 +244,14 @@ class impl_sm_context : public sm_context\n \n     state_machine::state_t current\n       = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n-    if (current == from)\n-      {\n-\tif (logger)\n-\t  logger->log (\"%s: state transition of %qE: %s -> %s\",\n-\t\t       m_sm.get_name (),\n-\t\t       var,\n-\t\t       from->get_name (),\n-\t\t       to->get_name ());\n-\tm_new_smap->set_state (m_new_state->m_region_model, var_new_sval,\n-\t\t\t       to, origin_new_sval, m_eg.get_ext_state ());\n-      }\n+    if (logger)\n+      logger->log (\"%s: state transition of %qE: %s -> %s\",\n+\t\t   m_sm.get_name (),\n+\t\t   var,\n+\t\t   current->get_name (),\n+\t\t   to->get_name ());\n+    m_new_smap->set_state (m_new_state->m_region_model, var_new_sval,\n+\t\t\t   to, origin_new_sval, m_eg.get_ext_state ());\n   }\n \n   void warn_for_state (const supernode *snode, const gimple *stmt,"}, {"sha": "c5071464994f009d5e5579186adf5393bd7e93d1", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9ca8c8604e2e7c2403794baf691b260cc71fb9/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=6d9ca8c8604e2e7c2403794baf691b260cc71fb9", "patch": "@@ -170,15 +170,32 @@ class sm_context\n      other callback handling.  */\n   virtual tree get_fndecl_for_call (const gcall *call) = 0;\n \n+  /* Get the old state of VAR at STMT.  */\n+  virtual state_machine::state_t get_state (const gimple *stmt,\n+\t\t\t\t\t    tree var) = 0;\n+  /* Set the next state of VAR to be TO, recording the \"origin\" of the\n+     state as ORIGIN.\n+     Use STMT for location information.  */\n+  virtual void set_next_state (const gimple *stmt,\n+\t\t\t       tree var,\n+\t\t\t       state_machine::state_t to,\n+\t\t\t       tree origin = NULL_TREE) = 0;\n+\n   /* Called by state_machine in response to pattern matches:\n      if VAR is in state FROM, transition it to state TO, potentially\n      recording the \"origin\" of the state as ORIGIN.\n      Use NODE and STMT for location information.  */\n-   virtual void on_transition (const supernode *node, const gimple *stmt,\n-\t\t\t      tree var,\n-\t\t\t      state_machine::state_t from,\n-\t\t\t      state_machine::state_t to,\n-\t\t\t      tree origin = NULL_TREE) = 0;\n+  void on_transition (const supernode *node ATTRIBUTE_UNUSED,\n+\t\t      const gimple *stmt,\n+\t\t      tree var,\n+\t\t      state_machine::state_t from,\n+\t\t      state_machine::state_t to,\n+\t\t      tree origin = NULL_TREE)\n+  {\n+    state_machine::state_t current = get_state (stmt, var);\n+    if (current == from)\n+      set_next_state (stmt, var, to, origin);\n+  }\n \n   /* Called by state_machine in response to pattern matches:\n      issue a diagnostic D if VAR is in state STATE, using NODE and STMT"}]}