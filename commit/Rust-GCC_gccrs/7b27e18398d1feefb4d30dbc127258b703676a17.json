{"sha": "7b27e18398d1feefb4d30dbc127258b703676a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IyN2UxODM5OGQxZmVlZmI0ZDMwZGJjMTI3MjU4YjcwMzY3NmExNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:30:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:30:10Z"}, "message": "[multiple changes]\n\n2014-02-25  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Update \"Standard Library Routines\" chapter to\n\tinclude all 2012 packages.\n\tAdd section on pragma Reviewable.\n\t* sem_ch5.adb (Diagnose_Non_Variable_Lhs): Avoid wrong msgs if\n\texpander off.\n\t* exp_ch9.ads, exp_dist.adb, exp_dist.ads: Minor reformatting.\n\t* sem_ch6.adb (Assert_False): New function\n\t(Check_Statement_Sequence): Call Assert_False to check for\n\tpragma Assert (False) which is considered OK block of control\n\tfor function.\n\t* snames.ads-tmpl (Name_False): New entry.\n\n2014-02-25  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c (VxWorks Section): Enable sigtramp for ARM.\n\t* sigtramp-armvxw.c: New file.\n\nFrom-SVN: r208142", "tree": {"sha": "74683ca77f0ff3b7df848f0e954982594591e3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74683ca77f0ff3b7df848f0e954982594591e3ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b27e18398d1feefb4d30dbc127258b703676a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b27e18398d1feefb4d30dbc127258b703676a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b27e18398d1feefb4d30dbc127258b703676a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b27e18398d1feefb4d30dbc127258b703676a17/comments", "author": null, "committer": null, "parents": [{"sha": "9972d439b8dd8d37284fc1bcd41f32ec43c1e2c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9972d439b8dd8d37284fc1bcd41f32ec43c1e2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9972d439b8dd8d37284fc1bcd41f32ec43c1e2c4"}], "stats": {"total": 688, "additions": 545, "deletions": 143}, "files": [{"sha": "abbd4e72fba436d8e19af2f6695491f6acd6dadb", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -90,6 +90,8 @@ package Exp_Ch9 is\n    --  needed, but in fact, in Ada 2005 the subprogram may be used in a call-\n    --  back, and therefore a protected version of the operation must be\n    --  generated as well.\n+   --\n+   --  Possibly factor this with Exp_Dist.Copy_Specification ???\n \n    function Build_Protected_Sub_Specification\n      (N        : Node_Id;"}, {"sha": "da908fc2862d00293529cb3574e99334ee37b2c8", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -2660,10 +2660,10 @@ package body Exp_Dist is\n    ------------------------\n \n    function Copy_Specification\n-     (Loc         : Source_Ptr;\n-      Spec        : Node_Id;\n-      Ctrl_Type   : Entity_Id := Empty;\n-      New_Name    : Name_Id   := No_Name) return Node_Id\n+     (Loc       : Source_Ptr;\n+      Spec      : Node_Id;\n+      Ctrl_Type : Entity_Id := Empty;\n+      New_Name  : Name_Id   := No_Name) return Node_Id\n    is\n       Parameters : List_Id := No_List;\n "}, {"sha": "a249833604005aea3ed4d64eae7e5eeacdab46fd", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -95,15 +95,17 @@ package Exp_Dist is\n    --  Build a literal representing the remote subprogram identifier of E\n \n    function Copy_Specification\n-     (Loc         : Source_Ptr;\n-      Spec        : Node_Id;\n-      Ctrl_Type   : Entity_Id := Empty;\n-      New_Name    : Name_Id   := No_Name) return Node_Id;\n+     (Loc       : Source_Ptr;\n+      Spec      : Node_Id;\n+      Ctrl_Type : Entity_Id := Empty;\n+      New_Name  : Name_Id   := No_Name) return Node_Id;\n    --  Build a subprogram specification from another one, or from an\n    --  access-to-subprogram definition. If Ctrl_Type is not Empty, and any\n    --  controlling formal of an anonymous access type is found, then it is\n    --  replaced by an access to Ctrl_Type. If New_Name is given, then it will\n    --  be used as the name for the newly created spec.\n+   --\n+   --  Possibly factor this wrt Exp_Ch9.Build_Private_Protected_Declaration???\n \n    function Corresponding_Stub_Type (RACW_Type : Entity_Id) return Entity_Id;\n    --  Return the stub type associated with the given RACW type"}, {"sha": "88d3ce11e0e92595ac5942cb2f75d1935df56572", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 206, "deletions": 118, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -235,6 +235,7 @@ Implementation Defined Pragmas\n * Pragma Remote_Access_Type::\n * Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n+* Pragma Reviewable::\n * Pragma Share_Generic::\n * Pragma Shared::\n * Pragma Short_Circuit_And_Or::\n@@ -1068,6 +1069,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Remote_Access_Type::\n * Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n+* Pragma Reviewable::\n * Pragma Share_Generic::\n * Pragma Shared::\n * Pragma Short_Circuit_And_Or::\n@@ -6122,6 +6124,114 @@ the Ada_95 and Style_Checks pragmas are accepted without\n generating a warning, but any other use of implementation\n defined pragmas will cause a warning to be generated.\n \n+@node Pragma Reviewable\n+@unnumberedsec Pragma Reviewable\n+@findex Reviewable\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Reviewable;\n+@end smallexample\n+\n+@noindent\n+This pragma is an RM-defined standard pragma, but has no effect on the\n+program being compiled, or on the code generated for the program.\n+\n+To obtain the required output specified in RM H.3.1, the compiler must be\n+run with various special switches as follows:\n+\n+@table @i\n+\n+@item Where compiler-generated run-time checks remain\n+\n+The switch @option{-gnatGL}\n+@findex @option{-gnatGL}\n+may be used to list the expanded code in pseudo-Ada form.\n+Runtime checks show up in the listing either as explicit\n+checks or operators marked with @{@} to indicate a check is present.\n+\n+@item An identification of known exceptions at compile time\n+\n+If the program is compiled with @option{-gnatwa},\n+@findex @option{-gnatwa}\n+the compiler warning messages will indicate all cases where the compiler\n+detects that an exception is certain to occur at run time.\n+\n+@item Possible reads of uninitialized variables\n+\n+The compiler warns of many such cases, but its output is incomplete.\n+@ifclear FSFEDITION\n+The CodePeer analysis tool\n+@findex CodePeer static analysis tool\n+@end ifclear\n+@ifset FSFEDITION\n+A supplemental static analysis tool\n+@end ifset\n+may be used to obtain a comprehensive list of all\n+possible points at which uninitialized data may be read.\n+\n+@item Where run-time support routines are implicitly invoked\n+\n+In the output from @option{-gnatGL},\n+@findex @option{-gnatGL}\n+run-time calls are explicitly listed as calls to the relevant\n+run-time routine.\n+\n+@item Object code listing\n+\n+This may be obtained either by using the @option{-S} switch,\n+@findex @option{-S}\n+or the objdump utility.\n+@findex objdump\n+\n+@item Constructs known to be erroneous at compile time\n+\n+These are identified by warnings issued by the compiler (use @option{-gnatwa}).\n+@findex @option{-gnatwa}\n+\n+@item Stack usage information\n+\n+Static stack usage data (maximum per-subprogram) can be obtained via the\n+@option{-fstack-usage} switch to the compiler.\n+@findex @option{-fstack-usage}\n+Dynamic stack usage data (per task) can be obtained via the @option{-u} switch\n+to gnatbind\n+@findex @option{-u}\n+@ifclear FSFEDITION\n+The gnatstack utility\n+@findex gnatstack\n+can be used to provide additional information on stack usage.\n+@end ifclear\n+\n+@item Object code listing of entire partition\n+\n+This can be obtained by compiling the partition with @option{-S},\n+@findex @option{-S}\n+or by applying objdump\n+@findex objdump\n+to all the object files that are part of the partition.\n+\n+@item A description of the run-time model\n+\n+The full sources of the run-time are available, and the documentation of\n+these routines describes how these run-time routines interface to the\n+underlying operating system facilities.\n+\n+@item Control and data-flow information\n+\n+@ifclear FSFEDITION\n+The CodePeer tool\n+@findex CodePeer static analysis tool\n+@end ifclear\n+@ifset FSFEDITION\n+A supplemental static analysis tool\n+@end ifset\n+may be used to obtain complete control and data-flow information, as well as\n+comprehensive messages identifying possible problems based on this\n+information.\n+@end table\n+\n @node Pragma Share_Generic\n @unnumberedsec Pragma Share_Generic\n @findex Share_Generic\n@@ -16035,9 +16145,43 @@ dynamic allocation or finalization.\n @item Ada.Strings.Bounded.Equal_Case_Insensitive (A.4.10)\n Provides case-insensitive comparisons of bounded strings\n \n+@item Ada.Strings.Bounded.Hash (A.4.9)\n+This package provides a generic hash function for bounded strings\n+\n+@item Ada.Strings.Bounded.Hash_Case_Insensitive (A.4.9)\n+This package provides a generic hash function for bounded strings that\n+converts the string to be hashed to lower case.\n+\n+@item Ada.Strings.Bounded.Less_Case_Insensitive (A.4.10)\n+This package provides a comparison function for bounded strings that works\n+in a case insensitive manner by converting to lower case before the comparison.\n+\n @item Ada.Strings.Fixed (A.4.3)\n This package provides facilities for handling fixed length strings.\n \n+@item Ada.Strings.Fixed.Equal_Case_Insensitive (A.4.10)\n+This package provides an equality function for fixed strings that compares\n+the strings after converting both to lower case.\n+\n+@item Ada.Strings.Fixed.Hash_Case_Insensitive (A.4.9)\n+This package provides a case insensitive hash function for fixed strings that\n+converts the string to lower case before computing the hash.\n+\n+@item Ada.Strings.Fixed.Less_Case_Insensitive (A.4.10)\n+This package provides a comparison function for fixed strings that works\n+in a case insensitive manner by converting to lower case before the comparison.\n+\n+Ada.Strings.Hash (A.4.9)\n+This package provides a hash function for strings.\n+\n+Ada.Strings.Hash_Case_Insensitive (A.4.9)\n+This package provides a hash function for strings that is case insensitive.\n+The string is converted to lower case before computing the hash.\n+\n+@item Ada.Strings.Less_Case_Insensitive (A.4.10)\n+This package provides a comparison function for\\strings that works\n+in a case insensitive manner by converting to lower case before the comparison.\n+\n @item Ada.Strings.Maps (A.4.2)\n This package provides facilities for handling character mappings and\n arbitrarily defined subsets of characters.  For instance it is useful in\n@@ -16057,42 +16201,86 @@ This package provides facilities for handling variable length\n strings.  The unbounded model allows arbitrary length strings, but\n requires the use of dynamic allocation and finalization.\n \n+@item Ada.Strings.Unbounded.Equal_Case_Insensitive (A.4.10)\n+Provides case-insensitive comparisons of unbounded strings\n+\n+@item Ada.Strings.Unbounded.Hash (A.4.9)\n+This package provides a generic hash function for unbounded strings\n+\n+@item Ada.Strings.Unbounded.Hash_Case_Insensitive (A.4.9)\n+This package provides a generic hash function for unbounded strings that\n+converts the string to be hashed to lower case.\n+\n+@item Ada.Strings.Unbounded.Less_Case_Insensitive (A.4.10)\n+This package provides a comparison function for unbounded strings that works\n+in a case insensitive manner by converting to lower case before the comparison.\n+\n+@item Ada.Strings.UTF_Encoding (A.4.11)\n+This package provides basic definitions for dealing with UTF-encoded strings.\n+\n+@item Ada.Strings.UTF_Encoding.Conversions (A.4.11)\n+This package provides conversion functions for UTF-encoded strings.\n+\n+@item Ada.Strings.UTF_Encoding.Strings (A.4.11)\n+@itemx Ada.Strings.UTF_Encoding.Wide_Strings (A.4.11)\n+@itemx Ada.Strings.UTF_Encoding.Wide_Wide_Strings (A.4.11)\n+These packages provide facilities for handling UTF encodings for\n+Strings, Wide_Strings and Wide_Wide_Strings.\n+\n @item Ada.Strings.Wide_Bounded (A.4.7)\n @itemx Ada.Strings.Wide_Fixed (A.4.7)\n @itemx Ada.Strings.Wide_Maps (A.4.7)\n-@itemx Ada.Strings.Wide_Maps.Constants (A.4.7)\n @itemx Ada.Strings.Wide_Unbounded (A.4.7)\n These packages provide analogous capabilities to the corresponding\n packages without @samp{Wide_} in the name, but operate with the types\n @code{Wide_String} and @code{Wide_Character} instead of @code{String}\n-and @code{Character}.\n+and @code{Character}. Versions of all the child packages are available.\n \n @item Ada.Strings.Wide_Wide_Bounded (A.4.7)\n @itemx Ada.Strings.Wide_Wide_Fixed (A.4.7)\n @itemx Ada.Strings.Wide_Wide_Maps (A.4.7)\n-@itemx Ada.Strings.Wide_Wide_Maps.Constants (A.4.7)\n @itemx Ada.Strings.Wide_Wide_Unbounded (A.4.7)\n These packages provide analogous capabilities to the corresponding\n packages without @samp{Wide_} in the name, but operate with the types\n @code{Wide_Wide_String} and @code{Wide_Wide_Character} instead\n of @code{String} and @code{Character}.\n \n+@item Ada.Synchronous_Barriers (D.10.1)\n+This package provides facilities for synchronizing tasks at a low level\n+with barriers.\n+\n @item Ada.Synchronous_Task_Control (D.10)\n This package provides some standard facilities for controlling task\n communication in a synchronous manner.\n \n+@item Ada.Synchronous_Task_Control.EDF (D.10)\n+Not implemented in GNAT.\n+\n @item Ada.Tags\n This package contains definitions for manipulation of the tags of tagged\n values.\n \n-@item Ada.Task_Attributes\n+@item Ada.Tags.Generic_Dispatching_Constructor (3.9)\n+This package provides a way of constructing tagged class-wide values given\n+only the tag value.\n+\n+@item Ada.Task_Attributes (C.7.2)\n This package provides the capability of associating arbitrary\n task-specific data with separate tasks.\n \n+@item Ada.Task_Identifification (C.7.1)\n+This package provides capabilities for task identification.\n+\n+@item Ada.Task_Termination (C.7.3)\n+This package provides control over task termination.\n+\n @item Ada.Text_IO\n This package provides basic text input-output capabilities for\n character, string and numeric data.  The subpackages of this\n-package are listed next.\n+package are listed next. Note that although these are defined\n+as subpackages in the RM, they are actually transparently\n+implemented as child packages in GNAT, meaning that they\n+are only loaded if needed.\n \n @item Ada.Text_IO.Decimal_IO\n Provides input-output facilities for decimal fixed-point types\n@@ -16134,7 +16322,10 @@ predefined instantiations of this generic package are available:\n @end table\n \n @item Ada.Text_IO.Modular_IO\n-Provides input-output facilities for modular (unsigned) types\n+Provides input-output facilities for modular (unsigned) types.\n+\n+@item Ada.Text_IO.Bounded_IO (A.10.11)\n+Provides input-output facilities for bounded strings.\n \n @item Ada.Text_IO.Complex_IO (G.1.3)\n This package provides basic text input-output capabilities for complex\n@@ -16150,6 +16341,9 @@ This package provides a facility that allows Text_IO files to be treated\n as streams, so that the stream attributes can be used for writing\n arbitrary data, including binary data, to Text_IO files.\n \n+@item Ada.Text_IO.Unbounded_IO (A.10.12)\n+This package provides input-output facilities for unbounded strings.\n+\n @item Ada.Unchecked_Conversion (13.9)\n This generic package allows arbitrary conversion from one type to\n another of the same size, providing for breaking the type safety in\n@@ -16209,126 +16403,20 @@ allocated by use of an allocator.\n This package is similar to @code{Ada.Text_IO}, except that the external\n file supports wide character representations, and the internal types are\n @code{Wide_Character} and @code{Wide_String} instead of @code{Character}\n-and @code{String}.  It contains generic subpackages listed next.\n-\n-@item Ada.Wide_Text_IO.Decimal_IO\n-Provides input-output facilities for decimal fixed-point types\n-\n-@item Ada.Wide_Text_IO.Enumeration_IO\n-Provides input-output facilities for enumeration types.\n-\n-@item Ada.Wide_Text_IO.Fixed_IO\n-Provides input-output facilities for ordinary fixed-point types.\n-\n-@item Ada.Wide_Text_IO.Float_IO\n-Provides input-output facilities for float types.  The following\n-predefined instantiations of this generic package are available:\n-\n-@table @code\n-@item Short_Float\n-@code{Short_Float_Wide_Text_IO}\n-@item Float\n-@code{Float_Wide_Text_IO}\n-@item Long_Float\n-@code{Long_Float_Wide_Text_IO}\n-@end table\n-\n-@item Ada.Wide_Text_IO.Integer_IO\n-Provides input-output facilities for integer types.  The following\n-predefined instantiations of this generic package are available:\n-\n-@table @code\n-@item Short_Short_Integer\n-@code{Ada.Short_Short_Integer_Wide_Text_IO}\n-@item Short_Integer\n-@code{Ada.Short_Integer_Wide_Text_IO}\n-@item Integer\n-@code{Ada.Integer_Wide_Text_IO}\n-@item Long_Integer\n-@code{Ada.Long_Integer_Wide_Text_IO}\n-@item Long_Long_Integer\n-@code{Ada.Long_Long_Integer_Wide_Text_IO}\n-@end table\n-\n-@item Ada.Wide_Text_IO.Modular_IO\n-Provides input-output facilities for modular (unsigned) types\n-\n-@item Ada.Wide_Text_IO.Complex_IO (G.1.3)\n-This package is similar to @code{Ada.Text_IO.Complex_IO}, except that the\n-external file supports wide character representations.\n-\n-@item Ada.Wide_Text_IO.Editing (F.3.4)\n-This package is similar to @code{Ada.Text_IO.Editing}, except that the\n-types are @code{Wide_Character} and @code{Wide_String} instead of\n-@code{Character} and @code{String}.\n-\n-@item Ada.Wide_Text_IO.Streams (A.12.3)\n-This package is similar to @code{Ada.Text_IO.Streams}, except that the\n-types are @code{Wide_Character} and @code{Wide_String} instead of\n-@code{Character} and @code{String}.\n+and @code{String}. The corresponding set of nested packages and child\n+packages are defined.\n \n @item Ada.Wide_Wide_Text_IO (A.11)\n This package is similar to @code{Ada.Text_IO}, except that the external\n file supports wide character representations, and the internal types are\n @code{Wide_Character} and @code{Wide_String} instead of @code{Character}\n-and @code{String}.  It contains generic subpackages listed next.\n+and @code{String}. The corresponding set of nested packages and child\n+packages are defined.\n \n-@item Ada.Wide_Wide_Text_IO.Decimal_IO\n-Provides input-output facilities for decimal fixed-point types\n-\n-@item Ada.Wide_Wide_Text_IO.Enumeration_IO\n-Provides input-output facilities for enumeration types.\n-\n-@item Ada.Wide_Wide_Text_IO.Fixed_IO\n-Provides input-output facilities for ordinary fixed-point types.\n-\n-@item Ada.Wide_Wide_Text_IO.Float_IO\n-Provides input-output facilities for float types.  The following\n-predefined instantiations of this generic package are available:\n-\n-@table @code\n-@item Short_Float\n-@code{Short_Float_Wide_Wide_Text_IO}\n-@item Float\n-@code{Float_Wide_Wide_Text_IO}\n-@item Long_Float\n-@code{Long_Float_Wide_Wide_Text_IO}\n-@end table\n-\n-@item Ada.Wide_Wide_Text_IO.Integer_IO\n-Provides input-output facilities for integer types.  The following\n-predefined instantiations of this generic package are available:\n-\n-@table @code\n-@item Short_Short_Integer\n-@code{Ada.Short_Short_Integer_Wide_Wide_Text_IO}\n-@item Short_Integer\n-@code{Ada.Short_Integer_Wide_Wide_Text_IO}\n-@item Integer\n-@code{Ada.Integer_Wide_Wide_Text_IO}\n-@item Long_Integer\n-@code{Ada.Long_Integer_Wide_Wide_Text_IO}\n-@item Long_Long_Integer\n-@code{Ada.Long_Long_Integer_Wide_Wide_Text_IO}\n @end table\n \n-@item Ada.Wide_Wide_Text_IO.Modular_IO\n-Provides input-output facilities for modular (unsigned) types\n-\n-@item Ada.Wide_Wide_Text_IO.Complex_IO (G.1.3)\n-This package is similar to @code{Ada.Text_IO.Complex_IO}, except that the\n-external file supports wide character representations.\n-\n-@item Ada.Wide_Wide_Text_IO.Editing (F.3.4)\n-This package is similar to @code{Ada.Text_IO.Editing}, except that the\n-types are @code{Wide_Character} and @code{Wide_String} instead of\n-@code{Character} and @code{String}.\n-\n-@item Ada.Wide_Wide_Text_IO.Streams (A.12.3)\n-This package is similar to @code{Ada.Text_IO.Streams}, except that the\n-types are @code{Wide_Character} and @code{Wide_String} instead of\n-@code{Character} and @code{String}.\n-@end table\n+For packages in Interfaces and System, all the RM defined packages are\n+available in GNAT, see the Ada 2012 RM for full details.\n \n @node The Implementation of Standard I/O\n @chapter The Implementation of Standard I/O"}, {"sha": "c3824ab7ef30b945ebf75e660c7716f1cf870b7e", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -1906,7 +1906,7 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-#if defined (__PPC__) && defined(_WRS_KERNEL)\n+#if (defined (__ARMEL__) || defined (__PPC__)) && defined(_WRS_KERNEL)\n   /* On PowerPC, kernel mode, we process signals through a Call Frame Info\n      trampoline, voiding the need for myriads of fallback_frame_state\n      variants in the ZCX runtime.  We have no simple way to distinguish ZCX"}, {"sha": "409ea7bf43271b4ff41b6ece0b1e9fc29dd82aad", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -134,6 +134,7 @@ package body Sem_Ch5 is\n                if Ekind (Ent) = E_In_Parameter then\n                   Error_Msg_N\n                     (\"assignment to IN mode parameter not allowed\", N);\n+                  return;\n \n                --  Renamings of protected private components are turned into\n                --  constants when compiling a protected function. In the case\n@@ -151,39 +152,45 @@ package body Sem_Ch5 is\n                then\n                   Error_Msg_N\n                     (\"protected function cannot modify protected object\", N);\n+                  return;\n \n                elsif Ekind (Ent) = E_Loop_Parameter then\n-                  Error_Msg_N\n-                    (\"assignment to loop parameter not allowed\", N);\n-\n-               else\n-                  Error_Msg_N\n-                    (\"left hand side of assignment must be a variable\", N);\n+                  Error_Msg_N (\"assignment to loop parameter not allowed\", N);\n+                  return;\n                end if;\n             end;\n \n-         --  For indexed components or selected components, test prefix\n+         --  For indexed components, test prefix if it is in array. We do not\n+         --  want to recurse for cases where the prefix is a pointer, since we\n+         --  may get a message confusing the pointer and what it references.\n \n-         elsif Nkind (N) = N_Indexed_Component then\n+         elsif Nkind (N) = N_Indexed_Component\n+           and then Is_Array_Type (Etype (Prefix (N)))\n+         then\n             Diagnose_Non_Variable_Lhs (Prefix (N));\n+            return;\n \n          --  Another special case for assignment to discriminant\n \n          elsif Nkind (N) = N_Selected_Component then\n             if Present (Entity (Selector_Name (N)))\n               and then Ekind (Entity (Selector_Name (N))) = E_Discriminant\n             then\n-               Error_Msg_N\n-                 (\"assignment to discriminant not allowed\", N);\n-            else\n+               Error_Msg_N (\"assignment to discriminant not allowed\", N);\n+               return;\n+\n+            --  For selection from record, diagnose prefix, but note that again\n+            --  we only do this for a record, not e.g. for a pointer.\n+\n+            elsif Is_Record_Type (Etype (Prefix (N))) then\n                Diagnose_Non_Variable_Lhs (Prefix (N));\n+               return;\n             end if;\n+         end if;\n \n-         else\n-            --  If we fall through, we have no special message to issue\n+         --  If we fall through, we have no special message to issue\n \n-            Error_Msg_N (\"left hand side of assignment must be a variable\", N);\n-         end if;\n+         Error_Msg_N (\"left hand side of assignment must be a variable\", N);\n       end Diagnose_Non_Variable_Lhs;\n \n       --------------"}, {"sha": "2bf9f263d42b5202dd5546a4685c65e051f51fa0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -7160,10 +7160,45 @@ package body Sem_Ch6 is\n          Stm      : Node_Id;\n          Kind     : Node_Kind;\n \n+         function Assert_False return Boolean;\n+         --  Returns True if Last_Stm is a pragma Assert (False) that has been\n+         --  rewritten as a null statement when assertions are off. The assert\n+         --  is not active, but it is still enough to kill the warning.\n+\n+         ------------------\n+         -- Assert_False --\n+         ------------------\n+\n+         function Assert_False return Boolean is\n+            Orig : constant Node_Id := Original_Node (Last_Stm);\n+\n+         begin\n+            if Nkind (Orig) = N_Pragma\n+              and then Pragma_Name (Orig) = Name_Assert\n+              and then not Error_Posted (Orig)\n+            then\n+               declare\n+                  Arg : constant Node_Id :=\n+                          First (Pragma_Argument_Associations (Orig));\n+                  Exp : constant Node_Id := Expression (Arg);\n+               begin\n+                  return Nkind (Exp) = N_Identifier\n+                    and then Chars (Exp) = Name_False;\n+               end;\n+\n+            else\n+               return False;\n+            end if;\n+         end Assert_False;\n+\n+         --  Local variables\n+\n          Raise_Exception_Call : Boolean;\n          --  Set True if statement sequence terminated by Raise_Exception call\n          --  or a Reraise_Occurrence call.\n \n+      --  Start of processing for Check_Statement_Sequence\n+\n       begin\n          Raise_Exception_Call := False;\n \n@@ -7453,11 +7488,20 @@ package body Sem_Ch6 is\n          --  If we fall through, issue appropriate message\n \n          if Mode = 'F' then\n-            if not Raise_Exception_Call then\n+\n+            --  Kill warning if last statement is a raise exception call,\n+            --  or a pragma Assert (False). Note that with assertions enabled,\n+            --  such a pragma has been converted into a raise exception call\n+            --  already, so the Assert_False is for the assertions off case.\n+\n+            if not Raise_Exception_Call and then not Assert_False then\n \n                --  In GNATprove mode, it is an error to have a missing return\n \n                Error_Msg_Warn := SPARK_Mode /= On;\n+\n+               --  Issue error message or warning\n+\n                Error_Msg_N\n                  (\"RETURN statement missing following this statement<<!\",\n                   Last_Stm);"}, {"sha": "095c9ca301c081c608c20f3289ce2d3cd9d4ce22", "filename": "gcc/ada/sigtramp-armvxw.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsigtramp-armvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsigtramp-armvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-armvxw.c?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -0,0 +1,258 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *           Copyright (C) 2013, Free Software Foundation, Inc.             *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/******************************************************\n+ * ARM-VxWorks version of the __gnat_sigtramp service *\n+ ******************************************************/\n+\n+#include \"sigtramp.h\"\n+\n+#include <vxWorks.h>\n+#include <arch/../regs.h>\n+#include <sigLib.h>\n+\n+/* ----------------------\n+   -- General comments --\n+   ----------------------\n+\n+   Stubs are generated from toplevel asms and .cfi directives, much simpler\n+   to use and check for correctness than manual encodings of CFI byte\n+   sequences.  The general idea is to establish CFA as sigcontext->sc_pregs\n+   and state where to find the registers as offsets from there.\n+\n+   As of today, we support a single stub, providing CFI info for common\n+   registers (GPRs, LR, ...). We might need variants with support for floating\n+   point or altivec registers as well at some point.\n+\n+   Checking which variant should apply and getting at sc_pregs is simpler\n+   to express in C (we can't use offsetof in toplevel asms and hardcoding\n+   constants is not workable with the flurry of VxWorks variants), so this\n+   is the choice for our toplevel interface.\n+\n+   Note that the registers we \"restore\" here are those to which we have\n+   direct access through the system sigcontext structure, which includes\n+   only a partial set of the non-volatiles ABI-wise.  */\n+\n+/* -----------------------------------------\n+   -- Protypes for our internal asm stubs --\n+   -----------------------------------------\n+\n+   SC_PREGS is always expected to be SIGCONTEXT->sc_pregs.  Eventhough our\n+   symbols will remain local, the prototype claims \"extern\" and not\n+   \"static\" to prevent compiler complaints about a symbol used but never\n+   defined.  */\n+\n+/* sigtramp stub providing CFI info for common registers.  */\n+\n+extern void __gnat_sigtramp_common\n+(int signo, void *siginfo, void *sigcontext,\n+ sighandler_t * handler, void * sc_pregs);\n+\n+\n+/* -------------------------------------\n+   -- Common interface implementation --\n+   -------------------------------------\n+\n+   We enforce optimization to minimize the overhead of the extra layer.  */\n+\n+void __gnat_sigtramp (int signo, void *si, void *sc,\n+\t\t      sighandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp (int signo, void *si, void *sc,\n+\t\t      sighandler_t * handler)\n+{\n+  struct sigcontext * sctx = (struct sigcontext *) sc;\n+\n+  __gnat_sigtramp_common (signo, si, sctx, handler, sctx->sc_pregs);\n+}\n+\n+\n+/* ---------------------------\n+   -- And now the asm stubs --\n+   ---------------------------\n+\n+   They all have a common structure with blocks of asm sequences queued one\n+   after the others.  Typically:\n+\n+   SYMBOL_START\n+\n+   CFI_DIRECTIVES\n+     CFI_DEF_CFA,\n+     CFI_COMMON_REGISTERS,\n+     ...\n+\n+   STUB_BODY\n+     asm code to establish frame, setup the cfa reg value,\n+     call the real signal handler, ...\n+\n+   SYMBOL_END\n+*/\n+\n+/*--------------------------------\n+  -- Misc constants and helpers --\n+  -------------------------------- */\n+\n+/* REGNO constants, dwarf column numbers for registers of interest.  */\n+\n+#define REGNO_G_REG_OFFSET(N) (N)\n+\n+#define REGNO_PC_OFFSET  15  /* ARG_POINTER_REGNUM  */\n+\n+/* asm string construction helpers.  */\n+\n+#define STR(TEXT) #TEXT\n+/* stringify expanded TEXT, surrounding it with double quotes.  */\n+\n+#define S(E) STR(E)\n+/* stringify E, which will resolve as text but may contain macros\n+   still to be expanded.  */\n+\n+/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n+   multine contents:  */\n+#define TAB(S) \"\\t\" S\n+#define CR(S)  S \"\\n\"\n+\n+#undef TCR\n+#define TCR(S) TAB(CR(S))\n+\n+/*------------------------------\n+  -- Stub construction blocks --\n+  ------------------------------ */\n+\n+/* CFA setup block\n+   ---------------\n+   Only non-volatile registers are suitable for a CFA base. These are the\n+   only ones we can expect to be able retrieve from the unwinding context\n+   while walking up the chain, saved by at least the bottom-most exception\n+   propagation services.  We use r15 here and set it to the value we need\n+   in stub body that follows.  Note that r14 is inappropriate here, even\n+   though it is non-volatile according to the ABI, because GCC uses it as\n+   an extra SCRATCH on SPE targets.  */\n+\n+#define CFA_REG 8\n+\n+#define CFI_DEF_CFA \\\n+CR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n+\n+/* Register location blocks\n+   ------------------------\n+   Rules to find registers of interest from the CFA. This should comprise\n+   all the non-volatile registers relevant to the interrupted context.\n+\n+   Note that we include r1 in this set, unlike the libgcc unwinding\n+   fallbacks.  This is useful for fallbacks to allow the use of r1 in CFI\n+   expressions and the absence of rule for r1 gets compensated by using the\n+   target CFA instead.  We don't need the expression facility here and\n+   setup a fake CFA to allow very simple offset expressions, so having a\n+   rule for r1 is the proper thing to do.  We for sure have observed\n+   crashes in some cases without it.  */\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(G_REG_OFFSET(1)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(2)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(3)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(4)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(5)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(6)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(7)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(8)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(9)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(10)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(11)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(12)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(13)))  \\\n+TCR(COMMON_CFI(G_REG_OFFSET(14))) \\\n+TCR(COMMON_CFI(PC_OFFSET)) \\\n+TCR(\".cfi_return_column \" S(REGNO_PC_OFFSET))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"mov\tip, sp\") \\\n+TCR(\"stmfd\tsp!, {r\"S(CFA_REG)\", fp, ip, lr, pc}\") \\\n+TCR(\"# Setup CFA_REG = sc_pregs, that we'll retrieve as our CFA value\") \\\n+TCR(\"ldr\tr\"S(CFA_REG)\", [ip]\") \\\n+TCR(\"\")                 \\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received in r0, r1 and r2\") \\\n+TCR(\"sub\tfp, ip, #4\") \\\n+TCR(\"blx\tr3\") \\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"ldmfd\tsp, {r\"S(CFA_REG)\", fp, sp, pc}\")\n+\n+\n+/* Symbol definition block\n+   -----------------------  */\n+\n+#define SIGTRAMP_START(SYM) \\\n+CR(\"# \" S(SYM) \" cfi trampoline\") \\\n+TCR(\".type \" S(SYM) \", %function\") \\\n+CR(\"\") \\\n+CR(S(SYM) \":\") \\\n+TCR(\".cfi_startproc\") \\\n+TCR(\".cfi_signal_frame\")\n+\n+/* Symbol termination block\n+   ------------------------  */\n+\n+#define SIGTRAMP_END(SYM) \\\n+CR(\".cfi_endproc\") \\\n+TCR(\".size \" S(SYM) \", .-\" S(SYM))\n+\n+/*----------------------------\n+  -- And now, the real code --\n+  ---------------------------- */\n+\n+/* Text section start.  The compiler isn't aware of that switch.  */\n+\n+asm (\".text\\n\"\n+     TCR(\".align 2\"));\n+\n+/* sigtramp stub for common registers.  */\n+\n+#define TRAMP_COMMON __gnat_sigtramp_common\n+\n+asm (SIGTRAMP_START(TRAMP_COMMON));\n+asm (CFI_DEF_CFA);\n+asm (CFI_COMMON_REGS);\n+asm (SIGTRAMP_BODY);\n+asm (SIGTRAMP_END(TRAMP_COMMON));\n+\n+"}, {"sha": "76300a93715130a1842b83cc71c42e53c73caa39", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b27e18398d1feefb4d30dbc127258b703676a17/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=7b27e18398d1feefb4d30dbc127258b703676a17", "patch": "@@ -237,6 +237,7 @@ package Snames is\n \n    Name_Const                          : constant Name_Id := N + $;\n    Name_Error                          : constant Name_Id := N + $;\n+   Name_False                          : constant Name_Id := N + $;\n    Name_Go                             : constant Name_Id := N + $;\n    Name_Put                            : constant Name_Id := N + $;\n    Name_Put_Line                       : constant Name_Id := N + $;"}]}