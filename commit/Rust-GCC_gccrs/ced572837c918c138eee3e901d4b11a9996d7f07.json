{"sha": "ced572837c918c138eee3e901d4b11a9996d7f07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkNTcyODM3YzkxOGMxMzhlZWUzZTkwMWQ0YjExYTk5OTZkN2YwNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-09T10:10:25Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-09T10:10:25Z"}, "message": "gigi.h (gnat_mark_addressable): Rename parameter.\n\n\t* gcc-interface/gigi.h (gnat_mark_addressable): Rename parameter.\n\t* gcc-interface/decl.c (maybe_variable): Do not set TREE_STATIC on _REF\n\tnode.  Use the type of the operand to set TREE_READONLY.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Do not set TREE_STATIC on\n\t_REF node.  Do not overwrite TREE_READONLY.\n\t(call_to_gnu): Rename local variable and fix various nits.  In the\n\tcopy-in/copy-out case, build the SAVE_EXPR manually.\n\t(convert_with_check): Call protect_multiple_eval in lieu of save_expr\n\tand fold the computations.\n\t(protect_multiple_eval): Always save entire fat pointers.\n\t(maybe_stabilize_reference): Minor tweaks.\n\t(gnat_stabilize_reference_1): Likewise.  Do not deal with tcc_constant,\n\ttcc_type and tcc_statement.\n\t* gcc-interface/utils.c (convert_to_fat_pointer): Call\n\tprotect_multiple_eval in lieu of save_expr.\n\t(convert): Minor tweaks.\n\t(maybe_unconstrained_array): Do not set TREE_STATIC on _REF node.\n\t(builtin_type_for_size): Call gnat_type_for_size directly.\n\t* gcc-interface/utils2.c (contains_save_expr_p): Delete.\n\t(contains_null_expr): Likewise\n\t(gnat_build_constructor): Do not call it.\n\t(compare_arrays): Deal with all side-effects, use protect_multiple_eval\n\tinstead of gnat_stabilize_reference to protect the operands.\n\t(nonbinary_modular_operation): Call protect_multiple_eval in lieu of\n\tsave_expr.\n\t(maybe_wrap_malloc): Likewise.\n\t(build_allocator): Likewise.\n\t(build_unary_op) <INDIRECT_REF>: Do not set TREE_STATIC on _REF node.\n\t(gnat_mark_addressable): Rename parameter.\n\nFrom-SVN: r158156", "tree": {"sha": "5a9512bd856f8febed5a570cb5d9132498eca27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a9512bd856f8febed5a570cb5d9132498eca27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ced572837c918c138eee3e901d4b11a9996d7f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced572837c918c138eee3e901d4b11a9996d7f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced572837c918c138eee3e901d4b11a9996d7f07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced572837c918c138eee3e901d4b11a9996d7f07/comments", "author": null, "committer": null, "parents": [{"sha": "3e65f25191da23215ba847ed49d10af5cf207490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e65f25191da23215ba847ed49d10af5cf207490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e65f25191da23215ba847ed49d10af5cf207490"}], "stats": {"total": 506, "additions": 223, "deletions": 283}, "files": [{"sha": "8cd43c6793a3ed0bfa10dac8f1743c5000019870", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -1,3 +1,35 @@\n+2010-04-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_mark_addressable): Rename parameter.\n+\t* gcc-interface/decl.c (maybe_variable): Do not set TREE_STATIC on _REF\n+\tnode.  Use the type of the operand to set TREE_READONLY.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Do not set TREE_STATIC on\n+\t_REF node.  Do not overwrite TREE_READONLY.\n+\t(call_to_gnu): Rename local variable and fix various nits.  In the\n+\tcopy-in/copy-out case, build the SAVE_EXPR manually.\n+\t(convert_with_check): Call protect_multiple_eval in lieu of save_expr\n+\tand fold the computations.\n+\t(protect_multiple_eval): Always save entire fat pointers.\n+\t(maybe_stabilize_reference): Minor tweaks.\n+\t(gnat_stabilize_reference_1): Likewise.  Do not deal with tcc_constant,\n+\ttcc_type and tcc_statement.\n+\t* gcc-interface/utils.c (convert_to_fat_pointer): Call\n+\tprotect_multiple_eval in lieu of save_expr.\n+\t(convert): Minor tweaks.\n+\t(maybe_unconstrained_array): Do not set TREE_STATIC on _REF node.\n+\t(builtin_type_for_size): Call gnat_type_for_size directly.\n+\t* gcc-interface/utils2.c (contains_save_expr_p): Delete.\n+\t(contains_null_expr): Likewise\n+\t(gnat_build_constructor): Do not call it.\n+\t(compare_arrays): Deal with all side-effects, use protect_multiple_eval\n+\tinstead of gnat_stabilize_reference to protect the operands.\n+\t(nonbinary_modular_operation): Call protect_multiple_eval in lieu of\n+\tsave_expr.\n+\t(maybe_wrap_malloc): Likewise.\n+\t(build_allocator): Likewise.\n+\t(build_unary_op) <INDIRECT_REF>: Do not set TREE_STATIC on _REF node.\n+\t(gnat_mark_addressable): Rename parameter.\n+\n 2010-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/ada-tree.h (TYPE_RETURNS_UNCONSTRAINED_P): Rename into."}, {"sha": "03938d1712e0d8ced2e5595199e90d20f6b3bd8a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -5743,9 +5743,7 @@ maybe_variable (tree gnu_operand)\n       tree gnu_result\n \t= build1 (UNCONSTRAINED_ARRAY_REF, TREE_TYPE (gnu_operand),\n \t\t  variable_size (TREE_OPERAND (gnu_operand, 0)));\n-\n-      TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result)\n-\t= TYPE_READONLY (TREE_TYPE (TREE_TYPE (gnu_operand)));\n+      TREE_READONLY (gnu_result) = TYPE_READONLY (TREE_TYPE (gnu_operand));\n       return gnu_result;\n     }\n "}, {"sha": "97c5ca0a6327b8795c14dd843820c3c827e5b87a", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -871,9 +871,9 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal,\n                                  Node_Id gnat_actual);\n \n-/* Indicate that we need to make the address of EXPR_NODE and it therefore\n-   should not be allocated in a register.  Return true if successful.  */\n-extern bool gnat_mark_addressable (tree expr_node);\n+/* Indicate that we need to take the address of T and that it therefore\n+   should not be allocated in a register.  Returns true if successful.  */\n+extern bool gnat_mark_addressable (tree t);\n \n /* Implementation of the builtin_function langhook.  */\n extern tree gnat_builtin_function (tree decl);"}, {"sha": "438799c63d537e3ed48a4aa95fd7f7acca5a1fcd", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 134, "deletions": 140, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -914,7 +914,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  || (TREE_CODE (gnu_result) == PARM_DECL\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))))\n     {\n-      bool ro = DECL_POINTS_TO_READONLY_P (gnu_result);\n+      const bool read_only = DECL_POINTS_TO_READONLY_P (gnu_result);\n       tree renamed_obj;\n \n       if (TREE_CODE (gnu_result) == PARM_DECL\n@@ -928,8 +928,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t we can reference the renamed object directly, since the renamed\n \t expression has been protected against multiple evaluations.  */\n       else if (TREE_CODE (gnu_result) == VAR_DECL\n-\t       && (renamed_obj = DECL_RENAMED_OBJECT (gnu_result)) != 0\n-\t       && (! DECL_RENAMING_GLOBAL_P (gnu_result)\n+\t       && (renamed_obj = DECL_RENAMED_OBJECT (gnu_result))\n+\t       && (!DECL_RENAMING_GLOBAL_P (gnu_result)\n \t\t   || global_bindings_p ()))\n \tgnu_result = renamed_obj;\n \n@@ -942,7 +942,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       else\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n-      TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result) = ro;\n+      if (read_only)\n+\tTREE_READONLY (gnu_result) = 1;\n     }\n \n   /* The GNAT tree has the type of a function as the type of its result.  Also\n@@ -2404,75 +2405,68 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n static tree\n call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n {\n-  tree gnu_result;\n   /* The GCC node corresponding to the GNAT subprogram name.  This can either\n      be a FUNCTION_DECL node if we are dealing with a standard subprogram call,\n      or an indirect reference expression (an INDIRECT_REF node) pointing to a\n      subprogram.  */\n-  tree gnu_subprog_node = gnat_to_gnu (Name (gnat_node));\n+  tree gnu_subprog = gnat_to_gnu (Name (gnat_node));\n   /* The FUNCTION_TYPE node giving the GCC type of the subprogram.  */\n-  tree gnu_subprog_type = TREE_TYPE (gnu_subprog_node);\n-  tree gnu_subprog_addr\n-    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog_node);\n+  tree gnu_subprog_type = TREE_TYPE (gnu_subprog);\n+  tree gnu_subprog_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_subprog);\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n   tree gnu_actual_list = NULL_TREE;\n   tree gnu_name_list = NULL_TREE;\n   tree gnu_before_list = NULL_TREE;\n   tree gnu_after_list = NULL_TREE;\n-  tree gnu_subprog_call;\n+  tree gnu_call;\n \n   gcc_assert (TREE_CODE (gnu_subprog_type) == FUNCTION_TYPE);\n \n-  /* If we are calling a stubbed function, make this into a raise of\n-     Program_Error.  Elaborate all our args first.  */\n-  if (TREE_CODE (gnu_subprog_node) == FUNCTION_DECL\n-      && DECL_STUBBED_P (gnu_subprog_node))\n+  /* If we are calling a stubbed function, raise Program_Error, but Elaborate\n+     all our args first.  */\n+  if (TREE_CODE (gnu_subprog) == FUNCTION_DECL && DECL_STUBBED_P (gnu_subprog))\n     {\n+      tree call_expr = build_call_raise (PE_Stubbed_Subprogram_Called,\n+\t\t\t\t\t gnat_node, N_Raise_Program_Error);\n+\n       for (gnat_actual = First_Actual (gnat_node);\n \t   Present (gnat_actual);\n \t   gnat_actual = Next_Actual (gnat_actual))\n \tadd_stmt (gnat_to_gnu (gnat_actual));\n \n-      {\n-\ttree call_expr\n-\t  = build_call_raise (PE_Stubbed_Subprogram_Called, gnat_node,\n-\t\t\t      N_Raise_Program_Error);\n+      if (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n+\t{\n+\t  *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n+\t  return build1 (NULL_EXPR, TREE_TYPE (gnu_subprog_type), call_expr);\n+\t}\n \n-\tif (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n-\t  {\n-\t    *gnu_result_type_p = TREE_TYPE (gnu_subprog_type);\n-\t    return build1 (NULL_EXPR, *gnu_result_type_p, call_expr);\n-\t  }\n-\telse\n-\t  return call_expr;\n-      }\n+      return call_expr;\n     }\n \n   /* The only way we can be making a call via an access type is if Name is an\n      explicit dereference.  In that case, get the list of formal args from the\n-     type the access type is pointing to.  Otherwise, get the formals from\n+     type the access type is pointing to.  Otherwise, get the formals from the\n      entity being called.  */\n   if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n     gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)\n     /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n-    gnat_formal = 0;\n+    gnat_formal = Empty;\n   else\n     gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n \n-  /* Create the list of the actual parameters as GCC expects it, namely a chain\n-     of TREE_LIST nodes in which the TREE_VALUE field of each node is a\n-     parameter-expression and the TREE_PURPOSE field is null.  Skip Out\n-     parameters not passed by reference and don't need to be copied in.  */\n+  /* Create the list of the actual parameters as GCC expects it, namely a\n+     chain of TREE_LIST nodes in which the TREE_VALUE field of each node\n+     is an expression and the TREE_PURPOSE field is null.  But skip Out\n+     parameters not passed by reference and that need not be copied in.  */\n   for (gnat_actual = First_Actual (gnat_node);\n        Present (gnat_actual);\n        gnat_formal = Next_Formal_With_Extras (gnat_formal),\n        gnat_actual = Next_Actual (gnat_actual))\n     {\n-      tree gnu_formal\n-\t= (present_gnu_tree (gnat_formal)\n-\t   ? get_gnu_tree (gnat_formal) : NULL_TREE);\n+      tree gnu_formal = present_gnu_tree (gnat_formal)\n+\t\t\t? get_gnu_tree (gnat_formal) : NULL_TREE;\n       tree gnu_formal_type = gnat_to_gnu_type (Etype (gnat_formal));\n       /* We must suppress conversions that can cause the creation of a\n \t temporary in the Out or In Out case because we need the real\n@@ -2487,13 +2481,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t   || (Nkind (gnat_actual) == N_Type_Conversion\n \t       && Is_Composite_Type (Underlying_Type (Etype (gnat_formal)))));\n-      Node_Id gnat_name = (suppress_type_conversion\n-\t\t\t   ? Expression (gnat_actual) : gnat_actual);\n+      Node_Id gnat_name = suppress_type_conversion\n+\t\t\t  ? Expression (gnat_actual) : gnat_actual;\n       tree gnu_name = gnat_to_gnu (gnat_name), gnu_name_type;\n       tree gnu_actual;\n \n       /* If it's possible we may need to use this expression twice, make sure\n-\t that any side-effects are handled via SAVE_EXPRs.  Likewise if we need\n+\t that any side-effects are handled via SAVE_EXPRs; likewise if we need\n \t to force side-effects before the call.\n \t ??? This is more conservative than we need since we don't need to do\n \t this for pass-by-ref with no conversion.  */\n@@ -2518,13 +2512,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    post_error\n \t      (\"misaligned actual cannot be passed by reference\", gnat_actual);\n \n-\t  /* For users of Starlet we issue a warning because the\n-\t     interface apparently assumes that by-ref parameters\n-\t     outlive the procedure invocation.  The code still\n-\t     will not work as intended, but we cannot do much\n-\t     better since other low-level parts of the back-end\n-\t     would allocate temporaries at will because of the\n-\t     misalignment if we did not do so here.  */\n+\t  /* For users of Starlet we issue a warning because the interface\n+\t     apparently assumes that by-ref parameters outlive the procedure\n+\t     invocation.  The code still will not work as intended, but we\n+\t     cannot do much better since low-level parts of the back-end\n+\t     would allocate temporaries at will because of the misalignment\n+\t     if we did not do so here.  */\n \t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n \t    {\n \t      post_error\n@@ -2563,13 +2556,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n \t  /* Make a SAVE_EXPR to both properly account for potential side\n-\t     effects and handle the creation of a temporary copy.  Special\n-\t     code in gnat_gimplify_expr ensures that the same temporary is\n-\t     used as the object and copied back after the call if needed.  */\n+\t     effects and handle the creation of a temporary.  Special code\n+\t     in gnat_gimplify_expr ensures that the same temporary is used\n+\t     as the object and copied back after the call if needed.  */\n \t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n \t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n \n-\t  /* Set up to move the copy back to the original.  */\n+\t  /* Set up to move the copy back to the original if needed.  */\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n \t      tree stmt = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_copy,\n@@ -2618,9 +2611,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  /* We may have suppressed a conversion to the Etype of the actual\n \t     since the parent is a procedure call.  So put it back here.\n \t     ??? We use the reverse order compared to the case above because\n-\t     of an awkward interaction with the check and actually don't put\n-\t     back the conversion at all if a check is emitted.  This is also\n-\t     done for the conversion to the formal's type just below.  */\n+\t     of an awkward interaction with the check.  */\n \t  if (TREE_CODE (gnu_actual) != SAVE_EXPR)\n \t    gnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n \t\t\t\t  gnu_actual);\n@@ -2639,9 +2630,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t    gnu_name);\n \n       /* If we have not saved a GCC object for the formal, it means it is an\n-\t Out parameter not passed by reference and that does not need to be\n-\t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n-\t reference.  */\n+\t Out parameter not passed by reference and that need not be copied in.\n+\t Otherwise, first see if the PARM_DECL is passed by reference.  */\n       if (gnu_formal\n \t  && TREE_CODE (gnu_formal) == PARM_DECL\n \t  && DECL_BY_REF_P (gnu_formal))\n@@ -2707,12 +2697,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t       && TREE_CODE (gnu_formal) == PARM_DECL\n \t       && DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t{\n-\t  /* If arg is 'Null_Parameter, pass zero descriptor.  */\n+\t  /* If this is 'Null_Parameter, pass a zero descriptor.  */\n \t  if ((TREE_CODE (gnu_actual) == INDIRECT_REF\n \t       || TREE_CODE (gnu_actual) == UNCONSTRAINED_ARRAY_REF)\n \t      && TREE_PRIVATE (gnu_actual))\n-\t    gnu_actual = convert (DECL_ARG_TYPE (get_gnu_tree (gnat_formal)),\n-\t\t\t\t  integer_zero_node);\n+\t    gnu_actual\n+\t      = convert (DECL_ARG_TYPE (gnu_formal), integer_zero_node);\n \t  else\n \t    gnu_actual = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t fill_vms_descriptor (gnu_actual,\n@@ -2721,26 +2711,25 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t}\n       else\n \t{\n-\t  tree gnu_actual_size = TYPE_SIZE (TREE_TYPE (gnu_actual));\n+\t  tree gnu_size;\n \n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n-\t  if (!gnu_formal || TREE_CODE (gnu_formal) != PARM_DECL)\n+\t  if (!(gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL))\n \t    continue;\n \n \t  /* If this is 'Null_Parameter, pass a zero even though we are\n \t     dereferencing it.  */\n-\t  else if (TREE_CODE (gnu_actual) == INDIRECT_REF\n-\t\t   && TREE_PRIVATE (gnu_actual)\n-\t\t   && host_integerp (gnu_actual_size, 1)\n-\t\t   && 0 >= compare_tree_int (gnu_actual_size,\n-\t\t\t\t\t\t   BITS_PER_WORD))\n+\t  if (TREE_CODE (gnu_actual) == INDIRECT_REF\n+\t      && TREE_PRIVATE (gnu_actual)\n+\t      && (gnu_size = TYPE_SIZE (TREE_TYPE (gnu_actual)))\n+\t      && TREE_CODE (gnu_size) == INTEGER_CST\n+\t      && compare_tree_int (gnu_size, BITS_PER_WORD) <= 0)\n \t    gnu_actual\n \t      = unchecked_convert (DECL_ARG_TYPE (gnu_formal),\n \t\t\t\t   convert (gnat_type_for_size\n-\t\t\t\t\t    (tree_low_cst (gnu_actual_size, 1),\n-\t\t\t\t\t     1),\n+\t\t\t\t\t    (TREE_INT_CST_LOW (gnu_size), 1),\n \t\t\t\t\t    integer_zero_node),\n \t\t\t\t   false);\n \t  else\n@@ -2750,17 +2739,16 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       gnu_actual_list = tree_cons (NULL_TREE, gnu_actual, gnu_actual_list);\n     }\n \n-  gnu_subprog_call = build_call_list (TREE_TYPE (gnu_subprog_type),\n-\t\t\t\t      gnu_subprog_addr,\n-\t\t\t\t      nreverse (gnu_actual_list));\n-  set_expr_location_from_node (gnu_subprog_call, gnat_node);\n+  gnu_call = build_call_list (TREE_TYPE (gnu_subprog_type), gnu_subprog_addr,\n+\t\t\t      nreverse (gnu_actual_list));\n+  set_expr_location_from_node (gnu_call, gnat_node);\n \n   /* If it's a function call, the result is the call expression unless a target\n      is specified, in which case we copy the result into the target and return\n      the assignment statement.  */\n   if (Nkind (gnat_node) == N_Function_Call)\n     {\n-      gnu_result = gnu_subprog_call;\n+      tree gnu_result = gnu_call;\n       enum tree_code op_code;\n \n       /* If the function returns an unconstrained array or by direct reference,\n@@ -2802,12 +2790,16 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t{\n \t  tree gnu_name;\n \n-\t  gnu_subprog_call = save_expr (gnu_subprog_call);\n+\t  /* The call sequence must contain one and only one call, even though\n+\t     the function is const or pure.  So force a SAVE_EXPR.  */\n+\t  gnu_call = build1 (SAVE_EXPR, TREE_TYPE (gnu_call), gnu_call);\n+\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n \t  gnu_name_list = nreverse (gnu_name_list);\n \n \t  /* If any of the names had side-effects, ensure they are all\n \t     evaluated before the call.  */\n-\t  for (gnu_name = gnu_name_list; gnu_name;\n+\t  for (gnu_name = gnu_name_list;\n+\t       gnu_name;\n \t       gnu_name = TREE_CHAIN (gnu_name))\n \t    if (TREE_SIDE_EFFECTS (TREE_VALUE (gnu_name)))\n \t      append_to_statement_list (TREE_VALUE (gnu_name),\n@@ -2838,8 +2830,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t       either the result of the function if there is only a single such\n \t       parameter or the appropriate field from the record returned.  */\n \t    tree gnu_result\n-\t      = length == 1 ? gnu_subprog_call\n-\t\t: build_component_ref (gnu_subprog_call, NULL_TREE,\n+\t      = length == 1\n+\t\t? gnu_call\n+\t\t: build_component_ref (gnu_call, NULL_TREE,\n \t\t\t\t       TREE_PURPOSE (scalar_return_list),\n \t\t\t\t       false);\n \n@@ -2851,9 +2844,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t    /* If the result is a padded type, remove the padding.  */\n \t    if (TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n-\t      gnu_result = convert (TREE_TYPE (TYPE_FIELDS\n-\t\t\t\t\t       (TREE_TYPE (gnu_result))),\n-\t\t\t\t    gnu_result);\n+\t      gnu_result\n+\t\t= convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_result))),\n+\t\t\t   gnu_result);\n \n \t    /* If the actual is a type conversion, the real target object is\n \t       denoted by the inner Expression and we need to convert the\n@@ -2907,11 +2900,12 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    scalar_return_list = TREE_CHAIN (scalar_return_list);\n \t    gnu_name_list = TREE_CHAIN (gnu_name_list);\n \t  }\n-\t}\n+    }\n   else\n-    append_to_statement_list (gnu_subprog_call, &gnu_before_list);\n+    append_to_statement_list (gnu_call, &gnu_before_list);\n \n   append_to_statement_list (gnu_after_list, &gnu_before_list);\n+\n   return gnu_before_list;\n }\n \f\n@@ -6695,7 +6689,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       && !truncatep)\n     {\n       REAL_VALUE_TYPE half_minus_pred_half, pred_half;\n-      tree gnu_conv, gnu_zero, gnu_comp, gnu_saved_result, calc_type;\n+      tree gnu_conv, gnu_zero, gnu_comp, calc_type;\n       tree gnu_pred_half, gnu_add_pred_half, gnu_subtract_pred_half;\n       const struct real_format *fmt;\n \n@@ -6718,14 +6712,14 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       gnu_pred_half = build_real (calc_type, pred_half);\n \n       /* If the input is strictly negative, subtract this value\n-\t and otherwise add it from the input. For 0.5, the result\n+\t and otherwise add it from the input.  For 0.5, the result\n \t is exactly between 1.0 and the machine number preceding 1.0\n-\t (for calc_type). Since the last bit of 1.0 is even, this 0.5\n+\t (for calc_type).  Since the last bit of 1.0 is even, this 0.5\n \t will round to 1.0, while all other number with an absolute\n-\t value less than 0.5 round to 0.0. For larger numbers exactly\n+\t value less than 0.5 round to 0.0.  For larger numbers exactly\n \t halfway between integers, rounding will always be correct as\n \t the true mathematical result will be closer to the higher\n-\t integer compared to the lower one. So, this constant works\n+\t integer compared to the lower one.  So, this constant works\n \t for all floating-point numbers.\n \n \t The reason to use the same constant with subtract/add instead\n@@ -6734,16 +6728,16 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t conversion of the input to the calc_type (if necessary).  */\n \n       gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n-      gnu_saved_result = save_expr (gnu_result);\n-      gnu_conv = convert (calc_type, gnu_saved_result);\n-      gnu_comp = build2 (GE_EXPR, integer_type_node,\n-\t\t\t gnu_saved_result, gnu_zero);\n+      gnu_result = protect_multiple_eval (gnu_result);\n+      gnu_conv = convert (calc_type, gnu_result);\n+      gnu_comp\n+\t= fold_build2 (GE_EXPR, integer_type_node, gnu_result, gnu_zero);\n       gnu_add_pred_half\n-\t= build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+\t= fold_build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n       gnu_subtract_pred_half\n-\t= build2 (MINUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n-      gnu_result = build3 (COND_EXPR, calc_type, gnu_comp,\n-\t\t\t   gnu_add_pred_half, gnu_subtract_pred_half);\n+\t= fold_build2 (MINUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+      gnu_result = fold_build3 (COND_EXPR, calc_type, gnu_comp,\n+\t\t\t\tgnu_add_pred_half, gnu_subtract_pred_half);\n     }\n \n   if (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n@@ -6753,10 +6747,8 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   else\n     gnu_result = convert (gnu_base_type, gnu_result);\n \n-  /* Finally, do the range check if requested.  Note that if the\n-     result type is a modular type, the range check is actually\n-     an overflow check.  */\n-\n+  /* Finally, do the range check if requested.  Note that if the result type\n+     is a modular type, the range check is actually an overflow check.  */\n   if (rangep\n       || (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n \t  && TYPE_MODULAR_P (gnu_base_type) && overflowp))\n@@ -7205,6 +7197,7 @@ tree\n protect_multiple_eval (tree exp)\n {\n   tree type = TREE_TYPE (exp);\n+  enum tree_code code = TREE_CODE (exp);\n \n   /* If EXP has no side effects, we theoritically don't need to do anything.\n      However, we may be recursively passed more and more complex expressions\n@@ -7221,21 +7214,28 @@ protect_multiple_eval (tree exp)\n      Similarly, if we're indirectly referencing something, we only\n      need to protect the address since the data itself can't change\n      in these situations.  */\n-  if (TREE_CODE (exp) == NON_LVALUE_EXPR\n-      || CONVERT_EXPR_P (exp)\n-      || TREE_CODE (exp) == VIEW_CONVERT_EXPR\n-      || TREE_CODE (exp) == INDIRECT_REF\n-      || TREE_CODE (exp) == UNCONSTRAINED_ARRAY_REF)\n-  return build1 (TREE_CODE (exp), type,\n-\t\t protect_multiple_eval (TREE_OPERAND (exp, 0)));\n+  if (code == NON_LVALUE_EXPR\n+      || CONVERT_EXPR_CODE_P (code)\n+      || code == VIEW_CONVERT_EXPR\n+      || code == INDIRECT_REF\n+      || code == UNCONSTRAINED_ARRAY_REF)\n+  return build1 (code, type, protect_multiple_eval (TREE_OPERAND (exp, 0)));\n+\n+  /* If this is a COMPONENT_REF of a fat pointer, save the entire fat pointer.\n+     This may be more efficient, but will also allow us to more easily find\n+     the match for the PLACEHOLDER_EXPR.  */\n+  if (code == COMPONENT_REF\n+      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+    return build3 (code, type, protect_multiple_eval (TREE_OPERAND (exp, 0)),\n+\t\t   TREE_OPERAND (exp, 1), TREE_OPERAND (exp, 2));\n \n   /* If this is a fat pointer or something that can be placed in a register,\n      just make a SAVE_EXPR.  Likewise for a CALL_EXPR as large objects are\n      returned via invisible reference in most ABIs so the temporary will\n      directly be filled by the callee.  */\n   if (TYPE_IS_FAT_POINTER_P (type)\n       || TYPE_MODE (type) != BLKmode\n-      || TREE_CODE (exp) == CALL_EXPR)\n+      || code == CALL_EXPR)\n     return save_expr (exp);\n \n   /* Otherwise reference, protect the address and dereference.  */\n@@ -7354,26 +7354,23 @@ maybe_stabilize_reference (tree ref, bool force, bool *success)\n       return ref;\n     }\n \n-  TREE_READONLY (result) = TREE_READONLY (ref);\n-\n-  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS attached to the initial\n-     expression may not be sustained across some paths, such as the way via\n-     build1 for INDIRECT_REF.  We re-populate those flags here for the general\n-     case, which is consistent with the GCC version of this routine.\n+  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS set on the initial expression\n+     may not be sustained across some paths, such as the way via build1 for\n+     INDIRECT_REF.  We reset those flags here in the general case, which is\n+     consistent with the GCC version of this routine.\n \n      Special care should be taken regarding TREE_SIDE_EFFECTS, because some\n-     paths introduce side effects where there was none initially (e.g. calls\n-     to save_expr), and we also want to keep track of that.  */\n-\n-  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n+     paths introduce side-effects where there was none initially (e.g. if a\n+     SAVE_EXPR is built) and we also want to keep track of that.  */\n+  TREE_READONLY (result) = TREE_READONLY (ref);\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n \n   return result;\n }\n \n-/* Wrapper around maybe_stabilize_reference, for common uses without\n-   lvalue restrictions and without need to examine the success\n-   indication.  */\n+/* Wrapper around maybe_stabilize_reference, for common uses without lvalue\n+   restrictions and without the need to examine the success indication.  */\n \n static tree\n gnat_stabilize_reference (tree ref, bool force)\n@@ -7396,17 +7393,14 @@ gnat_stabilize_reference_1 (tree e, bool force)\n      to a const array but whose index contains side-effects.  But we can\n      ignore things that are actual constant or that already have been\n      handled by this function.  */\n-\n   if (TREE_CONSTANT (e) || code == SAVE_EXPR)\n     return e;\n \n   switch (TREE_CODE_CLASS (code))\n     {\n     case tcc_exceptional:\n-    case tcc_type:\n     case tcc_declaration:\n     case tcc_comparison:\n-    case tcc_statement:\n     case tcc_expression:\n     case tcc_reference:\n     case tcc_vl_exp:\n@@ -7415,44 +7409,44 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n       if (code == COMPONENT_REF\n \t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n-\tresult = build3 (COMPONENT_REF, type,\n-\t\t\t gnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n-\t\t\t\t\t\t     force),\n-\t\t\t TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n+\tresult\n+\t  = build3 (code, type,\n+\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t    TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n+      /* If the expression has side-effects, then encase it in a SAVE_EXPR\n+\t so that it will only be evaluated once.  */\n+      /* The tcc_reference and tcc_comparison classes could be handled as\n+\t below, but it is generally faster to only evaluate them once.  */\n       else if (TREE_SIDE_EFFECTS (e) || force)\n \treturn save_expr (e);\n       else\n \treturn e;\n       break;\n \n-    case tcc_constant:\n-      /* Constants need no processing.  In fact, we should never reach\n-\t here.  */\n-      return e;\n-\n     case tcc_binary:\n       /* Recursively stabilize each operand.  */\n-      result = build2 (code, type,\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 1),\n-\t\t\t\t\t\t   force));\n+      result\n+\t= build2 (code, type,\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), force));\n       break;\n \n     case tcc_unary:\n       /* Recursively stabilize each operand.  */\n-      result = build1 (code, type,\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n-\t\t\t\t\t\t   force));\n+      result\n+\t= build1 (code, type,\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force));\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  /* See similar handling in maybe_stabilize_reference.  */\n   TREE_READONLY (result) = TREE_READONLY (e);\n-\n-  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n+\n   return result;\n }\n \f"}, {"sha": "f35e9c729d72749e6f904f029ad0d7df6d141144", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -3587,7 +3587,7 @@ convert_to_fat_pointer (tree type, tree expr)\n     {\n       tree fields = TYPE_FIELDS (TREE_TYPE (etype));\n \n-      expr = save_expr (expr);\n+      expr = protect_multiple_eval (expr);\n       if (TREE_CODE (expr) == ADDR_EXPR)\n \texpr = TREE_OPERAND (expr, 0);\n       else\n@@ -3881,7 +3881,8 @@ convert (tree type, tree expr)\n \t      /* If packing has made this field a bitfield and the input\n \t\t value couldn't be emitted statically any more, we need to\n \t\t clear TREE_CONSTANT on our output.  */\n-\t      if (!clear_constant && TREE_CONSTANT (expr)\n+\t      if (!clear_constant\n+\t\t  && TREE_CONSTANT (expr)\n \t\t  && !CONSTRUCTOR_BITFIELD_P (efield)\n \t\t  && CONSTRUCTOR_BITFIELD_P (field)\n \t\t  && !initializer_constant_valid_for_bitfield_p (value))\n@@ -3900,7 +3901,7 @@ convert (tree type, tree expr)\n \t      TREE_TYPE (expr) = type;\n \t      CONSTRUCTOR_ELTS (expr) = v;\n \t      if (clear_constant)\n-\t\tTREE_CONSTANT (expr) = TREE_STATIC (expr) = false;\n+\t\tTREE_CONSTANT (expr) = TREE_STATIC (expr) = 0;\n \t      return expr;\n \t    }\n \t}\n@@ -4251,8 +4252,7 @@ maybe_unconstrained_array (tree exp)\n \t\t\t      build_component_ref (TREE_OPERAND (exp, 0),\n \t\t\t\t\t\t   get_identifier (\"P_ARRAY\"),\n \t\t\t\t\t\t   NULL_TREE, false));\n-\t  TREE_READONLY (new_exp) = TREE_STATIC (new_exp)\n-\t    = TREE_READONLY (exp);\n+\t  TREE_READONLY (new_exp) = TREE_READONLY (exp);\n \t  return new_exp;\n \t}\n \n@@ -4735,7 +4735,7 @@ build_void_list_node (void)\n static tree\n builtin_type_for_size (int size, bool unsignedp)\n {\n-  tree type = lang_hooks.types.type_for_size (size, unsignedp);\n+  tree type = gnat_type_for_size (size, unsignedp);\n   return type ? type : error_mark_node;\n }\n "}, {"sha": "5db38c531b0c7a06db72c11c605bfb346536ea75", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 47, "deletions": 131, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced572837c918c138eee3e901d4b11a9996d7f07/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=ced572837c918c138eee3e901d4b11a9996d7f07", "patch": "@@ -49,8 +49,6 @@\n #include \"gigi.h\"\n \n static tree find_common_type (tree, tree);\n-static bool contains_save_expr_p (tree);\n-static tree contains_null_expr (tree);\n static tree compare_arrays (tree, tree, tree);\n static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n static tree build_simple_component_ref (tree, tree, tree, bool);\n@@ -233,100 +231,13 @@ find_common_type (tree t1, tree t2)\n   return NULL_TREE;\n }\n \f\n-/* See if EXP contains a SAVE_EXPR in a position where we would\n-   normally put it.\n+/* Return an expression tree representing an equality comparison of A1 and A2,\n+   two objects of type ARRAY_TYPE.  The result should be of type RESULT_TYPE.\n \n-   ??? This is a real kludge, but is probably the best approach short\n-   of some very general solution.  */\n-\n-static bool\n-contains_save_expr_p (tree exp)\n-{\n-  switch (TREE_CODE (exp))\n-    {\n-    case SAVE_EXPR:\n-      return true;\n-\n-    case ADDR_EXPR:  case INDIRECT_REF:\n-    case COMPONENT_REF:\n-    CASE_CONVERT: case VIEW_CONVERT_EXPR:\n-      return contains_save_expr_p (TREE_OPERAND (exp, 0));\n-\n-    case CONSTRUCTOR:\n-      {\n-\ttree value;\n-\tunsigned HOST_WIDE_INT ix;\n-\n-\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), ix, value)\n-\t  if (contains_save_expr_p (value))\n-\t    return true;\n-\treturn false;\n-      }\n-\n-    default:\n-      return false;\n-    }\n-}\n-\f\n-/* See if EXP contains a NULL_EXPR in an expression we use for sizes. Return\n-   it if so.  This is used to detect types whose sizes involve computations\n-   that are known to raise Constraint_Error.  */\n-\n-static tree\n-contains_null_expr (tree exp)\n-{\n-  tree tem;\n-\n-  if (TREE_CODE (exp) == NULL_EXPR)\n-    return exp;\n-\n-  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n-    {\n-    case tcc_unary:\n-      return contains_null_expr (TREE_OPERAND (exp, 0));\n-\n-    case tcc_comparison:\n-    case tcc_binary:\n-      tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-      if (tem)\n-\treturn tem;\n-\n-      return contains_null_expr (TREE_OPERAND (exp, 1));\n-\n-    case tcc_expression:\n-      switch (TREE_CODE (exp))\n-\t{\n-\tcase SAVE_EXPR:\n-\t  return contains_null_expr (TREE_OPERAND (exp, 0));\n-\n-\tcase COND_EXPR:\n-\t  tem = contains_null_expr (TREE_OPERAND (exp, 0));\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  tem = contains_null_expr (TREE_OPERAND (exp, 1));\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  return contains_null_expr (TREE_OPERAND (exp, 2));\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\f\n-/* Return an expression tree representing an equality comparison of\n-   A1 and A2, two objects of ARRAY_TYPE.  The returned expression should\n-   be of type RESULT_TYPE\n-\n-   Two arrays are equal in one of two ways: (1) if both have zero length\n-   in some dimension (not necessarily the same dimension) or (2) if the\n-   lengths in each dimension are equal and the data is equal.  We perform the\n-   length tests in as efficient a manner as possible.  */\n+   Two arrays are equal in one of two ways: (1) if both have zero length in\n+   some dimension (not necessarily the same dimension) or (2) if the lengths\n+   in each dimension are equal and the data is equal.  We perform the length\n+   tests in as efficient a manner as possible.  */\n \n static tree\n compare_arrays (tree result_type, tree a1, tree a2)\n@@ -336,8 +247,18 @@ compare_arrays (tree result_type, tree a1, tree a2)\n   tree result = convert (result_type, integer_one_node);\n   tree a1_is_null = convert (result_type, integer_zero_node);\n   tree a2_is_null = convert (result_type, integer_zero_node);\n+  bool a1_side_effects_p = TREE_SIDE_EFFECTS (a1);\n+  bool a2_side_effects_p = TREE_SIDE_EFFECTS (a2);\n   bool length_zero_p = false;\n \n+  /* If either operand has side-effects, they have to be evaluated only once\n+     in spite of the multiple references to the operand in the comparison.  */\n+  if (a1_side_effects_p)\n+    a1 = protect_multiple_eval (a1);\n+\n+  if (a2_side_effects_p)\n+    a2 = protect_multiple_eval (a2);\n+\n   /* Process each dimension separately and compare the lengths.  If any\n      dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n      suppress the comparison of the data.  */\n@@ -350,9 +271,9 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       tree bt = get_base_type (TREE_TYPE (lb1));\n       tree length1 = fold_build2 (MINUS_EXPR, bt, ub1, lb1);\n       tree length2 = fold_build2 (MINUS_EXPR, bt, ub2, lb2);\n-      tree nbt;\n-      tree tem;\n       tree comparison, this_a1_is_null, this_a2_is_null;\n+      tree nbt, tem;\n+      bool btem;\n \n       /* If the length of the first array is a constant, swap our operands\n \t unless the length of the second array is the constant zero.\n@@ -367,6 +288,8 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  tem = ub1, ub1 = ub2, ub2 = tem;\n \t  tem = length1, length1 = length2, length2 = tem;\n \t  tem = a1_is_null, a1_is_null = a2_is_null, a2_is_null = tem;\n+\t  btem = a1_side_effects_p, a1_side_effects_p = a2_side_effects_p,\n+\t  a2_side_effects_p = btem;\n \t}\n \n       /* If the length of this dimension in the second array is the constant\n@@ -449,11 +372,13 @@ compare_arrays (tree result_type, tree a1, tree a2)\n       tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n \n       if (type)\n-\ta1 = convert (type, a1), a2 = convert (type, a2);\n+\t{\n+\t  a1 = convert (type, a1),\n+\t  a2 = convert (type, a2);\n+\t}\n \n       result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n \t\t\t\tfold_build2 (EQ_EXPR, result_type, a1, a2));\n-\n     }\n \n   /* The result is also true if both sizes are zero.  */\n@@ -462,14 +387,13 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t\t\t\t\t     a1_is_null, a2_is_null),\n \t\t\t    result);\n \n-  /* If either operand contains SAVE_EXPRs, they have to be evaluated before\n-     starting the comparison above since the place it would be otherwise\n-     evaluated would be wrong.  */\n-\n-  if (contains_save_expr_p (a1))\n+  /* If either operand has side-effects, they have to be evaluated before\n+     starting the comparison above since the place they would be otherwise\n+     evaluated could be wrong.  */\n+  if (a1_side_effects_p)\n     result = build2 (COMPOUND_EXPR, result_type, a1, result);\n \n-  if (contains_save_expr_p (a2))\n+  if (a2_side_effects_p)\n     result = build2 (COMPOUND_EXPR, result_type, a2, result);\n \n   return result;\n@@ -547,7 +471,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* For subtraction, add the modulus back if we are negative.  */\n   else if (op_code == MINUS_EXPR)\n     {\n-      result = save_expr (result);\n+      result = protect_multiple_eval (result);\n       result = fold_build3 (COND_EXPR, op_type,\n \t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n \t\t\t\t\t convert (op_type, integer_zero_node)),\n@@ -558,7 +482,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* For the other operations, subtract the modulus if we are >= it.  */\n   else\n     {\n-      result = save_expr (result);\n+      result = protect_multiple_eval (result);\n       result = fold_build3 (COND_EXPR, op_type,\n \t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n \t\t\t\t\t result, modulus),\n@@ -1241,7 +1165,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t{\n \t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n \t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n-\t  TREE_READONLY (result) = TREE_STATIC (result)\n+\t  TREE_READONLY (result)\n \t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n \t}\n       else if (TREE_CODE (operand) == ADDR_EXPR)\n@@ -1590,13 +1514,6 @@ gnat_build_constructor (tree type, tree list)\n \n       if (TREE_SIDE_EFFECTS (val))\n \tside_effects = true;\n-\n-      /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n-\t be executing the code we generate here in that case, but handle it\n-\t specially to avoid the compiler blowing up.  */\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  && (result = contains_null_expr (DECL_SIZE (obj))) != NULL_TREE)\n-\treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n     }\n \n   /* For record types with constant components only, sort field list\n@@ -1883,7 +1800,7 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n     {\n       /* Latch malloc's return value and get a pointer to the aligning field\n \t first.  */\n-      tree storage_ptr = save_expr (malloc_ptr);\n+      tree storage_ptr = protect_multiple_eval (malloc_ptr);\n \n       tree aligning_record_addr\n \t= convert (build_pointer_type (aligning_type), storage_ptr);\n@@ -2118,12 +2035,11 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t\t      gnat_proc, gnat_pool,\n \t\t\t\t\t      gnat_node));\n \n-  /* If we have an initial value, put the new address into a SAVE_EXPR, assign\n-     the value, and return the address.  Do this with a COMPOUND_EXPR.  */\n-\n+  /* If we have an initial value, protect the new address, assign the value\n+     and return the address with a COMPOUND_EXPR.  */\n   if (init)\n     {\n-      result = save_expr (result);\n+      result = protect_multiple_eval (result);\n       result\n \t= build2 (COMPOUND_EXPR, TREE_TYPE (result),\n \t\t  build_binary_op\n@@ -2188,14 +2104,14 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n   return gnat_build_constructor (record_type, nreverse (const_list));\n }\n \n-/* Indicate that we need to make the address of EXPR_NODE and it therefore\n+/* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n \n bool\n-gnat_mark_addressable (tree expr_node)\n+gnat_mark_addressable (tree t)\n {\n-  while (1)\n-    switch (TREE_CODE (expr_node))\n+  while (true)\n+    switch (TREE_CODE (t))\n       {\n       case ADDR_EXPR:\n       case COMPONENT_REF:\n@@ -2206,27 +2122,27 @@ gnat_mark_addressable (tree expr_node)\n       case VIEW_CONVERT_EXPR:\n       case NON_LVALUE_EXPR:\n       CASE_CONVERT:\n-\texpr_node = TREE_OPERAND (expr_node, 0);\n+\tt = TREE_OPERAND (t, 0);\n \tbreak;\n \n       case CONSTRUCTOR:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n+\tTREE_ADDRESSABLE (t) = 1;\n \treturn true;\n \n       case VAR_DECL:\n       case PARM_DECL:\n       case RESULT_DECL:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n+\tTREE_ADDRESSABLE (t) = 1;\n \treturn true;\n \n       case FUNCTION_DECL:\n-\tTREE_ADDRESSABLE (expr_node) = 1;\n+\tTREE_ADDRESSABLE (t) = 1;\n \treturn true;\n \n       case CONST_DECL:\n-\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node)\n-\t\t&& (gnat_mark_addressable\n-\t\t    (DECL_CONST_CORRESPONDING_VAR (expr_node))));\n+\treturn DECL_CONST_CORRESPONDING_VAR (t)\n+\t       && gnat_mark_addressable (DECL_CONST_CORRESPONDING_VAR (t));\n+\n       default:\n \treturn true;\n     }"}]}