{"sha": "66576e1bc7e407f69d09c2b85b69d65b70df4643", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1NzZlMWJjN2U0MDdmNjlkMDljMmI4NWI2OWQ2NWI3MGRmNDY0Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-19T23:55:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-19T23:55:38Z"}, "message": "ipareference2_0.c: New file.\n\n\t* gcc.dg/lto/ipareference2_0.c: New file.\n\t* gcc.dg/lto/ipareference2_1.c: New file.\n\t* lto.c (promote_var, promote_fn): New functions.\n\t(lto_promote_cross_file_statics): Compute correctly boundary including\n\tstatic initializers of readonly vars.\n\nFrom-SVN: r159604", "tree": {"sha": "6693d9b62dde78d7a6046c55afba52bd7195c4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6693d9b62dde78d7a6046c55afba52bd7195c4e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66576e1bc7e407f69d09c2b85b69d65b70df4643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66576e1bc7e407f69d09c2b85b69d65b70df4643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66576e1bc7e407f69d09c2b85b69d65b70df4643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66576e1bc7e407f69d09c2b85b69d65b70df4643/comments", "author": null, "committer": null, "parents": [{"sha": "676dd4d4df5ec4d6bece743cb8d87d862bc3c379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/676dd4d4df5ec4d6bece743cb8d87d862bc3c379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/676dd4d4df5ec4d6bece743cb8d87d862bc3c379"}], "stats": {"total": 165, "additions": 143, "deletions": 22}, "files": [{"sha": "492cd6152dce2f0414cbee5b1e53511eb1381163", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=66576e1bc7e407f69d09c2b85b69d65b70df4643", "patch": "@@ -1,6 +1,12 @@\n+2010-05-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (promote_var, promote_fn): New functions.\n+\t(lto_promote_cross_file_statics): Compute correctly boundary including\n+\tstatic initializers of readonly vars.\n+\n 2010-05-18  Jan Hubicka  <jh@suse.cz>\n \n-\t* lto/lto.c (lto_1_to_1_map): Partition non-inline clones.\n+\t* lto.c (lto_1_to_1_map): Partition non-inline clones.\n \t(lto_promote_cross_file_statics): Deal with non-inline clones.\n \n 2010-05-18  Jan Hubicka  <jh@suse.cz>"}, {"sha": "92fa4dd5a3804bdddc532f420447138116f36336", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 102, "deletions": 21, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=66576e1bc7e407f69d09c2b85b69d65b70df4643", "patch": "@@ -691,6 +691,42 @@ lto_add_all_inlinees (cgraph_node_set set)\n   lto_bitmap_free (original_decls);\n }\n \n+/* Promote variable VNODE to be static.  */\n+\n+static bool\n+promote_var (struct varpool_node *vnode)\n+{\n+  if (TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl))\n+    return false;\n+  gcc_assert (flag_wpa);\n+  TREE_PUBLIC (vnode->decl) = 1;\n+  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n+  return true;\n+}\n+\n+/* Promote function NODE to be static.  */\n+\n+static bool\n+promote_fn (struct cgraph_node *node)\n+{\n+  gcc_assert (flag_wpa);\n+  if (TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n+    return false;\n+  TREE_PUBLIC (node->decl) = 1;\n+  DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n+  if (node->same_body)\n+    {\n+      struct cgraph_node *alias;\n+      for (alias = node->same_body;\n+\t   alias; alias = alias->next)\n+\t{\n+\t  TREE_PUBLIC (alias->decl) = 1;\n+\t  DECL_VISIBILITY (alias->decl) = VISIBILITY_HIDDEN;\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Find out all static decls that need to be promoted to global because\n    of cross file sharing.  This function must be run in the WPA mode after\n    all inlinees are added.  */\n@@ -704,6 +740,8 @@ lto_promote_cross_file_statics (void)\n   varpool_node_set vset;\n   cgraph_node_set_iterator csi;\n   varpool_node_set_iterator vsi;\n+  VEC(varpool_node_ptr, heap) *promoted_initializers = NULL;\n+  struct pointer_set_t *inserted = pointer_set_create ();\n \n   gcc_assert (flag_wpa);\n \n@@ -725,21 +763,7 @@ lto_promote_cross_file_statics (void)\n \t  if (!DECL_EXTERNAL (node->decl)\n \t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n \t\t  || reachable_from_other_partition_p (node, set)))\n-\t     {\n-\t\tgcc_assert (flag_wpa);\n-\t\tTREE_PUBLIC (node->decl) = 1;\n-\t\tDECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n-\t\tif (node->same_body)\n-\t\t  {\n-\t\t    struct cgraph_node *alias;\n-\t\t    for (alias = node->same_body;\n-\t\t\t alias; alias = alias->next)\n-\t\t      {\n-\t\t\tTREE_PUBLIC (alias->decl) = 1;\n-\t\t\tDECL_VISIBILITY (alias->decl) = VISIBILITY_HIDDEN;\n-\t\t      }\n-\t\t  }\n-\t     }\n+\t    promote_fn (node);\n \t}\n       for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n \t{\n@@ -748,16 +772,73 @@ lto_promote_cross_file_statics (void)\n \t     be made global.  It is sensible to keep those ltrans local to\n \t     allow better optimization.  */\n \t  if (!DECL_IN_CONSTANT_POOL (vnode->decl)\n-\t      && !vnode->externally_visible && vnode->analyzed\n-\t      && referenced_from_other_partition_p (&vnode->ref_list, set, vset))\n+\t     && !vnode->externally_visible && vnode->analyzed\n+\t     && referenced_from_other_partition_p (&vnode->ref_list,\n+\t\t\t\t\t\t   set, vset))\n+\t    promote_var (vnode);\n+\t}\n+\n+      /* We export initializers of read-only var into each partition\n+\t referencing it.  Folding might take declarations from the\n+\t initializers and use it; so everything referenced from the\n+\t initializers needs can be accessed from this partition after\n+\t folding.\n+\n+\t This means that we need to promote all variables and functions\n+\t referenced from all initializers from readonly vars referenced\n+\t from this partition that are not in this partition.\n+\t This needs to be done recursively.  */\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif ((TREE_READONLY (vnode->decl) || DECL_IN_CONSTANT_POOL (vnode->decl))\n+\t    && DECL_INITIAL (vnode->decl)\n+\t    && !varpool_node_in_set_p (vnode, vset)\n+\t    && referenced_from_this_partition_p (&vnode->ref_list, set, vset)\n+\t    && !pointer_set_insert (inserted, vnode))\n+\tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n+      while (!VEC_empty (varpool_node_ptr, promoted_initializers))\n+\t{\n+\t  int i;\n+\t  struct ipa_ref *ref;\n+\n+\t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref); i++)\n \t    {\n-\t      gcc_assert (flag_wpa);\n-\t      TREE_PUBLIC (vnode->decl) = 1;\n-\t      DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n+\t      if (ref->refered_type == IPA_REF_CGRAPH)\n+\t\t{\n+\t\t  struct cgraph_node *n = ipa_ref_node (ref);\n+\t\t  gcc_assert (!n->global.inlined_to);\n+\t\t  if (!n->local.externally_visible\n+\t\t      && !cgraph_node_in_set_p (n, set))\n+\t\t    promote_fn (n);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct varpool_node *v = ipa_ref_varpool_node (ref);\n+\t\t  if (varpool_node_in_set_p (v, vset))\n+\t\t    continue;\n+\t\t  /* Constant pool references use internal labels and thus can not\n+\t\t     be made global.  It is sensible to keep those ltrans local to\n+\t\t     allow better optimization.  */\n+\t\t  if (DECL_IN_CONSTANT_POOL (v->decl))\n+\t\t    {\n+\t\t      if (!pointer_set_insert (inserted, vnode))\n+\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n+\t\t\t\t       promoted_initializers, v);\n+\t\t    }\n+\t\t  else if (!DECL_IN_CONSTANT_POOL (v->decl)\n+\t\t\t   && !v->externally_visible && v->analyzed)\n+\t\t    {\n+\t\t      if (promote_var (v)\n+\t\t\t  && DECL_INITIAL (v->decl) && TREE_READONLY (v->decl)\n+\t\t\t  && !pointer_set_insert (inserted, vnode))\n+\t\t\tVEC_safe_push (varpool_node_ptr, heap,\n+\t\t\t\t       promoted_initializers, v);\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n-\n     }\n+  pointer_set_destroy (inserted);\n }\n \n "}, {"sha": "b798cd6b4d5975e96e39d28f7585a71e33ec1e13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=66576e1bc7e407f69d09c2b85b69d65b70df4643", "patch": "@@ -1,3 +1,8 @@\n+2010-05-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/lto/ipareference2_0.c: New file.\n+\t* gcc.dg/lto/ipareference2_1.c: New file.\n+\n 2010-05-19  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/parse/fn-typedef2.C: New."}, {"sha": "b7b13e6b9a4016ef66d371a2702c0cb95ec90d95", "filename": "gcc/testsuite/gcc.dg/lto/ipareference2_0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_0.c?ref=66576e1bc7e407f69d09c2b85b69d65b70df4643", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-lto-options {{ -O1 -fwhopr -fwhole-program}} } */\n+/* { dg-lto-do run } */\n+\n+/* Verify that ipa-reference marks A as constant and we fold references\n+   to a[1] and a[2] to &c and that we promote C to hidden vars shared across ltrans units. */\n+void abort (void);\n+int b,c,d,e,f;\n+int *a[5]={&b,&c,&c,&e};\n+void other_ltrans (void);\n+main()\n+{\n+  other_ltrans ();\n+  if (*(a[1])!=11)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c7653b0807ba04e3987932328b3eef9371d5be3b", "filename": "gcc/testsuite/gcc.dg/lto/ipareference2_1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66576e1bc7e407f69d09c2b85b69d65b70df4643/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fipareference2_1.c?ref=66576e1bc7e407f69d09c2b85b69d65b70df4643", "patch": "@@ -0,0 +1,13 @@\n+void abort (void);\n+extern int *a[5];\n+extern int b,c,d,e,f;\n+__attribute__ ((noinline, noclone))\n+void\n+other_ltrans (void)\n+{\n+  if (!__builtin_constant_p (a[1]==a[2]))\n+    abort ();\n+  if (a[1]!=a[2])\n+    abort ();\n+  *(a[1])=11;\n+}"}]}