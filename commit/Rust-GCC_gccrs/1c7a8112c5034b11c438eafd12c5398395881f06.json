{"sha": "1c7a8112c5034b11c438eafd12c5398395881f06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3YTgxMTJjNTAzNGIxMWM0MzhlYWZkMTJjNTM5ODM5NTg4MWYwNg==", "commit": {"author": {"name": "Alan Modra", "email": "alan@linuxcare.com.au", "date": "2001-04-03T06:57:31Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-03T06:57:31Z"}, "message": "Rewrite hppa profiling support.\n\n\t* config/pa/pa.c (override_options): Remove PIC profiling warning.\n\t(hp_profile_labelno): Delete.\n\t(hp_profile_label_rtx): Delete.\n\t(hp_profile_label_name): Delete.\n\t(pa_add_gc_roots): Remove reference to hp_profile_label_rtx.\n\t(output_function_prologue): Remove profiling code and all tests on\n\tprofile_flag.  Move store of PIC_OFFSET_TABLE_REGNUM now that\n\tmerge_sp_adjust_with_store can work for PIC and profiling.\n\t(hppa_expand_epilogue): Remove profile_flag test.\n\t(hppa_can_use_return_insn_p): Likewise.\n\t(hppa_init_pic_save): Emit before tail_recursion_reentry, and\n\tcater for PROFILE_HOOK.\n\t(hppa_profile_hook): New function.\n\t* config/pa/pa.h (FUNCTION_PROFILER): Now does nothing.\n\t(PROFILE_HOOK): Define.\n\t(hppa_profile_hook): Declare.\n\t(PROFILE_BEFORE_PROLOGUE): Delete.\n\t(ASM_OUTPUT_REG_PUSH): Delete.\n\t(ASM_OUTPUT_REG_POP): Delete.\n\t* config/pa/pa.md (call_profiler): Turn it into a call insn, and\n\tdon't `use' r24.  Accept function name operand, and use this and a\n\tlocally generated label to calculate pc-rel offset to func start.\n\nFrom-SVN: r41038", "tree": {"sha": "b9bf6476fa74b761c8ff665141a55ff446041799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9bf6476fa74b761c8ff665141a55ff446041799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c7a8112c5034b11c438eafd12c5398395881f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7a8112c5034b11c438eafd12c5398395881f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7a8112c5034b11c438eafd12c5398395881f06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7a8112c5034b11c438eafd12c5398395881f06/comments", "author": null, "committer": null, "parents": [{"sha": "fe01b88e5acac29092b892743a5f2a3ae30dd594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe01b88e5acac29092b892743a5f2a3ae30dd594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe01b88e5acac29092b892743a5f2a3ae30dd594"}], "stats": {"total": 264, "additions": 152, "deletions": 112}, "files": [{"sha": "22db93e137a22469d8bcc3c12ba5076e6a607d16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c7a8112c5034b11c438eafd12c5398395881f06", "patch": "@@ -1,3 +1,28 @@\n+2001-04-03  Alan Modra  <alan@linuxcare.com.au>\n+\n+\t* config/pa/pa.c (override_options): Remove PIC profiling warning.\n+\t(hp_profile_labelno): Delete.\n+\t(hp_profile_label_rtx): Delete.\n+\t(hp_profile_label_name): Delete.\n+\t(pa_add_gc_roots): Remove reference to hp_profile_label_rtx.\n+\t(output_function_prologue): Remove profiling code and all tests on\n+\tprofile_flag.  Move store of PIC_OFFSET_TABLE_REGNUM now that\n+\tmerge_sp_adjust_with_store can work for PIC and profiling.\n+\t(hppa_expand_epilogue): Remove profile_flag test.\n+\t(hppa_can_use_return_insn_p): Likewise.\n+\t(hppa_init_pic_save): Emit before tail_recursion_reentry, and\n+\tcater for PROFILE_HOOK.\n+\t(hppa_profile_hook): New function.\n+\t* config/pa/pa.h (FUNCTION_PROFILER): Now does nothing.\n+\t(PROFILE_HOOK): Define.\n+\t(hppa_profile_hook): Declare.\n+\t(PROFILE_BEFORE_PROLOGUE): Delete.\n+\t(ASM_OUTPUT_REG_PUSH): Delete.\n+\t(ASM_OUTPUT_REG_POP): Delete.\n+\t* config/pa/pa.md (call_profiler): Turn it into a call insn, and\n+\tdon't `use' r24.  Accept function name operand, and use this and a\n+\tlocally generated label to calculate pc-rel offset to func start.\n+\n 2001-04-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* $(HOST_PREFIX_1)errors.o, $(HOST_PREFIX_1)ggc-none.o,"}, {"sha": "786ff50ce853d0f649cd803fd5ca4c64f661d9f2", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 101, "deletions": 99, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=1c7a8112c5034b11c438eafd12c5398395881f06", "patch": "@@ -76,9 +76,6 @@ enum architecture_type pa_arch;\n /* String to hold which architecture we are generating code for.  */\n const char *pa_arch_string;\n \n-/* Set by the FUNCTION_PROFILER macro. */\n-int hp_profile_labelno;\n-\n /* Counts for the number of callee-saved general and floating point\n    registers which were saved by the current function's prologue.  */\n static int gr_saved, fr_saved;\n@@ -170,11 +167,6 @@ override_options ()\n       warning (\"PIC code generation is not compatible with fast indirect calls\\n\");\n    }\n \n-  if (flag_pic && profile_flag)\n-    {\n-      warning (\"PIC code generation is not compatible with profiling\\n\");\n-    }\n-\n   if (! TARGET_GAS && write_symbols != NO_DEBUG)\n     {\n       warning (\"-g is only supported when using GAS on this processor,\");\n@@ -2886,8 +2878,6 @@ compute_frame_size (size, fregs_live)\n   return (fsize + STACK_BOUNDARY - 1) & ~(STACK_BOUNDARY - 1);\n }\n \n-rtx hp_profile_label_rtx;\n-static char hp_profile_label_name[8];\n void\n output_function_prologue (file, size)\n      FILE *file;\n@@ -2903,7 +2893,7 @@ output_function_prologue (file, size)\n      to output the assembler directives which denote the start\n      of a function.  */\n   fprintf (file, \"\\t.CALLINFO FRAME=%d\", actual_fsize);\n-  if (regs_ever_live[2] || profile_flag)\n+  if (regs_ever_live[2])\n     fputs (\",CALLS,SAVE_RP\", file);\n   else\n     fputs (\",NO_CALLS\", file);\n@@ -2927,12 +2917,6 @@ output_function_prologue (file, size)\n \n   fputs (\"\\n\\t.ENTRY\\n\", file);\n \n-  /* Horrid hack.  emit_function_prologue will modify this RTL in\n-     place to get the expected results.  */\n-  if (profile_flag)\n-    ASM_GENERATE_INTERNAL_LABEL (hp_profile_label_name, \"LP\",\n-\t\t\t\t hp_profile_labelno);\n-\n   /* If we're using GAS and not using the portable runtime model, then\n      we don't need to accumulate the total number of code bytes.  */\n   if (TARGET_GAS && ! TARGET_PORTABLE_RUNTIME)\n@@ -2983,7 +2967,7 @@ hppa_expand_prologue()\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp-20 or sp - 16\n      depending on which ABI is in use.  */\n-  if (regs_ever_live[2] || profile_flag)\n+  if (regs_ever_live[2])\n     store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n@@ -3030,10 +3014,7 @@ hppa_expand_prologue()\n \t     and allocating the stack frame at the same time.   If so, just\n \t     make a note of it and defer allocating the frame until saving\n \t     the callee registers.  */\n-\t  if (VAL_14_BITS_P (actual_fsize)\n-\t      && local_fsize == 0\n-\t      && ! profile_flag\n-\t      && ! flag_pic)\n+\t  if (VAL_14_BITS_P (actual_fsize) && local_fsize == 0)\n \t    merge_sp_adjust_with_store = 1;\n \t  /* Can not optimize.  Adjust the stack frame by actual_fsize\n \t     bytes.  */\n@@ -3042,77 +3023,6 @@ hppa_expand_prologue()\n \t\t\t    STACK_POINTER_REGNUM,\n \t\t\t    actual_fsize);\n \t}\n-\n-      /* The hppa calling conventions say that %r19, the pic offset\n-\t register, is saved at sp - 32 (in this function's frame)\n-\t when generating PIC code.  FIXME:  What is the correct thing\n-\t to do for functions which make no calls and allocate no\n-\t frame?  Do we need to allocate a frame, or can we just omit\n-\t the save?   For now we'll just omit the save.  */\n-      if (flag_pic && !TARGET_64BIT)\n-\tstore_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n-    }\n-\n-  /* Profiling code.\n-\n-     Instead of taking one argument, the counter label, as most normal\n-     mcounts do, _mcount appears to behave differently on the HPPA.  It\n-     takes the return address of the caller, the address of this routine,\n-     and the address of the label.  Also, it isn't magic, so\n-     argument registers have to be preserved.  */\n-  if (profile_flag)\n-    {\n-      int pc_offset, i, arg_offset, basereg, offsetadj;\n-\n-      pc_offset = 4 + (frame_pointer_needed\n-\t\t       ? (VAL_14_BITS_P (actual_fsize) ? 12 : 20)\n-\t\t       : (VAL_14_BITS_P (actual_fsize) ? 4 : 8));\n-\n-      /* When the function has a frame pointer, use it as the base\n-\t register for saving/restore registers.  Else use the stack\n-\t pointer.  Adjust the offset according to the frame size if\n-\t this function does not have a frame pointer.  */\n-\n-      basereg = frame_pointer_needed ? FRAME_POINTER_REGNUM\n-\t\t\t\t     : STACK_POINTER_REGNUM;\n-      offsetadj = frame_pointer_needed ? 0 : actual_fsize;\n-\n-      /* Horrid hack.  emit_function_prologue will modify this RTL in\n-\t place to get the expected results.   sprintf here is just to\n-\t put something in the name.  */\n-      sprintf(hp_profile_label_name, \"LP$%04d\", -1);\n-      hp_profile_label_rtx = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t\t hp_profile_label_name);\n-      if (current_function_returns_struct)\n-\tstore_reg (STRUCT_VALUE_REGNUM, - 12 - offsetadj, basereg);\n-      if (current_function_needs_context)\n-\tstore_reg (STATIC_CHAIN_REGNUM, - 16 - offsetadj, basereg);\n-\n-      for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n-\tif (regs_ever_live [i])\n-\t  {\n-\t    store_reg (i, arg_offset, basereg);\n-\t    /* Deal with arg_offset not fitting in 14 bits.  */\n-\t    pc_offset += VAL_14_BITS_P (arg_offset) ? 4 : 8;\n-\t  }\n-\n-      emit_move_insn (gen_rtx_REG (word_mode, 26), gen_rtx_REG (word_mode, 2));\n-      emit_move_insn (tmpreg, gen_rtx_HIGH (Pmode, hp_profile_label_rtx));\n-      emit_move_insn (gen_rtx_REG (Pmode, 24),\n-\t\t      gen_rtx_LO_SUM (Pmode, tmpreg, hp_profile_label_rtx));\n-      /* %r25 is set from within the output pattern.  */\n-      emit_insn (gen_call_profiler (GEN_INT (- pc_offset - 20)));\n-\n-      /* Restore argument registers.  */\n-      for (i = 26, arg_offset = -36 - offsetadj; i >= 23; i--, arg_offset -= 4)\n-\tif (regs_ever_live [i])\n-\t  load_reg (i, arg_offset, basereg);\n-\n-      if (current_function_returns_struct)\n-\tload_reg (STRUCT_VALUE_REGNUM, -12 - offsetadj, basereg);\n-\n-      if (current_function_needs_context)\n-\tload_reg (STATIC_CHAIN_REGNUM, -16 - offsetadj, basereg);\n     }\n \n   /* Normal register save.\n@@ -3160,6 +3070,15 @@ hppa_expand_prologue()\n \t\t\tactual_fsize);\n     }\n \n+  /* The hppa calling conventions say that %r19, the pic offset\n+     register, is saved at sp - 32 (in this function's frame)\n+     when generating PIC code.  FIXME:  What is the correct thing\n+     to do for functions which make no calls and allocate no\n+     frame?  Do we need to allocate a frame, or can we just omit\n+     the save?   For now we'll just omit the save.  */\n+  if (flag_pic && actual_fsize != 0 && !TARGET_64BIT)\n+    store_reg (PIC_OFFSET_TABLE_REGNUM, -32, STACK_POINTER_REGNUM);\n+\n   /* Align pointer properly (doubleword boundary).  */\n   offset = (offset + 7) & ~7;\n \n@@ -3235,7 +3154,7 @@ hppa_expand_epilogue ()\n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n      be necessary even when we schedule the prologue and epilogue. */\n-  if (regs_ever_live [2] || profile_flag)\n+  if (regs_ever_live [2])\n     {\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n@@ -3357,9 +3276,94 @@ void hppa_init_pic_save ()\n   insn = gen_rtx_SET (VOIDmode, PIC_OFFSET_TABLE_SAVE_RTX, picreg);\n \n   /* Emit the insn at the beginning of the function after the prologue.  */\n-  push_topmost_sequence ();\n-  emit_insn_after (insn, last_parm_insn ? last_parm_insn : get_insns ());\n-  pop_topmost_sequence ();\n+  if (tail_recursion_reentry)\n+    emit_insn_before (insn, tail_recursion_reentry);\n+  else\n+    /* We must have been called via PROFILE_HOOK.  */\n+    emit_insn (insn);\n+}\n+\n+void\n+hppa_profile_hook (label_no)\n+     int label_no ATTRIBUTE_UNUSED;\n+{\n+  rtx call_insn;\n+\n+  /* No profiling for inline functions.  We don't want extra calls to\n+     _mcount when the inline function is expanded.  Even if that made\n+     sense, it wouldn't work here as there is no function label for\n+     the inline expansion.  */\n+  if (DECL_INLINE (cfun->decl))\n+    return;\n+\n+  if (TARGET_64BIT)\n+    emit_move_insn (arg_pointer_rtx,\n+\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t  GEN_INT (64)));\n+\n+  if (flag_pic && PIC_OFFSET_TABLE_SAVE_RTX == NULL_RTX)\n+    hppa_init_pic_save ();\n+\n+  emit_move_insn (gen_rtx_REG (word_mode, 26), gen_rtx_REG (word_mode, 2));\n+\n+#ifndef NO_PROFILE_COUNTERS\n+  {\n+    rtx count_label_rtx, addr, r24;\n+    char label_name[16];\n+\n+    ASM_GENERATE_INTERNAL_LABEL (label_name, \"LP\", label_no);\n+    count_label_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label_name));\n+\n+    if (flag_pic)\n+      {\n+\trtx tmpreg;\n+\n+\tcurrent_function_uses_pic_offset_table = 1;\n+\ttmpreg = gen_rtx_REG (Pmode, 1);\n+\temit_move_insn (tmpreg,\n+\t\t\tgen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t      gen_rtx_HIGH (Pmode, count_label_rtx)));\n+\taddr = gen_rtx_MEM (Pmode,\n+\t\t\t    gen_rtx_LO_SUM (Pmode, tmpreg, count_label_rtx));\n+      }\n+    else\n+      {\n+\trtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\temit_move_insn (tmpreg, gen_rtx_HIGH (Pmode, count_label_rtx));\n+\taddr = gen_rtx_LO_SUM (Pmode, tmpreg, count_label_rtx);\n+      }\n+    r24 = gen_rtx_REG (Pmode, 24);\n+    emit_move_insn (r24, addr);\n+\n+    /* %r25 is set from within the output pattern.  */\n+    call_insn =\n+      emit_call_insn (gen_call_profiler (gen_rtx_SYMBOL_REF (Pmode, \"_mcount\"),\n+\t\t\t\t\t GEN_INT (TARGET_64BIT ? 24 : 12),\n+\t\t\t\t\t XEXP (DECL_RTL (cfun->decl), 0)));\n+\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), r24);\n+  }\n+#else\n+    /* %r25 is set from within the output pattern.  */\n+  call_insn =\n+    emit_call_insn (gen_call_profiler (gen_rtx_SYMBOL_REF (Pmode, \"_mcount\"),\n+\t\t\t\t       GEN_INT (TARGET_64BIT ? 16 : 8),\n+\t\t\t\t       XEXP (DECL_RTL (cfun->decl), 0)));\n+#endif\n+\n+  /* Indicate the _mcount call cannot throw, nor will it execute a\n+     non-local goto.  */\n+  REG_NOTES (call_insn)\n+    = gen_rtx_EXPR_LIST (REG_EH_REGION, constm1_rtx, REG_NOTES (call_insn));\n+\n+  if (flag_pic)\n+    {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n+      if (TARGET_64BIT)\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n+\n+      emit_move_insn (pic_offset_table_rtx, PIC_OFFSET_TABLE_SAVE_RTX);\n+    }\n }\n \n /* Fetch the return address for the frame COUNT steps up from\n@@ -3475,7 +3479,6 @@ hppa_can_use_return_insn_p ()\n {\n   return (reload_completed\n \t  && (compute_frame_size (get_frame_size (), 0) ? 0 : 1)\n-\t  && ! profile_flag\n \t  && ! regs_ever_live[2]\n \t  && ! frame_pointer_needed);\n }\n@@ -7098,7 +7101,6 @@ pa_add_gc_roots ()\n {\n   ggc_add_rtx_root (&hppa_compare_op0, 1);\n   ggc_add_rtx_root (&hppa_compare_op1, 1);\n-  ggc_add_rtx_root (&hp_profile_label_rtx, 1);\n   ggc_add_root (&deferred_plabels, 1, sizeof (&deferred_plabels),\n \t\t&mark_deferred_plabels);\n }"}, {"sha": "82be654ee18f642db6ed04bbc38c88453ddb7a39", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=1c7a8112c5034b11c438eafd12c5398395881f06", "patch": "@@ -883,16 +883,13 @@ extern enum cmp_type hppa_branch_type;\n #define FUNCTION_PROLOGUE(FILE, SIZE) \\\n   output_function_prologue (FILE, SIZE)\n \n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.\n+/* On HPPA, we emit profiling code as rtl via PROFILE_HOOK rather than\n+   as assembly via FUNCTION_PROFILER.  */\n \n-   Because HPUX _mcount is so different, we actually emit the\n-   profiling code in function_prologue. This just stores LABELNO for\n-   that. */\n+#define FUNCTION_PROFILER(FILE, LABEL) /* nothing */\n \n-#define PROFILE_BEFORE_PROLOGUE\n-#define FUNCTION_PROFILER(FILE, LABELNO) \\\n-{ extern int hp_profile_labelno; hp_profile_labelno = (LABELNO);}\n+#define PROFILE_HOOK(label_no) hppa_profile_hook (label_no)\n+void hppa_profile_hook PARAMS ((int label_no));\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n@@ -1834,8 +1831,6 @@ while (0)\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii ((FILE), (P), (SIZE))\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n /* This is how to output an element of a case-vector that is absolute.\n    Note that this method makes filling these branch delay slots\n    impossible.  */"}, {"sha": "04362092bf3c9478ad810a6b53000f7da5417591", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7a8112c5034b11c438eafd12c5398395881f06/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=1c7a8112c5034b11c438eafd12c5398395881f06", "patch": "@@ -5513,10 +5513,28 @@\n ;; from within its delay slot to set the value for the 2nd parameter to\n ;; the call.\n (define_insn \"call_profiler\"\n-  [(unspec_volatile [(const_int 0)] 0)\n-   (use (match_operand:SI 0 \"const_int_operand\" \"\"))]\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (reg:SI 25))\n+   (use (reg:SI 26))\n+   (clobber (reg:SI 2))]\n   \"\"\n-  \"{bl|b,l} _mcount,%%r2\\;ldo %0(%%r2),%%r25\"\n+  \"*\n+{\n+  rtx xoperands[3];\n+\n+  output_arg_descriptor (insn);\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[2];\n+  xoperands[2] = gen_label_rtx ();\n+  output_asm_insn (\\\"{bl|b,l} %0,%%r2\\;ldo %1-%2(%%r2),%%r25\\\", xoperands);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (xoperands[2]));\n+  return \\\"\\\";\n+}\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n "}]}