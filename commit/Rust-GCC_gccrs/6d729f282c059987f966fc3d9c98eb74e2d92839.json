{"sha": "6d729f282c059987f966fc3d9c98eb74e2d92839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3MjlmMjgyYzA1OTk4N2Y5NjZmYzNkOWM5OGViNzRlMmQ5MjgzOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-05T16:32:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-05T16:32:20Z"}, "message": "re PR c++/43787 (memory copy of empty class (sizeof is one))\n\n\tPR c++/43787\ngcc:\n\t* gimplify.c (gimplify_expr): Keep working if gimplify_modify_expr\n\treturns GS_OK.\n\t(gimplify_modify_expr_rhs): Return GS_OK if anything changed.\ngcc/cp:\n\t* cp-gimplify.c (cp_gimplify_expr): Remove copies of empty classes.\n\t* call.c (build_over_call): Don't try to avoid INIT_EXPR copies here.\n\nFrom-SVN: r159072", "tree": {"sha": "76394a4dd6bd685ffee7f55fc84a357aecb19236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76394a4dd6bd685ffee7f55fc84a357aecb19236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d729f282c059987f966fc3d9c98eb74e2d92839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d729f282c059987f966fc3d9c98eb74e2d92839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d729f282c059987f966fc3d9c98eb74e2d92839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d729f282c059987f966fc3d9c98eb74e2d92839/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2c9b836ba7e2781effde72da473534cb32743ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c9b836ba7e2781effde72da473534cb32743ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c9b836ba7e2781effde72da473534cb32743ee"}], "stats": {"total": 492, "additions": 268, "deletions": 224}, "files": [{"sha": "26ef33b3fc7faef1207bff121acce6f33914d67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -1,3 +1,10 @@\n+2010-05-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/43787\n+\t* gimplify.c (gimplify_expr): Keep working if gimplify_modify_expr\n+\treturns GS_OK.\n+\t(gimplify_modify_expr_rhs): Return GS_OK if anything changed.\n+\n 2010-05-05  Alexandre Oliva  <aoliva@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "4e9a2d0bfb55e26488278de4a1abf444763e177f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -1,3 +1,9 @@\n+2010-05-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/43787\n+\t* cp-gimplify.c (cp_gimplify_expr): Remove copies of empty classes.\n+\t* call.c (build_over_call): Don't try to avoid INIT_EXPR copies here.\n+\n 2010-05-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/43028"}, {"sha": "0ba0994d1a6d9fafa2f11104f828425ca70c0cb8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -5778,20 +5778,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t{\n \t  tree to = stabilize_reference (cp_build_indirect_ref (fa, RO_NULL,\n \t\t\t\t\t\t\t\tcomplain));\n-\t  tree type = TREE_TYPE (to);\n \n-\t  if (TREE_CODE (arg) != TARGET_EXPR\n-\t      && TREE_CODE (arg) != AGGR_INIT_EXPR\n-\t      && is_really_empty_class (type))\n-\t    {\n-\t      /* Avoid copying empty classes.  */\n-\t      val = build2 (COMPOUND_EXPR, void_type_node, to, arg);\n-\t      TREE_NO_WARNING (val) = 1;\n-\t      val = build2 (COMPOUND_EXPR, type, val, to);\n-\t      TREE_NO_WARNING (val) = 1;\n-\t    }\n-\t  else\n-\t    val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n+\t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  return val;\n \t}\n     }"}, {"sha": "d6ae28fb97d62811683778c0245ba625845b3731", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -569,6 +569,26 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t    && !useless_type_conversion_p (TREE_TYPE (op1), TREE_TYPE (op0)))\n \t  TREE_OPERAND (*expr_p, 1) = build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t      TREE_TYPE (op0), op1);\n+\n+\telse if ((rhs_predicate_for (op0)) (op1)\n+\t\t && !(TREE_CODE (op1) == CALL_EXPR\n+\t\t      && CALL_EXPR_RETURN_SLOT_OPT (op1))\n+\t\t && is_really_empty_class (TREE_TYPE (op0)))\n+\t  {\n+\t    /* Remove any copies of empty classes.  We check that the RHS\n+\t       has a simple form so that TARGET_EXPRs and CONSTRUCTORs get\n+\t       reduced properly, and we leave the return slot optimization\n+\t       alone because it isn't a copy.\n+\n+\t       Also drop volatile variables on the RHS to avoid infinite\n+\t       recursion from gimplify_expr trying to load the value.  */\n+\t    if (!TREE_SIDE_EFFECTS (op1)\n+\t\t|| (DECL_P (op1) && TREE_THIS_VOLATILE (op1)))\n+\t      *expr_p = op0;\n+\t    else\n+\t      *expr_p = build2 (COMPOUND_EXPR, TREE_TYPE (*expr_p),\n+\t\t\t\top0, op1);\n+\t  }\n       }\n       ret = GS_OK;\n       break;"}, {"sha": "8f7ff89d44cc70cf85ab275f0a000187de79cffd", "filename": "gcc/gimplify.c", "status": "modified", "additions": 218, "deletions": 211, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -4089,253 +4089,252 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p,\n \t\t\t  gimple_seq *pre_p, gimple_seq *post_p,\n \t\t\t  bool want_value)\n {\n-  enum gimplify_status ret = GS_OK;\n+  enum gimplify_status ret = GS_UNHANDLED;\n+  bool changed;\n \n-  while (ret != GS_UNHANDLED)\n-    switch (TREE_CODE (*from_p))\n-      {\n-      case VAR_DECL:\n-\t/* If we're assigning from a read-only variable initialized with\n-\t   a constructor, do the direct assignment from the constructor,\n-\t   but only if neither source nor target are volatile since this\n-\t   latter assignment might end up being done on a per-field basis.  */\n-\tif (DECL_INITIAL (*from_p)\n-\t    && TREE_READONLY (*from_p)\n-\t    && !TREE_THIS_VOLATILE (*from_p)\n-\t    && !TREE_THIS_VOLATILE (*to_p)\n-\t    && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)\n+  do\n+    {\n+      changed = false;\n+      switch (TREE_CODE (*from_p))\n+\t{\n+\tcase VAR_DECL:\n+\t  /* If we're assigning from a read-only variable initialized with\n+\t     a constructor, do the direct assignment from the constructor,\n+\t     but only if neither source nor target are volatile since this\n+\t     latter assignment might end up being done on a per-field basis.  */\n+\t  if (DECL_INITIAL (*from_p)\n+\t      && TREE_READONLY (*from_p)\n+\t      && !TREE_THIS_VOLATILE (*from_p)\n+\t      && !TREE_THIS_VOLATILE (*to_p)\n+\t      && TREE_CODE (DECL_INITIAL (*from_p)) == CONSTRUCTOR)\n+\t    {\n+\t      tree old_from = *from_p;\n+\t      enum gimplify_status subret;\n+\n+\t      /* Move the constructor into the RHS.  */\n+\t      *from_p = unshare_expr (DECL_INITIAL (*from_p));\n+\n+\t      /* Let's see if gimplify_init_constructor will need to put\n+\t\t it in memory.  */\n+\t      subret = gimplify_init_constructor (expr_p, NULL, NULL,\n+\t\t\t\t\t\t  false, true);\n+\t      if (subret == GS_ERROR)\n+\t\t{\n+\t\t  /* If so, revert the change.  */\n+\t\t  *from_p = old_from;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  ret = GS_OK;\n+\t\t  changed = true;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase INDIRECT_REF:\n \t  {\n-\t    tree old_from = *from_p;\n+\t    /* If we have code like\n \n-\t    /* Move the constructor into the RHS.  */\n-\t    *from_p = unshare_expr (DECL_INITIAL (*from_p));\n+\t     *(const A*)(A*)&x\n \n-\t    /* Let's see if gimplify_init_constructor will need to put\n-\t       it in memory.  If so, revert the change.  */\n-\t    ret = gimplify_init_constructor (expr_p, NULL, NULL, false, true);\n-\t    if (ret == GS_ERROR)\n+\t     where the type of \"x\" is a (possibly cv-qualified variant\n+\t     of \"A\"), treat the entire expression as identical to \"x\".\n+\t     This kind of code arises in C++ when an object is bound\n+\t     to a const reference, and if \"x\" is a TARGET_EXPR we want\n+\t     to take advantage of the optimization below.  */\n+\t    tree t = gimple_fold_indirect_ref_rhs (TREE_OPERAND (*from_p, 0));\n+\t    if (t)\n \t      {\n-\t\t*from_p = old_from;\n-\t\t/* Fall through.  */\n+\t\t*from_p = t;\n+\t\tret = GS_OK;\n+\t\tchanged = true;\n \t      }\n-\t    else\n+\t    break;\n+\t  }\n+\n+\tcase TARGET_EXPR:\n+\t  {\n+\t    /* If we are initializing something from a TARGET_EXPR, strip the\n+\t       TARGET_EXPR and initialize it directly, if possible.  This can't\n+\t       be done if the initializer is void, since that implies that the\n+\t       temporary is set in some non-trivial way.\n+\n+\t       ??? What about code that pulls out the temp and uses it\n+\t       elsewhere? I think that such code never uses the TARGET_EXPR as\n+\t       an initializer.  If I'm wrong, we'll die because the temp won't\n+\t       have any RTL.  In that case, I guess we'll need to replace\n+\t       references somehow.  */\n+\t    tree init = TARGET_EXPR_INITIAL (*from_p);\n+\n+\t    if (init\n+\t\t&& !VOID_TYPE_P (TREE_TYPE (init)))\n \t      {\n+\t\t*from_p = init;\n \t\tret = GS_OK;\n-\t\tbreak;\n+\t\tchanged = true;\n \t      }\n \t  }\n-\tret = GS_UNHANDLED;\n-\tbreak;\n-      case INDIRECT_REF:\n-\t{\n-\t  /* If we have code like\n+\t  break;\n \n-\t        *(const A*)(A*)&x\n+\tcase COMPOUND_EXPR:\n+\t  /* Remove any COMPOUND_EXPR in the RHS so the following cases will be\n+\t     caught.  */\n+\t  gimplify_compound_expr (from_p, pre_p, true);\n+\t  ret = GS_OK;\n+\t  changed = true;\n+\t  break;\n \n-\t     where the type of \"x\" is a (possibly cv-qualified variant\n-\t     of \"A\"), treat the entire expression as identical to \"x\".\n-\t     This kind of code arises in C++ when an object is bound\n-\t     to a const reference, and if \"x\" is a TARGET_EXPR we want\n-\t     to take advantage of the optimization below.  */\n-\t  tree t = gimple_fold_indirect_ref_rhs (TREE_OPERAND (*from_p, 0));\n-\t  if (t)\n+\tcase CONSTRUCTOR:\n+\t  /* If we're initializing from a CONSTRUCTOR, break this into\n+\t     individual MODIFY_EXPRs.  */\n+\t  return gimplify_init_constructor (expr_p, pre_p, post_p, want_value,\n+\t\t\t\t\t    false);\n+\n+\tcase COND_EXPR:\n+\t  /* If we're assigning to a non-register type, push the assignment\n+\t     down into the branches.  This is mandatory for ADDRESSABLE types,\n+\t     since we cannot generate temporaries for such, but it saves a\n+\t     copy in other cases as well.  */\n+\t  if (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n \t    {\n-\t      *from_p = t;\n-\t      ret = GS_OK;\n+\t      /* This code should mirror the code in gimplify_cond_expr. */\n+\t      enum tree_code code = TREE_CODE (*expr_p);\n+\t      tree cond = *from_p;\n+\t      tree result = *to_p;\n+\n+\t      ret = gimplify_expr (&result, pre_p, post_p,\n+\t\t\t\t   is_gimple_lvalue, fb_lvalue);\n+\t      if (ret != GS_ERROR)\n+\t\tret = GS_OK;\n+\n+\t      if (TREE_TYPE (TREE_OPERAND (cond, 1)) != void_type_node)\n+\t\tTREE_OPERAND (cond, 1)\n+\t\t  = build2 (code, void_type_node, result,\n+\t\t\t    TREE_OPERAND (cond, 1));\n+\t      if (TREE_TYPE (TREE_OPERAND (cond, 2)) != void_type_node)\n+\t\tTREE_OPERAND (cond, 2)\n+\t\t  = build2 (code, void_type_node, unshare_expr (result),\n+\t\t\t    TREE_OPERAND (cond, 2));\n+\n+\t      TREE_TYPE (cond) = void_type_node;\n+\t      recalculate_side_effects (cond);\n+\n+\t      if (want_value)\n+\t\t{\n+\t\t  gimplify_and_add (cond, pre_p);\n+\t\t  *expr_p = unshare_expr (result);\n+\t\t}\n+\t      else\n+\t\t*expr_p = cond;\n+\t      return ret;\n \t    }\n-\t  else\n-\t    ret = GS_UNHANDLED;\n \t  break;\n-\t}\n \n-      case TARGET_EXPR:\n-\t{\n-\t  /* If we are initializing something from a TARGET_EXPR, strip the\n-\t     TARGET_EXPR and initialize it directly, if possible.  This can't\n-\t     be done if the initializer is void, since that implies that the\n-\t     temporary is set in some non-trivial way.\n-\n-\t     ??? What about code that pulls out the temp and uses it\n-\t     elsewhere? I think that such code never uses the TARGET_EXPR as\n-\t     an initializer.  If I'm wrong, we'll die because the temp won't\n-\t     have any RTL.  In that case, I guess we'll need to replace\n-\t     references somehow.  */\n-\t  tree init = TARGET_EXPR_INITIAL (*from_p);\n-\n-\t  if (init\n-\t      && !VOID_TYPE_P (TREE_TYPE (init)))\n+\tcase CALL_EXPR:\n+\t  /* For calls that return in memory, give *to_p as the CALL_EXPR's\n+\t     return slot so that we don't generate a temporary.  */\n+\t  if (!CALL_EXPR_RETURN_SLOT_OPT (*from_p)\n+\t      && aggregate_value_p (*from_p, *from_p))\n \t    {\n-\t      *from_p = init;\n-\t      ret = GS_OK;\n+\t      bool use_target;\n+\n+\t      if (!(rhs_predicate_for (*to_p))(*from_p))\n+\t\t/* If we need a temporary, *to_p isn't accurate.  */\n+\t\tuse_target = false;\n+\t      else if (TREE_CODE (*to_p) == RESULT_DECL\n+\t\t       && DECL_NAME (*to_p) == NULL_TREE\n+\t\t       && needs_to_live_in_memory (*to_p))\n+\t\t/* It's OK to use the return slot directly unless it's an NRV. */\n+\t\tuse_target = true;\n+\t      else if (is_gimple_reg_type (TREE_TYPE (*to_p))\n+\t\t       || (DECL_P (*to_p) && DECL_REGISTER (*to_p)))\n+\t\t/* Don't force regs into memory.  */\n+\t\tuse_target = false;\n+\t      else if (TREE_CODE (*expr_p) == INIT_EXPR)\n+\t\t/* It's OK to use the target directly if it's being\n+\t\t   initialized. */\n+\t\tuse_target = true;\n+\t      else if (!is_gimple_non_addressable (*to_p))\n+\t\t/* Don't use the original target if it's already addressable;\n+\t\t   if its address escapes, and the called function uses the\n+\t\t   NRV optimization, a conforming program could see *to_p\n+\t\t   change before the called function returns; see c++/19317.\n+\t\t   When optimizing, the return_slot pass marks more functions\n+\t\t   as safe after we have escape info.  */\n+\t\tuse_target = false;\n+\t      else\n+\t\tuse_target = true;\n+\n+\t      if (use_target)\n+\t\t{\n+\t\t  CALL_EXPR_RETURN_SLOT_OPT (*from_p) = 1;\n+\t\t  mark_addressable (*to_p);\n+\t\t}\n \t    }\n-\t  else\n-\t    ret = GS_UNHANDLED;\n-\t}\n-\tbreak;\n+\t  break;\n \n-      case COMPOUND_EXPR:\n-\t/* Remove any COMPOUND_EXPR in the RHS so the following cases will be\n-\t   caught.  */\n-\tgimplify_compound_expr (from_p, pre_p, true);\n-\tret = GS_OK;\n-\tbreak;\n+\tcase WITH_SIZE_EXPR:\n+\t  /* Likewise for calls that return an aggregate of non-constant size,\n+\t     since we would not be able to generate a temporary at all.  */\n+\t  if (TREE_CODE (TREE_OPERAND (*from_p, 0)) == CALL_EXPR)\n+\t    {\n+\t      *from_p = TREE_OPERAND (*from_p, 0);\n+\t      ret = GS_OK;\n+\t      changed = true;\n+\t    }\n+\t  break;\n \n-      case CONSTRUCTOR:\n-\t/* If we're initializing from a CONSTRUCTOR, break this into\n-\t   individual MODIFY_EXPRs.  */\n-\treturn gimplify_init_constructor (expr_p, pre_p, post_p, want_value,\n-\t\t\t\t\t  false);\n-\n-      case COND_EXPR:\n-\t/* If we're assigning to a non-register type, push the assignment\n-\t   down into the branches.  This is mandatory for ADDRESSABLE types,\n-\t   since we cannot generate temporaries for such, but it saves a\n-\t   copy in other cases as well.  */\n-\tif (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n+\t  /* If we're initializing from a container, push the initialization\n+\t     inside it.  */\n+\tcase CLEANUP_POINT_EXPR:\n+\tcase BIND_EXPR:\n+\tcase STATEMENT_LIST:\n \t  {\n-\t    /* This code should mirror the code in gimplify_cond_expr. */\n-\t    enum tree_code code = TREE_CODE (*expr_p);\n-\t    tree cond = *from_p;\n-\t    tree result = *to_p;\n+\t    tree wrap = *from_p;\n+\t    tree t;\n \n-\t    ret = gimplify_expr (&result, pre_p, post_p,\n-\t\t\t\t is_gimple_lvalue, fb_lvalue);\n+\t    ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_min_lval,\n+\t\t\t\t fb_lvalue);\n \t    if (ret != GS_ERROR)\n \t      ret = GS_OK;\n \n-\t    if (TREE_TYPE (TREE_OPERAND (cond, 1)) != void_type_node)\n-\t      TREE_OPERAND (cond, 1)\n-\t\t= build2 (code, void_type_node, result,\n-\t\t\t  TREE_OPERAND (cond, 1));\n-\t    if (TREE_TYPE (TREE_OPERAND (cond, 2)) != void_type_node)\n-\t      TREE_OPERAND (cond, 2)\n-\t\t= build2 (code, void_type_node, unshare_expr (result),\n-\t\t\t  TREE_OPERAND (cond, 2));\n-\n-\t    TREE_TYPE (cond) = void_type_node;\n-\t    recalculate_side_effects (cond);\n+\t    t = voidify_wrapper_expr (wrap, *expr_p);\n+\t    gcc_assert (t == *expr_p);\n \n \t    if (want_value)\n \t      {\n-\t\tgimplify_and_add (cond, pre_p);\n-\t\t*expr_p = unshare_expr (result);\n+\t\tgimplify_and_add (wrap, pre_p);\n+\t\t*expr_p = unshare_expr (*to_p);\n \t      }\n \t    else\n-\t      *expr_p = cond;\n-\t    return ret;\n+\t      *expr_p = wrap;\n+\t    return GS_OK;\n \t  }\n-\telse\n-\t  ret = GS_UNHANDLED;\n-\tbreak;\n \n-      case CALL_EXPR:\n-\t/* For calls that return in memory, give *to_p as the CALL_EXPR's\n-\t   return slot so that we don't generate a temporary.  */\n-\tif (!CALL_EXPR_RETURN_SLOT_OPT (*from_p)\n-\t    && aggregate_value_p (*from_p, *from_p))\n+\tcase COMPOUND_LITERAL_EXPR:\n \t  {\n-\t    bool use_target;\n-\n-\t    if (!(rhs_predicate_for (*to_p))(*from_p))\n-\t      /* If we need a temporary, *to_p isn't accurate.  */\n-\t      use_target = false;\n-\t    else if (TREE_CODE (*to_p) == RESULT_DECL\n-\t\t     && DECL_NAME (*to_p) == NULL_TREE\n-\t\t     && needs_to_live_in_memory (*to_p))\n-\t      /* It's OK to use the return slot directly unless it's an NRV. */\n-\t      use_target = true;\n-\t    else if (is_gimple_reg_type (TREE_TYPE (*to_p))\n-\t\t     || (DECL_P (*to_p) && DECL_REGISTER (*to_p)))\n-\t      /* Don't force regs into memory.  */\n-\t      use_target = false;\n-\t    else if (TREE_CODE (*expr_p) == INIT_EXPR)\n-\t      /* It's OK to use the target directly if it's being\n-\t\t initialized. */\n-\t      use_target = true;\n-\t    else if (!is_gimple_non_addressable (*to_p))\n-\t      /* Don't use the original target if it's already addressable;\n-\t\t if its address escapes, and the called function uses the\n-\t\t NRV optimization, a conforming program could see *to_p\n-\t\t change before the called function returns; see c++/19317.\n-\t\t When optimizing, the return_slot pass marks more functions\n-\t\t as safe after we have escape info.  */\n-\t      use_target = false;\n-\t    else\n-\t      use_target = true;\n-\n-\t    if (use_target)\n+\t    tree complit = TREE_OPERAND (*expr_p, 1);\n+\t    tree decl_s = COMPOUND_LITERAL_EXPR_DECL_EXPR (complit);\n+\t    tree decl = DECL_EXPR_DECL (decl_s);\n+\t    tree init = DECL_INITIAL (decl);\n+\n+\t    /* struct T x = (struct T) { 0, 1, 2 } can be optimized\n+\t       into struct T x = { 0, 1, 2 } if the address of the\n+\t       compound literal has never been taken.  */\n+\t    if (!TREE_ADDRESSABLE (complit)\n+\t\t&& !TREE_ADDRESSABLE (decl)\n+\t\t&& init)\n \t      {\n-\t\tCALL_EXPR_RETURN_SLOT_OPT (*from_p) = 1;\n-\t\tmark_addressable (*to_p);\n+\t\t*expr_p = copy_node (*expr_p);\n+\t\tTREE_OPERAND (*expr_p, 1) = init;\n+\t\treturn GS_OK;\n \t      }\n \t  }\n \n-\tret = GS_UNHANDLED;\n-\tbreak;\n-\n-      case WITH_SIZE_EXPR:\n-\t/* Likewise for calls that return an aggregate of non-constant size,\n-\t   since we would not be able to generate a temporary at all.  */\n-\tif (TREE_CODE (TREE_OPERAND (*from_p, 0)) == CALL_EXPR)\n-\t  {\n-\t    *from_p = TREE_OPERAND (*from_p, 0);\n-\t    ret = GS_OK;\n-\t  }\n-\telse\n-\t  ret = GS_UNHANDLED;\n-\tbreak;\n-\n-\t/* If we're initializing from a container, push the initialization\n-\t   inside it.  */\n-      case CLEANUP_POINT_EXPR:\n-      case BIND_EXPR:\n-      case STATEMENT_LIST:\n-\t{\n-\t  tree wrap = *from_p;\n-\t  tree t;\n-\n-\t  ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_min_lval,\n-\t\t\t       fb_lvalue);\n-\t  if (ret != GS_ERROR)\n-\t    ret = GS_OK;\n-\n-\t  t = voidify_wrapper_expr (wrap, *expr_p);\n-\t  gcc_assert (t == *expr_p);\n-\n-\t  if (want_value)\n-\t    {\n-\t      gimplify_and_add (wrap, pre_p);\n-\t      *expr_p = unshare_expr (*to_p);\n-\t    }\n-\t  else\n-\t    *expr_p = wrap;\n-\t  return GS_OK;\n-\t}\n-\n-      case COMPOUND_LITERAL_EXPR:\n-\t{\n-\t  tree complit = TREE_OPERAND (*expr_p, 1);\n-\t  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_EXPR (complit);\n-\t  tree decl = DECL_EXPR_DECL (decl_s);\n-\t  tree init = DECL_INITIAL (decl);\n-\n-\t  /* struct T x = (struct T) { 0, 1, 2 } can be optimized\n-\t     into struct T x = { 0, 1, 2 } if the address of the\n-\t     compound literal has never been taken.  */\n-\t  if (!TREE_ADDRESSABLE (complit)\n-\t      && !TREE_ADDRESSABLE (decl)\n-\t      && init)\n-\t    {\n-\t      *expr_p = copy_node (*expr_p);\n-\t      TREE_OPERAND (*expr_p, 1) = init;\n-\t      return GS_OK;\n-\t    }\n+\tdefault:\n+\t  break;\n \t}\n-\n-      default:\n-\tret = GS_UNHANDLED;\n-\tbreak;\n-      }\n+    }\n+  while (changed);\n \n   return ret;\n }\n@@ -6616,8 +6615,16 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase MODIFY_EXPR:\n \tcase INIT_EXPR:\n-\t  ret = gimplify_modify_expr (expr_p, pre_p, post_p,\n-\t\t\t\t      fallback != fb_none);\n+\t  {\n+\t    tree from = TREE_OPERAND (*expr_p, 1);\n+\t    ret = gimplify_modify_expr (expr_p, pre_p, post_p,\n+\t\t\t\t\tfallback != fb_none);\n+\t    /* Don't let the end of loop logic change GS_OK into GS_ALL_DONE\n+\t       if the RHS has changed.  */\n+\t    if (ret == GS_OK && *expr_p == save_expr\n+\t\t&& TREE_OPERAND (*expr_p, 1) != from)\n+\t      continue;\n+\t  }\n \t  break;\n \n \tcase TRUTH_ANDIF_EXPR:"}, {"sha": "ebba7731f1c2385476d17caf957b8fc95e7b2099", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -1,3 +1,8 @@\n+2010-05-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/43787\n+\t* g++.dg/opt/empty1.C: New.\n+\n 2010-05-05  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/43696"}, {"sha": "66784fb28bfa95f422adc7f5fcb19fa9041edb63", "filename": "gcc/testsuite/g++.dg/opt/empty1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fempty1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d729f282c059987f966fc3d9c98eb74e2d92839/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fempty1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fempty1.C?ref=6d729f282c059987f966fc3d9c98eb74e2d92839", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/43787\n+// Test that we don't try to copy *x.\n+// { dg-do run }\n+\n+class empty_t {};\n+\n+int main()\n+{\n+  empty_t* x = 0;\n+  empty_t y = *x;\n+}"}]}