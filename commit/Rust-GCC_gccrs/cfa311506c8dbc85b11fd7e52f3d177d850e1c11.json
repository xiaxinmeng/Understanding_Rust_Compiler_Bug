{"sha": "cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZhMzExNTA2YzhkYmM4NWIxMWZkN2U1MmYzZDE3N2Q4NTBlMWMxMQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-08-24T23:54:05Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-08-24T23:54:05Z"}, "message": "re PR target/11787 (always call memcpy for block move in mips16)\n\n2007-08-24  Sandra Loosemore  <sandra@codesourcery.com>\n            Nigel Stephens <nigel@mips.com>\n\n\tPR target/11787\n\n\tgcc/\n\n\t* doc/tm.texi (SET_RATIO, SET_BY_PIECES_P): Document new macros.\n\t(STORE_BY_PIECES_P): No longer applies to __builtin_memset.\n\t* expr.c (SET_BY_PIECES_P): Define.\n\t(can_store_by_pieces, store_by_pieces): Add MEMSETP argument; use\n\tit to decide whether to use SET_BY_PIECES_P or STORE_BY_PIECES_P.\n\t(store_expr):  Pass MEMSETP argument to can_store_by_pieces and\n\tstore_by_pieces.\n\t* expr.h (SET_RATIO): Define.\n\t(can_store_by_pieces, store_by_pieces):\tUpdate prototypes.\n\t* builtins.c (expand_builtin_memcpy): Pass MEMSETP argument to\n\tcan_store_by_pieces/store_by_pieces.\n\t(expand_builtin_memcpy_args): Likewise.\n\t(expand_builtin_strncpy): Likewise.\n\t(expand_builtin_memset_args): Likewise.  Also remove special case\n\tfor optimize_size so that can_store_by_pieces/SET_BY_PIECES_P can\n\tdecide what to do instead.\n\t* value-prof.c (tree_stringops_transform): Pass MEMSETP argument\n\tto can_store_by_pieces.\n\n\t* config/sh/sh.h (SET_BY_PIECES_P): Clone from STORE_BY_PIECES_P.\n\t* config/s390/s390.h (SET_BY_PIECES_P): Likewise.\n\n\t* config/mips/mips.opt (mmemcpy): Change from Var to Mask.\n\t* config/mips/mips.c (override_options): Make -Os default to -mmemcpy.\n\t* config/mips/mips.h (MIPS_CALL_RATIO): Define.\n\t(MOVE_RATIO, CLEAR_RATIO, SET_RATIO): Define.\n\t(STORE_BY_PIECES_P): Define.\n\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r127790", "tree": {"sha": "6895f19a8975ec8b4b0758ed56b3ed5a18bd56e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6895f19a8975ec8b4b0758ed56b3ed5a18bd56e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9837879d58101f62cd52cc7d17b5dd76b975978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9837879d58101f62cd52cc7d17b5dd76b975978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9837879d58101f62cd52cc7d17b5dd76b975978"}], "stats": {"total": 208, "additions": 173, "deletions": 35}, "files": [{"sha": "cd929650abc1416c242a0e740f9e60df164a0165", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -1,3 +1,36 @@\n+2007-08-24  Sandra Loosemore  <sandra@codesourcery.com>\n+            Nigel Stephens <nigel@mips.com>\n+\n+\tPR target/11787\n+\n+\t* doc/tm.texi (SET_RATIO, SET_BY_PIECES_P): Document new macros.\n+\t(STORE_BY_PIECES_P): No longer applies to __builtin_memset.\n+\t* expr.c (SET_BY_PIECES_P): Define.\n+\t(can_store_by_pieces, store_by_pieces): Add MEMSETP argument; use\n+\tit to decide whether to use SET_BY_PIECES_P or STORE_BY_PIECES_P.\n+\t(store_expr):  Pass MEMSETP argument to can_store_by_pieces and\n+\tstore_by_pieces.\n+\t* expr.h (SET_RATIO): Define.\n+\t(can_store_by_pieces, store_by_pieces):\tUpdate prototypes.\n+\t* builtins.c (expand_builtin_memcpy): Pass MEMSETP argument to\n+\tcan_store_by_pieces/store_by_pieces.\n+\t(expand_builtin_memcpy_args): Likewise.\n+\t(expand_builtin_strncpy): Likewise.\n+\t(expand_builtin_memset_args): Likewise.  Also remove special case\n+\tfor optimize_size so that can_store_by_pieces/SET_BY_PIECES_P can\n+\tdecide what to do instead.\n+\t* value-prof.c (tree_stringops_transform): Pass MEMSETP argument\n+\tto can_store_by_pieces.\n+\n+\t* config/sh/sh.h (SET_BY_PIECES_P): Clone from STORE_BY_PIECES_P.\n+\t* config/s390/s390.h (SET_BY_PIECES_P): Likewise.\n+\n+\t* config/mips/mips.opt (mmemcpy): Change from Var to Mask.\n+\t* config/mips/mips.c (override_options): Make -Os default to -mmemcpy.\n+\t* config/mips/mips.h (MIPS_CALL_RATIO): Define.\n+\t(MOVE_RATIO, CLEAR_RATIO, SET_RATIO): Define.\n+\t(STORE_BY_PIECES_P): Define.\n+\n 2007-08-24  Tom Tromey  <tromey@redhat.com>\n \n \t* varpool.c (varpool_last_needed_node): Fix comment typo."}, {"sha": "e353e4dce1dad97023ce3ebee1796586e2f30864", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -3331,11 +3331,11 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t  && GET_CODE (len_rtx) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t\t  (void *) src_str, dest_align))\n+\t\t\t\t  (void *) src_str, dest_align, false))\n \t{\n \t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      (void *) src_str, dest_align, 0);\n+\t\t\t\t      (void *) src_str, dest_align, false, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3444,13 +3444,14 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n \t  && GET_CODE (len_rtx) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t\t  (void *) src_str, dest_align))\n+\t\t\t\t  (void *) src_str, dest_align, false))\n \t{\n \t  dest_mem = get_memory_rtx (dest, len);\n \t  set_mem_align (dest_mem, dest_align);\n \t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      (void *) src_str, dest_align, endp);\n+\t\t\t\t      (void *) src_str, dest_align,\n+\t\t\t\t      false, endp);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3792,13 +3793,13 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n \t  if (!p || dest_align == 0 || !host_integerp (len, 1)\n \t      || !can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t       builtin_strncpy_read_str,\n-\t\t\t\t       (void *) p, dest_align))\n+\t\t\t\t       (void *) p, dest_align, false))\n \t    return NULL_RTX;\n \n \t  dest_mem = get_memory_rtx (dest, len);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_strncpy_read_str,\n-\t\t\t   (void *) p, dest_align, 0);\n+\t\t\t   (void *) p, dest_align, false, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3926,14 +3927,15 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n        * We can't pass builtin_memset_gen_str as that emits RTL.  */\n       c = 1;\n       if (host_integerp (len, 1)\n-\t  && !(optimize_size && tree_low_cst (len, 1) > 1)\n \t  && can_store_by_pieces (tree_low_cst (len, 1),\n-\t\t\t\t  builtin_memset_read_str, &c, dest_align))\n+\t\t\t\t  builtin_memset_read_str, &c, dest_align,\n+\t\t\t\t  true))\n \t{\n \t  val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n \t\t\t       val_rtx);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n-\t\t\t   builtin_memset_gen_str, val_rtx, dest_align, 0);\n+\t\t\t   builtin_memset_gen_str, val_rtx, dest_align,\n+\t\t\t   true, 0);\n \t}\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\tdest_align, expected_align,\n@@ -3951,11 +3953,11 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   if (c)\n     {\n       if (host_integerp (len, 1)\n-\t  && !(optimize_size && tree_low_cst (len, 1) > 1)\n \t  && can_store_by_pieces (tree_low_cst (len, 1),\n-\t\t\t\t  builtin_memset_read_str, &c, dest_align))\n+\t\t\t\t  builtin_memset_read_str, &c, dest_align,\n+\t\t\t\t  true))\n \tstore_by_pieces (dest_mem, tree_low_cst (len, 1),\n-\t\t\t builtin_memset_read_str, &c, dest_align, 0);\n+\t\t\t builtin_memset_read_str, &c, dest_align, true, 0);\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, GEN_INT (c),\n \t\t\t\t\tdest_align, expected_align,\n \t\t\t\t\texpected_size))"}, {"sha": "2c2f11eb66a6a76dd1db1752c8d8c3e4c5c8c922", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -5323,6 +5323,11 @@ override_options (void)\n       flag_delayed_branch = 0;\n     }\n \n+  /* Prefer a call to memcpy over inline code when optimizing for size,\n+     though see MOVE_RATIO in mips.h.  */\n+  if (optimize_size && (target_flags_explicit & MASK_MEMCPY) == 0)\n+    target_flags |= MASK_MEMCPY;\n+\n #ifdef MIPS_TFMODE_FORMAT\n   REAL_MODE_FORMAT (TFmode) = &MIPS_TFMODE_FORMAT;\n #endif"}, {"sha": "c3797e530dc5573f48c88fef26ccceacbe20e4af", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -2785,6 +2785,57 @@ while (0)\n \n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n+\n+/* The base cost of a memcpy call, for MOVE_RATIO and friends.  These\n+   values were determined experimentally by benchmarking with CSiBE.\n+   In theory, the call overhead is higher for TARGET_ABICALLS (especially\n+   for o32 where we have to restore $gp afterwards as well as make an\n+   indirect call), but in practice, bumping this up higher for\n+   TARGET_ABICALLS doesn't make much difference to code size.  */\n+\n+#define MIPS_CALL_RATIO 8\n+\n+/* Define MOVE_RATIO to encourage use of movmemsi when enabled,\n+   since it should always generate code at least as good as\n+   move_by_pieces().  But when inline movmemsi pattern is disabled\n+   (i.e., with -mips16 or -mmemcpy), instead use a value approximating\n+   the length of a memcpy call sequence, so that move_by_pieces will\n+   generate inline code if it is shorter than a function call.\n+   Since move_by_pieces_ninsns() counts memory-to-memory moves, but\n+   we'll have to generate a load/store pair for each, halve the value of \n+   MIPS_CALL_RATIO to take that into account.\n+   The default value for MOVE_RATIO when HAVE_movmemsi is true is 2.\n+   There is no point to setting it to less than this to try to disable\n+   move_by_pieces entirely, because that also disables some desirable \n+   tree-level optimizations, specifically related to optimizing a\n+   one-byte string copy into a simple move byte operation.  */\n+\n+#define MOVE_RATIO \\\n+  ((TARGET_MIPS16 || TARGET_MEMCPY) ? MIPS_CALL_RATIO / 2 : 2)\n+\n+/* For CLEAR_RATIO, when optimizing for size, give a better estimate\n+   of the length of a memset call, but use the default otherwise.  */\n+\n+#define CLEAR_RATIO \\\n+  (optimize_size ? MIPS_CALL_RATIO : 15)\n+\n+/* This is similar to CLEAR_RATIO, but for a non-zero constant, so when\n+   optimizing for size adjust the ratio to account for the overhead of\n+   loading the constant and replicating it across the word.  */\n+\n+#define SET_RATIO \\\n+  (optimize_size ? MIPS_CALL_RATIO - 2 : 15)\n+\n+/* STORE_BY_PIECES_P can be used when copying a constant string, but\n+   in that case each word takes 3 insns (lui, ori, sw), or more in\n+   64-bit mode, instead of 2 (lw, sw).  For now we always fail this\n+   and let the move_by_pieces code copy the string from read-only\n+   memory.  In the future, this could be tuned further for multi-issue\n+   CPUs that can issue stores down one pipe and arithmetic instructions\n+   down another; in that case, the lui/ori/sw combination would be a\n+   win for long enough strings.  */\n+\n+#define STORE_BY_PIECES_P(SIZE, ALIGN) 0\n \f\n #ifndef __mips16\n /* Since the bits of the _init and _fini function is spread across"}, {"sha": "6f6c109187cf661a6b9c24237754398dcaa86bc4", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -173,7 +173,7 @@ Target Report RejectNegative Mask(LONG64)\n Use a 64-bit long type\n \n mmemcpy\n-Target Report Var(TARGET_MEMCPY)\n+Target Report Mask(MEMCPY)\n Don't optimize block moves\n \n mmips-tfile"}, {"sha": "8cc8edfe070f97a89e018a397063ba7ca3bac12c", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -803,10 +803,13 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1, *s390_compare_emitte\n     || (TARGET_64BIT && (SIZE) == 8) )\n \n /* This macro is used to determine whether store_by_pieces should be\n-   called to \"memset\" storage with byte values other than zero, or\n-   to \"memcpy\" storage when the source is a constant string.  */\n+   called to \"memcpy\" storage when the source is a constant string.  */\n #define STORE_BY_PIECES_P(SIZE, ALIGN) MOVE_BY_PIECES_P (SIZE, ALIGN)\n \n+/* Likewise to decide whether to \"memset\" storage with byte values\n+   other than zero.  */\n+#define SET_BY_PIECES_P(SIZE, ALIGN) STORE_BY_PIECES_P (SIZE, ALIGN)\n+\n /* Don't perform CSE on function addresses.  */\n #define NO_FUNCTION_CSE\n "}, {"sha": "8f299b75afef58be83931d0fcc400ae946320ad6", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -2184,6 +2184,8 @@ struct sh_args {\n   (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n    < (TARGET_SMALLCODE ? 2 : ((ALIGN >= 32) ? 16 : 2)))\n \n+#define SET_BY_PIECES_P(SIZE, ALIGN) STORE_BY_PIECES_P(SIZE, ALIGN)\n+\n /* Macros to check register numbers against specific register classes.  */\n \n /* These assume that REGNO is a hard or pseudo reg number."}, {"sha": "a913b8058c651de6b319ea8ba2cc44eeb1d85666", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -5897,12 +5897,30 @@ will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n than @code{CLEAR_RATIO}.\n @end defmac\n \n+@defmac SET_RATIO\n+The threshold of number of scalar move insns, @emph{below} which a sequence\n+of insns should be generated to set memory to a constant value, instead of\n+a block set insn or a library call.  \n+Increasing the value will always make code faster, but\n+eventually incurs high cost in increased code size.\n+\n+If you don't define this, it defaults to the value of @code{MOVE_RATIO}.\n+@end defmac\n+\n+@defmac SET_BY_PIECES_P (@var{size}, @var{alignment})\n+A C expression used to determine whether @code{store_by_pieces} will be\n+used to set a chunk of memory to a constant value, or whether some \n+other mechanism will be used.  Used by @code{__builtin_memset} when \n+storing values other than constant zero.\n+Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n+than @code{SET_RATIO}.\n+@end defmac\n+\n @defmac STORE_BY_PIECES_P (@var{size}, @var{alignment})\n A C expression used to determine whether @code{store_by_pieces} will be\n-used to set a chunk of memory to a constant value, or whether some other\n-mechanism will be used.  Used by @code{__builtin_memset} when storing\n-values other than constant zero and by @code{__builtin_strcpy} when\n-when called with a constant source string.\n+used to set a chunk of memory to a constant string value, or whether some \n+other mechanism will be used.  Used by @code{__builtin_strcpy} when\n+called with a constant source string.\n Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n than @code{MOVE_RATIO}.\n @end defmac"}, {"sha": "244604000a9e0d51d05d39d05a66658f517ffe50", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -186,8 +186,15 @@ static bool float_extend_from_mem[NUM_MACHINE_MODES][NUM_MACHINE_MODES];\n #endif\n \n /* This macro is used to determine whether store_by_pieces should be\n-   called to \"memset\" storage with byte values other than zero, or\n-   to \"memcpy\" storage when the source is a constant string.  */\n+   called to \"memset\" storage with byte values other than zero.  */\n+#ifndef SET_BY_PIECES_P\n+#define SET_BY_PIECES_P(SIZE, ALIGN) \\\n+  (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n+   < (unsigned int) SET_RATIO)\n+#endif\n+\n+/* This macro is used to determine whether store_by_pieces should be\n+   called to \"memcpy\" storage when the source is a constant string.  */\n #ifndef STORE_BY_PIECES_P\n #define STORE_BY_PIECES_P(SIZE, ALIGN) \\\n   (move_by_pieces_ninsns (SIZE, ALIGN, STORE_MAX_PIECES + 1) \\\n@@ -2191,13 +2198,14 @@ use_group_regs (rtx *call_fusage, rtx regs)\n /* Determine whether the LEN bytes generated by CONSTFUN can be\n    stored to memory using several move instructions.  CONSTFUNDATA is\n    a pointer which will be passed as argument in every CONSTFUN call.\n-   ALIGN is maximum alignment we can assume.  Return nonzero if a\n-   call to store_by_pieces should succeed.  */\n+   ALIGN is maximum alignment we can assume.  MEMSETP is true if this is\n+   a memset operation and false if it's a copy of a constant string.\n+   Return nonzero if a call to store_by_pieces should succeed.  */\n \n int\n can_store_by_pieces (unsigned HOST_WIDE_INT len,\n \t\t     rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n-\t\t     void *constfundata, unsigned int align)\n+\t\t     void *constfundata, unsigned int align, bool memsetp)\n {\n   unsigned HOST_WIDE_INT l;\n   unsigned int max_size;\n@@ -2210,7 +2218,9 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n   if (len == 0)\n     return 1;\n \n-  if (! STORE_BY_PIECES_P (len, align))\n+  if (! (memsetp \n+\t ? SET_BY_PIECES_P (len, align)\n+\t : STORE_BY_PIECES_P (len, align)))\n     return 0;\n \n   tmode = mode_for_size (STORE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);\n@@ -2285,15 +2295,16 @@ can_store_by_pieces (unsigned HOST_WIDE_INT len,\n /* Generate several move instructions to store LEN bytes generated by\n    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n    pointer which will be passed as argument in every CONSTFUN call.\n-   ALIGN is maximum alignment we can assume.\n+   ALIGN is maximum alignment we can assume.  MEMSETP is true if this is\n+   a memset operation and false if it's a copy of a constant string.\n    If ENDP is 0 return to, if ENDP is 1 return memory at the end ala\n    mempcpy, and if ENDP is 2 return memory the end minus one byte ala\n    stpcpy.  */\n \n rtx\n store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n \t\t rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n-\t\t void *constfundata, unsigned int align, int endp)\n+\t\t void *constfundata, unsigned int align, bool memsetp, int endp)\n {\n   struct store_by_pieces data;\n \n@@ -2303,7 +2314,9 @@ store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n       return to;\n     }\n \n-  gcc_assert (STORE_BY_PIECES_P (len, align));\n+  gcc_assert (memsetp\n+\t      ? SET_BY_PIECES_P (len, align)\n+\t      : STORE_BY_PIECES_P (len, align));\n   data.constfun = constfun;\n   data.constfundata = constfundata;\n   data.len = len;\n@@ -4498,7 +4511,7 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n       str_copy_len = MIN (str_copy_len, exp_len);\n       if (!can_store_by_pieces (str_copy_len, builtin_strncpy_read_str,\n \t\t\t\t(void *) TREE_STRING_POINTER (exp),\n-\t\t\t\tMEM_ALIGN (target)))\n+\t\t\t\tMEM_ALIGN (target), false))\n \tgoto normal_expr;\n \n       dest_mem = target;\n@@ -4507,7 +4520,8 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t\t\t  str_copy_len, builtin_strncpy_read_str,\n \t\t\t\t  (void *) TREE_STRING_POINTER (exp),\n \t\t\t\t  MEM_ALIGN (target),\n-\t\t\t\t  exp_len > str_copy_len ? 1 : 0);\n+\t\t\t\t  exp_len > str_copy_len ? 1 : 0,\n+\t\t\t\t  false);\n       if (exp_len > str_copy_len)\n \tclear_storage (dest_mem, GEN_INT (exp_len - str_copy_len),\n \t\t       BLOCK_OP_NORMAL);"}, {"sha": "24a391cc7f6d2a647e90a2e9af1ef3b62979c421", "filename": "gcc/expr.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -84,6 +84,13 @@ enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM, EXPAND_SUM,\n #define CLEAR_RATIO (optimize_size ? 3 : 15)\n #endif\n #endif\n+\n+/* If a memory set (to value other than zero) operation would take\n+   SET_RATIO or more simple move-instruction sequences, we will do a movmem\n+   or libcall instead.  */\n+#ifndef SET_RATIO\n+#define SET_RATIO MOVE_RATIO\n+#endif\n \f\n enum direction {none, upward, downward};\n \n@@ -444,20 +451,23 @@ extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n    CONSTFUN with several move instructions by store_by_pieces\n    function.  CONSTFUNDATA is a pointer which will be passed as argument\n    in every CONSTFUN call.\n-   ALIGN is maximum alignment we can assume.  */\n+   ALIGN is maximum alignment we can assume.\n+   MEMSETP is true if this is a real memset/bzero, not a copy\n+   of a const string.  */\n extern int can_store_by_pieces (unsigned HOST_WIDE_INT,\n \t\t\t\trtx (*) (void *, HOST_WIDE_INT,\n \t\t\t\t\t enum machine_mode),\n-\t\t\t\tvoid *, unsigned int);\n+\t\t\t\tvoid *, unsigned int, bool);\n \n /* Generate several move instructions to store LEN bytes generated by\n    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n    pointer which will be passed as argument in every CONSTFUN call.\n    ALIGN is maximum alignment we can assume.\n+   MEMSETP is true if this is a real memset/bzero, not a copy.\n    Returns TO + LEN.  */\n extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT,\n \t\t\t    rtx (*) (void *, HOST_WIDE_INT, enum machine_mode),\n-\t\t\t    void *, unsigned int, int);\n+\t\t\t    void *, unsigned int, bool, int);\n \n /* Emit insns to set X from Y.  */\n extern rtx emit_move_insn (rtx, rtx);"}, {"sha": "124a3c866b1a25361301d7f22be3aafb0ab8f7ca", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfa311506c8dbc85b11fd7e52f3d177d850e1c11/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=cfa311506c8dbc85b11fd7e52f3d177d850e1c11", "patch": "@@ -1392,13 +1392,13 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n     case BUILT_IN_MEMSET:\n       if (!can_store_by_pieces (val, builtin_memset_read_str,\n \t\t\t\tCALL_EXPR_ARG (call, 1),\n-\t\t\t\tdest_align))\n+\t\t\t\tdest_align, true))\n \treturn false;\n       break;\n     case BUILT_IN_BZERO:\n       if (!can_store_by_pieces (val, builtin_memset_read_str,\n \t\t\t\tinteger_zero_node,\n-\t\t\t\tdest_align))\n+\t\t\t\tdest_align, true))\n \treturn false;\n       break;\n     default:"}]}