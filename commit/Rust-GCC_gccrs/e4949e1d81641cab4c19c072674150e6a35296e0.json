{"sha": "e4949e1d81641cab4c19c072674150e6a35296e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5NDllMWQ4MTY0MWNhYjRjMTljMDcyNjc0MTUwZTZhMzUyOTZlMA==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-04-23T11:02:47Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-04-23T11:02:47Z"}, "message": "[ARM] Remove an unused reload hook.\n\n\t* config/arm/arm.h (LEGITIMIZE_RELOAD_ADDRESS): Remove.\n\t(ARM_LEGITIMIZE_RELOAD_ADDRESS): Remove.\n\t(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Remove.\n\t* config/arm/arm.c (arm_legimitimize_reload_address): Remove.\n\t(thumb_legimitimize_reload_address): Remove.\n\t* config/arm/arm-protos.h (arm_legimitimize_reload_address):\n\tRemove.\n\t(thumb_legimitimize_reload_address): Remove.\n\nFrom-SVN: r222359", "tree": {"sha": "73050cd10df040e080a80935d103e7c020d81533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73050cd10df040e080a80935d103e7c020d81533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4949e1d81641cab4c19c072674150e6a35296e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4949e1d81641cab4c19c072674150e6a35296e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4949e1d81641cab4c19c072674150e6a35296e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4949e1d81641cab4c19c072674150e6a35296e0/comments", "author": null, "committer": null, "parents": [{"sha": "8778aed76e7b273d2e40112a4d8d3a799bd8fbd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8778aed76e7b273d2e40112a4d8d3a799bd8fbd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8778aed76e7b273d2e40112a4d8d3a799bd8fbd2"}], "stats": {"total": 285, "additions": 11, "deletions": 274}, "files": [{"sha": "c56113e1dd6b769089687a9e04fa800017a227f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4949e1d81641cab4c19c072674150e6a35296e0", "patch": "@@ -1,3 +1,14 @@\n+2015-04-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/arm/arm.h (LEGITIMIZE_RELOAD_ADDRESS): Remove.\n+\t(ARM_LEGITIMIZE_RELOAD_ADDRESS): Remove.\n+\t(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Remove.\n+\t* config/arm/arm.c (arm_legimitimize_reload_address): Remove.\n+\t(thumb_legimitimize_reload_address): Remove.\n+\t* config/arm/arm-protos.h (arm_legimitimize_reload_address):\n+\tRemove.\n+\t(thumb_legimitimize_reload_address): Remove.\n+\n 2015-04-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* conditions.h (CC_STATUS_INIT): Gate on #ifndef CC_STATUS_INIT."}, {"sha": "ecca944a2bd874f0c43b6e63f9b6c1739106699d", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=e4949e1d81641cab4c19c072674150e6a35296e0", "patch": "@@ -66,10 +66,6 @@ extern rtx legitimize_tls_address (rtx, rtx);\n extern bool arm_legitimate_address_p (machine_mode, rtx, bool);\n extern int arm_legitimate_address_outer_p (machine_mode, rtx, RTX_CODE, int);\n extern int thumb_legitimate_offset_p (machine_mode, HOST_WIDE_INT);\n-extern bool arm_legitimize_reload_address (rtx *, machine_mode, int, int,\n-\t\t\t\t\t   int);\n-extern rtx thumb_legitimize_reload_address (rtx *, machine_mode, int, int,\n-\t\t\t\t\t    int);\n extern int thumb1_legitimate_address_p (machine_mode, rtx, int);\n extern bool ldm_stm_operation_p (rtx, bool, machine_mode mode,\n                                  bool, bool);"}, {"sha": "10dca3d8b81c5ad9c0aecf413774b40f35adf7bd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e4949e1d81641cab4c19c072674150e6a35296e0", "patch": "@@ -7974,236 +7974,6 @@ thumb_legitimize_address (rtx x, rtx orig_x, machine_mode mode)\n   return x;\n }\n \n-bool\n-arm_legitimize_reload_address (rtx *p,\n-\t\t\t       machine_mode mode,\n-\t\t\t       int opnum, int type,\n-\t\t\t       int ind_levels ATTRIBUTE_UNUSED)\n-{\n-  /* We must recognize output that we have already generated ourselves.  */\n-  if (GET_CODE (*p) == PLUS\n-      && GET_CODE (XEXP (*p, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (*p, 0), 0))\n-      && CONST_INT_P (XEXP (XEXP (*p, 0), 1))\n-      && CONST_INT_P (XEXP (*p, 1)))\n-    {\n-      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n-\t\t   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),\n-\t\t   VOIDmode, 0, 0, opnum, (enum reload_type) type);\n-      return true;\n-    }\n-\n-  if (GET_CODE (*p) == PLUS\n-      && REG_P (XEXP (*p, 0))\n-      && ARM_REGNO_OK_FOR_BASE_P (REGNO (XEXP (*p, 0)))\n-      /* If the base register is equivalent to a constant, let the generic\n-\t code handle it.  Otherwise we will run into problems if a future\n-\t reload pass decides to rematerialize the constant.  */\n-      && !reg_equiv_constant (ORIGINAL_REGNO (XEXP (*p, 0)))\n-      && CONST_INT_P (XEXP (*p, 1)))\n-    {\n-      HOST_WIDE_INT val = INTVAL (XEXP (*p, 1));\n-      HOST_WIDE_INT low, high;\n-\n-      /* Detect coprocessor load/stores.  */\n-      bool coproc_p = ((TARGET_HARD_FLOAT\n-\t\t\t&& TARGET_VFP\n-\t\t\t&& (mode == SFmode || mode == DFmode))\n-\t\t       || (TARGET_REALLY_IWMMXT\n-\t\t\t   && VALID_IWMMXT_REG_MODE (mode))\n-\t\t       || (TARGET_NEON\n-\t\t\t   && (VALID_NEON_DREG_MODE (mode)\n-\t\t\t       || VALID_NEON_QREG_MODE (mode))));\n-\n-      /* For some conditions, bail out when lower two bits are unaligned.  */\n-      if ((val & 0x3) != 0\n-\t  /* Coprocessor load/store indexes are 8-bits + '00' appended.  */\n-\t  && (coproc_p\n-\t      /* For DI, and DF under soft-float: */\n-\t      || ((mode == DImode || mode == DFmode)\n-\t\t  /* Without ldrd, we use stm/ldm, which does not\n-\t\t     fair well with unaligned bits.  */\n-\t\t  && (! TARGET_LDRD\n-\t\t      /* Thumb-2 ldrd/strd is [-1020,+1020] in steps of 4.  */\n-\t\t      || TARGET_THUMB2))))\n-\treturn false;\n-\n-      /* When breaking down a [reg+index] reload address into [(reg+high)+low],\n-\t of which the (reg+high) gets turned into a reload add insn,\n-\t we try to decompose the index into high/low values that can often\n-\t also lead to better reload CSE.\n-\t For example:\n-\t         ldr r0, [r2, #4100]  // Offset too large\n-\t\t ldr r1, [r2, #4104]  // Offset too large\n-\n-\t is best reloaded as:\n-\t         add t1, r2, #4096\n-\t\t ldr r0, [t1, #4]\n-\t\t add t2, r2, #4096\n-\t\t ldr r1, [t2, #8]\n-\n-\t which post-reload CSE can simplify in most cases to eliminate the\n-\t second add instruction:\n-\t         add t1, r2, #4096\n-\t\t ldr r0, [t1, #4]\n-\t\t ldr r1, [t1, #8]\n-\n-\t The idea here is that we want to split out the bits of the constant\n-\t as a mask, rather than as subtracting the maximum offset that the\n-\t respective type of load/store used can handle.\n-\n-\t When encountering negative offsets, we can still utilize it even if\n-\t the overall offset is positive; sometimes this may lead to an immediate\n-\t that can be constructed with fewer instructions.\n-\t For example:\n-\t         ldr r0, [r2, #0x3FFFFC]\n-\n-\t This is best reloaded as:\n-\t         add t1, r2, #0x400000\n-\t\t ldr r0, [t1, #-4]\n-\n-\t The trick for spotting this for a load insn with N bits of offset\n-\t (i.e. bits N-1:0) is to look at bit N; if it is set, then chose a\n-\t negative offset that is going to make bit N and all the bits below\n-\t it become zero in the remainder part.\n-\n-\t The SIGN_MAG_LOW_ADDR_BITS macro below implements this, with respect\n-\t to sign-magnitude addressing (i.e. separate +- bit, or 1's complement),\n-\t used in most cases of ARM load/store instructions.  */\n-\n-#define SIGN_MAG_LOW_ADDR_BITS(VAL, N)\t\t\t\t\t\\\n-      (((VAL) & ((1 << (N)) - 1))\t\t\t\t\t\\\n-       ? (((VAL) & ((1 << ((N) + 1)) - 1)) ^ (1 << (N))) - (1 << (N))\t\\\n-       : 0)\n-\n-      if (coproc_p)\n-\t{\n-\t  low = SIGN_MAG_LOW_ADDR_BITS (val, 10);\n-\n-\t  /* NEON quad-word load/stores are made of two double-word accesses,\n-\t     so the valid index range is reduced by 8. Treat as 9-bit range if\n-\t     we go over it.  */\n-\t  if (TARGET_NEON && VALID_NEON_QREG_MODE (mode) && low >= 1016)\n-\t    low = SIGN_MAG_LOW_ADDR_BITS (val, 9);\n-\t}\n-      else if (GET_MODE_SIZE (mode) == 8)\n-\t{\n-\t  if (TARGET_LDRD)\n-\t    low = (TARGET_THUMB2\n-\t\t   ? SIGN_MAG_LOW_ADDR_BITS (val, 10)\n-\t\t   : SIGN_MAG_LOW_ADDR_BITS (val, 8));\n-\t  else\n-\t    /* For pre-ARMv5TE (without ldrd), we use ldm/stm(db/da/ib)\n-\t       to access doublewords. The supported load/store offsets are\n-\t       -8, -4, and 4, which we try to produce here.  */\n-\t    low = ((val & 0xf) ^ 0x8) - 0x8;\n-\t}\n-      else if (GET_MODE_SIZE (mode) < 8)\n-\t{\n-\t  /* NEON element load/stores do not have an offset.  */\n-\t  if (TARGET_NEON_FP16 && mode == HFmode)\n-\t    return false;\n-\n-\t  if (TARGET_THUMB2)\n-\t    {\n-\t      /* Thumb-2 has an asymmetrical index range of (-256,4096).\n-\t\t Try the wider 12-bit range first, and re-try if the result\n-\t\t is out of range.  */\n-\t      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n-\t      if (low < -255)\n-\t\tlow = SIGN_MAG_LOW_ADDR_BITS (val, 8);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (mode == HImode || mode == HFmode)\n-\t\t{\n-\t\t  if (arm_arch4)\n-\t\t    low = SIGN_MAG_LOW_ADDR_BITS (val, 8);\n-\t\t  else\n-\t\t    {\n-\t\t      /* The storehi/movhi_bytes fallbacks can use only\n-\t\t\t [-4094,+4094] of the full ldrb/strb index range.  */\n-\t\t      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n-\t\t      if (low == 4095 || low == -4095)\n-\t\t\treturn false;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tlow = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n-\t    }\n-\t}\n-      else\n-\treturn false;\n-\n-      high = ((((val - low) & (unsigned HOST_WIDE_INT) 0xffffffff)\n-\t       ^ (unsigned HOST_WIDE_INT) 0x80000000)\n-\t      - (unsigned HOST_WIDE_INT) 0x80000000);\n-      /* Check for overflow or zero */\n-      if (low == 0 || high == 0 || (high + low != val))\n-\treturn false;\n-\n-      /* Reload the high part into a base reg; leave the low part\n-\t in the mem.\n-\t Note that replacing this gen_rtx_PLUS with plus_constant is\n-\t wrong in this case because we rely on the\n-\t (plus (plus reg c1) c2) structure being preserved so that\n-\t XEXP (*p, 0) in push_reload below uses the correct term.  */\n-      *p = gen_rtx_PLUS (GET_MODE (*p),\n-\t\t\t gen_rtx_PLUS (GET_MODE (*p), XEXP (*p, 0),\n-\t\t\t\t       GEN_INT (high)),\n-\t\t\t GEN_INT (low));\n-      push_reload (XEXP (*p, 0), NULL_RTX, &XEXP (*p, 0), NULL,\n-\t\t   MODE_BASE_REG_CLASS (mode), GET_MODE (*p),\n-\t\t   VOIDmode, 0, 0, opnum, (enum reload_type) type);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-rtx\n-thumb_legitimize_reload_address (rtx *x_p,\n-\t\t\t\t machine_mode mode,\n-\t\t\t\t int opnum, int type,\n-\t\t\t\t int ind_levels ATTRIBUTE_UNUSED)\n-{\n-  rtx x = *x_p;\n-\n-  if (GET_CODE (x) == PLUS\n-      && GET_MODE_SIZE (mode) < 4\n-      && REG_P (XEXP (x, 0))\n-      && XEXP (x, 0) == stack_pointer_rtx\n-      && CONST_INT_P (XEXP (x, 1))\n-      && !thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))\n-    {\n-      rtx orig_x = x;\n-\n-      x = copy_rtx (x);\n-      push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),\n-\t\t   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);\n-      return x;\n-    }\n-\n-  /* If both registers are hi-regs, then it's better to reload the\n-     entire expression rather than each register individually.  That\n-     only requires one reload register rather than two.  */\n-  if (GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x, 0))\n-      && REG_P (XEXP (x, 1))\n-      && !REG_MODE_OK_FOR_REG_BASE_P (XEXP (x, 0), mode)\n-      && !REG_MODE_OK_FOR_REG_BASE_P (XEXP (x, 1), mode))\n-    {\n-      rtx orig_x = x;\n-\n-      x = copy_rtx (x);\n-      push_reload (orig_x, NULL_RTX, x_p, NULL, MODE_BASE_REG_CLASS (mode),\n-\t\t   Pmode, VOIDmode, 0, 0, opnum, (enum reload_type) type);\n-      return x;\n-    }\n-\n-  return NULL;\n-}\n-\n /* Return TRUE if X contains any TLS symbol references.  */\n \n bool"}, {"sha": "8a93b175f48d106d72002f0fa303c211b310ea95", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4949e1d81641cab4c19c072674150e6a35296e0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e4949e1d81641cab4c19c072674150e6a35296e0", "patch": "@@ -1360,46 +1360,6 @@ enum reg_class\n      ? GENERAL_REGS : NO_REGS)\t\t\t\t\t\\\n     : THUMB_SECONDARY_INPUT_RELOAD_CLASS (CLASS, MODE, X)))\n \n-/* Try a machine-dependent way of reloading an illegitimate address\n-   operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.\n-\n-   For the ARM, we wish to handle large displacements off a base\n-   register by splitting the addend across a MOV and the mem insn.\n-   This can cut the number of reloads needed.  */\n-#define ARM_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND, WIN)\t   \\\n-  do\t\t\t\t\t\t\t\t\t   \\\n-    {\t\t\t\t\t\t\t\t\t   \\\n-      if (arm_legitimize_reload_address (&X, MODE, OPNUM, TYPE, IND))\t   \\\n-\tgoto WIN;\t\t\t\t\t\t\t   \\\n-    }\t\t\t\t\t\t\t\t\t   \\\n-  while (0)\n-\n-/* XXX If an HImode FP+large_offset address is converted to an HImode\n-   SP+large_offset address, then reload won't know how to fix it.  It sees\n-   only that SP isn't valid for HImode, and so reloads the SP into an index\n-   register, but the resulting address is still invalid because the offset\n-   is too big.  We fix it here instead by reloading the entire address.  */\n-/* We could probably achieve better results by defining PROMOTE_MODE to help\n-   cope with the variances between the Thumb's signed and unsigned byte and\n-   halfword load instructions.  */\n-/* ??? This should be safe for thumb2, but we may be able to do better.  */\n-#define THUMB_LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_L, WIN)     \\\n-do {\t\t\t\t\t\t\t\t\t      \\\n-  rtx new_x = thumb_legitimize_reload_address (&X, MODE, OPNUM, TYPE, IND_L); \\\n-  if (new_x)\t\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      X = new_x;\t\t\t\t\t\t\t      \\\n-      goto WIN;\t\t\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-} while (0)\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)   \\\n-  if (TARGET_ARM)\t\t\t\t\t\t\t   \\\n-    ARM_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN); \\\n-  else\t\t\t\t\t\t\t\t\t   \\\n-    THUMB_LEGITIMIZE_RELOAD_ADDRESS (X, MODE, OPNUM, TYPE, IND_LEVELS, WIN)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n    ARM regs are UNITS_PER_WORD bits.  "}]}