{"sha": "00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBkMzM5NmZkYmFiZTY4YWQyYjdjNjRhYzI4YzU2MDg2MjhjNzVhZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-11T07:09:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-11T07:09:58Z"}, "message": "call.c (build_new_method_call): Handle getting a TEMPLATE_ID_EXPR around a TEMPLATE_DECL.\n\n\t* call.c (build_new_method_call): Handle getting a\n \tTEMPLATE_ID_EXPR around a TEMPLATE_DECL.  Don't look for a field\n \tif we got template parms.\n\t* typeck.c (build_x_function_call): Remember the TEMPLATE_ID_EXPR,\n \tnot just the args.\n\t* decl2.c (build_expr_from_tree): Tweak last change.\n\t* pt.c (tsubst_copy): Use get_first_fn instead of TREE_VALUE.\n\t(maybe_fold_nontype_arg): Split out from tsubst_copy.\n\t* tree.c (get_first_fn): Just return a TEMPLATE_ID_EXPR.\n\nMon Nov 10 20:08:38 1997  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n\n\t* pt.c (tsubst_copy): Handle explicit template arguments in\n\tfunction calls.\n\t* typeck.c (build_x_function_call): Likewise.\n\t* decl2.c (build_expr_from_tree): Lookup function name if it\n\thasn't been done.\n\n\t* pt.c (tsubst): Instantiate template functions properly when\n\ttemplate parameter does not appear in function arguments and return\n\ttype.\n\t(comp_template_args): Handle member templates required by tsubst.\n\nFrom-SVN: r16427", "tree": {"sha": "bdf1e6e2cf3489fb92d44c2f7e6d2004a4513b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdf1e6e2cf3489fb92d44c2f7e6d2004a4513b78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/comments", "author": null, "committer": null, "parents": [{"sha": "1afc355025f984fb0b26d68a7337f987890e6042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afc355025f984fb0b26d68a7337f987890e6042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afc355025f984fb0b26d68a7337f987890e6042"}], "stats": {"total": 161, "additions": 117, "deletions": 44}, "files": [{"sha": "b267d2869ebb4cdc584ffe6ee359e0f7931c8f9b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -4,6 +4,31 @@ Sun Nov  9 01:29:55 1997  Jim Wilson  (wilson@cygnus.com)\n \t* init.c (build_vec_delete_1): Delete build_block and\n \tadd_block_current_level calls.\n \n+Mon Nov 10 20:25:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_new_method_call): Handle getting a\n+ \tTEMPLATE_ID_EXPR around a TEMPLATE_DECL.  Don't look for a field\n+ \tif we got template parms.\n+\t* typeck.c (build_x_function_call): Remember the TEMPLATE_ID_EXPR,\n+ \tnot just the args.\n+\t* decl2.c (build_expr_from_tree): Tweak last change.\n+\t* pt.c (tsubst_copy): Use get_first_fn instead of TREE_VALUE.\n+\t(maybe_fold_nontype_arg): Split out from tsubst_copy.\n+\t* tree.c (get_first_fn): Just return a TEMPLATE_ID_EXPR.\n+\n+Mon Nov 10 20:08:38 1997  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n+\n+\t* pt.c (tsubst_copy): Handle explicit template arguments in \n+\tfunction calls.\n+\t* typeck.c (build_x_function_call): Likewise.\n+\t* decl2.c (build_expr_from_tree): Lookup function name if it \n+\thasn't been done.\n+\n+\t* pt.c (tsubst): Instantiate template functions properly when \n+\ttemplate parameter does not appear in function arguments and return \n+\ttype.\n+\t(comp_template_args): Handle member templates required by tsubst.\n+\n Mon Nov 10 20:08:38 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (grokdeclarator): Tweak conditions for pedwarn in"}, {"sha": "da1d50ca692b7550e7b029f52b9511cde9616838", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -5474,6 +5474,8 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     {\n       explicit_targs = TREE_OPERAND (name, 1);\n       name = TREE_OPERAND (name, 0);\n+      if (TREE_CODE (name) == TEMPLATE_DECL)\n+\tname = DECL_NAME (name);\n       template_only = 1;\n     }\n \n@@ -5526,10 +5528,13 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     {\n       instance_ptr = build_this (instance);\n \n-      /* XXX this should be handled before we get here.  */\n-      fns = build_field_call (basetype_path, instance_ptr, name, args);\n-      if (fns)\n-\treturn fns;\n+      if (! template_only)\n+\t{\n+\t  /* XXX this should be handled before we get here.  */\n+\t  fns = build_field_call (basetype_path, instance_ptr, name, args);\n+\t  if (fns)\n+\t    return fns;\n+\t}\n     }\n   else\n     {"}, {"sha": "5d94797e299472eb465f1ba158ff65348c881a5f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -3406,10 +3406,9 @@ build_expr_from_tree (t)\n \treturn do_identifier (TREE_OPERAND (t, 0), 0);\n \n     case TEMPLATE_ID_EXPR:\n-      return lookup_template_function (build_expr_from_tree\n-\t\t\t\t       (TREE_OPERAND (t, 0)),\n-\t\t\t\t       build_expr_from_tree\n-\t\t\t\t       (TREE_OPERAND (t, 1)));\n+      return (lookup_template_function\n+\t      (build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t       build_expr_from_tree (TREE_OPERAND (t, 1))));\n \n     case INDIRECT_REF:\n       return build_x_indirect_ref\n@@ -3568,7 +3567,8 @@ build_expr_from_tree (t)\n       else\n \t{\n \t  tree name = TREE_OPERAND (t, 0);\n-\t  if (! really_overloaded_fn (name))\n+\t  if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n+\t      || ! really_overloaded_fn (name))\n \t    name = build_expr_from_tree (name);\n \t  return build_x_function_call\n \t    (name, build_expr_from_tree (TREE_OPERAND (t, 1)),"}, {"sha": "8e05af3b613fd349bf858ebba38bd2f2c785e6c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -1157,7 +1157,13 @@ comp_template_args (oldargs, newargs)\n \tcontinue;\n       if (TREE_CODE (nt) != TREE_CODE (ot))\n \treturn 0;\n-      if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n+      if (TREE_CODE (nt) == TREE_VEC)\n+        {\n+          /* For member templates */\n+\t  if (comp_template_args (nt, ot))\n+\t    continue;\n+        }\n+      else if (TREE_CODE_CLASS (TREE_CODE (ot)) == 't')\n \t{\n \t  if (comptypes (ot, nt, 1))\n \t    continue;\n@@ -2025,6 +2031,39 @@ lookup_nested_type_by_name (ctype, name)\n   return NULL_TREE;\n }\n \n+/* If arg is a non-type template parameter that does not depend on template\n+   arguments, fold it like we weren't in the body of a template.  */\n+\n+static tree\n+maybe_fold_nontype_arg (arg)\n+     tree arg;\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (arg)) != 't'\n+      && !uses_template_parms (arg))\n+    {\n+      /* Sometimes, one of the args was an expression involving a\n+\t template constant parameter, like N - 1.  Now that we've\n+\t tsubst'd, we might have something like 2 - 1.  This will\n+\t confuse lookup_template_class, so we do constant folding\n+\t here.  We have to unset processing_template_decl, to\n+\t fool build_expr_from_tree() into building an actual\n+\t tree.  */\n+\n+      int saved_processing_template_decl = processing_template_decl; \n+      processing_template_decl = 0;\n+      arg = fold (build_expr_from_tree (arg));\n+      processing_template_decl = saved_processing_template_decl; \n+    }\n+  return arg;\n+}\n+\n+/* Take the tree structure T and replace template parameters used therein\n+   with the argument vector ARGS.  NARGS is the number of args; should\n+   be removed.  IN_DECL is an associated decl for diagnostics.\n+\n+   tsubst is used for dealing with types, decls and the like; for\n+   expressions, use tsubst_expr or tsubst_copy.  */\n+\n tree\n tsubst (t, args, nargs, in_decl)\n      tree t, args;\n@@ -2246,14 +2285,6 @@ tsubst (t, args, nargs, in_decl)\n \t    type = tsubst (type, args, nargs, in_decl);\n \t  }\n \n-\tif (type == TREE_TYPE (t)\n-\t    && (! member || ctx == DECL_CLASS_CONTEXT (t)))\n-\t  {\n-\t    t = copy_node (t);\n-\t    copy_lang_decl (t);\n-\t    return t;\n-\t  }\n-\n \t/* Do we already have this instantiation?  */\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n@@ -2262,7 +2293,8 @@ tsubst (t, args, nargs, in_decl)\n \n \t    for (; decls; decls = TREE_CHAIN (decls))\n \t      if (TREE_TYPE (TREE_VALUE (decls)) == type\n-\t\t  && DECL_CLASS_CONTEXT (TREE_VALUE (decls)) == ctx)\n+\t\t  && DECL_CLASS_CONTEXT (TREE_VALUE (decls)) == ctx\n+\t\t  && comp_template_args (TREE_PURPOSE (decls), args))\n \t\treturn TREE_VALUE (decls);\n \t  }\n \n@@ -2616,24 +2648,8 @@ tsubst (t, args, nargs, in_decl)\n \n \tfor (i = 0; i < len; i++)\n \t  {\n-\t    elts[i] = tsubst_expr (TREE_VEC_ELT (t, i), args, nargs, in_decl);\n-\n-\t    if (TREE_CODE_CLASS (TREE_CODE (elts[i])) != 't'\n-\t\t&& !uses_template_parms (elts[i]))\n-\t      {\n-\t\t/* Sometimes, one of the args was an expression involving a\n-\t\t   template constant parameter, like N - 1.  Now that we've\n-\t\t   tsubst'd, we might have something like 2 - 1.  This will\n-\t\t   confuse lookup_template_class, so we do constant folding\n-\t\t   here.  We have to unset processing_template_decl, to\n-\t\t   fool build_expr_from_tree() into building an actual\n-\t\t   tree.  */\n-\n-\t\tint saved_processing_template_decl = processing_template_decl; \n-\t\tprocessing_template_decl = 0;\n-\t\telts[i] = fold (build_expr_from_tree (elts[i]));\n-\t\tprocessing_template_decl = saved_processing_template_decl; \n-\t      }\n+\t    elts[i] = maybe_fold_nontype_arg\n+\t      (tsubst_expr (TREE_VEC_ELT (t, i), args, nargs, in_decl));\n \n \t    if (elts[i] != TREE_VEC_ELT (t, i))\n \t      need_new = 1;\n@@ -2847,6 +2863,10 @@ do_poplevel ()\n   return t;\n }\n \n+/* Like tsubst, but deals with expressions.  This function just replaces\n+   template parms; to finish processing the resultant expression, use\n+   tsubst_expr.  */\n+\n tree\n tsubst_copy (t, args, nargs, in_decl)\n      tree t, args;\n@@ -2966,7 +2986,7 @@ tsubst_copy (t, args, nargs, in_decl)\n       {\n \ttree fn = TREE_OPERAND (t, 0);\n \tif (really_overloaded_fn (fn))\n-\t  fn = tsubst_copy (TREE_VALUE (fn), args, nargs, in_decl);\n+\t  fn = tsubst_copy (get_first_fn (fn), args, nargs, in_decl);\n \telse\n \t  fn = tsubst_copy (fn, args, nargs, in_decl);\n \treturn build_nt\n@@ -3028,10 +3048,14 @@ tsubst_copy (t, args, nargs, in_decl)\n \n     case TEMPLATE_ID_EXPR:\n       {\n-\ttree r = lookup_template_function\n-\t  (tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t   tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl));\n-\treturn r;\n+        /* Substituted template arguments */\n+\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl);\n+\ttree chain;\n+\tfor (chain = targs; chain; chain = TREE_CHAIN (chain))\n+\t  TREE_VALUE (chain) = maybe_fold_nontype_arg (TREE_VALUE (chain));\n+\n+\treturn lookup_template_function\n+\t  (tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl), targs);\n       }\n \n     case TREE_LIST:\n@@ -3089,6 +3113,8 @@ tsubst_copy (t, args, nargs, in_decl)\n     }\n }\n \n+/* Like tsubst_copy, but also does semantic processing and RTL expansion.  */\n+\n tree\n tsubst_expr (t, args, nargs, in_decl)\n      tree t, args;"}, {"sha": "e94fd554057d63c49623014824763493d7e88559", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -1306,7 +1306,8 @@ tree\n get_first_fn (from)\n      tree from;\n {\n-  if (TREE_CODE (from) == FUNCTION_DECL \n+  if (TREE_CODE (from) == FUNCTION_DECL\n+      || TREE_CODE (from) == TEMPLATE_ID_EXPR\n       || DECL_FUNCTION_TEMPLATE_P (from))\n     return from;\n "}, {"sha": "54f8c83726ec19fa34aaf71fbf9d7c0bb114489b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00d3396fdbabe68ad2b7c64ac28c5608628c75ad/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=00d3396fdbabe68ad2b7c64ac28c5608628c75ad", "patch": "@@ -2281,6 +2281,7 @@ build_x_function_call (function, params, decl)\n      tree function, params, decl;\n {\n   tree type;\n+  tree template_id = NULL_TREE;\n   int is_method;\n \n   if (function == error_mark_node)\n@@ -2289,6 +2290,13 @@ build_x_function_call (function, params, decl)\n   if (processing_template_decl)\n     return build_min_nt (CALL_EXPR, function, params, NULL_TREE);\n \n+  /* Save explicit template arguments if found */\n+  if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n+    {\n+      template_id = function;\n+      function = TREE_OPERAND (function, 0);\n+    }\n+\n   type = TREE_TYPE (function);\n \n   if (TREE_CODE (type) == OFFSET_TYPE\n@@ -2383,6 +2391,9 @@ build_x_function_call (function, params, decl)\n \t  decl = build_indirect_ref (decl, NULL_PTR);\n \t}\n \n+      /* Put back explicit template arguments, if any.  */\n+      if (template_id)\n+        function = template_id;\n       return build_method_call (decl, function, params,\n \t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n     }\n@@ -2411,7 +2422,12 @@ build_x_function_call (function, params, decl)\n \t  tree val = TREE_VALUE (function);\n \n \t  if (flag_ansi_overloading)\n-\t    return build_new_function_call (function, params, NULL_TREE);\n+\t    {\n+\t      /* Put back explicit template arguments, if any.  */\n+\t      if (template_id)\n+\t\tfunction = template_id;\n+\t      return build_new_function_call (function, params, NULL_TREE);\n+\t    }\n \n \t  if (TREE_CODE (val) == TEMPLATE_DECL)\n \t    return build_overload_call_real"}]}