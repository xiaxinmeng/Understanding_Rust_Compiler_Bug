{"sha": "1da37f43b21e0c35e57b627edfa99ec80d2976ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRhMzdmNDNiMjFlMGMzNWU1N2I2MjdlZGZhOTllYzgwZDI5NzZlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-01T20:27:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-01T20:27:36Z"}, "message": "runtime: persistentalloc and cache itabs\n    \n    Previously, each time we do an interface conversion for which the\n    method table is not known at compile time, we allocate a new\n    method table.\n    \n    This CL ports the mechanism of itab caching from the gc runtime,\n    adapted to our itab representation and method finding mechanism.\n    With the cache, we reuse the same itab for the same (interface,\n    concrete) type pair. This reduces allocations in interface\n    conversions.\n    \n    Unlike the gc runtime, we don't prepopulate the cache with\n    statically allocated itabs, as currently we don't have a way to\n    find them. This means we don't deduplicate run-time allocated\n    itabs with compile-time allocated ones. But that is not too bad\n    -- it is just a cache anyway.\n    \n    As now itabs are never freed, it is also possible to drop the\n    write barrier for writing the first word of an interface header.\n    I'll leave this optimization for the future.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/171617\n\nFrom-SVN: r270778", "tree": {"sha": "26483152e3287f06aa81c6a9d5905447f1ac0474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26483152e3287f06aa81c6a9d5905447f1ac0474"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1da37f43b21e0c35e57b627edfa99ec80d2976ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da37f43b21e0c35e57b627edfa99ec80d2976ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da37f43b21e0c35e57b627edfa99ec80d2976ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da37f43b21e0c35e57b627edfa99ec80d2976ee/comments", "author": null, "committer": null, "parents": [{"sha": "9f3a481e08cbcce98793b3c7a78045e4e9621493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3a481e08cbcce98793b3c7a78045e4e9621493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f3a481e08cbcce98793b3c7a78045e4e9621493"}], "stats": {"total": 258, "additions": 226, "deletions": 32}, "files": [{"sha": "b3042d0b532345fc556f5390c56dbf349d6185f7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da37f43b21e0c35e57b627edfa99ec80d2976ee/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da37f43b21e0c35e57b627edfa99ec80d2976ee/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1da37f43b21e0c35e57b627edfa99ec80d2976ee", "patch": "@@ -1,4 +1,4 @@\n-9476f6183791477dd9b883f51e2a46b224227735\n+e0b906b13cbc947406c634aaf8b06270292bd7e0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "dc9247625b18ce6c94ee45ac62e9829573c79a39", "filename": "libgo/go/runtime/iface.go", "status": "modified", "additions": 225, "deletions": 31, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da37f43b21e0c35e57b627edfa99ec80d2976ee/libgo%2Fgo%2Fruntime%2Fiface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da37f43b21e0c35e57b627edfa99ec80d2976ee/libgo%2Fgo%2Fruntime%2Fiface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface.go?ref=1da37f43b21e0c35e57b627edfa99ec80d2976ee", "patch": "@@ -5,6 +5,8 @@\n package runtime\n \n import (\n+\t\"runtime/internal/atomic\"\n+\t\"runtime/internal/sys\"\n \t\"unsafe\"\n )\n \n@@ -73,47 +75,160 @@ import (\n \n // For a nil interface value both fields in the interface struct are nil.\n \n-// Return the interface method table for a value of type rhs converted\n-// to an interface of type lhs.\n-func getitab(lhs, rhs *_type, canfail bool) unsafe.Pointer {\n-\tif rhs == nil {\n-\t\treturn nil\n-\t}\n+// itabs are statically allocated or persistently allocated. They are\n+// never freed. For itabs allocated at run time, they are cached in\n+// itabTable, so we reuse the same itab for the same (interface, concrete)\n+// type pair. The gc runtime prepopulates the cache with statically\n+// allocated itabs. Currently we don't do that as we don't have a way to\n+// find all the statically allocated itabs.\n \n-\tif lhs.kind&kindMask != kindInterface {\n-\t\tthrow(\"getitab called for non-interface type\")\n+const itabInitSize = 512\n+\n+var (\n+\titabLock      mutex                               // lock for accessing itab table\n+\titabTable     = &itabTableInit                    // pointer to current table\n+\titabTableInit = itabTableType{size: itabInitSize} // starter table\n+)\n+\n+// Cache entry type of itab table.\n+// For gccgo, this is not the data type we used in the interface header.\n+type itab struct {\n+\tinter   *interfacetype\n+\tmethods [2]unsafe.Pointer // method table. variable sized. first entry is the type descriptor.\n+}\n+\n+func (m *itab) _type() *_type {\n+\treturn (*_type)(m.methods[0])\n+}\n+\n+// Note: change the formula in the mallocgc call in itabAdd if you change these fields.\n+type itabTableType struct {\n+\tsize    uintptr             // length of entries array. Always a power of 2.\n+\tcount   uintptr             // current number of filled entries.\n+\tentries [itabInitSize]*itab // really [size] large\n+}\n+\n+func itabHashFunc(inter *interfacetype, typ *_type) uintptr {\n+\t// compiler has provided some good hash codes for us.\n+\treturn uintptr(inter.typ.hash ^ typ.hash)\n+}\n+\n+// find finds the given interface/type pair in t.\n+// Returns nil if the given interface/type pair isn't present.\n+func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab {\n+\t// Implemented using quadratic probing.\n+\t// Probe sequence is h(i) = h0 + i*(i+1)/2 mod 2^k.\n+\t// We're guaranteed to hit all table entries using this probe sequence.\n+\tmask := t.size - 1\n+\th := itabHashFunc(inter, typ) & mask\n+\tfor i := uintptr(1); ; i++ {\n+\t\tp := (**itab)(add(unsafe.Pointer(&t.entries), h*sys.PtrSize))\n+\t\t// Use atomic read here so if we see m != nil, we also see\n+\t\t// the initializations of the fields of m.\n+\t\t// m := *p\n+\t\tm := (*itab)(atomic.Loadp(unsafe.Pointer(p)))\n+\t\tif m == nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif m.inter == inter && m._type() == typ {\n+\t\t\treturn m\n+\t\t}\n+\t\th += i\n+\t\th &= mask\n \t}\n+}\n \n-\tlhsi := (*interfacetype)(unsafe.Pointer(lhs))\n+// itabAdd adds the given itab to the itab hash table.\n+// itabLock must be held.\n+func itabAdd(m *itab) {\n+\t// Bugs can lead to calling this while mallocing is set,\n+\t// typically because this is called while panicing.\n+\t// Crash reliably, rather than only when we need to grow\n+\t// the hash table.\n+\tif getg().m.mallocing != 0 {\n+\t\tthrow(\"malloc deadlock\")\n+\t}\n \n-\tif len(lhsi.methods) == 0 {\n-\t\tthrow(\"getitab called for empty interface type\")\n+\tt := itabTable\n+\tif t.count >= 3*(t.size/4) { // 75% load factor\n+\t\t// Grow hash table.\n+\t\t// t2 = new(itabTableType) + some additional entries\n+\t\t// We lie and tell malloc we want pointer-free memory because\n+\t\t// all the pointed-to values are not in the heap.\n+\t\tt2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true))\n+\t\tt2.size = t.size * 2\n+\n+\t\t// Copy over entries.\n+\t\t// Note: while copying, other threads may look for an itab and\n+\t\t// fail to find it. That's ok, they will then try to get the itab lock\n+\t\t// and as a consequence wait until this copying is complete.\n+\t\titerate_itabs(t2.add)\n+\t\tif t2.count != t.count {\n+\t\t\tthrow(\"mismatched count during itab table copy\")\n+\t\t}\n+\t\t// Publish new hash table. Use an atomic write: see comment in getitab.\n+\t\tatomicstorep(unsafe.Pointer(&itabTable), unsafe.Pointer(t2))\n+\t\t// Adopt the new table as our own.\n+\t\tt = itabTable\n+\t\t// Note: the old table can be GC'ed here.\n \t}\n+\tt.add(m)\n+}\n \n-\tif rhs.uncommontype == nil || len(rhs.methods) == 0 {\n-\t\tif canfail {\n-\t\t\treturn nil\n+// add adds the given itab to itab table t.\n+// itabLock must be held.\n+func (t *itabTableType) add(m *itab) {\n+\t// See comment in find about the probe sequence.\n+\t// Insert new itab in the first empty spot in the probe sequence.\n+\tmask := t.size - 1\n+\th := itabHashFunc(m.inter, m._type()) & mask\n+\tfor i := uintptr(1); ; i++ {\n+\t\tp := (**itab)(add(unsafe.Pointer(&t.entries), h*sys.PtrSize))\n+\t\tm2 := *p\n+\t\tif m2 == m {\n+\t\t\t// A given itab may be used in more than one module\n+\t\t\t// and thanks to the way global symbol resolution works, the\n+\t\t\t// pointed-to itab may already have been inserted into the\n+\t\t\t// global 'hash'.\n+\t\t\treturn\n \t\t}\n-\t\tpanic(&TypeAssertionError{nil, rhs, lhs, *lhsi.methods[0].name})\n+\t\tif m2 == nil {\n+\t\t\t// Use atomic write here so if a reader sees m, it also\n+\t\t\t// sees the correctly initialized fields of m.\n+\t\t\t// NoWB is ok because m is not in heap memory.\n+\t\t\t// *p = m\n+\t\t\tatomic.StorepNoWB(unsafe.Pointer(p), unsafe.Pointer(m))\n+\t\t\tt.count++\n+\t\t\treturn\n+\t\t}\n+\t\th += i\n+\t\th &= mask\n \t}\n+}\n \n-\tmethods := make([]unsafe.Pointer, len(lhsi.methods)+1)\n-\tmethods[0] = unsafe.Pointer(rhs)\n+// init fills in the m.methods array with all the code pointers for\n+// the m.inter/m._type pair. If the type does not implement the interface,\n+// it sets m.methods[1] to nil and returns the name of an interface function that is missing.\n+// It is ok to call this multiple times on the same m, even concurrently.\n+func (m *itab) init() string {\n+\tinter := m.inter\n+\ttyp := m._type()\n+\tni := len(inter.methods) + 1\n+\tmethods := (*[1 << 16]unsafe.Pointer)(unsafe.Pointer(&m.methods[0]))[:ni:ni]\n+\tvar m1 unsafe.Pointer\n \n \tri := 0\n-\tfor li := range lhsi.methods {\n-\t\tlhsMethod := &lhsi.methods[li]\n+\tfor li := range inter.methods {\n+\t\tlhsMethod := &inter.methods[li]\n \t\tvar rhsMethod *method\n \n \t\tfor {\n-\t\t\tif ri >= len(rhs.methods) {\n-\t\t\t\tif canfail {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t\tpanic(&TypeAssertionError{nil, rhs, lhs, *lhsMethod.name})\n+\t\t\tif ri >= len(typ.methods) {\n+\t\t\t\tm.methods[1] = nil\n+\t\t\t\treturn *lhsMethod.name\n \t\t\t}\n \n-\t\t\trhsMethod = &rhs.methods[ri]\n+\t\t\trhsMethod = &typ.methods[ri]\n \t\t\tif (lhsMethod.name == rhsMethod.name || *lhsMethod.name == *rhsMethod.name) &&\n \t\t\t\t(lhsMethod.pkgPath == rhsMethod.pkgPath || *lhsMethod.pkgPath == *rhsMethod.pkgPath) {\n \t\t\t\tbreak\n@@ -123,17 +238,96 @@ func getitab(lhs, rhs *_type, canfail bool) unsafe.Pointer {\n \t\t}\n \n \t\tif !eqtype(lhsMethod.typ, rhsMethod.mtyp) {\n-\t\t\tif canfail {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tpanic(&TypeAssertionError{nil, rhs, lhs, *lhsMethod.name})\n+\t\t\tm.methods[1] = nil\n+\t\t\treturn *lhsMethod.name\n \t\t}\n \n-\t\tmethods[li+1] = unsafe.Pointer(rhsMethod.tfn)\n+\t\tif li == 0 {\n+\t\t\tm1 = rhsMethod.tfn // we'll set m.methods[1] at the end\n+\t\t} else {\n+\t\t\tmethods[li+1] = rhsMethod.tfn\n+\t\t}\n \t\tri++\n \t}\n+\tm.methods[1] = m1\n+\treturn \"\"\n+}\n+\n+func iterate_itabs(fn func(*itab)) {\n+\t// Note: only runs during stop the world or with itabLock held,\n+\t// so no other locks/atomics needed.\n+\tt := itabTable\n+\tfor i := uintptr(0); i < t.size; i++ {\n+\t\tm := *(**itab)(add(unsafe.Pointer(&t.entries), i*sys.PtrSize))\n+\t\tif m != nil {\n+\t\t\tfn(m)\n+\t\t}\n+\t}\n+}\n \n-\treturn unsafe.Pointer(&methods[0])\n+// Return the interface method table for a value of type rhs converted\n+// to an interface of type lhs.\n+func getitab(lhs, rhs *_type, canfail bool) unsafe.Pointer {\n+\tif rhs == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif lhs.kind&kindMask != kindInterface {\n+\t\tthrow(\"getitab called for non-interface type\")\n+\t}\n+\n+\tlhsi := (*interfacetype)(unsafe.Pointer(lhs))\n+\n+\tif len(lhsi.methods) == 0 {\n+\t\tthrow(\"getitab called for empty interface type\")\n+\t}\n+\n+\tif rhs.uncommontype == nil || len(rhs.methods) == 0 {\n+\t\tif canfail {\n+\t\t\treturn nil\n+\t\t}\n+\t\tpanic(&TypeAssertionError{nil, rhs, lhs, *lhsi.methods[0].name})\n+\t}\n+\n+\tvar m *itab\n+\n+\t// First, look in the existing table to see if we can find the itab we need.\n+\t// This is by far the most common case, so do it without locks.\n+\t// Use atomic to ensure we see any previous writes done by the thread\n+\t// that updates the itabTable field (with atomic.Storep in itabAdd).\n+\tt := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&itabTable)))\n+\tif m = t.find(lhsi, rhs); m != nil {\n+\t\tgoto finish\n+\t}\n+\n+\t// Not found.  Grab the lock and try again.\n+\tlock(&itabLock)\n+\tif m = itabTable.find(lhsi, rhs); m != nil {\n+\t\tunlock(&itabLock)\n+\t\tgoto finish\n+\t}\n+\n+\t// Entry doesn't exist yet. Make a new entry & add it.\n+\tm = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(lhsi.methods)-1)*sys.PtrSize, 0, &memstats.other_sys))\n+\tm.inter = lhsi\n+\tm.methods[0] = unsafe.Pointer(rhs)\n+\tm.init()\n+\titabAdd(m)\n+\tunlock(&itabLock)\n+finish:\n+\tif m.methods[1] != nil {\n+\t\treturn unsafe.Pointer(&m.methods[0])\n+\t}\n+\tif canfail {\n+\t\treturn nil\n+\t}\n+\t// this can only happen if the conversion\n+\t// was already done once using the , ok form\n+\t// and we have a cached negative result.\n+\t// The cached result doesn't record which\n+\t// interface function was missing, so initialize\n+\t// the itab again to get the missing function name.\n+\tpanic(&TypeAssertionError{nil, rhs, lhs, m.init()})\n }\n \n // Return the interface method table for a value of type rhs converted"}]}