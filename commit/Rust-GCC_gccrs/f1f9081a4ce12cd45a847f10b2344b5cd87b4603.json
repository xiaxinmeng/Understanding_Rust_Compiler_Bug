{"sha": "f1f9081a4ce12cd45a847f10b2344b5cd87b4603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFmOTA4MWE0Y2UxMmNkNDVhODQ3ZjEwYjIzNDRiNWNkODdiNDYwMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-18T02:31:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-18T02:31:15Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r206", "tree": {"sha": "97a573b1f7cf663327cd23d8a3dc59f9e79f7f47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97a573b1f7cf663327cd23d8a3dc59f9e79f7f47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1f9081a4ce12cd45a847f10b2344b5cd87b4603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f9081a4ce12cd45a847f10b2344b5cd87b4603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f9081a4ce12cd45a847f10b2344b5cd87b4603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f9081a4ce12cd45a847f10b2344b5cd87b4603/comments", "author": null, "committer": null, "parents": [{"sha": "84607dc137419cd7c5e7c4d10c9710b92aac6080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84607dc137419cd7c5e7c4d10c9710b92aac6080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84607dc137419cd7c5e7c4d10c9710b92aac6080"}], "stats": {"total": 53, "additions": 42, "deletions": 11}, "files": [{"sha": "deb97e0020c3db187d97177f637424e7ac2b1390", "filename": "gcc/reorg.c", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1f9081a4ce12cd45a847f10b2344b5cd87b4603/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1f9081a4ce12cd45a847f10b2344b5cd87b4603/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f1f9081a4ce12cd45a847f10b2344b5cd87b4603", "patch": "@@ -1,5 +1,5 @@\n /* Perform instruction reorganizations for delay slot filling.\n-   Copyright (C) 1990, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu).\n    Hacked by Michael Tiemann (tiemann@cygnus.com).\n \n@@ -273,6 +273,23 @@ mark_referenced_resources (x, res, include_called_routine)\n       res->cc = 1;\n       return;\n \n+    case ASM_INPUT:\n+      /* Traditional asm's are always volatile.  */\n+      res->volatil = 1;\n+      return;\n+\n+    case ASM_OPERANDS:\n+      res->volatil = MEM_VOLATILE_P (x);\n+\n+      /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n+\t We can not just fall through here since then we would be confused\n+\t by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n+\t traditional asms unlike their normal usage.  */\n+      \n+      for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n+\tmark_referenced_resources (ASM_OPERANDS_INPUT (x, i), res, 0);\n+      return;\n+\n     case CALL:\n       /* The first operand will be a (MEM (xxx)) but doesn't really reference\n \t memory.  The second operand may be referenced, though.  */\n@@ -719,6 +736,20 @@ emit_delay_sequence (insn, list, length, avail)\n \n   NEXT_INSN (XVECEXP (seq, 0, length)) = NEXT_INSN (seq_insn);\n \n+  /* If the previous insn is a SEQUENCE, update the NEXT_INSN pointer on the\n+     last insn in that SEQUENCE to point to us.  Similarly for the first\n+     insn in the following insn if it is a SEQUENCE.  */\n+\n+  if (PREV_INSN (seq_insn) && GET_CODE (PREV_INSN (seq_insn)) == INSN\n+      && GET_CODE (PATTERN (PREV_INSN (seq_insn))) == SEQUENCE)\n+    NEXT_INSN (XVECEXP (PATTERN (PREV_INSN (seq_insn)), 0,\n+\t\t\tXVECLEN (PATTERN (PREV_INSN (seq_insn)), 0) - 1))\n+      = seq_insn;\n+\n+  if (NEXT_INSN (seq_insn) && GET_CODE (NEXT_INSN (seq_insn)) == INSN\n+      && GET_CODE (PATTERN (NEXT_INSN (seq_insn))) == SEQUENCE)\n+    PREV_INSN (XVECEXP (PATTERN (NEXT_INSN (seq_insn)), 0, 0)) = seq_insn;\n+    \n   /* If there used to be a BARRIER, put it back.  */\n   if (had_barrier)\n     emit_barrier_after (seq_insn);\n@@ -811,7 +842,7 @@ delete_from_delay_slot (insn)\n   /* If there are any delay insns, remit them.  Otherwise clear the\n      annul flag.  */\n   if (delay_list)\n-    trial = emit_delay_sequence (trial, delay_list, XVECLEN (seq, 0) - 1, 0);\n+    trial = emit_delay_sequence (trial, delay_list, XVECLEN (seq, 0) - 2, 0);\n   else\n     INSN_ANNULLED_BRANCH_P (trial) = 0;\n \n@@ -1377,7 +1408,7 @@ try_merge_delay_insns (insn, thread)\n \n \t  if (! annul_p)\n \t    {\n-\t      update_block (trial, trial);\n+\t      update_block (trial, thread);\n \t      delete_insn (trial);\n \t      INSN_FROM_TARGET_P (next_to_match) = 0;\n \t    }\n@@ -1420,7 +1451,7 @@ try_merge_delay_insns (insn, thread)\n \t    {\n \t      if (! annul_p)\n \t\t{\n-\t\t  update_block (dtrial, trial);\n+\t\t  update_block (dtrial, thread);\n \t\t  delete_from_delay_slot (dtrial);\n \t\t  INSN_FROM_TARGET_P (next_to_match) = 0;\n \t\t}\n@@ -1447,12 +1478,12 @@ try_merge_delay_insns (insn, thread)\n \t{\n \t  if (GET_MODE (merged_insns) == SImode)\n \t    {\n-\t      update_block (XEXP (merged_insns, 0), trial);\n+\t      update_block (XEXP (merged_insns, 0), thread);\n \t      delete_from_delay_slot (XEXP (merged_insns, 0));\n \t    }\n \t  else\n \t    {\n-\t      update_block (XEXP (merged_insns, 0), XEXP (merged_insns, 0));\n+\t      update_block (XEXP (merged_insns, 0), thread);\n \t      delete_insn (XEXP (merged_insns, 0));\n \t    }\n \t}\n@@ -1761,7 +1792,7 @@ update_block_from_store (dest, x)\n }\n \n /* Called when INSN is being moved from a location near the target of a jump.\n-   If INSN is the first active insn at the start of its basic block, we can\n+   If WHERE is the first active insn at the start of its basic block, we can\n    just mark the registers set in INSN as live at the start of the basic block\n    that starts immediately before INSN.\n \n@@ -1783,7 +1814,7 @@ update_block (insn, where)\n   if (current_block_number == -1)\n     return;\n \n-  if (insn == next_active_insn (basic_block_head[current_block_number]))\n+  if (where == next_active_insn (basic_block_head[current_block_number]))\n     note_stores (PATTERN (insn), update_block_from_store);\n   else\n     emit_insn_before (gen_rtx (USE, VOIDmode, insn), where);\n@@ -2689,7 +2720,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t    {\n \t      if (own_thread)\n \t\t{\n-\t\t  update_block (trial, trial);\n+\t\t  update_block (trial, thread);\n \t\t  delete_insn (trial);\n \t\t}\n \t      else\n@@ -2741,7 +2772,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t     starting point of this thread.  */\n \t\t  if (own_thread)\n \t\t    {\n-\t\t      update_block (trial, trial);\n+\t\t      update_block (trial, thread);\n \t\t      delete_insn (trial);\n \t\t    }\n \t\t  else\n@@ -2884,7 +2915,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n \t  if (own_thread)\n \t    {\n-\t      update_block (trial, trial);\n+\t      update_block (trial, thread);\n \t      delete_insn (trial);\n \t    }\n \t  else"}]}