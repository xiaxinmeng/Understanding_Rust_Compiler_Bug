{"sha": "2ddc34ba077d7c0eff279688c236ba4eaaa79538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRkYzM0YmEwNzdkN2MwZWZmMjc5Njg4YzIzNmJhNGVhYWE3OTUzOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-11-27T20:56:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-11-27T20:56:22Z"}, "message": "* gcc-interface/decl.c: Fix various nits.\n\nFrom-SVN: r142247", "tree": {"sha": "32223b9e346d0d66c3f253ea3695d7bb3acc06cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32223b9e346d0d66c3f253ea3695d7bb3acc06cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ddc34ba077d7c0eff279688c236ba4eaaa79538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ddc34ba077d7c0eff279688c236ba4eaaa79538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ddc34ba077d7c0eff279688c236ba4eaaa79538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ddc34ba077d7c0eff279688c236ba4eaaa79538/comments", "author": null, "committer": null, "parents": [{"sha": "50e0f1313a01bafed02b3c8ebc53b92c37d05ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e0f1313a01bafed02b3c8ebc53b92c37d05ee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e0f1313a01bafed02b3c8ebc53b92c37d05ee3"}], "stats": {"total": 118, "additions": 62, "deletions": 56}, "files": [{"sha": "b212a1136551068038f5f2b1a6764acf4a41b956", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ddc34ba077d7c0eff279688c236ba4eaaa79538/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ddc34ba077d7c0eff279688c236ba4eaaa79538/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2ddc34ba077d7c0eff279688c236ba4eaaa79538", "patch": "@@ -1,3 +1,7 @@\n+2008-11-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c: Fix various nits.\n+\n 2008-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (init_gigi_decls): Fix type mismatch."}, {"sha": "14fcd634b610ad400520cb87c4de1de4961b9262", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ddc34ba077d7c0eff279688c236ba4eaaa79538/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ddc34ba077d7c0eff279688c236ba4eaaa79538/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=2ddc34ba077d7c0eff279688c236ba4eaaa79538", "patch": "@@ -76,7 +76,7 @@\n    support it and use FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN for this purpose.\n \n    It is defined on targets where the circuitry is available, and indicates\n-   whether the realignment is needed for 'main'. We use this to decide for\n+   whether the realignment is needed for 'main'.  We use this to decide for\n    foreign subprograms as well.\n \n    It is not defined on targets where the circuitry is not implemented, and\n@@ -181,7 +181,7 @@ gnat_to_gnu_type (Entity_Id gnat_entity)\n    defining identifier.\n \n    If GNAT_ENTITY is a variable or a constant declaration, GNU_EXPR gives its\n-   initial value (in GCC tree form). This is optional for variables.\n+   initial value (in GCC tree form).  This is optional for variables.\n    For renamed entities, GNU_EXPR gives the object being renamed.\n \n    DEFINITION is nonzero if this call is intended for a definition.  This is\n@@ -198,7 +198,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   tree gnu_entity_id;\n   tree gnu_type = NULL_TREE;\n   /* Contains the gnu XXXX_DECL tree node which is equivalent to the input\n-     GNAT tree. This node will be associated with the GNAT node by calling\n+     GNAT tree.  This node will be associated with the GNAT node by calling\n      the save_gnu_tree routine at the end of the `switch' statement.  */\n   tree gnu_decl = NULL_TREE;\n   /* true if we have already saved gnu_decl as a gnat association.  */\n@@ -231,7 +231,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   unsigned int align = 0;\n \n   /* Since a use of an Itype is a definition, process it as such if it\n-     is not in a with'ed unit. */\n+     is not in a with'ed unit.  */\n \n   if (!definition && Is_Itype (gnat_entity)\n       && !present_gnu_tree (gnat_entity)\n@@ -437,7 +437,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Discriminant:\n     case E_Component:\n       {\n-\t/* The GNAT record where the component was defined. */\n+\t/* The GNAT record where the component was defined.  */\n \tEntity_Id gnat_record = Underlying_Type (Scope (gnat_entity));\n \n \t/* If the variable is an inherited record component (in the case of\n@@ -468,7 +468,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (Present (Corresponding_Discriminant (gnat_entity))\n \t\t && Is_Tagged_Type (gnat_record))\n \t  {\n-\t    /* A tagged record has no explicit stored discriminants. */\n+\t    /* A tagged record has no explicit stored discriminants.  */\n \n \t    gcc_assert (First_Discriminant (gnat_record)\n \t\t       == First_Stored_Discriminant (gnat_record));\n@@ -488,8 +488,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n-\t/* If the enclosing record has explicit stored discriminants,\n-\t   then it is an untagged record. If the Corresponding_Discriminant\n+\t/* If the enclosing record has explicit stored discriminants, then\n+\t   it is an untagged record.  If the Corresponding_Discriminant\n \t   is not empty then this must be a renamed discriminant and its\n \t   Original_Record_Component must point to the corresponding explicit\n \t   stored discriminant (i.e., we should have taken the first\n@@ -532,7 +532,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \telse\n \t  /* Here we have no GCC type and this is a reference rather than a\n-\t     definition. This should never happen. Most likely the cause is a\n+\t     definition.  This should never happen.  Most likely the cause is\n \t     reference before declaration in the gnat tree for gnat_entity.  */\n \t  gcc_unreachable ();\n       }\n@@ -597,7 +597,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_type = get_base_type (gnu_type);\n \n \t/* Reject non-renamed objects whose types are unconstrained arrays or\n-\t   any object whose type is a dummy type or VOID_TYPE. */\n+\t   any object whose type is a dummy type or VOID_TYPE.  */\n \n \tif ((TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n \t     && No (Renamed_Object (gnat_entity)))\n@@ -624,8 +624,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* If we are defining the object, see if it has a Size value and\n-\t   validate it if so. If we are not defining the object and a Size\n-\t   clause applies, simply retrieve the value. We don't want to ignore\n+\t   validate it if so.  If we are not defining the object and a Size\n+\t   clause applies, simply retrieve the value.  We don't want to ignore\n \t   the clause and it is expected to have been validated already.  Then\n \t   get the new type, if any.  */\n \tif (definition)\n@@ -762,7 +762,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   type and validate it.\n \n \t   ??? Note that we ignore Has_Volatile_Components on objects; it's\n-\t   not at all clear what to do in that case. */\n+\t   not at all clear what to do in that case.  */\n \n \tif (Has_Atomic_Components (gnat_entity))\n \t  {\n@@ -1410,16 +1410,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n     case E_Enumeration_Type:\n       /* A special case, for the types Character and Wide_Character in\n-\t Standard, we do not list all the literals. So if the literals\n+\t Standard, we do not list all the literals.  So if the literals\n \t are not specified, make this an unsigned type.  */\n       if (No (First_Literal (gnat_entity)))\n \t{\n \t  gnu_type = make_unsigned_type (esize);\n \t  TYPE_NAME (gnu_type) = gnu_entity_id;\n \n-\t  /* Set the TYPE_STRING_FLAG for Ada Character and\n-\t     Wide_Character types. This is needed by the dwarf-2 debug writer to\n-\t     distinguish between unsigned integer types and character types.  */\n+\t  /* Set TYPE_STRING_FLAG for Ada Character and Wide_Character types.\n+\t     This is needed by the DWARF-2 back-end to distinguish between\n+\t     unsigned integer types and character types.  */\n \t  TYPE_STRING_FLAG (gnu_type) = 1;\n \t  break;\n \t}\n@@ -1563,7 +1563,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t unit and one of our bounds is non-static.  We do this to ensure\n \t consistent naming in the case where several subtypes share the same\n \t bounds by always elaborating the first such subtype first, thus\n-\t using its name. */\n+\t using its name.  */\n \n       if (!definition\n \t  && Present (Ancestor_Subtype (gnat_entity))\n@@ -1917,7 +1917,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t   build_range_type (gnu_ind_subtype,\n \t\t\t\t\t\t     gnu_min, gnu_max),\n \t\t\t\t   gnat_entity);\n-\t    /* Update the maximum size of the array, in elements. */\n+\t    /* Update the maximum size of the array, in elements.  */\n \t    gnu_max_size\n \t      = size_binop (MULT_EXPR, gnu_max_size,\n \t\t\t    size_binop (PLUS_EXPR, size_one_node,\n@@ -1954,7 +1954,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  check_ok_for_atomic (tem, gnat_entity, true);\n \n \t/* Get and validate any specified Component_Size, but if Packed,\n-\t   ignore it since the front end will have taken care of it. */\n+\t   ignore it since the front end will have taken care of it.  */\n \tgnu_comp_size\n \t  = validate_size (Component_Size (gnat_entity), tem,\n \t\t\t   gnat_entity,\n@@ -2319,7 +2319,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_type = make_packable_type (gnu_type, false);\n \n \t      /* Get and validate any specified Component_Size, but if Packed,\n-\t\t ignore it since the front end will have taken care of it. */\n+\t\t ignore it since the front end will have taken care of it.  */\n \t      gnu_comp_size\n \t\t= validate_size (Component_Size (gnat_entity), gnu_type,\n \t\t\t\t gnat_entity,\n@@ -2571,14 +2571,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \t}\n \n-      /* Abort if packed array with no packed array type field set. */\n+      /* Abort if packed array with no packed array type field set.  */\n       else\n \tgcc_assert (!Is_Packed (gnat_entity));\n \n       break;\n \n     case E_String_Literal_Subtype:\n-      /* Create the type for a string literal. */\n+      /* Create the type for a string literal.  */\n       {\n \tEntity_Id gnat_full_type\n \t  = (IN (Ekind (Etype (gnat_entity)), Private_Kind)\n@@ -2637,7 +2637,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n        Processing of a record type definition comprises starting the list of\n        field declarations here from the discriminants and the calling the\n        function components_to_record to add the rest of the fields from the\n-       component list and return the gnu type node. The function\n+       component list and return the gnu type node.  The function\n        components_to_record will call itself recursively as it traverses\n        the tree.  */\n \n@@ -2870,14 +2870,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_entity);\n \n \t/* If it is a tagged record force the type to BLKmode to insure\n-\t   that these objects will always be placed in memory. Do the\n-\t   same thing for limited record types. */\n+\t   that these objects will always be placed in memory.  Do the\n+\t   same thing for limited record types.  */\n \tif (Is_Tagged_Type (gnat_entity) || Is_Limited_Record (gnat_entity))\n \t  TYPE_MODE (gnu_type) = BLKmode;\n \n \t/* If this is a derived type, we must make the alias set of this type\n \t   the same as that of the type we are derived from.  We assume here\n-\t   that the other type is already frozen. */\n+\t   that the other type is already frozen.  */\n \tif (Etype (gnat_entity) != gnat_entity\n \t    && !(Is_Private_Type (Etype (gnat_entity))\n \t\t && Full_View (Etype (gnat_entity)) == gnat_entity))\n@@ -3305,7 +3305,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Nonzero if we make a dummy type here.  */\n \tbool got_fat_p = false;\n-\t/* Nonzero if the dummy is a fat pointer. */\n+\t/* Nonzero if the dummy is a fat pointer.  */\n \tbool made_dummy = false;\n \ttree gnu_desig_type = NULL_TREE;\n \tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n@@ -3436,7 +3436,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    are to defer elaborating incomplete types.  We do this\n \t\t    since this access type may be the full view of some\n \t\t    private type.  Note that the unconstrained array case is\n-\t\t    handled above. */\n+\t\t    handled above.  */\n \t\t || ((! in_main_unit || imported_p)\n \t\t     && defer_incomplete_level != 0\n \t\t     && ! present_gnu_tree (gnat_desig_equiv)\n@@ -3450,7 +3450,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    when the declaration is processed.  In both cases, the\n \t\t    pointer eventually created below will be automatically\n \t\t    adjusted when the Freeze_Node is processed.  Note that the\n-\t\t    unconstrained array case is handled above. */\n+\t\t    unconstrained array case is handled above.  */\n \t\t ||  (in_main_unit && is_from_limited_with\n \t\t      && Present (Freeze_Node (gnat_desig_rep))))\n \t  {\n@@ -3499,7 +3499,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     TYPE_QUALS (gnu_desig_type) | TYPE_QUAL_CONST);\n \n \t\t/* Some extra processing is required if we are building a\n-\t\t   pointer to an incomplete type (in the GCC sense). We might\n+\t\t   pointer to an incomplete type (in the GCC sense).  We might\n \t\t   have such a type if we just made a dummy, or directly out\n \t\t   of the call to gnat_to_gnu_type above if we are processing\n \t\t   an access type for a record component designating the\n@@ -3508,16 +3508,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  {\n \t\t    /* We must ensure that the pointer to variant we make will\n \t\t       be processed by update_pointer_to when the initial type\n-\t\t       is completed. Pretend we made a dummy and let further\n+\t\t       is completed.  Pretend we made a dummy and let further\n \t\t       processing act as usual.  */\n \t\t    made_dummy = true;\n \n \t\t    /* We must ensure that update_pointer_to will not retrieve\n \t\t       the dummy variant when building a properly qualified\n-\t\t       version of the complete type. We take advantage of the\n+\t\t       version of the complete type.  We take advantage of the\n \t\t       fact that get_qualified_type is requiring TYPE_NAMEs to\n \t\t       match to influence build_qualified_type and then also\n-\t\t       update_pointer_to here. */\n+\t\t       update_pointer_to here.  */\n \t\t    TYPE_NAME (gnu_desig_type)\n \t\t      = create_concat_name (gnat_desig_type, \"INCOMPLETE_CST\");\n \t\t  }\n@@ -3574,7 +3574,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t node as the one we got.\n \n \t\t Besides, variants of this non-dummy type might have been\n-\t\t created along the way. update_pointer_to is expected to\n+\t\t created along the way.  update_pointer_to is expected to\n \t\t properly take care of those situations.  */\n \t    else\n \t      {\n@@ -3602,9 +3602,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type = ptr_void_type_node;\n       else\n \t{\n-\t  /* The runtime representation is the equivalent type. */\n+\t  /* The runtime representation is the equivalent type.  */\n \t  gnu_type = gnat_to_gnu_type (gnat_equiv_type);\n-\t  maybe_present = 1;\n+\t  maybe_present = true;\n \t}\n \n       if (Is_Itype (Directly_Designated_Type (gnat_entity))\n@@ -3622,12 +3622,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t meaningful only to the front end.\n \n \t The designated type must be elaborated as well, if it does\n-\t not have its own freeze node. Designated (sub)types created\n+\t not have its own freeze node.  Designated (sub)types created\n \t for constrained components of records with discriminants are\n \t not frozen by the front end and thus not elaborated by gigi,\n \t because their use may appear before the base type is frozen,\n \t and because it is not clear that they are needed anywhere in\n-\t Gigi. With the current model, there is no correct place where\n+\t Gigi.  With the current model, there is no correct place where\n \t they could be elaborated.  */\n \n       gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n@@ -3669,7 +3669,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\tFirst_Formal\tThe first formal parameter.\n \t\tIs_Imported     Indicates that the subprogram has appeared in\n-\t\t\t\tan INTERFACE or IMPORT pragma. For now we\n+\t\t\t\tan INTERFACE or IMPORT pragma.  For now we\n \t\t\t\tassume that the external language is C.\n \t\tIs_Exported     Likewise but for an EXPORT pragma.\n \t\tIs_Inlined      True if the subprogram is to be inlined.\n@@ -3683,7 +3683,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n        are copied in, if they are Ada In Out or Out parameters, their return\n        value becomes part of a record which becomes the return type of the\n        function (C function - note that this applies only to Ada procedures\n-       so there is no Ada return type). Additional code to store back the\n+       so there is no Ada return type).  Additional code to store back the\n        parameters will be generated on the caller side.  This transformation\n        is done here, not in the front-end.\n \n@@ -3716,7 +3716,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_param_list = NULL_TREE;\n \t/* Likewise for the stub associated with an exported procedure.  */\n \ttree gnu_stub_param_list = NULL_TREE;\n-\t/* The type returned by a function. If the subprogram is a procedure\n+\t/* The type returned by a function.  If the subprogram is a procedure\n \t   this type should be void_type_node.  */\n \ttree gnu_return_type = void_type_node;\n \t/* List of fields in return type of procedure with copy-in copy-out\n@@ -3802,7 +3802,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* ??? What if we don't find the builtin node above ? warn ? err ?\n \t   In the current state we neither warn nor err, and calls will just\n-\t   be handled as for regular subprograms. */\n+\t   be handled as for regular subprograms.  */\n \n \tif (kind == E_Function || kind == E_Subprogram_Type)\n \t  gnu_return_type = gnat_to_gnu_type (Etype (gnat_entity));\n@@ -4071,7 +4071,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* A subprogram (something that doesn't return anything) shouldn't\n \t   be considered const since there would be no reason for such a\n \t   subprogram.  Note that procedures with Out (or In Out) parameters\n-\t   have already been converted into a function with a return type. */\n+\t   have already been converted into a function with a return type.  */\n \tif (TREE_CODE (gnu_return_type) == VOID_TYPE)\n \t  const_flag = false;\n \n@@ -4537,7 +4537,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      /* In this mode the tag and the parent components are not\n \t\t generated by the front-end, so the sizes must be adjusted\n-\t\t explicitly now. */\n+\t\t explicitly now.  */\n \t      int size_offset, new_size;\n \n \t      if (Is_Derived_Type (gnat_entity))\n@@ -4571,7 +4571,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     DECL_IGNORED_P (gnu_decl) = 1;\n \n   /* If we haven't already, associate the ..._DECL node that we just made with\n-     the input GNAT entity node. */\n+     the input GNAT entity node.  */\n   if (!saved)\n     save_gnu_tree (gnat_entity, gnu_decl, false);\n \n@@ -5054,7 +5054,7 @@ elaborate_entity (Entity_Id gnat_entity)\n \n \t/* ??? Tests for avoiding static constraint error expression\n \t   is needed until the front stops generating bogus conversions\n-\t   on bounds of real types. */\n+\t   on bounds of real types.  */\n \n \tif (!Raises_Constraint_Error (gnat_lb))\n \t  elaborate_expression (gnat_lb, gnat_entity, get_identifier (\"L\"),\n@@ -5177,7 +5177,7 @@ copy_alias_set (tree gnu_new_type, tree gnu_old_type)\n /* Return a TREE_LIST describing the substitutions needed to reflect\n    discriminant substitutions from GNAT_SUBTYPE to GNAT_TYPE and add\n    them to GNU_LIST.  If GNAT_TYPE is not specified, use the base type\n-   of GNAT_SUBTYPE. The substitutions can be in any order.  TREE_PURPOSE\n+   of GNAT_SUBTYPE.  The substitutions can be in any order.  TREE_PURPOSE\n    gives the tree for the discriminant and TREE_VALUES is the replacement\n    value.  They are in the form of operands to substitute_in_expr.\n    DEFINITION is as in gnat_to_gnu_entity.  */\n@@ -5406,7 +5406,7 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n \t\t\t      gnu_name, definition, need_debug);\n \n   /* Save the expression in case we try to elaborate this entity again.  Since\n-     this is not a DECL, don't check it.  Don't save if it's a discriminant. */\n+     it's not a DECL, don't check it.  Don't save if it's a discriminant.  */\n   if (!CONTAINS_PLACEHOLDER_P (gnu_expr))\n     save_gnu_tree (gnat_expr, gnu_expr, true);\n \n@@ -5869,7 +5869,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a\n-     variable that indicates our size, if still variable. */\n+     variable that indicates our size, if still variable.  */\n   if (TYPE_NAME (record)\n       && AGGREGATE_TYPE_P (type)\n       && TREE_CODE (orig_size) != INTEGER_CST\n@@ -6012,7 +6012,9 @@ choices_to_gnu (tree operand, Node_Id choices)\n \t\t\t\t\t\t    operand, high));\n \t      break;\n \t    }\n+\n \t  /* ... fall through ... */\n+\n \tcase N_Character_Literal:\n \tcase N_Integer_Literal:\n \t  single = gnat_to_gnu (choice);\n@@ -6445,7 +6447,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t      }\n \t  }\n \n-\t  save_gnu_tree (gnat_field, gnu_field, false);\n+\tsave_gnu_tree (gnat_field, gnu_field, false);\n       }\n \n   /* At the end of the component list there may be a variant part.  */\n@@ -6654,7 +6656,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n   else if (gnu_our_rep_list)\n     {\n       /* Otherwise, sort the fields by bit position and put them into their\n-\t own record if we have any fields without rep clauses. */\n+\t own record if we have any fields without rep clauses.  */\n       tree gnu_rep_type\n \t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n       int len = list_length (gnu_our_rep_list);\n@@ -7009,7 +7011,7 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n     return NULL_TREE;\n \n   /* Get the size as a tree.  Give an error if a size was specified, but cannot\n-     be represented as in sizetype. */\n+     be represented as in sizetype.  */\n   size = UI_To_gnu (uint_size, bitsizetype);\n   if (TREE_OVERFLOW (size))\n     {\n@@ -7391,7 +7393,7 @@ check_ok_for_atomic (tree object, Entity_Id gnat_entity, bool comp_p)\n \f\n /* Check if FTYPE1 and FTYPE2, two potentially different function type nodes,\n    have compatible signatures so that a call using one type may be safely\n-   issued if the actual target function type is the other. Return 1 if it is\n+   issued if the actual target function type is the other.  Return 1 if it is\n    the case, 0 otherwise, and post errors on the incompatibilities.\n \n    This is used when an Ada subprogram is mapped onto a GCC builtin, to ensure\n@@ -7688,9 +7690,9 @@ create_concat_name (Entity_Id gnat_entity, const char *suffix)\n   Get_External_Name_With_Suffix (gnat_entity, fp);\n \n   /* A variable using the Stdcall convention (meaning we are running\n-     on a Windows box) live in a DLL. Here we adjust its name to use\n+     on a Windows box) live in a DLL.  Here we adjust its name to use\n      the jump-table, the _imp__NAME contains the address for the NAME\n-     variable. */\n+     variable.  */\n   if ((kind == E_Variable || kind == E_Constant)\n       && Has_Stdcall_Convention (gnat_entity))\n     {"}]}