{"sha": "dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQzZDJiMzU2N2Y3YjhkN2EyMmVlOWMxMjRlNDEzZGEzN2JiNWQyYg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-25T17:43:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-25T17:43:41Z"}, "message": "config/ia64/ia64.c: Use rtx_insn\n\ngcc/\n\t* config/ia64/ia64.c (ia64_expand_tls_address): Strengthen local\n\t\"insns\" from rtx to rtx_insn *.\n\t(ia64_emit_cond_move): Likewise for locals \"insn\", \"first\".\n\t(struct spill_fill_data): Likewise for field \"init_after\" and for\n\telements of array field \"prev_insn\".\n\t(spill_restore_mem): Likewise for locals \"insn\", \"first\".\n\t(do_spill): Likewise for local \"insn\".\n\t(do_restore): Likewise.\n\t(ia64_expand_prologue): Likewise.\n\t(ia64_expand_epilogue): Likewise.\n\t(emit_insn_group_barriers): Likewise for locals \"insn\",\n\t\"last_label\".\n\t(emit_all_insn_group_barriers): Likewise for locals \"insn\",\n\t\"last\".\n\t(dfa_stop_insn): Likewise for this global.\n\t(dfa_pre_cycle_insn): Likewise.\n\t(ia64_nop): Likewise.\n\t(final_emit_insn_group_barriers): Likewise for locals \"insn\",\n\t\"last\".\n\t(emit_predicate_relation_info): Likewise for locals \"head\", \"n\",\n\t\"insn\", \"b\", \"a\".\n\t(ia64_reorg): Likewise for local \"insn\".\n\t(ia64_output_mi_thunk): Likewise.\n\t(expand_vec_perm_interleave_2): Likewise for local \"seq\".\n\nFrom-SVN: r214445", "tree": {"sha": "1d8b4a8ad0077b117ff355875173e99c8e1113cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d8b4a8ad0077b117ff355875173e99c8e1113cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "612b40cfab82f66de5a27a36ad208b2eed20234a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612b40cfab82f66de5a27a36ad208b2eed20234a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/612b40cfab82f66de5a27a36ad208b2eed20234a"}], "stats": {"total": 90, "additions": 62, "deletions": 28}, "files": [{"sha": "5b3367ce90ee961641eb7b60d51799360d956b8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "patch": "@@ -1,3 +1,30 @@\n+2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_expand_tls_address): Strengthen local\n+\t\"insns\" from rtx to rtx_insn *.\n+\t(ia64_emit_cond_move): Likewise for locals \"insn\", \"first\".\n+\t(struct spill_fill_data): Likewise for field \"init_after\" and for\n+\telements of array field \"prev_insn\".\n+\t(spill_restore_mem): Likewise for locals \"insn\", \"first\".\n+\t(do_spill): Likewise for local \"insn\".\n+\t(do_restore): Likewise.\n+\t(ia64_expand_prologue): Likewise.\n+\t(ia64_expand_epilogue): Likewise.\n+\t(emit_insn_group_barriers): Likewise for locals \"insn\",\n+\t\"last_label\".\n+\t(emit_all_insn_group_barriers): Likewise for locals \"insn\",\n+\t\"last\".\n+\t(dfa_stop_insn): Likewise for this global.\n+\t(dfa_pre_cycle_insn): Likewise.\n+\t(ia64_nop): Likewise.\n+\t(final_emit_insn_group_barriers): Likewise for locals \"insn\",\n+\t\"last\".\n+\t(emit_predicate_relation_info): Likewise for locals \"head\", \"n\",\n+\t\"insn\", \"b\", \"a\".\n+\t(ia64_reorg): Likewise for local \"insn\".\n+\t(ia64_output_mi_thunk): Likewise.\n+\t(expand_vec_perm_interleave_2): Likewise for local \"seq\".\n+\n 2014-08-25  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/i386/i386-protos.h (ix86_avoid_lea_for_add): Strengthen"}, {"sha": "c187941976dcae4eadda21b36560b64dda38fcfa", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=dd3d2b3567f7b8d7a22ee9c124e413da37bb5d2b", "patch": "@@ -1159,7 +1159,8 @@ static rtx\n ia64_expand_tls_address (enum tls_model tls_kind, rtx op0, rtx op1,\n \t\t\t rtx orig_op1, HOST_WIDE_INT addend)\n {\n-  rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n+  rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp;\n+  rtx_insn *insns;\n   rtx orig_op0 = op0;\n   HOST_WIDE_INT addend_lo, addend_hi;\n \n@@ -1340,7 +1341,7 @@ ia64_expand_move (rtx op0, rtx op1)\n void\n ia64_emit_cond_move (rtx op0, rtx op1, rtx cond)\n {\n-  rtx insn, first = get_last_insn ();\n+  rtx_insn *insn, *first = get_last_insn ();\n \n   emit_move_insn (op0, op1);\n \n@@ -2995,11 +2996,11 @@ ia64_initial_elimination_offset (int from, int to)\n \n struct spill_fill_data\n {\n-  rtx init_after;\t\t/* point at which to emit initializations */\n+  rtx_insn *init_after;\t\t/* point at which to emit initializations */\n   rtx init_reg[2];\t\t/* initial base register */\n   rtx iter_reg[2];\t\t/* the iterator registers */\n   rtx *prev_addr[2];\t\t/* address of last memory use */\n-  rtx prev_insn[2];\t\t/* the insn corresponding to prev_addr */\n+  rtx_insn *prev_insn[2];\t/* the insn corresponding to prev_addr */\n   HOST_WIDE_INT prev_off[2];\t/* last offset */\n   int n_iter;\t\t\t/* number of iterators in use */\n   int next_iter;\t\t/* next iterator to use */\n@@ -3087,7 +3088,8 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n     }\n   else\n     {\n-      rtx seq, insn;\n+      rtx seq;\n+      rtx_insn *insn;\n \n       if (disp == 0)\n \tseq = gen_movdi (spill_fill_data.iter_reg[iter],\n@@ -3116,7 +3118,7 @@ spill_restore_mem (rtx reg, HOST_WIDE_INT cfa_off)\n \tinsn = emit_insn_after (seq, spill_fill_data.init_after);\n       else\n \t{\n-\t  rtx first = get_insns ();\n+\t  rtx_insn *first = get_insns ();\n \t  if (first)\n \t    insn = emit_insn_before (seq, first);\n \t  else\n@@ -3147,7 +3149,8 @@ do_spill (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off,\n \t  rtx frame_reg)\n {\n   int iter = spill_fill_data.next_iter;\n-  rtx mem, insn;\n+  rtx mem;\n+  rtx_insn *insn;\n \n   mem = spill_restore_mem (reg, cfa_off);\n   insn = emit_insn ((*move_fn) (mem, reg, GEN_INT (cfa_off)));\n@@ -3188,7 +3191,7 @@ static void\n do_restore (rtx (*move_fn) (rtx, rtx, rtx), rtx reg, HOST_WIDE_INT cfa_off)\n {\n   int iter = spill_fill_data.next_iter;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   insn = emit_insn ((*move_fn) (reg, spill_restore_mem (reg, cfa_off),\n \t\t\t\tGEN_INT (cfa_off)));\n@@ -3443,7 +3446,8 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n void\n ia64_expand_prologue (void)\n {\n-  rtx insn, ar_pfs_save_reg, ar_unat_save_reg;\n+  rtx_insn *insn;\n+  rtx ar_pfs_save_reg, ar_unat_save_reg;\n   int i, epilogue_p, regno, alt_regno, cfa_off, n_varargs;\n   rtx reg, alt_reg;\n \n@@ -3854,7 +3858,8 @@ ia64_start_function (FILE *file, const char *fnname,\n void\n ia64_expand_epilogue (int sibcall_p)\n {\n-  rtx insn, reg, alt_reg, ar_unat_save_reg;\n+  rtx_insn *insn;\n+  rtx reg, alt_reg, ar_unat_save_reg;\n   int regno, alt_regno, cfa_off;\n \n   ia64_compute_frame_size (get_frame_size ());\n@@ -6949,8 +6954,8 @@ safe_group_barrier_needed (rtx insn)\n static void\n emit_insn_group_barriers (FILE *dump)\n {\n-  rtx insn;\n-  rtx last_label = 0;\n+  rtx_insn *insn;\n+  rtx_insn *last_label = 0;\n   int insns_since_last_label = 0;\n \n   init_insn_group_barriers ();\n@@ -7005,15 +7010,15 @@ emit_insn_group_barriers (FILE *dump)\n static void\n emit_all_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n \n   init_insn_group_barriers ();\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       if (BARRIER_P (insn))\n \t{\n-\t  rtx last = prev_active_insn (insn);\n+\t  rtx_insn *last = prev_active_insn (insn);\n \n \t  if (! last)\n \t    continue;\n@@ -7078,7 +7083,7 @@ static int pos_1, pos_2, pos_3, pos_4, pos_5, pos_6;\n \n /* The following variable value is an insn group barrier.  */\n \n-static rtx dfa_stop_insn;\n+static rtx_insn *dfa_stop_insn;\n \n /* The following variable value is the last issued insn.  */\n \n@@ -7556,7 +7561,7 @@ ia64_first_cycle_multipass_dfa_lookahead_guard (rtx insn, int ready_index)\n    scheduler to change the DFA state when the simulated clock is\n    increased.  */\n \n-static rtx dfa_pre_cycle_insn;\n+static rtx_insn *dfa_pre_cycle_insn;\n \n /* Returns 1 when a meaningful insn was scheduled between the last group\n    barrier and LAST.  */\n@@ -8650,7 +8655,7 @@ finish_bundle_state_table (void)\n /* The following variable is a insn `nop' used to check bundle states\n    with different number of inserted nops.  */\n \n-static rtx ia64_nop;\n+static rtx_insn *ia64_nop;\n \n /* The following function tries to issue NOPS_NUM nops for the current\n    state without advancing processor cycle.  If it failed, the\n@@ -9379,7 +9384,7 @@ ia64_sched_finish (FILE *dump, int sched_verbose)\n static void\n final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   int need_barrier_p = 0;\n   int seen_good_insn = 0;\n \n@@ -9391,7 +9396,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n     {\n       if (BARRIER_P (insn))\n \t{\n-\t  rtx last = prev_active_insn (insn);\n+\t  rtx_insn *last = prev_active_insn (insn);\n \n \t  if (! last)\n \t    continue;\n@@ -9419,7 +9424,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t    {\n \t      if (TARGET_EARLY_STOP_BITS)\n \t\t{\n-\t\t  rtx last;\n+\t\t  rtx_insn *last;\n \n \t\t  for (last = insn;\n \t\t       last != current_sched_info->prev_head;\n@@ -9602,7 +9607,7 @@ emit_predicate_relation_info (void)\n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n       int r;\n-      rtx head = BB_HEAD (bb);\n+      rtx_insn *head = BB_HEAD (bb);\n \n       /* We only need such notes at code labels.  */\n       if (! LABEL_P (head))\n@@ -9616,7 +9621,7 @@ emit_predicate_relation_info (void)\n \tif (REGNO_REG_SET_P (df_get_live_in (bb), r))\n \t  {\n \t    rtx p = gen_rtx_REG (BImode, r);\n-\t    rtx n = emit_insn_after (gen_pred_rel_mutex (p), head);\n+\t    rtx_insn *n = emit_insn_after (gen_pred_rel_mutex (p), head);\n \t    if (head == BB_END (bb))\n \t      SET_BB_END (bb) = n;\n \t    head = n;\n@@ -9629,16 +9634,17 @@ emit_predicate_relation_info (void)\n      the call.  */\n   FOR_EACH_BB_REVERSE_FN (bb, cfun)\n     {\n-      rtx insn = BB_HEAD (bb);\n+      rtx_insn *insn = BB_HEAD (bb);\n \n       while (1)\n \t{\n \t  if (CALL_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == COND_EXEC\n \t      && find_reg_note (insn, REG_NORETURN, NULL_RTX))\n \t    {\n-\t      rtx b = emit_insn_before (gen_safe_across_calls_all (), insn);\n-\t      rtx a = emit_insn_after (gen_safe_across_calls_normal (), insn);\n+\t      rtx_insn *b =\n+\t\temit_insn_before (gen_safe_across_calls_all (), insn);\n+\t      rtx_insn *a = emit_insn_after (gen_safe_across_calls_normal (), insn);\n \t      if (BB_HEAD (bb) == insn)\n \t\tSET_BB_HEAD (bb) = b;\n \t      if (BB_END (bb) == insn)\n@@ -9772,7 +9778,7 @@ ia64_reorg (void)\n      properly.  Note that IA-64 differs from dwarf2 on this point.  */\n   if (ia64_except_unwind_info (&global_options) == UI_TARGET)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       int saw_stop = 0;\n \n       insn = get_last_insn ();\n@@ -10742,7 +10748,8 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t\t      HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n \t\t      tree function)\n {\n-  rtx this_rtx, insn, funexp;\n+  rtx this_rtx, funexp;\n+  rtx_insn *insn;\n   unsigned int this_parmno;\n   unsigned int this_regno;\n   rtx delta_rtx;\n@@ -11401,7 +11408,7 @@ expand_vec_perm_interleave_2 (struct expand_vec_perm_d *d)\n   unsigned char remap[2 * MAX_VECT_LEN];\n   unsigned contents, i, nelt, nelt2;\n   unsigned h0, h1, h2, h3;\n-  rtx seq;\n+  rtx_insn *seq;\n   bool ok;\n \n   if (d->one_operand_p)"}]}