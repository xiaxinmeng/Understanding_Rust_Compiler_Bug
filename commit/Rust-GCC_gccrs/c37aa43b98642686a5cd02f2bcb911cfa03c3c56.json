{"sha": "c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM3YWE0M2I5ODY0MjY4NmE1Y2QwMmYyYmNiOTExY2ZhMDNjM2M1Ng==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2015-05-11T07:21:19Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-05-11T07:21:19Z"}, "message": "* config/alpha/alpha.c (alpha_emit_set_const_1)\n\t(alpha_emit_set_long_const, alpha_extract_integer)\n\t(alpha_legitimate_constant_p, alpha_split_const_mov)\n\t(alpha_expand_block_clear, alpha_expand_zap_mask, print_operand):\n\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n\t(alpha_emit_set_const_1): Change \"(HOST_WIDE_INT) 1\" to\n\tHOST_WIDE_INT_1U.\n\t* config/alpha/predicates.md (mode_mask_operand): Do not match\n\tconst_double RTX.\n\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n\t* config/alpha/alpha.md (abstf, *abstf_internal, UNSPEC_ZAP splitter):\n\tChange \"(HOST_WIDE_INT) 1\" to HOST_WIDE_INT_1U.\n\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n\t(*negtf_internal): Use gen_int_mode instead of immed_double_const.\n\nFrom-SVN: r222994", "tree": {"sha": "922b5b98a57e6efedc45fec1bdbed85a0fff6d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/922b5b98a57e6efedc45fec1bdbed85a0fff6d20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbddf64c0243816b45e6680754a251c603245dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbddf64c0243816b45e6680754a251c603245dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbddf64c0243816b45e6680754a251c603245dbc"}], "stats": {"total": 199, "additions": 58, "deletions": 141}, "files": [{"sha": "c2138c6abefbffdbe012f4edb59eec2991fca76d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "patch": "@@ -1,3 +1,20 @@\n+2015-05-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/alpha/alpha.c (alpha_emit_set_const_1)\n+\t(alpha_emit_set_long_const, alpha_extract_integer)\n+\t(alpha_legitimate_constant_p, alpha_split_const_mov)\n+\t(alpha_expand_block_clear, alpha_expand_zap_mask, print_operand):\n+\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n+\t(alpha_emit_set_const_1): Change \"(HOST_WIDE_INT) 1\" to\n+\tHOST_WIDE_INT_1U.\n+\t* config/alpha/predicates.md (mode_mask_operand): Do not match\n+\tconst_double RTX.\n+\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n+\t* config/alpha/alpha.md (abstf, *abstf_internal, UNSPEC_ZAP splitter):\n+\tChange \"(HOST_WIDE_INT) 1\" to HOST_WIDE_INT_1U.\n+\t[HOST_BITS_PER_WIDE_INT < 64]: Remove dead code.\n+\t(*negtf_internal): Use gen_int_mode instead of immed_double_const.\n+\n 2015-05-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/65780"}, {"sha": "17024990b84b1c9f7891167526dca1318afcd7af", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 17, "deletions": 87, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "patch": "@@ -1771,11 +1771,9 @@ alpha_emit_set_const_1 (rtx target, machine_mode mode,\n   rtx temp, insn;\n \n   /* If this is a sign-extended 32-bit constant, we can do this in at most\n-     three insns, so do it if we have enough insns left.  We always have\n-     a sign-extended 32-bit constant when compiling on a narrow machine.  */\n+     three insns, so do it if we have enough insns left.  */\n \n-  if (HOST_BITS_PER_WIDE_INT != 64\n-      || c >> 31 == -1 || c >> 31 == 0)\n+  if (c >> 31 == -1 || c >> 31 == 0)\n     {\n       HOST_WIDE_INT low = ((c & 0xffff) ^ 0x8000) - 0x8000;\n       HOST_WIDE_INT tmp1 = c - low;\n@@ -1917,19 +1915,17 @@ alpha_emit_set_const_1 (rtx target, machine_mode mode,\n       /* Now try high-order zero bits.  Here we try the shifted-in bits as\n \t all zero and all ones.  Be careful to avoid shifting outside the\n \t mode and to avoid shifting outside the host wide int size.  */\n-      /* On narrow hosts, don't shift a 1 into the high bit, since we'll\n-\t confuse the recursive call and set all of the high 32 bits.  */\n \n       bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n-\t      - floor_log2 (c) - 1 - (HOST_BITS_PER_WIDE_INT < 64));\n+\t      - floor_log2 (c) - 1);\n       if (bits > 0)\n \tfor (; bits > 0; bits--)\n \t  {\n \t    new_const = c << bits;\n \t    temp = alpha_emit_set_const (subtarget, mode, new_const, i, no_output);\n \t    if (!temp)\n \t      {\n-\t\tnew_const = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t\tnew_const = (c << bits) | ((HOST_WIDE_INT_1U << bits) - 1);\n \t        temp = alpha_emit_set_const (subtarget, mode, new_const,\n \t\t\t\t\t     i, no_output);\n \t      }\n@@ -1955,7 +1951,7 @@ alpha_emit_set_const_1 (rtx target, machine_mode mode,\n \t    temp = alpha_emit_set_const (subtarget, mode, new_const, i, no_output);\n \t    if (!temp)\n \t      {\n-\t\tnew_const = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t\tnew_const = (c << bits) | ((HOST_WIDE_INT_1U << bits) - 1);\n \t        temp = alpha_emit_set_const (subtarget, mode, new_const,\n \t\t\t\t\t     i, no_output);\n \t      }\n@@ -1969,7 +1965,6 @@ alpha_emit_set_const_1 (rtx target, machine_mode mode,\n \t  }\n     }\n \n-#if HOST_BITS_PER_WIDE_INT == 64\n   /* Finally, see if can load a value into the target that is the same as the\n      constant except that all bytes that are 0 are changed to be 0xff.  If we\n      can, then we can do a ZAPNOT to obtain the desired constant.  */\n@@ -1996,7 +1991,6 @@ alpha_emit_set_const_1 (rtx target, machine_mode mode,\n \t\t\t       target, 0, OPTAB_WIDEN);\n \t}\n     }\n-#endif\n \n   return 0;\n }\n@@ -2077,7 +2071,7 @@ alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n   HOST_WIDE_INT d1, d2, d3, d4;\n \n   /* Decompose the entire word */\n-#if HOST_BITS_PER_WIDE_INT >= 64\n+\n   gcc_assert (c2 == -(c1 < 0));\n   d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n   c1 -= d1;\n@@ -2087,17 +2081,6 @@ alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n   c1 -= d3;\n   d4 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n   gcc_assert (c1 == d4);\n-#else\n-  d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n-  c1 -= d1;\n-  d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-  gcc_assert (c1 == d2);\n-  c2 += (d2 < 0);\n-  d3 = ((c2 & 0xffff) ^ 0x8000) - 0x8000;\n-  c2 -= d3;\n-  d4 = ((c2 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-  gcc_assert (c2 == d4);\n-#endif\n \n   /* Construct the high word */\n   if (d4)\n@@ -2138,15 +2121,10 @@ alpha_extract_integer (rtx x, HOST_WIDE_INT *p0, HOST_WIDE_INT *p1)\n       i0 = INTVAL (x);\n       i1 = -(i0 < 0);\n     }\n-  else if (HOST_BITS_PER_WIDE_INT >= 64)\n-    {\n-      i0 = CONST_DOUBLE_LOW (x);\n-      i1 = -(i0 < 0);\n-    }\n   else\n     {\n       i0 = CONST_DOUBLE_LOW (x);\n-      i1 = CONST_DOUBLE_HIGH (x);\n+      i1 = -(i0 < 0);\n     }\n \n   *p0 = i0;\n@@ -2206,9 +2184,7 @@ alpha_legitimate_constant_p (machine_mode mode, rtx x)\n       if (TARGET_BUILD_CONSTANTS)\n \treturn true;\n       alpha_extract_integer (x, &i0, &i1);\n-      if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == (-i0 < 0))\n-        return alpha_emit_set_const_1 (x, mode, i0, 3, true) != NULL;\n-      return false;\n+      return alpha_emit_set_const_1 (x, mode, i0, 3, true) != NULL;\n \n     default:\n       return false;\n@@ -2226,8 +2202,7 @@ alpha_split_const_mov (machine_mode mode, rtx *operands)\n \n   alpha_extract_integer (operands[1], &i0, &i1);\n \n-  if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == -(i0 < 0))\n-    temp = alpha_emit_set_const (operands[0], mode, i0, 3, false);\n+  temp = alpha_emit_set_const (operands[0], mode, i0, 3, false);\n \n   if (!temp && TARGET_BUILD_CONSTANTS)\n     temp = alpha_emit_set_long_const (operands[0], i0, i1);\n@@ -4099,7 +4074,6 @@ alpha_expand_block_clear (rtx operands[])\n \n   if (alignofs > 0)\n     {\n-#if HOST_BITS_PER_WIDE_INT >= 64\n       /* Given that alignofs is bounded by align, the only time BWX could\n \t generate three stores is for a 7 byte fill.  Prefer two individual\n \t stores over a load/mask/store sequence.  */\n@@ -4134,7 +4108,6 @@ alpha_expand_block_clear (rtx operands[])\n \n \t  emit_move_insn (mem, tmp);\n \t}\n-#endif\n \n       if (TARGET_BWX && (alignofs & 1) && bytes >= 1)\n \t{\n@@ -4246,7 +4219,6 @@ alpha_expand_block_clear (rtx operands[])\n \n   /* Next clean up any trailing pieces.  */\n \n-#if HOST_BITS_PER_WIDE_INT >= 64\n   /* Count the number of bits in BYTES for which aligned stores could\n      be emitted.  */\n   words = 0;\n@@ -4291,7 +4263,6 @@ alpha_expand_block_clear (rtx operands[])\n \t  return 1;\n \t}\n     }\n-#endif\n \n   if (!TARGET_BWX && bytes >= 4)\n     {\n@@ -4336,43 +4307,16 @@ alpha_expand_zap_mask (HOST_WIDE_INT value)\n {\n   rtx result;\n   int i;\n+  HOST_WIDE_INT mask = 0;\n \n-  if (HOST_BITS_PER_WIDE_INT >= 64)\n+  for (i = 7; i >= 0; --i)\n     {\n-      HOST_WIDE_INT mask = 0;\n-\n-      for (i = 7; i >= 0; --i)\n-\t{\n-\t  mask <<= 8;\n-\t  if (!((value >> i) & 1))\n-\t    mask |= 0xff;\n-\t}\n-\n-      result = gen_int_mode (mask, DImode);\n-    }\n-  else\n-    {\n-      HOST_WIDE_INT mask_lo = 0, mask_hi = 0;\n-\n-      gcc_assert (HOST_BITS_PER_WIDE_INT == 32);\n-      \n-      for (i = 7; i >= 4; --i)\n-\t{\n-\t  mask_hi <<= 8;\n-\t  if (!((value >> i) & 1))\n-\t    mask_hi |= 0xff;\n-\t}\n-\n-      for (i = 3; i >= 0; --i)\n-\t{\n-\t  mask_lo <<= 8;\n-\t  if (!((value >> i) & 1))\n-\t    mask_lo |= 0xff;\n-\t}\n-\n-      result = immed_double_const (mask_lo, mask_hi, DImode);\n+      mask <<= 8;\n+      if (!((value >> i) & 1))\n+\tmask |= 0xff;\n     }\n \n+  result = gen_int_mode (mask, DImode);\n   return result;\n }\n \n@@ -5288,7 +5232,7 @@ print_operand (FILE *file, rtx x, int code)\n       if (!CONST_INT_P (x))\n \toutput_operand_lossage (\"invalid %%P value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) 1 << INTVAL (x));\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, HOST_WIDE_INT_1 << INTVAL (x));\n       break;\n \n     case 'h':\n@@ -5385,14 +5329,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      break;\n \t    }\n \t}\n-      else if (HOST_BITS_PER_WIDE_INT == 32\n-\t       && GET_CODE (x) == CONST_DOUBLE\n-\t       && CONST_DOUBLE_LOW (x) == 0xffffffff\n-\t       && CONST_DOUBLE_HIGH (x) == 0)\n-\t{\n-\t  fputc ('l', file);\n-\t  break;\n-\t}\n+\n       output_operand_lossage (\"invalid %%U value\");\n       break;\n \n@@ -6788,13 +6725,6 @@ alpha_expand_builtin (tree exp, rtx target,\n     return const0_rtx;\n }\n \n-\n-/* Several bits below assume HWI >= 64 bits.  This should be enforced\n-   by config.gcc.  */\n-#if HOST_BITS_PER_WIDE_INT < 64\n-# error \"HOST_WIDE_INT too small\"\n-#endif\n-\n /* Fold the builtin for the CMPBGE instruction.  This is a vector comparison\n    with an 8-bit output vector.  OPINT contains the integer operands; bit N\n    of OP_CONST is set if OPINT[N] is valid.  */"}, {"sha": "eb59f6ca427513621b3d0416b721d63ea51cc790", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "patch": "@@ -951,7 +951,7 @@\n   [(set (match_operand:DI 0 \"register_operand\")\n \t(and:DI (match_operand:DI 1 \"register_operand\")\n \t\t(match_operand:DI 2 \"const_int_operand\")))]\n-  \"HOST_BITS_PER_WIDE_INT == 64 && ! and_operand (operands[2], DImode)\"\n+  \"! and_operand (operands[2], DImode)\"\n   [(set (match_dup 0) (and:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (and:DI (match_dup 0) (match_dup 4)))]\n {\n@@ -1508,17 +1508,14 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   \t   (match_operand:DI 2 \"mul8_operand\" \"I\"))\n-\t\t(match_operand:DI 3 \"immediate_operand\" \"i\")))]\n-  \"HOST_BITS_PER_WIDE_INT == 64\n-   && CONST_INT_P (operands[3])\n-   && (((unsigned HOST_WIDE_INT) 0xff << INTVAL (operands[2])\n+\t\t(match_operand:DI 3 \"const_int_operand\" \"i\")))]\n+  \"((unsigned HOST_WIDE_INT) 0xff << INTVAL (operands[2])\n+    == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n+    || ((unsigned HOST_WIDE_INT) 0xffff << INTVAL (operands[2])\n         == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n-       || ((unsigned HOST_WIDE_INT) 0xffff << INTVAL (operands[2])\n-        == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n-       || ((unsigned HOST_WIDE_INT) 0xffffffff << INTVAL (operands[2])\n-        == (unsigned HOST_WIDE_INT) INTVAL (operands[3])))\"\n+    || ((unsigned HOST_WIDE_INT) 0xffffffff << INTVAL (operands[2])\n+        == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\"\n {\n-#if HOST_BITS_PER_WIDE_INT == 64\n   if ((unsigned HOST_WIDE_INT) 0xff << INTVAL (operands[2])\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n     return \"insbl %1,%s2,%0\";\n@@ -1528,7 +1525,7 @@\n   if ((unsigned HOST_WIDE_INT) 0xffffffff << INTVAL (operands[2])\n       == (unsigned HOST_WIDE_INT) INTVAL (operands[3]))\n     return \"insll %1,%s2,%0\";\n-#endif\n+\n   gcc_unreachable ();\n }\n   [(set_attr \"type\" \"shift\")])\n@@ -1619,13 +1616,7 @@\n \t\t   (abs:TF (match_operand:TF 1 \"reg_or_0_operand\")))\n \t      (use (match_dup 2))])]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-{\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  operands[2] = force_reg (DImode, GEN_INT ((HOST_WIDE_INT) 1 << 63));\n-#else\n-  operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n-#endif\n-})\n+  \"operands[2] = force_reg (DImode, GEN_INT (HOST_WIDE_INT_1U << 63));\")\n \n (define_insn_and_split \"*abstf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n@@ -1649,13 +1640,7 @@\n \t\t   (neg:TF (match_operand:TF 1 \"reg_or_0_operand\")))\n \t      (use (match_dup 2))])]\n   \"TARGET_HAS_XFLOATING_LIBS\"\n-{\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-  operands[2] = force_reg (DImode, GEN_INT ((HOST_WIDE_INT) 1 << 63));\n-#else\n-  operands[2] = force_reg (DImode, immed_double_const (0, 0x80000000, DImode));\n-#endif\n-})\n+  \"operands[2] = force_reg (DImode, GEN_INT (HOST_WIDE_INT_1U << 63));\")\n \n (define_insn_and_split \"*negtf_internal\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n@@ -5440,7 +5425,7 @@\n    (match_operand:DI 2 \"reg_or_8bit_operand\")]\n   \"\"\n {\n-  rtx mask = immed_double_const (0xffffffff, 0, DImode);\n+  rtx mask = gen_int_mode (0xffffffff, DImode);\n   emit_insn (gen_mskxl (operands[0], operands[1], mask, operands[2]));\n   DONE;\n })\n@@ -5542,16 +5527,8 @@\n   [(const_int 0)]\n {\n   rtx mask = alpha_expand_zap_mask (INTVAL (operands[2]));\n-  if (HOST_BITS_PER_WIDE_INT >= 64 || CONST_INT_P (mask))\n-    operands[1] = gen_int_mode (INTVAL (operands[1]) & INTVAL (mask), DImode);\n-  else\n-    {\n-      HOST_WIDE_INT c_lo = INTVAL (operands[1]);\n-      HOST_WIDE_INT c_hi = (c_lo < 0 ? -1 : 0);\n-      operands[1] = immed_double_const (c_lo & CONST_DOUBLE_LOW (mask),\n-\t\t\t\t\tc_hi & CONST_DOUBLE_HIGH (mask),\n-\t\t\t\t\tDImode);\n-    }\n+\n+  operands[1] = gen_int_mode (INTVAL (operands[1]) & INTVAL (mask), DImode);\n   emit_move_insn (operands[0], operands[1]);\n   DONE;\n })"}, {"sha": "241a4ceec690a97f40ea83dc4d6caa9a2387ea80", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c37aa43b98642686a5cd02f2bcb911cfa03c3c56/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=c37aa43b98642686a5cd02f2bcb911cfa03c3c56", "patch": "@@ -110,26 +110,19 @@\n ;; Return 1 if OP is a constant that is a mask of ones of width of an\n ;; integral machine mode not larger than DImode.\n (define_predicate \"mode_mask_operand\"\n-  (match_code \"const_int,const_double\")\n+  (match_code \"const_int\")\n {\n-  if (CONST_INT_P (op))\n-    {\n-      HOST_WIDE_INT value = INTVAL (op);\n+  HOST_WIDE_INT value = INTVAL (op);\n+\n+  if (value == 0xff)\n+    return 1;\n+  if (value == 0xffff)\n+    return 1;\n+  if (value == 0xffffffff)\n+    return 1;\n+  if (value == -1)\n+    return 1;\n \n-      if (value == 0xff)\n-\treturn 1;\n-      if (value == 0xffff)\n-\treturn 1;\n-      if (value == 0xffffffff)\n-\treturn 1;\n-      if (value == -1)\n-\treturn 1;\n-    }\n-  else if (HOST_BITS_PER_WIDE_INT == 32 && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      if (CONST_DOUBLE_LOW (op) == 0xffffffff && CONST_DOUBLE_HIGH (op) == 0)\n-\treturn 1;\n-    }\n   return 0;\n })\n "}]}