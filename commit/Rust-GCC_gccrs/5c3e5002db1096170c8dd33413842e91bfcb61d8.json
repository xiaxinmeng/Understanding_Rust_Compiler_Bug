{"sha": "5c3e5002db1096170c8dd33413842e91bfcb61d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzZTUwMDJkYjEwOTYxNzBjOGRkMzM0MTM4NDJlOTFiZmNiNjFkOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2016-08-05T23:29:53Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@gcc.gnu.org", "date": "2016-08-05T23:29:53Z"}, "message": "Improve forward jump threading of switch statements (PR18046)\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/18046\n\t* tree-ssa-threadedge.c: Include cfganal.h.\n\t(simplify_control_statement_condition): If simplifying a\n\tGIMPLE_SWITCH, replace the index operand of the GIMPLE_SWITCH\n\twith the dominating ASSERT_EXPR before handing it off to VRP.\n\tMention that a CASE_LABEL_EXPR may be returned.\n\t(thread_around_empty_blocks): Adjust to handle\n\tsimplify_control_statement_condition() returning a\n\tCASE_LABEL_EXPR.\n\t(thread_through_normal_block): Likewise.\n\t* tree-vrp.c (simplify_stmt_for_jump_threading): Simplify\n\ta switch statement by trying to determine which case label\n\twill be taken.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/18046\n\t* gcc.dg/tree-ssa/vrp105.c: New test.\n\t* gcc.dg/tree-ssa/vrp106.c: New test.\n\nFrom-SVN: r239181", "tree": {"sha": "79bec8abe360b6fb22f3048f60ff643598e1a6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79bec8abe360b6fb22f3048f60ff643598e1a6b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c3e5002db1096170c8dd33413842e91bfcb61d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c3e5002db1096170c8dd33413842e91bfcb61d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c3e5002db1096170c8dd33413842e91bfcb61d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c3e5002db1096170c8dd33413842e91bfcb61d8/comments", "author": null, "committer": null, "parents": [{"sha": "b10d44efe5bb64662a55fe74696b8c2ca2d17303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b10d44efe5bb64662a55fe74696b8c2ca2d17303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b10d44efe5bb64662a55fe74696b8c2ca2d17303"}], "stats": {"total": 187, "additions": 181, "deletions": 6}, "files": [{"sha": "f6a62d1ffc12c8522a8c896f7ba74268c668a891", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -1,3 +1,19 @@\n+2016-08-05  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR tree-optimization/18046\n+\t* tree-ssa-threadedge.c: Include cfganal.h.\n+\t(simplify_control_statement_condition): If simplifying a\n+\tGIMPLE_SWITCH, replace the index operand of the GIMPLE_SWITCH\n+\twith the dominating ASSERT_EXPR before handing it off to VRP.\n+\tMention that a CASE_LABEL_EXPR may be returned.\n+\t(thread_around_empty_blocks): Adjust to handle\n+\tsimplify_control_statement_condition() returning a\n+\tCASE_LABEL_EXPR.\n+\t(thread_through_normal_block): Likewise.\n+\t* tree-vrp.c (simplify_stmt_for_jump_threading): Simplify\n+\ta switch statement by trying to determine which case label\n+\twill be taken.\n+\n 2016-08-05  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/69847"}, {"sha": "e9792962c62d80bcac629077173210c7d0815d77", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -1,3 +1,9 @@\n+2016-08-05  Patrick Palka  <ppalka@gcc.gnu.org>\n+\n+\tPR tree-optimization/18046\n+\t* gcc.dg/tree-ssa/vrp105.c: New test.\n+\t* gcc.dg/tree-ssa/vrp106.c: New test.\n+\n 2016-08-05 Martin Sebor  <msebor@redhat.com>\n \n \t* g++.dg/cpp0x/constexpr-cast.C: Avoid assuming (void*)1 is spelled"}, {"sha": "7cdd4dd8f3a5c47d70651386e57ac0016bcc6993", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp105.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp105.c?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/18046  */\n+/* { dg-options \"-O2 -fdump-tree-vrp2-details\" }  */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"vrp2\" } }  */\n+/* In the 2nd VRP pass (after PRE) we expect to thread the default label of the\n+   1st switch straight to that of the 2nd switch.  */\n+\n+extern void foo (void);\n+extern void bar (void);\n+\n+extern int i;\n+void\n+test (void)\n+{\n+  switch (i)\n+    {\n+    case 0:\n+      foo ();\n+      break;\n+    case 1:\n+      bar ();\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  switch (i)\n+    {\n+    case 0:\n+      foo ();\n+      break;\n+    case 1:\n+      bar ();\n+      break;\n+    default:\n+      break;\n+    }\n+}"}, {"sha": "e2e48d8deb9645bddcf6d5585ac9667101f3424b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp106.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp106.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp106.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp106.c?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -0,0 +1,27 @@\n+/* PR tree-optimization/18046  */\n+/* { dg-options \"-O2 -fdump-tree-vrp1-details\" }  */\n+/* { dg-final { scan-tree-dump-times \"Threaded jump\" 1 \"vrp1\" } }  */\n+/* During VRP we expect to thread the true arm of the conditional through the switch\n+   and to the BB that corresponds to the 7 ... 9 case label.  */\n+extern void foo (void);\n+extern void bar (void);\n+extern void baz (void);\n+\n+void\n+test (int i)\n+{\n+  if (i >= 7 && i <= 8)\n+    foo ();\n+\n+  switch (i)\n+  {\n+    case 1:\n+      bar ();\n+      break;\n+    case 7:\n+    case 8:\n+    case 9:\n+      baz ();\n+      break;\n+  }\n+}"}, {"sha": "170e4564b559a09a86eb32318d6f62bc86fd3ad7", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-dom.h\"\n #include \"gimple-fold.h\"\n+#include \"cfganal.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -390,7 +391,8 @@ static tree simplify_control_stmt_condition_1 (edge, gimple *,\n    a condition using pass specific information.\n \n    Return the simplified condition or NULL if simplification could\n-   not be performed.\n+   not be performed.  When simplifying a GIMPLE_SWITCH, we may return\n+   the CASE_LABEL_EXPR that will be taken.\n \n    The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n@@ -513,7 +515,21 @@ simplify_control_stmt_condition (edge e,\n       /* If we haven't simplified to an invariant yet, then use the\n \t pass specific callback to try and simplify it further.  */\n       if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n-        cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n+\t{\n+\t  if (handle_dominating_asserts && code == GIMPLE_SWITCH)\n+\t    {\n+\t      /* Replace the index operand of the GIMPLE_SWITCH with the\n+\t\t dominating ASSERT_EXPR before handing it off to VRP.  If\n+\t\t simplification is possible, the simplified value will be a\n+\t\t CASE_LABEL_EXPR of the label that is proven to be taken.  */\n+\t      gswitch *dummy_switch = as_a<gswitch *> (gimple_copy (stmt));\n+\t      gimple_switch_set_index (dummy_switch, cached_lhs);\n+\t      cached_lhs = (*simplify) (dummy_switch, stmt, avail_exprs_stack);\n+\t      ggc_free (dummy_switch);\n+\t    }\n+\t  else\n+\t    cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n+\t}\n \n       /* We couldn't find an invariant.  But, callers of this\n \t function may be able to do something useful with the\n@@ -938,9 +954,14 @@ thread_around_empty_blocks (edge taken_edge,\n   /* If the condition can be statically computed and we have not already\n      visited the destination edge, then add the taken edge to our thread\n      path.  */\n-  if (cond && is_gimple_min_invariant (cond))\n+  if (cond != NULL_TREE\n+      && (is_gimple_min_invariant (cond)\n+\t  || TREE_CODE (cond) == CASE_LABEL_EXPR))\n     {\n-      taken_edge = find_taken_edge (bb, cond);\n+      if (TREE_CODE (cond) == CASE_LABEL_EXPR)\n+\ttaken_edge = find_edge (bb, label_to_block (CASE_LABEL (cond)));\n+      else\n+\ttaken_edge = find_taken_edge (bb, cond);\n \n       if ((taken_edge->flags & EDGE_DFS_BACK) != 0)\n \treturn false;\n@@ -1069,9 +1090,16 @@ thread_through_normal_block (edge e,\n       if (!cond)\n \treturn 0;\n \n-      if (is_gimple_min_invariant (cond))\n+      if (is_gimple_min_invariant (cond)\n+\t  || TREE_CODE (cond) == CASE_LABEL_EXPR)\n \t{\n-\t  edge taken_edge = find_taken_edge (e->dest, cond);\n+\t  edge taken_edge;\n+\t  if (TREE_CODE (cond) == CASE_LABEL_EXPR)\n+\t    taken_edge = find_edge (e->dest,\n+\t\t\t\t    label_to_block (CASE_LABEL (cond)));\n+\t  else\n+\t    taken_edge = find_taken_edge (e->dest, cond);\n+\n \t  basic_block dest = (taken_edge ? taken_edge->dest : NULL);\n \n \t  /* DEST could be NULL for a computed jump to an absolute"}, {"sha": "44dfc84b268278d9e61efed59681c6cbe5266edf", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c3e5002db1096170c8dd33413842e91bfcb61d8/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5c3e5002db1096170c8dd33413842e91bfcb61d8", "patch": "@@ -10183,6 +10183,67 @@ simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,\n \t\t\t\t     gimple_cond_rhs (cond_stmt),\n \t\t\t\t     within_stmt);\n \n+  /* We simplify a switch statement by trying to determine which case label\n+     will be taken.  If we are successful then we return the corresponding\n+     CASE_LABEL_EXPR.  */\n+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n+    {\n+      tree op = gimple_switch_index (switch_stmt);\n+      if (TREE_CODE (op) != SSA_NAME)\n+\treturn NULL_TREE;\n+\n+      value_range *vr = get_value_range (op);\n+      if ((vr->type != VR_RANGE && vr->type != VR_ANTI_RANGE)\n+\t  || symbolic_range_p (vr))\n+\treturn NULL_TREE;\n+\n+      if (vr->type == VR_RANGE)\n+\t{\n+\t  size_t i, j;\n+\t  /* Get the range of labels that contain a part of the operand's\n+\t     value range.  */\n+\t  find_case_label_range (switch_stmt, vr->min, vr->max, &i, &j);\n+\n+\t  /* Is there only one such label?  */\n+\t  if (i == j)\n+\t    {\n+\t      tree label = gimple_switch_label (switch_stmt, i);\n+\n+\t      /* The i'th label will be taken only if the value range of the\n+\t\t operand is entirely within the bounds of this label.  */\n+\t      if (CASE_HIGH (label) != NULL_TREE\n+\t\t  ? (tree_int_cst_compare (CASE_LOW (label), vr->min) <= 0\n+\t\t     && tree_int_cst_compare (CASE_HIGH (label), vr->max) >= 0)\n+\t\t  : (tree_int_cst_equal (CASE_LOW (label), vr->min)\n+\t\t     && tree_int_cst_equal (vr->min, vr->max)))\n+\t\treturn label;\n+\t    }\n+\n+\t  /* If there are no such labels then the default label will be\n+\t     taken.  */\n+\t  if (i > j)\n+\t    return gimple_switch_label (switch_stmt, 0);\n+\t}\n+\n+      if (vr->type == VR_ANTI_RANGE)\n+\t{\n+\t  unsigned n = gimple_switch_num_labels (switch_stmt);\n+\t  tree min_label = gimple_switch_label (switch_stmt, 1);\n+\t  tree max_label = gimple_switch_label (switch_stmt, n - 1);\n+\n+\t  /* The default label will be taken only if the anti-range of the\n+\t     operand is entirely outside the bounds of all the (non-default)\n+\t     case labels.  */\n+\t  if (tree_int_cst_compare (vr->min, CASE_LOW (min_label)) <= 0\n+\t      && (CASE_HIGH (max_label) != NULL_TREE\n+\t\t  ? tree_int_cst_compare (vr->max, CASE_HIGH (max_label)) >= 0\n+\t\t  : tree_int_cst_compare (vr->max, CASE_LOW (max_label)) >= 0))\n+\t  return gimple_switch_label (switch_stmt, 0);\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n   if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n     {\n       value_range new_vr = VR_INITIALIZER;"}]}