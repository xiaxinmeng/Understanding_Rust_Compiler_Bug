{"sha": "3e348fccfa971cf81fe9fcf3489bf011979957e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzNDhmY2NmYTk3MWNmODFmZTlmY2YzNDg5YmYwMTE5Nzk5NTdlMw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-11-30T03:43:57Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-11-30T03:43:57Z"}, "message": "re PR libgomp/51249 (semaphore implemetation for linux leaves threads blocked)\n\n\tPR libgomp/51249\n\t* config/linux/sem.h: Rewrite.\n\t* config/linux/sem.c: Rewrite.\n\nFrom-SVN: r181831", "tree": {"sha": "28027834dab96be18e7642ddac8d7a2dc9223272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28027834dab96be18e7642ddac8d7a2dc9223272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e348fccfa971cf81fe9fcf3489bf011979957e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e348fccfa971cf81fe9fcf3489bf011979957e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e348fccfa971cf81fe9fcf3489bf011979957e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e348fccfa971cf81fe9fcf3489bf011979957e3/comments", "author": null, "committer": null, "parents": [{"sha": "b87974949f096925805aec63eac7c5a02f2bb483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87974949f096925805aec63eac7c5a02f2bb483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87974949f096925805aec63eac7c5a02f2bb483"}], "stats": {"total": 130, "additions": 94, "deletions": 36}, "files": [{"sha": "e9148f6375f6e7058d6931bfb1d76f1a3be901cf", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,3 +1,9 @@\n+2011-11-30  Alan Modra  <amodra@gmail.com>\n+\n+\tPR libgomp/51249\n+\t* config/linux/sem.h: Rewrite.\n+\t* config/linux/sem.c: Rewrite.\n+\n 2011-11-28  Richard Henderson  <rth@redhat.com>\n \n \t* libgomp.h (enum memmodel): New.\n@@ -316,7 +322,7 @@\n \t    Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32049\n-\t* configure.ac: \n+\t* configure.ac:\n \t* configure: Regenerate.\n \n 2010-10-06  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n@@ -1080,7 +1086,7 @@\n \t(gomp_new_thread_pool, gomp_free_pool_helper, gomp_free_thread): New\n \tfunctions.\n \t(gomp_team_start): Create new pool if current thread doesn't have\n-\tone.  Use pool fields instead of global gomp_* variables. \n+\tone.  Use pool fields instead of global gomp_* variables.\n \tInitialize thread_pool field for new threads.  Clear single_count.\n \tChange last argument from ws to team, don't create\n \tnew team, set ts.work_share to &team->work_shares[0] and clear\n@@ -1312,7 +1318,7 @@\n \tinlines.\n \t* config/posix/bar.c (gomp_barrier_init): Clear generation field.\n \t(gomp_barrier_wait_end): Change second argument to\n-\tgomp_barrier_state_t. \n+\tgomp_barrier_state_t.\n \t(gomp_team_barrier_wait, gomp_team_barrier_wait_end,\n \tgomp_team_barrier_wake): New functions.\n \t* config/linux/mutex.c: Include wait.h instead of libgomp.h and"}, {"sha": "3f2fc9988193f5331a6ed9c0fb9085f4e29ba422", "filename": "libgomp/config/linux/sem.c", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsem.c?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -28,34 +28,56 @@\n \n #include \"wait.h\"\n \n-\n void\n-gomp_sem_wait_slow (gomp_sem_t *sem)\n+gomp_sem_wait_slow (gomp_sem_t *sem, int count)\n {\n+  /* First loop spins a while.  */\n+  while (count == 0)\n+    if (do_spin (sem, 0)\n+\t/* Spin timeout, nothing changed.  Set waiting flag.  */\n+\t&& __atomic_compare_exchange_n (sem, &count, SEM_WAIT, false,\n+\t\t\t\t\tMEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+      {\n+\tfutex_wait (sem, SEM_WAIT);\n+\tcount = *sem;\n+\tbreak;\n+      }\n+  /* Something changed.  If it wasn't the wait flag, we're good to go.  */\n+    else if (__builtin_expect (((count = *sem) & SEM_WAIT) == 0 && count != 0,\n+\t\t\t       1))\n+      {\n+\tif (__atomic_compare_exchange_n (sem, &count, count - SEM_INC, false,\n+\t\t\t\t\t MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+\t  return;\n+      }\n+\n+  /* Second loop waits until semaphore is posted.  We always exit this\n+     loop with wait flag set, so next post will awaken a thread.  */\n   while (1)\n     {\n-      int val = __sync_val_compare_and_swap (sem, 0, -1);\n-      if (val > 0)\n+      unsigned int wake = count & ~SEM_WAIT;\n+      int newval = SEM_WAIT;\n+\n+      if (wake != 0)\n+\tnewval |= wake - SEM_INC;\n+      if (__atomic_compare_exchange_n (sem, &count, newval, false,\n+\t\t\t\t       MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n \t{\n-\t  if (__sync_bool_compare_and_swap (sem, val, val - 1))\n-\t    return;\n+\t  if (wake != 0)\n+\t    {\n+\t      /* If we can wake more threads, do so now.  */\n+\t      if (wake > SEM_INC)\n+\t\tgomp_sem_post_slow (sem);\n+\t      break;\n+\t    }\n+\t  do_wait (sem, SEM_WAIT);\n+\t  count = *sem;\n \t}\n-      do_wait (sem, -1);\n     }\n }\n \n void\n gomp_sem_post_slow (gomp_sem_t *sem)\n {\n-  int old, tmp = *sem, wake;\n-\n-  do\n-    {\n-      old = tmp;\n-      wake = old > 0 ? old + 1 : 1;\n-      tmp = __sync_val_compare_and_swap (sem, old, wake);\n-    }\n-  while (old != tmp);\n-\n-  futex_wake (sem, wake);\n+  futex_wake (sem, 1);\n }"}, {"sha": "9bf480ded36709fc4562f2182508ea840984df4a", "filename": "libgomp/config/linux/sem.h", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fsem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e348fccfa971cf81fe9fcf3489bf011979957e3/libgomp%2Fconfig%2Flinux%2Fsem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fsem.h?ref=3e348fccfa971cf81fe9fcf3489bf011979957e3", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -24,34 +24,64 @@\n \n /* This is a Linux specific implementation of a semaphore synchronization\n    mechanism for libgomp.  This type is private to the library.  This \n-   implementation uses atomic instructions and the futex syscall.  */\n+   counting semaphore implementation uses atomic instructions and the\n+   futex syscall, and a single 32-bit int to store semaphore state.\n+   The low 31 bits are the count, the top bit is a flag set when some\n+   threads may be waiting.  */\n \n #ifndef GOMP_SEM_H\n #define GOMP_SEM_H 1\n \n+#include <limits.h> /* For INT_MIN */\n+\n typedef int gomp_sem_t;\n+#define SEM_WAIT INT_MIN\n+#define SEM_INC 1\n+\n+extern void gomp_sem_wait_slow (gomp_sem_t *, int);\n+extern void gomp_sem_post_slow (gomp_sem_t *);\n \n-static inline void gomp_sem_init (gomp_sem_t *sem, int value)\n+static inline void\n+gomp_sem_init (gomp_sem_t *sem, int value)\n {\n-  *sem = value;\n+  *sem = value * SEM_INC;\n }\n \n-extern void gomp_sem_wait_slow (gomp_sem_t *);\n-static inline void gomp_sem_wait (gomp_sem_t *sem)\n+static inline void\n+gomp_sem_destroy (gomp_sem_t *sem)\n {\n-  if (!__sync_bool_compare_and_swap (sem, 1, 0))\n-    gomp_sem_wait_slow (sem);\n }\n \n-extern void gomp_sem_post_slow (gomp_sem_t *);\n-static inline void gomp_sem_post (gomp_sem_t *sem)\n+static inline void\n+gomp_sem_wait (gomp_sem_t *sem)\n {\n-  if (!__sync_bool_compare_and_swap (sem, 0, 1))\n-    gomp_sem_post_slow (sem);\n+  int count = *sem;\n+\n+  while ((count & ~SEM_WAIT) != 0)\n+    if (__atomic_compare_exchange_n (sem, &count, count - SEM_INC, true,\n+\t\t\t\t     MEMMODEL_ACQUIRE, MEMMODEL_RELAXED))\n+      return;\n+  gomp_sem_wait_slow (sem, count);\n }\n \n-static inline void gomp_sem_destroy (gomp_sem_t *sem)\n+static inline void\n+gomp_sem_post (gomp_sem_t *sem)\n {\n-}\n+  int count = *sem;\n+\n+  /* Clear SEM_WAIT here so that if there are no more waiting threads\n+     we transition back to the uncontended state that does not make\n+     futex syscalls.  If there are waiting threads then when one is\n+     awoken it will set SEM_WAIT again, so other waiting threads are\n+     woken on a future gomp_sem_post.  Furthermore, the awoken thread\n+     will wake other threads in case gomp_sem_post was called again\n+     before it had time to set SEM_WAIT.  */\n+  while (!__atomic_compare_exchange_n (sem, &count,\n+\t\t\t\t       (count + SEM_INC) & ~SEM_WAIT, true,\n+\t\t\t\t       MEMMODEL_RELEASE, MEMMODEL_RELAXED))\n+    continue;\n \n+  if (__builtin_expect (count & SEM_WAIT, 0))\n+    gomp_sem_post_slow (sem);\n+}\n #endif /* GOMP_SEM_H */"}]}