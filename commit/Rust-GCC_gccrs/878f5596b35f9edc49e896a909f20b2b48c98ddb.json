{"sha": "878f5596b35f9edc49e896a909f20b2b48c98ddb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc4ZjU1OTZiMzVmOWVkYzQ5ZTg5NmE5MDlmMjBiMmI0OGM5OGRkYg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2014-10-10T17:36:21Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-10-10T17:36:21Z"}, "message": "re PR target/63483 (Scheduler performs Invalid move of aliased memory reference)\n\n\tPR rtl-optimization/63483\n\t* alias.c (true_dependence_1): Do not exit early for MEM_READONLY_P\n\treferences when alignment ANDs are involved.\n\t(write_dependence_p): Ditto.\n\t(may_alias_p): Ditto.\n\nFrom-SVN: r216100", "tree": {"sha": "b560dc86a8c7958d9770475d551aa4903dce6882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b560dc86a8c7958d9770475d551aa4903dce6882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/878f5596b35f9edc49e896a909f20b2b48c98ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878f5596b35f9edc49e896a909f20b2b48c98ddb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878f5596b35f9edc49e896a909f20b2b48c98ddb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878f5596b35f9edc49e896a909f20b2b48c98ddb/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e82f089719b464e4d5959b45555b3dd135ae745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e82f089719b464e4d5959b45555b3dd135ae745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e82f089719b464e4d5959b45555b3dd135ae745"}], "stats": {"total": 89, "additions": 55, "deletions": 34}, "files": [{"sha": "d418235e08f5c946434edd53e648989fbb6ba2ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878f5596b35f9edc49e896a909f20b2b48c98ddb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878f5596b35f9edc49e896a909f20b2b48c98ddb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=878f5596b35f9edc49e896a909f20b2b48c98ddb", "patch": "@@ -1,3 +1,11 @@\n+2014-10-10  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR rtl-optimization/63483\n+\t* alias.c (true_dependence_1): Do not exit early for MEM_READONLY_P\n+\treferences when alignment ANDs are involved.\n+\t(write_dependence_p): Ditto.\n+\t(may_alias_p): Ditto.\n+\n 2014-10-10  Marek Polacek  <polacek@redhat.com>\n \n \t* asan.c (pass_sanopt::execute): Handle IFN_UBSAN_OBJECT_SIZE."}, {"sha": "134b6fb5485b3df600f16aeb3b4333c2579c845d", "filename": "gcc/alias.c", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878f5596b35f9edc49e896a909f20b2b48c98ddb/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878f5596b35f9edc49e896a909f20b2b48c98ddb/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=878f5596b35f9edc49e896a909f20b2b48c98ddb", "patch": "@@ -2458,18 +2458,6 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  /* Read-only memory is by definition never modified, and therefore can't\n-     conflict with anything.  We don't expect to find read-only set on MEM,\n-     but stupid user tricks can produce them, so don't die.  */\n-  if (MEM_READONLY_P (x))\n-    return 0;\n-\n-  /* If we have MEMs referring to different address spaces (which can\n-     potentially overlap), we cannot easily tell from the addresses\n-     whether the references overlap.  */\n-  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n-    return 1;\n-\n   if (! mem_addr)\n     {\n       mem_addr = XEXP (mem, 0);\n@@ -2493,6 +2481,22 @@ true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n \t}\n     }\n \n+  /* Read-only memory is by definition never modified, and therefore can't\n+     conflict with anything.  However, don't assume anything when AND\n+     addresses are involved and leave to the code below to determine\n+     dependence.  We don't expect to find read-only set on MEM, but\n+     stupid user tricks can produce them, so don't die.  */\n+  if (MEM_READONLY_P (x)\n+      && GET_CODE (x_addr) != AND\n+      && GET_CODE (mem_addr) != AND)\n+    return 0;\n+\n+  /* If we have MEMs referring to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   base = find_base_term (x_addr);\n   if (base && (GET_CODE (base) == LABEL_REF\n \t       || (GET_CODE (base) == SYMBOL_REF\n@@ -2576,16 +2580,6 @@ write_dependence_p (const_rtx mem,\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  /* A read from read-only memory can't conflict with read-write memory.  */\n-  if (!writep && MEM_READONLY_P (mem))\n-    return 0;\n-\n-  /* If we have MEMs referring to different address spaces (which can\n-     potentially overlap), we cannot easily tell from the addresses\n-     whether the references overlap.  */\n-  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n-    return 1;\n-\n   mem_addr = XEXP (mem, 0);\n   if (!x_addr)\n     {\n@@ -2603,6 +2597,21 @@ write_dependence_p (const_rtx mem,\n \t}\n     }\n \n+  /* A read from read-only memory can't conflict with read-write memory.\n+     Don't assume anything when AND addresses are involved and leave to\n+     the code below to determine dependence.  */\n+  if (!writep\n+      && MEM_READONLY_P (mem)\n+      && GET_CODE (x_addr) != AND\n+      && GET_CODE (mem_addr) != AND)\n+    return 0;\n+\n+  /* If we have MEMs referring to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   base = find_base_term (mem_addr);\n   if (! writep\n       && base\n@@ -2690,18 +2699,6 @@ may_alias_p (const_rtx mem, const_rtx x)\n       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)\n     return 1;\n \n-  /* Read-only memory is by definition never modified, and therefore can't\n-     conflict with anything.  We don't expect to find read-only set on MEM,\n-     but stupid user tricks can produce them, so don't die.  */\n-  if (MEM_READONLY_P (x))\n-    return 0;\n-\n-  /* If we have MEMs referring to different address spaces (which can\n-     potentially overlap), we cannot easily tell from the addresses\n-     whether the references overlap.  */\n-  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n-    return 1;\n-\n   x_addr = XEXP (x, 0);\n   mem_addr = XEXP (mem, 0);\n   if (!((GET_CODE (x_addr) == VALUE\n@@ -2715,6 +2712,22 @@ may_alias_p (const_rtx mem, const_rtx x)\n       mem_addr = get_addr (mem_addr);\n     }\n \n+  /* Read-only memory is by definition never modified, and therefore can't\n+     conflict with anything.  However, don't assume anything when AND\n+     addresses are involved and leave to the code below to determine\n+     dependence.  We don't expect to find read-only set on MEM, but\n+     stupid user tricks can produce them, so don't die.  */\n+  if (MEM_READONLY_P (x)\n+      && GET_CODE (x_addr) != AND\n+      && GET_CODE (mem_addr) != AND)\n+    return 0;\n+\n+  /* If we have MEMs referring to different address spaces (which can\n+     potentially overlap), we cannot easily tell from the addresses\n+     whether the references overlap.  */\n+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))\n+    return 1;\n+\n   rtx x_base = find_base_term (x_addr);\n   rtx mem_base = find_base_term (mem_addr);\n   if (! base_alias_check (x_addr, x_base, mem_addr, mem_base,"}]}