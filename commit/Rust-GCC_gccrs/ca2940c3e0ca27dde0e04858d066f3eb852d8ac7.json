{"sha": "ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EyOTQwYzNlMGNhMjdkZGUwZTA0ODU4ZDA2NmYzZWI4NTJkOGFjNw==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-10-04T13:03:43Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-10-04T13:03:43Z"}, "message": "trans-array.c (gfc_conv_expr_descriptor): Check for substriungs.\n\n2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n\tPaul Brook  <paul@codesourcery.com>\n\n\t* trans-array.c (gfc_conv_expr_descriptor): Check for substriungs.\n\tUse gfc_get_expr_charlen.\n\t* trans-expr.c (gfc_get_expr_charlen): New function.\n\t* trans.h (gfc_get_expr_charlen): Add prototype.\ntestsuite/\n\t* gfortran.dg/pr17612.f90: New test.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r88483", "tree": {"sha": "c2bb575fefe91c0ea361e22ef1df9305d35086c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2bb575fefe91c0ea361e22ef1df9305d35086c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b805ea17e55a0da7424d97eb9fb252917e51445e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b805ea17e55a0da7424d97eb9fb252917e51445e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b805ea17e55a0da7424d97eb9fb252917e51445e"}], "stats": {"total": 138, "additions": 129, "deletions": 9}, "files": [{"sha": "f99c54f989cb4ca6e9e1963a6f3fe19b6728db18", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -1,3 +1,11 @@\n+2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\t* trans-array.c (gfc_conv_expr_descriptor): Check for substriungs.\n+\tUse gfc_get_expr_charlen.\n+\t* trans-expr.c (gfc_get_expr_charlen): New function.\n+\t* trans.h (gfc_get_expr_charlen): Add prototype.\n+\n 2004-10-04  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* trans-intrinsic.c: Fix a comment typo."}, {"sha": "a6397d313fd5d3946004e51a126c3a805ec8decf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -3486,6 +3486,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree offset;\n   int full;\n   gfc_ss *vss;\n+  gfc_ref *ref;\n \n   gcc_assert (ss != gfc_ss_terminator);\n \n@@ -3528,23 +3529,42 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tfull = 0;\n       else\n \t{\n-\t  gcc_assert (info->ref->u.ar.type == AR_SECTION);\n+\t  ref = info->ref;\n+\t  gcc_assert (ref->u.ar.type == AR_SECTION);\n \n \t  full = 1;\n-\t  for (n = 0; n < info->ref->u.ar.dimen; n++)\n+\t  for (n = 0; n < ref->u.ar.dimen; n++)\n \t    {\n \t      /* Detect passing the full array as a section.  This could do\n \t         even more checking, but it doesn't seem worth it.  */\n-\t      if (info->ref->u.ar.start[n]\n-\t\t  || info->ref->u.ar.end[n]\n-\t\t  || (info->ref->u.ar.stride[n]\n-\t\t      && !gfc_expr_is_one (info->ref->u.ar.stride[n], 0)))\n+\t      if (ref->u.ar.start[n]\n+\t\t  || ref->u.ar.end[n]\n+\t\t  || (ref->u.ar.stride[n]\n+\t\t      && !gfc_expr_is_one (ref->u.ar.stride[n], 0)))\n \t\t{\n \t\t  full = 0;\n \t\t  break;\n \t\t}\n \t    }\n \t}\n+\n+      /* Check for substring references.  */\n+      ref = expr->ref;\n+      if (!need_tmp && ref && expr->ts.type == BT_CHARACTER)\n+\t{\n+\t  while (ref->next)\n+\t    ref = ref->next;\n+\t  if (ref->type == REF_SUBSTRING)\n+\t    {\n+\t      /* In general character substrings need a copy.  Character\n+\t\t array strides are expressed as multiples of the element\n+\t\t size (consistent with other array types), not in\n+\t\t characters.  */\n+\t      full = 0;\n+\t      need_tmp = 1;\n+\t    }\n+\t}\n+\n       if (full)\n \t{\n \t  if (se->direct_byref)\n@@ -3562,8 +3582,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    {\n \t      se->expr = desc;\n \t    }\n+\n \t  if (expr->ts.type == BT_CHARACTER)\n-\t    se->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n+\t    se->string_length = gfc_get_expr_charlen (expr);\n+\n \t  return;\n \t}\n       break;\n@@ -3634,7 +3656,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       loop.temp_ss->type = GFC_SS_TEMP;\n       loop.temp_ss->next = gfc_ss_terminator;\n       loop.temp_ss->data.temp.type = gfc_typenode_for_spec (&expr->ts);\n-      /* Which can hold our string, if present.  */\n+      /* ... which can hold our string, if present.  */\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length = loop.temp_ss->string_length\n \t  = TYPE_SIZE_UNIT (loop.temp_ss->data.temp.type);\n@@ -3716,7 +3738,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       /* Set the string_length for a character array.  */\n       if (expr->ts.type == BT_CHARACTER)\n-\tse->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n+\tse->string_length =  gfc_get_expr_charlen (expr);\n \n       desc = info->descriptor;\n       gcc_assert (secss && secss != gfc_ss_terminator);"}, {"sha": "45f3acfbbd548965430795a3203d1297c1d9d90d", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -140,6 +140,53 @@ gfc_conv_expr_present (gfc_symbol * sym)\n }\n \n \n+/* Get the character length of an expression, looking through gfc_refs\n+   if necessary.  */\n+\n+tree\n+gfc_get_expr_charlen (gfc_expr *e)\n+{\n+  gfc_ref *r;\n+  tree length;\n+\n+  gcc_assert (e->expr_type == EXPR_VARIABLE \n+\t      && e->ts.type == BT_CHARACTER);\n+  \n+  length = NULL; /* To silence compiler warning.  */\n+\n+  /* First candidate: if the variable is of type CHARACTER, the\n+     expression's length could be the length of the character\n+     variable. */\n+  if (e->symtree->n.sym->ts.type == BT_CHARACTER)\n+    length = e->symtree->n.sym->ts.cl->backend_decl;\n+\n+  /* Look through the reference chain for component references.  */\n+  for (r = e->ref; r; r = r->next)\n+    {\n+      switch (r->type)\n+\t{\n+\tcase REF_COMPONENT:\n+\t  if (r->u.c.component->ts.type == BT_CHARACTER)\n+\t    length = r->u.c.component->ts.cl->backend_decl;\n+\t  break;\n+\n+\tcase REF_ARRAY:\n+\t  /* Do nothing.  */\n+\t  break;\n+\n+\tdefault:\n+\t  /* We should never got substring references here.  These will be\n+\t     broken down by the scalarizer.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  gcc_assert (length != NULL);\n+  return length;\n+}\n+\n+  \n+\n /* Generate code to initialize a string length variable. Returns the\n    value.  */\n "}, {"sha": "f61fd4f97216ef1b42480222acdf09118da66bba", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -316,6 +316,8 @@ tree gfc_conv_expr_present (gfc_symbol *);\n \n /* Generate code to allocate a string temporary.  */\n tree gfc_conv_string_tmp (gfc_se *, tree, tree);\n+/* Get the string length variable belonging to an expression.  */\n+tree gfc_get_expr_charlen (gfc_expr *);\n /* Initialize a string length variable.  */\n void gfc_trans_init_string_length (gfc_charlen *, stmtblock_t *);\n "}, {"sha": "3f54500f88e3d4cc5bb2b7ad9d794df44c2d05f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -1,3 +1,7 @@\n+2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* gfortran.dg/pr17612.f90: New test.\n+\n 2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* g++.dg/template/local1.C: Adjust quoting marks in"}, {"sha": "1b6853269ab297c7d8c8cd52bf9acde74a54f950", "filename": "gcc/testsuite/gfortran.dg/pr17612.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17612.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2940c3e0ca27dde0e04858d066f3eb852d8ac7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17612.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr17612.f90?ref=ca2940c3e0ca27dde0e04858d066f3eb852d8ac7", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+! PR 17612\n+! We used to not determine the length of character-valued expressions\n+! correctly, leading to a segfault.\n+program prog\n+  character(len=2), target :: c(4)\n+  type pseudo_upf \n+     character(len=2), pointer :: els(:)\n+  end type pseudo_upf\n+  type (pseudo_upf) :: p\n+  type t\n+    character(5) :: s(2)\n+  end type\n+  type (t) v\n+  ! A full arrays.\n+  c = (/\"ab\",\"cd\",\"ef\",\"gh\"/)\n+  call n(p)\n+  if (any (c /= p%els)) call abort\n+  ! An array section that needs a new array descriptor.\n+  v%s(1) = \"hello\"\n+  v%s(2) = \"world\"\n+  call test (v%s)\n+contains \n+\n+  subroutine n (upf) \n+    type (pseudo_upf), intent(inout) :: upf \n+    upf%els => c\n+    return \n+  end subroutine n\n+\n+  subroutine test(s)\n+    character(len=*) :: s(:)\n+    if ((len (s) .ne. 5) .or. (any (s .ne. (/\"hello\", \"world\"/)))) call abort\n+  end subroutine\n+end program\n+  \n+"}]}