{"sha": "2726bdbaac4a5697ded7377fcd5a7592efca00ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcyNmJkYmFhYzRhNTY5N2RlZDczNzdmY2Q1YTc1OTJlZmNhMDBlYw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2001-10-29T21:23:31Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2001-10-29T21:23:31Z"}, "message": "Rewritten all the internals - great performance boost.\n\nFrom-SVN: r46615", "tree": {"sha": "b239b34fead7f126a6f4a82020ace8c0d352e652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b239b34fead7f126a6f4a82020ace8c0d352e652"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2726bdbaac4a5697ded7377fcd5a7592efca00ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2726bdbaac4a5697ded7377fcd5a7592efca00ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2726bdbaac4a5697ded7377fcd5a7592efca00ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2726bdbaac4a5697ded7377fcd5a7592efca00ec/comments", "author": null, "committer": null, "parents": [{"sha": "3df95b7b7c3b26348ba3dd14072ba510db7845fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3df95b7b7c3b26348ba3dd14072ba510db7845fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3df95b7b7c3b26348ba3dd14072ba510db7845fc"}], "stats": {"total": 585, "additions": 463, "deletions": 122}, "files": [{"sha": "e6c943779ff9b8808f6135906fc4f6c7da6ef32b", "filename": "libobjc/class.c", "status": "modified", "additions": 463, "deletions": 122, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2726bdbaac4a5697ded7377fcd5a7592efca00ec/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2726bdbaac4a5697ded7377fcd5a7592efca00ec/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=2726bdbaac4a5697ded7377fcd5a7592efca00ec", "patch": "@@ -1,7 +1,10 @@\n /* GNU Objective C Runtime class related functions\n-   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997, 2001 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup and Dennis Glatting.\n \n+   Lock-free class table code designed and written from scratch by\n+   Nicola Pero, 2001.\n+\n This file is part of GNU CC.\n \n GNU CC is free software; you can redistribute it and/or modify it under the\n@@ -23,59 +26,426 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    however invalidate any other reasons why the executable file might be\n    covered by the GNU General Public License.  */\n \n-#include \"runtime.h\"\t\t/* the kitchen sink */\n+/*\n+  The code in this file critically affects class method invocation\n+  speed.  This long preamble comment explains why, and the issues\n+  involved.  \n+\n+\n+  One of the traditional weaknesses of the GNU Objective-C runtime is\n+  that class method invocations are slow.  The reason is that when you\n+  write\n+  \n+  array = [NSArray new];\n+  \n+  this gets basically compiled into the equivalent of \n+  \n+  array = [(objc_get_class (\"NSArray\")) new];\n+  \n+  objc_get_class returns the class pointer corresponding to the string\n+  `NSArray'; and because of the lookup, the operation is more\n+  complicated and slow than a simple instance method invocation.  \n+  \n+  Most high performance Objective-C code (using the GNU Objc runtime)\n+  I had the opportunity to read (or write) work around this problem by\n+  caching the class pointer:\n+  \n+  Class arrayClass = [NSArray class];\n+  \n+  ... later on ...\n+  \n+  array = [arrayClass new];\n+  array = [arrayClass new];\n+  array = [arrayClass new];\n+  \n+  In this case, you always perform a class lookup (the first one), but\n+  then all the [arrayClass new] methods run exactly as fast as an\n+  instance method invocation.  It helps if you have many class method\n+  invocations to the same class.  \n+  \n+  The long-term solution to this problem would be to modify the\n+  compiler to output tables of class pointers corresponding to all the\n+  class method invocations, and to add code to the runtime to update\n+  these tables - that should in the end allow class method invocations\n+  to perform precisely as fast as instance method invocations, because\n+  no class lookup would be involved.  I think the Apple Objective-C\n+  runtime uses this technique.  Doing this involves synchronized\n+  modifications in the runtime and in the compiler.  \n+  \n+  As a first medicine to the problem, I [NP] have redesigned and\n+  rewritten the way the runtime is performing class lookup.  This\n+  doesn't give as much speed as the other (definitive) approach, but\n+  at least a class method invocation now takes approximately 4.5 times\n+  an instance method invocation on my machine (it would take approx 12\n+  times before the rewriting), which is a lot better.  \n+\n+  One of the main reason the new class lookup is so faster is because\n+  I implemented it in a way that can safely run multithreaded without\n+  using locks - a so-called `lock-free' data structure.  The atomic\n+  operation is pointer assignment.  The reason why in this problem\n+  lock-free data structures work so well is that you never remove\n+  classes from the table - and the difficult thing with lock-free data\n+  structures is freeing data when is removed from the structures.  */\n+\n+#include \"runtime.h\"            /* the kitchen sink */\n #include \"sarray.h\"\n \n-/* The table of classname->class.  Used for objc_lookup_class and friends */\n-static cache_ptr __objc_class_hash = 0;                 /* !T:MUTEX */\n+#include <objc/objc.h>\n+#include <objc/objc-api.h>\n+#include <objc/thr.h>\n+\n+/* We use a table which maps a class name to the corresponding class\n+ * pointer.  The first part of this file defines this table, and\n+ * functions to do basic operations on the table.  The second part of\n+ * the file implements some higher level Objective-C functionality for\n+ * classes by using the functions provided in the first part to manage\n+ * the table. */\n+\n+/**\n+ ** Class Table Internals\n+ **/\n+\n+/* A node holding a class */\n+typedef struct class_node\n+{\n+  struct class_node *next;      /* Pointer to next entry on the list.\n+                                   NULL indicates end of list. */\n+  \n+  const char *name;             /* The class name string */\n+  int length;                   /* The class name string length */\n+  Class pointer;                /* The Class pointer */\n+  \n+} *class_node_ptr;\n+\n+/* A table containing classes is a class_node_ptr (pointing to the\n+   first entry in the table - if it is NULL, then the table is\n+   empty). */\n+\n+/* We have 1024 tables.  Each table contains all class names which\n+   have the same hash (which is a number between 0 and 1023).  To look\n+   up a class_name, we compute its hash, and get the corresponding\n+   table.  Once we have the table, we simply compare strings directly\n+   till we find the one which we want (using the length first).  The\n+   number of tables is quite big on purpose (a normal big application\n+   has less than 1000 classes), so that you shouldn't normally get any\n+   collisions, and get away with a single comparison (which we can't\n+   avoid since we need to know that you have got the right thing).  */\n+#define CLASS_TABLE_SIZE 1024\n+#define CLASS_TABLE_MASK 1023\n+\n+static class_node_ptr class_table_array[CLASS_TABLE_SIZE];\n+\n+/* The table writing mutex - we lock on writing to avoid conflicts\n+   between different writers, but we read without locks.  That is\n+   possible because we assume pointer assignment to be an atomic\n+   operation.  */\n+static objc_mutex_t __class_table_lock = NULL;\n+\n+/* CLASS_TABLE_HASH is how we compute the hash of a class name.  It is\n+   a macro - *not* a function - arguments *are* modified directly.  \n+\n+   INDEX should be a variable holding an int;\n+   HASH should be a variable holding an int;\n+   CLASS_NAME should be a variable holding a (char *) to the class_name.  \n+\n+   After the macro is executed, INDEX contains the length of the\n+   string, and HASH the computed hash of the string; CLASS_NAME is\n+   untouched.  */\n+\n+#define CLASS_TABLE_HASH(INDEX, HASH, CLASS_NAME)          \\\n+  HASH = 0;                                                  \\\n+  for (INDEX = 0; CLASS_NAME[INDEX] != '\\0'; INDEX++)        \\\n+    {                                                        \\\n+      HASH = (HASH << 4) ^ (HASH >> 28) ^ CLASS_NAME[INDEX]; \\\n+    }                                                        \\\n+                                                             \\\n+  HASH = (HASH ^ (HASH >> 10) ^ (HASH >> 20)) & CLASS_TABLE_MASK;\n+\n+/* Setup the table.  */\n+static void\n+class_table_setup ()\n+{\n+  /* Start - nothing in the table.  */\n+  memset (class_table_array, 0, sizeof(class_node_ptr) * CLASS_TABLE_SIZE);\n+\n+  /* The table writing mutex.  */\n+  __class_table_lock = objc_mutex_allocate ();\n+}\n+\n+\n+/* Insert a class in the table (used when a new class is registered).  */\n+static void \n+class_table_insert (const char *class_name, Class class_pointer)\n+{\n+  int hash, length;\n+  class_node_ptr new_node;\n+\n+  /* Find out the class name's hash and length.  */\n+  CLASS_TABLE_HASH (length, hash, class_name);\n+  \n+  /* Prepare the new node holding the class.  */\n+  new_node = objc_malloc (sizeof (struct class_node));\n+  new_node->name = class_name;\n+  new_node->length = length;\n+  new_node->pointer = class_pointer;\n+\n+  /* Lock the table for modifications.  */\n+  objc_mutex_lock (__class_table_lock);\n+  \n+  /* Insert the new node in the table at the beginning of the table at\n+     class_table_array[hash].  */\n+  new_node->next = class_table_array[hash];\n+  class_table_array[hash] = new_node;\n+  \n+  objc_mutex_unlock (__class_table_lock);\n+}\n+\n+/* Replace a class in the table (used only by poseAs:).  */\n+static void \n+class_table_replace (Class old_class_pointer, Class new_class_pointer)\n+{\n+  int hash;\n+  class_node_ptr node;\n+\n+  objc_mutex_lock (__class_table_lock);\n+  \n+  hash = 0;\n+  node = class_table_array[hash];\n+  \n+  while (hash < CLASS_TABLE_SIZE)\n+    {\n+      if (node == NULL)\n+        {\n+          hash++;\n+          if (hash < CLASS_TABLE_SIZE)\n+            {\n+              node = class_table_array[hash];\n+            }\n+        }\n+      else\n+        {\n+          Class class1 = node->pointer;\n+\n+          if (class1 == old_class_pointer)\n+            {\n+              node->pointer = new_class_pointer;\n+            }\n+          node = node->next;\n+        }\n+    }\n \n-/* This is a hook which is called by objc_get_class and \n-   objc_lookup_class if the runtime is not able to find the class.\n-   This may e.g. try to load in the class using dynamic loading */\n+  objc_mutex_unlock (__class_table_lock);\n+}\n+\n+\n+/* Get a class from the table.  This does not need mutex protection.\n+   Currently, this function is called each time you call a static\n+   method, this is why it must be very fast.  */\n+static inline Class \n+class_table_get_safe (const char *class_name)\n+{\n+  class_node_ptr node;  \n+  int length, hash;\n+\n+  /* Compute length and hash.  */\n+  CLASS_TABLE_HASH (length, hash, class_name);\n+  \n+  node = class_table_array[hash];\n+  \n+  if (node != NULL)\n+    {\n+      do\n+        {\n+          if (node->length == length)\n+            {\n+              /* Compare the class names.  */\n+              int i;\n+\n+              for (i = 0; i < length; i++)\n+                {\n+                  if ((node->name)[i] != class_name[i]) \n+                    {\n+                      break;\n+                    }\n+                }\n+              \n+              if (i == length)\n+                {\n+                  /* They are equal!  */\n+                  return node->pointer;\n+                }\n+            }\n+        }\n+      while ((node = node->next) != NULL);\n+    }\n+\n+  return Nil;\n+}\n+\n+/* Enumerate over the class table.  */\n+struct class_table_enumerator\n+{\n+  int hash;\n+  class_node_ptr node;\n+};\n+\n+\n+static Class\n+class_table_next (struct class_table_enumerator **e)\n+{\n+  struct class_table_enumerator *enumerator = *e;\n+  class_node_ptr next;\n+  \n+  if (enumerator == NULL)\n+    {\n+       *e = objc_malloc (sizeof (struct class_table_enumerator));\n+      enumerator = *e;\n+      enumerator->hash = 0;\n+      enumerator->node = NULL;\n+\n+      next = class_table_array[enumerator->hash];\n+    }\n+  else\n+    {\n+      next = enumerator->node->next;\n+    }\n+  \n+  if (next != NULL)\n+    {\n+      enumerator->node = next;\n+      return enumerator->node->pointer;\n+    }\n+  else \n+    {\n+      enumerator->hash++;\n+     \n+      while (enumerator->hash < CLASS_TABLE_SIZE)\n+        {\n+          next = class_table_array[enumerator->hash];\n+          if (next != NULL)\n+            {\n+              enumerator->node = next;\n+              return enumerator->node->pointer;\n+            }\n+          enumerator->hash++;\n+        }\n+      \n+      /* Ok - table finished - done.  */\n+      objc_free (enumerator);\n+      return Nil;\n+    }\n+}\n+\n+#if 0 /* DEBUGGING FUNCTIONS */\n+/* Debugging function - print the class table.  */\n+void\n+class_table_print ()\n+{\n+  int i;\n+  \n+  for (i = 0; i < CLASS_TABLE_SIZE; i++)\n+    {\n+      class_node_ptr node;\n+      \n+      printf (\"%d:\\n\", i);\n+      node = class_table_array[i];\n+      \n+      while (node != NULL)\n+        {\n+          printf (\"\\t%s\\n\", node->name);\n+          node = node->next;\n+        }\n+    }\n+}\n+\n+/* Debugging function - print an histogram of number of classes in\n+   function of hash key values.  Useful to evaluate the hash function\n+   in real cases.  */\n+void\n+class_table_print_histogram ()\n+{\n+  int i, j;\n+  int counter = 0;\n+  \n+  for (i = 0; i < CLASS_TABLE_SIZE; i++)\n+    {\n+      class_node_ptr node;\n+      \n+      node = class_table_array[i];\n+      \n+      while (node != NULL)\n+        {\n+          counter++;\n+          node = node->next;\n+        }\n+      if (((i + 1) % 50) == 0)\n+        {\n+          printf (\"%4d:\", i + 1);\n+          for (j = 0; j < counter; j++)\n+            {\n+              printf (\"X\");\n+            }\n+          printf (\"\\n\");\n+          counter = 0;\n+        }\n+    }\n+  printf (\"%4d:\", i + 1);\n+  for (j = 0; j < counter; j++)\n+    {\n+      printf (\"X\");\n+    }\n+  printf (\"\\n\");\n+}\n+#endif /* DEBUGGING FUNCTIONS */\n+\n+/**\n+ ** Objective-C runtime functions\n+ **/\n+\n+/* From now on, the only access to the class table data structure\n+   should be via the class_table_* functions.  */\n+\n+/* This is a hook which is called by objc_get_class and\n+   objc_lookup_class if the runtime is not able to find the class.  \n+   This may e.g. try to load in the class using dynamic loading.  */\n Class (*_objc_lookup_class)(const char* name) = 0;      /* !T:SAFE */\n \n \n-/* True when class links has been resolved */     \n+/* True when class links has been resolved.  */     \n BOOL __objc_class_links_resolved = NO;                  /* !T:UNUSED */\n \n \n-/* Initial number of buckets size of class hash table. */\n-#define CLASS_HASH_SIZE 32\n-\n void __objc_init_class_tables()\n {\n-  /* Allocate the class hash table */\n-\n-  if(__objc_class_hash)\n+  /* Allocate the class hash table.  */\n+  \n+  if(__class_table_lock)\n     return;\n-\n+  \n   objc_mutex_lock(__objc_runtime_mutex);\n-\n-  __objc_class_hash\n-    =  hash_new (CLASS_HASH_SIZE,\n-\t\t (hash_func_type) hash_string,\n-\t\t (compare_func_type) compare_strings);\n+  \n+  class_table_setup ();\n \n   objc_mutex_unlock(__objc_runtime_mutex);\n }  \n \n-/* This function adds a class to the class hash table, and assigns the \n-   class a number, unless it's already known */\n+/* This function adds a class to the class hash table, and assigns the\n+   class a number, unless it's already known.  */\n void\n __objc_add_class_to_hash(Class class)\n {\n   Class h_class;\n \n   objc_mutex_lock(__objc_runtime_mutex);\n \n-  /* make sure the table is there */\n-  assert(__objc_class_hash);\n+  /* Make sure the table is there.  */\n+  assert(__class_table_lock);\n \n-  /* make sure it's not a meta class */  \n+  /* Make sure it's not a meta class.  */\n   assert(CLS_ISCLASS(class));\n \n   /* Check to see if the class is already in the hash table.  */\n-  h_class = hash_value_for_key (__objc_class_hash, class->name);\n+  h_class = class_table_get_safe (class->name);\n   if (!h_class)\n     {\n       /* The class isn't in the hash table.  Add the class and assign a class\n@@ -86,27 +456,20 @@ __objc_add_class_to_hash(Class class)\n       CLS_SETNUMBER(class->class_pointer, class_number);\n \n       ++class_number;\n-      hash_add (&__objc_class_hash, class->name, class);\n+      class_table_insert (class->name, class);\n     }\n \n   objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n-   this fails, nil is returned */\n+   this fails, nil is returned.  */\n Class objc_lookup_class (const char* name)\n {\n   Class class;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-\n-  /* Make sure the class hash table exists.  */\n-  assert (__objc_class_hash);\n-\n-  class = hash_value_for_key (__objc_class_hash, name);\n-\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  class = class_table_get_safe (name);\n \n   if (class)\n     return class;\n@@ -119,20 +482,13 @@ Class objc_lookup_class (const char* name)\n \n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n-   this fails,  an error message is issued and the system aborts */\n+   this fails, an error message is issued and the system aborts.  */\n Class\n objc_get_class (const char *name)\n {\n   Class class;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-\n-  /* Make sure the class hash table exists.  */\n-  assert (__objc_class_hash);\n-\n-  class = hash_value_for_key (__objc_class_hash, name);\n-\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  class = class_table_get_safe (name);\n \n   if (class)\n     return class;\n@@ -144,7 +500,7 @@ objc_get_class (const char *name)\n     return class;\n   \n   objc_error(nil, OBJC_ERR_BAD_CLASS, \n-\t     \"objc runtime: cannot find class %s\\n\", name);\n+             \"objc runtime: cannot find class %s\\n\", name);\n   return 0;\n }\n \n@@ -166,44 +522,42 @@ objc_get_meta_class(const char *name)\n Class\n objc_next_class(void **enum_state)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  Class class;\n \n-  /* make sure the table is there */\n-  assert(__objc_class_hash);\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  \n+  /* Make sure the table is there.  */\n+  assert(__class_table_lock);\n \n-  *(node_ptr*)enum_state = \n-    hash_next(__objc_class_hash, *(node_ptr*)enum_state);\n+  class = class_table_next ((struct class_table_enumerator **)enum_state);\n \n   objc_mutex_unlock(__objc_runtime_mutex);\n-\n-  if (*(node_ptr*)enum_state)\n-    return (*(node_ptr*)enum_state)->value;\n-  return (Class)0;\n+  \n+  return class;\n }\n \n-/* Resolve super/subclass links for all classes.  The only thing we \n-   can be sure of is that the class_pointer for class objects point \n-   to the right meta class objects */\n+/* Resolve super/subclass links for all classes.  The only thing we\n+   can be sure of is that the class_pointer for class objects point to\n+   the right meta class objects.  */\n void __objc_resolve_class_links()\n {\n-  node_ptr node;\n+  struct class_table_enumerator *es = NULL;\n   Class object_class = objc_get_class (\"Object\");\n+  Class class1;\n \n   assert(object_class);\n \n   objc_mutex_lock(__objc_runtime_mutex);\n \n-  /* Assign subclass links */\n-  for (node = hash_next (__objc_class_hash, NULL); node;\n-       node = hash_next (__objc_class_hash, node))\n+  /* Assign subclass links.  */\n+  while ((class1 = class_table_next (&es)))\n     {\n-      Class class1 = node->value;\n-\n       /* Make sure we have what we think we have.  */\n       assert (CLS_ISCLASS(class1));\n       assert (CLS_ISMETA(class1->class_pointer));\n \n-      /* The class_pointer of all meta classes point to Object's meta class. */\n+      /* The class_pointer of all meta classes point to Object's meta\n+         class.  */\n       class1->class_pointer->class_pointer = object_class->class_pointer;\n \n       if (!(CLS_ISRESOLV(class1)))\n@@ -221,11 +575,11 @@ void __objc_resolve_class_links()\n               DEBUG_PRINTF (\"making class connections for: %s\\n\",\n                             class1->name);\n               \n-              /* assign subclass links for superclass */\n+              /* Assign subclass links for superclass.  */\n               class1->sibling_class = a_super_class->subclass_list;\n               a_super_class->subclass_list = class1;\n               \n-              /* Assign subclass links for meta class of superclass */\n+              /* Assign subclass links for meta class of superclass.  */\n               if (a_super_class->class_pointer)\n                 {\n                   class1->class_pointer->sibling_class\n@@ -234,8 +588,8 @@ void __objc_resolve_class_links()\n                     = class1->class_pointer;\n                 }\n             }\n-          else                  /* a root class, make its meta object */\n-                                /* be a subclass of Object */\n+          else /* A root class, make its meta object be a subclass of\n+                  Object.  */\n             {\n               class1->class_pointer->sibling_class \n                 = object_class->subclass_list;\n@@ -244,11 +598,10 @@ void __objc_resolve_class_links()\n         }\n     }\n \n-  /* Assign superclass links */\n-  for (node = hash_next (__objc_class_hash, NULL); node;\n-       node = hash_next (__objc_class_hash, node))\n+  /* Assign superclass links.  */\n+   es = NULL;\n+   while ((class1 = class_table_next (&es)))\n     {\n-      Class class1 = node->value;\n       Class sub_class;\n       for (sub_class = class1->subclass_list; sub_class;\n            sub_class = sub_class->sibling_class)\n@@ -269,13 +622,10 @@ void __objc_resolve_class_links()\n Class\n class_pose_as (Class impostor, Class super_class)\n {\n-  node_ptr node;\n-  Class class1;\n-\n   if (!CLS_ISRESOLV (impostor))\n     __objc_resolve_class_links ();\n \n-  /* preconditions */\n+  /* Preconditions */\n   assert (impostor);\n   assert (super_class);\n   assert (impostor->super_class == super_class);\n@@ -286,73 +636,64 @@ class_pose_as (Class impostor, Class super_class)\n   {\n     Class *subclass = &(super_class->subclass_list);\n \n-    /* move subclasses of super_class to impostor */\n+    /* Move subclasses of super_class to impostor.  */\n     while (*subclass)\n       {\n-\tClass nextSub = (*subclass)->sibling_class;\n-\n-\tif (*subclass != impostor)\n-\t  {\n-\t    Class sub = *subclass;\n-\n-\t    /* classes */\n-\t    sub->sibling_class = impostor->subclass_list;\n-\t    sub->super_class = impostor;\n-\t    impostor->subclass_list = sub;\n-\n-\t    /* It will happen that SUB is not a class object if it is \n-\t       the top of the meta class hierarchy chain.  (root\n-\t       meta-class objects inherit their class object)  If that is\n-\t       the case... don't mess with the meta-meta class. */ \n-\t    if (CLS_ISCLASS (sub))\n-\t      {\n-\t\t/* meta classes */\n-\t\tCLASSOF (sub)->sibling_class = \n-\t\t  CLASSOF (impostor)->subclass_list;\n-\t\tCLASSOF (sub)->super_class = CLASSOF (impostor);\n-\t\tCLASSOF (impostor)->subclass_list = CLASSOF (sub);\n-\t      }\n-\t  }\n-\n-\t*subclass = nextSub;\n+        Class nextSub = (*subclass)->sibling_class;\n+\n+        if (*subclass != impostor)\n+          {\n+            Class sub = *subclass;\n+\n+            /* Classes */\n+            sub->sibling_class = impostor->subclass_list;\n+            sub->super_class = impostor;\n+            impostor->subclass_list = sub;\n+\n+            /* It will happen that SUB is not a class object if it is\n+               the top of the meta class hierarchy chain (root\n+               meta-class objects inherit their class object).  If\n+               that is the case... don't mess with the meta-meta\n+               class.  */\n+            if (CLS_ISCLASS (sub))\n+              {\n+                /* Meta classes */\n+                CLASSOF (sub)->sibling_class = \n+                  CLASSOF (impostor)->subclass_list;\n+                CLASSOF (sub)->super_class = CLASSOF (impostor);\n+                CLASSOF (impostor)->subclass_list = CLASSOF (sub);\n+              }\n+          }\n+\n+        *subclass = nextSub;\n       }\n \n-    /* set subclasses of superclass to be impostor only */\n+    /* Set subclasses of superclass to be impostor only.  */\n     super_class->subclass_list = impostor;\n     CLASSOF (super_class)->subclass_list = CLASSOF (impostor);\n     \n-    /* set impostor to have no sibling classes */\n+    /* Set impostor to have no sibling classes.  */\n     impostor->sibling_class = 0;\n     CLASSOF (impostor)->sibling_class = 0;\n   }\n   \n-  /* check relationship of impostor and super_class is kept. */\n+  /* Check relationship of impostor and super_class is kept.  */\n   assert (impostor->super_class == super_class);\n   assert (CLASSOF (impostor)->super_class == CLASSOF (super_class));\n \n-  /* This is how to update the lookup table. Regardless of\n-     what the keys of the hashtable is, change all values that are\n-     superclass into impostor. */\n+  /* This is how to update the lookup table.  Regardless of what the\n+     keys of the hashtable is, change all values that are superclass\n+     into impostor.  */\n \n   objc_mutex_lock(__objc_runtime_mutex);\n \n-  for (node = hash_next (__objc_class_hash, NULL); node;\n-       node = hash_next (__objc_class_hash, node))\n-    {\n-      class1 = (Class)node->value;\n-      if (class1 == super_class)\n-\t{\n-\t  node->value = impostor; /* change hash table value */\n-\t}\n-    }      \n+  class_table_replace (super_class, impostor);\n \n   objc_mutex_unlock(__objc_runtime_mutex);\n \n-  /* next, we update the dispatch tables... */\n+  /* Next, we update the dispatch tables...  */\n   __objc_update_dispatch_table_for_class (CLASSOF (impostor));\n   __objc_update_dispatch_table_for_class (impostor);\n \n   return impostor;\n }\n-  \n-"}]}