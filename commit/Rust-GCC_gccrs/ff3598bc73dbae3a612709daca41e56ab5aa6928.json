{"sha": "ff3598bc73dbae3a612709daca41e56ab5aa6928", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYzNTk4YmM3M2RiYWUzYTYxMjcwOWRhY2E0MWU1NmFiNWFhNjkyOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-10T17:02:53Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-09-10T17:02:53Z"}, "message": "re PR fortran/34640 (ICE when assigning item of a derived-component to a pointer)\n\n2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34640\n\tPR fortran/40737\n\tPR fortran/55763\n\tPR fortran/57019\n\tPR fortran/57116\n\n\t* expr.c (is_subref_array): Add class pointer array dummies\n\tto the list of expressions that return true.\n\t* trans-array.c: Add SPAN_FIELD and update indices for\n\tsubsequent fields.\n\t(gfc_conv_descriptor_span, gfc_conv_descriptor_span_get,\n\tgfc_conv_descriptor_span_set, is_pointer_array,\n\tget_array_span): New functions.\n\t(gfc_get_descriptor_offsets_for_info): New function to preserve\n\tAPI for access to descriptor fields for trans-types.c.\n\t(gfc_conv_scalarized_array_ref): If the expression is a subref\n\tarray, make sure that info->descriptor is a descriptor type.\n\tOtherwise, if info->descriptor is a pointer array, set 'decl'\n\tand fix it if it is a component reference.\n\t(build_array_ref): Simplify handling of class array refs by\n\tpassing the vptr to gfc_build_array_ref rather than generating\n\tthe pointer arithmetic in this function.\n\t(gfc_conv_array_ref): As in gfc_conv_scalarized_array_ref, set\n\t'decl'.\n\t(gfc_array_allocate): Set the span field if this is a pointer\n\tarray. Use the expr3 element size if it is available, so that\n\tthe dynamic type element size is used.\n\t(gfc_conv_expr_descriptor): Set the span field for pointer\n\tassignments.\n\t* trans-array.h: Prototypes for gfc_conv_descriptor_span_get\n\tgfc_conv_descriptor_span_set and\n\tgfc_get_descriptor_offsets_for_info added.\n\ttrans-decl.c (gfc_get_symbol_decl): If a non-class pointer\n\tarray, mark the declaration as a GFC_DECL_PTR_ARRAY_P. Remove\n\tthe setting of GFC_DECL_SPAN.\n\t(gfc_trans_deferred_vars): Set the span field to zero in thge\n\toriginating scope.\n\t* trans-expr.c (gfc_conv_procedure_call): Do not use copy-in/\n\tcopy-out to pass subref expressions to a pointer dummy.\n\t(gfc_trans_pointer_assignment): Remove code for setting of\n\tGFC_DECL_SPAN. Set the 'span' field for non-class pointers to\n\tclass function results. Likewise for rank remap. In the case\n\tthat the target is not a whole array, use the target array ref\n\tfor remap and, since the 'start' indices are missing, set the\n\tlbounds to one, as required by the standard.\n\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Pick up the\n\t'token' offset from the field decl in the descriptor.\n\t(conv_isocbinding_subroutine): Set the 'span' field.\n\t* trans-io.c (gfc_trans_transfer): Always scalarize pointer\n\tarray io.\n\t* trans-stmt.c (trans_associate_var): Set the 'span' field.\n\t* trans-types.c (gfc_get_array_descriptor_base): Add the 'span'\n\tfield to the array descriptor.\n\t(gfc_get_derived_type): Pointer array components are marked as\n\tGFC_DECL_PTR_ARRAY_P.\n\t(gfc_get_array_descr_info): Replaced API breaking code for\n\tdescriptor offset calling gfc_get_descriptor_offsets_for_info.\n\t* trans.c (get_array_span): New function.\n\t(gfc_build_array_ref): Simplify by calling get_array_span and\n\tobtain 'span' if 'decl' or 'vptr' present.\n\t* trans.h : Rename DECL_LANG_FLAG_6, GFC_DECL_SUBREF_ARRAY_P,\n\tas GFC_DECL_PTR_ARRAY_P.\n\n\n2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34640\n\t* gfortran.dg/associate_24.f90: New test.\n\t* gfortran.dg/assumed_type_2.f90: Adjust some of the tree dump\n\tchecks.\n\t* gfortran.dg/no_arg_check_2.f90: Likewise.\n\t* gfortran.dg/pointer_array_1.f90: New test.\n\t* gfortran.dg/pointer_array_2.f90: New test.\n\t* gfortran.dg/pointer_array_7.f90: New test.\n\t* gfortran.dg/pointer_array_8.f90: New test.\n\t* gfortran.dg/pointer_array_component_1.f90: New test.\n\t* gfortran.dg/pointer_array_component_2.f90: New test.\n\t* gfortran.dg/goacc/kernels-alias-4.f95: Bump up both tree scan\n\tcounts by 1.\n\n\tPR fortran/40737\n\t* gfortran.dg/pointer_array_3.f90: New test.\n\n\tPR fortran/57116\n\t* gfortran.dg/pointer_array_4.f90: New test.\n\n\tPR fortran/55763\n\t* gfortran.dg/pointer_array_5.f90: New test.\n\n\tPR fortran/57019\n\t* gfortran.dg/pointer_array_6.f90: New test.\n\n2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/34640\n\t* libgfortran/libgfortran.h: Add span field to descriptor.\n\t* libgfortran/libtool-version : Bump up version number to 5:0:0.\n\nFrom-SVN: r251949", "tree": {"sha": "83cec48b6de78db0f46a3c655690f575a6ab84ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83cec48b6de78db0f46a3c655690f575a6ab84ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff3598bc73dbae3a612709daca41e56ab5aa6928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3598bc73dbae3a612709daca41e56ab5aa6928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff3598bc73dbae3a612709daca41e56ab5aa6928", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff3598bc73dbae3a612709daca41e56ab5aa6928/comments", "author": null, "committer": null, "parents": [{"sha": "7368cfa4986d83317fbfb839b1eeb249a9ef7199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7368cfa4986d83317fbfb839b1eeb249a9ef7199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7368cfa4986d83317fbfb839b1eeb249a9ef7199"}], "stats": {"total": 1381, "additions": 1202, "deletions": 179}, "files": [{"sha": "20fae5ae804c6a876aaf0d20542a5fe8503ad723", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1,3 +1,68 @@\n+2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34640\n+\tPR fortran/40737\n+\tPR fortran/55763\n+\tPR fortran/57019\n+\tPR fortran/57116\n+\n+\t* expr.c (is_subref_array): Add class pointer array dummies\n+\tto the list of expressions that return true.\n+\t* trans-array.c: Add SPAN_FIELD and update indices for\n+\tsubsequent fields.\n+\t(gfc_conv_descriptor_span, gfc_conv_descriptor_span_get,\n+\tgfc_conv_descriptor_span_set, is_pointer_array,\n+\tget_array_span): New functions.\n+\t(gfc_get_descriptor_offsets_for_info): New function to preserve\n+\tAPI for access to descriptor fields for trans-types.c.\n+\t(gfc_conv_scalarized_array_ref): If the expression is a subref\n+\tarray, make sure that info->descriptor is a descriptor type.\n+\tOtherwise, if info->descriptor is a pointer array, set 'decl'\n+\tand fix it if it is a component reference.\n+\t(build_array_ref): Simplify handling of class array refs by\n+\tpassing the vptr to gfc_build_array_ref rather than generating\n+\tthe pointer arithmetic in this function.\n+\t(gfc_conv_array_ref): As in gfc_conv_scalarized_array_ref, set\n+\t'decl'.\n+\t(gfc_array_allocate): Set the span field if this is a pointer\n+\tarray. Use the expr3 element size if it is available, so that\n+\tthe dynamic type element size is used.\n+\t(gfc_conv_expr_descriptor): Set the span field for pointer\n+\tassignments.\n+\t* trans-array.h: Prototypes for gfc_conv_descriptor_span_get\n+\tgfc_conv_descriptor_span_set and\n+\tgfc_get_descriptor_offsets_for_info added.\n+\ttrans-decl.c (gfc_get_symbol_decl): If a non-class pointer\n+\tarray, mark the declaration as a GFC_DECL_PTR_ARRAY_P. Remove\n+\tthe setting of GFC_DECL_SPAN.\n+\t(gfc_trans_deferred_vars): Set the span field to zero in thge\n+\toriginating scope.\n+\t* trans-expr.c (gfc_conv_procedure_call): Do not use copy-in/\n+\tcopy-out to pass subref expressions to a pointer dummy.\n+\t(gfc_trans_pointer_assignment): Remove code for setting of\n+\tGFC_DECL_SPAN. Set the 'span' field for non-class pointers to\n+\tclass function results. Likewise for rank remap. In the case\n+\tthat the target is not a whole array, use the target array ref\n+\tfor remap and, since the 'start' indices are missing, set the\n+\tlbounds to one, as required by the standard.\n+\t* trans-intrinsic.c (conv_expr_ref_to_caf_ref): Pick up the\n+\t'token' offset from the field decl in the descriptor.\n+\t(conv_isocbinding_subroutine): Set the 'span' field.\n+\t* trans-io.c (gfc_trans_transfer): Always scalarize pointer\n+\tarray io.\n+\t* trans-stmt.c (trans_associate_var): Set the 'span' field.\n+\t* trans-types.c (gfc_get_array_descriptor_base): Add the 'span'\n+\tfield to the array descriptor.\n+\t(gfc_get_derived_type): Pointer array components are marked as\n+\tGFC_DECL_PTR_ARRAY_P.\n+\t(gfc_get_array_descr_info): Replaced API breaking code for\n+\tdescriptor offset calling gfc_get_descriptor_offsets_for_info.\n+\t* trans.c (get_array_span): New function.\n+\t(gfc_build_array_ref): Simplify by calling get_array_span and\n+\tobtain 'span' if 'decl' or 'vptr' present.\n+\t* trans.h : Rename DECL_LANG_FLAG_6, GFC_DECL_SUBREF_ARRAY_P,\n+\tas GFC_DECL_PTR_ARRAY_P.\n+\n 2017-09-09  Paul Thomas  <pault@gcc.gnu.org>\n \n \t* decl.c : Add decl_type_param_list, type_param_spec_list as"}, {"sha": "35df29c66522a04ad6f7ffbae72372d8fba65882", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -995,6 +995,11 @@ is_subref_array (gfc_expr * e)\n   if (e->symtree->n.sym->attr.subref_array_pointer)\n     return true;\n \n+  if (e->symtree->n.sym->ts.type == BT_CLASS\n+      && e->symtree->n.sym->attr.dummy\n+      && CLASS_DATA (e->symtree->n.sym)->attr.class_pointer)\n+    return true;\n+\n   seen_array = false;\n   for (ref = e->ref; ref; ref = ref->next)\n     {"}, {"sha": "328da4e78b193d84caab363351826566b09c242f", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 227, "deletions": 31, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -125,8 +125,9 @@ gfc_array_dataptr_type (tree desc)\n #define DATA_FIELD 0\n #define OFFSET_FIELD 1\n #define DTYPE_FIELD 2\n-#define DIMENSION_FIELD 3\n-#define CAF_TOKEN_FIELD 4\n+#define SPAN_FIELD 3\n+#define DIMENSION_FIELD 4\n+#define CAF_TOKEN_FIELD 5\n \n #define STRIDE_SUBFIELD 0\n #define LBOUND_SUBFIELD 1\n@@ -244,6 +245,36 @@ gfc_conv_descriptor_dtype (tree desc)\n \t\t\t  desc, field, NULL_TREE);\n }\n \n+static tree\n+gfc_conv_descriptor_span (tree desc)\n+{\n+  tree type;\n+  tree field;\n+\n+  type = TREE_TYPE (desc);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n+\n+  field = gfc_advance_chain (TYPE_FIELDS (type), SPAN_FIELD);\n+  gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n+\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n+}\n+\n+tree\n+gfc_conv_descriptor_span_get (tree desc)\n+{\n+  return gfc_conv_descriptor_span (desc);\n+}\n+\n+void\n+gfc_conv_descriptor_span_set (stmtblock_t *block, tree desc,\n+\t\t\t\ttree value)\n+{\n+  tree t = gfc_conv_descriptor_span (desc);\n+  gfc_add_modify (block, t, fold_convert (TREE_TYPE (t), value));\n+}\n+\n \n tree\n gfc_conv_descriptor_rank (tree desc)\n@@ -466,11 +497,41 @@ gfc_conv_shift_descriptor_lbound (stmtblock_t* block, tree desc,\n }\n \n \n+/* Obtain offsets for trans-types.c(gfc_get_array_descr_info).  */\n+\n+void\n+gfc_get_descriptor_offsets_for_info (const_tree desc_type, tree *data_off,\n+\t\t\t\t     tree *dtype_off, tree *dim_off,\n+\t\t\t\t     tree *dim_size, tree *stride_suboff,\n+\t\t\t\t     tree *lower_suboff, tree *upper_suboff)\n+{\n+  tree field;\n+  tree type;\n+\n+  type = TYPE_MAIN_VARIANT (desc_type);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n+  *data_off = byte_position (field);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n+  *dtype_off = byte_position (field);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), DIMENSION_FIELD);\n+  *dim_off = byte_position (field);\n+  type = TREE_TYPE (TREE_TYPE (field));\n+  *dim_size = TYPE_SIZE_UNIT (type);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), STRIDE_SUBFIELD);\n+  *stride_suboff = byte_position (field);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), LBOUND_SUBFIELD);\n+  *lower_suboff = byte_position (field);\n+  field = gfc_advance_chain (TYPE_FIELDS (type), UBOUND_SUBFIELD);\n+  *upper_suboff = byte_position (field);\n+}\n+\n+\n /* Cleanup those #defines.  */\n \n #undef DATA_FIELD\n #undef OFFSET_FIELD\n #undef DTYPE_FIELD\n+#undef SPAN_FIELD\n #undef DIMENSION_FIELD\n #undef CAF_TOKEN_FIELD\n #undef STRIDE_SUBFIELD\n@@ -720,6 +781,84 @@ gfc_add_ss_to_loop (gfc_loopinfo * loop, gfc_ss * head)\n }\n \n \n+/* Returns true if the expression is an array pointer.  */\n+\n+static bool\n+is_pointer_array (tree expr)\n+{\n+  if (flag_openmp)\n+    return false;\n+\n+  if (expr == NULL_TREE\n+      || !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (expr))\n+      || GFC_CLASS_TYPE_P (TREE_TYPE (expr)))\n+    return false;\n+\n+  if (TREE_CODE (expr) == VAR_DECL\n+      && GFC_DECL_PTR_ARRAY_P (expr))\n+    return true;\n+\n+  if (TREE_CODE (expr) == PARM_DECL\n+      && GFC_DECL_PTR_ARRAY_P (expr))\n+    return true;\n+\n+  if (TREE_CODE (expr) == INDIRECT_REF\n+      && GFC_DECL_PTR_ARRAY_P (TREE_OPERAND (expr, 0)))\n+    return true;\n+\n+  /* The field declaration is marked as an pointer array.  */\n+  if (TREE_CODE (expr) == COMPONENT_REF\n+      && GFC_DECL_PTR_ARRAY_P (TREE_OPERAND (expr, 1))\n+      && !GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1))))\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Return the span of an array.  */\n+\n+static tree\n+get_array_span (tree desc, gfc_expr *expr)\n+{\n+  tree tmp;\n+\n+  if (is_pointer_array (desc))\n+    /* This will have the span field set.  */\n+    tmp = gfc_conv_descriptor_span_get (desc);\n+  else if (TREE_CODE (desc) == COMPONENT_REF\n+\t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n+\t   && GFC_CLASS_TYPE_P (TREE_TYPE (TREE_OPERAND (desc, 0))))\n+    {\n+      /* The descriptor is a class _data field and so use the vtable\n+\t size for the receiving span field.  */\n+      tmp = gfc_get_vptr_from_expr (desc);\n+      tmp = gfc_vptr_size_get (tmp);\n+    }\n+  else if (expr && expr->expr_type == EXPR_VARIABLE\n+\t   && expr->symtree->n.sym->ts.type == BT_CLASS\n+\t   && expr->ref->type == REF_COMPONENT\n+\t   && expr->ref->next->type == REF_ARRAY\n+\t   && expr->ref->next->next == NULL\n+\t   && CLASS_DATA (expr->symtree->n.sym)->attr.dimension)\n+    {\n+      /* Dummys come in sometimes with the descriptor detached from\n+\t the class field or declaration.  */\n+      tmp = gfc_class_vptr_get (expr->symtree->n.sym->backend_decl);\n+      tmp = gfc_vptr_size_get (tmp);\n+    }\n+  else\n+    {\n+      /* If none of the fancy stuff works, the span is the element\n+\t size of the array.  */\n+      tmp = gfc_get_element_type (TREE_TYPE (desc));\n+      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t  size_in_bytes (tmp));\n+    }\n+  return tmp;\n+}\n+\n+\n /* Generate an initializer for a static pointer or allocatable array.  */\n \n void\n@@ -3239,11 +3378,30 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n     index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n \t\t\t     index, info->offset);\n \n-  if (expr && (is_subref_array (expr)\n+  if (expr && ((is_subref_array (expr)\n+\t\t&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (info->descriptor)))\n \t       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE\n \t\t\t\t\t || expr->expr_type == EXPR_FUNCTION))))\n     decl = expr->symtree->n.sym->backend_decl;\n \n+  /* A pointer array component can be detected from its field decl. Fix\n+     the descriptor, mark the resulting variable decl and pass it to\n+     gfc_build_array_ref.  */\n+  if (is_pointer_array (info->descriptor))\n+    {\n+      if (TREE_CODE (info->descriptor) == COMPONENT_REF)\n+\t{\n+\t  decl = gfc_evaluate_now (info->descriptor, &se->pre);\n+\t  GFC_DECL_PTR_ARRAY_P (decl) = 1;\n+\t  TREE_USED (decl) = 1;\n+\t}\n+      else if (TREE_CODE (info->descriptor) == INDIRECT_REF)\n+\tdecl = TREE_OPERAND (info->descriptor, 0);\n+\n+      if (decl == NULL_TREE)\n+\tdecl = info->descriptor;\n+    }\n+\n   tmp = build_fold_indirect_ref_loc (input_location, info->data);\n \n   /* Use the vptr 'size' field to access a class the element of a class\n@@ -3288,45 +3446,27 @@ build_array_ref (tree desc, tree offset, tree decl, tree vptr)\n {\n   tree tmp;\n   tree type;\n-  tree cdecl;\n-  bool classarray = false;\n+  tree cdesc;\n \n   /* For class arrays the class declaration is stored in the saved\n      descriptor.  */\n   if (INDIRECT_REF_P (desc)\n       && DECL_LANG_SPECIFIC (TREE_OPERAND (desc, 0))\n       && GFC_DECL_SAVED_DESCRIPTOR (TREE_OPERAND (desc, 0)))\n-    cdecl = gfc_class_data_get (GFC_DECL_SAVED_DESCRIPTOR (\n+    cdesc = gfc_class_data_get (GFC_DECL_SAVED_DESCRIPTOR (\n \t\t\t\t  TREE_OPERAND (desc, 0)));\n   else\n-    cdecl = desc;\n+    cdesc = desc;\n \n   /* Class container types do not always have the GFC_CLASS_TYPE_P\n      but the canonical type does.  */\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (cdecl))\n-      && TREE_CODE (cdecl) == COMPONENT_REF)\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (cdesc))\n+      && TREE_CODE (cdesc) == COMPONENT_REF)\n     {\n-      type = TREE_TYPE (TREE_OPERAND (cdecl, 0));\n+      type = TREE_TYPE (TREE_OPERAND (cdesc, 0));\n       if (TYPE_CANONICAL (type)\n \t  && GFC_CLASS_TYPE_P (TYPE_CANONICAL (type)))\n-\t{\n-\t  type = TREE_TYPE (desc);\n-\t  classarray = true;\n-\t}\n-    }\n-  else\n-    type = NULL;\n-\n-  /* Class array references need special treatment because the assigned\n-     type size needs to be used to point to the element.  */\n-  if (classarray)\n-    {\n-      type = gfc_get_element_type (type);\n-      tmp = TREE_OPERAND (cdecl, 0);\n-      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE);\n-      tmp = fold_convert (build_pointer_type (type), tmp);\n-      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-      return tmp;\n+\tvptr = gfc_class_vptr_get (TREE_OPERAND (cdesc, 0));\n     }\n \n   tmp = gfc_conv_array_data (desc);\n@@ -3350,6 +3490,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n   tree offset, cst_offset;\n   tree tmp;\n   tree stride;\n+  tree decl = NULL_TREE;\n   gfc_se indexse;\n   gfc_se tmpse;\n   gfc_symbol * sym = expr->symtree->n.sym;\n@@ -3494,8 +3635,31 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n     offset = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t      gfc_array_index_type, offset, cst_offset);\n \n-  se->expr = build_array_ref (se->expr, offset, sym->ts.type == BT_CLASS ?\n-\t\t\t\tNULL_TREE : sym->backend_decl, se->class_vptr);\n+  /* A pointer array component can be detected from its field decl. Fix\n+     the descriptor, mark the resulting variable decl and pass it to\n+     build_array_ref.  */\n+  if (!expr->ts.deferred && !sym->attr.codimension\n+      && is_pointer_array (se->expr))\n+    {\n+      if (TREE_CODE (se->expr) == COMPONENT_REF)\n+\t{\n+\t  decl = gfc_evaluate_now (se->expr, &se->pre);\n+\t  GFC_DECL_PTR_ARRAY_P (decl) = 1;\n+\t  TREE_USED (decl) = 1;\n+\t}\n+      else if (TREE_CODE (se->expr) == INDIRECT_REF)\n+\tdecl = TREE_OPERAND (se->expr, 0);\n+      else\n+\tdecl = se->expr;\n+    }\n+  else if (expr->ts.deferred\n+\t   || (sym->ts.type == BT_CHARACTER\n+\t       && sym->attr.select_type_temporary))\n+    decl = sym->backend_decl;\n+  else if (sym->ts.type == BT_CLASS)\n+    decl = NULL_TREE;\n+\n+  se->expr = build_array_ref (se->expr, offset, decl, se->class_vptr);\n }\n \n \n@@ -5651,6 +5815,19 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (dimension)\n     gfc_conv_descriptor_offset_set (&set_descriptor_block, se->expr, offset);\n \n+  /* Pointer arrays need the span field to be set.  */\n+  if (is_pointer_array (se->expr)\n+      || (expr->ts.type == BT_CLASS\n+\t  && CLASS_DATA (expr)->attr.class_pointer))\n+    {\n+      if (expr3 && expr3_elem_size != NULL_TREE)\n+\ttmp = expr3_elem_size;\n+      else\n+\ttmp = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (se->expr)));\n+      tmp = fold_convert (gfc_array_index_type, tmp);\n+      gfc_conv_descriptor_span_set (&set_descriptor_block, se->expr, tmp);\n+    }\n+\n   set_descriptor = gfc_finish_block (&set_descriptor_block);\n   if (status != NULL_TREE)\n     {\n@@ -6854,6 +7031,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t      /* Add any offsets from subreferences.  */\n \t      gfc_get_dataptr_offset (&se->pre, se->expr, desc, NULL_TREE,\n \t\t\t\t      subref_array_target, expr);\n+\n+\t      /* ....and set the span field.  */\n+\t      tmp = get_array_span (desc, expr);\n+\t      gfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n \t    }\n \t  else if (se->want_pointer)\n \t    {\n@@ -6889,8 +7070,18 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t    se->ss = ss;\n \t  else\n \t    gcc_assert (se->ss == ss);\n+\n+\t  if (!is_pointer_array (se->expr))\n+\t    {\n+\t      tmp = gfc_get_element_type (TREE_TYPE (se->expr));\n+\t      tmp = fold_convert (gfc_array_index_type,\n+\t\t\t\t  size_in_bytes (tmp));\n+\t      gfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n+\t    }\n+\n \t  se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \t  gfc_conv_expr (se, expr);\n+\n \t  gfc_free_ss_chain (ss);\n \t  return;\n \t}\n@@ -7110,9 +7301,13 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       desc = info->descriptor;\n       if (se->direct_byref && !se->byref_noassign)\n \t{\n-\t  /* For pointer assignments we fill in the destination.  */\n+\t  /* For pointer assignments we fill in the destination....  */\n \t  parm = se->expr;\n \t  parmtype = TREE_TYPE (parm);\n+\n+\t  /* ....and set the span field.  */\n+\t  tmp = get_array_span (desc, expr);\n+\t  gfc_conv_descriptor_span_set (&loop.pre, parm, tmp);\n \t}\n       else\n \t{\n@@ -7585,6 +7780,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n       /* Every other type of array.  */\n       se->want_pointer = 1;\n       gfc_conv_expr_descriptor (se, expr);\n+\n       if (size)\n \tarray_parameter_size (build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t       se->expr),"}, {"sha": "e2a8737421f92eab0e1e92d61f612159ff3bbe0e", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -156,9 +156,13 @@ tree gfc_conv_array_ubound (tree, int);\n void gfc_trans_array_cobounds (tree, stmtblock_t *, const gfc_symbol *);\n \n /* Build expressions for accessing components of an array descriptor.  */\n+void gfc_get_descriptor_offsets_for_info (const_tree, tree *, tree *, tree *, tree *,\n+\t\t\t\t\t  tree *, tree *, tree *);\n+\n tree gfc_conv_descriptor_data_get (tree);\n tree gfc_conv_descriptor_data_addr (tree);\n tree gfc_conv_descriptor_offset_get (tree);\n+tree gfc_conv_descriptor_span_get (tree);\n tree gfc_conv_descriptor_dtype (tree);\n tree gfc_conv_descriptor_rank (tree);\n tree gfc_get_descriptor_dimension (tree);\n@@ -169,6 +173,7 @@ tree gfc_conv_descriptor_token (tree);\n \n void gfc_conv_descriptor_data_set (stmtblock_t *, tree, tree);\n void gfc_conv_descriptor_offset_set (stmtblock_t *, tree, tree);\n+void gfc_conv_descriptor_span_set (stmtblock_t *, tree, tree);\n void gfc_conv_descriptor_stride_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_lbound_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_ubound_set (stmtblock_t *, tree, tree, tree);"}, {"sha": "830c53ac38414c22e190f311d139aa389d6d3a24", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1532,6 +1532,9 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       /* Dummy variables should already have been created.  */\n       gcc_assert (sym->backend_decl);\n \n+      if (sym->attr.pointer && sym->attr.dimension && sym->ts.type != BT_CLASS)\n+\tGFC_DECL_PTR_ARRAY_P (sym->backend_decl) = 1;\n+\n       /* Create a character length variable.  */\n       if (sym->ts.type == BT_CHARACTER)\n \t{\n@@ -1766,27 +1769,18 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   if (sym->ts.type == BT_CHARACTER)\n     /* Character variables need special handling.  */\n     gfc_allocate_lang_decl (decl);\n-  else if (sym->attr.subref_array_pointer)\n-    /* We need the span for these beasts.  */\n-    gfc_allocate_lang_decl (decl);\n \n-  if (sym->attr.subref_array_pointer)\n-    {\n-      tree span;\n-      GFC_DECL_SUBREF_ARRAY_P (decl) = 1;\n-      span = build_decl (input_location,\n-\t\t\t VAR_DECL, create_tmp_var_name (\"span\"),\n-\t\t\t gfc_array_index_type);\n-      gfc_finish_var_decl (span, sym);\n-      TREE_STATIC (span) = TREE_STATIC (decl);\n-      DECL_ARTIFICIAL (span) = 1;\n+  if (sym->assoc && sym->attr.subref_array_pointer)\n+    sym->attr.pointer = 1;\n \n-      GFC_DECL_SPAN (decl) = span;\n-      GFC_TYPE_ARRAY_SPAN (TREE_TYPE (decl)) = span;\n-    }\n+  if (sym->attr.pointer && sym->attr.dimension\n+      && !sym->ts.deferred\n+      && !(sym->attr.select_type_temporary\n+\t   && !sym->attr.subref_array_pointer))\n+    GFC_DECL_PTR_ARRAY_P (decl) = 1;\n \n   if (sym->ts.type == BT_CLASS)\n-\tGFC_DECL_CLASS(decl) = 1;\n+    GFC_DECL_CLASS(decl) = 1;\n \n   sym->backend_decl = decl;\n \n@@ -4347,13 +4341,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t    }\n \t}\n \n-      if (sym->attr.subref_array_pointer\n-\t  && GFC_DECL_SPAN (sym->backend_decl)\n-\t  && !TREE_STATIC (GFC_DECL_SPAN (sym->backend_decl)))\n+      if (sym->attr.pointer && sym->attr.dimension\n+\t  && !sym->attr.use_assoc\n+\t  && !sym->attr.host_assoc\n+\t  && !sym->attr.dummy\n+\t  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (sym->backend_decl)))\n \t{\n \t  gfc_init_block (&tmpblock);\n-\t  gfc_add_modify (&tmpblock, GFC_DECL_SPAN (sym->backend_decl),\n-\t\t\t  build_int_cst (gfc_array_index_type, 0));\n+\t  gfc_conv_descriptor_span_set (&tmpblock, sym->backend_decl,\n+\t\t\t\tbuild_int_cst (gfc_array_index_type, 0));\n \t  gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock),\n \t\t\t\tNULL_TREE);\n \t}"}, {"sha": "8c8569f1d86497414d55e597600d34b9f207f3b4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -5413,7 +5413,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \n \t      if (e->expr_type == EXPR_VARIABLE\n-\t\t    && is_subref_array (e))\n+\t\t    && is_subref_array (e)\n+\t\t    && !(fsym && fsym->attr.pointer))\n \t\t/* The actual argument is a component reference to an\n \t\t   array of derived types.  In this case, the argument\n \t\t   is converted to a temporary, which is passed and then\n@@ -8223,7 +8224,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n   stmtblock_t block;\n   tree desc;\n   tree tmp;\n-  tree decl;\n   bool scalar, non_proc_pointer_assign;\n   gfc_ss *ss;\n \n@@ -8412,30 +8412,24 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gfc_conv_expr_descriptor (&lse, expr2);\n \t  strlen_rhs = lse.string_length;\n \n-\t  /* If this is a subreference array pointer assignment, use the rhs\n-\t     descriptor element size for the lhs span.  */\n-\t  if (expr1->symtree->n.sym->attr.subref_array_pointer)\n-\t    {\n-\t      decl = expr1->symtree->n.sym->backend_decl;\n-\t      gfc_init_se (&rse, NULL);\n-\t      rse.descriptor_only = 1;\n-\t      gfc_conv_expr (&rse, expr2);\n-\t      if (expr1->ts.type == BT_CLASS)\n-\t\ttrans_class_vptr_len_assignment (&block, expr1, expr2, &rse,\n-\t\t\t\t\t\t NULL, NULL);\n-\t      tmp = gfc_get_element_type (TREE_TYPE (rse.expr));\n-\t      tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n-\t      if (!INTEGER_CST_P (tmp))\n-\t\tgfc_add_block_to_block (&lse.post, &rse.pre);\n-\t      gfc_add_modify (&lse.post, GFC_DECL_SPAN(decl), tmp);\n-\t    }\n-\t  else if (expr1->ts.type == BT_CLASS)\n+\t  if (expr1->ts.type == BT_CLASS)\n \t    {\n \t      rse.expr = NULL_TREE;\n \t      rse.string_length = NULL_TREE;\n \t      trans_class_vptr_len_assignment (&block, expr1, expr2, &rse,\n \t\t\t\t\t       NULL, NULL);\n \t    }\n+\n+\t  if (remap == NULL)\n+\t    {\n+\t      /* If the target is not a whole array, use the target array\n+\t\t reference for remap.  */\n+\t      for (remap = expr2->ref; remap; remap = remap->next)\n+\t\tif (remap->type == REF_ARRAY\n+\t\t    && remap->u.ar.type == AR_FULL\n+\t\t    && remap->next)\n+\t\t  break;\n+\t    }\n \t}\n       else if (expr2->expr_type == EXPR_FUNCTION && expr2->ts.type == BT_CLASS)\n \t{\n@@ -8446,7 +8440,12 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    {\n \t      rse.expr = gfc_class_data_get (rse.expr);\n \t      gfc_add_modify (&lse.pre, desc, rse.expr);\n-\t    }\n+\t      /* Set the lhs span.  */\n+\t      tmp = TREE_TYPE (rse.expr);\n+\t      tmp = TYPE_SIZE_UNIT (gfc_get_element_type (tmp));\n+\t      tmp = fold_convert (gfc_array_index_type, tmp);\n+\t      gfc_conv_descriptor_span_set (&lse.pre, desc, tmp);\n+ \t    }\n \t  else\n \t    {\n \t      expr1_vptr = trans_class_vptr_len_assignment (&block, expr1,\n@@ -8492,7 +8491,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t converted in rse and now have to build the correct LHS\n \t\t descriptor for it.  */\n \n-\t      tree dtype, data;\n+\t      tree dtype, data, span;\n \t      tree offs, stride;\n \t      tree lbound, ubound;\n \n@@ -8505,6 +8504,18 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t      data = gfc_conv_descriptor_data_get (rse.expr);\n \t      gfc_conv_descriptor_data_set (&block, desc, data);\n \n+\t      /* Copy the span.  */\n+\t      if (TREE_CODE (rse.expr) == VAR_DECL\n+\t\t  && GFC_DECL_PTR_ARRAY_P (rse.expr))\n+\t\tspan = gfc_conv_descriptor_span_get (rse.expr);\n+\t      else\n+\t\t{\n+\t\t  tmp = TREE_TYPE (rse.expr);\n+\t\t  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (tmp));\n+\t\t  span = fold_convert (gfc_array_index_type, tmp);\n+\t\t}\n+\t      gfc_conv_descriptor_span_set (&block, desc, span);\n+\n \t      /* Copy offset but adjust it such that it would correspond\n \t\t to a lbound of zero.  */\n \t      offs = gfc_conv_descriptor_offset_get (rse.expr);\n@@ -8586,12 +8597,18 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t{\n \t\t  gfc_se lbound_se;\n \n-\t\t  gcc_assert (remap->u.ar.start[dim]);\n \t\t  gcc_assert (!remap->u.ar.end[dim]);\n \t\t  gfc_init_se (&lbound_se, NULL);\n-\t\t  gfc_conv_expr (&lbound_se, remap->u.ar.start[dim]);\n-\n-\t\t  gfc_add_block_to_block (&block, &lbound_se.pre);\n+\t\t  if (remap->u.ar.start[dim])\n+\t\t    {\n+\t\t      gfc_conv_expr (&lbound_se, remap->u.ar.start[dim]);\n+\t\t      gfc_add_block_to_block (&block, &lbound_se.pre);\n+\t\t    }\n+\t\t  else\n+\t\t    /* This remap arises from a target that is not a whole\n+\t\t       array. The start expressions will be NULL but we need\n+\t\t       the lbounds to be one.  */\n+\t\t    lbound_se.expr = gfc_index_one_node;\n \t\t  gfc_conv_shift_descriptor_lbound (&block, desc,\n \t\t\t\t\t\t    dim, lbound_se.expr);\n \t\t  gfc_add_block_to_block (&block, &lbound_se.post);"}, {"sha": "9bc465e43d93d0a6c8dd698b5d5a02624218f499", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1225,10 +1225,9 @@ conv_expr_ref_to_caf_ref (stmtblock_t *block, gfc_expr *expr)\n \t      && ref->u.c.component->attr.dimension)\n \t    {\n \t      tree arr_desc_token_offset;\n-\t      /* Get the token from the descriptor.  */\n-\t      arr_desc_token_offset = gfc_advance_chain (\n-\t\t    TYPE_FIELDS (TREE_TYPE (ref->u.c.component->backend_decl)),\n-\t\t    4 /* CAF_TOKEN_FIELD  */);\n+\t      /* Get the token field from the descriptor.  */\n+\t      arr_desc_token_offset = TREE_OPERAND (\n+\t\t    gfc_conv_descriptor_token (ref->u.c.component->backend_decl), 1);\n \t      arr_desc_token_offset\n \t\t  = compute_component_offset (arr_desc_token_offset,\n \t\t\t\t\t      TREE_TYPE (tmp));\n@@ -8129,6 +8128,11 @@ conv_isocbinding_subroutine (gfc_code *code)\n   gfc_add_block_to_block (&block, &fptrse.pre);\n   desc = fptrse.expr;\n \n+  /* Set the span field.  */\n+  tmp = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n+  tmp = fold_convert (gfc_array_index_type, tmp);\n+  gfc_conv_descriptor_span_set (&block, desc, tmp);\n+\n   /* Set data value, dtype, and offset.  */\n   tmp = GFC_TYPE_ARRAY_DATAPTR_TYPE (TREE_TYPE (desc));\n   gfc_conv_descriptor_data_set (&block, desc, fold_convert (tmp, cptrse.expr));"}, {"sha": "026f9a993d2b49f5e95b6ec0df8109c59bdc849a", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -2569,6 +2569,12 @@ gfc_trans_transfer (gfc_code * code)\n \t  gcc_assert (ref && ref->type == REF_ARRAY);\n \t}\n \n+      if (expr->ts.type != BT_CLASS\n+\t && expr->expr_type == EXPR_VARIABLE\n+\t && gfc_expr_attr (expr).pointer)\n+\tgoto scalarize;\n+\n+\n       if (!(gfc_bt_struct (expr->ts.type)\n \t      || expr->ts.type == BT_CLASS)\n \t    && ref && ref->next == NULL\n@@ -2603,6 +2609,7 @@ gfc_trans_transfer (gfc_code * code)\n \t  goto finish_block_label;\n \t}\n \n+scalarize:\n       /* Initialize the scalarizer.  */\n       ss = gfc_walk_expr (expr);\n       gfc_init_loopinfo (&loop);\n@@ -2618,7 +2625,9 @@ gfc_trans_transfer (gfc_code * code)\n \n       gfc_copy_loopinfo_to_se (&se, &loop);\n       se.ss = ss;\n+\n       gfc_conv_expr_reference (&se, expr);\n+\n       if (expr->ts.type == BT_CLASS)\n \tvptr = gfc_get_vptr_from_expr (ss->info->data.array.descriptor);\n       else"}, {"sha": "925ea636258d4617b983c49e583648553e6df96d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1531,6 +1531,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   int n;\n   tree charlen;\n   bool need_len_assign;\n+  bool whole_array = true;\n+  gfc_ref *ref;\n \n   gcc_assert (sym->assoc);\n   e = sym->assoc->target;\n@@ -1541,6 +1543,15 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \n   unlimited = UNLIMITED_POLY (e);\n \n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY\n+\t&& ref->u.ar.type == AR_FULL\n+\t&& ref->next)\n+      {\n+\twhole_array =  false;\n+\tbreak;\n+      }\n+\n   /* Assignments to the string length need to be generated, when\n      ( sym is a char array or\n        sym has a _len component)\n@@ -1583,11 +1594,13 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \n       /* If we didn't already do the pointer assignment, set associate-name\n \t descriptor to the one generated for the temporary.  */\n-      if (!sym->assoc->variable && !cst_array_ctor)\n+      if ((!sym->assoc->variable && !cst_array_ctor)\n+\t  || !whole_array)\n \t{\n \t  int dim;\n \n-\t  gfc_add_modify (&se.pre, desc, se.expr);\n+\t  if (whole_array)\n+\t    gfc_add_modify (&se.pre, desc, se.expr);\n \n \t  /* The generated descriptor has lower bound zero (as array\n \t     temporary), shift bounds so we get lower bounds of 1.  */\n@@ -1606,7 +1619,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t      : e->symtree->n.sym->backend_decl;\n \t  tmp = gfc_get_element_type (TREE_TYPE (tmp));\n \t  tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n-\t  gfc_add_modify (&se.pre, GFC_DECL_SPAN(desc), tmp);\n+\t  gfc_conv_descriptor_span_set (&se.pre, desc, tmp);\n \t}\n \n       /* Done, register stuff as init / cleanup code.  */"}, {"sha": "b106794205b9a7625bf07938e5a30cb1187b1d2b", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\t/* For rest_of_decl_compilation.  */\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n+#include \"trans-array.h\"\n #include \"dwarf2out.h\"\t/* For struct array_descr_info.  */\n #include \"attribs.h\"\n \f\n@@ -1786,6 +1787,12 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted)\n \t\t\t\t    gfc_array_index_type, &chain);\n   TREE_NO_WARNING (decl) = 1;\n \n+  /* Add the span component.  */\n+  decl = gfc_add_field_to_struct_1 (fat_type,\n+\t\t\t\t    get_identifier (\"span\"),\n+\t\t\t\t    gfc_array_index_type, &chain);\n+  TREE_NO_WARNING (decl) = 1;\n+\n   /* Build the array type for the stride and bound components.  */\n   if (dimen + codimen > 0)\n     {\n@@ -2715,6 +2722,11 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n       if (!c->backend_decl)\n \tc->backend_decl = field;\n \n+      if (c->attr.pointer && c->attr.dimension\n+\t  && !(c->ts.type == BT_DERIVED\n+\t       && strcmp (c->name, \"_data\") == 0))\n+\tGFC_DECL_PTR_ARRAY_P (c->backend_decl) = 1;\n+\n       /* Do not add a caf_token field for classes' data components.  */\n       if (codimen && !c->attr.dimension && !c->attr.codimension\n \t  && (c->attr.allocatable || c->attr.pointer)\n@@ -3154,7 +3166,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n {\n   int rank, dim;\n   bool indirect = false;\n-  tree etype, ptype, field, t, base_decl;\n+  tree etype, ptype, t, base_decl;\n   tree data_off, dim_off, dtype_off, dim_size, elem_size;\n   tree lower_suboff, upper_suboff, stride_suboff;\n \n@@ -3211,24 +3223,11 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   if (indirect)\n     base_decl = build1 (INDIRECT_REF, ptype, base_decl);\n \n-  if (GFC_TYPE_ARRAY_SPAN (type))\n-    elem_size = GFC_TYPE_ARRAY_SPAN (type);\n-  else\n-    elem_size = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (etype));\n-  field = TYPE_FIELDS (TYPE_MAIN_VARIANT (type));\n-  data_off = byte_position (field);\n-  field = DECL_CHAIN (field);\n-  field = DECL_CHAIN (field);\n-  dtype_off = byte_position (field);\n-  field = DECL_CHAIN (field);\n-  dim_off = byte_position (field);\n-  dim_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (field)));\n-  field = TYPE_FIELDS (TREE_TYPE (TREE_TYPE (field)));\n-  stride_suboff = byte_position (field);\n-  field = DECL_CHAIN (field);\n-  lower_suboff = byte_position (field);\n-  field = DECL_CHAIN (field);\n-  upper_suboff = byte_position (field);\n+  elem_size = fold_convert (gfc_array_index_type, TYPE_SIZE_UNIT (etype));\n+\n+  gfc_get_descriptor_offsets_for_info (type, &data_off, &dtype_off, &dim_off,\n+\t\t\t\t       &dim_size, &stride_suboff,\n+\t\t\t\t       &lower_suboff, &upper_suboff);\n \n   t = base_decl;\n   if (!integer_zerop (data_off))"}, {"sha": "149f482586f992705ca9e681a3fef19b99bcebfe", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -305,14 +305,75 @@ gfc_build_addr_expr (tree type, tree t)\n }\n \n \n+static tree\n+get_array_span (tree type, tree decl)\n+{\n+  tree span;\n+\n+  /* Return the span for deferred character length array references.  */\n+  if (type && TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n+      && (VAR_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF)\n+      && (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || DECL_CONTEXT (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t\t\t\t\t== DECL_CONTEXT (decl)))\n+    {\n+      span = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+      span = fold_convert (gfc_array_index_type, span);\n+    }\n+  /* Likewise for class array or pointer array references.  */\n+  else if (TREE_CODE (decl) == FIELD_DECL\n+\t   || VAR_OR_FUNCTION_DECL_P (decl)\n+\t   || TREE_CODE (decl) == PARM_DECL)\n+    {\n+      if (GFC_DECL_CLASS (decl))\n+\t{\n+\t  /* When a temporary is in place for the class array, then the\n+\t     original class' declaration is stored in the saved\n+\t     descriptor.  */\n+\t  if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+\t    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+\t  else\n+\t    {\n+\t      /* Allow for dummy arguments and other good things.  */\n+\t      if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+\t\tdecl = build_fold_indirect_ref_loc (input_location, decl);\n+\n+\t      /* Check if '_data' is an array descriptor.  If it is not,\n+\t\t the array must be one of the components of the class\n+\t\t object, so return a null span.  */\n+\t      if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (\n+\t\t\t\t\t  gfc_class_data_get (decl))))\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  span = gfc_class_vtab_size_get (decl);\n+\t}\n+      else if (GFC_DECL_PTR_ARRAY_P (decl))\n+\t{\n+\t  if (TREE_CODE (decl) == PARM_DECL)\n+\t    decl = build_fold_indirect_ref_loc (input_location, decl);\n+\t  span = gfc_conv_descriptor_span_get (decl);\n+\t}\n+      else\n+\tspan = NULL_TREE;\n+    }\n+  else\n+    span = NULL_TREE;\n+\n+  return span;\n+}\n+\n+\n /* Build an ARRAY_REF with its natural type.  */\n \n tree\n gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n {\n   tree type = TREE_TYPE (base);\n   tree tmp;\n-  tree span;\n+  tree span = NULL_TREE;\n \n   if (GFC_ARRAY_TYPE_P (type) && GFC_TYPE_ARRAY_RANK (type) == 0)\n     {\n@@ -331,77 +392,23 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n \n   type = TREE_TYPE (type);\n \n-  /* Use pointer arithmetic for deferred character length array\n-     references.  */\n-  if (type && TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n-      && (VAR_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t  || TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF)\n-      && decl\n-      && (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) == INDIRECT_REF\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || (DECL_CONTEXT (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t      == DECL_CONTEXT (decl))))\n-    span = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-  else\n-    span = NULL_TREE;\n-\n   if (DECL_P (base))\n     TREE_ADDRESSABLE (base) = 1;\n \n   /* Strip NON_LVALUE_EXPR nodes.  */\n   STRIP_TYPE_NOPS (offset);\n \n-  /* If the array reference is to a pointer, whose target contains a\n-     subreference, use the span that is stored with the backend decl\n-     and reference the element with pointer arithmetic.  */\n-  if ((decl && (TREE_CODE (decl) == FIELD_DECL\n-\t\t|| VAR_OR_FUNCTION_DECL_P (decl)\n-\t\t|| TREE_CODE (decl) == PARM_DECL)\n-       && ((GFC_DECL_SUBREF_ARRAY_P (decl)\n-\t    && !integer_zerop (GFC_DECL_SPAN (decl)))\n-\t   || GFC_DECL_CLASS (decl)\n-\t   || span != NULL_TREE))\n-      || vptr != NULL_TREE)\n-    {\n-      if (decl)\n-\t{\n-\t  if (GFC_DECL_CLASS (decl))\n-\t    {\n-\t      /* When a temporary is in place for the class array, then the\n-\t\t original class' declaration is stored in the saved\n-\t\t descriptor.  */\n-\t      if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n-\t\tdecl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n-\t      else\n-\t\t{\n-\t\t  /* Allow for dummy arguments and other good things.  */\n-\t\t  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n-\t\t    decl = build_fold_indirect_ref_loc (input_location, decl);\n-\n-\t\t  /* Check if '_data' is an array descriptor.  If it is not,\n-\t\t     the array must be one of the components of the class\n-\t\t     object, so return a normal array reference.  */\n-\t\t  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (\n-\t\t\t\t\t\tgfc_class_data_get (decl))))\n-\t\t    return build4_loc (input_location, ARRAY_REF, type, base,\n-\t\t\t\t       offset, NULL_TREE, NULL_TREE);\n-\t\t}\n-\n-\t      span = gfc_class_vtab_size_get (decl);\n-\t    }\n-\t  else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n-\t    span = GFC_DECL_SPAN (decl);\n-\t  else if (span)\n-\t    span = fold_convert (gfc_array_index_type, span);\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-      else if (vptr)\n-\tspan = gfc_vptr_size_get (vptr);\n-      else\n-\tgcc_unreachable ();\n+  /* If decl or vptr are non-null, pointer arithmetic for the array reference\n+     is likely. Generate the 'span' for the array reference.  */\n+  if (vptr)\n+    span = gfc_vptr_size_get (vptr);\n+  else if (decl)\n+    span = get_array_span (type, decl);\n \n+  /* If a non-null span has been generated reference the element with\n+     pointer arithmetic.  */\n+  if (span != NULL_TREE)\n+    {\n       offset = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\tgfc_array_index_type,\n \t\t\t\toffset, span);\n@@ -412,8 +419,8 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n \ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n       return tmp;\n     }\n+  /* Otherwise use a straightforward array reference.  */\n   else\n-    /* Otherwise use a straightforward array reference.  */\n     return build4_loc (input_location, ARRAY_REF, type, base, offset,\n \t\t       NULL_TREE, NULL_TREE);\n }"}, {"sha": "c970ace86f997a52d0de175a3b47d34001699582", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -982,7 +982,7 @@ struct GTY(()) lang_decl {\n #define GFC_DECL_COMMON_OR_EQUIV(node) DECL_LANG_FLAG_3(node)\n #define GFC_DECL_CRAY_POINTEE(node) DECL_LANG_FLAG_4(node)\n #define GFC_DECL_RESULT(node) DECL_LANG_FLAG_5(node)\n-#define GFC_DECL_SUBREF_ARRAY_P(node) DECL_LANG_FLAG_6(node)\n+#define GFC_DECL_PTR_ARRAY_P(node) DECL_LANG_FLAG_6(node)\n #define GFC_DECL_ASSOCIATE_VAR_P(node) DECL_LANG_FLAG_7(node)\n #define GFC_DECL_CLASS(node) DECL_LANG_FLAG_8(node)\n "}, {"sha": "10f56bd5987f52e0a2b8ebbc4bd4d512bf3d179d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1,3 +1,31 @@\n+2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34640\n+\t* gfortran.dg/associate_24.f90: New test.\n+\t* gfortran.dg/assumed_type_2.f90: Adjust some of the tree dump\n+\tchecks.\n+\t* gfortran.dg/no_arg_check_2.f90: Likewise.\n+\t* gfortran.dg/pointer_array_1.f90: New test.\n+\t* gfortran.dg/pointer_array_2.f90: New test.\n+\t* gfortran.dg/pointer_array_7.f90: New test.\n+\t* gfortran.dg/pointer_array_8.f90: New test.\n+\t* gfortran.dg/pointer_array_component_1.f90: New test.\n+\t* gfortran.dg/pointer_array_component_2.f90: New test.\n+\t* gfortran.dg/goacc/kernels-alias-4.f95: Bump up both tree scan\n+\tcounts by 1.\n+\n+\tPR fortran/40737\n+\t* gfortran.dg/pointer_array_3.f90: New test.\n+\n+\tPR fortran/57116\n+\t* gfortran.dg/pointer_array_4.f90: New test.\n+\n+\tPR fortran/55763\n+\t* gfortran.dg/pointer_array_5.f90: New test.\n+\n+\tPR fortran/57019\n+\t* gfortran.dg/pointer_array_6.f90: New test.\n+\n 2017-09-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR c++/81852"}, {"sha": "94ba378b6e52fd53b478496748e79387b5ea3bf1", "filename": "gcc/testsuite/gfortran.dg/associate_24.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_24.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_24.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_24.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+!\n+! From posting by Spectrum to clf on thread entitled \"Bounds for array pointer dummy argument\".\n+!\n+PROGRAM X\n+    implicit none\n+    TYPE T\n+        INTEGER :: I\n+    END TYPE T\n+    TYPE(T), TARGET :: T1( 0:3 )\n+\n+    associate( P => T1 % I )\n+        call check (lbound (P, 1), ubound (P, 1) ,1 , 4)\n+    endassociate\n+\n+    associate( P2 => T1(:) % I )\n+        call check (lbound (P2, 1), ubound (P2, 1) ,1 , 4)\n+    endassociate\n+\n+    associate( Q => T1 )\n+        call check (lbound (Q, 1), ubound (Q, 1) ,0 , 3)\n+    endassociate\n+\n+    associate( Q2 => T1(:) )\n+        call check (lbound (Q2, 1), ubound (Q2, 1) ,1 , 4)\n+    endassociate\n+contains\n+    subroutine check (lbnd, ubnd, lower, upper)\n+      integer :: lbnd, ubnd, lower, upper\n+      if (lbnd .ne. lower) call abort\n+      if (ubnd .ne. upper) call abort\n+    end subroutine\n+END PROGRAM X"}, {"sha": "a0e1bc1b19c3b7b1ebb9a2deb8369c517ea1d11b", "filename": "gcc/testsuite/gfortran.dg/assumed_type_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_2.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -151,9 +151,9 @@ end subroutine sub_array_assumed\n ! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(real.kind=4..0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(character.kind=1..0:..1:1. .\\\\) array_char_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(character.kind=1..1:1. .\\\\) .array_char_ptr.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t3.0:. .\\\\) array_t3_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t3 .\\\\) .array_t3_ptr.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_alloc._data.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) \\\\(array_class_t1_ptr._data.dat\" 1 \"original\" } }\n "}, {"sha": "415eb96344a52025de8f287da22924a8d2e1d571", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-alias-4.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-alias-4.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-alias-4.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-alias-4.f95?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -16,5 +16,5 @@ program main\n end program main\n \n ! Only the omp_data_i related loads should be annotated with cliques.\n-! { dg-final { scan-tree-dump-times \"clique 1 base 1\" 3 \"ealias\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)clique 1 base 0\" 4 \"ealias\" } }\n+! { dg-final { scan-tree-dump-times \"clique 1 base 1\" 4 \"ealias\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)clique 1 base 0\" 5 \"ealias\" } }"}, {"sha": "90e4c8cd51582bc98c7d06c8ccb8647546d2f113", "filename": "gcc/testsuite/gfortran.dg/no_arg_check_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fno_arg_check_2.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -133,9 +133,9 @@ end subroutine sub\n ! { dg-final { scan-tree-dump-times \"sub_scalar .&scalar_t1,\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(real.kind=4..0:. . restrict\\\\) array_real_alloc.data\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(character.kind=1..0:..1:1. .\\\\) array_char_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(character.kind=1..1:1. .\\\\) .array_char_ptr.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t2.0:. . restrict\\\\) array_t2_alloc.data\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"sub_scalar .&\\\\(.\\\\(struct t3.0:. .\\\\) array_t3_ptr.data\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t3 .\\\\) .array_t3_ptr.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) array_class_t1_alloc._data.data\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"sub_scalar .\\\\(struct t1 .\\\\) \\\\(array_class_t1_ptr._data.dat\" 1 \"original\" } }\n "}, {"sha": "b43101fb31b4c028b404df4b58d7b5172810bcaa", "filename": "gcc/testsuite/gfortran.dg/pointer_array_1.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_1.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+!\n+! Check the fix for PR34640 comments 1 and 3.\n+!\n+! This involves passing and returning pointer array components that\n+! point to components of arrays of derived types.\n+!\n+MODULE test\n+  IMPLICIT NONE\n+  TYPE :: my_type\n+    INTEGER :: value\n+    integer :: tag\n+  END TYPE\n+CONTAINS\n+  SUBROUTINE get_values(values, switch)\n+    INTEGER, POINTER :: values(:)\n+    integer :: switch\n+    TYPE(my_type), POINTER :: d(:)\n+    allocate (d, source = [my_type(1,101), my_type(2,102)])\n+    if (switch .eq. 1) then\n+      values => d(:)%value\n+      if (any (values .ne. [1,2])) print *, values(2)\n+    else\n+      values => d(:)%tag\n+      if (any (values .ne. [101,102])) call abort\n+    end if\n+  END SUBROUTINE\n+\n+  function return_values(switch) result (values)\n+    INTEGER, POINTER :: values(:)\n+    integer :: switch\n+    TYPE(my_type), POINTER :: d(:)\n+    allocate (d, source = [my_type(1,101), my_type(2,102)])\n+    if (switch .eq. 1) then\n+      values => d(:)%value\n+      if (any (values .ne. [1,2])) call abort\n+    else\n+      values => d(:)%tag\n+      if (any (values([2,1]) .ne. [102,101])) call abort\n+    end if\n+  END function\n+END MODULE\n+\n+  use test\n+  integer, pointer :: x(:)\n+  type :: your_type\n+    integer, pointer :: x(:)\n+  end type\n+  type(your_type) :: y\n+\n+  call get_values (x, 1)\n+  if (any (x .ne. [1,2])) call abort\n+  call get_values (y%x, 2)\n+  if (any (y%x .ne. [101,102])) call abort\n+\n+  x => return_values (2)\n+  if (any (x .ne. [101,102])) call abort\n+  y%x => return_values (1)\n+  if (any (y%x .ne. [1,2])) call abort\n+end"}, {"sha": "1f9c13796a4151e3205d326dfd2375b110ff8bf4", "filename": "gcc/testsuite/gfortran.dg/pointer_array_2.f90", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_2.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR40737 as part of the overall fix for PR34640.\n+!\n+! Contributed by David Hough  <dh458@oakapple.net>\n+!\n+module testmod\n+\n+integer, parameter :: standard_integer = 1\n+integer, parameter :: int = KIND( standard_integer)\n+\n+integer, parameter :: i8  = selected_int_kind(12)\n+integer, parameter :: i4  = selected_int_kind(8)\n+integer, parameter :: i2  = selected_int_kind(4)\n+\n+integer, parameter :: standard_real = 1.\n+integer, parameter :: std_real = KIND( standard_real)\n+\n+integer, parameter :: r8  = selected_real_kind(12)\n+integer, parameter :: r4  = selected_real_kind(6)\n+integer, parameter :: double  = selected_real_kind(20)\n+\n+integer, parameter :: name_string_length = 40\n+integer, parameter :: file_name_length = 60\n+integer, parameter :: text_string_length = 80\n+integer, parameter :: max_kwd_lgth = file_name_length\n+\n+integer(int) :: bytes_per_int  = 4\n+integer(int) :: bytes_per_real = 8\n+integer(int) :: workcomm, spincomm\n+\n+   integer(int), parameter :: nb_directions = 3,  &\n+                              direction_x = 1,    &\n+                              direction_y = 2,    &\n+                              direction_z = 3,    &\n+                              nb_ghost_cells = 5     ! might be different for the lagrange step?\n+\n+   integer(int), parameter :: ends = 4,            &\n+                              lower_ghost = 1,     &\n+                              lower_interior = 2,  &\n+                              upper_interior = 3,  &\n+                              upper_ghost = 4\n+\n+   ! Neighbors\n+   integer(int), parameter :: side = 2,       &\n+                              lower_end = 1,  &\n+                              upper_end = 2\n+\n+\n+   integer(int), parameter :: nb_variables = 5,    &\n+                              ro_var = 1,          &\n+                              ets_var = 2,         &\n+                              u_var = 3,           &\n+                              up1_var = 4,         &\n+                              up2_var = 5,         &\n+                              eis_var = 6,         &\n+                              ecs_var = 7,         &\n+                              p_var = 8,           &\n+                              c_var = 9,           &\n+                              nb_var_sortie = 9\n+\n+   type :: VARIABLES_LIGNE\n+      sequence\n+      real, pointer, dimension( :, :) :: l\n+   end type VARIABLES_LIGNE\n+\n+   type VARIABLES_MAILLE\n+      sequence\n+      real(r8), dimension( nb_variables) :: cell_var\n+   end type VARIABLES_MAILLE\n+\n+   integer(int), dimension( nb_directions) :: &\n+         first_real_cell,    &  ! without ghost cells\n+         last_real_cell,     &  !\n+         nb_real_cells,      &  !\n+         first_work_cell,    &  ! including ghost cells\n+         last_work_cell,     &  !\n+         nb_work_cells,      &  !\n+         global_nb_cells        ! number of real cells, for the entire grid\n+\n+   integer(int) :: dim_probleme  ! dimension du probleme (1, 2 ou 3)\n+\n+   integer(int) :: largest_local_size   ! the largest of the 3 dimensions of the local grid\n+\n+   ! Hydro variables of the actual domain\n+   ! There are 3 copies of these, for use according to current work direction\n+   type (VARIABLES_MAILLE), allocatable, target, dimension( :, :, :) ::  &\n+            Hydro_vars_XYZ,  &\n+            Hydro_vars_YZX,  &\n+            Hydro_vars_ZXY\n+\n+   ! Pointers to current and next Hydro var arrays\n+   type (VARIABLES_MAILLE), pointer, dimension( :, :, :) :: Hydro_vars,      &\n+                                                            Hydro_vars_next\n+\n+   ! Which of these 3 copies of the 3D arrays has been updated last\n+   integer(int) :: last_updated_3D_array = 0\n+\n+   real(r8), pointer, dimension( :) ::        &\n+         ! Variables \"permanentes\" (entrant dans la projection)\n+         Ro,      & ! densite\n+         Ets,     & ! energie totale specifique\n+         Um,      & ! vitesse aux mailles, dans la direction de travail\n+         Xn,      & ! abscisse en fin de pas de temps\n+         ! Variables en lecture seulement\n+         Um_p1,   & ! vitesse aux mailles, dans les directions\n+         Um_p2,   & !                      orthogonales\n+         Xa,      & ! abscisses des noeuds en debut de pas de temps\n+         Dxa,     & ! longueur des mailles en debut de pas de temps\n+         U_dxa      ! inverses des longueurs des mailles\n+\n+end module testmod\n+\n+\n+subroutine TF_AD_SPLITTING_DRIVER_PLANE\n+\n+use testmod\n+\n+implicit none\n+save\n+\n+   real(r8), allocatable, dimension( :) ::  &\n+         ! Variables maille recalculees a chaque pas de temps\n+         Eis,     & ! energie interne specifique (seulement pour calculer la pression)\n+         Vit_son, & ! comme son nom l'indique\n+         C_f_l,   & ! nombre de Courant\n+         Pm,      & ! pression aux mailles\n+         ! Variables aux noeuds\n+         Un,      & ! vitesse des noeuds\n+         Pn         ! pression aux noeuds\n+\n+\n+integer(int) :: i, j, k\n+integer(int) :: first_cell, last_cell\n+\n+         Ro => Hydro_vars( first_cell:last_cell, j, k)%cell_var( ro_var)\n+         Ets => Hydro_vars( first_cell:last_cell, j, k)%cell_var( ets_var)\n+         Um => Hydro_vars( first_cell:last_cell, j, k)%cell_var( u_var)\n+         Um_p1 => Hydro_vars( first_cell:last_cell, j, k)%cell_var( up1_var)\n+         Um_p2 => Hydro_vars( first_cell:last_cell, j, k)%cell_var( up2_var)\n+\n+end subroutine TF_AD_SPLITTING_DRIVER_PLANE\n+"}, {"sha": "d760167b76f92db229772595ddb8381a9820cd8f", "filename": "gcc/testsuite/gfortran.dg/pointer_array_3.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_3.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR40737 comment 17 as part of the overall fix for PR34640.\n+!\n+! Contributed by Josh Hykes  <joshuahykes@yahoo.com>\n+!\n+   module test_mod\n+!\n+   type t1\n+      character(8)  :: string\n+   end type t1\n+!\n+   type t2\n+     integer :: tab\n+     type(t1), pointer :: fp(:)\n+   end type t2\n+!\n+   type t3\n+      integer :: tab\n+      type(t2), pointer :: as\n+   end type t3\n+!\n+   type(t3), pointer :: as_typ(:) => null()\n+!\n+   character(8),  pointer, public :: p(:)\n+!\n+   contains\n+!\n+   subroutine as_set_alias (i)\n+!\n+   implicit none\n+!\n+   integer, intent(in)    :: i\n+!\n+     allocate (as_typ(2))\n+     allocate (as_typ(1)%as)\n+     allocate (as_typ(1)%as%fp(2), source = [t1(\"abcdefgh\"),t1(\"ijklmnop\")])\n+     p => as_typ(i)%as%fp(:)%string\n+!\n+   end subroutine as_set_alias\n+!\n+   end module test_mod\n+\n+   program test_prog\n+   use test_mod\n+   call as_set_alias(1)\n+   if (any (p .ne. [\"abcdefgh\",\"ijklmnop\"])) call abort\n+   deallocate (as_typ(1)%as%fp)\n+   deallocate (as_typ(1)%as)\n+   deallocate (as_typ)\n+   end program test_prog"}, {"sha": "31a90a5570783998c76487f51ee2b95bb63673e8", "filename": "gcc/testsuite/gfortran.dg/pointer_array_4.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_4.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR57116 as part of the overall fix for PR34640.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_rtti_ptr\n+  implicit none\n+  type :: foo\n+     real :: v\n+     integer :: i\n+  end type foo\n+contains\n+  subroutine extract(this, v, ic)\n+    class(*), target :: this(:)\n+    real, pointer :: v(:)\n+    integer :: ic\n+    select type (this)\n+    type is (real)\n+       v => this(ic:)\n+    class is (foo)\n+       v => this(ic:)%v\n+    end select\n+  end subroutine extract\n+end module\n+\n+program prog_rtti_ptr\n+  use mod_rtti_ptr\n+  class(*), allocatable, target :: o(:)\n+  real, pointer :: v(:)\n+\n+  allocate(o(3), source=[1.0, 2.0, 3.0])\n+  call extract(o, v, 2)\n+  if (size(v) == 2 .and. all (v == [2.0, 3.0])) then\n+     deallocate(o)\n+  else\n+     call abort\n+  end if\n+\n+  allocate(o(3), source=[foo(1.0, 1), foo(4.0, 4), foo(5.0, 5)])\n+  call extract(o, v, 2)\n+  if (size(v) == 2 .and. all (v == [4.0, 5.0])) then\n+     deallocate(o)\n+  else\n+     call abort\n+  end if\n+\n+! The rest tests the case in comment 2 <janus@gcc.gnu.org>\n+\n+  call extract1 (v, 1)\n+  if (any (v /= [1.0, 2.0])) call abort\n+  call extract1 (v, 2)  ! Call to deallocate pointer.\n+\n+contains\n+  subroutine extract1(v, flag)\n+    type :: foo\n+       real :: v\n+       character(4) :: str\n+    end type\n+    class(foo), pointer, save :: this(:)\n+    real, pointer :: v(:)\n+    integer :: flag\n+\n+    if (flag == 1) then\n+      allocate (this(2), source = [foo (1.0, \"one \"), foo (2.0, \"two \")])\n+      select type (this)\n+        class is (foo)\n+          v => this(1:2)%v\n+      end select\n+    else\n+      deallocate (this)\n+    end if\n+  end subroutine\n+\n+end program prog_rtti_ptr"}, {"sha": "312d097854b3f867aed3fc09687d5cd574243b05", "filename": "gcc/testsuite/gfortran.dg/pointer_array_5.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_5.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR55763 comment 9 as part of the overall fix for PR34640.\n+!\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+  program change_field_type\n+    use, intrinsic :: iso_c_binding\n+    implicit none\n+    REAL(kind=c_float), POINTER :: vector_comp(:)\n+    TYPE, BIND(C) :: scalar_vector\n+       REAL(kind=c_float) :: scalar\n+       REAL(kind=c_float) :: vec(3)\n+    END TYPE\n+    TYPE, BIND(C) :: scalar_vector_matrix\n+       REAL(kind=c_float) :: scalar\n+       REAL(kind=c_float) :: vec(3)\n+       REAL(kind=c_float) :: mat(3,3)\n+    END TYPE\n+    CLASS(*), ALLOCATABLE, TARGET :: one_d_field(:)\n+    real, pointer :: v1(:)\n+\n+    allocate(one_d_field(3), &\n+             source = (/ scalar_vector( 1.0, (/ -1.0, 0.0, 1.0 /) ), &\n+                         scalar_vector( 1.1, (/ -1.2, 0.2, 0.9 /) ), &\n+                         scalar_vector( 1.2, (/ -1.4, 0.4, 0.8 /) )  /) )\n+\n+    call extract_vec(one_d_field, 1, 2)\n+    if (any (abs (vector_comp - [0.0,0.2,0.4]) .gt. 1e-4)) call abort\n+    deallocate(one_d_field)   ! v1 becomes undefined\n+\n+    allocate(one_d_field(1), &\n+         source = (/ scalar_vector_matrix( 1.0, (/ -1.0, 0.0, 1.0 /), &\n+         reshape( (/ 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 /), &\n+                 (/3, 3/) ) ) /) )\n+\n+    call extract_vec(one_d_field, 2, 1)\n+    if (abs (vector_comp(1) + 1.0) > 1e-4) call abort\n+    call extract_vec(one_d_field, 2, 3)\n+    if (abs (vector_comp(1) - 1.0) > 1e-4) call abort\n+    deallocate(one_d_field)   ! v1 becomes undefined\n+  contains\n+    subroutine extract_vec(field, tag, ic)\n+        use, intrinsic :: iso_c_binding\n+        CLASS(*), TARGET :: field(:)\n+        INTEGER(kind=c_int), value :: tag, ic\n+\n+        type(scalar_vector), pointer :: sv(:)\n+        type(scalar_vector_matrix), pointer :: svm(:)\n+\n+        select type (field)\n+        type is (real(c_float))\n+          vector_comp => field\n+        class default\n+          select case (tag)\n+          case (1)\n+             sv => field\n+             vector_comp => sv(:)%vec(ic)\n+          case (2)\n+             svm => field\n+             vector_comp => svm(:)%vec(ic)\n+          end select\n+        end select\n+    end subroutine\n+  end program"}, {"sha": "86685563209389a37318afd9084ecd338d2d638f", "filename": "gcc/testsuite/gfortran.dg/pointer_array_6.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_6.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR57019 comment 4 as part of the overall fix for PR34640.\n+!\n+! Contributed by  <thambsup@gmail.com>\n+!\n+  type cParticle\n+    real(4) :: v(3)\n+  endtype cParticle\n+\n+  type pCItem\n+    type(cParticle) :: Ele\n+  end type pCItem\n+\n+  type(pCItem), target, dimension(1:1,1:1) :: pCellArray\n+  type(cParticle), pointer, dimension(:,:) :: pArray\n+  real(4), pointer, dimension(:) :: v_pointer\n+  real(4), dimension(3) :: v_real = 99.\n+\n+  pArray => pCellArray%Ele\n+  v_pointer => pArray(1,1)%v;\n+  v_pointer = v_real !OK %%%%%%%%%%%%\n+  if (any (int (pArray(1,1)%v) .ne. 99)) call abort\n+\n+  v_real = 88\n+  pArray(1,1)%v = v_real !SEGFAULT %%%%%%%%%%%%%%%%%%%%%%%%\n+  if (any (int (v_pointer) .ne. 88)) call abort\n+end"}, {"sha": "1aa48b7a0788d4c999897889b174d965f38ebf82", "filename": "gcc/testsuite/gfortran.dg/pointer_array_7.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_7.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+!\n+! Test for the fix for PR34640. In this case, final testing of the\n+! patch revealed that in some cases the actual descriptor was not\n+! being passed to procedure dummy pointers.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@netcologne.de>\n+!\n+module x\n+  use iso_c_binding\n+  implicit none\n+  type foo\n+     complex :: c\n+     integer :: i\n+  end type foo\n+contains\n+  subroutine printit(c, a)\n+    complex, pointer, dimension(:) :: c\n+    integer :: i\n+    integer(kind=c_intptr_t) :: a\n+    a = transfer(c_loc(c(2)),a)\n+  end subroutine printit\n+end module x\n+\n+program main\n+  use x\n+  use iso_c_binding\n+  implicit none\n+  type(foo), dimension(5), target :: a\n+  integer :: i\n+  complex, dimension(:), pointer :: pc\n+  integer(kind=c_intptr_t) :: s1, s2, s3\n+  a%i = 0\n+  do i=1,5\n+     a(i)%c = cmplx(i**2,i)\n+  end do\n+  pc => a%c\n+  call printit(pc, s3)\n+\n+  s1 = transfer(c_loc(a(2)%c),s1)\n+  if (s1 /= s3) call abort\n+\n+  s2 = transfer(c_loc(pc(2)),s2)\n+  if (s2 /= s3) call abort\n+\n+end program main"}, {"sha": "bbf2c997dd6e27858d067486e885d2e773d4982e", "filename": "gcc/testsuite/gfortran.dg/pointer_array_8.f90", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_8.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,81 @@\n+! { dg-do run }\n+!\n+! Make sure that the fix for pr34640 works with class pointers.\n+!\n+  type :: mytype\n+    real :: r\n+    integer :: i\n+  end type\n+\n+  type :: thytype\n+    real :: r\n+    integer :: i\n+    type(mytype) :: der\n+  end type\n+\n+  type(thytype), dimension(0:2), target :: tgt\n+  class(*), dimension(:), pointer :: cptr\n+  class(mytype), dimension(:), pointer :: cptr1\n+  integer :: i\n+  integer(8) :: s1, s2\n+\n+  tgt = [(thytype(int(i), i, mytype(int(2*i), 2*i)), i= 1,3)]\n+\n+  cptr => tgt%i\n+  if (lbound (cptr, 1) .ne. 1)  Call abort     ! Not a whole array target!\n+\n+  s1 = loc(cptr)\n+  call foo (cptr, s2)                          ! Check bounds not changed...\n+  if (s1 .ne. s2) Call abort                   ! ...and that the descriptor is passed.\n+\n+  select type (cptr)\n+    type is (integer)\n+      if (any (cptr .ne. [1,2,3])) call abort  ! Check the the scalarizer works.\n+      if (cptr(2) .ne. 2) call abort           ! Check ordinary array indexing.\n+  end select\n+\n+  cptr(1:3) => tgt%der%r                       ! Something a tad more complicated!\n+\n+  select type (cptr)\n+    type is (real)\n+      if (any (int(cptr) .ne. [2,4,6])) call abort\n+      if (any (int(cptr([2,3,1])) .ne. [4,6,2])) call abort\n+      if (int(cptr(3)) .ne. 6) call abort\n+  end select\n+\n+  cptr1(1:3) => tgt%der\n+\n+  s1 = loc(cptr1)\n+  call bar(cptr1, s2)\n+  if (s1 .ne. s2) Call abort                   ! Check that the descriptor is passed.\n+\n+  select type (cptr1)\n+    type is (mytype)\n+      if (any (cptr1%i .ne. [2,4,6])) call abort\n+      if (cptr1(2)%i .ne. 4) call abort\n+  end select\n+\n+contains\n+\n+  subroutine foo (arg, addr)\n+    class(*), dimension(:), pointer :: arg\n+    integer(8) :: addr\n+    addr = loc(arg)\n+    select type (arg)\n+      type is (integer)\n+        if (any (arg .ne. [1,2,3])) call abort  ! Check the the scalarizer works.\n+        if (arg(2) .ne. 2) call abort           ! Check ordinary array indexing.\n+    end select\n+  end subroutine\n+\n+  subroutine bar (arg, addr)\n+    class(mytype), dimension(:), pointer :: arg\n+    integer(8) :: addr\n+    addr = loc(arg)\n+    select type (arg)\n+      type is (mytype)\n+        if (any (arg%i .ne. [2,4,6])) call abort\n+        if (arg(2)%i .ne. 4) call abort\n+    end select\n+  end subroutine\n+end"}, {"sha": "b96071b178a1dfebf5633cf0602354f35e4d4c46", "filename": "gcc/testsuite/gfortran.dg/pointer_array_component_1.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_1.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! Check the fix for PR34640 comment 28.\n+!\n+! This involves pointer array components that point to components of arrays\n+! of derived types.\n+!\n+  type var_tables\n+     real, pointer :: rvar(:)\n+  end type\n+\n+  type real_vars\n+     real r\n+     real :: index\n+  end type\n+\n+  type(var_tables) ::  vtab_r\n+  type(real_vars),  target :: x(2)\n+  real, pointer :: z(:)\n+  real :: y(2)\n+\n+  x = [real_vars (11.0, 1.0), real_vars (42.0, 2.0)]\n+  vtab_r%rvar => x%r\n+  if (any (abs (vtab_r%rvar - [11.0, 42.0]) > 1.0e-5)) call abort  ! Check skipping 'index; is OK.\n+\n+  y = vtab_r%rvar\n+  if (any (abs (y - [11.0, 42.0]) > 1.0e-5)) call abort  ! Check that the component is usable in assignment.\n+\n+  call foobar (vtab_r, [11.0, 42.0])\n+\n+  vtab_r = barfoo ()\n+\n+  call foobar (vtab_r, [111.0, 142.0])\n+\n+contains\n+  subroutine foobar (vtab, array)\n+    type(var_tables) ::  vtab\n+    real :: array (:)\n+    if (any (abs (vtab%rvar - array) > 1.0e-5)) call abort  ! Check passing as a dummy.\n+    if (abs (vtab%rvar(2) - array(2)) > 1.0e-5) call abort  ! Check component reference.\n+  end subroutine\n+\n+  function barfoo () result(res)\n+    type(var_tables) ::  res\n+    allocate (res%rvar(2), source = [111.0, 142.0])  ! Check allocation\n+  end function\n+end"}, {"sha": "bde66f67e5a1d287e74135bf93262ce840442d9f", "filename": "gcc/testsuite/gfortran.dg/pointer_array_component_2.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_array_component_2.f90?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR34640. In the first version of the fix, the first\n+! testcase in PR51218 failed with a segfault. This test extracts the\n+! failing part and checks that all is well.\n+!\n+  type t_info_block\n+    integer                      :: n     =  0      ! number of elements\n+  end type t_info_block\n+  !\n+  type t_dec_info\n+    integer                      :: n     =  0      ! number of elements\n+    integer                      :: n_b   =  0      ! number of blocks\n+    type (t_info_block) ,pointer :: b (:) => NULL() ! info blocks\n+  end type t_dec_info\n+  !\n+  type t_vector_segm\n+    integer           :: n    =  0      ! number of elements\n+    real ,pointer :: x(:) => NULL() ! coefficients\n+  end type t_vector_segm\n+  !\n+  type t_vector\n+    type (t_dec_info)    ,pointer :: info    => NULL()  ! decomposition info\n+    integer                       :: n       =  0       ! number of elements\n+    integer                       :: n_s     =  0       ! number of segments\n+    integer                       :: alloc_l =  0       ! allocation level\n+    type (t_vector_segm) ,pointer :: s (:)   => NULL()  ! vector blocks\n+  end type t_vector\n+\n+\n+  type(t_vector) :: z\n+  type(t_vector_segm), pointer :: ss\n+\n+  allocate (z%s(2))\n+  do i = 1, 2\n+    ss => z%s(i)\n+    allocate (ss%x(2), source = [1.0, 2.0]*real(i))\n+  end do\n+\n+! These lines would segfault.\n+  if (int (sum (z%s(1)%x)) .ne. 3) call abort\n+  if (int (sum (z%s(1)%x * z%s(2)%x)) .ne. 10) call abort\n+end"}, {"sha": "3dd2718b9d7af053ee636a9a3bfe63c65422241b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -1,3 +1,9 @@\n+2017-09-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/34640\n+\t* libgfortran/libgfortran.h: Add span field to descriptor.\n+\t* libgfortran/libtool-version : Bump up version number to 5:0:0.\n+\n 2017-08-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/78387"}, {"sha": "cdbdd9516875ca39853e17b1080ad436efd5580a", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -339,6 +339,7 @@ struct {\\\n   type *base_addr;\\\n   size_t offset;\\\n   index_type dtype;\\\n+  index_type span;\\\n   descriptor_dimension dim[r];\\\n }\n "}, {"sha": "4ce57a911da5ec44cf800c60c63c3d586c410bca", "filename": "libgfortran/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff3598bc73dbae3a612709daca41e56ab5aa6928/libgfortran%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibtool-version?ref=ff3598bc73dbae3a612709daca41e56ab5aa6928", "patch": "@@ -3,4 +3,4 @@\n # This is a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-4:0:0\n+5:0:0"}]}