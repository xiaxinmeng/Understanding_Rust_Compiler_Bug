{"sha": "e82c382971664d6fd138cc36020db4b1a91885c6", "node_id": "C_kwDOANBUbNoAKGU4MmMzODI5NzE2NjRkNmZkMTM4Y2MzNjAyMGRiNGIxYTkxODg1YzY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-10T12:21:59Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-10T22:13:27Z"}, "message": "Allow loop header copying when first iteration condition is known.\n\nAs discussed in the PR, the loop header copying pass avoids doing so\nwhen optimizing for size.  However, sometimes we can determine the\nloop entry conditional statically for the first iteration of the loop.\n\nThis patch uses the path solver to determine the outgoing edge\nout of preheader->header->xx.  If so, it allows header copying.  Doing\nthis in the loop optimizer saves us from doing gymnastics in the\nthreader which doesn't have the context to determine if a loop\ntransformation is profitable.\n\nI am only returning true in entry_loop_condition_is_static for\na true conditional.  Technically a false conditional is also\nprovably static, but allowing any boolean value causes a regression\nin gfortran.dg/vector_subscript_1.f90.\n\nI would have preferred not passing around the query object, but the\nlayout of pass_ch and should_duplicate_loop_header_p make it a bit\nawkward to get it right without an outright refactor to the\npass.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102906\n\t* tree-ssa-loop-ch.c (entry_loop_condition_is_static): New.\n\t(should_duplicate_loop_header_p): Call entry_loop_condition_is_static.\n\t(class ch_base): Add m_ranger and m_query.\n\t(ch_base::copy_headers): Pass m_query to\n\tentry_loop_condition_is_static.\n\t(pass_ch::execute): Allocate and deallocate m_ranger and\n\tm_query.\n\t(pass_ch_vect::execute): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr102906.c: New test.", "tree": {"sha": "8f48928684678ccedc0594c74b4801397ed334f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f48928684678ccedc0594c74b4801397ed334f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e82c382971664d6fd138cc36020db4b1a91885c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82c382971664d6fd138cc36020db4b1a91885c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e82c382971664d6fd138cc36020db4b1a91885c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e82c382971664d6fd138cc36020db4b1a91885c6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c744ae0897957def0cd798399ef8ed6dc0d23811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c744ae0897957def0cd798399ef8ed6dc0d23811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c744ae0897957def0cd798399ef8ed6dc0d23811"}], "stats": {"total": 68, "additions": 60, "deletions": 8}, "files": [{"sha": "1846f0b6dba3a9bc2dfe998f2e03d78744bb94b2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr102906.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82c382971664d6fd138cc36020db4b1a91885c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102906.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82c382971664d6fd138cc36020db4b1a91885c6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102906.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr102906.c?ref=e82c382971664d6fd138cc36020db4b1a91885c6", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-Os -fdump-tree-ch-details\" }\n+\n+extern unsigned int foo (int*) __attribute__((pure));\n+\n+unsigned int\n+tr2 (int array[], int n)\n+{\n+  unsigned int sum = 0;\n+  int x;\n+  if (n > 0)\n+    for (x = 0; x < n; x++)\n+      sum += foo (&array[x]);\n+  return sum;\n+}\n+\n+// { dg-final { scan-tree-dump-not \"Not duplicating.*optimizing for size\" \"ch2\" } }"}, {"sha": "c7d86d751d4dff32a441647a4199e979464e052c", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e82c382971664d6fd138cc36020db4b1a91885c6/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e82c382971664d6fd138cc36020db4b1a91885c6/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=e82c382971664d6fd138cc36020db4b1a91885c6", "patch": "@@ -35,30 +35,52 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-sccvn.h\"\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n+#include \"value-range.h\"\n+#include \"gimple-range.h\"\n+#include \"gimple-range-path.h\"\n \n /* Duplicates headers of loops if they are small enough, so that the statements\n    in the loop body are always executed when the loop is entered.  This\n    increases effectiveness of code motion optimizations, and reduces the need\n    for loop preconditioning.  */\n \n+/* Return true if the condition on the first iteration of the loop can\n+   be statically determined.  */\n+\n+static bool\n+entry_loop_condition_is_static (class loop *l, path_range_query *query)\n+{\n+  edge e = loop_preheader_edge (l);\n+  gcond *last = safe_dyn_cast <gcond *> (last_stmt (e->dest));\n+\n+  if (!last\n+      || !irange::supports_type_p (TREE_TYPE (gimple_cond_lhs (last))))\n+    return false;\n+\n+  int_range<2> r;\n+  query->compute_ranges (e);\n+  query->range_of_stmt (r, last);\n+  return r == int_range<2> (boolean_true_node, boolean_true_node);\n+}\n+\n /* Check whether we should duplicate HEADER of LOOP.  At most *LIMIT\n    instructions should be duplicated, limit is decreased by the actual\n    amount.  */\n \n static bool\n should_duplicate_loop_header_p (basic_block header, class loop *loop,\n-\t\t\t\tint *limit)\n+\t\t\t\tint *limit, path_range_query *query)\n {\n   gimple_stmt_iterator bsi;\n \n   gcc_assert (!header->aux);\n \n-  /* Loop header copying usually increases size of the code.  This used not to\n-     be true, since quite often it is possible to verify that the condition is\n-     satisfied in the first iteration and therefore to eliminate it.  Jump\n-     threading handles these cases now.  */\n+  /* Avoid loop header copying when optimizing for size unless we can\n+     determine that the loop condition is static in the first\n+     iteration.  */\n   if (optimize_loop_for_size_p (loop)\n-      && !loop->force_vectorize)\n+      && !loop->force_vectorize\n+      && !entry_loop_condition_is_static (loop, query))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -267,6 +289,9 @@ class ch_base : public gimple_opt_pass\n \n   /* Return true to copy headers of LOOP or false to skip.  */\n   virtual bool process_loop_p (class loop *loop) = 0;\n+\n+  gimple_ranger *m_ranger = NULL;\n+  path_range_query *m_query = NULL;\n };\n \n const pass_data pass_data_ch =\n@@ -389,7 +414,8 @@ ch_base::copy_headers (function *fun)\n \n       exit = NULL;\n       n_bbs = 0;\n-      while (should_duplicate_loop_header_p (header, loop, &remaining_limit))\n+      while (should_duplicate_loop_header_p (header, loop, &remaining_limit,\n+\t\t\t\t\t     m_query))\n \t{\n \t  /* Find a successor of header that is inside a loop; i.e. the new\n \t     header after the condition is copied.  */\n@@ -526,9 +552,13 @@ pass_ch::execute (function *fun)\n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n \t\t       | LOOPS_HAVE_SIMPLE_LATCHES\n \t\t       | LOOPS_HAVE_RECORDED_EXITS);\n+  m_ranger = new gimple_ranger;\n+  m_query = new path_range_query (*m_ranger, /*resolve=*/true);\n \n   unsigned int res = copy_headers (fun);\n \n+  delete m_query;\n+  delete m_ranger;\n   loop_optimizer_finalize ();\n   return res;\n }\n@@ -540,7 +570,12 @@ pass_ch::execute (function *fun)\n unsigned int\n pass_ch_vect::execute (function *fun)\n {\n-  return copy_headers (fun);\n+  m_ranger = new gimple_ranger;\n+  m_query = new path_range_query (*m_ranger, /*resolve=*/true);\n+  unsigned int res = copy_headers (fun);\n+  delete m_query;\n+  delete m_ranger;\n+  return res;\n }\n \n /* Apply header copying according to a very simple test of do-while shape.  */"}]}