{"sha": "7987a8d29a78eb373b5e054d539e332d75e92e92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4N2E4ZDI5YTc4ZWIzNzNiNWUwNTRkNTM5ZTMzMmQ3NWU5MmU5Mg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@linux.alibaba.com", "date": "2020-11-06T21:19:40Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-11-06T21:21:11Z"}, "message": "Improve uninitialized warning with value range info\n\nFunction use_pred_not_overlap_with_undef_path_pred of\npass_late_warn_uninitialized\nchecks if predicate of variable use overlaps with predicate of undefined\ncontrol flow path.\nFor now, it only checks ssa_var comparing against constant, this can be\nimproved where\nssa_var compares against another ssa_var with value range info, as described in\ncomment:\n\n+         /* Check value range info of rhs, do following transforms:\n+              flag_var < [min, max]  ->  flag_var < max\n+              flag_var > [min, max]  ->  flag_var > min\n+\n+            We can also transform LE_EXPR/GE_EXPR to LT_EXPR/GT_EXPR:\n+              flag_var <= [min, max] ->  flag_var < [min, max+1]\n+              flag_var >= [min, max] ->  flag_var > [min-1, max]\n+            if no overflow/wrap.  */\n\ngcc/\n\n\t* tree-ssa-uninit.c (find_var_cmp_const): New function.\n\t(use_pred_not_overlap_with_undef_path_pred): Call above.", "tree": {"sha": "b4197947306fbb473293ef3b951a8b0c5b31cad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4197947306fbb473293ef3b951a8b0c5b31cad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7987a8d29a78eb373b5e054d539e332d75e92e92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7987a8d29a78eb373b5e054d539e332d75e92e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7987a8d29a78eb373b5e054d539e332d75e92e92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7987a8d29a78eb373b5e054d539e332d75e92e92/comments", "author": null, "committer": null, "parents": [{"sha": "887515acd27e49c176395ab76d5826959d89cb9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887515acd27e49c176395ab76d5826959d89cb9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887515acd27e49c176395ab76d5826959d89cb9b"}], "stats": {"total": 192, "additions": 129, "deletions": 63}, "files": [{"sha": "f23514395e08069ec031b722d8b65d24fdcfbe32", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 129, "deletions": 63, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7987a8d29a78eb373b5e054d539e332d75e92e92/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7987a8d29a78eb373b5e054d539e332d75e92e92/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=7987a8d29a78eb373b5e054d539e332d75e92e92", "patch": "@@ -1345,21 +1345,18 @@ value_sat_pred_p (tree val, tree boundary, enum tree_code cmpc,\n }\n \n /* Returns true if PRED is common among all the predicate\n-   chains (PREDS) (and therefore can be factored out).\n-   NUM_PRED_CHAIN is the size of array PREDS.  */\n+   chains (PREDS) (and therefore can be factored out).  */\n \n static bool\n-find_matching_predicate_in_rest_chains (pred_info pred,\n-\t\t\t\t\tpred_chain_union preds,\n-\t\t\t\t\tsize_t num_pred_chains)\n+find_matching_predicate_in_rest_chains (pred_info pred, pred_chain_union preds)\n {\n   size_t i, j, n;\n \n   /* Trival case.  */\n-  if (num_pred_chains == 1)\n+  if (preds.length () == 1)\n     return true;\n \n-  for (i = 1; i < num_pred_chains; i++)\n+  for (i = 1; i < preds.length (); i++)\n     {\n       bool found = false;\n       pred_chain one_chain = preds[i];\n@@ -1530,6 +1527,129 @@ prune_uninit_phi_opnds (gphi *phi, unsigned uninit_opnds, gphi *flag_def,\n   return true;\n }\n \n+/* A helper function finds predicate which will be examined against uninit\n+   paths.  If there is no \"flag_var cmp const\" form predicate, the function\n+   tries to find predicate of form like \"flag_var cmp flag_var\" with value\n+   range info.  PHI is the phi node whose incoming (undefined) paths need to\n+   be examined.  On success, the function returns the comparsion code, sets\n+   defintion gimple of the flag_var to FLAG_DEF, sets boundary_cst to\n+   BOUNDARY_CST.  On fail, the function returns ERROR_MARK.  */\n+\n+static enum tree_code\n+find_var_cmp_const (pred_chain_union preds, gphi *phi, gimple **flag_def,\n+\t\t    tree *boundary_cst)\n+{\n+  enum tree_code vrinfo_code = ERROR_MARK, code;\n+  gimple *vrinfo_def = NULL;\n+  tree vrinfo_cst = NULL, cond_lhs, cond_rhs;\n+\n+  gcc_assert (preds.length () > 0);\n+  pred_chain the_pred_chain = preds[0];\n+  for (unsigned i = 0; i < the_pred_chain.length (); i++)\n+    {\n+      bool use_vrinfo_p = false;\n+      pred_info the_pred = the_pred_chain[i];\n+      cond_lhs = the_pred.pred_lhs;\n+      cond_rhs = the_pred.pred_rhs;\n+      if (cond_lhs == NULL_TREE || cond_rhs == NULL_TREE)\n+\tcontinue;\n+\n+      code = get_cmp_code (the_pred.cond_code, false, the_pred.invert);\n+      if (code == ERROR_MARK)\n+\tcontinue;\n+\n+      if (TREE_CODE (cond_lhs) == SSA_NAME && is_gimple_constant (cond_rhs))\n+\t;\n+      else if (TREE_CODE (cond_rhs) == SSA_NAME\n+\t       && is_gimple_constant (cond_lhs))\n+\t{\n+\t  std::swap (cond_lhs, cond_rhs);\n+\t  if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n+\t    continue;\n+\t}\n+      /* Check if we can take advantage of \"flag_var comp flag_var\" predicate\n+\t with value range info.  Note only first of such case is handled.  */\n+      else if (vrinfo_code == ERROR_MARK\n+\t       && TREE_CODE (cond_lhs) == SSA_NAME\n+\t       && TREE_CODE (cond_rhs) == SSA_NAME)\n+\t{\n+\t  gimple* lhs_def = SSA_NAME_DEF_STMT (cond_lhs);\n+\t  if (!lhs_def || gimple_code (lhs_def) != GIMPLE_PHI\n+\t      || gimple_bb (lhs_def) != gimple_bb (phi))\n+\t    {\n+\t      std::swap (cond_lhs, cond_rhs);\n+\t      if ((code = get_cmp_code (code, true, false)) == ERROR_MARK)\n+\t\tcontinue;\n+\t    }\n+\n+\t  /* Check value range info of rhs, do following transforms:\n+\t       flag_var < [min, max]  ->  flag_var < max\n+\t       flag_var > [min, max]  ->  flag_var > min\n+\n+\t     We can also transform LE_EXPR/GE_EXPR to LT_EXPR/GT_EXPR:\n+\t       flag_var <= [min, max] ->  flag_var < [min, max+1]\n+\t       flag_var >= [min, max] ->  flag_var > [min-1, max]\n+\t     if no overflow/wrap.  */\n+\t  wide_int min, max;\n+\t  tree type = TREE_TYPE (cond_lhs);\n+\t  if (!INTEGRAL_TYPE_P (type)\n+\t      || get_range_info (cond_rhs, &min, &max) != VR_RANGE)\n+\t    continue;\n+\t  if (code == LE_EXPR\n+\t      && max != wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n+\t    {\n+\t      code = LT_EXPR;\n+\t      max = max + 1;\n+\t    }\n+\t  if (code == GE_EXPR\n+\t      && min != wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n+\t    {\n+\t      code = GT_EXPR;\n+\t      min = min - 1;\n+\t    }\n+\t  if (code == LT_EXPR)\n+\t    cond_rhs = wide_int_to_tree (type, max);\n+\t  else if (code == GT_EXPR)\n+\t    cond_rhs = wide_int_to_tree (type, min);\n+\t  else\n+\t    continue;\n+\n+\t  use_vrinfo_p = true;\n+\t}\n+      else\n+\tcontinue;\n+\n+      if ((*flag_def = SSA_NAME_DEF_STMT (cond_lhs)) == NULL)\n+\tcontinue;\n+\n+      if (gimple_code (*flag_def) != GIMPLE_PHI\n+\t  || gimple_bb (*flag_def) != gimple_bb (phi)\n+\t  || !find_matching_predicate_in_rest_chains (the_pred, preds))\n+\tcontinue;\n+\n+      /* Return if any \"flag_var comp const\" predicate is found.  */\n+      if (!use_vrinfo_p)\n+\t{\n+\t  *boundary_cst = cond_rhs;\n+\t  return code;\n+\t}\n+      /* Record if any \"flag_var comp flag_var[vinfo]\" predicate is found.  */\n+      else if (vrinfo_code == ERROR_MARK)\n+\t{\n+\t  vrinfo_code = code;\n+\t  vrinfo_def = *flag_def;\n+\t  vrinfo_cst = cond_rhs;\n+\t}\n+    }\n+  /* Return the \"flag_var cmp flag_var[vinfo]\" predicate we found.  */\n+  if (vrinfo_code != ERROR_MARK)\n+    {\n+      *flag_def = vrinfo_def;\n+      *boundary_cst = vrinfo_cst;\n+    }\n+  return vrinfo_code;\n+}\n+\n /* A helper function that determines if the predicate set\n    of the use is not overlapping with that of the uninit paths.\n    The most common senario of guarded use is in Example 1:\n@@ -1607,75 +1727,21 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n \t\t\t\t\t   gphi *phi, unsigned uninit_opnds,\n \t\t\t\t\t   hash_set<gphi *> *visited_phis)\n {\n-  unsigned int i, n;\n   gimple *flag_def = 0;\n   tree boundary_cst = 0;\n   enum tree_code cmp_code;\n-  bool swap_cond = false;\n-  bool invert = false;\n-  pred_chain the_pred_chain = vNULL;\n   bitmap visited_flag_phis = NULL;\n   bool all_pruned = false;\n-  size_t num_preds = preds.length ();\n \n-  gcc_assert (num_preds > 0);\n   /* Find within the common prefix of multiple predicate chains\n      a predicate that is a comparison of a flag variable against\n      a constant.  */\n-  the_pred_chain = preds[0];\n-  n = the_pred_chain.length ();\n-  for (i = 0; i < n; i++)\n-    {\n-      tree cond_lhs, cond_rhs, flag = 0;\n-\n-      pred_info the_pred = the_pred_chain[i];\n-\n-      invert = the_pred.invert;\n-      cond_lhs = the_pred.pred_lhs;\n-      cond_rhs = the_pred.pred_rhs;\n-      cmp_code = the_pred.cond_code;\n-\n-      if (cond_lhs != NULL_TREE && TREE_CODE (cond_lhs) == SSA_NAME\n-\t  && cond_rhs != NULL_TREE && is_gimple_constant (cond_rhs))\n-\t{\n-\t  boundary_cst = cond_rhs;\n-\t  flag = cond_lhs;\n-\t}\n-      else if (cond_rhs != NULL_TREE && TREE_CODE (cond_rhs) == SSA_NAME\n-\t       && cond_lhs != NULL_TREE && is_gimple_constant (cond_lhs))\n-\t{\n-\t  boundary_cst = cond_lhs;\n-\t  flag = cond_rhs;\n-\t  swap_cond = true;\n-\t}\n-\n-      if (!flag)\n-\tcontinue;\n-\n-      flag_def = SSA_NAME_DEF_STMT (flag);\n-\n-      if (!flag_def)\n-\tcontinue;\n-\n-      if ((gimple_code (flag_def) == GIMPLE_PHI)\n-\t  && (gimple_bb (flag_def) == gimple_bb (phi))\n-\t  && find_matching_predicate_in_rest_chains (the_pred, preds,\n-\t\t\t\t\t\t     num_preds))\n-\tbreak;\n-\n-      flag_def = 0;\n-    }\n-\n-  if (!flag_def)\n+  cmp_code = find_var_cmp_const (preds, phi, &flag_def, &boundary_cst);\n+  if (cmp_code == ERROR_MARK)\n     return false;\n \n   /* Now check all the uninit incoming edge has a constant flag value\n      that is in conflict with the use guard/predicate.  */\n-  cmp_code = get_cmp_code (cmp_code, swap_cond, invert);\n-\n-  if (cmp_code == ERROR_MARK)\n-    return false;\n-\n   all_pruned = prune_uninit_phi_opnds\n     (phi, uninit_opnds, as_a<gphi *> (flag_def), boundary_cst, cmp_code,\n      visited_phis, &visited_flag_phis);"}]}