{"sha": "53c170316f895dc3dfa7173e69fc43b15b7acb1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNjMTcwMzE2Zjg5NWRjM2RmYTcxNzNlNjlmYzQzYjE1YjdhY2IxYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-21T12:55:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-21T12:55:18Z"}, "message": "basic-block.h (flow_delete_insn, [...]): Kill.\n\n\t* basic-block.h (flow_delete_insn, flow_delete_insn_chain): Kill.\n\t* cfg.c (delete_insn): Rename from ....; use remove_insn; do not\n\tremove some labels.\n\t(flow_delete_insn): This one.\n\t(delete_insn_chain): Rename from ...; do not care labels.\n\t(flow_delete_insn_chain): ... this one.\n\t(flow_delete_block): Remove the insns one BB has been expunged.\n\t(merge_blocks_nomove): Likewise.\n\t(try_redirect_by_replacing_jump): Use delete_insn[_chain]; do not care\n\tupdating BB boundaries.\n\t(tidy_fallthru_edge): Likewise.\n\t(commit_one_edge_insertion): Likewise.\n\t* cfgbuild.c (find_basic_block): Likewise.\n\t(find_basic_blocks_1): Likewise.\n\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps): Likewise.\n\t(try_crossjump_to_edge): Likewise.\n\t(try_optimize_cfg): Likewise.\n\t* cse.c (delete_trivially_dead_insns): Likewise.\n\t* df.c (df_insn_delete): Likewise.\n\t* doloop.c (doloop_modify): Use delete_related_insns.\n\t* emit-rtl.c (try_split): Likewise.\n\t(remove_insn): Update BB boundaries.\n\t* expect.c (connect_post_landing_pads): Use delete_related_insns.\n\t* flow.c (delete_dead_jumptables): Use delete_insn[_chain]; do not care\n\tupdating BB boundaries.\n\t(propagate_block_delete_insn): Likewise.\n\t(propagate_block_delete_libcall): Likewise.\n\t* function.c (delete_handlers): Use delete_related_insns.\n\t(thread_prologue_and_epilogue_insns): Likewise.\n\t* gcse.c (delete_null_pointer_checks): Use delete_related_insns.\n\t* genpeep.c (gen_peephole): Use delete_related_insns.\n\t* ifcvt.c (noce_process_if_block): Use delete_insn; do not care updating\n\tBB boundaries.\n\t(find_cond_trap): Likewise.\n\t* integrate.c (save_for_inline): Use delete_related_insns.\n\t(copy_insn_list): Likewise.\n\t* jump.c (pruge_linie_number_notes): Likewise.\n\t(duplicate_loop_exit_test): Likewise.\n\t(delete_computation): Likewise.\n\t(delete_related_insn): Rename from ...; use delete_insn\n\t(delete_insn): ... this one.\n\t(redirect_jump): Use delete_related_insns.\n\t* loop.c (scan_loop): Likewise.\n\t(move_movables): Likewise.\n\t(find_and_verify_loops): Likewise.\n\t(check_dbra_loop): Likewise.\n\t* recog.c (peephole2_optimize): Likewise.\n\t* reg-stack.c (delete_insn_for_stacker): Remove.\n\t(move_for_stack_reg): Use delete_insn.\n\t* regmove.c (combine_stack_adjustments_for_block): Likewise.\n\t* reload1.c (delete_address_reloads): Use delete_related_insns.\n\t(fixup_abnormal_edges): Use delete_insn.\n\t* recog.c (emit_delay_sequence): Use delete_related_insns.\n\t(delete_from-delay_slot): Likewise.\n\t(delete_scheduled_jump): likewise.\n\t(optimize_skip): Likewise.\n\t(try_merge_delay_insns): Likewise.\n\t(full_simple_delay_slots): Likewise.\n\t(fill_slots_from_thread): Likewise.\n\t(relax_delay_slots): Likewise.\n\t(make_return_insns): Likewise.\n\t(dbr_schedule): Likewise.\n\t* rtl.h (delete_insn): Rename to delete_related_insns.\n\t(delete_insn, delete_insn_chain): New prototypes.\n\t* ssa-ccp (sse_fast_dce):  Remove deleting of DEF, as it is done\n\tby df_insn_delete already.\n\t* ssa-dce.c (delete_insn_bb): Use delete_insn.\n\t* ssa.c (convert_from_ssa): Use delete_related_insns.\n\t* unroll.c (unroll_loop): Likewise.\n\t(calculate_giv_inc): Likewise.\n\t(copy_loop_body): Likewise.\n\n\t* i386-protos.h (ix86_libcall_value, ix86_function_value,\n\tix86_function_arg_regno_p, ix86_function_arg_boundary,\n\tix86_return_in_memory, ix86_function_value): Declare.\n\t* i386.c (x86_64_int_parameter_registers, x86_64_int_return_registers):\n\tnew static valurables.\n\t(x86_64_reg_class): New enum\n\t(x86_64_reg_class_name): New array.\n\t(classify_argument, examine_argument, construct_container,\n\t merge_classes): New static functions.\n\t(optimization_options): Enable flag_omit_frame_pointer and disable\n\tflag_pcc_struct_return on 64bit.\n\t(ix86_libcall_value, ix86_function_value,\n\tix86_function_arg_regno_p, ix86_function_arg_boundary,\n\tix86_return_in_memory, ix86_function_value): New global functions.\n\t(init_cumulative_args): Refuse regparm on x86_64, set maybe_vaarg.\n\t(function_arg_advance): Handle x86_64 passing conventions.\n\t(function_arg): Likewise.\n\t* i386.h (FUNCTION_ARG_BOUNDARY): New macro.\n\t(RETURN_IN_MEMORY): Move offline.\n\t(FUNCTION_VALUE, LIBCALL_VALUE): Likewise.\n\t(FUNCTION_VALUE_REGNO_P): New macro.\n\t(FUNCTION_ARG_REGNO_P): Move offline.\n\t(struct ix86_args): Add maybe_vaarg.\n\t* next.h (FUNCTION_VALUE_REGNO_P): Delete.\n\t* unix.h (FUNCTION_VALUE_REGNO_P): Delete.\n\nFrom-SVN: r45726", "tree": {"sha": "270b09662a6e53b3a40319fd6d71ba88ad553f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/270b09662a6e53b3a40319fd6d71ba88ad553f13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53c170316f895dc3dfa7173e69fc43b15b7acb1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53c170316f895dc3dfa7173e69fc43b15b7acb1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53c170316f895dc3dfa7173e69fc43b15b7acb1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53c170316f895dc3dfa7173e69fc43b15b7acb1a/comments", "author": null, "committer": null, "parents": [{"sha": "f2d3c02aa02309b6bd102066f4961451fbcfc1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d3c02aa02309b6bd102066f4961451fbcfc1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d3c02aa02309b6bd102066f4961451fbcfc1bb"}], "stats": {"total": 1387, "additions": 1013, "deletions": 374}, "files": [{"sha": "4dfc2e023c4a4582a848c322cffef451b9d15410", "filename": "gcc/ChangeLog", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1,3 +1,103 @@\n+Fri Sep 21 14:24:29 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (flow_delete_insn, flow_delete_insn_chain): Kill.\n+\t* cfg.c (delete_insn): Rename from ....; use remove_insn; do not\n+\tremove some labels.\n+\t(flow_delete_insn): This one.\n+\t(delete_insn_chain): Rename from ...; do not care labels.\n+\t(flow_delete_insn_chain): ... this one.\n+\t(flow_delete_block): Remove the insns one BB has been expunged.\n+\t(merge_blocks_nomove): Likewise.\n+\t(try_redirect_by_replacing_jump): Use delete_insn[_chain]; do not care\n+\tupdating BB boundaries.\n+\t(tidy_fallthru_edge): Likewise.\n+\t(commit_one_edge_insertion): Likewise.\n+\t* cfgbuild.c (find_basic_block): Likewise.\n+\t(find_basic_blocks_1): Likewise.\n+\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps): Likewise.\n+\t(try_crossjump_to_edge): Likewise.\n+\t(try_optimize_cfg): Likewise.\n+\t* cse.c (delete_trivially_dead_insns): Likewise.\n+\t* df.c (df_insn_delete): Likewise.\n+\t* doloop.c (doloop_modify): Use delete_related_insns.\n+\t* emit-rtl.c (try_split): Likewise.\n+\t(remove_insn): Update BB boundaries.\n+\t* expect.c (connect_post_landing_pads): Use delete_related_insns.\n+\t* flow.c (delete_dead_jumptables): Use delete_insn[_chain]; do not care\n+\tupdating BB boundaries.\n+\t(propagate_block_delete_insn): Likewise.\n+\t(propagate_block_delete_libcall): Likewise.\n+\t* function.c (delete_handlers): Use delete_related_insns.\n+\t(thread_prologue_and_epilogue_insns): Likewise.\n+\t* gcse.c (delete_null_pointer_checks): Use delete_related_insns.\n+\t* genpeep.c (gen_peephole): Use delete_related_insns.\n+\t* ifcvt.c (noce_process_if_block): Use delete_insn; do not care updating\n+\tBB boundaries.\n+\t(find_cond_trap): Likewise.\n+\t* integrate.c (save_for_inline): Use delete_related_insns.\n+\t(copy_insn_list): Likewise.\n+\t* jump.c (pruge_linie_number_notes): Likewise.\n+\t(duplicate_loop_exit_test): Likewise.\n+\t(delete_computation): Likewise.\n+\t(delete_related_insn): Rename from ...; use delete_insn\n+\t(delete_insn): ... this one.\n+\t(redirect_jump): Use delete_related_insns.\n+\t* loop.c (scan_loop): Likewise.\n+\t(move_movables): Likewise.\n+\t(find_and_verify_loops): Likewise.\n+\t(check_dbra_loop): Likewise.\n+\t* recog.c (peephole2_optimize): Likewise.\n+\t* reg-stack.c (delete_insn_for_stacker): Remove.\n+\t(move_for_stack_reg): Use delete_insn.\n+\t* regmove.c (combine_stack_adjustments_for_block): Likewise.\n+\t* reload1.c (delete_address_reloads): Use delete_related_insns.\n+\t(fixup_abnormal_edges): Use delete_insn.\n+\t* recog.c (emit_delay_sequence): Use delete_related_insns.\n+\t(delete_from-delay_slot): Likewise.\n+\t(delete_scheduled_jump): likewise.\n+\t(optimize_skip): Likewise.\n+\t(try_merge_delay_insns): Likewise.\n+\t(full_simple_delay_slots): Likewise.\n+\t(fill_slots_from_thread): Likewise.\n+\t(relax_delay_slots): Likewise.\n+\t(make_return_insns): Likewise.\n+\t(dbr_schedule): Likewise.\n+\t* rtl.h (delete_insn): Rename to delete_related_insns.\n+\t(delete_insn, delete_insn_chain): New prototypes.\n+\t* ssa-ccp (sse_fast_dce):  Remove deleting of DEF, as it is done\n+\tby df_insn_delete already.\n+\t* ssa-dce.c (delete_insn_bb): Use delete_insn.\n+\t* ssa.c (convert_from_ssa): Use delete_related_insns.\n+\t* unroll.c (unroll_loop): Likewise.\n+\t(calculate_giv_inc): Likewise.\n+\t(copy_loop_body): Likewise.\n+\n+\t* i386-protos.h (ix86_libcall_value, ix86_function_value,\n+\tix86_function_arg_regno_p, ix86_function_arg_boundary,\n+\tix86_return_in_memory, ix86_function_value): Declare.\n+\t* i386.c (x86_64_int_parameter_registers, x86_64_int_return_registers):\n+\tnew static valurables.\n+\t(x86_64_reg_class): New enum\n+\t(x86_64_reg_class_name): New array.\n+\t(classify_argument, examine_argument, construct_container,\n+\t merge_classes): New static functions.\n+\t(optimization_options): Enable flag_omit_frame_pointer and disable\n+\tflag_pcc_struct_return on 64bit.\n+\t(ix86_libcall_value, ix86_function_value,\n+\tix86_function_arg_regno_p, ix86_function_arg_boundary,\n+\tix86_return_in_memory, ix86_function_value): New global functions.\n+\t(init_cumulative_args): Refuse regparm on x86_64, set maybe_vaarg.\n+\t(function_arg_advance): Handle x86_64 passing conventions.\n+\t(function_arg): Likewise.\n+\t* i386.h (FUNCTION_ARG_BOUNDARY): New macro.\n+\t(RETURN_IN_MEMORY): Move offline.\n+\t(FUNCTION_VALUE, LIBCALL_VALUE): Likewise.\n+\t(FUNCTION_VALUE_REGNO_P): New macro.\n+\t(FUNCTION_ARG_REGNO_P): Move offline.\n+\t(struct ix86_args): Add maybe_vaarg.\n+\t* next.h (FUNCTION_VALUE_REGNO_P): Delete.\n+\t* unix.h (FUNCTION_VALUE_REGNO_P): Delete.\n+\n 2001-09-21  Hartmut Penner  <hpenner@de.ibm.com>\n \n \t* s390.md: Changed attributes for scheduling."}, {"sha": "880d6ee908784dc0844cce6d83a6ffe8920c7830", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -303,8 +303,6 @@ extern void remove_fake_edges\t\tPARAMS ((void));\n extern void add_noreturn_fake_exit_edges\tPARAMS ((void));\n extern void connect_infinite_loops_to_exit\tPARAMS ((void));\n extern int flow_call_edges_add\t\tPARAMS ((sbitmap));\n-extern rtx flow_delete_insn\t\tPARAMS ((rtx));\n-extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n extern edge cached_make_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t basic_block, int));\n extern edge make_edge\t\t\tPARAMS ((basic_block,"}, {"sha": "9988ecd20990d05fd05004a5b148fe763a4f0781", "filename": "gcc/cfg.c", "status": "modified", "additions": 50, "deletions": 66, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -27,7 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      - Initialization/deallocation\n \t init_flow, clear_edges\n      - CFG aware instruction chain manipulation\n-\t flow_delete_insn, flow_delete_insn_chain\n+\t delete_insn, delete_insn_chain\n      - Basic block manipulation\n \t create_basic_block, flow_delete_block, split_block, merge_blocks_nomove\n      - Infrastructure to determine quickly basic block for instruction.\n@@ -242,26 +242,35 @@ can_delete_label_p (label)\n /* Delete INSN by patching it out.  Return the next insn.  */\n \n rtx\n-flow_delete_insn (insn)\n+delete_insn (insn)\n      rtx insn;\n {\n-  rtx prev = PREV_INSN (insn);\n   rtx next = NEXT_INSN (insn);\n   rtx note;\n+  bool really_delete = true;\n \n-  PREV_INSN (insn) = NULL_RTX;\n-  NEXT_INSN (insn) = NULL_RTX;\n-  INSN_DELETED_P (insn) = 1;\n+  if (GET_CODE (insn) == CODE_LABEL)\n+    {\n+      /* Some labels can't be directly removed from the INSN chain, as they\n+         might be references via variables, constant pool etc. \n+         Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n+      if (! can_delete_label_p (insn))\n+\t{\n+\t  const char *name = LABEL_NAME (insn);\n \n-  if (prev)\n-    NEXT_INSN (prev) = next;\n-  if (next)\n-    PREV_INSN (next) = prev;\n-  else\n-    set_last_insn (prev);\n+\t  really_delete = false;\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n+\t  NOTE_SOURCE_FILE (insn) = name;\n+\t}\n+      remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n+    }\n \n-  if (GET_CODE (insn) == CODE_LABEL)\n-    remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n+  if (really_delete)\n+    {\n+      remove_insn (insn);\n+      INSN_DELETED_P (insn) = 1;\n+    }\n \n   /* If deleting a jump, decrement the use count of the label.  Deleting\n      the label itself should happen in the normal course of block merging.  */\n@@ -295,7 +304,7 @@ flow_delete_insn (insn)\n    that must be paired.  */\n \n void\n-flow_delete_insn_chain (start, finish)\n+delete_insn_chain (start, finish)\n      rtx start, finish;\n {\n   /* Unchain the insns one by one.  It would be quicker to delete all\n@@ -309,16 +318,8 @@ flow_delete_insn_chain (start, finish)\n       next = NEXT_INSN (start);\n       if (GET_CODE (start) == NOTE && !can_delete_note_p (start))\n \t;\n-      else if (GET_CODE (start) == CODE_LABEL\n-\t       && ! can_delete_label_p (start))\n-\t{\n-\t  const char *name = LABEL_NAME (start);\n-\t  PUT_CODE (start, NOTE);\n-\t  NOTE_LINE_NUMBER (start) = NOTE_INSN_DELETED_LABEL;\n-\t  NOTE_SOURCE_FILE (start) = name;\n-\t}\n       else\n-\tnext = flow_delete_insn (start);\n+\tnext = delete_insn (start);\n \n       if (start == finish)\n \tbreak;\n@@ -510,19 +511,18 @@ flow_delete_block (b)\n     end = tmp;\n \n   /* Selectively delete the entire chain.  */\n-  flow_delete_insn_chain (insn, end);\n+  b->head = NULL;\n+  delete_insn_chain (insn, end);\n \n   /* Remove the edges into and out of this block.  Note that there may\n      indeed be edges in, if we are removing an unreachable loop.  */\n-  {\n-    while (b->pred != NULL)\n-      remove_edge (b->pred);\n-    while (b->succ != NULL)\n-      remove_edge (b->succ);\n+  while (b->pred != NULL)\n+    remove_edge (b->pred);\n+  while (b->succ != NULL)\n+    remove_edge (b->succ);\n \n-    b->pred = NULL;\n-    b->succ = NULL;\n-  }\n+  b->pred = NULL;\n+  b->succ = NULL;\n \n   /* Remove the basic block from the array, and compact behind it.  */\n   expunge_block (b);\n@@ -958,10 +958,6 @@ merge_blocks_nomove (a, b)\n   else if (GET_CODE (NEXT_INSN (a_end)) == BARRIER)\n     del_first = NEXT_INSN (a_end);\n \n-  /* Delete everything marked above as well as crap that might be\n-     hanging out between the two blocks.  */\n-  flow_delete_insn_chain (del_first, del_last);\n-\n   /* Normally there should only be one successor of A and that is B, but\n      partway though the merge of blocks for conditional_execution we'll\n      be merging a TEST block with THEN and ELSE successors.  Free the\n@@ -977,6 +973,12 @@ merge_blocks_nomove (a, b)\n   /* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */\n   b->pred = b->succ = NULL;\n \n+  expunge_block (b);\n+\n+  /* Delete everything marked above as well as crap that might be\n+     hanging out between the two blocks.  */\n+  delete_insn_chain (del_first, del_last);\n+\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n@@ -993,8 +995,6 @@ merge_blocks_nomove (a, b)\n       a_end = b_end;\n     }\n   a->end = a_end;\n-\n-  expunge_block (b);\n }\n \f\n /* Return label in the head of basic block.  Create one if it doesn't exist.  */\n@@ -1055,13 +1055,12 @@ try_redirect_by_replacing_jump (e, target)\n   /* See if we can create the fallthru edge.  */\n   if (can_fallthru (src, target))\n     {\n-      src->end = PREV_INSN (kill_from);\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n       fallthru = 1;\n \n       /* Selectivly unlink whole insn chain.  */\n-      flow_delete_insn_chain (kill_from, PREV_INSN (target->head));\n+      delete_insn_chain (kill_from, PREV_INSN (target->head));\n     }\n   /* If this already is simplejump, redirect it.  */\n   else if (simplejump_p (insn))\n@@ -1079,14 +1078,14 @@ try_redirect_by_replacing_jump (e, target)\n       rtx target_label = block_label (target);\n       rtx barrier;\n \n-      src->end = emit_jump_insn_before (gen_jump (target_label), kill_from);\n+      emit_jump_insn_after (gen_jump (target_label), kill_from);\n       JUMP_LABEL (src->end) = target_label;\n       LABEL_NUSES (target_label)++;\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n \t\t INSN_UID (insn), INSN_UID (src->end));\n \n-      flow_delete_insn_chain (kill_from, insn);\n+      delete_insn_chain (kill_from, insn);\n \n       barrier = next_nonnote_insn (src->end);\n       if (!barrier || GET_CODE (barrier) != BARRIER)\n@@ -1108,11 +1107,7 @@ try_redirect_by_replacing_jump (e, target)\n      the potential of changing the code between -g and not -g.  */\n   while (GET_CODE (e->src->end) == NOTE\n \t && NOTE_LINE_NUMBER (e->src->end) >= 0)\n-    {\n-      rtx prev = PREV_INSN (e->src->end);\n-      flow_delete_insn (e->src->end);\n-      e->src->end = prev;\n-    }\n+    delete_insn (e->src->end);\n \n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n@@ -1387,28 +1382,17 @@ tidy_fallthru_edge (e, b, c)\n \tq = PREV_INSN (q);\n #endif\n \n-      if (b->head == q)\n-\t{\n-\t  PUT_CODE (q, NOTE);\n-\t  NOTE_LINE_NUMBER (q) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (q) = 0;\n-\t}\n-      else\n-\t{\n-\t  q = PREV_INSN (q);\n-\n-\t  /* We don't want a block to end on a line-number note since that has\n-\t     the potential of changing the code between -g and not -g.  */\n-\t  while (GET_CODE (q) == NOTE && NOTE_LINE_NUMBER (q) >= 0)\n-\t    q = PREV_INSN (q);\n-\t}\n+      q = PREV_INSN (q);\n \n-      b->end = q;\n+      /* We don't want a block to end on a line-number note since that has\n+\t the potential of changing the code between -g and not -g.  */\n+      while (GET_CODE (q) == NOTE && NOTE_LINE_NUMBER (q) >= 0)\n+\tq = PREV_INSN (q);\n     }\n \n   /* Selectively unlink the sequence.  */\n   if (q != PREV_INSN (c->head))\n-    flow_delete_insn_chain (NEXT_INSN (q), PREV_INSN (c->head));\n+    delete_insn_chain (NEXT_INSN (q), PREV_INSN (c->head));\n \n   e->flags |= EDGE_FALLTHRU;\n }\n@@ -1692,7 +1676,7 @@ commit_one_edge_insertion (e)\n       emit_barrier_after (last);\n \n       if (before)\n-\tflow_delete_insn (before);\n+\tdelete_insn (before);\n     }\n   else if (GET_CODE (last) == JUMP_INSN)\n     abort ();"}, {"sha": "4afab8137a81c960fb1346350b86313f751760ac", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -442,7 +442,7 @@ find_basic_blocks_1 (f)\n \t\tif (bb_note == NULL_RTX)\n \t\t  bb_note = insn;\n \t\telse\n-\t\t  next = flow_delete_insn (insn);\n+\t\t  next = delete_insn (insn);\n \t      }\n \t    break;\n \t  }\n@@ -581,7 +581,7 @@ find_basic_blocks_1 (f)\n   if (head != NULL_RTX)\n     create_basic_block_structure (i++, head, end, bb_note);\n   else if (bb_note)\n-    flow_delete_insn (bb_note);\n+    delete_insn (bb_note);\n \n   if (i != n_basic_blocks)\n     abort ();"}, {"sha": "314d9f401cf6331bd2f50fef298ab79e8b48f3d7", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -277,7 +277,7 @@ merge_blocks_move_predecessor_nojumps (a, b)\n   barrier = next_nonnote_insn (a->end);\n   if (GET_CODE (barrier) != BARRIER)\n     abort ();\n-  flow_delete_insn (barrier);\n+  delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n      disturb their order.\n@@ -337,7 +337,7 @@ merge_blocks_move_successor_nojumps (a, b)\n \n   /* There had better have been a barrier there.  Delete it.  */\n   if (barrier && GET_CODE (barrier) == BARRIER)\n-    flow_delete_insn (barrier);\n+    delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n      disturb their order.\n@@ -901,12 +901,12 @@ try_crossjump_to_edge (mode, e1, e2)\n \n   /* Emit the jump insn.   */\n   label = block_label (redirect_to);\n-  src1->end = emit_jump_insn_before (gen_jump (label), newpos1);\n+  emit_jump_insn_after (gen_jump (label), src1->end);\n   JUMP_LABEL (src1->end) = label;\n   LABEL_NUSES (label)++;\n \n   /* Delete the now unreachable instructions.  */\n-  flow_delete_insn_chain (newpos1, last);\n+  delete_insn_chain (newpos1, last);\n \n   /* Make sure there is a barrier after the new jump.  */\n   last = next_nonnote_insn (src1->end);\n@@ -1078,7 +1078,7 @@ try_optimize_cfg (mode)\n \t    {\n \t      rtx label = b->head;\n \t      b->head = NEXT_INSN (b->head);\n-\t      flow_delete_insn_chain (label, label);\n+\t      delete_insn_chain (label, label);\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n \t\t\t b->index);"}, {"sha": "f69dd2a54419867d274e21789ba44d995ed3d690", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -135,6 +135,11 @@ extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n extern int x86_64_sign_extended_value PARAMS ((rtx));\n extern int x86_64_zero_extended_value PARAMS ((rtx));\n+extern rtx ix86_libcall_value PARAMS ((enum machine_mode));\n+extern bool ix86_function_value_regno_p PARAMS ((int));\n+extern bool ix86_function_arg_regno_p PARAMS ((int));\n+extern int ix86_function_arg_boundary PARAMS ((enum machine_mode, tree));\n+extern int ix86_return_in_memory PARAMS ((tree));\n \n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n@@ -160,6 +165,7 @@ extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));\n extern rtx function_arg PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n extern void function_arg_advance PARAMS ((CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t\ttree, int));\n+extern rtx ix86_function_value PARAMS ((tree));\n extern void ix86_init_builtins PARAMS ((void));\n extern void ix86_init_mmx_sse_builtins PARAMS ((void));\n extern rtx ix86_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));"}, {"sha": "c6c2340fb25a56fea4ea5ea06f97405954ccf033", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 692, "deletions": 35, "changes": 727, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -404,6 +404,12 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n };\n \n+static int x86_64_int_parameter_registers[6] = {5 /*RDI*/, 4 /*RSI*/,\n+\t\t\t\t\t        1 /*RDX*/, 2 /*RCX*/,\n+\t\t\t\t\t        FIRST_REX_INT_REG /*R8 */,\n+\t\t\t\t\t        FIRST_REX_INT_REG + 1 /*R9 */};\n+static int x86_64_int_return_registers[4] = {0 /*RAX*/, 1 /*RDI*/, 5, 4};\n+\n /* The \"default\" register map used in 64bit mode.  */\n int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n {\n@@ -668,6 +674,40 @@ static void ix86_svr3_asm_out_constructor PARAMS ((rtx, int));\n static void sco_asm_named_section PARAMS ((const char *, unsigned int));\n static void sco_asm_out_constructor PARAMS ((rtx, int));\n #endif\n+/* Register class used for passing given 64bit part of the argument.\n+   These represent classes as documented by the PS ABI, with the exception\n+   of SSESF, SSEDF classes, that are basically SSE class, just gcc will\n+   use SF or DFmode move instead of DImode to avoid reformating penalties.\n+\n+   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves\n+   whenever possible (upper half does contain padding).\n+ */\n+enum x86_64_reg_class\n+  {\n+    X86_64_NO_CLASS,\n+    X86_64_INTEGER_CLASS,\n+    X86_64_INTEGERSI_CLASS,\n+    X86_64_SSE_CLASS,\n+    X86_64_SSESF_CLASS,\n+    X86_64_SSEDF_CLASS,\n+    X86_64_SSEUP_CLASS,\n+    X86_64_X87_CLASS,\n+    X86_64_X87UP_CLASS,\n+    X86_64_MEMORY_CLASS\n+  };\n+const char * const x86_64_reg_class_name[] =\n+   {\"no\", \"integer\", \"integerSI\", \"sse\", \"sseSF\", \"sseDF\", \"sseup\", \"x87\", \"x87up\", \"no\"};\n+\n+#define MAX_CLASSES 4\n+static int classify_argument PARAMS ((enum machine_mode, tree,\n+\t\t\t\t      enum x86_64_reg_class [MAX_CLASSES],\n+\t\t\t\t      int));\n+static int examine_argument PARAMS ((enum machine_mode, tree, int, int *,\n+\t\t\t\t     int *));\n+static rtx construct_container PARAMS ((enum machine_mode, tree, int, int, int,\n+\t\t\t\t\tint *, int));\n+static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n+\t\t\t\t\t\t    enum x86_64_reg_class));\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -974,6 +1014,10 @@ optimization_options (level, size)\n   if (level > 1)\n     flag_schedule_insns = 0;\n #endif\n+  if (TARGET_64BIT && optimize >= 1)\n+    flag_omit_frame_pointer = 1;\n+  if (TARGET_64BIT)\n+    flag_pcc_struct_return = 0;\n }\n \f\n /* Table of valid machine attributes.  */\n@@ -1236,6 +1280,25 @@ ix86_return_pops_args (fundecl, funtype, size)\n \f\n /* Argument support functions.  */\n \n+/* Return true when register may be used to pass function parameters.  */\n+bool\n+ix86_function_arg_regno_p (regno)\n+     int regno;\n+{\n+  int i;\n+  if (!TARGET_64BIT)\n+    return regno < REGPARM_MAX || (TARGET_SSE && SSE_REGNO_P (regno));\n+  if (SSE_REGNO_P (regno) && TARGET_SSE)\n+    return true;\n+  /* RAX is used as hidden argument to va_arg functions.  */\n+  if (!regno)\n+    return true;\n+  for (i = 0; i < REGPARM_MAX; i++)\n+    if (regno == x86_64_int_parameter_registers[i])\n+      return true;\n+  return false;\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n@@ -1267,13 +1330,15 @@ init_cumulative_args (cum, fntype, libname)\n \n   /* Set up the number of registers to use for passing arguments.  */\n   cum->nregs = ix86_regparm;\n-  if (fntype)\n+  cum->sse_nregs = SSE_REGPARM_MAX;\n+  if (fntype && !TARGET_64BIT)\n     {\n       tree attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (fntype));\n \n       if (attr)\n \tcum->nregs = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n     }\n+  cum->maybe_vaarg = false;\n \n   /* Determine if this function has variable arguments.  This is\n      indicated by the last argument being 'void_type_mode' if there\n@@ -1287,16 +1352,461 @@ init_cumulative_args (cum, fntype, libname)\n \t{\n \t  next_param = TREE_CHAIN (param);\n \t  if (next_param == 0 && TREE_VALUE (param) != void_type_node)\n-\t    cum->nregs = 0;\n+\t    {\n+\t      if (!TARGET_64BIT)\n+\t\tcum->nregs = 0;\n+\t      cum->maybe_vaarg = true;\n+\t    }\n \t}\n     }\n+  if ((!fntype && !libname)\n+      || (fntype && !TYPE_ARG_TYPES (fntype)))\n+    cum->maybe_vaarg = 1;\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr, \", nregs=%d )\\n\", cum->nregs);\n \n   return;\n }\n \n+/* x86-64 register passing impleemntation.  See x86-64 ABI for details.  Goal\n+   of this code is to classify each 8bytes of incomming argument by the register\n+   class and assign registers accordingly.  */\n+\n+/* Return the union class of CLASS1 and CLASS2.\n+   See the x86-64 PS ABI for details.  */\n+\n+static enum x86_64_reg_class\n+merge_classes (class1, class2)\n+     enum x86_64_reg_class class1, class2;\n+{\n+  /* Rule #1: If both classes are equal, this is the resulting class.  */\n+  if (class1 == class2)\n+    return class1;\n+\n+  /* Rule #2: If one of the classes is NO_CLASS, the resulting class is\n+     the other class.  */\n+  if (class1 == X86_64_NO_CLASS)\n+    return class2;\n+  if (class2 == X86_64_NO_CLASS)\n+    return class1;\n+\n+  /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */\n+  if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)\n+    return X86_64_MEMORY_CLASS;\n+\n+  /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */\n+  if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)\n+      || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))\n+    return X86_64_INTEGERSI_CLASS;\n+  if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS\n+      || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)\n+    return X86_64_INTEGER_CLASS;\n+\n+  /* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */\n+  if (class1 == X86_64_X87_CLASS || class1 == X86_64_X87UP_CLASS\n+      || class2 == X86_64_X87_CLASS || class2 == X86_64_X87UP_CLASS)\n+    return X86_64_MEMORY_CLASS;\n+\n+  /* Rule #6: Otherwise class SSE is used.  */\n+  return X86_64_SSE_CLASS;\n+}\n+\n+/* Classify the argument of type TYPE and mode MODE.\n+   CLASSES will be filled by the register class used to pass each word\n+   of the operand.  The number of words is returned.  In case the parameter\n+   should be passed in memory, 0 is returned. As a special case for zero\n+   sized containers, classes[0] will be NO_CLASS and 1 is returned.\n+\n+   BIT_OFFSET is used internally for handling records and specifies offset\n+   of the offset in bits modulo 256 to avoid overflow cases.\n+\n+   See the x86-64 PS ABI for details.\n+*/\n+\n+static int\n+classify_argument (mode, type, classes, bit_offset)\n+     enum machine_mode mode;\n+     tree type;\n+     enum x86_64_reg_class classes[MAX_CLASSES];\n+     int bit_offset;\n+{\n+  int bytes =\n+    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n+  int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (type && AGGREGATE_TYPE_P (type))\n+    {\n+      int i;\n+      tree field;\n+      enum x86_64_reg_class subclasses[MAX_CLASSES];\n+\n+      /* On x86-64 we pass structures larger than 16 bytes on the stack.  */\n+      if (bytes > 16)\n+\treturn 0;\n+\n+      for (i = 0; i < words; i++)\n+\tclasses[i] = X86_64_NO_CLASS;\n+\n+      /* Zero sized arrays or structures are NO_CLASS.  We return 0 to\n+\t signalize memory class, so handle it as special case.  */\n+      if (!words)\n+\t{\n+\t  classes[0] = X86_64_NO_CLASS;\n+\t  return 1;\n+\t}\n+\n+      /* Classify each field of record and merge classes.  */\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      if (TREE_CODE (field) == FIELD_DECL)\n+\t\t{\n+\t\t  int num;\n+\n+\t\t  /* Bitfields are always classified as integer.  Handle them\n+\t\t     early, since later code would consider them to be\n+\t\t     misaligned integers.  */\n+\t\t  if (DECL_BIT_FIELD (field))\n+\t\t    {\n+\t\t      for (i = int_bit_position (field) / 8 / 8;\n+\t\t\t   i < (int_bit_position (field)\n+\t\t\t        + tree_low_cst (DECL_SIZE (field), 0)\n+\t\t\t       \t+ 63) / 8 / 8; i++)\n+\t\t\tclasses[i] =\n+\t\t\t  merge_classes (X86_64_INTEGER_CLASS,\n+\t\t\t\t\t classes[i]);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      num = classify_argument (TYPE_MODE (TREE_TYPE (field)),\n+\t\t\t\t\t       TREE_TYPE (field), subclasses,\n+\t\t\t\t\t       (int_bit_position (field)\n+\t\t\t\t\t\t+ bit_offset) % 256);\n+\t\t      if (!num)\n+\t\t\treturn 0;\n+\t\t      for (i = 0; i < num; i++)\n+\t\t\t{\n+\t\t\t  int pos =\n+\t\t\t    (int_bit_position (field) + bit_offset) / 8 / 8;\n+\t\t\t  classes[i + pos] =\n+\t\t\t    merge_classes (subclasses[i], classes[i + pos]);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      /* Arrays are handled as small records.  */\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  int num;\n+\t  num = classify_argument (TYPE_MODE (TREE_TYPE (type)),\n+\t\t\t\t   TREE_TYPE (type), subclasses, bit_offset);\n+\t  if (!num)\n+\t    return 0;\n+\n+\t  /* The partial classes are now full classes.  */\n+\t  if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)\n+\t    subclasses[0] = X86_64_SSE_CLASS;\n+\t  if (subclasses[0] == X86_64_INTEGERSI_CLASS && bytes != 4)\n+\t    subclasses[0] = X86_64_INTEGER_CLASS;\n+\n+\t  for (i = 0; i < words; i++)\n+\t    classes[i] = subclasses[i % num];\n+\t}\n+      /* Unions are similar to RECORD_TYPE but offset is always 0.  */\n+      else if (TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      if (TREE_CODE (field) == FIELD_DECL)\n+\t\t{\n+\t\t  int num;\n+\t\t  num = classify_argument (TYPE_MODE (TREE_TYPE (field)),\n+\t\t\t\t\t   TREE_TYPE (field), subclasses,\n+\t\t\t\t\t   bit_offset);\n+\t\t  if (!num)\n+\t\t    return 0;\n+\t\t  for (i = 0; i < num; i++)\n+\t\t    classes[i] = merge_classes (subclasses[i], classes[i]);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tabort ();\n+\n+      /* Final merger cleanup.  */\n+      for (i = 0; i < words; i++)\n+\t{\n+\t  /* If one class is MEMORY, everything should be passed in\n+\t     memory.  */\n+\t  if (classes[i] == X86_64_MEMORY_CLASS)\n+\t    return 0;\n+\n+\t  /* The X86_64_SSEUP_CLASS should be always preceeded by\n+\t     X86_64_SSE_CLASS.  */\n+\t  if (classes[i] == X86_64_SSEUP_CLASS\n+\t      && (i == 0 || classes[i - 1] != X86_64_SSE_CLASS))\n+\t    classes[i] = X86_64_SSE_CLASS;\n+\n+\t  /*  X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */\n+\t  if (classes[i] == X86_64_X87UP_CLASS\n+\t      && (i == 0 || classes[i - 1] != X86_64_X87_CLASS))\n+\t    classes[i] = X86_64_SSE_CLASS;\n+\t}\n+      return words;\n+    }\n+\n+  /* Compute alignment needed.  We align all types to natural boundaries with\n+     exception of XFmode that is aligned to 64bits.  */\n+  if (mode != VOIDmode && mode != BLKmode)\n+    {\n+      int mode_alignment = GET_MODE_BITSIZE (mode);\n+\n+      if (mode == XFmode)\n+\tmode_alignment = 128;\n+      else if (mode == XCmode)\n+\tmode_alignment = 256;\n+      /* Missalignmed fields are always returned in memory.  */\n+      if (bit_offset % mode_alignment)\n+\treturn 0;\n+    }\n+\n+  /* Classification of atomic types.  */\n+  switch (mode)\n+    {\n+    case DImode:\n+    case SImode:\n+    case HImode:\n+    case QImode:\n+    case CSImode:\n+    case CHImode:\n+    case CQImode:\n+      if (bit_offset + GET_MODE_BITSIZE (mode) <= 32)\n+\tclasses[0] = X86_64_INTEGERSI_CLASS;\n+      else\n+\tclasses[0] = X86_64_INTEGER_CLASS;\n+      return 1;\n+    case CDImode:\n+    case TImode:\n+      classes[0] = classes[1] = X86_64_INTEGER_CLASS;\n+      return 2;\n+    case CTImode:\n+      classes[0] = classes[1] = X86_64_INTEGER_CLASS;\n+      classes[2] = classes[3] = X86_64_INTEGER_CLASS;\n+      return 4;\n+    case SFmode:\n+      if (!(bit_offset % 64))\n+\tclasses[0] = X86_64_SSESF_CLASS;\n+      else\n+\tclasses[0] = X86_64_SSE_CLASS;\n+      return 1;\n+    case DFmode:\n+      classes[0] = X86_64_SSEDF_CLASS;\n+      return 1;\n+    case TFmode:\n+      classes[0] = X86_64_X87_CLASS;\n+      classes[1] = X86_64_X87UP_CLASS;\n+      return 2;\n+    case TCmode:\n+      classes[0] = X86_64_X87_CLASS;\n+      classes[1] = X86_64_X87UP_CLASS;\n+      classes[2] = X86_64_X87_CLASS;\n+      classes[3] = X86_64_X87UP_CLASS;\n+      return 4;\n+    case DCmode:\n+      classes[0] = X86_64_SSEDF_CLASS;\n+      classes[1] = X86_64_SSEDF_CLASS;\n+      return 2;\n+    case SCmode:\n+      classes[0] = X86_64_SSE_CLASS;\n+      return 1;\n+    case BLKmode:\n+      return 0;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Examine the argument and return set number of register required in each\n+   class.  Return 0 ifif parameter should be passed in memory.  */\n+static int\n+examine_argument (mode, type, in_return, int_nregs, sse_nregs)\n+     enum machine_mode mode;\n+     tree type;\n+     int *int_nregs, *sse_nregs;\n+     int in_return;\n+{\n+  enum x86_64_reg_class class[MAX_CLASSES];\n+  int n = classify_argument (mode, type, class, 0);\n+\n+  *int_nregs = 0;\n+  *sse_nregs = 0;\n+  if (!n)\n+    return 0;\n+  for (n--; n >= 0; n--)\n+    switch (class[n])\n+      {\n+      case X86_64_INTEGER_CLASS:\n+      case X86_64_INTEGERSI_CLASS:\n+\t(*int_nregs)++;\n+\tbreak;\n+      case X86_64_SSE_CLASS:\n+      case X86_64_SSESF_CLASS:\n+      case X86_64_SSEDF_CLASS:\n+\t(*sse_nregs)++;\n+\tbreak;\n+      case X86_64_NO_CLASS:\n+      case X86_64_SSEUP_CLASS:\n+\tbreak;\n+      case X86_64_X87_CLASS:\n+      case X86_64_X87UP_CLASS:\n+\tif (!in_return)\n+\t  return 0;\n+\tbreak;\n+      case X86_64_MEMORY_CLASS:\n+\tabort ();\n+      }\n+  return 1;\n+}\n+/* Construct container for the argument used by GCC interface.  See\n+   FUNCTION_ARG for the detailed description.  */\n+static rtx\n+construct_container (mode, type, in_return, nintregs, nsseregs, intreg, sse_regno)\n+     enum machine_mode mode;\n+     tree type;\n+     int in_return;\n+     int nintregs, nsseregs;\n+     int *intreg, sse_regno;\n+{\n+  enum machine_mode tmpmode;\n+  int bytes =\n+    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n+  enum x86_64_reg_class class[MAX_CLASSES];\n+  int n;\n+  int i;\n+  int nexps = 0;\n+  int needed_sseregs, needed_intregs;\n+  rtx exp[MAX_CLASSES];\n+  rtx ret;\n+\n+  n = classify_argument (mode, type, class, 0);\n+  if (TARGET_DEBUG_ARG)\n+    {\n+      if (!n)\n+\tfprintf (stderr, \"Memory class\\n\");\n+      else\n+\t{\n+\t  fprintf (stderr, \"Classes:\");\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      fprintf (stderr, \" %s\", x86_64_reg_class_name[class[i]]);\n+\t    }\n+\t   fprintf (stderr, \"\\n\");\n+\t}\n+    }\n+  if (!n)\n+    return NULL;\n+  if (!examine_argument (mode, type, in_return, &needed_intregs, &needed_sseregs))\n+    return NULL;\n+  if (needed_intregs > nintregs || needed_sseregs > nsseregs)\n+    return NULL;\n+\n+  /* First construct simple cases.  Avoid SCmode, since we want to use\n+     single register to pass this type.  */\n+  if (n == 1 && mode != SCmode)\n+    switch (class[0])\n+      {\n+      case X86_64_INTEGER_CLASS:\n+      case X86_64_INTEGERSI_CLASS:\n+\treturn gen_rtx_REG (mode, intreg[0]);\n+      case X86_64_SSE_CLASS:\n+      case X86_64_SSESF_CLASS:\n+      case X86_64_SSEDF_CLASS:\n+\treturn gen_rtx_REG (mode, SSE_REGNO (sse_regno));\n+      case X86_64_X87_CLASS:\n+\treturn gen_rtx_REG (mode, FIRST_STACK_REG);\n+      case X86_64_NO_CLASS:\n+\t/* Zero sized array, struct or class.  */\n+\treturn NULL;\n+      default:\n+\tabort ();\n+      }\n+  if (n == 2 && class[0] == X86_64_SSE_CLASS && class[1] == X86_64_SSEUP_CLASS)\n+    return gen_rtx_REG (TImode, SSE_REGNO (sse_regno));\n+  if (n == 2\n+      && class[0] == X86_64_X87_CLASS && class[1] == X86_64_X87UP_CLASS)\n+    return gen_rtx_REG (TFmode, FIRST_STACK_REG);\n+  if (n == 2 && class[0] == X86_64_INTEGER_CLASS\n+      && class[1] == X86_64_INTEGER_CLASS\n+      && (mode == CDImode || mode == TImode)\n+      && intreg[0] + 1 == intreg[1])\n+    return gen_rtx_REG (mode, intreg[0]);\n+  if (n == 4\n+      && class[0] == X86_64_X87_CLASS && class[1] == X86_64_X87UP_CLASS\n+      && class[2] == X86_64_X87_CLASS && class[3] == X86_64_X87UP_CLASS)\n+    return gen_rtx_REG (TCmode, FIRST_STACK_REG);\n+\n+  /* Otherwise figure out the entries of the PARALLEL.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      switch (class[i])\n+        {\n+\t  case X86_64_NO_CLASS:\n+\t    break;\n+\t  case X86_64_INTEGER_CLASS:\n+\t  case X86_64_INTEGERSI_CLASS:\n+\t    /* Merge TImodes on aligned occassions here too.  */\n+\t    if (i * 8 + 8 > bytes)\n+\t      tmpmode = mode_for_size ((bytes - i * 8) * BITS_PER_UNIT, MODE_INT, 0);\n+\t    else if (class[i] == X86_64_INTEGERSI_CLASS)\n+\t      tmpmode = SImode;\n+\t    else\n+\t      tmpmode = DImode;\n+\t    /* We've requested 24 bytes we don't have mode for.  Use DImode.  */\n+\t    if (tmpmode == BLKmode)\n+\t      tmpmode = DImode;\n+\t    exp [nexps++] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (tmpmode, *intreg),\n+\t\t\t\t\t       GEN_INT (i*8));\n+\t    intreg++;\n+\t    break;\n+\t  case X86_64_SSESF_CLASS:\n+\t    exp [nexps++] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (SFmode,\n+\t\t\t\t\t\t\t    SSE_REGNO (sse_regno)),\n+\t\t\t\t\t       GEN_INT (i*8));\n+\t    sse_regno++;\n+\t    break;\n+\t  case X86_64_SSEDF_CLASS:\n+\t    exp [nexps++] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (DFmode,\n+\t\t\t\t\t\t\t    SSE_REGNO (sse_regno)),\n+\t\t\t\t\t       GEN_INT (i*8));\n+\t    sse_regno++;\n+\t    break;\n+\t  case X86_64_SSE_CLASS:\n+\t    if (i < n && class[i + 1] == X86_64_SSEUP_CLASS)\n+\t      tmpmode = TImode, i++;\n+\t    else\n+\t      tmpmode = DImode;\n+\t    exp [nexps++] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (tmpmode,\n+\t\t\t\t\t\t\t    SSE_REGNO (sse_regno)),\n+\t\t\t\t\t       GEN_INT (i*8));\n+\t    sse_regno++;\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t}\n+    }\n+  ret =  gen_rtx_PARALLEL (mode, rtvec_alloc (nexps));\n+  for (i = 0; i < nexps; i++)\n+    XVECEXP (ret, 0, i) = exp [i];\n+  return ret;\n+}\n+\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n@@ -1316,27 +1826,45 @@ function_arg_advance (cum, mode, type, named)\n     fprintf (stderr,\n \t     \"function_adv (sz=%d, wds=%2d, nregs=%d, mode=%s, named=%d)\\n\\n\",\n \t     words, cum->words, cum->nregs, GET_MODE_NAME (mode), named);\n-  if (TARGET_SSE && mode == TImode)\n+  if (TARGET_64BIT)\n     {\n-      cum->sse_words += words;\n-      cum->sse_nregs -= 1;\n-      cum->sse_regno += 1;\n-      if (cum->sse_nregs <= 0)\n+      int int_nregs, sse_nregs;\n+      if (!examine_argument (mode, type, 0, &int_nregs, &sse_nregs))\n+\tcum->words += words;\n+      else if (sse_nregs <= cum->sse_nregs && int_nregs <= cum->nregs)\n \t{\n-\t  cum->sse_nregs = 0;\n-\t  cum->sse_regno = 0;\n+\t  cum->nregs -= int_nregs;\n+\t  cum->sse_nregs -= sse_nregs;\n+\t  cum->regno += int_nregs;\n+\t  cum->sse_regno += sse_nregs;\n \t}\n+      else\n+\tcum->words += words;\n     }\n   else\n     {\n-      cum->words += words;\n-      cum->nregs -= words;\n-      cum->regno += words;\n-\n-      if (cum->nregs <= 0)\n+      if (TARGET_SSE && mode == TImode)\n \t{\n-\t  cum->nregs = 0;\n-\t  cum->regno = 0;\n+\t  cum->sse_words += words;\n+\t  cum->sse_nregs -= 1;\n+\t  cum->sse_regno += 1;\n+\t  if (cum->sse_nregs <= 0)\n+\t    {\n+\t      cum->sse_nregs = 0;\n+\t      cum->sse_regno = 0;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  cum->words += words;\n+\t  cum->nregs -= words;\n+\t  cum->regno += words;\n+\n+\t  if (cum->nregs <= 0)\n+\t    {\n+\t      cum->nregs = 0;\n+\t      cum->regno = 0;\n+\t    }\n \t}\n     }\n   return;\n@@ -1367,28 +1895,44 @@ function_arg (cum, mode, type, named)\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n+  /* Handle an hidden AL argument containing number of registers for varargs\n+     x86-64 functions.  For i386 ABI just return constm1_rtx to avoid\n+     any AL settings.  */\n   if (mode == VOIDmode)\n-    return constm1_rtx;\n-\n-  switch (mode)\n     {\n-      /* For now, pass fp/complex values on the stack.  */\n-    default:\n-      break;\n-\n-    case BLKmode:\n-    case DImode:\n-    case SImode:\n-    case HImode:\n-    case QImode:\n-      if (words <= cum->nregs)\n-\tret = gen_rtx_REG (mode, cum->regno);\n-      break;\n-    case TImode:\n-      if (cum->sse_nregs)\n-        ret = gen_rtx_REG (mode, cum->sse_regno);\n-      break;\n+      if (TARGET_64BIT)\n+\treturn GEN_INT (cum->maybe_vaarg\n+\t\t\t? (cum->sse_nregs < 0\n+\t\t\t   ? SSE_REGPARM_MAX\n+\t\t\t   : cum->sse_regno)\n+\t\t\t: -1);\n+      else\n+\treturn constm1_rtx;\n     }\n+  if (TARGET_64BIT)\n+    ret = construct_container (mode, type, 0, cum->nregs, cum->sse_nregs,\n+\t\t\t       &x86_64_int_parameter_registers [cum->regno],\n+\t\t\t       cum->sse_regno);\n+  else\n+    switch (mode)\n+      {\n+\t/* For now, pass fp/complex values on the stack.  */\n+      default:\n+\tbreak;\n+\n+      case BLKmode:\n+      case DImode:\n+      case SImode:\n+      case HImode:\n+      case QImode:\n+\tif (words <= cum->nregs)\n+\t  ret = gen_rtx_REG (mode, cum->regno);\n+\tbreak;\n+      case TImode:\n+\tif (cum->sse_nregs)\n+\t  ret = gen_rtx_REG (mode, cum->sse_regno);\n+\tbreak;\n+      }\n \n   if (TARGET_DEBUG_ARG)\n     {\n@@ -1406,6 +1950,119 @@ function_arg (cum, mode, type, named)\n \n   return ret;\n }\n+\n+/* Gives the alignment boundary, in bits, of an argument with the specified mode\n+   and type.   */\n+\n+int\n+ix86_function_arg_boundary (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  int align;\n+  if (!TARGET_64BIT)\n+    return PARM_BOUNDARY;\n+  if (type)\n+    align = TYPE_ALIGN (type);\n+  else\n+    align = GET_MODE_ALIGNMENT (mode);\n+  if (align < PARM_BOUNDARY)\n+    align = PARM_BOUNDARY;\n+  if (align > 128)\n+    align = 128;\n+  return align;\n+}\n+\n+/* Return true if N is a possible register number of function value.  */\n+bool\n+ix86_function_value_regno_p (regno)\n+     int regno;\n+{\n+  if (!TARGET_64BIT)\n+    {\n+      return ((regno) == 0\n+\t      || ((regno) == FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387)\n+\t      || ((regno) == FIRST_SSE_REG && TARGET_SSE));\n+    }\n+  return ((regno) == 0 || (regno) == FIRST_FLOAT_REG\n+\t  || ((regno) == FIRST_SSE_REG && TARGET_SSE)\n+\t  || ((regno) == FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387));\n+}\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+rtx\n+ix86_function_value (valtype)\n+     tree valtype;\n+{\n+  if (TARGET_64BIT)\n+    {\n+      rtx ret = construct_container (TYPE_MODE (valtype), valtype, 1,\n+\t\t\t\t     REGPARM_MAX, SSE_REGPARM_MAX,\n+\t\t\t\t     x86_64_int_return_registers, 0);\n+      /* For zero sized structures, construct_continer return NULL, but we need\n+         to keep rest of compiler happy by returning meaningfull value.  */\n+      if (!ret)\n+\tret = gen_rtx_REG (TYPE_MODE (valtype), 0);\n+      return ret;\n+    }\n+  else\n+    return gen_rtx_REG (TYPE_MODE (valtype), VALUE_REGNO (TYPE_MODE (valtype)));\n+}\n+\n+/* Return false ifif type is returned in memory.  */\n+int\n+ix86_return_in_memory (type)\n+     tree type;\n+{\n+  int needed_intregs, needed_sseregs;\n+  if (TARGET_64BIT)\n+    {\n+      return !examine_argument (TYPE_MODE (type), type, 1,\n+\t\t\t\t&needed_intregs, &needed_sseregs);\n+    }\n+  else\n+    {\n+      if (TYPE_MODE (type) == BLKmode\n+\t  || (VECTOR_MODE_P (TYPE_MODE (type))\n+\t      && int_size_in_bytes (type) == 8)\n+\t  || (int_size_in_bytes (type) > 12 && TYPE_MODE (type) != TImode\n+\t      && TYPE_MODE (type) != TFmode\n+\t      && !VECTOR_MODE_P (TYPE_MODE (type))))\n+\treturn 1;\n+      return 0;\n+    }\n+}\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+rtx\n+ix86_libcall_value (mode)\n+   enum machine_mode mode;\n+{\n+  if (TARGET_64BIT)\n+    {\n+      switch (mode)\n+\t{\n+\t  case SFmode:\n+\t  case SCmode:\n+\t  case DFmode:\n+\t  case DCmode:\n+\t    return gen_rtx_REG (mode, FIRST_SSE_REG);\n+\t  case TFmode:\n+\t  case TCmode:\n+\t    return gen_rtx_REG (mode, FIRST_FLOAT_REG);\n+\t  default:\n+\t    return gen_rtx_REG (mode, 0);\n+\t}\n+    }\n+  else\n+   return gen_rtx_REG (mode, VALUE_REGNO (mode));\n+}\n+\n+\n \f\n \n /* Return nonzero if OP is general operand representable on x86_64.  */"}, {"sha": "4d76ac67b29b4ccc065eaf136c9fcd19b3f346b4", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -720,6 +720,12 @@ extern int ix86_arch;\n \n #define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment (TYPE, ALIGN)\n \n+/* If defined, a C expression that gives the alignment boundary, in\n+   bits, of an argument with the specified mode and type.  If it is\n+   not defined, `PARM_BOUNDARY' is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE,TYPE) ix86_function_arg_boundary (MODE, TYPE)\n+\n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n@@ -1062,10 +1068,7 @@ extern int ix86_arch;\n    `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n \n #define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n-  ((TYPE_MODE (TYPE) == BLKmode)\t\t\t\t\t\\\n-   || (VECTOR_MODE_P (TYPE_MODE (TYPE)) && int_size_in_bytes (TYPE) == 8)\\\n-   || (int_size_in_bytes (TYPE) > 12 && TYPE_MODE (TYPE) != TImode\t\\\n-       && TYPE_MODE (TYPE) != TFmode && ! VECTOR_MODE_P (TYPE_MODE (TYPE))))\n+  ix86_return_in_memory (TYPE)\n \n \f\n /* Define the classes of registers for register constraints in the\n@@ -1517,14 +1520,16 @@ enum reg_class\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-   gen_rtx_REG (TYPE_MODE (VALTYPE), \\\n-\t\tVALUE_REGNO (TYPE_MODE (VALTYPE)))\n+   ix86_function_value (VALTYPE)\n+\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+  ix86_function_value_regno_p (N)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx_REG (MODE, VALUE_REGNO (MODE))\n+  ix86_libcall_value (MODE)\n \n /* Define the size of the result block used for communication between\n    untyped_call and untyped_return.  The block contains a DImode value\n@@ -1533,7 +1538,7 @@ enum reg_class\n #define APPLY_RESULT_SIZE (8+108)\n \n /* 1 if N is a possible register number for function argument passing.  */\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < REGPARM_MAX)\n+#define FUNCTION_ARG_REGNO_P(N) ix86_function_arg_regno_p (N)\n \n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -1548,6 +1553,7 @@ typedef struct ix86_args {\n   int sse_words;\t\t/* # sse words passed so far */\n   int sse_nregs;\t\t/* # sse registers available for passing */\n   int sse_regno;\t\t/* next available sse register number */\n+  int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts. */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "729ae4ccb5f45842aa32dc46ae8c72191673ea2d", "filename": "gcc/config/i386/next.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fnext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Fnext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnext.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -42,11 +42,6 @@ Boston, MA 02111-1307, USA.  */\n   ((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode\t\\\n    ? FIRST_FLOAT_REG : 0)\n \n-/* 1 if N is a possible register number for a function value. */\n-\n-#undef\tFUNCTION_VALUE_REGNO_P\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N)== FIRST_FLOAT_REG)\n-\n #ifdef REAL_VALUE_TO_TARGET_LONG_DOUBLE\n #undef\tASM_OUTPUT_LONG_DOUBLE\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\t\t\\"}, {"sha": "15a07018cf3671f8606d155242703bd87caa529e", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -77,11 +77,6 @@ Boston, MA 02111-1307, USA.  */\n    : (MODE) == TImode || VECTOR_MODE_P (MODE) ? FIRST_SSE_REG\t\\\n    : 0)\n \n-/* 1 if N is a possible register number for a function value. */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) \\\n-  ((N) == 0 || ((N)== FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387))\n-\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n #define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t    \\"}, {"sha": "00019c2cd5ce39be5b35d63112b043463cbf0376", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -7646,7 +7646,7 @@ delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n \tif (! live_insn)\n \t  {\n \t    count_reg_usage (insn, counts, NULL_RTX, -1);\n-\t    delete_insn (insn);\n+\t    delete_related_insns (insn);\n \t  }\n \n \tif (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n@@ -7687,9 +7687,7 @@ delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n \t  if (! live_insn)\n \t    {\n \t      count_reg_usage (insn, counts, NULL_RTX, -1);\n-\t      if (insn == bb->end)\n-\t\tbb->end = PREV_INSN (insn);\n-\t      flow_delete_insn (insn);\n+\t      delete_insn (insn);\n \t    }\n \n \t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))"}, {"sha": "6d124a86b46625640a3f911df451a7de664869e4", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -2593,13 +2593,9 @@ df_insn_delete (df, bb, insn)\n   /* We should not be deleting the NOTE_INSN_BASIC_BLOCK or label.  */\n   if (insn == bb->head)\n     abort ();\n-  if (insn == bb->end)\n-    bb->end = PREV_INSN (insn);  \n \n   /* Delete the insn.  */\n-  PUT_CODE (insn, NOTE);\n-  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (insn) = 0;\n+  delete_insn (insn);\n \n   df_insn_modify (df, bb, insn);\n "}, {"sha": "283080bb4295872c6f3c7bb83f10fee547787d59", "filename": "gcc/doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -423,7 +423,7 @@ doloop_modify (loop, iterations, iterations_max,\n \n   /* Discard original jump to continue loop.  The original compare\n      result may still be live, so it cannot be discarded explicitly.  */\n-  delete_insn (jump_insn);\n+  delete_related_insns (jump_insn);\n \n   counter_reg = XEXP (condition, 0);\n   if (GET_CODE (counter_reg) == PLUS)"}, {"sha": "1c449d69f1b4ef355dcef8073d71575f3bcefa4f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -2613,7 +2613,7 @@ try_split (pat, trial, last)\n \n \t  tem = emit_insn_after (seq, trial);\n \n-\t  delete_insn (trial);\n+\t  delete_related_insns (trial);\n \t  if (has_barrier)\n \t    emit_barrier_after (tem);\n \n@@ -2873,6 +2873,8 @@ remove_insn (insn)\n {\n   rtx next = NEXT_INSN (insn);\n   rtx prev = PREV_INSN (insn);\n+  basic_block bb;\n+\n   if (prev)\n     {\n       NEXT_INSN (prev) = next;\n@@ -2921,6 +2923,21 @@ remove_insn (insn)\n       if (stack == 0)\n \tabort ();\n     }\n+  if (basic_block_for_insn\n+      && (unsigned int)INSN_UID (insn) < basic_block_for_insn->num_elements\n+      && (bb = BLOCK_FOR_INSN (insn)))\n+    {\n+      if (bb->head == insn)\n+\t{\n+\t  /* Never ever delete the basic block note without deleting whole basic\n+\t     block.  */\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    abort ();\n+\t  bb->head = next;\n+\t}\n+      if (bb->end == insn)\n+\tbb->end = prev;\n+    }\n }\n \n /* Delete all insns made since FROM."}, {"sha": "0f0b6621e308fff51a5d003beecf48a24a431c52", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1850,7 +1850,7 @@ connect_post_landing_pads ()\n       seq = get_insns ();\n       end_sequence ();\n       emit_insns_before (seq, region->resume);\n-      flow_delete_insn (region->resume);\n+      delete_insn (region->resume);\n     }\n }\n "}, {"sha": "eb1d23a12e243ce88e5a6efcb198a59eae018628", "filename": "gcc/flow.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -771,7 +771,7 @@ delete_noop_moves (f)\n \t  next = NEXT_INSN (insn);\n \t  if (INSN_P (insn) && noop_move_p (insn))\n \t    {\n-\t      /* Do not call flow_delete_insn here to not confuse backward\n+\t      /* Do not call delete_insn here to not confuse backward\n \t         pointers of LIBCALL block.  */\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n@@ -802,8 +802,8 @@ delete_dead_jumptables ()\n \t{\n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \"Dead jumptable %i removed\\n\", INSN_UID (insn));\n-\t  flow_delete_insn (NEXT_INSN (insn));\n-\t  flow_delete_insn (insn);\n+\t  delete_insn (NEXT_INSN (insn));\n+\t  delete_insn (insn);\n \t  next = NEXT_INSN (next);\n \t}\n     }\n@@ -1323,6 +1323,7 @@ propagate_block_delete_insn (bb, insn)\n      rtx insn;\n {\n   rtx inote = find_reg_note (insn, REG_LABEL, NULL_RTX);\n+  bool purge = false;\n \n   /* If the insn referred to a label, and that label was attached to\n      an ADDR_VEC, it's safe to delete the ADDR_VEC.  In fact, it's\n@@ -1360,16 +1361,15 @@ propagate_block_delete_insn (bb, insn)\n \t  for (i = 0; i < len; i++)\n \t    LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n \n-\t  flow_delete_insn (next);\n+\t  delete_insn (next);\n \t}\n     }\n \n   if (bb->end == insn)\n-    {\n-      bb->end = PREV_INSN (insn);\n-      purge_dead_edges (bb);\n-    }\n-  flow_delete_insn (insn);\n+    purge = true;\n+  delete_insn (insn);\n+  if (purge)\n+    purge_dead_edges (bb);\n }\n \n /* Delete dead libcalls for propagate_block.  Return the insn\n@@ -1383,10 +1383,7 @@ propagate_block_delete_libcall (bb, insn, note)\n   rtx first = XEXP (note, 0);\n   rtx before = PREV_INSN (first);\n \n-  if (insn == bb->end)\n-    bb->end = before;\n-\n-  flow_delete_insn_chain (first, insn);\n+  delete_insn_chain (first, insn);\n   return before;\n }\n "}, {"sha": "592842efde1303804b1692f526173ebac4b559c9", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -4140,7 +4140,7 @@ delete_handlers ()\n \t      || (nonlocal_goto_stack_level != 0\n \t\t  && reg_mentioned_p (nonlocal_goto_stack_level,\n \t\t\t\t      PATTERN (insn))))\n-\t    delete_insn (insn);\n+\t    delete_related_insns (insn);\n \t}\n     }\n }\n@@ -7300,7 +7300,7 @@ thread_prologue_and_epilogue_insns (f)\n \t      if (simplejump_p (jump))\n \t\t{\n \t\t  emit_return_into_block (bb, epilogue_line_note);\n-\t\t  flow_delete_insn (jump);\n+\t\t  delete_insn (jump);\n \t\t}\n \n \t      /* If we have a conditional jump, we can try to replace"}, {"sha": "6cc915f650bddee4fa70732643357c98a2e4a810", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -5456,7 +5456,7 @@ delete_null_pointer_checks (f)\n   if (delete_list)\n     {\n       for (i = 0; i < VARRAY_ACTIVE_SIZE (delete_list); i++)\n-\tdelete_insn (VARRAY_RTX (delete_list, i));\n+\tdelete_related_insns (VARRAY_RTX (delete_list, i));\n       VARRAY_FREE (delete_list);\n     }\n \n@@ -6836,7 +6836,7 @@ replace_store_insn (reg, del, bb)\n       fprintf(gcse_file, \"\\n\");\n     }\n   \n-  delete_insn (del);\n+  delete_related_insns (del);\n }\n \n "}, {"sha": "6d70cbad5a4a3ddd9a4e0ee3bf0204ff82367a78", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -119,7 +119,7 @@ gen_peephole (peep)\n   printf (\"  if (want_jump && GET_CODE (ins1) != JUMP_INSN)\\n\");\n   printf (\"    {\\n\");\n   printf (\"      rtx insn2 = emit_jump_insn_before (PATTERN (ins1), ins1);\\n\");\n-  printf (\"      delete_insn (ins1);\\n\");\n+  printf (\"      delete_related_insns (ins1);\\n\");\n   printf (\"      ins1 = ins2;\\n\");\n   printf (\"    }\\n\");\n #endif"}, {"sha": "fcbc645d32b24e69c7ff1bd518b7cb57f1f01e44", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1765,9 +1765,7 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n \n  success:\n   /* The original sets may now be killed.  */\n-  if (insn_a == then_bb->end)\n-    then_bb->end = PREV_INSN (insn_a);\n-  flow_delete_insn (insn_a);\n+  delete_insn (insn_a);\n \n   /* Several special cases here: First, we may have reused insn_b above,\n      in which case insn_b is now NULL.  Second, we want to delete insn_b\n@@ -1776,17 +1774,12 @@ noce_process_if_block (test_bb, then_bb, else_bb, join_bb)\n      the TEST block, it may in fact be loading data needed for the comparison.\n      We'll let life_analysis remove the insn if it's really dead.  */\n   if (insn_b && else_bb)\n-    {\n-      if (insn_b == else_bb->end)\n-\telse_bb->end = PREV_INSN (insn_b);\n-      flow_delete_insn (insn_b);\n-    }\n+    delete_insn (insn_b);\n \n   /* The new insns will have been inserted before cond_earliest.  We should\n      be able to remove the jump with impunity, but the condition itself may\n      have been modified by gcse to be shared across basic blocks.  */\n-  test_bb->end = PREV_INSN (jump);\n-  flow_delete_insn (jump);\n+  delete_insn (jump);\n \n   /* If we used a temporary, fix it up now.  */\n   if (orig_x != x)\n@@ -2189,11 +2182,9 @@ find_cond_trap (test_bb, then_edge, else_edge)\n \n   emit_insn_before (seq, cond_earliest);\n \n-  test_bb->end = PREV_INSN (jump);\n-  flow_delete_insn (jump);\n+  delete_insn (jump);\n \n-  trap_bb->end = PREV_INSN (trap);\n-  flow_delete_insn (trap);\n+  delete_insn (trap);\n \n   /* Merge the blocks!  */\n   if (trap_bb != then_bb && ! else_bb)"}, {"sha": "1bc85b150e72c1833753d4cc4186b389f90effdd", "filename": "gcc/integrate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -460,7 +460,7 @@ save_for_inline (fndecl)\n      for basic_block structures on already freed obstack.  */\n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n-      delete_insn (insn);\n+      delete_related_insns (insn);\n \n   /* If there are insns that copy parms from the stack into pseudo registers,\n      those insns are not copied.  `expand_inline_function' must\n@@ -1492,13 +1492,13 @@ copy_insn_list (insns, map, static_chain_value)\n #ifdef HAVE_cc0\n \t      /* If the previous insn set cc0 for us, delete it.  */\n \t      if (only_sets_cc0_p (PREV_INSN (copy)))\n-\t\tdelete_insn (PREV_INSN (copy));\n+\t\tdelete_related_insns (PREV_INSN (copy));\n #endif\n \n \t      /* If this is now a no-op, delete it.  */\n \t      if (map->last_pc_value == pc_rtx)\n \t\t{\n-\t\t  delete_insn (copy);\n+\t\t  delete_related_insns (copy);\n \t\t  copy = 0;\n \t\t}\n \t      else"}, {"sha": "544b67267c81f84043b972d72baf96f0ff50a288", "filename": "gcc/jump.c", "status": "modified", "additions": 23, "deletions": 68, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -182,7 +182,7 @@ purge_line_number_notes (f)\n \t\t&& NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last_note)\n \t\t&& NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last_note))\n \t      {\n-\t\tdelete_insn (insn);\n+\t\tdelete_related_insns (insn);\n \t\tcontinue;\n \t      }\n \n@@ -529,7 +529,7 @@ duplicate_loop_exit_test (loop_start)\n   /* Mark the exit code as the virtual top of the converted loop.  */\n   emit_note_before (NOTE_INSN_LOOP_VTOP, exitcode);\n \n-  delete_insn (next_nonnote_insn (loop_start));\n+  delete_related_insns (next_nonnote_insn (loop_start));\n \n   /* Clean up.  */\n   if (reg_map)\n@@ -1710,24 +1710,24 @@ delete_computation (insn)\n       delete_prior_computation (note, insn);\n     }\n \n-  delete_insn (insn);\n+  delete_related_insns (insn);\n }\n \f\n-/* Delete insn INSN from the chain of insns and update label ref counts.\n-   May delete some following insns as a consequence; may even delete\n-   a label elsewhere and insns that follow it.\n+/* Delete insn INSN from the chain of insns and update label ref counts\n+   and delete insns now unreachable. \n+\n+   Returns the first insn after INSN that was not deleted. \n \n-   Returns the first insn after INSN that was not deleted.  */\n+   Usage of this instruction is deprecated.  Use delete_insn instead and\n+   subsequent cfg_cleanup pass to delete unreachable code if needed.  */\n \n rtx\n-delete_insn (insn)\n+delete_related_insns (insn)\n      register rtx insn;\n {\n-  register rtx next = NEXT_INSN (insn);\n-  register rtx prev = PREV_INSN (insn);\n   register int was_code_label = (GET_CODE (insn) == CODE_LABEL);\n-  register int dont_really_delete = 0;\n   rtx note;\n+  rtx next = NEXT_INSN (insn), prev = PREV_INSN (insn);\n \n   while (next && INSN_DELETED_P (next))\n     next = NEXT_INSN (next);\n@@ -1736,58 +1736,13 @@ delete_insn (insn)\n   if (INSN_DELETED_P (insn))\n     return next;\n \n-  if (was_code_label)\n-    remove_node_from_expr_list (insn, &nonlocal_goto_handler_labels);\n-\n-  /* Don't delete user-declared labels.  When optimizing, convert them\n-     to special NOTEs instead.  When not optimizing, leave them alone.  */\n-  if (was_code_label && LABEL_NAME (insn) != 0)\n-    {\n-      if (optimize)\n-\t{\n-\t  const char *name = LABEL_NAME (insn);\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n-\t  NOTE_SOURCE_FILE (insn) = name;\n-\t}\n-\n-      dont_really_delete = 1;\n-    }\n-  else\n-    /* Mark this insn as deleted.  */\n-    INSN_DELETED_P (insn) = 1;\n+  delete_insn (insn);\n \n   /* If instruction is followed by a barrier,\n      delete the barrier too.  */\n \n   if (next != 0 && GET_CODE (next) == BARRIER)\n-    {\n-      INSN_DELETED_P (next) = 1;\n-      next = NEXT_INSN (next);\n-    }\n-\n-  /* Patch out INSN (and the barrier if any) */\n-\n-  if (! dont_really_delete)\n-    {\n-      if (prev)\n-\t{\n-\t  NEXT_INSN (prev) = next;\n-\t  if (GET_CODE (prev) == INSN && GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\t    NEXT_INSN (XVECEXP (PATTERN (prev), 0,\n-\t\t\t\tXVECLEN (PATTERN (prev), 0) - 1)) = next;\n-\t}\n-\n-      if (next)\n-\t{\n-\t  PREV_INSN (next) = prev;\n-\t  if (GET_CODE (next) == INSN && GET_CODE (PATTERN (next)) == SEQUENCE)\n-\t    PREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = prev;\n-\t}\n-\n-      if (prev && NEXT_INSN (prev) == 0)\n-\tset_last_insn (prev);\n-    }\n+    delete_insn (next);\n \n   /* If deleting a jump, decrement the count of the label,\n      and delete the label if it is now unused.  */\n@@ -1796,12 +1751,12 @@ delete_insn (insn)\n     {\n       rtx lab = JUMP_LABEL (insn), lab_next;\n \n-      if (--LABEL_NUSES (lab) == 0)\n+      if (LABEL_NUSES (lab) == 0)\n \t{\n \t  /* This can delete NEXT or PREV,\n \t     either directly if NEXT is JUMP_LABEL (INSN),\n \t     or indirectly through more levels of jumps.  */\n-\t  delete_insn (lab);\n+\t  delete_related_insns (lab);\n \n \t  /* I feel a little doubtful about this loop,\n \t     but I see no clean and sure alternative way\n@@ -1820,7 +1775,7 @@ delete_insn (insn)\n \t     We may not be able to kill the label immediately preceeding\n \t     just yet, as it might be referenced in code leading up to\n \t     the tablejump.  */\n-\t  delete_insn (lab_next);\n+\t  delete_related_insns (lab_next);\n \t}\n     }\n \n@@ -1835,8 +1790,8 @@ delete_insn (insn)\n       int len = XVECLEN (pat, diff_vec_p);\n \n       for (i = 0; i < len; i++)\n-\tif (--LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0)) == 0)\n-\t  delete_insn (XEXP (XVECEXP (pat, diff_vec_p, i), 0));\n+\tif (LABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0)) == 0)\n+\t  delete_related_insns (XEXP (XVECEXP (pat, diff_vec_p, i), 0));\n       while (next && INSN_DELETED_P (next))\n \tnext = NEXT_INSN (next);\n       return next;\n@@ -1848,8 +1803,8 @@ delete_insn (insn)\n       if (REG_NOTE_KIND (note) == REG_LABEL\n \t  /* This could also be a NOTE_INSN_DELETED_LABEL note.  */\n \t  && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n-\tif (--LABEL_NUSES (XEXP (note, 0)) == 0)\n-\t  delete_insn (XEXP (note, 0));\n+\tif (LABEL_NUSES (XEXP (note, 0)) == 0)\n+\t  delete_related_insns (XEXP (note, 0));\n \n   while (prev && (INSN_DELETED_P (prev) || GET_CODE (prev) == NOTE))\n     prev = PREV_INSN (prev);\n@@ -1863,7 +1818,7 @@ delete_insn (insn)\n       && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n       && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n \t  || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n-    next = delete_insn (NEXT_INSN (insn));\n+    next = delete_related_insns (NEXT_INSN (insn));\n \n   /* If INSN was a label, delete insns following it if now unreachable.  */\n \n@@ -1886,7 +1841,7 @@ delete_insn (insn)\n \t       deletion of unreachable code, after a different label.\n \t       As long as the value from this recursive call is correct,\n \t       this invocation functions correctly.  */\n-\t    next = delete_insn (next);\n+\t    next = delete_related_insns (next);\n \t}\n     }\n \n@@ -2128,7 +2083,7 @@ redirect_jump (jump, nlabel, delete_unused)\n     emit_note_after (NOTE_INSN_FUNCTION_END, nlabel);\n \n   if (olabel && --LABEL_NUSES (olabel) == 0 && delete_unused)\n-    delete_insn (olabel);\n+    delete_related_insns (olabel);\n \n   return 1;\n }"}, {"sha": "d27e05880393f23c2e43f845288825f5796ab306", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1047,7 +1047,7 @@ scan_loop (loop, flags)\n \n       if (update_end && GET_CODE (update_end) == CODE_LABEL\n \t  && --LABEL_NUSES (update_end) == 0)\n-\tdelete_insn (update_end);\n+\tdelete_related_insns (update_end);\n     }\n \n \n@@ -1774,7 +1774,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t    = gen_rtx_EXPR_LIST (VOIDmode, r1,\n \t\t\t\t\t gen_rtx_EXPR_LIST (VOIDmode, r2,\n \t\t\t\t\t\t\t    regs_may_share));\n-\t\t  delete_insn (m->insn);\n+\t\t  delete_related_insns (m->insn);\n \n \t\t  if (new_start == 0)\n \t\t    new_start = i1;\n@@ -1805,11 +1805,11 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t{\n \t\t\t  temp = XEXP (temp, 0);\n \t\t\t  while (temp != p)\n-\t\t\t    temp = delete_insn (temp);\n+\t\t\t    temp = delete_related_insns (temp);\n \t\t\t}\n \n \t\t      temp = p;\n-\t\t      p = delete_insn (p);\n+\t\t      p = delete_related_insns (p);\n \n \t\t      /* simplify_giv_expr expects that it can walk the insns\n \t\t\t at m->insn forwards and see this old sequence we are\n@@ -1936,7 +1936,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t      if (temp == fn_address_insn)\n \t\t\t\tfn_address_insn = i1;\n \t\t\t      REG_NOTES (i1) = REG_NOTES (temp);\n-\t\t\t      delete_insn (temp);\n+\t\t\t      delete_related_insns (temp);\n \t\t\t    }\n \t\t\t  if (new_start == 0)\n \t\t\t    new_start = first;\n@@ -2031,7 +2031,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t}\n \n \t\t      temp = p;\n-\t\t      delete_insn (p);\n+\t\t      delete_related_insns (p);\n \t\t      p = NEXT_INSN (p);\n \n \t\t      /* simplify_giv_expr expects that it can walk the insns\n@@ -2110,9 +2110,9 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t{\n \t\t\t  for (temp = XEXP (temp, 0); temp != m1->insn;\n \t\t\t       temp = NEXT_INSN (temp))\n-\t\t\t    delete_insn (temp);\n+\t\t\t    delete_related_insns (temp);\n \t\t\t}\n-\t\t      delete_insn (m1->insn);\n+\t\t      delete_related_insns (m1->insn);\n \n \t\t      /* Any other movable that loads the same register\n \t\t\t MUST be moved.  */\n@@ -2799,7 +2799,7 @@ find_and_verify_loops (f, loops)\n \t\t\tif (JUMP_LABEL (insn) != 0\n \t\t\t    && (next_real_insn (JUMP_LABEL (insn))\n \t\t\t\t== next_real_insn (insn)))\n-\t\t\t  delete_insn (insn);\n+\t\t\t  delete_related_insns (insn);\n \t\t      }\n \n \t\t    /* Continue the loop after where the conditional\n@@ -2809,7 +2809,7 @@ find_and_verify_loops (f, loops)\n \t\t    insn = NEXT_INSN (cond_label);\n \n \t\t    if (--LABEL_NUSES (cond_label) == 0)\n-\t\t      delete_insn (cond_label);\n+\t\t      delete_related_insns (cond_label);\n \n \t\t    /* This loop will be continued with NEXT_INSN (insn).  */\n \t\t    insn = PREV_INSN (insn);\n@@ -7628,7 +7628,7 @@ check_dbra_loop (loop, insn_count)\n \t      end_sequence ();\n \n \t      p = loop_insn_emit_before (loop, 0, bl->biv->insn, tem);\n-\t      delete_insn (bl->biv->insn);\n+\t      delete_related_insns (bl->biv->insn);\n \n \t      /* Update biv info to reflect its new status.  */\n \t      bl->biv->insn = p;\n@@ -7656,9 +7656,9 @@ check_dbra_loop (loop, insn_count)\n \t\tloop_insn_sink (loop, gen_move_insn (reg, final_value));\n \n \t      /* Delete compare/branch at end of loop.  */\n-\t      delete_insn (PREV_INSN (loop_end));\n+\t      delete_related_insns (PREV_INSN (loop_end));\n \t      if (compare_and_branch == 2)\n-\t\tdelete_insn (first_compare);\n+\t\tdelete_related_insns (first_compare);\n \n \t      /* Add new compare/branch insn at end of loop.  */\n \t      start_sequence ();"}, {"sha": "7f723f97e114c9776663fb99cc70ec825f260476", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -3128,7 +3128,7 @@ peephole2_optimize (dump_file)\n \n \t\t  /* Replace the old sequence with the new.  */\n \t\t  try = emit_insn_after (try, peep2_insn_data[i].insn);\n-\t\t  flow_delete_insn_chain (insn, peep2_insn_data[i].insn);\n+\t\t  delete_insn_chain (insn, peep2_insn_data[i].insn);\n \n #ifdef HAVE_conditional_execution\n \t\t  /* With conditional execution, we cannot back up the"}, {"sha": "c247048b4d63658dfec74ab87d8695197b3e7129", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -245,7 +245,6 @@ static void replace_reg\t\t\tPARAMS ((rtx *, int));\n static void remove_regno_note\t\tPARAMS ((rtx, enum reg_note,\n \t\t\t\t\t\t unsigned int));\n static int get_hard_regnum\t\tPARAMS ((stack, rtx));\n-static void delete_insn_for_stacker\tPARAMS ((rtx));\n static rtx emit_pop_insn\t\tPARAMS ((rtx, stack, rtx,\n \t\t\t\t\t       enum emit_where));\n static void emit_swap_insn\t\tPARAMS ((rtx, stack, rtx));\n@@ -907,19 +906,6 @@ get_hard_regnum (regstack, reg)\n \n   return i >= 0 ? (FIRST_STACK_REG + regstack->top - i) : -1;\n }\n-\n-/* Delete INSN from the RTL.  Mark the insn, but don't remove it from\n-   the chain of insns.  Doing so could confuse block_begin and block_end\n-   if this were the only insn in the block.  */\n-\n-static void\n-delete_insn_for_stacker (insn)\n-     rtx insn;\n-{\n-  PUT_CODE (insn, NOTE);\n-  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (insn) = 0;\n-}\n \f\n /* Emit an insn to pop virtual register REG before or after INSN.\n    REGSTACK is the stack state after INSN and is updated to reflect this\n@@ -1114,7 +1100,7 @@ move_for_stack_reg (insn, regstack, pat)\n \t    {\n \t      emit_pop_insn (insn, regstack, src, EMIT_AFTER);\n \n-\t      delete_insn_for_stacker (insn);\n+\t      delete_insn (insn);\n \t      return;\n \t    }\n \n@@ -1123,7 +1109,7 @@ move_for_stack_reg (insn, regstack, pat)\n \t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n \t  CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (src));\n \n-\t  delete_insn_for_stacker (insn);\n+\t  delete_insn (insn);\n \n \t  return;\n \t}\n@@ -1140,7 +1126,7 @@ move_for_stack_reg (insn, regstack, pat)\n \t  if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n \t    emit_pop_insn (insn, regstack, dest, EMIT_AFTER);\n \n-\t  delete_insn_for_stacker (insn);\n+\t  delete_insn (insn);\n \t  return;\n \t}\n "}, {"sha": "48f97640832aefd5d30286f02dbdab2ebd3f9563", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -2408,7 +2408,7 @@ combine_stack_adjustments_for_block (bb)\n \t\t\t\t\t\t  -last_sp_adjust))\n \t\t    {\n \t\t      /* It worked!  */\n-\t\t      flow_delete_insn (last_sp_set);\n+\t\t      delete_insn (last_sp_set);\n \t\t      last_sp_set = insn;\n \t\t      last_sp_adjust += this_adjust;\n \t\t      free_csa_memlist (memlist);\n@@ -2450,7 +2450,7 @@ combine_stack_adjustments_for_block (bb)\n \t    {\n \t      if (last_sp_set == bb->head)\n \t\tbb->head = NEXT_INSN (last_sp_set);\n-\t      flow_delete_insn (last_sp_set);\n+\t      delete_insn (last_sp_set);\n \n \t      free_csa_memlist (memlist);\n \t      memlist = NULL;\n@@ -2487,12 +2487,9 @@ combine_stack_adjustments_for_block (bb)\n \tbreak;\n \n       if (pending_delete)\n-\tflow_delete_insn (pending_delete);\n+\tdelete_insn (pending_delete);\n     }\n \n   if (pending_delete)\n-    {\n-      bb->end = PREV_INSN (pending_delete);\n-      flow_delete_insn (pending_delete);\n-    }\n+    delete_insn (pending_delete);\n }"}, {"sha": "1636337281e4f52e31641ccf98bc774a29ece2e1", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -7744,8 +7744,8 @@ delete_address_reloads (dead_insn, current_insn)\n       || (INTVAL (XEXP (SET_SRC (set), 1))\n \t  != -INTVAL (XEXP (SET_SRC (set2), 1))))\n     return;\n-  delete_insn (prev);\n-  delete_insn (next);\n+  delete_related_insns (prev);\n+  delete_related_insns (next);\n }\n \n /* Subfunction of delete_address_reloads: process registers found in X.  */\n@@ -9519,7 +9519,7 @@ fixup_abnormal_edges ()\n \t      if (INSN_P (insn))\n \t\t{\n \t          insert_insn_on_edge (PATTERN (insn), e);\n-\t          flow_delete_insn (insn);\n+\t          delete_insn (insn);\n \t\t}\n \t      insn = next;\n \t    }"}, {"sha": "986ef671eca898f69673276f619d69d6045c19f0", "filename": "gcc/reorg.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -455,7 +455,7 @@ emit_delay_sequence (insn, list, length)\n      We will put the BARRIER back in later.  */\n   if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n     {\n-      delete_insn (NEXT_INSN (insn));\n+      delete_related_insns (NEXT_INSN (insn));\n       last = get_last_insn ();\n       had_barrier = 1;\n     }\n@@ -590,7 +590,7 @@ delete_from_delay_slot (insn)\n      list, and rebuild the delay list if non-empty.  */\n   prev = PREV_INSN (seq_insn);\n   trial = XVECEXP (seq, 0, 0);\n-  delete_insn (seq_insn);\n+  delete_related_insns (seq_insn);\n   add_insn_after (trial, prev);\n \n   if (GET_CODE (trial) == JUMP_INSN\n@@ -651,14 +651,14 @@ delete_scheduled_jump (insn)\n \t      || FIND_REG_INC_NOTE (trial, 0))\n \t    return;\n \t  if (PREV_INSN (NEXT_INSN (trial)) == trial)\n-\t    delete_insn (trial);\n+\t    delete_related_insns (trial);\n \t  else\n \t    delete_from_delay_slot (trial);\n \t}\n     }\n #endif\n \n-  delete_insn (insn);\n+  delete_related_insns (insn);\n }\n \f\n /* Counters for delay-slot filling.  */\n@@ -762,7 +762,7 @@ optimize_skip (insn)\n       delay_list = add_to_delay_list (trial, NULL_RTX);\n       next_trial = next_active_insn (trial);\n       update_block (trial, trial);\n-      delete_insn (trial);\n+      delete_related_insns (trial);\n \n       /* Also, if we are targeting an unconditional\n \t branch, thread our jump to the target of that branch.  Don't\n@@ -1510,7 +1510,7 @@ try_merge_delay_insns (insn, thread)\n \t      if (trial == thread)\n \t\tthread = next_active_insn (thread);\n \n-\t      delete_insn (trial);\n+\t      delete_related_insns (trial);\n \t      INSN_FROM_TARGET_P (next_to_match) = 0;\n \t    }\n \t  else\n@@ -1603,7 +1603,7 @@ try_merge_delay_insns (insn, thread)\n \t  else\n \t    {\n \t      update_block (XEXP (merged_insns, 0), thread);\n-\t      delete_insn (XEXP (merged_insns, 0));\n+\t      delete_related_insns (XEXP (merged_insns, 0));\n \t    }\n \t}\n \n@@ -2191,7 +2191,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t      delay_list = gen_rtx_INSN_LIST (VOIDmode,\n \t\t\t\t\t\t      trial, delay_list);\n \t\t      update_block (trial, trial);\n-\t\t      delete_insn (trial);\n+\t\t      delete_related_insns (trial);\n \t\t      if (slots_to_fill == ++slots_filled)\n \t\t\tbreak;\n \t\t      continue;\n@@ -2329,7 +2329,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t      link_cc0_insns (trial);\n #endif\n \n-\t\t    delete_insn (trial);\n+\t\t    delete_related_insns (trial);\n \t\t    if (slots_to_fill == ++slots_filled)\n \t\t      break;\n \t\t    continue;\n@@ -2488,7 +2488,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t\t\t     current_function_epilogue_delay_list);\n \t      mark_end_of_function_resources (trial, 1);\n \t      update_block (trial, trial);\n-\t      delete_insn (trial);\n+\t      delete_related_insns (trial);\n \n \t      /* Clear deleted bit so final.c will output the insn.  */\n \t      INSN_DELETED_P (trial) = 0;\n@@ -2636,7 +2636,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t\tnew_thread = thread;\n \t\t    }\n \n-\t\t  delete_insn (trial);\n+\t\t  delete_related_insns (trial);\n \t\t}\n \t      else\n \t\t{\n@@ -2710,7 +2710,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t\t  if (new_thread == trial)\n \t\t\t    new_thread = thread;\n \t\t\t}\n-\t\t      delete_insn (trial);\n+\t\t      delete_related_insns (trial);\n \t\t    }\n \t\t  else\n \t\t    new_thread = next_active_insn (trial);\n@@ -2869,7 +2869,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t  if (recog_memoized (ninsn) < 0\n \t      || (extract_insn (ninsn), ! constrain_operands (1)))\n \t    {\n-\t      delete_insn (ninsn);\n+\t      delete_related_insns (ninsn);\n \t      return 0;\n \t    }\n \n@@ -2882,7 +2882,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t  if (new_thread == trial)\n \t\t    new_thread = thread;\n \t\t}\n-\t      delete_insn (trial);\n+\t      delete_related_insns (trial);\n \t    }\n \t  else\n \t    new_thread = next_active_insn (trial);\n@@ -3128,15 +3128,15 @@ relax_delay_slots (first)\n \n \t      if (invert_jump (insn, label, 1))\n \t\t{\n-\t\t  delete_insn (next);\n+\t\t  delete_related_insns (next);\n \t\t  next = insn;\n \t\t}\n \n \t      if (label)\n \t\t--LABEL_NUSES (label);\n \n \t      if (--LABEL_NUSES (target_label) == 0)\n-\t\tdelete_insn (target_label);\n+\t\tdelete_related_insns (target_label);\n \n \t      continue;\n \t    }\n@@ -3212,7 +3212,7 @@ relax_delay_slots (first)\n \t    INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)) = 0;\n \n \t  trial = PREV_INSN (insn);\n-\t  delete_insn (insn);\n+\t  delete_related_insns (insn);\n \t  emit_insn_after (pat, trial);\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n@@ -3325,7 +3325,7 @@ relax_delay_slots (first)\n \t    INSN_FROM_TARGET_P (XVECEXP (pat, 0, i)) = 0;\n \n \t  trial = PREV_INSN (insn);\n-\t  delete_insn (insn);\n+\t  delete_related_insns (insn);\n \t  emit_insn_after (pat, trial);\n \t  delete_scheduled_jump (delay_insn);\n \t  continue;\n@@ -3340,7 +3340,7 @@ relax_delay_slots (first)\n \t  && XVECLEN (pat, 0) == 2\n \t  && rtx_equal_p (PATTERN (next), PATTERN (XVECEXP (pat, 0, 1))))\n \t{\n-\t  delete_insn (insn);\n+\t  delete_related_insns (insn);\n \t  continue;\n \t}\n \n@@ -3384,12 +3384,12 @@ relax_delay_slots (first)\n \t\t      INSN_FROM_TARGET_P (slot) = ! INSN_FROM_TARGET_P (slot);\n \t\t    }\n \n-\t\t  delete_insn (next);\n+\t\t  delete_related_insns (next);\n \t\t  next = insn;\n \t\t}\n \n \t      if (old_label && --LABEL_NUSES (old_label) == 0)\n-\t\tdelete_insn (old_label);\n+\t\tdelete_related_insns (old_label);\n \t      continue;\n \t    }\n \t}\n@@ -3508,7 +3508,7 @@ make_return_insns (first)\n \t{\n \t  rtx prev = PREV_INSN (insn);\n \n-\t  delete_insn (insn);\n+\t  delete_related_insns (insn);\n \t  for (i = 1; i < XVECLEN (pat, 0); i++)\n \t    prev = emit_insn_after (PATTERN (XVECEXP (pat, 0, i)), prev);\n \n@@ -3527,7 +3527,7 @@ make_return_insns (first)\n   /* Now delete REAL_RETURN_LABEL if we never used it.  Then try to fill any\n      new delay slots we have created.  */\n   if (--LABEL_NUSES (real_return_label) == 0)\n-    delete_insn (real_return_label);\n+    delete_related_insns (real_return_label);\n \n   fill_simple_delay_slots (1);\n   fill_simple_delay_slots (0);\n@@ -3637,14 +3637,14 @@ dbr_schedule (first, file)\n \n       if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE\n \t  && INSN_P (XEXP (PATTERN (insn), 0)))\n-\tnext = delete_insn (insn);\n+\tnext = delete_related_insns (insn);\n     }\n \n   /* If we made an end of function label, indicate that it is now\n      safe to delete it by undoing our prior adjustment to LABEL_NUSES.\n      If it is now unused, delete it.  */\n   if (end_of_function_label && --LABEL_NUSES (end_of_function_label) == 0)\n-    delete_insn (end_of_function_label);\n+    delete_related_insns (end_of_function_label);\n \n #ifdef HAVE_return\n   if (HAVE_return && end_of_function_label != 0)"}, {"sha": "7deb964e5a3094632f470363a467a27c365a27af", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1288,7 +1288,7 @@ extern void cleanup_barriers\t\tPARAMS ((void));\n \n /* In jump.c */\n extern void squeeze_notes\t\tPARAMS ((rtx *, rtx *));\n-extern rtx delete_insn\t\t\tPARAMS ((rtx));\n+extern rtx delete_related_insns\t\t\tPARAMS ((rtx));\n extern void delete_jump\t\t\tPARAMS ((rtx));\n extern void delete_barrier\t\tPARAMS ((rtx));\n extern rtx get_label_before\t\tPARAMS ((rtx));\n@@ -1775,6 +1775,8 @@ int force_line_numbers PARAMS ((void));\n void restore_line_number_status PARAMS ((int old_value));\n extern void renumber_insns                      PARAMS ((FILE *));\n extern void remove_unnecessary_notes             PARAMS ((void));\n+extern rtx delete_insn\t\t\tPARAMS ((rtx));\n+extern void delete_insn_chain\t\tPARAMS ((rtx, rtx));\n \n /* In combine.c */\n extern int combine_instructions\t\tPARAMS ((rtx, unsigned int));"}, {"sha": "047b29d82b2a8a81cd8d5288b7b24410573c6d5b", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -1208,32 +1208,6 @@ ssa_fast_dce (df)\n \t     deleted.  */\n \t  df_insn_delete (df, BLOCK_FOR_INSN (def), def);\n \n-\t  if (PHI_NODE_P (def))\n-\t    {\n-\t      if (def == BLOCK_FOR_INSN (def)->head\n-\t\t  && def == BLOCK_FOR_INSN (def)->end)\n-\t\t{\n-\t\t  /* Delete it.  */\n-\t\t  PUT_CODE (def, NOTE);\n-\t\t  NOTE_LINE_NUMBER (def) = NOTE_INSN_DELETED;\n-\t\t}\n-\t      else if (def == BLOCK_FOR_INSN (def)->head)\n-\t        {\n-\t\t  BLOCK_FOR_INSN (def)->head = NEXT_INSN (def);\n-\t\t  flow_delete_insn (def);\n-\t\t}\n-\t      else if (def == BLOCK_FOR_INSN (def)->end)\n-\t\t{\n-\t\t  BLOCK_FOR_INSN (def)->end = PREV_INSN (def);\n-\t\t  flow_delete_insn (def);\n-\t\t}\n-\t      else\n-\t\tflow_delete_insn (def);\n-\t    }\n-\t  else\n-\t    {\n-\t      flow_delete_insn (def);\n-\t    }\n \t  VARRAY_RTX (ssa_definition, reg) = NULL;\n \t}\n     }"}, {"sha": "62e59e80bfce4297d4bc1c2745cd2c4475af6bdf", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -468,7 +468,6 @@ static void\n delete_insn_bb (insn)\n      rtx insn;\n {\n-  basic_block bb;\n   if (!insn)\n     abort ();\n \n@@ -480,20 +479,6 @@ delete_insn_bb (insn)\n   if (! INSN_P (insn))\n     return;\n \n-  bb = BLOCK_FOR_INSN (insn);\n-  if (!bb)\n-    abort ();\n-  if (bb->head == bb->end)\n-    {\n-      /* Delete the insn by converting it to a note.  */\n-      PUT_CODE (insn, NOTE);\n-      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-      return;\n-    }\n-  else if (insn == bb->head)\n-    bb->head = NEXT_INSN (insn);\n-  else if (insn == bb->end)\n-    bb->end = PREV_INSN (insn);\n   delete_insn (insn);\n }\n \f"}, {"sha": "55aef891cf136b0b8ad8a647f8f468c9890d7e91", "filename": "gcc/ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -2186,7 +2186,7 @@ convert_from_ssa()\n \t    {\n \t      if (insn == BLOCK_END (bb))\n \t\tBLOCK_END (bb) = PREV_INSN (insn);\n-\t      insn = delete_insn (insn);\n+\t      insn = delete_related_insns (insn);\n \t    }\n \t  /* Since all the phi nodes come at the beginning of the\n \t     block, if we find an ordinary insn, we can stop looking"}, {"sha": "f3f565681d8a6fd2409d987cafdd4d65d6b7a4c2", "filename": "gcc/unroll.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53c170316f895dc3dfa7173e69fc43b15b7acb1a/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=53c170316f895dc3dfa7173e69fc43b15b7acb1a", "patch": "@@ -355,7 +355,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \n       rtx ujump = ujump_to_loop_cont (loop->start, loop->cont);\n       if (ujump)\n-\tdelete_insn (ujump);\n+\tdelete_related_insns (ujump);\n \n       /* If number of iterations is exactly 1, then eliminate the compare and\n \t branch at the end of the loop since they will never be taken.\n@@ -367,31 +367,31 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n       if (GET_CODE (last_loop_insn) == BARRIER)\n \t{\n \t  /* Delete the jump insn.  This will delete the barrier also.  */\n-\t  delete_insn (PREV_INSN (last_loop_insn));\n+\t  delete_related_insns (PREV_INSN (last_loop_insn));\n \t}\n       else if (GET_CODE (last_loop_insn) == JUMP_INSN)\n \t{\n #ifdef HAVE_cc0\n \t  rtx prev = PREV_INSN (last_loop_insn);\n #endif\n-\t  delete_insn (last_loop_insn);\n+\t  delete_related_insns (last_loop_insn);\n #ifdef HAVE_cc0\n \t  /* The immediately preceding insn may be a compare which must be\n \t     deleted.  */\n \t  if (only_sets_cc0_p (prev))\n-\t    delete_insn (prev);\n+\t    delete_related_insns (prev);\n #endif\n \t}\n \n       /* Remove the loop notes since this is no longer a loop.  */\n       if (loop->vtop)\n-\tdelete_insn (loop->vtop);\n+\tdelete_related_insns (loop->vtop);\n       if (loop->cont)\n-\tdelete_insn (loop->cont);\n+\tdelete_related_insns (loop->cont);\n       if (loop_start)\n-\tdelete_insn (loop_start);\n+\tdelete_related_insns (loop_start);\n       if (loop_end)\n-\tdelete_insn (loop_end);\n+\tdelete_related_insns (loop_end);\n \n       return;\n     }\n@@ -1291,16 +1291,16 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t  && ! (GET_CODE (insn) == CODE_LABEL && LABEL_NAME (insn))\n \t  && ! (GET_CODE (insn) == NOTE\n \t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))\n-\tinsn = delete_insn (insn);\n+\tinsn = delete_related_insns (insn);\n       else\n \tinsn = NEXT_INSN (insn);\n     }\n \n   /* Can now delete the 'safety' label emitted to protect us from runaway\n-     delete_insn calls.  */\n+     delete_related_insns calls.  */\n   if (INSN_DELETED_P (safety_label))\n     abort ();\n-  delete_insn (safety_label);\n+  delete_related_insns (safety_label);\n \n   /* If exit_label exists, emit it after the loop.  Doing the emit here\n      forces it to have a higher INSN_UID than any insn in the unrolled loop.\n@@ -1315,13 +1315,13 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n     {\n       /* Remove the loop notes since this is no longer a loop.  */\n       if (loop->vtop)\n-\tdelete_insn (loop->vtop);\n+\tdelete_related_insns (loop->vtop);\n       if (loop->cont)\n-\tdelete_insn (loop->cont);\n+\tdelete_related_insns (loop->cont);\n       if (loop_start)\n-\tdelete_insn (loop_start);\n+\tdelete_related_insns (loop_start);\n       if (loop_end)\n-\tdelete_insn (loop_end);\n+\tdelete_related_insns (loop_end);\n     }\n \n   if (map->const_equiv_varray)\n@@ -1562,7 +1562,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \n       /* The last insn emitted is not needed, so delete it to avoid confusing\n \t the second cse pass.  This insn sets the giv unnecessarily.  */\n-      delete_insn (get_last_insn ());\n+      delete_related_insns (get_last_insn ());\n     }\n \n   /* Verify that we have a constant as the second operand of the plus.  */\n@@ -1601,7 +1601,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \t  src_insn = PREV_INSN (src_insn);\n \t  increment = SET_SRC (PATTERN (src_insn));\n \t  /* Don't need the last insn anymore.  */\n-\t  delete_insn (get_last_insn ());\n+\t  delete_related_insns (get_last_insn ());\n \n \t  if (GET_CODE (second_part) != CONST_INT\n \t      || GET_CODE (increment) != CONST_INT)\n@@ -1620,7 +1620,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \n       /* The insn loading the constant into a register is no longer needed,\n \t so delete it.  */\n-      delete_insn (get_last_insn ());\n+      delete_related_insns (get_last_insn ());\n     }\n \n   if (increment_total)\n@@ -1644,7 +1644,7 @@ calculate_giv_inc (pattern, src_insn, regno)\n \t  src_insn = PREV_INSN (src_insn);\n \t  pattern = PATTERN (src_insn);\n \n-\t  delete_insn (get_last_insn ());\n+\t  delete_related_insns (get_last_insn ());\n \n \t  goto retry;\n \t}\n@@ -2148,7 +2148,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n #ifdef HAVE_cc0\n \t      /* If the previous insn set cc0 for us, delete it.  */\n \t      if (only_sets_cc0_p (PREV_INSN (copy)))\n-\t\tdelete_insn (PREV_INSN (copy));\n+\t\tdelete_related_insns (PREV_INSN (copy));\n #endif\n \n \t      /* If this is now a no-op, delete it.  */\n@@ -2159,7 +2159,7 @@ copy_loop_body (loop, copy_start, copy_end, map, exit_label, last_iteration,\n \t\t     instruction in the loop.  */\n \t\t  if (JUMP_LABEL (copy))\n \t\t    LABEL_NUSES (JUMP_LABEL (copy))++;\n-\t\t  delete_insn (copy);\n+\t\t  delete_related_insns (copy);\n \t\t  if (JUMP_LABEL (copy))\n \t\t    LABEL_NUSES (JUMP_LABEL (copy))--;\n \t\t  copy = 0;\n@@ -2954,7 +2954,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t      /* We can't use bl->initial_value to compute the initial\n \t\t\t value, because the loop may have been preconditioned.\n \t\t\t We must calculate it from NEW_REG.  */\n-\t\t      delete_insn (PREV_INSN (loop->start));\n+\t\t      delete_related_insns (PREV_INSN (loop->start));\n \n \t\t      start_sequence ();\n \t\t      ret = force_operand (v->new_reg, tem);"}]}