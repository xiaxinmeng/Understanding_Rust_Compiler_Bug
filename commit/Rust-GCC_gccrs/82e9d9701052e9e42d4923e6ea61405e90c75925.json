{"sha": "82e9d9701052e9e42d4923e6ea61405e90c75925", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJlOWQ5NzAxMDUyZTllNDJkNDkyM2U2ZWE2MTQwNWU5MGM3NTkyNQ==", "commit": {"author": {"name": "Philip Blundell", "email": "pb@futuretv.com", "date": "2000-02-09T20:00:29Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-09T20:00:29Z"}, "message": "Apply Philip Blundell's patch to fix PIC operands.\n\nFrom-SVN: r31867", "tree": {"sha": "55bfeafb6ed144ccc170fd248c857c4e3da12819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55bfeafb6ed144ccc170fd248c857c4e3da12819"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82e9d9701052e9e42d4923e6ea61405e90c75925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e9d9701052e9e42d4923e6ea61405e90c75925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82e9d9701052e9e42d4923e6ea61405e90c75925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e9d9701052e9e42d4923e6ea61405e90c75925/comments", "author": null, "committer": null, "parents": [{"sha": "2387c1d4329e53fe34eca418bb29b97793313f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2387c1d4329e53fe34eca418bb29b97793313f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2387c1d4329e53fe34eca418bb29b97793313f4a"}], "stats": {"total": 302, "additions": 269, "deletions": 33}, "files": [{"sha": "2e17b20aa486f71dac818683f27d42829522104a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82e9d9701052e9e42d4923e6ea61405e90c75925", "patch": "@@ -1,3 +1,12 @@\n+2000-02-09  Philip Blundell  <pb@futuretv.com>\n+\n+        * config/arm/arm.c (legitimize_pic_address): Handle LABEL_REF\n+        correctly.\n+\n+        * config/arm/arm.h (LEGITIMATE_CONSTANT_P): Allow anything when\n+        generating PIC.\n+        (LEGITIMATE_PIC_OPERAND): Disallow references to labels.\n+\n 2000-02-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplib.c (cpp_define, cpp_undef): Make sure the stacked buffer"}, {"sha": "6560893fb101c06e07c75240412b5db1f296a08e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 189, "deletions": 1, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=82e9d9701052e9e42d4923e6ea61405e90c75925", "patch": "@@ -1476,6 +1476,181 @@ arm_return_in_memory (type)\n   return 1;\n }\n \n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is NULL.  */\n+void\n+arm_init_cumulative_args (pcum, fntype, libname, indirect)\n+     CUMULATIVE_ARGS * pcum;\n+     tree fntype;\n+     rtx libname  ATTRIBUTE_UNUSED;\n+     int indirect ATTRIBUTE_UNUSED;\n+{\n+  /* On the ARM, the offset starts at 0.  */\n+  pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype)))\n+\t\t ? 1 : 0);\n+\n+  pcum->call_cookie = CALL_NORMAL;\n+\n+  if (TARGET_LONG_CALLS)\n+    pcum->call_cookie = CALL_LONG;\n+    \n+  /* Check for long call/short call attributes.  The attributes\n+     override any command line option.  */\n+  if (fntype)\n+    {\n+      if (lookup_attribute (\"short_call\", TYPE_ATTRIBUTES (fntype)))\n+\tpcum->call_cookie = CALL_SHORT;\n+      else if (lookup_attribute (\"long_call\", TYPE_ATTRIBUTES (fntype)))\n+\tpcum->call_cookie = CALL_LONG;\n+    }\n+}\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+rtx\n+arm_function_arg (pcum, mode, type, named)\n+     CUMULATIVE_ARGS * pcum;\n+     enum machine_mode mode;\n+     tree type ATTRIBUTE_UNUSED;\n+     int named;\n+{\n+  if (mode == VOIDmode)\n+    /* Compute operand 2 of the call insn.  */\n+    return GEN_INT (pcum->call_cookie);\n+  \n+  if (! named || pcum->nregs >= NUM_ARG_REGS)\n+    return NULL_RTX;\n+  \n+  return gen_rtx_REG (mode, pcum->nregs);\n+}\n+\n+\f\n+/* Return 1 if the operand is a SYMBOL_REF for a function known to be in\n+   this file.  */\n+static int\n+current_file_function_operand (sym_ref)\n+  rtx sym_ref;\n+{\n+  return (SYMBOL_REF_FLAG (sym_ref)\n+\t  || sym_ref == XEXP (DECL_RTL (current_function_decl), 0));\n+}\n+\n+/* Return non-zero if a 32 bit \"long call\" should be generated for this\n+   call.\n+\n+   We generate a long call if the function is not declared\n+   __attribute__ ((short_call),\n+\n+   AND:\n+   \n+     (1)  the function is declared __attribute__ ((long_call))\n+\n+   OR\n+\n+     (2) -mlong-calls is enabled and we don't know whether the target\n+         function is declared in this file.\n+\t \n+   This function will typically be called by C fragments in the machine\n+   description file.  CALL_REF is the matched rtl operand.  CALL_COOKIE\n+   describes the value of the long_call and short_call attributes for\n+   the called functiion.  CALL_SYMBOL is used to distinguish between\n+   two different callers of the function.  It is set to 1 in the \"call_symbol\"\n+   and \"call_symbol_value\" patterns in arm.md and to 0 in the \"call\" and\n+   \"call_value\" patterns.  This is because of the difference of SYM_REFs passed\n+   from \"call_symbol\" and \"call\"  patterns.  */\n+int\n+arm_is_longcall_p (sym_ref, call_cookie, call_symbol)\n+  rtx sym_ref;\n+  int call_cookie;\n+  int call_symbol;\n+{\n+  if (! call_symbol)\n+    {\n+      if (GET_CODE (sym_ref) != MEM)\n+\treturn 0;\n+\n+      sym_ref = XEXP (sym_ref, 0);\n+    }\n+\n+  if (GET_CODE (sym_ref) != SYMBOL_REF)\n+    return 0;\n+\n+  if (call_cookie & CALL_SHORT)\n+    return 0;\n+\n+  if (TARGET_LONG_CALLS && flag_function_sections)\n+    return 1;\n+  \n+  if (current_file_function_operand (sym_ref, VOIDmode))\n+    return 0;\n+  \n+  return (call_cookie & CALL_LONG) || TARGET_LONG_CALLS;\n+}\n+\f\n+/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n+   attribute for TYPE.  The attributes in ATTRIBUTES have previously been\n+   assigned to TYPE.  */\n+int\n+arm_valid_type_attribute_p (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes ATTRIBUTE_UNUSED;\n+     tree identifier;\n+     tree args;\n+{\n+  if (   TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != METHOD_TYPE\n+      && TREE_CODE (type) != FIELD_DECL\n+      && TREE_CODE (type) != TYPE_DECL)\n+    return 0;\n+\n+  /* Function calls made to this symbol must be done indirectly, because\n+     it may lie outside of the 26 bit addressing range of a normal function\n+     call.  */\n+  if (is_attribute_p (\"long_call\", identifier))\n+    return (args == NULL_TREE);\n+\n+  /* Whereas these functions are always known to reside within the 26 bit\n+     addressing range.  */\n+  if (is_attribute_p (\"short_call\", identifier))\n+    return (args == NULL_TREE);\n+  \n+  return 0;\n+}\n+\n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+int\n+arm_comp_type_attributes (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  int l1, l2, s1, s2;\n+  /* Check for mismatch of non-default calling convention.  */\n+  if (TREE_CODE (type1) != FUNCTION_TYPE)\n+    return 1;\n+\n+  /* Check for mismatched call attributes.  */\n+  l1 = ! lookup_attribute (\"long_call\", TYPE_ATTRIBUTES (type1));\n+  l2 = ! lookup_attribute (\"long_call\", TYPE_ATTRIBUTES (type2));\n+  s1 = ! lookup_attribute (\"short_call\", TYPE_ATTRIBUTES (type1));\n+  s2 = ! lookup_attribute (\"short_call\", TYPE_ATTRIBUTES (type2));\n+\n+  return ! ((l1 ^ l2) || (s1 ^s2) || (l1 | s2) || (s1 | l2));\n+}\n+\n+\f\n int\n legitimate_pic_operand_p (x)\n      rtx x;\n@@ -1590,7 +1765,20 @@ legitimize_pic_address (orig, mode, reg)\n       return gen_rtx_PLUS (Pmode, base, offset);\n     }\n   else if (GET_CODE (orig) == LABEL_REF)\n-    current_function_uses_pic_offset_table = 1;\n+    {\n+      current_function_uses_pic_offset_table = 1;\n+      \n+      if (NEED_GOT_RELOC)\n+        {\n+          rtx pic_ref, address = gen_reg_rtx (Pmode);\n+          \n+          emit_insn (gen_pic_load_addr (address, orig));\n+          pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, address);\n+          \n+          emit_move_insn (address, pic_ref);\n+          return address;\n+        }\n+    }\n \n   return orig;\n }"}, {"sha": "f457f92e0fda2a8d585277235238b5c1dd397ace", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 71, "deletions": 32, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e9d9701052e9e42d4923e6ea61405e90c75925/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=82e9d9701052e9e42d4923e6ea61405e90c75925", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for ARM.\n-   Copyright (C) 1991, 93-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 93, 94, 05, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rearnsha@arm.com)\n@@ -48,7 +48,7 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_strongarm1100 0x0040\n #define TARGET_CPU_arm9\t\t0x0080\n #define TARGET_CPU_arm9tdmi\t0x0080\n-/* Configure didn't specify */\n+/* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n enum arm_cond_code\n@@ -365,7 +365,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n      \"Generate re-entrant, PIC code\" },\t\t\t\t\\\n   {\"no-apcs-reentrant\",\t       -ARM_FLAG_APCS_REENT, \"\" },\t\\\n   {\"alignment-traps\",           ARM_FLAG_MMU_TRAPS,\t\t\\\n-     \"The MMU will trap on unaligned accesses\" },\\\n+     \"The MMU will trap on unaligned accesses\" },\t\t\\\n   {\"no-alignment-traps\",       -ARM_FLAG_MMU_TRAPS, \"\" },\t\\\n   {\"short-load-bytes\",\t\tARM_FLAG_MMU_TRAPS, \"\" },\t\\\n   {\"no-short-load-bytes\",      -ARM_FLAG_MMU_TRAPS, \"\" },\t\\\n@@ -385,7 +385,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n      \"Support calls between THUMB and ARM instructions sets\" },\t\\\n   {\"no-thumb-interwork\",       -ARM_FLAG_INTERWORK, \"\" },\t\\\n   {\"abort-on-noreturn\",         ARM_FLAG_ABORT_NORETURN,\t\\\n-   \"Generate a call to abort if a noreturn function returns\"},\t\\\n+     \"Generate a call to abort if a noreturn function returns\"},\\\n   {\"no-abort-on-noreturn\",     -ARM_FLAG_ABORT_NORETURN, \"\"},\t\\\n   {\"sched-prolog\",             -ARM_FLAG_NO_SCHED_PRO,\t\t\\\n      \"Do not move instructions into a function's prologue\" },\t\\\n@@ -394,7 +394,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n      \"Do not load the PIC register in function prologues\" },\t\\\n   {\"no-single-pic-base\",       -ARM_FLAG_SINGLE_PIC_BASE, \"\" },\t\\\n   {\"long-calls\",\t\tARM_FLAG_LONG_CALLS,\t\t\\\n-   \"Generate all call instructions as indirect calls\"},\t\t\\\n+     \"Generate all call instructions as indirect calls\"},\t\\\n   {\"no-long-calls\",\t       -ARM_FLAG_LONG_CALLS, \"\"},\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\\\n@@ -411,7 +411,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   {\"fp=\",   & target_fp_name,\t\t\t\t\t\\\n      \"Specify the version of the floating point emulator\" },\t\\\n   { \"structure-size-boundary=\", & structure_size_string, \t\\\n-     \"Specify the minumum bit alignment of structures\" }, \t\\\n+     \"Specify the minimum bit alignment of structures\" }, \t\\\n   { \"pic-register=\", & arm_pic_register_string,\t\t\t\\\n      \"Specify the register to be used for PIC addressing\" }\t\\\n }\n@@ -1136,6 +1136,23 @@ enum reg_class\n    than a word, or if they contain elements offset from zero in the struct. */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n+/* A C type for declaring a variable that is used as the first argument of\n+   `FUNCTION_ARG' and other related values.  For some target machines, the\n+   type `int' suffices and can hold the number of bytes of argument so far.  */\n+typedef struct\n+{\n+  /* This is the number of argument registers scanned so far.  */\n+  int nregs;\n+  /* instructions on how to process this call.  */\n+  int call_cookie;\n+}\n+CUMULATIVE_ARGS;\n+\n+/* Flags for the call_cookie field of CUMULATIVE_ARGS.  */\n+#define CALL_NORMAL\t\t0\t/* No special processing.  */\n+#define CALL_LONG\t\t1\t/* Always call indirect.  */\n+#define CALL_SHORT\t\t2\t/* Never call indirect.  */\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -1154,38 +1171,29 @@ enum reg_class\n    only in assign_parms, since SETUP_INCOMING_VARARGS is defined), say it is\n    passed in the stack (function_prologue will indeed make it pass in the\n    stack if necessary).  */\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n-  ((NAMED)\t\t\t\t\t\t\\\n-   ? ((CUM) >= NUM_ARG_REGS ? 0 : gen_rtx_REG (MODE, CUM))\\\n-   : 0)\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  arm_function_arg (&(CUM), (MODE), (TYPE), (NAMED))\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n-  (    NUM_ARG_REGS > (CUM)\t\t\t\t\t\\\n-   && (NUM_ARG_REGS < ((CUM) + NUM_REGS2 (MODE, TYPE)))\t\t\\\n-   ?   NUM_ARG_REGS - (CUM) : 0)\n-\n-/* A C type for declaring a variable that is used as the first argument of\n-   `FUNCTION_ARG' and other related values.  For some target machines, the\n-   type `int' suffices and can hold the number of bytes of argument so far.\n-\n-   On the ARM, this is the number of bytes of arguments scanned so far.  */\n-#define CUMULATIVE_ARGS  int\n+  (    NUM_ARG_REGS > (CUM).nregs\t\t\t\t\\\n+   && (NUM_ARG_REGS < ((CUM).nregs + NUM_REGS2 (MODE, TYPE)))\t\\\n+   ?   NUM_ARG_REGS - (CUM).nregs : 0)\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n    On the ARM, the offset starts at 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)  \\\n-  ((CUM) = (((FNTYPE) && aggregate_value_p (TREE_TYPE ((FNTYPE)))) ? 1 : 0))\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n+  arm_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (INDIRECT))\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (CUM) += NUM_REGS2 (MODE, TYPE)\n+  (CUM).nregs += NUM_REGS2 (MODE, TYPE)\n \n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n@@ -1209,8 +1217,8 @@ enum reg_class\n {\t\t\t\t\t\t\t\t\t\\\n   extern int current_function_anonymous_args;\t\t\t\t\\\n   current_function_anonymous_args = 1;\t\t\t\t\t\\\n-  if ((CUM) < NUM_ARG_REGS)\t\t\t\t\t\t\\\n-    (PRETEND_SIZE) = (NUM_ARG_REGS - (CUM)) * UNITS_PER_WORD;\t\t\\\n+  if ((CUM).nregs < NUM_ARG_REGS)\t\t\t\t\t\\\n+    (PRETEND_SIZE) = (NUM_ARG_REGS - (CUM).nregs) * UNITS_PER_WORD;\t\\\n }\n \n /* Generate assembly output for the start of a function.  */\n@@ -1437,8 +1445,18 @@ enum reg_class\n \n    On the ARM, allow any integer (invalid ones are removed later by insn\n    patterns), nice doubles and symbol_refs which refer to the function's\n-   constant pool XXX.  */\n-#define LEGITIMATE_CONSTANT_P(X)\t(! label_mentioned_p (X))\n+   constant pool XXX.  \n+   \n+   When generating pic allow anything.  */\n+#define LEGITIMATE_CONSTANT_P(X)\t(flag_pic || ! label_mentioned_p (X))\n+\n+/* If we are referencing a function that is static or is known to be \n+   in this file, make the SYMBOL_REF special.  We can use this to indicate\n+   that we can do direct call to that function.  */\n+#define ARM_MARK_NEARBY_FUNCTION(decl)\t\t\t\t\t\\\n+  if (TREE_CODE (decl) == FUNCTION_DECL\t\t\t                \\\n+      && (TREE_ASM_WRITTEN (decl) || ! TREE_PUBLIC (decl)))             \\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1;                    \\\n \n /* Symbols in the text segment can be accessed without indirecting via the\n    constant pool; it may take an extra binary operation, but this is still\n@@ -1457,6 +1475,13 @@ enum reg_class\n                  ? TREE_CST_RTL (decl) : DECL_RTL (decl));\t\t\\\n       SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  ARM_MARK_NEARBY_FUNCTION (decl)\t\t\t\t\t\\\n+}\n+#else\n+#define ENCODE_SECTION_INFO(decl)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ARM_MARK_NEARBY_FUNCTION (decl)\t\t\t\t\t\\\n }\n #endif\n \n@@ -1875,16 +1900,30 @@ extern const char * arm_pic_register_string;\n \n /* We can't directly access anything that contains a symbol,\n    nor can we indirect via the constant pool.  */\n-#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n-\t(! symbol_mentioned_p (X)\t\t\t\t\\\n-\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n-\t     || ! symbol_mentioned_p (get_pool_constant (X))))\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\t\\\n+\t(   ! symbol_mentioned_p (X)\t\t\t\t\t\\\n+\t && ! label_mentioned_p (X)\t\t\t\t\t\\\n+\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n+\t     || (   ! symbol_mentioned_p (get_pool_constant (X)))  \t\\\n+\t         && ! label_mentioned_p (get_pool_constant (X))))\n      \n /* We need to know when we are making a constant pool; this determines\n    whether data needs to be in the GOT or can be referenced via a GOT\n    offset.  */\n extern int making_const_table;\n-\n+\f\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n+  (arm_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+  (arm_comp_type_attributes (TYPE1, TYPE2))\n \f\n /* Condition code information. */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,"}]}