{"sha": "5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQzNmVmYWEwZjNlMDg5M2MzYWViZDJiMzczZDM3ZjlhN2E2NTRmOA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-11-21T09:00:26Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-21T09:00:26Z"}, "message": "avr.h (struct base_arch_s): Add field sfr_offset.\n\n\t* config/avr/avr.h (struct base_arch_s): Add field sfr_offset.\n\t* config/avr/avr-devices.c: Ditto. And initialize it.\n\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): New built-in define\n\t__AVR_SFR_OFFSET__.\n\t* config/avr/avr-protos.h (out_movqi_r_mr, out_movqi_mr_r): Remove.\n\t(out_movhi_r_mr, out_movhi_mr_r): Remove.\n\t(out_movsi_r_mr, out_movsi_mr_r): Remove.\n\t* config/avr/avr.md (*cbi, *sbi): Use %i instead of %m-0x20.\n\t(*insv.io, *insv.not.io): Ditto.\n\t* config/avr/avr.c (out_movsi_r_mr, out_movsi_mr_r): Make static.\n\t(print_operand): Implement \"%i\" to print address as I/O address.\n\t(output_movqi): Clean up call of out_movqi_mr_r.\n\t(output_movhi): Clean up call of out_movhi_mr_r.\n\t(avr_file_start): Use avr_current_arch->sfr_offset instead of\n\tmagic -0x20. Use TMP_REGNO, ZERO_REGNO instead of 0, 1.\n\t(avr_out_sbxx_branch): Use %i instead of %m-0x20.\n\t(out_movqi_r_mr, out_movqi_mr_r): Ditto. And make static.\n\t(out_movhi_r_mr, out_movhi_mr_r): Ditto. And use avr_asm_len.\n\t(out_shift_with_cnt): Clean up code: Use avr_asm_len.\n\t(output_movsisf): Use output_reload_insisf for all CONSTANT_P sources.\n\t(avr_out_movpsi): USE avr_out_reload_inpsi for all CONSTANT_P sources.\n\tClean up call of avr_out_store_psi.\n\t(output_reload_in_const): Don't cut symbols longer than 2 bytes.\n\t(output_reload_insisf): Filter CONST_INT_P or CONST_DOUBLE_P to\n\ttry if setting pre-cleared register is advantageous.\n\t(avr_out_plus_1): Use gen_int_mode instead of GEN_INT.\n\nFrom-SVN: r181552", "tree": {"sha": "d48ea8420f59893a11d672dfdf33aa1a4979598f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48ea8420f59893a11d672dfdf33aa1a4979598f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4"}], "stats": {"total": 851, "additions": 379, "deletions": 472}, "files": [{"sha": "ad20f694d906e49d984e4de4ff24754a62088082", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -1,3 +1,32 @@\n+2011-11-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* config/avr/avr.h (struct base_arch_s): Add field sfr_offset.\n+\t* config/avr/avr-devices.c: Ditto. And initialize it.\n+\t* config/avr/avr-c.c (avr_cpu_cpp_builtins): New built-in define\n+\t__AVR_SFR_OFFSET__.\n+\t* config/avr/avr-protos.h (out_movqi_r_mr, out_movqi_mr_r): Remove.\n+\t(out_movhi_r_mr, out_movhi_mr_r): Remove.\n+\t(out_movsi_r_mr, out_movsi_mr_r): Remove.\n+\t* config/avr/avr.md (*cbi, *sbi): Use %i instead of %m-0x20.\n+\t(*insv.io, *insv.not.io): Ditto.\n+\t* config/avr/avr.c (out_movsi_r_mr, out_movsi_mr_r): Make static.\n+\t(print_operand): Implement \"%i\" to print address as I/O address.\n+\t(output_movqi): Clean up call of out_movqi_mr_r.\n+\t(output_movhi): Clean up call of out_movhi_mr_r.\n+\t(avr_file_start): Use avr_current_arch->sfr_offset instead of\n+\tmagic -0x20. Use TMP_REGNO, ZERO_REGNO instead of 0, 1.\n+\t(avr_out_sbxx_branch): Use %i instead of %m-0x20.\n+\t(out_movqi_r_mr, out_movqi_mr_r): Ditto. And make static.\n+\t(out_movhi_r_mr, out_movhi_mr_r): Ditto. And use avr_asm_len.\n+\t(out_shift_with_cnt): Clean up code: Use avr_asm_len.\n+\t(output_movsisf): Use output_reload_insisf for all CONSTANT_P sources.\n+\t(avr_out_movpsi): USE avr_out_reload_inpsi for all CONSTANT_P sources.\n+\tClean up call of avr_out_store_psi.\n+\t(output_reload_in_const): Don't cut symbols longer than 2 bytes.\n+\t(output_reload_insisf): Filter CONST_INT_P or CONST_DOUBLE_P to\n+\ttry if setting pre-cleared register is advantageous.\n+\t(avr_out_plus_1): Use gen_int_mode instead of GEN_INT.\n+\n 2011-11-20  Joey Ye  <joey.ye@arm.com>\n \n \t* expr.c (expand_expr_real_1): Correctly handle strict volatile"}, {"sha": "f0b3a628c2c7da0f539f884ec9176e9e44ebcfd6", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -106,6 +106,9 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n         cpp_define (pfile, \"__AVR_ERRATA_SKIP_JMP_CALL__\");\n     }\n \n+  cpp_define_formatted (pfile, \"__AVR_SFR_OFFSET__=0x%x\",\n+                        avr_current_arch->sfr_offset);\n+    \n   /* Define builtin macros so that the user can easily query if or if not\n      non-generic address spaces (and which) are supported.\n      This is only supported for C.  For C++, a language extension is needed"}, {"sha": "8d6e947f12988504fcdec074770b3149bea00068", "filename": "gcc/config/avr/avr-devices.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-devices.c?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -23,29 +23,30 @@\n #include \"coretypes.h\"\n #include \"tm.h\"\n \n-/* List of all known AVR MCU architectures.  */\n+/* List of all known AVR MCU architectures.\n+   Order as of enum avr_arch from avr.h.  */\n \n const struct base_arch_s\n avr_arch_types[] =\n {\n   /* unknown device specified */\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, NULL,               \"avr2\" },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, NULL,              \"avr2\"  },\n   /*\n-    A  M  J  L  E  E  E         d  S   # F\n-    S  U  M  P  L  L  I         a  t   6 l \n-    M  L  P  M  P  P  J  -  -   t  a   4 a   \n-             X  M  M  M         a  r     s\n-                   X  P            t   k h  */\n-  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=1\",   \"avr1\" },\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=2\",   \"avr2\" },\n-  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=25\",  \"avr25\" },\n-  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=3\",   \"avr3\" },\n-  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 2, \"__AVR_ARCH__=31\",  \"avr31\" },\n-  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=35\",  \"avr35\" },\n-  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=4\",   \"avr4\" },\n-  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 1, \"__AVR_ARCH__=5\",   \"avr5\" },\n-  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 2, \"__AVR_ARCH__=51\",  \"avr51\" },\n-  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 4, \"__AVR_ARCH__=6\",   \"avr6\" }\n+    A  M  J  LM E  E  E         d S   S O  # F\n+    S  U  M  PO L  L  I         a t   F ff 6 l \n+    M  L  P  MV P  P  J  -  -   t a   R s  4 a   \n+             XW M  M  M         a r     e    s\n+                   X  P           t     t  k h  */\n+  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=1\",  \"avr1\"  },\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=2\",  \"avr2\"  },\n+  { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=25\", \"avr25\" },\n+  { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=3\",  \"avr3\"  },\n+  { 0, 0, 1, 0, 1, 0, 0, 0, 0, 0x0060, 32, 2, \"__AVR_ARCH__=31\", \"avr31\" },\n+  { 0, 0, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=35\", \"avr35\" },\n+  { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=4\",  \"avr4\"  },\n+  { 0, 1, 1, 1, 0, 0, 0, 0, 0, 0x0060, 32, 1, \"__AVR_ARCH__=5\",  \"avr5\"  },\n+  { 0, 1, 1, 1, 1, 1, 0, 0, 0, 0x0060, 32, 2, \"__AVR_ARCH__=51\", \"avr51\" },\n+  { 0, 1, 1, 1, 1, 1, 1, 0, 0, 0x0060, 32, 4, \"__AVR_ARCH__=6\",  \"avr6\"  }\n };\n \n const struct mcu_type_s avr_mcu_types[] = {"}, {"sha": "22b1548ed66f297981309d3f6916edb15e381346", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -51,12 +51,6 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n #ifdef RTX_CODE\n extern const char *output_movqi (rtx insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx insn, rtx operands[], int *l);\n-extern const char *out_movqi_r_mr (rtx insn, rtx op[], int *l);\n-extern const char *out_movqi_mr_r (rtx insn, rtx op[], int *l);\n-extern const char *out_movhi_r_mr (rtx insn, rtx op[], int *l);\n-extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n-extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n-extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n extern const char *avr_out_tstsi (rtx, rtx*, int*);\n extern const char *avr_out_tsthi (rtx, rtx*, int*);"}, {"sha": "f9dd60388dfb548edc7489509331e4a90a85115b", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 298, "deletions": 425, "changes": 723, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -63,6 +63,13 @@\n \n /* Prototypes for local helper functions.  */\n \n+static const char* out_movqi_r_mr (rtx, rtx[], int*);\n+static const char* out_movhi_r_mr (rtx, rtx[], int*);\n+static const char* out_movsi_r_mr (rtx, rtx[], int*);\n+static const char* out_movqi_mr_r (rtx, rtx[], int*);\n+static const char* out_movhi_mr_r (rtx, rtx[], int*);\n+static const char* out_movsi_mr_r (rtx, rtx[], int*);\n+\n static int avr_naked_function_p (tree);\n static int interrupt_function_p (tree);\n static int signal_function_p (tree);\n@@ -1824,7 +1831,7 @@ print_operand (FILE *file, rtx x, int code)\n       if (code == 'm')\n \t{\n           if (!CONSTANT_P (addr))\n-            fatal_insn (\"bad address, not a constant):\", addr);\n+            fatal_insn (\"bad address, not a constant:\", addr);\n           /* Assembler template with m-code is data - not progmem section */\n           if (text_segment_operand (addr, VOIDmode))\n             if (warning (0, \"accessing data memory with\"\n@@ -1835,6 +1842,24 @@ print_operand (FILE *file, rtx x, int code)\n               }\n           output_addr_const (file, addr);\n \t}\n+      else if (code == 'i')\n+        {\n+          if (!io_address_operand (addr, GET_MODE (x)))\n+            fatal_insn (\"bad address, not an I/O address:\", addr);\n+          \n+          switch (INTVAL (addr))\n+            {\n+            case RAMPZ_ADDR: fprintf (file, \"__RAMPZ__\"); break;\n+            case SREG_ADDR: fprintf (file, \"__SREG__\"); break;\n+            case SP_ADDR:   fprintf (file, \"__SP_L__\"); break;\n+            case SP_ADDR+1: fprintf (file, \"__SP_H__\"); break;\n+              \n+            default:\n+              fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+                       UINTVAL (addr) - avr_current_arch->sfr_offset);\n+              break;\n+            }\n+        }\n       else if (code == 'o')\n \t{\n \t  if (GET_CODE (addr) != PLUS)\n@@ -2796,17 +2821,12 @@ output_movqi (rtx insn, rtx operands[], int *l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      const char *templ;\n-\n-      if (src == const0_rtx)\n-\toperands[1] = zero_reg_rtx;\n+      rtx xop[2];\n \n-      templ = out_movqi_mr_r (insn, operands, real_l);\n+      xop[0] = dest;\n+      xop[1] = src == const0_rtx ? zero_reg_rtx : src;\n \n-      if (!real_l)\n-\toutput_asm_insn (templ, operands);\n-\n-      operands[1] = src;\n+      return out_movqi_mr_r (insn, xop, real_l);\n     }\n   return \"\";\n }\n@@ -2877,24 +2897,18 @@ output_movhi (rtx insn, rtx operands[], int *l)\n     }\n   else if (GET_CODE (dest) == MEM)\n     {\n-      const char *templ;\n+      rtx xop[2];\n \n-      if (src == const0_rtx)\n-\toperands[1] = zero_reg_rtx;\n+      xop[0] = dest;\n+      xop[1] = src == const0_rtx ? zero_reg_rtx : src;\n \n-      templ = out_movhi_mr_r (insn, operands, real_l);\n-\n-      if (!real_l)\n-\toutput_asm_insn (templ, operands);\n-\n-      operands[1] = src;\n-      return \"\";\n+      return out_movhi_mr_r (insn, xop, real_l);\n     }\n   fatal_insn (\"invalid insn:\", insn);\n   return \"\";\n }\n \n-const char *\n+static const char*\n out_movqi_r_mr (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n@@ -2903,19 +2917,9 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n-      if (CONST_INT_P (x))\n-        {\n-          if (SREG_ADDR == INTVAL (x))\n-            return avr_asm_len (\"in %0,__SREG__\", op, plen, -1);\n-\n-          if (RAMPZ_ADDR == INTVAL (x))\n-            return avr_asm_len (\"in %0,__RAMPZ__\", op, plen, -1);\n-        }\n-      \n-      if (optimize > 0 && io_address_operand (x, QImode))\n-        return avr_asm_len (\"in %0,%m1-0x20\", op, plen, -1);\n-\n-      return avr_asm_len (\"lds %0,%m1\", op, plen, -2);\n+      return optimize > 0 && io_address_operand (x, QImode)\n+        ? avr_asm_len (\"in %0,%i1\", op, plen, -1)\n+        : avr_asm_len (\"lds %0,%m1\", op, plen, -2);\n     }\n   else if (GET_CODE (x) == PLUS\n            && REG_P (XEXP (x, 0))\n@@ -2964,8 +2968,8 @@ out_movqi_r_mr (rtx insn, rtx op[], int *plen)\n   return avr_asm_len (\"ld %0,%1\", op, plen, -1);\n }\n \n-const char *\n-out_movhi_r_mr (rtx insn, rtx op[], int *l)\n+static const char*\n+out_movhi_r_mr (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -2975,149 +2979,116 @@ out_movhi_r_mr (rtx insn, rtx op[], int *l)\n   /* \"volatile\" forces reading low byte first, even if less efficient,\n      for correct operation with 16-bit I/O registers.  */\n   int mem_volatile_p = MEM_VOLATILE_P (src);\n-  int tmp;\n-\n-  if (!l)\n-    l = &tmp;\n \n   if (reg_base > 0)\n     {\n       if (reg_dest == reg_base)         /* R = (R) */\n-\t{\n-\t  *l = 3;\n-\t  return (AS2 (ld,__tmp_reg__,%1+) CR_TAB\n-\t\t  AS2 (ld,%B0,%1) CR_TAB\n-\t\t  AS2 (mov,%A0,__tmp_reg__));\n-\t}\n-      else if (reg_base == REG_X)        /* (R26) */\n-        {\n-          if (reg_unused_after (insn, base))\n-\t    {\n-\t      *l = 2;\n-\t      return (AS2 (ld,%A0,X+) CR_TAB\n-\t\t      AS2 (ld,%B0,X));\n-\t    }\n-\t  *l  = 3;\n-\t  return (AS2 (ld,%A0,X+) CR_TAB\n-\t\t  AS2 (ld,%B0,X) CR_TAB\n-\t\t  AS2 (sbiw,r26,1));\n-        }\n-      else                      /* (R)  */\n-\t{\n-\t  *l = 2;\n-\t  return (AS2 (ld,%A0,%1)    CR_TAB\n-\t\t  AS2 (ldd,%B0,%1+1));\n-\t}\n+        return avr_asm_len (\"ld __tmp_reg__,%1+\" CR_TAB\n+                            \"ld %B0,%1\"          CR_TAB\n+                            \"mov %A0,__tmp_reg__\", op, plen, -3);\n+\n+      if (reg_base != REG_X)\n+        return avr_asm_len (\"ld %A0,%1\" CR_TAB\n+                            \"ldd %B0,%1+1\", op, plen, -2);\n+      \n+      avr_asm_len (\"ld %A0,X+\" CR_TAB\n+                   \"ld %B0,X\", op, plen, -2);\n+          \n+      if (!reg_unused_after (insn, base))\n+        avr_asm_len (\"sbiw r26,1\", op, plen, 1);\n+\n+      return \"\";\n     }\n   else if (GET_CODE (base) == PLUS) /* (R + i) */\n     {\n       int disp = INTVAL (XEXP (base, 1));\n       int reg_base = true_regnum (XEXP (base, 0));\n       \n       if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n-\t{\n-\t  if (REGNO (XEXP (base, 0)) != REG_Y)\n-\t    fatal_insn (\"incorrect insn:\",insn);\n-\t  \n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n-\t    return *l = 4, (AS2 (adiw,r28,%o1-62) CR_TAB\n-\t\t\t    AS2 (ldd,%A0,Y+62)    CR_TAB\n-\t\t\t    AS2 (ldd,%B0,Y+63)    CR_TAB\n-\t\t\t    AS2 (sbiw,r28,%o1-62));\n+        {\n+          if (REGNO (XEXP (base, 0)) != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+          \n+          return disp <= 63 + MAX_LD_OFFSET (GET_MODE (src))\n+            ? avr_asm_len (\"adiw r28,%o1-62\" CR_TAB\n+                           \"ldd %A0,Y+62\"    CR_TAB\n+                           \"ldd %B0,Y+63\"    CR_TAB\n+                           \"sbiw r28,%o1-62\", op, plen, -4)\n+\n+            : avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n+                           \"sbci r29,hi8(-%o1)\" CR_TAB\n+                           \"ld %A0,Y\"           CR_TAB\n+                           \"ldd %B0,Y+1\"        CR_TAB\n+                           \"subi r28,lo8(%o1)\"  CR_TAB\n+                           \"sbci r29,hi8(%o1)\", op, plen, -6);\n+        }\n+\n+      /* This is a paranoid case. LEGITIMIZE_RELOAD_ADDRESS must exclude\n+         it but I have this situation with extremal\n+         optimization options.  */\n \n-\t  return *l = 6, (AS2 (subi,r28,lo8(-%o1)) CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(-%o1)) CR_TAB\n-\t\t\t  AS2 (ld,%A0,Y)           CR_TAB\n-\t\t\t  AS2 (ldd,%B0,Y+1)        CR_TAB\n-\t\t\t  AS2 (subi,r28,lo8(%o1))  CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(%o1)));\n-\t}\n       if (reg_base == REG_X)\n-\t{\n-\t  /* This is a paranoid case. LEGITIMIZE_RELOAD_ADDRESS must exclude\n-\t     it but I have this situation with extremal\n-\t     optimization options.  */\n-\t  \n-\t  *l = 4;\n-\t  if (reg_base == reg_dest)\n-\t    return (AS2 (adiw,r26,%o1)      CR_TAB\n-\t\t    AS2 (ld,__tmp_reg__,X+) CR_TAB\n-\t\t    AS2 (ld,%B0,X)          CR_TAB\n-\t\t    AS2 (mov,%A0,__tmp_reg__));\n+        return reg_base == reg_dest\n+          ? avr_asm_len (\"adiw r26,%o1\"      CR_TAB\n+                         \"ld __tmp_reg__,X+\" CR_TAB\n+                         \"ld %B0,X\"          CR_TAB\n+                         \"mov %A0,__tmp_reg__\", op, plen, -4)\n \n-\t  return (AS2 (adiw,r26,%o1) CR_TAB\n-\t\t  AS2 (ld,%A0,X+)    CR_TAB\n-\t\t  AS2 (ld,%B0,X)     CR_TAB\n-\t\t  AS2 (sbiw,r26,%o1+1));\n-\t}\n+          : avr_asm_len (\"adiw r26,%o1\" CR_TAB\n+                         \"ld %A0,X+\"    CR_TAB\n+                         \"ld %B0,X\"     CR_TAB\n+                         \"sbiw r26,%o1+1\", op, plen, -4);\n \n-      if (reg_base == reg_dest)\n-\t{\n-\t  *l = 3;\n-\t  return (AS2 (ldd,__tmp_reg__,%A1) CR_TAB\n-\t\t  AS2 (ldd,%B0,%B1)         CR_TAB\n-\t\t  AS2 (mov,%A0,__tmp_reg__));\n-\t}\n-      \n-      *l = 2;\n-      return (AS2 (ldd,%A0,%A1) CR_TAB\n-\t      AS2 (ldd,%B0,%B1));\n+      return reg_base == reg_dest\n+        ? avr_asm_len (\"ldd __tmp_reg__,%A1\" CR_TAB\n+                       \"ldd %B0,%B1\"         CR_TAB\n+                       \"mov %A0,__tmp_reg__\", op, plen, -3)\n+\n+        : avr_asm_len (\"ldd %A0,%A1\" CR_TAB\n+                       \"ldd %B0,%B1\", op, plen, -2);\n     }\n   else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n     {\n       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n-\tfatal_insn (\"incorrect insn:\", insn);\n+        fatal_insn (\"incorrect insn:\", insn);\n \n-      if (mem_volatile_p)\n-        {\n-          if (REGNO (XEXP (base, 0)) == REG_X)\n-            {\n-              *l = 4;\n-              return (AS2 (sbiw,r26,2)  CR_TAB\n-                      AS2 (ld,%A0,X+)   CR_TAB\n-                      AS2 (ld,%B0,X)    CR_TAB\n-                      AS2 (sbiw,r26,1));\n-            }\n-          else\n-            {\n-              *l = 3;\n-              return (AS2 (sbiw,%r1,2)   CR_TAB\n-                      AS2 (ld,%A0,%p1)  CR_TAB\n-                      AS2 (ldd,%B0,%p1+1));\n-            }\n-        }\n-\n-      *l = 2;\n-      return (AS2 (ld,%B0,%1) CR_TAB\n-\t      AS2 (ld,%A0,%1));\n+      if (!mem_volatile_p)\n+        return avr_asm_len (\"ld %B0,%1\" CR_TAB\n+                            \"ld %A0,%1\", op, plen, -2);\n+      \n+      return REGNO (XEXP (base, 0)) == REG_X\n+        ? avr_asm_len (\"sbiw r26,2\"  CR_TAB\n+                       \"ld %A0,X+\"   CR_TAB\n+                       \"ld %B0,X\"    CR_TAB\n+                       \"sbiw r26,1\", op, plen, -4)\n+        \n+        : avr_asm_len (\"sbiw %r1,2\"  CR_TAB\n+                       \"ld %A0,%p1\"  CR_TAB\n+                       \"ldd %B0,%p1+1\", op, plen, -3);\n     }\n   else if (GET_CODE (base) == POST_INC) /* (R++) */\n     {\n       if (reg_overlap_mentioned_p (dest, XEXP (base, 0)))\n-\tfatal_insn (\"incorrect insn:\", insn);\n+        fatal_insn (\"incorrect insn:\", insn);\n \n-      *l = 2;\n-      return (AS2 (ld,%A0,%1)  CR_TAB\n-\t      AS2 (ld,%B0,%1));\n+      return avr_asm_len (\"ld %A0,%1\"  CR_TAB\n+                          \"ld %B0,%1\", op, plen, -2);\n     }\n   else if (CONSTANT_ADDRESS_P (base))\n     {\n-      if (optimize > 0 && io_address_operand (base, HImode))\n-\t{\n-\t  *l = 2;\n-\t  return (AS2 (in,%A0,%m1-0x20) CR_TAB\n-\t\t  AS2 (in,%B0,%m1+1-0x20));\n-\t}\n-      *l = 4;\n-      return (AS2 (lds,%A0,%m1) CR_TAB\n-\t      AS2 (lds,%B0,%m1+1));\n+      return optimize > 0 && io_address_operand (base, HImode)\n+        ? avr_asm_len (\"in %A0,%i1\" CR_TAB\n+                       \"in %B0,%i1+1\", op, plen, -2)\n+\n+        : avr_asm_len (\"lds %A0,%m1\" CR_TAB\n+                       \"lds %B0,%m1+1\", op, plen, -4);\n     }\n   \n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n }\n \n-const char *\n+static const char*\n out_movsi_r_mr (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n@@ -3278,7 +3249,7 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)\n   return \"\";\n }\n \n-const char *\n+static const char*\n out_movsi_mr_r (rtx insn, rtx op[], int *l)\n {\n   rtx dest = op[0];\n@@ -3483,34 +3454,10 @@ output_movsisf (rtx insn, rtx operands[], int *l)\n \t\t      AS2 (mov,%D0,%D1));\n \t    }\n \t}\n-      else if (CONST_INT_P (src)\n-               || CONST_DOUBLE_P (src))\n-        {\n-          return output_reload_insisf (operands, NULL_RTX, real_l);\n-        }\n       else if (CONSTANT_P (src))\n \t{\n-\t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n-\t    {\n-\t      *l = 4;\n-\t      return (AS2 (ldi,%A0,lo8(%1))  CR_TAB\n-\t\t      AS2 (ldi,%B0,hi8(%1))  CR_TAB\n-\t\t      AS2 (ldi,%C0,hlo8(%1)) CR_TAB\n-\t\t      AS2 (ldi,%D0,hhi8(%1)));\n-\t    }\n-\t  /* Last resort, better than loading from memory.  */\n-\t  *l = 10;\n-\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n-\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n-\t\t  AS2 (mov,%A0,r31)         CR_TAB\n-\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n-\t\t  AS2 (mov,%B0,r31)         CR_TAB\n-\t\t  AS2 (ldi,r31,hlo8(%1))    CR_TAB\n-\t\t  AS2 (mov,%C0,r31)         CR_TAB\n-\t\t  AS2 (ldi,r31,hhi8(%1))    CR_TAB\n-\t\t  AS2 (mov,%D0,r31)         CR_TAB\n-\t\t  AS2 (mov,r31,__tmp_reg__));\n-\t}\n+          return output_reload_insisf (operands, NULL_RTX, real_l);\n+        }\n       else if (GET_CODE (src) == MEM)\n \treturn out_movsi_r_mr (insn, operands, real_l); /* mov r,m */\n     }\n@@ -3797,49 +3744,29 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)\n               return avr_asm_len (\"mov %C0,%C1\", op, plen, 1);\n             }\n         }\n-      else if (CONST_INT_P (src))\n-        {\n-          return avr_out_reload_inpsi (op, NULL_RTX, plen);\n-        }\n       else if (CONSTANT_P (src))\n         {\n-          if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n-            {\n-              return avr_asm_len (\"ldi %A0,lo8(%1)\" CR_TAB\n-                                  \"ldi %B0,hi8(%1)\" CR_TAB\n-                                  \"ldi %C0,hh8(%1)\", op, plen, -3);\n-            }\n-          \n-          /* Last resort, better than loading from memory.  */\n-          return avr_asm_len (\"mov __tmp_reg__,r31\" CR_TAB\n-                              \"ldi r31,lo8(%1)\" CR_TAB\n-                              \"mov %A0,r31\"     CR_TAB\n-                              \"ldi r31,hi8(%1)\" CR_TAB\n-                              \"mov %B0,r31\"     CR_TAB\n-                              \"ldi r31,hh8(%1)\" CR_TAB\n-                              \"mov %C0,r31\"     CR_TAB\n-                              \"mov r31,__tmp_reg__\", op, plen, -8);\n+          return avr_out_reload_inpsi (op, NULL_RTX, plen);\n         }\n       else if (MEM_P (src))\n         return avr_out_load_psi (insn, op, plen); /* mov r,m */\n     }\n   else if (MEM_P (dest))\n     {\n-      if (src == CONST0_RTX (GET_MODE (dest)))\n-        op[1] = zero_reg_rtx;\n-      \n-      avr_out_store_psi (insn, op, plen);\n+      rtx xop[2];\n+\n+      xop[0] = dest;\n+      xop[1] = src == CONST0_RTX (GET_MODE (dest)) ? zero_reg_rtx : src;\n       \n-      op[1] = src;\n-      return \"\";\n+      return avr_out_store_psi (insn, xop, plen);\n     }\n     \n   fatal_insn (\"invalid insn:\", insn);\n   return \"\";\n }\n \n \n-const char *\n+static const char*\n out_movqi_mr_r (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n@@ -3848,19 +3775,9 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)\n   \n   if (CONSTANT_ADDRESS_P (x))\n     {\n-      if (CONST_INT_P (x))\n-        {\n-          if (SREG_ADDR == INTVAL (x))\n-            return avr_asm_len (\"out __SREG__,%1\", op, plen, -1);\n-\n-          if (RAMPZ_ADDR == INTVAL (x))\n-            return avr_asm_len (\"out __RAMPZ__,%1\", op, plen, -1);\n-        }\n-      \n-      if (optimize > 0 && io_address_operand (x, QImode))\n-        avr_asm_len (\"out %m0-0x20,%1\", op, plen, -1);\n-\n-      return avr_asm_len (\"sts %m0,%1\", op, plen, -2);\n+      return optimize > 0 && io_address_operand (x, QImode)\n+        ? avr_asm_len (\"out %i0,%1\", op, plen, -1)\n+        : avr_asm_len (\"sts %m0,%1\", op, plen, -2);\n     }\n   else if (GET_CODE (x) == PLUS\n            && REG_P (XEXP (x, 0))\n@@ -3912,8 +3829,8 @@ out_movqi_mr_r (rtx insn, rtx op[], int *plen)\n   return avr_asm_len (\"st %0,%1\", op, plen, 1);\n }\n \n-const char *\n-out_movhi_mr_r (rtx insn, rtx op[], int *l)\n+static const char*\n+out_movhi_mr_r (rtx insn, rtx op[], int *plen)\n {\n   rtx dest = op[0];\n   rtx src = op[1];\n@@ -3923,127 +3840,103 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n   /* \"volatile\" forces writing high byte first, even if less efficient,\n      for correct operation with 16-bit I/O registers.  */\n   int mem_volatile_p = MEM_VOLATILE_P (dest);\n-  int tmp;\n \n-  if (!l)\n-    l = &tmp;\n   if (CONSTANT_ADDRESS_P (base))\n-    {\n-      if (optimize > 0 && io_address_operand (base, HImode))\n-\t{\n-\t  *l = 2;\n-\t  return (AS2 (out,%m0+1-0x20,%B1) CR_TAB\n-\t\t  AS2 (out,%m0-0x20,%A1));\n-\t}\n-      return *l = 4, (AS2 (sts,%m0+1,%B1) CR_TAB\n-\t\t      AS2 (sts,%m0,%A1));\n-    }\n+    return optimize > 0 && io_address_operand (base, HImode)\n+      ? avr_asm_len (\"out %i0+1,%B1\" CR_TAB\n+                     \"out %i0,%A1\", op, plen, -2)\n+\n+      : avr_asm_len (\"sts %m0+1,%B1\" CR_TAB\n+                     \"sts %m0,%A1\", op, plen, -4);\n+  \n   if (reg_base > 0)\n     {\n-      if (reg_base == REG_X)\n-        {\n-          if (reg_src == REG_X)\n-            {\n-              /* \"st X+,r26\" and \"st -X,r26\" are undefined.  */\n-              if (!mem_volatile_p && reg_unused_after (insn, src))\n-\t\treturn *l=4, (AS2 (mov,__tmp_reg__,r27) CR_TAB\n-\t\t\t      AS2 (st,X,r26)            CR_TAB\n-\t\t\t      AS2 (adiw,r26,1)          CR_TAB\n-\t\t\t      AS2 (st,X,__tmp_reg__));\n-              else\n-\t\treturn *l=5, (AS2 (mov,__tmp_reg__,r27) CR_TAB\n-\t\t\t      AS2 (adiw,r26,1)          CR_TAB\n-\t\t\t      AS2 (st,X,__tmp_reg__)    CR_TAB\n-                              AS2 (sbiw,r26,1)          CR_TAB\n-                              AS2 (st,X,r26));\n-            }\n-          else\n-            {\n-              if (!mem_volatile_p && reg_unused_after (insn, base))\n-                return *l=2, (AS2 (st,X+,%A1) CR_TAB\n-                              AS2 (st,X,%B1));\n-              else\n-                return *l=3, (AS2 (adiw,r26,1) CR_TAB\n-                              AS2 (st,X,%B1)   CR_TAB\n-                              AS2 (st,-X,%A1));\n-            }\n-        }\n-      else\n-        return  *l=2, (AS2 (std,%0+1,%B1) CR_TAB\n-                       AS2 (st,%0,%A1));\n+      if (reg_base != REG_X)\n+        return avr_asm_len (\"std %0+1,%B1\" CR_TAB\n+                            \"st %0,%A1\", op, plen, -2);\n+      \n+      if (reg_src == REG_X)\n+        /* \"st X+,r26\" and \"st -X,r26\" are undefined.  */\n+        return !mem_volatile_p && reg_unused_after (insn, src)\n+          ? avr_asm_len (\"mov __tmp_reg__,r27\" CR_TAB\n+                         \"st X,r26\"            CR_TAB\n+                         \"adiw r26,1\"          CR_TAB\n+                         \"st X,__tmp_reg__\", op, plen, -4)\n+\n+          : avr_asm_len (\"mov __tmp_reg__,r27\" CR_TAB\n+                         \"adiw r26,1\"          CR_TAB\n+                         \"st X,__tmp_reg__\"    CR_TAB\n+                         \"sbiw r26,1\"          CR_TAB\n+                         \"st X,r26\", op, plen, -5);\n+      \n+      return !mem_volatile_p && reg_unused_after (insn, base)\n+        ? avr_asm_len (\"st X+,%A1\" CR_TAB\n+                       \"st X,%B1\", op, plen, -2)\n+        : avr_asm_len (\"adiw r26,1\" CR_TAB\n+                       \"st X,%B1\"   CR_TAB\n+                       \"st -X,%A1\", op, plen, -3);\n     }\n   else if (GET_CODE (base) == PLUS)\n     {\n       int disp = INTVAL (XEXP (base, 1));\n       reg_base = REGNO (XEXP (base, 0));\n       if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n-\t{\n-\t  if (reg_base != REG_Y)\n-\t    fatal_insn (\"incorrect insn:\",insn);\n-\n-\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n-\t    return *l = 4, (AS2 (adiw,r28,%o0-62) CR_TAB\n-\t\t\t    AS2 (std,Y+63,%B1)    CR_TAB\n-\t\t\t    AS2 (std,Y+62,%A1)    CR_TAB\n-\t\t\t    AS2 (sbiw,r28,%o0-62));\n-\n-\t  return *l = 6, (AS2 (subi,r28,lo8(-%o0)) CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(-%o0)) CR_TAB\n-\t\t\t  AS2 (std,Y+1,%B1)        CR_TAB\n-\t\t\t  AS2 (st,Y,%A1)           CR_TAB\n-\t\t\t  AS2 (subi,r28,lo8(%o0))  CR_TAB\n-\t\t\t  AS2 (sbci,r29,hi8(%o0)));\n-\t}\n-      if (reg_base == REG_X)\n-\t{\n-\t  /* (X + d) = R */\n-\t  if (reg_src == REG_X)\n-            {\n-\t      *l = 7;\n-\t      return (AS2 (mov,__tmp_reg__,r26)  CR_TAB\n-\t\t      AS2 (mov,__zero_reg__,r27) CR_TAB\n-                      AS2 (adiw,r26,%o0+1)       CR_TAB\n-\t\t      AS2 (st,X,__zero_reg__)    CR_TAB\n-\t\t      AS2 (st,-X,__tmp_reg__)    CR_TAB\n-\t\t      AS1 (clr,__zero_reg__)     CR_TAB\n-                      AS2 (sbiw,r26,%o0));\n-\t    }\n-\t  *l = 4;\n-          return (AS2 (adiw,r26,%o0+1) CR_TAB\n-                  AS2 (st,X,%B1)       CR_TAB\n-                  AS2 (st,-X,%A1)      CR_TAB\n-                  AS2 (sbiw,r26,%o0));\n-\t}\n-      return *l=2, (AS2 (std,%B0,%B1)    CR_TAB\n-                    AS2 (std,%A0,%A1));\n+        {\n+          if (reg_base != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+          \n+          return disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest))\n+            ? avr_asm_len (\"adiw r28,%o0-62\" CR_TAB\n+                           \"std Y+63,%B1\"    CR_TAB\n+                           \"std Y+62,%A1\"    CR_TAB\n+                           \"sbiw r28,%o0-62\", op, plen, -4)\n+\n+            : avr_asm_len (\"subi r28,lo8(-%o0)\" CR_TAB\n+                           \"sbci r29,hi8(-%o0)\" CR_TAB\n+                           \"std Y+1,%B1\"        CR_TAB\n+                           \"st Y,%A1\"           CR_TAB\n+                           \"subi r28,lo8(%o0)\"  CR_TAB\n+                           \"sbci r29,hi8(%o0)\", op, plen, -6);\n+        }\n+      \n+      if (reg_base != REG_X)\n+        return avr_asm_len (\"std %B0,%B1\" CR_TAB\n+                            \"std %A0,%A1\", op, plen, -2);\n+      /* (X + d) = R */\n+      return reg_src == REG_X\n+        ? avr_asm_len (\"mov __tmp_reg__,r26\"  CR_TAB\n+                       \"mov __zero_reg__,r27\" CR_TAB\n+                       \"adiw r26,%o0+1\"       CR_TAB\n+                       \"st X,__zero_reg__\"    CR_TAB\n+                       \"st -X,__tmp_reg__\"    CR_TAB\n+                       \"clr __zero_reg__\"     CR_TAB\n+                       \"sbiw r26,%o0\", op, plen, -7)\n+\n+        : avr_asm_len (\"adiw r26,%o0+1\" CR_TAB\n+                       \"st X,%B1\"       CR_TAB\n+                       \"st -X,%A1\"      CR_TAB\n+                       \"sbiw r26,%o0\", op, plen, -4);\n     }\n   else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n-    return *l=2, (AS2 (st,%0,%B1) CR_TAB\n-\t\t  AS2 (st,%0,%A1));\n+    {\n+      return avr_asm_len (\"st %0,%B1\" CR_TAB\n+                          \"st %0,%A1\", op, plen, -2);\n+    }\n   else if (GET_CODE (base) == POST_INC) /* (R++) */\n     {\n-      if (mem_volatile_p)\n-        {\n-          if (REGNO (XEXP (base, 0)) == REG_X)\n-            {\n-              *l = 4;\n-              return (AS2 (adiw,r26,1)  CR_TAB\n-                      AS2 (st,X,%B1)    CR_TAB\n-                      AS2 (st,-X,%A1)   CR_TAB\n-                      AS2 (adiw,r26,2));\n-            }\n-          else\n-            {\n-              *l = 3;\n-              return (AS2 (std,%p0+1,%B1) CR_TAB\n-                      AS2 (st,%p0,%A1)    CR_TAB\n-                      AS2 (adiw,%r0,2));\n-            }\n-        }\n+      if (!mem_volatile_p)\n+        return avr_asm_len (\"st %0,%A1\"  CR_TAB\n+                            \"st %0,%B1\", op, plen, -2);\n+      \n+      return REGNO (XEXP (base, 0)) == REG_X\n+        ? avr_asm_len (\"adiw r26,1\"  CR_TAB\n+                       \"st X,%B1\"    CR_TAB\n+                       \"st -X,%A1\"   CR_TAB\n+                       \"adiw r26,2\", op, plen, -4)\n \n-      *l = 2;\n-      return (AS2 (st,%0,%A1)  CR_TAB\n-            AS2 (st,%0,%B1));\n+        : avr_asm_len (\"std %p0+1,%B1\" CR_TAB\n+                       \"st %p0,%A1\"    CR_TAB\n+                       \"adiw %r0,2\", op, plen, -3);\n     }\n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n@@ -4338,29 +4231,33 @@ avr_out_tstsi (rtx insn, rtx *op, int *plen)\n }\n \n \n-/* Generate asm equivalent for various shifts.\n-   Shift count is a CONST_INT, MEM or REG.\n-   This only handles cases that are not already\n-   carefully hand-optimized in ?sh??i3_out.  */\n+/* Generate asm equivalent for various shifts.  This only handles cases\n+   that are not already carefully hand-optimized in ?sh??i3_out.\n+\n+   OPERANDS[0] resp. %0 in TEMPL is the operand to be shifted.\n+   OPERANDS[2] is the shift count as CONST_INT, MEM or REG.\n+   OPERANDS[3] is a QImode scratch register from LD regs if\n+               available and SCRATCH, otherwise (no scratch available)\n+\n+   TEMPL is an assembler template that shifts by one position.\n+   T_LEN is the length of this template.  */\n \n void\n out_shift_with_cnt (const char *templ, rtx insn, rtx operands[],\n-\t\t    int *len, int t_len)\n+\t\t    int *plen, int t_len)\n {\n-  rtx op[10];\n-  char str[500];\n-  int second_label = 1;\n-  int saved_in_tmp = 0;\n-  int use_zero_reg = 0;\n+  bool second_label = true;\n+  bool saved_in_tmp = false;\n+  bool use_zero_reg = false;\n+  rtx op[5];\n \n   op[0] = operands[0];\n   op[1] = operands[1];\n   op[2] = operands[2];\n   op[3] = operands[3];\n-  str[0] = 0;\n \n-  if (len)\n-    *len = 1;\n+  if (plen)\n+    *plen = 0;\n \n   if (CONST_INT_P (operands[2]))\n     {\n@@ -4370,118 +4267,90 @@ out_shift_with_cnt (const char *templ, rtx insn, rtx operands[],\n       int max_len = 10;  /* If larger than this, always use a loop.  */\n \n       if (count <= 0)\n-\t{\n-\t  if (len)\n-\t    *len = 0;\n-\t  return;\n-\t}\n+          return;\n \n       if (count < 8 && !scratch)\n-\tuse_zero_reg = 1;\n+        use_zero_reg = true;\n \n       if (optimize_size)\n-\tmax_len = t_len + (scratch ? 3 : (use_zero_reg ? 4 : 5));\n+        max_len = t_len + (scratch ? 3 : (use_zero_reg ? 4 : 5));\n \n       if (t_len * count <= max_len)\n-\t{\n-\t  /* Output shifts inline with no loop - faster.  */\n-\t  if (len)\n-\t    *len = t_len * count;\n-\t  else\n-\t    {\n-\t      while (count-- > 0)\n-\t\toutput_asm_insn (templ, op);\n-\t    }\n+        {\n+          /* Output shifts inline with no loop - faster.  */\n+          \n+          while (count-- > 0)\n+            avr_asm_len (templ, op, plen, t_len);\n \n-\t  return;\n-\t}\n+          return;\n+        }\n \n       if (scratch)\n-\t{\n-\t  if (!len)\n-\t    strcat (str, AS2 (ldi,%3,%2));\n-\t}\n+        {\n+          avr_asm_len (\"ldi %3,%2\", op, plen, 1);\n+        }\n       else if (use_zero_reg)\n-\t{\n-\t  /* Hack to save one word: use __zero_reg__ as loop counter.\n-\t     Set one bit, then shift in a loop until it is 0 again.  */\n+        {\n+          /* Hack to save one word: use __zero_reg__ as loop counter.\n+             Set one bit, then shift in a loop until it is 0 again.  */\n \n-\t  op[3] = zero_reg_rtx;\n-\t  if (len)\n-\t    *len = 2;\n-\t  else\n-\t    strcat (str, (\"set\" CR_TAB\n-\t\t\t  AS2 (bld,%3,%2-1)));\n-\t}\n+          op[3] = zero_reg_rtx;\n+\n+          avr_asm_len (\"set\" CR_TAB\n+                       \"bld %3,%2-1\", op, plen, 2);\n+        }\n       else\n-\t{\n-\t  /* No scratch register available, use one from LD_REGS (saved in\n-\t     __tmp_reg__) that doesn't overlap with registers to shift.  */\n+        {\n+          /* No scratch register available, use one from LD_REGS (saved in\n+             __tmp_reg__) that doesn't overlap with registers to shift.  */\n \n-\t  op[3] = all_regs_rtx[((REGNO (operands[0]) - 1) & 15) + 16];\n-\t  op[4] = tmp_reg_rtx;\n-\t  saved_in_tmp = 1;\n+          op[3] = all_regs_rtx[((REGNO (op[0]) - 1) & 15) + 16];\n+          op[4] = tmp_reg_rtx;\n+          saved_in_tmp = true;\n \n-\t  if (len)\n-\t    *len = 3;  /* Includes \"mov %3,%4\" after the loop.  */\n-\t  else\n-\t    strcat (str, (AS2 (mov,%4,%3) CR_TAB\n-\t\t\t  AS2 (ldi,%3,%2)));\n-\t}\n+          avr_asm_len (\"mov %4,%3\" CR_TAB\n+                       \"ldi %3,%2\", op, plen, 2);\n+        }\n \n-      second_label = 0;\n+      second_label = false;\n     }\n-  else if (GET_CODE (operands[2]) == MEM)\n+  else if (MEM_P (op[2]))\n     {\n-      rtx op_mov[10];\n+      rtx op_mov[2];\n       \n-      op[3] = op_mov[0] = tmp_reg_rtx;\n+      op_mov[0] = op[3] = tmp_reg_rtx;\n       op_mov[1] = op[2];\n \n-      if (len)\n-\tout_movqi_r_mr (insn, op_mov, len);\n-      else\n-\toutput_asm_insn (out_movqi_r_mr (insn, op_mov, NULL), op_mov);\n+      out_movqi_r_mr (insn, op_mov, plen);\n     }\n-  else if (register_operand (operands[2], QImode))\n+  else if (register_operand (op[2], QImode))\n     {\n-      if (reg_unused_after (insn, operands[2])\n-          && !reg_overlap_mentioned_p (operands[0], operands[2]))\n+      op[3] = op[2];\n+      \n+      if (!reg_unused_after (insn, op[2])\n+          || reg_overlap_mentioned_p (op[0], op[2]))\n         {\n-          op[3] = op[2];\n+          op[3] = tmp_reg_rtx;\n+          avr_asm_len (\"mov %3,%2\", op, plen, 1);\n         }\n-      else\n-\t{\n-\t  op[3] = tmp_reg_rtx;\n-\t  if (!len)\n-\t    strcat (str, (AS2 (mov,%3,%2) CR_TAB));\n-\t}\n     }\n   else\n     fatal_insn (\"bad shift insn:\", insn);\n \n   if (second_label)\n-    {\n-      if (len)\n-\t++*len;\n-      else\n-\tstrcat (str, AS1 (rjmp,2f));\n-    }\n+      avr_asm_len (\"rjmp 2f\", op, plen, 1);\n \n-  if (len)\n-    *len += t_len + 2;  /* template + dec + brXX */\n-  else\n-    {\n-      strcat (str, \"\\n1:\\t\");\n-      strcat (str, templ);\n-      strcat (str, second_label ? \"\\n2:\\t\" : \"\\n\\t\");\n-      strcat (str, use_zero_reg ? AS1 (lsr,%3) : AS1 (dec,%3));\n-      strcat (str, CR_TAB);\n-      strcat (str, second_label ? AS1 (brpl,1b) : AS1 (brne,1b));\n-      if (saved_in_tmp)\n-\tstrcat (str, (CR_TAB AS2 (mov,%3,%4)));\n-      output_asm_insn (str, op);\n-    }\n+  avr_asm_len (\"1:\", op, plen, 0);\n+  avr_asm_len (templ, op, plen, t_len);\n+\n+  if (second_label)\n+    avr_asm_len (\"2:\", op, plen, 0);\n+\n+  avr_asm_len (use_zero_reg ? \"lsr %3\" : \"dec %3\", op, plen, 1);\n+  avr_asm_len (second_label ? \"brpl 1b\" : \"brne 1b\", op, plen, 1);\n+\n+  if (saved_in_tmp)\n+    avr_asm_len (\"mov %3,%4\", op, plen, 1);\n }\n \n \n@@ -5946,7 +5815,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n       bool ld_reg_p = test_hard_reg_class (LD_REGS, reg8);\n \n       op[0] = reg8;\n-      op[1] = GEN_INT (val8);\n+      op[1] = gen_int_mode (val8, QImode);\n \n       /* To get usable cc0 no low-bytes must have been skipped.  */\n       \n@@ -7355,7 +7224,7 @@ avr_asm_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n static void\n avr_file_start (void)\n {\n-  int sfr_offset = 0x20;\n+  int sfr_offset = avr_current_arch->sfr_offset;\n \n   if (avr_current_arch->asm_only)\n     error (\"MCU %qs supported for assembler only\", avr_current_device->name);\n@@ -7367,12 +7236,14 @@ avr_file_start (void)\n            \"__SP_H__ = 0x%02x\\n\"\n            \"__SP_L__ = 0x%02x\\n\"\n            \"__RAMPZ__ = 0x%02x\\n\"\n-           \"__tmp_reg__ = 0\\n\" \n-           \"__zero_reg__ = 1\\n\",\n+           \"__tmp_reg__ = %d\\n\" \n+           \"__zero_reg__ = %d\\n\",\n            -sfr_offset + SREG_ADDR,\n            -sfr_offset + SP_ADDR + 1,\n            -sfr_offset + SP_ADDR,\n-           -sfr_offset + RAMPZ_ADDR);\n+           -sfr_offset + RAMPZ_ADDR,\n+           TMP_REGNO,\n+           ZERO_REGNO);\n }\n \n \n@@ -9042,7 +8913,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n           xop[1] = src;\n           xop[2] = clobber_reg;\n \n-          if (n >= 2)\n+          if (n >= 2 + (avr_current_arch->n_segments > 1))\n             avr_asm_len (\"clr %0\", xop, len, 1);\n           else\n             avr_asm_len (asm_code[n][ldreg_p], xop, len, ldreg_p ? 1 : 2);\n@@ -9218,7 +9089,9 @@ const char *\n output_reload_insisf (rtx *op, rtx clobber_reg, int *len)\n {\n   if (AVR_HAVE_MOVW\n-      && !test_hard_reg_class (LD_REGS, op[0]))\n+      && !test_hard_reg_class (LD_REGS, op[0])\n+      && (CONST_INT_P (op[1])\n+          || CONST_DOUBLE_P (op[1])))\n     {\n       int len_clr, len_noclr;\n       \n@@ -9373,13 +9246,13 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])\n       if (low_io_address_operand (operands[1], QImode))\n         {\n           if (comp == EQ)\n-            output_asm_insn (\"sbis %m1-0x20,%2\", operands);\n+            output_asm_insn (\"sbis %i1,%2\", operands);\n           else\n-            output_asm_insn (\"sbic %m1-0x20,%2\", operands);\n+            output_asm_insn (\"sbic %i1,%2\", operands);\n         }\n       else\n         {\n-          output_asm_insn (\"in __tmp_reg__,%m1-0x20\", operands);\n+          output_asm_insn (\"in __tmp_reg__,%i1\", operands);\n           if (comp == EQ)\n             output_asm_insn (\"sbrs __tmp_reg__,%2\", operands);\n           else"}, {"sha": "96133b8da280316072cc56cba2b1640c6f99892b", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -23,7 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n-struct base_arch_s {\n+struct base_arch_s\n+{\n   /* Assembler only.  */\n   int asm_only;\n \n@@ -54,6 +55,10 @@ struct base_arch_s {\n   /* Default start of data section address for architecture.  */\n   int default_data_section_start;\n \n+  /* Offset between SFR address and RAM address:\n+     SFR-address = RAM-address - sfr_offset  */\n+  int sfr_offset;\n+\n   /* Number of 64k segments in the flash.  */\n   int n_segments;\n "}, {"sha": "67420ce9dabe6d1e5d25eace6ea1cf2a61de0d90", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5436efaa0f3e0893c3aebd2b373d37f9a7a654f8/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=5436efaa0f3e0893c3aebd2b373d37f9a7a654f8", "patch": "@@ -28,6 +28,8 @@\n ;;  j  Branch condition.\n ;;  k  Reverse branch condition.\n ;;..m..Constant Direct Data memory address.\n+;;  i  Print the SFR address quivalent of a CONST_INT RAM address.\n+;;     The resulting addres is suitable to be used in IN/OUT.\n ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)\n ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)\n@@ -45,12 +47,12 @@\n    (LPM_REGNO\t0)\t; implicit target register of LPM\n    (TMP_REGNO\t0)\t; temporary register r0\n    (ZERO_REGNO\t1)\t; zero register r1\n-   \n-   (SREG_ADDR   0x5F)\n-   (SP_ADDR     0x5D)\n \n-   ;; Register holding the address' high part when loading via ELPM\n-   (RAMPZ_ADDR  0x5B)\n+   ;; RAM addresses of some SFRs common to all Devices.\n+\n+   (SREG_ADDR   0x5F)   ; Status Register\n+   (SP_ADDR     0x5D)   ; Stack Pointer\n+   (RAMPZ_ADDR  0x5B)   ; Address' high part when loading via ELPM\n    ])\n \n (define_c_enum \"unspec\"\n@@ -4658,25 +4660,25 @@\n \n (define_insn \"*cbi\"\n   [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n-\t(and:QI (mem:QI (match_dup 0))\n-\t\t(match_operand:QI 1 \"single_zero_operand\" \"n\")))]\n-  \"(optimize > 0)\"\n-{\n-  operands[2] = GEN_INT (exact_log2 (~INTVAL (operands[1]) & 0xff));\n-  return AS2 (cbi,%m0-0x20,%2);\n-}\n+        (and:QI (mem:QI (match_dup 0))\n+                (match_operand:QI 1 \"single_zero_operand\" \"n\")))]\n+  \"optimize > 0\"\n+  {\n+    operands[2] = GEN_INT (exact_log2 (~INTVAL (operands[1]) & 0xff));\n+    return \"cbi %i0,%2\";\n+  }\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*sbi\"\n   [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n-\t(ior:QI (mem:QI (match_dup 0))\n-\t\t(match_operand:QI 1 \"single_one_operand\" \"n\")))]\n-  \"(optimize > 0)\"\n-{\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1]) & 0xff));\n-  return AS2 (sbi,%m0-0x20,%2);\n-}\n+        (ior:QI (mem:QI (match_dup 0))\n+                (match_operand:QI 1 \"single_one_operand\" \"n\")))]\n+  \"optimize > 0\"\n+  {\n+    operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1]) & 0xff));\n+    return \"sbi %i0,%2\";\n+  }\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n \n@@ -5635,9 +5637,9 @@\n         (match_operand:QI 2 \"nonmemory_operand\"                            \"L,P,r\"))]\n   \"\"\n   \"@\n-\tcbi %m0-0x20,%1\n-\tsbi %m0-0x20,%1\n-\tsbrc %2,0\\;sbi %m0-0x20,%1\\;sbrs %2,0\\;cbi %m0-0x20,%1\"\n+\tcbi %i0,%1\n+\tsbi %i0,%1\n+\tsbrc %2,0\\;sbi %i0,%1\\;sbrs %2,0\\;cbi %i0,%1\"\n   [(set_attr \"length\" \"1,1,4\")\n    (set_attr \"cc\" \"none\")])\n \n@@ -5647,7 +5649,7 @@\n                          (match_operand:QI 1 \"const_0_to_7_operand\"        \"n\"))\n         (not:QI (match_operand:QI 2 \"register_operand\"                     \"r\")))]\n   \"\"\n-  \"sbrs %2,0\\;sbi %m0-0x20,%1\\;sbrc %2,0\\;cbi %m0-0x20,%1\"\n+  \"sbrs %2,0\\;sbi %i0,%1\\;sbrc %2,0\\;cbi %i0,%1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none\")])\n "}]}