{"sha": "f2acf80cab788bd8b98918c6ba9547cf5637f816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJhY2Y4MGNhYjc4OGJkOGI5ODkxOGM2YmE5NTQ3Y2Y1NjM3ZjgxNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T10:42:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T10:42:02Z"}, "message": "[multiple changes]\n\n2010-10-26  Matthew Heaney  <heaney@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Add bounded hashed set and bounded hashed\n\tmap containers.\n\t* a-cohata.ads: Add declaration of generic package for bounded hash\n\ttable types.\n\t* a-chtgbo.ads, a-chtgbo.adb, a-chtgbk.ads, a-chtgbk.adb, a-cbhase.ads,\n\ta-cbhase.adb, a-cbhama.ads, a-cbhama.adb: New files.\n\n2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_warn.adb: Improve warning message on overlapping actuals.\n\n2010-10-26  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch4.adb, exp_dist.adb: Minor reformatting.\n\n2010-10-26  Vincent Celier  <celier@adacore.com>\n\n\t* makeusg.adb (Makeusg): Add lines for switches -vl, -vm and -vh.\n\n2010-10-26  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Move generation of\n\tpredicate check to analyzer, since too much rewriting occurs in the\n\tanalyzer.\n\t* sem_ch13.adb (Build_Predicate_Function): Change calling sequence, and\n\tchange the order in which things are done to fix several errors in\n\tdealing with qualification of the type name.\n\t(Build_Static_Predicate): Built static predicate after full analysis\n\tof the body. This is necessary to fix several problems.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Move predicate check here\n\tfrom expander, since too much expansion occurs in the analyzer to leave\n\tit that late.\n\t(Analyze_Object_Declaration): Change parameter Include_Null to new name\n\tInclude_Implicit in Is_Partially_Initialized_Type call.\n\t(Analyze_Subtype_Declaration): Make sure predicates are proapagated in\n\tsome strange cases of internal subtype generation.\n\t* sem_util.ads, sem_util.adb (Is_Partially_Initialized_Type): Change\n\tInclude_Null to Include_Implicit, now includes the case of\n\tdiscriminants.\n\n2010-10-26  Sergey Rybin  <rybin@adacore.com>\n\n\t* gnat_rm.texi: Revise the documentation for pragma Eliminate.\n\nFrom-SVN: r165939", "tree": {"sha": "4f1c965877fefdb62615f11273740d0004272bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f1c965877fefdb62615f11273740d0004272bc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2acf80cab788bd8b98918c6ba9547cf5637f816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2acf80cab788bd8b98918c6ba9547cf5637f816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2acf80cab788bd8b98918c6ba9547cf5637f816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2acf80cab788bd8b98918c6ba9547cf5637f816/comments", "author": null, "committer": null, "parents": [{"sha": "143eac1265ef53a189c92b11c4b1c77eab1156c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143eac1265ef53a189c92b11c4b1c77eab1156c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143eac1265ef53a189c92b11c4b1c77eab1156c9"}], "stats": {"total": 5200, "additions": 4979, "deletions": 221}, "files": [{"sha": "4529d876d250241a469581249740d69ea130b456", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -1,3 +1,49 @@\n+2010-10-26  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Add bounded hashed set and bounded hashed\n+\tmap containers.\n+\t* a-cohata.ads: Add declaration of generic package for bounded hash\n+\ttable types.\n+\t* a-chtgbo.ads, a-chtgbo.adb, a-chtgbk.ads, a-chtgbk.adb, a-cbhase.ads,\n+\ta-cbhase.adb, a-cbhama.ads, a-cbhama.adb: New files.\n+\n+2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_warn.adb: Improve warning message on overlapping actuals.\n+\n+2010-10-26  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch4.adb, exp_dist.adb: Minor reformatting.\n+\n+2010-10-26  Vincent Celier  <celier@adacore.com>\n+\n+\t* makeusg.adb (Makeusg): Add lines for switches -vl, -vm and -vh.\n+\n+2010-10-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Move generation of\n+\tpredicate check to analyzer, since too much rewriting occurs in the\n+\tanalyzer.\n+\t* sem_ch13.adb (Build_Predicate_Function): Change calling sequence, and\n+\tchange the order in which things are done to fix several errors in\n+\tdealing with qualification of the type name.\n+\t(Build_Static_Predicate): Built static predicate after full analysis\n+\tof the body. This is necessary to fix several problems.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Move predicate check here\n+\tfrom expander, since too much expansion occurs in the analyzer to leave\n+\tit that late.\n+\t(Analyze_Object_Declaration): Change parameter Include_Null to new name\n+\tInclude_Implicit in Is_Partially_Initialized_Type call.\n+\t(Analyze_Subtype_Declaration): Make sure predicates are proapagated in\n+\tsome strange cases of internal subtype generation.\n+\t* sem_util.ads, sem_util.adb (Is_Partially_Initialized_Type): Change\n+\tInclude_Null to Include_Implicit, now includes the case of\n+\tdiscriminants.\n+\n+2010-10-26  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* gnat_rm.texi: Revise the documentation for pragma Eliminate. \n+\n 2010-10-26  Matthew Heaney  <heaney@adacore.com>\n \n \t* Makefile.rtl, impunit.adb: Added bounded list container."}, {"sha": "78f585536bc054ac0769a976da3e74251f8e7b91", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -86,6 +86,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-calend$(objext) \\\n   a-calfor$(objext) \\\n   a-catizo$(objext) \\\n+  a-cbhama$(objext) \\\n+  a-cbhase$(objext) \\\n   a-cborse$(objext) \\\n   a-cbdlli$(objext) \\\n   a-cborma$(objext) \\\n@@ -98,6 +100,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-charac$(objext) \\\n   a-chlat1$(objext) \\\n   a-chlat9$(objext) \\\n+  a-chtgbo$(objext) \\\n+  a-chtgbk$(objext) \\\n   a-chtgke$(objext) \\\n   a-chtgop$(objext) \\\n   a-chzla1$(objext) \\"}, {"sha": "942007cde5d13346118e3aa3069c0f63be68566a", "filename": "gcc/ada/a-cbhama.adb", "status": "added", "additions": 1068, "deletions": 0, "changes": 1068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,1068 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ H A S H E D _ M A P S    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Prime_Numbers;  use Ada.Containers.Prime_Numbers;\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Bounded_Hashed_Maps is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Equivalent_Key_Node\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean;\n+   pragma Inline (Equivalent_Key_Node);\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   function Next (Node : Node_Type) return Count_Type;\n+   pragma Inline (Next);\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n+   pragma Inline (Set_Next);\n+\n+   function Vet (Position : Cursor) return Boolean;\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package HT_Ops is new Hash_Tables.Generic_Bounded_Operations\n+     (HT_Types  => HT_Types,\n+      Hash_Node => Hash_Node,\n+      Next      => Next,\n+      Set_Next  => Set_Next);\n+\n+   package Key_Ops is new Hash_Tables.Generic_Bounded_Keys\n+     (HT_Types        => HT_Types,\n+      Next            => Next,\n+      Set_Next        => Set_Next,\n+      Key_Type        => Key_Type,\n+      Hash            => Hash,\n+      Equivalent_Keys => Equivalent_Key_Node);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Map) return Boolean is\n+      function Find_Equal_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean;\n+\n+      function Is_Equal is new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+      --------------------\n+      -- Find_Equal_Key --\n+      --------------------\n+\n+      function Find_Equal_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean\n+      is\n+         R_Index : constant Hash_Type := Key_Ops.Index (R_HT, L_Node.Key);\n+         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n+\n+      begin\n+         while R_Node /= 0 loop\n+            if Equivalent_Keys (L_Node.Key, R_HT.Nodes (R_Node).Key) then\n+               return L_Node.Element = R_HT.Nodes (R_Node).Element;\n+            end if;\n+\n+            R_Node := R_HT.Nodes (R_Node).Next;\n+         end loop;\n+\n+         return False;\n+      end Find_Equal_Key;\n+\n+   --  Start of processing for \"=\"\n+\n+   begin\n+      return Is_Equal (Left, Right);\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Map; Source : Map) is\n+      procedure Insert_Element (Source_Node : Count_Type);\n+\n+      procedure Insert_Elements is\n+         new HT_Ops.Generic_Iteration (Insert_Element);\n+\n+      --------------------\n+      -- Insert_Element --\n+      --------------------\n+\n+      procedure Insert_Element (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.Nodes (Source_Node);\n+         C : Cursor;\n+         B : Boolean;\n+\n+      begin\n+         Insert (Target, N.Key, N.Element, C, B);\n+         pragma Assert (B);\n+      end Insert_Element;\n+\n+   --  Start of processing for Assign\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      HT_Ops.Clear (Target);\n+      Insert_Elements (Source);\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Map) return Count_Type is\n+   begin\n+      return Container.Capacity;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Map) is\n+   begin\n+      HT_Ops.Clear (Container);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean is\n+   begin\n+      return Find (Container, Key) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Map;\n+      Capacity : Count_Type := 0;\n+      Modulus  : Hash_Type := 0) return Map\n+   is\n+      C : Count_Type;\n+      M : Hash_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error with \"Capacity value too small\";\n+      end if;\n+\n+      if Modulus = 0 then\n+         M := Default_Modulus (C);\n+      else\n+         M := Modulus;\n+      end if;\n+\n+      return Target : Map (Capacity => C, Modulus => M) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ---------------------\n+   -- Default_Modulus --\n+   ---------------------\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n+   begin\n+      return To_Prime (Capacity);\n+   end Default_Modulus;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type) is\n+      X : Count_Type;\n+\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete key not in map\";\n+      end if;\n+\n+      HT_Ops.Free (Container, X);\n+   end Delete;\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor) is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"Delete attempted to tamper with cursors (map is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      HT_Ops.Free (Container, Position.Node);\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.Nodes (Node).Element;\n+   end Element;\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      return Position.Container.Nodes (Position.Node).Element;\n+   end Element;\n+\n+   -------------------------\n+   -- Equivalent_Key_Node --\n+   -------------------------\n+\n+   function Equivalent_Key_Node\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean is\n+   begin\n+      return Equivalent_Keys (Key, Node.Key);\n+   end Equivalent_Key_Node;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left), \"Left cursor of Equivalent_Keys is bad\");\n+      pragma Assert (Vet (Right), \"Right cursor of Equivalent_Keys is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return Equivalent_Keys (LN.Key, RN.Key);\n+      end;\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left), \"Left cursor in Equivalent_Keys is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+\n+      begin\n+         return Equivalent_Keys (LN.Key, Right);\n+      end;\n+   end Equivalent_Keys;\n+\n+   function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Keys equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Right), \"Right cursor of Equivalent_Keys is bad\");\n+\n+      declare\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return Equivalent_Keys (Left, RN.Key);\n+      end;\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type) is\n+      X : Count_Type;\n+   begin\n+      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      HT_Ops.Free (Container, X);\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Map) return Cursor is\n+      Node : constant Count_Type := HT_Ops.First (Container);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end First;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= 0;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type is\n+   begin\n+      return Hash (Node.Key);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"Include attempted to tamper with elements (map is locked)\";\n+         end if;\n+\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+\n+         begin\n+            N.Key := Key;\n+            N.Element := New_Item;\n+         end;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Assign_Key (Node : in out Node_Type);\n+      pragma Inline (Assign_Key);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+      procedure Allocate is\n+         new HT_Ops.Generic_Allocate (Assign_Key);\n+\n+      -----------------\n+      --  Assign_Key --\n+      -----------------\n+\n+      procedure Assign_Key (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         --  Node.Element := New_Item;\n+      end Assign_Key;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      --  ???\n+      --  if HT_Ops.Capacity (HT) = 0 then\n+      --     HT_Ops.Reserve_Capacity (HT, 1);\n+      --  end if;\n+\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n+\n+      --  ???\n+      --  if Inserted\n+      --    and then HT.Length > HT_Ops.Capacity (HT)\n+      --  then\n+      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n+      --  end if;\n+\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Assign_Key (Node : in out Node_Type);\n+      pragma Inline (Assign_Key);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Key_Ops.Generic_Conditional_Insert (New_Node);\n+\n+      procedure Allocate is\n+         new HT_Ops.Generic_Allocate (Assign_Key);\n+\n+      -----------------\n+      --  Assign_Key --\n+      -----------------\n+\n+      procedure Assign_Key (Node : in out Node_Type) is\n+      begin\n+         Node.Key := Key;\n+         Node.Element := New_Item;\n+      end Assign_Key;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      --  ??\n+      --  if HT_Ops.Capacity (HT) = 0 then\n+      --     HT_Ops.Reserve_Capacity (HT, 1);\n+      --  end if;\n+\n+      Local_Insert (Container, Key, Position.Node, Inserted);\n+\n+      --  ???\n+      --  if Inserted\n+      --    and then HT.Length > HT_Ops.Capacity (HT)\n+      --  then\n+      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n+      --  end if;\n+\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, Key, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert key already in map\";\n+      end if;\n+   end Insert;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Map) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Local_Iterate is new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Local_Iterate (Container);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ---------\n+   -- Key --\n+   ---------\n+\n+   function Key (Position : Cursor) return Key_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+      return Position.Container.Nodes (Position.Node).Key;\n+   end Key;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Map) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move\n+     (Target : in out Map;\n+      Source : in out Map)\n+   is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Assign (Target => Target, Source => Source);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Next\");\n+\n+      declare\n+         M    : Map renames Position.Container.all;\n+         Node : constant Count_Type := HT_Ops.Next (M, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         M : Map renames Position.Container.all;\n+         N : Node_Type renames M.Nodes (Position.Node);\n+         B : Natural renames M.Busy;\n+         L : Natural renames M.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         declare\n+\n+         begin\n+            Process (N.Key, N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map)\n+   is\n+      function Read_Node\n+        (Stream : not null access Root_Stream_Type'Class) return Count_Type;\n+      --  pragma Inline (Read_Node);  ???\n+\n+      procedure Read_Nodes is new HT_Ops.Generic_Read (Read_Node);\n+\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n+\n+      function Read_Node\n+        (Stream : not null access Root_Stream_Type'Class) return Count_Type\n+      is\n+         procedure Read_Element (Node : in out Node_Type);\n+         --  pragma Inline (Read_Element);  ???\n+\n+         procedure Allocate is\n+            new HT_Ops.Generic_Allocate (Read_Element);\n+\n+         procedure Read_Element (Node : in out Node_Type) is\n+         begin\n+            Key_Type'Read (Stream, Node.Key);\n+            Element_Type'Read (Stream, Node.Element);\n+         end Read_Element;\n+\n+         Node : Count_Type;\n+\n+      --  Start of processing for Read_Node\n+\n+      begin\n+         Allocate (Container, Node);\n+         return Node;\n+      end Read_Node;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Read_Nodes (Stream, Container);\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace key not in map\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"Replace attempted to tamper with elements (map is locked)\";\n+      end if;\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Node);\n+\n+      begin\n+         N.Key := Key;\n+         N.Element := New_Item;\n+      end;\n+   end Replace;\n+\n+   ---------------------\n+   -- Replace_Element --\n+   ---------------------\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n+      end if;\n+\n+      if Position.Container.Lock > 0 then\n+         raise Program_Error with\n+           \"Replace_Element attempted to tamper with elements (map is locked)\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      Container.Nodes (Position.Node).Element := New_Item;\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Map;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      if Capacity > Container.Capacity then\n+         raise Capacity_Error with \"requested capacity is too large\";\n+      end if;\n+   end Reserve_Capacity;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   --------------------\n+   -- Update_Element --\n+   --------------------\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access procedure (Key     : Key_Type;\n+                                             Element : in out Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n+\n+      declare\n+         N : Node_Type renames Container.Nodes (Position.Node);\n+         B : Natural renames Container.Busy;\n+         L : Natural renames Container.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (N.Key, N.Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Update_Element;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         M : Map renames Position.Container.all;\n+         X : Count_Type;\n+\n+      begin\n+         if M.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if M.Capacity = 0 then\n+            return False;\n+         end if;\n+\n+         if M.Buckets'Length = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > M.Capacity then\n+            return False;\n+         end if;\n+\n+         if M.Nodes (Position.Node).Next = Position.Node then\n+            return False;\n+         end if;\n+\n+         X := M.Buckets (Key_Ops.Index (M, M.Nodes (Position.Node).Key));\n+\n+         for J in 1 .. M.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = 0 then\n+               return False;\n+            end if;\n+\n+            if X = M.Nodes (X).Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := M.Nodes (X).Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is new HT_Ops.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Key_Type'Write (Stream, Node.Key);\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream map cursor\";\n+   end Write;\n+\n+end Ada.Containers.Bounded_Hashed_Maps;"}, {"sha": "042cc0fa1dfbcc72062408c0f1361625f4b3f07e", "filename": "gcc/ada/a-cbhama.ads", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhama.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,343 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--   A D A . C O N T A I N E R S . B O U N D E D _ H A S H E D _ M A P S    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+\n+generic\n+   type Key_Type is private;\n+   type Element_Type is private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+   with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Hashed_Maps is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   pragma Preelaborable_Initialization (Map);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Map : constant Map;\n+   --  Map objects declared without an initialization expression are\n+   --  initialized to the value Empty_Map.\n+\n+   No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n+\n+   function \"=\" (Left, Right : Map) return Boolean;\n+   --  For each key/element pair in Left, equality attempts to find the key in\n+   --  Right; if a search fails the equality returns False. The search works by\n+   --  calling Hash to find the bucket in the Right map that corresponds to the\n+   --  Left key. If bucket is non-empty, then equality calls Equivalent_Keys\n+   --  to compare the key (in Left) to the key of each node in the bucket (in\n+   --  Right); if the keys are equivalent, then the equality test for this\n+   --  key/element pair (in Left) completes by calling the element equality\n+   --  operator to compare the element (in Left) to the element of the node\n+   --  (in Right) whose key matched.\n+\n+   function Capacity (Container : Map) return Count_Type;\n+   --  Returns the current capacity of the map. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Map; Capacity : Count_Type);\n+   --  If the value of the Capacity actual parameter is less or equal to\n+   --  Container.Capacity, then the operation has no effect.  Otherwise it\n+   --  raises Capacity_Error (as no expansion of capacity is possible for a\n+   --  bounded form).\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+   --  Returns a modulus value (hash table size) which is optimal for the\n+   --  specified capacity (which corresponds to the maximum number of items).\n+\n+   function Length (Container : Map) return Count_Type;\n+   --  Returns the number of items in the map\n+\n+   function Is_Empty (Container : Map) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n+\n+   procedure Clear (Container : in out Map);\n+   --  Removes all of the items from the map\n+\n+   function Key (Position : Cursor) return Key_Type;\n+   --  Returns the key of the node designated by the cursor\n+\n+   function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n+\n+   procedure Replace_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+   --  Assigns the value New_Item to the element designated by the cursor\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access\n+                   procedure (Key : Key_Type; Element : Element_Type));\n+   --  Calls Process with the key and element (both having only a constant\n+   --  view) of the node designed by the cursor.\n+\n+   procedure Update_Element\n+     (Container : in out Map;\n+      Position  : Cursor;\n+      Process   : not null access\n+                    procedure (Key : Key_Type; Element : in out Element_Type));\n+   --  Calls Process with the key (with only a constant view) and element (with\n+   --  a variable view) of the node designed by the cursor.\n+\n+   procedure Assign (Target : in out Map; Source : Map);\n+   --  If Target denotes the same object as Source, then the operation has no\n+   --  effect. If the Target capacity is less then the Source length, then\n+   --  Assign raises Capacity_Error.  Otherwise, Assign clears Target and then\n+   --  copies the (active) elements from Source to Target.\n+\n+   function Copy\n+     (Source   : Map;\n+      Capacity : Count_Type := 0;\n+      Modulus  : Hash_Type := 0) return Map;\n+   --  Constructs a new set object whose elements correspond to Source.  If the\n+   --  Capacity parameter is 0, then the capacity of the result is the same as\n+   --  the length of Source. If the Capacity parameter is equal or greater than\n+   --  the length of Source, then the capacity of the result is the specified\n+   --  value. Otherwise, Copy raises Capacity_Error. If the Modulus parameter\n+   --  is 0, then the modulus of the result is the value returned by a call to\n+   --  Default_Modulus with the capacity parameter determined as above;\n+   --  otherwise the modulus of the result is the specified value.\n+\n+   procedure Move (Target : in out Map; Source : in out Map);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the map. If Key is already in the\n+   --  map, then Inserted returns False and Position designates the node\n+   --  containing the existing key/element pair (neither of which is modified).\n+   --  If Key is not already in the map, the Inserted returns True and Position\n+   --  designates the newly-inserted node container Key and New_Item. The\n+   --  search for the key works as follows. Hash is called to determine Key's\n+   --  bucket; if the bucket is non-empty, then Equivalent_Keys is called to\n+   --  compare Key to each node in that bucket. If the bucket is empty, or\n+   --  there were no matching keys in the bucket, the search \"fails\" and the\n+   --  key/item pair is inserted in the map (and Inserted returns True);\n+   --  otherwise, the search \"succeeds\" (and Inserted returns False).\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+   --  The same as the (conditional) Insert that accepts an element parameter,\n+   --  with the difference that if Inserted returns True, then the element of\n+   --  the newly-inserted node is initialized to its default value.\n+\n+   procedure Insert\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map, performing the usual search (which\n+   --  involves calling both Hash and Equivalent_Keys); if the search succeeds\n+   --  (because Key is already in the map), then it raises Constraint_Error.\n+   --  (This version of Insert is similar to Replace, but having the opposite\n+   --  exception behavior. It is intended for use when you want to assert that\n+   --  Key is not already in the map.)\n+\n+   procedure Include\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+   --  Attempts to insert Key into the map. If Key is already in the map, then\n+   --  both the existing key and element are assigned the values of Key and\n+   --  New_Item, respectively. (This version of Insert only raises an exception\n+   --  if cursor tampering occurs. It is intended for use when you want to\n+   --  insert the key/element pair in the map, and you don't care whether Key\n+   --  is already present.)\n+\n+   procedure Replace\n+     (Container : in out Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type);\n+   --  Searches for Key in the map; if the search fails (because Key was not in\n+   --  the map), then it raises Constraint_Error. Otherwise, both the existing\n+   --  key and element are assigned the values of Key and New_Item rsp. (This\n+   --  is similar to Insert, but with the opposite exception behavior. It is to\n+   --  be used when you want to assert that Key is already in the map.)\n+\n+   procedure Exclude (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map, and if found, removes its node from the map\n+   --  and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the key's bucket; if the bucket is not empty, it\n+   --  calls Equivalent_Keys to compare Key to each key in the bucket. (This is\n+   --  the deletion analog of Include. It is intended for use when you want to\n+   --  remove the item from the map, but don't care whether the key is already\n+   --  in the map.)\n+\n+   procedure Delete (Container : in out Map; Key : Key_Type);\n+   --  Searches for Key in the map (which involves calling both Hash and\n+   --  Equivalent_Keys). If the search fails, then the operation raises\n+   --  Constraint_Error. Otherwise it removes the node from the map and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the map.)\n+\n+   procedure Delete (Container : in out Map; Position : in out Cursor);\n+   --  Removes the node designated by Position from the map, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Keys).\n+\n+   function First (Container : Map) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n+\n+   function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n+\n+   procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n+\n+   function Find (Container : Map; Key : Key_Type) return Cursor;\n+   --  Searches for Key in the map. Find calls Hash to determine the key's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Keys to compare\n+   --  Key to each key in the bucket. If the search succeeds, Find returns a\n+   --  cursor designating the matching node; otherwise, it returns No_Element.\n+\n+   function Contains (Container : Map; Key : Key_Type) return Boolean;\n+   --  Equivalent to Find (Container, Key) /= No_Element\n+\n+   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   --  Equivalent to Element (Find (Container, Key))\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with the keys of the nodes\n+   --  designated by cursors Left and Right.\n+\n+   function Equivalent_Keys (Left : Cursor; Right : Key_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key of the node\n+   --  designated by Left and key Right.\n+\n+   function Equivalent_Keys (Left : Key_Type; Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Keys with key Left and the node\n+   --  designated by Right.\n+\n+   procedure Iterate\n+     (Container : Map;\n+      Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the map\n+\n+private\n+   --  pragma Inline (\"=\");\n+   pragma Inline (Length);\n+   pragma Inline (Is_Empty);\n+   pragma Inline (Clear);\n+   pragma Inline (Key);\n+   pragma Inline (Element);\n+   pragma Inline (Move);\n+   pragma Inline (Contains);\n+   pragma Inline (Capacity);\n+   pragma Inline (Reserve_Capacity);\n+   pragma Inline (Has_Element);\n+   pragma Inline (Equivalent_Keys);\n+   pragma Inline (Next);\n+\n+   type Node_Type is record\n+      Key     : Key_Type;\n+      Element : Element_Type;\n+      Next    : Count_Type;\n+   end record;\n+\n+   package HT_Types is\n+     new Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n+\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is\n+      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n+\n+   use HT_Types;\n+   use Ada.Streams;\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Map);\n+\n+   for Map'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Map);\n+\n+   for Map'Read use Read;\n+\n+   type Map_Access is access all Map;\n+   for Map_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Map_Access;\n+      Node      : Count_Type;\n+   end record;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   No_Element : constant Cursor := (Container => null, Node => 0);\n+\n+   Empty_Map : constant Map :=\n+     (Hash_Table_Type with Capacity => 0, Modulus => 0);\n+\n+end Ada.Containers.Bounded_Hashed_Maps;"}, {"sha": "e477690d997716109cf0e93d50a57d1cd3920cc9", "filename": "gcc/ada/a-cbhase.adb", "status": "added", "additions": 1737, "deletions": 0, "changes": 1737, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,1737 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . B O U N D E D _ H A S H E D _ S E T S   --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+\n+with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+\n+with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Bounded_Hashed_Sets is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Type) return Boolean;\n+   pragma Inline (Equivalent_Keys);\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type;\n+   pragma Inline (Hash_Node);\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean);\n+\n+   function Is_In\n+     (HT  : Set;\n+      Key : Node_Type) return Boolean;\n+   pragma Inline (Is_In);\n+\n+   procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n+   pragma Inline (Set_Element);\n+\n+   function Next (Node : Node_Type) return Count_Type;\n+   pragma Inline (Next);\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n+   pragma Inline (Set_Next);\n+\n+   function Vet (Position : Cursor) return Boolean;\n+\n+   --------------------------\n+   -- Local Instantiations --\n+   --------------------------\n+\n+   package HT_Ops is new Hash_Tables.Generic_Bounded_Operations\n+     (HT_Types  => HT_Types,\n+      Hash_Node => Hash_Node,\n+      Next      => Next,\n+      Set_Next  => Set_Next);\n+\n+   package Element_Keys is new Hash_Tables.Generic_Bounded_Keys\n+     (HT_Types        => HT_Types,\n+      Next            => Next,\n+      Set_Next        => Set_Next,\n+      Key_Type        => Element_Type,\n+      Hash            => Hash,\n+      Equivalent_Keys => Equivalent_Keys);\n+\n+   procedure Replace_Element is\n+      new Element_Keys.Generic_Replace_Element (Hash_Node, Set_Element);\n+\n+   ---------\n+   -- \"=\" --\n+   ---------\n+\n+   function \"=\" (Left, Right : Set) return Boolean is\n+      function Find_Equal_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean;\n+      pragma Inline (Find_Equal_Key);\n+\n+      function Is_Equal is\n+        new HT_Ops.Generic_Equal (Find_Equal_Key);\n+\n+      --------------------\n+      -- Find_Equal_Key --\n+      --------------------\n+\n+      function Find_Equal_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean\n+      is\n+         R_Index : constant Hash_Type :=\n+                     Element_Keys.Index (R_HT, L_Node.Element);\n+\n+         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n+\n+      begin\n+         loop\n+            if R_Node = 0 then\n+               return False;\n+            end if;\n+\n+            if L_Node.Element = R_HT.Nodes (R_Node).Element then\n+               return True;\n+            end if;\n+\n+            R_Node := Next (R_HT.Nodes (R_Node));\n+         end loop;\n+      end Find_Equal_Key;\n+\n+   --  Start of processing for \"=\"\n+\n+   begin\n+      return Is_Equal (Left, Right);\n+   end \"=\";\n+\n+   ------------\n+   -- Assign --\n+   ------------\n+\n+   procedure Assign (Target : in out Set; Source : Set) is\n+      procedure Insert_Element (Source_Node : Count_Type);\n+\n+      procedure Insert_Elements is\n+         new HT_Ops.Generic_Iteration (Insert_Element);\n+\n+      --------------------\n+      -- Insert_Element --\n+      --------------------\n+\n+      procedure Insert_Element (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.Nodes (Source_Node);\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         Insert (Target, N.Element, X, B);\n+         pragma Assert (B);\n+      end Insert_Element;\n+\n+   --  Start of processing for Assign\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Capacity < Source.Length then\n+         raise Capacity_Error\n+           with \"Target capacity is less than Source length\";\n+      end if;\n+\n+      HT_Ops.Clear (Target);\n+      Insert_Elements (Source);\n+   end Assign;\n+\n+   --------------\n+   -- Capacity --\n+   --------------\n+\n+   function Capacity (Container : Set) return Count_Type is\n+   begin\n+      return Container.Capacity;\n+   end Capacity;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (Container : in out Set) is\n+   begin\n+      HT_Ops.Clear (Container);\n+   end Clear;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+   begin\n+      return Find (Container, Item) /= No_Element;\n+   end Contains;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   function Copy\n+     (Source   : Set;\n+      Capacity : Count_Type := 0;\n+      Modulus  : Hash_Type := 0) return Set\n+   is\n+      C : Count_Type;\n+      M : Hash_Type;\n+\n+   begin\n+      if Capacity = 0 then\n+         C := Source.Length;\n+\n+      elsif Capacity >= Source.Length then\n+         C := Capacity;\n+\n+      else\n+         raise Capacity_Error with \"Capacity value too small\";\n+      end if;\n+\n+      if Modulus = 0 then\n+         M := Default_Modulus (C);\n+      else\n+         M := Modulus;\n+      end if;\n+\n+      return Target : Set (Capacity => C, Modulus => M) do\n+         Assign (Target => Target, Source => Source);\n+      end return;\n+   end Copy;\n+\n+   ---------------------\n+   -- Default_Modulus --\n+   ---------------------\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n+   begin\n+      return To_Prime (Capacity);\n+   end Default_Modulus;\n+\n+   ------------\n+   -- Delete --\n+   ------------\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Count_Type;\n+\n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+\n+      if X = 0 then\n+         raise Constraint_Error with \"attempt to delete element not in set\";\n+      end if;\n+\n+      HT_Ops.Free (Container, X);\n+   end Delete;\n+\n+   procedure Delete\n+     (Container : in out Set;\n+      Position  : in out Cursor)\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor designates wrong set\";\n+      end if;\n+\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Delete\");\n+\n+      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      HT_Ops.Free (Container, Position.Node);\n+\n+      Position := No_Element;\n+   end Delete;\n+\n+   ----------------\n+   -- Difference --\n+   ----------------\n+\n+   procedure Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node, Src_Node : Count_Type;\n+\n+      TN : Nodes_Type renames Target.Nodes;\n+      SN : Nodes_Type renames Source.Nodes;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         HT_Ops.Clear (Target);\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n+      if Source.Length < Target.Length then\n+         Src_Node := HT_Ops.First (Source);\n+         while Src_Node /= 0 loop\n+            Tgt_Node := Element_Keys.Find (Target, SN (Src_Node).Element);\n+\n+            if Tgt_Node /= 0 then\n+               HT_Ops.Delete_Node_Sans_Free (Target, Tgt_Node);\n+               HT_Ops.Free (Target, Tgt_Node);\n+            end if;\n+\n+            Src_Node := HT_Ops.Next (Source, Src_Node);\n+         end loop;\n+\n+      else\n+         Tgt_Node := HT_Ops.First (Target);\n+         while Tgt_Node /= 0 loop\n+            if Is_In (Source, TN (Tgt_Node)) then\n+               declare\n+                  X : constant Count_Type := Tgt_Node;\n+               begin\n+                  Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+                  HT_Ops.Delete_Node_Sans_Free (Target, X);\n+                  HT_Ops.Free (Target, X);\n+               end;\n+\n+            else\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+            end if;\n+         end loop;\n+      end if;\n+   end Difference;\n+\n+   function Difference (Left, Right : Set) return Set is\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      return Result : Set (Left.Length, To_Prime (Left.Length)) do\n+         Iterate_Left : declare\n+            procedure Process (L_Node : Count_Type);\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            procedure Process (L_Node : Count_Type) is\n+               N : Node_Type renames Left.Nodes (L_Node);\n+               X : Count_Type;\n+               B : Boolean;\n+\n+            begin\n+               if not Is_In (Right, N) then\n+                  Insert (Result, N.Element, X, B);  --  optimize this ???\n+                  pragma Assert (B);\n+                  pragma Assert (X > 0);\n+               end if;\n+            end Process;\n+\n+         --  Start of processing for Iterate_Left\n+\n+         begin\n+            Iterate (Left);\n+         end Iterate_Left;\n+      end return;\n+   end Difference;\n+\n+   -------------\n+   -- Element --\n+   -------------\n+\n+   function Element (Position : Cursor) return Element_Type is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in function Element\");\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+         N : Node_Type renames S.Nodes (Position.Node);\n+\n+      begin\n+         return N.Element;\n+      end;\n+   end Element;\n+\n+   ---------------------\n+   -- Equivalent_Sets --\n+   ---------------------\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean is\n+      function Find_Equivalent_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean;\n+      pragma Inline (Find_Equivalent_Key);\n+\n+      function Is_Equivalent is\n+         new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n+\n+      -------------------------\n+      -- Find_Equivalent_Key --\n+      -------------------------\n+\n+      function Find_Equivalent_Key\n+        (R_HT   : Hash_Table_Type'Class;\n+         L_Node : Node_Type) return Boolean\n+      is\n+         R_Index : constant Hash_Type :=\n+                     Element_Keys.Index (R_HT, L_Node.Element);\n+\n+         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n+\n+         RN      : Nodes_Type renames R_HT.Nodes;\n+\n+      begin\n+         loop\n+            if R_Node = 0 then\n+               return False;\n+            end if;\n+\n+            if Equivalent_Elements (L_Node.Element, RN (R_Node).Element) then\n+               return True;\n+            end if;\n+\n+            R_Node := HT_Ops.Next (R_HT, R_Node);\n+         end loop;\n+      end Find_Equivalent_Key;\n+\n+   --  Start of processing for Equivalent_Sets\n+\n+   begin\n+      return Is_Equivalent (Left, Right);\n+   end Equivalent_Sets;\n+\n+   -------------------------\n+   -- Equivalent_Elements --\n+   -------------------------\n+\n+   function Equivalent_Elements (Left, Right : Cursor)\n+     return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n+\n+      if Right.Node = 0 then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left), \"bad Left cursor in Equivalent_Elements\");\n+      pragma Assert (Vet (Right), \"bad Right cursor in Equivalent_Elements\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+\n+      begin\n+         return Equivalent_Elements (LN.Element, RN.Element);\n+      end;\n+   end Equivalent_Elements;\n+\n+   function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n+     return Boolean is\n+   begin\n+      if Left.Node = 0 then\n+         raise Constraint_Error with\n+           \"Left cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Left), \"Left cursor in Equivalent_Elements is bad\");\n+\n+      declare\n+         LN : Node_Type renames Left.Container.Nodes (Left.Node);\n+      begin\n+         return Equivalent_Elements (LN.Element, Right);\n+      end;\n+   end Equivalent_Elements;\n+\n+   function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n+     return Boolean is\n+   begin\n+      if Right.Node = 0 then\n+         raise Constraint_Error with\n+           \"Right cursor of Equivalent_Elements equals No_Element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Right),\n+         \"Right cursor of Equivalent_Elements is bad\");\n+\n+      declare\n+         RN : Node_Type renames Right.Container.Nodes (Right.Node);\n+      begin\n+         return Equivalent_Elements (Left, RN.Element);\n+      end;\n+   end Equivalent_Elements;\n+\n+   ---------------------\n+   -- Equivalent_Keys --\n+   ---------------------\n+\n+   function Equivalent_Keys (Key : Element_Type; Node : Node_Type)\n+     return Boolean is\n+   begin\n+      return Equivalent_Elements (Key, Node.Element);\n+   end Equivalent_Keys;\n+\n+   -------------\n+   -- Exclude --\n+   -------------\n+\n+   procedure Exclude\n+     (Container : in out Set;\n+      Item      : Element_Type)\n+   is\n+      X : Count_Type;\n+   begin\n+      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      HT_Ops.Free (Container, X);\n+   end Exclude;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor\n+   is\n+      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end Find;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (Container : Set) return Cursor is\n+      Node : constant Count_Type := HT_Ops.First (Container);\n+\n+   begin\n+      if Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Container'Unrestricted_Access, Node);\n+   end First;\n+\n+   -----------------\n+   -- Has_Element --\n+   -----------------\n+\n+   function Has_Element (Position : Cursor) return Boolean is\n+   begin\n+      pragma Assert (Vet (Position), \"bad cursor in Has_Element\");\n+      return Position.Node /= 0;\n+   end Has_Element;\n+\n+   ---------------\n+   -- Hash_Node --\n+   ---------------\n+\n+   function Hash_Node (Node : Node_Type) return Hash_Type is\n+   begin\n+      return Hash (Node.Element);\n+   end Hash_Node;\n+\n+   -------------\n+   -- Include --\n+   -------------\n+\n+   procedure Include\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         if Container.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (set is locked)\";\n+         end if;\n+\n+         Container.Nodes (Position.Node).Element := New_Item;\n+      end if;\n+   end Include;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean)\n+   is\n+   begin\n+      Insert (Container, New_Item, Position.Node, Inserted);\n+      Position.Container := Container'Unchecked_Access;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Position : Cursor;\n+      pragma Unreferenced (Position);\n+\n+      Inserted : Boolean;\n+\n+   begin\n+      Insert (Container, New_Item, Position, Inserted);\n+\n+      if not Inserted then\n+         raise Constraint_Error with\n+           \"attempt to insert element already in set\";\n+      end if;\n+   end Insert;\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Node      : out Count_Type;\n+      Inserted  : out Boolean)\n+   is\n+      procedure Allocate_Set_Element (Node : in out Node_Type);\n+      pragma Inline (Allocate_Set_Element);\n+\n+      function New_Node return Count_Type;\n+      pragma Inline (New_Node);\n+\n+      procedure Local_Insert is\n+        new Element_Keys.Generic_Conditional_Insert (New_Node);\n+\n+      procedure Allocate is\n+         new HT_Ops.Generic_Allocate (Allocate_Set_Element);\n+\n+      ---------------------------\n+      --  Allocate_Set_Element --\n+      ---------------------------\n+\n+      procedure Allocate_Set_Element (Node : in out Node_Type) is\n+      begin\n+         Node.Element := New_Item;\n+      end Allocate_Set_Element;\n+\n+      --------------\n+      -- New_Node --\n+      --------------\n+\n+      function New_Node return Count_Type is\n+         Result : Count_Type;\n+      begin\n+         Allocate (Container, Result);\n+         return Result;\n+      end New_Node;\n+\n+   --  Start of processing for Insert\n+\n+   begin\n+      --  ???\n+      --  if HT_Ops.Capacity (HT) = 0 then\n+      --     HT_Ops.Reserve_Capacity (HT, 1);\n+      --  end if;\n+\n+      Local_Insert (Container, New_Item, Node, Inserted);\n+\n+      --  ???\n+      --  if Inserted\n+      --    and then HT.Length > HT_Ops.Capacity (HT)\n+      --  then\n+      --     HT_Ops.Reserve_Capacity (HT, HT.Length);\n+      --  end if;\n+   end Insert;\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   procedure Intersection\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      Tgt_Node : Count_Type;\n+      TN       : Nodes_Type renames Target.Nodes;\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Length = 0 then\n+         HT_Ops.Clear (Target);\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n+      Tgt_Node := HT_Ops.First (Target);\n+      while Tgt_Node /= 0 loop\n+         if Is_In (Source, TN (Tgt_Node)) then\n+            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+\n+         else\n+            declare\n+               X : constant Count_Type := Tgt_Node;\n+            begin\n+               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               HT_Ops.Free (Target, X);\n+            end;\n+         end if;\n+      end loop;\n+   end Intersection;\n+\n+   function Intersection (Left, Right : Set) return Set is\n+      C : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      C := Count_Type'Min (Left.Length, Right.Length);\n+\n+      if C = 0 then\n+         return Empty_Set;\n+      end if;\n+\n+      return Result : Set (C, To_Prime (C)) do\n+         Iterate_Left : declare\n+            procedure Process (L_Node : Count_Type);\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            procedure Process (L_Node : Count_Type) is\n+               N : Node_Type renames Left.Nodes (L_Node);\n+               X : Count_Type;\n+               B : Boolean;\n+\n+            begin\n+               if Is_In (Right, N) then\n+                  Insert (Result, N.Element, X, B);  -- optimize ???\n+                  pragma Assert (B);\n+                  pragma Assert (X > 0);\n+               end if;\n+            end Process;\n+\n+         --  Start of processing for Iterate_Left\n+\n+         begin\n+            Iterate (Left);\n+         end Iterate_Left;\n+      end return;\n+   end Intersection;\n+\n+   --------------\n+   -- Is_Empty --\n+   --------------\n+\n+   function Is_Empty (Container : Set) return Boolean is\n+   begin\n+      return Container.Length = 0;\n+   end Is_Empty;\n+\n+   -----------\n+   -- Is_In --\n+   -----------\n+\n+   function Is_In (HT : Set; Key : Node_Type) return Boolean is\n+   begin\n+      return Element_Keys.Find (HT, Key.Element) /= 0;\n+   end Is_In;\n+\n+   ---------------\n+   -- Is_Subset --\n+   ---------------\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n+      Subset_Node : Count_Type;\n+      SN          : Nodes_Type renames Subset.Nodes;\n+\n+   begin\n+      if Subset'Address = Of_Set'Address then\n+         return True;\n+      end if;\n+\n+      if Subset.Length > Of_Set.Length then\n+         return False;\n+      end if;\n+\n+      Subset_Node := HT_Ops.First (Subset);\n+      while Subset_Node /= 0 loop\n+         if not Is_In (Of_Set, SN (Subset_Node)) then\n+            return False;\n+         end if;\n+         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n+      end loop;\n+\n+      return True;\n+   end Is_Subset;\n+\n+   -------------\n+   -- Iterate --\n+   -------------\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor))\n+   is\n+      procedure Process_Node (Node : Count_Type);\n+      pragma Inline (Process_Node);\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process_Node);\n+\n+      ------------------\n+      -- Process_Node --\n+      ------------------\n+\n+      procedure Process_Node (Node : Count_Type) is\n+      begin\n+         Process (Cursor'(Container'Unrestricted_Access, Node));\n+      end Process_Node;\n+\n+      B : Natural renames Container'Unrestricted_Access.Busy;\n+\n+   --  Start of processing for Iterate\n+\n+   begin\n+      B := B + 1;\n+\n+      begin\n+         Iterate (Container);\n+      exception\n+         when others =>\n+            B := B - 1;\n+            raise;\n+      end;\n+\n+      B := B - 1;\n+   end Iterate;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (Container : Set) return Count_Type is\n+   begin\n+      return Container.Length;\n+   end Length;\n+\n+   ----------\n+   -- Move --\n+   ----------\n+\n+   procedure Move (Target : in out Set; Source : in out Set) is\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Source.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      Assign (Target => Target, Source => Source);\n+   end Move;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next (Node : Node_Type) return Count_Type is\n+   begin\n+      return Node.Next;\n+   end Next;\n+\n+   function Next (Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = 0 then\n+         return No_Element;\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Next\");\n+\n+      declare\n+         HT   : Set renames Position.Container.all;\n+         Node : constant Count_Type := HT_Ops.Next (HT, Position.Node);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Position.Container, Node);\n+      end;\n+   end Next;\n+\n+   procedure Next (Position : in out Cursor) is\n+   begin\n+      Position := Next (Position);\n+   end Next;\n+\n+   -------------\n+   -- Overlap --\n+   -------------\n+\n+   function Overlap (Left, Right : Set) return Boolean is\n+      Left_Node : Count_Type;\n+\n+   begin\n+      if Right.Length = 0 then\n+         return False;\n+      end if;\n+\n+      if Left'Address = Right'Address then\n+         return True;\n+      end if;\n+\n+      Left_Node := HT_Ops.First (Left);\n+      while Left_Node /= 0 loop\n+         if Is_In (Right, Left.Nodes (Left_Node)) then\n+            return True;\n+         end if;\n+         Left_Node := HT_Ops.Next (Left, Left_Node);\n+      end loop;\n+\n+      return False;\n+   end Overlap;\n+\n+   -------------------\n+   -- Query_Element --\n+   -------------------\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type))\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+         B : Natural renames S.Busy;\n+         L : Natural renames S.Lock;\n+\n+      begin\n+         B := B + 1;\n+         L := L + 1;\n+\n+         begin\n+            Process (S.Nodes (Position.Node).Element);\n+         exception\n+            when others =>\n+               L := L - 1;\n+               B := B - 1;\n+               raise;\n+         end;\n+\n+         L := L - 1;\n+         B := B - 1;\n+      end;\n+   end Query_Element;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set)\n+   is\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+        return Count_Type;\n+\n+      procedure Read_Nodes is\n+         new HT_Ops.Generic_Read (Read_Node);\n+\n+      ---------------\n+      -- Read_Node --\n+      ---------------\n+\n+      function Read_Node (Stream : not null access Root_Stream_Type'Class)\n+        return Count_Type\n+      is\n+         procedure Read_Element (Node : in out Node_Type);\n+         pragma Inline (Read_Element);\n+\n+         procedure Allocate is\n+            new HT_Ops.Generic_Allocate (Read_Element);\n+\n+         procedure Read_Element (Node : in out Node_Type) is\n+         begin\n+            Element_Type'Read (Stream, Node.Element);\n+         end Read_Element;\n+\n+         Node : Count_Type;\n+\n+      --  Start of processing for Read_Node\n+\n+      begin\n+         Allocate (Container, Node);\n+         return Node;\n+      end Read_Node;\n+\n+   --  Start of processing for Read\n+\n+   begin\n+      Read_Nodes (Stream, Container);\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Read;\n+\n+   -------------\n+   -- Replace --\n+   -------------\n+\n+   procedure Replace\n+     (Container : in out Set;\n+      New_Item  : Element_Type)\n+   is\n+      Node : constant Count_Type :=\n+               Element_Keys.Find (Container, New_Item);\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"attempt to replace element not in set\";\n+      end if;\n+\n+      if Container.Lock > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with elements (set is locked)\";\n+      end if;\n+\n+      Container.Nodes (Node).Element := New_Item;\n+   end Replace;\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type)\n+   is\n+   begin\n+      if Position.Node = 0 then\n+         raise Constraint_Error with\n+           \"Position cursor equals No_Element\";\n+      end if;\n+\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Position cursor designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+\n+      Replace_Element (Container, Position.Node, New_Item);\n+   end Replace_Element;\n+\n+   ----------------------\n+   -- Reserve_Capacity --\n+   ----------------------\n+\n+   procedure Reserve_Capacity\n+     (Container : in out Set;\n+      Capacity  : Count_Type)\n+   is\n+   begin\n+      if Capacity > Container.Capacity then\n+         raise Capacity_Error with \"requested capacity is too large\";\n+      end if;\n+   end Reserve_Capacity;\n+\n+   ------------------\n+   --  Set_Element --\n+   ------------------\n+\n+   procedure Set_Element (Node : in out Node_Type; Item : Element_Type) is\n+   begin\n+      Node.Element := Item;\n+   end Set_Element;\n+\n+   --------------\n+   -- Set_Next --\n+   --------------\n+\n+   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n+   begin\n+      Node.Next := Next;\n+   end Set_Next;\n+\n+   --------------------------\n+   -- Symmetric_Difference --\n+   --------------------------\n+\n+   procedure Symmetric_Difference\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Source_Node : Count_Type);\n+      pragma Inline (Process);\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Source_Node : Count_Type) is\n+         N : Node_Type renames Source.Nodes (Source_Node);\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         if Is_In (Target, N) then\n+            Delete (Target, N.Element);\n+         else\n+            Insert (Target, N.Element, X, B);\n+            pragma Assert (B);\n+         end if;\n+      end Process;\n+\n+   --  Start of processing for Symmetric_Difference\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         HT_Ops.Clear (Target);\n+         return;\n+      end if;\n+\n+      if Target.Length = 0 then\n+         Assign (Target => Target, Source => Source);\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n+      Iterate (Source);\n+   end Symmetric_Difference;\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set is\n+      C : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Empty_Set;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      C := Left.Length + Right.Length;\n+\n+      return Result : Set (C, To_Prime (C)) do\n+         Iterate_Left : declare\n+            procedure Process (L_Node : Count_Type);\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            procedure Process (L_Node : Count_Type) is\n+               N : Node_Type renames Left.Nodes (L_Node);\n+               X : Count_Type;\n+               B : Boolean;\n+\n+            begin\n+               if not Is_In (Right, N) then\n+                  Insert (Result, N.Element, X, B);\n+                  pragma Assert (B);\n+               end if;\n+            end Process;\n+\n+         --  Start of processing for Iterate_Left\n+\n+         begin\n+            Iterate (Left);\n+         end Iterate_Left;\n+\n+         Iterate_Right : declare\n+            procedure Process (R_Node : Count_Type);\n+\n+            procedure Iterate is\n+               new HT_Ops.Generic_Iteration (Process);\n+\n+            -------------\n+            -- Process --\n+            -------------\n+\n+            procedure Process (R_Node : Count_Type) is\n+               N : Node_Type renames Left.Nodes (R_Node);\n+               X : Count_Type;\n+               B : Boolean;\n+\n+            begin\n+               if not Is_In (Left, N) then\n+                  Insert (Result, N.Element, X, B);\n+                  pragma Assert (B);\n+               end if;\n+            end Process;\n+\n+         --  Start of processing for Iterate_Right\n+\n+         begin\n+            Iterate (Right);\n+         end Iterate_Right;\n+      end return;\n+   end Symmetric_Difference;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set (New_Item : Element_Type) return Set is\n+      X : Count_Type;\n+      B : Boolean;\n+\n+   begin\n+      return Result : Set (1, 1) do\n+         Insert (Result, New_Item, X, B);\n+         pragma Assert (B);\n+      end return;\n+   end To_Set;\n+\n+   -----------\n+   -- Union --\n+   -----------\n+\n+   procedure Union\n+     (Target : in out Set;\n+      Source : Set)\n+   is\n+      procedure Process (Src_Node : Count_Type);\n+\n+      procedure Iterate is\n+         new HT_Ops.Generic_Iteration (Process);\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      procedure Process (Src_Node : Count_Type) is\n+         N : Node_Type renames Source.Nodes (Src_Node);\n+         X : Count_Type;\n+         B : Boolean;\n+\n+      begin\n+         Insert (Target, N.Element, X, B);\n+      end Process;\n+\n+   --  Start of processing for Union\n+\n+   begin\n+      if Target'Address = Source'Address then\n+         return;\n+      end if;\n+\n+      if Target.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n+      --  ???\n+      --  declare\n+      --     N : constant Count_Type := Target.Length + Source.Length;\n+      --  begin\n+      --     if N > HT_Ops.Capacity (Target.HT) then\n+      --        HT_Ops.Reserve_Capacity (Target.HT, N);\n+      --     end if;\n+      --  end;\n+\n+      Iterate (Source);\n+   end Union;\n+\n+   function Union (Left, Right : Set) return Set is\n+      C : Count_Type;\n+\n+   begin\n+      if Left'Address = Right'Address then\n+         return Left;\n+      end if;\n+\n+      if Right.Length = 0 then\n+         return Left;\n+      end if;\n+\n+      if Left.Length = 0 then\n+         return Right;\n+      end if;\n+\n+      C := Left.Length + Right.Length;\n+\n+      return Result : Set (C, To_Prime (C)) do\n+         Assign (Target => Result, Source => Left);\n+         Union (Target => Result, Source => Right);\n+      end return;\n+   end Union;\n+\n+   ---------\n+   -- Vet --\n+   ---------\n+\n+   function Vet (Position : Cursor) return Boolean is\n+   begin\n+      if Position.Node = 0 then\n+         return Position.Container = null;\n+      end if;\n+\n+      if Position.Container = null then\n+         return False;\n+      end if;\n+\n+      declare\n+         S : Set renames Position.Container.all;\n+         N : Nodes_Type renames S.Nodes;\n+         X : Count_Type;\n+\n+      begin\n+         if S.Length = 0 then\n+            return False;\n+         end if;\n+\n+         if Position.Node > N'Last then\n+            return False;\n+         end if;\n+\n+         if N (Position.Node).Next = Position.Node then\n+            return False;\n+         end if;\n+\n+         X := S.Buckets (Element_Keys.Index (S, N (Position.Node).Element));\n+\n+         for J in 1 .. S.Length loop\n+            if X = Position.Node then\n+               return True;\n+            end if;\n+\n+            if X = 0 then\n+               return False;\n+            end if;\n+\n+            if X = N (X).Next then  --  to prevent unnecessary looping\n+               return False;\n+            end if;\n+\n+            X := N (X).Next;\n+         end loop;\n+\n+         return False;\n+      end;\n+   end Vet;\n+\n+   -----------\n+   -- Write --\n+   -----------\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set)\n+   is\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+      pragma Inline (Write_Node);\n+\n+      procedure Write_Nodes is\n+         new HT_Ops.Generic_Write (Write_Node);\n+\n+      ----------------\n+      -- Write_Node --\n+      ----------------\n+\n+      procedure Write_Node\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type)\n+      is\n+      begin\n+         Element_Type'Write (Stream, Node.Element);\n+      end Write_Node;\n+\n+   --  Start of processing for Write\n+\n+   begin\n+      Write_Nodes (Stream, Container);\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream set cursor\";\n+   end Write;\n+\n+   package body Generic_Keys is\n+\n+      -----------------------\n+      -- Local Subprograms --\n+      -----------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean;\n+      pragma Inline (Equivalent_Key_Node);\n+\n+      --------------------------\n+      -- Local Instantiations --\n+      --------------------------\n+\n+      package Key_Keys is\n+         new Hash_Tables.Generic_Bounded_Keys\n+          (HT_Types  => HT_Types,\n+           Next      => Next,\n+           Set_Next  => Set_Next,\n+           Key_Type  => Key_Type,\n+           Hash      => Hash,\n+           Equivalent_Keys => Equivalent_Key_Node);\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains\n+        (Container : Set;\n+         Key       : Key_Type) return Boolean\n+      is\n+      begin\n+         return Find (Container, Key) /= No_Element;\n+      end Contains;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+\n+      begin\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+\n+         if X = 0 then\n+            raise Constraint_Error with \"attempt to delete key not in set\";\n+         end if;\n+\n+         HT_Ops.Free (Container, X);\n+      end Delete;\n+\n+      -------------\n+      -- Element --\n+      -------------\n+\n+      function Element\n+        (Container : Set;\n+         Key       : Key_Type) return Element_Type\n+      is\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with \"key not in map\";\n+         end if;\n+\n+         return Container.Nodes (Node).Element;\n+      end Element;\n+\n+      -------------------------\n+      -- Equivalent_Key_Node --\n+      -------------------------\n+\n+      function Equivalent_Key_Node\n+        (Key  : Key_Type;\n+         Node : Node_Type) return Boolean\n+      is\n+      begin\n+         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n+      end Equivalent_Key_Node;\n+\n+      -------------\n+      -- Exclude --\n+      -------------\n+\n+      procedure Exclude\n+        (Container : in out Set;\n+         Key       : Key_Type)\n+      is\n+         X : Count_Type;\n+      begin\n+         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         HT_Ops.Free (Container, X);\n+      end Exclude;\n+\n+      ----------\n+      -- Find --\n+      ----------\n+\n+      function Find\n+        (Container : Set;\n+         Key       : Key_Type) return Cursor\n+      is\n+         Node : constant Count_Type :=\n+                  Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            return No_Element;\n+         end if;\n+\n+         return Cursor'(Container'Unrestricted_Access, Node);\n+      end Find;\n+\n+      ---------\n+      -- Key --\n+      ---------\n+\n+      function Key (Position : Cursor) return Key_Type is\n+      begin\n+         if Position.Node = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n+         end if;\n+\n+         pragma Assert (Vet (Position), \"bad cursor in function Key\");\n+\n+         return Key (Position.Container.Nodes (Position.Node).Element);\n+      end Key;\n+\n+      -------------\n+      -- Replace --\n+      -------------\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type)\n+      is\n+         Node : constant Count_Type :=\n+                  Key_Keys.Find (Container, Key);\n+\n+      begin\n+         if Node = 0 then\n+            raise Constraint_Error with\n+              \"attempt to replace key not in set\";\n+         end if;\n+\n+         Replace_Element (Container, Node, New_Item);\n+      end Replace;\n+\n+      -----------------------------------\n+      -- Update_Element_Preserving_Key --\n+      -----------------------------------\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type))\n+      is\n+         Indx : Hash_Type;\n+         N    : Nodes_Type renames Container.Nodes;\n+\n+      begin\n+         if Position.Node = 0 then\n+            raise Constraint_Error with\n+              \"Position cursor equals No_Element\";\n+         end if;\n+\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with\n+              \"Position cursor designates wrong set\";\n+         end if;\n+\n+         --  ???\n+         --  if HT.Buckets = null\n+         --    or else HT.Buckets'Length = 0\n+         --    or else HT.Length = 0\n+         --    or else Position.Node.Next = Position.Node\n+         --  then\n+         --     raise Program_Error with\n+         --        \"Position cursor is bad (set is empty)\";\n+         --  end if;\n+\n+         pragma Assert\n+           (Vet (Position),\n+            \"bad cursor in Update_Element_Preserving_Key\");\n+\n+         --  Record bucket now, in case key is changed.\n+         Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n+\n+         declare\n+            E : Element_Type renames N (Position.Node).Element;\n+            K : constant Key_Type := Key (E);\n+\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+\n+            begin\n+               Process (E);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+\n+            if Equivalent_Keys (K, Key (E)) then\n+               pragma Assert (Hash (K) = Hash (E));\n+               return;\n+            end if;\n+         end;\n+\n+         --  Key was modified, so remove this node from set.\n+\n+         if Container.Buckets (Indx) = Position.Node then\n+            Container.Buckets (Indx) := N (Position.Node).Next;\n+\n+         else\n+            declare\n+               Prev : Count_Type := Container.Buckets (Indx);\n+\n+            begin\n+               while N (Prev).Next /= Position.Node loop\n+                  Prev := N (Prev).Next;\n+\n+                  if Prev = 0 then\n+                     raise Program_Error with\n+                       \"Position cursor is bad (node not found)\";\n+                  end if;\n+               end loop;\n+\n+               N (Prev).Next := N (Position.Node).Next;\n+            end;\n+         end if;\n+\n+         Container.Length := Container.Length - 1;\n+         HT_Ops.Free (Container, Position.Node);\n+\n+         raise Program_Error with \"key was modified\";\n+      end Update_Element_Preserving_Key;\n+\n+   end Generic_Keys;\n+\n+end Ada.Containers.Bounded_Hashed_Sets;"}, {"sha": "8854357a084a7c891f10caac38bc5c160ce0e3dc", "filename": "gcc/ada/a-cbhase.ads", "status": "added", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cbhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,466 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--    A D A . C O N T A I N E R S . B O U N D E D _ H A S H E D _ S E T S   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+private with Ada.Containers.Hash_Tables;\n+private with Ada.Streams;\n+\n+generic\n+   type Element_Type is private;\n+\n+   with function Hash (Element : Element_Type) return Hash_Type;\n+\n+   with function Equivalent_Elements\n+          (Left, Right : Element_Type) return Boolean;\n+\n+   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n+\n+package Ada.Containers.Bounded_Hashed_Sets is\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   pragma Preelaborable_Initialization (Set);\n+\n+   type Cursor is private;\n+   pragma Preelaborable_Initialization (Cursor);\n+\n+   Empty_Set : constant Set;\n+   --  Set objects declared without an initialization expression are\n+   --  initialized to the value Empty_Set.\n+\n+   No_Element : constant Cursor;\n+   --  Cursor objects declared without an initialization expression are\n+   --  initialized to the value No_Element.\n+\n+   function \"=\" (Left, Right : Set) return Boolean;\n+   --  For each element in Left, set equality attempts to find the equal\n+   --  element in Right; if a search fails, then set equality immediately\n+   --  returns False. The search works by calling Hash to find the bucket in\n+   --  the Right set that corresponds to the Left element. If the bucket is\n+   --  non-empty, the search calls the generic formal element equality operator\n+   --  to compare the element (in Left) to the element of each node in the\n+   --  bucket (in Right); the search terminates when a matching node in the\n+   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n+   --  element equality is called here, not Equivalent_Elements. Set equality\n+   --  is the only operation in which element equality is used. Compare set\n+   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n+\n+   function Equivalent_Sets (Left, Right : Set) return Boolean;\n+   --  Similar to set equality, with the difference that the element in Left is\n+   --  compared to the elements in Right using the generic formal\n+   --  Equivalent_Elements operation instead of element equality.\n+\n+   function To_Set (New_Item : Element_Type) return Set;\n+   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n+   --  determine the bucket for New_Item.\n+\n+   function Capacity (Container : Set) return Count_Type;\n+   --  Returns the current capacity of the set. Capacity is the maximum length\n+   --  before which rehashing in guaranteed not to occur.\n+\n+   procedure Reserve_Capacity (Container : in out Set; Capacity : Count_Type);\n+   --  If the value of the Capacity actual parameter is less or equal to\n+   --  Container.Capacity, then the operation has no effect.  Otherwise it\n+   --  raises Capacity_Error (as no expansion of capacity is possible for a\n+   --  bounded form).\n+\n+   function Default_Modulus (Capacity : Count_Type) return Hash_Type;\n+   --  Returns a modulus value (hash table size) which is optimal for the\n+   --  specified capacity (which corresponds to the maximum number of items).\n+\n+   function Length (Container : Set) return Count_Type;\n+   --  Returns the number of items in the set\n+\n+   function Is_Empty (Container : Set) return Boolean;\n+   --  Equivalent to Length (Container) = 0\n+\n+   procedure Clear (Container : in out Set);\n+   --  Removes all of the items from the set\n+\n+   function Element (Position : Cursor) return Element_Type;\n+   --  Returns the element of the node designated by the cursor\n+\n+   procedure Replace_Element\n+     (Container : in out Set;\n+      Position  : Cursor;\n+      New_Item  : Element_Type);\n+   --  If New_Item is equivalent (as determined by calling Equivalent_Elements)\n+   --  to the element of the node designated by Position, then New_Element is\n+   --  assigned to that element. Otherwise, it calls Hash to determine the\n+   --  bucket for New_Item. If the bucket is not empty, then it calls\n+   --  Equivalent_Elements for each node in that bucket to determine whether\n+   --  New_Item is equivalent to an element in that bucket. If\n+   --  Equivalent_Elements returns True then Program_Error is raised (because\n+   --  an element may appear only once in the set); otherwise, New_Item is\n+   --  assigned to the node designated by Position, and the node is moved to\n+   --  its new bucket.\n+\n+   procedure Query_Element\n+     (Position : Cursor;\n+      Process  : not null access procedure (Element : Element_Type));\n+   --  Calls Process with the element (having only a constant view) of the node\n+   --  designed by the cursor.\n+\n+   procedure Assign (Target : in out Set; Source : Set);\n+   --  If Target denotes the same object as Source, then the operation has no\n+   --  effect. If the Target capacity is less then the Source length, then\n+   --  Assign raises Capacity_Error.  Otherwise, Assign clears Target and then\n+   --  copies the (active) elements from Source to Target.\n+\n+   function Copy\n+     (Source   : Set;\n+      Capacity : Count_Type := 0;\n+      Modulus  : Hash_Type := 0) return Set;\n+   --  Constructs a new set object whose elements correspond to Source.  If the\n+   --  Capacity parameter is 0, then the capacity of the result is the same as\n+   --  the length of Source. If the Capacity parameter is equal or greater than\n+   --  the length of Source, then the capacity of the result is the specified\n+   --  value. Otherwise, Copy raises Capacity_Error. If the Modulus parameter\n+   --  is 0, then the modulus of the result is the value returned by a call to\n+   --  Default_Modulus with the capacity parameter determined as above;\n+   --  otherwise the modulus of the result is the specified value.\n+\n+   procedure Move (Target : in out Set; Source : in out Set);\n+   --  Clears Target (if it's not empty), and then moves (not copies) the\n+   --  buckets array and nodes from Source to Target.\n+\n+   procedure Insert\n+     (Container : in out Set;\n+      New_Item  : Element_Type;\n+      Position  : out Cursor;\n+      Inserted  : out Boolean);\n+   --  Conditionally inserts New_Item into the set. If New_Item is already in\n+   --  the set, then Inserted returns False and Position designates the node\n+   --  containing the existing element (which is not modified). If New_Item is\n+   --  not already in the set, then Inserted returns True and Position\n+   --  designates the newly-inserted node containing New_Item. The search for\n+   --  an existing element works as follows. Hash is called to determine\n+   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n+   --  is called to compare New_Item to the element of each node in that\n+   --  bucket. If the bucket is empty, or there were no equivalent elements in\n+   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n+   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n+   --  Inserted returns False).\n+\n+   procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set, performing the usual insertion\n+   --  search (which involves calling both Hash and Equivalent_Elements); if\n+   --  the search succeeds (New_Item is equivalent to an element already in the\n+   --  set, and so was not inserted), then this operation raises\n+   --  Constraint_Error. (This version of Insert is similar to Replace, but\n+   --  having the opposite exception behavior. It is intended for use when you\n+   --  want to assert that the item is not already in the set.)\n+\n+   procedure Include (Container : in out Set; New_Item : Element_Type);\n+   --  Attempts to insert New_Item into the set. If an element equivalent to\n+   --  New_Item is already in the set (the insertion search succeeded, and\n+   --  hence New_Item was not inserted), then the value of New_Item is assigned\n+   --  to the existing element. (This insertion operation only raises an\n+   --  exception if cursor tampering occurs. It is intended for use when you\n+   --  want to insert the item in the set, and you don't care whether an\n+   --  equivalent element is already present.)\n+\n+   procedure Replace (Container : in out Set; New_Item : Element_Type);\n+   --  Searches for New_Item in the set; if the search fails (because an\n+   --  equivalent element was not in the set), then it raises\n+   --  Constraint_Error. Otherwise, the existing element is assigned the value\n+   --  New_Item. (This is similar to Insert, but with the opposite exception\n+   --  behavior. It is intended for use when you want to assert that the item\n+   --  is already in the set.)\n+\n+   procedure Exclude (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set, and if found, removes its node from the\n+   --  set and then deallocates it. The search works as follows. The operation\n+   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n+   --  it calls Equivalent_Elements to compare Item to the element of each node\n+   --  in the bucket. (This is the deletion analog of Include. It is intended\n+   --  for use when you want to remove the item from the set, but don't care\n+   --  whether the item is already in the set.)\n+\n+   procedure Delete  (Container : in out Set; Item : Element_Type);\n+   --  Searches for Item in the set (which involves calling both Hash and\n+   --  Equivalent_Elements). If the search fails, then the operation raises\n+   --  Constraint_Error. Otherwise it removes the node from the set and then\n+   --  deallocates it. (This is the deletion analog of non-conditional\n+   --  Insert. It is intended for use when you want to assert that the item is\n+   --  already in the set.)\n+\n+   procedure Delete (Container : in out Set; Position : in out Cursor);\n+   --  Removes the node designated by Position from the set, and then\n+   --  deallocates the node. The operation calls Hash to determine the bucket,\n+   --  and then compares Position to each node in the bucket until there's a\n+   --  match (it does not call Equivalent_Elements).\n+\n+   procedure Union (Target : in out Set; Source : Set);\n+   --  Iterates over the Source set, and conditionally inserts each element\n+   --  into Target.\n+\n+   function Union (Left, Right : Set) return Set;\n+   --  The operation first copies the Left set to the result, and then iterates\n+   --  over the Right set to conditionally insert each element into the result.\n+\n+   function \"or\" (Left, Right : Set) return Set renames Union;\n+\n+   procedure Intersection (Target : in out Set; Source : Set);\n+   --  Iterates over the Target set (calling First and Next), calling Find to\n+   --  determine whether the element is in Source. If an equivalent element is\n+   --  not found in Source, the element is deleted from Target.\n+\n+   function Intersection (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in Right. If an equivalent element is found, it is inserted\n+   --  into the result set.\n+\n+   function \"and\" (Left, Right : Set) return Set renames Intersection;\n+\n+   procedure Difference (Target : in out Set; Source : Set);\n+   --  Iterates over the Source (calling First and Next), calling Find to\n+   --  determine whether the element is in Target. If an equivalent element is\n+   --  found, it is deleted from Target.\n+\n+   function Difference (Left, Right : Set) return Set;\n+   --  Iterates over the Left set, calling Find to determine whether the\n+   --  element is in the Right set. If an equivalent element is not found, the\n+   --  element is inserted into the result set.\n+\n+   function \"-\" (Left, Right : Set) return Set renames Difference;\n+\n+   procedure Symmetric_Difference (Target : in out Set; Source : Set);\n+   --  The operation iterates over the Source set, searching for the element\n+   --  in Target (calling Hash and Equivalent_Elements). If an equivalent\n+   --  elementis found, it is removed from Target; otherwise it is inserted\n+   --  into Target.\n+\n+   function Symmetric_Difference (Left, Right : Set) return Set;\n+   --  The operation first iterates over the Left set. It calls Find to\n+   --  determine whether the element is in the Right set. If no equivalent\n+   --  element is found, the element from Left is inserted into the result. The\n+   --  operation then iterates over the Right set, to determine whether the\n+   --  element is in the Left set. If no equivalent element is found, the Right\n+   --  element is inserted into the result.\n+\n+   function \"xor\" (Left, Right : Set) return Set\n+     renames Symmetric_Difference;\n+\n+   function Overlap (Left, Right : Set) return Boolean;\n+   --  Iterates over the Left set (calling First and Next), calling Find to\n+   --  determine whether the element is in the Right set. If an equivalent\n+   --  element is found, the operation immediately returns True. The operation\n+   --  returns False if the iteration over Left terminates without finding any\n+   --  equivalent element in Right.\n+\n+   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n+   --  Iterates over Subset (calling First and Next), calling Find to determine\n+   --  whether the element is in Of_Set. If no equivalent element is found in\n+   --  Of_Set, the operation immediately returns False. The operation returns\n+   --  True if the iteration over Subset terminates without finding an element\n+   --  not in Of_Set (that is, every element in Subset is equivalent to an\n+   --  element in Of_Set).\n+\n+   function First (Container : Set) return Cursor;\n+   --  Returns a cursor that designates the first non-empty bucket, by\n+   --  searching from the beginning of the buckets array.\n+\n+   function Next (Position : Cursor) return Cursor;\n+   --  Returns a cursor that designates the node that follows the current one\n+   --  designated by Position. If Position designates the last node in its\n+   --  bucket, the operation calls Hash to compute the index of this bucket,\n+   --  and searches the buckets array for the first non-empty bucket, starting\n+   --  from that index; otherwise, it simply follows the link to the next node\n+   --  in the same bucket.\n+\n+   procedure Next (Position : in out Cursor);\n+   --  Equivalent to Position := Next (Position)\n+\n+   function Find\n+     (Container : Set;\n+      Item      : Element_Type) return Cursor;\n+   --  Searches for Item in the set. Find calls Hash to determine the item's\n+   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n+   --  compare Item to each element in the bucket. If the search succeeds, Find\n+   --  returns a cursor designating the node containing the equivalent element;\n+   --  otherwise, it returns No_Element.\n+\n+   function Contains (Container : Set; Item : Element_Type) return Boolean;\n+   --  Equivalent to Find (Container, Item) /= No_Element\n+\n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with the elements of\n+   --  the nodes designated by cursors Left and Right.\n+\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element of the\n+   --  node designated by Left and element Right.\n+\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean;\n+   --  Returns the result of calling Equivalent_Elements with element Left and\n+   --  the element of the node designated by Right.\n+\n+   procedure Iterate\n+     (Container : Set;\n+      Process   : not null access procedure (Position : Cursor));\n+   --  Calls Process for each node in the set\n+\n+   generic\n+      type Key_Type (<>) is private;\n+\n+      with function Key (Element : Element_Type) return Key_Type;\n+\n+      with function Hash (Key : Key_Type) return Hash_Type;\n+\n+      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n+   package Generic_Keys is\n+\n+      function Key (Position : Cursor) return Key_Type;\n+      --  Applies generic formal operation Key to the element of the node\n+      --  designated by Position.\n+\n+      function Element (Container : Set; Key : Key_Type) return Element_Type;\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  returns the associated element.\n+\n+      procedure Replace\n+        (Container : in out Set;\n+         Key       : Key_Type;\n+         New_Item  : Element_Type);\n+      --  Searches (as per the key-based Find) for the node containing Key, and\n+      --  then replaces the element of that node (as per the element-based\n+      --  Replace_Element).\n+\n+      procedure Exclude (Container : in out Set; Key : Key_Type);\n+      --  Searches for Key in the set, and if found, removes its node from the\n+      --  set and then deallocates it. The search works by first calling Hash\n+      --  (on Key) to determine the bucket; if the bucket is not empty, it\n+      --  calls Equivalent_Keys to compare parameter Key to the value of\n+      --  generic formal operation Key applied to element of each node in the\n+      --  bucket.\n+\n+      procedure Delete (Container : in out Set; Key : Key_Type);\n+      --  Deletes the node containing Key as per Exclude, with the difference\n+      --  that Constraint_Error is raised if Key is not found.\n+\n+      function Find (Container : Set; Key : Key_Type) return Cursor;\n+      --  Searches for the node containing Key, and returns a cursor\n+      --  designating the node. The search works by first calling Hash (on Key)\n+      --  to determine the bucket. If the bucket is not empty, the search\n+      --  compares Key to the element of each node in the bucket, and returns\n+      --  the matching node. The comparison itself works by applying the\n+      --  generic formal Key operation to the element of the node, and then\n+      --  calling generic formal operation Equivalent_Keys.\n+\n+      function Contains (Container : Set; Key : Key_Type) return Boolean;\n+      --  Equivalent to Find (Container, Key) /= No_Element\n+\n+      procedure Update_Element_Preserving_Key\n+        (Container : in out Set;\n+         Position  : Cursor;\n+         Process   : not null access\n+                       procedure (Element : in out Element_Type));\n+      --  Calls Process with the element of the node designated by Position,\n+      --  but with the restriction that the key-value of the element is not\n+      --  modified. The operation first makes a copy of the value returned by\n+      --  applying generic formal operation Key on the element of the node, and\n+      --  then calls Process with the element. The operation verifies that the\n+      --  key-part has not been modified by calling generic formal operation\n+      --  Equivalent_Keys to compare the saved key-value to the value returned\n+      --  by applying generic formal operation Key to the post-Process value of\n+      --  element. If the key values compare equal then the operation\n+      --  completes. Otherwise, the node is removed from the map and\n+      --  Program_Error is raised.\n+\n+   end Generic_Keys;\n+\n+private\n+\n+   pragma Inline (Next);\n+\n+   type Node_Type is record\n+      Element : Element_Type;\n+      Next    : Count_Type;\n+   end record;\n+\n+   package HT_Types is\n+     new Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n+\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is\n+      new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n+\n+   use HT_Types;\n+   use Ada.Streams;\n+\n+   type Set_Access is access all Set;\n+   for Set_Access'Storage_Size use 0;\n+\n+   type Cursor is record\n+      Container : Set_Access;\n+      Node      : Count_Type;\n+   end record;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Cursor);\n+\n+   for Cursor'Read use Read;\n+\n+   No_Element : constant Cursor := (Container => null, Node => 0);\n+\n+   procedure Write\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : Set);\n+\n+   for Set'Write use Write;\n+\n+   procedure Read\n+     (Stream    : not null access Root_Stream_Type'Class;\n+      Container : out Set);\n+\n+   for Set'Read use Read;\n+\n+   Empty_Set : constant Set :=\n+     (Hash_Table_Type with Capacity => 0, Modulus => 0);\n+\n+end Ada.Containers.Bounded_Hashed_Sets;"}, {"sha": "211e921c6c5032ee6e5211cde1b1b17389349f77", "filename": "gcc/ada/a-chtgbk.adb", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,322 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.HASH_TABLES.GENERIC_BOUNDED_KEYS             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n+\n+   --------------------------\n+   -- Delete_Key_Sans_Free --\n+   --------------------------\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT  : in out Hash_Table_Type'Class;\n+      Key : Key_Type;\n+      X   : out Count_Type)\n+   is\n+      Indx : Hash_Type;\n+      Prev : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         X := 0;\n+         return;\n+      end if;\n+\n+      Indx := Index (HT, Key);\n+      X := HT.Buckets (Indx);\n+\n+      if X = 0 then\n+         return;\n+      end if;\n+\n+      if Equivalent_Keys (Key, HT.Nodes (X)) then\n+         if HT.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n+         end if;\n+         HT.Buckets (Indx) := Next (HT.Nodes (X));\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      loop\n+         Prev := X;\n+         X := Next (HT.Nodes (Prev));\n+\n+         if X = 0 then\n+            return;\n+         end if;\n+\n+         if Equivalent_Keys (Key, HT.Nodes (X)) then\n+            if HT.Busy > 0 then\n+               raise Program_Error with\n+                 \"attempt to tamper with cursors (container is busy)\";\n+            end if;\n+            Set_Next (HT.Nodes (Prev), Next => Next (HT.Nodes (X)));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+      end loop;\n+   end Delete_Key_Sans_Free;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Count_Type\n+   is\n+      Indx : Hash_Type;\n+      Node : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return 0;\n+      end if;\n+\n+      Indx := Index (HT, Key);\n+\n+      Node := HT.Buckets (Indx);\n+      while Node /= 0 loop\n+         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+            return Node;\n+         end if;\n+         Node := Next (HT.Nodes (Node));\n+      end loop;\n+\n+      return 0;\n+   end Find;\n+\n+   --------------------------------\n+   -- Generic_Conditional_Insert --\n+   --------------------------------\n+\n+   procedure Generic_Conditional_Insert\n+     (HT       : in out Hash_Table_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean)\n+   is\n+      Indx : constant Hash_Type := Index (HT, Key);\n+      B    : Count_Type renames HT.Buckets (Indx);\n+\n+   begin\n+      if B = 0 then\n+         if HT.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (container is busy)\";\n+         end if;\n+\n+         if HT.Length = HT.Capacity then\n+            raise Capacity_Error with \"no more capacity for insertion\";\n+         end if;\n+\n+         Node := New_Node;\n+         Set_Next (HT.Nodes (Node), Next => 0);\n+\n+         Inserted := True;\n+\n+         B := Node;\n+         HT.Length := HT.Length + 1;\n+\n+         return;\n+      end if;\n+\n+      Node := B;\n+      loop\n+         if Equivalent_Keys (Key, HT.Nodes (Node)) then\n+            Inserted := False;\n+            return;\n+         end if;\n+\n+         Node := Next (HT.Nodes (Node));\n+\n+         exit when Node = 0;\n+      end loop;\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      if HT.Length = HT.Capacity then\n+         raise Capacity_Error with \"no more capacity for insertion\";\n+      end if;\n+\n+      Node := New_Node;\n+      Set_Next (HT.Nodes (Node), Next => B);\n+\n+      Inserted := True;\n+\n+      B := Node;\n+      HT.Length := HT.Length + 1;\n+   end Generic_Conditional_Insert;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type is\n+   begin\n+      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n+   end Index;\n+\n+   -----------------------------\n+   -- Generic_Replace_Element --\n+   -----------------------------\n+\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : Count_Type;\n+      Key  : Key_Type)\n+   is\n+      pragma Assert (HT.Length > 0);\n+      pragma Assert (Node /= 0);\n+\n+      BB : Buckets_Type renames HT.Buckets;\n+      NN : Nodes_Type renames HT.Nodes;\n+\n+      Old_Hash : constant Hash_Type := Hash (NN (Node));\n+      Old_Indx : constant Hash_Type := BB'First + Old_Hash mod BB'Length;\n+\n+      New_Hash : constant Hash_Type := Hash (Key);\n+      New_Indx : constant Hash_Type := BB'First + New_Hash mod BB'Length;\n+\n+      New_Bucket : Count_Type renames BB (New_Indx);\n+      N, M       : Count_Type;\n+\n+   begin\n+      --  Replace_Element is allowed to change a node's key to Key\n+      --  (generic formal operation Assign provides the mechanism), but\n+      --  only if Key is not already in the hash table. (In a unique-key\n+      --  hash table as this one, a key is mapped to exactly one node.)\n+\n+      if Equivalent_Keys (Key, NN (Node)) then\n+         pragma Assert (New_Hash = Old_Hash);\n+\n+         if HT.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (container is locked)\";\n+         end if;\n+\n+         --  The new Key value is mapped to this same Node, so Node\n+         --  stays in the same bucket.\n+\n+         Assign (NN (Node), Key);\n+         pragma Assert (Hash (NN (Node)) = New_Hash);\n+         pragma Assert (Equivalent_Keys (Key, NN (Node)));\n+         return;\n+      end if;\n+\n+      --  Key is not equivalent to Node, so we now have to determine if it's\n+      --  equivalent to some other node in the hash table. This is the case\n+      --  irrespective of whether Key is in the same or a different bucket from\n+      --  Node.\n+\n+      N := New_Bucket;\n+      while N /= 0 loop\n+         if Equivalent_Keys (Key, NN (N)) then\n+            pragma Assert (N /= Node);\n+            raise Program_Error with\n+              \"attempt to replace existing element\";\n+         end if;\n+\n+         N := Next (NN (N));\n+      end loop;\n+\n+      --  We have determined that Key is not already in the hash table, so\n+      --  the change is tentatively allowed. We now perform the standard\n+      --  checks to determine whether the hash table is locked (because you\n+      --  cannot change an element while it's in use by Query_Element or\n+      --  Update_Element), or if the container is busy (because moving a\n+      --  node to a different bucket would interfere with iteration).\n+\n+      if Old_Indx = New_Indx then\n+         --  The node is already in the bucket implied by Key. In this case\n+         --  we merely change its value without moving it.\n+\n+         if HT.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements (container is locked)\";\n+         end if;\n+\n+         Assign (NN (Node), Key);\n+         pragma Assert (Hash (NN (Node)) = New_Hash);\n+         pragma Assert (Equivalent_Keys (Key, NN (Node)));\n+         return;\n+      end if;\n+\n+      --  The node is a bucket different from the bucket implied by Key\n+\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      --  Do the assignment first, before moving the node, so that if Assign\n+      --  propagates an exception, then the hash table will not have been\n+      --  modified (except for any possible side-effect Assign had on Node).\n+\n+      Assign (NN (Node), Key);\n+      pragma Assert (Hash (NN (Node)) = New_Hash);\n+      pragma Assert (Equivalent_Keys (Key, NN (Node)));\n+\n+      --  Now we can safely remove the node from its current bucket\n+\n+      N := BB (Old_Indx);  -- get value of first node in old bucket\n+      pragma Assert (N /= 0);\n+\n+      if N = Node then  -- node is first node in its bucket\n+         BB (Old_Indx) := Next (NN (Node));\n+\n+      else\n+         pragma Assert (HT.Length > 1);\n+\n+         loop\n+            M := Next (NN (N));\n+            pragma Assert (M /= 0);\n+\n+            if M = Node then\n+               Set_Next (NN (N), Next => Next (NN (Node)));\n+               exit;\n+            end if;\n+\n+            N := M;\n+         end loop;\n+      end if;\n+\n+      --  Now we link the node into its new bucket (corresponding to Key)\n+\n+      Set_Next (NN (Node), Next => New_Bucket);\n+      New_Bucket := Node;\n+   end Generic_Replace_Element;\n+\n+end Ada.Containers.Hash_Tables.Generic_Bounded_Keys;"}, {"sha": "4257c251e8db459ff433840ee466a6efe49e3b86", "filename": "gcc/ada/a-chtgbk.ads", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbk.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,106 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--              ADA.CONTAINERS.HASH_TABLES.GENERIC_BOUNDED_KEYS             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Hash_Table_Type is used to implement hashed containers. This package\n+--  declares hash-table operations that depend on keys.\n+\n+generic\n+   with package HT_Types is\n+     new Generic_Bounded_Hash_Table_Types (<>);\n+\n+   use HT_Types;\n+\n+   with function Next (Node : Node_Type) return Count_Type;\n+\n+   with procedure Set_Next\n+     (Node : in out Node_Type;\n+      Next : Count_Type);\n+\n+   type Key_Type (<>) is limited private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+\n+   with function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean;\n+\n+package Ada.Containers.Hash_Tables.Generic_Bounded_Keys is\n+   pragma Pure;\n+\n+   function Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Returns the bucket number (array index value) for the given key\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT  : in out Hash_Table_Type'Class;\n+      Key : Key_Type;\n+      X   : out Count_Type);\n+   --  Removes the node (if any) with the given key from the hash table,\n+   --  without deallocating it. Program_Error is raised if the hash\n+   --  table is busy.\n+\n+   function Find\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Count_Type;\n+   --  Returns the node (if any) corresponding to the given key\n+\n+   generic\n+      with function New_Node return Count_Type;\n+   procedure Generic_Conditional_Insert\n+     (HT       : in out Hash_Table_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean);\n+   --  Attempts to insert a new node with the given key into the hash table.\n+   --  If a node with that key already exists in the table, then that node\n+   --  is returned and Inserted returns False. Otherwise New_Node is called\n+   --  to allocate a new node, and Inserted returns True. Program_Error is\n+   --  raised if the hash table is busy.\n+\n+   generic\n+      with function Hash (Node : Node_Type) return Hash_Type;\n+      with procedure Assign (Node : in out Node_Type; Key : Key_Type);\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : Count_Type;\n+      Key  : Key_Type);\n+   --  Assigns Key to Node, possibly changing its equivalence class. If Node\n+   --  is in the same equivalence class as Key (that is, it's already in the\n+   --  bucket implied by Key), then if the hash table is locked then\n+   --  Program_Error is raised; otherwise Assign is called to assign Key to\n+   --  Node. If Node is in a different bucket from Key, then Program_Error is\n+   --  raised if the hash table is busy. Otherwise it Assigns Key to Node and\n+   --  moves the Node from its current bucket to the bucket implied by Key.\n+   --  Note that it is never proper to assign to Node a key value already\n+   --  in the map, and so if Key is equivalent to some other node then\n+   --  Program_Error is raised.\n+\n+end Ada.Containers.Hash_Tables.Generic_Bounded_Keys;"}, {"sha": "700ca2ebd510490a45255f1aff9acb32b1adb592", "filename": "gcc/ada/a-chtgbo.adb", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,473 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--           ADA.CONTAINERS.HASH_TABLES.GENERIC_BOUNDED_OPERATIONS          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System;  use type System.Address;\n+\n+package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (HT : in out Hash_Table_Type'Class) is\n+   begin\n+      if HT.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (container is busy)\";\n+      end if;\n+\n+      HT.Length := 0;\n+      --  HT.Busy := 0;\n+      --  HT.Lock := 0;\n+      HT.Free := -1;\n+      HT.Buckets := (others => 0);  -- optimize this somehow ???\n+   end Clear;\n+\n+   ---------------------------\n+   -- Delete_Node_Sans_Free --\n+   ---------------------------\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type)\n+   is\n+      pragma Assert (X /= 0);\n+\n+      Indx : Hash_Type;\n+      Prev : Count_Type;\n+      Curr : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hashed container\";\n+      end if;\n+\n+      Indx := Index (HT, HT.Nodes (X));\n+      Prev := HT.Buckets (Indx);\n+\n+      if Prev = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hash bucket\";\n+      end if;\n+\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (HT, Prev);\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      if HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (HT, Prev);\n+\n+         if Curr = 0 then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         if Curr = X then\n+            Set_Next (HT.Nodes (Prev), Next => Next (HT, Curr));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+\n+         Prev := Curr;\n+      end loop;\n+   end Delete_Node_Sans_Free;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (HT : Hash_Table_Type'Class) return Count_Type is\n+      Indx : Hash_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return 0;\n+      end if;\n+\n+      Indx := HT.Buckets'First;\n+      loop\n+         if HT.Buckets (Indx) /= 0 then\n+            return HT.Buckets (Indx);\n+         end if;\n+\n+         Indx := Indx + 1;\n+      end loop;\n+   end First;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type)\n+   is\n+      pragma Assert (X > 0);\n+      pragma Assert (X <= HT.Capacity);\n+\n+      N : Nodes_Type renames HT.Nodes;\n+      --  pragma Assert (N (X).Prev >= 0);  -- node is active\n+      --  Find a way to mark a node as active vs. inactive; we could\n+      --  use a special value in Color_Type for this.  ???\n+\n+   begin\n+      --  The hash table actually contains two data structures: a list for\n+      --  the \"active\" nodes that contain elements that have been inserted\n+      --  onto the container, and another for the \"inactive\" nodes of the free\n+      --  store.\n+      --\n+      --  We desire that merely declaring an object should have only minimal\n+      --  cost; specially, we want to avoid having to initialize the free\n+      --  store (to fill in the links), especially if the capacity is large.\n+      --\n+      --  The head of the free list is indicated by Container.Free. If its\n+      --  value is non-negative, then the free store has been initialized\n+      --  in the \"normal\" way: Container.Free points to the head of the list\n+      --  of free (inactive) nodes, and the value 0 means the free list is\n+      --  empty. Each node on the free list has been initialized to point\n+      --  to the next free node (via its Parent component), and the value 0\n+      --  means that this is the last free node.\n+      --\n+      --  If Container.Free is negative, then the links on the free store\n+      --  have not been initialized. In this case the link values are\n+      --  implied: the free store comprises the components of the node array\n+      --  started with the absolute value of Container.Free, and continuing\n+      --  until the end of the array (Nodes'Last).\n+      --\n+      --  ???\n+      --  It might be possible to perform an optimization here. Suppose that\n+      --  the free store can be represented as having two parts: one\n+      --  comprising the non-contiguous inactive nodes linked together\n+      --  in the normal way, and the other comprising the contiguous\n+      --  inactive nodes (that are not linked together, at the end of the\n+      --  nodes array). This would allow us to never have to initialize\n+      --  the free store, except in a lazy way as nodes become inactive.\n+\n+      --  When an element is deleted from the list container, its node\n+      --  becomes inactive, and so we set its Next component to value of\n+      --  the node's index (in the nodes array), to indicate that it is\n+      --  now inactive. This provides a useful way to detect a dangling\n+      --  cursor reference.  ???\n+\n+      Set_Next (N (X), Next => X);  -- Node is deallocated (not on active list)\n+\n+      if HT.Free >= 0 then\n+         --  The free store has previously been initialized. All we need to\n+         --  do here is link the newly-free'd node onto the free list.\n+\n+         Set_Next (N (X), HT.Free);\n+         HT.Free := X;\n+\n+      elsif X + 1 = abs HT.Free then\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive immediately precedes the start of the free store. All\n+         --  we need to do is move the start of the free store back by one.\n+\n+         HT.Free := HT.Free + 1;\n+\n+      else\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive does not immediately precede the free store. Here we\n+         --  first initialize the free store (meaning the links are given\n+         --  values in the traditional way), and then link the newly-free'd\n+         --  node onto the head of the free store.\n+\n+         --  ???\n+         --  See the comments above for an optimization opportunity. If\n+         --  the next link for a node on the free store is negative, then\n+         --  this means the remaining nodes on the free store are\n+         --  physically contiguous, starting as the absolute value of\n+         --  that index value.\n+\n+         HT.Free := abs HT.Free;\n+\n+         if HT.Free > HT.Capacity then\n+            HT.Free := 0;\n+\n+         else\n+            for I in HT.Free .. HT.Capacity - 1 loop\n+               Set_Next (Node => N (I), Next => I + 1);\n+            end loop;\n+\n+            Set_Next (Node => N (HT.Capacity), Next => 0);\n+         end if;\n+\n+         Set_Next (Node => N (X), Next => HT.Free);\n+         HT.Free := X;\n+      end if;\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : out Count_Type)\n+   is\n+      N : Nodes_Type renames HT.Nodes;\n+\n+   begin\n+      if HT.Free >= 0 then\n+         Node := HT.Free;\n+\n+         --  We always perform the assignment first, before we\n+         --  change container state, in order to defend against\n+         --  exceptions duration assignment.\n+\n+         Set_Element (N (Node));\n+         HT.Free := Next (N (Node));\n+\n+      else\n+         --  A negative free store value means that the links of the nodes\n+         --  in the free store have not been initialized. In this case, the\n+         --  nodes are physically contiguous in the array, starting at the\n+         --  index that is the absolute value of the Container.Free, and\n+         --  continuing until the end of the array (Nodes'Last).\n+\n+         Node := abs HT.Free;\n+\n+         --  As above, we perform this assignment first, before modifying\n+         --  any container state.\n+\n+         Set_Element (N (Node));\n+         HT.Free := HT.Free - 1;\n+      end if;\n+   end Generic_Allocate;\n+\n+   -------------------\n+   -- Generic_Equal --\n+   -------------------\n+\n+   function Generic_Equal\n+     (L, R : Hash_Table_Type'Class) return Boolean\n+   is\n+      L_Index : Hash_Type;\n+      L_Node  : Count_Type;\n+\n+      N : Count_Type;\n+\n+   begin\n+      if L'Address = R'Address then\n+         return True;\n+      end if;\n+\n+      if L.Length /= R.Length then\n+         return False;\n+      end if;\n+\n+      if L.Length = 0 then\n+         return True;\n+      end if;\n+\n+      --  Find the first node of hash table L\n+\n+      L_Index := 0;\n+      loop\n+         L_Node := L.Buckets (L_Index);\n+         exit when L_Node /= 0;\n+         L_Index := L_Index + 1;\n+      end loop;\n+\n+      --  For each node of hash table L, search for an equivalent node in hash\n+      --  table R.\n+\n+      N := L.Length;\n+      loop\n+         if not Find (HT => R, Key => L.Nodes (L_Node)) then\n+            return False;\n+         end if;\n+\n+         N := N - 1;\n+\n+         L_Node := Next (L, L_Node);\n+\n+         if L_Node = 0 then\n+            --  We have exhausted the nodes in this bucket\n+\n+            if N = 0 then\n+               return True;\n+            end if;\n+\n+            --  Find the next bucket\n+\n+            loop\n+               L_Index := L_Index + 1;\n+               L_Node := L.Buckets (L_Index);\n+               exit when L_Node /= 0;\n+            end loop;\n+         end if;\n+      end loop;\n+   end Generic_Equal;\n+\n+   -----------------------\n+   -- Generic_Iteration --\n+   -----------------------\n+\n+   procedure Generic_Iteration (HT : Hash_Table_Type'Class) is\n+      Node : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return;\n+      end if;\n+\n+      for Indx in HT.Buckets'Range loop\n+         Node := HT.Buckets (Indx);\n+         while Node /= 0 loop\n+            Process (Node);\n+            Node := Next (HT, Node);\n+         end loop;\n+      end loop;\n+   end Generic_Iteration;\n+\n+   ------------------\n+   -- Generic_Read --\n+   ------------------\n+\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type'Class)\n+   is\n+      N  : Count_Type'Base;\n+\n+   begin\n+      Clear (HT);\n+\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if N < 0 then\n+         raise Program_Error with \"stream appears to be corrupt\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      if N > HT.Capacity then\n+         raise Capacity_Error with \"too many elements in stream\";\n+      end if;\n+\n+      for J in 1 .. N loop\n+         declare\n+            Node : constant Count_Type := New_Node (Stream);\n+            Indx : constant Hash_Type := Index (HT, HT.Nodes (Node));\n+            B    : Count_Type renames HT.Buckets (Indx);\n+         begin\n+            Set_Next (HT.Nodes (Node), Next => B);\n+            B := Node;\n+         end;\n+\n+         HT.Length := HT.Length + 1;\n+      end loop;\n+   end Generic_Read;\n+\n+   -------------------\n+   -- Generic_Write --\n+   -------------------\n+\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type'Class)\n+   is\n+      procedure Write (Node : Count_Type);\n+      pragma Inline (Write);\n+\n+      procedure Write is new Generic_Iteration (Write);\n+\n+      -----------\n+      -- Write --\n+      -----------\n+\n+      procedure Write (Node : Count_Type) is\n+      begin\n+         Write (Stream, HT.Nodes (Node));\n+      end Write;\n+\n+   begin\n+      Count_Type'Base'Write (Stream, HT.Length);\n+      Write (HT);\n+   end Generic_Write;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Type) return Hash_Type is\n+   begin\n+      return Buckets'First + Hash_Node (Node) mod Buckets'Length;\n+   end Index;\n+\n+   function Index\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Node_Type) return Hash_Type is\n+   begin\n+      return Index (HT.Buckets, Node);\n+   end Index;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+      Result : Count_Type := Next (HT.Nodes (Node));\n+\n+   begin\n+      if Result /= 0 then  -- another node in same bucket\n+         return Result;\n+      end if;\n+\n+      --  This was the last node in the bucket, so move to the next\n+      --  bucket, and start searching for next node from there.\n+\n+      for Indx in Index (HT, HT.Nodes (Node)) + 1 .. HT.Buckets'Last loop\n+         Result := HT.Buckets (Indx);\n+\n+         if Result /= 0 then  -- bucket is not empty\n+            return Result;\n+         end if;\n+      end loop;\n+\n+      return 0;\n+   end Next;\n+\n+end Ada.Containers.Hash_Tables.Generic_Bounded_Operations;"}, {"sha": "8eca9e6a53e0d39bda0a52bb30235bd7e8f296d7", "filename": "gcc/ada/a-chtgbo.ads", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-chtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -0,0 +1,140 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--           ADA.CONTAINERS.HASH_TABLES.GENERIC_BOUNDED_OPERATIONS          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Hash_Table_Type is used to implement hashed containers. This package\n+--  declares hash-table operations that do not depend on keys.\n+\n+with Ada.Streams;\n+\n+generic\n+   with package HT_Types is\n+     new Generic_Bounded_Hash_Table_Types (<>);\n+\n+   use HT_Types;\n+\n+   with function Hash_Node (Node : Node_Type) return Hash_Type;\n+\n+   with function Next (Node : Node_Type) return Count_Type;\n+\n+   with procedure Set_Next\n+     (Node : in out Node_Type;\n+      Next : Count_Type);\n+\n+package Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n+   pragma Pure;\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Uses the hash value of Node to compute its Buckets array index\n+\n+   function Index\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Node_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Uses the hash value of Node to compute its Hash_Table buckets array\n+   --  index.\n+\n+   generic\n+      with function Find\n+        (HT  : Hash_Table_Type'Class;\n+         Key : Node_Type) return Boolean;\n+   function Generic_Equal (L, R : Hash_Table_Type'Class) return Boolean;\n+   --  Used to implement hashed container equality. For each node in hash table\n+   --  L, it calls Find to search for an equivalent item in hash table R. If\n+   --  Find returns False for any node then Generic_Equal terminates\n+   --  immediately and returns False. Otherwise if Find returns True for every\n+   --  node then Generic_Equal returns True.\n+\n+   procedure Clear (HT : in out Hash_Table_Type'Class);\n+   --  Deallocates each node in hash table HT. (Note that it only deallocates\n+   --  the nodes, not the buckets array.)  Program_Error is raised if the hash\n+   --  table is busy.\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type);\n+   --  Removes node X from the hash table without deallocating the node\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : out Count_Type);\n+   --  Claim a node from the free store. Generic_Allocate first\n+   --  calls Set_Element on the potential node, and then returns\n+   --  the node's index as the value of the Node parameter.\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type);\n+   --  Return a node back to the free store, from where it had\n+   --  been previously claimed via Generic_Allocate.\n+\n+   function First (HT : Hash_Table_Type'Class) return Count_Type;\n+   --  Returns the head of the list in the first (lowest-index) non-empty\n+   --  bucket.\n+\n+   function Next\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Count_Type) return Count_Type;\n+   --  Returns the node that immediately follows Node. This corresponds to\n+   --  either the next node in the same bucket, or (if Node is the last node in\n+   --  its bucket) the head of the list in the first non-empty bucket that\n+   --  follows.\n+\n+   generic\n+      with procedure Process (Node : Count_Type);\n+   procedure Generic_Iteration (HT : Hash_Table_Type'Class);\n+   --  Calls Process for each node in hash table HT\n+\n+   generic\n+      use Ada.Streams;\n+      with procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type'Class);\n+   --  Used to implement the streaming attribute for hashed containers. It\n+   --  calls Write for each node to write its value into Stream.\n+\n+   generic\n+      use Ada.Streams;\n+      with function New_Node (Stream : not null access Root_Stream_Type'Class)\n+         return Count_Type;\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type'Class);\n+   --  Used to implement the streaming attribute for hashed containers. It\n+   --  first clears hash table HT, then populates the hash table by calling\n+   --  New_Node for each item in Stream.\n+\n+end Ada.Containers.Hash_Tables.Generic_Bounded_Operations;"}, {"sha": "d935447b25bea7ad64bc9d3be00fb57a3172a9d9", "filename": "gcc/ada/a-cohata.ads", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohata.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,4 +52,23 @@ package Ada.Containers.Hash_Tables is\n       end record;\n    end Generic_Hash_Table_Types;\n \n+   generic\n+      type Node_Type is private;\n+   package Generic_Bounded_Hash_Table_Types is\n+      type Nodes_Type is array (Count_Type range <>) of Node_Type;\n+      type Buckets_Type is array (Hash_Type range <>) of Count_Type;\n+\n+      type Hash_Table_Type\n+        (Capacity : Count_Type;\n+         Modulus  : Hash_Type) is\n+      tagged record\n+         Length  : Count_Type := 0;\n+         Busy    : Natural := 0;\n+         Lock    : Natural := 0;\n+         Free    : Count_Type'Base := -1;\n+         Nodes   : Nodes_Type (1 .. Capacity);\n+         Buckets : Buckets_Type (1 .. Modulus) := (others => 0);\n+      end record;\n+   end Generic_Bounded_Hash_Table_Types;\n+\n end Ada.Containers.Hash_Tables;"}, {"sha": "a4acb245ec4bed8923b50cf92eb043cb9c0bcd87", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -4508,25 +4508,6 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n-      --  Deal with predicate check before we start to do major rewriting.\n-      --  it is OK to initialize and then check the initialized value, since\n-      --  the object goes out of scope if we get a predicate failure.\n-\n-      --  We need a predicate check if the type has predicates, and if either\n-      --  there is an initializing expression, or for default initialization\n-      --  when we have at least one case of an explicit default initial value.\n-\n-      if not Suppress_Assignment_Checks (N)\n-        and then Present (Predicate_Function (Typ))\n-        and then\n-          (Present (Expr)\n-            or else\n-              Is_Partially_Initialized_Type (Typ, Include_Null => False))\n-      then\n-         Insert_After (N,\n-           Make_Predicate_Check (Typ, New_Occurrence_Of (Def_Id, Loc)));\n-      end if;\n-\n       --  Force construction of dispatch tables of library level tagged types\n \n       if Tagged_Type_Expansion"}, {"sha": "24b27ceea255c613cdf65e3336cdc6fe7329c98f", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -1011,7 +1011,7 @@ package body Exp_Dist is\n       --  Subprogram id 0 is reserved for calls received from\n       --  remote access-to-subprogram dereferences.\n \n-      RCI_Instantiation   : Node_Id;\n+      RCI_Instantiation : Node_Id;\n \n       procedure Visit_Subprogram (Decl : Node_Id);\n       --  Generate calling stub for one remote subprogram\n@@ -1024,21 +1024,22 @@ package body Exp_Dist is\n          Loc        : constant Source_Ptr := Sloc (Decl);\n          Spec       : constant Node_Id := Specification (Decl);\n          Subp_Stubs : Node_Id;\n-         Subp_Str   : String_Id;\n+\n+         Subp_Str : String_Id;\n          pragma Warnings (Off, Subp_Str);\n \n       begin\n          Assign_Subprogram_Identifier\n            (Defining_Unit_Name (Spec), Current_Subprogram_Number, Subp_Str);\n \n          Subp_Stubs :=\n-           Build_Subprogram_Calling_Stubs (\n-             Vis_Decl     => Decl,\n-             Subp_Id      =>\n-               Build_Subprogram_Id (Loc, Defining_Unit_Name (Spec)),\n-             Asynchronous =>\n-               Nkind (Spec) = N_Procedure_Specification\n-                 and then Is_Asynchronous (Defining_Unit_Name (Spec)));\n+           Build_Subprogram_Calling_Stubs\n+             (Vis_Decl     => Decl,\n+              Subp_Id      =>\n+                Build_Subprogram_Id (Loc, Defining_Unit_Name (Spec)),\n+              Asynchronous =>\n+                Nkind (Spec) = N_Procedure_Specification\n+                  and then Is_Asynchronous (Defining_Unit_Name (Spec)));\n \n          Append_To (List_Containing (Decl), Subp_Stubs);\n          Analyze (Subp_Stubs);\n@@ -1067,7 +1068,7 @@ package body Exp_Dist is\n \n       --  For each subprogram declaration visible in the spec, we do build a\n       --  body. We also increment a counter to assign a different Subprogram_Id\n-      --  to each subprograms. The receiving stubs processing uses the same\n+      --  to each subprogram. The receiving stubs processing uses the same\n       --  mechanism and will thus assign the same Id and do the correct\n       --  dispatching.\n \n@@ -6830,12 +6831,12 @@ package body Exp_Dist is\n             Subp_Val : String_Id;\n \n             Subp_Dist_Name : constant Entity_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars =>\n-                  New_External_Name\n-                    (Related_Id   => Chars (Subp_Def),\n-                     Suffix       => 'D',\n-                     Suffix_Index => -1));\n+                               Make_Defining_Identifier (Loc,\n+                                 Chars =>\n+                                   New_External_Name\n+                                     (Related_Id   => Chars (Subp_Def),\n+                                      Suffix       => 'D',\n+                                      Suffix_Index => -1));\n \n             Current_Stubs  : Node_Id;\n             Proxy_Obj_Addr : Entity_Id;\n@@ -6846,9 +6847,8 @@ package body Exp_Dist is\n             Current_Stubs :=\n               Build_Subprogram_Receiving_Stubs\n                 (Vis_Decl     => Decl,\n-                 Asynchronous =>\n-                   Nkind (Spec) = N_Procedure_Specification\n-                 and then Is_Asynchronous (Subp_Def));\n+                 Asynchronous => Nkind (Spec) = N_Procedure_Specification\n+                                   and then Is_Asynchronous (Subp_Def));\n \n             Append_To (Decls, Current_Stubs);\n             Analyze (Current_Stubs);"}, {"sha": "a7af2054c8a55b65859526534e38d44d9b5cf4b0", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 44, "deletions": 98, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -1762,124 +1762,70 @@ gnat_ugn, @value{EDITION} User's Guide}.\n Syntax:\n \n @smallexample @c ada\n-pragma Eliminate (\n-    [Unit_Name =>] IDENTIFIER |\n-                   SELECTED_COMPONENT);\n+pragma Eliminate (UNIT_NAME, ENTITY, Source_Location => SOURCE_TRACE)\n \n-pragma Eliminate (\n-    [Unit_Name       =>]  IDENTIFIER |\n-                          SELECTED_COMPONENT,\n-    [Entity          =>]  IDENTIFIER |\n-                          SELECTED_COMPONENT |\n-                          STRING_LITERAL\n-    [,OVERLOADING_RESOLUTION]);\n+UNIT_NAME        ::= IDENTIFIER |\n+                     SELECTED_COMPONENT,\n \n-OVERLOADING_RESOLUTION ::= PARAMETER_AND_RESULT_TYPE_PROFILE |\n-                           SOURCE_LOCATION\n+ENTITY           ::= IDENTIFIER |\n+                     SELECTED_COMPONENT,\n \n-PARAMETER_AND_RESULT_TYPE_PROFILE ::= PROCEDURE_PROFILE |\n-                                      FUNCTION_PROFILE\n+SOURCE_TRACE     ::= SOURCE_REFERENCE |\n+                     SOURCE_REFERENCE LBRACKET SOURCE_TRACE RBRACKET\n \n-PROCEDURE_PROFILE ::= Parameter_Types => PARAMETER_TYPES\n+LBRACKET         ::= [\n+RBRACKET         ::= ]\n \n-FUNCTION_PROFILE ::= [Parameter_Types => PARAMETER_TYPES,]\n-                      Result_Type => result_SUBTYPE_NAME]\n+SOURCE_REFERENCE ::= FILE_NAME : LINE_NUMBER\n \n-PARAMETER_TYPES ::= (SUBTYPE_NAME @{, SUBTYPE_NAME@})\n-SUBTYPE_NAME    ::= STRING_VALUE\n-\n-SOURCE_LOCATION ::= Source_Location => SOURCE_TRACE\n-SOURCE_TRACE    ::= STRING_VALUE\n-\n-STRING_VALUE ::= STRING_LITERAL @{& STRING_LITERAL@}\n+FILE_NAME        ::= STRING_LITERAL\n+LINE_NUMBER      ::= INTEGER_LITERAL\n @end smallexample\n \n @noindent\n-This pragma indicates that the given entity is not used outside the\n-compilation unit it is defined in. The entity must be an explicitly declared\n-subprogram; this includes  generic subprogram instances and\n-subprograms declared in generic package instances.\n-\n-If the entity to be eliminated is a library level subprogram, then\n-the first form of pragma @code{Eliminate} is used with only a single argument.\n-In this form, the @code{Unit_Name} argument specifies the name of the\n-library  level unit to be eliminated.\n-\n-In all other cases, both @code{Unit_Name} and @code{Entity} arguments\n-are required. If item is an entity of a library package, then the first\n-argument specifies the unit name, and the second argument specifies\n-the particular entity.  If the second argument is in string form, it must\n-correspond to the internal manner in which GNAT stores entity names (see\n-compilation unit Namet in the compiler sources for details).\n+This pragma indicates that the given entity is not used in the program\n+to be compiled and built. The entity must be an explicitly declared\n+subprogram; this includes generic subprogram instances and\n+subprograms declared in generic package instances. @code{Unit_Name}\n+must be the name of the compilation unit in which the entity is declared.\n \n-The remaining parameters (OVERLOADING_RESOLUTION) are optionally used\n-to distinguish between overloaded subprograms. If a pragma does not contain\n-the OVERLOADING_RESOLUTION parameter(s), it is applied to all the overloaded\n-subprograms denoted by the first two parameters.\n-\n-Use PARAMETER_AND_RESULT_TYPE_PROFILE to specify the profile of the subprogram\n-to be eliminated in a manner similar to that used for the extended\n-@code{Import} and @code{Export} pragmas, except that the subtype names are\n-always given as strings. At the moment, this form of distinguishing\n-overloaded subprograms is implemented only partially, so we do not recommend\n-using it for practical subprogram elimination.\n-\n-Note that in case of a parameterless procedure its profile is represented\n-as @code{Parameter_Types => (\"\")}\n-\n-Alternatively, the @code{Source_Location} parameter is used to specify\n-which overloaded alternative is to be eliminated by pointing to the\n-location of the DEFINING_PROGRAM_UNIT_NAME of this subprogram in the\n-source text. The string literal (or concatenation of string literals)\n-given as SOURCE_TRACE must have the following format:\n-\n-@smallexample @c ada\n-SOURCE_TRACE ::= SOURCE_LOCATION@{LBRACKET SOURCE_LOCATION RBRACKET@}\n-\n-LBRACKET ::= [\n-RBRACKET ::= ]\n-\n-SOURCE_LOCATION ::= FILE_NAME:LINE_NUMBER\n-FILE_NAME       ::= STRING_LITERAL\n-LINE_NUMBER     ::= DIGIT @{DIGIT@}\n-@end smallexample\n-\n-SOURCE_TRACE should be the short name of the source file (with no directory\n-information), and LINE_NUMBER is supposed to point to the line where the\n-defining name of the subprogram is located.\n-\n-For the subprograms that are not a part of generic instantiations, only one\n-SOURCE_LOCATION is used. If a subprogram is declared in a package\n-instantiation, SOURCE_TRACE contains two SOURCE_LOCATIONs, the first one is\n-the location of the (DEFINING_PROGRAM_UNIT_NAME of the) instantiation, and the\n-second one denotes the declaration of the corresponding subprogram in the\n-generic package. This approach is recursively used to create SOURCE_LOCATIONs\n-in case of nested instantiations.\n+The @code{Source_Location} argument is used to resolve overloading\n+in case more then one callable entity with the same name is declared\n+in the given compilation unit. Each file name must be the short name of the\n+source file (with no directory information).\n+If an entity is not declared in\n+a generic instantiation (this includes generic subprogram instances),\n+the source trace includes only one source\n+reference. If an entity is declared inside a generic instantiation,\n+its source trace starts from the source location in the instantiation and\n+ends with the source location of the declaration of the corresponding\n+entity in the generic\n+unit. This approach is recursively used in case of nested instantiations:\n+the leftmost element of the\n+source trace is the location of the outermost instantiation, the next\n+element is the location of the next (first nested) instantiation in the\n+code of the corresponding generic unit, and so on.\n \n The effect of the pragma is to allow the compiler to eliminate\n the code or data associated with the named entity.  Any reference to\n-an eliminated entity outside the compilation unit it is defined in,\n-causes a compile time or link time error.\n+an eliminated entity outside the compilation unit where it is defined\n+causes a compile-time or link-time error.\n \n The intention of pragma @code{Eliminate} is to allow a program to be compiled\n-in a system independent manner, with unused entities eliminated, without\n-the requirement of modifying the source text.  Normally the required set\n+in a system-independent manner, with unused entities eliminated, without\n+needing to modify the source text.  Normally the required set\n of @code{Eliminate} pragmas is constructed automatically using the gnatelim\n tool. Elimination of unused entities local to a compilation unit is\n automatic, without requiring the use of pragma @code{Eliminate}.\n \n-Note that the reason this pragma takes string literals where names might\n-be expected is that a pragma @code{Eliminate} can appear in a context where the\n-relevant names are not visible.\n-\n-Note that any change in the source files that includes removing, splitting of\n-adding lines may make the set of Eliminate pragmas using SOURCE_LOCATION\n-parameter illegal.\n+Any source file change that removes, splits, or\n+adds lines may make the set of Eliminate pragmas invalid because their\n+@code{Source_Location} argument values may get out of date.\n \n-It is legal to use pragma Eliminate where the referenced entity is a\n-dispatching operation, but it is not clear what this would mean, since\n-in general the call does not know which entity is actually being called.\n-Consequently, a pragma Eliminate for a dispatching operation is ignored.\n+Pragma Eliminate may be used where the referenced entity is a\n+dispatching operation. In this case all the subprograms to which the\n+given operation can dispatch are considered to be unused (are never called\n+as a result of a direct or a dispatching call).\n \n @node Pragma Export_Exception\n @unnumberedsec Pragma Export_Exception"}, {"sha": "85ae7055fcdef5f3898c756a4167d2ccd56381a1", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -510,7 +510,9 @@ package body Impunit is\n      \"a-cobove\",    -- Ada.Containers.Bounded_Vectors\n      \"a-cbdlli\",    -- Ada.Containers.Bounded_Doubly_Linked_Lists\n      \"a-cborse\",    -- Ada.Containers.Bounded_Ordered_Sets\n-     \"a-cborma\");   -- Ada.Containers.Bounded_Ordered_Maps\n+     \"a-cborma\",    -- Ada.Containers.Bounded_Ordered_Maps\n+     \"a-cbhase\",    -- Ada.Containers.Bounded_Hashed_Sets\n+     \"a-cbhama\");   -- Ada.Containers.Bounded_Hashed_Maps\n \n    -----------------------\n    -- Alternative Units --"}, {"sha": "bc34387273c6b5124c9b73841985b86b78d991c4", "filename": "gcc/ada/makeusg.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -196,6 +196,21 @@ begin\n    Write_Str (\"  -v       Display reasons for all (re)compilations\");\n    Write_Eol;\n \n+   --  Line for -vl\n+\n+   Write_Str (\"  -vl      Verbose output (low verbosity)\");\n+   Write_Eol;\n+\n+   --  Line for -vm\n+\n+   Write_Str (\"  -vm      Verbose output (medium verbosity)\");\n+   Write_Eol;\n+\n+   --  Line for -vh\n+\n+   Write_Str (\"  -vh      Equivalent to -v (high verbosity)\");\n+   Write_Eol;\n+\n    --  Line for -vPx\n \n    Write_Str (\"  -vPx     Specify verbosity when parsing GNAT Project Files\");"}, {"sha": "594cbce75a1f650104678246f7bcbe498a1c81ba", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 122, "deletions": 64, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -44,6 +44,7 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -77,18 +78,15 @@ package body Sem_Ch13 is\n    --  inherited from a derived type that is no longer appropriate for the\n    --  new Esize value. In this case, we reset the Alignment to unknown.\n \n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id);\n+   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id);\n    --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n    --  then either there are pragma Invariant entries on the rep chain for the\n    --  type (note that Predicate aspects are converted to pragam Predicate), or\n-   --  there are inherited aspects from a parent type, or ancestor subtypes,\n-   --  or interfaces. This procedure builds the spec and body for the Predicate\n-   --  function that tests these predicates, returning them in PDecl and Pbody\n-   --  and setting Predicate_Procedure for Typ. In some error situations no\n-   --  procedure is built, in which case PDecl/PBody are empty on return.\n+   --  there are inherited aspects from a parent type, or ancestor subtypes.\n+   --  This procedure builds the spec and body for the Predicate function that\n+   --  tests these predicates. N is the freeze node for the type. The spec of\n+   --  the function is inserted before the freeze node, and the body of the\n+   --  funtion is inserted after the freeze node.\n \n    procedure Build_Static_Predicate\n      (Typ  : Entity_Id;\n@@ -3070,18 +3068,7 @@ package body Sem_Ch13 is\n       --  If we have a type with predicates, build predicate function\n \n       if Is_Type (E) and then Has_Predicates (E) then\n-         declare\n-            FDecl : Node_Id;\n-            FBody : Node_Id;\n-\n-         begin\n-            Build_Predicate_Function (E, FDecl, FBody);\n-\n-            if Present (FDecl) then\n-               Insert_After (N, FBody);\n-               Insert_After (N, FDecl);\n-            end if;\n-         end;\n+         Build_Predicate_Function (E, N);\n       end if;\n    end Analyze_Freeze_Entity;\n \n@@ -3839,14 +3826,15 @@ package body Sem_Ch13 is\n    --  inherited. Note that we do NOT generate Check pragmas, that's because we\n    --  use this function even if checks are off, e.g. for membership tests.\n \n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id)\n-   is\n+   procedure Build_Predicate_Function (Typ : Entity_Id; N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (Typ);\n       Spec : Node_Id;\n       SId  : Entity_Id;\n+      FDecl : Node_Id;\n+      FBody : Node_Id;\n+\n+      TName : constant Name_Id := Chars (Typ);\n+      --  Name of the type, used for replacement in predicate expression\n \n       Expr : Node_Id;\n       --  This is the expression for the return statement in the function. It\n@@ -3898,11 +3886,14 @@ package body Sem_Ch13 is\n             --  Output info message on inheritance if required. Note we do not\n             --  give this information for generic actual types, since it is\n             --  unwelcome noise in that case in instantiations. We also\n-            --  generally suppress the message in instantiations.\n+            --  generally suppress the message in instantiations, and also\n+            --  if it involves internal names.\n \n             if Opt.List_Inherited_Aspects\n               and then not Is_Generic_Actual_Type (Typ)\n               and then Instantiation_Depth (Sloc (Typ)) = 0\n+              and then not Is_Internal_Name (Chars (T))\n+              and then not Is_Internal_Name (Chars (Typ))\n             then\n                Error_Msg_Sloc := Sloc (Predicate_Function (T));\n                Error_Msg_Node_2 := T;\n@@ -3924,34 +3915,102 @@ package body Sem_Ch13 is\n          --  Process single node for traversal to replace type references\n \n          procedure Replace_Type is new Traverse_Proc (Replace_Node);\n-         --  Traverse an expression changing every occurrence of an entity\n-         --  reference to type T with a reference to the object argument.\n+         --  Traverse an expression changing every occurrence of an identifier\n+         --  whose name is TName with a reference to the object argument.\n \n          ------------------\n          -- Replace_Node --\n          ------------------\n \n          function Replace_Node (N : Node_Id) return Traverse_Result is\n+            S : Entity_Id;\n+            P : Node_Id;\n+\n          begin\n-            --  Case of entity name referencing the type\n+            --  Case of identifier\n \n-            if Is_Entity_Name (N) and then Entity (N) = Typ then\n+            if Nkind (N) = N_Identifier then\n \n-               --  Replace with object\n+               --  If not the type name, all done with this node\n \n-               Rewrite (N,\n-                 Make_Identifier (Loc,\n-                   Chars => Object_Name));\n+               if Chars (N) /= TName then\n+                  return Skip;\n \n-               --  All done with this node\n+               --  Otherwise do the replacement\n \n-               return Skip;\n+               else\n+                  goto Do_Replace;\n+               end if;\n+\n+               --  Case of selected component (which is what a qualification\n+               --  looks like in the unanalyzed tree, which is what we have.\n+\n+            elsif Nkind (N) = N_Selected_Component then\n+\n+               --  If selector name is not our type, keeping going (we might\n+               --  still have an occurrence of the type in the prefix).\n+\n+               if Nkind (Selector_Name (N)) /= N_Identifier\n+                 or else Chars (Selector_Name (N)) /= TName\n+               then\n+                  return OK;\n+\n+               --  Selector name is our type, check qualification\n+\n+               else\n+                  --  Loop through scopes and prefixes, doing comparison\n+\n+                  S := Current_Scope;\n+                  P := Prefix (N);\n+                  loop\n+                     --  Continue if no more scopes or scope with no name\n+\n+                     if No (S) or else Nkind (S) not in N_Has_Chars then\n+                        return OK;\n+                     end if;\n+\n+                     --  Do replace if prefix is an identifier matching the\n+                     --  scope that we are currently looking at.\n+\n+                     if Nkind (P) = N_Identifier\n+                       and then Chars (P) = Chars (S)\n+                     then\n+                        goto Do_Replace;\n+                     end if;\n+\n+                     --  Go check scope above us if prefix is itself of the\n+                     --  form of a selected component, whose selector matches\n+                     --  the scope we are currently looking at.\n+\n+                     if Nkind (P) = N_Selected_Component\n+                       and then Nkind (Selector_Name (P)) = N_Identifier\n+                       and then Chars (Selector_Name (P)) = Chars (S)\n+                     then\n+                        S := Scope (S);\n+                        P := Prefix (P);\n \n-            --  Not an occurrence of the type entity, keep going\n+                     --  For anything else, we don't have a match, so keep on\n+                     --  going, there are still some weird cases where we may\n+                     --  still have a replacement within the prefix.\n+\n+                     else\n+                        return OK;\n+                     end if;\n+                  end loop;\n+               end if;\n+\n+            --  Continue for any other node kind\n \n             else\n                return OK;\n             end if;\n+\n+         <<Do_Replace>>\n+\n+            --  Replace with object\n+\n+            Rewrite (N, Make_Identifier (Loc, Chars => Object_Name));\n+            return Skip;\n          end Replace_Node;\n \n       --  Start of processing for Add_Predicates\n@@ -3975,17 +4034,8 @@ package body Sem_Ch13 is\n                   --  We have a match, this entry is for our subtype\n \n                   --  First We need to replace any occurrences of the name of\n-                  --  the type with references to the object. We do this by\n-                  --  first doing a preanalysis, to identify all the entities,\n-                  --  then we traverse looking for the type entity, doing the\n-                  --  needed substitution. The preanalysis is done with the\n-                  --  special OK_To_Reference flag set on the type, so that if\n-                  --  we get an occurrence of this type, it will be recognized\n-                  --  as legitimate.\n-\n-                  Set_OK_To_Reference (Typ, True);\n-                  Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n-                  Set_OK_To_Reference (Typ, False);\n+                  --  the type with references to the object.\n+\n                   Replace_Type (Arg2);\n \n                   --  OK, replacement complete, now we can add the expression\n@@ -4014,8 +4064,6 @@ package body Sem_Ch13 is\n       --  Initialize for construction of statement list\n \n       Expr  := Empty;\n-      FDecl := Empty;\n-      FBody := Empty;\n \n       --  Return if already built or if type does not have predicates\n \n@@ -4043,16 +4091,6 @@ package body Sem_Ch13 is\n \n       if Present (Expr) then\n \n-         --  Deal with static predicate case\n-\n-         if Ekind_In (Typ, E_Enumeration_Subtype,\n-                           E_Modular_Integer_Subtype,\n-                           E_Signed_Integer_Subtype)\n-           and then Is_Static_Subtype (Typ)\n-         then\n-            Build_Static_Predicate (Typ, Expr, Object_Name);\n-         end if;\n-\n          --  Build function declaration\n \n          pragma Assert (Has_Predicates (Typ));\n@@ -4073,9 +4111,7 @@ package body Sem_Ch13 is\n              Result_Definition        =>\n                New_Occurrence_Of (Standard_Boolean, Loc));\n \n-         FDecl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Spec);\n+         FDecl := Make_Subprogram_Declaration (Loc, Specification => Spec);\n \n          --  Build function body\n \n@@ -4104,6 +4140,21 @@ package body Sem_Ch13 is\n                  Statements => New_List (\n                    Make_Simple_Return_Statement (Loc,\n                      Expression => Expr))));\n+\n+         --  Insert declaration before freeze node and body after\n+\n+         Insert_Before_And_Analyze (N, FDecl);\n+         Insert_After_And_Analyze  (N, FBody);\n+\n+         --  Deal with static predicate case\n+\n+         if Ekind_In (Typ, E_Enumeration_Subtype,\n+                           E_Modular_Integer_Subtype,\n+                           E_Signed_Integer_Subtype)\n+           and then Is_Static_Subtype (Typ)\n+         then\n+            Build_Static_Predicate (Typ, Expr, Object_Name);\n+         end if;\n       end if;\n    end Build_Predicate_Function;\n \n@@ -4908,6 +4959,13 @@ package body Sem_Ch13 is\n                    Left_Opnd    => Make_Identifier (Loc, Nam),\n                    Right_Opnd   => Empty,\n                    Alternatives => New_Alts));\n+\n+               --  Resolve new expression in function context\n+\n+               Install_Formals (Predicate_Function (Typ));\n+               Push_Scope (Predicate_Function (Typ));\n+               Analyze_And_Resolve (Expr, Standard_Boolean);\n+               Pop_Scope;\n             end if;\n          end;\n       end;"}, {"sha": "8bdd67859d0379e603d29ec5e4e9c642878a4d99", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -3077,6 +3077,27 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Deal with predicate check before we start to do major rewriting.\n+      --  it is OK to initialize and then check the initialized value, since\n+      --  the object goes out of scope if we get a predicate failure. Note\n+      --  that we do this in the analyzer and not the expander because the\n+      --  analyzer does some substantial rewriting in some cases.\n+\n+      --  We need a predicate check if the type has predicates, and if either\n+      --  there is an initializing expression, or for default initialization\n+      --  when we have at least one case of an explicit default initial value.\n+\n+      if not Suppress_Assignment_Checks (N)\n+        and then Present (Predicate_Function (T))\n+        and then\n+          (Present (E)\n+            or else\n+              Is_Partially_Initialized_Type (T, Include_Implicit => False))\n+      then\n+         Insert_After (N,\n+           Make_Predicate_Check (T, New_Occurrence_Of (Id, Loc)));\n+      end if;\n+\n       --  Case of unconstrained type\n \n       if Is_Indefinite_Subtype (T) then\n@@ -3846,7 +3867,13 @@ package body Sem_Ch3 is\n       --  If ancestor has predicates then so does the subtype, and in addition\n       --  we must delay the freeze to properly arrange predicate inheritance.\n \n-      if Has_Predicates (T) then\n+      --  The Ancestor_Type test is a big kludge, there seem to be cases in\n+      --  which T = ID, so the above tests and assignments do nothing???\n+\n+      if Has_Predicates (T)\n+        or else (Present (Ancestor_Subtype (T))\n+                   and then Has_Predicates (Ancestor_Subtype (T)))\n+      then\n          Set_Has_Predicates (Id);\n          Set_Has_Delayed_Freeze (Id);\n       end if;"}, {"sha": "604a9b16b14216dfdd0aa5e2e59fbf7e93431cac", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -2277,8 +2277,8 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Membership_Op (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n-      L     : constant Node_Id     := Left_Opnd (N);\n-      R     : constant Node_Id     := Right_Opnd (N);\n+      L     : constant Node_Id    := Left_Opnd (N);\n+      R     : constant Node_Id    := Right_Opnd (N);\n \n       Index : Interp_Index;\n       It    : Interp;"}, {"sha": "603a23022f8992987debd9383ffd3ffa895573a2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -6859,22 +6859,22 @@ package body Sem_Util is\n    -----------------------------------\n \n    function Is_Partially_Initialized_Type\n-     (Typ          : Entity_Id;\n-      Include_Null : Boolean := True) return Boolean\n+     (Typ              : Entity_Id;\n+      Include_Implicit : Boolean := True) return Boolean\n    is\n    begin\n       if Is_Scalar_Type (Typ) then\n          return False;\n \n       elsif Is_Access_Type (Typ) then\n-         return Include_Null;\n+         return Include_Implicit;\n \n       elsif Is_Array_Type (Typ) then\n \n          --  If component type is partially initialized, so is array type\n \n          if Is_Partially_Initialized_Type\n-              (Component_Type (Typ), Include_Null)\n+              (Component_Type (Typ), Include_Implicit)\n          then\n             return True;\n \n@@ -6888,9 +6888,10 @@ package body Sem_Util is\n \n       elsif Is_Record_Type (Typ) then\n \n-         --  A discriminated type is always partially initialized\n+         --  A discriminated type is always partially initialized if in\n+         --  all mode\n \n-         if Has_Discriminants (Typ) then\n+         if Has_Discriminants (Typ) and then Include_Implicit then\n             return True;\n \n          --  A tagged type is always partially initialized\n@@ -6929,7 +6930,7 @@ package body Sem_Util is\n                      --  initialized, then the enclosing record type is also.\n \n                      elsif Is_Partially_Initialized_Type\n-                             (Etype (Ent), Include_Null)\n+                             (Etype (Ent), Include_Implicit)\n                      then\n                         return True;\n                      end if;\n@@ -6969,7 +6970,7 @@ package body Sem_Util is\n             if No (U) then\n                return True;\n             else\n-               return Is_Partially_Initialized_Type (U, Include_Null);\n+               return Is_Partially_Initialized_Type (U, Include_Implicit);\n             end if;\n          end;\n "}, {"sha": "18d141eae6d56f02ee70353a7dd74aa5876ca95e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -769,17 +769,20 @@ package Sem_Util is\n    --  conversions and hence variables.\n \n    function Is_Partially_Initialized_Type\n-     (Typ          : Entity_Id;\n-      Include_Null : Boolean := True) return Boolean;\n+     (Typ              : Entity_Id;\n+      Include_Implicit : Boolean := True) return Boolean;\n    --  Typ is a type entity. This function returns true if this type is partly\n    --  initialized, meaning that an object of the type is at least partly\n    --  initialized (in particular in the record case, that at least one\n    --  component has an initialization expression). Note that initialization\n    --  resulting from the use of pragma Normalized_Scalars does not count.\n-   --  Include_Null controls the handling of access types, and components of\n-   --  access types not explicitly initialized. If set to True, the default,\n-   --  default initialization of access types counts as making the type be\n-   --  partially initialized. If False, this does not count.\n+   --  Include_Implicit controls whether implicit initialiation of access\n+   --  values to null, and of discriminant values, is counted as making the\n+   --  type be partially initialized. For the default setting of True, these\n+   --  implicit cases do count, and discriminated types or types containing\n+   --  access values not explicitly initialized will return True. Otherwise\n+   --  if Include_Implicit is False, these cases do not count as making the\n+   --  type be partially initialied.\n \n    function Is_Potentially_Persistent_Type (T : Entity_Id) return Boolean;\n    --  Determines if type T is a potentially persistent type. A potentially"}, {"sha": "209ddfd571b6ac2ac098d24a29494877732997a1", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2acf80cab788bd8b98918c6ba9547cf5637f816/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=f2acf80cab788bd8b98918c6ba9547cf5637f816", "patch": "@@ -3797,9 +3797,10 @@ package body Sem_Warn is\n                            end if;\n \n                         else\n+                           Error_Msg_Node_2 := Form;\n                            Error_Msg_FE\n-                             (\"writable actual overlaps with actual for&?\",\n-                              Act1, Form);\n+                             (\"writable actual for & overlaps with\"\n+                               & \" actual for&?\", Act1, Form1);\n                         end if;\n                      end;\n                   end if;"}]}