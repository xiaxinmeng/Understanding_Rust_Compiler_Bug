{"sha": "5109d49f79bd30eed20e28d4a24253860e0eaa06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEwOWQ0OWY3OWJkMzBlZWQyMGUyOGQ0YTI0MjUzODYwZTBlYWEwNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-02T22:52:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-02T22:52:56Z"}, "message": "(subst): Move simple operations inside IF_THEN_ELSE if the IF_THEN_ELSE is in the second operand as well as the first.\n\n(subst): Move simple operations inside IF_THEN_ELSE if the IF_THEN_ELSE is in\nthe second operand as well as the first.\n(subst, case NEG): Use plus_constant to make a PLUS.\n(subst, case MINUS): Simplify (minus 1 (comparison foo bar)).\n(subst, case EQ): Add a number of missing cases where comparisons may be\nreplaced with arithmetic or logical ops.\n(subst, case IF_THEN_ELSE): Handle (if_then_else COND (OP Z C1) Z) in a more\ngeneral manner.\n(simplify_and_const_int): Make AND with gen_binary in case we can simplify it.\n\nFrom-SVN: r5056", "tree": {"sha": "f25f0a40e1a441faee462eba46f337dbb1dfdbca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25f0a40e1a441faee462eba46f337dbb1dfdbca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5109d49f79bd30eed20e28d4a24253860e0eaa06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5109d49f79bd30eed20e28d4a24253860e0eaa06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5109d49f79bd30eed20e28d4a24253860e0eaa06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5109d49f79bd30eed20e28d4a24253860e0eaa06/comments", "author": null, "committer": null, "parents": [{"sha": "5937bc8428e95e960bb3de18ea1517ebe3d954e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5937bc8428e95e960bb3de18ea1517ebe3d954e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5937bc8428e95e960bb3de18ea1517ebe3d954e3"}], "stats": {"total": 310, "additions": 218, "deletions": 92}, "files": [{"sha": "84bcef9c94c2aab17adc2554503e1ddcf75b45f5", "filename": "gcc/combine.c", "status": "modified", "additions": 218, "deletions": 92, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5109d49f79bd30eed20e28d4a24253860e0eaa06/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5109d49f79bd30eed20e28d4a24253860e0eaa06/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5109d49f79bd30eed20e28d4a24253860e0eaa06", "patch": "@@ -2898,6 +2898,23 @@ subst (x, from, to, in_dest, unique_copy)\n       goto restart;\n     }\n \n+  else if ((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n+\t   && GET_CODE (XEXP (x, 1)) == IF_THEN_ELSE)\n+    {\n+      /* Don't do this by using SUBST inside X since we might be messing\n+\t up a shared expression.  */\n+      rtx cond = XEXP (XEXP (x, 1), 0);\n+      rtx t_arm = subst (gen_binary (code, mode, XEXP (x, 0),\n+\t\t\t\t     XEXP (XEXP (x, 1), 1)),\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n+      rtx f_arm = subst (gen_binary (code, mode, XEXP (x, 0),\n+\t\t\t\t     XEXP (XEXP (x, 1), 2)),\n+\t\t\t pc_rtx, pc_rtx, 0, 0);\n+\n+      x = gen_rtx (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n+      goto restart;\n+    }\n+\n   else if (GET_RTX_CLASS (code) == '1'\n \t   && GET_CODE (XEXP (x, 0)) == IF_THEN_ELSE\n \t   && GET_MODE (XEXP (x, 0)) == mode)\n@@ -3242,7 +3259,7 @@ subst (x, from, to, in_dest, unique_copy)\n       /* Similarly, (neg (not X)) is (plus X 1).  */\n       if (GET_CODE (XEXP (x, 0)) == NOT)\n  \t{\n-\t  x = gen_rtx_combine (PLUS, mode, XEXP (XEXP (x, 0), 0), const1_rtx);\n+\t  x = plus_constant (XEXP (XEXP (x, 0), 0), 1);\n \t  goto restart;\n  \t}\n \n@@ -3457,6 +3474,17 @@ subst (x, from, to, in_dest, unique_copy)\n       break;\n \n     case MINUS:\n+#if STORE_FLAG_VALUE == 1\n+      /* (minus 1 (comparison foo bar)) can be done by reversing the comparison\n+\t code if valid.  */\n+      if (XEXP (x, 0) == const1_rtx\n+\t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<'\n+\t  && reversible_comparison_p (XEXP (x, 1)))\n+\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 1))),\n+\t\t\t   mode, XEXP (XEXP (x, 1), 0),\n+\t\t\t\tXEXP (XEXP (x, 1), 1));\n+#endif\n+\n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n       if (GET_CODE (XEXP (x, 1)) == AND\n@@ -3551,42 +3579,90 @@ subst (x, from, to, in_dest, unique_copy)\n #if STORE_FLAG_VALUE == 1\n \t  /* If STORE_FLAG_VALUE is 1, we can convert (ne x 0) to simply X\n \t     if only the low-order bit is possibly nonzero in X (such as when\n-\t     X is a ZERO_EXTRACT of one bit.  Similarly, we can convert\n-\t     EQ to (xor X 1).  Remove any ZERO_EXTRACT we made when thinking\n-\t     this was a comparison.  It may now be simpler to use, e.g., an\n-\t     AND.  If a ZERO_EXTRACT is indeed appropriate, it will\n-\t     be placed back by the call to make_compound_operation in the\n-\t     SET case.  */\n+\t     X is a ZERO_EXTRACT of one bit).  Similarly, we can convert EQ to\n+\t     (xor X 1) or (minus 1 X); we use the former.  Finally, if X is\n+\t     known to be either 0 or -1, NE becomes a NEG and EQ becomes\n+\t     (plus X 1).\n+\n+\t     Remove any ZERO_EXTRACT we made when thinking this was a\n+\t     comparison.  It may now be simpler to use, e.g., an AND.  If a\n+\t     ZERO_EXTRACT is indeed appropriate, it will be placed back by\n+\t     the call to make_compound_operation in the SET case.  */\n+\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n-\t      && nonzero_bits (op0, GET_MODE (op0)) == 1)\n+\t      && nonzero_bits (op0, mode) == 1)\n \t    return gen_lowpart_for_combine (mode,\n \t\t\t\t\t    expand_compound_operation (op0));\n+\n+\t  else if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && op1 == const0_rtx\n+\t\t   && (num_sign_bit_copies (op0, mode)\n+\t\t       == GET_MODE_BITSIZE (mode)))\n+\t    {\n+\t      op0 = expand_compound_operation (op0);\n+\t      x = gen_unary (NEG, mode, gen_lowpart_for_combine (mode, op0));\n+\t      goto restart;\n+\t    }\n+\n \t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n \t\t   && op1 == const0_rtx\n-\t\t   && nonzero_bits (op0, GET_MODE (op0)) == 1)\n+\t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n+\t      x = gen_binary (XOR, mode,\n+\t\t\t      gen_lowpart_for_combine (mode, op0),\n+\t\t\t      const1_rtx);\n+\t      goto restart;\n+\t    }\n \n-\t      x = gen_rtx_combine (XOR, mode,\n-\t\t\t\t   gen_lowpart_for_combine (mode, op0),\n-\t\t\t\t   const1_rtx);\n+\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && op1 == const0_rtx\n+\t\t   && (num_sign_bit_copies (op0, mode)\n+\t\t       == GET_MODE_BITSIZE (mode)))\n+\t    {\n+\t      op0 = expand_compound_operation (op0);\n+\t      x = plus_constant (gen_lowpart_for_combine (mode, op0), 1);\n \t      goto restart;\n \t    }\n #endif\n \n #if STORE_FLAG_VALUE == -1\n-\t  /* If STORE_FLAG_VALUE is -1, we can convert (ne x 0)\n-\t     to (neg x) if only the low-order bit of X can be nonzero.\n-\t     This converts (ne (zero_extract X 1 Y) 0) to\n-\t     (sign_extract X 1 Y).  */\n+\t  /* If STORE_FLAG_VALUE is -1, we have cases similar to\n+\t     those above.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && op1 == const0_rtx\n-\t      && nonzero_bits (op0, GET_MODE (op0)) == 1)\n+\t      && (num_sign_bit_copies (op0, mode)\n+\t\t  == GET_MODE_BITSIZE (mode)))\n+\t    return gen_lowpart_for_combine (mode,\n+\t\t\t\t\t    expand_compound_operation (op0));\n+\n+\t  else if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && op1 == const0_rtx\n+\t\t   && nonzero_bits (op0, mode) == 1)\n+\t    {\n+\t      op0 = expand_compound_operation (op0);\n+\t      x = gen_unary (NEG, mode, gen_lowpart_for_combine (mode, op0));\n+\t      goto restart;\n+\t    }\n+\n+\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && op1 == const0_rtx\n+\t\t   && (num_sign_bit_copies (op0, mode)\n+\t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      x = gen_rtx_combine (NEG, mode,\n-\t\t\t\t   gen_lowpart_for_combine (mode, op0));\n+\t      x = gen_unary (NOT, mode, gen_lowpart_for_combine (mode, op0));\n+\t      goto restart;\n+\t    }\n+\n+\t  /* If X is 0/1, (eq X 0) is X-1.  */\n+\t  else if (new_code == EQ && GET_MODE_CLASS (mode) == MODE_INT\n+\t\t   && op1 == const0_rtx\n+\t\t   && nonzero_bits (op0, mode) == 1)\n+\t    {\n+\t      op0 = expand_compound_operation (op0);\n+\t      x = plus_constant (gen_lowpart_for_combine (mode, op0), -1);\n \t      goto restart;\n \t    }\n #endif\n@@ -3602,7 +3678,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t  == (HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n-\t      && (i = exact_log2 (nonzero_bits (op0, GET_MODE (op0)))) >= 0)\n+\t      && (i = exact_log2 (nonzero_bits (op0, mode))) >= 0)\n \t    {\n \t      x = simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t\t\texpand_compound_operation (op0),\n@@ -3756,94 +3832,144 @@ subst (x, from, to, in_dest, unique_copy)\n \t    goto restart;\n \t  }\n \n-      /* If we have something like (if_then_else (ne A 0) (OP X C) X),\n-\t A is known to be either 0 or 1, and OP is an identity when its\n-\t second operand is zero, this can be done as (OP X (mult A C)).\n-\t Similarly if A is known to be 0 or -1 and also similarly if we have\n-\t a ZERO_EXTEND or SIGN_EXTEND as long as X is already extended (so\n-\t we don't destroy it).  */\n-\n-      if (mode != VOIDmode\n-\t  && (GET_CODE (XEXP (x, 0)) == EQ || GET_CODE (XEXP (x, 0)) == NE)\n-\t  && XEXP (XEXP (x, 0), 1) == const0_rtx\n-\t  && (nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n-\t      || (num_sign_bit_copies (XEXP (XEXP (x, 0), 0), mode)\n-\t\t  == GET_MODE_BITSIZE (mode))))\n-\t{\n-\t  rtx nz = make_compound_operation (GET_CODE (XEXP (x, 0)) == NE\n-\t\t\t\t\t    ? XEXP (x, 1) : XEXP (x, 2),\n-\t\t\t\t\t    SET);\n-\t  rtx z = GET_CODE (XEXP (x, 0)) == NE ? XEXP (x, 2) : XEXP (x, 1);\n-\t  rtx dir = (nonzero_bits (XEXP (XEXP (x, 0), 0), mode) == 1\n-\t\t     ? const1_rtx : constm1_rtx);\n-\t  rtx c = 0;\n+#if STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1\n+\n+      /* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when\n+\t its second operand is zero, this can be done as (OP Z (mult COND C2))\n+\t where C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer\n+\t ZERO_EXTEND or SIGN_EXTEND as long as Z is already extended (so\n+\t we don't destroy it).  We can do this kind of thing in some\n+\t cases when STORE_FLAG_VALUE is neither of the above, but it isn't\n+\t worth checking for.  */\n+\n+      if (mode != VOIDmode && ! side_effects_p (x))\n+\t{\n+\t  rtx t = make_compound_operation (XEXP (x, 1), SET);\n+\t  rtx f = make_compound_operation (XEXP (x, 2), SET);\n+\t  rtx cond_op0 = XEXP (XEXP (x, 0), 0);\n+\t  rtx cond_op1 = XEXP (XEXP (x, 0), 1);\n+\t  enum rtx_code cond_op = GET_CODE (XEXP (x, 0));\n+\t  enum rtx_code op, extend_op = NIL;\n \t  enum machine_mode m = mode;\n-\t  enum rtx_code op, extend_op = 0;\n-\n-\t  if ((GET_CODE (nz) == PLUS || GET_CODE (nz) == MINUS\n-\t       || GET_CODE (nz) == IOR || GET_CODE (nz) == XOR\n-\t       || GET_CODE (nz) == ASHIFT\n-\t       || GET_CODE (nz) == LSHIFTRT || GET_CODE (nz) == ASHIFTRT)\n-\t      && rtx_equal_p (XEXP (nz, 0), z))\n-\t    c = XEXP (nz, 1), op = GET_CODE (nz);\n-\t  else if (GET_CODE (nz) == SIGN_EXTEND\n-\t\t   && (GET_CODE (XEXP (nz, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (nz, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (nz, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (nz, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (nz, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (nz, 0), 0)) == SUBREG\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (nz, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (nz, 0), 0)), z)\n-\t\t   && (num_sign_bit_copies (z, GET_MODE (z))\n-\t\t       >= (GET_MODE_BITSIZE (mode)\n-\t\t\t   - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (nz, 0), 0))))))\n+\t  rtx z = 0, c1, c2;\n+\n+\t  if ((GET_CODE (t) == PLUS || GET_CODE (t) == MINUS\n+\t       || GET_CODE (t) == IOR || GET_CODE (t) == XOR\n+\t       || GET_CODE (t) == ASHIFT\n+\t       || GET_CODE (t) == LSHIFTRT || GET_CODE (t) == ASHIFTRT)\n+\t      && rtx_equal_p (XEXP (t, 0), f))\n+\t    c1 = XEXP (t, 1), op = GET_CODE (t), z = f;\n+\t  else if (GET_CODE (t) == SIGN_EXTEND\n+\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n+\t\t   && (num_sign_bit_copies (f, GET_MODE (f))\n+\t\t       > (GET_MODE_BITSIZE (mode)\n+\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (t, 0), 0))))))\n+\t    {\n+\t      c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n+\t      extend_op = SIGN_EXTEND;\n+\t      m = GET_MODE (XEXP (t, 0));\n+\t    }\n+\t  else if (GET_CODE (t) == ZERO_EXTEND\n+\t\t   && (GET_CODE (XEXP (t, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (t, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (t, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (t, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (t, 0), 0)) == SUBREG\n+\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n+\t\t   && ((nonzero_bits (f, GET_MODE (f))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n+\t\t       == 0))\n+\t    {\n+\t      c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n+\t      extend_op = ZERO_EXTEND;\n+\t      m = GET_MODE (XEXP (t, 0));\n+\t    }\n+\n+\t  if (reversible_comparison_p (XEXP (x, 0))\n+\t      && (GET_CODE (f) == PLUS || GET_CODE (f) == MINUS\n+\t\t  || GET_CODE (f) == IOR || GET_CODE (f) == XOR\n+\t\t  || GET_CODE (f) == ASHIFT\n+\t\t  || GET_CODE (f) == LSHIFTRT || GET_CODE (f) == ASHIFTRT)\n+\t      && rtx_equal_p (XEXP (f, 0), t))\n+\t    {\n+\t      c1 = XEXP (f, 1), op = GET_CODE (f), z = t;\n+\t      cond_op = reverse_condition (cond_op);\n+\t    }\n+\t  else if (GET_CODE (f) == SIGN_EXTEND\n+\t\t   && (GET_CODE (XEXP (f, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (f, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (f, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (f, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (f, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (f, 0), 0)) == SUBREG\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (f, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (f, 0), 0)), f)\n+\t\t   && (num_sign_bit_copies (t, GET_MODE (t))\n+\t\t       > (GET_MODE_BITSIZE (mode)\n+\t\t\t  - GET_MODE_BITSIZE (GET_MODE (XEXP (XEXP (f, 0), 0))))))\n \t    {\n-\t      c = XEXP (XEXP (nz, 0), 1);\n-\t      op = GET_CODE (XEXP (nz, 0));\n+\t      c1 = XEXP (XEXP (f, 0), 1); z = t; op = GET_CODE (XEXP (f, 0));\n \t      extend_op = SIGN_EXTEND;\n-\t      m = GET_MODE (XEXP (nz, 0));\n+\t      m = GET_MODE (XEXP (f, 0));\n+\t      cond_op = reverse_condition (cond_op);\n \t    }\n-\t  else if (GET_CODE (nz) == ZERO_EXTEND\n-\t\t   && (GET_CODE (XEXP (nz, 0)) == PLUS\n-\t\t       || GET_CODE (XEXP (nz, 0)) == MINUS\n-\t\t       || GET_CODE (XEXP (nz, 0)) == IOR\n-\t\t       || GET_CODE (XEXP (nz, 0)) == XOR\n-\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFT\n-\t\t       || GET_CODE (XEXP (nz, 0)) == LSHIFTRT\n-\t\t       || GET_CODE (XEXP (nz, 0)) == ASHIFTRT)\n-\t\t   && GET_CODE (XEXP (XEXP (nz, 0), 0)) == SUBREG\n+\t  else if (GET_CODE (f) == ZERO_EXTEND\n+\t\t   && (GET_CODE (XEXP (f, 0)) == PLUS\n+\t\t       || GET_CODE (XEXP (f, 0)) == MINUS\n+\t\t       || GET_CODE (XEXP (f, 0)) == IOR\n+\t\t       || GET_CODE (XEXP (f, 0)) == XOR\n+\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFT\n+\t\t       || GET_CODE (XEXP (f, 0)) == LSHIFTRT\n+\t\t       || GET_CODE (XEXP (f, 0)) == ASHIFTRT)\n+\t\t   && GET_CODE (XEXP (XEXP (f, 0), 0)) == SUBREG\n \t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t\t   && subreg_lowpart_p (XEXP (XEXP (nz, 0), 0))\n-\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (nz, 0), 0)), z)\n-\t\t   && ((nonzero_bits (z, GET_MODE (z))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (nz, 0), 0))))\n+\t\t   && subreg_lowpart_p (XEXP (XEXP (f, 0), 0))\n+\t\t   && rtx_equal_p (SUBREG_REG (XEXP (XEXP (f, 0), 0)), t)\n+\t\t   && ((nonzero_bits (t, GET_MODE (t))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (f, 0), 0))))\n \t\t       == 0))\n \t    {\n-\t      c = XEXP (XEXP (nz, 0), 1);\n-\t      op = GET_CODE (XEXP (nz, 0));\n+\t      c1 = XEXP (XEXP (f, 0), 1); z = t; op = GET_CODE (XEXP (f, 0));\n \t      extend_op = ZERO_EXTEND;\n-\t      m = GET_MODE (XEXP (nz, 0));\n+\t      m = GET_MODE (XEXP (f, 0));\n+\t      cond_op = reverse_condition (cond_op);\n \t    }\n \n-\t  if (c && ! side_effects_p (c) && ! side_effects_p (z))\n+\t  if (z)\n \t    {\n-\t      temp\n-\t\t= gen_binary (MULT, m,\n-\t\t\t      gen_lowpart_for_combine (m,\n-\t\t\t\t\t\t       XEXP (XEXP (x, 0), 0)),\n-\t\t\t      gen_binary (MULT, m, c, dir));\n+\t      temp = subst (gen_binary (cond_op, m, cond_op0, cond_op1),\n+\t\t\t    pc_rtx, pc_rtx, 0, 0);\n+\n+\n+\t      temp = gen_binary (MULT, m, temp,\n+\t\t\t\t gen_binary (MULT, m, c1,\n+\t\t\t\t\t     GEN_INT (STORE_FLAG_VALUE)));\n \n \t      temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n \n-\t      if (extend_op != 0)\n+\t      if (extend_op != NIL)\n \t\ttemp = gen_unary (extend_op, mode, temp);\n \n \t      return temp;\n \t    }\n \t}\n+#endif\n \n       /* If we have (if_then_else (ne A 0) C1 0) and either A is known to \n \t be 0 or 1 and C1 is a single bit or A is known to be 0 or -1 and\n@@ -6591,9 +6717,9 @@ nonzero_bits (x, mode)\n }\n \f\n /* Return the number of bits at the high-order end of X that are known to\n-   be equal to the sign bit.  This number will always be between 1 and\n-   the number of bits in the mode of X.  MODE is the mode to be used\n-   if X is VOIDmode.  */\n+   be equal to the sign bit.  X will be used in mode MODE; if MODE is\n+   VOIDmode, X will be used in its own mode.  The returned value  will always\n+   be between 1 and the number of bits in MODE.  */\n \n static int\n num_sign_bit_copies (x, mode)"}]}