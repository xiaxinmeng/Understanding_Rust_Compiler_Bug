{"sha": "78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhjMGFjZmRkMzk1OWQyZTU1NDJjMmFkNjczNDc1NGViM2U2Mzg3YQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-10-02T23:31:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-10-02T23:31:45Z"}, "message": "pa.h (EXTRA_CONSTRAINT): Loosen conditions for match of 'Q' and 'T' while reload is running.\n\n        * pa.h (EXTRA_CONSTRAINT): Loosen conditions for match of\n        'Q' and 'T' while reload is running.\n        * pa/pa.c (hppa_legitimize_address): Rework to generate more\n        indexed and scaled indexed addressing.\n        * pa/pa.md (scaled indexed store): Add define_splits to undo\n        pessimizations created by hppa_legitimize_address for integer\n        stores.\n\nFrom-SVN: r12892", "tree": {"sha": "d1e534ba80df220419ef3524733d2a1b25cb08af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1e534ba80df220419ef3524733d2a1b25cb08af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/comments", "author": null, "committer": null, "parents": [{"sha": "085540da9cdac32931b9d2948dde6857326fd92d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/085540da9cdac32931b9d2948dde6857326fd92d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/085540da9cdac32931b9d2948dde6857326fd92d"}], "stats": {"total": 273, "additions": 213, "deletions": 60}, "files": [{"sha": "046f93a8df2882e3e64b1dd97158a1cf90b864b8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 163, "deletions": 58, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "patch": "@@ -771,11 +771,7 @@ hppa_legitimize_address (x, oldx, mode)\n       return plus_constant (ptr_reg, offset - newoffset);\n     }\n \n-  /* Try to arrange things so that indexing modes can be used, but\n-     only do so if indexing is safe.\n-\n-     Indexing is safe when the second operand for the outer PLUS\n-     is a REG, SUBREG, SYMBOL_REF or the like.  */\n+  /* Handle (plus (mult (a) (shadd_constant)) (b)).  */\n \n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -786,66 +782,145 @@ hppa_legitimize_address (x, oldx, mode)\n     {\n       int val = INTVAL (XEXP (XEXP (x, 0), 1));\n       rtx reg1, reg2;\n-      reg1 = force_reg (Pmode, force_operand (XEXP (x, 1), 0));\n-      reg2 = force_reg (Pmode,\n-\t\t\tforce_operand (XEXP (XEXP (x, 0), 0), 0));\n-      return force_reg (Pmode,\n-\t\t        gen_rtx (PLUS, Pmode,\n-\t\t\t\t gen_rtx (MULT, Pmode, reg2,\n-\t\t\t\t\t  GEN_INT (val)),\n-\t\t\t\t reg1));\n+\n+      reg1 = XEXP (x, 1);\n+      if (GET_CODE (reg1) != REG)\n+\treg1 = force_reg (Pmode, force_operand (reg1, 0));\n+\n+      reg2 = XEXP (XEXP (x, 0), 0);\n+      if (GET_CODE (reg2) != REG)\n+        reg2 = force_reg (Pmode, force_operand (reg2, 0));\n+\n+      if (INTVAL (XEXP (XEXP (x, 0), 1)) != GET_MODE_SIZE (mode))\n+\t{\n+\t  reg2 = force_reg (Pmode, gen_rtx (MULT, Pmode, reg2, GEN_INT (val)));\n+\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode, reg1, reg2));\n+\t}\n+\t\n+      return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\tgen_rtx (MULT, Pmode,\n+\t\t\t\t\t\t reg2, GEN_INT (val)),\n+\t\t\t\t\treg1));\n     }\n \n   /* Similarly for (plus (plus (mult (a) (shadd_constant)) (b)) (c)).\n \n      Only do so for floating point modes since this is more speculative\n      and we lose if it's an integer store.  */\n-  if ((mode == DFmode || mode == SFmode)\n-      && GET_CODE (x) == PLUS\n+  if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n       && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n-      && shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))))\n+      && shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n+      && (mode == SFmode || mode == DFmode))\n     {\n-      rtx regx1, regx2;\n-\n-      /* Add the two unscaled terms B and C; if either B or C isn't\n-\t a register or small constant int, then fail.  */\n-      regx1 = XEXP (XEXP (x, 0), 1);\n-      if (! (GET_CODE (regx1) == REG\n-\t     || (GET_CODE (regx1) == CONST_INT\n-\t\t && INT_14_BITS (regx1))))\n-\treturn orig;\n-      \n-      regx2 = XEXP (x, 1);\n-      if (! (GET_CODE (regx2) == REG\n-\t     || (GET_CODE (regx2) == CONST_INT\n-\t\t && INT_14_BITS (regx2))))\n+\n+      /* First, try and figure out what to use as a base register.  */\n+      rtx reg1, reg2, base, idx, orig_base;\n+\n+      reg1 = XEXP (XEXP (x, 0), 1);\n+      reg2 = XEXP (x, 1);\n+      base = NULL_RTX;\n+      idx = NULL_RTX;\n+\n+      /* Make sure they're both regs.  If one was a SYMBOL_REF [+ const],\n+\t then emit_move_sequence will turn on REGNO_POINTER_FLAG so we'll\n+\t know it's a base register below.  */\n+      if (GET_CODE (reg1) != REG)\n+\treg1 = force_reg (Pmode, force_operand (reg1, 0));\n+\n+      if (GET_CODE (reg2) != REG)\n+\treg2 = force_reg (Pmode, force_operand (reg2, 0));\n+\n+      /* Figure out what the base and index are.  */\n+\t \n+      if (GET_CODE (reg1) == REG\n+\t  && REGNO_POINTER_FLAG (REGNO (reg1)))\n+\t{\n+\t  base = reg1;\n+\t  orig_base = XEXP (XEXP (x, 0), 1);\n+\t  idx = gen_rtx (PLUS, Pmode,\n+\t\t\t gen_rtx (MULT, Pmode,\n+\t\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 0),\n+\t\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 1)),\n+\t\t\t XEXP (x, 1));\n+\t}\n+      else if (GET_CODE (reg2) == REG\n+\t       && REGNO_POINTER_FLAG (REGNO (reg2)))\n+\t{\n+\t  base = reg2;\n+\t  orig_base = XEXP (x, 1);\n+\t  idx = XEXP (x, 0);\n+\t}\n+\n+      if (base == 0)\n \treturn orig;\n+\n+      /* If the index adds a large constant, try to scale the\n+\t constant so that it can be loaded with only one insn.  */\n+      if (GET_CODE (XEXP (idx, 1)) == CONST_INT\n+\t  && VAL_14_BITS_P (INTVAL (XEXP (idx, 1))\n+\t\t\t    / INTVAL (XEXP (XEXP (idx, 0), 1)))\n+\t  && INTVAL (XEXP (idx, 1)) % INTVAL (XEXP (XEXP (idx, 0), 1)) == 0)\n+\t{\n+\t  /* Divide the CONST_INT by the scale factor, then add it to A.  */\n+\t  int val = INTVAL (XEXP (idx, 1));\n+\n+\t  val /= INTVAL (XEXP (XEXP (idx, 0), 1));\n+\t  reg1 = XEXP (XEXP (idx, 0), 0);\n+\t  if (GET_CODE (reg1) != REG)\n+\t    reg1 = force_reg (Pmode, force_operand (reg1, 0));\n+\n+\t  reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, reg1, GEN_INT (val)));\n+\n+\t  /* We can now generate a simple scaled indexed address.  */\n+\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t    gen_rtx (MULT, Pmode, reg1,\n+\t\t\t\t\t\t     XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t\t    base));\n+\t}\n+\n+      /* If B + C is still a valid base register, then add them.  */\n+      if (GET_CODE (XEXP (idx, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (idx, 1)) <= 4096\n+\t  && INTVAL (XEXP (idx, 1)) >= -4096)\n+\t{\n+\t  int val = INTVAL (XEXP (XEXP (idx, 0), 1));\n+\t  rtx reg1, reg2;\n+\n+\t  reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, base, XEXP (idx, 1)));\n+\n+\t  reg2 = XEXP (XEXP (idx, 0), 0);\n+\t  if (GET_CODE (reg2) != CONST_INT)\n+\t    reg2 = force_reg (Pmode, force_operand (reg2, 0));\n+\n+\t  return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t    gen_rtx (MULT, Pmode,\n+\t\t\t\t\t\t     reg2, GEN_INT (val)),\n+\t\t\t\t\t    reg1));\n+\t}\n+\n+      /* Get the index into a register, then add the base + index and\n+\t return a register holding the result.  */\n+\n+      /* First get A into a register.  */\n+      reg1 = XEXP (XEXP (idx, 0), 0);\n+      if (GET_CODE (reg1) != REG)\n+\treg1 = force_reg (Pmode, force_operand (reg1, 0));\n+\n+      /* And get B into a register.  */\n+      reg2 = XEXP (idx, 1);\n+      if (GET_CODE (reg2) != REG)\n+\treg2 = force_reg (Pmode, force_operand (reg2, 0));\n+\n+      reg1 = force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\tgen_rtx (MULT, Pmode, reg1,\n+\t\t\t\t\t\t XEXP (XEXP (idx, 0), 1)),\n+\t\t\t\t\treg2));\n+\n+      /* Add the result to our base register and return.  */\n+      return force_reg (Pmode, gen_rtx (PLUS, Pmode, base, reg1));\n       \n-      /* Add them, make sure the result is in canonical form.  */\n-      if (GET_CODE (regx1) == REG)\n-\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regx2));\n-      else if (GET_CODE (regx2) == REG)\n-\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode, regx2, regx1));\n-      else\n-\tregx1 = force_reg (Pmode, gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t   force_reg (Pmode, regx1),\n-\t\t\t\t\t   regx2));\n-\n-      /* Get the term to scale in a register.  */\n-      regx2 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n-      if (GET_CODE (regx2) != REG)\n-\tregx2 = force_reg (Pmode, force_operand (regx2, 0));\n-\n-      /* And make an indexed address.  */\n-      regx2 = gen_rtx (PLUS, Pmode,\n-\t\t       gen_rtx (MULT, Pmode, regx2,\n-\t\t\t\tXEXP (XEXP (XEXP (x, 0), 0), 1)),\n-\t\t\tregx1);\n-\n-      /* Return it.  */\n-      return force_reg (Pmode, regx2);\n     }\n \n   /* Uh-oh.  We might have an address for x[n-100000].  This needs\n@@ -879,12 +954,42 @@ hppa_legitimize_address (x, oldx, mode)\n \t\t(plus (mult (reg) (shadd_const))\n \t\t      (const (plus (symbol_ref) (const_int))))\n \n-\t     Where const_int can be divided evenly by shadd_const and\n-\t     added to (reg).  This allows more scaled indexed addresses.  */\n-\t  if ((mode == DFmode || mode == SFmode)\n-\t      && GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n+\t     Where const_int is small.  In that case the const\n+\t     expression is a valid pointer for indexing. \n+\n+\t     If const_int is big, but can be divided evenly by shadd_const\n+\t     and added to (reg).  This allows more scaled indexed addresses.  */\n+\t  if (GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n+\t      && GET_CODE (XEXP (x, 0)) == MULT\n \t      && GET_CODE (XEXP (y, 1)) == CONST_INT\n-\t      && INTVAL (XEXP (y, 1)) % INTVAL (XEXP (XEXP (x, 0), 1)) == 0)\n+\t      && INTVAL (XEXP (y, 1)) >= -4096\n+\t      && INTVAL (XEXP (y, 1)) <= 4095\n+\t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+\t    {\n+\t      int val = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t      rtx reg1, reg2;\n+\n+\t      reg1 = XEXP (x, 1);\n+\t      if (GET_CODE (reg1) != REG)\n+\t\treg1 = force_reg (Pmode, force_operand (reg1, 0));\n+\n+\t      reg2 = XEXP (XEXP (x, 0), 0);\n+\t      if (GET_CODE (reg2) != REG)\n+\t        reg2 = force_reg (Pmode, force_operand (reg2, 0));\n+\n+\t      return force_reg (Pmode, gen_rtx (PLUS, Pmode,\n+\t\t\t\t\t\tgen_rtx (MULT, Pmode,\n+\t\t\t\t\t\t\t reg2, GEN_INT (val)),\n+\t\t\t\t\t\treg1));\n+\t    }\n+\t  else if ((mode == DFmode || mode == SFmode)\n+\t\t   && GET_CODE (XEXP (y, 0)) == SYMBOL_REF\n+\t\t   && GET_CODE (XEXP (x, 0)) == MULT\n+\t\t   && GET_CODE (XEXP (y, 1)) == CONST_INT\n+\t\t   && INTVAL (XEXP (y, 1)) % INTVAL (XEXP (XEXP (x, 0), 1)) == 0\n+\t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t\t   && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n \t    {\n \t      regx1\n \t\t= force_reg (Pmode, GEN_INT (INTVAL (XEXP (y, 1))"}, {"sha": "f69102549277a320fbf31ba0e2c2e4fbd166b37a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "patch": "@@ -1405,7 +1405,8 @@ extern struct rtx_def *hppa_builtin_saveregs ();\n   ((C) == 'Q' ?\t\t\t\t\t\t\\\n    (IS_RELOADING_PSEUDO_P (OP)\t\t\t\t\\\n     || (GET_CODE (OP) == MEM\t\t\t\t\\\n-\t&& memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n+\t&& (memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n+\t    || reload_in_progress)\t\t\t\\\n \t&& ! symbolic_memory_operand (OP, VOIDmode)\t\\\n         && !(GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n \t     && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\\\n@@ -1416,7 +1417,8 @@ extern struct rtx_def *hppa_builtin_saveregs ();\n       && (GET_CODE (XEXP (XEXP (OP, 0), 0)) == MULT\t\\\n \t  || GET_CODE (XEXP (XEXP (OP, 0), 1)) == MULT)\t\\\n       && (move_operand (OP, GET_MODE (OP))\t\t\\\n-\t  || memory_address_p (GET_MODE (OP), XEXP (OP, 0))))\\\n+\t  || memory_address_p (GET_MODE (OP), XEXP (OP, 0))\\\n+\t  || reload_in_progress))\t\t\t\\\n    : ((C) == 'T' ? \t\t\t\t\t\\\n       (GET_CODE (OP) == MEM\t\t\t\t\\\n        /* Using DFmode forces only short displacements\t\\"}, {"sha": "d881956490cb23dc92e096da1d040e8dff270a92", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78c0acfdd3959d2e5542c2ad6734754eb3e6387a/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=78c0acfdd3959d2e5542c2ad6734754eb3e6387a", "patch": "@@ -1664,6 +1664,52 @@\n    (set (match_dup 0) (lo_sum:SI (match_dup 2) (match_dup 1)))]\n   \"\")\n \n+;; hppa_legitimize_address goes to a great deal of trouble to\n+;; create addresses which use indexing.  In some cases, this\n+;; is a lose because there isn't any store instructions which\n+;; allow indexed addresses (with integer register source).\n+;;\n+;; These define_splits try to turn a 3 insn store into\n+;; a 2 insn store with some creative RTL rewriting.\n+(define_split\n+  [(set (mem:SI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SI 1 \"shadd_operand\" \"\"))\n+\t\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 3 \"const_int_operand\" \"\"))))\n+\t(match_operand:SI 4 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"\"))]\n+  \"\"\n+  [(set (match_dup 5) (plus:SI (mult:SI (match_dup 0) (match_dup 1))\n+\t\t\t       (match_dup 2)))\n+   (set (mem:SI (plus:SI (match_dup 5) (match_dup 3))) (match_dup 4))]\n+  \"\")\n+\n+(define_split\n+  [(set (mem:HI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SI 1 \"shadd_operand\" \"\"))\n+\t\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 3 \"const_int_operand\" \"\"))))\n+\t(match_operand:HI 4 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"\"))]\n+  \"\"\n+  [(set (match_dup 5) (plus:SI (mult:SI (match_dup 0) (match_dup 1))\n+\t\t\t       (match_dup 2)))\n+   (set (mem:HI (plus:SI (match_dup 5) (match_dup 3))) (match_dup 4))]\n+  \"\")\n+\n+(define_split\n+  [(set (mem:QI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SI 1 \"shadd_operand\" \"\"))\n+\t\t   (plus:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:SI 3 \"const_int_operand\" \"\"))))\n+\t(match_operand:QI 4 \"register_operand\" \"\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"\"))]\n+  \"\"\n+  [(set (match_dup 5) (plus:SI (mult:SI (match_dup 0) (match_dup 1))\n+\t\t\t       (match_dup 2)))\n+   (set (mem:QI (plus:SI (match_dup 5) (match_dup 3))) (match_dup 4))]\n+  \"\")\n+\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]"}]}