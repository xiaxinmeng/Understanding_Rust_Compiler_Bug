{"sha": "3791773c9395246e5fb860a20bb3dddd8e5edeb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc5MTc3M2M5Mzk1MjQ2ZTVmYjg2MGEyMGJiM2RkZGQ4ZTVlZGViNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-04-17T02:15:32Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-04-17T02:15:32Z"}, "message": "Port to sparc 32 and 64 Linux.\n\nFrom-SVN: r33196", "tree": {"sha": "5eee77be9c61a0f60260a8f47e6085ac5e0738a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eee77be9c61a0f60260a8f47e6085ac5e0738a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3791773c9395246e5fb860a20bb3dddd8e5edeb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3791773c9395246e5fb860a20bb3dddd8e5edeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3791773c9395246e5fb860a20bb3dddd8e5edeb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3791773c9395246e5fb860a20bb3dddd8e5edeb6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11033ba5226589d2e7a7055cda6ddf0379f7cad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11033ba5226589d2e7a7055cda6ddf0379f7cad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11033ba5226589d2e7a7055cda6ddf0379f7cad1"}], "stats": {"total": 535, "additions": 476, "deletions": 59}, "files": [{"sha": "037726e1144977a416f4f02b958343f65f684761", "filename": "libffi/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -1,3 +1,38 @@\n+2000-04-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+        * include/ffi.h.in (SPARC64): Define for 64bit SPARC builds.\n+\tSet SPARC FFI_DEFAULT_ABI based on SPARC64 define.\n+\t* src/sparc/ffi.c (ffi_prep_args_v8): Renamed from ffi_prep_args.\n+\tReplace all void * sizeofs with sizeof(int).\n+\tOnly compare type with FFI_TYPE_LONGDOUBLE if LONGDOUBLE is\n+\tdifferent than DOUBLE.\n+\tRemove FFI_TYPE_SINT32 and FFI_TYPE_UINT32 cases (handled elsewhere).\n+\t(ffi_prep_args_v9): New function.\n+\t(ffi_prep_cif_machdep): Handle V9 ABI and long long on V8.\n+\t(ffi_V9_return_struct): New function.\n+\t(ffi_call): Handle FFI_V9 ABI from 64bit code and FFI_V8 ABI from\n+\t32bit code (not yet cross-arch calls).\n+\t* src/sparc/v8.S: Add struct return delay nop.\n+\tHandle long long.\n+\t* src/sparc/v9.S: New file.\n+\t* src/prep_cif.c (ffi_prep_cif): Return structure pointer\n+\tis used on sparc64 only for structures larger than 32 bytes.\n+\tPass by reference for structures is done for structure arguments\n+\tlarger than 16 bytes.\n+\t* src/ffitest.c (main): Use 64bit rint on sparc64.\n+\tRun long long tests on sparc.\n+\t* src/types.c (FFI_TYPE_POINTER): Pointer is 64bit on alpha and\n+\tsparc64.\n+\t(FFI_TYPE_LONGDOUBLE): long double is 128 bit aligned to 128 bits\n+\ton sparc64.\n+\t* configure.in (sparc-*-linux*): New supported target.\n+\t(sparc64-*-linux*): Likewise.\n+\t* configure: Rebuilt.\n+\t* Makefile.am: Add v9.S to SPARC files.\n+\t* Makefile.in: Likewise.\n+\t(LINK): Surround $(CCLD) into double quotes, so that multilib\n+\tcompiles work correctly.\n+\n 2000-04-04  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* configure: Rebuilt."}, {"sha": "8f51eb34d898c47529378f6e5c268b7b9ddd9832", "filename": "libffi/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -4,7 +4,7 @@ AUTOMAKE_OPTIONS = cygnus\n \n EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/mips/n32.s src/mips/o32.S src/mips/o32.s \\\n-\t\tsrc/sparc/ffi.c src/sparc/v8.S \\\n+\t\tsrc/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n@@ -40,7 +40,7 @@ ffitest_LDADD = libffi.la\n TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s\n TARGET_SRC_X86 = src/x86/ffi.c src/x86/sysv.S\n-TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S\n+TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S\n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S"}, {"sha": "078daf4d058a5f448b8dd2e525ec149592eee5f4", "filename": "libffi/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -84,7 +84,7 @@ AUTOMAKE_OPTIONS = cygnus\n \n EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/mips/n32.s src/mips/o32.S src/mips/o32.s \\\n-\t\tsrc/sparc/ffi.c src/sparc/v8.S \\\n+\t\tsrc/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S \\\n \t\tsrc/x86/ffi.c src/x86/sysv.S \\\n \t\tsrc/alpha/ffi.c src/alpha/osf.S \\\n \t\tsrc/m68k/ffi.c src/m68k/sysv.S \\\n@@ -115,7 +115,7 @@ ffitest_LDADD = libffi.la\n TARGET_SRC_MIPS_GCC = src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n TARGET_SRC_MIPS_SGI = src/mips/ffi.c src/mips/o32.s src/mips/n32.s\n TARGET_SRC_X86 = src/x86/ffi.c src/x86/sysv.S\n-TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S\n+TARGET_SRC_SPARC = src/sparc/ffi.c src/sparc/v8.S src/sparc/v9.S \n TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n@@ -164,7 +164,7 @@ libffi_la_LIBADD =\n @POWERPC_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n @POWERPC_TRUE@raw_api.lo java_raw_api.lo ffi.lo sysv.lo\n @SPARC_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n-@SPARC_TRUE@raw_api.lo java_raw_api.lo ffi.lo v8.lo\n+@SPARC_TRUE@raw_api.lo java_raw_api.lo ffi.lo v8.lo v9.lo\n @X86_TRUE@am_libffi_la_OBJECTS =  debug.lo prep_cif.lo types.lo \\\n @X86_TRUE@raw_api.lo java_raw_api.lo ffi.lo sysv.lo\n libffi_la_OBJECTS =  $(am_libffi_la_OBJECTS)\n@@ -179,7 +179,7 @@ COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CF\n LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CFLAGS = @CFLAGS@\n CCLD = $(CC)\n-LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n+LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\n DIST_SOURCES =  $(libffi_la_SOURCES) $(ffitest_SOURCES)\n DIST_COMMON =  README ./stamp-h.in ChangeLog Makefile.am Makefile.in \\\n acconfig.h aclocal.m4 config.guess config.sub configure configure.in \\\n@@ -299,6 +299,7 @@ sysv.lo: src/arm/sysv.S\n o32.lo: src/mips/o32.S\n n32.lo: src/mips/n32.S\n v8.lo: src/sparc/v8.S\n+v9.lo: src/sparc/v9.S\n \n libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES)\n \t$(LINK) -rpath $(toolexeclibdir) $(libffi_la_LDFLAGS) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)"}, {"sha": "d876117f90f27e5f7ef30dfc37c10c664d918885", "filename": "libffi/configure", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -1630,6 +1630,8 @@ i*86-*-solaris*) TARGET=X86; TARGETDIR=x86;;\n i*86-*-beos*) TARGET=X86; TARGETDIR=x86;;\n sparc-sun-4*) TARGET=SPARC; TARGETDIR=sparc;;\n sparc-sun-*) TARGET=SPARC; TARGETDIR=sparc;;\n+sparc-*-linux*) TARGET=SPARC; TARGETDIR=sparc;;\n+sparc64-*-linux*) TARGET=SPARC; TARGETDIR=sparc;;\n alpha*-*-linux* | alpha*-*-osf*) TARGET=ALPHA; TARGETDIR=alpha;;\n ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;"}, {"sha": "38d8473852ce87b163e17e56b8b4ee4ca49a9ff2", "filename": "libffi/configure.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -50,6 +50,8 @@ i*86-*-solaris*) TARGET=X86; TARGETDIR=x86;;\n i*86-*-beos*) TARGET=X86; TARGETDIR=x86;;\n sparc-sun-4*) TARGET=SPARC; TARGETDIR=sparc;;\n sparc-sun-*) TARGET=SPARC; TARGETDIR=sparc;;\n+sparc-*-linux*) TARGET=SPARC; TARGETDIR=sparc;;\n+sparc64-*-linux*) TARGET=SPARC; TARGETDIR=sparc;;\n alpha*-*-linux* | alpha*-*-osf*) TARGET=ALPHA; TARGETDIR=alpha;;\n ia64*-*-*) TARGET=IA64; TARGETDIR=ia64;;\n m68k-*-linux*) TARGET=M68K; TARGETDIR=m68k;;"}, {"sha": "6be7e23c727ec0c1c5bef26c1caf4ad749779d25", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n    libffi @VERSION@ - Copyright (c) 1996-1999  Cygnus Solutions\n \n-   $Id: ffi.h.in,v 1.3 1999/09/01 23:16:34 tromey Exp $\n+   $Id: ffi.h.in,v 1.4 2000/02/25 19:13:44 tromey Exp $\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -160,6 +160,12 @@ extern \"C\" {\n #define SIZEOF_ARG SIZEOF_VOID_P\n #endif\n \n+#ifdef SPARC\n+#if defined(__arch64__) || defined(__sparcv9)\n+#define SPARC64\n+#endif\n+#endif\n+\n #ifndef LIBFFI_ASM\n \n /* ---- Generic type definitions ----------------------------------------- */\n@@ -176,9 +182,13 @@ typedef enum ffi_abi {\n   /* ---- Sparc -------------------- */\n #ifdef SPARC\n   FFI_V8,\n-  FFI_DEFAULT_ABI = FFI_V8,\n   FFI_V8PLUS,\n   FFI_V9,\n+#ifdef SPARC64\n+  FFI_DEFAULT_ABI = FFI_V9,\n+#else\n+  FFI_DEFAULT_ABI = FFI_V8,\n+#endif\n #endif\n \n   /* ---- Intel x86 ---------------- */"}, {"sha": "d4a687c6d53ca9d873ba1f6c154b50915f435f1d", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -224,7 +224,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n   signed int si1;\n   signed int si2;\n \n-#if defined(ALPHA) || defined(IA64) || (defined(MIPS) && (_MIPS_SIM == _ABIN32))\n+#if defined(ALPHA) || defined(IA64) || defined(SPARC64) || (defined(MIPS) && (_MIPS_SIM == _ABIN32))\n   long long rint;\n #else\n   int rint;\n@@ -295,7 +295,7 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n \n   /* return value tests */\n   {\n-#if defined(MIPS) || defined(SPARC) /* || defined(ARM) */\n+#if defined(MIPS) /* || defined(ARM) */\n     puts (\"long long tests not run. This is a known bug on this architecture.\");\n #else\n     args[0] = &ffi_type_sint64;"}, {"sha": "3f21411a6cb22ff42f00b687a066e52ce2f40a24", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -107,7 +107,11 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n \n #ifndef M68K\n   /* Make space for the return structure pointer */\n-  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+#ifdef SPARC\n+      && (cif->abi != FFI_V9 || cif->rtype->size > 32)\n+#endif\n+      )\n     bytes = STACK_ARG_SIZE(sizeof(void*));\n #endif\n \n@@ -121,8 +125,10 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n \treturn FFI_BAD_TYPEDEF;\n \n #ifdef SPARC\n-      if ((*ptr)->type == FFI_TYPE_STRUCT\n-\t  || (*ptr)->type == FFI_TYPE_LONGDOUBLE)\n+      if (((*ptr)->type == FFI_TYPE_STRUCT\n+\t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))\n+\t  || ((*ptr)->type == FFI_TYPE_LONGDOUBLE\n+\t      && cif->abi != FFI_V9))\n \tbytes += sizeof(void*);\n       else\n #endif\n@@ -140,4 +146,3 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n   /* Perform machine dependent cif processing */\n   return ffi_prep_cif_machdep(cif);\n }\n-"}, {"sha": "647063686b9e8f409e2b6c67b50cc76e4453500e", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 252, "deletions": 44, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -33,7 +33,7 @@\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-void ffi_prep_args(char *stack, extended_cif *ecif)\n+void ffi_prep_args_v8(char *stack, extended_cif *ecif)\n {\n   int i;\n   int tmp;\n@@ -45,16 +45,16 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n   tmp = 0;\n \n   /* Skip 16 words for the window save area */\n-  argp = stack + 16*sizeof(void*);\n+  argp = stack + 16*sizeof(int);\n \n   /* This should only really be done when we are returning a structure,\n      however, it's faster just to do it all the time...\n \n   if ( ecif->cif->rtype->type == FFI_TYPE_STRUCT ) */\n-  *(void **) argp = ecif->rvalue;\n+  *(int *) argp = (long)ecif->rvalue;\n \n   /* And 1 word for the  structure return value. */\n-  argp += sizeof(void*);\n+  argp += sizeof(int);\n \n #ifdef USING_PURIFY\n   /* Purify will probably complain in our assembly routine, unless we\n@@ -81,10 +81,13 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t{\n \t  avn--;\n \t  if ((*p_arg)->type == FFI_TYPE_STRUCT\n-\t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE)\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t      || (*p_arg)->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+\t      )\n \t    {\n-\t      *(unsigned int *) argp = (unsigned int)(* p_argv);\n-\t      z = sizeof(void*);\n+\t      *(unsigned int *) argp = (unsigned long)(* p_argv);\n+\t      z = sizeof(int);\n \t    }\n \t  else\n \t    {\n@@ -109,15 +112,7 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \t\t    case FFI_TYPE_UINT16:\n \t\t      *(unsigned int *) argp = *(UINT16 *)(* p_argv);\n \t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_SINT32:\n-\t\t      *(signed int *) argp = *(SINT32 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n-\t\t    case FFI_TYPE_UINT32:\n-\t\t      *(unsigned int *) argp = *(UINT32 *)(* p_argv);\n-\t\t      break;\n-\t\t      \n+\n \t\t    default:\n \t\t      FFI_ASSERT(0);\n \t\t    }\n@@ -135,82 +130,295 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n   return;\n }\n \n+int ffi_prep_args_v9(char *stack, extended_cif *ecif)\n+{\n+  int i, ret = 0;\n+  int tmp;\n+  void **p_argv;\n+  char *argp;\n+  ffi_type **p_arg;\n+\n+  tmp = 0;\n+\n+  /* Skip 16 words for the window save area */\n+  argp = stack + 16*sizeof(long long);\n+\n+#ifdef USING_PURIFY\n+  /* Purify will probably complain in our assembly routine, unless we\n+     zero out this memory. */\n+\n+  ((long long*)argp)[0] = 0;\n+  ((long long*)argp)[1] = 0;\n+  ((long long*)argp)[2] = 0;\n+  ((long long*)argp)[3] = 0;\n+  ((long long*)argp)[4] = 0;\n+  ((long long*)argp)[5] = 0;\n+#endif\n+\n+  p_argv = ecif->avalue;\n+\n+  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT &&\n+      ecif->cif->rtype->size > 32)\n+    {\n+      *(unsigned long long *) argp = (unsigned long)ecif->rvalue;\n+      tmp = 1;\n+    }\n+\n+  for (i = 0, p_arg = ecif->cif->arg_types; i < ecif->cif->nargs;\n+       i++, p_arg++)\n+    {\n+      size_t z;\n+\n+      z = (*p_arg)->size;\n+      switch ((*p_arg)->type)\n+\t{\n+\tcase FFI_TYPE_STRUCT:\n+\t  if (z > 16)\n+\t    {\n+\t      /* For structures larger than 16 bytes we pass reference.  */\n+\t      *(unsigned long long *) argp = (unsigned long)* p_argv;\n+\t      argp += sizeof(long long);\n+\t      tmp++;\n+\t      p_argv++;\n+\t      continue;\n+\t    }\n+\t  /* FALLTHROUGH */\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t  ret = 1; /* We should promote into FP regs as well as integer.  */\n+\t  break;\n+\t}\n+      if (z < sizeof(long long))\n+\t{\n+\t  switch ((*p_arg)->type)\n+\t    {\n+\t    case FFI_TYPE_SINT8:\n+\t      *(signed long long *) argp = *(SINT8 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT8:\n+\t      *(unsigned long long *) argp = *(UINT8 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_SINT16:\n+\t      *(signed long long *) argp = *(SINT16 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT16:\n+\t      *(unsigned long long *) argp = *(UINT16 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_SINT32:\n+\t      *(signed long long *) argp = *(SINT32 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT32:\n+\t      *(unsigned long long *) argp = *(UINT32 *)(* p_argv);\n+\t      break;\n+\n+\t    case FFI_TYPE_FLOAT:\n+\t      *(float *) (argp + 4) = *(FLOAT32 *)(* p_argv); /* Right justify */\n+\t      break;\n+\n+\t    case FFI_TYPE_STRUCT:\n+\t      memcpy(argp, *p_argv, z);\n+\t      break;\n+\n+\t    default:\n+\t      FFI_ASSERT(0);\n+\t    }\n+\t  z = sizeof(long long);\n+\t  tmp++;\n+\t}\n+      else if (z == sizeof(long long))\n+\t{\n+\t  memcpy(argp, *p_argv, z);\n+\t  z = sizeof(long long);\n+\t  tmp++;\n+\t}\n+      else\n+\t{\n+\t  if ((tmp & 1) && (*p_arg)->alignment > 8)\n+\t    {\n+\t      tmp++;\n+\t      argp += sizeof(long long);\n+\t    }\n+\t  memcpy(argp, *p_argv, z);\n+\t  z = 2 * sizeof(long long);\n+\t  tmp += 2;\n+\t}\n+      p_argv++;\n+      argp += z;\n+    }\n+\n+  return ret;\n+}\n+\n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n-  /* If we are returning a struct, this will already have been added.\n-     Otherwise we need to add it because it's always got to be there! */\n+  int wordsize;\n+\n+  if (cif->abi != FFI_V9)\n+    {\n+      wordsize = 4;\n \n-  if (cif->rtype->type != FFI_TYPE_STRUCT)\n-    cif->bytes += sizeof(void*);\n+      /* If we are returning a struct, this will already have been added.\n+\t Otherwise we need to add it because it's always got to be there! */\n \n-  /* sparc call frames require that space is allocated for 6 args,\n-     even if they aren't used. Make that space if necessary. */\n+      if (cif->rtype->type != FFI_TYPE_STRUCT)\n+\tcif->bytes += wordsize;\n+\n+      /* sparc call frames require that space is allocated for 6 args,\n+\t even if they aren't used. Make that space if necessary. */\n   \n-  if (cif->bytes < 4*6+4)\n-    cif->bytes = 4*6+4;\n+      if (cif->bytes < 4*6+4)\n+\tcif->bytes = 4*6+4;\n+    }\n+  else\n+    {\n+      wordsize = 8;\n+\n+      /* sparc call frames require that space is allocated for 6 args,\n+\t even if they aren't used. Make that space if necessary. */\n+  \n+      if (cif->bytes < 8*6)\n+\tcif->bytes = 8*6;\n+    }\n \n   /* Adjust cif->bytes. to include 16 words for the window save area,\n      and maybe the struct/union return pointer area, */\n \n-  cif->bytes += 64;\n+  cif->bytes += 16 * wordsize;\n \n-  /* The stack must be double word aligned, so round bytes up\n+  /* The stack must be 2 word aligned, so round bytes up\n      appropriately. */\n \n-  cif->bytes = ALIGN(cif->bytes, 2*sizeof(void*));\n+  cif->bytes = ALIGN(cif->bytes, 2 * wordsize);\n \n   /* Set the return type flag */\n   switch (cif->rtype->type)\n     {\n     case FFI_TYPE_VOID:\n-    case FFI_TYPE_STRUCT:\n-      cif->flags = cif->rtype->type;\n-      break;\n-\n     case FFI_TYPE_FLOAT:\n-      cif->flags = FFI_TYPE_FLOAT;\n+    case FFI_TYPE_DOUBLE:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+#endif\n+      cif->flags = cif->rtype->type;\n       break;\n \n-    case FFI_TYPE_DOUBLE:\n-      cif->flags = FFI_TYPE_DOUBLE;\n+    case FFI_TYPE_STRUCT:\n+      if (cif->abi == FFI_V9 && cif->rtype->size > 32)\n+\tcif->flags = FFI_TYPE_VOID;\n+      else\n+\tcif->flags = FFI_TYPE_STRUCT;\n       break;\n \n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      if (cif->abi != FFI_V9)\n+\t{\n+\t  cif->flags = FFI_TYPE_SINT64;\n+\t  break;\n+\t}\n+      /* FALLTHROUGH */\n     default:\n       cif->flags = FFI_TYPE_INT;\n       break;\n     }\n-\n   return FFI_OK;\n }\n \n+int ffi_V9_return_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n+{\n+  ffi_type **ptr = &arg->elements[0];\n+\n+  while (*ptr != NULL)\n+    {\n+      if (off & ((*ptr)->alignment - 1))\n+\toff = ALIGN(off, (*ptr)->alignment);\n+\n+      switch ((*ptr)->type)\n+\t{\n+\tcase FFI_TYPE_STRUCT:\n+\t  off = ffi_V9_return_struct(*ptr, off, ret, intg, flt);\n+\t  break;\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcase FFI_TYPE_LONGDOUBLE:\n+#endif\n+\t  memcpy(ret + off, flt + off, (*ptr)->size);\n+\t  off += (*ptr)->size;\n+\t  break;\n+\tdefault:\n+\t  memcpy(ret + off, intg + off, (*ptr)->size);\n+\t  off += (*ptr)->size;\n+\t  break;\n+\t}\n+      ptr++;\n+    }\n+  return off;\n+}\n+\n extern int ffi_call_V8(void *, extended_cif *, unsigned, \n \t\t       unsigned, unsigned *, void (*fn)());\n+extern int ffi_call_V9(void *, extended_cif *, unsigned, \n+\t\t       unsigned, unsigned *, void (*fn)());\n \n void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n+  void *rval = rvalue;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n-  \n+\n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n-  \n-  if ((rvalue == NULL) && \n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n-    ecif.rvalue = alloca(cif->rtype->size);\n-  else\n-    ecif.rvalue = rvalue;\n-    \n+\n+  ecif.rvalue = rvalue;\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      if (cif->rtype->size <= 32)\n+\trval = alloca(64);\n+      else\n+\t{\n+\t  rval = NULL;\n+\t  if (rvalue == NULL)\n+\t    ecif.rvalue = alloca(cif->rtype->size);\n+\t}\n+    }\n+\n   switch (cif->abi) \n     {\n     case FFI_V8:\n-      ffi_call_V8(ffi_prep_args, &ecif, cif->bytes, \n+#ifdef SPARC64\n+      /* We don't yet support calling 32bit code from 64bit */\n+      FFI_ASSERT(0);\n+#else\n+      ffi_call_V8(ffi_prep_args_v8, &ecif, cif->bytes, \n \t\t  cif->flags, rvalue, fn);\n+#endif\n+      break;\n+    case FFI_V9:\n+#ifdef SPARC64\n+      ffi_call_V9(ffi_prep_args_v9, &ecif, cif->bytes,\n+\t\t  cif->flags, rval, fn);\n+      if (rvalue && rval && cif->rtype->type == FFI_TYPE_STRUCT)\n+\tffi_V9_return_struct(cif->rtype, 0, (char *)rvalue, (char *)rval, ((char *)rval)+32);\n+#else\n+      /* And vice versa */\n+      FFI_ASSERT(0);\n+#endif\n       break;\n     default:\n       FFI_ASSERT(0);\n       break;\n     }\n+\n }"}, {"sha": "e4b2ba96a6cc92a26dbc3ece03de7ee8c6fb58a5", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -56,6 +56,7 @@ _ffi_call_V8:\n \tld\t[%l0+ARGS+20], %o5\n \tcall\t%i5\n \tmov\t%l0, %sp\t! (delay) switch to frame\n+\tnop\t\t\t! STRUCT returning functions skip 12 instead of 8 bytes\n \n \t! If the return value pointer is NULL, assume no return value.\n \ttst\t%i4\n@@ -70,6 +71,9 @@ _ffi_call_V8:\n \tbe,a\tdone\n \tst\t%f0, [%i4+0]\t! (delay)\n \n+\tcmp\t%i3, FFI_TYPE_SINT64\n+\tbe\tlonglong\n+\n \tcmp\t%i3, FFI_TYPE_DOUBLE\n \tbne\tdone\n \tnop\n@@ -80,6 +84,12 @@ done:\n \tret\n \trestore\n \n+longlong:\n+\tst\t%o0, [%i4+0]\n+\tst\t%o1, [%i4+4]\n+\tret\n+\trestore\n+\n .ffi_call_V8_end:\n         .size    ffi_call_V8,.ffi_call_V8_end-ffi_call_V8\n "}, {"sha": "38494344dbb11200768607ec387440539081eaa3", "filename": "libffi/src/sparc/v9.S", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -0,0 +1,127 @@\n+/* -----------------------------------------------------------------------\n+   v9.S - Copyright (c) 2000 Cygnus Solutions\n+   \n+   Sparc 64bit Foreign Function Interface \n+\n+   $Id:$\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\t\n+#include <ffi.h>\n+\n+#ifdef SPARC64\n+/* Only compile this in for 64bit builds, because otherwise the object file\n+   will have inproper architecture due to used instructions.  */\n+\n+#define STACKFRAME 128\t\t/* Minimum stack framesize for SPARC */\n+#define STACK_BIAS 2047\n+#define ARGS (128)\t\t/* Offset of register area in frame */\n+\n+.text\n+        .align 8\n+.globl ffi_call_V9\n+.globl _ffi_call_V9\n+\n+ffi_call_V9:\n+_ffi_call_V9:\n+\tsave\t%sp, -STACKFRAME, %sp\n+\t\n+\tsub\t%sp, %i2, %sp\t! alloca() space in stack for frame to set up\n+\tadd\t%sp, STACKFRAME+STACK_BIAS, %l0\t! %l0 has start of \n+\t\t\t\t\t\t! frame to set up\n+\n+\tmov\t%l0, %o0\t! call routine to set up frame\n+\tcall\t%i0\n+\t mov\t%i1, %o1\t! (delay)\n+\tbrz,pt\t%o0, 1f\n+\t ldx\t[%l0+ARGS], %o0\t! call foreign function\n+\n+\tldd\t[%l0+ARGS], %f0\n+\tldd\t[%l0+ARGS+8], %f2\n+\tldd\t[%l0+ARGS+16], %f4\n+\tldd\t[%l0+ARGS+24], %f6\n+\tldd\t[%l0+ARGS+32], %f8\n+\tldd\t[%l0+ARGS+40], %f10\n+\tldd\t[%l0+ARGS+48], %f12\n+\tldd\t[%l0+ARGS+56], %f14\n+\tldd\t[%l0+ARGS+64], %f16\n+\tldd\t[%l0+ARGS+72], %f18\n+\tldd\t[%l0+ARGS+80], %f20\n+\tldd\t[%l0+ARGS+88], %f22\n+\tldd\t[%l0+ARGS+96], %f24\n+\tldd\t[%l0+ARGS+104], %f26\n+\tldd\t[%l0+ARGS+112], %f28\n+\tldd\t[%l0+ARGS+120], %f30\n+\n+1:\tldx\t[%l0+ARGS+8], %o1\n+\tldx\t[%l0+ARGS+16], %o2\n+\tldx\t[%l0+ARGS+24], %o3\n+\tldx\t[%l0+ARGS+32], %o4\n+\tldx\t[%l0+ARGS+40], %o5\n+\tcall\t%i5\n+\t sub\t%l0, STACK_BIAS, %sp\t! (delay) switch to frame\n+\n+\t! If the return value pointer is NULL, assume no return value.\n+\tbrz,pn\t%i4, done\n+\t nop\n+\n+\tcmp\t%i3, FFI_TYPE_INT\n+\tbe,a,pt\t%icc, done\n+\t stx\t%o0, [%i4]\t! (delay)\n+\n+\tcmp\t%i3, FFI_TYPE_FLOAT\n+\tbe,a,pn\t%icc, done\n+\t st\t%f0, [%i4+0]\t! (delay)\n+\n+\tcmp\t%i3, FFI_TYPE_DOUBLE\n+\tbe,a,pn\t%icc, done\n+\t std\t%f0, [%i4+0]\t! (delay)\n+\n+\tcmp\t%i3, FFI_TYPE_STRUCT\n+\tbe,pn\t%icc, dostruct\n+\n+\t cmp\t%i3, FFI_TYPE_LONGDOUBLE\n+\tbne,pt\t%icc, done\n+\t nop\n+\tstd\t%f0, [%i4+0]\n+\tstd\t%f2, [%i4+8]\n+\n+done:\tret\n+\t restore\n+\n+dostruct:\n+\t/* This will not work correctly for unions. */\n+\tstx\t%o0, [%i4+0]\n+\tstx\t%o1, [%i4+8]\n+\tstx\t%o2, [%i4+16]\n+\tstx\t%o3, [%i4+24]\n+\tstd\t%f0, [%i4+32]\n+\tstd\t%f2, [%i4+40]\n+\tstd\t%f4, [%i4+48]\n+\tstd\t%f6, [%i4+56]\n+\tret\n+\t restore\n+\n+.ffi_call_V9_end:\n+        .size    ffi_call_V9,.ffi_call_V9_end-ffi_call_V9\n+\n+#endif"}, {"sha": "43aab913130bb255b4697bcf9c1120960d71e6c1", "filename": "libffi/src/types.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3791773c9395246e5fb860a20bb3dddd8e5edeb6/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=3791773c9395246e5fb860a20bb3dddd8e5edeb6", "patch": "@@ -42,9 +42,17 @@ FFI_INTEGRAL_TYPEDEF(uint16, 2, 2, FFI_TYPE_UINT16);\n FFI_INTEGRAL_TYPEDEF(sint16, 2, 2, FFI_TYPE_SINT16);\n FFI_INTEGRAL_TYPEDEF(uint32, 4, 4, FFI_TYPE_UINT32);\n FFI_INTEGRAL_TYPEDEF(sint32, 4, 4, FFI_TYPE_SINT32);\n-FFI_INTEGRAL_TYPEDEF(pointer, 4, 4, FFI_TYPE_POINTER);\n FFI_INTEGRAL_TYPEDEF(float, 4, 4, FFI_TYPE_FLOAT);\n \n+#if defined ALPHA || defined SPARC64\n+\n+FFI_INTEGRAL_TYPEDEF(pointer, 8, 8, FFI_TYPE_POINTER);\n+\n+#else\n+\n+FFI_INTEGRAL_TYPEDEF(pointer, 4, 4, FFI_TYPE_POINTER);\n+\n+#endif\n \n #ifdef X86\n \n@@ -87,8 +95,17 @@ FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n #elif defined SPARC\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);\n+\n+#ifdef SPARC64\n+\n+FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n+\n+#else\n+\n FFI_INTEGRAL_TYPEDEF(longdouble, 16, 8, FFI_TYPE_LONGDOUBLE);\n \n+#endif\n+\n #else\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);"}]}