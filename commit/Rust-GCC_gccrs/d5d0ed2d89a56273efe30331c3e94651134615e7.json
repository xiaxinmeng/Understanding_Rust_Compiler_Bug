{"sha": "d5d0ed2d89a56273efe30331c3e94651134615e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVkMGVkMmQ4OWE1NjI3M2VmZTMwMzMxYzNlOTQ2NTExMzQ2MTVlNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-07-30T17:27:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-07-30T17:27:14Z"}, "message": "re PR lto/53808 (Undefined symbol when building a library with lto)\n\n\tPR lto/53808\n\tPR c++/61659\n\t* pt.c (push_template_decl_real): Set DECL_COMDAT on templates.\n\t(check_explicit_specialization): Clear it on specializations.\n\t* decl.c (duplicate_decls, start_decl): Likewise.\n\t(grokmethod, grokfndecl): Set DECL_COMDAT on inlines.\n\t* method.c (implicitly_declare_fn): Set DECL_COMDAT.  Determine\n\tlinkage after setting the appropriate flags.\n\t* tree.c (decl_linkage): Don't check DECL_COMDAT.\n\t* decl2.c (mark_needed): Mark clones.\n\t(import_export_decl): Not here.\n\nFrom-SVN: r213307", "tree": {"sha": "043925ba81282b0a865db1992b86c852a51fdf2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043925ba81282b0a865db1992b86c852a51fdf2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5d0ed2d89a56273efe30331c3e94651134615e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d0ed2d89a56273efe30331c3e94651134615e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5d0ed2d89a56273efe30331c3e94651134615e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5d0ed2d89a56273efe30331c3e94651134615e7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea3e455ac77a67e96a916c4c64249be8e20124cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea3e455ac77a67e96a916c4c64249be8e20124cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea3e455ac77a67e96a916c4c64249be8e20124cd"}], "stats": {"total": 79, "additions": 50, "deletions": 29}, "files": [{"sha": "3d8bf6d58a542c5094eefbd9116229559797c19a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -1,3 +1,17 @@\n+2014-07-30  Jason Merrill  <jason@redhat.com>\n+\n+\tPR lto/53808\n+\tPR c++/61659\n+\t* pt.c (push_template_decl_real): Set DECL_COMDAT on templates.\n+\t(check_explicit_specialization): Clear it on specializations.\n+\t* decl.c (duplicate_decls, start_decl): Likewise.\n+\t(grokmethod, grokfndecl): Set DECL_COMDAT on inlines.\n+\t* method.c (implicitly_declare_fn): Set DECL_COMDAT.  Determine\n+\tlinkage after setting the appropriate flags.\n+\t* tree.c (decl_linkage): Don't check DECL_COMDAT.\n+\t* decl2.c (mark_needed): Mark clones.\n+\t(import_export_decl): Not here.\n+\n 2014-07-25  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tImplement N4051 - Allow typename in a template template parameter"}, {"sha": "fd5e2e5f3c501e9d201cdb5a83e010dcc10e24e4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -2197,6 +2197,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\t      olddecl);\n \n \t  SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);\n+\t  DECL_COMDAT (newdecl) = DECL_DECLARED_INLINE_P (olddecl);\n \n \t  /* Don't propagate visibility from the template to the\n \t     specialization here.  We'll do that in determine_visibility if\n@@ -4683,6 +4684,10 @@ start_decl (const cp_declarator *declarator,\n       if (DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))\n \t{\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    DECL_COMDAT (decl) = DECL_DECLARED_INLINE_P (decl);\n+\t  else\n+\t    DECL_COMDAT (decl) = false;\n \n \t  /* [temp.expl.spec] An explicit specialization of a static data\n \t     member of a template is a definition if the declaration\n@@ -7663,7 +7668,10 @@ grokfndecl (tree ctype,\n \n   /* If the declaration was declared inline, mark it as such.  */\n   if (inlinep)\n-    DECL_DECLARED_INLINE_P (decl) = 1;\n+    {\n+      DECL_DECLARED_INLINE_P (decl) = 1;\n+      DECL_COMDAT (decl) = 1;\n+    }\n   if (inlinep & 2)\n     DECL_DECLARED_CONSTEXPR_P (decl) = true;\n \n@@ -14223,6 +14231,7 @@ grokmethod (cp_decl_specifier_seq *declspecs,\n \n   check_template_shadow (fndecl);\n \n+  DECL_COMDAT (fndecl) = 1;\n   DECL_DECLARED_INLINE_P (fndecl) = 1;\n   DECL_NO_INLINE_WARNING_P (fndecl) = 1;\n "}, {"sha": "884be0a954e8d60eb2dbcaa8bae55bfe02aa66d8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -1930,6 +1930,12 @@ mark_needed (tree decl)\n \t definition.  */\n       struct cgraph_node *node = cgraph_node::get_create (decl);\n       node->forced_by_abi = true;\n+\n+      /* #pragma interface and -frepo code can call mark_needed for\n+          maybe-in-charge 'tors; mark the clones as well.  */\n+      tree clone;\n+      FOR_EACH_CLONE (clone, decl)\n+\tmark_needed (clone);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n@@ -2728,17 +2734,7 @@ import_export_decl (tree decl)\n     {\n       /* The repository indicates that this entity should be defined\n \t here.  Make sure the back end honors that request.  */\n-      if (VAR_P (decl))\n-\tmark_needed (decl);\n-      else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)\n-\t       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n-\t{\n-\t  tree clone;\n-\t  FOR_EACH_CLONE (clone, decl)\n-\t    mark_needed (clone);\n-\t}\n-      else\n-\tmark_needed (decl);\n+      mark_needed (decl);\n       /* Output the definition as an ordinary strong definition.  */\n       DECL_EXTERNAL (decl) = 0;\n       DECL_INTERFACE_KNOWN (decl) = 1;"}, {"sha": "f86a21482e671d88802b3cb84665dea1729f0a9d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -1798,8 +1798,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   DECL_ARGUMENTS (fn) = this_parm;\n \n   grokclassfn (type, fn, kind == sfk_destructor ? DTOR_FLAG : NO_SPECIAL);\n-  set_linkage_according_to_type (type, fn);\n-  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_DEFAULTED_FN (fn) = 1;\n@@ -1811,6 +1809,9 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   DECL_EXTERNAL (fn) = true;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_COMDAT (fn) = 1;\n+  set_linkage_according_to_type (type, fn);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n   gcc_assert (!TREE_USED (fn));\n \n   /* Restore PROCESSING_TEMPLATE_DECL.  */"}, {"sha": "0eac7718b221ff57190c1c5f7f5ceef5c1dbe57c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -2787,6 +2787,9 @@ check_explicit_specialization (tree declarator,\n \t       It's just the name of an instantiation.  But, it's not\n \t       a request for an instantiation, either.  */\n \t    SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\t  else\n+\t    /* A specialization is not necessarily COMDAT.  */\n+\t    DECL_COMDAT (decl) = DECL_DECLARED_INLINE_P (decl);\n \n \t  /* Register this specialization so that we can find it\n \t     again.  */\n@@ -5017,6 +5020,13 @@ template arguments to %qD do not match original template %qD\",\n \tDECL_TEMPLATE_INFO (decl) = info;\n     }\n \n+  if (flag_implicit_templates\n+      && VAR_OR_FUNCTION_DECL_P (decl))\n+    /* Set DECL_COMDAT on template instantiations; if we force\n+       them to be emitted by explicit instantiation or -frepo,\n+       mark_needed will tell cgraph to do the right thing.  */\n+    DECL_COMDAT (decl) = true;\n+\n   return DECL_TEMPLATE_RESULT (tmpl);\n }\n "}, {"sha": "1bfffb8174bab781018d7693f41e36573fda11eb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -3722,23 +3722,15 @@ decl_linkage (tree decl)\n   if (TREE_CODE (decl) == CONST_DECL)\n     return decl_linkage (TYPE_NAME (DECL_CONTEXT (decl)));\n \n-  /* Some things that are not TREE_PUBLIC have external linkage, too.\n-     For example, on targets that don't have weak symbols, we make all\n-     template instantiations have internal linkage (in the object\n-     file), but the symbols should still be treated as having external\n-     linkage from the point of view of the language.  */\n-  if (VAR_OR_FUNCTION_DECL_P (decl)\n-      && DECL_COMDAT (decl))\n-    return lk_external;\n-\n   /* Things in local scope do not have linkage, if they don't have\n      TREE_PUBLIC set.  */\n   if (decl_function_context (decl))\n     return lk_none;\n \n   /* Members of the anonymous namespace also have TREE_PUBLIC unset, but\n-     are considered to have external linkage for language purposes.  DECLs\n-     really meant to have internal linkage have DECL_THIS_STATIC set.  */\n+     are considered to have external linkage for language purposes, as do\n+     template instantiations on targets without weak symbols.  DECLs really\n+     meant to have internal linkage have DECL_THIS_STATIC set.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n     return lk_external;\n   if (VAR_OR_FUNCTION_DECL_P (decl))"}, {"sha": "72f56afcadcc7c55b0db7d1239086f6761096696", "filename": "gcc/testsuite/g++.dg/opt/devirt4.C", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5d0ed2d89a56273efe30331c3e94651134615e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt4.C?ref=d5d0ed2d89a56273efe30331c3e94651134615e7", "patch": "@@ -1,8 +1,7 @@\n // PR lto/53808\n-// Devirtualization + inlining should produce a non-virtual\n-// call to ~foo.\n-// { dg-options \"-O -fdevirtualize\" }\n-// { dg-final { scan-assembler \"_ZN3fooD2Ev\" } }\n+// Devirtualization should not produce an external ref to ~bar.\n+// { dg-options \"-O2\" }\n+// { dg-final { scan-assembler-not \"_ZN3barD0Ev\" } }\n \n struct foo {\n  virtual ~foo();"}]}