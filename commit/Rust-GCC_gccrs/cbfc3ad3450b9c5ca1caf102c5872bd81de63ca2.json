{"sha": "cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmYzNhZDM0NTBiOWM1Y2ExY2FmMTAyYzU4NzJiZDgxZGU2M2NhMg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-18T12:12:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-18T12:12:50Z"}, "message": "(reload): Don't call reload_cse_regs here.\n\n(reload_cse_mem_conflict_p): Remove MEM_OFFSET and MEM_MODE args.\n(reload_cse_mem_conflict_p, case MEM): Call anti_dependence.\n(reload_cse_invalidate_mem): Update call to reload_cse_mem_conflict_p.\n(reload_cse_regs): No longer static.\nCall init_alias_analysis.\nIgnore CLOBBER in a PARALLEL.\n\nFrom-SVN: r14479", "tree": {"sha": "05b4726c07d07bab89eb0161ba09f80942589852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05b4726c07d07bab89eb0161ba09f80942589852"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2/comments", "author": null, "committer": null, "parents": [{"sha": "c8ed219d31279e8c14312e0246887303d56ef4bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8ed219d31279e8c14312e0246887303d56ef4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8ed219d31279e8c14312e0246887303d56ef4bd"}], "stats": {"total": 76, "additions": 14, "deletions": 62}, "files": [{"sha": "564a579b8a48f8405c3124cf44be782d7c35c6e3", "filename": "gcc/reload1.c", "status": "modified", "additions": 14, "deletions": 62, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cbfc3ad3450b9c5ca1caf102c5872bd81de63ca2", "patch": "@@ -394,11 +394,9 @@ static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n static int count_occurrences\t\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n-static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx, enum machine_mode,\n-\t\t\t\t\t       rtx));\n+static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_mem\tPROTO((rtx));\n static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx));\n-static void reload_cse_regs\t\tPROTO((rtx));\n static int reload_cse_regno_equal_p\tPROTO((int, rtx, enum machine_mode));\n static int reload_cse_noop_set_p\tPROTO((rtx, rtx));\n static void reload_cse_simplify_set\tPROTO((rtx, rtx));\n@@ -2137,10 +2135,6 @@ reload (first, global, dumpfile)\n \t}\n     }\n \n-  /* Do a very simple CSE pass over just the hard registers.  */\n-  if (optimize > 0)\n-    reload_cse_regs (first);\n-\n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n   /* Make a pass over all the insns and remove death notes for things that\n      are no longer registers or no longer die in the insn (e.g., an input\n@@ -7674,15 +7668,12 @@ reload_cse_invalidate_regno (regno, mode, clobber)\n     }\n }\n \n-/* The memory at address (plus MEM_BASE MEM_OFFSET), where MEM_OFFSET\n-   is a CONST_INT, is being changed.  MEM_MODE is the mode of the\n-   memory reference.  Return whether this change will invalidate VAL.  */\n+/* The memory at address MEM_BASE is being changed.  MEM_MODE is the mode of\n+   the memory reference.  Return whether this change will invalidate VAL.  */\n \n static int\n-reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode, val)\n+reload_cse_mem_conflict_p (mem_base, val)\n      rtx mem_base;\n-     rtx mem_offset;\n-     enum machine_mode mem_mode;\n      rtx val;\n {\n   enum rtx_code code;\n@@ -7705,37 +7696,7 @@ reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode, val)\n       return 0;\n \n     case MEM:\n-      {\n-\trtx val_base, val_offset;\n-\n-\tif (mem_mode == BLKmode || GET_MODE (val) == BLKmode)\n-\t  return 1;\n-\n-\tval_offset = const0_rtx;\n-\tval_base = eliminate_constant_term (XEXP (val, 0), &val_offset);\n-\n-\t/* If MEM_BASE and VAL_BASE are the same, but the offsets do\n-\t   not overlap, then we do not have a conflict on this MEM.\n-\t   For complete safety, we still need to check that VAL_BASE\n-\t   itself does not contain an overlapping MEM.\n-\n-\t   We can't simplify the check to just OFFSET + SIZE <=\n-\t   OTHER_OFFSET, because SIZE might cause OFFSET to wrap from\n-\t   positive to negative.  If we used unsigned arithmetic, we\n-\t   would have the same problem wrapping around zero.  */\n-\n-\tif (rtx_equal_p (mem_base, val_base)\n-\t    && ((INTVAL (mem_offset) < INTVAL (val_offset)\n-\t\t && (INTVAL (mem_offset) + GET_MODE_SIZE (mem_mode)\n-\t\t     <= INTVAL (val_offset)))\n-\t\t|| (INTVAL (val_offset) < INTVAL (mem_offset)\n-\t\t    && (INTVAL (val_offset) + GET_MODE_SIZE (GET_MODE (val))\n-\t\t\t<= INTVAL (mem_offset)))))\n-\t  return reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n-\t\t\t\t\t    val_base);\n-\n-\treturn 1;\n-      }\n+      return anti_dependence (val, mem_base);\n \n     default:\n       break;\n@@ -7747,17 +7708,15 @@ reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode, val)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  if (reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n-\t\t\t\t\t XEXP (val, i)))\n+\t  if (reload_cse_mem_conflict_p (mem_base, XEXP (val, i)))\n \t    return 1;\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \n \t  for (j = 0; j < XVECLEN (val, i); j++)\n-\t    if (reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n-\t\t\t\t\t   XVECEXP (val, i, j)))\n+\t    if (reload_cse_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n \t      return 1;\n \t}\n     }\n@@ -7774,15 +7733,6 @@ reload_cse_invalidate_mem (mem_rtx)\n      rtx mem_rtx;\n {\n   register int i;\n-  rtx mem_base, mem_offset;\n-  enum machine_mode mem_mode;\n-\n-  /* We detect certain cases where memory addresses can not conflict:\n-     if they use the same register, and the offsets do not overlap.  */\n-\n-  mem_offset = const0_rtx;\n-  mem_base = eliminate_constant_term (XEXP (mem_rtx, 0), &mem_offset);\n-  mem_mode = GET_MODE (mem_rtx);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -7791,8 +7741,7 @@ reload_cse_invalidate_mem (mem_rtx)\n       for (x = reg_values[i]; x; x = XEXP (x, 1))\n \t{\n \t  if (XEXP (x, 0) != 0\n-\t      && reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n-\t\t\t\t\t    XEXP (x, 0)))\n+\t      && reload_cse_mem_conflict_p (mem_rtx, XEXP (x, 0)))\n \t    {\n \t      /* If this is the only entry on the list, clear\n                  reg_values[i].  Otherwise, just clear this entry on\n@@ -7841,7 +7790,7 @@ reload_cse_invalidate_rtx (dest, ignore)\n    registers) changes it to simply copy the first register into the\n    second register.  */\n \n-static void\n+void\n reload_cse_regs (first)\n      rtx first;\n {\n@@ -7850,6 +7799,8 @@ reload_cse_regs (first)\n   register int i;\n   rtx insn;\n \n+  init_alias_analysis ();\n+\n   reg_values = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_values[i] = 0;\n@@ -7931,8 +7882,9 @@ reload_cse_regs (first)\n \t  /* If every action in a PARALLEL is a noop, we can delete\n              the entire PARALLEL.  */\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n-\t    if (GET_CODE (XVECEXP (body, 0, i)) != SET\n-\t\t|| ! reload_cse_noop_set_p (XVECEXP (body, 0, i), insn))\n+\t    if ((GET_CODE (XVECEXP (body, 0, i)) != SET\n+\t\t || ! reload_cse_noop_set_p (XVECEXP (body, 0, i), insn))\n+\t\t&& GET_CODE (XVECEXP (body, 0, i)) != CLOBBER)\n \t      break;\n \t  if (i < 0)\n \t    {"}]}