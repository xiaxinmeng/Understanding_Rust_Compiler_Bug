{"sha": "48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhhYjhiYTZiODJjZTEwY2I1ZjcyNmQyYWU5NWQ0YjRiODU3YmE5Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-25T23:14:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-08-25T23:14:20Z"}, "message": "Change Bound_method_expression to refer to a constant method.\n\nFrom-SVN: r178091", "tree": {"sha": "f2687d565e5bf329a4cdc9c5a8665365460a026e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2687d565e5bf329a4cdc9c5a8665365460a026e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/comments", "author": null, "committer": null, "parents": [{"sha": "2e335040bcd1fddb5a775d537092c5a3b783263e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e335040bcd1fddb5a775d537092c5a3b783263e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e335040bcd1fddb5a775d537092c5a3b783263e"}], "stats": {"total": 219, "additions": 121, "deletions": 98}, "files": [{"sha": "af29a3006368dbbf8e23b8e0d2a7befb2e4ed9e2", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "patch": "@@ -6798,9 +6798,7 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n int\n Bound_method_expression::do_traverse(Traverse* traverse)\n {\n-  if (Expression::traverse(&this->expr_, traverse) == TRAVERSE_EXIT)\n-    return TRAVERSE_EXIT;\n-  return Expression::traverse(&this->method_, traverse);\n+  return Expression::traverse(&this->expr_, traverse);\n }\n \n // Return the type of a bound method expression.  The type of this\n@@ -6811,17 +6809,20 @@ Bound_method_expression::do_traverse(Traverse* traverse)\n Type*\n Bound_method_expression::do_type()\n {\n-  return this->method_->type();\n+  if (this->method_->is_function())\n+    return this->method_->func_value()->type();\n+  else if (this->method_->is_function_declaration())\n+    return this->method_->func_declaration_value()->type();\n+  else\n+    return Type::make_error_type();\n }\n \n // Determine the types of a method expression.\n \n void\n Bound_method_expression::do_determine_type(const Type_context*)\n {\n-  this->method_->determine_type_no_context();\n-  Type* mtype = this->method_->type();\n-  Function_type* fntype = mtype == NULL ? NULL : mtype->function_type();\n+  Function_type* fntype = this->type()->function_type();\n   if (fntype == NULL || !fntype->is_method())\n     this->expr_->determine_type_no_context();\n   else\n@@ -6836,14 +6837,12 @@ Bound_method_expression::do_determine_type(const Type_context*)\n void\n Bound_method_expression::do_check_types(Gogo*)\n {\n-  Type* type = this->method_->type()->deref();\n-  if (type == NULL\n-      || type->function_type() == NULL\n-      || !type->function_type()->is_method())\n+  if (!this->method_->is_function()\n+      && !this->method_->is_function_declaration())\n     this->report_error(_(\"object is not a method\"));\n   else\n     {\n-      Type* rtype = type->function_type()->receiver()->type()->deref();\n+      Type* rtype = this->type()->function_type()->receiver()->type()->deref();\n       Type* etype = (this->expr_type_ != NULL\n \t\t     ? this->expr_type_\n \t\t     : this->expr_->type());\n@@ -6881,14 +6880,13 @@ Bound_method_expression::do_dump_expression(Ast_dump_context* ast_dump_context)\n       ast_dump_context->ostream() << \")\";\n     }\n     \n-  ast_dump_context->ostream() << \".\";\n-  ast_dump_context->dump_expression(method_);\n+  ast_dump_context->ostream() << \".\" << this->method_->name();\n }\n \n // Make a method expression.\n \n Bound_method_expression*\n-Expression::make_bound_method(Expression* expr, Expression* method,\n+Expression::make_bound_method(Expression* expr, Named_object* method,\n \t\t\t      source_location location)\n {\n   return new Bound_method_expression(expr, method, location);\n@@ -9257,6 +9255,9 @@ Call_expression::bound_method_function(Translate_context* context,\n \t\t\t\t       Bound_method_expression* bound_method,\n \t\t\t\t       tree* first_arg_ptr)\n {\n+  Gogo* gogo = context->gogo();\n+  source_location loc = this->location();\n+\n   Expression* first_argument = bound_method->first_argument();\n   tree first_arg = first_argument->get_tree(context);\n   if (first_arg == error_mark_node)\n@@ -9272,7 +9273,7 @@ Call_expression::bound_method_function(Translate_context* context,\n \t  || TREE_CODE(first_arg) == INDIRECT_REF\n \t  || TREE_CODE(first_arg) == COMPONENT_REF)\n \t{\n-\t  first_arg = build_fold_addr_expr(first_arg);\n+\t  first_arg = build_fold_addr_expr_loc(loc, first_arg);\n \t  if (DECL_P(first_arg))\n \t    TREE_ADDRESSABLE(first_arg) = 1;\n \t}\n@@ -9282,9 +9283,10 @@ Call_expression::bound_method_function(Translate_context* context,\n \t\t\t\t    get_name(first_arg));\n \t  DECL_IGNORED_P(tmp) = 0;\n \t  DECL_INITIAL(tmp) = first_arg;\n-\t  first_arg = build2(COMPOUND_EXPR, pointer_to_arg_type,\n-\t\t\t     build1(DECL_EXPR, void_type_node, tmp),\n-\t\t\t     build_fold_addr_expr(tmp));\n+\t  first_arg = build2_loc(loc, COMPOUND_EXPR, pointer_to_arg_type,\n+\t\t\t\t build1_loc(loc, DECL_EXPR, void_type_node,\n+\t\t\t\t\t    tmp),\n+\t\t\t\t build_fold_addr_expr_loc(loc, tmp));\n \t  TREE_ADDRESSABLE(tmp) = 1;\n \t}\n       if (first_arg == error_mark_node)\n@@ -9296,16 +9298,30 @@ Call_expression::bound_method_function(Translate_context* context,\n     {\n       if (fatype->points_to() == NULL)\n \tfatype = Type::make_pointer_type(fatype);\n-      Btype* bfatype = fatype->get_backend(context->gogo());\n-      first_arg = fold_convert(type_to_tree(bfatype), first_arg);\n+      Btype* bfatype = fatype->get_backend(gogo);\n+      first_arg = fold_convert_loc(loc, type_to_tree(bfatype), first_arg);\n       if (first_arg == error_mark_node\n \t  || TREE_TYPE(first_arg) == error_mark_node)\n \treturn error_mark_node;\n     }\n \n   *first_arg_ptr = first_arg;\n \n-  return bound_method->method()->get_tree(context);\n+  Named_object* method = bound_method->method();\n+  tree id = method->get_id(gogo);\n+  if (id == error_mark_node)\n+    return error_mark_node;\n+\n+  tree fndecl;\n+  if (method->is_function())\n+    fndecl = method->func_value()->get_or_make_decl(gogo, method, id);\n+  else if (method->is_function_declaration())\n+    fndecl = method->func_declaration_value()->get_or_make_decl(gogo, method,\n+\t\t\t\t\t\t\t\tid);\n+  else\n+    go_unreachable();\n+\n+  return build_fold_addr_expr_loc(loc, fndecl);\n }\n \n // Get the function and the first argument to use when calling an"}, {"sha": "530ea4e27072ec405985ce0347edea3bc91720f8", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "patch": "@@ -192,7 +192,7 @@ class Expression\n   // Make an expression which is a method bound to its first\n   // parameter.\n   static Bound_method_expression*\n-  make_bound_method(Expression* object, Expression* method, source_location);\n+  make_bound_method(Expression* object, Named_object* method, source_location);\n \n   // Make an index or slice expression.  This is a parser expression\n   // which represents LEFT[START:END].  END may be NULL, meaning an\n@@ -1636,7 +1636,7 @@ class Map_index_expression : public Expression\n class Bound_method_expression : public Expression\n {\n  public:\n-  Bound_method_expression(Expression* expr, Expression* method,\n+  Bound_method_expression(Expression* expr, Named_object* method,\n \t\t\t  source_location location)\n     : Expression(EXPRESSION_BOUND_METHOD, location),\n       expr_(expr), expr_type_(NULL), method_(method)\n@@ -1654,8 +1654,8 @@ class Bound_method_expression : public Expression\n   first_argument_type() const\n   { return this->expr_type_; }\n \n-  // Return the reference to the method function.\n-  Expression*\n+  // Return the method function.\n+  Named_object*\n   method()\n   { return this->method_; }\n \n@@ -1680,8 +1680,7 @@ class Bound_method_expression : public Expression\n   Expression*\n   do_copy()\n   {\n-    return new Bound_method_expression(this->expr_->copy(),\n-\t\t\t\t       this->method_->copy(),\n+    return new Bound_method_expression(this->expr_->copy(), this->method_,\n \t\t\t\t       this->location());\n   }\n \n@@ -1699,8 +1698,8 @@ class Bound_method_expression : public Expression\n   // NULL in the normal case, non-NULL when using a method from an\n   // anonymous field which does not require a stub.\n   Type* expr_type_;\n-  // The method itself.  This is a Func_expression.\n-  Expression* method_;\n+  // The method itself.\n+  Named_object* method_;\n };\n \n // A reference to a field in a struct."}, {"sha": "c2caaa4eab6afbe0bc19f4ba68d9e5d453ed00cc", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 68, "deletions": 52, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "patch": "@@ -1808,10 +1808,6 @@ Statement::make_dec_statement(Expression* expr)\n // Class Thunk_statement.  This is the base class for go and defer\n // statements.\n \n-const char* const Thunk_statement::thunk_field_fn = \"fn\";\n-\n-const char* const Thunk_statement::thunk_field_receiver = \"receiver\";\n-\n // Constructor.\n \n Thunk_statement::Thunk_statement(Statement_classification classification,\n@@ -1991,6 +1987,30 @@ Gogo::simplify_thunk_statements()\n   this->traverse(&thunk_traverse);\n }\n \n+// Return true if the thunk function is a constant, which means that\n+// it does not need to be passed to the thunk routine.\n+\n+bool\n+Thunk_statement::is_constant_function() const\n+{\n+  Call_expression* ce = this->call_->call_expression();\n+  Function_type* fntype = ce->get_function_type();\n+  if (fntype == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return false;\n+    }\n+  if (fntype->is_builtin())\n+    return true;\n+  Expression* fn = ce->fn();\n+  if (fn->func_expression() != NULL)\n+    return fn->func_expression()->closure() == NULL;\n+  if (fn->bound_method_expression() != NULL\n+      || fn->interface_field_reference_expression() != NULL)\n+    return true;\n+  return false;\n+}\n+\n // Simplify complex thunk statements into simple ones.  A complicated\n // thunk statement is one which takes anything other than zero\n // parameters or a single pointer parameter.  We rewrite it into code\n@@ -2031,30 +2051,28 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n   Bound_method_expression* bound_method = fn->bound_method_expression();\n   Interface_field_reference_expression* interface_method =\n     fn->interface_field_reference_expression();\n-  const bool is_method = bound_method != NULL || interface_method != NULL;\n \n   source_location location = this->location();\n \n   std::string thunk_name = Gogo::thunk_name();\n \n   // Build the thunk.\n-  this->build_thunk(gogo, thunk_name, fntype);\n+  this->build_thunk(gogo, thunk_name);\n \n   // Generate code to call the thunk.\n \n   // Get the values to store into the struct which is the single\n   // argument to the thunk.\n \n   Expression_list* vals = new Expression_list();\n-  if (fntype->is_builtin())\n-    ;\n-  else if (!is_method)\n+  if (!this->is_constant_function())\n     vals->push_back(fn);\n-  else if (interface_method != NULL)\n+\n+  if (interface_method != NULL)\n     vals->push_back(interface_method->expr());\n-  else if (bound_method != NULL)\n+\n+  if (bound_method != NULL)\n     {\n-      vals->push_back(bound_method->method());\n       Expression* first_arg = bound_method->first_argument();\n \n       // We always pass a pointer when calling a method.\n@@ -2076,8 +2094,6 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n \n       vals->push_back(first_arg);\n     }\n-  else\n-    go_unreachable();\n \n   if (ce->args() != NULL)\n     {\n@@ -2152,45 +2168,46 @@ Thunk_statement::build_struct(Function_type* fntype)\n   Call_expression* ce = this->call_->call_expression();\n   Expression* fn = ce->fn();\n \n+  if (!this->is_constant_function())\n+    {\n+      // The function to call.\n+      fields->push_back(Struct_field(Typed_identifier(\"fn\", fntype,\n+\t\t\t\t\t\t      location)));\n+    }\n+\n+  // If this thunk statement calls a method on an interface, we pass\n+  // the interface object to the thunk.\n   Interface_field_reference_expression* interface_method =\n     fn->interface_field_reference_expression();\n   if (interface_method != NULL)\n     {\n-      // If this thunk statement calls a method on an interface, we\n-      // pass the interface object to the thunk.\n-      Typed_identifier tid(Thunk_statement::thunk_field_fn,\n-\t\t\t   interface_method->expr()->type(),\n+      Typed_identifier tid(\"object\", interface_method->expr()->type(),\n \t\t\t   location);\n       fields->push_back(Struct_field(tid));\n     }\n-  else if (!fntype->is_builtin())\n-    {\n-      // The function to call.\n-      Typed_identifier tid(Go_statement::thunk_field_fn, fntype, location);\n-      fields->push_back(Struct_field(tid));\n-    }\n-  else if (ce->is_recover_call())\n-    {\n-      // The predeclared recover function has no argument.  However,\n-      // we add an argument when building recover thunks.  Handle that\n-      // here.\n-      fields->push_back(Struct_field(Typed_identifier(\"can_recover\",\n-\t\t\t\t\t\t      Type::lookup_bool_type(),\n-\t\t\t\t\t\t      location)));\n-    }\n \n+  // If this is a method call, pass down the expression we are\n+  // calling.\n   if (fn->bound_method_expression() != NULL)\n     {\n       go_assert(fntype->is_method());\n       Type* rtype = fntype->receiver()->type();\n       // We always pass the receiver as a pointer.\n       if (rtype->points_to() == NULL)\n \trtype = Type::make_pointer_type(rtype);\n-      Typed_identifier tid(Thunk_statement::thunk_field_receiver, rtype,\n-\t\t\t   location);\n+      Typed_identifier tid(\"receiver\", rtype, location);\n       fields->push_back(Struct_field(tid));\n     }\n \n+  // The predeclared recover function has no argument.  However, we\n+  // add an argument when building recover thunks.  Handle that here.\n+  if (ce->is_recover_call())\n+    {\n+      fields->push_back(Struct_field(Typed_identifier(\"can_recover\",\n+\t\t\t\t\t\t      Type::lookup_bool_type(),\n+\t\t\t\t\t\t      location)));\n+    }\n+\n   const Expression_list* args = ce->args();\n   if (args != NULL)\n     {\n@@ -2213,8 +2230,7 @@ Thunk_statement::build_struct(Function_type* fntype)\n // artificial, function.\n \n void\n-Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n-\t\t\t     Function_type* fntype)\n+Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n {\n   source_location location = this->location();\n \n@@ -2307,37 +2323,37 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n \n   Expression* func_to_call;\n   unsigned int next_index;\n-  if (!fntype->is_builtin())\n+  if (this->is_constant_function())\n     {\n-      func_to_call = Expression::make_field_reference(thunk_parameter,\n-\t\t\t\t\t\t      0, location);\n-      next_index = 1;\n+      func_to_call = ce->fn();\n+      next_index = 0;\n     }\n   else\n     {\n-      go_assert(bound_method == NULL && interface_method == NULL);\n-      func_to_call = ce->fn();\n-      next_index = 0;\n+      func_to_call = Expression::make_field_reference(thunk_parameter,\n+\t\t\t\t\t\t      0, location);\n+      next_index = 1;\n     }\n \n   if (bound_method != NULL)\n     {\n-      Expression* r = Expression::make_field_reference(thunk_parameter, 1,\n+      go_assert(next_index == 0);\n+      Expression* r = Expression::make_field_reference(thunk_parameter, 0,\n \t\t\t\t\t\t       location);\n-      // The main program passes in a function pointer from the\n-      // interface expression, so here we can make a bound method in\n-      // all cases.\n-      func_to_call = Expression::make_bound_method(r, func_to_call,\n+      func_to_call = Expression::make_bound_method(r, bound_method->method(),\n \t\t\t\t\t\t   location);\n-      next_index = 2;\n+      next_index = 1;\n     }\n   else if (interface_method != NULL)\n     {\n       // The main program passes the interface object.\n+      go_assert(next_index == 0);\n+      Expression* r = Expression::make_field_reference(thunk_parameter, 0,\n+\t\t\t\t\t\t       location);\n       const std::string& name(interface_method->name());\n-      func_to_call = Expression::make_interface_field_reference(func_to_call,\n-\t\t\t\t\t\t\t\tname,\n+      func_to_call = Expression::make_interface_field_reference(r, name,\n \t\t\t\t\t\t\t\tlocation);\n+      next_index = 1;\n     }\n \n   Expression_list* call_params = new Expression_list();"}, {"sha": "0a87a8b733c46f091aae57d74fe361a81f4a0697", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "patch": "@@ -906,21 +906,17 @@ class Thunk_statement : public Statement\n   bool\n   is_simple(Function_type*) const;\n \n+  // Return whether the thunk function is a constant.\n+  bool\n+  is_constant_function() const;\n+\n   // Build the struct to use for a complex case.\n   Struct_type*\n   build_struct(Function_type* fntype);\n \n   // Build the thunk.\n   void\n-  build_thunk(Gogo*, const std::string&, Function_type* fntype);\n-\n-  // The field name used in the thunk structure for the function\n-  // pointer.\n-  static const char* const thunk_field_fn;\n-\n-  // The field name used in the thunk structure for the receiver, if\n-  // there is one.\n-  static const char* const thunk_field_receiver;\n+  build_thunk(Gogo*, const std::string&);\n \n   // Set the name to use for thunk field N.\n   void"}, {"sha": "cf404a364960c59b2da63d6e06b59cf46dfb95f1", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=48ab8ba6b82ce10cb5f726d2ae95d4b4b857ba9c", "patch": "@@ -6085,10 +6085,7 @@ Method::bind_method(Expression* expr, source_location location) const\n       // the child class.\n       return this->do_bind_method(expr, location);\n     }\n-\n-  Expression* func = Expression::make_func_reference(this->stub_, NULL,\n-\t\t\t\t\t\t     location);\n-  return Expression::make_bound_method(expr, func, location);\n+  return Expression::make_bound_method(expr, this->stub_, location);\n }\n \n // Return the named object associated with a method.  This may only be\n@@ -6130,9 +6127,8 @@ Named_method::do_receiver_location() const\n Expression*\n Named_method::do_bind_method(Expression* expr, source_location location) const\n {\n-  Expression* func = Expression::make_func_reference(this->named_object_, NULL,\n-\t\t\t\t\t\t     location);\n-  Bound_method_expression* bme = Expression::make_bound_method(expr, func,\n+  Named_object* no = this->named_object_;\n+  Bound_method_expression* bme = Expression::make_bound_method(expr, no,\n \t\t\t\t\t\t\t       location);\n   // If this is not a local method, and it does not use a stub, then\n   // the real method expects a different type.  We need to cast the"}]}