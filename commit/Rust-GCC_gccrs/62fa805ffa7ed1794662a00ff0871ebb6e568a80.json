{"sha": "62fa805ffa7ed1794662a00ff0871ebb6e568a80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJmYTgwNWZmYTdlZDE3OTQ2NjJhMDBmZjA4NzFlYmI2ZTU2OGE4MA==", "commit": {"author": {"name": "Daniel Krugler", "email": "daniel.kruegler@googlemail.com", "date": "2012-04-23T21:34:06Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-04-23T21:34:06Z"}, "message": "type_traits (is_nothrow_destructible): Implement.\n\n2012-04-23  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\n\t* include/std/type_traits (is_nothrow_destructible): Implement.\n\t(is_destructible): Implement LWG 2049.\n\t* testsuite/util/testsuite_tr1.h: Add tests.\n\t* testsuite/20_util/is_nothrow_destructible/value.cc: New.\n\t* testsuite/20_util/is_nothrow_destructible/requirements/typedefs.cc:\n\t* testsuite/20_util/is_nothrow_destructible/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_destructible/value.cc: Adjust and extend.\n\t* testsuite/20_util/is_default_constructible/value.cc: Tweak.\n\t* testsuite/20_util/is_constructible/value-2.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n\tdg-error line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\nFrom-SVN: r186726", "tree": {"sha": "7d8657c51c9ac736f522f44992985b70428b2aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8657c51c9ac736f522f44992985b70428b2aaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62fa805ffa7ed1794662a00ff0871ebb6e568a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62fa805ffa7ed1794662a00ff0871ebb6e568a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62fa805ffa7ed1794662a00ff0871ebb6e568a80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62fa805ffa7ed1794662a00ff0871ebb6e568a80/comments", "author": {"login": "Dani-Hub", "id": 431432, "node_id": "MDQ6VXNlcjQzMTQzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/431432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dani-Hub", "html_url": "https://github.com/Dani-Hub", "followers_url": "https://api.github.com/users/Dani-Hub/followers", "following_url": "https://api.github.com/users/Dani-Hub/following{/other_user}", "gists_url": "https://api.github.com/users/Dani-Hub/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dani-Hub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dani-Hub/subscriptions", "organizations_url": "https://api.github.com/users/Dani-Hub/orgs", "repos_url": "https://api.github.com/users/Dani-Hub/repos", "events_url": "https://api.github.com/users/Dani-Hub/events{/privacy}", "received_events_url": "https://api.github.com/users/Dani-Hub/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "025735b738048b0910777555df9c5f2eff23857d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025735b738048b0910777555df9c5f2eff23857d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025735b738048b0910777555df9c5f2eff23857d"}], "stats": {"total": 519, "additions": 448, "deletions": 71}, "files": [{"sha": "0c08c091dd331b0616380a662034649dcd34995e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -1,3 +1,21 @@\n+2012-04-23  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\n+\t* include/std/type_traits (is_nothrow_destructible): Implement.\n+\t(is_destructible): Implement LWG 2049.\n+\t* testsuite/util/testsuite_tr1.h: Add tests.\n+\t* testsuite/20_util/is_nothrow_destructible/value.cc: New.\n+\t* testsuite/20_util/is_nothrow_destructible/requirements/typedefs.cc:\n+\t* testsuite/20_util/is_nothrow_destructible/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_destructible/value.cc: Adjust and extend.\n+\t* testsuite/20_util/is_default_constructible/value.cc: Tweak.\n+\t* testsuite/20_util/is_constructible/value-2.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n+\tdg-error line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\n 2012-04-23  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/53080"}, {"sha": "9232af7934c532fd1dc3352ffa40cefa712e50ca", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -594,73 +594,100 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type\n     { };\n     \n-  // In N3290 is_destructible does not say anything about function \n+  // In N3290 is_destructible does not say anything about function\n   // types and abstract types, see LWG 2049. This implementation\n-  // describes function types as trivially nothrow destructible and\n-  // abstract types as destructible, iff the  explicit destructor\n+  // describes function types as non-destructible and all complete\n+  // object types as destructible, iff the explicit destructor\n   // call expression is wellformed.\n-  struct __do_is_destructible_impl_1\n+  struct __do_is_destructible_impl\n   {\n-    template<typename _Up>\n-      struct __w { _Up __u; };\n-\n-    template<typename _Tp, typename\n-             = decltype(declval<__w<_Tp>&>().~__w<_Tp>())>\n+    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n       static true_type __test(int);\n \n     template<typename>\n       static false_type __test(...);\n   };\n \n   template<typename _Tp>\n-    struct __is_destructible_impl_1\n-    : public __do_is_destructible_impl_1\n+    struct __is_destructible_impl\n+    : public __do_is_destructible_impl\n     {\n       typedef decltype(__test<_Tp>(0)) type;\n     };\n \n-  // Special implementation for abstract types\n-  struct __do_is_destructible_impl_2\n+  template<typename _Tp,\n+           bool = __or_<is_void<_Tp>,\n+                        __is_array_unknown_bounds<_Tp>,\n+                        is_function<_Tp>>::value,\n+           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>\n+    struct __is_destructible_safe;\n+\n+  template<typename _Tp>\n+    struct __is_destructible_safe<_Tp, false, false>\n+    : public __is_destructible_impl<typename\n+               remove_all_extents<_Tp>::type>::type\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_destructible_safe<_Tp, true, false>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_destructible_safe<_Tp, false, true>\n+    : public true_type { };\n+\n+  /// is_destructible\n+  template<typename _Tp>\n+    struct is_destructible\n+    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>\n+    { };\n+\n+  // is_nothrow_destructible requires that is_destructible is\n+  // satisfied as well.  We realize that by mimicing the\n+  // implementation of is_destructible but refer to noexcept(expr)\n+  // instead of decltype(expr).\n+  struct __do_is_nt_destructible_impl\n   {\n-    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n-      static true_type __test(int);\n+    template<typename _Tp>\n+      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>\n+        __test(int);\n \n     template<typename>\n       static false_type __test(...);\n   };\n \n   template<typename _Tp>\n-    struct __is_destructible_impl_2\n-    : public __do_is_destructible_impl_2\n+    struct __is_nt_destructible_impl\n+    : public __do_is_nt_destructible_impl\n     {\n       typedef decltype(__test<_Tp>(0)) type;\n     };\n \n   template<typename _Tp,\n            bool = __or_<is_void<_Tp>,\n-                        __is_array_unknown_bounds<_Tp>>::value,\n-           bool = __or_<is_reference<_Tp>, is_function<_Tp>>::value>\n-    struct __is_destructible_safe;\n+                        __is_array_unknown_bounds<_Tp>,\n+                        is_function<_Tp>>::value,\n+           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>\n+    struct __is_nt_destructible_safe;\n \n   template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, false, false>\n-    : public conditional<is_abstract<_Tp>::value,\n-\t\t\t __is_destructible_impl_2<_Tp>,\n-                         __is_destructible_impl_1<_Tp>>::type::type\n+    struct __is_nt_destructible_safe<_Tp, false, false>\n+    : public __is_nt_destructible_impl<typename\n+               remove_all_extents<_Tp>::type>::type\n     { };\n \n   template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, true, false>\n+    struct __is_nt_destructible_safe<_Tp, true, false>\n     : public false_type { };\n \n   template<typename _Tp>\n-    struct __is_destructible_safe<_Tp, false, true>\n+    struct __is_nt_destructible_safe<_Tp, false, true>\n     : public true_type { };\n \n-  /// is_destructible\n+  /// is_nothrow_destructible\n   template<typename _Tp>\n-    struct is_destructible\n-    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>\n+    struct is_nothrow_destructible\n+    : public integral_constant<bool, (__is_nt_destructible_safe<_Tp>::value)>\n     { };\n \n   struct __do_is_default_constructible_impl"}, {"sha": "2b6757efd6993b2a45c72fbbc22c47d4e5df4d35", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1786 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1813 }\n \n #include <utility>\n "}, {"sha": "5bd0520fcda3ca46b63d5b923c3b863f16026103", "filename": "libstdc++-v3/testsuite/20_util/is_constructible/value-2.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,7 +22,7 @@\n #include <initializer_list>\n #include <testsuite_tr1.h>\n \n-using namespace __gnu_test::construct_destruct;\n+using namespace __gnu_test::construct;\n \n static_assert(std::is_constructible<int, int>::value, \"Error\");\n static_assert(std::is_constructible<std::nullptr_t, std::nullptr_t>::value,\n@@ -753,7 +753,7 @@ static_assert(!std::is_constructible<FromArgs<std::initializer_list<int>&,\n \n static_assert(!std::is_constructible<FromArgs<std::initializer_list<int>>,\n \t      int, int>::value, \"Error\");\n-static_assert(!std::is_constructible<const \n+static_assert(!std::is_constructible<const\n \t      FromArgs<std::initializer_list<int>>, int, int>::value, \"Error\");\n static_assert(!std::is_constructible<B[2], B, B>::value, \"Error\");\n static_assert(!std::is_constructible<const B[2], B, B>::value, \"Error\");"}, {"sha": "979e421587b3a04e4be836c1ce1fe3903a208a5b", "filename": "libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,7 +22,7 @@\n #include <initializer_list>\n #include <testsuite_tr1.h>\n \n-using namespace __gnu_test::construct_destruct;\n+using namespace __gnu_test::construct;\n \n static_assert(std::is_default_constructible<int>::value, \"Error\");\n static_assert(std::is_default_constructible<int const>::value, \"Error\");"}, {"sha": "b6b2b31fa29b01ef052eb575cee756993b3149ac", "filename": "libstdc++-v3/testsuite/20_util/is_destructible/value.cc", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2011 Free Software Foundation, Inc.\n+// Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -22,49 +22,53 @@\n #include <initializer_list>\n #include <testsuite_tr1.h>\n \n-using namespace __gnu_test::construct_destruct;\n+using namespace __gnu_test::destruct;\n \n static_assert(std::is_destructible<int>::value, \"Error\");\n static_assert(std::is_destructible<const int>::value, \"Error\");\n static_assert(std::is_destructible<bool>::value, \"Error\");\n static_assert(std::is_destructible<const bool>::value, \"Error\");\n static_assert(std::is_destructible<int*>::value, \"Error\");\n static_assert(std::is_destructible<void*>::value, \"Error\");\n-static_assert(std::is_destructible<int B::*>::value, \"Error\");\n-static_assert(std::is_destructible<const int D::*>::value, \"Error\");\n-static_assert(std::is_destructible<E>::value, \"Error\");\n-static_assert(std::is_destructible<const E>::value, \"Error\");\n-static_assert(std::is_destructible<SE>::value, \"Error\");\n-static_assert(std::is_destructible<const SE>::value, \"Error\");\n+static_assert(std::is_destructible<int Der::*>::value, \"Error\");\n+static_assert(std::is_destructible<const int Der::*>::value, \"Error\");\n+static_assert(std::is_destructible<void (Der::*)() const>::value, \"Error\");\n+static_assert(std::is_destructible<void(*)()>::value, \"Error\");\n+static_assert(std::is_destructible<En>::value, \"Error\");\n+static_assert(std::is_destructible<const En>::value, \"Error\");\n+static_assert(std::is_destructible<En2>::value, \"Error\");\n+static_assert(std::is_destructible<const En2>::value, \"Error\");\n static_assert(std::is_destructible<OpE>::value, \"Error\");\n static_assert(std::is_destructible<const OpE>::value, \"Error\");\n static_assert(std::is_destructible<OpSE>::value, \"Error\");\n static_assert(std::is_destructible<const OpSE>::value, \"Error\");\n static_assert(std::is_destructible<std::nullptr_t>::value, \"Error\");\n static_assert(std::is_destructible<const std::nullptr_t>::value, \"Error\");\n-static_assert(std::is_destructible<B>::value, \"Error\");\n-static_assert(std::is_destructible<const B>::value, \"Error\");\n-static_assert(std::is_destructible<D>::value, \"Error\");\n-static_assert(std::is_destructible<const D>::value, \"Error\");\n-static_assert(std::is_destructible<Empty>::value, \"Error\");\n-static_assert(std::is_destructible<const Empty>::value, \"Error\");\n-static_assert(std::is_destructible<U>::value, \"Error\");\n-static_assert(std::is_destructible<const U>::value, \"Error\");\n-static_assert(std::is_destructible<Abstract>::value, \"Error\");\n-static_assert(std::is_destructible<const Abstract>::value, \"Error\");\n+static_assert(std::is_destructible<Der>::value, \"Error\");\n+static_assert(std::is_destructible<const Der>::value, \"Error\");\n+static_assert(std::is_destructible<Aggr>::value, \"Error\");\n+static_assert(std::is_destructible<const Aggr>::value, \"Error\");\n+static_assert(std::is_destructible<E>::value, \"Error\");\n+static_assert(std::is_destructible<const E>::value, \"Error\");\n+static_assert(std::is_destructible<U1>::value, \"Error\");\n+static_assert(std::is_destructible<const U1>::value, \"Error\");\n+static_assert(std::is_destructible<Abstract1>::value, \"Error\");\n+static_assert(std::is_destructible<const Abstract1>::value, \"Error\");\n static_assert(std::is_destructible<int[1]>::value, \"Error\");\n static_assert(std::is_destructible<const int[1]>::value, \"Error\");\n static_assert(std::is_destructible<int[1][2]>::value, \"Error\");\n static_assert(std::is_destructible<const int[1][2]>::value, \"Error\");\n static_assert(std::is_destructible<int&>::value, \"Error\");\n static_assert(std::is_destructible<int&&>::value, \"Error\");\n+static_assert(std::is_destructible<int(&)[1]>::value, \"Error\");\n+static_assert(std::is_destructible<const int(&)[1]>::value, \"Error\");\n static_assert(std::is_destructible<void(&)()>::value, \"Error\");\n static_assert(std::is_destructible<Ellipsis>::value, \"Error\");\n static_assert(std::is_destructible<const Ellipsis>::value, \"Error\");\n-static_assert(std::is_destructible<Any>::value, \"Error\");\n-static_assert(std::is_destructible<const Any>::value, \"Error\");\n-static_assert(std::is_destructible<nAny>::value, \"Error\");\n-static_assert(std::is_destructible<const nAny>::value, \"Error\");\n+static_assert(std::is_destructible<Abstract2>::value, \"Error\");\n+static_assert(std::is_destructible<const Abstract2>::value, \"Error\");\n+static_assert(std::is_destructible<Aggr2>::value, \"Error\");\n+static_assert(std::is_destructible<const Aggr2>::value, \"Error\");\n static_assert(std::is_destructible<DelDef>::value, \"Error\");\n static_assert(std::is_destructible<const DelDef>::value, \"Error\");\n static_assert(std::is_destructible<DelCopy>::value, \"Error\");\n@@ -75,23 +79,25 @@ static_assert(std::is_destructible<std::initializer_list<int>>::value,\n \t      \"Error\");\n static_assert(std::is_destructible<const std::initializer_list<int>>::value,\n \t      \"Error\");\n-static_assert(std::is_destructible<void()>::value, \"Error\");\n-static_assert(std::is_destructible<void() const>::value, \"Error\");\n+static_assert(std::is_destructible<std::initializer_list<Del>>::value,\n+\t      \"Error\");\n \n static_assert(!std::is_destructible<void>::value, \"Error\");\n static_assert(!std::is_destructible<const void>::value, \"Error\");\n+static_assert(!std::is_destructible<void()>::value, \"Error\");\n+static_assert(!std::is_destructible<void() const>::value, \"Error\");\n static_assert(!std::is_destructible<int[]>::value, \"Error\");\n static_assert(!std::is_destructible<const int[]>::value, \"Error\");\n-static_assert(!std::is_destructible<DelDtor>::value, \"Error\");\n-static_assert(!std::is_destructible<const DelDtor>::value, \"Error\");\n+static_assert(!std::is_destructible<Del>::value, \"Error\");\n+static_assert(!std::is_destructible<const Del>::value, \"Error\");\n static_assert(!std::is_destructible<AbstractDelDtor>::value, \"Error\");\n static_assert(!std::is_destructible<const AbstractDelDtor>::value, \"Error\");\n static_assert(!std::is_destructible<int[][1]>::value, \"Error\");\n static_assert(!std::is_destructible<const int[][1]>::value, \"Error\");\n-static_assert(!std::is_destructible<DelDtor[1]>::value, \"Error\");\n-static_assert(!std::is_destructible<const DelDtor[1]>::value, \"Error\");\n-static_assert(!std::is_destructible<DelDtor[]>::value, \"Error\");\n-static_assert(!std::is_destructible<const DelDtor[]>::value, \"Error\");\n+static_assert(!std::is_destructible<Del[1]>::value, \"Error\");\n+static_assert(!std::is_destructible<const Del[1]>::value, \"Error\");\n+static_assert(!std::is_destructible<Del[]>::value, \"Error\");\n+static_assert(!std::is_destructible<const Del[]>::value, \"Error\");\n \n // Deleted members in unions with non-trivial members:\n static_assert(!std::is_destructible<NontrivialUnion>::value, \"Error\");"}, {"sha": "3b43f9193225b6eb5e6772fc0e35dc470e687386", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_destructible/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Fexplicit_instantiation.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_nothrow_destructible<test_type>;\n+}"}, {"sha": "c2343fa82cfe5548f0a8b30bf25629a1c9163e43", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_destructible/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Frequirements%2Ftypedefs.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_nothrow_destructible<int>   test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "af9771915a0a9354ee884195e8964fd4f4836f9d", "filename": "libstdc++-v3/testsuite/20_util/is_nothrow_destructible/value.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_nothrow_destructible%2Fvalue.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -0,0 +1,112 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test::destruct;\n+\n+// is_nothrow_destructible:\n+static_assert(std::is_nothrow_destructible<int>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const int>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const volatile int>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<int[12]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const int[12]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const volatile int[12]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<decltype(nullptr)>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<std::initializer_list<int>>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<std::initializer_list<decltype(nullptr)>>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<std::initializer_list<TD1>>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<std::initializer_list<TD2>>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<E>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const E>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<const volatile E>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<NTD1>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<NTD2>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<NTD3>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Aggr>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<U1>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<void(*)()>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<void*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<int&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD1&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD2&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD1*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD2*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<void(&)()>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<void(&&)()>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En2>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En2*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<En2&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD1(&)(Aggr2, TD2)>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<TD1(*)(Aggr2, TD2)>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Abstract1>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Der>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del2&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del3&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del(&)[1]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del2(&)[2]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del3(&)[3]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del&&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del2&&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del3&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del(&&)[1]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del2(&&)[2]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Del3(&&)[3]>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Ut&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Ut&&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Ut*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Abstract2&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Abstract3&>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Abstract2*>::value, \"Error\");\n+static_assert(std::is_nothrow_destructible<Abstract3*>::value, \"Error\");\n+\n+static_assert(!std::is_nothrow_destructible<void>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<const void>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<void()>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<void() const>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<TD1(Aggr2, TD2)>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<int[]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<const int[]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<const volatile int[]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<int[][123]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<TD1>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<TD2>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Aggr2>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Aggr2[1]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<TD1[1][2]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Ut>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Ut[3]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<AbstractDelDtor>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Abstract2>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Abstract3>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Der2>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del2>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del3>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del[1]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del2[2]>::value, \"Error\");\n+static_assert(!std::is_nothrow_destructible<Del3[3]>::value, \"Error\");\n+"}, {"sha": "1c68fac6b6e78713f8ed529a25206e4adfc54437", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -49,5 +49,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 43 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1575 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1539 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1602 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1566 }"}, {"sha": "a41e5e61a157c23bbe9ecd8bf429548bdbc420eb", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -49,5 +49,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 43 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1493 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1457 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1520 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1484 }"}, {"sha": "083574e27ceef53c66adccd214851eb7b32e115c", "filename": "libstdc++-v3/testsuite/util/testsuite_tr1.h", "status": "modified", "additions": 151, "deletions": 2, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62fa805ffa7ed1794662a00ff0871ebb6e568a80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h?ref=62fa805ffa7ed1794662a00ff0871ebb6e568a80", "patch": "@@ -1,7 +1,7 @@\n // -*- C++ -*-\n // Testing utilities for the tr1 testsuite.\n //\n-// Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011\n+// Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011, 2012\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -404,7 +404,7 @@ namespace __gnu_test\n     { return true; }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-  namespace construct_destruct\n+  namespace construct\n   {\n     struct Empty {};\n \n@@ -526,6 +526,155 @@ namespace __gnu_test\n     };\n   }\n \n+  namespace destruct\n+  {\n+    struct E\n+    {};\n+    \n+    struct NTD1\n+    {\n+      ~NTD1() = default;\n+    };\n+    \n+    struct NTD2\n+    {\n+      ~NTD2();\n+    };\n+    \n+    struct NTD3\n+    {\n+      ~NTD3() throw();\n+    };\n+    \n+    struct TD1\n+    {\n+      ~TD1() noexcept(false);\n+    };\n+    \n+    struct TD2\n+    {\n+      ~TD2() throw(int);\n+    };\n+    \n+    struct Aggr\n+    {\n+      int i;\n+      bool b;\n+      E e;\n+    };\n+    \n+    struct Aggr2\n+    {\n+      int i;\n+      bool b;\n+      TD1 r;\n+    };\n+    \n+    struct Del\n+    {\n+      ~Del() = delete;\n+    };\n+    \n+    struct Del2\n+    {\n+      ~Del2() noexcept = delete;\n+    };\n+    \n+    struct Del3\n+    {\n+      ~Del3() noexcept(false) = delete;\n+    };\n+    \n+    struct Der : Aggr\n+    {};\n+    \n+    struct Der2 : Aggr2\n+    {};\n+    \n+    union U1\n+    {\n+      int i;\n+      double d;\n+      void* p;\n+      TD1* pt;\n+    };\n+    \n+    union Ut\n+    {\n+      int i;\n+      double d;\n+      void* p;\n+      TD1 pt;\n+    };\n+    \n+    enum class En { a, b, c, d };\n+    enum En2 { En2a, En2b, En2c, En2d };\n+\n+    enum OpE : int;\n+    enum class OpSE : bool;\n+\n+    struct Abstract1\n+    {\n+      virtual ~Abstract1() = 0;\n+    };\n+    \n+    struct AbstractDelDtor\n+    {\n+      ~AbstractDelDtor() = delete;\n+      virtual void foo() = 0;\n+    };\n+\n+    struct Abstract2\n+    {\n+      virtual ~Abstract2() noexcept(false) = 0;\n+    };\n+    \n+    struct Abstract3\n+    {\n+      ~Abstract3() noexcept(false);\n+      virtual void foo() noexcept = 0;\n+    };\n+\n+    struct Nontrivial\n+    {\n+      Nontrivial();\n+      Nontrivial(const Nontrivial&);\n+      Nontrivial& operator=(const Nontrivial&);\n+      ~Nontrivial();\n+    };\n+\n+    union NontrivialUnion\n+    {\n+      int i;\n+      Nontrivial n;\n+    };\n+\n+    struct UnusualCopy\n+    {\n+      UnusualCopy(UnusualCopy&);\n+    };\n+\n+    struct Ellipsis\n+    {\n+      Ellipsis(...){}\n+    };\n+\n+    struct DelEllipsis\n+    {\n+      DelEllipsis(...) = delete;\n+    };\n+\n+    struct DelDef\n+    {\n+      DelDef() = delete;\n+    };\n+\n+    struct DelCopy\n+    {\n+      DelCopy(const DelCopy&) = delete;\n+    };\n+  }\n+  \n   namespace assign\n   {\n     struct Empty {};"}]}