{"sha": "b5040344b9ca609e19ee59ba56cd4af9697a1692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUwNDAzNDRiOWNhNjA5ZTE5ZWU1OWJhNTZjZDRhZjk2OTdhMTY5Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-03T08:53:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-03T08:53:58Z"}, "message": "dwarf2out: Fix -gsplit-dwarf on riscv or other non-.uleb128 targets [PR99090]\n\nAs mentioned in the PR, riscv* only supports .uleb128 with constant\narguments, doesn't support difference of two labels because of aggressive\nlinker relaxations.  But I bet various other targets, especially those not\nusing GNU assembler, might suffer from the same problem.\nAs the FIXME comment in output_loc_list indicates, we ICE on\n-gsplit-dwarf on those targets whenever we need .debug_loclists, because\nwe only emit DW_LLE_startx_length which requires working .uleb128 delta\nof 2 code section labels.  We can't use DW_LLE_base_addressx\nonce followed by DW_LLE_offset_pair either because the latter suffers\nfrom the same issue - need .uleb128 difference of code section labels\n(and in that case not just for the second operand but also for the first).\n\nSo, this patch implements what the comment said and emits DW_LLE_startx_endx\ninstead, which wastes more space in .debug_addr, but will work.\n\nBootstrapped/regtested on x86_64-linux and i686-linux and as written in the\nPR, Jim has tested it on riscv*linux.  Ok for trunk?\n\nBTW, for HAVE_AS_LEB128 -gdwarf-5 -gsplit-dwarf, maybe we should consider\ninstead of always emitting DW_LLE_startx_length do all the optimizations\nthat we do for HAVE_AS_LEB128 -gdwarf-5, or at least a subset of them.\nFor !have_multiple_function_sections, we in that case emit just\nDW_LLE_offset_pair (that can certainly be a win for small TUs, we wouldn't\nneed any .debug_addr entry in that case; on the other side, just using\nDW_LLE_offset_pair can be harmful for very large TUs especially if the\nloclist has many entries, emitting in that case a single DW_LLE_base_address\nor for -gsplit-dwarf DW_LLE_base_addressx followed by DW_LLE_offset_pair\nmight be much smaller), and for have_multiple_function_sections figuring\nout if DW_LLE_base_address followed by DW_LLE_offset_pair entries\nor DW_LLE_start_length is bettter.  So perhaps a middle-ground for\n-gsplit-dwarf would be to always do the have_multiple_function_sections\nbehavior, i.e. DW_LLE_base_addressx followed by DW_LLE_offset_pair vs.\nDW_LLE_startx_length decisions based on the ranges and their counts.\nAnd perhaps dwz could optimize afterwards, on linked binaries or shared\nlibraries it knows all the offsets and could figure out optimal DW_LLE_*.\n\n2021-03-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/99090\n\t* dwarf2out.c (dw_loc_list_struct): Add end_entry member.\n\t(new_loc_list): Clear end_entry.\n\t(output_loc_list): Only use DW_LLE_startx_length for -gsplit-dwarf\n\tif HAVE_AS_LEB128, otherwise use DW_LLE_startx_endx.  Fix comment\n\ttypo.\n\t(index_location_lists): For dwarf_version >= 5 without HAVE_AS_LEB128,\n\tinitialize also end_entry.", "tree": {"sha": "050224af3060244cdd5046463d77ad5ef974e7bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/050224af3060244cdd5046463d77ad5ef974e7bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5040344b9ca609e19ee59ba56cd4af9697a1692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5040344b9ca609e19ee59ba56cd4af9697a1692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5040344b9ca609e19ee59ba56cd4af9697a1692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5040344b9ca609e19ee59ba56cd4af9697a1692/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ad5b1915d50cc39691487f58794d699c7900ace", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad5b1915d50cc39691487f58794d699c7900ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ad5b1915d50cc39691487f58794d699c7900ace"}], "stats": {"total": 31, "additions": 24, "deletions": 7}, "files": [{"sha": "b3ca159c3a8c377084189a2dedecf245b8c69703", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5040344b9ca609e19ee59ba56cd4af9697a1692/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5040344b9ca609e19ee59ba56cd4af9697a1692/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b5040344b9ca609e19ee59ba56cd4af9697a1692", "patch": "@@ -1317,6 +1317,7 @@ typedef struct GTY(()) dw_loc_list_struct {\n   const char *begin; /* Label and addr_entry for start of range */\n   addr_table_entry *begin_entry;\n   const char *end;  /* Label for end of range */\n+  addr_table_entry *end_entry;\n   char *ll_symbol; /* Label for beginning of location list.\n \t\t      Only on head of list.  */\n   char *vl_symbol; /* Label for beginning of view list.  Ditto.  */\n@@ -10101,6 +10102,7 @@ new_loc_list (dw_loc_descr_ref expr, const char *begin, var_loc_view vbegin,\n   retlist->begin = begin;\n   retlist->begin_entry = NULL;\n   retlist->end = end;\n+  retlist->end_entry = NULL;\n   retlist->expr = expr;\n   retlist->section = section;\n   retlist->vbegin = vbegin;\n@@ -10327,24 +10329,37 @@ output_loc_list (dw_loc_list_ref list_head)\n \n       if (dwarf_version >= 5)\n \t{\n-\t  if (dwarf_split_debug_info)\n+\t  if (dwarf_split_debug_info && HAVE_AS_LEB128)\n \t    {\n \t      dwarf2out_maybe_output_loclist_view_pair (curr);\n-\t      /* For -gsplit-dwarf, emit DW_LLE_starx_length, which has\n+\t      /* For -gsplit-dwarf, emit DW_LLE_startx_length, which has\n \t\t uleb128 index into .debug_addr and uleb128 length.  */\n \t      dw2_asm_output_data (1, DW_LLE_startx_length,\n \t\t\t\t   \"DW_LLE_startx_length (%s)\",\n \t\t\t\t   list_head->ll_symbol);\n \t      dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n \t\t\t\t\t   \"Location list range start index \"\n \t\t\t\t\t   \"(%s)\", curr->begin);\n-\t      /* FIXME: This will ICE ifndef HAVE_AS_LEB128.\n-\t\t For that case we probably need to emit DW_LLE_startx_endx,\n-\t\t but we'd need 2 .debug_addr entries rather than just one.  */\n \t      dw2_asm_output_delta_uleb128 (curr->end, curr->begin,\n \t\t\t\t\t    \"Location list length (%s)\",\n \t\t\t\t\t    list_head->ll_symbol);\n \t    }\n+\t  else if (dwarf_split_debug_info)\n+\t    {\n+\t      dwarf2out_maybe_output_loclist_view_pair (curr);\n+\t      /* For -gsplit-dwarf without usable .uleb128 support, emit\n+\t\t DW_LLE_startx_endx, which has two uleb128 indexes into\n+\t\t .debug_addr.  */\n+\t      dw2_asm_output_data (1, DW_LLE_startx_endx,\n+\t\t\t\t   \"DW_LLE_startx_endx (%s)\",\n+\t\t\t\t   list_head->ll_symbol);\n+\t      dw2_asm_output_data_uleb128 (curr->begin_entry->index,\n+\t\t\t\t\t   \"Location list range start index \"\n+\t\t\t\t\t   \"(%s)\", curr->begin);\n+\t      dw2_asm_output_data_uleb128 (curr->end_entry->index,\n+\t\t\t\t\t   \"Location list range end index \"\n+\t\t\t\t\t   \"(%s)\", curr->end);\n+\t    }\n \t  else if (!have_multiple_function_sections && HAVE_AS_LEB128)\n \t    {\n \t      dwarf2out_maybe_output_loclist_view_pair (curr);\n@@ -31301,12 +31316,14 @@ index_location_lists (dw_die_ref die)\n \t       to the hash table.  In the rare case of DWARF[234] >= 64KB\n \t       location expression, we'll just waste unused address table entry\n \t       for it.  */\n-            if (curr->begin_entry != NULL\n-                || skip_loc_list_entry (curr))\n+\t    if (curr->begin_entry != NULL || skip_loc_list_entry (curr))\n               continue;\n \n             curr->begin_entry\n \t      = add_addr_table_entry (xstrdup (curr->begin), ate_kind_label);\n+\t    if (dwarf_version >= 5 && !HAVE_AS_LEB128)\n+\t      curr->end_entry\n+\t\t= add_addr_table_entry (xstrdup (curr->end), ate_kind_label);\n           }\n       }\n "}]}