{"sha": "2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyYWE3NGQxZGYwN2NiZTI0NzM5ZGRkN2QwZmNiMTc1NDc5YmI4Nw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-05-04T09:36:50Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-05-04T09:36:50Z"}, "message": "rs6000: Remove Xilinx FP\n\nThis removes the special Xilinx FP support.  It was deprecated in\nGCC 8.\n\nAfter this patch all of TARGET_{DOUBLE,SINGLE}_FLOAT,\nTARGET_{DF,SF}_INSN, and TARGET_{DF,SF}_FPR are replaced by\nTARGET_HARD_FLOAT.  Also the fp_type attribute is deleted.\n\n\n\t* common/config/rs6000/rs6000-common.c (rs6000_handle_option): Remove\n\tXilinx FP support.\n\t* config.gcc (powerpc-xilinx-eabi*): Remove.\n\t* config/rs6000/predicates.md (easy_fp_constant): Remove Xilinx FP\n\tsupport.\n\t(fusion_addis_mem_combo_load): Ditto.\n\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Remove Xilinx\n\tFP support.\n\t(rs6000_cpu_cpp_builtins): Ditto.\n\t* config/rs6000/rs6000-linux.c\n\t(rs6000_linux_float_exceptions_rounding_supported_p): Ditto.\n\t* config/rs6000/rs6000-opts.h (enum fpu_type_t): Delete.\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Remove Xilinx FP\n\tsupport.\n\t(rs6000_setup_reg_addr_masks): Ditto.\n\t(rs6000_init_hard_regno_mode_ok): Ditto.\n\t(rs6000_option_override_internal): Ditto.\n\t(legitimate_lo_sum_address_p): Ditto.\n\t(rs6000_legitimize_address): Ditto.\n\t(rs6000_legitimize_reload_address): Ditto.\n\t(rs6000_legitimate_address_p): Ditto.\n\t(abi_v4_pass_in_fpr): Ditto.\n\t(setup_incoming_varargs): Ditto.\n\t(rs6000_gimplify_va_arg): Ditto.\n\t(rs6000_split_multireg_move): Ditto.\n\t(rs6000_savres_strategy): Ditto.\n\t(rs6000_emit_prologue_components): Ditto.\n\t(rs6000_emit_epilogue_components): Ditto.\n\t(rs6000_emit_prologue): Ditto.\n\t(rs6000_emit_epilogue): Ditto.\n\t(rs6000_elf_file_end): Ditto.\n\t(rs6000_function_value): Ditto.\n\t(rs6000_libcall_value): Ditto.\n\t* config/rs6000/rs6000.h: Ditto.\n\t(TARGET_MINMAX_SF, TARGET_MINMAX_DF): Delete, merge to ...\n\t(TARGET_MINMAX): ... this.  New.\n\t(TARGET_SF_FPR, TARGET_DF_FPR, TARGET_SF_INSN, TARGET_DF_INSN): Delete.\n\t* config/rs6000/rs6000.md: Remove Xilinx FP support.\n\t(*movsi_internal1_single): Delete.\n\t* config/rs6000/rs6000.opt (msingle-float, mdouble-float, msimple-fpu,\n\tmfpu=, mxilinx-fpu): Delete.\n\t* config/rs6000/singlefp.h: Delete.\n\t* config/rs6000/sysv4.h: Remove Xilinx FP support.\n\t* config/rs6000/t-rs6000: Ditto.\n\t* config/rs6000/t-xilinx: Delete.\n\t* gcc/config/rs6000/titan.md: Adjust for fp_type removal.\n\t* gcc/config/rs6000/vsx.md: Remove Xilinx FP support.\n\t(VStype_simple): Delete.\n\t(VSfptype_simple, VSfptype_mul, VSfptype_div, VSfptype_sqrt): Delete.\n\t* config/rs6000/xfpu.h: Delete.\n\t* config/rs6000/xfpu.md: Delete.\n\t* config/rs6000/xilinx.h: Delete.\n\t* config/rs6000/xilinx.opt: Delete.\n\t* gcc/doc/invoke.texi (RS/6000 and PowerPC Options): Remove\n\t-msingle-float, -mdouble-float, -msimple-fpu, -mfpu=, and -mxilinx-fpu.\n\nFrom-SVN: r259929", "tree": {"sha": "e2aba505d5214104d637fb85126fb210f780bd5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2aba505d5214104d637fb85126fb210f780bd5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ed6b074f71f423e0ffc7307228a98d0d194b8a"}], "stats": {"total": 1111, "additions": 255, "deletions": 856}, "files": [{"sha": "09af7f346d3d328b3397c2e435f00a3e1d084523", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -1,3 +1,61 @@\n+2018-05-04  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* common/config/rs6000/rs6000-common.c (rs6000_handle_option): Remove\n+\tXilinx FP support.\n+\t* config.gcc (powerpc-xilinx-eabi*): Remove.\n+\t* config/rs6000/predicates.md (easy_fp_constant): Remove Xilinx FP\n+\tsupport.\n+\t(fusion_addis_mem_combo_load): Ditto.\n+\t* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Remove Xilinx\n+\tFP support.\n+\t(rs6000_cpu_cpp_builtins): Ditto.\n+\t* config/rs6000/rs6000-linux.c\n+\t(rs6000_linux_float_exceptions_rounding_supported_p): Ditto.\n+\t* config/rs6000/rs6000-opts.h (enum fpu_type_t): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Remove Xilinx FP\n+\tsupport.\n+\t(rs6000_setup_reg_addr_masks): Ditto.\n+\t(rs6000_init_hard_regno_mode_ok): Ditto.\n+\t(rs6000_option_override_internal): Ditto.\n+\t(legitimate_lo_sum_address_p): Ditto.\n+\t(rs6000_legitimize_address): Ditto.\n+\t(rs6000_legitimize_reload_address): Ditto.\n+\t(rs6000_legitimate_address_p): Ditto.\n+\t(abi_v4_pass_in_fpr): Ditto.\n+\t(setup_incoming_varargs): Ditto.\n+\t(rs6000_gimplify_va_arg): Ditto.\n+\t(rs6000_split_multireg_move): Ditto.\n+\t(rs6000_savres_strategy): Ditto.\n+\t(rs6000_emit_prologue_components): Ditto.\n+\t(rs6000_emit_epilogue_components): Ditto.\n+\t(rs6000_emit_prologue): Ditto.\n+\t(rs6000_emit_epilogue): Ditto.\n+\t(rs6000_elf_file_end): Ditto.\n+\t(rs6000_function_value): Ditto.\n+\t(rs6000_libcall_value): Ditto.\n+\t* config/rs6000/rs6000.h: Ditto.\n+\t(TARGET_MINMAX_SF, TARGET_MINMAX_DF): Delete, merge to ...\n+\t(TARGET_MINMAX): ... this.  New.\n+\t(TARGET_SF_FPR, TARGET_DF_FPR, TARGET_SF_INSN, TARGET_DF_INSN): Delete.\n+\t* config/rs6000/rs6000.md: Remove Xilinx FP support.\n+\t(*movsi_internal1_single): Delete.\n+\t* config/rs6000/rs6000.opt (msingle-float, mdouble-float, msimple-fpu,\n+\tmfpu=, mxilinx-fpu): Delete.\n+\t* config/rs6000/singlefp.h: Delete.\n+\t* config/rs6000/sysv4.h: Remove Xilinx FP support.\n+\t* config/rs6000/t-rs6000: Ditto.\n+\t* config/rs6000/t-xilinx: Delete.\n+\t* gcc/config/rs6000/titan.md: Adjust for fp_type removal.\n+\t* gcc/config/rs6000/vsx.md: Remove Xilinx FP support.\n+\t(VStype_simple): Delete.\n+\t(VSfptype_simple, VSfptype_mul, VSfptype_div, VSfptype_sqrt): Delete.\n+\t* config/rs6000/xfpu.h: Delete.\n+\t* config/rs6000/xfpu.md: Delete.\n+\t* config/rs6000/xilinx.h: Delete.\n+\t* config/rs6000/xilinx.opt: Delete.\n+\t* gcc/doc/invoke.texi (RS/6000 and PowerPC Options): Remove\n+\t-msingle-float, -mdouble-float, -msimple-fpu, -mfpu=, and -mxilinx-fpu.\n+\n 2018-05-04  Tom de Vries  <tom@codesourcery.com>\n \n \tPR libgomp/85639"}, {"sha": "c4e77a272c9f2d7eabb19548a4e69701548d085a", "filename": "gcc/common/config/rs6000/rs6000-common.c", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -83,7 +83,6 @@ rs6000_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\t      const struct cl_decoded_option *decoded,\n \t\t      location_t loc)\n {\n-  enum fpu_type_t fpu_type = FPU_NONE;\n   char *p, *q;\n   size_t code = decoded->opt_index;\n   const char *arg = decoded->arg;\n@@ -225,63 +224,6 @@ rs6000_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t}\n       break;\n \n-    case OPT_msingle_float:\n-      if (!TARGET_SINGLE_FPU) \n-\twarning_at (loc, 0,\n-\t\t    \"-msingle-float option equivalent to -mhard-float\");\n-      /* -msingle-float implies -mno-double-float and TARGET_HARD_FLOAT. */\n-      opts->x_rs6000_double_float = 0;\n-      opts->x_rs6000_isa_flags &= ~OPTION_MASK_SOFT_FLOAT;\n-      opts_set->x_rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;\n-      break;\n-\n-    case OPT_mdouble_float:\n-      /* -mdouble-float implies -msingle-float and TARGET_HARD_FLOAT. */\n-      opts->x_rs6000_single_float = 1;\n-      opts->x_rs6000_isa_flags &= ~OPTION_MASK_SOFT_FLOAT;\n-      opts_set->x_rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;\n-      break;\n-\n-    case OPT_msimple_fpu:\n-      if (!TARGET_SINGLE_FPU) \n-\twarning_at (loc, 0, \"-msimple-fpu option ignored\");\n-      break;\n-\n-    case OPT_mhard_float:\n-      /* -mhard_float implies -msingle-float and -mdouble-float. */\n-      opts->x_rs6000_single_float = opts->x_rs6000_double_float = 1;\n-      break;\n-\n-    case OPT_msoft_float:\n-      /* -msoft_float implies -mnosingle-float and -mnodouble-float. */\n-      opts->x_rs6000_single_float = opts->x_rs6000_double_float = 0;\n-      break;\n-\n-    case OPT_mfpu_:\n-      fpu_type = (enum fpu_type_t) value;\n-      if (fpu_type != FPU_NONE)\n-\t{\n-\t  /* If -mfpu is not none, then turn off SOFT_FLOAT, turn on\n-\t     HARD_FLOAT. */\n-\t  opts->x_rs6000_isa_flags &= ~OPTION_MASK_SOFT_FLOAT;\n-\t  opts_set->x_rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;\n-\t  opts->x_rs6000_xilinx_fpu = 1;\n-\t  if (fpu_type == FPU_SF_LITE || fpu_type == FPU_SF_FULL) \n-\t    opts->x_rs6000_single_float = 1;\n-\t  if (fpu_type == FPU_DF_LITE || fpu_type == FPU_DF_FULL) \n-\t    opts->x_rs6000_single_float = opts->x_rs6000_double_float = 1;\n-\t  if (fpu_type == FPU_SF_LITE || fpu_type == FPU_DF_LITE) \n-\t    opts->x_rs6000_simple_fpu = 1;\n-\t}\n-      else\n-\t{\n-\t  /* -mfpu=none is equivalent to -msoft-float.  */\n-\t  opts->x_rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;\n-\t  opts_set->x_rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;\n-\t  opts->x_rs6000_single_float = opts->x_rs6000_double_float = 0;\n-\t}\n-      break;\n-\n     case OPT_mrecip:\n       opts->x_rs6000_recip_name = (value) ? \"default\" : \"none\";\n       break;"}, {"sha": "8741dd1e3b2485c681d5265fc309424a3f790d2a", "filename": "gcc/config.gcc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -2451,12 +2451,6 @@ powerpc-*-eabialtivec*)\n \ttmake_file=\"rs6000/t-fprules rs6000/t-ppcendian rs6000/t-ppccomm\"\n \tuse_gcc_stdint=wrap\n \t;;\n-powerpc-xilinx-eabi*)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/singlefp.h rs6000/xfpu.h rs6000/xilinx.h\"\n-\textra_options=\"${extra_options} rs6000/sysv4.opt rs6000/xilinx.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm rs6000/t-xilinx\"\n-\tuse_gcc_stdint=wrap\n-\t;;\n powerpc-*-eabi*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\""}, {"sha": "018b5f95f6bf424312380dcf84246b6bfc9cd55a", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -611,9 +611,7 @@\n     return 0;\n \n   /* Consider all constants with -msoft-float to be easy.  */\n-  if ((TARGET_SOFT_FLOAT\n-      || (TARGET_HARD_FLOAT && (TARGET_SINGLE_FLOAT && ! TARGET_DOUBLE_FLOAT)))\n-      && mode != DImode)\n+  if (TARGET_SOFT_FLOAT && mode != DImode)\n     return 1;\n \n   /* 0.0D is not all zero bits.  */\n@@ -1835,7 +1833,7 @@\n        DFmode in 32-bit if -msoft-float since it splits into two separate\n        instructions.  */\n     case E_DFmode:\n-      if ((!TARGET_POWERPC64 && !TARGET_DF_FPR) || !TARGET_P9_FUSION)\n+      if ((!TARGET_POWERPC64 && !TARGET_HARD_FLOAT) || !TARGET_P9_FUSION)\n \treturn 0;\n       break;\n \n@@ -1895,7 +1893,7 @@\n        into two separate instructions.  Do allow fusion if we have hardware\n        floating point.  */\n     case E_DFmode:\n-      if (!TARGET_POWERPC64 && !TARGET_DF_FPR)\n+      if (!TARGET_POWERPC64 && !TARGET_HARD_FLOAT)\n \treturn 0;\n       break;\n "}, {"sha": "0a850a35fa3088a390f4e82705fb94c231c492ff", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -490,8 +490,7 @@ rs6000_target_modify_macros (bool define_p, HOST_WIDE_INT flags,\n      the following conditions:\n      1. The operating system does not support saving of AltiVec\n \tregisters (OS_MISSING_ALTIVEC).\n-     2. If any of the options TARGET_HARD_FLOAT, TARGET_SINGLE_FLOAT,\n-\tor TARGET_DOUBLE_FLOAT are turned off.  Hereafter, the\n+     2. If the option TARGET_HARD_FLOAT is turned off.  Hereafter, the\n \tOPTION_MASK_VSX flag is considered to have been turned off\n \texplicitly.\n      3. If TARGET_AVOID_XFORM is turned on explicitly at the outermost\n@@ -635,7 +634,7 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n \t  cpp_get_callbacks (pfile)->macro_to_expand = rs6000_macro_to_expand;\n \t}\n     }\n-  if (!TARGET_HARD_FLOAT || !TARGET_DOUBLE_FLOAT)\n+  if (!TARGET_HARD_FLOAT)\n     builtin_define (\"_SOFT_DOUBLE\");\n   /* Used by lwarx/stwcx. errata work-around.  */\n   if (rs6000_cpu == PROCESSOR_PPC405)\n@@ -766,26 +765,6 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n       || DEFAULT_ABI == ABI_ELFv2\n       || (DEFAULT_ABI == ABI_AIX && !rs6000_compat_align_parm))\n     builtin_define (\"__STRUCT_PARM_ALIGN__=16\");\n-\n-  /* Generate defines for Xilinx FPU. */\n-  if (rs6000_xilinx_fpu) \n-    {\n-      builtin_define (\"_XFPU\");\n-      if (rs6000_single_float && ! rs6000_double_float)\n-\t{\n-\t  if (rs6000_simple_fpu) \n-\t    builtin_define (\"_XFPU_SP_LITE\"); \n-\t  else \n-\t    builtin_define (\"_XFPU_SP_FULL\");\n-\t}\n-      if (rs6000_double_float)\n-\t{\n-\t  if (rs6000_simple_fpu) \n-\t    builtin_define (\"_XFPU_DP_LITE\");\n-\t  else\n-\t    builtin_define (\"_XFPU_DP_FULL\");\n-        }\n-    }\n }\n \n \f"}, {"sha": "da1f823290a439298e366626382161a977c65ea7", "filename": "gcc/config/rs6000/rs6000-linux.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-linux.c?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -34,5 +34,5 @@ rs6000_linux_float_exceptions_rounding_supported_p (void)\n   if (OPTION_GLIBC)\n     return true;\n   else\n-    return TARGET_DF_INSN;\n+    return TARGET_HARD_FLOAT;\n }"}, {"sha": "bd0eea32cc5a8cfefb99591a6742ba4da0fe5941", "filename": "gcc/config/rs6000/rs6000-opts.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-opts.h?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -70,17 +70,6 @@ enum processor_type\n };\n \n \n-/* FP processor type.  */\n-enum fpu_type_t\n-{\n-  FPU_NONE,\t\t\t/* No FPU */\n-  FPU_SF_LITE,\t\t\t/* Limited Single Precision FPU */\n-  FPU_DF_LITE,\t\t\t/* Limited Double Precision FPU */\n-  FPU_SF_FULL,\t\t\t/* Full Single Precision FPU */\n-  FPU_DF_FULL\t\t\t/* Full Double Single Precision FPU */\n-};\n-\n-\n /* Types of costly dependences.  */\n enum rs6000_dependence_cost\n {"}, {"sha": "6fb79f29a6255b37c2f49b37702e85444aa6d875", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 32, "deletions": 76, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -2841,12 +2841,6 @@ rs6000_debug_reg_global (void)\n   if (rs6000_darwin64_abi)\n     fprintf (stderr, DEBUG_FMT_S, \"darwin64_abi\", \"true\");\n \n-  fprintf (stderr, DEBUG_FMT_S, \"single_float\",\n-\t   (TARGET_SINGLE_FLOAT ? \"true\" : \"false\"));\n-\n-  fprintf (stderr, DEBUG_FMT_S, \"double_float\",\n-\t   (TARGET_DOUBLE_FLOAT ? \"true\" : \"false\"));\n-\n   fprintf (stderr, DEBUG_FMT_S, \"soft_float\",\n \t   (TARGET_SOFT_FLOAT ? \"true\" : \"false\"));\n \n@@ -3002,7 +2996,7 @@ rs6000_setup_reg_addr_masks (void)\n \n \t\t    case E_DFmode:\n \t\t    case E_DDmode:\n-\t\t      if (TARGET_DF_INSN)\n+\t\t      if (TARGET_HARD_FLOAT)\n \t\t\taddr_mask |= RELOAD_REG_PRE_MODIFY;\n \t\t      break;\n \t\t    }\n@@ -3278,10 +3272,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \twK - Altivec register if QImode/HImode are allowed in VSX registers.  */\n \n   if (TARGET_HARD_FLOAT)\n-    rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\t/* SFmode  */\n-\n-  if (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-    rs6000_constraints[RS6000_CONSTRAINT_d]  = FLOAT_REGS;\t/* DFmode  */\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\t/* SFmode  */\n+      rs6000_constraints[RS6000_CONSTRAINT_d] = FLOAT_REGS;\t/* DFmode  */\n+    }\n \n   if (TARGET_VSX)\n     {\n@@ -3652,10 +3646,8 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       reg_addr[DImode].fused_toc = true;\n       if (TARGET_HARD_FLOAT)\n \t{\n-\t  if (TARGET_SINGLE_FLOAT)\n-\t    reg_addr[SFmode].fused_toc = true;\n-\t  if (TARGET_DOUBLE_FLOAT)\n-\t    reg_addr[DFmode].fused_toc = true;\n+\t  reg_addr[SFmode].fused_toc = true;\n+\t  reg_addr[DFmode].fused_toc = true;\n \t}\n     }\n \n@@ -4245,7 +4237,7 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_VSX)\n     {\n       const char *msg = NULL;\n-      if (!TARGET_HARD_FLOAT || !TARGET_SINGLE_FLOAT || !TARGET_DOUBLE_FLOAT)\n+      if (!TARGET_HARD_FLOAT)\n \t{\n \t  if (rs6000_isa_flags_explicit & OPTION_MASK_VSX)\n \t    msg = N_(\"-mvsx requires hardware floating point\");\n@@ -4798,16 +4790,6 @@ rs6000_option_override_internal (bool global_init_p)\n   if (TARGET_DEBUG_REG || TARGET_DEBUG_TARGET)\n     rs6000_print_isa_options (stderr, 0, \"after subtarget\", rs6000_isa_flags);\n \n-  if (main_target_opt)\n-    {\n-      if (main_target_opt->x_rs6000_single_float != rs6000_single_float)\n-\terror (\"target attribute or pragma changes single precision floating \"\n-\t       \"point\");\n-      if (main_target_opt->x_rs6000_double_float != rs6000_double_float)\n-\terror (\"target attribute or pragma changes double precision floating \"\n-\t       \"point\");\n-    }\n-\n   rs6000_always_hint = (rs6000_tune != PROCESSOR_POWER4\n \t\t\t&& rs6000_tune != PROCESSOR_POWER5\n \t\t\t&& rs6000_tune != PROCESSOR_POWER6\n@@ -5175,12 +5157,6 @@ rs6000_option_override_internal (bool global_init_p)\n \ttargetm.expand_builtin_va_start = NULL;\n     }\n \n-  /* Set up single/double float flags.  \n-     If TARGET_HARD_FLOAT is set, but neither single or double is set, \n-     then set both flags. */\n-  if (TARGET_HARD_FLOAT && rs6000_single_float == 0 && rs6000_double_float == 0)\n-    rs6000_single_float = rs6000_double_float = 1;\n-\n   /* If not explicitly specified via option, decide whether to generate indexed\n      load/store instructions.  A value of -1 indicates that the\n      initial value of this variable has not been overwritten. During\n@@ -8474,8 +8450,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n \treturn false;\n       if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n \t  && !(/* ??? Assume floating point reg based on mode?  */\n-\t       TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t       && (mode == DFmode || mode == DDmode)))\n+\t       TARGET_HARD_FLOAT && (mode == DFmode || mode == DDmode)))\n \treturn false;\n \n       return CONSTANT_P (x) || large_toc_ok;\n@@ -8583,8 +8558,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || (/* ??? Assume floating point reg based on mode?  */\n-\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t   && (mode == DFmode || mode == DDmode)))\n+\t\t   TARGET_HARD_FLOAT && (mode == DFmode || mode == DDmode)))\n \t   && !avoiding_indexed_address_p (mode))\n     {\n       return gen_rtx_PLUS (Pmode, XEXP (x, 0),\n@@ -8605,8 +8579,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_MODE_NUNITS (mode) == 1\n \t   && (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t       || (/* ??? Assume floating point reg based on mode?  */\n-\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t   && (mode == DFmode || mode == DDmode))))\n+\t\t   TARGET_HARD_FLOAT && (mode == DFmode || mode == DDmode))))\n     {\n       rtx reg = gen_reg_rtx (Pmode);\n       if (TARGET_ELF)\n@@ -9396,7 +9369,7 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && mode != PTImode\n       && (mode != DImode || TARGET_POWERPC64)\n       && ((mode != DFmode && mode != DDmode) || TARGET_POWERPC64\n-\t  || (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)))\n+\t  || TARGET_HARD_FLOAT))\n     {\n #if TARGET_MACHO\n       if (flag_pic)\n@@ -9577,7 +9550,7 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict, false))\n     return 1;\n   if (!FLOAT128_2REG_P (mode)\n-      && ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n+      && (TARGET_HARD_FLOAT\n \t  || TARGET_POWERPC64\n \t  || (mode != DFmode && mode != DDmode))\n       && (TARGET_POWERPC64 || mode != DImode)\n@@ -11231,9 +11204,9 @@ abi_v4_pass_in_fpr (machine_mode mode, bool named)\n {\n   if (!TARGET_HARD_FLOAT)\n     return false;\n-  if (TARGET_DOUBLE_FLOAT && mode == DFmode)\n+  if (mode == DFmode)\n     return true;\n-  if (TARGET_SINGLE_FLOAT && mode == SFmode && named)\n+  if (mode == SFmode && named)\n     return true;\n   /* ABI_V4 passes complex IBM long double in 8 gprs.\n      Stupid, but we can't change the ABI now.  */\n@@ -12901,17 +12874,14 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \t   fregno <= FP_ARG_V4_MAX_REG && nregs < cfun->va_list_fpr_size;\n \t   fregno++, off += UNITS_PER_FP_WORD, nregs++)\n \t{\n-\t  mem = gen_rtx_MEM ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t      ? DFmode : SFmode, \n+\t  mem = gen_rtx_MEM (TARGET_HARD_FLOAT ? DFmode : SFmode,\n                              plus_constant (Pmode, save_area, off));\n   \t  MEM_NOTRAP_P (mem) = 1;\n   \t  set_mem_alias_set (mem, set);\n \t  set_mem_align (mem, GET_MODE_ALIGNMENT (\n-\t\t\t (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t  ? DFmode : SFmode));\n+\t\t\t TARGET_HARD_FLOAT ? DFmode : SFmode));\n \t  emit_move_insn (mem, gen_rtx_REG (\n-                          (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t   ? DFmode : SFmode, fregno));\n+                          TARGET_HARD_FLOAT ? DFmode : SFmode, fregno));\n \t}\n \n       emit_label (lab);\n@@ -13181,8 +13151,8 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       /* FP args go in FP registers, if present.  */\n       reg = fpr;\n       n_reg = (size + 7) / 8;\n-      sav_ofs = ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? 8 : 4) * 4;\n-      sav_scale = ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? 8 : 4);\n+      sav_ofs = (TARGET_HARD_FLOAT ? 8 : 4) * 4;\n+      sav_scale = (TARGET_HARD_FLOAT ? 8 : 4);\n       if (mode != SFmode && mode != SDmode)\n \talign = 8;\n     }\n@@ -23321,8 +23291,8 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n   mode = GET_MODE (dst);\n   nregs = hard_regno_nregs (reg, mode);\n   if (FP_REGNO_P (reg))\n-    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode : \n-\t((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT) ? DFmode : SFmode);\n+    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode :\n+\t(TARGET_HARD_FLOAT ? DFmode : SFmode);\n   else if (ALTIVEC_REGNO_P (reg))\n     reg_mode = V16QImode;\n   else\n@@ -23784,10 +23754,7 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n   if (info->first_gp_reg_save == 32)\n     strategy |= SAVE_INLINE_GPRS | REST_INLINE_GPRS;\n \n-  if (info->first_fp_reg_save == 64\n-      /* The out-of-line FP routines use double-precision stores;\n-\t we can't use those routines if we don't have such stores.  */\n-      || (TARGET_HARD_FLOAT && !TARGET_DOUBLE_FLOAT))\n+  if (info->first_fp_reg_save == 64)\n     strategy |= SAVE_INLINE_FPRS | REST_INLINE_FPRS;\n \n   if (info->first_altivec_reg_save == LAST_ALTIVEC_REGNO + 1)\n@@ -26178,8 +26145,7 @@ rs6000_emit_prologue_components (sbitmap components)\n \n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n-  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t     ? DFmode : SFmode;\n+  machine_mode fp_reg_mode = TARGET_HARD_FLOAT ? DFmode : SFmode;\n   int fp_reg_size = 8;\n \n   /* Prologue for LR.  */\n@@ -26260,8 +26226,7 @@ rs6000_emit_epilogue_components (sbitmap components)\n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n \n-  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t     ? DFmode : SFmode;\n+  machine_mode fp_reg_mode = TARGET_HARD_FLOAT ? DFmode : SFmode;\n   int fp_reg_size = 8;\n \n   /* Epilogue for the FPRs.  */\n@@ -26419,8 +26384,7 @@ rs6000_emit_prologue (void)\n   rs6000_stack_t *info = rs6000_stack_info ();\n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n-  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t     ? DFmode : SFmode;\n+  machine_mode fp_reg_mode = TARGET_HARD_FLOAT ? DFmode : SFmode;\n   int fp_reg_size = 8;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx frame_reg_rtx = sp_reg_rtx;\n@@ -26564,8 +26528,7 @@ rs6000_emit_prologue (void)\n \t properly.  */\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n \tRTVEC_ELT (p, j++)\n-\t  = gen_frame_store (gen_rtx_REG (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t\t  ? DFmode : SFmode,\n+\t  = gen_frame_store (gen_rtx_REG (TARGET_HARD_FLOAT ? DFmode : SFmode,\n \t\t\t\t\t  info->first_fp_reg_save + i),\n \t\t\t     frame_reg_rtx,\n \t\t\t     info->fp_save_offset + frame_off + 8 * i);\n@@ -27657,8 +27620,7 @@ rs6000_emit_epilogue (int sibcall)\n   rtx cr_save_reg = NULL_RTX;\n   machine_mode reg_mode = Pmode;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n-  machine_mode fp_reg_mode = (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\t\t\t     ? DFmode : SFmode;\n+  machine_mode fp_reg_mode = TARGET_HARD_FLOAT ? DFmode : SFmode;\n   int fp_reg_size = 8;\n   int i;\n   bool exit_func;\n@@ -27760,8 +27722,7 @@ rs6000_emit_epilogue (int sibcall)\n \t}\n       for (i = 0; info->first_fp_reg_save + i <= 63; i++)\n \t{\n-\t  rtx reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t  ? DFmode : SFmode),\n+\t  rtx reg = gen_rtx_REG (TARGET_HARD_FLOAT ? DFmode : SFmode,\n \t\t\t\t info->first_fp_reg_save + i);\n \t  RTVEC_ELT (p, j++)\n \t    = gen_frame_load (reg, frame_reg_rtx, info->fp_save_offset + 8 * i);\n@@ -33223,10 +33184,8 @@ rs6000_elf_file_end (void)\n     {\n       int fp;\n \n-      if (TARGET_DF_FPR)\n+      if (TARGET_HARD_FLOAT)\n \tfp = 1;\n-      else if (TARGET_SF_FPR)\n-\tfp = 3;\n       else\n \tfp = 2;\n       if (rs6000_passes_long_double)\n@@ -35617,8 +35576,7 @@ rs6000_function_value (const_tree valtype,\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n   else if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT\n-\t   && !FLOAT128_VECTOR_P (mode)\n-\t   && ((TARGET_SINGLE_FLOAT && (mode == SFmode)) || TARGET_DOUBLE_FLOAT))\n+\t   && !FLOAT128_VECTOR_P (mode))\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n \t   && targetm.calls.split_complex_arg)\n@@ -35650,9 +35608,7 @@ rs6000_libcall_value (machine_mode mode)\n   if (DECIMAL_FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT)\n     /* _Decimal128 must use an even/odd register pair.  */\n     regno = (mode == TDmode) ? FP_ARG_RETURN + 1 : FP_ARG_RETURN;\n-  else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode)\n-\t   && TARGET_HARD_FLOAT\n-           && ((TARGET_SINGLE_FLOAT && mode == SFmode) || TARGET_DOUBLE_FLOAT))\n+  else if (SCALAR_FLOAT_MODE_NOT_VECTOR_P (mode) && TARGET_HARD_FLOAT)\n     regno = FP_ARG_RETURN;\n   /* VSX is a superset of Altivec and adds V2DImode/V2DFmode.  Since the same\n      return register is used in both cases, and we won't see V2DImode/V2DFmode"}, {"sha": "348eb355fc624c7647b1af05e254af3e83bc28ec", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -378,15 +378,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define TARGET_DEFAULT (MASK_MULTIPLE)\n \n-/* FPU operations supported. \n-   Each use of TARGET_SINGLE_FLOAT or TARGET_DOUBLE_FLOAT must \n-   also test TARGET_HARD_FLOAT.  */\n-#define TARGET_SINGLE_FLOAT 1\n-#define TARGET_DOUBLE_FLOAT 1\n-#define TARGET_SINGLE_FPU   0\n-#define TARGET_SIMPLE_FPU   0\n-#define TARGET_XILINX_FPU   0\n-\n /* Define generic processor types based upon current deployment.  */\n #define PROCESSOR_COMMON    PROCESSOR_PPC601\n #define PROCESSOR_POWERPC   PROCESSOR_PPC604\n@@ -567,14 +558,12 @@ extern int rs6000_vector_align[];\n #endif\n \n /* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.\n-   Enable 32-bit fcfid's on any of the switches for newer ISA machines or\n-   XILINX.  */\n+   Enable 32-bit fcfid's on any of the switches for newer ISA machines.  */\n #define TARGET_FCFID\t(TARGET_POWERPC64\t\t\t\t\\\n \t\t\t || TARGET_PPC_GPOPT\t/* 970/power4 */\t\\\n \t\t\t || TARGET_POPCNTB\t/* ISA 2.02 */\t\t\\\n \t\t\t || TARGET_CMPB\t\t/* ISA 2.05 */\t\t\\\n-\t\t\t || TARGET_POPCNTD\t/* ISA 2.06 */\t\t\\\n-\t\t\t || TARGET_XILINX_FPU)\n+\t\t\t || TARGET_POPCNTD)\t/* ISA 2.06 */\n \n #define TARGET_FCTIDZ\tTARGET_FCFID\n #define TARGET_STFIWX\tTARGET_PPC_GFXOPT\n@@ -622,11 +611,8 @@ extern int rs6000_vector_align[];\n /* ISA 3.0 has new min/max functions that don't need fast math that are being\n    phased in.  Min/max using FSEL or XSMAXDP/XSMINDP do not return the correct\n    answers if the arguments are not in the normal range.  */\n-#define TARGET_MINMAX_SF\t(TARGET_SF_FPR && TARGET_PPC_GFXOPT\t\\\n-\t\t\t\t && (TARGET_P9_MINMAX || !flag_trapping_math))\n-\n-#define TARGET_MINMAX_DF\t(TARGET_DF_FPR && TARGET_PPC_GFXOPT\t\\\n-\t\t\t\t && (TARGET_P9_MINMAX || !flag_trapping_math))\n+#define TARGET_MINMAX\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT\t\t\\\n+\t\t\t && (TARGET_P9_MINMAX || !flag_trapping_math))\n \n /* In switching from using target_flags to using rs6000_isa_flags, the options\n    machinery creates OPTION_MASK_<xxx> instead of MASK_<xxx>.  For now map\n@@ -707,26 +693,16 @@ extern int rs6000_vector_align[];\n \t\t\t  || rs6000_cpu == PROCESSOR_PPC8548)\n \n \n-/* Whether SF/DF operations are supported by the normal floating point unit\n-   (or the vector/scalar unit).  */\n-#define TARGET_SF_FPR\t(TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT)\n-#define TARGET_DF_FPR\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-\n-/* Whether SF/DF operations are supported by any hardware.  */\n-#define TARGET_SF_INSN\tTARGET_SF_FPR\n-#define TARGET_DF_INSN\tTARGET_DF_FPR\n-\n /* Which machine supports the various reciprocal estimate instructions.  */\n-#define TARGET_FRES\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT \\\n-\t\t\t && TARGET_SINGLE_FLOAT)\n+#define TARGET_FRES\t(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT)\n \n-#define TARGET_FRE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \\\n+#define TARGET_FRE\t(TARGET_HARD_FLOAT \\\n \t\t\t && (TARGET_POPCNTB || VECTOR_UNIT_VSX_P (DFmode)))\n \n #define TARGET_FRSQRTES\t(TARGET_HARD_FLOAT && TARGET_POPCNTB \\\n-\t\t\t && TARGET_PPC_GFXOPT && TARGET_SINGLE_FLOAT)\n+\t\t\t && TARGET_PPC_GFXOPT)\n \n-#define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \\\n+#define TARGET_FRSQRTE\t(TARGET_HARD_FLOAT \\\n \t\t\t && (TARGET_PPC_GFXOPT || VECTOR_UNIT_VSX_P (DFmode)))\n \n /* Conditions to allow TOC fusion for loading/storing integers.  */\n@@ -740,9 +716,7 @@ extern int rs6000_vector_align[];\n \t\t\t\t && TARGET_TOC_FUSION\t\t\t\\\n \t\t\t\t && (TARGET_CMODEL != CMODEL_SMALL)\t\\\n \t\t\t\t && TARGET_POWERPC64\t\t\t\\\n-\t\t\t\t && TARGET_HARD_FLOAT\t\t\t\\\n-\t\t\t\t && TARGET_SINGLE_FLOAT\t\t\t\\\n-\t\t\t\t && TARGET_DOUBLE_FLOAT)\n+\t\t\t\t && TARGET_HARD_FLOAT)\n \n /* Macro to say whether we can do optimizations where we need to do parts of\n    the calculation in 64-bit GPRs and then is transfered to the vector"}, {"sha": "1e0ee26cb511f4856c5b85183cbbfd3a01bf8e60", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 117, "deletions": 177, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -244,9 +244,6 @@\n ;; Is copying of this instruction disallowed?\n (define_attr \"cannot_copy\" \"no,yes\" (const_string \"no\"))\n \n-;; Define floating point instruction sub-types for use with Xfpu.md\n-(define_attr \"fp_type\" \"fp_default,fp_addsub_s,fp_addsub_d,fp_mul_s,fp_mul_d,fp_div_s,fp_div_d,fp_maddsub_s,fp_maddsub_d,fp_sqrt_s,fp_sqrt_d\" (const_string \"fp_default\"))\n-\n ;; Length (in bytes).\n ; '(pc)' in the following doesn't include the instruction itself; it is\n ; calculated as if the instruction had zero size.\n@@ -309,7 +306,6 @@\n (include \"power8.md\")\n (include \"power9.md\")\n (include \"cell.md\")\n-(include \"xfpu.md\")\n (include \"a2.md\")\n (include \"titan.md\")\n \n@@ -381,8 +377,8 @@\n \n ; Any hardware-supported floating-point mode\n (define_mode_iterator FP [\n-  (SF \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\")\n-  (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")\n+  (SF \"TARGET_HARD_FLOAT\")\n+  (DF \"TARGET_HARD_FLOAT\")\n   (TF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n   (IF \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\")\n   (KF \"TARGET_FLOAT128_TYPE\")\n@@ -391,9 +387,8 @@\n \n ; Any fma capable floating-point mode.\n (define_mode_iterator FMA_F [\n-  (SF \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\")\n-  (DF \"(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)\n-       || VECTOR_UNIT_VSX_P (DFmode)\")\n+  (SF \"TARGET_HARD_FLOAT\")\n+  (DF \"TARGET_HARD_FLOAT || VECTOR_UNIT_VSX_P (DFmode)\")\n   (V4SF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\")\n   (V2DF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V2DFmode)\")\n   (KF \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (KFmode)\")\n@@ -517,7 +512,7 @@\n ; SF/DF constraint for arithmetic on altivec registers\n (define_mode_attr Fa\t\t[(SF \"wu\") (DF \"wv\")])\n \n-; s/d suffix for things like fp_addsub_s/fp_addsub_d\n+; s/d suffix for things like sdiv/ddiv\n (define_mode_attr Fs\t\t[(SF \"s\")  (DF \"d\")])\n \n ; FRE/FRES support\n@@ -618,9 +613,6 @@\n (define_mode_attr SI_CONVERT_FP [(SF \"TARGET_FCFIDS\")\n \t\t\t\t (DF \"TARGET_FCFID\")])\n \n-(define_mode_attr TARGET_FLOAT [(SF \"TARGET_SINGLE_FLOAT\")\n-\t\t\t\t(DF \"TARGET_DOUBLE_FLOAT\")])\n-\n ;; Mode iterator for logical operations on 128-bit types\n (define_mode_iterator BOOL_128\t\t[TI\n \t\t\t\t\t PTI\n@@ -4516,106 +4508,100 @@\n (define_expand \"abs<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*abs<mode>2_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(abs:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fabs %0,%1\n    xsabsdp %x0,%x1\"\n-  [(set_attr \"type\" \"fpsimple\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fpsimple\")])\n \n (define_insn \"*nabs<mode>2_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(neg:SFDF\n \t (abs:SFDF\n \t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fnabs %0,%1\n    xsnabsdp %x0,%x1\"\n-  [(set_attr \"type\" \"fpsimple\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fpsimple\")])\n \n (define_expand \"neg<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(neg:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*neg<mode>2_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(neg:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fneg %0,%1\n    xsnegdp %x0,%x1\"\n-  [(set_attr \"type\" \"fpsimple\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fpsimple\")])\n \n (define_expand \"add<mode>3\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(plus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t   (match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*add<mode>3_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv2>\")\n \t(plus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv2>\")\n \t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fadd<Ftrad> %0,%1,%2\n    xsadd<Fvsx> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_expand \"sub<mode>3\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(minus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t    (match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*sub<mode>3_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv2>\")\n \t(minus:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")\n \t\t    (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fsub<Ftrad> %0,%1,%2\n    xssub<Fvsx> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_expand \"mul<mode>3\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(mult:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t   (match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*mul<mode>3_fpr\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv2>\")\n \t(mult:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv2>\")\n \t\t   (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fmul<Ftrad> %0,%1,%2\n    xsmul<Fvsx> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"dmul\")\n-   (set_attr \"fp_type\" \"fp_mul_<Fs>\")])\n+  [(set_attr \"type\" \"dmul\")])\n \n (define_expand \"div<mode>3\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(div:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t  (match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_INSN && !TARGET_SIMPLE_FPU\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (RS6000_RECIP_AUTO_RE_P (<MODE>mode)\n       && can_create_pseudo_p () && flag_finite_math_only\n@@ -4630,29 +4616,25 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv2>\")\n \t(div:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")\n \t\t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR && !TARGET_SIMPLE_FPU\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fdiv<Ftrad> %0,%1,%2\n    xsdiv<Fvsx> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<Fs>div\")\n-   (set_attr \"fp_type\" \"fp_div_<Fs>\")])\n+  [(set_attr \"type\" \"<Fs>div\")])\n \n (define_insn \"*sqrt<mode>2_internal\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv2>\")\n \t(sqrt:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR && !TARGET_SIMPLE_FPU\n-   && (TARGET_PPC_GPOPT || (<MODE>mode == SFmode && TARGET_XILINX_FPU))\"\n+  \"TARGET_HARD_FLOAT && TARGET_PPC_GPOPT\"\n   \"@\n    fsqrt<Ftrad> %0,%1\n    xssqrt<Fvsx> %x0,%x1\"\n-  [(set_attr \"type\" \"<Fs>sqrt\")\n-   (set_attr \"fp_type\" \"fp_sqrt_<Fs>\")])\n+  [(set_attr \"type\" \"<Fs>sqrt\")])\n \n (define_expand \"sqrt<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(sqrt:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_FPR && !TARGET_SIMPLE_FPU\n-   && (TARGET_PPC_GPOPT || (<MODE>mode == SFmode && TARGET_XILINX_FPU))\"\n+  \"TARGET_HARD_FLOAT && TARGET_PPC_GPOPT\"\n {\n   if (<MODE>mode == SFmode\n       && TARGET_RECIP_PRECISION\n@@ -4692,7 +4674,7 @@\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y,y\")\n \t(compare:CCFP (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")\n \t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fcmpu %0,%1,%2\n    xscmpudp %0,%x1,%x2\"\n@@ -4702,7 +4684,7 @@\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (HONOR_SNANS (SFmode))\n     operands[1] = force_reg (SFmode, operands[1]);\n@@ -4711,7 +4693,7 @@\n (define_insn_and_split \"*extendsfdf2_fpr\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wu,wb\")\n \t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wy,Z,wY\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !HONOR_SNANS (SFmode)\"\n+  \"TARGET_HARD_FLOAT && !HONOR_SNANS (SFmode)\"\n   \"@\n    #\n    fmr %0,%1\n@@ -4731,7 +4713,7 @@\n (define_insn \"*extendsfdf2_snan\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float_extend:DF (match_operand:SF 1 \"gpc_reg_operand\" \"f,wy\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && HONOR_SNANS (SFmode)\"\n+  \"TARGET_HARD_FLOAT && HONOR_SNANS (SFmode)\"\n   \"@\n    frsp %0,%1\n    xsrsp %x0,%x1\"\n@@ -4740,13 +4722,13 @@\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n \t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"*truncdfsf2_fpr\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n \t(float_truncate:SF (match_operand:DF 1 \"gpc_reg_operand\" \"d,ws\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    frsp %0,%1\n    xsrsp %x0,%x1\"\n@@ -4873,7 +4855,7 @@\n \t\t\t       (match_dup 5))\n \t\t\t (match_dup 3)\n \t\t\t (match_dup 4)))]\n-  \"TARGET_HARD_FLOAT && <TARGET_FLOAT>\n+  \"TARGET_HARD_FLOAT\n    && ((TARGET_PPC_GFXOPT\n         && !HONOR_NANS (<MODE>mode)\n         && !HONOR_SIGNED_ZEROS (<MODE>mode))\n@@ -4899,7 +4881,7 @@\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")\n \t\t      (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_COPYSIGN))]\n-  \"TARGET_<MODE>_FPR && (TARGET_CMPB || VECTOR_UNIT_VSX_P (<MODE>mode))\"\n+  \"TARGET_HARD_FLOAT && (TARGET_CMPB || VECTOR_UNIT_VSX_P (<MODE>mode))\"\n   \"@\n    fcpsgn %0,%2,%1\n    xscpsgndp %x0,%x2,%x1\"\n@@ -4922,7 +4904,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(fp_minmax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t\t(match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"TARGET_MINMAX_<MODE>\"\n+  \"TARGET_MINMAX\"\n {\n   rs6000_emit_minmax (operands[0], <SMINMAX>, operands[1], operands[2]);\n   DONE;\n@@ -4932,7 +4914,7 @@\n   [(set (match_operand:SFDF 0 \"vsx_register_operand\" \"=<Fv>\")\n \t(fp_minmax:SFDF (match_operand:SFDF 1 \"vsx_register_operand\" \"<Fv>\")\n \t\t\t(match_operand:SFDF 2 \"vsx_register_operand\" \"<Fv>\")))]\n-  \"TARGET_VSX && TARGET_<MODE>_FPR\"\n+  \"TARGET_VSX && TARGET_HARD_FLOAT\"\n {\n   return (TARGET_P9_MINMAX\n \t  ? \"xs<minmax>cdp %x0,%x1,%x2\"\n@@ -4948,7 +4930,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\")\n \t(fp_minmax:SFDF (match_operand:SFDF 1 \"gpc_reg_operand\")\n \t\t\t(match_operand:SFDF 2 \"gpc_reg_operand\")))]\n-  \"!TARGET_VSX && TARGET_MINMAX_<MODE>\"\n+  \"!TARGET_VSX && TARGET_MINMAX\"\n   \"#\"\n   \"&& 1\"\n   [(const_int 0)]\n@@ -5042,7 +5024,7 @@\n \t (if_then_else:SFDF (match_operand 1 \"comparison_operator\")\n \t\t\t    (match_operand:SFDF 2 \"gpc_reg_operand\")\n \t\t\t    (match_operand:SFDF 3 \"gpc_reg_operand\")))]\n-  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT\"\n+  \"TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT\"\n {\n   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n     DONE;\n@@ -5057,7 +5039,7 @@\n \t     (match_operand:SFDF2 4 \"zero_fp_constant\" \"F\"))\n \t (match_operand:SFDF 2 \"gpc_reg_operand\" \"<SFDF:rreg2>\")\n \t (match_operand:SFDF 3 \"gpc_reg_operand\" \"<SFDF:rreg2>\")))]\n-  \"TARGET_<MODE>_FPR && TARGET_PPC_GFXOPT\"\n+  \"TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT\"\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -5160,7 +5142,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wK\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wK\")]\n \t\t   UNSPEC_LFIWAX))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\"\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWAX\"\n   \"@\n    lfiwax %0,%y1\n    lxsiwax %x0,%y1\n@@ -5177,7 +5159,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWAX\n    && <SI_CONVERT_FP> && can_create_pseudo_p ()\"\n   \"#\"\n   \"\"\n@@ -5219,7 +5201,7 @@\n \t (sign_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWAX && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWAX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5241,7 +5223,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wj,wj,wJwK\")\n \t(unspec:DI [(match_operand:SI 1 \"reg_or_indexed_operand\" \"Z,Z,r,wJwK\")]\n \t\t   UNSPEC_LFIWZX))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX\"\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWZX\"\n   \"@\n    lfiwzx %0,%y1\n    lxsiwzx %x0,%y1\n@@ -5253,7 +5235,7 @@\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unsigned_float:SFDF (match_operand:SI 1 \"nonimmediate_operand\" \"r\")))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5294,7 +5276,7 @@\n \t (zero_extend:DI\n \t  (match_operand:SI 1 \"indexed_or_indirect_operand\" \"Z\"))))\n    (clobber (match_scratch:DI 2 \"=wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n+  \"TARGET_HARD_FLOAT && TARGET_LFIWZX && <SI_CONVERT_FP>\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5325,7 +5307,7 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (TARGET_LFIWAX && TARGET_FCFID)\n     {\n@@ -5359,7 +5341,7 @@\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))\n    (clobber (match_operand:SI 6 \"gpc_reg_operand\" \"=&r\"))]\n-  \"! TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"!TARGET_FCFID && TARGET_HARD_FLOAT\"\n   \"#\"\n   \"\"\n   [(pc)]\n@@ -5388,9 +5370,9 @@\n (define_expand \"floatunssisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n         (unsigned_float:SF (match_operand:SI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && ((TARGET_FCFIDUS && TARGET_LFIWZX)\n-       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+       || (TARGET_FCFID\n \t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n {\n   if (TARGET_LFIWZX && TARGET_FCFIDUS)\n@@ -5416,7 +5398,7 @@\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))])]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (TARGET_LFIWZX && TARGET_FCFID)\n     {\n@@ -5448,7 +5430,7 @@\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"d\"))\n    (clobber (match_operand:DF 4 \"offsettable_mem_operand\" \"=o\"))\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&d\"))]\n-  \"! TARGET_FCFIDU && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"!TARGET_FCFIDU && TARGET_HARD_FLOAT\n    && !(TARGET_FCFID && TARGET_POWERPC64)\"\n   \"#\"\n   \"\"\n@@ -5576,7 +5558,7 @@\n (define_expand \"fix_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_HARD_FLOAT && <TARGET_FLOAT>\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   if (!(TARGET_P8_VECTOR && TARGET_DIRECT_MOVE))\n     {\n@@ -5602,9 +5584,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-   && (<MODE>mode != SFmode || TARGET_SINGLE_FLOAT)\n-   && TARGET_STFIWX && can_create_pseudo_p ()\n+  \"TARGET_HARD_FLOAT && TARGET_STFIWX && can_create_pseudo_p ()\n    && !(TARGET_P8_VECTOR && TARGET_DIRECT_MOVE)\"\n   \"#\"\n   \"\"\n@@ -5646,7 +5626,7 @@\n \t(fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d,<rreg>\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=1,d\"))\n    (clobber (match_operand:DI 3 \"offsettable_mem_operand\" \"=o,o\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && !(TARGET_P8_VECTOR && TARGET_DIRECT_MOVE)\"\n   \"#\"\n   \"\"\n@@ -5667,13 +5647,13 @@\n (define_expand \"fix_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\")\n \t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFID\"\n   \"\")\n \n (define_insn \"*fix_trunc<mode>di2_fctidz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n \t(fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFID\"\n   \"@\n    fctidz %0,%1\n    xscvdpsxds %x0,%x1\"\n@@ -5737,7 +5717,7 @@\n (define_expand \"fixuns_trunc<mode>si2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\")))]\n-  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ && TARGET_STFIWX\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCTIWUZ && TARGET_STFIWX\"\n {\n   if (!TARGET_P8_VECTOR)\n     {\n@@ -5750,7 +5730,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DI 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ\n+  \"TARGET_HARD_FLOAT && TARGET_FCTIWUZ\n    && TARGET_STFIWX && can_create_pseudo_p ()\n    && !TARGET_P8_VECTOR\"\n   \"#\"\n@@ -5791,7 +5771,7 @@\n (define_insn \"fixuns_trunc<mode>di2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d,wi\")\n \t(unsigned_fix:DI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCTIDUZ\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCTIDUZ\"\n   \"@\n    fctiduz %0,%1\n    xscvdpuxds %x0,%x1\"\n@@ -5806,7 +5786,7 @@\n \t(unspec:DI [(fix:SI\n \t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWZ))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fctiwz %0,%1\n    xscvdpsxws %x0,%x1\"\n@@ -5817,7 +5797,7 @@\n \t(unspec:DI [(unsigned_fix:SI\n \t\t     (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\"))]\n \t\t   UNSPEC_FCTIWUZ))]\n-  \"TARGET_HARD_FLOAT && <TARGET_FLOAT> && TARGET_FCTIWUZ\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCTIWUZ\"\n   \"@\n    fctiwuz %0,%1\n    xscvdpuxws %x0,%x1\"\n@@ -5829,7 +5809,7 @@\n (define_insn \"*friz\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (fix:DI (match_operand:DF 1 \"gpc_reg_operand\" \"d,ws\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FPRND\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\n    && flag_unsafe_math_optimizations && !flag_trapping_math && TARGET_FRIZ\"\n   \"@\n    friz %0,%1\n@@ -5848,7 +5828,7 @@\n \t (fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n    (clobber (match_scratch:DI 2 \"=d\"))\n    (clobber (match_scratch:DI 3 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && <SI_CONVERT_FP> && TARGET_LFIWAX && TARGET_STFIWX && TARGET_FCFID\n    && !TARGET_DIRECT_MOVE && can_create_pseudo_p ()\"\n   \"#\"\n@@ -5881,7 +5861,7 @@\n \t (unsigned_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d\"))))\n    (clobber (match_scratch:DI 2 \"=d\"))\n    (clobber (match_scratch:DI 3 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && TARGET_LFIWZX && TARGET_STFIWX && TARGET_FCFIDU && !TARGET_DIRECT_MOVE\n    && can_create_pseudo_p ()\"\n   \"#\"\n@@ -5913,61 +5893,56 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=d\")\n \t(unspec:DI [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n \t\t   UNSPEC_FCTID))]\n-  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\"\n   \"fctid %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"btrunc<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIZ))]\n-  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\"\n   \"@\n    friz %0,%1\n    xsrdpiz %x0,%x1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_insn \"ceil<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIP))]\n-  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\"\n   \"@\n    frip %0,%1\n    xsrdpip %x0,%x1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_insn \"floor<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Ff>,<Fv>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")]\n \t\t     UNSPEC_FRIM))]\n-  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\"\n   \"@\n    frim %0,%1\n    xsrdpim %x0,%x1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n ;; No VSX equivalent to frin\n (define_insn \"round<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<rreg2>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<rreg2>\")]\n \t\t     UNSPEC_FRIN))]\n-  \"TARGET_<MODE>_FPR && TARGET_FPRND\"\n+  \"TARGET_HARD_FLOAT && TARGET_FPRND\"\n   \"frin %0,%1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_insn \"*xsrdpi<mode>2\"\n   [(set (match_operand:SFDF 0 \"gpc_reg_operand\" \"=<Fv>\")\n \t(unspec:SFDF [(match_operand:SFDF 1 \"gpc_reg_operand\" \"<Fv>\")]\n \t\t     UNSPEC_XSRDPI))]\n-  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n+  \"TARGET_HARD_FLOAT && TARGET_VSX\"\n   \"xsrdpi %x0,%x1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_expand \"lround<mode>di2\"\n   [(set (match_dup 2)\n@@ -5976,7 +5951,7 @@\n    (set (match_operand:DI 0 \"gpc_reg_operand\")\n \t(unspec:DI [(match_dup 2)]\n \t\t   UNSPEC_FCTID))]\n-  \"TARGET_<MODE>_FPR && TARGET_VSX\"\n+  \"TARGET_HARD_FLOAT && TARGET_VSX\"\n {\n   operands[2] = gen_reg_rtx (<MODE>mode);\n })\n@@ -6000,9 +5975,9 @@\n (define_expand \"floatsisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n         (float:SF (match_operand:SI 1 \"nonimmediate_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && ((TARGET_FCFIDS && TARGET_LFIWAX)\n-       || (TARGET_DOUBLE_FLOAT && TARGET_FCFID\n+       || (TARGET_FCFID\n \t   && (TARGET_POWERPC64 || flag_unsafe_math_optimizations)))\"\n {\n   if (TARGET_FCFIDS && TARGET_LFIWAX)\n@@ -6031,7 +6006,7 @@\n (define_insn \"floatdidf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT\"\n   \"@\n    fcfid %0,%1\n    xscvsxddp %x0,%x1\"\n@@ -6046,7 +6021,7 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,ws\")\n \t(float:DF (match_operand:DI 1 \"memory_operand\" \"m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_FCFID\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFID\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -6088,7 +6063,7 @@\n (define_expand \"floatdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\")))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT\n    && (TARGET_FCFIDS || TARGET_POWERPC64 || flag_unsafe_math_optimizations)\"\n {\n   if (!TARGET_FCFIDS)\n@@ -6109,8 +6084,7 @@\n (define_insn \"floatdisf2_fcfids\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy\")\n \t(float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDS\"\n   \"@\n    fcfids %0,%1\n    xscvsxdsp %x0,%x1\"\n@@ -6120,8 +6094,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n \t(float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDS\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n@@ -6140,7 +6113,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n         (float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_FCFID && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && !TARGET_FCFIDS\"\n+  \"TARGET_FCFID && TARGET_HARD_FLOAT && !TARGET_FCFIDS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -6175,8 +6148,7 @@\n \t\t\t   (label_ref (match_operand:DI 2 \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 0) (match_dup 1))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && !TARGET_FCFIDS\"\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && !TARGET_FCFIDS\"\n {\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (CCUNSmode);\n@@ -6185,15 +6157,13 @@\n (define_expand \"floatunsdisf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n         (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDUS\"\n   \"\")\n \n (define_insn \"floatunsdisf2_fcfidus\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wu\")\n         (unsigned_float:SF (match_operand:DI 1 \"gpc_reg_operand\" \"d,wi\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDUS\"\n   \"@\n    fcfidus %0,%1\n    xscvuxdsp %x0,%x1\"\n@@ -6203,8 +6173,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f,wy,wy\")\n \t(unsigned_float:SF (match_operand:DI 1 \"memory_operand\" \"m,m,Z\")))\n    (clobber (match_scratch:DI 2 \"=d,d,wi\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_FCFIDUS\"\n+  \"TARGET_HARD_FLOAT && TARGET_FCFIDUS\"\n   \"#\"\n   \"&& reload_completed\"\n   [(pc)]\n@@ -6714,8 +6683,8 @@\n \t\t O,          wM,          wS,          r,           wIwH,\n \t\t *h,         r,           r,           0\"))]\n \n-  \"!TARGET_SINGLE_FPU &&\n-   (gpc_reg_operand (operands[0], SImode) || gpc_reg_operand (operands[1], SImode))\"\n+  \"gpc_reg_operand (operands[0], SImode)\n+   || gpc_reg_operand (operands[1], SImode)\"\n   \"@\n    mr %0,%1\n    la %0,%a1\n@@ -6755,28 +6724,6 @@\n \t\t 4,          4,           8,           4,           4,\n \t\t 4,          4,           4,           4\")])\n \n-(define_insn \"*movsi_internal1_single\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,*c*l,*h,*h,m,*f\")\n-        (match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,*h,r,r,0,f,m\"))]\n-  \"TARGET_SINGLE_FPU &&\n-   (gpc_reg_operand (operands[0], SImode) || gpc_reg_operand (operands[1], SImode))\"\n-  \"@\n-   mr %0,%1\n-   la %0,%a1\n-   lwz%U1%X1 %0,%1\n-   stw%U0%X0 %1,%0\n-   li %0,%1\n-   lis %0,%v1\n-   #\n-   mf%1 %0\n-   mt%0 %1\n-   mt%0 %1\n-   nop\n-   stfs%U0%X0 %1,%0\n-   lfs%U1%X1 %0,%1\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,mtjmpr,*,*,fpstore,fpload\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4\")])\n-\n ;; Like movsi, but adjust a SF value to be used in a SI context, i.e.\n ;; (set (reg:SI ...) (subreg:SI (reg:SF ...) 0))\n ;;\n@@ -7154,7 +7101,7 @@\n \t  r,         r,         *h,         0\"))]\n   \"(register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode))\n-   && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\n+   && TARGET_HARD_FLOAT\n    && (TARGET_ALLOW_SF_SUBREG\n        || valid_sf_si_move (operands[0], operands[1], SFmode))\"\n   \"@\n@@ -7190,7 +7137,7 @@\n \t  f,         r,         r,         *h,        0\"))]\n   \"(register_operand (operands[0], SDmode)\n    || register_operand (operands[1], SDmode))\n-   && TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT\"\n+   && TARGET_HARD_FLOAT\"\n   \"@\n    lwz%U1%X1 %0,%1\n    lfiwzx %0,%y1\n@@ -7391,7 +7338,7 @@\n (define_insn \"*mov<mode>_hardfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_p9>,wY,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,wY,<f64_p9>,Z,<f64_av>,<f64_vsx>,<zero_fp>,<zero_fp>,r,Y,r\"))]\n-  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT \n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7415,8 +7362,7 @@\n (define_insn \"*mov<mode>_softfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"r,Y,r,G,H,F\"))]\n-  \"! TARGET_POWERPC64 \n-   && (TARGET_SINGLE_FLOAT || TARGET_SOFT_FLOAT)\n+  \"!TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"#\"\n@@ -7428,7 +7374,7 @@\n (define_insn \"*mov<mode>_hardfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_p9>,wY,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>\")\n \t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,wY,<f64_p9>,Z,<f64_av>,<f64_vsx>,<zero_fp>,<zero_fp>,r,Y,r,r,h,0,wg,r,<f64_dm>,r\"))]\n-  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"TARGET_POWERPC64 && TARGET_HARD_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n@@ -7581,7 +7527,7 @@\n \t(float_extend:IBM128\n \t (match_operand:DF 1 \"nonimmediate_operand\" \"d,m,d\")))\n    (use (match_operand:DF 2 \"nonimmediate_operand\" \"m,m,d\"))]\n-  \"!TARGET_VSX && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"!TARGET_VSX && TARGET_HARD_FLOAT\n    && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -7662,10 +7608,9 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(float_truncate:DF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))]\n   \"FLOAT128_IBM_P (<MODE>mode) && TARGET_XL_COMPAT && TARGET_HARD_FLOAT\n-   && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_LONG_DOUBLE_128\"\n   \"fadd %0,%1,%L1\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n+  [(set_attr \"type\" \"fp\")])\n \n (define_expand \"trunc<mode>sf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\")\n@@ -7687,8 +7632,7 @@\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(float_truncate:SF (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")))\n    (clobber (match_scratch:DF 2 \"=d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT \n-   && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128 && FLOAT128_IBM_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n@@ -7734,7 +7678,7 @@\n \t(unspec:DF [(match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")]\n \t\t   UNSPEC_FIX_TRUNC_TF))\n    (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=&d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && FLOAT128_IBM_P (<MODE>mode)\"\n+  \"TARGET_HARD_FLOAT && FLOAT128_IBM_P (<MODE>mode)\"\n   \"mffs %2\\n\\tmtfsb1 31\\n\\tmtfsb0 30\\n\\tfadd %0,%1,%L1\\n\\tmtfsf 1,%2\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"length\" \"20\")])\n@@ -7971,7 +7915,7 @@\n \t\t\t   (label_ref (match_operand 2 \"\"))\n \t\t\t   (pc)))\n    (set (match_dup 6) (neg:DF (match_dup 6)))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+  \"TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n {\n   const int hi_word = LONG_DOUBLE_LARGE_FIRST ? 0 : GET_MODE_SIZE (DFmode);\n   const int lo_word = LONG_DOUBLE_LARGE_FIRST ? GET_MODE_SIZE (DFmode) : 0;\n@@ -9105,7 +9049,7 @@\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9121,7 +9065,7 @@\n \t(match_operand:SF 3 \"gpc_reg_operand\" \"f,f\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9169,7 +9113,7 @@\n \t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\"))))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -9186,7 +9130,7 @@\n \t(match_operand:DF 3 \"gpc_reg_operand\" \"d,d\"))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n \t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_UPDATE\n+  \"TARGET_HARD_FLOAT && TARGET_UPDATE\n    && (!avoiding_indexed_address_p (SImode)\n        || !gpc_reg_operand (operands[2], SImode))\"\n   \"@\n@@ -11575,7 +11519,7 @@\n \t(compare:CCFP (match_operand:IBM128 1 \"gpc_reg_operand\" \"d\")\n \t\t      (match_operand:IBM128 2 \"gpc_reg_operand\" \"d\")))]\n   \"!TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n-   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"fcmpu %0,%1,%2\\;bne %0,$+8\\;fcmpu %0,%L1,%L2\"\n   [(set_attr \"type\" \"fpcompare\")\n    (set_attr \"length\" \"12\")])\n@@ -11594,7 +11538,7 @@\n     (clobber (match_scratch:DF 10 \"=d\"))\n     (clobber (match_scratch:GPR 11 \"=b\"))]\n   \"TARGET_XL_COMPAT && FLOAT128_IBM_P (<MODE>mode)\n-   && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 3) (match_dup 14))\n@@ -13323,13 +13267,12 @@\n \t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"%<Ff>,<Fv2>,<Fv2>\")\n \t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>,0\")\n \t  (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv2>\")))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fmadd<Ftrad> %0,%1,%2,%3\n    xsmadda<Fvsx> %x0,%x1,%x2\n    xsmaddm<Fvsx> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n ; Altivec only has fma and nfms.\n (define_expand \"fms<mode>4\"\n@@ -13347,13 +13290,12 @@\n \t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>,<Fv2>\")\n \t (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>,0\")\n \t (neg:SFDF (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv2>\"))))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fmsub<Ftrad> %0,%1,%2,%3\n    xsmsuba<Fvsx> %x0,%x1,%x2\n    xsmsubm<Fvsx> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n ;; If signed zeros are ignored, -(a * b - c) = -a * b + c.\n (define_expand \"fnma<mode>4\"\n@@ -13395,13 +13337,12 @@\n \t  (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv2>,<Fv2>\")\n \t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>,0\")\n \t  (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv2>\"))))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fnmadd<Ftrad> %0,%1,%2,%3\n    xsnmadda<Fvsx> %x0,%x1,%x2\n    xsnmaddm<Fvsx> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n ; Not an official optab name, but used from builtins.\n (define_expand \"nfms<mode>4\"\n@@ -13422,13 +13363,12 @@\n \t  (match_operand:SFDF 2 \"gpc_reg_operand\" \"<Ff>,<Fv2>,0\")\n \t  (neg:SFDF\n \t   (match_operand:SFDF 3 \"gpc_reg_operand\" \"<Ff>,0,<Fv2>\")))))]\n-  \"TARGET_<MODE>_FPR\"\n+  \"TARGET_HARD_FLOAT\"\n   \"@\n    fnmsub<Ftrad> %0,%1,%2,%3\n    xsnmsuba<Fvsx> %x0,%x1,%x2\n    xsnmsubm<Fvsx> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"fp\")\n-   (set_attr \"fp_type\" \"fp_maddsub_<Fs>\")])\n+  [(set_attr \"type\" \"fp\")])\n \n \f\n (define_expand \"rs6000_get_timebase\""}, {"sha": "58233091c52a5b7a0806430aff161394122ba9a8", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -463,44 +463,6 @@ mprioritize-restricted-insns=\n Target RejectNegative Joined UInteger Var(rs6000_sched_restricted_insns_priority) Save\n Specify scheduling priority for dispatch slot restricted insns.\n \n-msingle-float\n-Target RejectNegative Var(rs6000_single_float) Save\n-Single-precision floating point unit.\n-\n-mdouble-float\n-Target RejectNegative Var(rs6000_double_float) Save\n-Double-precision floating point unit.\n-\n-msimple-fpu\n-Target RejectNegative Var(rs6000_simple_fpu) Save\n-Floating point unit does not support divide & sqrt.\n-\n-mfpu=\n-Target RejectNegative Joined Enum(fpu_type_t) Var(rs6000_fpu_type) Init(FPU_NONE)\n--mfpu=\tSpecify FP (sp, dp, sp-lite, dp-lite) (implies -mxilinx-fpu).\n-\n-Enum\n-Name(fpu_type_t) Type(enum fpu_type_t)\n-\n-EnumValue\n-Enum(fpu_type_t) String(none) Value(FPU_NONE)\n-\n-EnumValue\n-Enum(fpu_type_t) String(sp_lite) Value(FPU_SF_LITE)\n-\n-EnumValue\n-Enum(fpu_type_t) String(dp_lite) Value(FPU_DF_LITE)\n-\n-EnumValue\n-Enum(fpu_type_t) String(sp_full) Value(FPU_SF_FULL)\n-\n-EnumValue\n-Enum(fpu_type_t) String(dp_full) Value(FPU_DF_FULL)\n-\n-mxilinx-fpu\n-Target Var(rs6000_xilinx_fpu) Save\n-Specify Xilinx FPU.\n-\n mpointers-to-nested-functions\n Target Report Var(TARGET_POINTERS_TO_NESTED_FUNCTIONS) Init(1) Save\n Use r11 to hold the static link in calls to functions via pointers."}, {"sha": "e1d3efd5ec70e7de6d1d3d3c7528622a6f30d369", "filename": "gcc/config/rs6000/singlefp.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fsinglefp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fsinglefp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsinglefp.h?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,40 +0,0 @@\n-/* Definitions for PowerPC single-precision floating point unit\n-   such as Xilinx PowerPC 405/440 APU.\n-\n-   Copyright (C) 2008-2018 Free Software Foundation, Inc.\n-   Contributed by Michael Eager (eager@eagercon.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Undefine definitions from rs6000.h. */\n-#undef TARGET_SINGLE_FLOAT\n-#undef TARGET_DOUBLE_FLOAT\n-#undef TARGET_SINGLE_FPU\n-#undef TARGET_SIMPLE_FPU\n-#undef UNITS_PER_FP_WORD\n-\n-/* FPU operations supported. \n-   If TARGET_SINGLE_FPU set, processor supports single fp options. */\n-#define TARGET_SINGLE_FLOAT (rs6000_single_float)\n-#define TARGET_DOUBLE_FLOAT (rs6000_double_float)\n-#define TARGET_SINGLE_FPU   1\n-#define TARGET_SIMPLE_FPU   (rs6000_simple_fpu)\n-\n-/* FP word width depends on single/double fp support. */\n-#define UNITS_PER_FP_WORD ((TARGET_SOFT_FLOAT || TARGET_DOUBLE_FLOAT) ? 8 : 4)\n-"}, {"sha": "6b709fb6bab9970fd9444ac27920bf33a36e45c4", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -608,9 +608,6 @@ ENDIAN_SELECT(\" -mbig\", \" -mlittle\", DEFAULT_ASM_ENDIAN)\n \n #define LINK_OS_DEFAULT_SPEC \"\"\n \n-#define DRIVER_SELF_SPECS \"%{mfpu=none: %<mfpu=* \\\n- \t%<msingle-float %<mdouble-float}\"\n-\n /* Override rs6000.h definition.  */\n #undef\tCPP_SPEC\n #define\tCPP_SPEC \"%{posix: -D_POSIX_SOURCE} \\"}, {"sha": "007f75bd6ba7cb4540e08ffe9879d4efd3b70282", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -61,7 +61,6 @@ MD_INCLUDES = $(srcdir)/config/rs6000/rs64.md \\\n \t$(srcdir)/config/rs6000/power8.md \\\n \t$(srcdir)/config/rs6000/power9.md \\\n \t$(srcdir)/config/rs6000/cell.md \\\n-\t$(srcdir)/config/rs6000/xfpu.md \\\n \t$(srcdir)/config/rs6000/a2.md \\\n \t$(srcdir)/config/rs6000/predicates.md \\\n \t$(srcdir)/config/rs6000/constraints.md \\"}, {"sha": "eabecbeb50ade01fc12d64cf98aee9e4df9e1c94", "filename": "gcc/config/rs6000/t-xilinx", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Ft-xilinx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Ft-xilinx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-xilinx?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,28 +0,0 @@\n-# Multilibs for Xilinx powerpc embedded ELF targets.\n-#\n-# Copyright (C) 2009-2018 Free Software Foundation, Inc.\n-# Contributed by Michael Eager, eager@eagercon.com\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Switch synonyms\n-MULTILIB_MATCHES        = mfpu?sp_lite=msingle-float mfpu?dp_lite=mdouble-float mfpu?dp_lite=mhard-float mfpu?sp_lite=mfpu?sp_full mfpu?dp_lite=mfpu?dp_full \n-\n-MULTILIB_OPTIONS        = mfpu=sp_lite/mfpu=dp_lite \n-\n-MULTILIB_DIRNAMES       = single double \n-"}, {"sha": "80802a4d9c43e40712985e4d6fe00f9faf33664a", "filename": "gcc/config/rs6000/titan.md", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Ftitan.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Ftitan.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ftitan.md?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -148,11 +148,6 @@\n        (eq_attr \"cpu\" \"titan\"))\n   \"titan_issue,titan_fpdiv*46,titan_fpwb\")\n \n-(define_insn_reservation \"titan_fp_single\" 12\n-  (and (eq_attr \"fp_type\" \"fp_addsub_s,fp_mul_s,fp_maddsub_s\")       \n-       (eq_attr \"cpu\" \"titan\"))\n-  \"titan_issue,titan_fp0*2,nothing*10,titan_fpwb\")\n-\n ;; Make sure the \"titan_fp\" rule stays last, as it's a catch all for\n ;; double-precision and unclassified (e.g. fsel) FP-instructions\n (define_insn_reservation \"titan_fp\" 10"}, {"sha": "9bb5c2778bc01d24c97d41cc73bff697db7f050f", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 31, "deletions": 77, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -214,38 +214,22 @@\n \t\t\t\t (V4SF \"vecfloat\")\n \t\t\t\t (DF   \"fp\")])\n \n-(define_mode_attr VSfptype_simple [(V2DF \"fp_addsub_d\")\n-\t\t\t\t   (V4SF \"fp_addsub_s\")\n-\t\t\t\t   (DF   \"fp_addsub_d\")])\n-\n ;; Appropriate type for multiply ops\n (define_mode_attr VStype_mul\t[(V2DF \"vecdouble\")\n \t\t\t\t (V4SF \"vecfloat\")\n \t\t\t\t (DF   \"dmul\")])\n \n-(define_mode_attr VSfptype_mul\t[(V2DF \"fp_mul_d\")\n-\t\t\t\t (V4SF \"fp_mul_s\")\n-\t\t\t\t (DF   \"fp_mul_d\")])\n-\n ;; Appropriate type for divide ops.\n (define_mode_attr VStype_div\t[(V2DF \"vecdiv\")\n \t\t\t\t (V4SF \"vecfdiv\")\n \t\t\t\t (DF   \"ddiv\")])\n \n-(define_mode_attr VSfptype_div\t[(V2DF \"fp_div_d\")\n-\t\t\t\t (V4SF \"fp_div_s\")\n-\t\t\t\t (DF   \"fp_div_d\")])\n-\n ;; Appropriate type for sqrt ops.  For now, just lump the vector sqrt with\n ;; the scalar sqrt\n (define_mode_attr VStype_sqrt\t[(V2DF \"dsqrt\")\n \t\t\t\t (V4SF \"ssqrt\")\n \t\t\t\t (DF   \"dsqrt\")])\n \n-(define_mode_attr VSfptype_sqrt\t[(V2DF \"fp_sqrt_d\")\n-\t\t\t\t (V4SF \"fp_sqrt_s\")\n-\t\t\t\t (DF   \"fp_sqrt_d\")])\n-\n ;; Iterator and modes for sp<->dp conversions\n ;; Because scalar SF values are represented internally as double, use the\n ;; V4SF type to represent this than SF.\n@@ -1612,26 +1596,23 @@\n \t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvadd<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_sub<mode>3\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (minus:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t     (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvsub<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_mul<mode>3\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (mult:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmul<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ; Emulate vector with scalar for vec_mul in V2DImode\n (define_insn_and_split \"vsx_mul_v2di\"\n@@ -1679,8 +1660,7 @@\n \t\t   (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvdiv<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_div>\")\n-   (set_attr \"fp_type\" \"<VSfptype_div>\")])\n+  [(set_attr \"type\" \"<VStype_div>\")])\n \n ; Emulate vector with scalar for vec_div in V2DImode\n (define_insn_and_split \"vsx_div_v2di\"\n@@ -1812,33 +1792,29 @@\n \t\t   UNSPEC_VSX_TDIV))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>tdiv<VSs> %0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_fre<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRES))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvre<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_neg<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (neg:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvneg<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_abs<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (abs:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvabs<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_nabs<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n@@ -1847,43 +1823,38 @@\n \t  (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\"))))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvnabs<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_smax<mode>3\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (smax:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmax<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_smin<mode>3\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (smin:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t    (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvmin<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_sqrt<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n         (sqrt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvsqrt<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_sqrt>\")\n-   (set_attr \"fp_type\" \"<VSfptype_sqrt>\")])\n+  [(set_attr \"type\" \"<VStype_sqrt>\")])\n \n (define_insn \"*vsx_rsqrte<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_RSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvrsqrte<VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; *tsqrt* returning the fg flag\n (define_expand \"vsx_tsqrt<mode>2_fg\"\n@@ -1917,8 +1888,7 @@\n \t\t     UNSPEC_VSX_TSQRT))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>tsqrt<VSs> %0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; Fused vector multiply/add instructions. Support the classical Altivec\n ;; versions of fma, which allows the target to be a separate register from the\n@@ -1982,8 +1952,7 @@\n    xvnmaddm<VSs> %x0,%x1,%x3\n    xvnmadda<VSs> %x0,%x1,%x2\n    xvnmaddm<VSs> %x0,%x1,%x3\"\n-  [(set_attr \"type\" \"<VStype_mul>\")\n-   (set_attr \"fp_type\" \"<VSfptype_mul>\")])\n+  [(set_attr \"type\" \"<VStype_mul>\")])\n \n (define_insn \"*vsx_nfmsv4sf4\"\n   [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wf,wf,?wa,?wa,v\")\n@@ -2025,26 +1994,23 @@\n \t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpeq<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_gt<mode>\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(gt:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpgt<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_ge<mode>\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(ge:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")\n \t\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcmpge<VSs> %x0,%x1,%x2\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; Compare vectors producing a vector result and a predicate, setting CR6 to\n ;; indicate a combined status\n@@ -2119,8 +2085,7 @@\n \t UNSPEC_COPYSIGN))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcpsgn<VSs> %x0,%x2,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; For the conversions, limit the register class for the integer value to be\n ;; the fprs because we don't want to add the altivec registers to movdi/movsi.\n@@ -2133,32 +2098,28 @@\n \t(float:VSX_F (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcvsx<VSc><VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_floatuns<VSi><mode>2\"\n   [(set (match_operand:VSX_F 0 \"gpc_reg_operand\" \"=<VSr>,?<VSa>\")\n \t(unsigned_float:VSX_F (match_operand:<VSI> 1 \"gpc_reg_operand\" \"<VSr2>,<VSr3>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvcvux<VSc><VSs> %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_fix_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n \t(fix:<VSI> (match_operand:VSX_F 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>sx<VSc>s %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_fixuns_trunc<mode><VSi>2\"\n   [(set (match_operand:<VSI> 0 \"gpc_reg_operand\" \"=<VSr2>,?<VSr3>\")\n \t(unsigned_fix:<VSI> (match_operand:VSX_F 1 \"gpc_reg_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>cv<VSs>ux<VSc>s %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n ;; Math rounding functions\n (define_insn \"vsx_x<VSv>r<VSs>i\"\n@@ -2167,52 +2128,46 @@\n \t\t      UNSPEC_VSX_ROUND_I))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>i %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_x<VSv>r<VSs>ic\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_VSX_ROUND_IC))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>ic %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_btrunc<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(fix:VSX_F (match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>iz %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"*vsx_b2trunc<mode>2\"\n   [(set (match_operand:VSX_B 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_B [(match_operand:VSX_B 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIZ))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"x<VSv>r<VSs>iz %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_floor<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIM))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>im %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n (define_insn \"vsx_ceil<mode>2\"\n   [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=<VSr>,?<VSa>\")\n \t(unspec:VSX_F [(match_operand:VSX_F 1 \"vsx_register_operand\" \"<VSr>,<VSa>\")]\n \t\t      UNSPEC_FRIP))]\n   \"VECTOR_UNIT_VSX_P (<MODE>mode)\"\n   \"xvr<VSs>ip %x0,%x1\"\n-  [(set_attr \"type\" \"<VStype_simple>\")\n-   (set_attr \"fp_type\" \"<VSfptype_simple>\")])\n+  [(set_attr \"type\" \"<VStype_simple>\")])\n \n \f\n ;; VSX convert to/from double vector\n@@ -2867,12 +2822,11 @@\n \t(float:V2DF\n \t (fix:V2DI\n \t  (match_operand:V2DF 1 \"vsx_register_operand\" \"wd,?wa\"))))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+  \"TARGET_HARD_FLOAT\n    && VECTOR_UNIT_VSX_P (V2DFmode) && flag_unsafe_math_optimizations\n    && !flag_trapping_math && TARGET_FRIZ\"\n   \"xvrdpiz %x0,%x1\"\n-  [(set_attr \"type\" \"vecdouble\")\n-   (set_attr \"fp_type\" \"fp_addsub_d\")])\n+  [(set_attr \"type\" \"vecdouble\")])\n \n \f\n ;; Permute operations"}, {"sha": "863a8da57f2fdb226c7f65e7714d3dd243dfcece", "filename": "gcc/config/rs6000/xfpu.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxfpu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxfpu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxfpu.h?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,26 +0,0 @@\n-/* Definitions for Xilinx PowerPC 405/440 APU.\n-\n-   Copyright (C) 2008-2018 Free Software Foundation, Inc.\n-   Contributed by Michael Eager (eager@eagercon.com)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-\n-/* Undefine definitions from rs6000.h. */\n-#undef TARGET_XILINX_FPU \n-\n-#define TARGET_XILINX_FPU  (rs6000_xilinx_fpu)"}, {"sha": "c0195a3ef66131a1078b5a1a812966e06f34ba10", "filename": "gcc/config/rs6000/xfpu.md", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxfpu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxfpu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxfpu.md?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,140 +0,0 @@\n-;; Scheduling description for the Xilinx PowerPC 405 APU Floating Point Unit.\n-;; Copyright (C) 2008-2018 Free Software Foundation, Inc.\n-;; Contributed by Michael Eager (eager@eagercon.com).\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;;----------------------------------------------------\n-;; Xilinx APU FPU Pipeline Description\n-;;\n-;;  - attr 'type' and 'fp_type' should definitely\n-;;    be cleaned up at some point in the future.\n-;;    ddiv,sdiv,dmul,smul etc are quite confusing.\n-;;    Should use consistent fp* attrs. 'fp_type'\n-;;    should also go away, leaving us only with 'fp'\n-;;\n-;;----------------------------------------------------\n-\n-;; -------------------------------------------------------------------------\n-;; Latencies\n-;; Latest latency figures (all in FCB cycles). PowerPC to FPU frequency ratio\n-;; assumed to be 1/2. (most common deployment)\n-;; Add 2 PPC cycles for (register file access + wb) and 2 PPC cycles \n-;; for issue (from PPC)\n-;;                          SP          DP\n-;; Loads:                    4           6\n-;; Stores:                   1           2      (from availability of data)\n-;; Move/Abs/Neg:             1           1\n-;; Add/Subtract:             5           7\n-;; Multiply:                 4          11\n-;; Multiply-add:            10          19\n-;; Convert (any):            4           6\n-;; Divide/Sqrt:             27          56\n-;; Compares:                 1           2\n-;;\n-;; bypasses needed for forwarding capability of the FPU. \n-;; Add this at some future time.\n-;; -------------------------------------------------------------------------\n-(define_automaton \"Xfpu\")\n-(define_cpu_unit \"Xfpu_issue,Xfpu_addsub,Xfpu_mul,Xfpu_div,Xfpu_sqrt\" \"Xfpu\")\n-\n-\n-(define_insn_reservation \"fp-default\" 2\n-  (and (and \n-        (eq_attr \"type\" \"fp,fpsimple\")\n-        (eq_attr \"fp_type\" \"fp_default\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2\")\n-\n-(define_insn_reservation \"fp-compare\" 6\n-  (and (eq_attr \"type\" \"fpcompare\")                     ;; Inconsistent naming\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_addsub\")\n-\n-(define_insn_reservation \"fp-addsub-s\" 14\n-  (and (and\n-        (eq_attr \"type\" \"fp,fpsimple\")\n-        (eq_attr \"fp_type\" \"fp_addsub_s\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_addsub\")\n-\n-(define_insn_reservation \"fp-addsub-d\" 18\n-  (and (and\n-        (eq_attr \"type\" \"fp,fpsimple\")\n-        (eq_attr \"fp_type\" \"fp_addsub_d\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_addsub\")\n-\n-(define_insn_reservation \"fp-mul-s\" 12\n-  (and (and\n-        (eq_attr \"type\" \"fp\")\n-        (eq_attr \"fp_type\" \"fp_mul_s\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_mul\")\n-\n-(define_insn_reservation \"fp-mul-d\" 16    ;; Actually 28. Long latencies are killing the automaton formation. Need to figure out why.\n-  (and (and\n-        (eq_attr \"type\" \"fp\")\n-        (eq_attr \"fp_type\" \"fp_mul_d\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_mul\")\n-\n-(define_insn_reservation \"fp-div-s\" 24                   ;; Actually 34\n-   (and (eq_attr \"type\" \"sdiv\")                          ;; Inconsistent attr naming\n-        (eq_attr \"cpu\" \"ppc405\"))\n-   \"Xfpu_issue*2,Xfpu_div*10\")                           ;; Unpipelined\n-\n-(define_insn_reservation \"fp-div-d\" 34                   ;; Actually 116\n-  (and (eq_attr \"type\" \"ddiv\")\n-       (eq_attr \"cpu\" \"ppc405\"))                         ;; Inconsistent attr naming\n-  \"Xfpu_issue*2,Xfpu_div*10\")                            ;; Unpipelined\n-\n-(define_insn_reservation \"fp-maddsub-s\" 24\n-  (and (and\n-        (eq_attr \"type\" \"fp\")\n-        (eq_attr \"fp_type\" \"fp_maddsub_s\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_mul,nothing*7,Xfpu_addsub\")\n-\n-(define_insn_reservation \"fp-maddsub-d\" 34              ;; Actually 42\n-  (and (and\n-        (eq_attr \"type\" \"dmul\")                         ;; Inconsistent attr naming\n-        (eq_attr \"fp_type\" \"fp_maddsub_d\"))\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_mul,nothing*7,Xfpu_addsub\")\n-\n-(define_insn_reservation \"fp-load\" 10                   ;; FIXME. Is double/single precision the same ?\n-  (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*10\")\n-\n-(define_insn_reservation \"fp-store\" 4\n-  (and (eq_attr \"type\" \"fpstore\")\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*4\")\n-\n-(define_insn_reservation \"fp-sqrt-s\" 24         ;; Actually 56\n-  (and (eq_attr \"type\" \"ssqrt\")\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_sqrt*10\")                  ;; Unpipelined\n-\n-\n-(define_insn_reservation \"fp-sqrt-d\" 34         ;; Actually 116\n-  (and (eq_attr \"type\" \"dsqrt\")\n-       (eq_attr \"cpu\" \"ppc405\"))\n-  \"Xfpu_issue*2,Xfpu_sqrt*10\")                  ;; Unpipelined\n-"}, {"sha": "66740fd64cd9eb72ef6c2c31a637ce9c5597ca6b", "filename": "gcc/config/rs6000/xilinx.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxilinx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxilinx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxilinx.h?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,47 +0,0 @@\n-/* Support for GCC on Xilinx embedded PowerPC systems\n-   Copyright (C) 2008-2018 Free Software Foundation, Inc.\n-   Contributed by Michael Eager, eager@eagercon.com\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Set defaults for Xilinx embedded target boards. */\n-\n-#undef  CPP_SPEC\n-#define CPP_SPEC \"\\\n--mxilinx-fpu                                    \\\n-%{mfpu=sp_lite: -DHAVE_XFPU_SP_LITE}            \\\n-%{mfpu=sp_full: -DHAVE_XFPU_SP_FULL}            \\\n-%{mfpu=dp_lite: -DHAVE_XFPU_DP_LITE}            \\\n-%{mfpu=dp_full: -DHAVE_XFPU_DP_FULL}            \\\n-%{mfpu=*:   -DHAVE_XFPU}\"\n-\n-#undef\tLIB_DEFAULT_SPEC\n-#define LIB_DEFAULT_SPEC \"\\\n-%{!nostdlib: --start-group -lxil -lc -lm --end-group   \\\n-%{mppcperflib: %{mfpu=*: -lppcstr405 -lgcc}            \\\n-%{!mfpu=*: -lppcstr405 -lppcfp -lgcc}}                 \\\n-%{!mppcperflib: -lgcc}}\"\n-\n-#undef\tSTARTFILE_DEFAULT_SPEC\n-#define STARTFILE_DEFAULT_SPEC \"\\\n-ecrti.o%s %{pg: %{!mno-clearbss: xil-pgcrt0.o%s} \\\n-%{mno-clearbss: xil-sim-pgcrt0.o%s}}            \\\n-%{!pg: %{!mno-clearbss: xil-crt0.o%s}           \\\n-%{mno-clearbss: xil-sim-crt0.o%s}} crtbegin.o%s\"\n-\n-#undef\tLINK_START_DEFAULT_SPEC\n-#define LINK_START_DEFAULT_SPEC \"-T xilinx.ld%s\""}, {"sha": "7afbcbb1e2c25bc2edb49445fa99436c0da26215", "filename": "gcc/config/rs6000/xilinx.opt", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxilinx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/gcc%2Fconfig%2Frs6000%2Fxilinx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxilinx.opt?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,32 +0,0 @@\n-; Xilinx embedded PowerPC options.\n-\n-; Copyright (C) 2011-2018 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-; See the GCC internals manual (options.texi) for a description of\n-; this file's format.\n-\n-; Please try to keep this file in ASCII collating order.\n-\n-mno-clearbss\n-Target RejectNegative\n-\n-mppcperflib\n-Target RejectNegative\n-\n-; This comment is to ensure we retain the blank line above."}, {"sha": "255149fcfb87001eaebc5477d9d697d274ff1432", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c2aa74d1df07cbe24739ddd7d0fcb175479bb87/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2c2aa74d1df07cbe24739ddd7d0fcb175479bb87", "patch": "@@ -1065,7 +1065,6 @@ See RS/6000 and PowerPC Options.\n -m64  -m32  -mxl-compat  -mno-xl-compat  -mpe @gol\n -malign-power  -malign-natural @gol\n -msoft-float  -mhard-float  -mmultiple  -mno-multiple @gol\n--msingle-float  -mdouble-float  -msimple-fpu @gol\n -mupdate  -mno-update @gol\n -mavoid-indexed-addresses  -mno-avoid-indexed-addresses @gol\n -mfused-madd  -mno-fused-madd  -mbit-align  -mno-bit-align @gol\n@@ -23340,8 +23339,8 @@ following options:\n \n @gccoptlist{-maltivec  -mfprnd  -mhard-float  -mmfcrf  -mmultiple @gol\n -mpopcntb -mpopcntd  -mpowerpc64 @gol\n--mpowerpc-gpopt  -mpowerpc-gfxopt  -msingle-float -mdouble-float @gol\n--msimple-fpu  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n+-mpowerpc-gpopt  -mpowerpc-gfxopt @gol\n+-mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n -mcrypto -mhtm -mpower8-fusion -mpower8-vector @gol\n -mquad-memory -mquad-memory-atomic -mfloat128 -mfloat128-hardware}\n \n@@ -23660,30 +23659,6 @@ Generate code that does not use (uses) the floating-point register set.\n Software floating-point emulation is provided if you use the\n @option{-msoft-float} option, and pass the option to GCC when linking.\n \n-@item -msingle-float\n-@itemx -mdouble-float\n-@opindex msingle-float\n-@opindex mdouble-float\n-Generate code for single- or double-precision floating-point operations.\n-@option{-mdouble-float} implies @option{-msingle-float}.\n-\n-@item -msimple-fpu\n-@opindex msimple-fpu\n-Do not generate @code{sqrt} and @code{div} instructions for hardware\n-floating-point unit.\n-\n-@item -mfpu=@var{name}\n-@opindex mfpu\n-Specify type of floating-point unit.  Valid values for @var{name} are\n-@samp{sp_lite} (equivalent to @option{-msingle-float -msimple-fpu}),\n-@samp{dp_lite} (equivalent to @option{-mdouble-float -msimple-fpu}),\n-@samp{sp_full} (equivalent to @option{-msingle-float}),\n-and @samp{dp_full} (equivalent to @option{-mdouble-float}).\n-\n-@item -mxilinx-fpu\n-@opindex mxilinx-fpu\n-Perform optimizations for the floating-point unit on Xilinx PPC 405/440.\n-\n @item -mmultiple\n @itemx -mno-multiple\n @opindex mmultiple"}]}