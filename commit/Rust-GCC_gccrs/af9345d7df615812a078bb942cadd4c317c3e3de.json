{"sha": "af9345d7df615812a078bb942cadd4c317c3e3de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5MzQ1ZDdkZjYxNTgxMmEwNzhiYjk0MmNhZGQ0YzMxN2MzZTNkZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2015-12-22T15:38:25Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2015-12-22T15:38:25Z"}, "message": "[PATCH] Use call-clobbered register for sibcall via GOT\n\nFrom: H.J. Lu  <hongjiu.lu@intel.com>\n\nSince sibcall never returns, we can only use call-clobbered register as\nGOT base.  Otherwise, callee-saved register used as GOT base won't be\nproperly restored.  sibcall_memory_operand is changed to allow 32-bit\nGOT slot only with pseudo register as GOT base for RTL expansion.  2\nnew patterns, *sibcall_GOT_32 and *sibcall_value_GOT_32, are added to\nexpose GOT base register to register allocator so that call-clobbered\nregister will be used for GOT base.\n\ngcc/\n\n\tPR target/68937\n\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Count\n\tcall to global function via GOT slot as indirect call.\n\t* config/i386/i386.md (*sibcall_GOT_32): New pattern.\n\t(*sibcall_value_GOT_32): Likewise.\n\t* config/i386/predicates.md (sibcall_memory_operand): Rewrite.\n\tAllow 32-bit GOT slot only with pseudo register as GOT base.\n\t(GOT32_symbol_operand): New predicate.\n\ngcc/testsuite/\n\n\tPR target/68937\n\t* gcc.target/i386/pr68937-1.c: New test.\n\t* gcc.target/i386/pr68937-2.c: Likewise.\n\t* gcc.target/i386/pr68937-3.c: Likewise.\n\t* gcc.target/i386/pr68937-4.c: Likewise.\n\t* gcc.target/i386/pr68937-5.c: Likewise.\n\t* gcc.target/i386/pr68937-6.c: Likewise.\n\nFrom-SVN: r231903", "tree": {"sha": "50dc8240bb2cdb582ac0bdae2f5b1ce15d0be998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50dc8240bb2cdb582ac0bdae2f5b1ce15d0be998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af9345d7df615812a078bb942cadd4c317c3e3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9345d7df615812a078bb942cadd4c317c3e3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af9345d7df615812a078bb942cadd4c317c3e3de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9345d7df615812a078bb942cadd4c317c3e3de/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fda5652f8fe24f637b29608d12fff72e6df08ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fda5652f8fe24f637b29608d12fff72e6df08ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fda5652f8fe24f637b29608d12fff72e6df08ba9"}], "stats": {"total": 172, "additions": 163, "deletions": 9}, "files": [{"sha": "0cf2dc4882314914015424673a46201dd3333a00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -1,3 +1,14 @@\n+2015-12-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/68937\n+\t* config/i386/i386.c (ix86_function_ok_for_sibcall): Count\n+\tcall to global function via GOT slot as indirect call.\n+\t* config/i386/i386.md (*sibcall_GOT_32): New pattern.\n+\t(*sibcall_value_GOT_32): Likewise.\n+\t* config/i386/predicates.md (sibcall_memory_operand): Rewrite.\n+\tAllow 32-bit GOT slot only with pseudo register as GOT base.\n+\t(GOT32_symbol_operand): New predicate.\n+\n 2015-12-22  Sujoy Saraswati  <sujoy.saraswati@hpe.com>\n \n \t* fold-const.c (const_binop): Convert sNaN to qNaN when"}, {"sha": "f5d23d9b9479ae0b0824fe681ee9cbb7bc81e4f6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -6657,6 +6657,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n {\n   tree type, decl_or_type;\n   rtx a, b;\n+  bool bind_global = decl && !targetm.binds_local_p (decl);\n \n   /* If we are generating position-independent code, we cannot sibcall\n      optimize direct calls to global functions, as the PLT requires\n@@ -6665,7 +6666,7 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n       && !TARGET_64BIT\n       && flag_pic\n       && flag_plt\n-      && decl && !targetm.binds_local_p (decl))\n+      && bind_global)\n     return false;\n \n   /* If we need to align the outgoing stack, then sibcalling would\n@@ -6723,8 +6724,10 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n       /* If this call is indirect, we'll need to be able to use a\n \t call-clobbered register for the address of the target function.\n \t Make sure that all such registers are not used for passing\n-\t parameters.  Note that DLLIMPORT functions are indirect.  */\n+\t parameters.  Note that DLLIMPORT functions and call to global\n+\t function via GOT slot are indirect.  */\n       if (!decl\n+\t  || (bind_global && flag_pic && !flag_plt)\n \t  || (TARGET_DLLIMPORT_DECL_ATTRIBUTES && DECL_DLLIMPORT_P (decl)))\n \t{\n \t  /* Check if regparm >= 3 since arg_reg_available is set to"}, {"sha": "5e5c97bf5152fe22ef3bcd3d5acfd4f1ada62012", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -11865,6 +11865,22 @@\n   \"* return ix86_output_call_insn (insn, operands[0]);\"\n   [(set_attr \"type\" \"call\")])\n \n+;; Since sibcall never returns, we can only use call-clobbered register\n+;; as GOT base.\n+(define_insn \"*sibcall_GOT_32\"\n+  [(call (mem:QI\n+\t   (mem:SI (plus:SI\n+\t\t     (match_operand:SI 0 \"register_no_elim_operand\" \"U\")\n+\t\t     (match_operand:SI 1 \"GOT32_symbol_operand\"))))\n+\t (match_operand 2))]\n+  \"!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+{\n+  rtx fnaddr = gen_rtx_PLUS (Pmode, operands[0], operands[1]);\n+  fnaddr = gen_const_mem (Pmode, fnaddr);\n+  return ix86_output_call_insn (insn, fnaddr);\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n (define_insn \"*sibcall\"\n   [(call (mem:QI (match_operand:W 0 \"sibcall_insn_operand\" \"UBsBz\"))\n \t (match_operand 1))]\n@@ -12042,6 +12058,23 @@\n   \"* return ix86_output_call_insn (insn, operands[1]);\"\n   [(set_attr \"type\" \"callv\")])\n \n+;; Since sibcall never returns, we can only use call-clobbered register\n+;; as GOT base.\n+(define_insn \"*sibcall_value_GOT_32\"\n+  [(set (match_operand 0)\n+        (call (mem:QI\n+\t\t(mem:SI (plus:SI\n+\t\t\t  (match_operand:SI 1 \"register_no_elim_operand\" \"U\")\n+\t\t\t  (match_operand:SI 2 \"GOT32_symbol_operand\"))))\n+\t (match_operand 3)))]\n+  \"!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n+{\n+  rtx fnaddr = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n+  fnaddr = gen_const_mem (Pmode, fnaddr);\n+  return ix86_output_call_insn (insn, fnaddr);\n+}\n+  [(set_attr \"type\" \"callv\")])\n+\n (define_insn \"*sibcall_value\"\n   [(set (match_operand 0)\n \t(call (mem:QI (match_operand:W 1 \"sibcall_insn_operand\" \"UBsBz\"))"}, {"sha": "96d946c63d36f30a1e30c7357b66c76927fc80aa", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -597,14 +597,28 @@\n \t    (match_operand 0 \"memory_operand\"))))\n \n ;; Return true if OP is a memory operands that can be used in sibcalls.\n+;; Since sibcall never returns, we can only use call-clobbered register\n+;; as GOT base.  Allow GOT slot here only with pseudo register as GOT\n+;; base.  Properly handle sibcall over GOT slot with *sibcall_GOT_32\n+;; and *sibcall_value_GOT_32 patterns.\n (define_predicate \"sibcall_memory_operand\"\n-  (and (match_operand 0 \"memory_operand\")\n-       (match_test \"CONSTANT_P (XEXP (op, 0))\n-\t\t    || (GET_CODE (XEXP (op, 0)) == PLUS\n-\t\t\t&& REG_P (XEXP (XEXP (op, 0), 0))\n-\t\t\t&& GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST\n-\t\t\t&& GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 0)) == UNSPEC\n-\t\t\t&& XINT (XEXP (XEXP (XEXP (op, 0), 1), 0), 1) == UNSPEC_GOT)\")))\n+  (match_operand 0 \"memory_operand\")\n+{\n+  op = XEXP (op, 0);\n+  if (CONSTANT_P (op))\n+    return true;\n+  if (GET_CODE (op) == PLUS && REG_P (XEXP (op, 0)))\n+    {\n+      int regno = REGNO (XEXP (op, 0));\n+      if (!HARD_REGISTER_NUM_P (regno) || call_used_regs[regno])\n+\t{\n+\t  op = XEXP (op, 1);\n+\t  if (GOT32_symbol_operand (op, VOIDmode))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+})\n \n ;; Test for a valid operand for a call instruction.\n ;; Allow constant call address operands in Pmode only.\n@@ -633,6 +647,12 @@\n \t  && XINT (XEXP (op, 0), 1) == UNSPEC_GOTPCREL);\n })\n \n+;; Return true if OP is a 32-bit GOT symbol operand.\n+(define_predicate \"GOT32_symbol_operand\"\n+  (match_test \"GET_CODE (op) == CONST\n+               && GET_CODE (XEXP (op, 0)) == UNSPEC\n+               && XINT (XEXP (op, 0), 1) == UNSPEC_GOT\"))\n+\n ;; Match exactly zero.\n (define_predicate \"const0_operand\"\n   (match_code \"const_int,const_wide_int,const_double,const_vector\")"}, {"sha": "b43cfee63e34cbbf8a87bed301128dc870ed1aed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -1,3 +1,13 @@\n+2015-12-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/68937\n+\t* gcc.target/i386/pr68937-1.c: New test.\n+\t* gcc.target/i386/pr68937-2.c: Likewise.\n+\t* gcc.target/i386/pr68937-3.c: Likewise.\n+\t* gcc.target/i386/pr68937-4.c: Likewise.\n+\t* gcc.target/i386/pr68937-5.c: Likewise.\n+\t* gcc.target/i386/pr68937-6.c: Likewise.\n+\n 2015-12-22  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/69002"}, {"sha": "897856bc590341573e6f88fb5a9cb1663d719047", "filename": "gcc/testsuite/gcc.target/i386/pr68937-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-1.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { *-*-linux* && ia32 } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -mregparm=3\" } */\n+\n+extern void bar (int);\n+\n+void\n+foo (int b)\n+{\n+  bar (b);\n+  bar (b);\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]*.bar@GOT\\\\(%e(a|c|d)x\\\\)\" } } */"}, {"sha": "257f4e267f468aed5a345351e6180ea509cc8b1d", "filename": "gcc/testsuite/gcc.target/i386/pr68937-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-2.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { *-*-linux* && ia32 } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -mregparm=3\" } */\n+\n+extern void bar (int, int);\n+\n+void\n+foo (int a, int b)\n+{\n+  bar (a, b);\n+  bar (a, b);\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]*.bar@GOT\\\\(%e(a|c|d)x\\\\)\" } } */"}, {"sha": "6d8e40ff769dfdf9d20ad077b730e9e7e441f5bb", "filename": "gcc/testsuite/gcc.target/i386/pr68937-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-3.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { *-*-linux* && ia32 } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -mregparm=3\" } */\n+\n+extern void bar (int, int, int);\n+\n+void\n+foo (int a, int b, int c)\n+{\n+  bar (a, b, c);\n+  bar (a, b, c);\n+}\n+\n+/* { dg-final { scan-assembler-not \"jmp\\[ \\t\\]*.bar@GOT\" } } */"}, {"sha": "9c199568d661fa53e27c02b426b2417be52f11cd", "filename": "gcc/testsuite/gcc.target/i386/pr68937-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-4.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { *-*-linux* && ia32 } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -mregparm=3\" } */\n+\n+extern int bar (int, int);\n+\n+int\n+foo (int a, int b)\n+{\n+  (void) bar (a, b);\n+  return bar (a, b);\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]*.bar@GOT\\\\(%e(a|c|d)x\\\\)\" } } */"}, {"sha": "f7e3ec5ef1e18c23b5b50db096e8ea1995b3eaec", "filename": "gcc/testsuite/gcc.target/i386/pr68937-5.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-5.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { *-*-linux* } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -funroll-loops\" } */\n+\n+extern void *f();\n+void dmi_scan_machine(void) {\n+  char *p = f(), *q;\n+  for (q = p; q < p + 10; q++)\n+    ;\n+}"}, {"sha": "406ce282d94522303ccfd5e188352c39b032bde5", "filename": "gcc/testsuite/gcc.target/i386/pr68937-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af9345d7df615812a078bb942cadd4c317c3e3de/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68937-6.c?ref=af9345d7df615812a078bb942cadd4c317c3e3de", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { *-*-linux* && ia32 } } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -mregparm=3\" } */\n+\n+extern void foo (int, int, int);\n+extern void bar (int, int, int) __attribute__((visibility(\"hidden\")));\n+\n+void\n+foo (int a, int b, int c)\n+{\n+  foo (a, b, c);\n+  bar (a, b, c);\n+  foo (a, b, c);\n+  bar (a, b, c);\n+}\n+\n+/* { dg-final { scan-assembler \"jmp\\[ \\t\\]bar\" } } */"}]}