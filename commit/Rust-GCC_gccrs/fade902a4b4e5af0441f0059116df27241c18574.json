{"sha": "fade902a4b4e5af0441f0059116df27241c18574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkZTkwMmE0YjRlNWFmMDQ0MWYwMDU5MTE2ZGYyNzI0MWMxODU3NA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-18T18:12:57Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-04-18T18:12:57Z"}, "message": "tree-switch-conversion.c (info): Remove global pass info.\n\n\t* tree-switch-conversion.c (info): Remove global pass info.\n\t(check_range, check_process_case, check_final_bb, create_temp_arrays,\n\tfree_temp_arrays, gather_default_values, build_constructors,\n\tarray_value_type, build_one_array, build_arrays, gen_def_assigns,\n\tfix_phi_nodes, gen_inbound_check): Pass info around from ...\n\t(process_switch): ... here.  Unify message format.  Return a const\n\tchar pointer to the failure reason message.\n\t(do_switchconv): Unify message format.  Update process_switch usage.\n\nFrom-SVN: r186576", "tree": {"sha": "cdbba559b43d3a26e6638615aaa7001f697df44a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdbba559b43d3a26e6638615aaa7001f697df44a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fade902a4b4e5af0441f0059116df27241c18574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fade902a4b4e5af0441f0059116df27241c18574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fade902a4b4e5af0441f0059116df27241c18574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fade902a4b4e5af0441f0059116df27241c18574/comments", "author": null, "committer": null, "parents": [{"sha": "308e3ba6f57485756135cd8c8262a3a076c01bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308e3ba6f57485756135cd8c8262a3a076c01bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308e3ba6f57485756135cd8c8262a3a076c01bd0"}], "stats": {"total": 312, "additions": 161, "deletions": 151}, "files": [{"sha": "019b91819624b7cc058d71477381c0abd715d315", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fade902a4b4e5af0441f0059116df27241c18574/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fade902a4b4e5af0441f0059116df27241c18574/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fade902a4b4e5af0441f0059116df27241c18574", "patch": "@@ -1,5 +1,14 @@\n 2012-04-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n+\t* tree-switch-conversion.c (info): Remove global pass info.\n+\t(check_range, check_process_case, check_final_bb, create_temp_arrays,\n+\tfree_temp_arrays, gather_default_values, build_constructors,\n+\tarray_value_type, build_one_array, build_arrays, gen_def_assigns,\n+\tfix_phi_nodes, gen_inbound_check): Pass info around from ...\n+\t(process_switch): ... here.  Unify message format.  Return a const\n+\tchar pointer to the failure reason message.\n+\t(do_switchconv): Unify message format.  Update process_switch usage.\n+\n \t* tree.def (CASE_LABEL_EXPR): Fix documentation, mention all operands.\n \t* tree-cfg.c (edge_to_cases): Fix documentation.\n "}, {"sha": "aa7b6c7d12ef8530a63ff630ab798eb0b1cb4fe5", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 152, "deletions": 151, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fade902a4b4e5af0441f0059116df27241c18574/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fade902a4b4e5af0441f0059116df27241c18574/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=fade902a4b4e5af0441f0059116df27241c18574", "patch": "@@ -24,8 +24,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      Switch initialization conversion\n \n The following pass changes simple initializations of scalars in a switch\n-statement into initializations from a static array.  Obviously, the values must\n-be constant and known at compile time and a default branch must be\n+statement into initializations from a static array.  Obviously, the values\n+must be constant and known at compile time and a default branch must be\n provided.  For example, the following code:\n \n         int a,b;\n@@ -162,16 +162,12 @@ struct switch_conv_info\n   basic_block bit_test_bb[2];\n };\n \n-/* Global pass info.  */\n-static struct switch_conv_info info;\n-\n-\n /* Checks whether the range given by individual case statements of the SWTCH\n    switch statement isn't too big and whether the number of branches actually\n    satisfies the size of the new array.  */\n \n static bool\n-check_range (gimple swtch)\n+check_range (gimple swtch, struct switch_conv_info *info)\n {\n   tree min_case, max_case;\n   unsigned int branch_num = gimple_switch_num_labels (swtch);\n@@ -181,7 +177,7 @@ check_range (gimple swtch)\n      is a default label which is the first in the vector.  */\n \n   min_case = gimple_switch_label (swtch, 1);\n-  info.range_min = CASE_LOW (min_case);\n+  info->range_min = CASE_LOW (min_case);\n \n   gcc_assert (branch_num > 1);\n   gcc_assert (CASE_LOW (gimple_switch_label (swtch, 0)) == NULL_TREE);\n@@ -191,22 +187,22 @@ check_range (gimple swtch)\n   else\n     range_max = CASE_LOW (max_case);\n \n-  gcc_assert (info.range_min);\n+  gcc_assert (info->range_min);\n   gcc_assert (range_max);\n \n-  info.range_size = int_const_binop (MINUS_EXPR, range_max, info.range_min);\n+  info->range_size = int_const_binop (MINUS_EXPR, range_max, info->range_min);\n \n-  gcc_assert (info.range_size);\n-  if (!host_integerp (info.range_size, 1))\n+  gcc_assert (info->range_size);\n+  if (!host_integerp (info->range_size, 1))\n     {\n-      info.reason = \"index range way too large or otherwise unusable.\\n\";\n+      info->reason = \"index range way too large or otherwise unusable\";\n       return false;\n     }\n \n-  if ((unsigned HOST_WIDE_INT) tree_low_cst (info.range_size, 1)\n+  if ((unsigned HOST_WIDE_INT) tree_low_cst (info->range_size, 1)\n       > ((unsigned) branch_num * SWITCH_CONVERSION_BRANCH_RATIO))\n     {\n-      info.reason = \"the maximum range-branch ratio exceeded.\\n\";\n+      info->reason = \"the maximum range-branch ratio exceeded\";\n       return false;\n     }\n \n@@ -219,7 +215,7 @@ check_range (gimple swtch)\n    and returns true.  Otherwise returns false.  */\n \n static bool\n-check_process_case (tree cs)\n+check_process_case (tree cs, struct switch_conv_info *info)\n {\n   tree ldecl;\n   basic_block label_bb, following_bb;\n@@ -228,48 +224,48 @@ check_process_case (tree cs)\n   ldecl = CASE_LABEL (cs);\n   label_bb = label_to_block (ldecl);\n \n-  e = find_edge (info.switch_bb, label_bb);\n+  e = find_edge (info->switch_bb, label_bb);\n   gcc_assert (e);\n \n   if (CASE_LOW (cs) == NULL_TREE)\n     {\n       /* Default branch.  */\n-      info.default_prob = e->probability;\n-      info.default_count = e->count;\n+      info->default_prob = e->probability;\n+      info->default_count = e->count;\n     }\n   else\n     {\n       int i;\n-      info.other_count += e->count;\n+      info->other_count += e->count;\n       for (i = 0; i < 2; i++)\n-\tif (info.bit_test_bb[i] == label_bb)\n+\tif (info->bit_test_bb[i] == label_bb)\n \t  break;\n-\telse if (info.bit_test_bb[i] == NULL)\n+\telse if (info->bit_test_bb[i] == NULL)\n \t  {\n-\t    info.bit_test_bb[i] = label_bb;\n-\t    info.bit_test_uniq++;\n+\t    info->bit_test_bb[i] = label_bb;\n+\t    info->bit_test_uniq++;\n \t    break;\n \t  }\n       if (i == 2)\n-\tinfo.bit_test_uniq = 3;\n+\tinfo->bit_test_uniq = 3;\n       if (CASE_HIGH (cs) != NULL_TREE\n \t  && ! tree_int_cst_equal (CASE_LOW (cs), CASE_HIGH (cs)))\n-\tinfo.bit_test_count += 2;\n+\tinfo->bit_test_count += 2;\n       else\n-\tinfo.bit_test_count++;\n+\tinfo->bit_test_count++;\n     }\n \n   if (!label_bb)\n     {\n-      info.reason = \"  Bad case - cs BB  label is NULL\\n\";\n+      info->reason = \"bad case - cs BB  label is NULL\";\n       return false;\n     }\n \n   if (!single_pred_p (label_bb))\n     {\n-      if (info.final_bb && info.final_bb != label_bb)\n+      if (info->final_bb && info->final_bb != label_bb)\n \t{\n-\t  info.reason = \"  Bad case - a non-final BB has two predecessors\\n\";\n+\t  info->reason = \"bad case - a non-final BB has two predecessors\";\n \t  return false; /* sth complex going on in this branch  */\n \t}\n \n@@ -279,19 +275,19 @@ check_process_case (tree cs)\n     {\n       if (!empty_block_p (label_bb))\n \t{\n-\t  info.reason = \"  Bad case - a non-final BB not empty\\n\";\n+\t  info->reason = \"bad case - a non-final BB not empty\";\n \t  return false;\n \t}\n \n       e = single_succ_edge (label_bb);\n       following_bb = single_succ (label_bb);\n     }\n \n-  if (!info.final_bb)\n-    info.final_bb = following_bb;\n-  else if (info.final_bb != following_bb)\n+  if (!info->final_bb)\n+    info->final_bb = following_bb;\n+  else if (info->final_bb != following_bb)\n     {\n-      info.reason = \"  Bad case - different final BB\\n\";\n+      info->reason = \"bad case - different final BB\";\n       return false; /* the only successor is not common for all the branches */\n     }\n \n@@ -304,43 +300,43 @@ check_process_case (tree cs)\n    phi nodes are OK, otherwise false.  */\n \n static bool\n-check_final_bb (void)\n+check_final_bb (struct switch_conv_info *info)\n {\n   gimple_stmt_iterator gsi;\n \n-  info.phi_count = 0;\n-  for (gsi = gsi_start_phis (info.final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  info->phi_count = 0;\n+  for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n       unsigned int i;\n \n-      info.phi_count++;\n+      info->phi_count++;\n \n       for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t{\n \t  basic_block bb = gimple_phi_arg_edge (phi, i)->src;\n \n-\t  if (bb == info.switch_bb\n-\t      || (single_pred_p (bb) && single_pred (bb) == info.switch_bb))\n+\t  if (bb == info->switch_bb\n+\t      || (single_pred_p (bb) && single_pred (bb) == info->switch_bb))\n \t    {\n \t      tree reloc, val;\n \n \t      val = gimple_phi_arg_def (phi, i);\n \t      if (!is_gimple_ip_invariant (val))\n \t\t{\n-\t\t  info.reason = \"   Non-invariant value from a case\\n\";\n+\t\t  info->reason = \"non-invariant value from a case\";\n \t\t  return false; /* Non-invariant argument.  */\n \t\t}\n \t      reloc = initializer_constant_valid_p (val, TREE_TYPE (val));\n \t      if ((flag_pic && reloc != null_pointer_node)\n \t\t  || (!flag_pic && reloc == NULL_TREE))\n \t\t{\n \t\t  if (reloc)\n-\t\t    info.reason\n-\t\t      = \"   Value from a case would need runtime relocations\\n\";\n+\t\t    info->reason\n+\t\t      = \"value from a case would need runtime relocations\";\n \t\t  else\n-\t\t    info.reason\n-\t\t      = \"   Value from a case is not a valid initializer\\n\";\n+\t\t    info->reason\n+\t\t      = \"value from a case is not a valid initializer\";\n \t\t  return false;\n \t\t}\n \t    }\n@@ -355,35 +351,35 @@ check_final_bb (void)\n    vectors that will become constructors of new arrays.  */\n \n static void\n-create_temp_arrays (void)\n+create_temp_arrays (struct switch_conv_info *info)\n {\n   int i;\n \n-  info.default_values = XCNEWVEC (tree, info.phi_count * 3);\n-  info.constructors = XCNEWVEC (VEC (constructor_elt, gc) *, info.phi_count);\n-  info.target_inbound_names = info.default_values + info.phi_count;\n-  info.target_outbound_names = info.target_inbound_names + info.phi_count;\n-  for (i = 0; i < info.phi_count; i++)\n-    info.constructors[i]\n-      = VEC_alloc (constructor_elt, gc, tree_low_cst (info.range_size, 1) + 1);\n+  info->default_values = XCNEWVEC (tree, info->phi_count * 3);\n+  info->constructors = XCNEWVEC (VEC (constructor_elt, gc) *, info->phi_count);\n+  info->target_inbound_names = info->default_values + info->phi_count;\n+  info->target_outbound_names = info->target_inbound_names + info->phi_count;\n+  for (i = 0; i < info->phi_count; i++)\n+    info->constructors[i]\n+      = VEC_alloc (constructor_elt, gc, tree_low_cst (info->range_size, 1) + 1);\n }\n \n /* Free the arrays created by create_temp_arrays().  The vectors that are\n    created by that function are not freed here, however, because they have\n    already become constructors and must be preserved.  */\n \n static void\n-free_temp_arrays (void)\n+free_temp_arrays (struct switch_conv_info *info)\n {\n-  XDELETEVEC (info.constructors);\n-  XDELETEVEC (info.default_values);\n+  XDELETEVEC (info->constructors);\n+  XDELETEVEC (info->default_values);\n }\n \n /* Populate the array of default values in the order of phi nodes.\n    DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch.  */\n \n static void\n-gather_default_values (tree default_case)\n+gather_default_values (tree default_case, struct switch_conv_info *info)\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb = label_to_block (CASE_LABEL (default_case));\n@@ -392,17 +388,17 @@ gather_default_values (tree default_case)\n \n   gcc_assert (CASE_LOW (default_case) == NULL_TREE);\n \n-  if (bb == info.final_bb)\n-    e = find_edge (info.switch_bb, bb);\n+  if (bb == info->final_bb)\n+    e = find_edge (info->switch_bb, bb);\n   else\n     e = single_succ_edge (bb);\n \n-  for (gsi = gsi_start_phis (info.final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = gsi_start_phis (info->final_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n       tree val = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       gcc_assert (val);\n-      info.default_values[i++] = val;\n+      info->default_values[i++] = val;\n     }\n }\n \n@@ -411,10 +407,10 @@ gather_default_values (tree default_case)\n    order of phi nodes.  SWTCH is the switch statement being converted.  */\n \n static void\n-build_constructors (gimple swtch)\n+build_constructors (gimple swtch, struct switch_conv_info *info)\n {\n   unsigned i, branch_num = gimple_switch_num_labels (swtch);\n-  tree pos = info.range_min;\n+  tree pos = info->range_min;\n \n   for (i = 1; i < branch_num; i++)\n     {\n@@ -425,24 +421,24 @@ build_constructors (gimple swtch)\n       gimple_stmt_iterator gsi;\n       int j;\n \n-      if (bb == info.final_bb)\n-\te = find_edge (info.switch_bb, bb);\n+      if (bb == info->final_bb)\n+\te = find_edge (info->switch_bb, bb);\n       else\n \te = single_succ_edge (bb);\n       gcc_assert (e);\n \n       while (tree_int_cst_lt (pos, CASE_LOW (cs)))\n \t{\n \t  int k;\n-\t  for (k = 0; k < info.phi_count; k++)\n+\t  for (k = 0; k < info->phi_count; k++)\n \t    {\n \t      constructor_elt *elt;\n \n \t      elt = VEC_quick_push (constructor_elt,\n-\t\t\t\t    info.constructors[k], NULL);\n+\t\t\t\t    info->constructors[k], NULL);\n \t      elt->index = int_const_binop (MINUS_EXPR, pos,\n-\t\t\t\t\t    info.range_min);\n-\t      elt->value = info.default_values[k];\n+\t\t\t\t\t    info->range_min);\n+\t      elt->value = info->default_values[k];\n \t    }\n \n \t  pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n@@ -454,7 +450,7 @@ build_constructors (gimple swtch)\n \thigh = CASE_HIGH (cs);\n       else\n \thigh = CASE_LOW (cs);\n-      for (gsi = gsi_start_phis (info.final_bb);\n+      for (gsi = gsi_start_phis (info->final_bb);\n \t   !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n@@ -467,8 +463,8 @@ build_constructors (gimple swtch)\n \t      constructor_elt *elt;\n \n \t      elt = VEC_quick_push (constructor_elt,\n-\t\t\t\t    info.constructors[j], NULL);\n-\t      elt->index = int_const_binop (MINUS_EXPR, pos, info.range_min);\n+\t\t\t\t    info->constructors[j], NULL);\n+\t      elt->index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n \t      elt->value = val;\n \n \t      pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n@@ -505,9 +501,10 @@ constructor_contains_same_values_p (VEC (constructor_elt, gc) *vec)\n    all the constants.  */\n \n static tree\n-array_value_type (gimple swtch, tree type, int num)\n+array_value_type (gimple swtch, tree type, int num,\n+\t\t  struct switch_conv_info *info)\n {\n-  unsigned int i, len = VEC_length (constructor_elt, info.constructors[num]);\n+  unsigned int i, len = VEC_length (constructor_elt, info->constructors[num]);\n   constructor_elt *elt;\n   enum machine_mode mode;\n   int sign = 0;\n@@ -523,7 +520,7 @@ array_value_type (gimple swtch, tree type, int num)\n   if (len < (optimize_bb_for_size_p (gimple_bb (swtch)) ? 2 : 32))\n     return type;\n \n-  FOR_EACH_VEC_ELT (constructor_elt, info.constructors[num], i, elt)\n+  FOR_EACH_VEC_ELT (constructor_elt, info->constructors[num], i, elt)\n     {\n       double_int cst;\n \n@@ -585,37 +582,37 @@ array_value_type (gimple swtch, tree type, int num)\n \n static void\n build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n-\t\t tree tidx)\n+\t\t tree tidx, struct switch_conv_info *info)\n {\n   tree name, cst;\n   gimple load;\n   gimple_stmt_iterator gsi = gsi_for_stmt (swtch);\n   location_t loc = gimple_location (swtch);\n \n-  gcc_assert (info.default_values[num]);\n+  gcc_assert (info->default_values[num]);\n \n   name = make_ssa_name (SSA_NAME_VAR (PHI_RESULT (phi)), NULL);\n-  info.target_inbound_names[num] = name;\n+  info->target_inbound_names[num] = name;\n \n-  cst = constructor_contains_same_values_p (info.constructors[num]);\n+  cst = constructor_contains_same_values_p (info->constructors[num]);\n   if (cst)\n     load = gimple_build_assign (name, cst);\n   else\n     {\n       tree array_type, ctor, decl, value_type, fetch, default_type;\n \n-      default_type = TREE_TYPE (info.default_values[num]);\n-      value_type = array_value_type (swtch, default_type, num);\n+      default_type = TREE_TYPE (info->default_values[num]);\n+      value_type = array_value_type (swtch, default_type, num, info);\n       array_type = build_array_type (value_type, arr_index_type);\n       if (default_type != value_type)\n \t{\n \t  unsigned int i;\n \t  constructor_elt *elt;\n \n-\t  FOR_EACH_VEC_ELT (constructor_elt, info.constructors[num], i, elt)\n+\t  FOR_EACH_VEC_ELT (constructor_elt, info->constructors[num], i, elt)\n \t    elt->value = fold_convert (value_type, elt->value);\n \t}\n-      ctor = build_constructor (array_type, info.constructors[num]);\n+      ctor = build_constructor (array_type, info->constructors[num]);\n       TREE_CONSTANT (ctor) = true;\n       TREE_STATIC (ctor) = true;\n \n@@ -645,15 +642,15 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n   SSA_NAME_DEF_STMT (name) = load;\n   gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n   update_stmt (load);\n-  info.arr_ref_last = load;\n+  info->arr_ref_last = load;\n }\n \n /* Builds and initializes static arrays initialized with values gathered from\n    the SWTCH switch statement.  Also creates statements that load values from\n    them.  */\n \n static void\n-build_arrays (gimple swtch)\n+build_arrays (gimple swtch, struct switch_conv_info *info)\n {\n   tree arr_index_type;\n   tree tidx, sub, tmp, utype;\n@@ -665,49 +662,49 @@ build_arrays (gimple swtch)\n   gsi = gsi_for_stmt (swtch);\n \n   /* Make sure we do not generate arithmetics in a subrange.  */\n-  utype = TREE_TYPE (info.index_expr);\n+  utype = TREE_TYPE (info->index_expr);\n   if (TREE_TYPE (utype))\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (TREE_TYPE (utype)), 1);\n   else\n     utype = lang_hooks.types.type_for_mode (TYPE_MODE (utype), 1);\n \n-  arr_index_type = build_index_type (info.range_size);\n+  arr_index_type = build_index_type (info->range_size);\n   tmp = create_tmp_var (utype, \"csui\");\n   add_referenced_var (tmp);\n   tidx = make_ssa_name (tmp, NULL);\n   sub = fold_build2_loc (loc, MINUS_EXPR, utype,\n-\t\t\t fold_convert_loc (loc, utype, info.index_expr),\n-\t\t\t fold_convert_loc (loc, utype, info.range_min));\n+\t\t\t fold_convert_loc (loc, utype, info->index_expr),\n+\t\t\t fold_convert_loc (loc, utype, info->range_min));\n   sub = force_gimple_operand_gsi (&gsi, sub,\n \t\t\t\t  false, NULL, true, GSI_SAME_STMT);\n   stmt = gimple_build_assign (tidx, sub);\n   SSA_NAME_DEF_STMT (tidx) = stmt;\n \n   gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n   update_stmt (stmt);\n-  info.arr_ref_first = stmt;\n+  info->arr_ref_first = stmt;\n \n-  for (gsi = gsi_start_phis (info.final_bb), i = 0;\n+  for (gsi = gsi_start_phis (info->final_bb), i = 0;\n        !gsi_end_p (gsi); gsi_next (&gsi), i++)\n-    build_one_array (swtch, i, arr_index_type, gsi_stmt (gsi), tidx);\n+    build_one_array (swtch, i, arr_index_type, gsi_stmt (gsi), tidx, info);\n }\n \n /* Generates and appropriately inserts loads of default values at the position\n    given by BSI.  Returns the last inserted statement.  */\n \n static gimple\n-gen_def_assigns (gimple_stmt_iterator *gsi)\n+gen_def_assigns (gimple_stmt_iterator *gsi, struct switch_conv_info *info)\n {\n   int i;\n   gimple assign = NULL;\n \n-  for (i = 0; i < info.phi_count; i++)\n+  for (i = 0; i < info->phi_count; i++)\n     {\n       tree name\n-\t= make_ssa_name (SSA_NAME_VAR (info.target_inbound_names[i]), NULL);\n+\t= make_ssa_name (SSA_NAME_VAR (info->target_inbound_names[i]), NULL);\n \n-      info.target_outbound_names[i] = name;\n-      assign = gimple_build_assign (name, info.default_values[i]);\n+      info->target_outbound_names[i] = name;\n+      assign = gimple_build_assign (name, info->default_values[i]);\n       SSA_NAME_DEF_STMT (name) = assign;\n       gsi_insert_before (gsi, assign, GSI_SAME_STMT);\n       update_stmt (assign);\n@@ -743,7 +740,8 @@ prune_bbs (basic_block bbd, basic_block final)\n    bbf description in the comment below).  */\n \n static void\n-fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n+fix_phi_nodes (edge e1f, edge e2f, basic_block bbf,\n+\t       struct switch_conv_info *info)\n {\n   gimple_stmt_iterator gsi;\n   int i;\n@@ -752,10 +750,9 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n        !gsi_end_p (gsi); gsi_next (&gsi), i++)\n     {\n       gimple phi = gsi_stmt (gsi);\n-      add_phi_arg (phi, info.target_inbound_names[i], e1f, UNKNOWN_LOCATION);\n-      add_phi_arg (phi, info.target_outbound_names[i], e2f, UNKNOWN_LOCATION);\n+      add_phi_arg (phi, info->target_inbound_names[i], e1f, UNKNOWN_LOCATION);\n+      add_phi_arg (phi, info->target_outbound_names[i], e2f, UNKNOWN_LOCATION);\n     }\n-\n }\n \n /* Creates a check whether the switch expression value actually falls into the\n@@ -780,7 +777,7 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n */\n \n static void\n-gen_inbound_check (gimple swtch)\n+gen_inbound_check (gimple swtch, struct switch_conv_info *info)\n {\n   tree label_decl1 = create_artificial_label (UNKNOWN_LOCATION);\n   tree label_decl2 = create_artificial_label (UNKNOWN_LOCATION);\n@@ -797,32 +794,32 @@ gen_inbound_check (gimple swtch)\n   edge e01, e02, e21, e1d, e1f, e2f;\n   location_t loc = gimple_location (swtch);\n \n-  gcc_assert (info.default_values);\n+  gcc_assert (info->default_values);\n   bb0 = gimple_bb (swtch);\n \n-  tidx = gimple_assign_lhs (info.arr_ref_first);\n+  tidx = gimple_assign_lhs (info->arr_ref_first);\n   utype = TREE_TYPE (tidx);\n \n   /* (end of) block 0 */\n-  gsi = gsi_for_stmt (info.arr_ref_first);\n+  gsi = gsi_for_stmt (info->arr_ref_first);\n   gsi_next (&gsi);\n \n-  bound = fold_convert_loc (loc, utype, info.range_size);\n+  bound = fold_convert_loc (loc, utype, info->range_size);\n   cond_stmt = gimple_build_cond (LE_EXPR, tidx, bound, NULL_TREE, NULL_TREE);\n   gsi_insert_before (&gsi, cond_stmt, GSI_SAME_STMT);\n   update_stmt (cond_stmt);\n \n   /* block 2 */\n   label2 = gimple_build_label (label_decl2);\n   gsi_insert_before (&gsi, label2, GSI_SAME_STMT);\n-  last_assign = gen_def_assigns (&gsi);\n+  last_assign = gen_def_assigns (&gsi, info);\n \n   /* block 1 */\n   label1 = gimple_build_label (label_decl1);\n   gsi_insert_before (&gsi, label1, GSI_SAME_STMT);\n \n   /* block F */\n-  gsi = gsi_start_bb (info.final_bb);\n+  gsi = gsi_start_bb (info->final_bb);\n   label3 = gimple_build_label (label_decl3);\n   gsi_insert_before (&gsi, label3, GSI_SAME_STMT);\n \n@@ -834,66 +831,66 @@ gen_inbound_check (gimple swtch)\n   bb1 = e21->dest;\n   remove_edge (e21);\n \n-  e1d = split_block (bb1, info.arr_ref_last);\n+  e1d = split_block (bb1, info->arr_ref_last);\n   bbd = e1d->dest;\n   remove_edge (e1d);\n \n   /* flags and profiles of the edge for in-range values */\n   e01 = make_edge (bb0, bb1, EDGE_TRUE_VALUE);\n-  e01->probability = REG_BR_PROB_BASE - info.default_prob;\n-  e01->count = info.other_count;\n+  e01->probability = REG_BR_PROB_BASE - info->default_prob;\n+  e01->count = info->other_count;\n \n   /* flags and profiles of the edge taking care of out-of-range values */\n   e02->flags &= ~EDGE_FALLTHRU;\n   e02->flags |= EDGE_FALSE_VALUE;\n-  e02->probability = info.default_prob;\n-  e02->count = info.default_count;\n+  e02->probability = info->default_prob;\n+  e02->count = info->default_count;\n \n-  bbf = info.final_bb;\n+  bbf = info->final_bb;\n \n   e1f = make_edge (bb1, bbf, EDGE_FALLTHRU);\n   e1f->probability = REG_BR_PROB_BASE;\n-  e1f->count = info.other_count;\n+  e1f->count = info->other_count;\n \n   e2f = make_edge (bb2, bbf, EDGE_FALLTHRU);\n   e2f->probability = REG_BR_PROB_BASE;\n-  e2f->count = info.default_count;\n+  e2f->count = info->default_count;\n \n   /* frequencies of the new BBs */\n   bb1->frequency = EDGE_FREQUENCY (e01);\n   bb2->frequency = EDGE_FREQUENCY (e02);\n   bbf->frequency = EDGE_FREQUENCY (e1f) + EDGE_FREQUENCY (e2f);\n \n-  prune_bbs (bbd, info.final_bb); /* To keep calc_dfs_tree() in dominance.c\n+  prune_bbs (bbd, info->final_bb); /* To keep calc_dfs_tree() in dominance.c\n \t\t\t\t     happy.  */\n \n-  fix_phi_nodes (e1f, e2f, bbf);\n+  fix_phi_nodes (e1f, e2f, bbf, info);\n \n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n }\n \n /* The following function is invoked on every switch statement (the current one\n    is given in SWTCH) and runs the individual phases of switch conversion on it\n-   one after another until one fails or the conversion is completed.  */\n+   one after another until one fails or the conversion is completed.\n+   Returns NULL on success, or a pointer to a string with the reason why the\n+   conversion failed.  */\n \n-static bool\n+static const char *\n process_switch (gimple swtch)\n {\n   unsigned int i, branch_num = gimple_switch_num_labels (swtch);\n   tree index_type;\n+  struct switch_conv_info info;\n \n   /* Operand 2 is either NULL_TREE or a vector of cases (stmt.c).  */\n   if (branch_num < 2)\n-    {\n-      info.reason = \"switch has no labels\\n\";\n-      return false;\n-    }\n+    return \"switch has no labels\";\n \n+  info.reason = NULL;\n   info.final_bb = NULL;\n   info.switch_bb = gimple_bb (swtch);\n   info.index_expr = gimple_switch_index (swtch);\n-  index_type = TREE_TYPE (info.index_expr);\n   info.arr_ref_first = NULL;\n   info.arr_ref_last = NULL;\n   info.default_prob = 0;\n@@ -906,24 +903,26 @@ process_switch (gimple swtch)\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.\n      (comment from stmt.c) */\n+  index_type = TREE_TYPE (info.index_expr);\n   if (index_type == error_mark_node)\n-    {\n-      info.reason = \"index error.\\n\";\n-      return false;\n-    }\n+    return \"index error\\n\";\n \n   /* Check the case label values are within reasonable range:  */\n-  if (!check_range (swtch))\n-    return false;\n+  if (!check_range (swtch, &info))\n+    {\n+      gcc_assert (info.reason);\n+      return info.reason;\n+    }\n \n   /* For all the cases, see whether they are empty, the assignments they\n      represent constant and so on...  */\n   for (i = 0; i < branch_num; i++)\n-    if (!check_process_case (gimple_switch_label (swtch, i)))\n+    if (!check_process_case (gimple_switch_label (swtch, i), &info))\n       {\n+\tgcc_assert (info.reason);\n \tif (dump_file)\n-\t  fprintf (dump_file, \"Processing of case %i failed\\n\", i);\n-\treturn false;\n+\t  fprintf (dump_file, \"processing of case %i failed\\n\\t\", i);\n+\treturn info.reason;\n       }\n \n   if (info.bit_test_uniq <= 2)\n@@ -933,27 +932,29 @@ process_switch (gimple swtch)\n \t\t\t\t\t   info.range_size, info.bit_test_uniq,\n \t\t\t\t\t   info.bit_test_count))\n \t{\n-\t  info.reason = \"  Expanding as bit test is preferable\\n\";\n-\t  return false;\n+\t  return \"expanding as bit test is preferable\";\n \t}\n     }\n \n-  if (!check_final_bb ())\n-    return false;\n+  if (!check_final_bb (&info))\n+    {\n+      gcc_assert (info.reason);\n+      return info.reason;\n+    }\n \n   /* At this point all checks have passed and we can proceed with the\n      transformation.  */\n \n-  create_temp_arrays ();\n-  gather_default_values (gimple_switch_label (swtch, 0));\n-  build_constructors (swtch);\n+  create_temp_arrays (&info);\n+  gather_default_values (gimple_switch_label (swtch, 0), &info);\n+  build_constructors (swtch, &info);\n \n-  build_arrays (swtch); /* Build the static arrays and assignments.   */\n-  gen_inbound_check (swtch);\t/* Build the bounds check.  */\n+  build_arrays (swtch, &info); /* Build the static arrays and assignments.   */\n+  gen_inbound_check (swtch, &info);\t/* Build the bounds check.  */\n \n   /* Cleanup:  */\n-  free_temp_arrays ();\n-  return true;\n+  free_temp_arrays (&info);\n+  return NULL;\n }\n \n /* The main function of the pass scans statements for switches and invokes\n@@ -966,6 +967,7 @@ do_switchconv (void)\n \n   FOR_EACH_BB (bb)\n   {\n+    const char *failure_reason;\n     gimple stmt = last_stmt (bb);\n     if (stmt && gimple_code (stmt) == GIMPLE_SWITCH)\n       {\n@@ -980,8 +982,8 @@ do_switchconv (void)\n \t    putc ('\\n', dump_file);\n \t  }\n \n-\tinfo.reason = NULL;\n-\tif (process_switch (stmt))\n+\tfailure_reason = process_switch (stmt);\n+\tif (! failure_reason)\n \t  {\n \t    if (dump_file)\n \t      {\n@@ -993,10 +995,9 @@ do_switchconv (void)\n \t  {\n \t    if (dump_file)\n \t      {\n-\t\tgcc_assert (info.reason);\n \t\tfputs (\"Bailing out - \", dump_file);\n-\t\tfputs (info.reason, dump_file);\n-\t\tfputs (\"--------------------------------\\n\", dump_file);\n+\t\tfputs (failure_reason, dump_file);\n+\t\tfputs (\"\\n--------------------------------\\n\", dump_file);\n \t      }\n \t  }\n       }"}]}