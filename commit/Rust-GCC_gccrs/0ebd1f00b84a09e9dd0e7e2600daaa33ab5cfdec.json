{"sha": "0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGViZDFmMDBiODRhMDllOWRkMGU3ZTI2MDBkYWFhMzNhYjVjZmRlYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-04-24T20:33:04Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-04-24T20:33:04Z"}, "message": "types.rst (gccjit::type::get_const): Remove comment.\n\ngcc_jit_type_get_aligned\n\ngcc/jit/ChangeLog:\n\t* docs/cp/topics/types.rst (gccjit::type::get_const): Remove\n\tcomment.\n\t(gccjit::type::get_aligned): Add.\n\t* docs/topics/compatibility.rst: Add LIBGCCJIT_ABI_7.\n\t* docs/topics/types.rst: Add gcc_jit_type_get_aligned.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* jit-playback.c (gcc::jit::playback::type::get_aligned): New\n\tmethod.\n\t* jit-playback.h (gcc::jit::playback::type::get_aligned): New\n\tmethod.\n\t* jit-recording.c: Within namespace gcc::jit::recording...\n\t(type::get_aligned): New method.\n\t(memento_of_get_aligned::replay_into): New method.\n\t(memento_of_get_aligned::make_debug_string): New method.\n\t(memento_of_get_aligned::write_reproducer): New method.\n\t* jit-recording.h: Within namespace gcc::jit::recording...\n\t(type::get_aligned): New method.\n\t(type::accepts_writes_from): Strip off qualifications from\n\tthis when comparing pointer equality.\n\t(decorated_type): New subclass of type, subsuming the\n\tcommonality between memento_of_get_const and\n\tmemento_of_get_volatile.\n\t(memento_of_get_const): Make a subclass of decorated_type,\n\trather than type.\n\t(memento_of_get_volatile): Likewise.\n\t(memento_of_get_aligned): Likewise.\n\t* libgccjit++.h: Within namespace gccjit...\n\t(type::get_const): New method.\n\t(type::get_aligned): New method.\n\t* libgccjit.c (gcc_jit_type_get_aligned): New function.\n\t* libgccjit.h (gcc_jit_type_get_aligned): New decl.\n\t* libgccjit.map (LIBGCCJIT_ABI_7): New\n\t(gcc_jit_type_get_aligned): Add.\n\ngcc/testsuite/ChangeLog:\n\t* jit.dg/all-non-failing-tests.h: Add test-alignment.c.\n\t* jit.dg/test-alignment.c: New test case.\n\t* jit.dg/test-alignment.cc: New test case.\n\t* jit.dg/test-error-gcc_jit_type_get_aligned-non-power-of-two.c:\n\tNew test case.\n\nFrom-SVN: r247111", "tree": {"sha": "c90c5e9ff712be24739a3fe0b5fec18deb517683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90c5e9ff712be24739a3fe0b5fec18deb517683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "761ad35c86ae6eb2101259feacc54ce409ca2ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761ad35c86ae6eb2101259feacc54ce409ca2ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761ad35c86ae6eb2101259feacc54ce409ca2ff5"}], "stats": {"total": 1715, "additions": 1240, "deletions": 475}, "files": [{"sha": "dc7dda604d00302c5f4e6de590798b783f27ec92", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -1,3 +1,39 @@\n+2017-04-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/topics/types.rst (gccjit::type::get_const): Remove\n+\tcomment.\n+\t(gccjit::type::get_aligned): Add.\n+\t* docs/topics/compatibility.rst: Add LIBGCCJIT_ABI_7.\n+\t* docs/topics/types.rst: Add gcc_jit_type_get_aligned.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* jit-playback.c (gcc::jit::playback::type::get_aligned): New\n+\tmethod.\n+\t* jit-playback.h (gcc::jit::playback::type::get_aligned): New\n+\tmethod.\n+\t* jit-recording.c: Within namespace gcc::jit::recording...\n+\t(type::get_aligned): New method.\n+\t(memento_of_get_aligned::replay_into): New method.\n+\t(memento_of_get_aligned::make_debug_string): New method.\n+\t(memento_of_get_aligned::write_reproducer): New method.\n+\t* jit-recording.h: Within namespace gcc::jit::recording...\n+\t(type::get_aligned): New method.\n+\t(type::accepts_writes_from): Strip off qualifications from\n+\tthis when comparing pointer equality.\n+\t(decorated_type): New subclass of type, subsuming the\n+\tcommonality between memento_of_get_const and\n+\tmemento_of_get_volatile.\n+\t(memento_of_get_const): Make a subclass of decorated_type,\n+\trather than type.\n+\t(memento_of_get_volatile): Likewise.\n+\t(memento_of_get_aligned): Likewise.\n+\t* libgccjit++.h: Within namespace gccjit...\n+\t(type::get_const): New method.\n+\t(type::get_aligned): New method.\n+\t* libgccjit.c (gcc_jit_type_get_aligned): New function.\n+\t* libgccjit.h (gcc_jit_type_get_aligned): New decl.\n+\t* libgccjit.map (LIBGCCJIT_ABI_7): New\n+\t(gcc_jit_type_get_aligned): Add.\n+\n 2017-01-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* dummy-frontend.c (jit_langhook_type_for_size): Delete."}, {"sha": "fee8ef162719c6d62cb0b433bfe5f5eab2c62727", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 539, "deletions": 449, "changes": 988, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec"}, {"sha": "e85a4925896e6ff23734d6732d3ac5563ca2bc7d", "filename": "gcc/jit/docs/cp/topics/types.rst", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -82,8 +82,6 @@ Pointers, `const`, and `volatile`\n \n    Given type \"T\", get type \"T*\".\n \n-.. FIXME: get_const doesn't seem to exist\n-\n .. function::  gccjit::type gccjit::type::get_const ()\n \n    Given type \"T\", get type \"const T\".\n@@ -92,6 +90,16 @@ Pointers, `const`, and `volatile`\n \n    Given type \"T\", get type \"volatile T\".\n \n+.. function::  gccjit::type gccjit::type::get_aligned (size_t alignment_in_bytes)\n+\n+   Given type \"T\", get type:\n+\n+   .. code-block:: c\n+\n+      T __attribute__ ((aligned (ALIGNMENT_IN_BYTES)))\n+\n+   The alignment must be a power of two.\n+\n .. function::  gccjit::type \\\n                gccjit::context::new_array_type (gccjit::type element_type, \\\n                                                 int num_elements, \\"}, {"sha": "5a13653f3d19c981076215e8dc2996ae827a4fb5", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -142,3 +142,10 @@ entrypoints:\n -------------------\n ``LIBGCCJIT_ABI_6`` covers the addition of\n :func:`gcc_jit_rvalue_set_bool_require_tail_call`\n+\n+.. _LIBGCCJIT_ABI_7:\n+\n+``LIBGCCJIT_ABI_7``\n+-------------------\n+``LIBGCCJIT_ABI_7`` covers the addition of\n+:func:`gcc_jit_type_get_aligned`"}, {"sha": "119f10e5a47b095e7b162d4d74b2fe0130a6efd1", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -117,6 +117,25 @@ Pointers, `const`, and `volatile`\n \n    Given type \"T\", get type \"T[N]\" (for a constant N).\n \n+.. function::  gcc_jit_type *\\\n+               gcc_jit_type_get_aligned (gcc_jit_type *type, \\\n+                                         size_t alignment_in_bytes)\n+\n+   Given type \"T\", get type:\n+\n+   .. code-block:: c\n+\n+      T __attribute__ ((aligned (ALIGNMENT_IN_BYTES)))\n+\n+   The alignment must be a power of two.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_7`; you can test for\n+   its presence using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_aligned\n+\n \n Structures and unions\n ---------------------"}, {"sha": "76cc88fe36402bf3476f312b9637b6140ad2f4cd", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -1095,6 +1095,21 @@ new_dereference (tree ptr,\n   return datum;\n }\n \n+/* Construct a playback::type instance (wrapping a tree)\n+   with the given alignment.  */\n+\n+playback::type *\n+playback::type::\n+get_aligned (size_t alignment_in_bytes) const\n+{\n+  tree t_new_type = build_variant_type_copy (m_inner);\n+\n+  SET_TYPE_ALIGN (t_new_type, alignment_in_bytes * BITS_PER_UNIT);\n+  TYPE_USER_ALIGN (t_new_type) = 1;\n+\n+  return new type (t_new_type);\n+}\n+\n /* Construct a playback::lvalue instance (wrapping a tree) for a\n    field access.  */\n "}, {"sha": "0a83390f5a139ec7086e20a2b23eb9777f3660f0", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -391,6 +391,8 @@ class type : public wrapper\n     return new type (build_qualified_type (m_inner, TYPE_QUAL_VOLATILE));\n   }\n \n+  type *get_aligned (size_t alignment_in_bytes) const;\n+\n private:\n   tree m_inner;\n };"}, {"sha": "723ddb375075e8f5f462dd026c82443854e1f923", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -1974,6 +1974,20 @@ recording::type::get_volatile ()\n   return result;\n }\n \n+/* Given a type, get an aligned version of the type.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_type_get_aligned.  */\n+\n+recording::type *\n+recording::type::get_aligned (size_t alignment_in_bytes)\n+{\n+  recording::type *result\n+    = new memento_of_get_aligned (this, alignment_in_bytes);\n+  m_ctxt->record (result);\n+  return result;\n+}\n+\n const char *\n recording::type::access_as_type (reproducer &r)\n {\n@@ -2419,6 +2433,44 @@ recording::memento_of_get_volatile::write_reproducer (reproducer &r)\n \t   r.get_identifier_as_type (m_other_type));\n }\n \n+/* The implementation of class gcc::jit::recording::memento_of_get_aligned.  */\n+\n+/* Implementation of pure virtual hook recording::memento::replay_into\n+   for recording::memento_of_get_aligned.  */\n+\n+void\n+recording::memento_of_get_aligned::replay_into (replayer *)\n+{\n+  set_playback_obj\n+    (m_other_type->playback_type ()->get_aligned (m_alignment_in_bytes));\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   results of get_aligned.  */\n+\n+recording::string *\n+recording::memento_of_get_aligned::make_debug_string ()\n+{\n+  return string::from_printf (m_ctxt,\n+\t\t\t      \"%s  __attribute__((aligned(%zi)))\",\n+\t\t\t      m_other_type->get_debug_string (),\n+\t\t\t      m_alignment_in_bytes);\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for volatile\n+   types. */\n+\n+void\n+recording::memento_of_get_aligned::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"type\");\n+  r.write (\"  gcc_jit_type *%s =\\n\"\n+\t   \"    gcc_jit_type_get_aligned (%s, %zi);\\n\",\n+\t   id,\n+\t   r.get_identifier_as_type (m_other_type),\n+\t   m_alignment_in_bytes);\n+}\n+\n /* The implementation of class gcc::jit::recording::array_type */\n \n /* Implementation of pure virtual hook recording::type::dereference for"}, {"sha": "5faf35e0b17428b55263df9eae8b1b9a1ef15e60", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -473,6 +473,7 @@ class type : public memento\n   type *get_pointer ();\n   type *get_const ();\n   type *get_volatile ();\n+  type *get_aligned (size_t alignment_in_bytes);\n \n   /* Get the type obtained when dereferencing this type.\n \n@@ -489,7 +490,7 @@ class type : public memento\n   virtual bool accepts_writes_from (type *rtype)\n   {\n     gcc_assert (rtype);\n-    return this == rtype->unqualified ();\n+    return this->unqualified () == rtype->unqualified ();\n   }\n \n   /* Strip off \"const\" etc */\n@@ -599,16 +600,35 @@ class memento_of_get_pointer : public type\n   type *m_other_type;\n };\n \n-/* Result of \"gcc_jit_type_get_const\".  */\n-class memento_of_get_const : public type\n+/* A decorated version of a type, for get_const, get_volatile and\n+   get_aligned.  */\n+\n+class decorated_type : public type\n {\n public:\n-  memento_of_get_const (type *other_type)\n+  decorated_type (type *other_type)\n   : type (other_type->m_ctxt),\n     m_other_type (other_type) {}\n \n   type *dereference () FINAL OVERRIDE { return m_other_type->dereference (); }\n \n+  bool is_int () const FINAL OVERRIDE { return m_other_type->is_int (); }\n+  bool is_float () const FINAL OVERRIDE { return m_other_type->is_float (); }\n+  bool is_bool () const FINAL OVERRIDE { return m_other_type->is_bool (); }\n+  type *is_pointer () FINAL OVERRIDE { return m_other_type->is_pointer (); }\n+  type *is_array () FINAL OVERRIDE { return m_other_type->is_array (); }\n+\n+protected:\n+  type *m_other_type;\n+};\n+\n+/* Result of \"gcc_jit_type_get_const\".  */\n+class memento_of_get_const : public decorated_type\n+{\n+public:\n+  memento_of_get_const (type *other_type)\n+  : decorated_type (other_type) {}\n+\n   bool accepts_writes_from (type */*rtype*/) FINAL OVERRIDE\n   {\n     /* Can't write to a \"const\".  */\n@@ -618,40 +638,40 @@ class memento_of_get_const : public type\n   /* Strip off the \"const\", giving the underlying type.  */\n   type *unqualified () FINAL OVERRIDE { return m_other_type; }\n \n-  bool is_int () const FINAL OVERRIDE { return m_other_type->is_int (); }\n-  bool is_float () const FINAL OVERRIDE { return m_other_type->is_float (); }\n-  bool is_bool () const FINAL OVERRIDE { return m_other_type->is_bool (); }\n-  type *is_pointer () FINAL OVERRIDE { return m_other_type->is_pointer (); }\n-  type *is_array () FINAL OVERRIDE { return m_other_type->is_array (); }\n-\n   void replay_into (replayer *) FINAL OVERRIDE;\n \n private:\n   string * make_debug_string () FINAL OVERRIDE;\n   void write_reproducer (reproducer &r) FINAL OVERRIDE;\n-\n-private:\n-  type *m_other_type;\n };\n \n /* Result of \"gcc_jit_type_get_volatile\".  */\n-class memento_of_get_volatile : public type\n+class memento_of_get_volatile : public decorated_type\n {\n public:\n   memento_of_get_volatile (type *other_type)\n-  : type (other_type->m_ctxt),\n-    m_other_type (other_type) {}\n-\n-  type *dereference () FINAL OVERRIDE { return m_other_type->dereference (); }\n+  : decorated_type (other_type) {}\n \n   /* Strip off the \"volatile\", giving the underlying type.  */\n   type *unqualified () FINAL OVERRIDE { return m_other_type; }\n \n-  bool is_int () const FINAL OVERRIDE { return m_other_type->is_int (); }\n-  bool is_float () const FINAL OVERRIDE { return m_other_type->is_float (); }\n-  bool is_bool () const FINAL OVERRIDE { return m_other_type->is_bool (); }\n-  type *is_pointer () FINAL OVERRIDE { return m_other_type->is_pointer (); }\n-  type *is_array () FINAL OVERRIDE { return m_other_type->is_array (); }\n+  void replay_into (replayer *) FINAL OVERRIDE;\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+};\n+\n+/* Result of \"gcc_jit_type_get_aligned\".  */\n+class memento_of_get_aligned : public decorated_type\n+{\n+public:\n+  memento_of_get_aligned (type *other_type, size_t alignment_in_bytes)\n+  : decorated_type (other_type),\n+    m_alignment_in_bytes (alignment_in_bytes) {}\n+\n+  /* Strip off the alignment, giving the underlying type.  */\n+  type *unqualified () FINAL OVERRIDE { return m_other_type; }\n \n   void replay_into (replayer *) FINAL OVERRIDE;\n \n@@ -660,7 +680,7 @@ class memento_of_get_volatile : public type\n   void write_reproducer (reproducer &r) FINAL OVERRIDE;\n \n private:\n-  type *m_other_type;\n+  size_t m_alignment_in_bytes;\n };\n \n class array_type : public type"}, {"sha": "ea277f8c51b212626a5303f9abc192a89a699743", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -330,7 +330,9 @@ namespace gccjit\n     gcc_jit_type *get_inner_type () const;\n \n     type get_pointer ();\n+    type get_const ();\n     type get_volatile ();\n+    type get_aligned (size_t alignment_in_bytes);\n \n     // Shortcuts for getting values of numeric types:\n     rvalue zero ();\n@@ -1285,12 +1287,25 @@ type::get_pointer ()\n   return type (gcc_jit_type_get_pointer (get_inner_type ()));\n }\n \n+inline type\n+type::get_const ()\n+{\n+  return type (gcc_jit_type_get_const (get_inner_type ()));\n+}\n+\n inline type\n type::get_volatile ()\n {\n   return type (gcc_jit_type_get_volatile (get_inner_type ()));\n }\n \n+inline type\n+type::get_aligned (size_t alignment_in_bytes)\n+{\n+  return type (gcc_jit_type_get_aligned (get_inner_type (),\n+\t\t\t\t\t alignment_in_bytes));\n+}\n+\n inline rvalue\n type::zero ()\n {"}, {"sha": "9b003e39000b071e735162be71834b1d7cc018ec", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -2970,3 +2970,27 @@ gcc_jit_rvalue_set_bool_require_tail_call (gcc_jit_rvalue *rvalue,\n \n   call->set_require_tail_call (require_tail_call);\n }\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::get_aligned method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_get_aligned (gcc_jit_type *type,\n+\t\t\t  size_t alignment_in_bytes)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  gcc::jit::recording::context *ctxt = type->m_ctxt;\n+\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1\n+    (pow2_or_zerop (alignment_in_bytes), ctxt, NULL,\n+     \"alignment not a power of two: %zi\",\n+     alignment_in_bytes);\n+\n+  return (gcc_jit_type *)type->get_aligned (alignment_in_bytes);\n+}"}, {"sha": "898ee989b8307850bd6dcfa89d9094100d11a614", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -1387,6 +1387,22 @@ extern void\n gcc_jit_rvalue_set_bool_require_tail_call (gcc_jit_rvalue *call,\n \t\t\t\t\t   int require_tail_call);\n \n+#define LIBGCCJIT_HAVE_gcc_jit_type_get_aligned\n+\n+/* Given type \"T\", get type:\n+\n+     T __attribute__ ((aligned (ALIGNMENT_IN_BYTES)))\n+\n+   The alignment must be a power of two.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_7; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_gcc_jit_type_get_aligned\n+*/\n+extern gcc_jit_type *\n+gcc_jit_type_get_aligned (gcc_jit_type *type,\n+\t\t\t  size_t alignment_in_bytes);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "160f4cdd82aed3ca5b332a23940fa595dbd03cfc", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -150,3 +150,8 @@ LIBGCCJIT_ABI_6 {\n   global:\n     gcc_jit_rvalue_set_bool_require_tail_call;\n } LIBGCCJIT_ABI_5;\n+\n+LIBGCCJIT_ABI_7 {\n+  global:\n+    gcc_jit_type_get_aligned;\n+} LIBGCCJIT_ABI_6;"}, {"sha": "5bc04fe47a68435321698147037ab6013202a4e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -1,3 +1,11 @@\n+2017-04-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* jit.dg/all-non-failing-tests.h: Add test-alignment.c.\n+\t* jit.dg/test-alignment.c: New test case.\n+\t* jit.dg/test-alignment.cc: New test case.\n+\t* jit.dg/test-error-gcc_jit_type_get_aligned-non-power-of-two.c:\n+\tNew test case.\n+\n 2017-04-24  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/80016"}, {"sha": "58e0c30eb0fae57b3f8bfb7446ec2d5be466f37e", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -22,6 +22,13 @@\n #undef create_code\n #undef verify_code\n \n+/* test-alignment.c */\n+#define create_code create_code_alignment\n+#define verify_code verify_code_alignment\n+#include \"test-alignment.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-arith-overflow.c */\n #define create_code create_code_arith_overflow\n #define verify_code verify_code_arith_overflow\n@@ -246,6 +253,9 @@ const struct testcase testcases[] = {\n   {\"accessing_union\",\n    create_code_accessing_union,\n    verify_code_accessing_union},\n+  {\"alignment\",\n+   create_code_alignment,\n+   verify_code_alignment},\n   {\"arith_overflow\",\n    create_code_arith_overflow,\n    verify_code_arith_overflow},"}, {"sha": "686d98181b72a13eed5e8abc6bb9db53ac650edc", "filename": "gcc/testsuite/jit.dg/test-alignment.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.c?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -0,0 +1,232 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+struct s2\n+{\n+  char x __attribute__ ((aligned (2)));\n+  char y __attribute__ ((aligned (2)));\n+};\n+\n+struct s4\n+{\n+  char x __attribute__ ((aligned (4)));\n+  char y __attribute__ ((aligned (4)));\n+};\n+\n+struct s8\n+{\n+  char x __attribute__ ((aligned (8)));\n+  char y __attribute__ ((aligned (8)));\n+};\n+\n+struct s16\n+{\n+  char x __attribute__ ((aligned (16)));\n+  char y __attribute__ ((aligned (16)));\n+};\n+\n+struct s32\n+{\n+  char x __attribute__ ((aligned (32)));\n+  char y __attribute__ ((aligned (32)));\n+};\n+\n+struct s64\n+{\n+  char x __attribute__ ((aligned (64)));\n+  char y __attribute__ ((aligned (64)));\n+};\n+\n+struct s128\n+{\n+  char x __attribute__ ((aligned (128)));\n+  char y __attribute__ ((aligned (128)));\n+};\n+\n+static void\n+create_aligned_code (gcc_jit_context *ctxt, const char *struct_name,\n+\t\t     unsigned int alignment, const char *reader_fn_name,\n+\t\t     const char *writer_fn_name)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     char\n+     READER_FN_NAME (const struct STRUCT_NAME *f)\n+     {\n+       return f->x * f->y;\n+     }\n+\n+     char\n+     WRITER_FN_NAME (struct STRUCT_NAME *g)\n+     {\n+       g->x = 5;\n+       g->y = 7;\n+       return READER_FN_NAME (g);\n+     }\n+  */\n+  gcc_jit_type *char_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *aligned_char_type =\n+    gcc_jit_type_get_aligned (char_type, alignment);\n+  gcc_jit_field *x =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               aligned_char_type,\n+                               \"x\");\n+  gcc_jit_field *y =\n+    gcc_jit_context_new_field (ctxt,\n+                               NULL,\n+                               aligned_char_type,\n+                               \"y\");\n+  gcc_jit_field *fields[] = {x, y};\n+  gcc_jit_type *struct_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt, NULL, struct_name, 2, fields));\n+  gcc_jit_type *const_struct_type = gcc_jit_type_get_const (struct_type);\n+  gcc_jit_type *const_ptr_type = gcc_jit_type_get_pointer (const_struct_type);\n+\n+  /* Build the reader fn.  */\n+  gcc_jit_param *param_f =\n+    gcc_jit_context_new_param (ctxt, NULL, const_ptr_type, \"f\");\n+  gcc_jit_function *fn_test_reading =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  char_type,\n+\t\t\t\t  reader_fn_name,\n+                                  1, &param_f,\n+                                  0);\n+\n+  /* return f->x * f->y; */\n+  gcc_jit_block *reading_block = gcc_jit_function_new_block (fn_test_reading, NULL);\n+  gcc_jit_block_end_with_return (\n+    reading_block,\n+    NULL,\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_MULT,\n+      char_type,\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\t  gcc_jit_param_as_rvalue (param_f),\n+\t  NULL,\n+\t  x)),\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\tgcc_jit_param_as_rvalue (param_f),\n+\tNULL,\n+\ty))));\n+\n+  /* Build the writer fn.  */\n+  gcc_jit_type *ptr_type = gcc_jit_type_get_pointer (struct_type);\n+  gcc_jit_param *param_g =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"g\");\n+  gcc_jit_function *fn_test_writing =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  char_type,\n+                                  writer_fn_name,\n+                                  1, &param_g,\n+                                  0);\n+\n+  /* g->x = 5; */\n+  gcc_jit_block *writing_block = gcc_jit_function_new_block (fn_test_writing, NULL);\n+  gcc_jit_block_add_assignment (\n+    writing_block, NULL,\n+    gcc_jit_rvalue_dereference_field (gcc_jit_param_as_rvalue (param_g),\n+\t\t\t\t      NULL, x),\n+    gcc_jit_context_new_rvalue_from_int (ctxt, char_type, 5));\n+\n+  /* g->y = 7; */\n+  gcc_jit_block_add_assignment (\n+    writing_block, NULL,\n+    gcc_jit_rvalue_dereference_field (gcc_jit_param_as_rvalue (param_g),\n+\t\t\t\t      NULL, y),\n+    gcc_jit_context_new_rvalue_from_int (ctxt, char_type, 7));\n+\n+  /* return READER_FN_NAME (g); */\n+  gcc_jit_rvalue *arg = gcc_jit_param_as_rvalue (param_g);\n+  gcc_jit_block_end_with_return (\n+    writing_block,\n+    NULL,\n+    gcc_jit_context_new_call (\n+      ctxt, NULL,\n+      fn_test_reading,\n+      1, &arg));\n+}\n+\n+/* Implement a verifier function for a given struct.  */\n+\n+#define IMPL_VERIFY_ALIGNED_CODE(TYPENAME) \\\n+  static void\t\t\t\t\t\t\t\t\\\n+  verify_aligned_code_ ##TYPENAME (gcc_jit_context *ctxt,\t\t\\\n+\t\t\t\t   gcc_jit_result *result,\t\t\\\n+\t\t\t\t   const char *writer_fn_name)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+  typedef int (*fn_type) (struct TYPENAME *);\t\t\t\t\\\n+  CHECK_NON_NULL (result);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  struct TYPENAME tmp;\t\t\t\t\t\t\t\\\n+  memset (&tmp, 0xac, sizeof (tmp));\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  fn_type test_writing =\t\t\t\t\t\t\\\n+    (fn_type)gcc_jit_result_get_code (result, writer_fn_name);\t\t\\\n+  CHECK_NON_NULL (test_writing);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Verify that the code correctly returns the product of the fields.  */ \\\n+  CHECK_VALUE (test_writing (&tmp), 35);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Verify the we can read the values of the fields, and thus that the \\\n+     struct layout agrees with that of the C frontend.  */\t\t\\\n+  CHECK_VALUE (tmp.x, 5);\t\t\t\t\t\t\\\n+  CHECK_VALUE (tmp.y, 7);\t\t\t\t\t\t\\\n+  }\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  create_aligned_code (ctxt, \"s2\", 2, \"test_aligned_reading_s2\",\n+\t\t       \"test_aligned_writing_s2\");\n+  create_aligned_code (ctxt, \"s4\", 4, \"test_aligned_reading_s4\",\n+\t\t       \"test_aligned_writing_s4\");\n+  create_aligned_code (ctxt, \"s8\", 8, \"test_aligned_reading_s8\",\n+\t\t       \"test_aligned_writing_s8\");\n+  create_aligned_code (ctxt, \"s16\", 16, \"test_aligned_reading_s16\",\n+\t\t       \"test_aligned_writing_s16\");\n+  create_aligned_code (ctxt, \"s32\", 32, \"test_aligned_reading_s32\",\n+\t\t       \"test_aligned_writing_s32\");\n+  create_aligned_code (ctxt, \"s64\", 64, \"test_aligned_reading_s64\",\n+\t\t       \"test_aligned_writing_s64\");\n+  create_aligned_code (ctxt, \"s128\", 128, \"test_aligned_reading_s128\",\n+\t\t       \"test_aligned_writing_s128\");\n+}\n+\n+IMPL_VERIFY_ALIGNED_CODE(s2)\n+IMPL_VERIFY_ALIGNED_CODE(s4)\n+IMPL_VERIFY_ALIGNED_CODE(s8)\n+IMPL_VERIFY_ALIGNED_CODE(s16)\n+IMPL_VERIFY_ALIGNED_CODE(s32)\n+IMPL_VERIFY_ALIGNED_CODE(s64)\n+IMPL_VERIFY_ALIGNED_CODE(s128)\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  verify_aligned_code_s2 (ctxt, result,\n+\t\t\t  \"test_aligned_writing_s2\");\n+  verify_aligned_code_s4 (ctxt, result,\n+\t\t\t  \"test_aligned_writing_s4\");\n+  verify_aligned_code_s8 (ctxt, result,\n+\t\t\t  \"test_aligned_writing_s8\");\n+  verify_aligned_code_s16 (ctxt, result,\n+\t\t\t   \"test_aligned_writing_s16\");\n+  verify_aligned_code_s32 (ctxt, result,\n+\t\t\t   \"test_aligned_writing_s32\");\n+  verify_aligned_code_s64 (ctxt, result,\n+\t\t\t   \"test_aligned_writing_s64\");\n+  verify_aligned_code_s128 (ctxt, result,\n+\t\t\t   \"test_aligned_writing_s128\");\n+}"}, {"sha": "3e99209b9b10aaa166c5e743b80fb23230a6dd68", "filename": "gcc/testsuite/jit.dg/test-alignment.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-alignment.cc?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -0,0 +1,176 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit++.h\"\n+\n+#include \"harness.h\"\n+\n+struct s2\n+{\n+  char x __attribute__ ((aligned (2)));\n+  char y __attribute__ ((aligned (2)));\n+};\n+\n+struct s4\n+{\n+  char x __attribute__ ((aligned (4)));\n+  char y __attribute__ ((aligned (4)));\n+};\n+\n+struct s8\n+{\n+  char x __attribute__ ((aligned (8)));\n+  char y __attribute__ ((aligned (8)));\n+};\n+\n+struct s16\n+{\n+  char x __attribute__ ((aligned (16)));\n+  char y __attribute__ ((aligned (16)));\n+};\n+\n+struct s32\n+{\n+  char x __attribute__ ((aligned (32)));\n+  char y __attribute__ ((aligned (32)));\n+};\n+\n+struct s64\n+{\n+  char x __attribute__ ((aligned (64)));\n+  char y __attribute__ ((aligned (64)));\n+};\n+\n+struct s128\n+{\n+  char x __attribute__ ((aligned (128)));\n+  char y __attribute__ ((aligned (128)));\n+};\n+\n+static void\n+create_aligned_code (gcc_jit_context *c_ctxt, const char *struct_name,\n+\t\t     unsigned int alignment, const char *reader_fn_name,\n+\t\t     const char *writer_fn_name)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     char\n+     READER_FN_NAME (const struct STRUCT_NAME *f)\n+     {\n+       return f->x * f->y;\n+     }\n+\n+     char\n+     WRITER_FN_NAME (struct STRUCT_NAME *g)\n+     {\n+       g->x = 5;\n+       g->y = 7;\n+       return READER_FN_NAME (g);\n+     }\n+  */\n+  gccjit::context ctxt (c_ctxt);\n+  gccjit::type char_type = ctxt.get_type (GCC_JIT_TYPE_CHAR);\n+  gccjit::type aligned_char_type = char_type.get_aligned (alignment);\n+  gccjit::field x = ctxt.new_field (aligned_char_type, \"x\");\n+  gccjit::field y = ctxt.new_field (aligned_char_type, \"y\");\n+  std::vector<gccjit::field> fields = {x, y};\n+  gccjit::type struct_type = ctxt.new_struct_type (struct_name, fields);\n+  gccjit::type const_struct_type = struct_type.get_const ();\n+  gccjit::type const_ptr_type = const_struct_type.get_pointer ();\n+\n+  /* Build the reader fn.  */\n+  gccjit::param param_f = ctxt.new_param (const_ptr_type, \"f\");\n+  std::vector<gccjit::param> params = {param_f};\n+  gccjit::function fn_test_reading\n+    = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                         char_type,\n+                         reader_fn_name,\n+                         params,\n+                         0);\n+\n+  /* return f->x * f->y; */\n+  gccjit::block reading_block = fn_test_reading.new_block ();\n+  reading_block.end_with_return (param_f.dereference_field (x)\n+                                 * param_f.dereference_field (y));\n+\n+  /* Build the writer fn.  */\n+  gccjit::type ptr_type = struct_type.get_pointer ();\n+  gccjit::param param_g = ctxt.new_param (ptr_type, \"g\");\n+  params = {param_g};\n+  gccjit::function fn_test_writing\n+    = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                         char_type,\n+                         writer_fn_name,\n+                         params,\n+                         0);\n+\n+  /* g->x = 5; */\n+  gccjit::block writing_block = fn_test_writing.new_block ();\n+  writing_block.add_assignment (param_g.dereference_field (x),\n+                                ctxt.new_rvalue (char_type, 5));\n+\n+  /* g->y = 7; */\n+  writing_block.add_assignment (param_g.dereference_field (y),\n+                                ctxt.new_rvalue (char_type, 7));\n+\n+  /* return READER_FN_NAME (g); */\n+  writing_block.end_with_return (ctxt.new_call (fn_test_reading,\n+                                                param_g));\n+}\n+\n+/* Implement a verifier function for a given struct.  */\n+\n+template <typename T>\n+static void\n+verify_aligned_code (gcc_jit_context *ctxt,\n+                     gcc_jit_result *result,\n+                     const char *writer_fn_name)\n+{\n+  typedef int (*fn_type) (T *);\n+  CHECK_NON_NULL (result);\n+\n+  T tmp;\n+  memset (&tmp, 0xac, sizeof (tmp));\n+  fn_type test_writing =\n+    (fn_type)gcc_jit_result_get_code (result, writer_fn_name);\n+  CHECK_NON_NULL (test_writing);\n+\n+  /* Verify that the code correctly returns the product of the fields.  */\n+  CHECK_VALUE (test_writing (&tmp), 35);\n+\n+  /* Verify the we can read the values of the fields, and thus that the\n+     struct layout agrees with that of the C++ frontend.  */\n+  CHECK_VALUE (tmp.x, 5);\n+  CHECK_VALUE (tmp.y, 7);\n+}\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  create_aligned_code (ctxt, \"s2\", 2, \"test_aligned_reading_s2\",\n+\t\t       \"test_aligned_writing_s2\");\n+  create_aligned_code (ctxt, \"s4\", 4, \"test_aligned_reading_s4\",\n+\t\t       \"test_aligned_writing_s4\");\n+  create_aligned_code (ctxt, \"s8\", 8, \"test_aligned_reading_s8\",\n+\t\t       \"test_aligned_writing_s8\");\n+  create_aligned_code (ctxt, \"s16\", 16, \"test_aligned_reading_s16\",\n+\t\t       \"test_aligned_writing_s16\");\n+  create_aligned_code (ctxt, \"s32\", 32, \"test_aligned_reading_s32\",\n+\t\t       \"test_aligned_writing_s32\");\n+  create_aligned_code (ctxt, \"s64\", 64, \"test_aligned_reading_s64\",\n+\t\t       \"test_aligned_writing_s64\");\n+  create_aligned_code (ctxt, \"s128\", 128, \"test_aligned_reading_s128\",\n+\t\t       \"test_aligned_writing_s128\");\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  verify_aligned_code<s2> (ctxt, result, \"test_aligned_writing_s2\");\n+  verify_aligned_code<s4> (ctxt, result, \"test_aligned_writing_s4\");\n+  verify_aligned_code<s8> (ctxt, result, \"test_aligned_writing_s8\");\n+  verify_aligned_code<s16> (ctxt, result, \"test_aligned_writing_s16\");\n+  verify_aligned_code<s32> (ctxt, result, \"test_aligned_writing_s32\");\n+  verify_aligned_code<s64> (ctxt, result, \"test_aligned_writing_s64\");\n+  verify_aligned_code<s128> (ctxt, result, \"test_aligned_writing_s128\");\n+}"}, {"sha": "8f3233b46ace7c758f8d89c9576588e0cfc78485", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_type_get_aligned-non-power-of-two.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_type_get_aligned-non-power-of-two.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_type_get_aligned-non-power-of-two.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_type_get_aligned-non-power-of-two.c?ref=0ebd1f00b84a09e9dd0e7e2600daaa33ab5cfdec", "patch": "@@ -0,0 +1,30 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  /* Trigger an API error by passing a bad alignment.  */\n+  (void)gcc_jit_type_get_aligned (int_type, 7);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      (\"gcc_jit_type_get_aligned:\"\n+\t\t       \" alignment not a power of two: 7\"));\n+}\n+"}]}