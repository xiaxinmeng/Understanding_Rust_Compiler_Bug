{"sha": "20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkMzQ2NWJkMDBjNGQ2ZjQ3MmUzOTgyZmJlYjVmYTFiOWMyZjJkMg==", "commit": {"author": {"name": "Mircea Namolaru", "email": "mircea.namolaru@inria.fr", "date": "2014-11-15T15:37:49Z"}, "committer": {"name": "Mircea Namolaru", "email": "mircea@gcc.gnu.org", "date": "2014-11-15T15:37:49Z"}, "message": "New unroll and jam option in Graphite.\n\nFrom-SVN: r217604", "tree": {"sha": "5205bdb5761945fee1b6c762aab0ed2eca3079be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5205bdb5761945fee1b6c762aab0ed2eca3079be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/comments", "author": null, "committer": null, "parents": [{"sha": "cf4600ed3651d50dee80df07a7ea4d0e36cecedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4600ed3651d50dee80df07a7ea4d0e36cecedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf4600ed3651d50dee80df07a7ea4d0e36cecedf"}], "stats": {"total": 332, "additions": 308, "deletions": 24}, "files": [{"sha": "42fe8fa0b686d7191d2435b40478852c322bad61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -1,3 +1,28 @@\n+2014-11-15  Mircea Namolaru  <mircea.namolaru@inria.fr>\n+\n+\t* common.opt (flag_loop_unroll_and_jam): New flag.\n+\t* params.def (PARAM_LOOP_UNROLL_JAM_SIZE): Parameter for unroll and\n+\tjam flag.\n+\t(PARAM_LOOP_UNROLL_JAM_DEPTH): Likewise.\n+\t* graphite-poly.h (struct poly_bb:map_sepclass): New field\n+\t* graphite-poly.c (new_poly_bb): Initialization for new field.\n+\t(apply_poly_transforms): Support for unroll and jam flag.\n+\t* graphite-isl-ast-to-gimple.c (generate_luj_sepclass): Compute the\n+\tseparation class.\n+\t(generate_luj_sepclass_opt): Build the separation class option.\n+\t(generate_luj_options): Set unroll and jam options.\n+        (set_options): Support for unroll and jam options.\n+\t(scop_to_isl_ast): Likewise\n+\t* graphite-optimize-isl.c (getPrevectorMap_full): New function for\n+        computing the separating class map.\n+\t(optimize_isl): Support for the separating class map.\n+\t(apply_schedule_map_to_scop): Likewise.\n+\t(getScheduleMap): Likewise.\n+\t(getScheduleForBand): Likewise.\n+\t(getScheduleForBandList): Likewise.\n+        * graphite.c (gate_graphite_transforms): Add unroll and jam flag.\n+\t* toplev.c (process_options) Likewise.\n+\n 2014-11-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-cfg.c (replace_loop_annotate_in_block): New function extracted"}, {"sha": "3a6d7e10c2c02fcc6819665125dfd9405e630730", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -1315,6 +1315,10 @@ floop-block\n Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n+floop-unroll-and-jam\n+Common Report Var(flag_loop_unroll_jam) Optimization\n+Enable Loop Unroll Jam transformation\n+ \n fgnu-tm\n Common Report Var(flag_tm)\n Enable support for GNU transactional memory"}, {"sha": "bbf30550e94ac1c01a32e3996450a35667a870e3", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -831,6 +831,92 @@ extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)\n   return schedule;\n }\n \n+/* Set the separation_class option for unroll and jam. */\n+\n+static __isl_give isl_union_map *\n+generate_luj_sepclass_opt (scop_p scop, __isl_take isl_union_set *domain, \n+\t\t\tint dim, int cl)\n+{\n+  isl_map  *map;\n+  isl_space *space, *space_sep;\n+  isl_ctx *ctx;\n+  isl_union_map *mapu;\n+  int nsched = get_max_schedule_dimensions (scop);\n+ \n+  ctx = scop->ctx;\n+  space_sep = isl_space_alloc (ctx, 0, 1, 1);\n+  space_sep = isl_space_wrap (space_sep);\n+  space_sep = isl_space_set_tuple_name (space_sep, isl_dim_set,\n+\t\t\t\t        \"separation_class\");\n+  space = isl_set_get_space (scop->context);\n+  space_sep = isl_space_align_params (space_sep, isl_space_copy(space));\n+  space = isl_space_map_from_domain_and_range (space, space_sep);\n+  space = isl_space_add_dims (space,isl_dim_in, nsched);\n+  map = isl_map_universe (space);\n+  isl_map_fix_si (map,isl_dim_out,0,dim);\n+  isl_map_fix_si (map,isl_dim_out,1,cl);\n+\n+  mapu = isl_union_map_intersect_domain (isl_union_map_from_map (map), \n+\t\t\t\t\t domain);\n+  return (mapu);\n+}\n+\n+/* Compute the separation class for loop unroll and jam.  */\n+\n+static __isl_give isl_union_set *\n+generate_luj_sepclass (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  isl_union_set *domain_isl;\n+\n+  domain_isl = isl_union_set_empty (isl_set_get_space (scop->context));\n+\n+  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n+    {\n+      isl_set *bb_domain;\n+      isl_set *bb_domain_s;\n+\n+      if (pbb->map_sepclass == NULL)\n+\tcontinue;\n+\n+      if (isl_set_is_empty (pbb->domain))\n+\tcontinue;\n+\n+      bb_domain = isl_set_copy (pbb->domain);\n+      bb_domain_s = isl_set_apply (bb_domain, pbb->map_sepclass);\n+      pbb->map_sepclass = NULL;\n+\n+      domain_isl =\n+\tisl_union_set_union (domain_isl, isl_union_set_from_set (bb_domain_s));\n+    }\n+\n+  return domain_isl;\n+}\n+\n+/* Set the AST built options for loop unroll and jam. */\n+ \n+static __isl_give isl_union_map *\n+generate_luj_options (scop_p scop)\n+{\n+  isl_union_set *domain_isl;\n+  isl_union_map *options_isl_ss;\n+  isl_union_map *options_isl =\n+    isl_union_map_empty (isl_set_get_space (scop->context));\n+  int dim = get_max_schedule_dimensions (scop) - 1;\n+  int dim1 = dim - PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_DEPTH);\n+\n+  if (!flag_loop_unroll_jam)\n+    return options_isl;\n+\n+  domain_isl = generate_luj_sepclass (scop);\n+\n+  options_isl_ss = generate_luj_sepclass_opt (scop, domain_isl, dim1, 0);\n+  options_isl = isl_union_map_union (options_isl, options_isl_ss);\n+\n+  return options_isl;\n+}\n+\n /* Generates a schedule, which specifies an order used to\n    visit elements in a domain.  */\n \n@@ -879,11 +965,13 @@ ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n }\n \n /* Set the separate option for all dimensions.\n-   This helps to reduce control overhead.  */\n+   This helps to reduce control overhead.\n+   Set the options for unroll and jam.  */\n \n static __isl_give isl_ast_build *\n set_options (__isl_take isl_ast_build *control,\n-\t     __isl_keep isl_union_map *schedule)\n+\t     __isl_keep isl_union_map *schedule,\n+\t     __isl_take isl_union_map *opt_luj)\n {\n   isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n   isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n@@ -894,6 +982,9 @@ set_options (__isl_take isl_ast_build *control,\n   isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));\n   domain = isl_union_set_universe (domain);\n   isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);\n+\n+  options = isl_union_map_union (options, opt_luj);\n+\n   return isl_ast_build_set_options (control, options);\n }\n \n@@ -907,9 +998,14 @@ scop_to_isl_ast (scop_p scop, ivs_params &ip)\n   isl_options_set_ast_build_atomic_upper_bound (scop->ctx, true);\n \n   add_parameters_to_ivs_params (scop, ip);\n+\n+  isl_union_map *options_luj = generate_luj_options (scop);\n+\n   isl_union_map *schedule_isl = generate_isl_schedule (scop);\n   isl_ast_build *context_isl = generate_isl_context (scop);\n-  context_isl = set_options (context_isl, schedule_isl);\n+\n+  context_isl = set_options (context_isl, schedule_isl, options_luj);\n+\n   isl_union_map *dependences = NULL;\n   if (flag_loop_parallelize_all)\n   {"}, {"sha": "cbab82022446f078093ca28f4211dd70231d53c3", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 155, "deletions": 17, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -186,7 +186,7 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n   PartialSchedule = isl_band_get_partial_schedule (Band);\n   *Dimensions = isl_band_n_member (Band);\n \n-  if (DisableTiling)\n+  if (DisableTiling || flag_loop_unroll_jam)\n     return PartialSchedule;\n \n   /* It does not make any sense to tile a band with just one dimension.  */\n@@ -241,7 +241,9 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n    constant number of iterations, if the number of loop iterations at\n    DimToVectorize can be devided by VectorWidth. The default VectorWidth is\n    currently constant and not yet target specific. This function does not reason\n-   about parallelism.  */\n+   about parallelism.\n+\n+  */\n static isl_map *\n getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n \t\t int ScheduleDimensions,\n@@ -305,7 +307,97 @@ getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n   isl_constraint_set_constant_si (c, VectorWidth - 1);\n   TilingMap = isl_map_add_constraint (TilingMap, c);\n \n-  isl_map_dump (TilingMap);\n+  return TilingMap;\n+}\n+\n+/* Compute an auxiliary map to getPrevectorMap, for computing the separating \n+   class defined by full tiles.  Used in graphite_isl_ast_to_gimple.c to set the \n+   corresponding option for AST build.\n+\n+   The map (for VectorWidth=4):\n+\n+   [i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and it + 3 = i and\n+                        ip >= 0\n+\n+   The image of this map is the separation class. The range of this map includes\n+   all the i that are multiple of 4 in the domain beside the greater one. \n+    \n+ */ \n+static isl_map *\n+getPrevectorMap_full (isl_ctx *ctx, int DimToVectorize,\n+\t\t int ScheduleDimensions,\n+\t\t int VectorWidth)\n+{\n+  isl_space *Space;\n+  isl_local_space *LocalSpace, *LocalSpaceRange;\n+  isl_set *Modulo;\n+  isl_map *TilingMap;\n+  isl_constraint *c;\n+  isl_aff *Aff;\n+  int PointDimension; /* ip */\n+  int TileDimension;  /* it */\n+  isl_val *VectorWidthMP;\n+  int i;\n+\n+  /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n+\n+  Space = isl_space_alloc (ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n+  TilingMap = isl_map_universe (isl_space_copy (Space));\n+  LocalSpace = isl_local_space_from_space (Space);\n+  PointDimension = ScheduleDimensions;\n+  TileDimension = DimToVectorize;\n+\n+  /* Create an identity map for everything except DimToVectorize and the \n+     point loop. */\n+  for (i = 0; i < ScheduleDimensions; i++)\n+    {\n+      if (i == DimToVectorize)\n+        continue;\n+\n+      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n+\n+      isl_constraint_set_coefficient_si (c, isl_dim_in, i, -1);\n+      isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n+\n+      TilingMap = isl_map_add_constraint (TilingMap, c);\n+    }\n+\n+  /* it % 'VectorWidth' = 0  */\n+  LocalSpaceRange = isl_local_space_range (isl_local_space_copy (LocalSpace));\n+  Aff = isl_aff_zero_on_domain (LocalSpaceRange);\n+  Aff = isl_aff_set_constant_si (Aff, VectorWidth);\n+  Aff = isl_aff_set_coefficient_si (Aff, isl_dim_in, TileDimension, 1);\n+\n+  VectorWidthMP = isl_val_int_from_si (ctx, VectorWidth);\n+  Aff = isl_aff_mod_val (Aff, VectorWidthMP);\n+  Modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (Aff));\n+  TilingMap = isl_map_intersect_range (TilingMap, Modulo);\n+\n+  /* it + ('VectorWidth' - 1) = i0  */\n+  c = isl_equality_alloc (isl_local_space_copy(LocalSpace));\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension,-1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_in, TileDimension, 1);\n+  isl_constraint_set_constant_si (c, -VectorWidth + 1);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n+\n+  /* ip >= 0 */\n+  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n+  isl_constraint_set_constant_si (c, 0);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n+\n+  /* it <= ip */\n+  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, -1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n+\n+  /* ip <= it + ('VectorWidth' - 1) */\n+  c = isl_inequality_alloc (LocalSpace);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, 1);\n+  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, -1);\n+  isl_constraint_set_constant_si (c, VectorWidth - 1);\n+  TilingMap = isl_map_add_constraint (TilingMap, c);\n \n   return TilingMap;\n }\n@@ -316,9 +408,11 @@ static bool EnablePollyVector = false;\n     \n    We walk recursively the forest of bands to combine the schedules of the\n    individual bands to the overall schedule. In case tiling is requested,\n-   the individual bands are tiled.  */\n+   the individual bands are tiled.\n+   For unroll and jam the map the schedule for full tiles of the unrolled\n+   dimnesion is computed.  */\n static isl_union_map *\n-getScheduleForBandList (isl_band_list *BandList)\n+getScheduleForBandList (isl_band_list *BandList, isl_union_map **map_sepcl)\n {\n   int NumBands, i;\n   isl_union_map *Schedule;\n@@ -335,55 +429,87 @@ getScheduleForBandList (isl_band_list *BandList)\n       int ScheduleDimensions;\n       isl_space *Space;\n \n+      isl_union_map *PartialSchedule_f;\n+\n       Band = isl_band_list_get_band (BandList, i);\n       PartialSchedule = getScheduleForBand (Band, &ScheduleDimensions);\n       Space = isl_union_map_get_space (PartialSchedule);\n \n+      PartialSchedule_f = NULL;\n+\n       if (isl_band_has_children (Band))\n \t{\n \t  isl_band_list *Children;\n \t  isl_union_map *SuffixSchedule;\n \n \t  Children = isl_band_get_children (Band);\n-\t  SuffixSchedule = getScheduleForBandList (Children);\n+\t  SuffixSchedule = getScheduleForBandList (Children, map_sepcl);\n \t  PartialSchedule = isl_union_map_flat_range_product (PartialSchedule,\n \t\t\t\t\t\t\t      SuffixSchedule);\n \t  isl_band_list_free (Children);\n \t}\n-      else if (EnablePollyVector)\n+      else if (EnablePollyVector || flag_loop_unroll_jam)\n \t{\n+\t  int i;\n+\t  int depth;\n+ \n+ \t  depth = PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_DEPTH);\n+  \n \t  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)\n \t    {\n+\t      if (flag_loop_unroll_jam && (i != (ScheduleDimensions - depth)))\n+\t\tcontinue;\n+\n \t      if (isl_band_member_is_zero_distance (Band, i))\n \t\t{\n \t\t  isl_map *TileMap;\n \t\t  isl_union_map *TileUMap;\n+\t\t  int stride;\n+\n+                  stride = PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_SIZE);    \n+\n+\t\t  TileMap = getPrevectorMap_full (ctx, i, ScheduleDimensions, \n+\t\t\t\t\t\t  stride); \n+ \t\t  TileUMap = isl_union_map_from_map (TileMap);\n+\t\t  TileUMap = isl_union_map_align_params\n+\t\t    (TileUMap, isl_space_copy (Space));\n+\t\t  PartialSchedule_f = isl_union_map_apply_range\n+\t\t    (isl_union_map_copy (PartialSchedule), TileUMap);\n \n-\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, 4);\n+\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, stride);\n \t\t  TileUMap = isl_union_map_from_map (TileMap);\n \t\t  TileUMap = isl_union_map_align_params\n \t\t    (TileUMap, isl_space_copy (Space));\n \t\t  PartialSchedule = isl_union_map_apply_range\n \t\t    (PartialSchedule, TileUMap);\n \t\t  break;\n-\t\t}\n+\t\t}\t\n \t    }\n \t}\n-\n       Schedule = isl_union_map_union (Schedule, PartialSchedule);\n \n       isl_band_free (Band);\n       isl_space_free (Space);\n+\n+      if (!flag_loop_unroll_jam)\n+\tcontinue;\n+\n+      if (PartialSchedule_f)\n+\t*map_sepcl = isl_union_map_union (*map_sepcl, \n+\t\t\t\t\t  PartialSchedule_f);\n+      else\n+        *map_sepcl = isl_union_map_union (*map_sepcl, \n+         \t\t\t\t  isl_union_map_copy (PartialSchedule));\n     }\n \n   return Schedule;\n }\n \n static isl_union_map *\n-getScheduleMap (isl_schedule *Schedule)\n+getScheduleMap (isl_schedule *Schedule, isl_union_map **map_sepcl)\n {\n   isl_band_list *BandList = isl_schedule_get_band_forest (Schedule);\n-  isl_union_map *ScheduleMap = getScheduleForBandList (BandList);\n+  isl_union_map *ScheduleMap = getScheduleForBandList (BandList, map_sepcl);\n   isl_band_list_free (BandList);\n   return ScheduleMap;\n }\n@@ -398,7 +524,7 @@ getSingleMap (__isl_take isl_map *map, void *user)\n }\n \n static void\n-apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n+apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map, bool sepcl)\n {\n   int i;\n   poly_bb_p pbb;\n@@ -413,8 +539,15 @@ apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n \t(isl_union_map_copy (schedule_map),\n \t isl_union_set_from_set (domain));\n       isl_union_map_foreach_map (stmtBand, getSingleMap, &stmtSchedule);\n-      isl_map_free (pbb->transformed);\n-      pbb->transformed = stmtSchedule;\n+\n+      if (!sepcl)\n+\t{\n+\t  isl_map_free (pbb->transformed);\n+\t  pbb->transformed = stmtSchedule;\n+\t}\n+      else\n+\t  pbb->map_sepclass = stmtSchedule;\n+\n       isl_union_map_free (stmtBand);\n     }\n }\n@@ -429,6 +562,7 @@ optimize_isl (scop_p scop)\n   isl_union_set *domain;\n   isl_union_map *validity, *proximity, *dependences;\n   isl_union_map *schedule_map;\n+  isl_union_map *schedule_map_f;\n \n   domain = scop_get_domains (scop);\n   dependences = scop_get_dependences (scop);\n@@ -450,9 +584,13 @@ optimize_isl (scop_p scop)\n   if (!schedule)\n     return false;\n \n-  schedule_map = getScheduleMap (schedule);\n+  schedule_map_f = isl_union_map_empty (isl_space_params_alloc (scop->ctx, 0));\n+  schedule_map = getScheduleMap (schedule, &schedule_map_f);\n \n-  apply_schedule_map_to_scop (scop, schedule_map);\n+  apply_schedule_map_to_scop (scop, schedule_map, false);\n+  if (!isl_union_map_is_empty (schedule_map_f))\n+    apply_schedule_map_to_scop (scop, schedule_map_f, true);\n+  isl_union_map_free (schedule_map_f);\n \n   isl_schedule_free (schedule);\n   isl_union_map_free (schedule_map);"}, {"sha": "77ccc3d605ff47d08e741c93d8eae38bcfd8294e", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -272,7 +272,7 @@ apply_poly_transforms (scop_p scop)\n \n   /* This pass needs to be run at the final stage, as it does not\n      update the lst.  */\n-  if (flag_loop_optimize_isl)\n+  if (flag_loop_optimize_isl || flag_loop_unroll_jam)\n     transform_done |= optimize_isl (scop);\n \n   return transform_done;\n@@ -323,6 +323,7 @@ new_poly_bb (scop_p scop, void *black_box)\n   pbb->schedule = NULL;\n   pbb->transformed = NULL;\n   pbb->saved = NULL;\n+  pbb->map_sepclass = NULL;\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n   PBB_TRANSFORMED (pbb) = NULL;"}, {"sha": "c8d9fa1fbb30d857d5c3301b02dc48a693f6918b", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -349,6 +349,9 @@ struct poly_bb\n   poly_scattering_p _saved;\n   isl_map *saved;\n \n+  /* For tiling, the map for computing the separating class.  */\n+  isl_map *map_sepclass;\n+\n   /* True when this PBB contains only a reduction statement.  */\n   bool is_reduction;\n };"}, {"sha": "59d5a136cfc104527b4b3f1a3190b50e845ec02a", "filename": "gcc/graphite.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -343,7 +343,8 @@ gate_graphite_transforms (void)\n       || flag_loop_strip_mine\n       || flag_graphite_identity\n       || flag_loop_parallelize_all\n-      || flag_loop_optimize_isl)\n+      || flag_loop_optimize_isl\n+      || flag_loop_unroll_jam)\n     flag_graphite = 1;\n \n   return flag_graphite != 0;"}, {"sha": "6c713268b9716310bc5c3b9ef5353e8586c4f23f", "filename": "gcc/params.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -847,6 +847,21 @@ DEFPARAM (PARAM_LOOP_BLOCK_TILE_SIZE,\n \t  \"size of tiles for loop blocking\",\n \t  51, 0, 0)\n \n+/* Size of unrolling factor for unroll-and-jam.  */\n+ \n+DEFPARAM (PARAM_LOOP_UNROLL_JAM_SIZE,\n+ \t  \"loop-unroll-jam-size\",\n+ \t  \"size of unrolling factor for unroll-and-jam\",\n+ \t  4, 0, 0)\n+\n+/* Size of the band formed by the strip mined dimension and the most inner one for unroll-and-jam.  */\n+ \n+DEFPARAM (PARAM_LOOP_UNROLL_JAM_DEPTH,\n+ \t  \"loop-unroll-jam-depth\",\n+ \t  \"depth of unrolled loop for unroll-and-jam\",\n+ \t  2, 0, 0)\n+\n+\n /* Maximal number of parameters that we allow in a SCoP.  */\n \n DEFPARAM (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS,"}, {"sha": "2e480471d6b3e2d22c135adfc833e8518aa45c1b", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=20d3465bd00c4d6f472e3982fbeb5fa1b9c2f2d2", "patch": "@@ -1346,11 +1346,12 @@ process_options (void)\n       || flag_loop_block\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n-      || flag_loop_parallelize_all)\n+      || flag_loop_parallelize_all\n+      || flag_loop_unroll_jam)\n     sorry (\"Graphite loop optimizations cannot be used (ISL is not available)\" \n \t   \"(-fgraphite, -fgraphite-identity, -floop-block, \"\n \t   \"-floop-interchange, -floop-strip-mine, -floop-parallelize-all, \"\n-\t   \"and -ftree-loop-linear)\");\n+\t   \"-floop-unroll-and-jam, and -ftree-loop-linear)\");\n #endif\n \n   if (flag_check_pointer_bounds)"}]}