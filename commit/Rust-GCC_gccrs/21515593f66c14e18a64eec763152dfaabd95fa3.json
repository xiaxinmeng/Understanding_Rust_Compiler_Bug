{"sha": "21515593f66c14e18a64eec763152dfaabd95fa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE1MTU1OTNmNjZjMTRlMThhNjRlZWM3NjMxNTJkZmFhYmQ5NWZhMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-09T17:13:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-09T17:13:31Z"}, "message": "ia64.c (move_operand): Allow symbolic_operand, but not tls_symbolic_operand.\n\n        * config/ia64/ia64.c (move_operand): Allow symbolic_operand,\n        but not tls_symbolic_operand.\n        (ia64_expand_load_address): Remove scratch operand.\n        (ia64_expand_tls_address): Split out from ia64_expand_move.\n        (ia64_expand_move): Split symbolics only after reload.\n        (ia64_emit_cond_move): New.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/ia64.md (movsi_symbolic, movdi_symbolic): Remove.\n        (symbolic splitter): Accept SImode operands too.\n        (cmove splitter): Use ia64_emit_cond_move.\n\nFrom-SVN: r65399", "tree": {"sha": "4d9e4826fc267a1b078c89e342ea73d827ab20a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d9e4826fc267a1b078c89e342ea73d827ab20a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21515593f66c14e18a64eec763152dfaabd95fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21515593f66c14e18a64eec763152dfaabd95fa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21515593f66c14e18a64eec763152dfaabd95fa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21515593f66c14e18a64eec763152dfaabd95fa3/comments", "author": null, "committer": null, "parents": [{"sha": "66d6bf1fcc3d18137df6a61d6152a6e0fd3891db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d6bf1fcc3d18137df6a61d6152a6e0fd3891db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d6bf1fcc3d18137df6a61d6152a6e0fd3891db"}], "stats": {"total": 445, "additions": 183, "deletions": 262}, "files": [{"sha": "2b13098ff899ea4635492534289476b90d32acd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21515593f66c14e18a64eec763152dfaabd95fa3", "patch": "@@ -1,3 +1,16 @@\n+2003-04-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (move_operand): Allow symbolic_operand,\n+\tbut not tls_symbolic_operand.\n+\t(ia64_expand_load_address): Remove scratch operand.\n+\t(ia64_expand_tls_address): Split out from ia64_expand_move.\n+\t(ia64_expand_move): Split symbolics only after reload.\n+\t(ia64_emit_cond_move): New.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.md (movsi_symbolic, movdi_symbolic): Remove.\n+\t(symbolic splitter): Accept SImode operands too.\n+\t(cmove splitter): Use ia64_emit_cond_move.\n+\n 2003-04-09  Nick Clifton  <nickc@redhat.com>\n \n \t* doc/install.texi: Note that ARM toolchains need binutils 2.13 or"}, {"sha": "53630e6a157de4e08b378abe8bb192a8755511e7", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=21515593f66c14e18a64eec763152dfaabd95fa3", "patch": "@@ -76,6 +76,7 @@ extern int basereg_operand PARAMS((rtx, enum machine_mode));\n \n extern rtx ia64_expand_move PARAMS ((rtx, rtx));\n extern int ia64_move_ok PARAMS((rtx, rtx));\n+extern void ia64_emit_cond_move PARAMS((rtx, rtx, rtx));\n extern int ia64_depz_field_mask PARAMS((rtx, rtx));\n extern rtx ia64_split_timode PARAMS((rtx[], rtx, rtx));\n extern rtx spill_tfmode_operand PARAMS((rtx, int));\n@@ -89,7 +90,7 @@ extern void ia64_expand_prologue PARAMS((void));\n extern void ia64_expand_epilogue PARAMS((int));\n \n extern int ia64_direct_return PARAMS((void));\n-extern void ia64_expand_load_address PARAMS((rtx, rtx, rtx));\n+extern void ia64_expand_load_address PARAMS((rtx, rtx));\n extern int ia64_hard_regno_rename_ok PARAMS((int, int));\n \n extern void ia64_initialize_trampoline PARAMS((rtx, rtx, rtx));"}, {"sha": "0f14818e716bf3935b6333fb30d947ea6b3c7582", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 152, "deletions": 196, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=21515593f66c14e18a64eec763152dfaabd95fa3", "patch": "@@ -165,6 +165,7 @@ static int ia64_first_cycle_multipass_dfa_lookahead_guard PARAMS ((rtx));\n static int ia64_dfa_new_cycle PARAMS ((FILE *, int, rtx, int, int, int *));\n static rtx gen_tls_get_addr PARAMS ((void));\n static rtx gen_thread_pointer PARAMS ((void));\n+static rtx ia64_expand_tls_address PARAMS ((enum tls_model, rtx, rtx));\n static int find_gr_spill PARAMS ((int));\n static int next_scratch_gr_reg PARAMS ((void));\n static void mark_reg_gr_used_mask PARAMS ((rtx, void *));\n@@ -564,21 +565,14 @@ setjmp_operand (op, mode)\n   return retval;\n }\n \n-/* Return 1 if OP is a general operand, but when pic exclude symbolic\n-   operands.  */\n-\n-/* ??? If we drop no-pic support, can delete SYMBOL_REF, CONST, and LABEL_REF\n-   from PREDICATE_CODES.  */\n+/* Return 1 if OP is a general operand, excluding tls symbolic operands.  */\n \n int\n move_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (! TARGET_NO_PIC && symbolic_operand (op, mode))\n-    return 0;\n-\n-  return general_operand (op, mode);\n+  return general_operand (op, mode) && !tls_symbolic_operand (op, mode);\n }\n \n /* Return 1 if OP is a register operand that is (or could be) a GR reg.  */\n@@ -1099,40 +1093,37 @@ ia64_depz_field_mask (rop, rshift)\n }\n \n /* Expand a symbolic constant load.  */\n-/* ??? Should generalize this, so that we can also support 32 bit pointers.  */\n \n void\n-ia64_expand_load_address (dest, src, scratch)\n-      rtx dest, src, scratch;\n-{\n-  rtx temp;\n-\n-  /* The destination could be a MEM during initial rtl generation,\n-     which isn't a valid destination for the PIC load address patterns.  */\n-  if (! register_operand (dest, DImode))\n-    if (! scratch || ! register_operand (scratch, DImode))\n-      temp = gen_reg_rtx (DImode);\n-    else\n-      temp = scratch;\n-  else\n-    temp = dest;\n-\n-  if (tls_symbolic_operand (src, Pmode))\n+ia64_expand_load_address (dest, src)\n+      rtx dest, src;\n+{\n+  if (tls_symbolic_operand (src, VOIDmode))\n+    abort ();\n+  if (GET_CODE (dest) != REG)\n     abort ();\n \n   if (TARGET_AUTO_PIC)\n-    emit_insn (gen_load_gprel64 (temp, src));\n+    {\n+      emit_insn (gen_load_gprel64 (dest, src));\n+      return;\n+    }\n   else if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_FLAG (src))\n-    emit_insn (gen_load_fptr (temp, src));\n-  else if ((GET_MODE (src) == Pmode || GET_MODE (src) == ptr_mode)\n-           && sdata_symbolic_operand (src, VOIDmode))\n-    emit_insn (gen_load_gprel (temp, src));\n-  else if (GET_CODE (src) == CONST\n-\t   && GET_CODE (XEXP (src, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n-\t   && (INTVAL (XEXP (XEXP (src, 0), 1)) & 0x1fff) != 0)\n-    {\n-      rtx subtarget = no_new_pseudos ? temp : gen_reg_rtx (DImode);\n+    {\n+      emit_insn (gen_load_fptr (dest, src));\n+      return;\n+    }\n+  else if (sdata_symbolic_operand (src, VOIDmode))\n+    {\n+      emit_insn (gen_load_gprel (dest, src));\n+      return;\n+    }\n+\n+  if (GET_CODE (src) == CONST\n+      && GET_CODE (XEXP (src, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (src, 0), 1)) == CONST_INT\n+      && (INTVAL (XEXP (XEXP (src, 0), 1)) & 0x1fff) != 0)\n+    {\n       rtx sym = XEXP (XEXP (src, 0), 0);\n       HOST_WIDE_INT ofs, hi, lo;\n \n@@ -1142,43 +1133,19 @@ ia64_expand_load_address (dest, src, scratch)\n       lo = ((ofs & 0x3fff) ^ 0x2000) - 0x2000;\n       hi = ofs - lo;\n \n-      if (! scratch)\n-\tscratch = no_new_pseudos ? subtarget : gen_reg_rtx (DImode);\n-\n-      emit_insn (gen_load_symptr (subtarget, plus_constant (sym, hi),\n-\t\t\t\t  scratch));\n-      emit_insn (gen_adddi3 (temp, subtarget, GEN_INT (lo)));\n+      emit_insn (gen_load_symptr (dest, plus_constant (sym, hi), dest));\n+      emit_insn (gen_adddi3 (dest, dest, GEN_INT (lo)));\n     }\n   else\n-    {\n-      rtx insn;\n-      if (! scratch)\n-\tscratch = no_new_pseudos ? temp : gen_reg_rtx (DImode);\n-\n-      insn = emit_insn (gen_load_symptr (temp, src, scratch));\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-      if (GET_MODE (temp) != GET_MODE (src))\n-\tsrc = convert_memory_address (GET_MODE (temp), src);\n-#endif\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n-    }\n-\n-  if (temp != dest)\n-    {\n-      if (GET_MODE (dest) != GET_MODE (temp))\n-\ttemp = convert_to_mode (GET_MODE (dest), temp, 0);\n-      emit_move_insn (dest, temp);\n-    }\n+    emit_insn (gen_load_symptr (dest, src, dest));\n }\n \n static GTY(()) rtx gen_tls_tga;\n static rtx\n gen_tls_get_addr ()\n {\n   if (!gen_tls_tga)\n-    {\n-      gen_tls_tga = init_one_libfunc (\"__tls_get_addr\");\n-     }\n+    gen_tls_tga = init_one_libfunc (\"__tls_get_addr\");\n   return gen_tls_tga;\n }\n \n@@ -1194,165 +1161,154 @@ gen_thread_pointer ()\n   return thread_pointer_rtx;\n }\n \n-rtx\n-ia64_expand_move (op0, op1)\n+static rtx\n+ia64_expand_tls_address (tls_kind, op0, op1)\n+     enum tls_model tls_kind;\n      rtx op0, op1;\n {\n-  enum machine_mode mode = GET_MODE (op0);\n-\n-  if (!reload_in_progress && !reload_completed && !ia64_move_ok (op0, op1))\n-    op1 = force_reg (mode, op1);\n+  rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n \n-  if (mode == Pmode || mode == ptr_mode)\n+  switch (tls_kind)\n     {\n-      enum tls_model tls_kind;\n-      if ((tls_kind = tls_symbolic_operand (op1, Pmode)))\n-\t{\n-\t  rtx tga_op1, tga_op2, tga_ret, tga_eqv, tmp, insns;\n+    case TLS_MODEL_GLOBAL_DYNAMIC:\n+      start_sequence ();\n \n-\t  switch (tls_kind)\n-\t    {\n-\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n-\t      start_sequence ();\n-\n-\t      tga_op1 = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n-\t      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n-\t      RTX_UNCHANGING_P (tga_op1) = 1;\n-\n-\t      tga_op2 = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n-\t      tga_op2 = gen_rtx_MEM (Pmode, tga_op2);\n-\t      RTX_UNCHANGING_P (tga_op2) = 1;\n+      tga_op1 = gen_reg_rtx (Pmode);\n+      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n+      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n+      RTX_UNCHANGING_P (tga_op1) = 1;\n+\n+      tga_op2 = gen_reg_rtx (Pmode);\n+      emit_insn (gen_load_ltoff_dtprel (tga_op2, op1));\n+      tga_op2 = gen_rtx_MEM (Pmode, tga_op2);\n+      RTX_UNCHANGING_P (tga_op2) = 1;\n \t      \n-\t      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n-\t\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n-\t\t\t\t\t\t Pmode, tga_op2, Pmode);\n+      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n+\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n+\t\t\t\t\t Pmode, tga_op2, Pmode);\n \n-\t      insns = get_insns ();\n-\t      end_sequence ();\n+      insns = get_insns ();\n+      end_sequence ();\n \n-\t      emit_libcall_block (insns, op0, tga_ret, op1);\n-\t      return NULL_RTX;\n+      emit_libcall_block (insns, op0, tga_ret, op1);\n+      return NULL_RTX;\n \n-\t    case TLS_MODEL_LOCAL_DYNAMIC:\n-\t      /* ??? This isn't the completely proper way to do local-dynamic\n-\t\t If the call to __tls_get_addr is used only by a single symbol,\n-\t\t then we should (somehow) move the dtprel to the second arg\n-\t\t to avoid the extra add.  */\n-\t      start_sequence ();\n+    case TLS_MODEL_LOCAL_DYNAMIC:\n+      /* ??? This isn't the completely proper way to do local-dynamic\n+\t If the call to __tls_get_addr is used only by a single symbol,\n+\t then we should (somehow) move the dtprel to the second arg\n+\t to avoid the extra add.  */\n+      start_sequence ();\n \n-\t      tga_op1 = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n-\t      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n-\t      RTX_UNCHANGING_P (tga_op1) = 1;\n+      tga_op1 = gen_reg_rtx (Pmode);\n+      emit_insn (gen_load_ltoff_dtpmod (tga_op1, op1));\n+      tga_op1 = gen_rtx_MEM (Pmode, tga_op1);\n+      RTX_UNCHANGING_P (tga_op1) = 1;\n \n-\t      tga_op2 = const0_rtx;\n+      tga_op2 = const0_rtx;\n \n-\t      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n-\t\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n-\t\t\t\t\t\t Pmode, tga_op2, Pmode);\n+      tga_ret = emit_library_call_value (gen_tls_get_addr (), NULL_RTX,\n+\t\t\t\t\t LCT_CONST, Pmode, 2, tga_op1,\n+\t\t\t\t\t Pmode, tga_op2, Pmode);\n \n-\t      insns = get_insns ();\n-\t      end_sequence ();\n+      insns = get_insns ();\n+      end_sequence ();\n \n-\t      tga_eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n-\t\t\t\t\tUNSPEC_LD_BASE);\n-\t      tmp = gen_reg_rtx (Pmode);\n-\t      emit_libcall_block (insns, tmp, tga_ret, tga_eqv);\n+      tga_eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\tUNSPEC_LD_BASE);\n+      tmp = gen_reg_rtx (Pmode);\n+      emit_libcall_block (insns, tmp, tga_ret, tga_eqv);\n \n-\t      if (register_operand (op0, Pmode))\n-\t\ttga_ret = op0;\n-\t      else\n-\t\ttga_ret = gen_reg_rtx (Pmode);\n-\t      if (TARGET_TLS64)\n-\t\t{\n-\t\t  emit_insn (gen_load_dtprel (tga_ret, op1));\n-\t\t  emit_insn (gen_adddi3 (tga_ret, tmp, tga_ret));\n-\t\t}\n-\t      else\n-\t\temit_insn (gen_add_dtprel (tga_ret, tmp, op1));\n-\t      if (tga_ret == op0)\n-\t\treturn NULL_RTX;\n-\t      op1 = tga_ret;\n-\t      break;\n+      if (register_operand (op0, Pmode))\n+\ttga_ret = op0;\n+      else\n+\ttga_ret = gen_reg_rtx (Pmode);\n+      if (TARGET_TLS64)\n+\t{\n+\t  emit_insn (gen_load_dtprel (tga_ret, op1));\n+\t  emit_insn (gen_adddi3 (tga_ret, tmp, tga_ret));\n+\t}\n+      else\n+\temit_insn (gen_add_dtprel (tga_ret, tmp, op1));\n \n-\t    case TLS_MODEL_INITIAL_EXEC:\n-\t      tmp = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_load_ltoff_tprel (tmp, op1));\n-\t      tmp = gen_rtx_MEM (Pmode, tmp);\n-\t      RTX_UNCHANGING_P (tmp) = 1;\n-\t      tmp = force_reg (Pmode, tmp);\n+      return (tga_ret == op0 ? NULL_RTX : tga_ret);\n \n-\t      if (register_operand (op0, Pmode))\n-\t\top1 = op0;\n-\t      else\n-\t\top1 = gen_reg_rtx (Pmode);\n-\t      emit_insn (gen_adddi3 (op1, tmp, gen_thread_pointer ()));\n-\t      if (op1 == op0)\n-\t\treturn NULL_RTX;\n-\t      break;\n+    case TLS_MODEL_INITIAL_EXEC:\n+      tmp = gen_reg_rtx (Pmode);\n+      emit_insn (gen_load_ltoff_tprel (tmp, op1));\n+      tmp = gen_rtx_MEM (Pmode, tmp);\n+      RTX_UNCHANGING_P (tmp) = 1;\n+      tmp = force_reg (Pmode, tmp);\n \n-\t    case TLS_MODEL_LOCAL_EXEC:\n-\t      if (register_operand (op0, Pmode))\n-\t\ttmp = op0;\n-\t      else\n-\t\ttmp = gen_reg_rtx (Pmode);\n-\t      if (TARGET_TLS64)\n-\t\t{\n-\t\t  emit_insn (gen_load_tprel (tmp, op1));\n-\t\t  emit_insn (gen_adddi3 (tmp, gen_thread_pointer (), tmp));\n-\t\t}\n-\t      else\n-\t\temit_insn (gen_add_tprel (tmp, gen_thread_pointer (), op1));\n-\t      if (tmp == op0)\n-\t\treturn NULL_RTX;\n-\t      op1 = tmp;\n-\t      break;\n+      if (register_operand (op0, Pmode))\n+\top1 = op0;\n+      else\n+\top1 = gen_reg_rtx (Pmode);\n+      emit_insn (gen_adddi3 (op1, tmp, gen_thread_pointer ()));\n \n-\t    default:\n-\t      abort ();\n-\t    }\n+      return (op1 == op0 ? NULL_RTX : op1);\n+\n+    case TLS_MODEL_LOCAL_EXEC:\n+      if (register_operand (op0, Pmode))\n+\ttmp = op0;\n+      else\n+\ttmp = gen_reg_rtx (Pmode);\n+      if (TARGET_TLS64)\n+\t{\n+\t  emit_insn (gen_load_tprel (tmp, op1));\n+\t  emit_insn (gen_adddi3 (tmp, gen_thread_pointer (), tmp));\n \t}\n-      else if (!TARGET_NO_PIC &&\n-\t       (symbolic_operand (op1, Pmode) ||\n-\t\tsymbolic_operand (op1, ptr_mode)))\n+      else\n+\temit_insn (gen_add_tprel (tmp, gen_thread_pointer (), op1));\n+\n+      return (tmp == op0 ? NULL_RTX : tmp);\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+rtx\n+ia64_expand_move (op0, op1)\n+     rtx op0, op1;\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+\n+  if (!reload_in_progress && !reload_completed && !ia64_move_ok (op0, op1))\n+    op1 = force_reg (mode, op1);\n+\n+  if ((mode == Pmode || mode == ptr_mode) && symbolic_operand (op1, VOIDmode))\n+    {\n+      enum tls_model tls_kind;\n+      if ((tls_kind = tls_symbolic_operand (op1, VOIDmode)))\n+\treturn ia64_expand_tls_address (tls_kind, op0, op1);\n+\n+      if (!TARGET_NO_PIC && reload_completed)\n \t{\n-\t  /* Before optimization starts, delay committing to any particular\n-\t     type of PIC address load.  If this function gets deferred, we\n-\t     may acquire information that changes the value of the\n-\t     sdata_symbolic_operand predicate.\n-\n-\t     But don't delay for function pointers.  Loading a function address\n-\t     actually loads the address of the descriptor not the function.\n-\t     If we represent these as SYMBOL_REFs, then they get cse'd with\n-\t     calls, and we end up with calls to the descriptor address instead\n-\t     of calls to the function address.  Functions are not candidates\n-\t     for sdata anyways.\n-\n-\t     Don't delay for LABEL_REF because the splitter loses REG_LABEL\n-\t     notes.  Don't delay for pool addresses on general principals;\n-\t     they'll never become non-local behind our back.  */\n-\n-\t  if (rtx_equal_function_value_matters\n-\t      && GET_CODE (op1) != LABEL_REF\n-\t      && ! (GET_CODE (op1) == SYMBOL_REF\n-\t\t    && (SYMBOL_REF_FLAG (op1)\n-\t\t\t|| CONSTANT_POOL_ADDRESS_P (op1)\n-\t\t\t|| STRING_POOL_ADDRESS_P (op1))))\n-\t    if (GET_MODE (op1) == DImode)\n-\t      emit_insn (gen_movdi_symbolic (op0, op1));\n-\t    else\n-\t      emit_insn (gen_movsi_symbolic (op0, op1));\n-\t  else\n-\t    ia64_expand_load_address (op0, op1, NULL_RTX);\n+\t  ia64_expand_load_address (op0, op1);\n \t  return NULL_RTX;\n \t}\n     }\n \n   return op1;\n }\n \n+/* Split a move from OP1 to OP0 conditional on COND.  */\n+\n+void\n+ia64_emit_cond_move (op0, op1, cond)\n+     rtx op0, op1, cond;\n+{\n+  rtx insn, first = get_last_insn ();\n+\n+  emit_move_insn (op0, op1);\n+\n+  for (insn = get_last_insn (); insn != first; insn = PREV_INSN (insn))\n+    if (INSN_P (insn))\n+      PATTERN (insn) = gen_rtx_COND_EXEC (VOIDmode, copy_rtx (cond),\n+\t\t\t\t\t  PATTERN (insn));\n+}\n+\n /* Split a post-reload TImode reference into two DImode components.  */\n \n rtx"}, {"sha": "074d8fdd3b5f45fb829695fac80b631b6f7cc3a7", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 16, "deletions": 65, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21515593f66c14e18a64eec763152dfaabd95fa3/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=21515593f66c14e18a64eec763152dfaabd95fa3", "patch": "@@ -292,29 +292,6 @@\n   operands[1] = op1;\n })\n \n-;; This is used during early compilation to delay the decision on\n-;; how to refer to a variable as long as possible.  This is especially\n-;; important between initial rtl generation and optimization for\n-;; deferred functions, since we may acquire additional information\n-;; on the variables used in the meantime.\n-\n-(define_insn_and_split \"movsi_symbolic\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"symbolic_operand\" \"s\"))\n-   (clobber (match_scratch:DI 2 \"=r\"))\n-   (use (reg:DI 1))]\n-  \"\"\n-  \"* abort ();\"\n-  \"!no_new_pseudos || reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx scratch = operands[2];\n-  if (!reload_completed)\n-    scratch = gen_reg_rtx (Pmode);\n-  ia64_expand_load_address (operands[0], operands[1], scratch); \n-  DONE;\n-})\n-\n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"destination_operand\" \"=r,r,r,r, m, r,*f,*f, r,*d\")\n \t(match_operand:SI 1 \"move_operand\"        \"rO,J,i,m,rO,*f,rO,*f,*d,rK\"))]\n@@ -344,29 +321,6 @@\n   operands[1] = op1;\n })\n \n-;; This is used during early compilation to delay the decision on\n-;; how to refer to a variable as long as possible.  This is especially\n-;; important between initial rtl generation and optimization for\n-;; deferred functions, since we may acquire additional information\n-;; on the variables used in the meantime.\n-\n-(define_insn_and_split \"movdi_symbolic\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"symbolic_operand\" \"s\"))\n-   (clobber (match_scratch:DI 2 \"=r\"))\n-   (use (reg:DI 1))]\n-  \"\"\n-  \"* abort ();\"\n-  \"!no_new_pseudos || reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx scratch = operands[2];\n-  if (!reload_completed)\n-    scratch = gen_reg_rtx (Pmode);\n-  ia64_expand_load_address (operands[0], operands[1], scratch); \n-  DONE;\n-})\n-\n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"destination_operand\"\n \t\t    \"=r,r,r,r, m, r,*f,*f,*f, Q, r,*b, r,*e, r,*d, r,*c\")\n@@ -404,12 +358,12 @@\n   [(set_attr \"itanium_class\" \"ialu,ialu,long_i,ld,st,frfr,tofr,fmisc,fld,stf,frbr,tobr,frar_i,toar_i,frar_m,toar_m,frpr,topr\")])\n \n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operand:DI 1 \"symbolic_operand\" \"\"))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"symbolic_operand\" \"\"))]\n   \"reload_completed && ! TARGET_NO_PIC\"\n   [(const_int 0)]\n {\n-  ia64_expand_load_address (operands[0], operands[1], NULL_RTX);\n+  ia64_expand_load_address (operands[0], operands[1]);\n   DONE;\n })\n \n@@ -4452,26 +4406,23 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  rtx tmp;\n-  int emitted_something;\n+  bool emitted_something = false;\n+  rtx dest = operands[0];\n+  rtx srct = operands[2];\n+  rtx srcf = operands[3];\n+  rtx cond = operands[4];\n \n-  emitted_something = 0;\n-  if (! rtx_equal_p (operands[0], operands[2]))\n+  if (! rtx_equal_p (dest, srct))\n     {\n-      tmp = gen_rtx_SET (VOIDmode, operands[0], operands[2]);\n-      tmp = gen_rtx_COND_EXEC (VOIDmode, operands[4], tmp);\n-      emit_insn (tmp);\n-      emitted_something = 1;\n+      ia64_emit_cond_move (dest, srct, cond);\n+      emitted_something = true;\n     }\n-  if (! rtx_equal_p (operands[0], operands[3]))\n+  if (! rtx_equal_p (dest, srcf))\n     {\n-      tmp = gen_rtx_fmt_ee (GET_CODE (operands[4]) == NE ? EQ : NE,\n-\t\t\t    VOIDmode, operands[1], const0_rtx);\n-      tmp = gen_rtx_COND_EXEC (VOIDmode, tmp,\n-\t\t\t       gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t\t    operands[3]));\n-      emit_insn (tmp);\n-      emitted_something = 1;\n+      cond = gen_rtx_fmt_ee (GET_CODE (cond) == NE ? EQ : NE,\n+ \t\t\t     VOIDmode, operands[1], const0_rtx);\n+      ia64_emit_cond_move (dest, srcf, cond);\n+      emitted_something = true;\n     }\n   if (! emitted_something)\n     emit_note (NULL, NOTE_INSN_DELETED);"}]}