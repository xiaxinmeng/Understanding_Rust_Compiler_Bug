{"sha": "2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0YTljZmZjMTk3ZWFkZTVjN2I2ZTcxMzVhODVmYzIxOGE5MmI2Ng==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2003-07-08T01:45:30Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-07-08T01:45:30Z"}, "message": "configure.in: Test for PowerPC mfcr field support in assembler.\n\n2003-07-07  David Edelsohn  <edelsohn@gnu.org>\n            Fariborz Jahanian  <fjahanian@apple.com>\n\n        * configure.in: Test for PowerPC mfcr field support in assembler.\n        * config.in, configure: Regenderated.\n\n        * config/rs6000/power4.md: Add mfcrf reservation.\n        * config/rs6000/rs6000-protos.h (mfcr_operation): Declare.\n        * config/rs6000/rs6000.c (mfcr_operation): Define.\n        (print_operand): Add 'Q' case for mfcrf.\n        * config/rs6000/rs6000.h (TARGET_MFCRF): New.\n        * config/rs6000/rs6000.md (attribute \"type\"): Add mfcrf.\n        (movcc_internal1): Emit optional field operand for mfcr and set\n        \"type\" attribute appropriately.\n        (mfcr SCC): Likewise.\n        (movesi_from_cr_one): New.\n\nCo-Authored-By: Fariborz Jahanian <fjahanian@apple.com>\n\nFrom-SVN: r69064", "tree": {"sha": "f500526f9477b9b56cad63a6b0383535e5b405a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f500526f9477b9b56cad63a6b0383535e5b405a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/comments", "author": null, "committer": null, "parents": [{"sha": "ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee76b9314ba2aa2dc1f59c4efa32ac42dd84147d"}], "stats": {"total": 264, "additions": 247, "deletions": 17}, "files": [{"sha": "0d9300b12d6bbcd06a0436c554a17cd53182c6b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -1,3 +1,20 @@\n+2003-07-07  David Edelsohn  <edelsohn@gnu.org>\n+\t    Fariborz Jahanian  <fjahanian@apple.com>\n+\n+\t* configure.in: Test for PowerPC mfcr field support in assembler.\n+\t* config.in, configure: Regenderated.\n+\n+\t* config/rs6000/power4.md: Add mfcrf reservation.\n+\t* config/rs6000/rs6000-protos.h (mfcr_operation): Declare.\n+\t* config/rs6000/rs6000.c (mfcr_operation): Define.\n+\t(print_operand): Add 'Q' case for mfcrf.\n+\t* config/rs6000/rs6000.h (TARGET_MFCRF): New.\n+\t* config/rs6000/rs6000.md (attribute \"type\"): Add mfcrf.\n+\t(movcc_internal1): Emit optional field operand for mfcr and set\n+\t\"type\" attribute appropriately.\n+\t(mfcr SCC): Likewise.\n+\t(movesi_from_cr_one): New.\n+\n 2003-07-07  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md: Correct check-in of incorrect version."}, {"sha": "997094c5964014098bd0ad5dfc430c2b9d5b1c38", "filename": "gcc/config.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -572,6 +572,9 @@\n /* Define if your assembler supports ltoffx and ldxmov relocations. */\n #undef HAVE_AS_LTOFFX_LDXMOV_RELOCS\n \n+/* Define if your assembler supports mfcr field. */\n+#undef HAVE_AS_MFCRF\n+\n /* Define if your assembler supports dwarf2 .file/.loc directives,\n    and preserves file table indices exactly as given. */\n #undef HAVE_AS_DWARF2_DEBUG_LINE"}, {"sha": "fabc1de34aabefb4594f4c2b00b9ea73ff5d6fbc", "filename": "gcc/config/rs6000/power4.md", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Fpower4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Fpower4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpower4.md?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -202,7 +202,7 @@\n   |(du2_power4+du3_power4,iu2_power4,iu2_power4)\\\n   |(du3_power4+du4_power4,nothing,iu2_power4,iu1_power4)\")\n \n-(define_bypass 4 \"power4-compare\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr\")\n+(define_bypass 4 \"power4-compare\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-lmul-cmp\" 7\n   (and (eq_attr \"type\" \"lmul_compare\")\n@@ -212,7 +212,7 @@\n   |(du3_power4+du4_power4,iu2_power4*6,iu1_power4)\")\n ;  |(du3_power4+du4_power4,nothing,iu2_power4*6,iu1_power4)\")\n \n-(define_bypass 10 \"power4-lmul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr\")\n+(define_bypass 10 \"power4-lmul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-imul-cmp\" 5\n   (and (eq_attr \"type\" \"imul_compare\")\n@@ -222,7 +222,7 @@\n   |(du3_power4+du4_power4,iu2_power4*4,iu1_power4)\")\n ;  |(du3_power4+du4_power4,nothing,iu2_power4*4,iu1_power4)\")\n \n-(define_bypass 8 \"power4-imul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr\")\n+(define_bypass 8 \"power4-imul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-lmul\" 7\n   (and (eq_attr \"type\" \"lmul\")\n@@ -305,6 +305,12 @@\n    du1_power4+du2_power4+du3_power4+du4_power4+cru_power4,\\\n    cru_power4,cru_power4,cru_power4\")\n \n+; mfcrf (1 field)\n+(define_insn_reservation \"power4-mfcrf\" 3\n+  (and (eq_attr \"type\" \"mfcrf\")\n+       (eq_attr \"cpu\" \"power4\"))\n+  \"du1_power4,cru_power4\")\n+\n ; mtcrf (1 field)\n (define_insn_reservation \"power4-mtcr\" 4\n   (and (eq_attr \"type\" \"mtcr\")\n@@ -379,7 +385,7 @@\n (define_bypass 9 \"power4-vecfloat\" \"power4-vecperm\")\n \n (define_bypass 5 \"power4-vecsimple,power4-veccomplex\"\n-\t\t \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr\")\n+\t\t \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_bypass 4 \"power4-vecsimple,power4-vecperm\" \"power4-vecstore\")\n (define_bypass 7 \"power4-veccomplex\" \"power4-vecstore\")"}, {"sha": "fc7e9cb96d84db4fd58fd3acb21b985184e34d88", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -122,6 +122,7 @@ extern void rs6000_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n extern struct rtx_def *rs6000_longcall_ref PARAMS ((rtx));\n extern void rs6000_fatal_bad_address PARAMS ((rtx));\n extern int stmw_operation PARAMS ((rtx, enum machine_mode));\n+extern int mfcr_operation PARAMS ((rtx, enum machine_mode));\n extern int mtcrf_operation PARAMS ((rtx, enum machine_mode));\n extern int lmw_operation PARAMS ((rtx, enum machine_mode));\n extern struct rtx_def *create_TOC_reference PARAMS ((rtx));"}, {"sha": "7ff59de6b76674d957231a935acaa8dbbc7cde01", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -7294,6 +7294,56 @@ vrsave_operation (op, mode)\n   return 1;\n }\n \n+/* Return 1 for an PARALLEL suitable for mfcr.  */\n+\n+int\n+mfcr_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count < 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC\n+      || XVECLEN (SET_SRC (XVECEXP (op, 0, 0)), 0) != 2)\n+    return 0;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      rtx exp = XVECEXP (op, 0, i);\n+      rtx unspec;\n+      int maskval;\n+      rtx src_reg;\n+\n+      src_reg = XVECEXP (SET_SRC (exp), 0, 0);\n+\n+      if (GET_CODE (src_reg) != REG\n+\t  || GET_MODE (src_reg) != CCmode\n+\t  || ! CR_REGNO_P (REGNO (src_reg)))\n+\treturn 0;\n+\n+      if (GET_CODE (exp) != SET\n+\t  || GET_CODE (SET_DEST (exp)) != REG\n+\t  || GET_MODE (SET_DEST (exp)) != SImode\n+\t  || ! INT_REGNO_P (REGNO (SET_DEST (exp))))\n+\treturn 0;\n+      unspec = SET_SRC (exp);\n+      maskval = 1 << (MAX_CR_REGNO - REGNO (src_reg));\n+\n+      if (GET_CODE (unspec) != UNSPEC\n+\t  || XINT (unspec, 1) != UNSPEC_MOVESI_FROM_CR\n+\t  || XVECLEN (unspec, 0) != 2\n+\t  || XVECEXP (unspec, 0, 0) != src_reg\n+\t  || GET_CODE (XVECEXP (unspec, 0, 1)) != CONST_INT\n+\t  || INTVAL (XVECEXP (unspec, 0, 1)) != maskval)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n /* Return 1 for an PARALLEL suitable for mtcrf.  */\n \n int\n@@ -8499,6 +8549,13 @@ print_operand (file, x, code)\n       }\n       return;\n \n+    case 'Q':\n+      if (TARGET_MFCRF)\n+\tfputc (',',file);\n+        /* FALLTHRU */\n+      else\n+\treturn;\n+\n     case 'R':\n       /* X is a CR register.  Print the mask for `mtcrf'.  */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n@@ -13198,7 +13255,8 @@ rs6000_variable_issue (stream, verbose, insn, more)\n     {\n       enum attr_type type = get_attr_type (insn);\n       if (type == TYPE_LOAD_EXT_U || type == TYPE_LOAD_EXT_UX\n-\t  || type == TYPE_LOAD_UX || type == TYPE_STORE_UX)\n+\t  || type == TYPE_LOAD_UX || type == TYPE_STORE_UX\n+\t  || type == TYPE_MFCR)\n \treturn 0;\n       else if (type == TYPE_LOAD_U || type == TYPE_STORE_U\n \t       || type == TYPE_FPLOAD_U || type == TYPE_FPSTORE_U"}, {"sha": "e91571967d5f03671f61b3e9fdd0063edff14d93", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -475,6 +475,16 @@ extern int rs6000_alignment_flags;\n #define TARGET_ALIGN_NATURAL 0\n #endif\n \n+/* Define TARGET_MFCRF if the target assembler supports the optional\n+   field operand for mfcr and the target processor supports the\n+   instruction.  */\n+\n+#ifdef HAVE_AS_MFCRF\n+#define TARGET_MFCRF (rs6000_cpu == PROCESSOR_POWER4)\n+#else\n+#define TARGET_MFCRF 0\n+#endif\n+\n #define TARGET_LONG_DOUBLE_128 (rs6000_long_double_type_size == 128)\n #define TARGET_ALTIVEC_ABI rs6000_altivec_abi\n #define TARGET_ALTIVEC_VRSAVE rs6000_altivec_vrsave"}, {"sha": "bf778e2e22c7a64607ec567700c7118816aea8a6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -62,7 +62,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"integer,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv\"\n+(define_attr \"type\" \"integer,load,load_ext,load_ext_u,load_ext_ux,load_ux,load_u,store,store_ux,store_u,fpload,fpload_ux,fpload_u,fpstore,fpstore_ux,fpstore_u,vecload,vecstore,imul,imul2,imul3,lmul,idiv,ldiv,insert_word,branch,cmp,fast_compare,compare,delayed_compare,imul_compare,lmul_compare,fpcompare,cr_logical,delayed_cr,mfcr,mfcrf,mtcr,mfjmpr,mtjmpr,fp,fpsimple,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg,brinc,vecsimple,veccomplex,vecdiv,veccmp,veccmpsimple,vecperm,vecfloat,vecfdiv\"\n   (const_string \"integer\"))\n \n ;; Length (in bytes).\n@@ -7800,15 +7800,33 @@\n    mcrf %0,%1\n    mtcrf 128,%1\n    {rlinm|rlwinm} %1,%1,%F0,0xffffffff\\;mtcrf %R0,%1\\;{rlinm|rlwinm} %1,%1,%f0,0xffffffff\n-   mfcr %0\n-   mfcr %0\\;{rlinm|rlwinm} %0,%0,%f1,0xf0000000\n+   mfcr %0%Q1\n+   mfcr %0%Q1\\;{rlinm|rlwinm} %0,%0,%f1,0xf0000000\n    mr %0,%1\n    mf%1 %0\n    mt%0 %1\n    mt%0 %1\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%U1|stw%U0%U1} %1,%0\"\n-  [(set_attr \"type\" \"cr_logical,mtcr,mtcr,mfcr,mfcr,*,mfjmpr,*,mtjmpr,load,store\")\n+  [(set (attr \"type\")\n+     (cond [(eq_attr \"alternative\" \"0\")\n+\t\t(const_string \"cr_logical\")\n+\t    (eq_attr \"alternative\" \"1,2\")\n+\t\t(const_string \"mtcr\")\n+\t    (eq_attr \"alternative\" \"5,7\")\n+\t\t(const_string \"integer\")\n+\t    (eq_attr \"alternative\" \"6\")\n+\t\t(const_string \"mfjmpr\")\n+\t    (eq_attr \"alternative\" \"8\")\n+\t\t(const_string \"mtjmpr\")\n+\t    (eq_attr \"alternative\" \"9\")\n+\t\t(const_string \"load\")\n+\t    (eq_attr \"alternative\" \"10\")\n+\t\t(const_string \"store\")\n+\t    (ne (symbol_ref \"TARGET_MFCRF\") (const_int 0))\n+\t\t(const_string \"mfcrf\")\n+\t   ]\n+\t(const_string \"mfcr\")))\n    (set_attr \"length\" \"4,4,12,4,8,4,4,4,4,4,4\")])\n \f\n ;; For floating-point, we normally deal with the floating-point registers\n@@ -11368,8 +11386,12 @@\n \t\t\t   [(match_operand 2 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"\"\n-  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n-  [(set_attr \"type\" \"mfcr\")\n+  \"mfcr %0%Q2\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n+  [(set (attr \"type\")\n+     (cond [(ne (symbol_ref \"TARGET_MFCRF\") (const_int 0))\n+\t\t(const_string \"mfcrf\")\n+\t   ]\n+\t(const_string \"mfcr\")))\n    (set_attr \"length\" \"12\")])\n \n ;; Same as above, but get the OV/ORDERED bit.\n@@ -11387,8 +11409,12 @@\n \t\t\t   [(match_operand 2 \"cc_reg_operand\" \"y\")\n \t\t\t    (const_int 0)]))]\n   \"TARGET_POWERPC64\"\n-  \"mfcr %0\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n-  [(set_attr \"type\" \"mfcr\")\n+  \"mfcr %0%Q2\\;{rlinm|rlwinm} %0,%0,%J1,1\"\n+  [(set (attr \"type\")\n+     (cond [(ne (symbol_ref \"TARGET_MFCRF\") (const_int 0))\n+\t\t(const_string \"mfcrf\")\n+\t   ]\n+\t(const_string \"mfcr\")))\n    (set_attr \"length\" \"12\")])\n \n (define_insn \"\"\n@@ -11401,7 +11427,7 @@\n \t(match_op_dup 1 [(match_dup 2) (const_int 0)]))]\n   \"! TARGET_POWERPC64\"\n   \"@\n-   mfcr %3\\;{rlinm.|rlwinm.} %3,%3,%J1,1\n+   mfcr %3%Q2\\;{rlinm.|rlwinm.} %3,%3,%J1,1\n    #\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"12,16\")])\n@@ -11443,9 +11469,13 @@\n   operands[4] = GEN_INT (count);\n   operands[5] = GEN_INT (put_bit);\n \n-  return \\\"mfcr %0\\;{rlinm|rlwinm} %0,%0,%4,%5,%5\\\";\n+  return \\\"mfcr %0%Q2\\;{rlinm|rlwinm} %0,%0,%4,%5,%5\\\";\n }\"\n-  [(set_attr \"type\" \"mfcr\")\n+  [(set (attr \"type\")\n+     (cond [(ne (symbol_ref \"TARGET_MFCRF\") (const_int 0))\n+\t\t(const_string \"mfcrf\")\n+\t   ]\n+\t(const_string \"mfcr\")))\n    (set_attr \"length\" \"12\")])\n \n (define_insn \"\"\n@@ -11478,7 +11508,7 @@\n   operands[5] = GEN_INT (count);\n   operands[6] = GEN_INT (put_bit);\n \n-  return \\\"mfcr %4\\;{rlinm.|rlwinm.} %4,%4,%5,%6,%6\\\";\n+  return \\\"mfcr %4%Q2\\;{rlinm.|rlwinm.} %4,%4,%5,%6,%6\\\";\n }\"\n   [(set_attr \"type\" \"delayed_compare\")\n    (set_attr \"length\" \"12,16\")])\n@@ -14434,6 +14464,27 @@\n       DONE;\n }\")\n \n+(define_insn \"*movesi_from_cr_one\"\n+  [(match_parallel 0 \"mfcr_operation\"\n+\t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n+\t\t\t (unspec:SI [(match_operand:CC 2 \"cc_reg_operand\" \"y\")\n+\t\t\t\t     (match_operand 3 \"immediate_operand\" \"n\")]\n+\t\t\t  UNSPEC_MOVESI_FROM_CR))])]\n+  \"TARGET_MFCRF\"\n+  \"*\n+{\n+  int mask = 0;\n+  int i;\n+  for (i = 0; i < XVECLEN (operands[0], 0); i++)\n+  {\n+    mask = INTVAL (XVECEXP (SET_SRC (XVECEXP (operands[0], 0, i)), 0, 1));\n+    operands[4] = GEN_INT (mask);\n+    output_asm_insn (\\\"mfcr %1,%4\\\", operands);\n+  }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"mfcrf\")])\n+\n (define_insn \"movesi_from_cr\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n         (unspec:SI [(reg:CC 68) (reg:CC 69) (reg:CC 70) (reg:CC 71) "}, {"sha": "d80504cd1444a936519590df1142e9de98a58acf", "filename": "gcc/configure", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -8319,6 +8319,55 @@ echo \"$ac_t\"\"$gcc_cv_as_ltoffx_ldxmov_relocs\" 1>&6\n     if test \"x$gcc_cv_as_ltoffx_ldxmov_relocs\" = xyes; then\n \tcat >> confdefs.h <<\\EOF\n #define HAVE_AS_LTOFFX_LDXMOV_RELOCS 1\n+EOF\n+\n+    fi\n+    ;;\n+  powerpc*-*-*)\n+    echo $ac_n \"checking assembler supports mfcr field\"\"... $ac_c\" 1>&6\n+echo \"configure:8174: checking assembler supports mfcr field\" >&5\n+if eval \"test \\\"`echo '$''{'gcc_cv_as_mfcrf'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  \n+\tgcc_cv_as_mfcrf=unknown\n+\tif test $in_tree_gas = yes ; then\n+           if test $gcc_cv_gas_major_version -eq 2 \\\n+&& test $gcc_cv_gas_minor_version -ge 14 \\\n+|| test $gcc_cv_gas_major_version -gt 2 ; then\n+\n+\n+\t    gcc_cv_as_mfcrf=yes\n+          \n+\n+fi\n+\n+\telif test x$gcc_cv_as != x; then\n+\t    cat > conftest.s << 'EOF'\n+\t      case \"$target\" in\n+\t\t*-*-aix*)\n+\t.csect .text[PR]\n+\t\t;;\n+\t\t*)\n+\t.text\n+\t\t;;\n+\t      esac\n+\tmfcr 3,128\n+EOF\n+\t    if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_mfcrf=yes\n+\t    else\n+\t\tgcc_cv_as_mfcrf=no\n+\t    fi\n+\t    rm -f conftest.s conftest.o\n+\tfi\n+    \n+fi\n+\n+echo \"$ac_t\"\"$gcc_cv_as_mfcrf\" 1>&6\n+    if test \"x$gcc_cv_as_mfcrf\" = xyes; then\n+\tcat >> confdefs.h <<\\EOF\n+#define HAVE_AS_MFCRF 1\n EOF\n \n     fi"}, {"sha": "483b02ca80abfac8f5da4919ae4b3e676c22e403", "filename": "gcc/configure.in", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4a9cffc197eade5c7b6e7135a85fc218a92b66/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=2c4a9cffc197eade5c7b6e7135a85fc218a92b66", "patch": "@@ -2462,6 +2462,41 @@ changequote([,])dnl\n \t  [Define if your assembler supports ltoffx and ldxmov relocations.])\n     fi\n     ;;\n+  powerpc*-*-*)\n+    AC_CACHE_CHECK([assembler supports mfcr field],\n+\tgcc_cv_as_mfcrf, [\n+\tgcc_cv_as_mfcrf=unknown\n+\tif test $in_tree_gas = yes ; then\n+          gcc_GAS_VERSION_GTE_IFELSE(2,14,0,[\n+\t    gcc_cv_as_mfcrf=yes\n+          ])\n+\telif test x$gcc_cv_as != x; then\n+\t    cat > conftest.s << 'EOF'\n+\t      case \"$target\" in\n+changequote(,)dnl\n+\t\t*-*-aix*)\n+\t.csect .text[PR]\n+\t\t;;\n+\t\t*)\n+\t.text\n+\t\t;;\n+\t      esac\n+\tmfcr 3,128\n+EOF\n+changequote([,])dnl\n+\t    if $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1; then\n+\t\tgcc_cv_as_mfcrf=yes\n+\t    else\n+\t\tgcc_cv_as_mfcrf=no\n+\t    fi\n+\t    rm -f conftest.s conftest.o\n+\tfi\n+    ])\n+    if test \"x$gcc_cv_as_mfcrf\" = xyes; then\n+\tAC_DEFINE(HAVE_AS_MFCRF, 1,\n+\t  [Define if your assembler supports mfcr field.])\n+    fi\n+    ;;\n esac\n \n AC_MSG_CHECKING(assembler dwarf2 debug_line support)"}]}