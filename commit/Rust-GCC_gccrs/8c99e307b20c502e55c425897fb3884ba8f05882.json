{"sha": "8c99e307b20c502e55c425897fb3884ba8f05882", "node_id": "C_kwDOANBUbNoAKDhjOTllMzA3YjIwYzUwMmU1NWM0MjU4OTdmYjM4ODRiYThmMDU4ODI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-25T22:58:02Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-06-25T23:04:01Z"}, "message": "Convert DOM to use Ranger rather than EVRP\n\n[Jeff, this is the same patch I sent you last week with minor tweaks\nto the commit message.]\n\n[Despite the verbosity of the message, this is actually a pretty\nstraightforward patch.  It should've gone in last cycle, but there\nwas a nagging regression I couldn't get to until after stage1\nhad closed.]\n\nThere are 3 uses of EVRP in DOM that must be converted.\nUnfortunately, they need to be converted in one go, so further\nsplitting of this patch would be problematic.\n\nThere's nothing here earth shattering.  It's all pretty obvious in\nretrospect, but I've added a short description of each use to aid in\nreviewing:\n\n* Convert evrp use in cprop to ranger.\n\n  This is easy, as cprop in DOM was converted to the ranger API last\n  cycle, so this is just a matter of using a ranger instead of an\n  evrp_range_analyzer.\n\n* Convert evrp use in threader to ranger.\n\n  The idea here is to use the hybrid approach we used for the initial\n  VRP threader conversion last cycle.  The DOM threader will continue\n  using the forward threader infrastructure while continuing to query\n  DOM data structures, and only if the conditional does not relsolve,\n  using the ranger.  This gives us the best of both worlds, and is a\n  proven approach.\n\n  Furthermore, as frange and prange come live in the next cycle, we\n  can move away from the forward threader altogether, and just add\n  another backward threader.  This will not only remove the last use\n  of the forward threader, but will allow us to remove at least 1 or 2\n  threader instances.\n\n* Convert conditional folding to use the method used by the ranger and\n  evrp.  Previously DOM was calling into the guts of\n  simplify_using_ranges::vrp_visit_cond_stmt.  The blessed way now is\n  using fold_cond() which rewrites the conditional and edges\n  automatically.\n\n  When legacy is removed, simplify_using_ranges will be further\n  cleaned up, and there will only be one entry point into simplifying\n  a statement.\n\n* DOM was setting global ranges determined from unreachable edges as a\n  side-effect of using the evrp engine.  We must handle these cases\n  before nuking evrp, and DOM seems like a good fit.  I've just moved\n  the snippet to DOM, but it could live anywhere else we do a DOM\n  walk.\n\n  For the record, this is the case *vrp handled:\n\n\t<bb C>:\n\t...\n\tif (c_5(D) != 5)\n\tgoto <bb N>;\n\telse\n\tgoto <bb M>;\n\t<bb N>:\n\t__builtin_unreachable ();\n\t<bb M>:\n\n  If M dominates all uses of c_5, we can set the global range of c_5\n  to [5,5].\n\nI have tested on x86-64, pcc64le, and aarch64 Linux.\n\nI also ran threading benchmarks as well as performance benchmarks.\n\nDOM threads 1.56% more paths which ultimately yields a miniscule total\nincrease of 0.03%.\n\nThe conversion to ranger brings a 7.87% performance drop in DOM, which\nis a wash in overall compilation.  This is in line with other\nreplacements of legacy evrp with ranger.  We handle a lot more cases.\nIt's not free .\n\nThere is a a regression on Wstringop-overflow-4.C which I'm planning\non XFAILing.  It's another variant of the usual middle-end false\npositives: having no ranges produces no warnings, but slightly refined\nranges, or worse-- isolating specific problematic cases in the\nthreader causes flare-ups.\n\nAs an aside, as Richi has suggested, I think we should discuss\nrestricting the threader's ability to thread highly unlikely paths.\nThese cause no end of pain for middle-end warnings.  However,\nI don't know if this would conflict with path isolation for\nthings like null dereferencing.  ISTR you were interested in this.\n\nBTW, I think the Wstringop-overflow-4.C test is problematic and I've\nattached my analysis.  Basically the regression is caused by a bad\ninteraction with the rounding/alignment that placement new has inlined\ninto the IL.  This happens for int16_r[] which the test is testing.\nRanger can glean some range info, which causes DOM threading to\nisolate a path which causes a warning.\n\nOK for trunk?\n\ngcc/ChangeLog:\n\n\t* tree-ssa-dom.cc (dom_jt_state): Pass ranger to constructor\n\tinstead of evrp.\n\t(dom_jt_state::push): Remove m_evrp.\n\t(dom_jt_state::pop): Same.\n\t(dom_jt_state::record_ranges_from_stmt): Remove.\n\t(dom_jt_state::register_equiv): Remove updating of evrp ranges.\n\t(class dom_jt_simplifier): Pass ranger to constructor.\n\tInherit from hybrid_jt_simplifier.\n\t(dom_jt_simplifier::simplify): Convert to ranger.\n\t(pass_dominator::execute): Same.\n\t(all_uses_feed_or_dominated_by_stmt): New.\n\t(dom_opt_dom_walker::set_global_ranges_from_unreachable_edges): New.\n\t(dom_opt_dom_walker::before_dom_children): Call\n\tset_global_ranges_from_unreachable_edges.\n\tDo not call record_ranges_from_stmt.\n\t(dom_opt_dom_walker::after_dom_children): Remove evrp use.\n\t(cprop_operand): Use int_range<> instead of value_range.\n\t(dom_opt_dom_walker::fold_cond): New.\n\t(dom_opt_dom_walker::optimize_stmt): Pass ranger to\n\tcprop_into_stmt.\n\tUse fold_cond() instead of vrp_visit_cond_stmt().\n\t* tree-ssa-threadedge.cc (jt_state::register_equivs_stmt): Do not\n\tpass state to simplifier.\n\t* vr-values.h (class vr_values): Make fold_cond public.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/sancov/cmp0.c: Adjust for conversion to ranger.\n\t* gcc.dg/tree-ssa/ssa-dom-branch-1.c: Same.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Same.\n\t* gcc.dg/vect/bb-slp-pr81635-2.c: Same.\n\t* gcc.dg/vect/bb-slp-pr81635-4.c: Same.\n\t* g++.dg/warn/Wstringop-overflow-4.C: Likewise.\n\t* gcc.target/mips/data-sym-multi-pool.c: Likewise.\n\t* gcc.target/mips/mips.exp: Likewise.", "tree": {"sha": "4a4b7b02f25107e40541b75c213c8808035fa4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a4b7b02f25107e40541b75c213c8808035fa4c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c99e307b20c502e55c425897fb3884ba8f05882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c99e307b20c502e55c425897fb3884ba8f05882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c99e307b20c502e55c425897fb3884ba8f05882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c99e307b20c502e55c425897fb3884ba8f05882/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc259b522c0f8b7bbca8e7adcd3da63330094a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc259b522c0f8b7bbca8e7adcd3da63330094a34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc259b522c0f8b7bbca8e7adcd3da63330094a34"}], "stats": {"total": 283, "additions": 170, "deletions": 113}, "files": [{"sha": "eb4801918fc5d998346e44ea5e4e4de2845bc5dc", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-4.C", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -161,6 +161,40 @@ void test_strcpy_new_int16_t (size_t n, const size_t vals[])\n \n   ptrdiff_t r_dmin_dmax = SR (DIFF_MIN, DIFF_MAX);\n   T (S (1), new int16_t[r_dmin_dmax]);\n+  /* ?? The above SR(DIFF_MIN, DIFF_MAX) implies r_dmin_dmax can be\n+     the entire domain, including negative numbers because ptrdiff_t\n+     is a signed entity.\n+\n+     This causes a warning in the following line after the\n+     DOM/threader changes for C++98.\n+\n+      <bb 2> [local count: 1073741824]:\n+      _26 ={v} signed_value_source;                      ;; could be -1\n+      r_dmin_dmax.1_8 = (sizetype) _26;\n+      if (r_dmin_dmax.1_8 <= 4611686018427387900)        ;; placement new rounding\n+        goto <bb 3>; [50.00%]\n+      else\n+        goto <bb 9>; [50.00%]\n+\n+      ...\n+      ...\n+\n+      <bb 9> [local count: 536870912]:\n+      # iftmp.0_39 = PHI <18446744073709551615(2)>\n+      _41 = operator new [] (iftmp.0_39);\n+      __builtin_memcpy (_41, \"z\", 2);\n+      sink (_41);\n+      _44 = _26 + 1;\t\t\t\t\t;; _44 = 0\n+      _45 = (sizetype) _44;\t\t\t\t;; _45 = 0\n+      if (_45 <= 4611686018427387900)\n+        goto <bb 8>; [0.00%]\n+      else\n+        goto <bb 7>; [100.00%]\n+\n+      <bb 8> [local count: 0]:\n+      iftmp.2_33 = _45 * 2;\t\t\t\t;; iftmp.2_33 = 0\n+      _34 = operator new [] (iftmp.2_33);\t\t;; new [] (0)\n+  */\n   T (S (2), new int16_t[r_dmin_dmax + 1]);\n   T (S (9), new int16_t[r_dmin_dmax * 2 + 1]);\n }"}, {"sha": "9fd7f5cccc88f31b42994fcd2a503e3a5b97aade", "filename": "gcc/testsuite/gcc.dg/sancov/cmp0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -1,6 +1,6 @@\n /* Basic test on number of inserted callbacks.  */\n /* { dg-do compile } */\n-/* { dg-options \"-fsanitize-coverage=trace-cmp -fdump-tree-optimized\" } */\n+/* { dg-options \"-fsanitize-coverage=trace-cmp -fdump-tree-optimized -fno-thread-jumps\" } */\n /* { dg-skip-if \"different type layout\" { avr-*-* } } */\n \n #if __SIZEOF_INT__ < 4"}, {"sha": "ede3274f59d17ad061315a390b2659fe9b99ccae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-branch-1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-branch-1.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -19,10 +19,9 @@ try_combine (rtx i1, rtx newpat)\n   else if (i1 && foo ());\n }\n \n-/* There should be four tests against i1.  One from the hash table\n-   dumps, one from the EVRP analyzer one from EVRP evaluation and one\n+/* There should be 3 tests against i1.  Two from DOM machinery and one\n    in the code itself.  */\n-/* { dg-final { scan-tree-dump-times \"if .i1_\" 4 \"dom2\"} } */\n+/* { dg-final { scan-tree-dump-times \"if .i1_\" 3 \"dom2\"} } */\n \n /* There should be no actual jump threads realized by DOM.  The\n    legitimize jump threads are handled in VRP and those discovered"}, {"sha": "aa06db5e22359c59801f234ad40ccff7f5384873", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -11,7 +11,7 @@\n    to change decisions in switch expansion which in turn can expose new\n    jump threading opportunities.  Skip the later tests on aarch64.  */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom3\" { target { ! aarch64*-*-* } } } } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 7\"  \"thread2\" { target { ! aarch64*-*-* } } } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 8\"  \"thread2\" { target { ! aarch64*-*-* } } } } */\n /* { dg-final { scan-tree-dump \"Jumps threaded: 18\"  \"thread2\" { target { aarch64*-*-* } } } } */\n \n enum STATE {"}, {"sha": "56c4bbf86d86363d2b43e81568af0e66a33fff79", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize -fno-tree-dominator-opts\" } */\n /* { dg-require-effective-target lp64 } */\n \n double p[1000];"}, {"sha": "67ee809826c6d37d6421cb7226191de7e551e0fa", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-4.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -1,7 +1,11 @@\n /* { dg-do compile } */\n-/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize -fno-tree-dominator-opts\" } */\n /* { dg-require-effective-target lp64 } */\n \n+/* A ranger based DOM causes many more SSA names to be exported, which\n+   causes slp1 to vectorize more things.  Disabling DOM to avoid\n+   disturbing this test.  */\n+\n void\n f1 (double *p, double *q, unsigned int n)\n {"}, {"sha": "3cf2d4f0248bdb0ad62bd756792083bbb921a125", "filename": "gcc/testsuite/gcc.target/mips/data-sym-multi-pool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdata-sym-multi-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdata-sym-multi-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdata-sym-multi-pool.c?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mips16 -mcode-readable=yes -fno-tree-vrp\" } */\n+/* { dg-options \"-mips16 -mcode-readable=yes -fno-tree-vrp -fno-tree-dominator-opts\" } */\n /* { dg-skip-if \"per-function expected output\" { *-*-* } { \"-flto\" } { \"\" } } */\n \n /* This testcase generates multiple constant pools within a function body.  */"}, {"sha": "42a0dbb620208fb2c7ef9195d9e92fe7ed1f587a", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -335,6 +335,7 @@ foreach option {\n     split-wide-types\n     tree-vectorize\n     tree-vrp\n+    tree-dominator-opts\n     unroll-all-loops\n     unroll-loops\n     ipa-ra"}, {"sha": "208b0a0705009a9f858f573b6dc567d533973e96", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 120, "deletions": 103, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -48,7 +48,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"tree-vrp.h\"\n #include \"vr-values.h\"\n-#include \"gimple-ssa-evrp-analyze.h\"\n+#include \"gimple-range.h\"\n+#include \"gimple-range-path.h\"\n #include \"alias.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n@@ -588,132 +589,64 @@ class dom_jt_state : public jt_state\n {\n public:\n   dom_jt_state (const_and_copies *copies, avail_exprs_stack *avails,\n-\t\tevrp_range_analyzer *evrp)\n-    : m_copies (copies), m_avails (avails), m_evrp (evrp)\n+\t\tgimple_ranger *ranger)\n+    : m_copies (copies), m_avails (avails), m_ranger (ranger)\n   {\n   }\n   void push (edge e) override\n   {\n     m_copies->push_marker ();\n     m_avails->push_marker ();\n-    m_evrp->push_marker ();\n     jt_state::push (e);\n   }\n   void pop () override\n   {\n     m_copies->pop_to_marker ();\n     m_avails->pop_to_marker ();\n-    m_evrp->pop_to_marker ();\n     jt_state::pop ();\n   }\n   void register_equivs_edge (edge e) override\n   {\n     record_temporary_equivalences (e, m_copies, m_avails);\n   }\n-  void record_ranges_from_stmt (gimple *stmt, bool temporary) override\n-  {\n-    m_evrp->record_ranges_from_stmt (stmt, temporary);\n-  }\n   void register_equiv (tree dest, tree src, bool update) override;\n private:\n   const_and_copies *m_copies;\n   avail_exprs_stack *m_avails;\n-  evrp_range_analyzer *m_evrp;\n+  gimple_ranger *m_ranger;\n };\n \n void\n-dom_jt_state::register_equiv (tree dest, tree src, bool update)\n+dom_jt_state::register_equiv (tree dest, tree src, bool)\n {\n   m_copies->record_const_or_copy (dest, src);\n-\n-  /* If requested, update the value range associated with DST, using\n-     the range from SRC.  */\n-  if (update)\n-    {\n-      /* Get new VR we can pass to push_value_range.  */\n-      value_range_equiv *new_vr = m_evrp->allocate_value_range_equiv ();\n-      new (new_vr) value_range_equiv ();\n-\n-      /* There are three cases to consider:\n-\n-\t First if SRC is an SSA_NAME, then we can copy the value range\n-\t from SRC into NEW_VR.\n-\n-\t Second if SRC is an INTEGER_CST, then we can just set NEW_VR\n-\t to a singleton range.  Note that even if SRC is a constant we\n-\t need to set a suitable output range so that VR_UNDEFINED\n-\t ranges do not leak through.\n-\n-\t Otherwise set NEW_VR to varying.  This may be overly\n-\t conservative.  */\n-      if (TREE_CODE (src) == SSA_NAME)\n-\tnew_vr->deep_copy (m_evrp->get_value_range (src));\n-      else if (TREE_CODE (src) == INTEGER_CST)\n-\tnew_vr->set (src);\n-      else\n-\tnew_vr->set_varying (TREE_TYPE (src));\n-\n-      /* This is a temporary range for DST, so push it.  */\n-      m_evrp->push_value_range (dest, new_vr);\n-    }\n }\n \n-class dom_jt_simplifier : public jt_simplifier\n+class dom_jt_simplifier : public hybrid_jt_simplifier\n {\n public:\n-  dom_jt_simplifier (vr_values *v, avail_exprs_stack *avails)\n-    : m_vr_values (v), m_avails (avails) { }\n+  dom_jt_simplifier (avail_exprs_stack *avails, gimple_ranger *ranger,\n+\t\t     path_range_query *query)\n+    : hybrid_jt_simplifier (ranger, query), m_avails (avails) { }\n \n private:\n   tree simplify (gimple *, gimple *, basic_block, jt_state *) override;\n-  vr_values *m_vr_values;\n   avail_exprs_stack *m_avails;\n };\n \n tree\n dom_jt_simplifier::simplify (gimple *stmt, gimple *within_stmt,\n-\t\t\t     basic_block, jt_state *)\n+\t\t\t     basic_block bb, jt_state *state)\n {\n   /* First see if the conditional is in the hash table.  */\n   tree cached_lhs =  m_avails->lookup_avail_expr (stmt, false, true);\n   if (cached_lhs)\n     return cached_lhs;\n \n-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n-    {\n-      simplify_using_ranges simplifier (m_vr_values);\n-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_lhs (cond_stmt),\n-\t\t\t\t\t\t  gimple_cond_rhs (cond_stmt),\n-\t\t\t\t\t\t  within_stmt);\n-    }\n-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))\n-    {\n-      tree op = gimple_switch_index (switch_stmt);\n-      if (TREE_CODE (op) != SSA_NAME)\n-\treturn NULL_TREE;\n+  /* Otherwise call the ranger if possible.  */\n+  if (state)\n+    return hybrid_jt_simplifier::simplify (stmt, within_stmt, bb, state);\n \n-      const value_range *vr = m_vr_values->get_value_range (op);\n-      return find_case_label_range (switch_stmt, vr);\n-    }\n-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign_stmt);\n-      if (TREE_CODE (lhs) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t      || POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t  && stmt_interesting_for_vrp (stmt))\n-\t{\n-\t  edge dummy_e;\n-\t  tree dummy_tree;\n-\t  value_range_equiv new_vr;\n-\t  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,\n-\t\t\t\t\t\t&new_vr);\n-\t  tree singleton;\n-\t  if (new_vr.singleton_p (&singleton))\n-\t    return singleton;\n-\t}\n-    }\n   return NULL;\n }\n \n@@ -723,12 +656,12 @@ class dom_opt_dom_walker : public dom_walker\n   dom_opt_dom_walker (cdi_direction direction,\n \t\t      jump_threader *threader,\n \t\t      jt_state *state,\n-\t\t      evrp_range_analyzer *analyzer,\n+\t\t      gimple_ranger *ranger,\n \t\t      const_and_copies *const_and_copies,\n \t\t      avail_exprs_stack *avail_exprs_stack)\n     : dom_walker (direction, REACHABLE_BLOCKS)\n     {\n-      m_evrp_range_analyzer = analyzer;\n+      m_ranger = ranger;\n       m_state = state;\n       m_dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,\n \t\t\t\t\tinteger_zero_node, NULL, NULL);\n@@ -755,11 +688,13 @@ class dom_opt_dom_walker : public dom_walker\n      value.  */\n   edge optimize_stmt (basic_block, gimple_stmt_iterator *, bool *);\n \n+  void set_global_ranges_from_unreachable_edges (basic_block);\n \n   void test_for_singularity (gimple *, avail_exprs_stack *);\n+  edge fold_cond (gcond *cond);\n \n   jump_threader *m_threader;\n-  evrp_range_analyzer *m_evrp_range_analyzer;\n+  gimple_ranger *m_ranger;\n   jt_state *m_state;\n };\n \n@@ -856,18 +791,22 @@ pass_dominator::execute (function *fun)\n     record_edge_info (bb);\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n-  evrp_range_analyzer analyzer (true);\n-  dom_jt_simplifier simplifier (&analyzer, avail_exprs_stack);\n-  dom_jt_state state (const_and_copies, avail_exprs_stack, &analyzer);\n+  gimple_ranger *ranger = enable_ranger (fun);\n+  path_range_query path_query (/*resolve=*/true, ranger);\n+  dom_jt_simplifier simplifier (avail_exprs_stack, ranger, &path_query);\n+  dom_jt_state state (const_and_copies, avail_exprs_stack, ranger);\n   jump_threader threader (&simplifier, &state);\n   dom_opt_dom_walker walker (CDI_DOMINATORS,\n \t\t\t     &threader,\n \t\t\t     &state,\n-\t\t\t     &analyzer,\n+\t\t\t     ranger,\n \t\t\t     const_and_copies,\n \t\t\t     avail_exprs_stack);\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n+  ranger->export_global_ranges ();\n+  disable_ranger (fun);\n+\n   /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing\n      edge.  When found, remove jump threads which contain any outgoing\n      edge from the affected block.  */\n@@ -1252,6 +1191,77 @@ record_equivalences_from_phis (basic_block bb)\n     }\n }\n \n+/* Return true if all uses of NAME are dominated by STMT or feed STMT\n+   via a chain of single immediate uses.  */\n+\n+static bool\n+all_uses_feed_or_dominated_by_stmt (tree name, gimple *stmt)\n+{\n+  use_operand_p use_p, use2_p;\n+  imm_use_iterator iter;\n+  basic_block stmt_bb = gimple_bb (stmt);\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n+    {\n+      gimple *use_stmt = USE_STMT (use_p), *use_stmt2;\n+      if (use_stmt == stmt\n+\t  || is_gimple_debug (use_stmt)\n+\t  || (gimple_bb (use_stmt) != stmt_bb\n+\t      && dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t gimple_bb (use_stmt), stmt_bb)))\n+\tcontinue;\n+      while (use_stmt != stmt\n+\t     && is_gimple_assign (use_stmt)\n+\t     && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n+\t     && single_imm_use (gimple_assign_lhs (use_stmt),\n+\t\t\t\t&use2_p, &use_stmt2))\n+\tuse_stmt = use_stmt2;\n+      if (use_stmt != stmt)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Set global ranges that can be determined from the C->M edge:\n+\n+   <bb C>:\n+   ...\n+   if (something)\n+     goto <bb N>;\n+   else\n+     goto <bb M>;\n+   <bb N>:\n+   __builtin_unreachable ();\n+   <bb M>:\n+*/\n+\n+void\n+dom_opt_dom_walker::set_global_ranges_from_unreachable_edges (basic_block bb)\n+{\n+  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n+\n+  if (!pred_e)\n+    return;\n+\n+  gimple *stmt = last_stmt (pred_e->src);\n+  tree name;\n+  int_range_max r;\n+  if (stmt\n+      && gimple_code (stmt) == GIMPLE_COND\n+      && (name = gimple_cond_lhs (stmt))\n+      && TREE_CODE (name) == SSA_NAME\n+      && r.supports_type_p (TREE_TYPE (name))\n+      && assert_unreachable_fallthru_edge_p (pred_e)\n+      && all_uses_feed_or_dominated_by_stmt (name, stmt)\n+      && m_ranger->range_on_edge (r, pred_e, name)\n+      && !r.varying_p ()\n+      && !r.undefined_p ())\n+    {\n+      update_global_range (r, name);\n+      maybe_set_nonzero_bits (pred_e, name);\n+    }\n+}\n+\n /* Record any equivalences created by the incoming edge to BB into\n    CONST_AND_COPIES and AVAIL_EXPRS_STACK.  If BB has more than one\n    incoming edge, then no equivalence is created.  */\n@@ -1505,15 +1515,14 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n \n-  m_evrp_range_analyzer->enter (bb);\n-\n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n   m_avail_exprs_stack->push_marker ();\n   m_const_and_copies->push_marker ();\n \n   record_equivalences_from_incoming_edge (bb, m_const_and_copies,\n \t\t\t\t\t  m_avail_exprs_stack);\n+  set_global_ranges_from_unreachable_edges (bb);\n \n   /* PHI nodes can create equivalences too.  */\n   record_equivalences_from_phis (bb);\n@@ -1542,7 +1551,6 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \t  continue;\n \t}\n \n-      m_state->record_ranges_from_stmt (gsi_stmt (gsi), false);\n       bool removed_p = false;\n       taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);\n       if (!removed_p)\n@@ -1590,7 +1598,6 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n   m_threader->thread_outgoing_edges (bb);\n   m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n-  m_evrp_range_analyzer->leave (bb);\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n@@ -1832,7 +1839,7 @@ cprop_operand (gimple *stmt, use_operand_p op_p, range_query *query)\n   val = SSA_NAME_VALUE (op);\n   if (!val)\n     {\n-      value_range r;\n+      int_range<2> r;\n       tree single;\n       if (query->range_of_expr (r, op, stmt) && r.singleton_p (&single))\n \tval = single;\n@@ -2073,6 +2080,24 @@ reduce_vector_comparison_to_scalar_comparison (gimple *stmt)\n     }\n }\n \n+/* If possible, rewrite the conditional as TRUE or FALSE, and return\n+   the taken edge.  Otherwise, return NULL.  */\n+\n+edge\n+dom_opt_dom_walker::fold_cond (gcond *cond)\n+{\n+  simplify_using_ranges simplify (m_ranger);\n+  if (simplify.fold_cond (cond))\n+    {\n+      basic_block bb = gimple_bb (cond);\n+      if (gimple_cond_true_p (cond))\n+\treturn find_taken_edge (bb, boolean_true_node);\n+      if (gimple_cond_false_p (cond))\n+\treturn find_taken_edge (bb, boolean_false_node);\n+    }\n+  return NULL;\n+}\n+\n /* Optimize the statement in block BB pointed to by iterator SI.\n \n    We try to perform some simplistic global redundancy elimination and\n@@ -2121,7 +2146,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n   opt_stats.num_stmts++;\n \n   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */\n-  cprop_into_stmt (stmt, m_evrp_range_analyzer);\n+  cprop_into_stmt (stmt, m_ranger);\n \n   /* If the statement has been modified with constant replacements,\n      fold its RHS before checking for redundant computations.  */\n@@ -2218,17 +2243,9 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,\n \t\t IL because we've attached range information to new\n \t\t SSA_NAMES.  */\n \t      update_stmt_if_modified (stmt);\n-\t      edge taken_edge = NULL;\n-\t      simplify_using_ranges simpl (m_evrp_range_analyzer);\n-\t      simpl.vrp_visit_cond_stmt (as_a <gcond *> (stmt), &taken_edge);\n+\t      edge taken_edge = fold_cond (as_a <gcond *> (stmt));\n \t      if (taken_edge)\n \t\t{\n-\t\t  if (taken_edge->flags & EDGE_TRUE_VALUE)\n-\t\t    gimple_cond_make_true (as_a <gcond *> (stmt));\n-\t\t  else if (taken_edge->flags & EDGE_FALSE_VALUE)\n-\t\t    gimple_cond_make_false (as_a <gcond *> (stmt));\n-\t\t  else\n-\t\t    gcc_unreachable ();\n \t\t  gimple_set_modified (stmt, true);\n \t\t  update_stmt (stmt);\n \t\t  cfg_altered = true;"}, {"sha": "e64e4f209f76985bf0efe86f700824174f08299c", "filename": "gcc/tree-ssa-threadedge.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftree-ssa-threadedge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Ftree-ssa-threadedge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.cc?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -1377,7 +1377,9 @@ jt_state::register_equivs_stmt (gimple *stmt, basic_block bb,\n \t\tSET_USE (use_p, tmp);\n \t    }\n \n-\t  cached_lhs = simplifier->simplify (stmt, stmt, bb, this);\n+\t  /* Do not pass state to avoid calling the ranger with the\n+\t     temporarily altered IL.  */\n+\t  cached_lhs = simplifier->simplify (stmt, stmt, bb, /*state=*/NULL);\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  i = 0;"}, {"sha": "8c8f0317147920ac731fa76cedee04dc795fee73", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c99e307b20c502e55c425897fb3884ba8f05882/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=8c99e307b20c502e55c425897fb3884ba8f05882", "patch": "@@ -41,6 +41,7 @@ class simplify_using_ranges\n   // ?? These should be cleaned, merged, and made private.\n   tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n   void vrp_visit_cond_stmt (gcond *, edge *);\n+  bool fold_cond (gcond *);\n   tree vrp_evaluate_conditional_warnv_with_ops (gimple *stmt, enum tree_code,\n \t\t\t\t\t\ttree, tree, bool,\n \t\t\t\t\t\tbool *, bool *);\n@@ -53,7 +54,6 @@ class simplify_using_ranges\n   bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_cond_using_ranges_1 (gcond *);\n-  bool fold_cond (gcond *);\n   bool simplify_switch_using_ranges (gswitch *);\n   bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n \t\t\t\t\t       gimple *);"}]}