{"sha": "2bfcf297772c19dea98fac91400e458f6a1e449e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmY2YyOTc3NzJjMTlkZWE5OGZhYzkxNDAwZTQ1OGY2YTFlNDQ5ZQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2001-07-31T17:20:20Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2001-07-31T17:20:20Z"}, "message": "PowerPC reorg and support for powerpc64-*-linux*.\n\n2001-07-31  Daniel Berlin  <dan@cgsoftware.com>\n\n\tPowerPC reorg and support for powerpc64-*-linux*.\n\n\tAlso fixes emitting of constants on 32 bit and 64 bit\n\tplatforms.\n\n\t* config.gcc: powerpc64-*-linux* is a new target.\n\tThings that needed aix.h now also include xcoff.h\n\n\t* config/rs6000/rs6000.h: Split XCOFF specific stuff into\n\txcoff.h.\n\tMove AIX specific stuff into aix.h.\n\t(ASM_LONG): Use DOUBLE_INT_ASM_OP if we are on a 64 bit target.\n\t(ASM_OUTPUT_DOUBLE_INT): Ditto.\n\t(TARGET_AIX): Renamed to TARGET_XCOFF, since the AIX ABI is used\n\twith more than just XCOFF now.\n\t(SET_ASM_OP): Remove, now defined where needed.\n\t(FUNCTION_PROLOGUE): New macro definition.\n\t(FUNCTION_EPILOGUE): New macro definition.\n\t(CONST_OK_FOR_LETTER_P): Change N to require that value is\n\tpositive, too.\n\t(ASM_OPEN_PAREN, ASM_CLOSE_PAREN): New macro definition.\n\t(PREDICATE_CODES): Added exact_log2_cint_operand,\n\treg_or_add_cint64_operand, reg_or_sub_cint64_operand.\n\n\t* config/rs6000/rs6000.c: #ifdef XCOFF debugging info stuff on\n\tXCOFF_DEBUGGING_INFO.\n\tUse DOUBLE_INT_ASM_OP where approriate.\n\t(rs6000_emit_set_long_const): New function.\n\t(rs6000_emit_set_const): New function.\n\t(reg_or_sub_cint64_operand): New function.\n\t(reg_or_add_cint64_operand): New function.\n\t(exact_log2_cint_operand): New function.\n\n\t* config/rs6000/rs6000.md: Fix emitting of constants.\n\tFix patterns that were AIX ABI specific, but depended on\n\t!TARGET_ELF (instead of DEFAULT_ABI == ABI_AIX).\n\n\t* config/rs6000/xcoff.h: New file.\n\n\t* config/rs6000/linux64.h: New file.\n\n\t* config/rs6000/darwin.h: Copy needed AIX alignment definitions.\n\nFrom-SVN: r44516", "tree": {"sha": "189b8e1fd44b8f4e0a7998e44b31d6dc222a856b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/189b8e1fd44b8f4e0a7998e44b31d6dc222a856b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bfcf297772c19dea98fac91400e458f6a1e449e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bfcf297772c19dea98fac91400e458f6a1e449e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bfcf297772c19dea98fac91400e458f6a1e449e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bfcf297772c19dea98fac91400e458f6a1e449e/comments", "author": null, "committer": null, "parents": [{"sha": "befe7c61462d147b408df88fe8a6f8e14e3ad877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befe7c61462d147b408df88fe8a6f8e14e3ad877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befe7c61462d147b408df88fe8a6f8e14e3ad877"}], "stats": {"total": 2307, "additions": 1434, "deletions": 873}, "files": [{"sha": "1c009f3bd39b4d974307dc67b6e556449e4bad01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -1,3 +1,49 @@\n+2001-07-31  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\tPowerPC reorg and support for powerpc64-*-linux*.\n+\n+\tAlso fixes emitting of constants on 32 bit and 64 bit\n+\tplatforms.\n+\t\n+\t* config.gcc: powerpc64-*-linux* is a new target.\n+\tThings that needed aix.h now also include xcoff.h\t\n+\n+\t* config/rs6000/rs6000.h: Split XCOFF specific stuff into\n+\txcoff.h. \n+\tMove AIX specific stuff into aix.h.\n+\t(ASM_LONG): Use DOUBLE_INT_ASM_OP if we are on a 64 bit target.\n+\t(ASM_OUTPUT_DOUBLE_INT): Ditto.\n+\t(TARGET_AIX): Renamed to TARGET_XCOFF, since the AIX ABI is used\n+\twith more than just XCOFF now.\n+\t(SET_ASM_OP): Remove, now defined where needed.\n+\t(FUNCTION_PROLOGUE): New macro definition.\n+\t(FUNCTION_EPILOGUE): New macro definition.\n+\t(CONST_OK_FOR_LETTER_P): Change N to require that value is\n+\tpositive, too.\n+\t(ASM_OPEN_PAREN, ASM_CLOSE_PAREN): New macro definition.\n+\t(PREDICATE_CODES): Added exact_log2_cint_operand,\n+\treg_or_add_cint64_operand, reg_or_sub_cint64_operand.\n+\n+\t* config/rs6000/rs6000.c: #ifdef XCOFF debugging info stuff on\n+\tXCOFF_DEBUGGING_INFO.\n+\tUse DOUBLE_INT_ASM_OP where approriate.\n+\t(rs6000_emit_set_long_const): New function.\n+\t(rs6000_emit_set_const): New function.\n+\t(reg_or_sub_cint64_operand): New function.\n+\t(reg_or_add_cint64_operand): New function.\n+\t(exact_log2_cint_operand): New function.\n+\n+\t* config/rs6000/rs6000.md: Fix emitting of constants.\n+\tFix patterns that were AIX ABI specific, but depended on\n+\t!TARGET_ELF (instead of DEFAULT_ABI == ABI_AIX).\t\n+\t\n+\t* config/rs6000/xcoff.h: New file.\n+\n+\t* config/rs6000/linux64.h: New file.\n+\n+\t* config/rs6000/darwin.h: Copy needed AIX alignment definitions.\n+\t\n+\n 2001-07-31  Graham Stott <grahams@redhat.com>\n \n \t* function.c (pad_below): Revert 2001-07-26 patch."}, {"sha": "6380bab81a800a513ce874c00912e9d804e4f189", "filename": "gcc/config.gcc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -2559,9 +2559,16 @@ romp-*-openbsd*)\n powerpc-*-openbsd*)\n \ttmake_file=\"${tmake_file} rs6000/t-rs6000 rs6000/t-openbsd\"\n \t;;\n+powerpc64-*-linux*)\n+\ttm_file=\"${tm_file} svr4.h rs6000/sysv4.h rs6000/linux64.h\"\n+\tout_file=rs6000/rs6000.c\n+\ttmake_file=\"rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm\"\n+\txmake_file=x-linux\n+\textra_headers=ppc-asm.h\n+\t;;\n powerpc-*-beos*)\n \tcpu_type=rs6000\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/beos.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/beos.h rs6000/xcoff.h\"\n \txm_defines=POSIX\n \txm_file=rs6000/xm-beos.h\n \ttmake_file=rs6000/t-beos\n@@ -2700,49 +2707,49 @@ powerpcle-*-solaris2*)\n \t;;\n rs6000-ibm-aix3.[01]*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix31.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix31.h rs6000/xcoff.h\"\n \tfloat_format=none\n \tuse_collect2=yes\n \t;;\n rs6000-ibm-aix3.2.[456789]* | powerpc-ibm-aix3.2.[456789]*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix3newas.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix3newas.h rs6000/xcoff.h\"\n \ttmake_file=rs6000/t-newas\n \tfloat_format=none\n \tuse_collect2=yes\n \t;;\n rs6000-ibm-aix4.[12]* | powerpc-ibm-aix4.[12]*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix41.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix41.h rs6000/xcoff.h\"\n \ttmake_file=rs6000/t-newas\n \tfloat_format=none\n \tuse_collect2=yes\n \t;;\n rs6000-ibm-aix4.[3456789]* | powerpc-ibm-aix4.[3456789]*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix43.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix43.h rs6000/xcoff.h\"\n \ttmake_file=rs6000/t-aix43\n \tfloat_format=none\n \tuse_collect2=yes\n \tthread_file='aix'\n \t;;\n rs6000-ibm-aix[56789].* | powerpc-ibm-aix[56789].*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix51.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix51.h rs6000/xcoff.h\"\n \ttmake_file=rs6000/t-aix43\n \tfloat_format=none\n \tuse_collect2=yes\n \tthread_file='aix'\n \t;;\n rs6000-ibm-aix*)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/xcoff.h\"\n \tfloat_format=none\n \tuse_collect2=yes\n \t;;\n rs6000-bull-bosx)\n \txm_defines=POSIX\n-\ttm_file=\"${tm_file} rs6000/aix.h\"\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/xcoff.h\"\n \tfloat_format=none\n \tuse_collect2=yes\n \t;;"}, {"sha": "e478e86b2a57da1469bededbd39372d9d07dc8f2", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 98, "deletions": 454, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -21,58 +21,20 @@ Boston, MA 02111-1307, USA.  */\n \n /* Yes!  We are AIX!  */\n #define DEFAULT_ABI ABI_AIX\n-#define TARGET_OBJECT_FORMAT OBJECT_XCOFF\n-\n+#undef TARGET_AIX\n+#define TARGET_AIX 1\n /* The AIX linker will discard static constructors in object files before\n    collect has a chance to see them, so scan the object files directly.  */\n #define COLLECT_EXPORT_LIST\n \n-/* The RS/6000 uses the XCOFF format.  */\n-#define XCOFF_DEBUGGING_INFO\n-\n-/* Define if the object format being used is COFF or a superset.  */\n-#define OBJECT_FORMAT_COFF\n-\n-/* Define the magic numbers that we recognize as COFF.\n- \n-    AIX 4.3 adds U803XTOCMAGIC (0757) for 64-bit objects and AIX V5 adds\n-    U64_TOCMAGIC (0767), but collect2.c does not include files in the\n-    correct order to conditionally define the symbolic name in this macro.\n- \n-    The AIX linker accepts import/export files as object files,\n-    so accept \"#!\" (0x2321) magic number.  */\n-#define MY_ISCOFF(magic) \\\n-  ((magic) == U802WRMAGIC || (magic) == U802ROMAGIC \\\n-   || (magic) == U802TOCMAGIC || (magic) == 0757 || (magic) == 0767 \\\n-   || (magic) == 0x2321)\n-\n /* This is the only version of nm that collect2 can work with.  */\n #define REAL_NM_FILE_NAME \"/usr/ucb/nm\"\n \n-/* We don't have GAS for the RS/6000 yet, so don't write out special\n-    .stabs in cc1plus.  */\n-\n-#define FASCIST_ASSEMBLER\n-\n-/* We define this to prevent the name mangler from putting dollar signs into\n-   function names.  */\n-\n-#define NO_DOLLAR_IN_LABEL\n-\n-/* We define this to 0 so that gcc will never accept a dollar sign in a\n-   variable name.  This is needed because the AIX assembler will not accept\n-   dollar signs.  */\n-\n-#define DOLLARS_IN_IDENTIFIERS 0\n-\n /* AIX does not have any init/fini or ctor/dtor sections, so create\n     static constructors and destructors as normal functions.  */\n /* #define ASM_OUTPUT_CONSTRUCTOR(file, name) */\n /* #define ASM_OUTPUT_DESTRUCTOR(file, name) */\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-#define USER_LABEL_PREFIX \"\"\n-\n+#define USER_LABEL_PREFIX  \"\"\n /* Don't turn -B into -L if the argument specifies a relative file name.  */\n #define RELATIVE_PREFIX_NOT_LINKDIR\n \n@@ -90,6 +52,82 @@ Boston, MA 02111-1307, USA.  */\n    %{ansi: -D_ANSI_C_SOURCE}\\\n    %(cpp_cpu)\"\n \n+/* Common CPP definitions used by CPP_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#define CPP_CPU_SPEC \\\n+\"%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{mno-power: %{!mpowerpc*: -D_ARCH_COM}} \\\n+  %{!mno-power: %{!mpower2: %(cpp_default)}}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=power2: -D_ARCH_PWR2} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=401: -D_ARCH_PPC} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=505: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=ec603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=604e: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC} \\\n+%{mcpu=740: -D_ARCH_PPC} \\\n+%{mcpu=750: -D_ARCH_PPC} \\\n+%{mcpu=801: -D_ARCH_PPC} \\\n+%{mcpu=821: -D_ARCH_PPC} \\\n+%{mcpu=823: -D_ARCH_PPC} \\\n+%{mcpu=860: -D_ARCH_PPC}\"\n+\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_PWR\"\n+\n+/* Common ASM definitions used by ASM_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#define ASM_CPU_SPEC \\\n+\"%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -mpwr}} \\\n+  %{mpower2: -mpwrx} \\\n+  %{mpowerpc*: -mppc} \\\n+  %{mno-power: %{!mpowerpc*: -mcom}} \\\n+  %{!mno-power: %{!mpower2: %(asm_default)}}} \\\n+%{mcpu=common: -mcom} \\\n+%{mcpu=power: -mpwr} \\\n+%{mcpu=power2: -mpwrx} \\\n+%{mcpu=powerpc: -mppc} \\\n+%{mcpu=rios: -mpwr} \\\n+%{mcpu=rios1: -mpwr} \\\n+%{mcpu=rios2: -mpwrx} \\\n+%{mcpu=rsc: -mpwr} \\\n+%{mcpu=rsc1: -mpwr} \\\n+%{mcpu=401: -mppc} \\\n+%{mcpu=403: -mppc} \\\n+%{mcpu=505: -mppc} \\\n+%{mcpu=601: -m601} \\\n+%{mcpu=602: -mppc} \\\n+%{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n+%{mcpu=ec603e: -mppc} \\\n+%{mcpu=604: -mppc} \\\n+%{mcpu=604e: -mppc} \\\n+%{mcpu=620: -mppc} \\\n+%{mcpu=740: -mppc} \\\n+%{mcpu=750: -mppc} \\\n+%{mcpu=801: -mppc} \\\n+%{mcpu=821: -mppc} \\\n+%{mcpu=823: -mppc} \\\n+%{mcpu=860: -mppc}\"\n+\n+#define ASM_DEFAULT_SPEC \"\"\n+\n /* Tell the assembler to assume that all undefined names are external.\n \n    Don't do this until the fixed IBM assembler is more generally available.\n@@ -136,161 +174,25 @@ Boston, MA 02111-1307, USA.  */\n #define LIB_SPEC \"%{pg:-L/lib/profiled -L/usr/lib/profiled}\\\n %{p:-L/lib/profiled -L/usr/lib/profiled} %{!shared:%{g*:-lg}} -lc\"\n \n-/* Define the extra sections we need.  We define three: one is the read-only\n-   data section which is used for constants.  This is a csect whose name is\n-   derived from the name of the input file.  The second is for initialized\n-   global variables.  This is a csect whose name is that of the variable.\n-   The third is the TOC.  */\n-\n-#define EXTRA_SECTIONS \\\n-   read_only_data, private_data, read_only_private_data, toc, bss\n-\n-/* Define the routines to implement these extra sections.\n-   BIGGEST_ALIGNMENT is 64, so align the sections that much.  */\n-\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\\\n-read_only_data_section ()\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (in_section != read_only_data)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n-\t       xcoff_read_only_section_name);\t\t\\\n-      in_section = read_only_data;\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\\\n-private_data_section ()\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (in_section != private_data)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t.csect %s[RW],3\\n\",\t\\\n-\t       xcoff_private_data_section_name);\t\\\n-      in_section = private_data;\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\\\n-read_only_private_data_section ()\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (in_section != read_only_private_data)\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n-\t       xcoff_private_data_section_name);\t\\\n-      in_section = read_only_private_data;\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\\\n-toc_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (TARGET_MINIMAL_TOC)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      /* toc_section is always called at least once from ASM_FILE_START, \\\n-\t so this is guaranteed to always be defined once and only once   \\\n-\t in each file.  */\t\t\t\t\t\t \\\n-      if (! toc_initialized)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  fputs (\"\\t.toc\\nLCTOC..1:\\n\", asm_out_file);\t\\\n-\t  fputs (\"\\t.tc toc_table[TC],toc_table[RW]\\n\", asm_out_file); \\\n-\t  toc_initialized = 1;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      if (in_section != toc)\t\t\t\t\\\n-\tfprintf (asm_out_file, \"\\t.csect toc_table[RW]%s\\n\",\t\\\n-\t\t (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (in_section != toc)\t\t\t\t\\\n-        fputs (\"\\t.toc\\n\", asm_out_file);\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  in_section = toc;\t\t\t\t\t\\\n-}\n-\n-/* Define the name of our readonly data section.  */\n-\n-#define READONLY_DATA_SECTION read_only_data_section\n-\n-/* Select the section for an initialized data object.\n-\n-   On the RS/6000, we have a special section for all variables except those\n-   that are static.  */\n-\n-#define SELECT_SECTION(EXP,RELOC)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if ((TREE_CODE (EXP) == STRING_CST\t\t\t\\\n-       && ! flag_writable_strings)\t\t\t\\\n-      || (TREE_CODE_CLASS (TREE_CODE (EXP)) == 'd'\t\\\n-\t  && TREE_READONLY (EXP) && ! TREE_THIS_VOLATILE (EXP) \\\n-\t  && DECL_INITIAL (EXP)\t\t\t\t\\\n-\t  && (DECL_INITIAL (EXP) == error_mark_node\t\\\n-\t      || TREE_CONSTANT (DECL_INITIAL (EXP)))\t\\\n-\t  && ! (RELOC)))\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n-        read_only_data_section ();\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-        read_only_private_data_section ();\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n-        data_section ();\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-        private_data_section ();\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-/* Return non-zero if this entry is to be written into the constant\n-   pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n-   or a CONST containing one of them.  If -mfp-in-toc (the default),\n-   we also do this for floating-point constants.  We actually can only\n-   do this if the FP formats of the target and host machines are the\n-   same, but we can't check that since not every file that uses\n-   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n-   we can write the entry into the TOC and the entry is not larger\n-   than a TOC entry.  */\n-\n-#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n-  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n-   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n-       || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n-       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n-\t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n-       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n-\t   && (TARGET_POWERPC64\t\t\t\t\t\t\\\n-\t       || TARGET_MINIMAL_TOC\t\t\t\t\t\\\n-\t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n-\t\t   && ! TARGET_NO_FP_IN_TOC)))))\n-\n-/* Select section for constant in constant pool.\n-\n-   On RS/6000, all constants are in the private read-only data area.\n-   However, if this is being placed in the TOC it must be output as a\n-   toc entry.  */\n-\n-#define SELECT_RTX_SECTION(MODE, X)\t\t\t\\\n-{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X, MODE))\t\\\n-    toc_section ();\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    read_only_private_data_section ();\t\t\t\\\n-}\n-\n-/* If we are referencing a function that is static or is known to be\n-   in this file, make the SYMBOL_REF special.  We can use this to indicate\n-   that we can branch to this function without emitting a no-op after the\n-   call.  Do not set this flag if the function is weakly defined. */\n-\n-#define ENCODE_SECTION_INFO(DECL)\t\t\t\\\n-  if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n-      && (TREE_ASM_WRITTEN (DECL) || ! TREE_PUBLIC (DECL)) \\\n-      && ! DECL_WEAK (DECL))\t\t\t\t\\\n-    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+/* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n+  (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n+\t      ? get_inner_array_type (FIELD) \\\n+\t      : TREE_TYPE (FIELD)) == DFmode \\\n+   ? MIN ((COMPUTED), 32) : (COMPUTED))\n+\n+/* AIX increases natural record alignment to doubleword if the first\n+   field is an FP double while the FP fields remain word aligned.  */\n+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)\t\\\n+  ((TREE_CODE (STRUCT) == RECORD_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == UNION_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == QUAL_UNION_TYPE)\t\t\\\n+   && TYPE_FIELDS (STRUCT) != 0\t\t\t\t\\\n+   && DECL_MODE (TYPE_FIELDS (STRUCT)) == DFmode\t\\\n+   ? MAX (MAX ((COMPUTED), (SPECIFIED)), BIGGEST_ALIGNMENT) \\\n+   : MAX ((COMPUTED), (SPECIFIED)))\n+\n+\n \n /* Indicate that jump tables go in the text section.  */\n \n@@ -315,23 +217,9 @@ toc_section ()\t\t\t\t\t\t\\\n   { \"link_syscalls\",            LINK_SYSCALLS_SPEC },\t\t\t\\\n   { \"link_libg\",                LINK_LIBG_SPEC }\n \n-/* FP save and restore routines.  */\n-#define\tSAVE_FP_PREFIX \"._savef\"\n-#define SAVE_FP_SUFFIX \"\"\n-#define\tRESTORE_FP_PREFIX \"._restf\"\n-#define RESTORE_FP_SUFFIX \"\"\n-\n /* Define cutoff for using external functions to save floating point.  */\n #define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)\n \n-/* Function name to call to do profiling.  */\n-#define RS6000_MCOUNT \".__mcount\"\n-\n-/* Function names to call to do floating point truncation.  */\n-\n-#define RS6000_ITRUNC \"__itrunc\"\n-#define RS6000_UITRUNC \"__uitrunc\"\n-\n /* Optabs entries for the int->float routines, using the standard\n    AIX names.  */\n #define INIT_TARGET_OPTABS\t\t\t\t\t\t\\\n@@ -350,250 +238,6 @@ toc_section ()\t\t\t\t\t\t\\\n /* AIX allows r13 to be used.  */\n #define FIXED_R13 0\n \n-/* This outputs NAME to FILE up to the first null or '['.  */\n-\n-#define RS6000_OUTPUT_BASENAME(FILE, NAME)\t\\\n-  {\t\t\t\t\t\t\\\n-    const char *_p;\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-    STRIP_NAME_ENCODING (_p, (NAME));\t\t\\\n-    assemble_name ((FILE), _p);\t\t\t\\\n-  }\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { RS6000_OUTPUT_BASENAME (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\"\\t.globl \", FILE);\t\\\n-       RS6000_OUTPUT_BASENAME (FILE, NAME); putc ('\\n', FILE);} while (0)\n-\n-/* Remove any trailing [DS] or the like from the symbol name.  */\n-\n-#define STRIP_NAME_ENCODING(VAR,NAME)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      const char *_name = (NAME);\t\t\t\\\n-      size_t _len;\t\t\t\t\t\\\n-      if (*_name == '*')\t\t\t\t\\\n-        _name++;\t\t\t\t\t\\\n-      _len = strlen (_name);\t\t\t\t\\\n-      if (_name[_len - 1] != ']')\t\t\t\\\n-\t(VAR) = _name;\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  char *_new_name = (char *) alloca (_len + 1);\t\\\n-\t  strcpy (_new_name, _name);\t\t\t\\\n-\t  _new_name[_len - 4] = '\\0';\t\t\t\\\n-\t  (VAR) = _new_name;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output at beginning of assembler file.\n-\n-   Initialize the section names for the RS/6000 at this point.\n-\n-   Specify filename, including full path, to assembler.\n-\n-   We want to go into the TOC section so at least one .toc will be emitted.\n-   Also, in order to output proper .bs/.es pairs, we need at least one static\n-   [RW] section emitted.\n-\n-   Finally, declare mcount when profiling to make the assembler happy.  */\n-\n-#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  rs6000_gen_section_name (&xcoff_bss_section_name,\t\t\\\n-\t\t\t   main_input_filename, \".bss_\");\t\\\n-  rs6000_gen_section_name (&xcoff_private_data_section_name,\t\\\n-\t\t\t   main_input_filename, \".rw_\");\t\\\n-  rs6000_gen_section_name (&xcoff_read_only_section_name,\t\\\n-\t\t\t   main_input_filename, \".ro_\");\t\\\n-\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.file\\t\\\"%s\\\"\\n\", main_input_filename);\t\\\n-  if (TARGET_64BIT)\t\t\t\t\t\t\\\n-    fputs (\"\\t.machine\\t\\\"ppc64\\\"\\n\", FILE);\t\t\t\\\n-  toc_section ();\t\t\t\t\t\t\\\n-  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n-    private_data_section ();\t\t\t\t\t\\\n-  text_section ();\t\t\t\t\t\t\\\n-  if (profile_flag)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.extern %s\\n\", RS6000_MCOUNT);\t\t\\\n-  rs6000_file_start (FILE, TARGET_CPU_DEFAULT);\t\t\t\\\n-}\n-\n-/* Output at end of assembler file.\n-\n-   On the RS/6000, referencing data should automatically pull in text.  */\n-\n-#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  text_section ();\t\t\t\t\t\t\\\n-  fputs (\"_section_.text:\\n\", FILE);\t\t\t\t\\\n-  data_section ();\t\t\t\t\t\t\\\n-  fputs (TARGET_32BIT\t\t\t\t\t\t\\\n-\t ? \"\\t.long _section_.text\\n\" : \"\\t.llong _section_.text\\n\", FILE); \\\n-}\n-\n-/* This macro produces the initial definition of a function name.\n-   On the RS/6000, we need to place an extra '.' in the function name and\n-   output the function descriptor.\n-\n-   The csect for the function will have already been created by the\n-   `text_section' call previously done.  We do have to go back to that\n-   csect, however.\n-\n-   The third and fourth parameters to the .function pseudo-op (16 and 044)\n-   are placeholders which no longer have any use.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n-{ if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\t.globl .\", FILE);\t\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      putc ('\\n', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\t.lglobl .\", FILE);\t\t\t\t\\\n-      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n-      putc ('\\n', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.csect \", FILE);\t\t\t\t\t\\\n-  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fputs (TARGET_32BIT ? \"[DS]\\n\" : \"[DS],3\\n\", FILE);\t\t\\\n-  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n-  fputs (TARGET_32BIT ? \"\\t.long .\" : \"\\t.llong .\", FILE);\t\\\n-  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fputs (\", TOC[tc0], 0\\n\", FILE);\t\t\t\t\\\n-  in_section = no_section;\t\t\t\t\t\\\n-  function_section(DECL);\t\t\t\t\t\\\n-  putc ('.', FILE);\t\t\t\t\t\t\\\n-  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n-  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n-  if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n-    xcoffout_declare_function (FILE, DECL, NAME);\t\t\\\n-}\n-\n-/* Output a reference to SYM on FILE.  */\n-\n-#define ASM_OUTPUT_SYMBOL_REF(FILE, SYM) \\\n-  rs6000_output_symbol_ref (FILE, SYM)\n-\n-/* This says how to output an external.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n-{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n-  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n-       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n-      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n-    {\t\t\t\t\t\t\\\n-      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n-      strcpy (_name, XSTR (_symref, 0));\t\\\n-      strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n-      XSTR (_symref, 0) = _name;\t\t\\\n-    }\t\t\t\t\t\t\\\n-}\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s..%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to output an internal label prefix.  rs6000.c uses this\n-   when generating traceback tables.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)   \\\n-  fprintf (FILE, \"%s..\", PREFIX)\n-\n-/* This is how to output a label for a jump table.  Arguments are the same as\n-   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n-   passed. */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n-{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s..%ld\", (PREFIX), (long)(NUM))\n-\n-/* This is how to output an assembler line to define N characters starting\n-   at P to FILE.  */\n-\n-#define ASM_OUTPUT_ASCII(FILE, P, N)  output_ascii ((FILE), (P), (N))\n-\n-/* This is how to advance the location counter by SIZE bytes.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGNMENT)\t\\\n-  do { fputs (\".comm \", (FILE));\t\t\t\\\n-       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n-       if ( (SIZE) > 4)\t\t\t\t\t\\\n-         fprintf ((FILE), \",%d,3\\n\", (SIZE));\t\t\\\n-       else\t\t\t\t\t\t\\\n-\t fprintf( (FILE), \",%d\\n\", (SIZE));\t\t\\\n-  } while (0)\n-\n-/* These are various definitions for DWARF output.  They could just\n-   use '.long' or '.word', but that aligns to a 4-byte boundary which\n-   is not what is required.  So we define a million macros...  */\n-\n-#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.vbyte\\t2,\"\n-#define UNALIGNED_INT_ASM_OP\t\t\"\\t.vbyte\\t4,\"\n-#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.vbyte\\t8,\"\n-\n-/* Output before instructions.  */\n-#define TEXT_SECTION_ASM_OP \"\\t.csect .text[PR]\"\n-\n-/* Output before writable data.\n-   Align entire section to BIGGEST_ALIGNMENT.  */\n-#define DATA_SECTION_ASM_OP \"\\t.csect .data[RW],3\"\n-\n-/* Define unique section name -- functions only.  */\n-#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    int len;\t\t\t\t\t\t\\\n-    const char *name;\t\t\t\t\t\\\n-    char *string;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-    if (TREE_CODE (DECL) == FUNCTION_DECL) {\t\t\\\n-      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL)); \\\n-      len = strlen (name) + 5;\t\t\t\t\\\n-      string = alloca (len) + 1;\t\t\t\\\n-      sprintf (string, \".%s[PR]\", name);\t\t\\\n-      DECL_SECTION_NAME (DECL) = build_string (len, string); \\\n-    }\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_SECTION_NAME(ASM_OUT_FILE,DECL,NAME,RELOC)\t\\\n-  do { fputs (\"\\t.csect \", ASM_OUT_FILE);\t\t\t\\\n-       fputs (TREE_STRING_POINTER (DECL_SECTION_NAME (DECL)), ASM_OUT_FILE); \\\n-       putc ('\\n', ASM_OUT_FILE);\t\t\t\t\\\n-  } while (0)\n-\n-/* Define the name of the section to use for the exception tables.\n-   TODO: test and see if we can use read_only_data_section, if so,\n-   remove this.  */\n-\n-#define EXCEPTION_SECTION data_section\n-\n /* __throw will restore its own return address to be the same as the\n    return address of the function that the throw is being made to.\n    This is unfortunate, because we want to check the original"}, {"sha": "0ae4923600b3dc7fc802c5ead0ec19bc1f31707f", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -173,3 +173,21 @@ Boston, MA 02111-1307, USA.  */\n \n /* Fix for emit_group_load (): force large constants to be pushed via regs.  */\n #define ALWAYS_PUSH_CONSTS_USING_REGS_P\t\t1\n+\n+/* Darwin word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n+  (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n+\t      ? get_inner_array_type (FIELD) \\\n+\t      : TREE_TYPE (FIELD)) == DFmode \\\n+   ? MIN ((COMPUTED), 32) : (COMPUTED))\n+\n+/* Darwin increases natural record alignment to doubleword if the first\n+   field is an FP double while the FP fields remain word aligned.  */\n+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)\t\\\n+  ((TREE_CODE (STRUCT) == RECORD_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == UNION_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == QUAL_UNION_TYPE)\t\t\\\n+   && TYPE_FIELDS (STRUCT) != 0\t\t\t\t\\\n+   && DECL_MODE (TYPE_FIELDS (STRUCT)) == DFmode\t\\\n+   ? MAX (MAX ((COMPUTED), (SPECIFIED)), BIGGEST_ALIGNMENT) \\\n+   : MAX ((COMPUTED), (SPECIFIED)))"}, {"sha": "6e06ecbd78107ef84ffff4c8626e98bc504ea264", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -69,6 +69,11 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_APP_OFF\n #define ASM_APP_OFF \"#NO_APP\\n\"\n \n+#undef DEFAULT_VTABLE_THUNKS\n+#ifndef USE_GNULIBC_1\n+#define DEFAULT_VTABLE_THUNKS 1\n+#endif\n+\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n "}, {"sha": "9fba46efaa1a249a0bb93b79f295a7d290ec6176", "filename": "gcc/config/rs6000/linux64.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -0,0 +1,307 @@\n+/* Definitions of target machine for GNU compiler,\n+   for 64 bit powerpc linux.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Yes!  We are AIX! Err. Wait. We're Linux!. No, wait, we're a\n+  combo of both!*/\n+#undef DEFAULT_ABI\n+#define DEFAULT_ABI ABI_AIX\n+\n+#undef TARGET_AIX\n+#define TARGET_AIX 1\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_POWERPC64 | MASK_64BIT | MASK_NEW_MNEMONICS)\n+\n+/* AIX does not have any init/fini or ctor/dtor sections, so create\n+    static constructors and destructors as normal functions.  */\n+/* #define ASM_OUTPUT_CONSTRUCTOR(file, name) */\n+/* #define ASM_OUTPUT_DESTRUCTOR(file, name) */\n+#define USER_LABEL_PREFIX  \"\"\n+\n+/* Tell the assembler to assume that all undefined names are external.\n+\n+   Don't do this until the fixed IBM assembler is more generally available.\n+   When this becomes permanently defined, the ASM_OUTPUT_EXTERNAL,\n+   ASM_OUTPUT_EXTERNAL_LIBCALL, and RS6000_OUTPUT_BASENAME macros will no\n+   longer be needed.  Also, the extern declaration of mcount in ASM_FILE_START\n+   will no longer be needed.  */\n+\n+/* #define ASM_SPEC \"-u %(asm_cpu)\" */\n+\n+/* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n+  (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n+\t      ? get_inner_array_type (FIELD) \\\n+\t      : TREE_TYPE (FIELD)) == DFmode \\\n+   ? MIN ((COMPUTED), 32) : (COMPUTED))\n+\n+/* AIX increases natural record alignment to doubleword if the first\n+   field is an FP double while the FP fields remain word aligned.  */\n+#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)\t\\\n+  ((TREE_CODE (STRUCT) == RECORD_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == UNION_TYPE\t\t\t\\\n+    || TREE_CODE (STRUCT) == QUAL_UNION_TYPE)\t\t\\\n+   && TYPE_FIELDS (STRUCT) != 0\t\t\t\t\\\n+   && DECL_MODE (TYPE_FIELDS (STRUCT)) == DFmode\t\\\n+   ? MAX (MAX ((COMPUTED), (SPECIFIED)), BIGGEST_ALIGNMENT) \\\n+   : MAX ((COMPUTED), (SPECIFIED)))\n+\n+/* Indicate that jump tables go in the text section.  */\n+#undef JUMP_TABLES_IN_TEXT_SECTION\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* Define cutoff for using external functions to save floating point.  */\n+#undef FP_SAVE_INLINE\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) == 62 || (FIRST_REG) == 63)\n+\n+#undef TARGET_NO_TOC\n+#undef TARGET_TOC\n+\n+/* 64-bit PowerPC Linux always has a TOC.  */\n+#define TARGET_NO_TOC\t\t0\n+#define\tTARGET_TOC\t\t1\n+\n+/* 64-bit PowerPC Linux always has GPR13 fixed.  */\n+#define FIXED_R13\t\t1\n+\n+/* __throw will restore its own return address to be the same as the\n+   return address of the function that the throw is being made to.\n+   This is unfortunate, because we want to check the original\n+   return address to see if we need to restore the TOC.\n+   So we have to squirrel it away with this.  */\n+#define SETUP_FRAME_ADDRESSES() rs6000_aix_emit_builtin_unwind_init ()\n+\n+#define PROFILE_HOOK(LABEL)   output_profile_hook (LABEL)\n+/* Don't assume anything about the header files. */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+#undef MD_EXEC_PREFIX\n+#undef MD_STARTFILE_PREFIX\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+ \"-D_PPC_ -D__PPC__ -D_PPC64_ -D__PPC64__ -D__powerpc__ -D__powerpc64__ \\\n+  -D_PIC_ -D__PIC__ -D_BIG_ENDIAN -D__BIG_ENDIAN__ -D__ELF__ \\\n+  -D__LONG_MAX__=9223372036854775807L \\\n+  -Acpu=powerpc64 -Amachine=powerpc64\"\n+\n+#undef\tCPP_OS_DEFAULT_SPEC\n+#define CPP_OS_DEFAULT_SPEC \"%(cpp_os_linux)\"\n+\n+/* The GNU C++ standard library currently requires _GNU_SOURCE being\n+   defined on glibc-based systems. This temporary hack accomplishes this,\n+   it should go away as soon as libstdc++-v3 has a real fix.  */\n+#undef CPLUSPLUS_CPP_SPEC\n+#define CPLUSPLUS_CPP_SPEC \"-D_GNU_SOURCE %(cpp)\"\n+\n+#undef LINK_SHLIB_SPEC\n+#define LINK_SHLIB_SPEC \"%{shared:-shared} %{!shared: %{static:-static}}\"\n+\n+#undef\tLIB_DEFAULT_SPEC\n+#define LIB_DEFAULT_SPEC \"%(lib_linux)\"\n+\n+#undef\tSTARTFILE_DEFAULT_SPEC\n+#define STARTFILE_DEFAULT_SPEC \"%(startfile_linux)\"\n+\n+#undef\tENDFILE_DEFAULT_SPEC\n+#define ENDFILE_DEFAULT_SPEC \"%(endfile_linux)\"\n+\n+#undef\tLINK_START_DEFAULT_SPEC\n+#define LINK_START_DEFAULT_SPEC \"%(link_start_linux)\"\n+\n+#undef\tLINK_OS_DEFAULT_SPEC\n+#define LINK_OS_DEFAULT_SPEC \"%(link_os_linux)\"\n+\n+#undef  LINK_OS_LINUX_SPEC\n+#define LINK_OS_LINUX_SPEC \"-m elf64ppc %{!shared: %{!static: \\\n+  %{rdynamic:-export-dynamic} \\\n+  %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}}}\"\n+\n+#undef TOC_SECTION_ASM_OP\n+#define TOC_SECTION_ASM_OP \"\\t.section\\t\\\".toc\\\",\\\"aw\\\"\"\n+\n+#undef MINIMAL_TOC_SECTION_ASM_OP\n+#define\tMINIMAL_TOC_SECTION_ASM_OP \"\\t.section\\t\\\".toc1\\\",\\\"aw\\\"\\n\\t.align 3\"\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (PowerPC64 GNU/Linux)\");\n+\n+/* Must be at least as big as our pointer type.  */\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE \"long unsigned int\"\n+\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+/* Override rs6000.h definition.  */\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Override rs6000.h definition.  */\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#undef DEFAULT_VTABLE_THUNKS\n+#ifndef USE_GNULIBC_1\n+#define DEFAULT_VTABLE_THUNKS 1\n+#endif\n+\n+/* PowerPC no-op instruction.  */\n+#undef RS6000_CALL_GLUE\n+#define RS6000_CALL_GLUE \"nop\"\n+\n+/* Dwarf2 debugging.  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE  DWARF2_DEBUG\n+\n+/* This macro gets just the user-specified name\n+   out of the string in a SYMBOL_REF.  Discard\n+   a leading * or @.  */\n+#define\tSTRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  const char *_name = SYMBOL_NAME;\t\t\t\t\t\\\n+  while (*_name == '*' || *_name == '@')\t\t\t\t\\\n+    _name++;\t\t\t\t\t\t\t\t\\\n+  (VAR) = _name;\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+/* Override elfos.h definition.  */\n+#undef\tASM_OUTPUT_LABELREF\n+#define\tASM_OUTPUT_LABELREF(FILE,NAME)\t\t\\\n+do {\t\t\t\t\t\t\\\n+  const char *_name = NAME;\t\t\t\\\n+  if (*_name == '@')\t\t\t\t\\\n+    _name++;\t\t\t\t\t\\\n+ \t\t\t\t\t\t\\\n+  if (*_name == '*')\t\t\t\t\\\n+    fprintf (FILE, \"%s\", _name + 1);\t\t\\\n+  else\t\t\t\t\t\t\\\n+    asm_fprintf (FILE, \"%U%s\", _name);\t\t\\\n+} while (0)\n+\n+#undef  ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_RELOCATABLE && (get_pool_size () != 0 || profile_flag)\t\\\n+\t&& uses_TOC())\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar buf[256];\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tASM_OUTPUT_INTERNAL_LABEL (FILE, \"LCL\", rs6000_pic_labelno);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\t\t\t\\\n+\tfputs (\"\\t.quad \", FILE);\t\t\t\t\t\\\n+\tassemble_name (FILE, buf);\t\t\t\t\t\\\n+\tputc ('-', FILE);\t\t\t\t\t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\t\\\n+\tassemble_name (FILE, buf);\t\t\t\t\t\\\n+\tputc ('\\n', FILE);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", TYPE_ASM_OP);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    putc (',', FILE);\t\t\t\t\t\t\t\\\n+    fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\t\t\\\n+    putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (DEFAULT_ABI == ABI_AIX)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tconst char *desc_name, *orig_name;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        STRIP_NAME_ENCODING (orig_name, NAME);\t\t\t\t\\\n+        desc_name = orig_name;\t\t\t\t\t\t\\\n+\twhile (*desc_name == '.')\t\t\t\t\t\\\n+\t  desc_name++;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TREE_PUBLIC (DECL))\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.globl %s\\n\", desc_name);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfputs (\"\\t.section\\t\\\".opd\\\",\\\"aw\\\"\\n\", FILE);\t\t\t\\\n+\tfprintf (FILE, \"%s:\\n\", desc_name);\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.quad %s\\n\", orig_name);\t\t\t\\\n+\tfputs (\"\\t.quad .TOC.@tocbase\\n\", FILE);\t\t\t\\\n+\tif (DEFAULT_ABI == ABI_AIX)\t\t\t\t\t\\\n+\t  fputs (\"\\t.quad 0\\n\", FILE);\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t.previous\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Return non-zero if this entry is to be written into the constant\n+   pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n+   or a CONST containing one of them.  If -mfp-in-toc (the default),\n+   we also do this for floating-point constants.  We actually can only\n+   do this if the FP formats of the target and host machines are the\n+   same, but we can't check that since not every file that uses\n+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n+   we can write the entry into the TOC and the entry is not larger\n+   than a TOC entry.  */\n+\n+#undef  ASM_OUTPUT_SPECIAL_POOL_ENTRY_P\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n+  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n+   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+       || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+\t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n+       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+\t   && (TARGET_POWERPC64\t\t\t\t\t\t\\\n+\t       || TARGET_MINIMAL_TOC\t\t\t\t\t\\\n+\t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t\t   && ! TARGET_NO_FP_IN_TOC)))))\n+\n+/* This is how to output an assembler line defining an `int'\n+   constant.  */\n+#undef  ASM_OUTPUT_INT\n+#define ASM_OUTPUT_INT(FILE, VALUE)            \\\n+  do                                           \\\n+    {                                          \\\n+      fputs (\"\\t.long \", (FILE));              \\\n+      output_addr_const ((FILE), (VALUE));     \\\n+      putc ('\\n', (FILE));                     \\\n+    }                                          \\\n+  while (0)\n+\n+/* This is how to output an assembler line defining a `double int'\n+   constant.  */\n+#undef  ASM_OUTPUT_DOUBLE_INT\n+#define ASM_OUTPUT_DOUBLE_INT(FILE, VALUE)     \\\n+  do                                           \\\n+    {                                          \\\n+      fputs (DOUBLE_INT_ASM_OP, (FILE));       \\\n+      output_addr_const ((FILE), (VALUE));     \\\n+      putc ('\\n', (FILE));                     \\\n+    }                                          \\\n+  while (0)\n+\n+#undef  ASM_DEFAULT_SPEC\n+#define\tASM_DEFAULT_SPEC \"-mppc64\""}, {"sha": "a6c2b013df1006bfc86499a2c4f94f6613031a00", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -34,6 +34,7 @@ extern int any_operand PARAMS ((rtx, enum machine_mode));\n extern int short_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int u_short_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int non_short_cint_operand PARAMS ((rtx, enum machine_mode));\n+extern int exact_log2_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int gpc_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int cc_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int cc_reg_not_cr0_operand PARAMS ((rtx, enum machine_mode));\n@@ -42,6 +43,8 @@ extern int reg_or_neg_short_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_u_short_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_arith_cint_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_add_cint64_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_sub_cint64_operand PARAMS ((rtx, enum machine_mode));\n extern int reg_or_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int got_operand PARAMS ((rtx, enum machine_mode));\n extern int got_no_const_operand PARAMS ((rtx, enum machine_mode));\n@@ -96,6 +99,7 @@ extern enum rtx_code rs6000_reverse_condition PARAMS ((enum machine_mode,\n extern void rs6000_emit_sCOND PARAMS ((enum rtx_code, rtx));\n extern void rs6000_emit_cbranch PARAMS ((enum rtx_code, rtx));\n extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n+extern rtx rs6000_emit_set_const PARAMS ((rtx, enum machine_mode, rtx, int));\n extern int rs6000_emit_cmove PARAMS ((rtx, rtx, rtx, rtx));\n extern void rs6000_emit_minmax PARAMS ((rtx, enum rtx_code, rtx, rtx));\n extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));"}, {"sha": "867206dedf42983fd866705d0647857f4088075f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 231, "deletions": 41, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -128,6 +128,8 @@ static int rs6000_ra_ever_killed PARAMS ((void));\n static int rs6000_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n static void rs6000_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static void rs6000_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+static rtx rs6000_emit_set_long_const PARAMS ((rtx,\n+  HOST_WIDE_INT, HOST_WIDE_INT));\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -364,15 +366,16 @@ rs6000_override_options (default_cpu)\n \t}\n     }\n \n-  if (flag_pic && (DEFAULT_ABI == ABI_AIX))\n+  if (flag_pic && DEFAULT_ABI == ABI_AIX)\n     {\n-      warning (\"-f%s ignored for AIX (all code is position independent)\",\n+      warning (\"-f%s ignored (all code is position independent)\",\n \t       (flag_pic > 1) ? \"PIC\" : \"pic\");\n       flag_pic = 0;\n     }\n \n+#ifdef XCOFF_DEBUGGING_INFO\n   if (flag_function_sections && (write_symbols != NO_DEBUG)\n-      && (DEFAULT_ABI == ABI_AIX))\n+      && DEFAULT_ABI == ABI_AIX)\n     {\n       warning (\"-ffunction-sections disabled on AIX when debugging\");\n       flag_function_sections = 0;\n@@ -383,6 +386,7 @@ rs6000_override_options (default_cpu)\n       warning (\"-fdata-sections not supported on AIX\");\n       flag_data_sections = 0;\n     }\n+#endif\n \n   /* Set debug flags */\n   if (rs6000_debug_name)\n@@ -585,6 +589,19 @@ non_short_cint_operand (op, mode)\n \t  && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) >= 0x10000);\n }\n \n+/* Returns 1 if OP is a CONST_INT that is a positive value\n+   and an exact power of 2.  */\n+\n+int\n+exact_log2_cint_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) > 0\n+\t  && exact_log2 (INTVAL (op)) >= 0);\n+}\n+\n /* Returns 1 if OP is a register that is not special (i.e., not MQ,\n    ctr, or lr).  */\n \n@@ -693,6 +710,42 @@ reg_or_arith_cint_operand (op, mode)\n \t\t ));\n }\n \n+/* Return 1 is the operand is either a non-special register or a 32-bit\n+   signed constant integer valid for 64-bit addition.  */\n+\n+int\n+reg_or_add_cint64_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+     return (gpc_reg_operand (op, mode)\n+\t     || (GET_CODE (op) == CONST_INT\n+\t\t && INTVAL (op) < 0x7fff8000\n+#if HOST_BITS_PER_WIDE_INT != 32\n+\t\t && ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n+\t\t     < 0x100000000ll)\n+#endif\n+\t\t ));\n+}\n+\n+/* Return 1 is the operand is either a non-special register or a 32-bit\n+   signed constant integer valid for 64-bit subtraction.  */\n+\n+int\n+reg_or_sub_cint64_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+     return (gpc_reg_operand (op, mode)\n+\t     || (GET_CODE (op) == CONST_INT\n+\t\t && (- INTVAL (op)) < 0x7fff8000\n+#if HOST_BITS_PER_WIDE_INT != 32\n+\t\t && ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80008000)\n+\t\t     < 0x100000000ll)\n+#endif\n+\t\t ));\n+}\n+\n /* Return 1 is the operand is either a non-special register or ANY\n    32-bit unsigned constant integer.  */\n \n@@ -996,9 +1049,11 @@ add_operand (op, mode)\n     register rtx op;\n     enum machine_mode mode;\n {\n-  return (reg_or_short_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && CONST_OK_FOR_LETTER_P (INTVAL (op), 'L')));\n+  if (GET_CODE (op) == CONST_INT)\n+    return (CONST_OK_FOR_LETTER_P (INTVAL(op), 'I')\n+\t    || CONST_OK_FOR_LETTER_P (INTVAL(op), 'L'));\n+\n+  return gpc_reg_operand (op, mode);\n }\n \n /* Return 1 if OP is a constant but not a valid add_operand.  */\n@@ -1636,6 +1691,124 @@ rs6000_legitimate_address (mode, x, reg_ok_strict)\n   return 0;\n }\n \f\n+/* Try to output insns to set TARGET equal to the constant C if it can be\n+   done in less than N insns.  Do all computations in MODE.  Returns the place\n+   where the output has been placed if it can be done and the insns have been\n+   emitted.  If it would take more than N insns, zero is returned and no\n+   insns and emitted.  */\n+\n+rtx\n+rs6000_emit_set_const (dest, mode, source, n)\n+     rtx dest, source;\n+     enum machine_mode mode;\n+     int n ATTRIBUTE_UNUSED;\n+{\n+  HOST_WIDE_INT c0, c1;\n+\n+  if (mode == QImode || mode == HImode || mode == SImode)\n+    {\n+      if (dest == NULL)\n+        dest = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, source));\n+      return dest;\n+    }\n+\n+  if (GET_CODE (source) == CONST_INT)\n+    {\n+      c0 = INTVAL (source);\n+      c1 = -(c0 < 0);\n+    }\n+  else if (GET_CODE (source) == CONST_DOUBLE)\n+    {\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+      c0 = CONST_DOUBLE_LOW (source);\n+      c1 = -(c0 < 0);\n+#else\n+      c0 = CONST_DOUBLE_LOW (source);\n+      c1 = CONST_DOUBLE_HIGH (source);\n+#endif\n+    }\n+  else\n+    abort();\n+\n+  return rs6000_emit_set_long_const (dest, c0, c1);\n+}\n+\n+/* Having failed to find a 3 insn sequence in rs6000_emit_set_const,\n+   fall back to a straight forward decomposition.  We do this to avoid\n+   exponential run times encountered when looking for longer sequences\n+   with rs6000_emit_set_const.  */\n+static rtx\n+rs6000_emit_set_long_const (dest, c1, c2)\n+     rtx dest;\n+     HOST_WIDE_INT c1, c2;\n+{\n+  if (!TARGET_POWERPC64)\n+    {\n+      rtx operand1, operand2;\n+\n+      operand1 = operand_subword_force (dest, WORDS_BIG_ENDIAN == 0,\n+\t\t\t\t\tDImode);\n+      operand2 = operand_subword_force (dest, WORDS_BIG_ENDIAN != 0,\n+\t\t\t\t\tDImode);\n+      emit_move_insn (operand1, GEN_INT (c1));\n+      emit_move_insn (operand2, GEN_INT (c2));\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT d1, d2, d3, d4;\n+\n+  /* Decompose the entire word */\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+      if (c2 != -(c1 < 0))\n+\tabort ();\n+      d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n+      c1 -= d1;\n+      d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+      c1 = (c1 - d2) >> 32;\n+      d3 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n+      c1 -= d3;\n+      d4 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+      if (c1 != d4)\n+\tabort ();\n+#else\n+      d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n+      c1 -= d1;\n+      d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+      if (c1 != d2)\n+\tabort ();\n+      c2 += (d2 < 0);\n+      d3 = ((c2 & 0xffff) ^ 0x8000) - 0x8000;\n+      c2 -= d3;\n+      d4 = ((c2 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+      if (c2 != d4)\n+\tabort ();\n+#endif\n+\n+      /* Construct the high word */\n+      if (d4)\n+\t{\n+\t  emit_move_insn (dest, GEN_INT (d4));\n+\t  if (d3)\n+\t    emit_move_insn (dest,\n+\t\t\t    gen_rtx_PLUS (DImode, dest, GEN_INT (d3)));\n+\t}\n+      else\n+\temit_move_insn (dest, GEN_INT (d3));\n+\n+      /* Shift it into place */\n+      emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (32)));\n+\n+      /* Add in the low bits.  */\n+      if (d2)\n+\temit_move_insn (dest, gen_rtx_PLUS (DImode, dest, GEN_INT (d2)));\n+      if (d1)\n+\temit_move_insn (dest, gen_rtx_PLUS (DImode, dest, GEN_INT (d1)));\n+    }\n+\n+  return dest;\n+}\n+\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n rs6000_emit_move (dest, source, mode)\n@@ -4107,6 +4280,7 @@ print_operand (file, x, code)\n     case 'p':\n       /* X is a CONST_INT that is a power of two.  Output the logarithm.  */\n       if (! INT_P (x)\n+\t  || INT_LOWPART (x) < 0\n \t  || (i = exact_log2 (INT_LOWPART (x))) < 0)\n \toutput_operand_lossage (\"invalid %%p value\");\n       else\n@@ -4512,19 +4686,33 @@ print_operand_address (file, x)\n #endif\n   else if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (x))\n     {\n-      if (TARGET_AIX)\n+      if (TARGET_AIX && (!TARGET_ELF || !TARGET_MINIMAL_TOC))\n \t{\n-\t  rtx contains_minus = XEXP (x, 1); \n-\t  rtx minus;\n+\t  rtx contains_minus = XEXP (x, 1);\n+\t  rtx minus, symref;\n+\t  const char *name;\n \t  \n \t  /* Find the (minus (sym) (toc)) buried in X, and temporarily\n \t     turn it into (sym) for output_addr_const. */\n \t  while (GET_CODE (XEXP (contains_minus, 0)) != MINUS)\n \t    contains_minus = XEXP (contains_minus, 0);\n \n-\t  minus = XEXP (contains_minus, 0); \n-\t  XEXP (contains_minus, 0) = XEXP (minus, 0);\n-\t  output_addr_const (file, XEXP (x, 1)); \t  \n+\t  minus = XEXP (contains_minus, 0);\n+\t  symref = XEXP (minus, 0);\n+\t  XEXP (contains_minus, 0) = symref;\n+\t  if (TARGET_ELF)\n+\t    {\n+\t      char *newname;\n+\n+\t      name = XSTR (symref, 0);\n+\t      newname = alloca (strlen (name) + sizeof (\"@toc\"));\n+\t      strcpy (newname, name);\n+\t      strcat (newname, \"@toc\");\n+\t      XSTR (symref, 0) = newname;\n+\t    }\n+\t  output_addr_const (file, XEXP (x, 1));\n+\t  if (TARGET_ELF)\n+\t    XSTR (symref, 0) = name;\n \t  XEXP (contains_minus, 0) = minus;\n \t}\n       else\n@@ -5137,8 +5325,9 @@ rs6000_stack_info ()\n   info_ptr->first_gp_reg_save = first_reg_to_save ();\n   /* Assume that we will have to save PIC_OFFSET_TABLE_REGNUM, \n      even if it currently looks like we won't.  */\n-  if (((flag_pic == 1\n-\t&& (abi == ABI_V4 || abi == ABI_SOLARIS))\n+  if (((TARGET_TOC && TARGET_MINIMAL_TOC)\n+       || (flag_pic == 1\n+\t   && (abi == ABI_V4 || abi == ABI_SOLARIS))\n        || (flag_pic &&\n \t   abi == ABI_DARWIN))\n       && info_ptr->first_gp_reg_save > PIC_OFFSET_TABLE_REGNUM)\n@@ -5459,18 +5648,15 @@ rs6000_emit_load_toc_table (fromprolog)\n   rtx dest;\n   dest = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n \n-  if (TARGET_ELF)\n+  if (TARGET_ELF && DEFAULT_ABI != ABI_AIX)\n     {\n       if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) \n \t  && flag_pic == 1)\n \t{\n \t  rtx temp = (fromprolog \n \t\t      ? gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)\n \t\t      : gen_reg_rtx (Pmode));\n-\t  if (TARGET_32BIT)\n-\t    rs6000_maybe_dead (emit_insn (gen_load_toc_v4_pic_si (temp)));\n-\t  else\n-\t    rs6000_maybe_dead (emit_insn (gen_load_toc_v4_pic_di (temp)));\n+\t  rs6000_maybe_dead (emit_insn (gen_load_toc_v4_pic_si (temp)));\n \t  rs6000_maybe_dead (emit_move_insn (dest, temp));\n \t}\n       else if (flag_pic == 2)\n@@ -7259,19 +7445,19 @@ output_toc (file, x, labelno, mode)\n       if (TARGET_64BIT)\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n-\t    fprintf (file, \"\\t.llong 0x%lx%08lx\\n\", k[0], k[1]);\n+\t    fputs (DOUBLE_INT_ASM_OP, file);\n \t  else\n-\t    fprintf (file, \"\\t.tc FD_%lx_%lx[TC],0x%lx%08lx\\n\",\n-\t\t     k[0], k[1], k[0] & 0xffffffff, k[1] & 0xffffffff);\n+\t    fprintf (file, \"\\t.tc FD_%lx_%lx[TC],\", k[0], k[1]);\n+\t  fprintf (file, \"0x%lx%08lx\\n\", k[0], k[1]);\n \t  return;\n \t}\n       else\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n-\t    fprintf (file, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\", k[0], k[1]);\n+\t    fputs (\"\\t.long \", file);\n \t  else\n-\t    fprintf (file, \"\\t.tc FD_%lx_%lx[TC],0x%lx,0x%lx\\n\",\n-\t\t     k[0], k[1], k[0], k[1]);\n+\t    fprintf (file, \"\\t.tc FD_%lx_%lx[TC],\", k[0], k[1]);\n+\t  fprintf (file, \"0x%lx,0x%lx\\n\", k[0], k[1]);\n \t  return;\n \t}\n     }\n@@ -7286,17 +7472,19 @@ output_toc (file, x, labelno, mode)\n       if (TARGET_64BIT)\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n-\t    fprintf (file, \"\\t.llong 0x%lx00000000\\n\", l);\n+\t    fputs (DOUBLE_INT_ASM_OP, file);\n \t  else\n-\t    fprintf (file, \"\\t.tc FS_%lx[TC],0x%lx00000000\\n\", l, l);\n+\t    fprintf (file, \"\\t.tc FS_%lx[TC],\", l);\n+\t  fprintf (file, \"0x%lx00000000\\n\", l);\n \t  return;\n \t}\n       else\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n-\t    fprintf (file, \"\\t.long 0x%lx\\n\", l);\n+\t    fputs (\"\\t.long \", file);\n \t  else\n-\t    fprintf (file, \"\\t.tc FS_%lx[TC],0x%lx\\n\", l, l);\n+\t    fprintf (file, \"\\t.tc FS_%lx[TC],\", l);\n+\t  fprintf (file, \"0x%lx\\n\", l);\n \t  return;\n \t}\n     }\n@@ -7344,38 +7532,40 @@ output_toc (file, x, labelno, mode)\n       if (TARGET_64BIT)\n \t{\n \t  if (TARGET_MINIMAL_TOC)\n-\t    fprintf (file, \"\\t.llong 0x%lx%08lx\\n\", (long)high, (long)low);\n+\t    fputs (DOUBLE_INT_ASM_OP, file);\n \t  else\n-\t    fprintf (file, \"\\t.tc ID_%lx_%lx[TC],0x%lx%08lx\\n\",\n-\t\t     (long)high, (long)low, (long)high, (long)low);\n+\t    fprintf (file, \"\\t.tc ID_%lx_%lx[TC],\", (long)high, (long)low);\n+\t  fprintf (file, \"0x%lx%08lx\\n\", (long) high, (long) low);\n \t  return;\n \t}\n       else\n \t{\n \t  if (POINTER_SIZE < GET_MODE_BITSIZE (mode))\n \t    {\n \t      if (TARGET_MINIMAL_TOC)\n-\t\tfprintf (file, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\",\n-\t\t\t (long)high, (long)low);\n+\t\tfputs (\"\\t.long \", file);\n \t      else\n-\t\tfprintf (file, \"\\t.tc ID_%lx_%lx[TC],0x%lx,0x%lx\\n\",\n-\t\t\t (long)high, (long)low, (long)high, (long)low);\n+\t\tfprintf (file, \"\\t.tc ID_%lx_%lx[TC],\",\n+\t\t\t (long)high, (long)low);\n+\t      fprintf (file, \"0x%lx,0x%lx\\n\", (long) high, (long) low);\n \t    }\n \t  else\n \t    {\n \t      if (TARGET_MINIMAL_TOC)\n-\t\tfprintf (file, \"\\t.long 0x%lx\\n\",\n-\t\t\t (long)low);\n+\t\tfputs (\"\\t.long \", file);\n \t      else\n-\t\tfprintf (file, \"\\t.tc IS_%lx[TC],0x%lx\\n\",\n-\t\t\t (long)low, (long)low);\n+\t\tfprintf (file, \"\\t.tc IS_%lx[TC],\", (long) low);\n+\t      fprintf (file, \"0x%lx\\n\", (long) low);\n \t    }\n \t  return;\n \t}\n     }\n \n   if (GET_CODE (x) == CONST)\n     {\n+      if (GET_CODE (XEXP (x, 0)) != PLUS)\n+\tabort ();\n+\n       base = XEXP (XEXP (x, 0), 0);\n       offset = INTVAL (XEXP (XEXP (x, 0), 1));\n     }\n@@ -7391,7 +7581,7 @@ output_toc (file, x, labelno, mode)\n \n   STRIP_NAME_ENCODING (real_name, name);\n   if (TARGET_MINIMAL_TOC)\n-    fputs (TARGET_32BIT ? \"\\t.long \" : \"\\t.llong \", file);\n+    fputs (TARGET_32BIT ? \"\\t.long \" : DOUBLE_INT_ASM_OP, file);\n   else\n     {\n       fprintf (file, \"\\t.tc %s\", real_name);"}, {"sha": "d7588300c88bd03c4ba47bb9aec6c7d76cfe2c51", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 43, "deletions": 119, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -33,10 +33,14 @@ Boston, MA 02111-1307, USA.  */\n #define OBJECT_MACHO 4\n \n #define TARGET_ELF (TARGET_OBJECT_FORMAT == OBJECT_ELF)\n-#define TARGET_AIX (TARGET_OBJECT_FORMAT == OBJECT_XCOFF)\n+#define TARGET_XCOFF (TARGET_OBJECT_FORMAT == OBJECT_XCOFF)\n #define TARGET_MACOS (TARGET_OBJECT_FORMAT == OBJECT_PEF)\n #define TARGET_MACHO (TARGET_OBJECT_FORMAT == OBJECT_MACHO)\n \n+#ifndef TARGET_AIX\n+#define TARGET_AIX 0\n+#endif\n+\n /* Print subsidiary information on the compiler version in use.  */\n #define TARGET_VERSION ;\n \n@@ -45,82 +49,6 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_DEFAULT ((char *)0)\n #endif\n \n-/* Common CPP definitions used by CPP_SPEC among the various targets\n-   for handling -mcpu=xxx switches.  */\n-#define CPP_CPU_SPEC \\\n-\"%{!mcpu*: \\\n-  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n-  %{mpower2: -D_ARCH_PWR2} \\\n-  %{mpowerpc*: -D_ARCH_PPC} \\\n-  %{mno-power: %{!mpowerpc*: -D_ARCH_COM}} \\\n-  %{!mno-power: %{!mpower2: %(cpp_default)}}} \\\n-%{mcpu=common: -D_ARCH_COM} \\\n-%{mcpu=power: -D_ARCH_PWR} \\\n-%{mcpu=power2: -D_ARCH_PWR2} \\\n-%{mcpu=powerpc: -D_ARCH_PPC} \\\n-%{mcpu=rios: -D_ARCH_PWR} \\\n-%{mcpu=rios1: -D_ARCH_PWR} \\\n-%{mcpu=rios2: -D_ARCH_PWR2} \\\n-%{mcpu=rsc: -D_ARCH_PWR} \\\n-%{mcpu=rsc1: -D_ARCH_PWR} \\\n-%{mcpu=401: -D_ARCH_PPC} \\\n-%{mcpu=403: -D_ARCH_PPC} \\\n-%{mcpu=505: -D_ARCH_PPC} \\\n-%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n-%{mcpu=602: -D_ARCH_PPC} \\\n-%{mcpu=603: -D_ARCH_PPC} \\\n-%{mcpu=603e: -D_ARCH_PPC} \\\n-%{mcpu=ec603e: -D_ARCH_PPC} \\\n-%{mcpu=604: -D_ARCH_PPC} \\\n-%{mcpu=604e: -D_ARCH_PPC} \\\n-%{mcpu=620: -D_ARCH_PPC} \\\n-%{mcpu=740: -D_ARCH_PPC} \\\n-%{mcpu=750: -D_ARCH_PPC} \\\n-%{mcpu=801: -D_ARCH_PPC} \\\n-%{mcpu=821: -D_ARCH_PPC} \\\n-%{mcpu=823: -D_ARCH_PPC} \\\n-%{mcpu=860: -D_ARCH_PPC}\"\n-\n-#define CPP_DEFAULT_SPEC \"-D_ARCH_PWR\"\n-\n-/* Common ASM definitions used by ASM_SPEC among the various targets\n-   for handling -mcpu=xxx switches.  */\n-#define ASM_CPU_SPEC \\\n-\"%{!mcpu*: \\\n-  %{mpower: %{!mpower2: -mpwr}} \\\n-  %{mpower2: -mpwrx} \\\n-  %{mpowerpc*: -mppc} \\\n-  %{mno-power: %{!mpowerpc*: -mcom}} \\\n-  %{!mno-power: %{!mpower2: %(asm_default)}}} \\\n-%{mcpu=common: -mcom} \\\n-%{mcpu=power: -mpwr} \\\n-%{mcpu=power2: -mpwrx} \\\n-%{mcpu=powerpc: -mppc} \\\n-%{mcpu=rios: -mpwr} \\\n-%{mcpu=rios1: -mpwr} \\\n-%{mcpu=rios2: -mpwrx} \\\n-%{mcpu=rsc: -mpwr} \\\n-%{mcpu=rsc1: -mpwr} \\\n-%{mcpu=401: -mppc} \\\n-%{mcpu=403: -mppc} \\\n-%{mcpu=505: -mppc} \\\n-%{mcpu=601: -m601} \\\n-%{mcpu=602: -mppc} \\\n-%{mcpu=603: -mppc} \\\n-%{mcpu=603e: -mppc} \\\n-%{mcpu=ec603e: -mppc} \\\n-%{mcpu=604: -mppc} \\\n-%{mcpu=604e: -mppc} \\\n-%{mcpu=620: -mppc} \\\n-%{mcpu=740: -mppc} \\\n-%{mcpu=750: -mppc} \\\n-%{mcpu=801: -mppc} \\\n-%{mcpu=821: -mppc} \\\n-%{mcpu=823: -mppc} \\\n-%{mcpu=860: -mppc}\"\n-\n-#define ASM_DEFAULT_SPEC \"\"\n-\n /* This macro defines names of additional specifications to put in the specs\n    that can be used in various specifications like CC1_SPEC.  Its definition\n    is an initializer with a subgrouping for each command option.\n@@ -574,13 +502,6 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* Handle #pragma pack.  */\n #define HANDLE_PRAGMA_PACK 1\n \n-/* AIX word-aligns FP doubles but doubleword-aligns 64-bit ints.  */\n-#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED) \\\n-  (TYPE_MODE (TREE_CODE (TREE_TYPE (FIELD)) == ARRAY_TYPE \\\n-\t      ? get_inner_array_type (FIELD) \\\n-\t      : TREE_TYPE (FIELD)) == DFmode \\\n-   ? MIN ((COMPUTED), 32) : (COMPUTED))\n-\n /* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 32\n \n@@ -590,17 +511,6 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n /* A bitfield declared as `int' forces `int' alignment for the struct.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* AIX increases natural record alignment to doubleword if the first\n-   field is an FP double while the FP fields remain word aligned.  */\n-#define ROUND_TYPE_ALIGN(STRUCT, COMPUTED, SPECIFIED)\t\\\n-  ((TREE_CODE (STRUCT) == RECORD_TYPE\t\t\t\\\n-    || TREE_CODE (STRUCT) == UNION_TYPE\t\t\t\\\n-    || TREE_CODE (STRUCT) == QUAL_UNION_TYPE)\t\t\\\n-   && TYPE_FIELDS (STRUCT) != 0\t\t\t\t\\\n-   && DECL_MODE (TYPE_FIELDS (STRUCT)) == DFmode\t\\\n-   ? MAX (MAX ((COMPUTED), (SPECIFIED)), BIGGEST_ALIGNMENT) \\\n-   : MAX ((COMPUTED), (SPECIFIED)))\n-\n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   (TREE_CODE (EXP) == STRING_CST\t\\\n@@ -796,7 +706,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n    registers is expensive.  */\n \n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\t\\\n-  ((CLASS1) == FLOAT_REGS && (CLASS2) == FLOAT_REGS ? 2\t\t\\\n+   ((CLASS1) == FLOAT_REGS && (CLASS2) == FLOAT_REGS ? 2\t\t\\\n    : (CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS ? 10\t\\\n    : (CLASS1) != FLOAT_REGS && (CLASS2) == FLOAT_REGS ? 10\t\\\n    : (((CLASS1) == SPECIAL_REGS || (CLASS1) == MQ_REGS\t\t\\\n@@ -1050,7 +960,7 @@ enum reg_class\n    `K' is a constant with only the low-order 16 bits non-zero\n    `L' is a signed 16-bit constant shifted left 16 bits\n    `M' is a constant that is greater than 31\n-   `N' is a constant that is an exact power of two\n+   `N' is a positive constant that is an exact power of two\n    `O' is the constant zero\n    `P' is a constant whose negation is a signed 16-bit constant */\n \n@@ -1061,7 +971,7 @@ enum reg_class\n    : (C) == 'L' ? (((VALUE) & 0xffff) == 0\t\t\t\t\\\n \t\t   && ((VALUE) >> 31 == -1 || (VALUE) >> 31 == 0))\t\\\n    : (C) == 'M' ? (VALUE) > 31\t\t\t\t\t\t\\\n-   : (C) == 'N' ? exact_log2 (VALUE) >= 0\t\t\t\t\\\n+   : (C) == 'N' ? (VALUE) > 0 && exact_log2 (VALUE) >= 0\t\t\\\n    : (C) == 'O' ? (VALUE) == 0\t\t\t\t\t\t\\\n    : (C) == 'P' ? (unsigned HOST_WIDE_INT) ((- (VALUE)) + 0x8000) < 0x10000 \\\n    : 0)\n@@ -1384,8 +1294,8 @@ typedef struct rs6000_stack {\n /* 1 if N is a possible register number for function argument passing.\n    On RS/6000, these are r3-r10 and fp1-fp13.  */\n #define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n-  (((unsigned)((N) - GP_ARG_MIN_REG) < (unsigned)(GP_ARG_NUM_REG))\t\\\n-   || ((unsigned)((N) - FP_ARG_MIN_REG) < (unsigned)(FP_ARG_NUM_REG)))\n+  ((((N) - GP_ARG_MIN_REG) < (GP_ARG_NUM_REG))\t\\\n+   || (((N) - FP_ARG_MIN_REG) < (FP_ARG_NUM_REG)))\n \n \f\n /* A C structure for machine-specific, per-function data.\n@@ -1551,6 +1461,16 @@ typedef struct rs6000_args\n    argument is passed depends on whether or not it is a named argument.  */\n #define STRICT_ARGUMENT_NAMING 1\n \n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) output_prolog (FILE, SIZE)\n+\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n@@ -1575,6 +1495,18 @@ typedef struct rs6000_args\n    || (current_function_calls_eh_return\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n        && (REGNO) == TOC_REGISTER))\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) output_epilog (FILE, SIZE)\n \f\n /* TRAMPOLINE_TEMPLATE deleted */\n \n@@ -2281,10 +2213,6 @@ extern int toc_initialized;\n     }\t\t\t\t\t\t\t\t\t  \\\n }\n \n-/* This is how we tell the assembler that two symbols have the same value.  */\n-\n-#define SET_ASM_OP \"\\t.set\\t\"\n-\n /* This implementes the `alias' attribute.  */\n \n #define ASM_OUTPUT_DEF_FROM_DECLS(FILE,decl,target)\t\\\n@@ -2498,7 +2426,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\t.llong \", FILE);\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s \", DOUBLE_INT_ASM_OP);\t\t\t\\\n       output_addr_const (FILE, (VALUE));\t\t\t\t\\\n       putc ('\\n', FILE);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2527,7 +2455,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n \n /* This is used by the definition of ASM_OUTPUT_ADDR_ELT in defaults.h.  */\n-#define ASM_LONG (TARGET_32BIT ? \".long\" : \".quad\")\n+#define ASM_LONG (TARGET_32BIT ? \".long\" : DOUBLE_INT_ASM_OP)\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n@@ -2550,19 +2478,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   if ((LOG) != 0)\t\t\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n \n-/* This says how to output an assembler line\n-   to define a local common symbol.\n-   Alignment cannot be specified, but we can try to maintain\n-   alignment after preceding TOC section if it was aligned\n-   for 64-bit mode.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-  do { fputs (\".lcomm \", (FILE));\t\t\t\\\n-       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n-       fprintf ((FILE), \",%d,%s\\n\", (TARGET_32BIT ? (SIZE) : (ROUNDED)), \\\n-\t\txcoff_bss_section_name);\t\t\\\n-     } while (0)\n-\n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n    LABELNO is an integer which is different for each call.  */\n@@ -2571,6 +2486,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n /* Pick up the return address upon entry to a procedure. Used for\n    dwarf2 unwind information.  This also enables the table driven\n    mechanism.  */\n@@ -2603,6 +2524,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\t   \\\n   {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n   {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n+  {\"exact_log2_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n   {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n   {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n   {\"cc_reg_not_cr0_operand\", {SUBREG, REG}},\t\t\t\t   \\\n@@ -2611,6 +2533,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n   {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n   {\"reg_or_arith_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n+  {\"reg_or_add_cint64_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n+  {\"reg_or_sub_cint64_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n   {\"reg_or_logical_cint_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}}, \\\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n   {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\"}, {"sha": "5f4036609b8551ac42f64fcab8d33f2b20be782f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 85, "deletions": 244, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -1422,19 +1422,14 @@\n       rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (SImode));\n \n-      HOST_WIDE_INT low = INTVAL (operands[2]) & 0xffff;\n-      HOST_WIDE_INT high = INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff);\n-\n-      if (low & 0x8000)\n-\t{\n-\t  high = trunc_int_for_mode (high + 0x10000, SImode);\n-\t  low = trunc_int_for_mode (low, HImode);\n-\t}\n+      HOST_WIDE_INT val = INTVAL (operands[2]);\n+      HOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n+      HOST_WIDE_INT rest = trunc_int_for_mode (val - low, SImode);\n \n       /* The ordering here is important for the prolog expander.\n \t When space is allocated from the stack, adding 'low' first may\n \t produce a temporary deallocation (which would be bad).  */\n-      emit_insn (gen_addsi3 (tmp, operands[1], GEN_INT (high)));\n+      emit_insn (gen_addsi3 (tmp, operands[1], GEN_INT (rest)));\n       emit_insn (gen_addsi3 (operands[0], tmp, GEN_INT (low)));\n       DONE;\n     }\n@@ -1536,16 +1531,11 @@\n    (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]\n \"\n {\n-  HOST_WIDE_INT low = INTVAL (operands[2]) & 0xffff;\n-  HOST_WIDE_INT high = INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff);\n-\n-  if (low & 0x8000)\n-    {\n-      high = trunc_int_for_mode (high + 0x10000, SImode);\n-      low = trunc_int_for_mode (low, HImode);\n-    }\n+  HOST_WIDE_INT val = INTVAL (operands[2]);\n+  HOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n+  HOST_WIDE_INT rest = trunc_int_for_mode (val - low, SImode);\n \n-  operands[3] = GEN_INT (high);\n+  operands[3] = GEN_INT (rest);\n   operands[4] = GEN_INT (low);\n }\")\n \n@@ -2277,6 +2267,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 0\n       && exact_log2 (INTVAL (operands[2])) >= 0)\n     ;\n   else if (TARGET_POWERPC)\n@@ -2328,12 +2319,9 @@\n   rtx temp1;\n   rtx temp2;\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    FAIL;\n-\n-  i = exact_log2 (INTVAL (operands[2]));\n-\n-  if (i < 0)\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || INTVAL (operands[2]) < 0\n+      || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n     FAIL;\n \n   temp1 = gen_reg_rtx (SImode);\n@@ -2348,18 +2336,18 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"N\")))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0\"\n+\t\t(match_operand:SI 2 \"exact_log2_cint_operand\" \"N\")))]\n+  \"\"\n   \"{srai|srawi} %0,%1,%p2\\;{aze|addze} %0,%0\"\n   [(set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"N,N\"))\n+\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r\"))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"\"\n   \"@\n    {srai|srawi} %3,%1,%p2\\;{aze.|addze.} %3,%3\n    #\"\n@@ -2369,10 +2357,10 @@\n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"\"))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0 && reload_completed\"\n+  \"reload_completed\"\n   [(set (match_dup 3)\n \t(div:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n@@ -2383,11 +2371,11 @@\n (define_insn \"\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"N,N\"))\n+\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(div:SI (match_dup 1) (match_dup 2)))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"\"\n   \"@\n    {srai|srawi} %0,%1,%p2\\;{aze.|addze.} %0,%0\n    #\"\n@@ -2397,11 +2385,11 @@\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(div:SI (match_dup 1) (match_dup 2)))]\n-  \"exact_log2 (INTVAL (operands[2])) >= 0 && reload_completed\"\n+  \"reload_completed\"\n   [(set (match_dup 0)\n \t(div:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 3)\n@@ -5589,7 +5577,7 @@\n (define_expand \"adddi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DI 2 \"reg_or_arith_cint_operand\" \"\")))]\n+\t\t (match_operand:DI 2 \"reg_or_add_cint64_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -5605,16 +5593,17 @@\n \trtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n \t\t   ? operands[0] : gen_reg_rtx (DImode));\n \n-\tHOST_WIDE_INT low = INTVAL (operands[2]) & 0xffff;\n-\tHOST_WIDE_INT high = INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff);\n+\tHOST_WIDE_INT val = INTVAL (operands[2]);\n+\tHOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n+\tHOST_WIDE_INT rest = trunc_int_for_mode (val - low, DImode);\n \n-\tif (low & 0x8000)\n-\t  {\n-\t    high = trunc_int_for_mode (high + 0x10000, SImode);\n-\t    low = trunc_int_for_mode (low, HImode);\n-\t  }\n+\tif (!CONST_OK_FOR_LETTER_P (rest, 'L'))\n+\t  FAIL;\n \n-\temit_insn (gen_adddi3 (tmp, operands[1], GEN_INT (high)));\n+\t/* The ordering here is important for the prolog expander.\n+\t   When space is allocated from the stack, adding 'low' first may\n+\t   produce a temporary deallocation (which would be bad).  */\n+\temit_insn (gen_adddi3 (tmp, operands[1], GEN_INT (rest)));\n \temit_insn (gen_adddi3 (operands[0], tmp, GEN_INT (low)));\n \tDONE;\n       }\n@@ -5707,17 +5696,22 @@\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n \"\n {\n-  HOST_WIDE_INT low = INTVAL (operands[2]) & 0xffff;\n-  HOST_WIDE_INT high = INTVAL (operands[2]) & (~ (HOST_WIDE_INT) 0xffff);\n+  HOST_WIDE_INT val = INTVAL (operands[2]);\n+  HOST_WIDE_INT low = (val & 0xffff) - 2 * (val & 0x8000);\n+  HOST_WIDE_INT rest = trunc_int_for_mode (val - low, DImode);\n \n-  if (low & 0x8000)\n+  operands[4] = GEN_INT (low);\n+  if (CONST_OK_FOR_LETTER_P (rest, 'L'))\n+    operands[3] = GEN_INT (rest);\n+  else if (! no_new_pseudos)\n     {\n-      high = trunc_int_for_mode (high + 0x10000, SImode);\n-      low = trunc_int_for_mode (low, HImode);\n+      operands[3] = gen_reg_rtx (DImode);\n+      emit_move_insn (operands[3], operands[2]);\n+      emit_insn (gen_adddi3 (operands[0], operands[1], operands[3]));\n+      DONE;\n     }\n-\n-  operands[3] = GEN_INT (high);\n-  operands[4] = GEN_INT (low);\n+  else\n+    FAIL;\n }\")\n \n (define_insn \"one_cmpldi2\"\n@@ -5846,7 +5840,7 @@\n (define_expand \"subdi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(minus:DI (match_operand:DI 1 \"reg_or_short_operand\" \"\")\n-\t\t  (match_operand:DI 2 \"reg_or_arith_cint_operand\" \"\")))]\n+\t\t  (match_operand:DI 2 \"reg_or_sub_cint64_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -6005,6 +5999,7 @@\n   \"\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 0\n       && exact_log2 (INTVAL (operands[2])) >= 0)\n     ;\n   else\n@@ -6018,11 +6013,13 @@\n   \"TARGET_POWERPC64\"\n   \"\n {\n-  int i = exact_log2 (INTVAL (operands[2]));\n+  int i;\n   rtx temp1;\n   rtx temp2;\n \n-  if (GET_CODE (operands[2]) != CONST_INT || i < 0)\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || INTVAL (operands[2]) <= 0\n+      || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n     FAIL;\n \n   temp1 = gen_reg_rtx (DImode);\n@@ -6037,18 +6034,18 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:DI 2 \"const_int_operand\" \"N\")))]\n-  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+\t\t(match_operand:DI 2 \"exact_log2_cint_operand\" \"N\")))]\n+  \"TARGET_POWERPC64\"\n   \"sradi %0,%1,%p2\\;addze %0,%0\"\n   [(set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"N,N\"))\n+\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 3 \"=r,r\"))]\n-  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"TARGET_POWERPC64\"\n   \"@\n    sradi %3,%1,%p2\\;addze. %3,%3\n    #\"\n@@ -6058,10 +6055,10 @@\n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"\"))\n+\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0 && reload_completed\"\n+  \"TARGET_POWERPC64 && reload_completed\"\n   [(set (match_dup 3)\n \t(div:DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n@@ -6072,11 +6069,11 @@\n (define_insn \"\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"N,N\"))\n+\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(div:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0\"\n+  \"TARGET_POWERPC64\"\n   \"@\n    sradi %0,%1,%p2\\;addze. %0,%0\n    #\"\n@@ -6086,11 +6083,11 @@\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\" \"\"))\n+\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(div:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64 && exact_log2 (INTVAL (operands[2])) >= 0 && reload_completed\"\n+  \"TARGET_POWERPC64 && reload_completed\"\n   [(set (match_dup 0)\n \t(div:DI (match_dup 1) (match_dup 2)))\n    (set (match_dup 3)\n@@ -7877,135 +7874,6 @@\n \t ? \\\"li %0,%1\\\" : \\\"lis %0,%v1\\\";\n }\")\n \n-;; sign-extended 32-bit value\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))]\n-  \"\n-{\n-  operands[2] = GEN_INT (INTVAL (operands[1]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n-        && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) == 0)\n-       || (CONST_DOUBLE_HIGH (operands[1]) == -1\n-           && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))]\n-  \"\n-{\n-  operands[2] = GEN_INT (CONST_DOUBLE_LOW (operands[1]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[3] = GEN_INT (CONST_DOUBLE_LOW (operands[1]) & 0xffff);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT != 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && (((INTVAL (operands[1]) >> 32) == 0\n-        && (INTVAL (operands[1]) & 0x80000000) == 0)\n-       || ((INTVAL (operands[1]) >> 32) == -1\n-           && (INTVAL (operands[1]) & 0x80000000) != 0))\n-   && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))]\n-  \"\n-{\n-  operands[2] = GEN_INT (INTVAL (operands[1]) & (~ (HOST_WIDE_INT) 0xffff));\n-  operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n-}\")\n-\n-;; zero-extended 32-bit value\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && CONST_DOUBLE_HIGH (operands[1]) == 0\n-   && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(zero_extend:DI (match_dup 3)))]\n-  \"\n-{ \n-  operands[2] = GEN_INT (CONST_DOUBLE_LOW (operands[1])); \n-  operands[3] = gen_lowpart_common (SImode, operands[0]);\n-}\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT != 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && INTVAL (operands[1]) >> 32 == 0\n-   && (INTVAL (operands[1]) & 0x80000000) != 0\n-   && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(zero_extend:DI (match_dup 3)))]\n-  \"\n-{\n-#if HOST_BITS_PER_WIDE_INT != 32\n-  operands[2] = GEN_INT ((INTVAL (operands[1]) ^ 0x80000000) - 0x80000000);\n-#endif\n-  operands[3] = gen_lowpart_common (SImode, operands[0]);\n-}\")\n-\n-;; 32-bit value in upper half of doubleword\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && CONST_DOUBLE_LOW (operands[1]) == 0\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ashift:DI (match_dup 0)\n-\t\t   (const_int 32)))]\n-  \"\n-{ operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[1])); }\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT != 32 && TARGET_POWERPC64\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && (INTVAL (operands[1]) & 0xffffffff) == 0\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ashift:DI (match_dup 0)\n-\t\t   (const_int 32)))]\n-  \"\n-{\n-#if HOST_BITS_PER_WIDE_INT != 32\n-operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n-#endif\n-}\")\n-\n ;; Generate all one-bits and clear left or right.\n ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n (define_split\n@@ -8025,55 +7893,35 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n ;; easy_fp_constant predicate.\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT == 32 && TARGET_POWERPC64\n-   && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ashift:DI (match_dup 0)\n-\t\t   (const_int 32)))\n-   (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))]\n+\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n   \"\n-{\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    {\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-      operands[3] = immed_double_const (CONST_DOUBLE_LOW (operands[1]),\n-\t\t\t\t\t0, DImode);\n-    }\n+{ rtx tem = rs6000_emit_set_const (operands[0], DImode, operands[1], 5);\n+\n+  if (tem == operands[0])\n+    DONE;\n   else\n-    {\n-      HOST_WIDE_INT value = INTVAL (operands[1]);\n-      operands[2] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n-      operands[3] = immed_double_const (value, 0, DImode);\n-    }\n+    FAIL;\n }\")\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"HOST_BITS_PER_WIDE_INT != 32 && TARGET_POWERPC64\n-   && num_insns_constant (operands[1], DImode) > 1\"\n-  [(set (match_dup 0)\n-\t(match_dup 2))\n-   (set (match_dup 0)\n-\t(ashift:DI (match_dup 0)\n-\t\t   (const_int 32)))\n-   (set (match_dup 0)\n-\t(ior:DI (match_dup 0)\n-\t\t(match_dup 3)))]\n+\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n   \"\n-{\n-#if HOST_BITS_PER_WIDE_INT != 32\n-  HOST_WIDE_INT value = INTVAL (operands[1]);\n-  operands[2] = GEN_INT (value >> 32);\n-  operands[3] = GEN_INT ((value & 0x7fffffff) - (value & 0x80000000));\n-#endif\n+{ rtx tem = rs6000_emit_set_const (operands[0], DImode, operands[1], 5);\n+\n+  if (tem == operands[0])\n+    DONE;\n+  else\n+    FAIL;\n }\")\n \n+;; Split a load of a large constant into the appropriate five-instruction\n (define_insn \"*movdi_internal2\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n@@ -9068,7 +8916,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n (define_insn \"load_toc_aix_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(unspec:SI [(const_int 0)] 7))]\n-  \"! TARGET_ELF && TARGET_32BIT\"\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_32BIT\"\n   \"*\n {\n   char buf[30];\n@@ -9082,11 +8930,13 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n (define_insn \"load_toc_aix_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(const_int 0)] 7))]\n-  \"! TARGET_ELF && TARGET_64BIT\"\n+  \"DEFAULT_ABI == ABI_AIX && TARGET_64BIT\"\n   \"*\n {\n   char buf[30];\n   ASM_GENERATE_INTERNAL_LABEL (buf, \\\"LCTOC\\\", 1);\n+  if (TARGET_ELF)\n+    strcat (buf, \\\"@toc\\\");\n   operands[1] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n   operands[2] = gen_rtx_REG (Pmode, 2);\n   return \\\"ld %0,%1(%2)\\\";\n@@ -9102,15 +8952,6 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"load_toc_v4_pic_di\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n-\t(unspec:DI [(const_int 0)] 7))]\n-  \"(DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS) && flag_pic == 1\n-   && TARGET_64BIT\"\n-  \"bl _GLOBAL_OFFSET_TABLE_@local-4\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n (define_insn \"load_toc_v4_PIC_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(match_operand:SI 1 \"immediate_operand\" \"s\"))"}, {"sha": "c8930c7e103316cc1094204cbf8b30905c5934ee", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 80, "deletions": 7, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -37,6 +37,79 @@ Boston, MA 02111-1307, USA.  */\n /* Override rs6000.h definition.  */\n #undef\tCPP_DEFAULT_SPEC\n #define\tCPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n+/* Common CPP definitions used by CPP_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#define CPP_CPU_SPEC \\\n+\"%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -D_ARCH_PWR}} \\\n+  %{mpower2: -D_ARCH_PWR2} \\\n+  %{mpowerpc*: -D_ARCH_PPC} \\\n+  %{mno-power: %{!mpowerpc*: -D_ARCH_COM}} \\\n+  %{!mno-power: %{!mpower2: %(cpp_default)}}} \\\n+%{mcpu=common: -D_ARCH_COM} \\\n+%{mcpu=power: -D_ARCH_PWR} \\\n+%{mcpu=power2: -D_ARCH_PWR2} \\\n+%{mcpu=powerpc: -D_ARCH_PPC} \\\n+%{mcpu=rios: -D_ARCH_PWR} \\\n+%{mcpu=rios1: -D_ARCH_PWR} \\\n+%{mcpu=rios2: -D_ARCH_PWR2} \\\n+%{mcpu=rsc: -D_ARCH_PWR} \\\n+%{mcpu=rsc1: -D_ARCH_PWR} \\\n+%{mcpu=401: -D_ARCH_PPC} \\\n+%{mcpu=403: -D_ARCH_PPC} \\\n+%{mcpu=505: -D_ARCH_PPC} \\\n+%{mcpu=601: -D_ARCH_PPC -D_ARCH_PWR} \\\n+%{mcpu=602: -D_ARCH_PPC} \\\n+%{mcpu=603: -D_ARCH_PPC} \\\n+%{mcpu=603e: -D_ARCH_PPC} \\\n+%{mcpu=ec603e: -D_ARCH_PPC} \\\n+%{mcpu=604: -D_ARCH_PPC} \\\n+%{mcpu=604e: -D_ARCH_PPC} \\\n+%{mcpu=620: -D_ARCH_PPC} \\\n+%{mcpu=740: -D_ARCH_PPC} \\\n+%{mcpu=750: -D_ARCH_PPC} \\\n+%{mcpu=801: -D_ARCH_PPC} \\\n+%{mcpu=821: -D_ARCH_PPC} \\\n+%{mcpu=823: -D_ARCH_PPC} \\\n+%{mcpu=860: -D_ARCH_PPC}\"\n+\n+#define CPP_DEFAULT_SPEC \"-D_ARCH_PPC\"\n+\n+/* Common ASM definitions used by ASM_SPEC among the various targets\n+   for handling -mcpu=xxx switches.  */\n+#define ASM_CPU_SPEC \\\n+\"%{!mcpu*: \\\n+  %{mpower: %{!mpower2: -mpwr}} \\\n+  %{mpower2: -mpwrx} \\\n+  %{mpowerpc*: -mppc} \\\n+  %{mno-power: %{!mpowerpc*: -mcom}} \\\n+  %{!mno-power: %{!mpower2: %(asm_default)}}} \\\n+%{mcpu=common: -mcom} \\\n+%{mcpu=power: -mpwr} \\\n+%{mcpu=power2: -mpwrx} \\\n+%{mcpu=powerpc: -mppc} \\\n+%{mcpu=rios: -mpwr} \\\n+%{mcpu=rios1: -mpwr} \\\n+%{mcpu=rios2: -mpwrx} \\\n+%{mcpu=rsc: -mpwr} \\\n+%{mcpu=rsc1: -mpwr} \\\n+%{mcpu=401: -mppc} \\\n+%{mcpu=403: -mppc} \\\n+%{mcpu=505: -mppc} \\\n+%{mcpu=601: -m601} \\\n+%{mcpu=602: -mppc} \\\n+%{mcpu=603: -mppc} \\\n+%{mcpu=603e: -mppc} \\\n+%{mcpu=ec603e: -mppc} \\\n+%{mcpu=604: -mppc} \\\n+%{mcpu=604e: -mppc} \\\n+%{mcpu=620: -mppc} \\\n+%{mcpu=740: -mppc} \\\n+%{mcpu=750: -mppc} \\\n+%{mcpu=801: -mppc} \\\n+%{mcpu=821: -mppc} \\\n+%{mcpu=823: -mppc} \\\n+%{mcpu=860: -mppc}\"\n \n /* Small data support types.  */\n enum rs6000_sdata_type {\n@@ -694,10 +767,9 @@ extern int rs6000_pic_labelno;\n     the return address.  Hence returning from FUNCTION will return to whoever\n     called the current thunk'.\n \n-    The effect must be as if FUNCTION had been called directly with\n-    the adjusted first argument.  This macro is responsible for\n-    emitting all of the code for a thunk function;\n-    output_function_prologue() and output_function_epilogue() are not\n+    The effect must be as if FUNCTION had been called directly with the adjusted\n+    first argument.  This macro is responsible for emitting all of the code for\n+    a thunk function; FUNCTION_PROLOGUE' and FUNCTION_EPILOGUE' are not\n     invoked.\n \n     The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n@@ -1191,11 +1263,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define\tCPP_SYSV_DEFAULT_SPEC \"-D_CALL_SYSV\"\n \n-#define CPP_ENDIAN_BIG_SPEC \"-D_BIG_ENDIAN -D__BIG_ENDIAN__ -Aendian=big\"\n+#define CPP_ENDIAN_BIG_SPEC \"-D_BIG_ENDIAN -D__BIG_ENDIAN__ -Amachine=bigendian\"\n \n-#define CPP_ENDIAN_LITTLE_SPEC \"-D_LITTLE_ENDIAN -D__LITTLE_ENDIAN__ -Aendian=little\"\n+#define CPP_ENDIAN_LITTLE_SPEC \"-D_LITTLE_ENDIAN -D__LITTLE_ENDIAN__ -Amachine=littleendian\"\n \n-#define CPP_ENDIAN_SOLARIS_SPEC \"-D__LITTLE_ENDIAN__ -Aendian=little\"\n+#define CPP_ENDIAN_SOLARIS_SPEC \"-D__LITTLE_ENDIAN__ -Amachine=littleendian\"\n \n /* For solaris, don't define _LITTLE_ENDIAN, it conflicts with a header file.  */\n #define\tCPP_ENDIAN_SPEC \\\n@@ -1606,3 +1678,4 @@ do {\t\t\t\t\t\t\t\t\t\\\n    : DW_EH_PE_absptr)\n \n #define EXCEPTION_SECTION readonly_data_section\n+#define DOUBLE_INT_ASM_OP \".quad\""}, {"sha": "53cc7e730bb8de9b7aafd43ed6c420bb83b460e9", "filename": "gcc/config/rs6000/xcoff.h", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bfcf297772c19dea98fac91400e458f6a1e449e/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=2bfcf297772c19dea98fac91400e458f6a1e449e", "patch": "@@ -0,0 +1,502 @@\n+/* Definitions of target machine for GNU compiler,\n+   for some generic XCOFF file format\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#define TARGET_OBJECT_FORMAT OBJECT_XCOFF\n+\n+/* The AIX linker will discard static constructors in object files before\n+   collect has a chance to see them, so scan the object files directly.  */\n+#define COLLECT_EXPORT_LIST\n+\n+/* The RS/6000 uses the XCOFF format.  */\n+#define XCOFF_DEBUGGING_INFO\n+\n+/* Define if the object format being used is COFF or a superset.  */\n+#define OBJECT_FORMAT_COFF\n+\n+/* Define the magic numbers that we recognize as COFF.\n+ \n+    AIX 4.3 adds U803XTOCMAGIC (0757) for 64-bit objects and AIX V5 adds\n+    U64_TOCMAGIC (0767), but collect2.c does not include files in the\n+    correct order to conditionally define the symbolic name in this macro.\n+ \n+    The AIX linker accepts import/export files as object files,\n+    so accept \"#!\" (0x2321) magic number.  */\n+#define MY_ISCOFF(magic) \\\n+  ((magic) == U802WRMAGIC || (magic) == U802ROMAGIC \\\n+   || (magic) == U802TOCMAGIC || (magic) == 0757 || (magic) == 0767 \\\n+   || (magic) == 0x2321)\n+\n+/* We don't have GAS for the RS/6000 yet, so don't write out special\n+    .stabs in cc1plus.  */\n+\n+#define FASCIST_ASSEMBLER\n+\n+/* We define this to prevent the name mangler from putting dollar signs into\n+   function names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* We define this to 0 so that gcc will never accept a dollar sign in a\n+   variable name.  This is needed because the AIX assembler will not accept\n+   dollar signs.  */\n+\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\n+/* Define the extra sections we need.  We define three: one is the read-only\n+   data section which is used for constants.  This is a csect whose name is\n+   derived from the name of the input file.  The second is for initialized\n+   global variables.  This is a csect whose name is that of the variable.\n+   The third is the TOC.  */\n+\n+#define EXTRA_SECTIONS \\\n+   read_only_data, private_data, read_only_private_data, toc, bss\n+\n+/* Define the routines to implement these extra sections.\n+   BIGGEST_ALIGNMENT is 64, so align the sections that much.  */\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+read_only_data_section ()\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != read_only_data)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n+\t       xcoff_read_only_section_name);\t\t\\\n+      in_section = read_only_data;\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+private_data_section ()\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != private_data)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RW],3\\n\",\t\\\n+\t       xcoff_private_data_section_name);\t\\\n+      in_section = private_data;\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+read_only_private_data_section ()\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != read_only_private_data)\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t.csect %s[RO],3\\n\",\t\\\n+\t       xcoff_private_data_section_name);\t\\\n+      in_section = read_only_private_data;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+toc_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (TARGET_MINIMAL_TOC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      /* toc_section is always called at least once from ASM_FILE_START, \\\n+\t so this is guaranteed to always be defined once and only once   \\\n+\t in each file.  */\t\t\t\t\t\t \\\n+      if (! toc_initialized)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fputs (\"\\t.toc\\nLCTOC..1:\\n\", asm_out_file);\t\\\n+\t  fputs (\"\\t.tc toc_table[TC],toc_table[RW]\\n\", asm_out_file); \\\n+\t  toc_initialized = 1;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      if (in_section != toc)\t\t\t\t\\\n+\tfprintf (asm_out_file, \"\\t.csect toc_table[RW]%s\\n\",\t\\\n+\t\t (TARGET_32BIT ? \"\" : \",3\"));\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (in_section != toc)\t\t\t\t\\\n+        fputs (\"\\t.toc\\n\", asm_out_file);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  in_section = toc;\t\t\t\t\t\\\n+}\n+\n+/* Define the name of our readonly data section.  */\n+\n+#define READONLY_DATA_SECTION read_only_data_section\n+\n+/* Select the section for an initialized data object.\n+\n+   On the RS/6000, we have a special section for all variables except those\n+   that are static.  */\n+\n+#define SELECT_SECTION(EXP,RELOC)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if ((TREE_CODE (EXP) == STRING_CST\t\t\t\\\n+       && ! flag_writable_strings)\t\t\t\\\n+      || (TREE_CODE_CLASS (TREE_CODE (EXP)) == 'd'\t\\\n+\t  && TREE_READONLY (EXP) && ! TREE_THIS_VOLATILE (EXP) \\\n+\t  && DECL_INITIAL (EXP)\t\t\t\t\\\n+\t  && (DECL_INITIAL (EXP) == error_mark_node\t\\\n+\t      || TREE_CONSTANT (DECL_INITIAL (EXP)))\t\\\n+\t  && ! (RELOC)))\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n+        read_only_data_section ();\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        read_only_private_data_section ();\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (TREE_PUBLIC (EXP))\t\t\t\t\\\n+        data_section ();\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        private_data_section ();\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+/* Return non-zero if this entry is to be written into the constant\n+   pool in a special way.  We do so if this is a SYMBOL_REF, LABEL_REF\n+   or a CONST containing one of them.  If -mfp-in-toc (the default),\n+   we also do this for floating-point constants.  We actually can only\n+   do this if the FP formats of the target and host machines are the\n+   same, but we can't check that since not every file that uses\n+   GO_IF_LEGITIMATE_ADDRESS_P includes real.h.  We also do this when\n+   we can write the entry into the TOC and the entry is not larger\n+   than a TOC entry.  */\n+\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY_P(X, MODE)\t\t\t\\\n+  (TARGET_TOC\t\t\t\t\t\t\t\t\\\n+   && (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST && GET_CODE (XEXP (X, 0)) == PLUS\t\\\n+\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+       || GET_CODE (X) == LABEL_REF\t\t\t\t\t\\\n+       || (GET_CODE (X) == CONST_INT \t\t\t\t\t\\\n+\t   && GET_MODE_BITSIZE (MODE) <= GET_MODE_BITSIZE (Pmode))\t\\\n+       || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+\t   && (TARGET_POWERPC64\t\t\t\t\t\t\\\n+\t       || TARGET_MINIMAL_TOC\t\t\t\t\t\\\n+\t       || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+\t\t   && ! TARGET_NO_FP_IN_TOC)))))\n+\n+/* Select section for constant in constant pool.\n+\n+   On RS/6000, all constants are in the private read-only data area.\n+   However, if this is being placed in the TOC it must be output as a\n+   toc entry.  */\n+\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\t\\\n+{ if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (X, MODE))\t\\\n+    toc_section ();\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    read_only_private_data_section ();\t\t\t\\\n+}\n+\n+/* If we are referencing a function that is static or is known to be\n+   in this file, make the SYMBOL_REF special.  We can use this to indicate\n+   that we can branch to this function without emitting a no-op after the\n+   call.  Do not set this flag if the function is weakly defined. */\n+\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\\\n+      && !TREE_PUBLIC (DECL)\t\t\t\t\\\n+      && !DECL_WEAK (DECL))\t\t\t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+\n+/* FP save and restore routines.  */\n+#define\tSAVE_FP_PREFIX \"._savef\"\n+#define SAVE_FP_SUFFIX \"\"\n+#define\tRESTORE_FP_PREFIX \"._restf\"\n+#define RESTORE_FP_SUFFIX \"\"\n+\n+/* Function name to call to do profiling.  */\n+#define RS6000_MCOUNT \".__mcount\"\n+\n+/* Function names to call to do floating point truncation.  */\n+\n+#define RS6000_ITRUNC \"__itrunc\"\n+#define RS6000_UITRUNC \"__uitrunc\"\n+\n+/* This outputs NAME to FILE up to the first null or '['.  */\n+\n+#define RS6000_OUTPUT_BASENAME(FILE, NAME)\t\\\n+  {\t\t\t\t\t\t\\\n+    const char *_p;\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+    STRIP_NAME_ENCODING (_p, (NAME));\t\t\\\n+    assemble_name ((FILE), _p);\t\t\t\\\n+  }\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { RS6000_OUTPUT_BASENAME (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\"\\t.globl \", FILE);\t\\\n+       RS6000_OUTPUT_BASENAME (FILE, NAME); putc ('\\n', FILE);} while (0)\n+\n+/* Remove any trailing [DS] or the like from the symbol name.  */\n+\n+#define STRIP_NAME_ENCODING(VAR,NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      const char *_name = (NAME);\t\t\t\\\n+      size_t _len;\t\t\t\t\t\\\n+      if (*_name == '*')\t\t\t\t\\\n+        _name++;\t\t\t\t\t\\\n+      _len = strlen (_name);\t\t\t\t\\\n+      if (_name[_len - 1] != ']')\t\t\t\\\n+\t(VAR) = _name;\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  char *_new_name = (char *) alloca (_len + 1);\t\\\n+\t  strcpy (_new_name, _name);\t\t\t\\\n+\t  _new_name[_len - 4] = '\\0';\t\t\t\\\n+\t  (VAR) = _new_name;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Output at beginning of assembler file.\n+\n+   Initialize the section names for the RS/6000 at this point.\n+\n+   Specify filename, including full path, to assembler.\n+\n+   We want to go into the TOC section so at least one .toc will be emitted.\n+   Also, in order to output proper .bs/.es pairs, we need at least one static\n+   [RW] section emitted.\n+\n+   Finally, declare mcount when profiling to make the assembler happy.  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  rs6000_gen_section_name (&xcoff_bss_section_name,\t\t\\\n+\t\t\t   main_input_filename, \".bss_\");\t\\\n+  rs6000_gen_section_name (&xcoff_private_data_section_name,\t\\\n+\t\t\t   main_input_filename, \".rw_\");\t\\\n+  rs6000_gen_section_name (&xcoff_read_only_section_name,\t\\\n+\t\t\t   main_input_filename, \".ro_\");\t\\\n+\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.file\\t\\\"%s\\\"\\n\", main_input_filename);\t\\\n+  if (TARGET_64BIT)\t\t\t\t\t\t\\\n+    fputs (\"\\t.machine\\t\\\"ppc64\\\"\\n\", FILE);\t\t\t\\\n+  toc_section ();\t\t\t\t\t\t\\\n+  if (write_symbols != NO_DEBUG)\t\t\t\t\\\n+    private_data_section ();\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\\\n+  if (profile_flag)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.extern %s\\n\", RS6000_MCOUNT);\t\t\\\n+  rs6000_file_start (FILE, TARGET_CPU_DEFAULT);\t\t\t\\\n+}\n+\n+/* Output at end of assembler file.\n+\n+   On the RS/6000, referencing data should automatically pull in text.  */\n+\n+#define ASM_FILE_END(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\\\n+  fputs (\"_section_.text:\\n\", FILE);\t\t\t\t\\\n+  data_section ();\t\t\t\t\t\t\\\n+  fputs (TARGET_32BIT\t\t\t\t\t\t\\\n+\t ? \"\\t.long _section_.text\\n\" : \"\\t.llong _section_.text\\n\", FILE); \\\n+}\n+\n+/* This macro produces the initial definition of a function name.\n+   On the RS/6000, we need to place an extra '.' in the function name and\n+   output the function descriptor.\n+\n+   The csect for the function will have already been created by the\n+   `text_section' call previously done.  We do have to go back to that\n+   csect, however.\n+\n+   We also record that the function exists in the current compilation\n+   unit, reachable by short branch, by setting SYMBOL_REF_FLAG.\n+\n+   The third and fourth parameters to the .function pseudo-op (16 and 044)\n+   are placeholders which no longer have any use.  */\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n+{ rtx sym_ref = XEXP (DECL_RTL (DECL), 0);\t\t\t\\\n+  if (!DECL_WEAK (DECL))\t\t\t\t\t\\\n+    SYMBOL_REF_FLAG (sym_ref) = 1;\t\t\t\t\\\n+  if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.globl .\", FILE);\t\t\t\t\\\n+      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.lglobl .\", FILE);\t\t\t\t\\\n+      RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\t.csect \", FILE);\t\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fputs (TARGET_32BIT ? \"[DS]\\n\" : \"[DS],3\\n\", FILE);\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n+  fputs (TARGET_32BIT ? \"\\t.long .\" : \"\\t.llong .\", FILE);\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fputs (\", TOC[tc0], 0\\n\", FILE);\t\t\t\t\\\n+  in_section = no_section;\t\t\t\t\t\\\n+  function_section(DECL);\t\t\t\t\t\\\n+  putc ('.', FILE);\t\t\t\t\t\t\\\n+  RS6000_OUTPUT_BASENAME (FILE, NAME);\t\t\t\t\\\n+  fputs (\":\\n\", FILE);\t\t\t\t\t\t\\\n+  if (write_symbols == XCOFF_DEBUG)\t\t\t\t\\\n+    xcoffout_declare_function (FILE, DECL, NAME);\t\t\\\n+}\n+\n+/* Output a reference to SYM on FILE.  */\n+\n+#define ASM_OUTPUT_SYMBOL_REF(FILE, SYM) \\\n+  rs6000_output_symbol_ref (FILE, SYM)\n+\n+/* This says how to output an external.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n+  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n+       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n+    {\t\t\t\t\t\t\\\n+      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n+      strcpy (_name, XSTR (_symref, 0));\t\\\n+      strcat (_name, TREE_CODE (DECL) == FUNCTION_DECL ? \"[DS]\" : \"[RW]\"); \\\n+      XSTR (_symref, 0) = _name;\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s..%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output an internal label prefix.  rs6000.c uses this\n+   when generating traceback tables.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL_PREFIX(FILE,PREFIX)   \\\n+  fprintf (FILE, \"%s..\", PREFIX)\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed. */\n+\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 2); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s..%ld\", (PREFIX), (long)(NUM))\n+\n+/* This is how to output an assembler line to define N characters starting\n+   at P to FILE.  */\n+\n+#define ASM_OUTPUT_ASCII(FILE, P, N)  output_ascii ((FILE), (P), (N))\n+\n+/* This is how to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %d\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGNMENT)\t\\\n+  do { fputs (\".comm \", (FILE));\t\t\t\\\n+       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n+       if ( (SIZE) > 4)\t\t\t\t\t\\\n+         fprintf ((FILE), \",%d,3\\n\", (SIZE));\t\t\\\n+       else\t\t\t\t\t\t\\\n+\t fprintf ((FILE), \",%d\\n\", (SIZE));\t\t\\\n+  } while (0)\n+\n+/* Used by definition of ASM_OUTPUT_DOUBLE_INT */\n+#define DOUBLE_INT_ASM_OP \".llong\"\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.\n+   Alignment cannot be specified, but we can try to maintain\n+   alignment after preceding TOC section if it was aligned\n+   for 64-bit mode.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do { fputs (\".lcomm \", (FILE));\t\t\t\\\n+       RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n+       fprintf ((FILE), \",%d,%s\\n\", (TARGET_32BIT ? (SIZE) : (ROUNDED)), \\\n+\t\txcoff_bss_section_name);\t\t\\\n+     } while (0)\n+\n+/* This is how we tell the assembler that two symbols have the same value.  */\n+\n+#define SET_ASM_OP \"\\t.set\\t\"\n+\n+/* These are various definitions for DWARF output.  They could just\n+   use '.long' or '.word', but that aligns to a 4-byte boundary which\n+   is not what is required.  So we define a million macros...  */\n+\n+#define UNALIGNED_SHORT_ASM_OP\t\t\"\\t.vbyte\\t2,\"\n+#define UNALIGNED_INT_ASM_OP\t\t\"\\t.vbyte\\t4,\"\n+#define UNALIGNED_DOUBLE_INT_ASM_OP\t\"\\t.vbyte\\t8,\"\n+\n+/* Output before instructions.  */\n+#define TEXT_SECTION_ASM_OP \"\\t.csect .text[PR]\"\n+\n+/* Output before writable data.\n+   Align entire section to BIGGEST_ALIGNMENT.  */\n+#define DATA_SECTION_ASM_OP \"\\t.csect .data[RW],3\"\n+\n+/* Define unique section name -- functions only.  */\n+#define UNIQUE_SECTION(DECL,RELOC)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    int len;\t\t\t\t\t\t\\\n+    const char *name;\t\t\t\t\t\\\n+    char *string;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    if (TREE_CODE (DECL) == FUNCTION_DECL) {\t\t\\\n+      name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (DECL)); \\\n+      len = strlen (name) + 5;\t\t\t\t\\\n+      string = alloca (len) + 1;\t\t\t\\\n+      sprintf (string, \".%s[PR]\", name);\t\t\\\n+      DECL_SECTION_NAME (DECL) = build_string (len, string); \\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_SECTION_NAME(ASM_OUT_FILE,DECL,NAME,RELOC)\t\\\n+  do { fputs (\"\\t.csect \", ASM_OUT_FILE);\t\t\t\\\n+       fputs (TREE_STRING_POINTER (DECL_SECTION_NAME (DECL)), ASM_OUT_FILE); \\\n+       putc ('\\n', ASM_OUT_FILE);\t\t\t\t\\\n+  } while (0)\n+\n+/* Define the name of the section to use for the exception tables.\n+   TODO: test and see if we can use read_only_data_section, if so,\n+   remove this.  */\n+\n+#define EXCEPTION_SECTION data_section"}]}