{"sha": "623fe76a4c9035ec908db4c6f61e9f191dd657aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIzZmU3NmE0YzkwMzVlYzkwOGRiNGM2ZjYxZTlmMTkxZGQ2NTdhYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-06-12T18:08:05Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-06-12T18:08:05Z"}, "message": "PR c++/3130, c++/3131, c++/3132\n\ncp:\n\tPR c++/3130, c++/3131, c++/3132\n\t* cp-tree.h (BINFO_UNSHARED_MARKED): New #define.\n\t* class.c (force_canonical_binfo_r): Move\n\tBINFO_UNSHARED_MARKED, BINFO_LOST_PRIMARY_P. Don't move\n\tvirtual bases unless they're primary and what they're primary\n\ttoo has been moved.\n\t(dfs_unshared_virtual_bases): Use BINFO_UNSHARED_MARKED. Cope\n\twith morally virtual bases. Duplicate BINFO_LOST_PRIMARY_P and\n\tBINFO_PRIMARY_BASE_OF. Clear BINFO_VTABLE for all but the most\n\tderived binfo.\n\t(mark_primary_bases): Use BINFO_UNSHARED_MARKED.\n\t(layout_nonempty_base_or_field): Add most derived type\n\tparameter. Adjust.\n\t(layout_empty_base): Likewise.\n\t(build_base_field): Likewise.\n\t(build_base_fields): Likewise.\n\t(propagate_binfo_offsets): Add most derived type\n\tparameter. Skip non canonical virtual bases too.\n\t(dfs_set_offset_for_unshared_vbases): Don't skip primary\n\tbases. Do skip canonical bases.\n\t(layout_virtual_bases): Adjust.\n\t(layout_class_type): Adjust.\n\t(dfs_get_primary_binfo): Build list of virtual primary base\n\tcandidates.\n\t(get_primary_binfo): Check that the shared virtual primary\n\tbase candidate was found first.\n\t(accumulate_vtbl_inits): Don't do anything for non-vptr\n\tcontaining binfos. For case 1 primary virtual bases, keep\n\tchecking that we've not emerged from the hierarchy of RTTI_BINFO.\ntestsuite:\n\t* g++.old-deja/g++.abi/vbase5.C: New test.\n\t* g++.old-deja/g++.abi/vbase6.C: New test.\n\t* g++.old-deja/g++.abi/vbase7.C: New test.\n\nFrom-SVN: r43266", "tree": {"sha": "008913fbee6bdbb7652317a0c709f6c3927127f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/008913fbee6bdbb7652317a0c709f6c3927127f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/623fe76a4c9035ec908db4c6f61e9f191dd657aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623fe76a4c9035ec908db4c6f61e9f191dd657aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/623fe76a4c9035ec908db4c6f61e9f191dd657aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/623fe76a4c9035ec908db4c6f61e9f191dd657aa/comments", "author": null, "committer": null, "parents": [{"sha": "205a5b45503be8a8e165b0876082801917f7c240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205a5b45503be8a8e165b0876082801917f7c240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205a5b45503be8a8e165b0876082801917f7c240"}], "stats": {"total": 361, "additions": 294, "deletions": 67}, "files": [{"sha": "5df346cebada76bcc381c99be5620f6f0cdb52ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -1,3 +1,35 @@\n+2001-06-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/3130, c++/3131, c++/3132\n+\t* cp-tree.h (BINFO_UNSHARED_MARKED): New #define.\n+\t* class.c (force_canonical_binfo_r): Move\n+\tBINFO_UNSHARED_MARKED, BINFO_LOST_PRIMARY_P. Don't move\n+\tvirtual bases unless they're primary and what they're primary\n+\ttoo has been moved.\n+\t(dfs_unshared_virtual_bases): Use BINFO_UNSHARED_MARKED. Cope\n+\twith morally virtual bases. Duplicate BINFO_LOST_PRIMARY_P and\n+\tBINFO_PRIMARY_BASE_OF. Clear BINFO_VTABLE for all but the most\n+\tderived binfo.\n+\t(mark_primary_bases): Use BINFO_UNSHARED_MARKED.\n+\t(layout_nonempty_base_or_field): Add most derived type\n+\tparameter. Adjust.\n+\t(layout_empty_base): Likewise.\n+\t(build_base_field): Likewise.\n+\t(build_base_fields): Likewise.\n+\t(propagate_binfo_offsets): Add most derived type\n+\tparameter. Skip non canonical virtual bases too.\n+\t(dfs_set_offset_for_unshared_vbases): Don't skip primary\n+\tbases. Do skip canonical bases.\n+\t(layout_virtual_bases): Adjust.\n+\t(layout_class_type): Adjust.\n+\t(dfs_get_primary_binfo): Build list of virtual primary base\n+\tcandidates.\n+\t(get_primary_binfo): Check that the shared virtual primary\n+\tbase candidate was found first.\n+\t(accumulate_vtbl_inits): Don't do anything for non-vptr\n+\tcontaining binfos. For case 1 primary virtual bases, keep\n+\tchecking that we've not emerged from the hierarchy of RTTI_BINFO.\n+\n 2001-06-12  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/3089"}, {"sha": "c1347b3cb336fc6c6b504544669cf44bac839b2e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 168, "deletions": 67, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -144,9 +144,9 @@ static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n static bool build_base_field PARAMS ((record_layout_info, tree, int *,\n-\t\t\t\t     splay_tree));\n+\t\t\t\t     splay_tree, tree));\n static bool build_base_fields PARAMS ((record_layout_info, int *,\n-\t\t\t\t      splay_tree));\n+\t\t\t\t      splay_tree, tree));\n static tree build_vbase_pointer_fields PARAMS ((record_layout_info, int *));\n static tree build_vtbl_or_vbase_field PARAMS ((tree, tree, tree, tree, tree,\n \t\t\t\t\t       int *));\n@@ -159,7 +159,7 @@ static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n-static void propagate_binfo_offsets PARAMS ((tree, tree));\n+static void propagate_binfo_offsets PARAMS ((tree, tree, tree));\n static void layout_virtual_bases PARAMS ((tree, splay_tree));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n@@ -181,9 +181,9 @@ static void initialize_vtable PARAMS ((tree, tree));\n static void initialize_array PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n \t\t\t\t\t\t   tree, tree,\n-\t\t\t\t\t\t   splay_tree));\n+\t\t\t\t\t\t   splay_tree, tree));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n-static bool layout_empty_base PARAMS ((tree, tree, splay_tree));\n+static bool layout_empty_base PARAMS ((tree, tree, splay_tree, tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t       tree));\n@@ -1676,6 +1676,10 @@ force_canonical_binfo_r (to, from, type, mappings)\n   BINFO_INDIRECT_PRIMARY_P (to)\n           = BINFO_INDIRECT_PRIMARY_P (from);\n   BINFO_INDIRECT_PRIMARY_P (from) = 0;\n+  BINFO_UNSHARED_MARKED (to) = BINFO_UNSHARED_MARKED (from);\n+  BINFO_UNSHARED_MARKED (from) = 0;\n+  BINFO_LOST_PRIMARY_P (to) = BINFO_LOST_PRIMARY_P (from);\n+  BINFO_LOST_PRIMARY_P (from) = 0;\n   if (BINFO_PRIMARY_P (from))\n     {\n       tree primary = BINFO_PRIMARY_BASE_OF (from);\n@@ -1689,7 +1693,8 @@ force_canonical_binfo_r (to, from, type, mappings)\n       BINFO_PRIMARY_BASE_OF (to) = primary;\n       BINFO_PRIMARY_BASE_OF (from) = NULL_TREE;\n     }\n-  my_friendly_assert (same_type_p (BINFO_TYPE (to), BINFO_TYPE (from)), 20010104);\n+  my_friendly_assert (same_type_p (BINFO_TYPE (to), BINFO_TYPE (from)),\n+\t\t      20010104);\n   mappings = tree_cons (from, to, mappings);\n   for (i = 0; i != n_baseclasses; i++)\n     {\n@@ -1698,9 +1703,10 @@ force_canonical_binfo_r (to, from, type, mappings)\n       \n       if (TREE_VIA_VIRTUAL (from_binfo))\n         {\n-          tree shared_binfo = binfo_for_vbase (BINFO_TYPE (from_binfo), type);\n-          \n-          if (shared_binfo == from_binfo)\n+\t  if (BINFO_PRIMARY_P (from_binfo) &&\n+\t      purpose_member (BINFO_PRIMARY_BASE_OF (from_binfo), mappings))\n+\t    /* This base is a primary of some binfo we have already\n+\t       reseated. We must reseat this one too.  */\n             force_canonical_binfo (to_binfo, from_binfo, type, mappings);\n         }\n       else\n@@ -1764,27 +1770,51 @@ mark_primary_virtual_base (binfo, base_binfo, type)\n   delta = size_diffop (BINFO_OFFSET (binfo), BINFO_OFFSET (base_binfo));\n   if (!integer_zerop (delta))\n     {\n-      propagate_binfo_offsets (base_binfo, delta);\n+      propagate_binfo_offsets (base_binfo, delta, type);\n       BINFO_OFFSET (base_binfo) = BINFO_OFFSET (binfo);\n     }\n   return base_binfo;\n }\n \n /* If BINFO is an unmarked virtual binfo for a class with a primary virtual\n    base, then BINFO has no primary base in this graph.  Called from\n-   mark_primary_bases. */\n+   mark_primary_bases.  DATA is the most derived type. */\n \n static tree dfs_unshared_virtual_bases (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_MARKED (binfo)\n-      && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo))\n-      && TREE_VIA_VIRTUAL (CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo))))\n-    BINFO_LOST_PRIMARY_P (binfo) = 1;\n-\n-  CLEAR_BINFO_MARKED (binfo);\n+  tree t = (tree) data;\n+  \n+  if (!BINFO_UNSHARED_MARKED (binfo)\n+      && CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n+    {\n+      /* This morally virtual base has a primary base when it\n+         is a complete object. We need to locate the shared instance\n+         of this binfo in the type dominated by T. We duplicate the\n+         primary base information from there to here.  */\n+      tree vbase;\n+      tree unshared_base;\n+      \n+      for (vbase = binfo; !TREE_VIA_VIRTUAL (vbase);\n+\t   vbase = BINFO_INHERITANCE_CHAIN (vbase))\n+\tcontinue;\n+      unshared_base = get_original_base (binfo,\n+\t\t\t\t\t binfo_for_vbase (BINFO_TYPE (vbase),\n+\t\t\t\t\t\t\t  t));\n+      my_friendly_assert (unshared_base != binfo, 20010612);\n+      BINFO_LOST_PRIMARY_P (binfo) = BINFO_LOST_PRIMARY_P (unshared_base);\n+      if (!BINFO_LOST_PRIMARY_P (binfo))\n+\t      BINFO_PRIMARY_BASE_OF (get_primary_binfo (binfo)) = binfo;\n+    }\n+  \n+  if (binfo != TYPE_BINFO (t))\n+    /* The vtable fields will have been copied when duplicating the\n+       base binfos. That information is bogus, make sure we don't try\n+       and use it. */\n+    BINFO_VTABLE (binfo) = NULL_TREE;\n   \n+  BINFO_UNSHARED_MARKED (binfo) = 0;\n   return NULL;\n }\n \n@@ -1813,12 +1843,13 @@ mark_primary_bases (type)\n \n       if (base_binfo)\n         BINFO_PRIMARY_BASE_OF (base_binfo) = binfo;\n-      SET_BINFO_MARKED (binfo);\n+      \n+      BINFO_UNSHARED_MARKED (binfo) = 1;\n     }\n-  /* There could remain unshared virtual bases which were not visited\n+  /* There could remain unshared morally virtual bases which were not visited\n      in the inheritance graph walk. These bases will have lost their\n-     primary base (should they have one). We must now find them. */\n-  dfs_walk (TYPE_BINFO (type), dfs_unshared_virtual_bases, NULL, NULL);\n+     virtual primary base (should they have one). We must now find them. */\n+  dfs_walk (TYPE_BINFO (type), dfs_unshared_virtual_bases, NULL, type);\n }\n \n /* Make the BINFO the primary base of T.  */\n@@ -3933,15 +3964,16 @@ layout_conflict_p (type, offset, offsets, vbases_p)\n /* DECL is a FIELD_DECL corresponding either to a base subobject of a\n    non-static data member of the type indicated by RLI.  BINFO is the\n    binfo corresponding to the base subobject, OFFSETS maps offsets to\n-   types already located at those offsets.  This function determines\n-   the position of the DECL.  */\n+   types already located at those offsets.  T is the most derived\n+   type.  This function determines the position of the DECL.  */\n \n static void\n-layout_nonempty_base_or_field (rli, decl, binfo, offsets)\n+layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n      record_layout_info rli;\n      tree decl;\n      tree binfo;\n      splay_tree offsets;\n+     tree t;\n {\n   tree offset = NULL_TREE;\n   tree type = TREE_TYPE (decl);\n@@ -3998,24 +4030,25 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets)\n \tbreak;\n     }\n \n-  /* Now that we know where it wil be placed, update its\n+  /* Now that we know where it will be placed, update its\n      BINFO_OFFSET.  */\n   if (binfo && CLASS_TYPE_P (BINFO_TYPE (binfo)))\n     propagate_binfo_offsets (binfo, \n-\t\t\t     convert (ssizetype, offset));\n+\t\t\t     convert (ssizetype, offset), t);\n }\n \n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n    past the end of the class, and should be correctly aligned for a\n    class of the type indicated by BINFO; OFFSETS gives the offsets of\n-   the empty bases allocated so far. Return non-zero iff we added it\n-   at the end. */\n+   the empty bases allocated so far. T is the most derived\n+   type.  Return non-zero iff we added it at the end. */\n \n static bool\n-layout_empty_base (binfo, eoc, offsets)\n+layout_empty_base (binfo, eoc, offsets, t)\n      tree binfo;\n      tree eoc;\n      splay_tree offsets;\n+     tree t;\n {\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n@@ -4035,7 +4068,7 @@ layout_empty_base (binfo, eoc, offsets)\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       atend = true;\n-      propagate_binfo_offsets (binfo, convert (ssizetype, eoc));\n+      propagate_binfo_offsets (binfo, convert (ssizetype, eoc), t);\n       while (1) \n \t{\n \t  if (!layout_conflict_p (BINFO_TYPE (binfo),\n@@ -4046,7 +4079,7 @@ layout_empty_base (binfo, eoc, offsets)\n \t    break;\n \n \t  /* There's overlap here, too.  Bump along to the next spot.  */\n-\t  propagate_binfo_offsets (binfo, alignment);\n+\t  propagate_binfo_offsets (binfo, alignment, t);\n \t}\n     }\n   return atend;\n@@ -4055,15 +4088,17 @@ layout_empty_base (binfo, eoc, offsets)\n /* Build a FIELD_DECL for the base given by BINFO in the class\n    indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n    *BASE_ALIGN is a running maximum of the alignments of any base\n-   class.  OFFSETS gives the location of empty base subobjects. Return\n-   non-zero if the new object cannot be nearly-empty. */\n+   class.  OFFSETS gives the location of empty base subobjects.  T is\n+   the most derived type.  Return non-zero if the new object cannot be\n+   nearly-empty. */\n \n static bool\n-build_base_field (rli, binfo, empty_p, offsets)\n+build_base_field (rli, binfo, empty_p, offsets, t)\n      record_layout_info rli;\n      tree binfo;\n      int *empty_p;\n      splay_tree offsets;\n+     tree t;\n {\n   tree basetype = BINFO_TYPE (binfo);\n   tree decl;\n@@ -4091,7 +4126,7 @@ build_base_field (rli, binfo, empty_p, offsets)\n       /* Try to place the field.  It may take more than one try if we\n \t have a hard time placing the field without putting two\n \t objects of the same type at the same address.  */\n-      layout_nonempty_base_or_field (rli, decl, binfo, offsets);\n+      layout_nonempty_base_or_field (rli, decl, binfo, offsets, t);\n     }\n   else\n     {\n@@ -4101,7 +4136,7 @@ build_base_field (rli, binfo, empty_p, offsets)\n \t byte-aligned.  */\n       eoc = tree_low_cst (rli_size_unit_so_far (rli), 0);\n       eoc = CEIL (eoc, DECL_ALIGN_UNIT (decl)) * DECL_ALIGN_UNIT (decl);\n-      atend |= layout_empty_base (binfo, size_int (eoc), offsets);\n+      atend |= layout_empty_base (binfo, size_int (eoc), offsets, t);\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n@@ -4113,14 +4148,15 @@ build_base_field (rli, binfo, empty_p, offsets)\n }\n \n /* Layout all of the non-virtual base classes.  Record empty\n-   subobjects in OFFSETS. Return non-zero if the type cannot be nearly\n-   empty.  */\n+   subobjects in OFFSETS.  T is the most derived type.  Return\n+   non-zero if the type cannot be nearly empty.  */\n \n static bool\n-build_base_fields (rli, empty_p, offsets)\n+build_base_fields (rli, empty_p, offsets, t)\n      record_layout_info rli;\n      int *empty_p;\n      splay_tree offsets;\n+     tree t;\n {\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n@@ -4133,7 +4169,7 @@ build_base_fields (rli, empty_p, offsets)\n      first.  */\n   if (CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n     build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n-\t\t      empty_p, offsets);\n+\t\t      empty_p, offsets, t);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n@@ -4154,7 +4190,7 @@ build_base_fields (rli, empty_p, offsets)\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n-      atend |= build_base_field (rli, base_binfo, empty_p, offsets);\n+      atend |= build_base_field (rli, base_binfo, empty_p, offsets, t);\n     }\n   return atend;\n }\n@@ -4728,9 +4764,10 @@ fixup_inline_methods (type)\n    OFFSET, which is a type offset, is number of bytes.  */\n \n static void\n-propagate_binfo_offsets (binfo, offset)\n+propagate_binfo_offsets (binfo, offset, t)\n      tree binfo;\n      tree offset;\n+     tree t;\n {\n   int i;\n   tree primary_binfo;\n@@ -4751,9 +4788,9 @@ propagate_binfo_offsets (binfo, offset)\n     {\n       tree base_binfo;\n \n-      /* On the first through the loop, do the primary base.  Because\n-\t the primary base need not be an immediate base, we must\n-\t handle the primary base specially.  */\n+      /* On the first time through the loop, do the primary base.\n+\t Because the primary base need not be an immediate base, we\n+\t must handle the primary base specially.  */\n       if (i == -1) \n \t{\n \t  if (!primary_binfo) \n@@ -4769,12 +4806,13 @@ propagate_binfo_offsets (binfo, offset)\n \t    continue;\n \t}\n \n-      /* Skip virtual bases that aren't our primary base.  */\n+      /* Skip virtual bases that aren't our canonical primary base.  */\n       if (TREE_VIA_VIRTUAL (base_binfo)\n-\t  && BINFO_PRIMARY_BASE_OF (base_binfo) != binfo)\n+\t  && (BINFO_PRIMARY_BASE_OF (base_binfo) != binfo\n+\t      || base_binfo != binfo_for_vbase (BINFO_TYPE (base_binfo), t)))\n \tcontinue;\n \n-      propagate_binfo_offsets (base_binfo, offset);\n+      propagate_binfo_offsets (base_binfo, offset, t);\n     }\n }\n \n@@ -4788,15 +4826,18 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n   /* If this is a virtual base, make sure it has the same offset as\n      the shared copy.  If it's a primary base, then we know it's\n      correct.  */\n-  if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_P (binfo))\n+  if (TREE_VIA_VIRTUAL (binfo))\n     {\n       tree t = (tree) data;\n       tree vbase;\n       tree offset;\n       \n       vbase = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-      offset = size_diffop (BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n-      propagate_binfo_offsets (binfo, offset);\n+      if (vbase != binfo)\n+\t{\n+\t  offset = size_diffop (BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n+\t  propagate_binfo_offsets (binfo, offset, t);\n+\t}\n     }\n \n   return NULL_TREE;\n@@ -4866,7 +4907,7 @@ layout_virtual_bases (t, offsets)\n \t  if (is_empty_class (basetype))\n \t    layout_empty_base (vbase,\n \t\t\t       size_int (CEIL (dsize, BITS_PER_UNIT)),\n-\t\t\t       offsets);\n+\t\t\t       offsets, t);\n \t  else\n \t    {\n \t      tree offset;\n@@ -4877,7 +4918,7 @@ layout_virtual_bases (t, offsets)\n \t\t\t\t\t     BINFO_OFFSET (vbase)));\n \n \t      /* And compute the offset of the virtual base.  */\n-\t      propagate_binfo_offsets (vbase, offset);\n+\t      propagate_binfo_offsets (vbase, offset, t);\n \t      /* Every virtual baseclass takes a least a UNIT, so that\n \t\t we can take it's address and get something different\n \t\t for each base.  */\n@@ -5055,7 +5096,7 @@ layout_class_type (t, empty_p, vfuns_p,\n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n   empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n \t\t\t\t       NULL, NULL);\n-  if (build_base_fields (rli, empty_p, empty_base_offsets))\n+  if (build_base_fields (rli, empty_p, empty_base_offsets, t))\n     CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n   \n   /* Add pointers to all of our virtual base-classes.  */\n@@ -5117,7 +5158,7 @@ layout_class_type (t, empty_p, vfuns_p,\n \tpadding = NULL_TREE;\n \n       layout_nonempty_base_or_field (rli, field, NULL_TREE,\n-\t\t\t\t     empty_base_offsets);\n+\t\t\t\t     empty_base_offsets, t);\n \n       /* If we needed additional padding after this field, add it\n \t now.  */\n@@ -5134,7 +5175,7 @@ layout_class_type (t, empty_p, vfuns_p,\n \t  DECL_USER_ALIGN (padding_field) = 0;\n \t  layout_nonempty_base_or_field (rli, padding_field,\n \t\t\t\t\t NULL_TREE, \n-\t\t\t\t\t empty_base_offsets);\n+\t\t\t\t\t empty_base_offsets, t);\n \t}\n     }\n \n@@ -6716,18 +6757,24 @@ get_vtbl_decl_for_binfo (binfo)\n   return decl;\n }\n \n-/* Called from get_primary_binfo via dfs_walk.  */\n+/* Called from get_primary_binfo via dfs_walk.  DATA is a TREE_LIST\n+   who's TREE_PURPOSE is the TYPE of the required primary base and\n+   who's TREE_VALUE is a list of candidate binfos that we fill in. */\n \n static tree\n dfs_get_primary_binfo (binfo, data)\n      tree binfo;\n      void *data;\n {\n-  tree primary_base = (tree) data;\n+  tree cons = (tree) data;\n+  tree primary_base = TREE_PURPOSE (cons);\n \n   if (TREE_VIA_VIRTUAL (binfo) \n-      && same_type_p (BINFO_TYPE (binfo), BINFO_TYPE (primary_base)))\n-    return binfo;\n+      && same_type_p (BINFO_TYPE (binfo), primary_base))\n+    /* This is the right type of binfo, but it might be an unshared\n+       instance, and the shared instance is later in the dfs walk.  We\n+       must keep looking.  */\n+    TREE_VALUE (cons) = tree_cons (NULL, binfo, TREE_VALUE (cons));\n   \n   return NULL_TREE;\n }\n@@ -6745,7 +6792,8 @@ get_primary_binfo (binfo)\n {\n   tree primary_base;\n   tree result;\n-\n+  tree virtuals;\n+  \n   primary_base = CLASSTYPE_PRIMARY_BINFO (BINFO_TYPE (binfo));\n   if (!primary_base)\n     return NULL_TREE;\n@@ -6773,9 +6821,48 @@ get_primary_binfo (binfo)\n \n   /* For a primary virtual base, we have to scan the entire hierarchy\n      rooted at BINFO; the virtual base could be an indirect virtual\n-     base.  */\n-  result = dfs_walk (binfo, dfs_get_primary_binfo, NULL, primary_base);\n-  my_friendly_assert (result != NULL_TREE, 20000730);\n+     base.  There could be more than one instance of the primary base\n+     in the hierarchy, and if one is the canonical binfo we want that\n+     one.  If it exists, it should be the first one we find, but as a\n+     consistency check we find them all and make sure.  */\n+  virtuals = build_tree_list (BINFO_TYPE (primary_base), NULL_TREE);\n+  dfs_walk (binfo, dfs_get_primary_binfo, NULL, virtuals);\n+  virtuals = TREE_VALUE (virtuals);\n+  \n+  /* We must have found at least one instance.  */\n+  my_friendly_assert (virtuals, 20010612);\n+\n+  if (TREE_CHAIN (virtuals))\n+    {\n+      /* We found more than one instance of the base. We must make\n+         sure that, if one is the canonical one, it is the first one\n+         we found. As the chain is in reverse dfs order, that means\n+         the last on the list.  */\n+      tree complete_binfo;\n+      tree canonical;\n+      \n+      for (complete_binfo = binfo;\n+\t   BINFO_INHERITANCE_CHAIN (complete_binfo);\n+\t   complete_binfo = BINFO_INHERITANCE_CHAIN (complete_binfo))\n+\tcontinue;\n+      canonical = binfo_for_vbase (BINFO_TYPE (primary_base),\n+\t\t\t\t   BINFO_TYPE (complete_binfo));\n+      \n+      for (; virtuals; virtuals = TREE_CHAIN (virtuals))\n+\t{\n+\t  result = TREE_VALUE (virtuals);\n+\n+\t  if (canonical == result)\n+\t    {\n+\t      /* This is the unshared instance. Make sure it was the\n+\t\t first one found.  */\n+\t      my_friendly_assert (!TREE_CHAIN (virtuals), 20010612);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    result = TREE_VALUE (virtuals);\n   return result;\n }\n \n@@ -7477,6 +7564,10 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n \t\t\t\t   BINFO_TYPE (orig_binfo)),\n \t\t      20000517);\n \n+  /* If it doesn't have a vpte, we don't do anything. */\n+  if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n+    return;\n+  \n   /* If we're building a construction vtable, we're not interested in\n      subobjects that don't require construction vtables.  */\n   if (ctor_vtbl_p \n@@ -7562,10 +7653,20 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n \n \t      for (; b; b = BINFO_PRIMARY_BASE_OF (b))\n \t\t{\n+\t\t  tree probe;\n+\n+\t\t  /* See if B is still within the hierarchy starting\n+\t\t     at RTTI_BINFO. */\n+\t\t  for (probe = b; probe;\n+\t\t       probe = BINFO_INHERITANCE_CHAIN (probe))\n+\t\t    if (probe == rtti_binfo)\n+\t\t      break;\n+\t\t  \n+\t\t  if (!probe)\n+\t\t    break;\n+\t\t  \n \t\t  primary = b;\n \t\t  orig_primary = BINFO_PRIMARY_BASE_OF (orig_primary);\n-\t\t  if (b == rtti_binfo)\n-\t\t    break;\n \t\t}\n \t    }\n \t  else"}, {"sha": "5da11ee3151b127d8694edc8ec31243892c2952a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -1627,6 +1627,10 @@ struct lang_type\n    inheritance is indicated by the absence of the other two flags, not\n    by TREE_VIA_PRIVATE, which is unused.  */\n \n+/* Mark the binfo, whether shared or not. Each instance of a virtual\n+   base can be separately marked.  */\n+#define BINFO_UNSHARED_MARKED(NODE) TREE_LANG_FLAG_0(NODE)\n+\n /* Nonzero means marked by DFS or BFS search, including searches\n    by `get_binfo' and `get_base_distance'.  */\n #define BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED(BINFO_TYPE(NODE)):TREE_LANG_FLAG_0(NODE))"}, {"sha": "01139ba0dc39bfb61210a3a4a184fd606e902777", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -1,3 +1,9 @@\n+2001-06-12  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.abi/vbase5.C: New test.\n+\t* g++.old-deja/g++.abi/vbase6.C: New test.\n+\t* g++.old-deja/g++.abi/vbase7.C: New test.\n+\n 2001-06-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.c-torture/compile/20010610-1.c: New test."}, {"sha": "6a3bbfbfb4b4119f79ed079b8ce35187302efe95", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vbase5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase5.C?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+// \n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Jun 2001 <nathan@codesourcery.com>\n+\n+// 3130. A virtual base can have canonical and non-canonical instances\n+// of its primary. The canonical one should be first in dfs order.\n+\n+struct A\n+{\n+  virtual ~A ();\n+};\n+\n+struct B\n+{\n+  virtual ~B ();\n+};\n+\n+\n+struct C : virtual public A, virtual public B {};\n+class D : public virtual C {};\n+class E : public virtual C, public virtual D {};"}, {"sha": "e8b959db32c9b97e3fc037b0a44e612f9df19a79", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vbase6.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase6.C?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -0,0 +1,22 @@\n+// Build don't link:\n+// \n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Jun 2001 <nathan@codesourcery.com>\n+\n+// 3131. \n+\n+struct A\n+{\n+  virtual ~A ();\n+};\n+\n+struct B\n+{\n+  virtual ~B ();\n+};\n+\n+\n+struct C : virtual public B {};\n+struct D : virtual public A, virtual public C {};\n+struct E : public virtual C {};\n+struct F : public virtual D, public virtual E {};"}, {"sha": "5a4a3b5fdba0872035571eb20b4b7fc5a75d3bea", "filename": "gcc/testsuite/g++.old-deja/g++.abi/vbase7.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/623fe76a4c9035ec908db4c6f61e9f191dd657aa/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fvbase7.C?ref=623fe76a4c9035ec908db4c6f61e9f191dd657aa", "patch": "@@ -0,0 +1,40 @@\n+// Build don't run\n+// \n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Jun 2001 <nathan@codesourcery.com>\n+\n+// 3132. A virtual thunk was missing.\n+\n+struct A\n+{\n+  int x;\n+  virtual ~A() {}\n+};\n+\n+struct B\n+{\n+  virtual ~B() { }\n+};\n+\n+\n+struct C\n+{\n+  virtual ~C () {}\n+};\n+\n+\n+struct D : public virtual A {};\n+struct E : virtual public B, virtual public D {};\n+struct F : virtual public C, virtual public E {};\n+struct G : public virtual E {};\n+\n+struct H : public virtual F, public virtual G\n+{\n+  virtual ~H ();\n+};\n+H::~H() {}\n+\n+int main ()\n+{\n+  return 0;\n+}"}]}