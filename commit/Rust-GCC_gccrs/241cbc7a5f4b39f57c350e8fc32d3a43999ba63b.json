{"sha": "241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxY2JjN2E1ZjRiMzlmNTdjMzUwZThmYzMyZDNhNDM5OTliYTYzYg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2015-04-15T01:27:03Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2015-04-15T01:27:03Z"}, "message": "re PR fortran/65089 (FAIL: gfortran.dg/io_real_boz(2|_[45]).f90 when tested with -fsanitize=address)\n\n2015-04-14 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/65089\n\t* io/format.h (free_format): New function to free memory\n\tallocated for building format error messages.\n\t* io/format.c (format_error): Add checks before freeing memory\n\tto avoid potential segfaults and free formatting data when\n\tneeded on error conditions. Always allocate and NULL terminate\n\tthe string.\n\t* io/transfer.c (st_read_done, st_write_done): Use new\n\tfree_format function to clean up memory allocations when done.\n\nFrom-SVN: r222111", "tree": {"sha": "069058137168dad71c78507962553db85245d69c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/069058137168dad71c78507962553db85245d69c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/comments", "author": null, "committer": null, "parents": [{"sha": "182d115c19b636d1c33ebb905029853fc68e99da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/182d115c19b636d1c33ebb905029853fc68e99da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/182d115c19b636d1c33ebb905029853fc68e99da"}], "stats": {"total": 86, "additions": 67, "deletions": 19}, "files": [{"sha": "9f53ae3e8afbce587259d76a01a42c17518b33fa", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "patch": "@@ -1,3 +1,15 @@\n+2015-04-14 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/65089\n+\t* io/format.h (free_format): New function to free memory\n+\tallocated for building format error messages.\n+\t* io/format.c (format_error): Add checks before freeing memory\n+\tto avoid potential segfaults and free formatting data when\n+\tneeded on error conditions. Always allocate and NULL terminate\n+\tthe string.\n+\t* io/transfer.c (st_read_done, st_write_done): Use new\n+\tfree_format function to clean up memory allocations when done.\n+\n 2015-03-28 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/65596"}, {"sha": "42be2586e1fc192e21617b18cbbdb11d15e0f27f", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "patch": "@@ -243,6 +243,18 @@ get_fnode (format_data *fmt, fnode **head, fnode **tail, format_token t)\n }\n \n \n+/* free_format()-- Free allocated format string.  */\n+void\n+free_format (st_parameter_dt *dtp)\n+{\n+  if ((dtp->common.flags & IOPARM_DT_HAS_FORMAT) && dtp->format)\n+    {\n+      free (dtp->format);\n+      dtp->format = NULL;\n+    }\n+}\n+\n+\n /* free_format_data()-- Free all allocated format data.  */\n \n void\n@@ -1145,7 +1157,8 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n \n   p = strchr (buffer, '\\0');\n \n-  memcpy (p, dtp->format, width);\n+  if (dtp->format)\n+    memcpy (p, dtp->format, width);\n \n   p += width;\n   *p++ = '\\n';\n@@ -1158,6 +1171,26 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n   *p++ = '^';\n   *p = '\\0';\n \n+  /* Cleanup any left over memory allocations before calling generate\n+     error.  */\n+  if (is_internal_unit (dtp))\n+    {\n+      if (dtp->format != NULL)\n+\t{\n+\t  free (dtp->format);\n+\t  dtp->format = NULL;\n+\t}\n+\n+      /* Leave these alone if IOSTAT was given because execution will\n+\t return from generate error in those cases.  */\n+      if (!(dtp->common.flags & IOPARM_HAS_IOSTAT))\n+\t{\n+\t  free (dtp->u.p.fmt);\n+\t  free_format_hash_table (dtp->u.p.current_unit);\n+\t  free_internal_unit (dtp);\n+\t}\n+    }\n+\n   generate_error (&dtp->common, LIBERROR_FORMAT, buffer);\n }\n \n@@ -1218,13 +1251,8 @@ parse_format (st_parameter_dt *dtp)\n \n   /* Not found so proceed as follows.  */\n \n-  if (format_cache_ok)\n-    {\n-      char *fmt_string = xmalloc (dtp->format_len + 1);\n-      memcpy (fmt_string, dtp->format, dtp->format_len);\n-      dtp->format = fmt_string;\n-      dtp->format[dtp->format_len] = '\\0';\n-    }\n+  char *fmt_string = fc_strdup_notrim (dtp->format, dtp->format_len);\n+  dtp->format = fmt_string;\n \n   dtp->u.p.fmt = fmt = xmalloc (sizeof (format_data));\n   fmt->format_string = dtp->format;\n@@ -1256,19 +1284,13 @@ parse_format (st_parameter_dt *dtp)\n   else\n     fmt->error = \"Missing initial left parenthesis in format\";\n \n-  if (fmt->error)\n-    {\n-      format_error (dtp, NULL, fmt->error);\n-      if (format_cache_ok)\n-\tfree (dtp->format);\n-      free_format_hash_table (dtp->u.p.current_unit);\n-      return;\n-    }\n-\n   if (format_cache_ok)\n     save_parsed_format (dtp);\n   else\n     dtp->u.p.format_not_saved = 1;\n+\n+  if (fmt->error)\n+    format_error (dtp, NULL, fmt->error);\n }\n \n "}, {"sha": "11319f468d467f36a70480464b51b392fffb0fee", "filename": "libgfortran/io/format.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Fformat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Fformat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.h?ref=241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "patch": "@@ -132,6 +132,9 @@ internal_proto(format_error);\n extern void free_format_data (struct format_data *);\n internal_proto(free_format_data);\n \n+extern void free_format (st_parameter_dt *);\n+internal_proto(free_format);\n+\n extern void free_format_hash_table (gfc_unit *);\n internal_proto(free_format_hash_table);\n "}, {"sha": "746bb6dcc6cc4f3aa64f6410808383835b344322", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241cbc7a5f4b39f57c350e8fc32d3a43999ba63b/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=241cbc7a5f4b39f57c350e8fc32d3a43999ba63b", "patch": "@@ -3711,9 +3711,15 @@ void\n st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n+  \n   if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n-    free_format_data (dtp->u.p.fmt);\n+    {\n+      free_format_data (dtp->u.p.fmt);\n+      free_format (dtp);\n+    }\n+\n   free_ionml (dtp);\n+\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n \n@@ -3764,8 +3770,13 @@ st_write_done (st_parameter_dt *dtp)\n       }\n \n   if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n-    free_format_data (dtp->u.p.fmt);\n+    {\n+      free_format_data (dtp->u.p.fmt);\n+      free_format (dtp);\n+    }\n+\n   free_ionml (dtp);\n+\n   if (dtp->u.p.current_unit != NULL)\n     unlock_unit (dtp->u.p.current_unit);\n   "}]}