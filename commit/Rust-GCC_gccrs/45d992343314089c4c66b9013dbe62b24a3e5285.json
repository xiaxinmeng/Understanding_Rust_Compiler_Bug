{"sha": "45d992343314089c4c66b9013dbe62b24a3e5285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkOTkyMzQzMzE0MDg5YzRjNjZiOTAxM2RiZTYyYjI0YTNlNTI4NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-04T20:36:27Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-04T20:36:27Z"}, "message": "tree-ssa-threadedge.c: Fix some trailing whitespace problems.\n\n        * tree-ssa-threadedge.c: Fix some trailing whitespace problems.\n\n        * tree-ssa-threadedge.c (thread_through_normal_block): Broken out of ...\n        (thread_across_edge): Here.  Call it.\n\nFrom-SVN: r203217", "tree": {"sha": "5ffa74103db939eef2677c4a3e07c78c23239f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ffa74103db939eef2677c4a3e07c78c23239f87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d992343314089c4c66b9013dbe62b24a3e5285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d992343314089c4c66b9013dbe62b24a3e5285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d992343314089c4c66b9013dbe62b24a3e5285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d992343314089c4c66b9013dbe62b24a3e5285/comments", "author": null, "committer": null, "parents": [{"sha": "8a2cb59f1c4a4822f727a5cd8fdfc7d87636508e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a2cb59f1c4a4822f727a5cd8fdfc7d87636508e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a2cb59f1c4a4822f727a5cd8fdfc7d87636508e"}], "stats": {"total": 121, "additions": 88, "deletions": 33}, "files": [{"sha": "cf4a45cb4359677599e92f58fbc9d1195061eb3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d992343314089c4c66b9013dbe62b24a3e5285/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d992343314089c4c66b9013dbe62b24a3e5285/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45d992343314089c4c66b9013dbe62b24a3e5285", "patch": "@@ -1,3 +1,10 @@\n+2013-10-04  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c: Fix some trailing whitespace problems.\n+\n+\t* tree-ssa-threadedge.c (thread_through_normal_block): Broken out of ...\n+\t(thread_across_edge): Here.  Call it.\n+\n 2013-10-04  Cary Coutant  <ccoutant@google.com>\n \n \t* dwarf2out.c (dw_sra_loc_expr): Release addr_table entries when"}, {"sha": "c2dd0155697e7ab5a541e054c3df1091aada8cd4", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 81, "deletions": 33, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d992343314089c4c66b9013dbe62b24a3e5285/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d992343314089c4c66b9013dbe62b24a3e5285/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=45d992343314089c4c66b9013dbe62b24a3e5285", "patch": "@@ -771,15 +771,15 @@ thread_around_empty_blocks (edge taken_edge,\n   gsi = gsi_start_nondebug_bb (bb);\n \n   /* If the block has no statements, but does have a single successor, then\n-     it's just a forwarding block and we can thread through it trivially. \n+     it's just a forwarding block and we can thread through it trivially.\n \n      However, note that just threading through empty blocks with single\n      successors is not inherently profitable.  For the jump thread to\n      be profitable, we must avoid a runtime conditional.\n \n      By taking the return value from the recursive call, we get the\n      desired effect of returning TRUE when we found a profitable jump\n-     threading opportunity and FALSE otherwise. \n+     threading opportunity and FALSE otherwise.\n \n      This is particularly important when this routine is called after\n      processing a joiner block.  Returning TRUE too aggressively in\n@@ -844,25 +844,23 @@ thread_around_empty_blocks (edge taken_edge,\n \t\t\t\t  path);\n       return true;\n     }\n- \n+\n   return false;\n }\n-      \n+\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n+   E->dest can have arbitrary side effects which, if threading is\n+   successful, will be maintained.\n+\n    Special care is necessary if E is a back edge in the CFG as we\n    may have already recorded equivalences for E->dest into our\n    various tables, including the result of the conditional at\n    the end of E->dest.  Threading opportunities are severely\n    limited in that case to avoid short-circuiting the loop\n    incorrectly.\n \n-   Note it is quite common for the first block inside a loop to\n-   end with a conditional which is either always true or always\n-   false when reached via the loop backedge.  Thus we do not want\n-   to blindly disable threading across a loop backedge.\n-\n    DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n    to avoid allocating memory.\n \n@@ -873,38 +871,39 @@ thread_around_empty_blocks (edge taken_edge,\n    STACK is used to undo temporary equivalences created during the walk of\n    E->dest.\n \n-   SIMPLIFY is a pass-specific function used to simplify statements.  */\n+   SIMPLIFY is a pass-specific function used to simplify statements.\n \n-void\n-thread_across_edge (gimple dummy_cond,\n-\t\t    edge e,\n-\t\t    bool handle_dominating_asserts,\n-\t\t    vec<tree> *stack,\n-\t\t    tree (*simplify) (gimple, gimple))\n-{\n-  gimple stmt;\n+   Our caller is responsible for restoring the state of the expression\n+   and const_and_copies stacks.  */\n \n+static bool\n+thread_through_normal_block (edge e,\n+\t\t\t     gimple dummy_cond,\n+\t\t\t     bool handle_dominating_asserts,\n+\t\t\t     vec<tree> *stack,\n+\t\t\t     tree (*simplify) (gimple, gimple),\n+\t\t\t     vec<jump_thread_edge *> *path)\n+{\n   /* If E is a backedge, then we want to verify that the COND_EXPR,\n      SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected\n      by any statements in e->dest.  If it is affected, then it is not\n      safe to thread this edge.  */\n   if (e->flags & EDGE_DFS_BACK)\n     {\n       if (cond_arg_set_in_bb (e, e->dest))\n-\tgoto fail;\n+\treturn false;\n     }\n \n-  stmt_count = 0;\n-\n   /* PHIs create temporary equivalences.  */\n   if (!record_temporary_equivalences_from_phis (e, stack))\n-    goto fail;\n+    return false;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n-  stmt = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify);\n+  gimple stmt\n+    = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify);\n   if (!stmt)\n-    goto fail;\n+    return false;\n \n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n      will be taken.  */\n@@ -927,9 +926,8 @@ thread_across_edge (gimple dummy_cond,\n \t  /* DEST could be NULL for a computed jump to an absolute\n \t     address.  */\n \t  if (dest == NULL || dest == e->dest)\n-\t    goto fail;\n+\t    return false;\n \n-\t  vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n           jump_thread_edge *x\n \t    = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n \t  path->safe_push (x);\n@@ -956,14 +954,65 @@ thread_across_edge (gimple dummy_cond,\n \t\t\t\t\t  path);\n \t      BITMAP_FREE (visited);\n \t    }\n-\n-\t  remove_temporary_equivalences (stack);\n-\t  propagate_threaded_block_debug_into (path->last ()->e->dest,\n-\t\t\t\t\t       e->dest);\n-\t  register_jump_thread (path);\n-\t  return;\n+\t  return true;\n \t}\n     }\n+  return false;\n+}\n+\n+/* We are exiting E->src, see if E->dest ends with a conditional\n+   jump which has a known value when reached via E.\n+\n+   Special care is necessary if E is a back edge in the CFG as we\n+   may have already recorded equivalences for E->dest into our\n+   various tables, including the result of the conditional at\n+   the end of E->dest.  Threading opportunities are severely\n+   limited in that case to avoid short-circuiting the loop\n+   incorrectly.\n+\n+   Note it is quite common for the first block inside a loop to\n+   end with a conditional which is either always true or always\n+   false when reached via the loop backedge.  Thus we do not want\n+   to blindly disable threading across a loop backedge.\n+\n+   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,\n+   to avoid allocating memory.\n+\n+   HANDLE_DOMINATING_ASSERTS is true if we should try to replace operands of\n+   the simplified condition with left-hand sides of ASSERT_EXPRs they are\n+   used in.\n+\n+   STACK is used to undo temporary equivalences created during the walk of\n+   E->dest.\n+\n+   SIMPLIFY is a pass-specific function used to simplify statements.  */\n+\n+void\n+thread_across_edge (gimple dummy_cond,\n+\t\t    edge e,\n+\t\t    bool handle_dominating_asserts,\n+\t\t    vec<tree> *stack,\n+\t\t    tree (*simplify) (gimple, gimple))\n+{\n+  stmt_count = 0;\n+\n+  vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n+  if (thread_through_normal_block (e, dummy_cond, handle_dominating_asserts,\n+\t\t\t\t   stack, simplify, path))\n+    {\n+      propagate_threaded_block_debug_into (path->last ()->e->dest,\n+\t\t\t\t\t   e->dest);\n+      remove_temporary_equivalences (stack);\n+      register_jump_thread (path);\n+      return;\n+    }\n+  else\n+    {\n+      /* There should be no edges on the path, so no need to walk through\n+\t the vector entries.  */\n+      gcc_assert (path->length () == 0);\n+      path->release ();\n+    }\n \n  /* We were unable to determine what out edge from E->dest is taken.  However,\n     we might still be able to thread through successors of E->dest.  This\n@@ -1026,6 +1075,5 @@ thread_across_edge (gimple dummy_cond,\n     BITMAP_FREE (visited);\n   }\n \n- fail:\n   remove_temporary_equivalences (stack);\n }"}]}