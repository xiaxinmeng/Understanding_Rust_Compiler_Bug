{"sha": "9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUzYmUzNmU0NjViMDY5OWQxNjFlMWUxZmY5YTc4ZmQyMTZjMmM2MA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2016-06-20T12:27:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-20T12:27:05Z"}, "message": "sem_ch13.adb (Visible_Component): New procedure...\n\n2016-06-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Visible_Component): New procedure, subsidiary\n\tof Replace_Type_References_ Generic, to determine whether an\n\tidentifier in a predicate or invariant expression is a visible\n\tcomponent of the type to which the predicate or invariant\n\tapplies. Implements the visibility rule stated in RM 13.1.1\n\t(12/3).\n\nFrom-SVN: r237599", "tree": {"sha": "0188bb4ed9f12c4b185d27885c4814bbb1d172e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0188bb4ed9f12c4b185d27885c4814bbb1d172e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3be36e465b0699d161e1e1ff9a78fd216c2c60/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f8d7dfe21740d1066912f2f99b83096ebf2962b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f8d7dfe21740d1066912f2f99b83096ebf2962b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f8d7dfe21740d1066912f2f99b83096ebf2962b"}], "stats": {"total": 97, "additions": 93, "deletions": 4}, "files": [{"sha": "0f7c8352082ba188fb5c2f6f193b7629deb84ace", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e3be36e465b0699d161e1e1ff9a78fd216c2c60/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e3be36e465b0699d161e1e1ff9a78fd216c2c60/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "patch": "@@ -1,3 +1,12 @@\n+2016-06-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Visible_Component): New procedure, subsidiary\n+\tof Replace_Type_References_ Generic, to determine whether an\n+\tidentifier in a predicate or invariant expression is a visible\n+\tcomponent of the type to which the predicate or invariant\n+\tapplies. Implements the visibility rule stated in RM 13.1.1\n+\t(12/3).\n+\n 2016-06-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* s-regpat.adb, sem_prag.adb, pprint.adb, sem_ch13.adb: Minor"}, {"sha": "9d2a0bdd25a50a1652d68d6d4ef1b5057c087b73", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 84, "deletions": 4, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e3be36e465b0699d161e1e1ff9a78fd216c2c60/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e3be36e465b0699d161e1e1ff9a78fd216c2c60/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=9e3be36e465b0699d161e1e1ff9a78fd216c2c60", "patch": "@@ -12298,17 +12298,44 @@ package body Sem_Ch13 is\n       --  Processes a single node in the traversal procedure below, checking\n       --  if node N should be replaced, and if so, doing the replacement.\n \n+      function Visible_Component (Comp : Name_Id) return Entity_Id;\n+      --  Given an identifier in the expression, check whether there is a\n+      --  discriminant or component of the type that is directy visible, and\n+      --  rewrite it as the corresponding selected component of the formal of\n+      --  the subprogram. The entity is located by a sequential search, which\n+      --  seems acceptable given the typical size of component lists and check\n+      --  expressions. Possible optimization ???\n+\n       ----------------------\n       -- Replace_Type_Ref --\n       ----------------------\n \n       function Replace_Type_Ref (N : Node_Id) return Traverse_Result is\n-         S : Entity_Id;\n-         P : Node_Id;\n+         Loc : constant Source_Ptr := Sloc (N);\n+         C   : Entity_Id;\n+         S   : Entity_Id;\n+         P   : Node_Id;\n \n-      begin\n-         --  Case of identifier\n+         procedure Add_Prefix (Ref : Node_Id; Comp : Entity_Id);\n+         --  Add the proper prefix to a reference to a component of the\n+         --  type when it is not already a selected component.\n+\n+         ----------------\n+         -- Add_Prefix --\n+         ----------------\n \n+         procedure Add_Prefix (Ref : Node_Id; Comp : Entity_Id) is\n+         begin\n+            Rewrite (Ref,\n+              Make_Selected_Component (Loc,\n+                Prefix => New_Occurrence_Of (T, Loc),\n+                Selector_Name => New_Occurrence_Of (Comp, Loc)));\n+            Replace_Type_Reference (Prefix (Ref));\n+         end Add_Prefix;\n+\n+      --  Start of processing for Replace_Type_Ref\n+\n+      begin\n          if Nkind (N) = N_Identifier then\n \n             --  If not the type name, check whether it is a reference to some\n@@ -12323,6 +12350,33 @@ package body Sem_Ch13 is\n                   Freeze_Before (Freeze_Node (T), Current_Entity (N));\n                end if;\n \n+               --  The components of the type are directly visible and can\n+               --  be referenced without a prefix.\n+\n+               if Nkind (Parent (N)) = N_Selected_Component then\n+                  null;\n+\n+               --  In expression C (I), C may be a directly visible function\n+               --  or a visible component that has an array type. Disambiguate\n+               --  by examining the component type.\n+\n+               elsif Nkind (Parent (N)) = N_Indexed_Component\n+                 and then N = Prefix (Parent (N))\n+               then\n+                  C := Visible_Component (Chars (N));\n+\n+                  if Present (C) and then Is_Array_Type (Etype (C)) then\n+                     Add_Prefix (N, C);\n+                  end if;\n+\n+               else\n+                  C := Visible_Component (Chars (N));\n+\n+                  if Present (C) then\n+                     Add_Prefix (N, C);\n+                  end if;\n+               end if;\n+\n                return Skip;\n \n             --  Otherwise do the replacement and we are done with this node\n@@ -12397,6 +12451,32 @@ package body Sem_Ch13 is\n          end if;\n       end Replace_Type_Ref;\n \n+      -----------------------\n+      -- Visible_Component --\n+      -----------------------\n+\n+      function Visible_Component (Comp : Name_Id) return Entity_Id is\n+         E : Entity_Id;\n+      begin\n+         if Ekind (T) /= E_Record_Type then\n+            return Empty;\n+\n+         else\n+            E := First_Entity (T);\n+            while Present (E) loop\n+               if Comes_From_Source (E)\n+                 and then Chars (E) = Comp\n+               then\n+                  return E;\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+\n+            return Empty;\n+         end if;\n+      end Visible_Component;\n+\n       procedure Replace_Type_Refs is new Traverse_Proc (Replace_Type_Ref);\n \n    begin"}]}