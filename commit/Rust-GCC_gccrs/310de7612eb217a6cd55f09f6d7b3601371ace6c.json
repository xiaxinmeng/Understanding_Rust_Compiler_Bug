{"sha": "310de7612eb217a6cd55f09f6d7b3601371ace6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwZGU3NjEyZWIyMTdhNmNkNTVmMDlmNmQ3YjM2MDEzNzFhY2U2Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-16T02:26:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-16T02:26:47Z"}, "message": "tree-ssa-operands.c (get_expr_operands): Use a switch.\n\n        * tree-ssa-operands.c (get_expr_operands): Use a switch.  Split out...\n        (get_indirect_ref_operands, get_call_expr_operands): ... these.\n\nFrom-SVN: r84798", "tree": {"sha": "9ead538a57becb4654de90f43b18c68e97fa831a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ead538a57becb4654de90f43b18c68e97fa831a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/310de7612eb217a6cd55f09f6d7b3601371ace6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310de7612eb217a6cd55f09f6d7b3601371ace6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310de7612eb217a6cd55f09f6d7b3601371ace6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310de7612eb217a6cd55f09f6d7b3601371ace6c/comments", "author": null, "committer": null, "parents": [{"sha": "bc03b358a0a7f5acbc38c0e650ea5063080191ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc03b358a0a7f5acbc38c0e650ea5063080191ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc03b358a0a7f5acbc38c0e650ea5063080191ef"}], "stats": {"total": 461, "additions": 230, "deletions": 231}, "files": [{"sha": "bc412fce20245d6962124211ebbf75725eaed7a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310de7612eb217a6cd55f09f6d7b3601371ace6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310de7612eb217a6cd55f09f6d7b3601371ace6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=310de7612eb217a6cd55f09f6d7b3601371ace6c", "patch": "@@ -1,3 +1,8 @@\n+2004-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-ssa-operands.c (get_expr_operands): Use a switch.  Split out...\n+\t(get_indirect_ref_operands, get_call_expr_operands): ... these.\n+\n 2004-07-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h (VEC_address): New function."}, {"sha": "c032c9e46d030a3459c784d3f9a860b1fb6f1f67", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 225, "deletions": 231, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310de7612eb217a6cd55f09f6d7b3601371ace6c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310de7612eb217a6cd55f09f6d7b3601371ace6c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=310de7612eb217a6cd55f09f6d7b3601371ace6c", "patch": "@@ -81,6 +81,8 @@ typedef struct voperands_d\n static void note_addressable (tree, stmt_ann_t);\n static void get_expr_operands (tree, tree *, int, voperands_t);\n static void get_asm_expr_operands (tree, voperands_t);\n+static void get_indirect_ref_operands (tree, tree, int, voperands_t);\n+static void get_call_expr_operands (tree, tree, voperands_t);\n static inline void append_def (tree *, tree);\n static inline void append_use (tree *, tree);\n static void append_v_may_def (tree, tree, voperands_t);\n@@ -846,10 +848,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n   code = TREE_CODE (expr);\n   class = TREE_CODE_CLASS (code);\n \n-  /* We could have the address of a component, array member, etc which\n-     has interesting variable references.  */\n-  if (code == ADDR_EXPR)\n+  switch (code)\n     {\n+    case ADDR_EXPR:\n+      /* We could have the address of a component, array member,\n+\t etc which has interesting variable references.  */\n       /* Taking the address of a variable does not represent a\n \t reference to it, but the fact that STMT takes its address will be\n \t of interest to some passes (e.g. alias resolution).  */\n@@ -866,132 +869,28 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n \t does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n \n-      /* Avoid recursion.  */\n-      expr_p = &TREE_OPERAND (expr, 0);\n-      expr = *expr_p;\n-      code =  TREE_CODE (expr);\n-      class = TREE_CODE_CLASS (code);\n-    }\n-\n-  /* Expressions that make no memory references.  */\n-  if (class == 'c'\n-      || class == 't'\n-      || code == BLOCK\n-      || code == FUNCTION_DECL\n-      || code == EXC_PTR_EXPR\n-      || code == FILTER_EXPR\n-      || code == LABEL_DECL)\n-    return;\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+      return;\n \n-  /* If we found a variable, add it to DEFS or USES depending on the\n-     operand flags.  */\n-  if (SSA_VAR_P (expr))\n-    {\n+    case SSA_NAME:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      /* If we found a variable, add it to DEFS or USES depending\n+\t on the operand flags.  */\n       add_stmt_operand (expr_p, stmt, flags, prev_vops);\n       return;\n-    }\n-\n-  /* Pointer dereferences always represent a use of the base pointer.  */\n-  if (code == INDIRECT_REF)\n-    {\n-      tree *pptr = &TREE_OPERAND (expr, 0);\n-      tree ptr = *pptr;\n-\n-      if (SSA_VAR_P (ptr))\n-\t{\n-\t  if (!aliases_computed_p)\n-\t    {\n-\t      /* If the pointer does not have a memory tag and aliases have not\n-\t\t been computed yet, mark the statement as having volatile\n-\t\t operands to prevent DOM from entering it in equivalence tables\n-\t\t and DCE from killing it.  */\n-\t      stmt_ann (stmt)->has_volatile_ops = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      struct ptr_info_def *pi = NULL;\n-\n-\t      /* If we have computed aliasing already, check if PTR has\n-\t\t flow-sensitive points-to information.  */\n-\t      if (TREE_CODE (ptr) == SSA_NAME\n-\t\t  && (pi = SSA_NAME_PTR_INFO (ptr)) != NULL\n-\t\t  && pi->name_mem_tag)\n-\t\t{\n-\t\t  /* PTR has its own memory tag.  Use it.  */\n-\t\t  add_stmt_operand (&pi->name_mem_tag, stmt, flags,\n-\t\t                    prev_vops);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* If PTR is not an SSA_NAME or it doesn't have a name\n-\t\t     tag, use its type memory tag.  */\n-\t\t  var_ann_t ann;\n-\n-\t\t  /* If we are emitting debugging dumps, display a warning if\n-\t\t     PTR is an SSA_NAME with no flow-sensitive alias\n-\t\t     information.  That means that we may need to compute\n-\t\t     aliasing again.  */\n-\t\t  if (dump_file\n-\t\t      && TREE_CODE (ptr) == SSA_NAME\n-\t\t      && pi == NULL)\n-\t\t    {\n-\t\t      fprintf (dump_file,\n-\t\t\t  \"NOTE: no flow-sensitive alias info for \");\n-\t\t      print_generic_expr (dump_file, ptr, dump_flags);\n-\t\t      fprintf (dump_file, \" in \");\n-\t\t      print_generic_stmt (dump_file, stmt, dump_flags);\n-\t\t    }\n-\n-\t\t  if (TREE_CODE (ptr) == SSA_NAME)\n-\t\t    ptr = SSA_NAME_VAR (ptr);\n-\t\t  ann = var_ann (ptr);\n-\t\t  add_stmt_operand (&ann->type_mem_tag, stmt, flags, prev_vops);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If a constant is used as a pointer, we can't generate a real\n-\t operand for it but we mark the statement volatile to prevent\n-\t optimizations from messing things up.  */\n-      else if (TREE_CODE (ptr) == INTEGER_CST)\n-\t{\n-\t  stmt_ann (stmt)->has_volatile_ops = true;\n-\t  return;\n-\t}\n-\n-      /* Everything else *should* have been folded elsewhere, but users\n-\t are smarter than we in finding ways to write invalid code.  We\n-\t cannot just abort here.  If we were absolutely certain that we\n-\t do handle all valid cases, then we could just do nothing here.\n-\t That seems optimistic, so attempt to do something logical... */\n-      else if ((TREE_CODE (ptr) == PLUS_EXPR || TREE_CODE (ptr) == MINUS_EXPR)\n-\t       && TREE_CODE (TREE_OPERAND (ptr, 0)) == ADDR_EXPR\n-\t       && TREE_CODE (TREE_OPERAND (ptr, 1)) == INTEGER_CST)\n-\t{\n-\t  /* Make sure we know the object is addressable.  */\n-\t  pptr = &TREE_OPERAND (ptr, 0);\n-          add_stmt_operand (pptr, stmt, 0, NULL);\n-\n-\t  /* Mark the object itself with a VUSE.  */\n-\t  pptr = &TREE_OPERAND (*pptr, 0);\n-\t  get_expr_operands (stmt, pptr, flags, prev_vops);\n-\t  return;\n-\t}\n-\n-      /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n-      else\n-\tabort ();\n \n-      /* Add a USE operand for the base pointer.  */\n-      get_expr_operands (stmt, pptr, opf_none, prev_vops);\n+    case INDIRECT_REF:\n+      get_indirect_ref_operands (stmt, expr, flags, prev_vops);\n       return;\n-    }\n \n-  /* Treat array references as references to the virtual variable\n-     representing the array.  The virtual variable for an ARRAY_REF\n-     is the VAR_DECL for the array.  */\n-  if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n-    {\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      /* Treat array references as references to the virtual variable\n+\t representing the array.  The virtual variable for an ARRAY_REF\n+\t is the VAR_DECL for the array.  */\n+\n       /* Add the virtual variable for the ARRAY_REF to VDEFS or VUSES\n \t according to the value of IS_DEF.  Recurse if the LHS of the\n \t ARRAY_REF node is not a regular variable.  */\n@@ -1004,22 +903,23 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none, prev_vops);\n       return;\n-    }\n \n-  /* Similarly to arrays, references to compound variables (complex types\n-     and structures/unions) are globbed.\n+    case COMPONENT_REF:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      /* Similarly to arrays, references to compound variables (complex\n+\t types and structures/unions) are globbed.\n \n-     FIXME: This means that\n+\t FIXME: This means that\n \n      \t\t\ta.x = 6;\n \t\t\ta.y = 7;\n \t\t\tfoo (a.x, a.y);\n \n-\t   will not be constant propagated because the two partial\n-\t   definitions to 'a' will kill each other.  Note that SRA may be\n-\t   able to fix this problem if 'a' can be scalarized.  */\n-  if (code == IMAGPART_EXPR || code == REALPART_EXPR || code == COMPONENT_REF)\n-    {\n+\t will not be constant propagated because the two partial\n+\t definitions to 'a' will kill each other.  Note that SRA may be\n+\t able to fix this problem if 'a' can be scalarized.  */\n+\n       /* If the LHS of the compound reference is not a regular variable,\n \t recurse to keep looking for more operands in the subexpression.  */\n       if (SSA_VAR_P (TREE_OPERAND (expr, 0)))\n@@ -1030,56 +930,14 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       if (code == COMPONENT_REF)\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n       return;\n-    }\n-\n-  /* Function calls.  Add every argument to USES.  If the callee is\n-     neither pure nor const, create a VDEF reference for GLOBAL_VAR\n-     (See find_vars_r).  */\n-  if (code == CALL_EXPR)\n-    {\n-      tree op;\n-      int call_flags = call_expr_flags (expr);\n-\n-      /* Find uses in the called function.  */\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_none, prev_vops);\n-\n-      for (op = TREE_OPERAND (expr, 1); op; op = TREE_CHAIN (op))\n-        get_expr_operands (stmt, &TREE_VALUE (op), opf_none, prev_vops);\n-\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n-\n-      if (bitmap_first_set_bit (call_clobbered_vars) >= 0)\n-\t{\n-\t  /* A 'pure' or a 'const' functions never call clobber anything. \n-\t     A 'noreturn' function might, but since we don't return anyway \n-\t     there is no point in recording that.  */ \n-\t  if (!(call_flags\n-\t\t& (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n-\t    add_call_clobber_ops (stmt, prev_vops);\n-\t  else if (!(call_flags & (ECF_CONST | ECF_NORETURN)))\n-\t    add_call_read_ops (stmt, prev_vops);\n-\t}\n-      else if (!aliases_computed_p)\n-\tstmt_ann (stmt)->has_volatile_ops = true;\n-\n-      return;\n-    }\n-\n-  /* Lists.  */\n-  if (code == TREE_LIST)\n-    {\n-      tree op;\n-\n-      for (op = expr; op; op = TREE_CHAIN (op))\n-        get_expr_operands (stmt, &TREE_VALUE (op), flags, prev_vops);\n \n+    case CALL_EXPR:\n+      get_call_expr_operands (stmt, expr, prev_vops);\n       return;\n-    }\n \n-  /* Assignments.  */\n-  if (code == MODIFY_EXPR)\n-    {\n+    case MODIFY_EXPR:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none, prev_vops);\n+\n       if (TREE_CODE (TREE_OPERAND (expr, 0)) == ARRAY_REF \n           || TREE_CODE (TREE_OPERAND (expr, 0)) == COMPONENT_REF\n \t  || TREE_CODE (TREE_OPERAND (expr, 0)) == REALPART_EXPR\n@@ -1090,71 +948,79 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n         get_expr_operands (stmt, &TREE_OPERAND (expr, 0), \n \t                   opf_is_def | opf_kill_def, prev_vops);\n       return;\n-    }\n-\n \n-  /* Mark VA_ARG_EXPR nodes as making volatile references.  FIXME,\n-     this is needed because we currently do not gimplify VA_ARG_EXPR\n-     properly.  */\n-  if (code == VA_ARG_EXPR)\n-    {\n+    case VA_ARG_EXPR:\n+      /* Mark VA_ARG_EXPR nodes as making volatile references.  FIXME,\n+\t this is needed because we currently do not gimplify VA_ARG_EXPR\n+\t properly.  */\n       stmt_ann (stmt)->has_volatile_ops = true;\n       return;\n-    }\n \n-  /* Unary expressions.  */\n-  if (class == '1'\n-      || code == TRUTH_NOT_EXPR\n-      || code == BIT_FIELD_REF\n-      || code == CONSTRUCTOR)\n-    {\n+    case TRUTH_NOT_EXPR:\n+    case BIT_FIELD_REF:\n+    do_unary:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n       return;\n-    }\n \n-  /* Binary expressions.  */\n-  if (class == '2'\n-      || class == '<'\n-      || code == TRUTH_AND_EXPR\n-      || code == TRUTH_OR_EXPR\n-      || code == TRUTH_XOR_EXPR\n-      || code == COMPOUND_EXPR\n-      || code == OBJ_TYPE_REF)\n-    {\n-      tree op0 = TREE_OPERAND (expr, 0);\n-      tree op1 = TREE_OPERAND (expr, 1);\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case COMPOUND_EXPR:\n+    case OBJ_TYPE_REF:\n+    do_binary:\n+      {\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\ttree op1 = TREE_OPERAND (expr, 1);\n \n-      /* If it would be profitable to swap the operands, then do so to\n-\t canonicalize the statement, enabling better optimization.\n+\t/* If it would be profitable to swap the operands, then do so to\n+\t   canonicalize the statement, enabling better optimization.\n \n-\t By placing canonicalization of such expressions here we\n-\t transparently keep statements in canonical form, even\n-\t when the statement is modified.  */\n-      if (tree_swap_operands_p (op0, op1, false))\n-\t{\n-\t  /* For relationals we need to swap the operands and change\n-\t     the code.  */\n-\t  if (code == LT_EXPR\n-\t      || code == GT_EXPR\n-\t      || code == LE_EXPR\n-\t      || code == GE_EXPR)\n-\t    {\n-\t      TREE_SET_CODE (expr, swap_tree_comparison (code));\n-\t      TREE_OPERAND (expr, 0) = op1;\n-\t      TREE_OPERAND (expr, 1) = op0;\n-\t    }\n+\t   By placing canonicalization of such expressions here we\n+\t   transparently keep statements in canonical form, even\n+\t   when the statement is modified.  */\n+\tif (tree_swap_operands_p (op0, op1, false))\n+\t  {\n+\t    /* For relationals we need to swap the operands\n+\t       and change the code.  */\n+\t    if (code == LT_EXPR\n+\t\t|| code == GT_EXPR\n+\t\t|| code == LE_EXPR\n+\t\t|| code == GE_EXPR)\n+\t      {\n+\t\tTREE_SET_CODE (expr, swap_tree_comparison (code));\n+\t\tTREE_OPERAND (expr, 0) = op1;\n+\t\tTREE_OPERAND (expr, 1) = op0;\n+\t      }\n \t  \n-\t  /* For a commutative operator we can just swap the operands.  */\n-\t  if (commutative_tree_code (code))\n-\t    {\n-\t      TREE_OPERAND (expr, 0) = op1;\n-\t      TREE_OPERAND (expr, 1) = op0;\n-\t    }\n-\t}\n+\t    /* For a commutative operator we can just swap the operands.  */\n+\t    else if (commutative_tree_code (code))\n+\t      {\n+\t\tTREE_OPERAND (expr, 0) = op1;\n+\t\tTREE_OPERAND (expr, 1) = op0;\n+\t      }\n+\t  }\n \n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags, prev_vops);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags, prev_vops);\n+\treturn;\n+      }\n+\n+    case BLOCK:\n+    case FUNCTION_DECL:\n+    case EXC_PTR_EXPR:\n+    case FILTER_EXPR:\n+    case LABEL_DECL:\n+    case CONSTRUCTOR:\n+      /* Expressions that make no memory references.  */\n       return;\n+\n+    default:\n+      if (class == '1')\n+\tgoto do_unary;\n+      if (class == '2' || class == '<')\n+\tgoto do_binary;\n+      if (class == 'c' || class == 't')\n+\treturn;\n     }\n \n   /* If we get here, something has gone wrong.  */\n@@ -1260,6 +1126,134 @@ get_asm_expr_operands (tree stmt, voperands_t prev_vops)\n       }\n }\n \n+/* A subroutine of get_expr_operands to handle INDIRECT_REF.  */\n+\n+static void\n+get_indirect_ref_operands (tree stmt, tree expr, int flags,\n+\t\t\t   voperands_t prev_vops)\n+{\n+  tree *pptr = &TREE_OPERAND (expr, 0);\n+  tree ptr = *pptr;\n+\n+  if (SSA_VAR_P (ptr))\n+    {\n+      if (!aliases_computed_p)\n+\t{\n+\t  /* If the pointer does not have a memory tag and aliases have not\n+\t     been computed yet, mark the statement as having volatile\n+\t     operands to prevent DOM from entering it in equivalence tables\n+\t     and DCE from killing it.  */\n+\t  stmt_ann (stmt)->has_volatile_ops = true;\n+\t}\n+      else\n+\t{\n+\t  struct ptr_info_def *pi = NULL;\n+\n+\t  /* If we have computed aliasing already, check if PTR has\n+\t     flow-sensitive points-to information.  */\n+\t  if (TREE_CODE (ptr) == SSA_NAME\n+\t      && (pi = SSA_NAME_PTR_INFO (ptr)) != NULL\n+\t      && pi->name_mem_tag)\n+\t    {\n+\t      /* PTR has its own memory tag.  Use it.  */\n+\t      add_stmt_operand (&pi->name_mem_tag, stmt, flags, prev_vops);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If PTR is not an SSA_NAME or it doesn't have a name\n+\t\t tag, use its type memory tag.  */\n+\t      var_ann_t ann;\n+\n+\t      /* If we are emitting debugging dumps, display a warning if\n+\t\t PTR is an SSA_NAME with no flow-sensitive alias\n+\t\t information.  That means that we may need to compute\n+\t\t aliasing again.  */\n+\t      if (dump_file\n+\t\t  && TREE_CODE (ptr) == SSA_NAME\n+\t\t  && pi == NULL)\n+\t\t{\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"NOTE: no flow-sensitive alias info for \");\n+\t\t  print_generic_expr (dump_file, ptr, dump_flags);\n+\t\t  fprintf (dump_file, \" in \");\n+\t\t  print_generic_stmt (dump_file, stmt, dump_flags);\n+\t\t}\n+\n+\t      if (TREE_CODE (ptr) == SSA_NAME)\n+\t\tptr = SSA_NAME_VAR (ptr);\n+\t      ann = var_ann (ptr);\n+\t      add_stmt_operand (&ann->type_mem_tag, stmt, flags, prev_vops);\n+\t    }\n+\t}\n+    }\n+\n+  /* If a constant is used as a pointer, we can't generate a real\n+     operand for it but we mark the statement volatile to prevent\n+     optimizations from messing things up.  */\n+  else if (TREE_CODE (ptr) == INTEGER_CST)\n+    {\n+      stmt_ann (stmt)->has_volatile_ops = true;\n+      return;\n+    }\n+\n+  /* Everything else *should* have been folded elsewhere, but users\n+     are smarter than we in finding ways to write invalid code.  We\n+     cannot just abort here.  If we were absolutely certain that we\n+     do handle all valid cases, then we could just do nothing here.\n+     That seems optimistic, so attempt to do something logical... */\n+  else if ((TREE_CODE (ptr) == PLUS_EXPR || TREE_CODE (ptr) == MINUS_EXPR)\n+\t   && TREE_CODE (TREE_OPERAND (ptr, 0)) == ADDR_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (ptr, 1)) == INTEGER_CST)\n+    {\n+      /* Make sure we know the object is addressable.  */\n+      pptr = &TREE_OPERAND (ptr, 0);\n+      add_stmt_operand (pptr, stmt, 0, NULL);\n+\n+      /* Mark the object itself with a VUSE.  */\n+      pptr = &TREE_OPERAND (*pptr, 0);\n+      get_expr_operands (stmt, pptr, flags, prev_vops);\n+      return;\n+    }\n+\n+  /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n+  else\n+    abort ();\n+\n+  /* Add a USE operand for the base pointer.  */\n+  get_expr_operands (stmt, pptr, opf_none, prev_vops);\n+}\n+\n+/* A subroutine of get_expr_operands to handle CALL_EXPR.  */\n+\n+static void\n+get_call_expr_operands (tree stmt, tree expr, voperands_t prev_vops)\n+{\n+  tree op;\n+  int call_flags = call_expr_flags (expr);\n+\n+  /* Find uses in the called function.  */\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_none, prev_vops);\n+\n+  for (op = TREE_OPERAND (expr, 1); op; op = TREE_CHAIN (op))\n+    get_expr_operands (stmt, &TREE_VALUE (op), opf_none, prev_vops);\n+\n+  get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none, prev_vops);\n+\n+  if (bitmap_first_set_bit (call_clobbered_vars) >= 0)\n+    {\n+      /* A 'pure' or a 'const' functions never call clobber anything. \n+\t A 'noreturn' function might, but since we don't return anyway \n+\t there is no point in recording that.  */ \n+      if (!(call_flags\n+\t    & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n+\tadd_call_clobber_ops (stmt, prev_vops);\n+      else if (!(call_flags & (ECF_CONST | ECF_NORETURN)))\n+\tadd_call_read_ops (stmt, prev_vops);\n+    }\n+  else if (!aliases_computed_p)\n+    stmt_ann (stmt)->has_volatile_ops = true;\n+}\n+\n \n /* Add *VAR_P to the appropriate operand array of STMT.  FLAGS is as in\n    get_expr_operands.  If *VAR_P is a GIMPLE register, it will be added to"}]}