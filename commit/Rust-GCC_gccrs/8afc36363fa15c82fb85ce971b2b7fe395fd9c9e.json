{"sha": "8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFmYzM2MzYzZmExNWM4MmZiODVjZTk3MWIyYjdmZTM5NWZkOWM5ZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-05-20T23:31:35Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-05-20T23:31:35Z"}, "message": "predicates.md (input_operand): Don't match constant pool addresses.\n\n\t* config/rs6000/predicates.md (input_operand): Don't match\n\tconstant pool addresses.  Remove label_ref, high and plus from\n\tmatch_code list.  Remove redundant CONSTANT_P test.\n\t(splat_input_operand): Similarly update match_code list.\n\t(small_toc_ref): New predicate.\n\t* config/rs6000/rs6000-protos.h (toc_relative_expr_p): Update prototype.\n\t* config/rs6000/rs6000.c (tocrel_base, tocrel_offset): Make const.\n\t(legitimate_constant_pool_address_p): Move TARGET_TOC test and\n\tregister checks to..\n\t(toc_relative_expr_p): ..here.  Add \"strict\" param.  Match new rtl\n\tgenerated by create_TOC_reference.\n\t(rs6000_legitimize_address): Update cerate_TOC_reference call.\n\t(rs6000_delegitimize_address): Handle new rtl for toc refs.\n\t(rs6000_cannot_force_const_mem, rs6000_find_base_term): Likewise.\n\t(use_toc_relative_ref): New function, split out from..\n\t(rs6000_emit_move): ..here.  Remove redundant tests.  Update\n\tcreate_TOC_reference calls.\n\t(rs6000_legitimize_reload_address): Formatting.  Handle splitting\n\tof medium/large model toc addresses.  Use use_toc_relative_ref.\n\t(print_operand): Formatting, style.  Adjust for toc changes.\n\t(print_operand_address): Likewise.\n\t(rs6000_output_addr_const_extra): Likewise.\n\t(create_TOC_reference): Put TOC_REGISTER in UNSPEC_TOCREL rather\n\tthan a PLUS.  Use this formulation for both high and low part\n\tof -mcmodel=medium/large toc reference too.  Before reload,\n\talways use the small model formulation.\n\t* config/rs6000/rs6000.md (tls_gd, tls_gd_high): Similarly avoid\n\ta PLUS in high part of addresses here.\n\t(tls_ld, tls_ld_high, tls_got_dtprel, tls_got_dtprel_high): Likewise.\n\t(tls_got_tprel, tls_got_tprel_high, largetoc_high): Likewise.\n\t(largetoc_high, largetoc_low): Move earlier.  Cope when no\n\tbase reg available.\n\t(largetoc_high_plus): New insn.\n\t(movsi_internal1, movsi_internal1_single, movsf_softfloat,\n\tmovdi_mfpgpr, movdi_internal64): Don't handle 'R' constraint here..\n\t(tocref): ..instead do so here, new insn and split.\n\nFrom-SVN: r187699", "tree": {"sha": "2dbf0adec4309253bde2227586c7a907945ba943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dbf0adec4309253bde2227586c7a907945ba943"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d1925759edc64da96c7ca73cd43728e800b0d6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1925759edc64da96c7ca73cd43728e800b0d6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1925759edc64da96c7ca73cd43728e800b0d6fa"}], "stats": {"total": 555, "additions": 300, "deletions": 255}, "files": [{"sha": "55cf1fd30bdefa1d7e2f85607b32a3a4c645c963", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "patch": "@@ -1,3 +1,42 @@\n+2012-05-21  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/predicates.md (input_operand): Don't match\n+\tconstant pool addresses.  Remove label_ref, high and plus from\n+\tmatch_code list.  Remove redundant CONSTANT_P test.\n+\t(splat_input_operand): Similarly update match_code list.\n+\t(small_toc_ref): New predicate.\n+\t* config/rs6000/rs6000-protos.h (toc_relative_expr_p): Update prototype.\n+\t* config/rs6000/rs6000.c (tocrel_base, tocrel_offset): Make const.\n+\t(legitimate_constant_pool_address_p): Move TARGET_TOC test and\n+\tregister checks to..\n+\t(toc_relative_expr_p): ..here.  Add \"strict\" param.  Match new rtl\n+\tgenerated by create_TOC_reference.\n+\t(rs6000_legitimize_address): Update cerate_TOC_reference call.\n+\t(rs6000_delegitimize_address): Handle new rtl for toc refs.\n+\t(rs6000_cannot_force_const_mem, rs6000_find_base_term): Likewise.\n+\t(use_toc_relative_ref): New function, split out from..\n+\t(rs6000_emit_move): ..here.  Remove redundant tests.  Update\n+\tcreate_TOC_reference calls.\n+\t(rs6000_legitimize_reload_address): Formatting.  Handle splitting\n+\tof medium/large model toc addresses.  Use use_toc_relative_ref.\n+\t(print_operand): Formatting, style.  Adjust for toc changes.\n+\t(print_operand_address): Likewise.\n+\t(rs6000_output_addr_const_extra): Likewise.\n+\t(create_TOC_reference): Put TOC_REGISTER in UNSPEC_TOCREL rather\n+\tthan a PLUS.  Use this formulation for both high and low part\n+\tof -mcmodel=medium/large toc reference too.  Before reload,\n+\talways use the small model formulation.\n+\t* config/rs6000/rs6000.md (tls_gd, tls_gd_high): Similarly avoid\n+\ta PLUS in high part of addresses here.\n+\t(tls_ld, tls_ld_high, tls_got_dtprel, tls_got_dtprel_high): Likewise.\n+\t(tls_got_tprel, tls_got_tprel_high, largetoc_high): Likewise.\n+\t(largetoc_high, largetoc_low): Move earlier.  Cope when no\n+\tbase reg available.\n+\t(largetoc_high_plus): New insn.\n+\t(movsi_internal1, movsi_internal1_single, movsf_softfloat,\n+\tmovdi_mfpgpr, movdi_internal64): Don't handle 'R' constraint here..\n+\t(tocref): ..instead do so here, new insn and split.\n+\n 2012-05-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/driver-i386.c (host_detect_local_cpu): Support"}, {"sha": "70a4d2ca7088bb72816a3e2229b02f309572f0a2", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for POWER and PowerPC.\n-;; Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+;; Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n ;; Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n@@ -824,16 +824,15 @@\n \n ;; Return 1 if this operand is a valid input for a move insn.\n (define_predicate \"input_operand\"\n-  (match_code \"label_ref,symbol_ref,const,high,reg,subreg,mem,\n-\t       const_double,const_vector,const_int,plus\")\n+  (match_code \"symbol_ref,const,reg,subreg,mem,\n+\t       const_double,const_vector,const_int\")\n {\n   /* Memory is always valid.  */\n   if (memory_operand (op, mode))\n     return 1;\n \n   /* For floating-point, easy constants are valid.  */\n   if (SCALAR_FLOAT_MODE_P (mode)\n-      && CONSTANT_P (op)\n       && easy_fp_constant (op, mode))\n     return 1;\n \n@@ -866,14 +865,6 @@\n   if (register_operand (op, mode))\n     return 1;\n \n-  /* A SYMBOL_REF referring to the TOC is valid.  */\n-  if (legitimate_constant_pool_address_p (op, mode, false))\n-    return 1;\n-\n-  /* A constant pool expression (relative to the TOC) is valid */\n-  if (toc_relative_expr_p (op))\n-    return 1;\n-\n   /* V.4 allows SYMBOL_REFs and CONSTs that are in the small data region\n      to be valid.  */\n   if (DEFAULT_ABI == ABI_V4\n@@ -886,8 +877,8 @@\n \n ;; Return 1 if this operand is a valid input for a vsx_splat insn.\n (define_predicate \"splat_input_operand\"\n-  (match_code \"label_ref,symbol_ref,const,high,reg,subreg,mem,\n-\t       const_double,const_vector,const_int,plus\")\n+  (match_code \"symbol_ref,const,reg,subreg,mem,\n+\t       const_double,const_vector,const_int\")\n {\n   if (MEM_P (op))\n     {\n@@ -1461,3 +1452,14 @@\n \t  && GET_MODE (XEXP (XVECEXP (op, 0, 0), 0)) == BLKmode\n \t  && XEXP (XVECEXP (op, 0, 0), 1) == const0_rtx);\n })\n+\n+;; Match a small code model toc reference (or medium and large\n+;; model toc references before reload).\n+(define_predicate \"small_toc_ref\"\n+  (match_code \"unspec,plus\")\n+{\n+  if (GET_CODE (op) == PLUS && CONST_INT_P (XEXP (op, 1)))\n+    op = XEXP (op, 0);\n+\n+  return GET_CODE (op) == UNSPEC && XINT (op, 1) == UNSPEC_TOCREL;\n+})"}, {"sha": "119482fbafcfadea266b14c19708e5b282df5a06", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for IBM RS/6000.\n    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010, 2011\n+   2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -38,7 +38,7 @@ extern bool macho_lo_sum_memory_operand (rtx, enum machine_mode);\n extern int num_insns_constant (rtx, enum machine_mode);\n extern int num_insns_constant_wide (HOST_WIDE_INT);\n extern int small_data_operand (rtx, enum machine_mode);\n-extern bool toc_relative_expr_p (rtx);\n+extern bool toc_relative_expr_p (const_rtx, bool);\n extern bool invalid_e500_subreg (rtx, enum machine_mode);\n extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n extern bool legitimate_constant_pool_address_p (const_rtx, enum machine_mode,"}, {"sha": "dbd1b4a37ca9baac55dd812671b9efaf40d46b69", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 158, "deletions": 162, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "patch": "@@ -5307,15 +5307,37 @@ constant_pool_expr_p (rtx op)\n \t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (base), Pmode));\n }\n \n-static rtx tocrel_base, tocrel_offset;\n+static const_rtx tocrel_base, tocrel_offset;\n+\n+/* Return true if OP is a toc pointer relative address (the output\n+   of create_TOC_reference).  If STRICT, do not match high part or\n+   non-split -mcmodel=large/medium toc pointer relative addresses.  */\n \n bool\n-toc_relative_expr_p (rtx op)\n+toc_relative_expr_p (const_rtx op, bool strict)\n {\n-  if (GET_CODE (op) != CONST)\n+  if (!TARGET_TOC)\n     return false;\n \n-  split_const (op, &tocrel_base, &tocrel_offset);\n+  if (TARGET_CMODEL != CMODEL_SMALL)\n+    {\n+      /* Only match the low part.  */\n+      if (GET_CODE (op) == LO_SUM\n+\t  && REG_P (XEXP (op, 0))\n+\t  && INT_REG_OK_FOR_BASE_P (XEXP (op, 0), strict))\n+\top = XEXP (op, 1);\n+      else if (strict)\n+\treturn false;\n+    }\n+\n+  tocrel_base = op;\n+  tocrel_offset = const0_rtx;\n+  if (GET_CODE (op) == PLUS && CONST_INT_P (XEXP (op, 1)))\n+    {\n+      tocrel_base = XEXP (op, 0);\n+      tocrel_offset = XEXP (op, 1);\n+    }\n+\n   return (GET_CODE (tocrel_base) == UNSPEC\n \t  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);\n }\n@@ -5327,14 +5349,7 @@ bool\n legitimate_constant_pool_address_p (const_rtx x, enum machine_mode mode,\n \t\t\t\t    bool strict)\n {\n-  return (TARGET_TOC\n-\t  && (GET_CODE (x) == PLUS || GET_CODE (x) == LO_SUM)\n-\t  && GET_CODE (XEXP (x, 0)) == REG\n-\t  && (REGNO (XEXP (x, 0)) == TOC_REGISTER\n-\t      || ((TARGET_MINIMAL_TOC\n-\t\t   || TARGET_CMODEL != CMODEL_SMALL)\n-\t\t  && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict)))\n-\t  && toc_relative_expr_p (XEXP (x, 1))\n+  return (toc_relative_expr_p (x, strict)\n \t  && (TARGET_CMODEL != CMODEL_MEDIUM\n \t      || constant_pool_expr_p (XVECEXP (tocrel_base, 0, 0))\n \t      || mode == QImode\n@@ -5714,10 +5729,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t   && GET_CODE (x) == SYMBOL_REF\n \t   && constant_pool_expr_p (x)\n \t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), Pmode))\n-    {\n-      rtx reg = TARGET_CMODEL != CMODEL_SMALL ? gen_reg_rtx (Pmode) : NULL_RTX;\n-      return create_TOC_reference (x, reg);\n-    }\n+    return create_TOC_reference (x, NULL_RTX);\n   else\n     return x;\n }\n@@ -5800,49 +5812,55 @@ rs6000_output_dwarf_dtprel (FILE *file, int size, rtx x)\n static rtx\n rs6000_delegitimize_address (rtx orig_x)\n {\n-  rtx x, y;\n+  rtx x, y, offset;\n \n   orig_x = delegitimize_mem_from_attrs (orig_x);\n   x = orig_x;\n   if (MEM_P (x))\n     x = XEXP (x, 0);\n \n-  if (GET_CODE (x) == (TARGET_CMODEL != CMODEL_SMALL ? LO_SUM : PLUS)\n-      && GET_CODE (XEXP (x, 1)) == CONST)\n+  y = x;\n+  if (TARGET_CMODEL != CMODEL_SMALL\n+      && GET_CODE (y) == LO_SUM)\n+    y = XEXP (y, 1);\n+\n+  offset = NULL_RTX;\n+  if (GET_CODE (y) == PLUS\n+      && GET_MODE (y) == Pmode\n+      && CONST_INT_P (XEXP (y, 1)))\n     {\n-      rtx offset = NULL_RTX;\n+      offset = XEXP (y, 1);\n+      y = XEXP (y, 0);\n+    }\n \n-      y = XEXP (XEXP (x, 1), 0);\n-      if (GET_CODE (y) == PLUS\n-\t  && GET_MODE (y) == Pmode\n-\t  && CONST_INT_P (XEXP (y, 1)))\n+  if (GET_CODE (y) == UNSPEC\n+      && XINT (y, 1) == UNSPEC_TOCREL)\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (REG_P (XVECEXP (y, 0, 1))\n+\t  && REGNO (XVECEXP (y, 0, 1)) == TOC_REGISTER)\n \t{\n-\t  offset = XEXP (y, 1);\n-\t  y = XEXP (y, 0);\n+\t  /* All good.  */\n \t}\n-      if (GET_CODE (y) == UNSPEC\n-          && XINT (y, 1) == UNSPEC_TOCREL\n-\t  && ((GET_CODE (XEXP (x, 0)) == REG\n-\t       && (REGNO (XEXP (x, 0)) == TOC_REGISTER\n-\t\t   || TARGET_MINIMAL_TOC\n-\t\t   || TARGET_CMODEL != CMODEL_SMALL))\n-\t      || (TARGET_CMODEL != CMODEL_SMALL\n-\t\t  && GET_CODE (XEXP (x, 0)) == CONST\n-\t\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS\n-\t\t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == REG\n-\t\t  && REGNO (XEXP (XEXP (XEXP (x, 0), 0), 0)) == TOC_REGISTER\n-\t\t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == HIGH\n-\t\t  && rtx_equal_p (XEXP (x, 1),\n-\t\t\t\t  XEXP (XEXP (XEXP (XEXP (x, 0), 0), 1), 0)))))\n-\t{\n-\t  y = XVECEXP (y, 0, 0);\n-\t  if (offset != NULL_RTX)\n-\t    y = gen_rtx_PLUS (Pmode, y, offset);\n-\t  if (!MEM_P (orig_x))\n-\t    return y;\n-\t  else\n-\t    return replace_equiv_address_nv (orig_x, y);\n+      else if (GET_CODE (XVECEXP (y, 0, 1)) == DEBUG_EXPR)\n+\t{\n+\t  /* Weirdness alert.  df_note_compute can replace r2 with a\n+\t     debug_expr when this unspec is in a debug_insn.\n+\t     Seen in gcc.dg/pr51957-1.c  */\n \t}\n+      else\n+\t{\n+\t  debug_rtx (orig_x);\n+\t  abort ();\n+\t}\n+#endif\n+      y = XVECEXP (y, 0, 0);\n+      if (offset != NULL_RTX)\n+\ty = gen_rtx_PLUS (Pmode, y, offset);\n+      if (!MEM_P (orig_x))\n+\treturn y;\n+      else\n+\treturn replace_equiv_address_nv (orig_x, y);\n     }\n \n   if (TARGET_MACHO\n@@ -6104,9 +6122,8 @@ rs6000_tls_referenced_p (rtx x)\n static bool\n rs6000_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n-  if (GET_CODE (x) == CONST\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == HIGH)\n+  if (GET_CODE (x) == HIGH\n+      && GET_CODE (XEXP (x, 0)) == UNSPEC)\n     return true;\n \n   return rs6000_tls_referenced_p (x);\n@@ -6121,6 +6138,21 @@ rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n   return RS6000_SYMBOL_REF_TLS_P (*x);\n }\n \n+/* Return true iff the given SYMBOL_REF refers to a constant pool entry\n+   that we have put in the TOC, or for cmodel=medium, if the SYMBOL_REF\n+   can be addressed relative to the toc pointer.  */\n+\n+static bool\n+use_toc_relative_ref (rtx sym)\n+{\n+  return ((constant_pool_expr_p (sym)\n+\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (sym),\n+\t\t\t\t\t       get_pool_mode (sym)))\n+\t  || (TARGET_CMODEL == CMODEL_MEDIUM\n+\t      && !CONSTANT_POOL_ADDRESS_P (sym)\n+\t      && SYMBOL_REF_LOCAL_P (sym)));\n+}\n+\n /* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n    replace the input X, or the original X if no replacement is called for.\n    The output parameter *WIN is 1 if the calling macro should goto WIN,\n@@ -6158,7 +6190,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     {\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type)type);\n+\t\t   opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n@@ -6169,7 +6201,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n     {\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type)type);\n+\t\t   opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n@@ -6187,24 +6219,18 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t floating point constant.  */\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type)type);\n+\t\t   opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n #endif\n \n   if (TARGET_CMODEL != CMODEL_SMALL\n-      && GET_CODE (x) == LO_SUM\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n-      && REGNO (XEXP (XEXP (x, 0), 0)) == TOC_REGISTER\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST\n-      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 0)) == HIGH\n-      && GET_CODE (XEXP (x, 1)) == CONST\n-      && GET_CODE (XEXP (XEXP (x, 1), 0)) == UNSPEC\n-      && XINT (XEXP (XEXP (x, 1), 0), 1) == UNSPEC_TOCREL\n-      && rtx_equal_p (XEXP (XEXP (XEXP (XEXP (x, 0), 1), 0), 0), XEXP (x, 1)))\n+      && reg_offset_p\n+      && small_toc_ref (x, VOIDmode))\n     {\n+      rtx hi = gen_rtx_HIGH (Pmode, copy_rtx (x));\n+      x = gen_rtx_LO_SUM (Pmode, hi, x);\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -6267,7 +6293,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type)type);\n+\t\t   opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n@@ -6308,7 +6334,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type)type);\n+\t\t   opnum, (enum reload_type) type);\n       *win = 1;\n       return x;\n     }\n@@ -6335,8 +6361,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n   if (TARGET_TOC\n       && reg_offset_p\n       && GET_CODE (x) == SYMBOL_REF\n-      && constant_pool_expr_p (x)\n-      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (x), mode))\n+      && use_toc_relative_ref (x))\n     {\n       x = create_TOC_reference (x, NULL_RTX);\n       if (TARGET_CMODEL != CMODEL_SMALL)\n@@ -6571,9 +6596,13 @@ rs6000_debug_mode_dependent_address (const_rtx addr)\n rtx\n rs6000_find_base_term (rtx op)\n {\n-  rtx base, offset;\n+  rtx base;\n \n-  split_const (op, &base, &offset);\n+  base = op;\n+  if (GET_CODE (base) == CONST)\n+    base = XEXP (base, 0);\n+  if (GET_CODE (base) == PLUS)\n+    base = XEXP (base, 0);\n   if (GET_CODE (base) == UNSPEC)\n     switch (XINT (base, 1))\n       {\n@@ -7225,43 +7254,21 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       /* If this is a SYMBOL_REF that refers to a constant pool entry,\n \t and we have put it in the TOC, we just need to make a TOC-relative\n \t reference to it.  */\n-      if ((TARGET_TOC\n-\t   && GET_CODE (operands[1]) == SYMBOL_REF\n-\t   && constant_pool_expr_p (operands[1])\n-\t   && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (operands[1]),\n-\t\t\t\t\t       get_pool_mode (operands[1])))\n-\t  || (TARGET_CMODEL == CMODEL_MEDIUM\n-\t      && GET_CODE (operands[1]) == SYMBOL_REF\n-\t      && !CONSTANT_POOL_ADDRESS_P (operands[1])\n-\t      && SYMBOL_REF_LOCAL_P (operands[1])))\n-\t{\n-\t  rtx reg = NULL_RTX;\n-\t  if (TARGET_CMODEL != CMODEL_SMALL)\n-\t    {\n-\t      if (can_create_pseudo_p ())\n-\t\treg = gen_reg_rtx (Pmode);\n-\t      else\n-\t\treg = operands[0];\n-\t    }\n-\t  operands[1] = create_TOC_reference (operands[1], reg);\n-\t}\n+      if (TARGET_TOC\n+\t  && GET_CODE (operands[1]) == SYMBOL_REF\n+\t  && use_toc_relative_ref (operands[1]))\n+\toperands[1] = create_TOC_reference (operands[1], operands[0]);\n       else if (mode == Pmode\n \t       && CONSTANT_P (operands[1])\n \t       && GET_CODE (operands[1]) != HIGH\n-\t       && !(TARGET_CMODEL != CMODEL_SMALL\n-\t\t    && GET_CODE (operands[1]) == CONST\n-\t\t    && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t\t    && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == HIGH)\n \t       && ((GET_CODE (operands[1]) != CONST_INT\n \t\t    && ! easy_fp_constant (operands[1], mode))\n \t\t   || (GET_CODE (operands[1]) == CONST_INT\n \t\t       && (num_insns_constant (operands[1], mode)\n \t\t\t   > (TARGET_CMODEL != CMODEL_SMALL ? 3 : 2)))\n \t\t   || (GET_CODE (operands[0]) == REG\n \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n-\t       && ! legitimate_constant_pool_address_p (operands[1], mode,\n-\t\t\t\t\t\t\tfalse)\n-\t       && ! toc_relative_expr_p (operands[1])\n+\t       && !toc_relative_expr_p (operands[1], false)\n \t       && (TARGET_CMODEL == CMODEL_SMALL\n \t\t   || can_create_pseudo_p ()\n \t\t   || (REG_P (operands[0])\n@@ -7311,16 +7318,8 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t\tget_pool_constant (XEXP (operands[1], 0)),\n \t\t\tget_pool_mode (XEXP (operands[1], 0))))\n \t    {\n-\t      rtx tocref;\n-\t      rtx reg = NULL_RTX;\n-\t      if (TARGET_CMODEL != CMODEL_SMALL)\n-\t\t{\n-\t\t  if (can_create_pseudo_p ())\n-\t\t    reg = gen_reg_rtx (Pmode);\n-\t\t  else\n-\t\t    reg = operands[0];\n-\t\t}\n-\t      tocref = create_TOC_reference (XEXP (operands[1], 0), reg);\n+\t      rtx tocref = create_TOC_reference (XEXP (operands[1], 0),\n+\t\t\t\t\t\t operands[0]);\n \t      operands[1] = gen_const_mem (mode, tocref);\n \t      set_mem_alias_set (operands[1], get_TOC_alias_set ());\n \t    }\n@@ -14730,7 +14729,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'D':\n       /* Like 'J' but get to the GT bit only.  */\n-      gcc_assert (GET_CODE (x) == REG);\n+      gcc_assert (REG_P (x));\n \n       /* Bit 1 is GT bit.  */\n       i = 4 * (REGNO (x) - CR0_REGNO) + 1;\n@@ -14850,9 +14849,9 @@ print_operand (FILE *file, rtx x, int code)\n     case 'L':\n       /* Write second word of DImode or DFmode reference.  Works on register\n \t or non-indexed memory only.  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfputs (reg_names[REGNO (x) + 1], file);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \t{\n \t  /* Handle possible auto-increment.  Since it is pre-increment and\n \t     we have already done it, we can just use an offset of word.  */\n@@ -15021,7 +15020,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 't':\n       /* Like 'J' but get to the OVERFLOW/UNORDERED bit.  */\n-      gcc_assert (GET_CODE (x) == REG && GET_MODE (x) == CCmode);\n+      gcc_assert (REG_P (x) && GET_MODE (x) == CCmode);\n \n       /* Bit 3 is OV bit.  */\n       i = 4 * (REGNO (x) - CR0_REGNO) + 3;\n@@ -15061,7 +15060,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'U':\n       /* Print `u' if this has an auto-increment or auto-decrement.  */\n-      if (GET_CODE (x) == MEM\n+      if (MEM_P (x)\n \t  && (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_MODIFY))\n@@ -15153,7 +15152,7 @@ print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'X':\n-      if (GET_CODE (x) == MEM\n+      if (MEM_P (x)\n \t  && (legitimate_indexed_address_p (XEXP (x, 0), 0)\n \t      || (GET_CODE (XEXP (x, 0)) == PRE_MODIFY\n \t\t  && legitimate_indexed_address_p (XEXP (XEXP (x, 0), 1), 0))))\n@@ -15162,9 +15161,9 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'Y':\n       /* Like 'L', for third word of TImode  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfputs (reg_names[REGNO (x) + 2], file);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n@@ -15212,9 +15211,9 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'Z':\n       /* Like 'L', for last word of TImode.  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfputs (reg_names[REGNO (x) + 3], file);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n@@ -15234,7 +15233,7 @@ print_operand (FILE *file, rtx x, int code)\n       {\n \trtx tmp;\n \n-\tgcc_assert (GET_CODE (x) == MEM);\n+\tgcc_assert (MEM_P (x));\n \n \ttmp = XEXP (x, 0);\n \n@@ -15245,7 +15244,7 @@ print_operand (FILE *file, rtx x, int code)\n \t\t|| GET_MODE (x) == TImode))\n \t  {\n \t    /* Handle [reg].  */\n-\t    if (GET_CODE (tmp) == REG)\n+\t    if (REG_P (tmp))\n \t      {\n \t\tfprintf (file, \"0(%s)\", reg_names[REGNO (tmp)]);\n \t\tbreak;\n@@ -15256,7 +15255,7 @@ print_operand (FILE *file, rtx x, int code)\n \t      {\n \t\tint x;\n \n-\t\tgcc_assert (GET_CODE (XEXP (tmp, 0)) == REG);\n+\t\tgcc_assert (REG_P (XEXP (tmp, 0)));\n \n \t\tx = INTVAL (XEXP (tmp, 1));\n \t\tfprintf (file, \"%d(%s)\", x, reg_names[REGNO (XEXP (tmp, 0))]);\n@@ -15273,7 +15272,7 @@ print_operand (FILE *file, rtx x, int code)\n \telse if (VECTOR_MEM_VSX_P (GET_MODE (x))\n \t\t && GET_CODE (tmp) == PRE_MODIFY)\n \t  tmp = XEXP (tmp, 1);\n-\tif (GET_CODE (tmp) == REG)\n+\tif (REG_P (tmp))\n \t  fprintf (file, \"0,%s\", reg_names[REGNO (tmp)]);\n \telse\n \t  {\n@@ -15296,9 +15295,9 @@ print_operand (FILE *file, rtx x, int code)\n       }\n \n     case 0:\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \t{\n \t  /* We need to handle PRE_INC and PRE_DEC here, since we need to\n \t     know the width from the mode.  */\n@@ -15315,14 +15314,14 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       else\n \t{\n-\t  if (toc_relative_expr_p (x))\n+\t  if (toc_relative_expr_p (x, false))\n \t    /* This hack along with a corresponding hack in\n \t       rs6000_output_addr_const_extra arranges to output addends\n \t       where the assembler expects to find them.  eg.\n-\t       (const (plus (unspec [symbol_ref (\"x\") tocrel]) 4))\n+\t       (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 4)\n \t       without this hack would be output as \"x@toc+4\".  We\n \t       want \"x+4@toc\".  */\n-\t    output_addr_const (file, tocrel_base);\n+\t    output_addr_const (file, CONST_CAST_RTX (tocrel_base));\n \t  else\n \t    output_addr_const (file, x);\n \t}\n@@ -15342,7 +15341,7 @@ print_operand (FILE *file, rtx x, int code)\n void\n print_operand_address (FILE *file, rtx x)\n {\n-  if (GET_CODE (x) == REG)\n+  if (REG_P (x))\n     fprintf (file, \"0(%s)\", reg_names[ REGNO (x) ]);\n   else if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST\n \t   || GET_CODE (x) == LABEL_REF)\n@@ -15354,51 +15353,52 @@ print_operand_address (FILE *file, rtx x)\n       else\n \tgcc_assert (!TARGET_TOC);\n     }\n-  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == REG)\n+  else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n+\t   && REG_P (XEXP (x, 1)))\n     {\n-      gcc_assert (REG_P (XEXP (x, 0)));\n       if (REGNO (XEXP (x, 0)) == 0)\n \tfprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (x, 1)) ],\n \t\t reg_names[ REGNO (XEXP (x, 0)) ]);\n       else\n \tfprintf (file, \"%s,%s\", reg_names[ REGNO (XEXP (x, 0)) ],\n \t\t reg_names[ REGNO (XEXP (x, 1)) ]);\n     }\n-  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+  else if (GET_CODE (x) == PLUS && REG_P (XEXP (x, 0))\n+\t   && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     fprintf (file, HOST_WIDE_INT_PRINT_DEC \"(%s)\",\n \t     INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n #if TARGET_MACHO\n-  else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n+  else if (GET_CODE (x) == LO_SUM && REG_P (XEXP (x, 0))\n \t   && CONSTANT_P (XEXP (x, 1)))\n     {\n       fprintf (file, \"lo16(\");\n       output_addr_const (file, XEXP (x, 1));\n       fprintf (file, \")(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n-  else if (legitimate_constant_pool_address_p (x, QImode, true))\n+#if TARGET_ELF\n+  else if (GET_CODE (x) == LO_SUM && REG_P (XEXP (x, 0))\n+\t   && CONSTANT_P (XEXP (x, 1)))\n+    {\n+      output_addr_const (file, XEXP (x, 1));\n+      fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n+    }\n+#endif\n+  else if (toc_relative_expr_p (x, false))\n     {\n       /* This hack along with a corresponding hack in\n \t rs6000_output_addr_const_extra arranges to output addends\n \t where the assembler expects to find them.  eg.\n \t (lo_sum (reg 9)\n-\t .       (const (plus (unspec [symbol_ref (\"x\") tocrel]) 8)))\n+\t .       (plus (unspec [(symbol_ref (\"x\")) (reg 2)] tocrel) 8))\n \t without this hack would be output as \"x@toc+8@l(9)\".  We\n \t want \"x+8@toc@l(9)\".  */\n-      output_addr_const (file, tocrel_base);\n+      output_addr_const (file, CONST_CAST_RTX (tocrel_base));\n       if (GET_CODE (x) == LO_SUM)\n-\tfprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n+\tfprintf (file, \"@l(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n       else\n-\tfprintf (file, \"(%s)\", reg_names[REGNO (XEXP (x, 0))]);\n+\tfprintf (file, \"(%s)\", reg_names[REGNO (XVECEXP (tocrel_base, 0, 1))]);\n     }\n-#if TARGET_ELF\n-  else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n-\t   && CONSTANT_P (XEXP (x, 1)))\n-    {\n-      output_addr_const (file, XEXP (x, 1));\n-      fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n-    }\n-#endif\n   else\n     gcc_unreachable ();\n }\n@@ -15412,13 +15412,15 @@ rs6000_output_addr_const_extra (FILE *file, rtx x)\n     switch (XINT (x, 1))\n       {\n       case UNSPEC_TOCREL:\n-\tgcc_assert (GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF);\n+\tgcc_checking_assert (GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF\n+\t\t\t     && REG_P (XVECEXP (x, 0, 1))\n+\t\t\t     && REGNO (XVECEXP (x, 0, 1)) == TOC_REGISTER);\n \toutput_addr_const (file, XVECEXP (x, 0, 0));\n \tif (x == tocrel_base && tocrel_offset != const0_rtx)\n \t  {\n \t    if (INTVAL (tocrel_offset) >= 0)\n \t      fprintf (file, \"+\");\n-\t    output_addr_const (file, tocrel_offset);\n+\t    output_addr_const (file, CONST_CAST_RTX (tocrel_offset));\n \t  }\n \tif (!TARGET_AIX || (TARGET_ELF && TARGET_MINIMAL_TOC))\n \t  {\n@@ -18501,7 +18503,7 @@ uses_TOC (void)\n rtx\n create_TOC_reference (rtx symbol, rtx largetoc_reg)\n {\n-  rtx tocrel, tocreg;\n+  rtx tocrel, tocreg, hi;\n \n   if (TARGET_DEBUG_ADDR)\n     {\n@@ -18519,24 +18521,18 @@ create_TOC_reference (rtx symbol, rtx largetoc_reg)\n   if (!can_create_pseudo_p ())\n     df_set_regs_ever_live (TOC_REGISTER, true);\n \n-  tocrel = gen_rtx_CONST (Pmode,\n-\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, symbol),\n-\t\t\t\t\t  UNSPEC_TOCREL));\n   tocreg = gen_rtx_REG (Pmode, TOC_REGISTER);\n-  if (TARGET_CMODEL != CMODEL_SMALL)\n+  tocrel = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, symbol, tocreg), UNSPEC_TOCREL);\n+  if (TARGET_CMODEL == CMODEL_SMALL || can_create_pseudo_p ())\n+    return tocrel;\n+\n+  hi = gen_rtx_HIGH (Pmode, copy_rtx (tocrel));\n+  if (largetoc_reg != NULL)\n     {\n-      rtx hi = gen_rtx_CONST (Pmode,\n-\t\t\t      gen_rtx_PLUS (Pmode, tocreg, \n-\t\t\t\t\t    gen_rtx_HIGH (Pmode, tocrel)));\n-      if (largetoc_reg != NULL)\n-\t{\n-\t  emit_move_insn (largetoc_reg, hi);\n-\t  hi = largetoc_reg;\n-\t}\n-      return gen_rtx_LO_SUM (Pmode, hi, copy_rtx (tocrel));\n+      emit_move_insn (largetoc_reg, hi);\n+      hi = largetoc_reg;\n     }\n-  else\n-    return gen_rtx_PLUS (Pmode, tocreg, tocrel);\n+  return gen_rtx_LO_SUM (Pmode, hi, tocrel);\n }\n \n /* Issue assembly directives that create a reference to the given DWARF"}, {"sha": "e852c3e5306d8eb712b4ca0b24a2b6ebea33dc88", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 85, "deletions": 77, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc36363fa15c82fb85ce971b2b7fe395fd9c9e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8afc36363fa15c82fb85ce971b2b7fe395fd9c9e", "patch": "@@ -1,6 +1,7 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n ;; Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-;; 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+;; 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+;; 2011, 2012\n ;; Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n@@ -9305,8 +9306,8 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*movsi_internal1\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h,*h\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,R,*h,r,r,r,0\"))]\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,*q,*c*l,*h,*h\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,*h,r,r,r,0\"))]\n   \"!TARGET_SINGLE_FPU &&\n    (gpc_reg_operand (operands[0], SImode) || gpc_reg_operand (operands[1], SImode))\"\n   \"@\n@@ -9317,18 +9318,17 @@\n    {lil|li} %0,%1\n    {liu|lis} %0,%v1\n    #\n-   {cal|la} %0,%a1\n    mf%1 %0\n    mt%0 %1\n    mt%0 %1\n    mt%0 %1\n    {cror 0,0,0|nop}\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,*,mfjmpr,*,mtjmpr,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,*,mtjmpr,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4\")])\n \n (define_insn \"*movsi_internal1_single\"\n-  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h,*h,m,*f\")\n-        (match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,R,*h,r,r,r,0,f,m\"))]\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,*q,*c*l,*h,*h,m,*f\")\n+        (match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,*h,r,r,r,0,f,m\"))]\n   \"TARGET_SINGLE_FPU &&\n    (gpc_reg_operand (operands[0], SImode) || gpc_reg_operand (operands[1], SImode))\"\n   \"@\n@@ -9339,16 +9339,15 @@\n    {lil|li} %0,%1\n    {liu|lis} %0,%v1\n    #\n-   {cal|la} %0,%a1\n    mf%1 %0\n    mt%0 %1\n    mt%0 %1\n    mt%0 %1\n    {cror 0,0,0|nop}\n    stfs%U0%X0 %1, %0\n    lfs%U1%X1 %0, %1\"\n-  [(set_attr \"type\" \"*,*,load,store,*,*,*,*,mfjmpr,*,mtjmpr,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,*,load,store,*,*,*,mfjmpr,*,mtjmpr,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8,4,4,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n ;; sequence.\n@@ -9543,8 +9542,8 @@\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,8\")])\n \n (define_insn \"*movsf_softfloat\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,cl,q,r,r,m,r,r,r,r,r,*h\")\n-\t(match_operand:SF 1 \"input_operand\" \"r,r,r,h,m,r,I,L,R,G,Fn,0\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,cl,q,r,r,m,r,r,r,r,*h\")\n+\t(match_operand:SF 1 \"input_operand\" \"r,r,r,h,m,r,I,L,G,Fn,0\"))]\n   \"(gpc_reg_operand (operands[0], SFmode)\n    || gpc_reg_operand (operands[1], SFmode))\n    && (TARGET_SOFT_FLOAT || !TARGET_FPRS)\"\n@@ -9557,12 +9556,11 @@\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n    {liu|lis} %0,%v1\n-   {cal|la} %0,%a1\n    #\n    #\n    {cror 0,0,0|nop}\"\n-  [(set_attr \"type\" \"*,mtjmpr,*,mfjmpr,load,store,*,*,*,*,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,8,4\")])\n+  [(set_attr \"type\" \"*,mtjmpr,*,mfjmpr,load,store,*,*,*,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,4\")])\n \n \f\n (define_expand \"movdf\"\n@@ -10190,8 +10188,8 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"*movdi_mfpgpr\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,*d,*d,m,r,*h,*h,r,*d\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,R,d,m,d,*h,r,0,*d,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*d,*d,m,r,*h,*h,r,*d\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,d,m,d,*h,r,0,*d,r\"))]\n   \"TARGET_POWERPC64 && TARGET_MFPGPR && TARGET_HARD_FLOAT && TARGET_FPRS\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n@@ -10202,7 +10200,6 @@\n    li %0,%1\n    lis %0,%v1\n    #\n-   la %0,%a1\n    fmr %0,%1\n    lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n@@ -10211,12 +10208,12 @@\n    {cror 0,0,0|nop}\n    mftgpr %0,%1\n    mffgpr %0,%1\"\n-  [(set_attr \"type\" \"*,load,store,*,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,mftgpr,mffgpr\")\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,mftgpr,mffgpr\")\n+   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4\")])\n \n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,*d,*d,m,r,*h,*h,?wa\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,R,d,m,d,*h,r,0,O\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,*d,*d,m,r,*h,*h,?wa\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,d,m,d,*h,r,0,O\"))]\n   \"TARGET_POWERPC64 && (!TARGET_MFPGPR || !TARGET_HARD_FLOAT || !TARGET_FPRS)\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\"\n@@ -10227,16 +10224,15 @@\n    li %0,%1\n    lis %0,%v1\n    #\n-   la %0,%a1\n    fmr %0,%1\n    lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\n    mf%1 %0\n    mt%0 %1\n    {cror 0,0,0|nop}\n    xxlxor %x0,%x0,%x0\"\n-  [(set_attr \"type\" \"*,load,store,*,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,vecsimple\")\n-   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4,4\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,fp,fpload,fpstore,mfjmpr,mtjmpr,*,vecsimple\")\n+   (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4\")])\n \n ;; immediate value valid for a single instruction hiding in a const_double\n (define_insn \"\"\n@@ -11592,10 +11588,8 @@\n   \"addi %0,%1,%2@got@tlsgd\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 3)\n-\t(const:TLSmode\n-\t  (plus:TLSmode (match_dup 1)\n-\t    (high:TLSmode\n-\t      (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGD)))))\n+  \t(high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGD)))\n    (set (match_dup 0)\n    \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGD)))]\n@@ -11610,11 +11604,10 @@\n \n (define_insn \"*tls_gd_high<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n-     (const:TLSmode\n-       (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n-\t (high:TLSmode\n-\t   (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n-\t\t\t   UNSPEC_TLSGD)))))]\n+     (high:TLSmode\n+       (unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+\t\t\t(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t       UNSPEC_TLSGD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%2@got@tlsgd@ha\"\n   [(set_attr \"length\" \"4\")])\n@@ -11729,10 +11722,8 @@\n   \"addi %0,%1,%&@got@tlsld\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 2)\n-\t(const:TLSmode\n-\t  (plus:TLSmode (match_dup 1)\n-\t    (high:TLSmode\n-\t      (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)))))\n+  \t(high:TLSmode\n+\t    (unspec:TLSmode [(const_int 0) (match_dup 1)] UNSPEC_TLSLD)))\n    (set (match_dup 0)\n    \t(lo_sum:TLSmode (match_dup 2)\n \t    (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)))]\n@@ -11747,10 +11738,10 @@\n \n (define_insn \"*tls_ld_high<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n-     (const:TLSmode\n-       (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n-\t (high:TLSmode\n-\t   (unspec:TLSmode [(const_int 0)] UNSPEC_TLSLD)))))]\n+     (high:TLSmode\n+       (unspec:TLSmode [(const_int 0)\n+\t\t\t(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")]\n+\t\t       UNSPEC_TLSLD)))]\n   \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%&@got@tlsld@ha\"\n   [(set_attr \"length\" \"4\")])\n@@ -11826,10 +11817,8 @@\n   \"l<TLSmode:tls_insn_suffix> %0,%2@got@dtprel(%1)\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 3)\n-\t(const:TLSmode\n-\t  (plus:TLSmode (match_dup 1)\n-\t    (high:TLSmode\n-\t      (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTDTPREL)))))\n+\t(high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGOTDTPREL)))\n    (set (match_dup 0)\n \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTDTPREL)))]\n@@ -11844,11 +11833,10 @@\n \n (define_insn \"*tls_got_dtprel_high<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n-     (const:TLSmode\n-       (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n-\t (high:TLSmode\n-\t   (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n-\t\t\t   UNSPEC_TLSGOTDTPREL)))))]\n+     (high:TLSmode\n+       (unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+\t\t\t(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t       UNSPEC_TLSGOTDTPREL)))]\n   \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%2@got@dtprel@ha\"\n   [(set_attr \"length\" \"4\")])\n@@ -11898,10 +11886,8 @@\n   \"l<TLSmode:tls_insn_suffix> %0,%2@got@tprel(%1)\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 3)\n-\t(const:TLSmode\n-\t  (plus:TLSmode (match_dup 1)\n-\t    (high:TLSmode\n-\t      (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTTPREL)))))\n+\t(high:TLSmode\n+\t    (unspec:TLSmode [(match_dup 1) (match_dup 2)] UNSPEC_TLSGOTTPREL)))\n    (set (match_dup 0)\n \t(lo_sum:TLSmode (match_dup 3)\n \t    (unspec:TLSmode [(match_dup 2)] UNSPEC_TLSGOTTPREL)))]\n@@ -11916,11 +11902,10 @@\n \n (define_insn \"*tls_got_tprel_high<TLSmode:tls_abi_suffix>\"\n   [(set (match_operand:TLSmode 0 \"gpc_reg_operand\" \"=b\")\n-     (const:TLSmode\n-       (plus:TLSmode (match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n-\t (high:TLSmode\n-\t   (unspec:TLSmode [(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n-\t\t\t   UNSPEC_TLSGOTTPREL)))))]\n+     (high:TLSmode\n+       (unspec:TLSmode [(match_operand:TLSmode 1 \"gpc_reg_operand\" \"b\")\n+\t\t\t(match_operand:TLSmode 2 \"rs6000_tls_symbol_ref\" \"\")]\n+\t\t       UNSPEC_TLSGOTTPREL)))]\n   \"HAVE_AS_TLS && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%2@got@tprel@ha\"\n   [(set_attr \"length\" \"4\")])\n@@ -12277,6 +12262,45 @@\n   DONE;\n }\")\n \n+;; Largetoc support\n+(define_insn \"*largetoc_high\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b*r\")\n+        (high:DI\n+\t  (unspec [(match_operand:DI 1 \"\" \"\")\n+\t\t   (match_operand:DI 2 \"gpc_reg_operand\" \"b\")]\n+\t\t  UNSPEC_TOCREL)))]\n+   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n+   \"{cau|addis} %0,%2,%1@toc@ha\")\n+\n+(define_insn \"*largetoc_high_plus\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b*r\")\n+        (high:DI\n+\t  (plus:DI\n+\t    (unspec [(match_operand:DI 1 \"\" \"\")\n+\t\t     (match_operand:DI 2 \"gpc_reg_operand\" \"b\")]\n+\t\t    UNSPEC_TOCREL)\n+\t    (match_operand 3 \"const_int_operand\" \"n\"))))]\n+   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n+   \"{cau|addis} %0,%2,%1+%3@toc@ha\")\n+\n+(define_insn \"*largetoc_low\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+        (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,!*r\")\n+\t           (match_operand:DI 2 \"\" \"\")))]\n+   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n+   \"@\n+    {cal %0,%2@l(%1)|addi %0,%1,%2@l}\n+    {ai|addic} %0,%1,%2@l\")\n+\n+(define_insn_and_split \"*tocref<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b*r\")\n+\t(match_operand:P 1 \"small_toc_ref\" \"R\"))]\n+   \"TARGET_TOC\"\n+   \"{cal|la} %0,%a1\"\n+   \"&& TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL && reload_completed\"\n+  [(set (match_dup 0) (high:P (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:P (match_dup 0) (match_dup 1)))])\n+\n ;; Elf specific ways of loading addresses for non-PIC code.\n ;; The output of this could be r0, but we make a very strong\n ;; preference for a base register because it will usually\n@@ -12295,22 +12319,6 @@\n    \"@\n     {cal|la} %0,%2@l(%1)\n     {ai|addic} %0,%1,%K2\")\n-\n-;; Largetoc support\n-(define_insn \"largetoc_high\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=b\")\n-\t(const:DI\n-\t  (plus:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b\")\n-\t\t   (high:DI (match_operand:DI 2 \"\" \"\")))))]\n-   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n-   \"{cau|addis} %0,%1,%2@ha\")\n-\n-(define_insn \"largetoc_low\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-        (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b\")\n-\t           (match_operand:DI 2 \"\" \"\")))]\n-   \"TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n-   \"{cal %0,%2@l(%1)|addi %0,%1,%2@l}\")\n \f\n ;; Call and call_value insns\n (define_expand \"call\""}]}