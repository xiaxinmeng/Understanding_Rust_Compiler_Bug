{"sha": "72d6e3c594d6e52200aecadc38d98d273a351935", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkNmUzYzU5NGQ2ZTUyMjAwYWVjYWRjMzhkOThkMjczYTM1MTkzNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-11T18:52:43Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-11T18:52:43Z"}, "message": "mn10300: Clean up costing.\n\nAddress, register, memory and rtx costs bore little relation to reality.\n\nFrom-SVN: r168678", "tree": {"sha": "b6cdfa927ad5e52e4a39ce39648c9860cba841e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6cdfa927ad5e52e4a39ce39648c9860cba841e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d6e3c594d6e52200aecadc38d98d273a351935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d6e3c594d6e52200aecadc38d98d273a351935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d6e3c594d6e52200aecadc38d98d273a351935", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d6e3c594d6e52200aecadc38d98d273a351935/comments", "author": null, "committer": null, "parents": [{"sha": "62d3f9b2ef13057686f856e2b7775839806bcc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d3f9b2ef13057686f856e2b7775839806bcc76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d3f9b2ef13057686f856e2b7775839806bcc76"}], "stats": {"total": 448, "additions": 305, "deletions": 143}, "files": [{"sha": "1f80f216960960ecbcf415f1ddfb2aea3f12f733", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72d6e3c594d6e52200aecadc38d98d273a351935", "patch": "@@ -1,5 +1,19 @@\n 2011-01-11  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.c (mn10300_address_cost): Remove forward\n+\tdeclaration.  Rewrite for both speed and size.\n+\t(mn10300_address_cost_1): Remove.\n+\t(mn10300_register_move_cost): New.\n+\t(mn10300_memory_move_cost): New.\n+\t(mn10300_rtx_costs): Rewrite for both speed and size.  Don't handle\n+\tZERO_EXTRACT.  Do handle UNSPEC, arithmetic, logicals, compare,\n+\textensions, shifts, BSWAP, CLZ.\n+\t(mn10300_wide_const_load_uses_clr): Remove.\n+\t(TARGET_REGISTER_MOVE_COST): New.\n+\t(TARGET_MEMORY_MOVE_COST): New.\n+\t* config/mn10300/mn10300-protos.h: Update.\n+\t* config/mn10300/mn10300.h (REGISTER_MOVE_COST): Remove.\n+\n \t* config/mn10300/constraints.md (\"R\", \"T\"): Remove constraints.\n \t* config/mn10300/mn10300.c (mn10300_mask_ok_for_mem_btst): Remove.\n \t* config/mn10300/mn10300-protos.h: Update."}, {"sha": "d6cf850a52ce982b7793767fc39dddded327ad74", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=72d6e3c594d6e52200aecadc38d98d273a351935", "patch": "@@ -39,7 +39,6 @@ extern Rclas mn10300_secondary_reload_class (Rclas, Mmode, rtx);\n extern Mmode mn10300_select_cc_mode (rtx);\n extern int   mn10300_store_multiple_operation (rtx, Mmode);\n extern int   mn10300_symbolic_operand (rtx, Mmode);\n-extern bool  mn10300_wide_const_load_uses_clr (rtx operands[2]);\n #endif /* RTX_CODE */\n \n extern int   mn10300_can_use_return_insn (void);"}, {"sha": "d39b42785c5439c4d61bcfa0e536a83ccede7bad", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 291, "deletions": 129, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=72d6e3c594d6e52200aecadc38d98d273a351935", "patch": "@@ -75,8 +75,6 @@ enum processor_type mn10300_tune_cpu = PROCESSOR_DEFAULT;\n \t\t\t\t|| df_regs_ever_live_p (16)\t\\\n \t\t\t\t|| df_regs_ever_live_p (17)))\n \n-static int mn10300_address_cost (rtx, bool);\n-\n /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */\n static const struct default_options mn10300_option_optimization_table[] =\n   {\n@@ -2034,180 +2032,340 @@ mn10300_legitimate_constant_p (rtx x)\n   return true;\n }\n \n+/* For addresses, costs are relative to \"MOV (Rm),Rn\".  For AM33 this is\n+   the 3-byte fully general instruction; for MN103 this is the 2-byte form\n+   with an address register.  */\n+\n static int\n-mn10300_address_cost_1 (rtx x, int *unsig)\n+mn10300_address_cost (rtx x, bool speed)\n {\n+  HOST_WIDE_INT i;\n+  rtx base, index;\n+\n   switch (GET_CODE (x))\n     {\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      /* We assume all of these require a 32-bit constant, even though\n+\t some symbol and label references can be relaxed.  */\n+      return speed ? 1 : 4;\n+\n     case REG:\n-      switch (REGNO_REG_CLASS (REGNO (x)))\n+    case SUBREG:\n+    case POST_INC:\n+      return 0;\n+\n+    case POST_MODIFY:\n+      /* Assume any symbolic offset is a 32-bit constant.  */\n+      i = (CONST_INT_P (XEXP (x, 1)) ? INTVAL (XEXP (x, 1)) : 0x12345678);\n+      if (IN_RANGE (i, -128, 127))\n+\treturn speed ? 0 : 1;\n+      if (speed)\n+\treturn 1;\n+      if (IN_RANGE (i, -0x800000, 0x7fffff))\n+\treturn 3;\n+      return 4;\n+\n+    case PLUS:\n+      base = XEXP (x, 0);\n+      index = XEXP (x, 1);\n+      if (register_operand (index, SImode))\n \t{\n-\tcase SP_REGS:\n-\t  *unsig = 1;\n-\t  return 0;\n+\t  /* Attempt to minimize the number of registers in the address.\n+\t     This is similar to what other ports do.  */\n+\t  if (register_operand (base, SImode))\n+\t    return 1;\n \n-\tcase ADDRESS_REGS:\n-\t  return 1;\n+\t  base = XEXP (x, 1);\n+\t  index = XEXP (x, 0);\n+\t}\n \n-\tcase DATA_REGS:\n-\tcase EXTENDED_REGS:\n-\tcase FP_REGS:\n-\t  return 3;\n+      /* Assume any symbolic offset is a 32-bit constant.  */\n+      i = (CONST_INT_P (XEXP (x, 1)) ? INTVAL (XEXP (x, 1)) : 0x12345678);\n+      if (IN_RANGE (i, -128, 127))\n+\treturn speed ? 0 : 1;\n+      if (IN_RANGE (i, -32768, 32767))\n+\treturn speed ? 0 : 2;\n+      return speed ? 2 : 6;\n \n-\tcase NO_REGS:\n-\t  return 5;\n+    default:\n+      return rtx_cost (x, MEM, speed);\n+    }\n+}\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+/* Implement the TARGET_REGISTER_MOVE_COST hook.\n \n-    case PLUS:\n-    case MINUS:\n-    case ASHIFT:\n-    case AND:\n-    case IOR:\n-      return (mn10300_address_cost_1 (XEXP (x, 0), unsig)\n-\t      + mn10300_address_cost_1 (XEXP (x, 1), unsig));\n+   Recall that the base value of 2 is required by assumptions elsewhere\n+   in the body of the compiler, and that cost 2 is special-cased as an\n+   early exit from reload meaning no work is required.  */\n \n-    case EXPR_LIST:\n-    case SUBREG:\n-    case MEM:\n-      return mn10300_address_cost (XEXP (x, 0), !optimize_size);\n+static int\n+mn10300_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    reg_class_t ifrom, reg_class_t ito)\n+{\n+  enum reg_class from = (enum reg_class) ifrom;\n+  enum reg_class to = (enum reg_class) ito;\n+  enum reg_class scratch, test;\n+\n+  /* Simplify the following code by unifying the fp register classes.  */\n+  if (to == FP_ACC_REGS)\n+    to = FP_REGS;\n+  if (from == FP_ACC_REGS)\n+    from = FP_REGS;\n+\n+  /* Diagnose invalid moves by costing them as two moves.  */\n+\n+  scratch = NO_REGS;\n+  test = from;\n+  if (to == SP_REGS)\n+    scratch = (TARGET_AM33 ? GENERAL_REGS : ADDRESS_REGS);\n+  else if (to == FP_REGS && to != from)\n+    scratch = GENERAL_REGS;\n+  else\n+    {\n+      test = to;\n+      if (from == SP_REGS)\n+\tscratch = (TARGET_AM33 ? GENERAL_REGS : ADDRESS_REGS);\n+      else if (from == FP_REGS && to != from)\n+\tscratch = GENERAL_REGS;\n+    }\n+  if (scratch != NO_REGS && !reg_class_subset_p (test, scratch))\n+    return (mn10300_register_move_cost (VOIDmode, from, scratch)\n+\t    + mn10300_register_move_cost (VOIDmode, scratch, to));\n \n-    case ZERO_EXTEND:\n-      *unsig = 1;\n-      return mn10300_address_cost_1 (XEXP (x, 0), unsig);\n+  /* From here on, all we need consider are legal combinations.  */\n \n-    case CONST_INT:\n-      if (INTVAL (x) == 0)\n-\treturn 0;\n-      if (INTVAL (x) + (*unsig ? 0 : 0x80) < 0x100)\n-\treturn 1;\n-      if (INTVAL (x) + (*unsig ? 0 : 0x8000) < 0x10000)\n-\treturn 3;\n-      if (INTVAL (x) + (*unsig ? 0 : 0x800000) < 0x1000000)\n-\treturn 5;\n-      return 7;\n+  if (optimize_size)\n+    {\n+      /* The scale here is bytes * 2.  */\n \n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 8;\n+      if (from == to && (to == ADDRESS_REGS || to == DATA_REGS))\n+\treturn 2;\n \n-    default:\n-      gcc_unreachable ();\n+      if (from == SP_REGS)\n+\treturn (to == ADDRESS_REGS ? 2 : 6);\n+\n+      /* For MN103, all remaining legal moves are two bytes.  */\n+      if (TARGET_AM33)\n+\treturn 4;\n+\n+      if (to == SP_REGS)\n+\treturn (from == ADDRESS_REGS ? 4 : 6);\n+\n+      if ((from == ADDRESS_REGS || from == DATA_REGS)\n+\t   && (to == ADDRESS_REGS || to == DATA_REGS))\n+\treturn 4;\n+\n+      if (to == EXTENDED_REGS)\n+\treturn (to == from ? 6 : 4);\n \n+      /* What's left are SP_REGS, FP_REGS, or combinations of the above.  */\n+      return 6;\n+    }\n+  else\n+    {\n+      /* The scale here is cycles * 2.  */\n+\n+      if (to == FP_REGS)\n+\treturn 8;\n+      if (from == FP_REGS)\n+\treturn 4;\n+\n+      /* All legal moves between integral registers are single cycle.  */\n+      return 2;\n     }\n }\n \n+/* Implement the TARGET_MEMORY_MOVE_COST hook.\n+\n+   Given lack of the form of the address, this must be speed-relative,\n+   though we should never be less expensive than a size-relative register\n+   move cost above.  This is not a problem.  */\n+\n static int\n-mn10300_address_cost (rtx x, bool speed ATTRIBUTE_UNUSED)\n+mn10300_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED, \n+\t\t\t  reg_class_t iclass, bool in ATTRIBUTE_UNUSED)\n {\n-  int s = 0;\n-  return mn10300_address_cost_1 (x, &s);\n+  enum reg_class rclass = (enum reg_class) iclass;\n+\n+  if (rclass == FP_REGS)\n+    return 8;\n+  return 6;\n }\n \n+/* Implement the TARGET_RTX_COSTS hook.\n+\n+   Speed-relative costs are relative to COSTS_N_INSNS, which is intended\n+   to represent cycles.  Size-relative costs are in bytes.  */\n+\n static bool\n-mn10300_rtx_costs (rtx x, int code, int outer_code, int *total,\n-\t\t   bool speed ATTRIBUTE_UNUSED)\n+mn10300_rtx_costs (rtx x, int code, int outer_code, int *ptotal, bool speed)\n {\n+  /* This value is used for SYMBOL_REF etc where we want to pretend\n+     we have a full 32-bit constant.  */\n+  HOST_WIDE_INT i = 0x12345678;\n+  int total;\n+\n   switch (code)\n     {\n     case CONST_INT:\n-      /* Zeros are extremely cheap.  */\n-      if (INTVAL (x) == 0 && (outer_code == SET || outer_code == COMPARE))\n-\t*total = 0;\n-      /* If it fits in 8 bits, then it's still relatively cheap.  */\n-      else if (INT_8_BITS (INTVAL (x)))\n-\t*total = 1;\n-      /* This is the \"base\" cost, includes constants where either the\n-\t upper or lower 16bits are all zeros.  */\n-      else if (INT_16_BITS (INTVAL (x))\n-\t       || (INTVAL (x) & 0xffff) == 0\n-\t       || (INTVAL (x) & 0xffff0000) == 0)\n-\t*total = 2;\n+      i = INTVAL (x);\n+    do_int_costs:\n+      if (speed)\n+\t{\n+\t  if (outer_code == SET)\n+\t    {\n+\t      /* 16-bit integer loads have latency 1, 32-bit loads 2.  */\n+\t      if (IN_RANGE (i, -32768, 32767))\n+\t\ttotal = COSTS_N_INSNS (1);\n+\t      else\n+\t\ttotal = COSTS_N_INSNS (2);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* 16-bit integer operands don't affect latency;\n+\t\t 24-bit and 32-bit operands add a cycle.  */\n+\t      if (IN_RANGE (i, -32768, 32767))\n+\t\ttotal = 0;\n+\t      else\n+\t\ttotal = COSTS_N_INSNS (1);\n+\t    }\n+\t}\n       else\n-\t*total = 4;\n-      return true;\n+\t{\n+\t  if (outer_code == SET)\n+\t    {\n+\t      if (i == 0)\n+\t\ttotal = 1;\n+\t      else if (IN_RANGE (i, -128, 127))\n+\t\ttotal = 2;\n+\t      else if (IN_RANGE (i, -32768, 32767))\n+\t\ttotal = 3;\n+\t      else\n+\t\ttotal = 6;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Reference here is ADD An,Dn, vs ADD imm,Dn.  */\n+\t      if (IN_RANGE (i, -128, 127))\n+\t\ttotal = 0;\n+\t      else if (IN_RANGE (i, -32768, 32767))\n+\t\ttotal = 2;\n+\t      else if (TARGET_AM33 && IN_RANGE (i, -0x01000000, 0x00ffffff))\n+\t\ttotal = 3;\n+\t      else\n+\t\ttotal = 4;\n+\t    }\n+\t}\n+      goto alldone;\n \n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n-      /* These are more costly than a CONST_INT, but we can relax them,\n-\t so they're less costly than a CONST_DOUBLE.  */\n-      *total = 6;\n-      return true;\n-\n     case CONST_DOUBLE:\n-      /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\n-\t so their cost is very high.  */\n-      *total = 8;\n-      return true;\n-\n-    case ZERO_EXTRACT:\n-      /* This is cheap, we can use btst.  */\n-      if (outer_code == COMPARE)\n-\t*total = 0;\n-      return false;\n+      /* We assume all of these require a 32-bit constant, even though\n+\t some symbol and label references can be relaxed.  */\n+      goto do_int_costs;\n \n-   /* ??? This probably needs more work.  */\n-    case MOD:\n-    case DIV:\n-    case MULT:\n-      *total = 8;\n-      return true;\n+    case UNSPEC:\n+      switch (XINT (x, 1))\n+\t{\n+\tcase UNSPEC_PIC:\n+\tcase UNSPEC_GOT:\n+\tcase UNSPEC_GOTOFF:\n+\tcase UNSPEC_PLT:\n+\tcase UNSPEC_GOTSYM_OFF:\n+\t  /* The PIC unspecs also resolve to a 32-bit constant.  */\n+\t  goto do_int_costs;\n \n-    default:\n-      return false;\n-    }\n-}\n+\tdefault:\n+\t  /* Assume any non-listed unspec is some sort of arithmetic.  */\n+\t  goto do_arith_costs;\n+\t}\n \n-/* Check whether a constant used to initialize a DImode or DFmode can\n-   use a clr instruction.  The code here must be kept in sync with\n-   movdf and movdi.  */\n+    case PLUS:\n+      /* Notice the size difference of INC and INC4.  */\n+      if (!speed && outer_code == SET && CONST_INT_P (XEXP (x, 1)))\n+\t{\n+\t  i = INTVAL (XEXP (x, 1));\n+\t  if (i == 1 || i == 4)\n+\t    {\n+\t      total = 1 + rtx_cost (XEXP (x, 0), PLUS, speed);\n+\t      goto alldone;\n+\t    }\n+\t}\n+      goto do_arith_costs;\n+\t\n+    case MINUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case NOT:\n+    case NEG:\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+    case COMPARE:\n+    case BSWAP:\n+    case CLZ:\n+    do_arith_costs:\n+      total = (speed ? COSTS_N_INSNS (1) : 2);\n+      break;\n \n-bool\n-mn10300_wide_const_load_uses_clr (rtx operands[2])\n-{\n-  long val[2] = {0, 0};\n+    case ASHIFT:\n+      /* Notice the size difference of ASL2 and variants.  */\n+      if (!speed && CONST_INT_P (XEXP (x, 1)))\n+\tswitch (INTVAL (XEXP (x, 1)))\n+\t  {\n+\t  case 1:\n+\t  case 2:\n+\t    total = 1;\n+\t    goto alldone;\n+\t  case 3:\n+\t  case 4:\n+\t    total = 2;\n+\t    goto alldone;\n+\t  }\n+      /* FALLTHRU */\n \n-  if ((! REG_P (operands[0]))\n-      || REGNO_REG_CLASS (REGNO (operands[0])) != DATA_REGS)\n-    return false;\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      total = (speed ? COSTS_N_INSNS (1) : 3);\n+      goto alldone;\n \n-  switch (GET_CODE (operands[1]))\n-    {\n-    case CONST_INT:\n-      {\n-\trtx low, high;\n-\tsplit_double (operands[1], &low, &high);\n-\tval[0] = INTVAL (low);\n-\tval[1] = INTVAL (high);\n-      }\n+    case MULT:\n+      total = (speed ? COSTS_N_INSNS (3) : 2);\n       break;\n \n-    case CONST_DOUBLE:\n-      if (GET_MODE (operands[1]) == DFmode)\n-\t{\n-\t  REAL_VALUE_TYPE rv;\n-\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n-\t}\n-      else if (GET_MODE (operands[1]) == VOIDmode\n-\t       || GET_MODE (operands[1]) == DImode)\n-\t{\n-\t  val[0] = CONST_DOUBLE_LOW (operands[1]);\n-\t  val[1] = CONST_DOUBLE_HIGH (operands[1]);\n-\t}\n+    case DIV:\n+    case UDIV:\n+    case MOD:\n+    case UMOD:\n+      total = (speed ? COSTS_N_INSNS (39)\n+\t\t/* Include space to load+retrieve MDR.  */\n+\t\t: code == MOD || code == UMOD ? 6 : 4);\n       break;\n \n+    case MEM:\n+      total = mn10300_address_cost (XEXP (x, 0), speed);\n+      if (speed)\n+\ttotal = COSTS_N_INSNS (2 + total);\n+      goto alldone;\n+\n     default:\n-      return false;\n+      /* Probably not implemented.  Assume external call.  */\n+      total = (speed ? COSTS_N_INSNS (10) : 7);\n+      break;\n     }\n \n-  return val[0] == 0 || val[1] == 0;\n+  *ptotal = total;\n+  return false;\n+\n+ alldone:\n+  *ptotal = total;\n+  return true;\n }\n+\n /* If using PIC, mark a SYMBOL_REF for a non-global symbol so that we\n    may access it using GOTOFF instead of GOT.  */\n \n@@ -2502,10 +2660,14 @@ mn10300_conditional_register_usage (void)\n #undef  TARGET_LEGITIMIZE_ADDRESS\n #define TARGET_LEGITIMIZE_ADDRESS mn10300_legitimize_address\n \n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST  mn10300_address_cost\n+#undef  TARGET_REGISTER_MOVE_COST\n+#define TARGET_REGISTER_MOVE_COST  mn10300_register_move_cost\n+#undef  TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST  mn10300_memory_move_cost\n #undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS mn10300_rtx_costs\n-#undef  TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST mn10300_address_cost\n \n #undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START mn10300_file_start"}, {"sha": "ef79245b4cfca9a46226e09b3ea53eeb65e9870d", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d6e3c594d6e52200aecadc38d98d273a351935/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=72d6e3c594d6e52200aecadc38d98d273a351935", "patch": "@@ -600,19 +600,6 @@ struct cum_arg\n #define SELECT_CC_MODE(OP, X, Y)  mn10300_select_cc_mode (X)\n #define REVERSIBLE_CC_MODE(MODE)  0\n \f\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n-  ((CLASS1 == CLASS2 && (CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS)) ? 2 :\\\n-   ((CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS) && \\\n-    (CLASS2 == ADDRESS_REGS || CLASS2 == DATA_REGS)) ? 4 : \\\n-   (CLASS1 == SP_REGS && CLASS2 == ADDRESS_REGS) ? 2 : \\\n-   (CLASS1 == ADDRESS_REGS && CLASS2 == SP_REGS) ? 4 : \\\n-   ! TARGET_AM33 ? 6 : \\\n-   (CLASS1 == SP_REGS || CLASS2 == SP_REGS) ? 6 : \\\n-   (CLASS1 == CLASS2 && CLASS1 == EXTENDED_REGS) ? 6 : \\\n-   (CLASS1 == FP_REGS || CLASS2 == FP_REGS) ? 6 : \\\n-   (CLASS1 == EXTENDED_REGS || CLASS2 == EXTENDED_REGS) ? 4 : \\\n-   4)\n-\n /* Nonzero if access to memory by bytes or half words is no faster\n    than accessing full words.  */\n #define SLOW_BYTE_ACCESS 1"}]}