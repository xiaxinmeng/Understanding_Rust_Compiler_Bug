{"sha": "884815aa85fb661f34e3ea02c2a5b5aa02622ded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg0ODE1YWE4NWZiNjYxZjM0ZTNlYTAyYzJhNWI1YWEwMjYyMmRlZA==", "commit": {"author": {"name": "Jan Beulich", "email": "jbeulich@novell.com", "date": "2004-07-08T06:08:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-08T06:08:52Z"}, "message": "expmed.c (emit_store_flag): Also special-case double-word (in-)equality comparison against -1.\n\n        * expmed.c (emit_store_flag): Also special-case double-word\n        (in-)equality comparison against -1.\n\nFrom-SVN: r84268", "tree": {"sha": "a82a020cc231752174fc7f29a3b995cabb06c7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a82a020cc231752174fc7f29a3b995cabb06c7a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/884815aa85fb661f34e3ea02c2a5b5aa02622ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884815aa85fb661f34e3ea02c2a5b5aa02622ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/884815aa85fb661f34e3ea02c2a5b5aa02622ded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/884815aa85fb661f34e3ea02c2a5b5aa02622ded/comments", "author": null, "committer": null, "parents": [{"sha": "ff15c351eda434655cde7e6153b1a27db404a86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff15c351eda434655cde7e6153b1a27db404a86d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff15c351eda434655cde7e6153b1a27db404a86d"}], "stats": {"total": 21, "additions": 13, "deletions": 8}, "files": [{"sha": "74463e757b7797862ecc03bc13e2d2f7bc4c3892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884815aa85fb661f34e3ea02c2a5b5aa02622ded/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884815aa85fb661f34e3ea02c2a5b5aa02622ded/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=884815aa85fb661f34e3ea02c2a5b5aa02622ded", "patch": "@@ -1,5 +1,8 @@\n 2004-07-06 Jan Beulich <jbeulich@novell.com>\n                                                                                 \n+        * expmed.c (emit_store_flag): Also special-case double-word\n+        (in-)equality comparison against -1.\n+\n \t* config/i386/i386.c (ix86_gimplify_va_arg): Don't need temporary for\n \tpassing arguments the containers for which are registers.\n "}, {"sha": "ba3c9a6f83b5159c8500f25333610674363bf8c9", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/884815aa85fb661f34e3ea02c2a5b5aa02622ded/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/884815aa85fb661f34e3ea02c2a5b5aa02622ded/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=884815aa85fb661f34e3ea02c2a5b5aa02622ded", "patch": "@@ -4602,27 +4602,29 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       break;\n     }\n \n-  /* If we are comparing a double-word integer with zero, we can convert\n-     the comparison into one involving a single word.  */\n+  /* If we are comparing a double-word integer with zero or -1, we can\n+     convert the comparison into one involving a single word.  */\n   if (GET_MODE_BITSIZE (mode) == BITS_PER_WORD * 2\n       && GET_MODE_CLASS (mode) == MODE_INT\n-      && op1 == const0_rtx\n       && (!MEM_P (op0) || ! MEM_VOLATILE_P (op0)))\n     {\n-      if (code == EQ || code == NE)\n+      if ((code == EQ || code == NE)\n+\t  && (op1 == const0_rtx || op1 == constm1_rtx))\n \t{\n \t  rtx op00, op01, op0both;\n \n-\t  /* Do a logical OR of the two words and compare the result.  */\n+\t  /* Do a logical OR or AND of the two words and compare the result.  */\n \t  op00 = simplify_gen_subreg (word_mode, op0, mode, 0);\n \t  op01 = simplify_gen_subreg (word_mode, op0, mode, UNITS_PER_WORD);\n-\t  op0both = expand_binop (word_mode, ior_optab, op00, op01,\n-\t\t\t\t  NULL_RTX, unsignedp, OPTAB_DIRECT);\n+\t  op0both = expand_binop (word_mode,\n+\t\t\t\t  op1 == const0_rtx ? ior_optab : and_optab,\n+\t\t\t\t  op00, op01, NULL_RTX, unsignedp, OPTAB_DIRECT);\n+\n \t  if (op0both != 0)\n \t    return emit_store_flag (target, code, op0both, op1, word_mode,\n \t\t\t\t    unsignedp, normalizep);\n \t}\n-      else if (code == LT || code == GE)\n+      else if ((code == LT || code == GE) && op1 == const0_rtx)\n \t{\n \t  rtx op0h;\n "}]}