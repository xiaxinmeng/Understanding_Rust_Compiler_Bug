{"sha": "e2157b49e6ebff6aff00a3868aef4c56bb09052c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIxNTdiNDllNmViZmY2YWZmMDBhMzg2OGFlZjRjNTZiYjA5MDUyYw==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-04-02T04:27:40Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-04-02T04:27:40Z"}, "message": "tree-scalar-evolution.c (add_to_evolution_1): Pass an extra argument at_stmt.\n\n\t* tree-scalar-evolution.c (add_to_evolution_1): Pass an extra argument\n\tat_stmt.  Convert the type of operands before calling \n\tbuild_polynomial_chrec.\n\t(add_to_evolution): Pass an extra argument at_stmt.  Adjust the call to\n\tadd_to_evolution_1.\n\t(follow_ssa_edge_in_rhs): Adjust call to add_to_evolution.\n\t(instantiate_parameters_1): Convert the type of operands before calling \n\tbuild_polynomial_chrec.\n\t* tree-chrec.c (chrec_fold_poly_cst, chrec_fold_plus_poly_poly,\n\tchrec_fold_multiply_poly_poly, chrec_replace_initial_condition,\n\treset_evolution_in_loop): Insert asserts to check the types of the\n\toperands.\n\t(chrec_type): Moved...\n\t(eq_evolutions_p): Use operand_equal_p.\n\t* tree-chrec.h (build_polynomial_chrec): Insert an assert to check\n\tthe types of the operands.\n\t(chrec_type): ...here.\n\t* tree-data-ref.c (create_data_ref): Convert the operands before\n\tcalling chrec_replace_initial_condition.\n\t(same_access_functions, analyze_subscript_affine_affine,\n\tanalyze_miv_subscript, all_chrecs_equal_p): Use eq_evolutions_p.\n\t(compute_subscript_distance, analyze_ziv_subscript,\n\tanalyze_siv_subscript_cst_affine, compute_overlap_steps_for_affine_1_2,\n\tanalyze_miv_subscript): Convert the operands before calling\n\tchrec_fold_minus or chrec_fold_plus.\n\nFrom-SVN: r112621", "tree": {"sha": "83a4359437b9ecf688ad5a570bc8501f4db08ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83a4359437b9ecf688ad5a570bc8501f4db08ebd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2157b49e6ebff6aff00a3868aef4c56bb09052c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2157b49e6ebff6aff00a3868aef4c56bb09052c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2157b49e6ebff6aff00a3868aef4c56bb09052c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2157b49e6ebff6aff00a3868aef4c56bb09052c/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a84481aacbf798637896bf82b7992872421691e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a84481aacbf798637896bf82b7992872421691e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a84481aacbf798637896bf82b7992872421691e1"}], "stats": {"total": 256, "additions": 167, "deletions": 89}, "files": [{"sha": "e4b1e4caa97df46d6423dc94e49f00c74e68d212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2157b49e6ebff6aff00a3868aef4c56bb09052c", "patch": "@@ -1,3 +1,31 @@\n+2006-04-02  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-scalar-evolution.c (add_to_evolution_1): Pass an extra argument\n+\tat_stmt.  Convert the type of operands before calling \n+\tbuild_polynomial_chrec.\n+\t(add_to_evolution): Pass an extra argument at_stmt.  Adjust the call to\n+\tadd_to_evolution_1.\n+\t(follow_ssa_edge_in_rhs): Adjust call to add_to_evolution.\n+\t(instantiate_parameters_1): Convert the type of operands before calling \n+\tbuild_polynomial_chrec.\n+\t* tree-chrec.c (chrec_fold_poly_cst, chrec_fold_plus_poly_poly,\n+\tchrec_fold_multiply_poly_poly, chrec_replace_initial_condition,\n+\treset_evolution_in_loop): Insert asserts to check the types of the\n+\toperands.\n+\t(chrec_type): Moved...\n+\t(eq_evolutions_p): Use operand_equal_p.\n+\t* tree-chrec.h (build_polynomial_chrec): Insert an assert to check\n+\tthe types of the operands.\n+\t(chrec_type): ...here.\n+\t* tree-data-ref.c (create_data_ref): Convert the operands before\n+\tcalling chrec_replace_initial_condition.\n+\t(same_access_functions, analyze_subscript_affine_affine,\n+\tanalyze_miv_subscript, all_chrecs_equal_p): Use eq_evolutions_p.\n+\t(compute_subscript_distance, analyze_ziv_subscript,\n+\tanalyze_siv_subscript_cst_affine, compute_overlap_steps_for_affine_1_2,\n+\tanalyze_miv_subscript): Convert the operands before calling\n+\tchrec_fold_minus or chrec_fold_plus.\n+\n 2006-04-02  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \t* tree-data-ref.c (compute_all_dependences): Use a pointer to"}, {"sha": "5eb9037598be549c1f05a56d8f710b55a392fa13", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=e2157b49e6ebff6aff00a3868aef4c56bb09052c", "patch": "@@ -63,7 +63,8 @@ chrec_fold_poly_cst (enum tree_code code,\n   gcc_assert (cst);\n   gcc_assert (TREE_CODE (poly) == POLYNOMIAL_CHREC);\n   gcc_assert (!is_not_constant_evolution (cst));\n-  \n+  gcc_assert (type == chrec_type (poly));\n+\n   switch (code)\n     {\n     case PLUS_EXPR:\n@@ -103,6 +104,8 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n   gcc_assert (poly1);\n   gcc_assert (TREE_CODE (poly0) == POLYNOMIAL_CHREC);\n   gcc_assert (TREE_CODE (poly1) == POLYNOMIAL_CHREC);\n+  gcc_assert (chrec_type (poly0) == chrec_type (poly1));\n+  gcc_assert (type == chrec_type (poly0));\n   \n   /*\n     {a, +, b}_1 + {c, +, d}_2  ->  {{a, +, b}_1 + c, +, d}_2,\n@@ -177,6 +180,8 @@ chrec_fold_multiply_poly_poly (tree type,\n   gcc_assert (poly1);\n   gcc_assert (TREE_CODE (poly0) == POLYNOMIAL_CHREC);\n   gcc_assert (TREE_CODE (poly1) == POLYNOMIAL_CHREC);\n+  gcc_assert (chrec_type (poly0) == chrec_type (poly1));\n+  gcc_assert (type == chrec_type (poly0));\n   \n   /* {a, +, b}_1 * {c, +, d}_2  ->  {c*{a, +, b}_1, +, d}_2,\n      {a, +, b}_2 * {c, +, d}_1  ->  {a*{c, +, d}_1, +, b}_2,\n@@ -246,10 +251,8 @@ chrec_fold_automatically_generated_operands (tree op0,\n /* Fold the addition of two chrecs.  */\n \n static tree\n-chrec_fold_plus_1 (enum tree_code code, \n-\t\t   tree type, \n-\t\t   tree op0,\n-\t\t   tree op1)\n+chrec_fold_plus_1 (enum tree_code code, tree type, \n+\t\t   tree op0, tree op1)\n {\n   if (automatically_generated_chrec_p (op0)\n       || automatically_generated_chrec_p (op1))\n@@ -319,6 +322,10 @@ chrec_fold_plus (tree type,\n \t\t tree op0,\n \t\t tree op1)\n {\n+  if (automatically_generated_chrec_p (op0)\n+      || automatically_generated_chrec_p (op1))\n+    return chrec_fold_automatically_generated_operands (op0, op1);\n+\n   if (integer_zerop (op0))\n     return op1;\n   if (integer_zerop (op1))\n@@ -334,6 +341,10 @@ chrec_fold_minus (tree type,\n \t\t  tree op0, \n \t\t  tree op1)\n {\n+  if (automatically_generated_chrec_p (op0)\n+      || automatically_generated_chrec_p (op1))\n+    return chrec_fold_automatically_generated_operands (op0, op1);\n+\n   if (integer_zerop (op1))\n     return op0;\n   \n@@ -583,7 +594,9 @@ chrec_replace_initial_condition (tree chrec,\n {\n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n-  \n+\n+  gcc_assert (chrec_type (chrec) == chrec_type (init_cond));\n+\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n@@ -729,6 +742,8 @@ reset_evolution_in_loop (unsigned loop_num,\n \t\t\t tree chrec, \n \t\t\t tree new_evol)\n {\n+  gcc_assert (chrec_type (chrec) == chrec_type (new_evol));\n+\n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n       && CHREC_VARIABLE (chrec) > loop_num)\n     {\n@@ -1241,17 +1256,6 @@ chrec_convert_aggressive (tree type, tree chrec)\n   return build_polynomial_chrec (CHREC_VARIABLE (chrec), lc, rc);\n }\n \n-/* Returns the type of the chrec.  */\n-\n-tree \n-chrec_type (tree chrec)\n-{\n-  if (automatically_generated_chrec_p (chrec))\n-    return NULL_TREE;\n-  \n-  return TREE_TYPE (chrec);\n-}\n-\n /* Returns true when CHREC0 == CHREC1.  */\n \n bool \n@@ -1269,8 +1273,8 @@ eq_evolutions_p (tree chrec0,\n   switch (TREE_CODE (chrec0))\n     {\n     case INTEGER_CST:\n-      return integer_zerop (fold (build2 (MINUS_EXPR, TREE_TYPE (chrec0), \n-\t\t\t\t\t chrec0, chrec1)));\n+      return operand_equal_p (chrec0, chrec1, 0);\n+\n     case POLYNOMIAL_CHREC:\n       return (CHREC_VARIABLE (chrec0) == CHREC_VARIABLE (chrec1)\n \t      && eq_evolutions_p (CHREC_LEFT (chrec0), CHREC_LEFT (chrec1))"}, {"sha": "bc5c7782201d1dc7757ac9e117c15604dbbda12e", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=e2157b49e6ebff6aff00a3868aef4c56bb09052c", "patch": "@@ -69,7 +69,6 @@ extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n extern tree chrec_convert (tree, tree, tree);\n extern tree chrec_convert_aggressive (tree, tree);\n-extern tree chrec_type (tree);\n \n /* Operations.  */\n extern tree chrec_apply (unsigned, tree, tree);\n@@ -106,6 +105,8 @@ build_polynomial_chrec (unsigned loop_num,\n       || right == chrec_dont_know)\n     return chrec_dont_know;\n \n+  gcc_assert (TREE_TYPE (left) == TREE_TYPE (right));\n+\n   return build3 (POLYNOMIAL_CHREC, TREE_TYPE (left), \n \t\t build_int_cst (NULL_TREE, loop_num), left, right);\n }\n@@ -208,4 +209,16 @@ no_evolution_in_loop_p (tree chrec, unsigned loop_num, bool *res)\n   return true;\n }\n \n+/* Returns the type of the chrec.  */\n+\n+static inline tree\n+chrec_type (tree chrec)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return NULL_TREE;\n+\n+  return TREE_TYPE (chrec);\n+}\n+\n+\n #endif  /* GCC_TREE_CHREC_H  */"}, {"sha": "1421e7d3a288af0cd11eb219d7e580b679b4dcaf", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=e2157b49e6ebff6aff00a3868aef4c56bb09052c", "patch": "@@ -1930,8 +1930,8 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n \t\t\t       constant, type_size);\n     }\n   else\n-    DR_INIT (dr) = init_cond = ssize_int (0);;\n-  \n+    DR_INIT (dr) = init_cond = ssize_int (0);\n+\n   if (invariant)\n     DR_OFFSET (dr) = invariant;\n   else\n@@ -1957,6 +1957,8 @@ create_data_ref (tree memref, tree stmt, bool is_read)\n       new_step = size_binop (TRUNC_DIV_EXPR,  \n \t\t\t     fold_convert (ssizetype, step), type_size);\n \n+      init_cond = chrec_convert (chrec_type (access_fn), init_cond, stmt);\n+      new_step = chrec_convert (chrec_type (access_fn), new_step, stmt);\n       access_fn = chrec_replace_initial_condition (access_fn, init_cond);\n       access_fn = reset_evolution_in_loop (loop->num, access_fn, new_step);\n \n@@ -2011,14 +2013,10 @@ all_chrecs_equal_p (tree chrec)\n   int j;\n \n   for (j = 0; j < TREE_VEC_LENGTH (chrec) - 1; j++)\n-    {\n-      tree chrec_j = TREE_VEC_ELT (chrec, j);\n-      tree chrec_j_1 = TREE_VEC_ELT (chrec, j + 1);\n-      if (!integer_zerop \n-\t  (chrec_fold_minus \n-\t   (integer_type_node, chrec_j, chrec_j_1)))\n-\treturn false;\n-    }\n+    if (!eq_evolutions_p (TREE_VEC_ELT (chrec, j),\n+\t\t\t  TREE_VEC_ELT (chrec, j + 1)))\n+      return false;\n+\n   return true;\n }\n \n@@ -2063,6 +2061,10 @@ compute_subscript_distance (struct data_dependence_relation *ddr)\n \t\tconflicts_b = TREE_VEC_ELT (conflicts_b, 0);\n \t    }\n \n+\t  conflicts_b = chrec_convert (integer_type_node, conflicts_b,\n+\t\t\t\t       NULL_TREE);\n+\t  conflicts_a = chrec_convert (integer_type_node, conflicts_a,\n+\t\t\t\t       NULL_TREE);\n \t  difference = chrec_fold_minus \n \t    (integer_type_node, conflicts_b, conflicts_a);\n  \t  \n@@ -2250,6 +2252,8 @@ analyze_ziv_subscript (tree chrec_a,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_ziv_subscript \\n\");\n   \n+  chrec_a = chrec_convert (integer_type_node, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (integer_type_node, chrec_b, NULL_TREE);\n   difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n   \n   switch (TREE_CODE (difference))\n@@ -2323,7 +2327,11 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t\t\t  tree *last_conflicts)\n {\n   bool value0, value1, value2;\n-  tree difference = chrec_fold_minus \n+  tree difference;\n+\n+  chrec_a = chrec_convert (integer_type_node, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (integer_type_node, chrec_b, NULL_TREE);\n+  difference = chrec_fold_minus \n     (integer_type_node, CHREC_LEFT (chrec_b), chrec_a);\n   \n   if (!chrec_is_positive (initial_condition (difference), &value0))\n@@ -2641,32 +2649,52 @@ compute_overlap_steps_for_affine_1_2 (tree chrec_a, tree chrec_b,\n       *overlaps_b = integer_zero_node;\n       if (xz_p)\n \t{\n-\t  TREE_VEC_ELT (*overlaps_a, 0) = \n-\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 0),\n-\t\t\t     overlaps_a_xz);\n-\t  *overlaps_b = \n-\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_xz);\n+\t  tree t0 = chrec_convert (integer_type_node, \n+\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 0), NULL_TREE);\n+\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_xz,\n+\t\t\t\t   NULL_TREE);\n+\t  tree t2 = chrec_convert (integer_type_node, *overlaps_b,\n+\t\t\t\t   NULL_TREE);\n+\t  tree t3 = chrec_convert (integer_type_node, overlaps_b_xz,\n+\t\t\t\t   NULL_TREE);\n+\n+\t  TREE_VEC_ELT (*overlaps_a, 0) = chrec_fold_plus (integer_type_node,\n+\t\t\t\t\t\t\t   t0, t1);\n+\t  *overlaps_b = chrec_fold_plus (integer_type_node, t2, t3);\n \t  *last_conflicts = last_conflicts_xz;\n \t}\n       if (yz_p)\n \t{\n-\t  TREE_VEC_ELT (*overlaps_a, 1) = \n-\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 1),\n-\t\t\t     overlaps_a_yz);\n-\t  *overlaps_b = \n-\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_yz);\n+\t  tree t0 = chrec_convert (integer_type_node,\n+\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 1), NULL_TREE);\n+\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_yz, NULL_TREE);\n+\t  tree t2 = chrec_convert (integer_type_node, *overlaps_b, NULL_TREE);\n+\t  tree t3 = chrec_convert (integer_type_node, overlaps_b_yz, NULL_TREE);\n+\n+\t  TREE_VEC_ELT (*overlaps_a, 1) = chrec_fold_plus (integer_type_node,\n+\t\t\t\t\t\t\t   t0, t1);\n+\t  *overlaps_b = chrec_fold_plus (integer_type_node, t2, t3);\n \t  *last_conflicts = last_conflicts_yz;\n \t}\n       if (xyz_p)\n \t{\n-\t  TREE_VEC_ELT (*overlaps_a, 0) = \n-\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 0),\n-\t\t\t     overlaps_a_xyz);\n-\t  TREE_VEC_ELT (*overlaps_a, 1) = \n-\t    chrec_fold_plus (integer_type_node, TREE_VEC_ELT (*overlaps_a, 1),\n-\t\t\t     overlaps_a_xyz);\n-\t  *overlaps_b = \n-\t    chrec_fold_plus (integer_type_node, *overlaps_b, overlaps_b_xyz);\n+\t  tree t0 = chrec_convert (integer_type_node,\n+\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 0), NULL_TREE);\n+\t  tree t1 = chrec_convert (integer_type_node, overlaps_a_xyz,\n+\t\t\t\t   NULL_TREE);\n+\t  tree t2 = chrec_convert (integer_type_node,\n+\t\t\t\t   TREE_VEC_ELT (*overlaps_a, 1), NULL_TREE);\n+\t  tree t3 = chrec_convert (integer_type_node, overlaps_a_xyz,\n+\t\t\t\t   NULL_TREE);\n+\t  tree t4 = chrec_convert (integer_type_node, *overlaps_b, NULL_TREE);\n+\t  tree t5 = chrec_convert (integer_type_node, overlaps_b_xyz,\n+\t\t\t\t   NULL_TREE);\n+\n+\t  TREE_VEC_ELT (*overlaps_a, 0) = chrec_fold_plus (integer_type_node,\n+\t\t\t\t\t\t\t   t0, t1);\n+\t  TREE_VEC_ELT (*overlaps_a, 1) = chrec_fold_plus (integer_type_node,\n+\t\t\t\t\t\t\t   t2, t3);\n+\t  *overlaps_b = chrec_fold_plus (integer_type_node, t4, t5);\n \t  *last_conflicts = last_conflicts_xyz;\n \t}\n     }\n@@ -2694,12 +2722,11 @@ analyze_subscript_affine_affine (tree chrec_a,\n   int init_a, init_b, gamma, gcd_alpha_beta;\n   int tau1, tau2;\n   lambda_matrix A, U, S;\n-  tree difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n \n-  if (integer_zerop (difference))\n+  if (eq_evolutions_p (chrec_a, chrec_b))\n     {\n-      /* The difference is equal to zero: the accessed index\n-\t overlaps for each iteration in the loop.  */\n+      /* The accessed index overlaps for each iteration in the\n+\t loop.  */\n       *overlaps_a = integer_zero_node;\n       *overlaps_b = integer_zero_node;\n       *last_conflicts = chrec_dont_know;\n@@ -2719,7 +2746,6 @@ analyze_subscript_affine_affine (tree chrec_a,\n      there is no dependence.  This function outputs a description of\n      the iterations that hold the intersections.  */\n \n-  \n   nb_vars_a = nb_vars_in_chrec (chrec_a);\n   nb_vars_b = nb_vars_in_chrec (chrec_b);\n \n@@ -3177,10 +3203,12 @@ analyze_miv_subscript (tree chrec_a,\n   dependence_stats.num_miv++;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"(analyze_miv_subscript \\n\");\n-  \n+\n+  chrec_a = chrec_convert (integer_type_node, chrec_a, NULL_TREE);\n+  chrec_b = chrec_convert (integer_type_node, chrec_b, NULL_TREE);\n   difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n   \n-  if (chrec_zerop (difference))\n+  if (eq_evolutions_p (chrec_a, chrec_b))\n     {\n       /* Access functions are the same: all the elements are accessed\n \t in the same order.  */\n@@ -3502,15 +3530,9 @@ same_access_functions (struct data_dependence_relation *ddr)\n   unsigned i;\n \n   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    {\n-      tree access_fun_a = DR_ACCESS_FN (DDR_A (ddr), i);\n-      tree access_fun_b = DR_ACCESS_FN (DDR_B (ddr), i);\n-      tree difference = chrec_fold_minus (integer_type_node, access_fun_a,\n-\t\t\t\t\t  access_fun_b);\n-      if (TREE_CODE (difference) != INTEGER_CST\n-\t  || !integer_zerop (difference))\n-\treturn false;\n-    }\n+    if (!eq_evolutions_p (DR_ACCESS_FN (DDR_A (ddr), i),\n+\t\t\t  DR_ACCESS_FN (DDR_B (ddr), i)))\n+      return false;\n \n   return true;\n }"}, {"sha": "09fd5e9155e99aed87d69df37f3c171f23a6b0d5", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2157b49e6ebff6aff00a3868aef4c56bb09052c/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=e2157b49e6ebff6aff00a3868aef4c56bb09052c", "patch": "@@ -659,18 +659,19 @@ get_scalar_evolution (tree scalar)\n    part for this loop.  */\n \n static tree\n-add_to_evolution_1 (unsigned loop_nb, \n-\t\t    tree chrec_before, \n-\t\t    tree to_add)\n+add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n+\t\t    tree at_stmt)\n {\n+  tree type, left, right;\n+\n   switch (TREE_CODE (chrec_before))\n     {\n     case POLYNOMIAL_CHREC:\n       if (CHREC_VARIABLE (chrec_before) <= loop_nb)\n \t{\n \t  unsigned var;\n-\t  tree left, right;\n-\t  tree type = chrec_type (chrec_before);\n+\n+\t  type = chrec_type (chrec_before);\n \t  \n \t  /* When there is no evolution part in this loop, build it.  */\n \t  if (CHREC_VARIABLE (chrec_before) < loop_nb)\n@@ -688,21 +689,30 @@ add_to_evolution_1 (unsigned loop_nb,\n \t      right = CHREC_RIGHT (chrec_before);\n \t    }\n \n-\t  return build_polynomial_chrec \n-\t    (var, left, chrec_fold_plus (type, right, to_add));\n+\t  to_add = chrec_convert (type, to_add, at_stmt);\n+\t  right = chrec_convert (type, right, at_stmt);\n+\t  right = chrec_fold_plus (type, right, to_add);\n+\t  return build_polynomial_chrec (var, left, right);\n \t}\n       else\n-\t/* Search the evolution in LOOP_NB.  */\n-\treturn build_polynomial_chrec \n-\t  (CHREC_VARIABLE (chrec_before),\n-\t   add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before), to_add),\n-\t   CHREC_RIGHT (chrec_before));\n+\t{\n+\t  /* Search the evolution in LOOP_NB.  */\n+\t  left = add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before),\n+\t\t\t\t     to_add, at_stmt);\n+\t  right = CHREC_RIGHT (chrec_before);\n+\t  right = chrec_convert (chrec_type (left), right, at_stmt);\n+\t  return build_polynomial_chrec (CHREC_VARIABLE (chrec_before),\n+\t\t\t\t\t left, right);\n+\t}\n       \n     default:\n       /* These nodes do not depend on a loop.  */\n       if (chrec_before == chrec_dont_know)\n \treturn chrec_dont_know;\n-      return build_polynomial_chrec (loop_nb, chrec_before, to_add);\n+\n+      left = chrec_before;\n+      right = chrec_convert (chrec_type (left), to_add, at_stmt);\n+      return build_polynomial_chrec (loop_nb, left, right);\n     }\n }\n \n@@ -841,10 +851,8 @@ add_to_evolution_1 (unsigned loop_nb,\n */\n \n static tree \n-add_to_evolution (unsigned loop_nb, \n-\t\t  tree chrec_before,\n-\t\t  enum tree_code code,\n-\t\t  tree to_add)\n+add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n+\t\t  tree to_add, tree at_stmt)\n {\n   tree type = chrec_type (to_add);\n   tree res = NULL_TREE;\n@@ -874,7 +882,7 @@ add_to_evolution (unsigned loop_nb,\n \t\t\t\t  ? build_real (type, dconstm1)\n \t\t\t\t  : build_int_cst_type (type, -1));\n \n-  res = add_to_evolution_1 (loop_nb, chrec_before, to_add);\n+  res = add_to_evolution_1 (loop_nb, chrec_before, to_add, at_stmt);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1094,7 +1102,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, \n \t\t   chrec_convert (type_rhs, evol, at_stmt), \n-\t\t   PLUS_EXPR, rhs1);\n+\t\t   PLUS_EXPR, rhs1, at_stmt);\n \t      \n \t      else if (res == t_false)\n \t\t{\n@@ -1106,7 +1114,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t    *evolution_of_loop = add_to_evolution \n \t\t      (loop->num, \n \t\t       chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n-\t\t       PLUS_EXPR, rhs0);\n+\t\t       PLUS_EXPR, rhs0, at_stmt);\n \n \t\t  else if (res == t_dont_know)\n \t\t    *evolution_of_loop = chrec_dont_know;\n@@ -1127,7 +1135,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t     at_stmt),\n-\t\t   PLUS_EXPR, rhs1);\n+\t\t   PLUS_EXPR, rhs1, at_stmt);\n \n \t      else if (res == t_dont_know)\n \t\t*evolution_of_loop = chrec_dont_know;\n@@ -1145,7 +1153,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t    *evolution_of_loop = add_to_evolution \n \t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t at_stmt),\n-\t       PLUS_EXPR, rhs0);\n+\t       PLUS_EXPR, rhs0, at_stmt);\n \n \t  else if (res == t_dont_know)\n \t    *evolution_of_loop = chrec_dont_know;\n@@ -1175,7 +1183,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t  if (res == t_true)\n \t    *evolution_of_loop = add_to_evolution \n \t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop, at_stmt),\n-\t       MINUS_EXPR, rhs1);\n+\t       MINUS_EXPR, rhs1, at_stmt);\n \n \t  else if (res == t_dont_know)\n \t    *evolution_of_loop = chrec_dont_know;\n@@ -2043,7 +2051,10 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \n       if (CHREC_LEFT (chrec) != op0\n \t  || CHREC_RIGHT (chrec) != op1)\n-\tchrec = build_polynomial_chrec (CHREC_VARIABLE (chrec), op0, op1);\n+\t{\n+\t  op1 = chrec_convert (chrec_type (op0), op1, NULL_TREE);\n+\t  chrec = build_polynomial_chrec (CHREC_VARIABLE (chrec), op0, op1);\n+\t}\n       return chrec;\n \n     case PLUS_EXPR:"}]}