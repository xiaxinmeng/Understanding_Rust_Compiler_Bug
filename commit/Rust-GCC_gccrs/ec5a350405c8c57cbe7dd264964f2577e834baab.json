{"sha": "ec5a350405c8c57cbe7dd264964f2577e834baab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM1YTM1MDQwNWM4YzU3Y2JlN2RkMjY0OTY0ZjI1NzdlODM0YmFhYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-09-27T11:21:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-09-27T11:21:19Z"}, "message": "rtlanal.c (must_be_base_p, [...]): Delete.\n\ngcc/\n\t* rtlanal.c (must_be_base_p, must_be_index_p): Delete.\n\t(binary_scale_code_p, get_base_term, get_index_term): New functions.\n\t(set_address_segment, set_address_base, set_address_index)\n\t(set_address_disp): Accept the argument unconditionally.\n\t(baseness): Remove must_be_base_p and must_be_index_p checks.\n\t(decompose_normal_address): Classify as much as possible in the\n\tmain loop.\n\nFrom-SVN: r202970", "tree": {"sha": "8047e27d28756ef1496b114f430149b6a496557a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8047e27d28756ef1496b114f430149b6a496557a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec5a350405c8c57cbe7dd264964f2577e834baab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5a350405c8c57cbe7dd264964f2577e834baab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5a350405c8c57cbe7dd264964f2577e834baab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5a350405c8c57cbe7dd264964f2577e834baab/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f91aec98e2fe78e4200a22878968c9cdadb6187a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91aec98e2fe78e4200a22878968c9cdadb6187a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91aec98e2fe78e4200a22878968c9cdadb6187a"}], "stats": {"total": 111, "additions": 68, "deletions": 43}, "files": [{"sha": "4f40aadc96634ce1b95af7a69d4d1c6de9466dff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5a350405c8c57cbe7dd264964f2577e834baab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5a350405c8c57cbe7dd264964f2577e834baab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec5a350405c8c57cbe7dd264964f2577e834baab", "patch": "@@ -1,3 +1,13 @@\n+2013-09-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* rtlanal.c (must_be_base_p, must_be_index_p): Delete.\n+\t(binary_scale_code_p, get_base_term, get_index_term): New functions.\n+\t(set_address_segment, set_address_base, set_address_index)\n+\t(set_address_disp): Accept the argument unconditionally.\n+\t(baseness): Remove must_be_base_p and must_be_index_p checks.\n+\t(decompose_normal_address): Classify as much as possible in the\n+\tmain loop.\n+\n 2013-09-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* cse.c (count_reg_usage): Handle INT_LIST."}, {"sha": "7b2ec2406c04304b11a140f40251c2bf2a61e7d0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec5a350405c8c57cbe7dd264964f2577e834baab/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec5a350405c8c57cbe7dd264964f2577e834baab/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ec5a350405c8c57cbe7dd264964f2577e834baab", "patch": "@@ -5521,26 +5521,50 @@ strip_address_mutations (rtx *loc, enum rtx_code *outer_code)\n     }\n }\n \n-/* Return true if X must be a base rather than an index.  */\n+/* Return true if CODE applies some kind of scale.  The scaled value is\n+   is the first operand and the scale is the second.  */\n \n static bool\n-must_be_base_p (rtx x)\n+binary_scale_code_p (enum rtx_code code)\n {\n-  return GET_CODE (x) == LO_SUM;\n+  return (code == MULT\n+          || code == ASHIFT\n+          /* Needed by ARM targets.  */\n+          || code == ASHIFTRT\n+          || code == LSHIFTRT\n+          || code == ROTATE\n+          || code == ROTATERT);\n }\n \n-/* Return true if X must be an index rather than a base.  */\n+/* If *INNER can be interpreted as a base, return a pointer to the inner term\n+   (see address_info).  Return null otherwise.  */\n \n-static bool\n-must_be_index_p (rtx x)\n+static rtx *\n+get_base_term (rtx *inner)\n {\n-  return (GET_CODE (x) == MULT\n-          || GET_CODE (x) == ASHIFT\n-          /* Needed by ARM targets.  */\n-          || GET_CODE (x) == ASHIFTRT\n-          || GET_CODE (x) == LSHIFTRT\n-          || GET_CODE (x) == ROTATE\n-          || GET_CODE (x) == ROTATERT);\n+  if (GET_CODE (*inner) == LO_SUM)\n+    inner = strip_address_mutations (&XEXP (*inner, 0));\n+  if (REG_P (*inner)\n+      || MEM_P (*inner)\n+      || GET_CODE (*inner) == SUBREG)\n+    return inner;\n+  return 0;\n+}\n+\n+/* If *INNER can be interpreted as an index, return a pointer to the inner term\n+   (see address_info).  Return null otherwise.  */\n+\n+static rtx *\n+get_index_term (rtx *inner)\n+{\n+  /* At present, only constant scales are allowed.  */\n+  if (binary_scale_code_p (GET_CODE (*inner)) && CONSTANT_P (XEXP (*inner, 1)))\n+    inner = strip_address_mutations (&XEXP (*inner, 0));\n+  if (REG_P (*inner)\n+      || MEM_P (*inner)\n+      || GET_CODE (*inner) == SUBREG)\n+    return inner;\n+  return 0;\n }\n \n /* Set the segment part of address INFO to LOC, given that INNER is the\n@@ -5549,8 +5573,6 @@ must_be_index_p (rtx x)\n static void\n set_address_segment (struct address_info *info, rtx *loc, rtx *inner)\n {\n-  gcc_checking_assert (GET_CODE (*inner) == UNSPEC);\n-\n   gcc_assert (!info->segment);\n   info->segment = loc;\n   info->segment_term = inner;\n@@ -5562,12 +5584,6 @@ set_address_segment (struct address_info *info, rtx *loc, rtx *inner)\n static void\n set_address_base (struct address_info *info, rtx *loc, rtx *inner)\n {\n-  if (must_be_base_p (*inner))\n-    inner = strip_address_mutations (&XEXP (*inner, 0));\n-  gcc_checking_assert (REG_P (*inner)\n-\t\t       || MEM_P (*inner)\n-\t\t       || GET_CODE (*inner) == SUBREG);\n-\n   gcc_assert (!info->base);\n   info->base = loc;\n   info->base_term = inner;\n@@ -5579,12 +5595,6 @@ set_address_base (struct address_info *info, rtx *loc, rtx *inner)\n static void\n set_address_index (struct address_info *info, rtx *loc, rtx *inner)\n {\n-  if (must_be_index_p (*inner) && CONSTANT_P (XEXP (*inner, 1)))\n-    inner = strip_address_mutations (&XEXP (*inner, 0));\n-  gcc_checking_assert (REG_P (*inner)\n-\t\t       || MEM_P (*inner)\n-\t\t       || GET_CODE (*inner) == SUBREG);\n-\n   gcc_assert (!info->index);\n   info->index = loc;\n   info->index_term = inner;\n@@ -5596,8 +5606,6 @@ set_address_index (struct address_info *info, rtx *loc, rtx *inner)\n static void\n set_address_disp (struct address_info *info, rtx *loc, rtx *inner)\n {\n-  gcc_checking_assert (CONSTANT_P (*inner));\n-\n   gcc_assert (!info->disp);\n   info->disp = loc;\n   info->disp_term = inner;\n@@ -5677,12 +5685,6 @@ static int\n baseness (rtx x, enum machine_mode mode, addr_space_t as,\n \t  enum rtx_code outer_code, enum rtx_code index_code)\n {\n-  /* See whether we can be certain.  */\n-  if (must_be_base_p (x))\n-    return 3;\n-  if (must_be_index_p (x))\n-    return -3;\n-\n   /* Believe *_POINTER unless the address shape requires otherwise.  */\n   if (REG_P (x) && REG_POINTER (x))\n     return 2;\n@@ -5717,8 +5719,8 @@ decompose_normal_address (struct address_info *info)\n   if (n_ops > 1)\n     info->base_outer_code = PLUS;\n \n-  /* Separate the parts that contain a REG or MEM from those that don't.\n-     Record the latter in INFO and leave the former in OPS.  */\n+  /* Try to classify each sum operand now.  Leave those that could be\n+     either a base or an index in OPS.  */\n   rtx *inner_ops[4];\n   size_t out = 0;\n   for (size_t in = 0; in < n_ops; ++in)\n@@ -5731,18 +5733,31 @@ decompose_normal_address (struct address_info *info)\n \tset_address_segment (info, loc, inner);\n       else\n \t{\n-\t  ops[out] = loc;\n-\t  inner_ops[out] = inner;\n-\t  ++out;\n+\t  /* The only other possibilities are a base or an index.  */\n+\t  rtx *base_term = get_base_term (inner);\n+\t  rtx *index_term = get_index_term (inner);\n+\t  gcc_assert (base_term || index_term);\n+\t  if (!base_term)\n+\t    set_address_index (info, loc, index_term);\n+\t  else if (!index_term)\n+\t    set_address_base (info, loc, base_term);\n+\t  else\n+\t    {\n+\t      gcc_assert (base_term == index_term);\n+\t      ops[out] = loc;\n+\t      inner_ops[out] = base_term;\n+\t      ++out;\n+\t    }\n \t}\n     }\n \n   /* Classify the remaining OPS members as bases and indexes.  */\n   if (out == 1)\n     {\n-      /* Assume that the remaining value is a base unless the shape\n-\t requires otherwise.  */\n-      if (!must_be_index_p (*inner_ops[0]))\n+      /* If we haven't seen a base or an index yet, assume that this is\n+\t the base.  If we were confident that another term was the base\n+\t or index, treat the remaining operand as the other kind.  */\n+      if (!info->base)\n \tset_address_base (info, ops[0], inner_ops[0]);\n       else\n \tset_address_index (info, ops[0], inner_ops[0]);"}]}