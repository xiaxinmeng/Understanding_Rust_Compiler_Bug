{"sha": "fa62df0e600ef617bce549d64026c0e5cc817c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE2MmRmMGU2MDBlZjYxN2JjZTU0OWQ2NDAyNmMwZTVjYzgxN2MzMQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:04:38Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:04:38Z"}, "message": "[arm] Early split addvdi4\n\nThis patch adds early splitting for addvdi4; it's very similar to the\nuaddvdi4 splitter, but the details are just different enough in\nplaces, especially for the patterns that match the splitting, where we\nhave to compare against the non-widened version to detect if overflow\noccurred.\n\nI've also added a testcase to the testsuite for a couple of constants\nthat caught me out during the development of this patch.  They're\nprobably arm-specific values, but the test is generic enough that I've\nincluded it for all targets.\n\n[gcc]\n\t* config/arm/arm.c (arm_select_cc_mode): Allow either the first\n\tor second operand of the PLUS inside a DImode equality test to be\n\tsign-extend when selecting CC_Vmode.\n\t* config/arm/arm.md (addvdi4): Early-split the operation into SImode\n\tinstructions.\n\t(addsi3_cin_vout_reg, addsi3_cin_vout_imm, addsi3_cin_vout_0): New\n\texpand patterns.\n\t(addsi3_cin_vout_reg_insn, addsi3_cin_vout_imm_insn): New patterns.\n\t(addsi3_cin_vout_0): Likewise.\n\t(adddi3_compareV): Delete.\n\n[gcc/testsuite]\n\t* gcc.dg/builtin-arith-overflow-3.c: New test.\n\nFrom-SVN: r277186", "tree": {"sha": "56583c6d248e02eafd0d9dde04728a3aa05e74dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56583c6d248e02eafd0d9dde04728a3aa05e74dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa62df0e600ef617bce549d64026c0e5cc817c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa62df0e600ef617bce549d64026c0e5cc817c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa62df0e600ef617bce549d64026c0e5cc817c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa62df0e600ef617bce549d64026c0e5cc817c31/comments", "author": null, "committer": null, "parents": [{"sha": "db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db962d0ad4501f2f673fc3fadd4ac572ef9a177e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db962d0ad4501f2f673fc3fadd4ac572ef9a177e"}], "stats": {"total": 242, "additions": 220, "deletions": 22}, "files": [{"sha": "8275411b671eee980fa73744bc41df07de0eb6df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa62df0e600ef617bce549d64026c0e5cc817c31", "patch": "@@ -1,3 +1,16 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_select_cc_mode): Allow either the first\n+\tor second operand of the PLUS inside a DImode equality test to be\n+\tsign-extend when selecting CC_Vmode.\n+\t* config/arm/arm.md (addvdi4): Early-split the operation into SImode\n+\tinstructions.\n+\t(addsi3_cin_vout_reg, addsi3_cin_vout_imm, addsi3_cin_vout_0): New\n+\texpand patterns.\n+\t(addsi3_cin_vout_reg_insn, addsi3_cin_vout_imm_insn): New patterns.\n+\t(addsi3_cin_vout_0): Likewise.\n+\t(adddi3_compareV): Delete.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (addsi3_compareV_reg_nosum): New insn."}, {"sha": "fe240b2c1b8e7bee2a0a9d932e8a03590578bd70", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fa62df0e600ef617bce549d64026c0e5cc817c31", "patch": "@@ -15414,7 +15414,8 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n   if (GET_MODE (x) == DImode\n       && (op == EQ || op == NE)\n       && GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+      && (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t  || GET_CODE (XEXP (x, 1)) == SIGN_EXTEND)\n       && GET_CODE (y) == SIGN_EXTEND\n       && GET_CODE (XEXP (y, 0)) == PLUS)\n     return CC_Vmode;"}, {"sha": "e9e0ca925d28060eb431536f8c31e41d37a11ed1", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 160, "deletions": 21, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=fa62df0e600ef617bce549d64026c0e5cc817c31", "patch": "@@ -505,18 +505,173 @@\n })\n \n (define_expand \"addvdi4\"\n-  [(match_operand:DI 0 \"register_operand\")\n-   (match_operand:DI 1 \"register_operand\")\n-   (match_operand:DI 2 \"register_operand\")\n+  [(match_operand:DI 0 \"s_register_operand\")\n+   (match_operand:DI 1 \"s_register_operand\")\n+   (match_operand:DI 2 \"reg_or_int_operand\")\n    (match_operand 3 \"\")]\n   \"TARGET_32BIT\"\n {\n-  emit_insn (gen_adddi3_compareV (operands[0], operands[1], operands[2]));\n-  arm_gen_unlikely_cbranch (NE, CC_Vmode, operands[3]);\n+  rtx lo_result, hi_result;\n+  rtx lo_op1, hi_op1, lo_op2, hi_op2;\n+  arm_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,\n+\t\t\t  &lo_op2, &hi_op2);\n+  lo_result = gen_lowpart (SImode, operands[0]);\n+  hi_result = gen_highpart (SImode, operands[0]);\n+\n+  if (lo_op2 == const0_rtx)\n+    {\n+      emit_move_insn (lo_result, lo_op1);\n+      if (!arm_add_operand (hi_op2, SImode))\n+\thi_op2 = force_reg (SImode, hi_op2);\n+\n+      emit_insn (gen_addvsi4 (hi_result, hi_op1, hi_op2, operands[3]));\n+    }\n+  else\n+    {\n+      if (!arm_add_operand (lo_op2, SImode))\n+\tlo_op2 = force_reg (SImode, lo_op2);\n+      if (!arm_not_operand (hi_op2, SImode))\n+\thi_op2 = force_reg (SImode, hi_op2);\n+\n+      emit_insn (gen_addsi3_compare_op1 (lo_result, lo_op1, lo_op2));\n+\n+      if (hi_op2 == const0_rtx)\n+        emit_insn (gen_addsi3_cin_vout_0 (hi_result, hi_op1));\n+      else if (CONST_INT_P (hi_op2))\n+        emit_insn (gen_addsi3_cin_vout_imm (hi_result, hi_op1, hi_op2));\n+      else\n+        emit_insn (gen_addsi3_cin_vout_reg (hi_result, hi_op1, hi_op2));\n+\n+      arm_gen_unlikely_cbranch (NE, CC_Vmode, operands[3]);\n+    }\n \n   DONE;\n })\n \n+(define_expand \"addsi3_cin_vout_reg\"\n+  [(parallel\n+    [(set (match_dup 3)\n+\t  (compare:CC_V\n+\t   (plus:DI\n+\t    (plus:DI (match_dup 4)\n+\t\t     (sign_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t    (sign_extend:DI (match_operand:SI 2 \"s_register_operand\")))\n+\t   (sign_extend:DI (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t\t\t    (match_dup 2)))))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t   (match_dup 2)))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[3] = gen_rtx_REG (CC_Vmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[4] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[5] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_vout_reg_insn\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (match_operand:DI 3 \"arm_carry_operation\" \"\")\n+\t   (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"%0,r\")))\n+\t  (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"l,r\")))\n+\t (sign_extend:DI\n+\t  (plus:SI (plus:SI (match_operand:SI 4 \"arm_carry_operation\" \"\")\n+\t\t\t    (match_dup 1))\n+\t\t   (match_dup 2)))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=l,r\")\n+\t(plus:SI (plus:SI (match_dup 4) (match_dup 1))\n+\t\t (match_dup 2)))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   adcs%?\\\\t%0, %0, %2\n+   adcs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"alus_sreg\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")]\n+)\n+\n+(define_expand \"addsi3_cin_vout_imm\"\n+  [(parallel\n+    [(set (match_dup 3)\n+\t  (compare:CC_V\n+\t   (plus:DI\n+\t    (plus:DI (match_dup 4)\n+\t\t     (sign_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t    (match_dup 2))\n+\t   (sign_extend:DI (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t\t\t    (match_dup 2)))))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (plus:SI (match_dup 5) (match_dup 1))\n+\t\t   (match_operand 2 \"arm_adcimm_operand\")))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[3] = gen_rtx_REG (CC_Vmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[4] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[5] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_vout_imm_insn\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t (plus:DI\n+\t  (plus:DI\n+\t   (match_operand:DI 3 \"arm_carry_operation\" \"\")\n+\t   (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\")))\n+\t  (match_operand 2 \"arm_adcimm_operand\" \"I,K\"))\n+\t (sign_extend:DI\n+\t  (plus:SI (plus:SI (match_operand:SI 4 \"arm_carry_operation\" \"\")\n+\t\t\t    (match_dup 1))\n+\t\t   (match_dup 2)))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(plus:SI (plus:SI (match_dup 4) (match_dup 1))\n+\t\t (match_dup 2)))]\n+  \"TARGET_32BIT\"\n+  \"@\n+   adcs%?\\\\t%0, %1, %2\n+   sbcs%?\\\\t%0, %1, #%B2\"\n+  [(set_attr \"type\" \"alus_imm\")]\n+)\n+\n+(define_expand \"addsi3_cin_vout_0\"\n+  [(parallel\n+    [(set (match_dup 2)\n+\t  (compare:CC_V\n+\t   (plus:DI (match_dup 3)\n+\t\t    (sign_extend:DI (match_operand:SI 1 \"s_register_operand\")))\n+\t   (sign_extend:DI (plus:SI (match_dup 4) (match_dup 1)))))\n+     (set (match_operand:SI 0 \"s_register_operand\")\n+\t  (plus:SI (match_dup 4) (match_dup 1)))])]\n+  \"TARGET_32BIT\"\n+  {\n+    operands[2] = gen_rtx_REG (CC_Vmode, CC_REGNUM);\n+    rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+    operands[3] = gen_rtx_LTU (DImode, ccin, const0_rtx);\n+    operands[4] = gen_rtx_LTU (SImode, ccin, const0_rtx);\n+  }\n+)\n+\n+(define_insn \"*addsi3_cin_vout_0_insn\"\n+  [(set (reg:CC_V CC_REGNUM)\n+\t(compare:CC_V\n+\t (plus:DI\n+\t  (match_operand:DI 2 \"arm_carry_operation\" \"\")\n+\t  (sign_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r\")))\n+\t (sign_extend:DI (plus:SI\n+\t\t\t  (match_operand:SI 3 \"arm_carry_operation\" \"\")\n+\t\t\t  (match_dup 1)))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (match_dup 3) (match_dup 1)))]\n+  \"TARGET_32BIT\"\n+  \"adcs%?\\\\t%0, %1, #0\"\n+  [(set_attr \"type\" \"alus_imm\")]\n+)\n+\n (define_expand \"uaddvsi4\"\n   [(match_operand:SI 0 \"s_register_operand\")\n    (match_operand:SI 1 \"s_register_operand\")\n@@ -770,22 +925,6 @@\n  ]\n )\n \n-(define_insn \"adddi3_compareV\"\n-  [(set (reg:CC_V CC_REGNUM)\n-\t(ne:CC_V\n-\t  (plus:TI\n-\t    (sign_extend:TI (match_operand:DI 1 \"s_register_operand\" \"r\"))\n-\t    (sign_extend:TI (match_operand:DI 2 \"s_register_operand\" \"r\")))\n-\t  (sign_extend:TI (plus:DI (match_dup 1) (match_dup 2)))))\n-   (set (match_operand:DI 0 \"s_register_operand\" \"=&r\")\n-\t(plus:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_32BIT\"\n-  \"adds\\\\t%Q0, %Q1, %Q2;adcs\\\\t%R0, %R1, %R2\"\n- [(set_attr \"conds\" \"set\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_insn \"addsi3_compareV_reg\"\n   [(set (reg:CC_V CC_REGNUM)\n \t(compare:CC_V"}, {"sha": "4267ac48382ff5df4a8018e8237bbd9c487fd15e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa62df0e600ef617bce549d64026c0e5cc817c31", "patch": "@@ -1,3 +1,7 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* gcc.dg/builtin-arith-overflow-3.c: New test.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* gcc.target/arm/negdi-3.c: Remove XFAIL markers."}, {"sha": "6feae1eb42f66132470e9ad69111550d28b8a793", "filename": "gcc/testsuite/gcc.dg/builtin-arith-overflow-3.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa62df0e600ef617bce549d64026c0e5cc817c31/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-arith-overflow-3.c?ref=fa62df0e600ef617bce549d64026c0e5cc817c31", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+static int cnt = 0;\n+\n+#define LL_MIN ((long long)(-__LONG_LONG_MAX__ - 1))\n+\n+#define SC1 (LL_MIN + 5)\n+#define UC1 ((1ULL << (__LONG_LONG_WIDTH__ - 1)) | 5ULL)\n+#define UC2 (~UC1)\n+\n+long long __attribute__ ((noinline, noclone))\n+f1 (long long a)\n+{\n+  long long x;\n+  if (__builtin_add_overflow (a, SC1, &x)) cnt++;\n+  return x;\n+}\n+\n+unsigned long long __attribute__ ((noinline, noclone))\n+f2 (unsigned long long a)\n+{\n+  unsigned long long x;\n+  if (__builtin_add_overflow (a, UC1, &x))\n+    cnt++;\n+  return x;\n+}\n+\n+int main ()\n+{\n+  if (f1 (-5) != LL_MIN) __builtin_abort ();\n+  if (cnt != 0) __builtin_abort ();\n+  f1 (-6);\n+  if (cnt != 1) __builtin_abort ();\n+  cnt = 0;\n+  if (f2 (UC2) != ~0ULL) __builtin_abort ();\n+  if (cnt != 0) __builtin_abort ();\n+  if (f2 (UC2 + 1) != 0) __builtin_abort ();\n+  if (cnt != 1) __builtin_abort ();\n+  return 0;\n+}"}]}