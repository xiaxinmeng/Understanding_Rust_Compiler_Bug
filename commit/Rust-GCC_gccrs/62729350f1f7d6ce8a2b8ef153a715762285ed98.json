{"sha": "62729350f1f7d6ce8a2b8ef153a715762285ed98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI3MjkzNTBmMWY3ZDZjZThhMmI4ZWYxNTNhNzE1NzYyMjg1ZWQ5OA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-05-23T19:05:37Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-23T19:05:37Z"}, "message": "c-lex.c (read_escape, read_ucs): Delete.\n\n\t* c-lex.c (read_escape, read_ucs): Delete.\n\t(lex_string): Use cpp_parse_escape.\n\t* cpplex.c (read_ucs): Rename maybe_read_ucs.  Do nothing\n\tif not C++ or not C99.  Warn if traditional.\n\t(parse_escape): Rename cpp_parse_escape.  Make the bitmask\n\tunsigned.  Warn for out-of-range escape sequences here.\n\tUpdate to use maybe_read_ucs.\n\t(cpp_interpret_charconst):  Don't warn here.\n\t* cpplib.h (cpp_parse_escape): New exported function.\n\nFrom-SVN: r42509", "tree": {"sha": "0572715a50d0060cffa9b65761eba955082eb2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0572715a50d0060cffa9b65761eba955082eb2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62729350f1f7d6ce8a2b8ef153a715762285ed98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62729350f1f7d6ce8a2b8ef153a715762285ed98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62729350f1f7d6ce8a2b8ef153a715762285ed98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62729350f1f7d6ce8a2b8ef153a715762285ed98/comments", "author": null, "committer": null, "parents": [{"sha": "ff867905f91c0a19a7c057cd8539734b40946c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff867905f91c0a19a7c057cd8539734b40946c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff867905f91c0a19a7c057cd8539734b40946c0b"}], "stats": {"total": 330, "additions": 64, "deletions": 266}, "files": [{"sha": "e971438fc930b445b6e4432742eac3b08c9fead7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62729350f1f7d6ce8a2b8ef153a715762285ed98", "patch": "@@ -1,3 +1,15 @@\n+2001-05-23  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-lex.c (read_escape, read_ucs): Delete.\n+\t(lex_string): Use cpp_parse_escape.\n+\t* cpplex.c (read_ucs): Rename maybe_read_ucs.  Do nothing\n+\tif not C++ or not C99.  Warn if traditional.\n+\t(parse_escape): Rename cpp_parse_escape.  Make the bitmask\n+\tunsigned.  Warn for out-of-range escape sequences here.\n+\tUpdate to use maybe_read_ucs.\n+\t(cpp_interpret_charconst):  Don't warn here.\n+\t* cpplib.h (cpp_parse_escape): New exported function.\n+\n 2001-05-23  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* extend.texi (Attribute Syntax): Clarify application of"}, {"sha": "cb1590134a333d6eeaedef3cea1d12beb8a1de69", "filename": "gcc/c-lex.c", "status": "modified", "additions": 9, "deletions": 232, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=62729350f1f7d6ce8a2b8ef153a715762285ed98", "patch": "@@ -79,10 +79,6 @@ int c_header_level;\t /* depth in C headers - C++ only */\n /* Nonzero tells yylex to ignore \\ in string constants.  */\n static int ignore_escape_flag;\n \n-static const char *readescape\tPARAMS ((const char *, const char *,\n-\t\t\t\t\t unsigned int *));\n-static const char *read_ucs \tPARAMS ((const char *, const char *,\n-\t\t\t\t\t unsigned int *, int));\n static void parse_float\t\tPARAMS ((PTR));\n static tree lex_number\t\tPARAMS ((const char *, unsigned int));\n static tree lex_string\t\tPARAMS ((const char *, unsigned int, int));\n@@ -350,230 +346,6 @@ cb_undef (pfile, node)\n   debug_undef (lineno, (const char *) NODE_NAME (node));\n }\n \n-/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence.\n-\n-   [lex.charset]: The character designated by the universal-character-name \n-   \\UNNNNNNNN is that character whose character short name in ISO/IEC 10646\n-   is NNNNNNNN; the character designated by the universal-character-name\n-   \\uNNNN is that character whose character short name in ISO/IEC 10646 is\n-   0000NNNN. If the hexadecimal value for a universal character name is\n-   less than 0x20 or in the range 0x7F-0x9F (inclusive), or if the\n-   universal character name designates a character in the basic source\n-   character set, then the program is ill-formed.\n-\n-   We assume that wchar_t is Unicode, so we don't need to do any\n-   mapping.  Is this ever wrong?  */\n-\n-static const char *\n-read_ucs (p, limit, cptr, length)\n-     const char *p;\n-     const char *limit;\n-     unsigned int *cptr;\n-     int length;\n-{\n-  unsigned int code = 0;\n-  int c;\n-\n-  for (; length; --length)\n-    {\n-      if (p >= limit)\n-\t{\n-\t  error (\"incomplete universal-character-name\");\n-\t  break;\n-\t}\n-\n-      c = *p++;\n-      if (! ISXDIGIT (c))\n-\t{\n-\t  error (\"non hex digit '%c' in universal-character-name\", c);\n-\t  p--;\n-\t  break;\n-\t}\n-\n-      code <<= 4;\n-      if (c >= 'a' && c <= 'f')\n-\tcode += c - 'a' + 10;\n-      if (c >= 'A' && c <= 'F')\n-\tcode += c - 'A' + 10;\n-      if (c >= '0' && c <= '9')\n-\tcode += c - '0';\n-    }\n-\n-#ifdef TARGET_EBCDIC\n-  sorry (\"universal-character-name on EBCDIC target\");\n-  *cptr = 0x3f;  /* EBCDIC invalid character */\n-  return p;\n-#endif\n-\n-  if (code > 0x9f && !(code & 0x80000000))\n-    /* True extended character, OK.  */;\n-  else if (code >= 0x20 && code < 0x7f)\n-    {\n-      /* ASCII printable character.  The C character set consists of all of\n-\t these except $, @ and `.  We use hex escapes so that this also\n-\t works with EBCDIC hosts.  */\n-      if (code != 0x24 && code != 0x40 && code != 0x60)\n-\terror (\"universal-character-name used for '%c'\", code);\n-    }\n-  else\n-    error (\"invalid universal-character-name\");\n-\n-  *cptr = code;\n-  return p;\n-}\n-\n-/* Read an escape sequence and write its character equivalent into *CPTR.\n-   P is the input pointer, which is just after the backslash.  LIMIT\n-   is how much text we have.\n-   Returns the updated input pointer.  */\n-\n-static const char *\n-readescape (p, limit, cptr)\n-     const char *p;\n-     const char *limit;\n-     unsigned int *cptr;\n-{\n-  unsigned int c, code, count;\n-  unsigned firstdig = 0;\n-  int nonnull;\n-\n-  if (p == limit)\n-    {\n-      /* cpp has already issued an error for this.  */\n-      *cptr = 0;\n-      return p;\n-    }\n-\n-  c = *p++;\n-\n-  switch (c)\n-    {\n-    case 'x':\n-      if (warn_traditional && !in_system_header)\n-\twarning (\"the meaning of `\\\\x' varies with -traditional\");\n-\n-      if (flag_traditional)\n-\t{\n-\t  *cptr = 'x';\n-\t  return p;\n-\t}\n-\n-      code = 0;\n-      count = 0;\n-      nonnull = 0;\n-      while (p < limit)\n-\t{\n-\t  c = *p++;\n-\t  if (! ISXDIGIT (c))\n-\t    {\n-\t      p--;\n-\t      break;\n-\t    }\n-\t  code *= 16;\n-\t  if (c >= 'a' && c <= 'f')\n-\t    code += c - 'a' + 10;\n-\t  if (c >= 'A' && c <= 'F')\n-\t    code += c - 'A' + 10;\n-\t  if (c >= '0' && c <= '9')\n-\t    code += c - '0';\n-\t  if (code != 0 || count != 0)\n-\t    {\n-\t      if (count == 0)\n-\t\tfirstdig = code;\n-\t      count++;\n-\t    }\n-\t  nonnull = 1;\n-\t}\n-      if (! nonnull)\n-\t{\n-\t  warning (\"\\\\x used with no following hex digits\");\n-\t  *cptr = 'x';\n-\t  return p;\n-\t}\n-      else if (count == 0)\n-\t/* Digits are all 0's.  Ok.  */\n-\t;\n-      else if ((count - 1) * 4 >= TYPE_PRECISION (integer_type_node)\n-\t       || (count > 1\n-\t\t   && (((unsigned)1\n-\t\t\t<< (TYPE_PRECISION (integer_type_node)\n-\t\t\t    - (count - 1) * 4))\n-\t\t       <= firstdig)))\n-\tpedwarn (\"hex escape out of range\");\n-      *cptr = code;\n-      return p;\n-\n-    case '0':  case '1':  case '2':  case '3':  case '4':\n-    case '5':  case '6':  case '7':\n-      code = 0;\n-      for (count = 0; count < 3; count++)\n-\t{\n-\t  if (c < '0' || c > '7')\n-\t    {\n-\t      p--;\n-\t      break;\n-\t    }\n-\t  code = (code * 8) + (c - '0');\n-\t  if (p == limit)\n-\t    break;\n-\t  c = *p++;\n-\t}\n-\n-      if (count == 3)\n-\tp--;\n-\n-      *cptr = code;\n-      return p;\n-\n-    case '\\\\': case '\\'': case '\"': case '?':\n-      *cptr = c;\n-      return p;\n-\n-    case 'n': *cptr = TARGET_NEWLINE;\treturn p;\n-    case 't': *cptr = TARGET_TAB;\treturn p;\n-    case 'r': *cptr = TARGET_CR;\treturn p;\n-    case 'f': *cptr = TARGET_FF;\treturn p;\n-    case 'b': *cptr = TARGET_BS;\treturn p;\n-    case 'v': *cptr = TARGET_VT;\treturn p;\n-    case 'a':\n-      if (warn_traditional && !in_system_header)\n-\twarning (\"the meaning of '\\\\a' varies with -traditional\");\n-      *cptr = flag_traditional ? c : TARGET_BELL;\n-      return p;\n-\n-      /* Warnings and support checks handled by read_ucs().  */\n-    case 'u': case 'U':\n-      if (c_language != clk_cplusplus && !flag_isoc99)\n-\tbreak;\n-\n-      if (warn_traditional && !in_system_header)\n-\twarning (\"the meaning of '\\\\%c' varies with -traditional\", c);\n-\n-      return read_ucs (p, limit, cptr, c == 'u' ? 4 : 8);\n-      \n-    case 'e': case 'E':\n-      if (pedantic)\n-\tpedwarn (\"non-ISO-standard escape sequence, '\\\\%c'\", c);\n-      *cptr = TARGET_ESC; return p;\n-\n-      /* '\\(', etc, are used at beginning of line to avoid confusing Emacs.\n-\t '\\%' is used to prevent SCCS from getting confused.  */\n-    case '(': case '{': case '[': case '%':\n-      if (pedantic)\n-\tpedwarn (\"unknown escape sequence '\\\\%c'\", c);\n-      *cptr = c;\n-      return p;\n-    }\n-\n-  if (ISGRAPH (c))\n-    pedwarn (\"unknown escape sequence '\\\\%c'\", c);\n-  else\n-    pedwarn (\"unknown escape sequence: '\\\\' followed by char 0x%x\", c);\n-\n-  *cptr = c;\n-  return p;\n-}\n-\n #if 0 /* not yet */\n /* Returns nonzero if C is a universal-character-name.  Give an error if it\n    is not one which may appear in an identifier, as per [extendid].\n@@ -1551,10 +1323,15 @@ lex_string (str, len, wide)\n \n       if (c == '\\\\' && !ignore_escape_flag)\n \t{\n-\t  p = readescape (p, limit, &c);\n-\t  if (width < HOST_BITS_PER_INT\n-\t      && (unsigned) c >= ((unsigned)1 << width))\n-\t    pedwarn (\"escape sequence out of range for character\");\n+\t  unsigned int mask;\n+\n+\t  if (width < HOST_BITS_PER_INT)\n+\t    mask = ((unsigned int) 1 << width) - 1;\n+\t  else\n+\t    mask = ~0;\n+\t  c = cpp_parse_escape (parse_in, (const unsigned char **) &p,\n+\t\t\t\t(const unsigned char *) limit,\n+\t\t\t\tmask, flag_traditional);\n \t}\n \t\n       /* Add this single character into the buffer either as a wchar_t"}, {"sha": "d2617494edd7bd9c2cad01fd22ec45ddb0aed789", "filename": "gcc/cpplex.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=62729350f1f7d6ce8a2b8ef153a715762285ed98", "patch": "@@ -98,11 +98,8 @@ static void save_comment PARAMS ((cpp_reader *, cpp_token *, const U_CHAR *));\n static void lex_percent PARAMS ((cpp_buffer *, cpp_token *));\n static void lex_dot PARAMS ((cpp_reader *, cpp_token *));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n-static unsigned int parse_escape PARAMS ((cpp_reader *, const unsigned char **,\n-\t\t\t\t\t  const unsigned char *, HOST_WIDE_INT,\n-\t\t\t\t\t  int));\n-static unsigned int read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n-\t\t\t\t      const unsigned char *, unsigned int));\n+static int maybe_read_ucs PARAMS ((cpp_reader *, const unsigned char **,\n+\t\t\t\t   const unsigned char *, unsigned int *));\n \n static cpp_chunk *new_chunk PARAMS ((unsigned int));\n static int chunk_suitable PARAMS ((cpp_pool *, cpp_chunk *, unsigned int));\n@@ -1670,7 +1667,10 @@ hex_digit_value (c)\n   abort ();\n }\n \n-/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence (C++ and C99).\n+/* Parse a '\\uNNNN' or '\\UNNNNNNNN' sequence.  Returns 1 to indicate\n+   failure if cpplib is not parsing C++ or C99.  Such failure is\n+   silent, and no variables are updated.  Otherwise returns 0, and\n+   warns if -Wtraditional.\n \n    [lex.charset]: The character designated by the universal character\n    name \\UNNNNNNNN is that character whose character short name in\n@@ -1683,19 +1683,31 @@ hex_digit_value (c)\n    program is ill-formed.\n \n    We assume that wchar_t is Unicode, so we don't need to do any\n-   mapping.  Is this ever wrong?  */\n+   mapping.  Is this ever wrong?\n \n-static unsigned int\n-read_ucs (pfile, pstr, limit, length)\n+   PC points to the 'u' or 'U', PSTR is points to the byte after PC,\n+   LIMIT is the end of the string or charconst.  PSTR is updated to\n+   point after the UCS on return, and the UCS is written into PC.  */\n+\n+static int\n+maybe_read_ucs (pfile, pstr, limit, pc)\n      cpp_reader *pfile;\n      const unsigned char **pstr;\n      const unsigned char *limit;\n-     unsigned int length;\n+     unsigned int *pc;\n {\n   const unsigned char *p = *pstr;\n-  unsigned int c, code = 0;\n+  unsigned int code = 0;\n+  unsigned int c = *pc, length;\n+\n+  /* Only attempt to interpret a UCS for C++ and C99.  */\n+  if (! (CPP_OPTION (pfile, cplusplus) || CPP_OPTION (pfile, c99)))\n+    return 1;\n \n-  for (; length; --length)\n+  if (CPP_WTRADITIONAL (pfile))\n+    cpp_warning (pfile, \"the meaning of '\\\\%c' varies with -traditional\", c);\n+  \n+  for (length = (c == 'u' ? 4: 8); length; --length)\n     {\n       if (p >= limit)\n \t{\n@@ -1737,21 +1749,24 @@ read_ucs (pfile, pstr, limit, length)\n #endif\n \n   *pstr = p;\n-  return code;\n+  *pc = code;\n+  return 0;\n }\n \n /* Interpret an escape sequence, and return its value.  PSTR points to\n    the input pointer, which is just after the backslash.  LIMIT is how\n-   much text we have.  MASK is the precision for the target type (char\n-   or wchar_t).  TRADITIONAL, if true, does not interpret escapes that\n-   did not exist in traditional C.  */\n+   much text we have.  MASK is a bitmask for the precision for the\n+   destination type (char or wchar_t).  TRADITIONAL, if true, does not\n+   interpret escapes that did not exist in traditional C.\n \n-static unsigned int\n-parse_escape (pfile, pstr, limit, mask, traditional)\n+   Handles all relevant diagnostics.  */\n+\n+unsigned int\n+cpp_parse_escape (pfile, pstr, limit, mask, traditional)\n      cpp_reader *pfile;\n      const unsigned char **pstr;\n      const unsigned char *limit;\n-     HOST_WIDE_INT mask;\n+     unsigned HOST_WIDE_INT mask;\n      int traditional;\n {\n   int unknown = 0;\n@@ -1787,17 +1802,8 @@ parse_escape (pfile, pstr, limit, mask, traditional)\n       c = TARGET_ESC;\n       break;\n       \n-      /* Warnings and support checks handled by read_ucs().  */\n     case 'u': case 'U':\n-      if (CPP_OPTION (pfile, cplusplus) || CPP_OPTION (pfile, c99))\n-\t{\n-\t  if (CPP_WTRADITIONAL (pfile))\n-\t    cpp_warning (pfile,\n-\t\t\t \"the meaning of '\\\\%c' varies with -traditional\", c);\n-\t  c = read_ucs (pfile, &str, limit, c == 'u' ? 4 : 8);\n-\t}\n-      else\n-\tunknown = 1;\n+      unknown = maybe_read_ucs (pfile, &str, limit, &c);\n       break;\n \n     case 'x':\n@@ -1869,6 +1875,9 @@ parse_escape (pfile, pstr, limit, mask, traditional)\n \tcpp_pedwarn (pfile, \"unknown escape sequence: '\\\\%03o'\", c);\n     }\n \n+  if (c > mask)\n+    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n+\n   *pstr = str;\n   return c;\n }\n@@ -1939,11 +1948,7 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n #endif\n \n       if (c == '\\\\')\n-\t{\n-\t  c = parse_escape (pfile, &str, limit, mask, traditional);\n-\t  if (width < HOST_BITS_PER_WIDE_INT && c > mask)\n-\t    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n-\t}\n+\tc = cpp_parse_escape (pfile, &str, limit, mask, traditional);\n \n #ifdef MAP_CHARACTER\n       if (ISPRINT (c))"}, {"sha": "bfc6a3fb6cd11046bb042ddde33a3700b732b7d4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62729350f1f7d6ce8a2b8ef153a715762285ed98/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=62729350f1f7d6ce8a2b8ef153a715762285ed98", "patch": "@@ -601,6 +601,10 @@ extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n extern void cpp_output_line\t\tPARAMS ((cpp_reader *, FILE *));\n extern void cpp_output_token\t\tPARAMS ((const cpp_token *, FILE *));\n extern const char *cpp_type2name\tPARAMS ((enum cpp_ttype));\n+extern unsigned int cpp_parse_escape\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char **,\n+\t\t\t\t\t\t const unsigned char *,\n+\t\t\t\t\t\t unsigned HOST_WIDE_INT, int));\n \n /* In cpphash.c */\n "}]}