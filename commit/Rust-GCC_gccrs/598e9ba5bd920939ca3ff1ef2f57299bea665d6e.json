{"sha": "598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ZTliYTViZDkyMDkzOWNhM2ZmMWVmMmY1NzI5OWJlYTY2NWQ2ZQ==", "commit": {"author": {"name": "Kurt Garloff", "email": "garloff@suse.de", "date": "2001-08-30T13:55:17Z"}, "committer": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "2001-08-30T13:55:17Z"}, "message": "optimize.c (inlinable_function_p): Allow only smaller single functions.\n\n\t* optimize.c (inlinable_function_p): Allow only smaller single\n\tfunctions. Halve inline limit after reaching recursive limit.\n\nFrom-SVN: r45286", "tree": {"sha": "cae4e0cb4dbf6c8771fb49c7bf4fc43074d8e219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae4e0cb4dbf6c8771fb49c7bf4fc43074d8e219"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598e9ba5bd920939ca3ff1ef2f57299bea665d6e/comments", "author": null, "committer": null, "parents": [{"sha": "95602da11cade17438211fe316b95e9dd5a68dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95602da11cade17438211fe316b95e9dd5a68dd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95602da11cade17438211fe316b95e9dd5a68dd4"}], "stats": {"total": 17, "additions": 12, "deletions": 5}, "files": [{"sha": "c44c8098546bf27a349dfbfef1b19439905b49cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598e9ba5bd920939ca3ff1ef2f57299bea665d6e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598e9ba5bd920939ca3ff1ef2f57299bea665d6e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "patch": "@@ -1,3 +1,8 @@\n+2001-08-30  Kurt Garloff  <garloff@suse.de>\n+ \n+\t* optimize.c (inlinable_function_p): Allow only smaller single\n+\tfunctions. Halve inline limit after reaching recursive limit.\n+ \n 2001-08-30  Joern Rennecke <amylaar@redhat.com>\n \t    Jason Merrill  <jason_merrill@redhat.com>\n "}, {"sha": "95d02b70c340d6f41d9934f6de8ca59d1e95f7d9", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598e9ba5bd920939ca3ff1ef2f57299bea665d6e/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598e9ba5bd920939ca3ff1ef2f57299bea665d6e/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=598e9ba5bd920939ca3ff1ef2f57299bea665d6e", "patch": "@@ -659,8 +659,9 @@ inlinable_function_p (fn, id)\n   /* We can't inline varargs functions.  */\n   else if (varargs_function_p (fn))\n     ;\n-  /* We can't inline functions that are too big.  */\n-  else if (DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS)\n+  /* We can't inline functions that are too big.\n+   * Only allow a single function to eat up half of our budget. */\n+  else if (DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 2)\n     ;\n   /* All is well.  We can inline this function.  Traditionally, GCC\n      has refused to inline functions using alloca, or functions whose\n@@ -674,9 +675,10 @@ inlinable_function_p (fn, id)\n \n   /* Even if this function is not itself too big to inline, it might\n      be that we've done so much inlining already that we don't want to\n-     risk inlining any more.  */\n-  if ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT \n-      > MAX_INLINE_INSNS)\n+     risk too much inlining any more and thus halve the acceptable size. */\n+  if ((DECL_NUM_STMTS (fn) + id->inlined_stmts) * INSNS_PER_STMT\n+      > MAX_INLINE_INSNS\n+      && DECL_NUM_STMTS (fn) * INSNS_PER_STMT > MAX_INLINE_INSNS / 4)\n     inlinable = 0;\n \n   /* We can inline a template instantiation only if it's fully"}]}