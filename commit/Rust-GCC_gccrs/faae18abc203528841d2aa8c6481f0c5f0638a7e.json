{"sha": "faae18abc203528841d2aa8c6481f0c5f0638a7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFhZTE4YWJjMjAzNTI4ODQxZDJhYThjNjQ4MWYwYzVmMDYzOGE3ZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-03T19:28:01Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-03T19:28:01Z"}, "message": "62nd Cygnus<->FSF merge\n\nFrom-SVN: r9298", "tree": {"sha": "487f72a8b5a01227bc4f06b52a2bf8c295151753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/487f72a8b5a01227bc4f06b52a2bf8c295151753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faae18abc203528841d2aa8c6481f0c5f0638a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faae18abc203528841d2aa8c6481f0c5f0638a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faae18abc203528841d2aa8c6481f0c5f0638a7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faae18abc203528841d2aa8c6481f0c5f0638a7e/comments", "author": null, "committer": null, "parents": [{"sha": "684cfb6b2f2a62a8401724a551503eea572083c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/684cfb6b2f2a62a8401724a551503eea572083c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/684cfb6b2f2a62a8401724a551503eea572083c8"}], "stats": {"total": 1086, "additions": 724, "deletions": 362}, "files": [{"sha": "1f68bf6ca9939d55d2b7fea13a4c51df0a990dbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -1,3 +1,116 @@\n+Sun Apr  2 23:43:51 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* search.c (compute_access): Don't try to do access control on\n+\tnested types.\n+\n+Fri Mar 31 10:14:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* repo.c: New file to handle things repo.\n+\n+\t* pt.c (instantiate_template): Call repo_template_used if the\n+\tdefinition is accessible.\n+\t(mark_function_instantiated): Split out from\n+\tdo_function_instantiation.\n+\t(mark_class_instantiated): Split out from do_type_instantiation.\n+\n+\t* parse.y (template_instantiate_once): Call repo_template_used.\n+\n+\t* lex.c (lang_init): Call init_repo.\n+\n+\t* decl2.c: Handle flag_use_repository.\n+\t(finish_file): Call finish_repo.\n+\n+\t* decl.c (start_method): Call repo_template_used if this is a\n+\ttemplate method.\n+\n+\t* Makefile.in (CXX_OBJS): Add repo.o.\n+\t(repo.o): Add dependencies.\n+\n+\t* Make-lang.in (CXX_SRCS): Add repo.c.\n+\n+\t* decl.c (start_function): If DECL_INTERFACE_KNOWN and\n+\tDECL_NOT_REALLY_EXTERN are both set, unset DECL_EXTERNAL.\n+\n+\t* typeck.c (build_binary_op_nodefault): Identify the invalid operand\n+\ttypes used.\n+\n+\t* decl.c (duplicate_decls): Propagate DECL_NOT_REALLY_EXTERN.\n+\n+Thu Mar 30 17:54:42 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault): Tidy up use of build_type\n+\tand result_type.  When checking for comparison between signed\n+\tand unsigned, use result_type rather than the (possibly shortened)\n+\ttype of op0.  Also, don't warn about equality comparison of a\n+\tsigned operand to an unsigned constant that fits in the signed\n+\ttype.\n+\n+\t* method.c (do_build_copy_constructor): Reverse\n+\tcurrent_base_init_list after we've built it up.\n+\n+Thu Mar 30 14:35:18 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (build_throw): Never warn about the value of throw not\n+\tbeing used.\n+\n+Thu Mar 30 13:16:54 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_start_catch_block): Check for bad catch parameter\n+\tdeclarations.\n+\n+Thu Mar 30 13:06:11 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (finish_function): Only set DECL_NOT_REALLY_EXTERN if\n+\tDECL_EXTERNAL is not already set.\n+\n+Thu Mar 30 11:26:24 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* method.c (emit_thunk): Let poplevel know that the last level is\n+\tfor a function so it can create a BLOCK_NODE and set DECL_INITIAL.\n+\n+Thu Mar 30 11:15:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (import_export_inline): Don't set DECL_NOT_REALLY_EXTERN\n+\there.\n+\n+\t* decl.c (grokdeclarator): OK, don't abort if we see a decl with\n+\tMETHOD_TYPE.\n+\t(finish_function): Set DECL_EXTERNAL and DECL_NOT_REALLY_EXTERN on\n+\tall deferred inlines.\n+\n+Wed Mar 29 19:35:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cp-tree.h (DECL_THIS_INLINE): New macro.\n+\t(DECL_NOT_REALLY_EXTERN): New macro.\n+\t(DECL_THIS_STATIC): New macro.\n+\n+\t* decl.c: Lose all references to current_extern_inline.  Break\n+\tinline semantics into DECL_INLINE for actual inlining and\n+\tDECL_THIS_INLINE for the linkage wierdness.  Use DECL_THIS_STATIC.\n+\t* decl2.c: Use DECL_NOT_REALLY_EXTERN to indicate that we want to\n+\temit an inline here.  Associated changes.\n+\t* lex.c: Ditto.\n+\t* pt.c: Ditto.\n+\t* typeck.c: Ditto.\n+\n+\t* call.c (build_method_call): Don't bother trying to handle inlines\n+\tspecially.\n+\t* cvt.c (convert_to_aggr): Ditto.\n+\n+\t* pt.c (do_function_instantiation): Handle instantiation of\n+\tpublic inlines, too.\n+\n+Wed Mar 29 16:04:25 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (init_exception_processing): Change the interface for\n+\t__throw_type_match and add decl for new rtti matching routine\n+\t__throw_type_match_rtti.\n+\t(build_eh_type): New routine to build a run time descriptor for the\n+\texpression given. \n+\t(expand_start_catch_block): Update to use new calling convention for\n+\tthe matcher.\n+\t(expand_throw): Update to use build_eh_type.\n+\n Mon Mar 27 07:14:33 1995  Warner Losh\t<imp@village.org>\n \n \t* g++.c: Removed __NetBSD__ from conditional."}, {"sha": "3eadf90a2ab023b466a60061c9b89b9866d8f8a6", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -76,7 +76,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/gc.c $(srcdir)/cp/method.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/init.c $(srcdir)/cp/parse.y \\\n- $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c\n+ $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c $(srcdir)/cp/repo.c\n \n cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus"}, {"sha": "98fea7eb2aeea919ecb9d4a0877c305c9f5bcf35", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -159,7 +159,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n \n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  class.o decl2.o error.o gc.o lex.o parse.o ptree.o spew.o typeck.o cvt.o \\\n- edsel.o except.o init.o method.o search.o tree.o xref.o\n+ edsel.o except.o init.o method.o search.o tree.o xref.o repo.o\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -247,6 +247,7 @@ pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H)\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n+repo.o : repo.c $(CONFIG.H) $(CXX_TREE_H)\n \f\n # These exist for maintenance purposes.\n "}, {"sha": "151d02f0d7ae043fa4ef28de8257520a63687c37", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -2575,14 +2575,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     if (TREE_CODE (function) == FUNCTION_DECL)\n       {\n \tis_constructor = DECL_CONSTRUCTOR_P (function);\n-\tif (DECL_INLINE (function))\n-\t  function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n-\telse\n-\t  {\n-\t    assemble_external (function);\n-\t    TREE_USED (function) = 1;\n-\t    function = default_conversion (function);\n-\t  }\n+\tTREE_USED (function) = 1;\n+\tfunction = default_conversion (function);\n       }\n     else\n       {"}, {"sha": "5dd853aff73ced86fb27845c180d561ddb98856f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -954,9 +954,11 @@ struct lang_decl_flags\n   unsigned saved_inline : 1;\n   unsigned use_template : 2;\n \n-  unsigned declared_static : 1;\n+  unsigned c_static : 1;\n   unsigned nonconverting : 1;\n-  unsigned dummy : 6;\n+  unsigned declared_inline : 1;\n+  unsigned not_really_extern : 1;\n+  unsigned dummy : 4;\n \n   tree access;\n   tree context;\n@@ -1234,10 +1236,14 @@ struct lang_decl\n #define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), delta2_identifier, 0, 0))\n #define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, 0, 0), pfn_identifier, 0, 0))\n \n-/* Nonzero for VAR_DECL and FUNCTION_DECL node means that `external' was\n+/* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  */\n #define DECL_THIS_EXTERN(NODE) (DECL_LANG_FLAG_2(NODE))\n \n+/* Nonzero for VAR_DECL and FUNCTION_DECL node means that `static' was\n+   specified in its declaration.  */\n+#define DECL_THIS_STATIC(NODE) (DECL_LANG_FLAG_6(NODE))\n+\n /* Nonzero for SAVE_EXPR if used to initialize a PARM_DECL.  */\n #define PARM_DECL_EXPR(NODE) (TREE_LANG_FLAG_2(NODE))\n \n@@ -1338,13 +1344,26 @@ struct lang_decl\n /* We know what we're doing with this decl now.  */\n #define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n \n-/* This decl was declared to have internal linkage.  */\n-#define DECL_DECLARED_STATIC(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.declared_static)\n+/* This decl was declared or deduced to have internal linkage.  This is\n+   only meaningful if TREE_PUBLIC is set.  */\n+#define DECL_C_STATIC(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.c_static)\n+\n+/* This function was declared inline.  This flag controls the linkage\n+   semantics of 'inline'; whether or not the function is inlined is\n+   controlled by DECL_INLINE.  */\n+#define DECL_THIS_INLINE(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.declared_inline)\n+\n+/* DECL_EXTERNAL must be set on a decl until the decl is actually emitted,\n+   so that assemble_external will work properly.  So we have this flag to\n+   tell us whether the decl is really not external.  */\n+#define DECL_NOT_REALLY_EXTERN(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.not_really_extern)\n \n #define DECL_PUBLIC(NODE) \\\n-  (TREE_CODE (NODE) == FUNCTION_DECL ? ! DECL_DECLARED_STATIC (NODE) \\\n-   : TREE_PUBLIC (NODE))\n+  (TREE_CODE (NODE) == FUNCTION_DECL \\\n+   ? ! DECL_C_STATIC (NODE) : TREE_PUBLIC (NODE))\n \n #define THUNK_DELTA(DECL) ((DECL)->decl.frame_size.i)\n "}, {"sha": "8cee211285aebe699e3145c3a1d2c0d56320f9b4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -1090,10 +1090,7 @@ convert_to_aggr (type, expr, msgp, protect)\n     return NULL_TREE;\n \n   fntype = TREE_TYPE (function);\n-  if (DECL_INLINE (function) && TREE_CODE (function) == FUNCTION_DECL)\n-    function = build1 (ADDR_EXPR, build_pointer_type (fntype), function);\n-  else\n-    function = default_conversion (function);\n+  function = default_conversion (function);\n \n   result = build_nt (CALL_EXPR, function,\n \t\t     convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),"}, {"sha": "de9e5b72e4e7c76d6eb32a9a5581a29cb93506a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 68, "deletions": 150, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -406,10 +406,6 @@ tree current_function_return_value;\n \n static int warn_about_return_type;\n \n-/* Nonzero when starting a function declared `extern inline'.  */\n-\n-static int current_extern_inline;\n-\n /* Nonzero means give `double' the same size as `float'.  */\n \n extern int flag_short_double;\n@@ -2082,13 +2078,11 @@ warn_extern_redeclared_static (newdecl, olddecl)\n     = \"`%D' was declared implicitly `extern' and later `static'\";\n \n   if (flag_traditional\n-      || TREE_CODE (newdecl) == TYPE_DECL\n-      || (! warn_extern_inline\n-\t  && DECL_INLINE (newdecl)))\n+      || TREE_CODE (newdecl) == TYPE_DECL)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  if (TREE_PUBLIC (name) && ! DECL_PUBLIC (newdecl))\n+  if (TREE_PUBLIC (name) && DECL_THIS_STATIC (newdecl))\n     {\n       /* It's okay to redeclare an ANSI built-in function as static,\n \t or to declare a non-ANSI built-in function as anything.  */\n@@ -2516,8 +2510,9 @@ duplicate_decls (newdecl, olddecl)\n \n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n-\t  DECL_DECLARED_STATIC (newdecl) = DECL_DECLARED_STATIC (olddecl);\n+\t  DECL_C_STATIC (newdecl) = DECL_C_STATIC (olddecl);\n \t  DECL_INTERFACE_KNOWN (newdecl) = DECL_INTERFACE_KNOWN (olddecl);\n+\t  DECL_NOT_REALLY_EXTERN (newdecl) = DECL_NOT_REALLY_EXTERN (olddecl);\n \t}\n     }\n   else\n@@ -2537,14 +2532,16 @@ duplicate_decls (newdecl, olddecl)\n \t}\n     }\n \n-  /* If either decl says `inline', this fn is inline,\n-     unless its definition was passed already.  */\n-  if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == NULL_TREE)\n-    DECL_INLINE (olddecl) = 1;\n-  DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n-\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n+      DECL_THIS_INLINE (newdecl) |= DECL_THIS_INLINE (olddecl);\n+\n+      /* If either decl says `inline', this fn is inline, unless its\n+         definition was passed already.  */\n+      if (DECL_INLINE (newdecl) && DECL_INITIAL (olddecl) == NULL_TREE)\n+\tDECL_INLINE (olddecl) = 1;\n+      DECL_INLINE (newdecl) = DECL_INLINE (olddecl);\n+\n       if (! types_match)\n \t{\n \t  DECL_LANGUAGE (olddecl) = DECL_LANGUAGE (newdecl);\n@@ -2968,7 +2965,7 @@ pushdecl (x)\n \t  /* If this is an extern function declaration, see if we\n \t     have a global definition or declaration for the function.  */\n \t  if (oldlocal == NULL_TREE\n-\t      && DECL_EXTERNAL (x) && !DECL_INLINE (x)\n+\t      && DECL_EXTERNAL (x)\n \t      && oldglobal != NULL_TREE\n \t      && TREE_CODE (x) == FUNCTION_DECL\n \t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n@@ -3454,11 +3451,7 @@ redeclaration_error_message (newdecl, olddecl)\n \n       /* defining the same name twice is no good.  */\n       if (DECL_INITIAL (olddecl) != NULL_TREE\n-\t  && DECL_INITIAL (newdecl) != NULL_TREE\n-\t  /* However, defining once as extern inline and a second\n-\t     time in another way is ok.  */\n-\t  && !(DECL_INLINE (olddecl) && DECL_EXTERNAL (olddecl)\n-\t       && !(DECL_INLINE (newdecl) && DECL_EXTERNAL (newdecl))))\n+\t  && DECL_INITIAL (newdecl) != NULL_TREE)\n \t{\n \t  if (DECL_NAME (olddecl) == NULL_TREE)\n \t    return \"`%#D' not declared in class\";\n@@ -6393,55 +6386,7 @@ finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \tsignature_error (decl, TREE_TYPE (type));\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-#if 0\n-\t  /* C++: Handle overloaded functions with default parameters.  */\n-\t  if (DECL_OVERLOADED (decl))\n-\t    {\n-\t      tree parmtypes = TYPE_ARG_TYPES (type);\n-\t      tree prev = NULL_TREE;\n-\t      tree original_name = DECL_NAME (decl);\n-\t      struct lang_decl *tmp_lang_decl = DECL_LANG_SPECIFIC (decl);\n-\t      /* All variants will share an uncollectible lang_decl.  */\n-\t      copy_decl_lang_specific (decl);\n-\n-\t      while (parmtypes && parmtypes != void_list_node)\n-\t\t{\n-\t\t  /* The default value for the parameter in parmtypes is\n-\t\t     stored in the TREE_PURPOSE of the TREE_LIST.  */ \n-\t\t  if (TREE_PURPOSE (parmtypes))\n-\t\t    {\n-\t\t      tree fnname, fndecl;\n-\t\t      tree *argp;\n-\n-\t\t      argp = prev ? & TREE_CHAIN (prev)\n-\t\t\t: & TYPE_ARG_TYPES (type);\n-\n-\t\t      *argp = NULL_TREE;\n-\t\t      fnname = build_decl_overload (original_name,\n-\t\t\t\t\t\t    TYPE_ARG_TYPES (type), 0);\n-\t\t      *argp = parmtypes;\n-\t\t      fndecl = build_decl (FUNCTION_DECL, fnname, type);\n-\t\t      DECL_EXTERNAL (fndecl) = DECL_EXTERNAL (decl);\n-\t\t      TREE_PUBLIC (fndecl) = TREE_PUBLIC (decl);\n-\t\t      DECL_INLINE (fndecl) = DECL_INLINE (decl);\n-\t\t      /* Keep G++ from thinking this function is unused.\n-\t\t\t It is only used to speed up search in name space.  */\n-\t\t      TREE_USED (fndecl) = 1;\n-\t\t      TREE_ASM_WRITTEN (fndecl) = 1;\n-\t\t      DECL_INITIAL (fndecl) = NULL_TREE;\n-\t\t      DECL_LANG_SPECIFIC (fndecl) = DECL_LANG_SPECIFIC (decl);\n-\t\t      fndecl = pushdecl (fndecl);\n-\t\t      DECL_INITIAL (fndecl) = error_mark_node;\n-\t\t      DECL_RTL (fndecl) = DECL_RTL (decl);\n-\t\t    }\n-\t\t  prev = parmtypes;\n-\t\t  parmtypes = TREE_CHAIN (parmtypes);\n-\t\t}\n-\t      DECL_LANG_SPECIFIC (decl) = tmp_lang_decl;\n-\t    }\n-#endif\n-\t}\n+\t;\n       else if (DECL_EXTERNAL (decl))\n \t;\n       else if (TREE_STATIC (decl) && type != error_mark_node)\n@@ -6775,13 +6720,13 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    not look, and -1 if we should not call `grokclassfn' at all.  */\n static tree\n grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n-\t    raises, check, publicp)\n+\t    raises, check, publicp, inlinep)\n      tree ctype, type;\n      tree declarator;\n      int virtualp;\n      enum overload_flags flags;\n      tree quals, raises;\n-     int check, publicp;\n+     int check, publicp, inlinep;\n {\n   tree cname, decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n@@ -6814,10 +6759,21 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n      definition or EOF) if appropriate.  */\n   TREE_PUBLIC (decl) = 1;\n \n-  if (publicp)\n-    ;\n-  else\n-    DECL_DECLARED_STATIC (decl) = 1;\n+  if (ctype == NULL_TREE && ! strcmp (IDENTIFIER_POINTER (declarator), \"main\"))\n+    {\n+      if (inlinep)\n+\terror (\"cannot declare `main' to be inline\");\n+      else if (! publicp)\n+\terror (\"cannot declare `main' to be static\");\n+      inlinep = 0;\n+      publicp = 1;\n+    }\n+\t  \n+  if (! publicp)\n+    DECL_C_STATIC (decl) = 1;\n+\n+  if (inlinep)\n+    DECL_THIS_INLINE (decl) = DECL_INLINE (decl) = 1;\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -9060,37 +9016,30 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      }\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n-\t    publicp = (RIDBIT_SETP (RID_EXTERN, specbits)\n-\t\t       || (ctype != NULL_TREE\n-\t\t\t   && funcdef_flag >= 0\n-\t\t\t   && RIDBIT_NOTSETP (RID_INLINE, specbits))\n-\t\t       || (friendp\n-\t\t\t   && ! funcdef_flag\n-\t\t\t   && RIDBIT_NOTSETP (RID_STATIC, specbits)\n-\t\t\t   && RIDBIT_NOTSETP (RID_INLINE, specbits)));\n+\t    publicp = (! friendp\n+\t\t       || RIDBIT_SETP (RID_EXTERN, specbits)\n+\t\t       || ! (funcdef_flag < 0 || inlinep));\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n-\t\t\t       raises, friendp ? -1 : 0, publicp);\n+\t\t\t       raises, friendp ? -1 : 0, publicp, inlinep);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t    decl = build_decl_attribute_variant (decl, decl_machine_attr);\n \n \t    if (explicitp == 2)\n \t      DECL_NONCONVERTING_P (decl) = 1;\n-\n-\t    DECL_INLINE (decl) = inlinep;\n \t  }\n \telse if (TREE_CODE (type) == METHOD_TYPE)\n \t  {\n+\t    /* We only get here for friend declarations of\n+\t       members of other classes.  */\n \t    /* All method decls are public, so tell grokfndecl to set\n \t       TREE_PUBLIC, also.  */\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n-\t\t\t       raises, friendp ? -1 : 0, 1);\n+\t\t\t       raises, friendp ? -1 : 0, 1, 0);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n-\n-\t    DECL_INLINE (decl) = inlinep;\n \t  }\n \telse if (TYPE_SIZE (type) == NULL_TREE && !staticp\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n@@ -9255,16 +9204,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  type = build_cplus_method_type (build_type_variant (ctype, constp, volatilep),\n \t\t\t\t\t  TREE_TYPE (type), TYPE_ARG_TYPES (type));\n \n-\t/* Record presence of `static'.  In C++, `inline' is like `static'.  */\n-\tpublicp\n-\t  = !(RIDBIT_SETP (RID_STATIC, specbits)\n-\t      || RIDBIT_SETP (RID_INLINE, specbits));\n+\t/* Record presence of `static'.  In C++, `inline' implies `static'.  */\n+\tpublicp = (ctype != NULL_TREE\n+\t\t   || (!RIDBIT_SETP (RID_STATIC, specbits)\n+\t\t       && !RIDBIT_SETP (RID_INLINE, specbits)));\n \n \tdecl = grokfndecl (ctype, type, original_name,\n \t\t\t   virtualp, flags, quals,\n \t\t\t   raises,\n \t\t\t   processing_template_decl ? 0 : friendp ? 2 : 1,\n-\t\t\t   publicp);\n+\t\t\t   publicp, inlinep);\n \tif (decl == NULL_TREE)\n \t  return NULL_TREE;\n \n@@ -9282,14 +9231,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tcp_pedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n \t\tillegal_static = 1;\n \t      }\n-\t    else if (! ctype\n-\t\t     && IDENTIFIER_LENGTH (original_name) == 4\n-\t\t     && IDENTIFIER_POINTER (original_name)[0] == 'm'\n-\t\t     && ! strcmp (IDENTIFIER_POINTER (original_name), \"main\"))\n-\t      {\n-\t\terror (\"cannot declare function `main' to have static linkage\");\n-\t\tillegal_static = 1;\n-\t      }\n \t    else if (current_function_decl)\n \t      {\n \t\t/* FIXME need arm citation */\n@@ -9303,28 +9244,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tRIDBIT_RESET (RID_STATIC, specbits);\n \t      }\n \t  }\n-\n-\t/* Record presence of `inline', if it is reasonable.  */\n-\tif (inlinep)\n-\t  {\n-\t    tree last = tree_last (TYPE_ARG_TYPES (type));\n-\n-\t    if (! ctype\n-\t\t&& ! strcmp (IDENTIFIER_POINTER (original_name), \"main\"))\n-\t      error (\"cannot inline function `main'\");\n-\t    else if (last && last != void_list_node)\n-\t      cp_warning (\"cannot inline function `%D' which takes `...'\", original_name);\n-\t    else\n-\t      /* Assume that otherwise the function can be inlined.  */\n-\t      DECL_INLINE (decl) = 1;\n-\n-\t    if (RIDBIT_SETP (RID_EXTERN, specbits))\n-\t      {\n-\t\tcurrent_extern_inline = 1;\n-\t\tif (pedantic)\n-\t\t  pedwarn (\"ANSI C++ does not permit `extern inline'\");\n-\t      }\n-\t  }\n       }\n     else\n       {\n@@ -9398,6 +9317,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     if (RIDBIT_SETP (RID_EXTERN, specbits))\n       DECL_THIS_EXTERN (decl) = 1;\n \n+    if (RIDBIT_SETP (RID_STATIC, specbits))\n+      DECL_THIS_STATIC (decl) = 1;\n+\n     /* Record constancy and volatility.  */\n \n     if (constp)\n@@ -10723,7 +10645,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   current_function_returns_value = 0;\n   current_function_returns_null = 0;\n   warn_about_return_type = 0;\n-  current_extern_inline = 0;\n   current_function_assigns_this = 0;\n   current_function_just_assigned_this = 0;\n   current_function_parms_stored = 0;\n@@ -10781,11 +10702,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t    doing_friend = 1;\n \t}\n \n-      if ( !(DECL_VINDEX (decl1)\n-\t     && write_virtuals >= 2\n-\t     && CLASSTYPE_VTABLE_NEEDS_WRITING (ctype)))\n-\tcurrent_extern_inline = DECL_THIS_EXTERN (decl1) && DECL_INLINE (decl1);\n-\n       raises = TYPE_RAISES_EXCEPTIONS (fntype);\n \n       /* In a fcn definition, arg types must be complete.  */\n@@ -10890,38 +10806,37 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   TREE_STATIC (decl1) = 1;\n \n   if (DECL_INTERFACE_KNOWN (decl1))\n-    /* We know.  */;\n+    {\n+      if (DECL_NOT_REALLY_EXTERN (decl1))\n+\tDECL_EXTERNAL (decl1) = 0;\n+    }\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      It doesn't matter whether it's inline or not.  */\n   else if (interface_unknown == 0)\n     {\n-      if (DECL_DECLARED_STATIC (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1))\n+      if (DECL_THIS_INLINE (decl1) || DECL_TEMPLATE_INSTANTIATION (decl1))\n \tDECL_EXTERNAL (decl1)\n \t  = (interface_only\n-\t     || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n+\t     || (DECL_THIS_INLINE (decl1) && ! flag_implement_inlines));\n       else\n-\tDECL_EXTERNAL (decl1) = current_extern_inline;\n+\tDECL_EXTERNAL (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n   else\n     {\n       /* This is a definition, not a reference.\n \t So clear DECL_EXTERNAL.  */\n       DECL_EXTERNAL (decl1) = 0;\n-      \n-      if (DECL_INLINE (decl1) && (DECL_FUNCTION_MEMBER_P (decl1)\n-\t\t\t\t  || DECL_TEMPLATE_INSTANTIATION (decl1)\n-\t\t\t\t  || current_extern_inline))\n-\t/* We know nothing yet */;\n+\n+      if (DECL_THIS_INLINE (decl1) && ! DECL_C_STATIC (decl1))\n+\tDECL_DEFER_OUTPUT (decl1) = 1;\n       else\n \t{\n \t  DECL_INTERFACE_KNOWN (decl1) = 1;\n-\t  if (DECL_DECLARED_STATIC (decl1))\n+\t  if (DECL_C_STATIC (decl1))\n \t    TREE_PUBLIC (decl1) = 0;\n \t}\n-\n-      DECL_DEFER_OUTPUT (decl1) = ! DECL_INTERFACE_KNOWN (decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -11728,9 +11643,10 @@ finish_function (lineno, call_poplevel, nested)\n   if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n     {\n       /* Set DECL_EXTERNAL so that assemble_external will be called as\n-         necessary.  We'll clear it again in import_export_inline.  */\n-      if (TREE_PUBLIC (fndecl))\n-\tDECL_EXTERNAL (fndecl) = 1;\n+         necessary.  We'll clear it again in finish_file.  */\n+      if (! DECL_EXTERNAL (fndecl))\n+\tDECL_NOT_REALLY_EXTERN (fndecl) = 1;\n+      DECL_EXTERNAL (fndecl) = 1;\n       mark_inline_for_output (fndecl);\n     }\n \n@@ -11857,11 +11773,16 @@ start_method (declspecs, declarator, raises)\n       return void_type_node;\n     }\n \n+  DECL_THIS_INLINE (fndecl) = 1;\n+\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n \n   if (processing_template_defn)\n-    SET_DECL_IMPLICIT_INSTANTIATION (fndecl);\n+    {\n+      SET_DECL_IMPLICIT_INSTANTIATION (fndecl);\n+      repo_template_used (fndecl);\n+    }\n \n   /* We read in the parameters on the maybepermanent_obstack,\n      but we won't be getting back to them until after we\n@@ -12207,7 +12128,6 @@ struct cp_function\n   int returns_value;\n   int returns_null;\n   int warn_about_return_type;\n-  int extern_inline;\n   int assigns_this;\n   int just_assigned_this;\n   int parms_stored;\n@@ -12247,7 +12167,6 @@ push_cp_function_context (context)\n   p->returns_value = current_function_returns_value;\n   p->returns_null = current_function_returns_null;\n   p->warn_about_return_type = warn_about_return_type;\n-  p->extern_inline = current_extern_inline;\n   p->binding_level = current_binding_level;\n   p->ctor_label = ctor_label;\n   p->dtor_label = dtor_label;\n@@ -12295,7 +12214,6 @@ pop_cp_function_context (context)\n   current_function_returns_value = p->returns_value;\n   current_function_returns_null = p->returns_null;\n   warn_about_return_type = p->warn_about_return_type;\n-  current_extern_inline = p->extern_inline;\n   current_binding_level = p->binding_level;\n   ctor_label = p->ctor_label;\n   dtor_label = p->dtor_label;"}, {"sha": "edce580237534a2ee5ca46462120b799588f37e4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -148,6 +148,10 @@ int warn_ctor_dtor_privacy = 1;\n \n int flag_vtable_thunks;\n \n+/* True if we want to deal with repository information.  */\n+\n+int flag_use_repository;\n+\n /* Nonzero means give string constants the type `const char *'\n    to get extra warnings from them.  These warnings will be too numerous\n    to be useful, except in thoroughly ANSIfied programs.  */\n@@ -399,7 +403,8 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"nonansi-builtins\", &flag_no_nonansi_builtin, 0},\n   {\"gnu-keywords\", &flag_no_gnu_keywords, 0},\n   {\"operator-names\", &flag_operator_names, 1},\n-  {\"check-new\", &flag_check_new, 1}\n+  {\"check-new\", &flag_check_new, 1},\n+  {\"repo\", &flag_use_repository, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -2466,13 +2471,7 @@ mark_vtable_entries (decl)\n \t    fnaddr = TREE_VALUE (entries);\n \t  TREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n \t}\n-      if (TREE_PUBLIC (fn) && ! TREE_ASM_WRITTEN (fn))\n-\t{\n-\t  int save_extern = DECL_EXTERNAL (fn);\n-\t  DECL_EXTERNAL (fn) = 1;\n-\t  assemble_external (fn);\n-\t  DECL_EXTERNAL (fn) = save_extern;\n-\t}\n+      assemble_external (fn);\n     }\n }\n \n@@ -2513,12 +2512,11 @@ import_export_vtable (decl, type, final)\n \n       if (! found && ! final)\n \t{\n-\t  /* This check only works before the method definitions are seen,\n-\t     since DECL_INLINE may get bashed.  */\n \t  tree method;\n \t  for (method = CLASSTYPE_METHODS (type); method != NULL_TREE;\n \t       method = DECL_NEXT_METHOD (method))\n-\t    if (DECL_VINDEX (method) != NULL_TREE && ! DECL_INLINE (method)\n+\t    if (DECL_VINDEX (method) != NULL_TREE\n+\t\t&& ! DECL_THIS_INLINE (method)\n \t\t&& ! DECL_ABSTRACT_VIRTUAL_P (method))\n \t      {\n \t\tfound = 1;\n@@ -2528,15 +2526,17 @@ import_export_vtable (decl, type, final)\n \n       if (final || ! found)\n \t{\n+#ifdef ASSEMBLE_EXTERNAL\n+\t  if (TREE_PUBLIC (decl))\n+\t    cp_error (\"all virtual functions redeclared inline\");\n+#endif\n \t  TREE_PUBLIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 0;\n-\t  DECL_INTERFACE_KNOWN (decl) = 1;\n \t}\n       else\n \t{\n \t  TREE_PUBLIC (decl) = 1;\n \t  DECL_EXTERNAL (decl) = 1;\n-\t  DECL_INTERFACE_KNOWN (decl) = 0;\n \t}\n     }\n }\n@@ -2570,7 +2570,7 @@ finish_prevtable_vardecl (prev, vars)\n \t   method = DECL_NEXT_METHOD (method))\n \t{\n \t  if (DECL_VINDEX (method) != NULL_TREE\n-\t      && !DECL_DECLARED_STATIC (method)\n+\t      && !DECL_THIS_INLINE (method)\n \t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n \t    {\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n@@ -2747,23 +2747,21 @@ import_export_inline (decl)\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n \n-  DECL_EXTERNAL (decl) = 0;\n-\n   if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n \tTREE_PUBLIC (decl) = 0;\n       else\n-\tDECL_EXTERNAL (decl) = 1;\n+\tDECL_NOT_REALLY_EXTERN (decl) = 0;\n     }\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n       tree ctype = DECL_CLASS_CONTEXT (decl);\n       if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n \t{\n-\t  DECL_EXTERNAL (decl)\n-\t    = (CLASSTYPE_INTERFACE_ONLY (ctype)\n-\t       || (DECL_INLINE (decl) && ! flag_implement_inlines));\n+\t  DECL_NOT_REALLY_EXTERN (decl)\n+\t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n+\t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n       else\n \tTREE_PUBLIC (decl) = 0;\n@@ -3045,6 +3043,8 @@ finish_file ()\n       assemble_constructor (IDENTIFIER_POINTER (fnname));\n     }\n \n+  permanent_allocation (1);\n+\n   /* Done with C language context needs.  */\n   pop_lang_context ();\n \n@@ -3115,8 +3115,9 @@ finish_file ()\n \t      {\n \t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n \n-\t\tif (! DECL_EXTERNAL (decl))\n+\t\tif (DECL_NOT_REALLY_EXTERN (decl))\n \t\t  {\n+\t\t    DECL_EXTERNAL (decl) = 0;\n \t\t    reconsider = 1;\n \t\t    temporary_allocation ();\n \t\t    output_inline_function (decl);\n@@ -3142,7 +3143,7 @@ finish_file ()\n \temit_thunk (vars);\n       else if (TREE_CODE (vars) == FUNCTION_DECL\n \t       && ! DECL_INTERFACE_KNOWN (vars)\n-\t       && DECL_DECLARED_STATIC (vars))\n+\t       && DECL_C_STATIC (vars))\n \tTREE_PUBLIC (vars) = 0;\n     }\n \n@@ -3162,7 +3163,8 @@ finish_file ()\n \t}\n     }\n \n-  permanent_allocation (1);\n+  finish_repo ();\n+\n   this_time = get_run_time ();\n   parse_time -= this_time - start_time;\n   varconst_time += this_time - start_time;"}, {"sha": "6c849fcdd5f10e9a42c78e9dfb5d330f9bc7cbf4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 88, "deletions": 68, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -780,9 +780,14 @@ init_exception_processing ()\n   push_lang_context (lang_name_c);\n \n   catch_match_fndecl =\n-    define_function (\"__throw_type_match\",\n-\t\t     build_function_type (integer_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, string_type_node, tree_cons (NULL_TREE, ptr_type_node, void_list_node))),\n+    define_function (flag_rtti\n+\t\t     ? \"__throw_type_match_rtti\"\n+\t\t     : \"__throw_type_match\",\n+\t\t     build_function_type (ptr_type_node,\n+\t\t\t\t\t  tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t\t\ttree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t\t\t\t\t\t\t   void_list_node)))),\n \t\t     NOT_BUILT_IN,\n \t\t     pushdecl,\n \t\t     0);\n@@ -1131,6 +1136,31 @@ expand_leftover_cleanups ()\n     }\n }\n \n+/* Build a type value for use at runtime for a exp that is thrown or\n+   matched against by the exception handling system.  */\n+static tree\n+build_eh_type (exp)\n+     tree exp;\n+{\n+  char *typestring;\n+  tree type;\n+\n+  if (flag_rtti)\n+    {\n+      exp = build_typeid (exp);\n+      return build1 (ADDR_EXPR, ptr_type_node, exp);\n+    }\n+  type = TREE_TYPE (exp);\n+\n+  /* peel back references, so they match. */\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  typestring = build_overload_name (type, 1, 1);\n+  exp = combine_strings (build_string (strlen (typestring)+1, typestring));\n+  return build1 (ADDR_EXPR, ptr_type_node, exp);\n+}\n+\n /* call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n@@ -1142,8 +1172,7 @@ expand_start_catch_block (declspecs, declarator)\n {\n   rtx false_label_rtx;\n   rtx protect_label_rtx;\n-  tree type;\n-  tree decl;\n+  tree decl = NULL_TREE;\n   tree init;\n \n   if (! doing_eh (1))\n@@ -1152,33 +1181,6 @@ expand_start_catch_block (declspecs, declarator)\n   /* Create a binding level for the parm.  */\n   expand_start_bindings (0);\n \n-  if (declspecs)\n-    {\n-      tree init_type;\n-      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n-\n-      /* Figure out the type that the initializer is. */\n-      init_type = TREE_TYPE (decl);\n-      if (TREE_CODE (init_type) != REFERENCE_TYPE)\n-\tinit_type = build_reference_type (init_type);\n-\n-      init = convert_from_reference (save_expr (make_tree (init_type, saved_throw_value)));\n-      \n-      /* Do we need the below two lines? */\n-      /* Let `finish_decl' know that this initializer is ok.  */\n-      DECL_INITIAL (decl) = init;\n-      /* This needs to be preallocated under the try block,\n-\t in a union of all catch variables. */\n-      pushdecl (decl);\n-      type = TREE_TYPE (decl);\n-\n-      /* peel back references, so they match. */\n-      if (TREE_CODE (type) == REFERENCE_TYPE)\n-\ttype = TREE_TYPE (type);\n-    }\n-  else\n-    type = NULL_TREE;\n-\n   /* These are saved for the exception table.  */\n   push_rtl_perm ();\n   false_label_rtx = gen_label_rtx ();\n@@ -1187,34 +1189,50 @@ expand_start_catch_block (declspecs, declarator)\n   push_label_entry (&false_label_stack, false_label_rtx);\n   push_label_entry (&false_label_stack, protect_label_rtx);\n \n-  if (type)\n+  if (declspecs)\n     {\n-      tree params;\n-      char *typestring;\n+      tree exp;\n       rtx call_rtx, return_value_rtx;\n-      tree catch_match_fcall;\n-      tree catchmatch_arg, argval;\n-\n-      typestring = build_overload_name (type, 1, 1);\n-\n-      params = tree_cons (NULL_TREE,\n-\t\t\t combine_strings (build_string (strlen (typestring)+1, typestring)),\n-\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t    make_tree (ptr_type_node, saved_throw_type),\n-\t\t\t\t    NULL_TREE));\n-      catch_match_fcall = build_function_call (CatchMatch, params);\n-      call_rtx = expand_call (catch_match_fcall, NULL_RTX, 0);\n+      tree init_type;\n+\n+      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n+\n+      if (decl == NULL_TREE)\n+\t{\n+\t  error (\"invalid catch parameter\");\n+\t  return;\n+\t}\n+\n+      /* Figure out the type that the initializer is. */\n+      init_type = TREE_TYPE (decl);\n+      if (TREE_CODE (init_type) != REFERENCE_TYPE)\n+\tinit_type = build_reference_type (init_type);\n+\n+      exp = make_tree (ptr_type_node, saved_throw_value);\n+      exp = tree_cons (NULL_TREE,\n+\t\t       build_eh_type (decl),\n+\t\t       tree_cons (NULL_TREE,\n+\t\t\t\t  make_tree (ptr_type_node, saved_throw_type),\n+\t\t\t\t  tree_cons (NULL_TREE, exp, NULL_TREE)));\n+      exp = build_function_call (CatchMatch, exp);\n+      call_rtx = expand_call (exp, NULL_RTX, 0);\n       assemble_external (TREE_OPERAND (CatchMatch, 0));\n \n-      return_value_rtx =\n-\thard_function_value (integer_type_node, catch_match_fcall);\n+      return_value_rtx = hard_function_value (ptr_type_node, exp);\n \n       /* did the throw type match function return TRUE? */\n-      emit_cmp_insn (return_value_rtx, const0_rtx, NE, NULL_RTX,\n+      emit_cmp_insn (return_value_rtx, const0_rtx, EQ, NULL_RTX,\n \t\t    GET_MODE (return_value_rtx), 0, 0);\n \n       /* if it returned FALSE, jump over the catch block, else fall into it */\n-      emit_jump_insn (gen_bne (false_label_rtx));\n+      emit_jump_insn (gen_beq (false_label_rtx));\n+\n+      init = convert_from_reference (save_expr (make_tree (init_type, call_rtx)));\n+\n+      /* Do we need the below two lines? */\n+      /* Let `finish_decl' know that this initializer is ok.  */\n+      DECL_INITIAL (decl) = init;\n+      decl = pushdecl (decl);\n       finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   else\n@@ -1535,7 +1553,6 @@ expand_throw (exp)\n      tree exp;\n {\n   rtx label;\n-  tree type;\n \n   if (! doing_eh (1))\n     return;\n@@ -1548,26 +1565,28 @@ expand_throw (exp)\n \n   if (exp)\n     {\n+      tree throw_type;\n+      rtx throw_type_rtx;\n+      rtx throw_value_rtx;\n+\n       /* throw expression */\n       /* First, decay it. */\n       exp = default_conversion (exp);\n-      type = TREE_TYPE (exp);\n \n-      {\n-\tchar *typestring = build_overload_name (type, 1, 1);\n-\ttree throw_type = build1 (ADDR_EXPR, ptr_type_node, combine_strings (build_string (strlen (typestring)+1, typestring)));\n-\trtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n-\trtx throw_value_rtx;\n-\n-\t/* Make a copy of the thrown object.  WP 15.1.5  */\n-\texp = build_new (NULL_TREE, type, build_tree_list (NULL_TREE, exp), 0);\n-\n-\tif (exp == error_mark_node)\n-\t  error (\"  in thrown expression\");\n-\tthrow_value_rtx = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n-\temit_move_insn (saved_throw_value, throw_value_rtx);\n-\temit_move_insn (saved_throw_type, throw_type_rtx);\n-      }\n+      /* Make a copy of the thrown object.  WP 15.1.5  */\n+      exp = build_new (NULL_TREE, TREE_TYPE (exp),\n+\t\t       build_tree_list (NULL_TREE, exp),\n+\t\t       0);\n+\n+      if (exp == error_mark_node)\n+\terror (\"  in thrown expression\");\n+\n+      throw_type = build_eh_type (build_indirect_ref (exp, NULL_PTR));\n+      throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n+\n+      throw_value_rtx = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+      emit_move_insn (saved_throw_value, throw_value_rtx);\n+      emit_move_insn (saved_throw_type, throw_type_rtx);\n     }\n   else\n     {\n@@ -1665,6 +1684,7 @@ build_throw (e)\n     {\n       e = build1 (THROW_EXPR, void_type_node, e);\n       TREE_SIDE_EFFECTS (e) = 1;\n+      TREE_USED (e) = 1;\n     }\n   return e;\n }"}, {"sha": "6d46976769a65c9e7cfd162fe4550ff7d526da54", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -362,6 +362,7 @@ lang_init ()\n   if (flag_cadillac)\n     cadillac_start ();\n   if (flag_gnu_xref) GNU_xref_begin (input_filename);\n+  init_repo (input_filename);\n }\n \n void\n@@ -1448,7 +1449,7 @@ store_pending_inline (decl, t)\n \t     punt them now, or output them now if we're doing implementations\n \t     and we know no overrides will exist.  Otherwise, we delay until\n \t     end-of-file, to see if the definition is really required.  */\n-\t  if (DECL_INLINE (decl))\n+\t  if (DECL_THIS_INLINE (decl))\n \t    /* delay_to_eof == 0 */;\n \t  else if (current_class_type && !interface_unknown)\n \t    {"}, {"sha": "1bf168438ed9d01349be4ea2fe7118369e27a633", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -1936,7 +1936,7 @@ emit_thunk (thunk_fndecl)\n     emit_insn (gen_rtx (USE, VOIDmode, need_use[--need_use_count]));\n \n   expand_end_bindings (NULL, 1, 0);\n-  poplevel (0, 0, 0);\n+  poplevel (0, 0, 1);\n \n   /* From now on, allocate rtl in current_obstack, not in saveable_obstack.\n      Note that that may have been done above, in save_for_inline_copying.\n@@ -2122,6 +2122,7 @@ do_build_copy_constructor (fndecl)\n \t    = tree_cons (DECL_NAME (fields), init, current_member_init_list);\n \t}\n       current_member_init_list = nreverse (current_member_init_list);\n+      current_base_init_list = nreverse (current_base_init_list);\n       setup_vtbl_ptr ();\n     }\n "}, {"sha": "a4bbd55bdfb40f0ab97e9ed45ca74f63e259d9f8", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -897,6 +897,8 @@ template_instantiate_once:\n \t\t  pop_obstacks ();\n \t\t  end_template_instantiation ($1);\n \n+\t\t  repo_template_used (t);\n+\n                   /* Now go after the methods & class data.  */\n                   instantiate_member_templates ($1);\n "}, {"sha": "5b5dceb796290818e106bceafdaf7ea2767ebb7e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -1450,6 +1450,7 @@ tsubst (t, args, nargs, in_decl)\n \tTREE_STATIC (r) = 0;\n \tDECL_INTERFACE_KNOWN (r) = 0;\n \tDECL_INLINE (r) = DECL_INLINE (t);\n+\tDECL_THIS_INLINE (r) = DECL_THIS_INLINE (t);\n \t{\n #if 0\t\t\t\t/* Maybe later.  -jason  */\n \t  struct tinst_level *til = tinst_for_decl();\n@@ -1751,6 +1752,7 @@ instantiate_template (tmpl, targ_ptr)\n   else if (t->text)\n     {\n       SET_DECL_IMPLICIT_INSTANTIATION (fndecl);\n+      repo_template_used (fndecl);\n       p = (struct pending_inline *) permalloc (sizeof (struct pending_inline));\n       p->parm_vec = t->parm_vec;\n       p->bindings = targs;\n@@ -2384,7 +2386,7 @@ do_pending_expansions ()\n \tDECIDE (0);\n \n       if (DECL_EXPLICIT_INSTANTIATION (t))\n-\tDECIDE (! DECL_EXTERNAL (t));\n+\tDECIDE (DECL_NOT_REALLY_EXTERN (t));\n       else if (! flag_implicit_templates)\n \tDECIDE (0);\n \n@@ -2486,6 +2488,22 @@ add_pending_template (pt)\n   p->id = pt;\n }\n \n+void\n+mark_function_instantiated (result, extern_p)\n+     tree result;\n+     int extern_p;\n+{\n+  if (DECL_TEMPLATE_INSTANTIATION (result))\n+    SET_DECL_EXPLICIT_INSTANTIATION (result);\n+  TREE_PUBLIC (result) = 1;\n+\n+  if (! extern_p)\n+    {\n+      DECL_INTERFACE_KNOWN (result) = 1;\n+      DECL_NOT_REALLY_EXTERN (result) = 1;\n+    }\n+}\n+\n /* called from the parser.  */\n void\n do_function_instantiation (declspecs, declarator, storage)\n@@ -2495,10 +2513,17 @@ do_function_instantiation (declspecs, declarator, storage)\n   tree name = DECL_NAME (decl);\n   tree fn = IDENTIFIER_GLOBAL_VALUE (name);\n   tree result = NULL_TREE;\n+  int extern_p = 0;\n   if (fn)\n     {\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n-\tif (TREE_CODE (fn) == TEMPLATE_DECL)\n+\tif (decls_match (fn, decl)\n+\t    && DECL_DEFER_OUTPUT (fn))\n+\t  {\n+\t    result = fn;\n+\t    break;\n+\t  }\n+\telse if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t  {\n \t    int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (fn));\n \t    tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n@@ -2518,27 +2543,40 @@ do_function_instantiation (declspecs, declarator, storage)\n \t  }\n     }\n   if (! result)\n-    cp_error (\"no matching template for `%D' found\", decl);\n+    {\n+      cp_error (\"no matching template for `%D' found\", decl);\n+      return;\n+    }\n \n   if (flag_external_templates)\n     return;\n \n-  SET_DECL_EXPLICIT_INSTANTIATION (result);\n-  TREE_PUBLIC (result) = 1;\n-\n   if (storage == NULL_TREE)\n-    {\n-      DECL_INTERFACE_KNOWN (result) = 1;\n-      DECL_EXTERNAL (result) = 0;\n-      TREE_STATIC (result) = 1;\n-    }\n-  else if (storage == ridpointers[(int) RID_EXTERN])\n     ;\n+  else if (storage == ridpointers[(int) RID_EXTERN])\n+    extern_p = 1;\n   else\n     cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n+  mark_function_instantiated (result, extern_p);\n }\n \n+void\n+mark_class_instantiated (t, extern_p)\n+     tree t;\n+     int extern_p;\n+{\n+  SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n+  SET_CLASSTYPE_INTERFACE_KNOWN (t);\n+  CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n+  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n+  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = extern_p;\n+  if (! extern_p)\n+    {\n+      CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n+      rest_of_type_compilation (t, 1);\n+    }\n+}     \n void\n do_type_instantiation (name, storage)\n      tree name, storage;\n@@ -2578,18 +2616,7 @@ do_type_instantiation (name, storage)\n     }\n \n   if (! CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n-    {\n-      SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n-      SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-      CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n-      TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = extern_p;\n-      if (! extern_p)\n-\t{\n-\t  CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n-\t  rest_of_type_compilation (t, 1);\n-\t}\n-    }\n+    mark_class_instantiated (t, extern_p);\n   \n   {\n     tree tmp;\n@@ -2615,8 +2642,7 @@ do_type_instantiation (name, storage)\n \tif (! extern_p)\n \t  {\n \t    DECL_INTERFACE_KNOWN (tmp) = 1;\n-\t    DECL_EXTERNAL (tmp) = 0;\n-\t    TREE_STATIC (tmp) = 1;\n+\t    DECL_NOT_REALLY_EXTERN (tmp) = 1;\n \t  }\n       }\n "}, {"sha": "78c8dddb20dc3d3c1e24e8c496e2ae375d297286", "filename": "gcc/cp/repo.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -0,0 +1,278 @@\n+/* Code to maintain a C++ template repository.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill (jason@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* My strategy here is as follows:\n+\n+   Everything should be emitted in a translation unit where it is used.\n+   The results of the automatic process should be easily reproducible with\n+   explicit code.\n+\n+   I'm thinking of compiling with -frepo, running a Perl script to update\n+   files, and then being able to rebuild everything with -fno-implicit.\n+   Full automation can come later.  */\n+\n+#include <stdio.h>\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"input.h\"\n+\n+extern char * rindex ();\n+\n+static tree pending_repo;\n+static char repo_name[1024];\n+static FILE *repo_file;\n+\n+extern int flag_use_repository;\n+extern int errorcount, sorrycount;\n+\n+static int repo_changed;\n+\n+#define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))\n+#define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_4 (NODE))\n+\n+/* Record the flags used to compile this translation unit.  */\n+\n+void\n+repo_compile_flags (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+}\n+\n+/* If this template has not been seen before, add a note to the repository\n+   saying where the declaration was.  This may be used to find the\n+   definition at link time.  */\n+\n+void\n+repo_template_declared (t)\n+     tree t;\n+{}\n+\n+/* Note where the definition of a template lives so that instantiations can\n+   be generated later.  */\n+\n+void\n+repo_template_defined (t)\n+     tree t;\n+{}\n+\n+/* Note where the definition of a class lives to that template\n+   instantiations can use it.  */\n+\n+void\n+repo_class_defined (t)\n+     tree t;\n+{}\n+\n+/* Note that a template has been used.  If we can see the definition, offer\n+   to emit it. */\n+\n+void\n+repo_template_used (t)\n+     tree t;\n+{\n+  tree id;\n+\n+  if (! flag_use_repository)\n+    return;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n+    {\n+      id = DECL_ASSEMBLER_NAME (TYPE_MAIN_DECL (t));\n+      if (IDENTIFIER_REPO_CHOSEN (id))\n+\tmark_class_instantiated (t, 0);\n+    }\n+  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+    {\n+      id = DECL_ASSEMBLER_NAME (t);\n+      if (IDENTIFIER_REPO_CHOSEN (id))\n+\tmark_function_instantiated (t, 0);\n+    }\n+  else\n+    my_friendly_abort (1);\n+\n+  if (! IDENTIFIER_REPO_USED (id))\n+    {\n+      repo_changed = 1;\n+      IDENTIFIER_REPO_USED (id) = 1;\n+    }\n+  pending_repo = perm_tree_cons (NULL_TREE, t, pending_repo);\n+}\n+\n+/* Note that the vtable for a class has been used, and offer to emit it.  */\n+\n+void\n+repo_vtable_used (t)\n+     tree t;\n+{\n+  if (! flag_use_repository)\n+    return;\n+\n+  pending_repo = perm_tree_cons (NULL_TREE, t, pending_repo);\n+}\n+\n+/* Note that an inline with external linkage has been used, and offer to\n+   emit it.  */\n+\n+void\n+repo_inline_used (fn)\n+     tree fn;\n+{\n+  if (! flag_use_repository)\n+    return;\n+\n+  /* Member functions of polymorphic classes go with their vtables.  */\n+  if (DECL_FUNCTION_MEMBER_P (fn) && TYPE_VIRTUAL_P (DECL_CLASS_CONTEXT (fn)))\n+    {\n+      repo_vtable_used (DECL_CLASS_CONTEXT (fn));\n+      return;\n+    }\n+\n+  pending_repo = perm_tree_cons (NULL_TREE, fn, pending_repo);\n+}\n+\n+/* Note that a particular typeinfo node has been used, and offer to\n+   emit it.  */\n+\n+void\n+repo_tinfo_used (ti)\n+     tree ti;\n+{\n+}\n+\n+static void\n+open_repo_file (filename)\n+     char *filename;\n+{\n+  register char *p, *q;\n+  char *file = filename;\n+  char *s = rindex (file, '/');\n+  if (s == NULL)\n+    s = file;\n+  else\n+    ++s;\n+\n+  for (p = repo_name, q = file; q < s; )\n+    *p++ = *q++;\n+  *p++ = '.';\n+  strcpy (p, q);\n+  strcat (p, \".repo\");\n+\n+  repo_file = fopen (repo_name, \"r\");\n+}\n+\n+void\n+init_repo (filename)\n+     char *filename;\n+{\n+  char buf[1024];\n+\n+  if (! flag_use_repository)\n+    return;\n+\n+  open_repo_file (filename);\n+\n+  if (repo_file == 0)\n+    return;\n+\n+  while (fgets (buf, 1024, repo_file))\n+    {\n+      int len = strlen (buf) - 1;\n+      if (buf[len] != '\\n')\n+\terror (\"repository info line too long in %s\", repo_name);\n+      buf[len] = '\\0';\n+\n+      switch (buf[0])\n+\t{\n+\tcase 'A':\n+\tcase 'M':\n+\t  break;\n+\tcase 'C':\n+\tcase 'O':\n+\t  {\n+\t    tree id = get_identifier (&buf[2]);\n+\t    IDENTIFIER_REPO_USED (id) = 1;\n+\t    if (buf[0] == 'C')\n+\t      IDENTIFIER_REPO_CHOSEN (id) = 1;\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  error (\"mysterious repository information in %s\", repo_name);\n+\t}\n+    }\n+}\n+\n+static void\n+reopen_repo_file_for_write ()\n+{\n+  if (repo_file)\n+    fclose (repo_file);\n+  repo_file = fopen (repo_name, \"w\");\n+\n+  if (repo_file == 0)\n+    {\n+      error (\"man't create repository information file `%s'\", repo_name);\n+      flag_use_repository = 0;\n+    }\n+}\n+\n+/* Emit any pending repos.  */\n+\n+void\n+finish_repo ()\n+{\n+  tree t;\n+  int changed = 0;\n+\n+  if (! flag_use_repository)\n+    return;\n+\n+  /* Do we have to write out a new info file?  */\n+\n+  if (! repo_changed || errorcount || sorrycount)\n+    goto out;\n+\n+  reopen_repo_file_for_write ();\n+\n+  if (repo_file == 0)\n+    goto out;\n+\n+  for (t = pending_repo; t; t = TREE_CHAIN (t))\n+    {\n+      tree val = TREE_VALUE (t);\n+      char type;\n+\n+      if (TREE_CODE_CLASS (TREE_CODE (val)) == 't')\n+\tval = TYPE_MAIN_DECL (val);\n+      val = DECL_ASSEMBLER_NAME (val);\n+\n+      if (! IDENTIFIER_REPO_USED (val))\n+\tcontinue;\n+      IDENTIFIER_REPO_USED (val) = 0;\n+\n+      type = IDENTIFIER_REPO_CHOSEN (val) ? 'C' : 'O';\n+\n+      fprintf (repo_file, \"%c %s\\n\", type, IDENTIFIER_POINTER (val));\n+    }\n+\n+ out:\n+  if (repo_file)\n+    fclose (repo_file);\n+}"}, {"sha": "c0f2f2f87717ba2793a71f0d8ffe4da4cfde547b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -793,6 +793,10 @@ compute_access (basetype_path, field)\n     }\n #endif\n \n+  /* We don't currently support access control on nested types.  */\n+  if (TREE_CODE (field) == TYPE_DECL)\n+    return access_public;\n+\n   previous_scope = current_scope ();\n   \n   context = DECL_CLASS_CONTEXT (field);"}, {"sha": "d83c3cba52e49b071bba4a51708e7e98fe8940de", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 57, "deletions": 71, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faae18abc203528841d2aa8c6481f0c5f0638a7e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=faae18abc203528841d2aa8c6481f0c5f0638a7e", "patch": "@@ -2880,7 +2880,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n   tree build_type = 0;\n \n   /* Nonzero means after finally constructing the expression\n-     give it this type.  Otherwise, give it type RESULT_TYPE.  */\n+     convert it to this type.  */\n   tree final_type = 0;\n \n   /* Nonzero if this is an operation like MIN or MAX which can\n@@ -3155,34 +3155,39 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  else\n \t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\ttype0, type1);\n+\n+\t  if (result_type == NULL_TREE)\n+\t    result_type = ptr_type_node;\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n-\top1 = null_pointer_node;\n+\tresult_type = type0;\n       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n-\top0 = null_pointer_node;\n+\tresult_type = type1;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n+\t  result_type = type0;\n \t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n-\t  op1 = convert (TREE_TYPE (op0), op1);\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n+\t  result_type = type1;\n \t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n-\t  op0 = convert (TREE_TYPE (op1), op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n \t{\n \t  op0 = build_component_ref (op0, index_identifier, 0, 0);\n \t  op1 = integer_zero_node;\n+\t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n \t{\n \t  op0 = build_component_ref (op1, index_identifier, 0, 0);\n \t  op1 = integer_zero_node;\n+\t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1)\n \t       && (TYPE_PTRMEMFUNC_FN_TYPE (type0)\n@@ -3258,11 +3263,6 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t{\n \t  return build_binary_op (code, op1, op0, 1);\n \t}\n-\n-      type0 = TREE_TYPE (op0);\n-      type1 = TREE_TYPE (op1);\n-      if (result_type == NULL_TREE)\n-\tresult_type = type0;\n       break;\n \n     case MAX_EXPR:\n@@ -3272,29 +3272,15 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \tshorten = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (! comp_target_types (type0, type1, 1))\n+\t  if (comp_target_types (type0, type1, 1))\n+\t    result_type = common_type (type0, type1);\n+\t  else\n \t    {\n \t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\t  type0, type1);\n \t      result_type = ptr_type_node;\n \t    }\n-#if 0\n-\t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n-\t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n-\t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n-\t\t\tTYPE_SIZE (TREE_TYPE (type0)) == 0 ? \"in\" : \"\",\n-\t\t\tTYPE_SIZE (TREE_TYPE (type1)) == 0 ? \"in\" : \"\",\n-\t\t\ttype0, type1);\n-\t  else if (pedantic\n-\t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n-#endif\n-\t  else\n-\t    result_type = common_type (type0, type1);\n \t}\n-\n-      if (result_type == NULL_TREE)\n-\tresult_type = type0;\n       break;\n \n     case LE_EXPR:\n@@ -3307,50 +3293,37 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (! comp_target_types (type0, type1, 1))\n-\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n-\t\t\ttype0, type1);\n-#if 0\n-\t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n-\t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n-\t    cp_pedwarn (\"comparison of %scomplete and %scomplete pointers\",\n-\t\t\tTYPE_SIZE (TREE_TYPE (type0)) == 0 ? \"in\" : \"\",\n-\t\t\tTYPE_SIZE (TREE_TYPE (type1)) == 0 ? \"in\" : \"\",\n-\t\t\ttype0, type1);\n-\t  else if (pedantic \n-\t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n-\t    pedwarn (\"ANSI C++ forbids ordered comparisons of pointers to functions\");\n-#endif\n-\t  else\n+\t  if (comp_target_types (type0, type1, 1))\n \t    result_type = common_type (type0, type1);\n+\t  else\n+\t    {\n+\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n+\t\t\t  type0, type1);\n+\t      result_type = ptr_type_node;\n+\t    }\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n-\top1 = null_pointer_node;\n+\tresult_type = type0;\n       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n-\top0 = null_pointer_node;\n+\tresult_type = type1;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n+\t  result_type = type0;\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t  else if (! flag_traditional)\n \t    warning (\"comparison between pointer and integer\");\n-\t  op1 = convert (TREE_TYPE (op0), op1);\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n+\t  result_type = type1;\n \t  if (pedantic)\n \t    pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t  else if (! flag_traditional)\n \t    warning (\"comparison between pointer and integer\");\n-\t  op0 = convert (TREE_TYPE (op1), op0);\n \t}\n-\n-      type0 = TREE_TYPE (op0);\n-      type1 = TREE_TYPE (op1);\n-      if (result_type == NULL_TREE)\n-\tresult_type = type0;\n       break;\n     }\n \n@@ -3496,26 +3469,38 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n \t  int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n \n-\t  tree comp_type = TREE_TYPE (op0);\n-\n \t  int unsignedp0, unsignedp1;\n \t  tree primop0 = get_narrower (op0, &unsignedp0);\n \t  tree primop1 = get_narrower (op1, &unsignedp1);\n \n \t  /* Give warnings for comparisons between signed and unsigned\n-\t     quantities that may fail.  Do not warn if the signed quantity\n-\t     is an unsuffixed integer literal (or some static constant\n-\t     expression involving such literals) and it is positive.\n-\t     Do not warn if the comparison is being done in a signed type,\n-\t     since the signed type will only be chosen if it can represent\n-\t     all the values of the unsigned type.  */\n+\t     quantities that may fail.  */\n \t  /* Do the checking based on the original operand trees, so that\n \t     casts will be considered, but default promotions won't be.  */\n-\t  if (TREE_UNSIGNED (comp_type)\n-\t      && ((op0_signed && (TREE_CODE (orig_op0) != INTEGER_CST\n-\t\t\t\t  || tree_int_cst_sgn (orig_op0) == -1))\n-\t\t  || (op1_signed && (TREE_CODE (orig_op1) != INTEGER_CST\n-\t\t\t\t     || tree_int_cst_sgn (orig_op1) == -1))))\n+\n+\t  /* Do not warn if the comparison is being done in a signed type,\n+\t     since the signed type will only be chosen if it can represent\n+\t     all the values of the unsigned type.  */\n+\t  if (! TREE_UNSIGNED (result_type))\n+\t    /* OK */;\n+\t  /* Do not warn if the signed quantity is an unsuffixed\n+\t     integer literal (or some static constant expression\n+\t     involving such literals) and it is non-negative.  */\n+\t  else if ((op0_signed && TREE_CODE (orig_op0) == INTEGER_CST\n+\t\t    && tree_int_cst_sgn (orig_op0) >= 0)\n+\t\t   || (op1_signed && TREE_CODE (orig_op1) == INTEGER_CST\n+\t\t       && tree_int_cst_sgn (orig_op1) >= 0))\n+\t    /* OK */;\n+\t  /* Do not warn if the comparison is an equality operation,\n+\t     the unsigned quantity is an integral constant and it does\n+\t     not use the most significant bit of result_type.  */\n+\t  else if ((resultcode == EQ_EXPR || resultcode == NE_EXPR)\n+\t\t   && ((op0_signed && TREE_CODE (orig_op1) == INTEGER_CST\n+\t\t\t&& int_fits_type_p (orig_op1, signed_type (result_type))\n+\t\t\t|| (op1_signed && TREE_CODE (orig_op0) == INTEGER_CST\n+\t\t\t    && int_fits_type_p (orig_op0, signed_type (result_type))))))\n+\t    /* OK */;\n+\t  else\n \t    warning (\"comparison between signed and unsigned\");\n \n \t  /* Warn if two unsigned values are being compared in a size\n@@ -3526,8 +3511,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t     have all bits set that are set in the ~ operand when it is\n \t     extended.  */\n \n-\t  else if (TREE_CODE (primop0) == BIT_NOT_EXPR\n-\t\t   ^ TREE_CODE (primop1) == BIT_NOT_EXPR)\n+\t  if (TREE_CODE (primop0) == BIT_NOT_EXPR\n+\t      ^ TREE_CODE (primop1) == BIT_NOT_EXPR)\n \t    {\n \t      if (TREE_CODE (primop0) == BIT_NOT_EXPR)\n \t\tprimop0 = get_narrower (TREE_OPERAND (op0, 0), &unsignedp0);\n@@ -3556,7 +3541,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t    }\n \n \t\t  bits = TYPE_PRECISION (TREE_TYPE (primop));\n-\t\t  if (bits < TYPE_PRECISION (comp_type)\n+\t\t  if (bits < TYPE_PRECISION (result_type)\n \t\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n \t\t    {\n \t\t      mask = (~ (HOST_WIDE_INT) 0) << bits;\n@@ -3566,9 +3551,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t\t}\n \t      else if (unsignedp0 && unsignedp1\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop0))\n-\t\t\t   < TYPE_PRECISION (comp_type))\n+\t\t\t   < TYPE_PRECISION (result_type))\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t\t   < TYPE_PRECISION (comp_type)))\n+\t\t\t   < TYPE_PRECISION (result_type)))\n \t\twarning (\"comparison of promoted ~unsigned with unsigned\");\n \t    }\n \t}\n@@ -3582,7 +3567,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \n   if (!result_type)\n     {\n-      binary_op_error (error_code);\n+      cp_error (\"invalid operands `%T' and `%T' to binary `%O'\",\n+\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), error_code);\n       return error_mark_node;\n     }\n \n@@ -4467,7 +4453,7 @@ mark_addressable (exp)\n \t   be non-zero in the case of processing a default function.\n \t   The second may be non-zero in the case of a template function.  */\n \tx = DECL_MAIN_VARIANT (x);\n-\tif ((DECL_INLINE (x) || DECL_PENDING_INLINE_INFO (x))\n+\tif ((DECL_THIS_INLINE (x) || DECL_PENDING_INLINE_INFO (x))\n \t    && (DECL_CONTEXT (x) == NULL_TREE\n \t\t|| TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (x))) != 't'\n \t\t|| ! CLASSTYPE_INTERFACE_ONLY (DECL_CONTEXT (x))))"}]}