{"sha": "72f1215c5823a668d673bc7af7784a58dd035719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJmMTIxNWM1ODIzYTY2OGQ2NzNiYzdhZjc3ODRhNThkZDAzNTcxOQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-14T22:53:16Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-14T22:53:16Z"}, "message": "(simplify_by_exploding, find_and_mark_used_attributes,\n\n\tunmark_used_attributes, add_values_to_cover, increment_current_value,\n\ttest_for_current_value, simplify_with_current_value,\n\tsimplify_with_current_value_aux): New functions.\n\t(struct function_unit): Add max_busy_cost, {min,max}_busy_delay.\n\t(expand_units): Use simplify_by_exploding to simplify the\n\tfunction_units_used attribute.  Compute the ready cost attributes\n\tas a COND in numeric order.\n\t(gen_unit): Compute {min,max}_ready_cost and {min,max}_busy_delay.\n\t(write_function_unit_info): Determine if there is only one busy\n\tdelay value by comparing the minimum and maximum busy delay.\n\tWrite the initializer for function_units in numeric order.\n\tWrite out the maximum busy delay field.\n\n(attr_desc): Add negative_ok field.\n\t(find_attr, make_internal_attr): Initialize negative_ok.\n\t(check_attr_value): Allow negative values for CONST_STRING for\n\tnumeric attributes with negative_ok.\n\t(encode_units_mask): Change the encoding of the function_units_used\n\tresult.\n\n{....\n\nFrom-SVN: r1848", "tree": {"sha": "8be676399f0c9f42cff6b3f595d1053fcf689ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8be676399f0c9f42cff6b3f595d1053fcf689ac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72f1215c5823a668d673bc7af7784a58dd035719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f1215c5823a668d673bc7af7784a58dd035719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72f1215c5823a668d673bc7af7784a58dd035719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f1215c5823a668d673bc7af7784a58dd035719/comments", "author": null, "committer": null, "parents": [{"sha": "d6927cc9589c923b7d5be294bcc8ea9280badc5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6927cc9589c923b7d5be294bcc8ea9280badc5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6927cc9589c923b7d5be294bcc8ea9280badc5a"}], "stats": {"total": 806, "additions": 737, "deletions": 69}, "files": [{"sha": "eab29482ebe8d59b9ff500c40543377f50ad6b26", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 737, "deletions": 69, "changes": 806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f1215c5823a668d673bc7af7784a58dd035719/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f1215c5823a668d673bc7af7784a58dd035719/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=72f1215c5823a668d673bc7af7784a58dd035719", "patch": "@@ -89,7 +89,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    `in_struct' (MEM_IN_STRUCT_P): This rtx is fully simplified\n       for the insn code currently being processed (see optimize_attrs).\n    `integrated' (RTX_INTEGRATED_P): This rtx is permanent and unique\n-      (see attr_rtx).  */\n+      (see attr_rtx).\n+   `volatil' (MEM_VOLATILE_P): During simplify_by_exploding the value of an\n+      EQ_ATTR rtx is true if !volatil and false if volatil.  */\n \n \n #include <stdio.h>\n@@ -164,6 +166,7 @@ struct attr_desc\n   char *name;\t\t\t/* Name of attribute. */\n   struct attr_desc *next;\t/* Next attribute. */\n   int is_numeric;\t\t/* Values of this attribute are numeric. */\n+  int negative_ok;\t\t/* Allow negative numeric values.  */\n   int is_const;\t\t\t/* Attribute value constant for each run.  */\n   int is_special;\t\t/* Don't call `write_attr_set'. */\n   struct attr_value *first_value; /* First value of this attribute. */\n@@ -209,6 +212,9 @@ struct function_unit\n   struct function_unit_op *ops;\t/* Pointer to first operation type.  */\n   int needs_conflict_function;\t/* Nonzero if a conflict function required.  */\n   rtx default_cost;\t\t/* Conflict cost, if constant.  */\n+  rtx max_busy_cost;\t\t/* Maximum conflict cost.  */\n+  int min_busy_delay;\t\t/* Minimum conflict cost.  */\n+  int max_busy_delay;\t\t/* Maximum conflict cost.  */\n };\n \n /* Listheads of above structures.  */\n@@ -295,6 +301,7 @@ static rtx copy_boolean ();\n static void expand_delays ();\n static rtx operate_exp ();\n static void expand_units ();\n+static rtx encode_units_mask ();\n static void fill_attr ();\n static rtx substitute_address ();\n static void make_length_attrs ();\n@@ -304,6 +311,14 @@ static rtx one_fn ();\n static rtx max_fn ();\n static rtx simplify_cond ();\n static rtx simplify_by_alternatives ();\n+static rtx simplify_by_exploding ();\n+static int find_and_mark_used_attributes ();\n+static void unmark_used_attributes ();\n+static int add_values_to_cover ();\n+static int increment_current_value ();\n+static rtx test_for_current_value ();\n+static rtx simplify_with_current_value ();\n+static rtx simplify_with_current_value_aux ();\n static void remove_insn_ent ();\n static void insert_insn_ent ();\n static rtx insert_right_side ();\n@@ -985,7 +1000,10 @@ check_attr_value (exp, attr)\n \n       if (attr == 0 || attr->is_numeric)\n \t{\n-\t  for (p = XSTR (exp, 0); *p; p++)\n+\t  p = XSTR (exp, 0);\n+\t  if (attr && attr->negative_ok && *p == '-')\n+\t    p++;\n+\t  for (; *p; p++)\n \t    if (*p > '9' || *p < '0')\n \t      fatal (\"Non-numeric value for numeric `%s' attribute\",\n \t\t     attr ? attr->name : \"internal\");\n@@ -1611,8 +1629,10 @@ operate_exp (op, left, right)\n    construct a number of attributes.\n \n    The first produces a function `function_units_used' which is given an\n-   insn and produces a mask showing which function units are required for\n-   the execution of that insn.\n+   insn and produces an encoding showing which function units are required\n+   for the execution of that insn.  If the value is non-negative, the insn\n+   uses that unit; otherwise, the value is a one's compliment mask of units\n+   used.\n \n    The second produces a function `result_ready_cost' which is used to\n    determine the time that the result of an insn will be ready and hence\n@@ -1624,89 +1644,258 @@ operate_exp (op, left, right)\n \n    For each unit, a `<name>_unit_ready_cost' function will take an\n    insn and give the delay until that unit will be ready with the result\n-   and a `<name>_unit_busy_delay' function is given an insn already\n+   and a `<name>_unit_conflict_cost' function is given an insn already\n    executing on the unit and a candidate to execute and will give the\n    cost from the time the executing insn started until the candidate\n    can start (ignore limitations on the number of simultaneous insns).  */\n \n static void\n expand_units ()\n {\n-  struct function_unit *unit;\n-  struct function_unit_op *op;\n+  struct function_unit *unit, **unit_num;\n+  struct function_unit_op *op, **op_array, ***unit_ops;\n   rtx unitsmask;\n   rtx readycost;\n   rtx newexp;\n   char *str;\n+  int i, j, u, num, nvalues;\n \n-  /* Initially, cost and masks are zero.  */\n-  unitsmask = readycost = make_numeric_value (0);\n+  /* Validate the expressions we were given for the conditions and busy cost.\n+     Then make attributes for use in the conflict function.  */\n+  for (unit = units; unit; unit = unit->next)\n+    for (op = unit->ops; op; op = op->next)\n+      {\n+\top->condexp = check_attr_test (op->condexp, 0);\n+\top->busyexp = check_attr_value (make_canonical (NULL_ATTR,\n+\t\t\t\t\t\t\top->busyexp),\n+\t\t\t\t\tNULL_ATTR);\n+\tstr = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n+\t\t\t   unit->name, op->num);\n+\tmake_internal_attr (str, op->busyexp, 1);\n+      }\n \n-  /* Set up a conditional for costs and unit mask.  */\n+  /* Compute the mask of function units used.  Initially, the unitsmask is\n+     zero.   Set up a conditional to compute each unit's contribution.  */\n+  unitsmask = make_numeric_value (0);\n   newexp = rtx_alloc (IF_THEN_ELSE);\n   XEXP (newexp, 2) = make_numeric_value (0);\n \n-  /* For each unit, insert its contribution to the above three values.  */\n+  /* Merge each function unit into the unit mask attributes.  */\n+  for (unit = units; unit; unit = unit->next)\n+    {\n+      XEXP (newexp, 0) = check_attr_test (unit->condexp, 0);\n+      XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n+      unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n+    }\n+\n+  /* Simplify the unit mask expression, encode it, and make an attribute\n+     for the function_units_used function.  */\n+  unitsmask = simplify_by_exploding (unitsmask);\n+  unitsmask = encode_units_mask (unitsmask);\n+  make_internal_attr (\"*function_units_used\", unitsmask, 2);\n+\n+  /* Create an array of ops for each unit.  Add an extra unit for the\n+     result_ready_cost function that has the ops of all other units.  */\n+  unit_ops = (struct function_unit_op ***)\n+    alloca ((num_units + 1) * sizeof (struct function_unit_op **));\n+  unit_num = (struct function_unit **)\n+    alloca ((num_units + 1) * sizeof (struct function_unit *));\n+\n+  unit_num[num_units] = unit = (struct function_unit *)\n+    alloca (sizeof (struct function_unit));\n+  unit->num = num_units;\n+  unit->num_opclasses = 0;\n+\n+  for (unit = units; unit; unit = unit->next)\n+    {\n+      unit_num[num_units]->num_opclasses += unit->num_opclasses;\n+      unit_num[unit->num] = unit;\n+      unit_ops[unit->num] = op_array = (struct function_unit_op **)\n+\talloca (unit->num_opclasses * sizeof (struct function_unit_op *));\n+\n+      for (op = unit->ops; op; op = op->next)\n+\top_array[op->num] = op;\n+    }\n+\n+  /* Compose the array of ops for the extra unit.  */\n+  unit_ops[num_units] = op_array = (struct function_unit_op **)\n+    alloca (unit_num[num_units]->num_opclasses\n+\t    * sizeof (struct function_unit_op *));\n+\n+  for (unit = units, i = 0; unit; i += unit->num_opclasses, unit = unit->next)\n+    bcopy (unit_ops[unit->num], &op_array[i],\n+\t   unit->num_opclasses * sizeof (struct function_unit_op *));\n+\n+  /* Compute the ready cost function for each unit by computing the\n+     condition for each non-default value.  */\n+  for (u = 0; u <= num_units; u++)\n+    {\n+      rtx orexp;\n+      int value;\n+\n+      unit = unit_num[u];\n+      op_array = unit_ops[unit->num];\n+      num = unit->num_opclasses;\n+\n+      /* Sort the array of ops into increasing ready cost order.  */\n+      for (i = 0; i < num; i++)\n+\tfor (j = num - 1; j > i; j--)\n+\t  if (op_array[j-1]->ready < op_array[j]->ready)\n+\t    {\n+\t      op = op_array[j];\n+\t      op_array[j] = op_array[j-1];\n+\t      op_array[j-1] = op;\n+\t    }\n+\n+      /* Determine how many distinct non-default ready cost values there\n+\t are.  We use a default ready cost value of 1.  */\n+      nvalues = 0; value = 1;\n+      for (i = num - 1; i >= 0; i--)\n+\tif (op_array[i]->ready > value)\n+\t  {\n+\t    value = op_array[i]->ready;\n+\t    nvalues++;\n+\t  }\n+\n+      if (nvalues == 0)\n+\treadycost = make_numeric_value (1);\n+      else\n+\t{\n+\t  /* Construct the ready cost expression as a COND of each value from\n+\t     the largest to the smallest.  */\n+\t  readycost = rtx_alloc (COND);\n+\t  XVEC (readycost, 0) = rtvec_alloc (nvalues * 2);\n+\t  XEXP (readycost, 1) = make_numeric_value (1);\n+\n+\t  nvalues = 0; orexp = false_rtx; value = op_array[0]->ready;\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      op = op_array[i];\n+\t      if (op->ready <= 1)\n+\t\tbreak;\n+\t      else if (op->ready == value)\n+\t\torexp = insert_right_side (IOR, orexp, op->condexp, -2);\n+\t      else\n+\t\t{\n+\t\t  XVECEXP (readycost, 0, nvalues * 2) = orexp;\n+\t\t  XVECEXP (readycost, 0, nvalues * 2 + 1)\n+\t\t    = make_numeric_value (value);\n+\t\t  nvalues++;\n+\t\t  value = op->ready;\n+\t\t  orexp = op->condexp;\n+\t\t}\n+\t    }\n+\t  XVECEXP (readycost, 0, nvalues * 2) = orexp;\n+\t  XVECEXP (readycost, 0, nvalues * 2 + 1) = make_numeric_value (value);\n+\t}\n+\n+      /* Make an attribute for the ready_cost function.  Simplifying\n+\t further with simplify_by_exploding doesn't win.  */\n+      if (u < num_units)\n+\tstr = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n+\t\t\t   unit->name);\n+      else\n+\tstr = \"*result_ready_cost\";\n+      make_internal_attr (str, readycost, 0);\n+    }\n+\n+  /* For each unit that requires a conflict cost function, make an attribute\n+     that maps insns to the operation number.  */\n   for (unit = units; unit; unit = unit->next)\n     {\n-      /* An expression that computes the ready cost for this unit.  */\n-      rtx readyexp = rtx_alloc (COND);\n-      /* An expression that maps insns to operation number for conflicts.  */\n-      rtx caseexp = rtx_alloc (COND);\n+      rtx caseexp;\n \n-      XVEC (readyexp, 0) = rtvec_alloc ((unit->num_opclasses - 1) * 2);\n+      if (unit->min_busy_delay == unit->max_busy_delay)\n+\tcontinue;\n+\n+      caseexp = rtx_alloc (COND);\n       XVEC (caseexp, 0) = rtvec_alloc ((unit->num_opclasses - 1) * 2);\n \n       for (op = unit->ops; op; op = op->next)\n \t{\n-\t  /* Validate the expressions we were given for the conditions\n-\t     and busy cost.  Then make an attribute for use in the conflict\n-\t     function.  */\n-\t  op->condexp = check_attr_test (op->condexp, 0);\n-\t  op->busyexp = check_attr_value (op->busyexp, NULL_ATTR);\n-\t  str = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n-\t\t\t     unit->name, op->num);\n-\t  make_internal_attr (str, make_canonical (NULL_ATTR, op->busyexp));\n-\n-\t  /* Make our adjustment to the two COND's being computed.  If we are\n-\t     the last operation class, place our values into the default of\n-\t     the COND.  */\n+\t  /* Make our adjustment to the COND being computed.  If we are the\n+\t     last operation class, place our values into the default of the\n+\t     COND.  */\n \t  if (op->num == unit->num_opclasses - 1)\n \t    {\n-\t      XEXP (readyexp, 1) = make_numeric_value (op->ready);\n \t      XEXP (caseexp, 1) = make_numeric_value (op->num);\n \t    }\n \t  else\n \t    {\n-\t      XVECEXP (readyexp, 0, op->num * 2) = op->condexp;\n-\t      XVECEXP (readyexp, 0, op->num * 2 + 1)\n-\t\t= make_numeric_value (op->ready);\n \t      XVECEXP (caseexp, 0, op->num * 2) = op->condexp;\n \t      XVECEXP (caseexp, 0, op->num * 2 + 1)\n \t\t= make_numeric_value (op->num);\n \t    }\n \t}\n \n-      /* Make an attribute for the case number and ready delay.  */\n+      /* Simplifying caseexp with simplify_by_exploding doesn't win.  */\n       str = attr_printf (strlen (unit->name) + 8, \"*%s_cases\", unit->name);\n       make_internal_attr (str, caseexp, 1);\n+    }\n+}\n \n-      str = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n-\t\t\t unit->name);\n-      make_internal_attr (str, readyexp, 0);\n+/* Translate the CONST_STRING expressions in X to change the encoding of\n+   value.  On input, the value is a bitmask with a one bit for each unit\n+   used; on output, the value is the unit number (zero based) if one\n+   and only one unit is used or the one's compliment of the bitmask.  */\n \n-      /* Merge this function unit into the ready cost and unit mask\n-\t attributes.  */\n-      XEXP (newexp, 0) = check_attr_test (unit->condexp, 0);\n-      XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-      unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n+static rtx\n+encode_units_mask (x)\n+     rtx x;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register char *fmt;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_STRING:\n+      i = atoi (XSTR (x, 0));\n+      if (i < 0)\n+\tabort (); /* The sign bit encodes a one's compliment mask.  */\n+      else if (i != 0 && i == (i & -i))\n+\t/* Only one bit is set, so yield that unit number.  */\n+\tfor (j = 0; (i >>= 1) != 0; j++)\n+\t  ;\n+      else\n+\tj = ~i;\n+      return attr_rtx (CONST_STRING, attr_printf (4, \"%d\", j));\n \n-      XEXP (newexp, 1) = readyexp;\n-      readycost = operate_exp (MAX_OP, readycost, newexp);\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case EQ_ATTR:\n+      return x;\n     }\n \n-  make_internal_attr (\"*function_units_used\", unitsmask, 0);\n-  make_internal_attr (\"*result_ready_cost\", readycost, 0);\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'V':\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    XVECEXP (x, i, j) = encode_units_mask (XVECEXP (x, i, j));\n+\t  break;\n+\n+\tcase 'e':\n+\t  XEXP (x, i) = encode_units_mask (XEXP (x, i));\n+\t  break;\n+\t}\n+    }\n+  return x;\n }\n \f\n /* Once all attributes and insns have been read and checked, we construct for\n@@ -2927,6 +3116,478 @@ simplify_by_alternatives (exp, insn_code, insn_index)\n   return simplify_cond (newexp, insn_code, insn_index);\n }\n \f\n+/* An expression where all the unknown terms are EQ_ATTR tests can be\n+   rearranged into a COND provided we can enumerate all possible\n+   combinations of the unknown values.  The set of combinations become the\n+   tests of the COND; the value of the expression given that combination is\n+   computed and becomes the corresponding value.  To do this, we must be\n+   able to enumerate all values for each attribute used in the expression\n+   (currently, we give up if we find a numeric attribute).\n+   \n+   If the set of EQ_ATTR tests used in an expression tests the value of N\n+   different attributes, the list of all possible combinations can be made\n+   by walking the N-dimensional attribute space defined by those\n+   attributes.  We record each of these as a struct dimension.\n+\n+   The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an\n+   expression are the same, the will also have the same address.  We find\n+   all the EQ_ATTR nodes by marking them MEM_VOLATILE_P.  This bit later\n+   represents the value of an EQ_ATTR node, so once all nodes are marked,\n+   they are also given an initial value of FALSE.\n+\n+   We then separate the set of EQ_ATTR nodes into dimensions for each\n+   attribute and put them on the VALUES list.  Terms are added as needed by\n+   `add_values_to_cover' so that all possible values of the attribute are\n+   tested.\n+\n+   Each dimension also has a current value.  This is the node that is\n+   currently considered to be TRUE.  If this is one of the nodes added by\n+   `add_values_to_cover', all the EQ_ATTR tests in the original expression\n+   will be FALSE.  Otherwise, only the CURRENT_VALUE will be true.\n+\n+   NUM_VALUES is simply the length of the VALUES list and is there for\n+   convenience.\n+\n+   Once the dimensions are created, the algorithm enumerates all possible\n+   values and computes the current value of the given expression.  */\n+\n+struct dimension \n+{\n+  struct attr_desc *attr;\t/* Attribute for this dimension.  */\n+  rtx values;\t\t\t/* List of attribute values used.  */\n+  rtx current_value;\t\t/* Position in the list for the TRUE value.  */\n+  int num_values;\t\t/* Length of the values list.  */\n+};\n+\n+/* If EXP is a suitable expression, reorganize it by constructing an\n+   equivalent expression that is a COND with the tests being all combinations\n+   of attribute values and the values being simple constants.  */\n+\n+static rtx\n+simplify_by_exploding (exp)\n+     rtx exp;\n+{\n+  rtx list = 0, link, condexp, defval;\n+  struct dimension *space;\n+  rtx *condtest, *condval;\n+  int i, j, total, ndim;\n+  int most_tests, num_marks, new_marks;\n+\n+  /* Locate all the EQ_ATTR expressions.  */\n+  if (! find_and_mark_used_attributes (exp, &list))\n+    {\n+      unmark_used_attributes (list, 0, 0);\n+      return exp;\n+    }\n+\n+  /* Create an attribute space from the list of used attributes.  For each\n+     dimension in the attribute space, record the attribute, list of values\n+     used, and number of values used.  Add members to the list of values to\n+     cover the domain of the attribute.  This makes the expanded COND form\n+     order independent.  */\n+\n+  ndim = 0;\n+  for (link = list; link; link = XEXP (link, 1))\n+    ndim++;\n+  space = (struct dimension *) alloca (ndim * sizeof (struct dimension));\n+\n+  total = 1;\n+  for (ndim = 0; list; ndim++)\n+    {\n+      /* Pull the first attribute value from the list and record that\n+\t attribute as another dimension in the attribute space.  */\n+      char *name = XSTR (XEXP (list, 0), 0);\n+      rtx *prev;\n+\n+      if ((space[ndim].attr = find_attr (name, 0)) == 0\n+\t  || space[ndim].attr->is_numeric)\n+\t{\n+\t  unmark_used_attributes (list, space, ndim);\n+\t  return exp;\n+\t}\n+\n+      /* Add all remaining attribute values that refer to this attribute.  */\n+      space[ndim].num_values = 0;\n+      space[ndim].values = 0;\n+      prev = &list;\n+      for (link = list; link; link = *prev)\n+\tif (! strcmp (XSTR (XEXP (link, 0), 0), name))\n+\t  {\n+\t    space[ndim].num_values++;\n+\t    *prev = XEXP (link, 1);\n+\t    XEXP (link, 1) = space[ndim].values;\n+\t    space[ndim].values = link;\n+\t  }\n+\telse\n+\t  prev = &XEXP (link, 1);\n+\n+      /* Add sufficient members to the list of values to make the list\n+\t mutually exclusive and record the total size of the attribute\n+\t space.  */\n+      total *= add_values_to_cover (&space[ndim]);\n+    }\n+\n+  /* Sort the attribute space so that the attributes go from non-constant\n+     to constant and from most values to least values.  */\n+  for (i = 0; i < ndim; i++)\n+    for (j = ndim - 1; j > i; j--)\n+      if ((space[j-1].attr->is_const && !space[j].attr->is_const)\n+\t  || space[j-1].num_values < space[j].num_values)\n+\t{\n+\t  struct dimension tmp;\n+\t  tmp = space[j];\n+\t  space[j] = space[j-1];\n+\t  space[j-1] = tmp;\n+\t}\n+\n+  /* Establish the initial current value.  */\n+  for (i = 0; i < ndim; i++)\n+    space[i].current_value = space[i].values;\n+\n+  condtest = (rtx *) alloca (total * sizeof (rtx));\n+  condval = (rtx *) alloca (total * sizeof (rtx));\n+\n+  /* Expand the tests and values by iterating over all values in the\n+     attribute space.  */\n+  for (i = 0;; i++)\n+    {\n+      condtest[i] = test_for_current_value (space, ndim);\n+      condval[i] = simplify_with_current_value (exp, space, ndim);\n+      if (! increment_current_value (space, ndim))\n+\tbreak;\n+    }\n+  if (i != total - 1)\n+    abort ();\n+\n+  /* We are now finished with the original expression.  */\n+  unmark_used_attributes (0, space, ndim);\n+\n+  /* Find the most used constant value and make that the default.  */\n+  most_tests = -1;\n+  for (i = num_marks = 0; i < total; i++)\n+    if (GET_CODE (condval[i]) == CONST_STRING\n+\t&& ! MEM_VOLATILE_P (condval[i]))\n+      {\n+\t/* Mark the unmarked constant value and count how many are marked.  */\n+\tMEM_VOLATILE_P (condval[i]) = 1;\n+\tfor (j = new_marks = 0; j < total; j++)\n+\t  if (GET_CODE (condval[j]) == CONST_STRING\n+\t      && MEM_VOLATILE_P (condval[j]))\n+\t    new_marks++;\n+\tif (new_marks - num_marks > most_tests)\n+\t  {\n+\t    most_tests = new_marks - num_marks;\n+\t    defval = condval[i];\n+\t  }\n+\tnum_marks = new_marks;\n+      }\n+  /* Clear all the marks.  */\n+  for (i = 0; i < total; i++)\n+    MEM_VOLATILE_P (condval[i]) = 0;\n+\n+  /* Give up if nothing is constant.  */\n+  if (num_marks == 0)\n+    return exp;\n+\n+  /* Make a COND with the most common constant value the default.  (A more\n+     complex method where tests with the same value were combined didn't\n+     seem to improve things.)  */\n+  condexp = rtx_alloc (COND);\n+  XVEC (condexp, 0) = rtvec_alloc ((total - most_tests) * 2);\n+  XEXP (condexp, 1) = defval;\n+  for (i = j = 0; i < total; i++)\n+    if (condval[i] != defval)\n+      {\n+\tXVECEXP (condexp, 0, 2 * j) = condtest[i];\n+\tXVECEXP (condexp, 0, 2 * j + 1) = condval[i];\n+\tj++;\n+      }\n+\n+  return condexp;\n+}\n+\n+/* Set the MEM_VOLATILE_P flag for all EQ_ATTR expressions in EXP and\n+   verify that EXP can be simplified to a constant term if all the EQ_ATTR\n+   tests have known value.  */\n+\n+static int\n+find_and_mark_used_attributes (exp, terms)\n+     rtx exp, *terms;\n+{\n+  int i;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case EQ_ATTR:\n+      if (! MEM_VOLATILE_P (exp))\n+\t{\n+\t  rtx link = rtx_alloc (EXPR_LIST);\n+\t  XEXP (link, 0) = exp;\n+\t  XEXP (link, 1) = *terms;\n+\t  *terms = link;\n+\t  MEM_VOLATILE_P (exp) = 1;\n+\t}\n+    case CONST_STRING:\n+      return 1;\n+\n+    case IF_THEN_ELSE:\n+      if (! find_and_mark_used_attributes (XEXP (exp, 2), terms))\n+\treturn 0;\n+    case IOR:\n+    case AND:\n+      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms))\n+\treturn 0;\n+    case NOT:\n+      if (! find_and_mark_used_attributes (XEXP (exp, 0), terms))\n+\treturn 0;\n+      return 1;\n+\n+    case COND:\n+      for (i = 0; i < XVECLEN (exp, 0); i++)\n+\tif (! find_and_mark_used_attributes (XVECEXP (exp, 0, i), terms))\n+\t  return 0;\n+      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms))\n+\treturn 0;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Clear the MEM_VOLATILE_P flag in all EQ_ATTR expressions on LIST and\n+   in the values of the NDIM-dimensional attribute space SPACE.  */\n+\n+static void\n+unmark_used_attributes (list, space, ndim)\n+     rtx list;\n+     struct dimension *space;\n+     int ndim;\n+{\n+  rtx link, exp;\n+  int i;\n+\n+  for (i = 0; i < ndim; i++)\n+    unmark_used_attributes (space[i].values, 0, 0);\n+\n+  for (link = list; link; link = XEXP (link, 1))\n+    {\n+      exp = XEXP (link, 0);\n+      if (GET_CODE (exp) == EQ_ATTR)\n+\tMEM_VOLATILE_P (exp) = 0;\n+    }\n+}\n+\n+/* Update the attribute dimension DIM so that all values of the attribute\n+   are tested.  Return the updated number of values.  */\n+\n+static int\n+add_values_to_cover (dim)\n+     struct dimension *dim;\n+{\n+  struct attr_value *av;\n+  rtx exp, link, *prev;\n+  int nalt = 0;\n+\n+  for (av = dim->attr->first_value; av; av = av->next)\n+    if (GET_CODE (av->value) == CONST_STRING)\n+      nalt++;\n+\n+  if (nalt < dim->num_values)\n+    abort ();\n+  else if (nalt == dim->num_values)\n+    ; /* Ok.  */\n+  else if (nalt * 2 < dim->num_values * 3)\n+    {\n+      /* Most all the values of the attribute are used, so add all the unused\n+\t values.  */\n+      prev = &dim->values;\n+      for (link = dim->values; link; link = *prev)\n+\tprev = &XEXP (link, 1);\n+\n+      for (av = dim->attr->first_value; av; av = av->next)\n+\tif (GET_CODE (av->value) == CONST_STRING)\n+\t  {\n+\t    exp = attr_eq (dim->attr->name, XSTR (av->value, 0));\n+\t    if (MEM_VOLATILE_P (exp))\n+\t      continue;\n+\n+\t    link = rtx_alloc (EXPR_LIST);\n+\t    XEXP (link, 0) = exp;\n+\t    XEXP (link, 1) = 0;\n+\t    *prev = link;\n+\t    prev = &XEXP (link, 1);\n+\t  }\n+      dim->num_values = nalt;\n+    }\n+  else\n+    {\n+      rtx orexp = false_rtx;\n+\n+      /* Very few values are used, so compute a mutually exclusive\n+\t expression.  (We could do this for numeric values if that becomes\n+\t important.)  */\n+      prev = &dim->values;\n+      for (link = dim->values; link; link = *prev)\n+\t{\n+\t  orexp = insert_right_side (IOR, orexp, XEXP (link, 0), -2);\n+\t  prev = &XEXP (link, 1);\n+\t}\n+      link = rtx_alloc (EXPR_LIST);\n+      XEXP (link, 0) = attr_rtx (NOT, orexp);\n+      XEXP (link, 1) = 0;\n+      *prev = link;\n+      dim->num_values++;\n+    }\n+  return dim->num_values;\n+}\n+\n+/* Increment the current value for the NDIM-dimensional attribute space SPACE\n+   and return FALSE if the increment overflowed.  */\n+\n+static int\n+increment_current_value (space, ndim)\n+     struct dimension *space;\n+     int ndim;\n+{\n+  int i;\n+\n+  for (i = ndim - 1; i >= 0; i--)\n+    {\n+      if ((space[i].current_value = XEXP (space[i].current_value, 1)) == 0)\n+\tspace[i].current_value = space[i].values;\n+      else\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Construct an expression corresponding to the current value for the\n+   NDIM-dimensional attribute space SPACE.  */\n+\n+static rtx\n+test_for_current_value (space, ndim)\n+     struct dimension *space;\n+     int ndim;\n+{\n+  int i;\n+  rtx exp = true_rtx;\n+\n+  for (i = 0; i < ndim; i++)\n+    exp = insert_right_side (AND, exp, XEXP (space[i].current_value, 0), -2);\n+\n+  return exp;\n+}\n+\n+/* Given the current value of the NDIM-dimensional attribute space SPACE,\n+   set the corresponding EQ_ATTR expressions to that value and reduce\n+   the expression EXP as much as possible.  On input [and output], all\n+   known EQ_ATTR expressions are set to FALSE.  */\n+\n+static rtx\n+simplify_with_current_value (exp, space, ndim)\n+     rtx exp;\n+     struct dimension *space;\n+     int ndim;\n+{\n+  int i;\n+  rtx x;\n+\n+  /* Mark each current value as TRUE.  */\n+  for (i = 0; i < ndim; i++)\n+    {\n+      x = XEXP (space[i].current_value, 0);\n+      if (GET_CODE (x) == EQ_ATTR)\n+\tMEM_VOLATILE_P (x) = 0;\n+    }\n+\n+  exp = simplify_with_current_value_aux (exp);\n+\n+  /* Change each current value back to FALSE.  */\n+  for (i = 0; i < ndim; i++)\n+    {\n+      x = XEXP (space[i].current_value, 0);\n+      if (GET_CODE (x) == EQ_ATTR)\n+\tMEM_VOLATILE_P (x) = 1;\n+    }\n+}\n+\n+/* Reduce the expression EXP based on the MEM_VOLATILE_P settings of\n+   all EQ_ATTR expressions.  */\n+\n+static rtx\n+simplify_with_current_value_aux (exp)\n+     rtx exp;\n+{\n+  register int i;\n+  rtx cond;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case EQ_ATTR:\n+      if (MEM_VOLATILE_P (exp))\n+\treturn false_rtx;\n+      else\n+\treturn true_rtx;\n+    case CONST_STRING:\n+      return exp;\n+\n+    case IF_THEN_ELSE:\n+      cond = simplify_with_current_value_aux (XEXP (exp, 0));\n+      if (cond == true_rtx)\n+\treturn simplify_with_current_value_aux (XEXP (exp, 1));\n+      else if (cond == false_rtx)\n+\treturn simplify_with_current_value_aux (XEXP (exp, 2));\n+      else\n+\treturn attr_rtx (IF_THEN_ELSE, cond,\n+\t\t\t simplify_with_current_value_aux (XEXP (exp, 1)),\n+\t\t\t simplify_with_current_value_aux (XEXP (exp, 2)));\n+\n+    case IOR:\n+      cond = simplify_with_current_value_aux (XEXP (exp, 1));\n+      if (cond == true_rtx)\n+\treturn cond;\n+      else if (cond == false_rtx)\n+\treturn simplify_with_current_value_aux (XEXP (exp, 0));\n+      else\n+\treturn attr_rtx (IOR, cond,\n+\t\t\t simplify_with_current_value_aux (XEXP (exp, 0)));\n+\n+    case AND:\n+      cond = simplify_with_current_value_aux (XEXP (exp, 1));\n+      if (cond == true_rtx)\n+\treturn simplify_with_current_value_aux (XEXP (exp, 0));\n+      else if (cond == false_rtx)\n+\treturn cond;\n+      else\n+\treturn attr_rtx (AND, cond,\n+\t\t\t simplify_with_current_value_aux (XEXP (exp, 0)));\n+\n+    case NOT:\n+      cond = simplify_with_current_value_aux (XEXP (exp, 0));\n+      if (cond == true_rtx)\n+\treturn false_rtx;\n+      else if (cond == false_rtx)\n+\treturn true_rtx;\n+      else\n+\treturn attr_rtx (NOT, cond);\n+\n+    case COND:\n+      for (i = 0; i < XVECLEN (exp, 0); i += 2)\n+\t{\n+\t  cond = simplify_with_current_value_aux (XVECEXP (exp, 0, i));\n+\t  if (cond == true_rtx)\n+\t    return simplify_with_current_value_aux (XVECEXP (exp, 0, i + 1));\n+\t  else if (cond == false_rtx)\n+\t    continue;\n+\t  else\n+\t    abort (); /* With all EQ_ATTR's of known value, a case should\n+\t\t\t have been selected.  */\n+\t}\n+      return simplify_with_current_value_aux (XEXP (exp, 1));\n+    }\n+  abort ();\n+}\n+\f\n /* Clear the MEM_IN_STRUCT_P flag in EXP and its subexpressions.  */\n \n clear_struct_flag (x)\n@@ -3297,6 +3958,7 @@ gen_unit (def)\n       unit->condexp = false_rtx;\n       unit->ops = 0;\n       unit->next = units;\n+      unit->min_busy_delay = unit->max_busy_delay = XINT (def, 5);\n       units = unit;\n     }\n \n@@ -3322,9 +3984,15 @@ gen_unit (def)\n       op->busyexp = attr_rtx (IF_THEN_ELSE, orexp,\n \t\t\t      make_numeric_value (XINT (def, 5)),\n \t\t\t      make_numeric_value (0));\n+      unit->min_busy_delay = MIN (unit->min_busy_delay, 0);\n+      unit->max_busy_delay = MAX (unit->max_busy_delay, XINT (def, 5));\n     }\n   else\n-    op->busyexp = make_numeric_value (XINT (def, 5));\n+    {\n+      op->busyexp = make_numeric_value (XINT (def, 5));\n+      unit->min_busy_delay = MIN (unit->min_busy_delay, XINT (def, 5));\n+      unit->max_busy_delay = MAX (unit->max_busy_delay, XINT (def, 5));\n+    }\n \n   /* Merge our conditional into that of the function unit so we can determine\n      which insns are used by the function unit.  */\n@@ -4100,25 +4768,16 @@ write_function_unit_info ()\n \n   for (unit = units; unit; unit = unit->next)\n     {\n-      /* See if only one case exists and if there is a constant value for\n-\t that case.  If so, we don't need a function.  */\n-      str = (char *) alloca (strlen (unit->name) + 10);\n-      sprintf (str, \"*%s_cases\", unit->name);\n-      attr = find_attr (str, 0);\n-      if (! attr) abort ();\n-      value = find_single_value (attr);\n-      if (value && GET_CODE (value) == CONST_STRING)\n+      /* Record the maximum busy cost.  */\n+      unit->max_busy_cost = make_numeric_value (unit->max_busy_delay);\n+\n+      /* If the minimum and maximum conflict costs are the same, there\n+\t is only one value, so we don't need a function.  */\n+      if (unit->min_busy_delay == unit->max_busy_delay)\n \t{\n-\t  sprintf (str, \"*%s_case_%s\", unit->name, XSTR (value, 0));\n-\t  attr = find_attr (str, 0);\n-\t  if (! attr) abort ();\n-\t  value = find_single_value (attr);\n-\t  if (value && GET_CODE (value) == CONST_STRING)\n-\t    {\n-\t      unit->needs_conflict_function = 0;\n-\t      unit->default_cost = value;\n-\t      continue;\n-\t    }\n+\t  unit->needs_conflict_function = 0;\n+\t  unit->default_cost = unit->max_busy_cost;\n+\t  continue;\n \t}\n \n       /* The function first computes the case from the candidate insn.  */\n@@ -4138,6 +4797,7 @@ write_function_unit_info ()\n       printf (\"    {\\n\");\n \n       /* Write the `switch' statement to get the case value.  */\n+      str = (char *) alloca (strlen (unit->name) + 10);\n       sprintf (str, \"*%s_cases\", unit->name);\n       case_attr = find_attr (str, 0);\n       if (! case_attr) abort ();\n@@ -4205,11 +4865,18 @@ write_function_unit_info ()\n \n   printf (\"struct function_unit_desc function_units[] = {\\n\");\n \n-  for (unit = units; unit; unit = unit->next)\n+  /* Write out the descriptions in numeric order, but don't force that order\n+     on the list.  Doing so increases the runtime of genattrtab.c.  */\n+  for (i = 0; i < num_units; i++)\n     {\n-      printf (\"  {\\\"%s\\\", %d, %d, %d, %s, %s_unit_ready_cost, \",\n+      for (unit = units; unit; unit = unit->next)\n+\tif (unit->num == i)\n+\t  break;\n+\n+      printf (\"  {\\\"%s\\\", %d, %d, %d, %s, %s, %s_unit_ready_cost, \",\n \t      unit->name, 1 << unit->num, unit->multiplicity,\n-\t      unit->simultaneity, XSTR (unit->default_cost, 0), unit->name);\n+\t      unit->simultaneity, XSTR (unit->default_cost, 0),\n+\t      XSTR (unit->max_busy_cost, 0), unit->name);\n \n       if (unit->needs_conflict_function)\n \tprintf (\"%s_unit_conflict_cost\", unit->name);\n@@ -4302,7 +4969,7 @@ find_attr (name, create)\n   attr = (struct attr_desc *) xmalloc (sizeof (struct attr_desc));\n   attr->name = attr_string (name, strlen (name));\n   attr->first_value = attr->default_val = NULL;\n-  attr->is_numeric = attr->is_const = attr->is_special = 0;\n+  attr->is_numeric = attr->negative_ok = attr->is_const = attr->is_special = 0;\n   attr->next = attrs[index];\n   attrs[index] = attr;\n \n@@ -4325,7 +4992,8 @@ make_internal_attr (name, value, special)\n \n   attr->is_numeric = 1;\n   attr->is_const = 0;\n-  attr->is_special = special;\n+  attr->is_special = (special & 1) != 0;\n+  attr->negative_ok = (special & 2) != 0;\n   attr->default_val = get_attr_value (value, attr, -2);\n }\n "}]}