{"sha": "78bca40d1df75b037b946d10dc1151fffc17fbf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiY2E0MGQxZGY3NWIwMzdiOTQ2ZDEwZGMxMTUxZmZmYzE3ZmJmOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-09-26T13:38:54Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-09-26T13:38:54Z"}, "message": "tree-ssa-live.h (find_replaceable_exprs, [...]): Move prototypes to...\n\n\n2013-09-26  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-ssa-live.h (find_replaceable_exprs, dump_replaceable_exprs): Move\n\tprototypes to...\n\t* tree-ssa-ter.h: New File.  Move prototypes here.\n\t* tree-flow.h (stmt_is_replaceable_p): Remove prototype.\n\t* tree-outof-ssa.h: New. Rename ssaexpand.h, include tree-ssa-ter.h.\n\t* tree-outof-ssa.c (ssa_is_replaceable_p): New.  Refactor common bits\n\tfrom is_replaceable_p. \n\t* tree-ssa-ter.c (is_replaceable_p, stmt_is_replaceable_p): Delete.\n\t(ter_is_replaceable_p): New.  Use new refactored ssa_is_replaceable_p.\n\t(process_replaceable): Use ter_is_replaceable_p.\n\t(find_replaceable_in_bb): Use ter_is_replaceable_p.\n\t* expr.c (stmt_is_replaceable_p): Relocate from tree-ssa-ter.c.  Use\n\tnewly refactored ssa_is_replaceable_p.\n\t* cfgexpand.c: Include tree-outof-ssa.h.\n\t* ssaexpand.h: Delete.\n\nFrom-SVN: r202946", "tree": {"sha": "bf1ee8e68198405d46df67850c59d9346411f5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf1ee8e68198405d46df67850c59d9346411f5b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78bca40d1df75b037b946d10dc1151fffc17fbf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bca40d1df75b037b946d10dc1151fffc17fbf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bca40d1df75b037b946d10dc1151fffc17fbf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bca40d1df75b037b946d10dc1151fffc17fbf9/comments", "author": null, "committer": null, "parents": [{"sha": "ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2a63a749c386637ef085f7bc3102a8d8d2aab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2a63a749c386637ef085f7bc3102a8d8d2aab3"}], "stats": {"total": 336, "additions": 211, "deletions": 125}, "files": [{"sha": "f69ae29ae1b56059ecb249b0e3e3febebbeaeaec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -1,3 +1,21 @@\n+2013-09-26  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-ssa-live.h (find_replaceable_exprs, dump_replaceable_exprs): Move\n+\tprototypes to...\n+\t* tree-ssa-ter.h: New File.  Move prototypes here.\n+\t* tree-flow.h (stmt_is_replaceable_p): Remove prototype.\n+\t* tree-outof-ssa.h: New. Rename ssaexpand.h, include tree-ssa-ter.h.\n+\t* tree-outof-ssa.c (ssa_is_replaceable_p): New.  Refactor common bits\n+\tfrom is_replaceable_p. \n+\t* tree-ssa-ter.c (is_replaceable_p, stmt_is_replaceable_p): Delete.\n+\t(ter_is_replaceable_p): New.  Use new refactored ssa_is_replaceable_p.\n+\t(process_replaceable): Use ter_is_replaceable_p.\n+\t(find_replaceable_in_bb): Use ter_is_replaceable_p.\n+\t* expr.c (stmt_is_replaceable_p): Relocate from tree-ssa-ter.c.  Use\n+\tnewly refactored ssa_is_replaceable_p.\n+\t* cfgexpand.c: Include tree-outof-ssa.h.\n+\t* ssaexpand.h: Delete.\n+\n 2013-09-26  Andrew MacLeod <amacleod@redhat.com>\n \n \t* gimple.c (gimple_replace_lhs): Move to tree-ssa.c and rename."}, {"sha": "f76e5f20b0ecbd4b6941463beaf4f34fd60b19ea", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -40,7 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"value-prof.h\"\n #include \"target.h\"\n-#include \"ssaexpand.h\"\n+#include \"tree-outof-ssa.h\"\n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n #include \"cfgloop.h\""}, {"sha": "235cd677e3a397b3b406836e447f5ee7f73a4cb5", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -49,7 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"diagnostic.h\"\n-#include \"ssaexpand.h\"\n+#include \"tree-outof-ssa.h\"\n #include \"target-globals.h\"\n #include \"params.h\"\n \n@@ -9126,6 +9126,24 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n }\n #undef REDUCE_BIT_FIELD\n \n+\n+/* Return TRUE if expression STMT is suitable for replacement.  \n+   Never consider memory loads as replaceable, because those don't ever lead \n+   into constant expressions.  */\n+\n+static bool\n+stmt_is_replaceable_p (gimple stmt)\n+{\n+  if (ssa_is_replaceable_p (stmt))\n+    {\n+      /* Don't move around loads.  */\n+      if (!gimple_assign_single_p (stmt)\n+\t  || is_gimple_val (gimple_assign_rhs1 (stmt)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n rtx\n expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier, rtx *alt_rtl)"}, {"sha": "cf96817649c5973588ecef59e8fb34be4ba28b5d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -679,9 +679,6 @@ bool fixup_noreturn_call (gimple stmt);\n /* In ipa-pure-const.c  */\n void warn_function_noreturn (tree);\n \n-/* In tree-ssa-ter.c  */\n-bool stmt_is_replaceable_p (gimple);\n-\n /* In tree-parloops.c  */\n bool parallelized_function_p (tree);\n "}, {"sha": "42c90d49a1807d65de26aad43f8a7510e05c67b7", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -30,12 +30,67 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"dumpfile.h\"\n #include \"diagnostic-core.h\"\n-#include \"ssaexpand.h\"\n+#include \"tree-outof-ssa.h\"\n \n /* FIXME: A lot of code here deals with expanding to RTL.  All that code\n    should be in cfgexpand.c.  */\n #include \"expr.h\"\n \n+/* Return TRUE if expression STMT is suitable for replacement.  */\n+\n+bool\n+ssa_is_replaceable_p (gimple stmt)\n+{\n+  use_operand_p use_p;\n+  tree def;\n+  gimple use_stmt;\n+\n+  /* Only consider modify stmts.  */\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  /* If the statement may throw an exception, it cannot be replaced.  */\n+  if (stmt_could_throw_p (stmt))\n+    return false;\n+\n+  /* Punt if there is more than 1 def.  */\n+  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+  if (!def)\n+    return false;\n+\n+  /* Only consider definitions which have a single use.  */\n+  if (!single_imm_use (def, &use_p, &use_stmt))\n+    return false;\n+\n+  /* Used in this block, but at the TOP of the block, not the end.  */\n+  if (gimple_code (use_stmt) == GIMPLE_PHI)\n+    return false;\n+\n+  /* There must be no VDEFs.  */\n+  if (gimple_vdef (stmt))\n+    return false;\n+\n+  /* Float expressions must go through memory if float-store is on.  */\n+  if (flag_float_store\n+      && FLOAT_TYPE_P (gimple_expr_type (stmt)))\n+    return false;\n+\n+  /* An assignment with a register variable on the RHS is not\n+     replaceable.  */\n+  if (gimple_assign_rhs_code (stmt) == VAR_DECL\n+      && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt)))\n+    return false;\n+\n+  /* No function calls can be replaced.  */\n+  if (is_gimple_call (stmt))\n+    return false;\n+\n+  /* Leave any stmt with volatile operands alone as well.  */\n+  if (gimple_has_volatile_ops (stmt))\n+    return false;\n+\n+  return true;\n+}\n \n \n /* Used to hold all the components required to do SSA PHI elimination."}, {"sha": "d0af95f0f3b4507f8fa38b6fdec4741a8c38b540", "filename": "gcc/tree-outof-ssa.h", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-outof-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-outof-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.h?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define _SSAEXPAND_H 1\n \n #include \"tree-ssa-live.h\"\n+#include \"tree-ssa-ter.h\"\n \n /* This structure (of which only a singleton SA exists) is used to\n    pass around information between the outof-SSA functions, cfgexpand\n@@ -71,9 +72,9 @@ get_gimple_for_ssa_name (tree exp)\n   return NULL;\n }\n \n-/* In tree-outof-ssa.c.  */\n-void finish_out_of_ssa (struct ssaexpand *sa);\n-unsigned int rewrite_out_of_ssa (struct ssaexpand *sa);\n-void expand_phi_nodes (struct ssaexpand *sa);\n+extern bool ssa_is_replaceable_p (gimple stmt);\n+extern void finish_out_of_ssa (struct ssaexpand *sa);\n+extern unsigned int rewrite_out_of_ssa (struct ssaexpand *sa);\n+extern void expand_phi_nodes (struct ssaexpand *sa);\n \n #endif", "previous_filename": "gcc/ssaexpand.h"}, {"sha": "542f6a1944e5f8173c76b940d55d467e9461a3ce", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -325,10 +325,4 @@ make_live_on_entry (tree_live_info_p live, basic_block bb , int p)\n /* From tree-ssa-coalesce.c  */\n extern var_map coalesce_ssa_name (void);\n \n-\n-/* From tree-ssa-ter.c  */\n-extern bitmap find_replaceable_exprs (var_map);\n-extern void dump_replaceable_exprs (FILE *, bitmap);\n-\n-\n #endif /* _TREE_SSA_LIVE_H  */"}, {"sha": "3659cf0c428fbd619519c59359f1996ec432b0c8", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 60, "deletions": 109, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"tree-ssa.h\"\n #include \"dumpfile.h\"\n-#include \"tree-ssa-live.h\"\n+#include \"tree-outof-ssa.h\"\n #include \"flags.h\"\n \n \n@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n    information is tracked.\n \n    Variables which only have one use, and whose defining stmt is considered\n-   a replaceable expression (see is_replaceable_p) are tracked to see whether\n+   a replaceable expression (see ssa_is_replaceable_p) are tracked to see whether\n    they can be replaced at their use location.\n \n    n_12 = C * 10\n@@ -359,111 +359,6 @@ add_dependence (temp_expr_table_p tab, int version, tree var)\n }\n \n \n-/* Return TRUE if expression STMT is suitable for replacement.\n-   TER is true if is_replaceable_p is called from within TER, false\n-   when used from within stmt_is_replaceable_p, i.e. EXPAND_INITIALIZER\n-   expansion.  The differences are that with !TER some tests are skipped\n-   to make it more aggressive (doesn't require the same bb, or for -O0\n-   same locus and same BLOCK), on the other side never considers memory\n-   loads as replaceable, because those don't ever lead into constant\n-   expressions.  */\n-\n-static inline bool\n-is_replaceable_p (gimple stmt, bool ter)\n-{\n-  use_operand_p use_p;\n-  tree def;\n-  gimple use_stmt;\n-  location_t locus1, locus2;\n-  tree block1, block2;\n-\n-  /* Only consider modify stmts.  */\n-  if (!is_gimple_assign (stmt))\n-    return false;\n-\n-  /* If the statement may throw an exception, it cannot be replaced.  */\n-  if (stmt_could_throw_p (stmt))\n-    return false;\n-\n-  /* Punt if there is more than 1 def.  */\n-  def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n-  if (!def)\n-    return false;\n-\n-  /* Only consider definitions which have a single use.  */\n-  if (!single_imm_use (def, &use_p, &use_stmt))\n-    return false;\n-\n-  /* If the use isn't in this block, it wont be replaced either.  */\n-  if (ter && gimple_bb (use_stmt) != gimple_bb (stmt))\n-    return false;\n-\n-  locus1 = gimple_location (stmt);\n-  block1 = LOCATION_BLOCK (locus1);\n-  locus1 = LOCATION_LOCUS (locus1);\n-\n-  if (gimple_code (use_stmt) == GIMPLE_PHI)\n-    locus2 = gimple_phi_arg_location (use_stmt, PHI_ARG_INDEX_FROM_USE (use_p));\n-  else\n-    locus2 = gimple_location (use_stmt);\n-  block2 = LOCATION_BLOCK (locus2);\n-  locus2 = LOCATION_LOCUS (locus2);\n-\n-  if ((!optimize || optimize_debug)\n-      && ter\n-      && ((locus1 != UNKNOWN_LOCATION\n-\t   && locus1 != locus2)\n-\t  || (block1 != NULL_TREE\n-\t      && block1 != block2)))\n-    return false;\n-\n-  /* Used in this block, but at the TOP of the block, not the end.  */\n-  if (gimple_code (use_stmt) == GIMPLE_PHI)\n-    return false;\n-\n-  /* There must be no VDEFs.  */\n-  if (gimple_vdef (stmt))\n-    return false;\n-\n-  /* Without alias info we can't move around loads.  */\n-  if ((!optimize || !ter)\n-      && gimple_assign_single_p (stmt)\n-      && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n-    return false;\n-\n-  /* Float expressions must go through memory if float-store is on.  */\n-  if (flag_float_store\n-      && FLOAT_TYPE_P (gimple_expr_type (stmt)))\n-    return false;\n-\n-  /* An assignment with a register variable on the RHS is not\n-     replaceable.  */\n-  if (gimple_assign_rhs_code (stmt) == VAR_DECL\n-      && DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt)))\n-    return false;\n-\n-  /* No function calls can be replaced.  */\n-  if (is_gimple_call (stmt))\n-    return false;\n-\n-  /* Leave any stmt with volatile operands alone as well.  */\n-  if (gimple_has_volatile_ops (stmt))\n-    return false;\n-\n-  return true;\n-}\n-\n-\n-/* Variant of is_replaceable_p test for use in EXPAND_INITIALIZER\n-   expansion.  */\n-\n-bool\n-stmt_is_replaceable_p (gimple stmt)\n-{\n-  return is_replaceable_p (stmt, false);\n-}\n-\n-\n /* This function will remove the expression for VERSION from replacement\n    consideration in table TAB.  If FREE_EXPR is true, then remove the\n    expression from consideration as well by freeing the decl uid bitmap.  */\n@@ -487,6 +382,62 @@ finished_with_expr (temp_expr_table_p tab, int version, bool free_expr)\n }\n \n \n+/* Return TRUE if expression STMT is suitable for replacement.\n+   In addition to ssa_is_replaceable_p, require the same bb, and for -O0\n+   same locus and same BLOCK), Considers memory loads as replaceable if aliasing\n+   is available.  */\n+\n+static inline bool\n+ter_is_replaceable_p (gimple stmt)\n+{\n+\n+  if (ssa_is_replaceable_p (stmt))\n+    {\n+      use_operand_p use_p;\n+      tree def;\n+      gimple use_stmt;\n+      location_t locus1, locus2;\n+      tree block1, block2;\n+\n+      /* Only consider definitions which have a single use.  ssa_is_replaceable_p\n+\t already performed this check, but the use stmt pointer is required for\n+\t further checks.  */\n+      def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+      if (!single_imm_use (def, &use_p, &use_stmt))\n+\t  return false;\n+\n+      /* If the use isn't in this block, it wont be replaced either.  */\n+      if (gimple_bb (use_stmt) != gimple_bb (stmt))\n+        return false;\n+\n+      locus1 = gimple_location (stmt);\n+      block1 = LOCATION_BLOCK (locus1);\n+      locus1 = LOCATION_LOCUS (locus1);\n+\n+      if (gimple_code (use_stmt) == GIMPLE_PHI)\n+\tlocus2 = gimple_phi_arg_location (use_stmt, \n+\t\t\t\t\t  PHI_ARG_INDEX_FROM_USE (use_p));\n+      else\n+\tlocus2 = gimple_location (use_stmt);\n+      block2 = LOCATION_BLOCK (locus2);\n+      locus2 = LOCATION_LOCUS (locus2);\n+\n+      if ((!optimize || optimize_debug)\n+\t  && ((locus1 != UNKNOWN_LOCATION && locus1 != locus2)\n+\t      || (block1 != NULL_TREE && block1 != block2)))\n+\treturn false;\n+\n+      /* Without alias info we can't move around loads.  */\n+      if (!optimize && gimple_assign_single_p (stmt)\n+\t  && !is_gimple_val (gimple_assign_rhs1 (stmt)))\n+\treturn false;\n+\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Create an expression entry for a replaceable expression.  */\n \n static void\n@@ -497,7 +448,7 @@ process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n   ssa_op_iter iter;\n   bitmap def_vars, use_vars;\n \n-  gcc_checking_assert (is_replaceable_p (stmt, true));\n+  gcc_checking_assert (ter_is_replaceable_p (stmt));\n \n   def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n   version = SSA_NAME_VERSION (def);\n@@ -612,7 +563,7 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n       if (is_gimple_debug (stmt))\n \tcontinue;\n \n-      stmt_replaceable = is_replaceable_p (stmt, true);\n+      stmt_replaceable = ter_is_replaceable_p (stmt);\n \n       /* Determine if this stmt finishes an existing expression.  */\n       FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)"}, {"sha": "4565db16b86015549cb35ef526b921318864499f", "filename": "gcc/tree-ssa-ter.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-ter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78bca40d1df75b037b946d10dc1151fffc17fbf9/gcc%2Ftree-ssa-ter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.h?ref=78bca40d1df75b037b946d10dc1151fffc17fbf9", "patch": "@@ -0,0 +1,52 @@\n+/* Header file for tree-ssa-ter.c exports.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_TER_H\n+#define GCC_TREE_SSA_TER_H\n+\n+extern bitmap find_replaceable_exprs (var_map);\n+extern void dump_replaceable_exprs (FILE *, bitmap);\n+\n+#endif /* GCC_TREE_SSA_TER_H */\n+/* Header file for tree-ssa-ter.c exports.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_TER_H\n+#define GCC_TREE_SSA_TER_H\n+\n+extern bitmap find_replaceable_exprs (var_map);\n+extern void dump_replaceable_exprs (FILE *, bitmap);\n+\n+#endif /* GCC_TREE_SSA_TER_H */"}]}