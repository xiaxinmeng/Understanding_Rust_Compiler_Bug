{"sha": "c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1ODNlZDIzZDZmYzI3MDZiZmFmNDAzYzRjM2JhNDFmOTJiOWI1MA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-07-16T00:39:40Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-07-16T00:39:40Z"}, "message": "re PR fortran/16404 (should reject invalid code with -pedantic -std=f95 ? (x8))\n\nPR fortran/16404\n(parts ported from g95)\n* parse.h (gfc_state_data): New field do_variable.\n(gfc_check_do_variable): Add prototype.\n* parse.c (push_state): Initialize field 'do_variable'.\n(gfc_check_do_variable): New function.\n(parse_do_block): Remember do iterator variable.\n(parse_file): Initialize field 'do_variable'.\n* match.c (gfc_match_assignment, gfc_match_do,\ngfc_match_allocate, gfc_match_nullify, gfc_match_deallocate):\nAdd previously missing checks.\n(gfc_match_return): Reformat error message.\n* io.c (match_out_tag): New function.\n(match_open_element, match_close_element,\nmatch_file_element, match_dt_element): Call match_out_tag\ninstead of match_vtag where appropriate.\n(match_io_iterator, match_io_element): Add missing check.\n(match_io): Reformat error message.\n(match_inquire_element): Call match_out_tag where appropriate.\n\nFrom-SVN: r84793", "tree": {"sha": "24952643edf5054848eaa39feffd49799b9beece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24952643edf5054848eaa39feffd49799b9beece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94f3b4f2bc52f378923e08e9f7b2684a9ef6c7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94f3b4f2bc52f378923e08e9f7b2684a9ef6c7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94f3b4f2bc52f378923e08e9f7b2684a9ef6c7c"}], "stats": {"total": 160, "additions": 142, "deletions": 18}, "files": [{"sha": "d3f24d068b039ca4dae49ff940000da2651e9ebb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "patch": "@@ -1,3 +1,25 @@\n+2004-07-16  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/16404\n+\t(parts ported from g95)\n+\t* parse.h (gfc_state_data): New field do_variable.\n+\t(gfc_check_do_variable): Add prototype.\n+\t* parse.c (push_state): Initialize field 'do_variable'.\n+\t(gfc_check_do_variable): New function.\n+\t(parse_do_block): Remember do iterator variable.\n+\t(parse_file): Initialize field 'do_variable'.\n+\t* match.c (gfc_match_assignment, gfc_match_do,\n+\tgfc_match_allocate, gfc_match_nullify, gfc_match_deallocate):\n+\tAdd previously missing checks.\n+\t(gfc_match_return): Reformat error message.\n+\t* io.c (match_out_tag): New function.\n+\t(match_open_element, match_close_element,\n+\tmatch_file_element, match_dt_element): Call match_out_tag\n+\tinstead of match_vtag where appropriate.\n+\t(match_io_iterator, match_io_element): Add missing check.\n+\t(match_io): Reformat error message.\n+\t(match_inquire_element): Call match_out_tag where appropriate.\n+\n 2004-07-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/15129"}, {"sha": "05c4571302ee526c87c8e6cd71d09ca4b39e771a", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "patch": "@@ -918,6 +918,21 @@ match_vtag (const io_tag * tag, gfc_expr ** v)\n }\n \n \n+/* Match I/O tags that cause variables to become redefined.  */\n+\n+static match\n+match_out_tag(const io_tag *tag, gfc_expr **result)\n+{\n+  match m;\n+\n+  m = match_vtag(tag, result);\n+  if (m == MATCH_YES)\n+    gfc_check_do_variable((*result)->symtree);\n+\n+  return m;\n+}\n+\n+\n /* Match a label I/O tag.  */\n \n static match\n@@ -993,7 +1008,7 @@ match_open_element (gfc_open * open)\n   m = match_etag (&tag_unit, &open->unit);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_vtag (&tag_iostat, &open->iostat);\n+  m = match_out_tag (&tag_iostat, &open->iostat);\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_file, &open->file);\n@@ -1179,7 +1194,7 @@ match_close_element (gfc_close * close)\n   m = match_etag (&tag_status, &close->status);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_vtag (&tag_iostat, &close->iostat);\n+  m = match_out_tag (&tag_iostat, &close->iostat);\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &close->err);\n@@ -1292,7 +1307,7 @@ match_file_element (gfc_filepos * fp)\n   m = match_etag (&tag_unit, &fp->unit);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_vtag (&tag_iostat, &fp->iostat);\n+  m = match_out_tag (&tag_iostat, &fp->iostat);\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &fp->err);\n@@ -1603,7 +1618,7 @@ match_dt_element (io_kind k, gfc_dt * dt)\n   m = match_etag (&tag_rec, &dt->rec);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_vtag (&tag_iostat, &dt->iostat);\n+  m = match_out_tag (&tag_iostat, &dt->iostat);\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &dt->err);\n@@ -1612,7 +1627,7 @@ match_dt_element (io_kind k, gfc_dt * dt)\n   m = match_etag (&tag_advance, &dt->advance);\n   if (m != MATCH_NO)\n     return m;\n-  m = match_vtag (&tag_size, &dt->size);\n+  m = match_out_tag (&tag_size, &dt->size);\n   if (m != MATCH_NO)\n     return m;\n \n@@ -1842,7 +1857,10 @@ match_io_iterator (io_kind k, gfc_code ** result)\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n-\tbreak;\n+\t{\n+\t  gfc_check_do_variable (iter->var->symtree);\n+\t  break;\n+\t}\n \n       m = match_io_element (k, &new);\n       if (m == MATCH_ERROR)\n@@ -1942,6 +1960,9 @@ match_io_element (io_kind k, gfc_code ** cpp)\n \t    m = MATCH_ERROR;\n \t  }\n \n+\tif (gfc_check_do_variable (expr->symtree))\n+\t  m = MATCH_ERROR;\n+\n \tbreak;\n \n       case M_WRITE:\n@@ -2149,8 +2170,8 @@ match_io (io_kind k)\n   if (!comma_flag\n       && gfc_match_char (',') == MATCH_YES\n       && k == M_WRITE\n-      && gfc_notify_std (GFC_STD_GNU, \"Comma before output item list \"\n-\t\t\t \"at %C is an extension\") == FAILURE)\n+      && gfc_notify_std (GFC_STD_GNU, \"Extension: Comma before output \"\n+\t\t\t \"item list at %C is an extension\") == FAILURE)\n     return MATCH_ERROR;\n \n   io_code = NULL;\n@@ -2298,20 +2319,20 @@ match_inquire_element (gfc_inquire * inquire)\n   m = match_etag (&tag_unit, &inquire->unit);\n   RETM m = match_etag (&tag_file, &inquire->file);\n   RETM m = match_ltag (&tag_err, &inquire->err);\n-  RETM m = match_vtag (&tag_iostat, &inquire->iostat);\n+  RETM m = match_out_tag (&tag_iostat, &inquire->iostat);\n   RETM m = match_vtag (&tag_exist, &inquire->exist);\n   RETM m = match_vtag (&tag_opened, &inquire->opened);\n   RETM m = match_vtag (&tag_named, &inquire->named);\n   RETM m = match_vtag (&tag_name, &inquire->name);\n-  RETM m = match_vtag (&tag_number, &inquire->number);\n+  RETM m = match_out_tag (&tag_number, &inquire->number);\n   RETM m = match_vtag (&tag_s_access, &inquire->access);\n   RETM m = match_vtag (&tag_sequential, &inquire->sequential);\n   RETM m = match_vtag (&tag_direct, &inquire->direct);\n   RETM m = match_vtag (&tag_s_form, &inquire->form);\n   RETM m = match_vtag (&tag_formatted, &inquire->formatted);\n   RETM m = match_vtag (&tag_unformatted, &inquire->unformatted);\n-  RETM m = match_vtag (&tag_s_recl, &inquire->recl);\n-  RETM m = match_vtag (&tag_nextrec, &inquire->nextrec);\n+  RETM m = match_out_tag (&tag_s_recl, &inquire->recl);\n+  RETM m = match_out_tag (&tag_nextrec, &inquire->nextrec);\n   RETM m = match_vtag (&tag_s_blank, &inquire->blank);\n   RETM m = match_vtag (&tag_s_position, &inquire->position);\n   RETM m = match_vtag (&tag_s_action, &inquire->action);"}, {"sha": "55e135b9ea213ad7bd0c3a3bf03bdfe5a7529223", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "patch": "@@ -835,6 +835,13 @@ gfc_match_assignment (void)\n   if (m != MATCH_YES)\n     goto cleanup;\n \n+  if (lvalue->symtree->n.sym->attr.flavor == FL_PARAMETER)\n+    {\n+      gfc_error (\"Cannot assign to a PARAMETER variable at %C\");\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n+\n   m = gfc_match (\" %e%t\", &rvalue);\n   if (m != MATCH_YES)\n     goto cleanup;\n@@ -845,6 +852,8 @@ gfc_match_assignment (void)\n   new_st.expr = lvalue;\n   new_st.expr2 = rvalue;\n \n+  gfc_check_do_variable (lvalue->symtree);\n+\n   return MATCH_YES;\n \n cleanup:\n@@ -1232,6 +1241,8 @@ gfc_match_do (void)\n   if (m == MATCH_ERROR)\n     goto cleanup;\n \n+  gfc_check_do_variable (iter.var->symtree);\n+\n   if (gfc_match_eos () != MATCH_YES)\n     {\n       gfc_syntax_error (ST_DO);\n@@ -1688,6 +1699,9 @@ gfc_match_allocate (void)\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n \n+      if (gfc_check_do_variable (tail->expr->symtree))\n+\tgoto cleanup;\n+\n       if (gfc_pure (NULL)\n           && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n@@ -1723,6 +1737,14 @@ gfc_match_allocate (void)\n \t     \"procedure\");\n \t  goto cleanup;\n \t}\n+\n+      if (stat->symtree->n.sym->attr.flavor != FL_VARIABLE)\n+\t{\n+\t  gfc_error(\"STAT expression at %C must be a variable\");\n+\t  goto cleanup;\n+\t}\n+\n+      gfc_check_do_variable(stat->symtree);\n     }\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n@@ -1767,6 +1789,9 @@ gfc_match_nullify (void)\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n+      if (gfc_check_do_variable(p->symtree))\n+\tgoto cleanup;\n+\n       if (gfc_pure (NULL) && gfc_impure_variable (p->symtree->n.sym))\n \t{\n \t  gfc_error\n@@ -1841,6 +1866,9 @@ gfc_match_deallocate (void)\n       if (m == MATCH_NO)\n \tgoto syntax;\n \n+      if (gfc_check_do_variable (tail->expr->symtree))\n+\tgoto cleanup;\n+\n       if (gfc_pure (NULL)\n           && gfc_impure_variable (tail->expr->symtree->n.sym))\n \t{\n@@ -1860,11 +1888,29 @@ gfc_match_deallocate (void)\n \tbreak;\n     }\n \n-  if (stat != NULL && stat->symtree->n.sym->attr.intent == INTENT_IN)\n+  if (stat != NULL)\n     {\n-      gfc_error (\"STAT variable '%s' of DEALLOCATE statement at %C cannot be \"\n-\t\t \"INTENT(IN)\", stat->symtree->n.sym->name);\n-      goto cleanup;\n+      if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n+\t{\n+\t  gfc_error (\"STAT variable '%s' of DEALLOCATE statement at %C \"\n+\t\t     \"cannot be INTENT(IN)\", stat->symtree->n.sym->name);\n+\t  goto cleanup;\n+\t}\n+\n+      if (gfc_pure(NULL) && gfc_impure_variable (stat->symtree->n.sym))\n+\t{\n+\t  gfc_error (\"Illegal STAT variable in DEALLOCATE statement at %C \"\n+\t\t     \"for a PURE procedure\");\n+\t  goto cleanup;\n+\t}\n+\n+      if (stat->symtree->n.sym->attr.flavor != FL_VARIABLE)\n+\t{\n+\t  gfc_error(\"STAT expression at %C must be a variable\");\n+\t  goto cleanup;\n+\t}\n+\n+      gfc_check_do_variable(stat->symtree);\n     }\n \n   if (gfc_match (\" )%t\") != MATCH_YES)\n@@ -1897,8 +1943,8 @@ gfc_match_return (void)\n \n   gfc_enclosing_unit (&s);\n   if (s == COMP_PROGRAM\n-      && gfc_notify_std (GFC_STD_GNU, \"RETURN statement in a main \"\n-\t\t\t \"program at %C is an extension.\") == FAILURE)\n+      && gfc_notify_std (GFC_STD_GNU, \"Extension: RETURN statement in \"\n+\t\t\t \"main program at %C\") == FAILURE)\n       return MATCH_ERROR;\n \n   e = NULL;"}, {"sha": "68f1ddd673db0ee368c34c98ae90082cd80b18e1", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "patch": "@@ -551,6 +551,7 @@ push_state (gfc_state_data * p, gfc_compile_state new_state, gfc_symbol * sym)\n   p->previous = gfc_state_stack;\n   p->sym = sym;\n   p->head = p->tail = NULL;\n+  p->do_variable = NULL;\n \n   gfc_state_stack = p;\n }\n@@ -1911,6 +1912,28 @@ parse_select_block (void)\n }\n \n \n+/* Given a symbol, make sure it is not an iteration variable for a DO\n+   statement.  This subroutine is called when the symbol is seen in a\n+   context that causes it to become redefined.  If the symbol is an\n+   iterator, we generate an error message and return nonzero.  */\n+\n+int \n+gfc_check_do_variable (gfc_symtree *st)\n+{\n+  gfc_state_data *s;\n+\n+  for (s=gfc_state_stack; s; s = s->previous)\n+    if (s->do_variable == st)\n+      {\n+\tgfc_error_now(\"Variable '%s' at %C cannot be redefined inside \"\n+\t\t      \"loop beginning at %L\", st->name, &s->tail->loc);\n+\treturn 1;\n+      }\n+\n+  return 0;\n+}\n+  \n+\n /* Checks to see if the current statement label closes an enddo.\n    Returns 0 if not, 1 if closes an ENDDO correctly, or 2 (and issues\n    an error) if it incorrectly closes an ENDDO.  */\n@@ -1965,14 +1988,22 @@ parse_do_block (void)\n   gfc_statement st;\n   gfc_code *top;\n   gfc_state_data s;\n+  gfc_symtree *stree;\n \n   s.ext.end_do_label = new_st.label;\n \n+  if (new_st.ext.iterator != NULL)\n+    stree = new_st.ext.iterator->var->symtree;\n+  else\n+    stree = NULL;\n+\n   accept_statement (ST_DO);\n \n   top = gfc_state_stack->tail;\n   push_state (&s, COMP_DO, gfc_new_block);\n \n+  s.do_variable = stree;\n+\n   top->block = new_level (top);\n   top->block->op = EXEC_DO;\n \n@@ -2506,6 +2537,7 @@ gfc_parse_file (void)\n   top.sym = NULL;\n   top.previous = NULL;\n   top.head = top.tail = NULL;\n+  top.do_variable = NULL;\n \n   gfc_state_stack = &top;\n "}, {"sha": "c0c096547514a2c53a3a4d511d2a0c93aa0fe6dd", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=c9583ed23d6fc2706bfaf403c4c3ba41f92b9b50", "patch": "@@ -40,6 +40,8 @@ typedef struct gfc_state_data\n {\n   gfc_compile_state state;\n   gfc_symbol *sym;              /* Block name associated with this level */\n+  gfc_symtree *do_variable;     /* For DO blocks the iterator variable.  */\n+\n   struct gfc_code *head, *tail;\n   struct gfc_state_data *previous;\n \n@@ -57,6 +59,7 @@ extern gfc_state_data *gfc_state_stack;\n #define gfc_current_block() (gfc_state_stack->sym)\n #define gfc_current_state() (gfc_state_stack->state)\n \n+int gfc_check_do_variable (gfc_symtree *);\n try gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n const char *gfc_ascii_statement (gfc_statement);"}]}