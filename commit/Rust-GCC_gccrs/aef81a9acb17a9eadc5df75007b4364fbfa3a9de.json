{"sha": "aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmODFhOWFjYjE3YTllYWRjNWRmNzUwMDdiNDM2NGZiZmEzYTlkZQ==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2003-11-26T22:23:40Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-11-26T22:23:40Z"}, "message": "StateEdit.java (getPresentationName): Docfix.\n\n2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/StateEdit.java (getPresentationName): Docfix.\n\t* javax/swing/undo/AbstractUndoableEdit.java (canUndo, canRedo,\n\tisSignificant): Likewise.\n\n2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/CompoundEdit.java: Re-format, document.\n\t(inProgress): Set initial value to true.\n\t(undo, redo, die, canUndo, canRedo): Also call inherited\n\timplementation; simplify code structure.\n\t(getPresentationName, getUndoPresentationName,\n\tgetRedoPresentationName): Make behavior dependent on lastEdit.\n\t(addEdit, isSignificant): Completely re-written.\n\n2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/StateEdit.java: Re-format, document.\n\t(undo, redo): Also call inherited implementation.\n\n2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/StateEditable.java: Re-format, document.\n\n2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* javax/swing/undo/AbstractUndoableEdit.java: Re-format, document.\n\t(AbstractUndoableEdit): Initialize hasBeenDone to true.\n\t(canUndo, canRedo): Simplify.\n\t(getUndoPresentationName, getRedoPresentationName): Support\n\tlocalized message; call getPresentationName() only once.\n\nFrom-SVN: r73967", "tree": {"sha": "549e886e60bcd55108bc0031071f65f863c0e849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/549e886e60bcd55108bc0031071f65f863c0e849"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/comments", "author": null, "committer": null, "parents": [{"sha": "034f23169e28ccf6d58dd77d669cccf8a3c91967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034f23169e28ccf6d58dd77d669cccf8a3c91967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/034f23169e28ccf6d58dd77d669cccf8a3c91967"}], "stats": {"total": 1244, "additions": 814, "deletions": 430}, "files": [{"sha": "d14bfdea90de4b749f3134a6416e5170f6566020", "filename": "libjava/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,3 +1,36 @@\n+2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/StateEdit.java (getPresentationName): Docfix.\n+\t* javax/swing/undo/AbstractUndoableEdit.java (canUndo, canRedo,\n+\tisSignificant): Likewise.\n+\n+2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/CompoundEdit.java: Re-format, document.\n+\t(inProgress): Set initial value to true.\n+\t(undo, redo, die, canUndo, canRedo): Also call inherited\n+\timplementation; simplify code structure.\n+\t(getPresentationName, getUndoPresentationName,\n+\tgetRedoPresentationName): Make behavior dependent on lastEdit.\n+\t(addEdit, isSignificant): Completely re-written.\n+\n+2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/StateEdit.java: Re-format, document.\n+\t(undo, redo): Also call inherited implementation.\n+\n+2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/StateEditable.java: Re-format, document.\n+\n+2003-11-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* javax/swing/undo/AbstractUndoableEdit.java: Re-format, document.\n+\t(AbstractUndoableEdit): Initialize hasBeenDone to true.\n+\t(canUndo, canRedo): Simplify.\n+\t(getUndoPresentationName, getRedoPresentationName): Support\n+\tlocalized message; call getPresentationName() only once.\n+\n 2003-11-26  David Belanger  <dbelan2@cs.mcgill.ca>\n \n \t* java/util/zip/ZipFile (Zipfile(File)): Set file path as name."}, {"sha": "e694c0a447f884ea3b26ce46fc497e7a0cb92c4b", "filename": "libjava/javax/swing/undo/AbstractUndoableEdit.java", "status": "modified", "additions": 214, "deletions": 109, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FAbstractUndoableEdit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FAbstractUndoableEdit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FAbstractUndoableEdit.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,4 +1,4 @@\n-/* AbstractTableModel.java --\n+/* AbstractUndoableEdit.java\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,180 +39,285 @@\n package javax.swing.undo;\n \n import java.io.Serializable;\n+import javax.swing.UIManager;\n+\n \n /**\n- * AbstractUndoableEdit\n- * @author Andrew Selkirk\n+ * A default implementation of <code>UndoableEdit</code> that can be\n+ * used as a base for implementing editing operations.\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class AbstractUndoableEdit implements UndoableEdit, Serializable\n+public class AbstractUndoableEdit\n+  implements UndoableEdit, Serializable\n {\n+  /**\n+   * The serialization ID.  Verified using the <code>serialver</code>\n+   * tool of Apple/Sun JDK 1.3.1 on MacOS X 10.1.5, and Sun JDK\n+   * 1.4.1_01 on GNU/Linux.\n+   */\n   static final long serialVersionUID = 580150227676302096L;\n \n-  //-------------------------------------------------------------\n-  // Constants --------------------------------------------------\n-  //-------------------------------------------------------------\n \n   /**\n-   * String returned by getRedoPresentationName()\n+   * The constant string &#x201c;Undo&#x201d;, which was returned by\n+   * {@link #getUndoPresentationName()} on early versions of the\n+   * platform. However, this field has become obsolete with version\n+   * 1.3.1.  That method now retrieves a localized string from the\n+   * {@link javax.swing.UIManager}, using the key\n+   * <code>&#x201c;AbstractUndoableEdit.undoText&#x201d;</code>.\n    */\n-  protected static final String RedoName = \"Redo\";\n+  protected static final String UndoName = \"Undo\";\n+\n \n   /**\n-   * String returned by getUndoPresentationName()\n+   * The constant string &#x201c;Redo&#x201d;, which was returned by\n+   * {@link #getRedoPresentationName()} on early versions of the\n+   * platform. However, this field has become obsolete with version\n+   * 1.3.1.  That method now retrieves a localized string from the\n+   * {@link javax.swing.UIManager}, using the key\n+   * <code>&#x201c;AbstractUndoableEdit.redoText&#x201d;</code>.\n    */\n-  protected static final String UndoName = \"Undo\";\n-\n+  protected static final String RedoName = \"Redo\";\n \n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n \n   /**\n-   * TODO\n+   * Indicates whether this editing action has been executed.  A value\n+   * of <code>true</code> means that the action was performed, or that\n+   * a redo operation was successful. A value of <code>false</code>\n+   * means that the action has not yet performed, or that an undo\n+   * operation was successful.\n    */\n-  private boolean hasBeenDone = false;\n+  private boolean hasBeenDone;\n+\n \n   /**\n-   * The edit is alive\n+   * Indicates whether this editing action is still alive. The value\n+   * is set to <code>true</code> by the constructor, and to\n+   * <code>false</code> by the {@link #die()} method.\n    */\n-  private boolean alive = true;\n+  private boolean alive;\n \n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * Create new AbstractUndoableEdit\n+   * Constructs a new <code>AbstractUndoableEdit</code>. The initial\n+   * state is that the editing action is alive, and\n+   * <code>hasBeenDone</code> is <code>true</code>.\n    */\n   public AbstractUndoableEdit()\n   {\n-  } // AbstractUndoableEdit()\n-\n+    // The API specification is not clear, but Mauve test code has\n+    // determined that hasBeenDone is initially set to true.\n+    alive = hasBeenDone = true;\n+  }\n \n-  //-------------------------------------------------------------\n-  // Interface: UndoableEdit ------------------------------------\n-  //-------------------------------------------------------------\n \n   /**\n-   * addEdit\n-   * @param anEdit TODO\n-   * @returns TODO\n+   * Undoes this editing action.\n+   *\n+   * @throws CannotUndoException if {@link #canUndo()} returns\n+   * <code>false</code>, for example because this action has already\n+   * been undone.\n+   *\n+   * @see #canUndo()\n+   * @see #redo()\n    */\n-  public boolean addEdit(UndoableEdit anEdit)\n+  public void undo()\n+    throws CannotUndoException\n   {\n-    return false;\n-  } // addEdit()\n-\n+    if (!canUndo())\n+      throw new CannotUndoException();\n+    hasBeenDone = false;\n+  }\n+  \n+  \n   /**\n-   * canRedo()\n-   * @returns true if redoable, false otherwise\n+   * Determines whether it would be possible to undo this editing\n+   * action.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * undone, <code>false</code> otherwise.\n+   *\n+   * @see #undo()\n+   * @see #canRedo()\n    */\n-  public boolean canRedo()\n+  public boolean canUndo()\n   {\n-    if (alive == true && hasBeenDone == false)\n-      return true;\n-    return false;\n-  } // canRedo()\n-\n+    return alive && hasBeenDone;\n+  }\n+  \n+  \n   /**\n-   * canUndo()\n-   * @returns true if undoable, false otherwise\n+   * Redoes this editing action.\n+   *\n+   * @throws CannotRedoException if {@link #canRedo()} returns\n+   * <code>false</code>, for example because this action has not\n+   * yet been undone.\n+   *\n+   * @see #canRedo()\n+   * @see #undo()\n    */\n-  public boolean canUndo()\n+  public void redo()\n+    throws CannotRedoException\n   {\n-    if (alive == true && hasBeenDone == true)\n-      return true;\n-    return false;\n-  } // canUndo()\n-\n+    if (!canRedo())\n+      throw new CannotRedoException();\n+    hasBeenDone = true;\n+  }\n+  \n+  \n   /**\n-   * die\n+   * Determines whether it would be possible to redo this editing\n+   * action.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * redone, <code>false</code> otherwise.\n+   *\n+   * @see #redo()\n+   * @see #canUndo()\n    */\n-  public void die()\n+  public boolean canRedo()\n   {\n-    alive = false;\n-  } // die()\n+    return alive && !hasBeenDone;\n+  }\n+\n \n   /**\n-   * getPresentation\n-   * @returns TODO\n+   * Informs this edit action that it will no longer be used. Some\n+   * actions might use this information to release resources, for\n+   * example open files.  Called by {@link UndoManager} before this\n+   * action is removed from the edit queue.\n    */\n-  public String getPresentationName()\n+  public void die()\n   {\n-    return \"\";\n-  } // getPresentationName()\n+    alive = false;\n+  }\n+\n \n   /**\n-   * getRedoPresentationName\n-   * @returns TODO\n+   * Incorporates another editing action into this one, thus forming a\n+   * combined action.\n+   *\n+   * <p>The default implementation always returns <code>false</code>,\n+   * indicating that the editing action could not be incorporated.\n+   *\n+   * @param edit the editing action to be incorporated.\n    */\n-  public String getRedoPresentationName()\n+  public boolean addEdit(UndoableEdit edit)\n   {\n-    if (getPresentationName().equals(\"\"))\n-      return RedoName;\n-    return RedoName + \" \" + getPresentationName();\n-  } // getRedoPresentationName()\n-\n+    return false;\n+  }\n+  \n+  \n   /**\n-   * getUndoPresentationName\n-   * @returns TODO\n+   * Incorporates another editing action into this one, thus forming a\n+   * combined action that replaces the argument action.\n+   *\n+   * <p>The default implementation always returns <code>false</code>,\n+   * indicating that the argument action should not be replaced.\n+   *\n+   * @param edit the editing action to be replaced.\n    */\n-  public String getUndoPresentationName()\n+  public boolean replaceEdit(UndoableEdit edit)\n   {\n-    if (getPresentationName().equals(\"\"))\n-      return UndoName;\n-    return UndoName + \" \" + getPresentationName();\n-  } // getUndoPresentationName()\n-\n+    return false;\n+  }\n+  \n+  \n   /**\n-   * isSignificant\n-   * @returns true\n+   * Determines whether this editing action is significant enough for\n+   * being seperately undoable by the user. A typical significant\n+   * action would be the resizing of an object. However, changing the\n+   * selection in a text document would usually not be considered\n+   * significant.\n+   *\n+   * <p>The default implementation returns <code>true</code>.\n+   *\n+   * @return <code>true</code> to indicate that the action is\n+   * significant enough for being separately undoable, or\n+   * <code>false</code> otherwise.\n    */\n   public boolean isSignificant()\n   {\n     return true;\n-  } // isSignificant()\n-\n+  }\n+  \n+  \n   /**\n-   * redo\n-   * @throws CannotRedoException TODO\n+   * Returns a human-readable, localized name that describes this\n+   * editing action and can be displayed to the user.\n+   *\n+   * <p>The default implementation returns an empty string.\n    */\n-  public void redo() throws CannotRedoException\n+  public String getPresentationName()\n   {\n-    if (! canRedo())\n-      throw new CannotRedoException();\n-    hasBeenDone = true;\n-  } // redo()\n+    return \"\";\n+  }\n+\n \n   /**\n-   * replaceEdit\n-   * @param anEdit TODO\n-   * @returns TODO\n+   * Calculates a localized name for presenting the undo action to the\n+   * user.\n+   *\n+   * <p>The default implementation returns the concatenation of the\n+   * string &#x201c;Undo&#x201d; and the action name, which is\n+   * determined by calling {@link #getPresentationName()}.\n+   *\n+   * <p>The string &#x201c;Undo&#x201d; is retrieved from the {@link\n+   * javax.swing.UIManager}, using the key\n+   * <code>&#x201c;AbstractUndoableEdit.undoText&#x201d;</code>.  This\n+   * allows the text to be localized.\n    */\n-  public boolean replaceEdit(UndoableEdit anEdit)\n+  public String getUndoPresentationName()\n   {\n-    return false;\n-  } // replaceEdit()\n+    String msg, pres;\n+\n+    msg = UIManager.getString(\"AbstractUndoableEdit.undoText\");\n+    if (msg == null)\n+      msg = UndoName;\n+\n+    pres = getPresentationName();\n+    if ((pres == null) || (pres.length() == 0))\n+      return msg;\n+    else\n+      return msg + ' ' + pres;\n+  }\n+\n \n   /**\n-   * String representation\n-   * @returns String representation\n+   * Calculates a localized name for presenting the redo action to the\n+   * user.\n+   *\n+   * <p>The default implementation returns the concatenation of the\n+   * string &#x201c;Redo&#x201d; and the action name, which is\n+   * determined by calling {@link #getPresentationName()}.\n+   *\n+   * <p>The string &#x201c;Redo&#x201d; is retrieved from the {@link\n+   * javax.swing.UIManager}, using the key\n+   * <code>&#x201c;AbstractUndoableEdit.redoText&#x201d;</code>.  This\n+   * allows the text to be localized.\n    */\n-  public String toString()\n+  public String getRedoPresentationName()\n   {\n-    return (super.toString() + \" hasBeenDone: \" + hasBeenDone\n-\t    + \" alive: \" + alive);\n+    String msg, pres;\n+\n+    msg = UIManager.getString(\"AbstractUndoableEdit.redoText\");\n+    if (msg == null)\n+      msg = RedoName;\n+\n+    pres = getPresentationName();\n+    if ((pres == null) || (pres.length() == 0))\n+      return msg;\n+    else\n+      return msg + ' ' + pres;\n   }\n \n-  /**\n-   * undo\n-   * @throws CannotUndoException TODO\n-   */\n-  public void undo() throws CannotUndoException\n+\n+  public String toString()\n   {\n-    if (! canUndo())\n-      throw new CannotUndoException();\n-    hasBeenDone = false;\n-  } // undo()\n-} // AbstractUndoableEdit\n+    return super.toString()\n+      + \" hasBeenDone: \" + hasBeenDone\n+      + \" alive: \" + alive;\n+  }\n+}"}, {"sha": "f482b75bb979c1ee5bef1142bc95df594d200b73", "filename": "libjava/javax/swing/undo/CannotRedoException.java", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCannotRedoException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCannotRedoException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FCannotRedoException.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,5 +1,5 @@\n-/* AbstractTableModel.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* CannotRedoException.java\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,17 +38,19 @@\n package javax.swing.undo;\n \n /**\n- * CannotRedoException\n- * @author Andrew Selkirk\n+ * An exception which indicates that an editing action cannot be\n+ * redone.\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class CannotRedoException extends RuntimeException {\n-\n-\t/**\n-\t * Create exception\n-\t */\n-\tpublic CannotRedoException() {\n-\t\tsuper();\n-\t} // CannotRedoException()\n-\n-\n-} // CannotRedoException\n+public class CannotRedoException\n+  extends RuntimeException\n+{\n+  /**\n+   * Constructs a new instance of a <code>CannotRedoException</code>.\n+   */\n+  public CannotRedoException()\n+  {\n+  }\n+}"}, {"sha": "0193921ed192cb497e16c4125f7bce233870b26f", "filename": "libjava/javax/swing/undo/CannotUndoException.java", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCannotUndoException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCannotUndoException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FCannotUndoException.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,5 +1,5 @@\n-/* AbstractTableModel.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* CannotUndoException.java\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,18 +37,21 @@\n \n package javax.swing.undo;\n \n+\n /**\n- * CannotUndoException\n- * @author Andrew Selkirk\n+ * An exception which indicates that an editing action cannot be\n+ * undone.\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class CannotUndoException extends RuntimeException {\n-\n-\t/**\n-\t * Create exception\n-\t */\n-\tpublic CannotUndoException() {\n-\t\tsuper();\n-\t} // CannotUndoException()\n-\n-\n-} // CannotUndoException\n+public class CannotUndoException\n+  extends RuntimeException\n+{\n+  /**\n+   * Constructs a new instance of a <code>CannotUndoException</code>.\n+   */\n+  public CannotUndoException()\n+  {\n+  }\n+}"}, {"sha": "12ff2bd36ec9f1044d35a395262c122fbe852713", "filename": "libjava/javax/swing/undo/CompoundEdit.java", "status": "modified", "additions": 350, "deletions": 240, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCompoundEdit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FCompoundEdit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FCompoundEdit.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,5 +1,5 @@\n-/* AbstractTableModel.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* CompoundEdit.java -- Combines multiple UndoableEdits.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,242 +41,352 @@\n import java.util.Vector;\n \n /**\n- * CompoundEdit\n- * @author Andrew Selkirk\n+ * An editing action that consists of multiple\n+ * <code>UndoableEdits</code>.\n+ *\n+ * <p>The use of a <code>CompoundEdit</code> is divided in two separate\n+ * phases.\n+ *\n+ * <ol><li>In the first phase, the <code>CompoundEdit</code> is\n+ * initialized.  After a new instance of <code>CompoundEdit</code> has\n+ * been created, {@link #addEdit(UndoableEdit)} is called for each\n+ * element of the compound.  To terminate the initialization phase,\n+ * call {@link #end()}.</li>\n+ *\n+ * <li>In the second phase, the the <code>CompoundEdit</code> can be\n+ * used, typically by invoking {@link #undo()} and {@link\n+ * #redo()}.</li></ol>\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class CompoundEdit extends AbstractUndoableEdit {\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * The collection of UndoableEdits undone/redone en\n-\t * masse by this CompoundEdit\n-\t */\n-\tprotected\tVector\tedits\t\t= new Vector();\n-\n-\t/**\n-\t * TODO\n-\t */\n-\tprivate\t\tboolean\tinProgress\t= false;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Create new Compound Edit\n-\t */\n-\tpublic CompoundEdit() {\n-\t} // CompoundEdit()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Interface: UndoableEdit ------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * addEdit\n-\t * @param anEdit TODO\n-\t * @returns TODO\n-\t */\n-\tpublic boolean addEdit(UndoableEdit anEdit) {\n-\n-\t\t// Variables\n-\t\tUndoableEdit\tlastEdit;\n-\n-\t\tif (inProgress == true) {\n-\n-\t\t\t// Get Last Edit\n-\t\t\tlastEdit = lastEdit();\n-\n-\t\t\t// Check for null\n-\t\t\tif (lastEdit != null) {\n-\n-\t\t\t\tif (lastEdit.addEdit(anEdit) == false) {\n-\t\t\t\t\tif (lastEdit.replaceEdit(anEdit) == false) {\n-\t\t\t\t\t\tedits.add(anEdit);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t} // if: lastEdit\n-\n-\t\t\treturn true;\n-\n-\t\t} else {\n-\t\t\treturn false;\n-\t\t}\n-\t} // addEdit()\n-\n-\t/**\n-\t * canRedo\n-\t * @returns TODO\n-\t */\n-\tpublic boolean canRedo() {\n-\t\tif (isInProgress() == true || super.canRedo() == false) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t} // canRedo()\n-\n-\t/**\n-\t * canUndo\n-\t * @returns TODO\n-\t */\n-\tpublic boolean canUndo() {\n-\t\tif (isInProgress() == true || super.canUndo() == false) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t} // canUndo()\n-\n-\t/**\n-\t * die\n-\t */\n-\tpublic void die() {\n-\n-\t\t// Variables\n-\t\tint\t\t\t\tindex;\n-\t\tUndoableEdit\tcurrent;\n-\n-\t\t// Loop through all contained UndoableEdits\n-\t\tfor (index = edits.size() - 1; index >= 0; index--) {\n-\t\t\tcurrent = (UndoableEdit) edits.elementAt(index);\n-\t\t\tcurrent.die();\n-\t\t} // for: index\n-\n-\t} // die()\n-\n-\t/**\n-\t * end\n-\t */\n-\tpublic void end() {\n-\t\tinProgress = false;\n-\t} // end()\n-\n-\t/**\n-\t * getPresentationName\n-\t * @returns TODO\n-\t */\n-\tpublic String getPresentationName() {\n-\t\tif (edits.size() == 0) {\n-\t\t\treturn super.getPresentationName();\n-\t\t} else {\n-\t\t\treturn lastEdit().getPresentationName();\n-\t\t}\n-\t} // getPresentationName()\n-\n-\t/**\n-\t * getRedoPresentationName\n-\t * @returns TODO\n-\t */\n-\tpublic String getRedoPresentationName()\t{\n-\t\tif (edits.size() == 0) {\n-\t\t\treturn super.getRedoPresentationName();\n-\t\t} else {\n-\t\t\treturn lastEdit().getRedoPresentationName();\n-\t\t}\n-\t} // getRedoPresentationName()\n-\n-\t/**\n-\t * getUndoPresentationName\n-\t * @returns TODO\n-\t */\n-\tpublic String getUndoPresentationName()\t{\n-\t\tif (edits.size() == 0) {\n-\t\t\treturn super.getUndoPresentationName();\n-\t\t} else {\n-\t\t\treturn lastEdit().getUndoPresentationName();\n-\t\t}\n-\t} // getUndoPresentationName()\n-\n-\t/**\n-\t * isInProgress\n-\t * @returns TODO\n-\t */\n-\tpublic boolean isInProgress() {\n-\t\treturn inProgress;\n-\t} // isInProgress()\n-\n-\n-\t/**\n-\t * isSignigicant\n-\t * @returns TODO\n-\t */\n-\tpublic boolean isSignificant() {\n-\n-\t\t// Variables\n-\t\tint\t\t\t\tindex;\n-\t\tUndoableEdit\tcurrent;\n-\n-\t\t// Check each edit\n-\t\tfor (index = 0; index < edits.size(); index++) {\n-\t\t\tcurrent = (UndoableEdit) edits.elementAt(index);\n-\t\t\tif (current.isSignificant() == true) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t} // for: index\n-\n-\t\treturn false;\n-\n-\t} // isSignificant()\n-\n-\t/**\n-\t * lastEdit\n-\t * @returns TODO\n-\t */\n-\tprotected UndoableEdit lastEdit() {\n-\t\tif (edits.size() == 0) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn (UndoableEdit) edits.elementAt(edits.size() - 1);\n-\t} // lastEdit()\n-\n-\t/**\n-\t * redo\n-\t * @throws CannotRedoException TODO\n-\t */\n-\tpublic void redo() throws CannotRedoException {\n-\n-\t\t// Variables\n-\t\tint\t\t\t\tindex;\n-\t\tUndoableEdit\tcurrent;\n-\n-\t\t// Loop through all contained UndoableEdits\n-\t\tfor (index = 0; index < edits.size(); index++) {\n-\t\t\tcurrent = (UndoableEdit) edits.elementAt(index);\n-\t\t\tcurrent.redo();\n-\t\t} // for: index\n-\n-\t} // redo()\n-\n-\t/**\n-\t * String representation\n-\t * @returns String representation\n-\t */\n-\tpublic String toString() {\n-\t\treturn null; // TODO\n-\t} // toString()\n-\n-\t/**\n-\t * undo\n-\t * @throws CannotUndoException TODO\n-\t */\n-\tpublic void undo() throws CannotUndoException {\n-\n-\t\t// Variables\n-\t\tint\t\t\t\tindex;\n-\t\tUndoableEdit\tcurrent;\n-\n-\t\t// Loop through all contained UndoableEdits\n-\t\tfor (index = edits.size() - 1; index >= 0; index--) {\n-\t\t\tcurrent = (UndoableEdit) edits.elementAt(index);\n-\t\t\tcurrent.undo();\n-\t\t} // for: index\n-\n-\t} // undo()\n-\n-\n-} // CompoundEdit\n+public class CompoundEdit\n+  extends AbstractUndoableEdit\n+{\n+  /**\n+   * The <code>UndoableEdit</code>s being combined into a compound\n+   * editing action.\n+   */\n+  protected Vector edits;\n+\n+\n+  /**\n+   * Indicates whether the creation of this CompoundEdit is still in\n+   * progress. Initially, the value of this flag is\n+   * <code>true</code>. The {@link #end()} method changes the flag to\n+   * <code>false</code>. \n+   */\n+  private boolean inProgress;\n+\n+\n+  /**\n+   * Constructs a new CompoundEdit.\n+   */\n+  public CompoundEdit()\n+  {\n+    edits = new Vector();\n+    inProgress = true;\n+  }\n+  \n+\n+  /**\n+   * Undoes all edits that are part of of this\n+   * <code>CompoundEdit</code>. The compound elements will receive the\n+   * <code>undo</code> message in the reverse order of addition.\n+   *\n+   * @throws CannotUndoException if {@link #canUndo()} returns\n+   * <code>false</code>. This can happen if {@link #end()} has not\n+   * been called on this <code>CompoundEdit</code>, or if this edit\n+   * has already been undone.\n+   *\n+   * @see #canUndo()\n+   * @see #redo()\n+   */\n+  public void undo()\n+    throws CannotUndoException\n+  {\n+    // AbstractUndoableEdit.undo() will throw a CannotUndoException if\n+    // canUndo returns false.\n+    super.undo();\n+\n+    for (int i = edits.size() - 1; i >= 0; i--)\n+      ((UndoableEdit) edits.elementAt(i)).undo();\n+  }\n+\n+\n+  /**\n+   * Redoes all edits that are part of of this\n+   * <code>CompoundEdit</code>. The compound elements will receive the\n+   * <code>undo</code> message in the same order as they were added.\n+   *\n+   * @throws CannotRedoException if {@link #canRedo()} returns\n+   * <code>false</code>. This can happen if {@link #end()} has not\n+   * been called on this <code>CompoundEdit</code>, or if this edit\n+   * has already been redone.\n+   *\n+   * @see #canRedo()\n+   * @see #undo()\n+   */\n+  public void redo()\n+    throws CannotRedoException\n+  {\n+    // AbstractUndoableEdit.redo() will throw a CannotRedoException if\n+    // canRedo returns false.\n+    super.redo();\n+\n+    for (int i = 0; i < edits.size(); i++)\n+      ((UndoableEdit) edits.elementAt(i)).redo();\n+  }\n+\n+  \n+  /**\n+   * Returns the the <code>UndoableEdit</code> that was last added to\n+   * this compound.\n+   */\n+  protected UndoableEdit lastEdit()\n+  {\n+    if (edits.size() == 0)\n+      return null;\n+    else\n+      return (UndoableEdit) edits.elementAt(edits.size() - 1);\n+  }\n+\n+\n+  /**\n+   * Informs this edit action, and all compound edits, that they will\n+   * no longer be used. Some actions might use this information to\n+   * release resources such as open files.  Called by {@link\n+   * UndoManager} before this action is removed from the edit queue.\n+   *\n+   * <p>The compound elements will receive the\n+   * <code>die</code> message in the reverse order of addition.\n+   */\n+  public void die()\n+  {\n+    for (int i = edits.size() - 1; i >= 0; i--)\n+      ((UndoableEdit) edits.elementAt(i)).die();\n+\n+    super.die();\n+  }\n+\n+\n+  /**\n+   * Incorporates another editing action into this one, thus forming a\n+   * combined edit.\n+   *\n+   * <p>If this edit&#x2019;s {@link #end()} method has been called\n+   * before, <code>false</code> is returned immediately. Otherwise,\n+   * the {@linkplain #lastEdit() last added edit} is given the\n+   * opportunity to {@linkplain UndoableEdit#addEdit(UndoableEdit)\n+   * incorporate} <code>edit</code>.  If this fails, <code>edit</code>\n+   * is given the opportunity to {@linkplain\n+   * UndoableEdit#replaceEdit(UndoableEdit) replace} the last added\n+   * edit.  If this fails as well, <code>edit</code> gets added as a\n+   * new compound to {@link #edits}.\n+   * \n+   * @param edit the editing action being added.\n+   *\n+   * @return <code>true</code> if <code>edit</code> could somehow be\n+   * incorporated; <code>false</code> if <code>edit</code> has not\n+   * been incorporated because {@link #end()} was called before.\n+   */\n+  public boolean addEdit(UndoableEdit edit)\n+  {\n+    UndoableEdit last;\n+\n+    // If end has been called before, do nothing.\n+    if (!inProgress)\n+      return false;\n+\n+    last = lastEdit();\n+\n+    // If edit is the very first edit, just add it to the list.\n+    if (last == null)\n+    {\n+      edits.add(edit);\n+      return true;\n+    }\n+\n+    // Try to incorporate edit into last.\n+    if (last.addEdit(edit))\n+      return true;\n+\n+    // Try to replace last by edit.\n+    if (edit.replaceEdit(last))\n+    {\n+      edits.set(edits.size() - 1, edit);\n+      return true;\n+    }\n+\n+    // If everything else has failed, add edit to the list of compound\n+    // edits.\n+    edits.add(edit);\n+    return true;\n+  }\n+\n+\n+  /**\n+   * Informs this <code>CompoundEdit</code> that its construction\n+   * phase has been completed. After this method has been called,\n+   * {@link #undo()} and {@link #redo()} may be called, {@link\n+   * #isInProgress()} will return <code>false</code>, and all attempts\n+   * to {@linkplain #addEdit(UndoableEdit) add further edits} will\n+   * fail.\n+   */\n+  public void end()\n+  {\n+    inProgress = false;\n+  }\n+\n+\n+  /**\n+   * Determines whether it would be possible to undo this editing\n+   * action. The result will be <code>true</code> if {@link #end()}\n+   * has been called on this <code>CompoundEdit</code>, {@link #die()}\n+   * has not yet been called, and the edit has not been undone\n+   * already.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * undone; <code>false</code> otherwise.\n+   *\n+   * @see #undo()\n+   * @see #canRedo()\n+   */\n+  public boolean canUndo()\n+  {\n+    return !inProgress && super.canUndo();\n+  }\n+\n+\n+  /**\n+   * Determines whether it would be possible to redo this editing\n+   * action. The result will be <code>true</code> if {@link #end()}\n+   * has been called on this <code>CompoundEdit</code>, {@link #die()}\n+   * has not yet been called, and the edit has not been redone\n+   * already.\n+   *\n+   * @return <code>true</code> to indicate that this action can be\n+   * redone; <code>false</code> otherwise.\n+   *\n+   * @see #redo()\n+   * @see #canUndo()\n+   */\n+  public boolean canRedo()\n+  {\n+    return !inProgress && super.canRedo();\n+  }\n+\n+\n+  /**\n+   * Determines whether the initial construction phase of this\n+   * <code>CompoundEdit</code> is still in progress.  During this\n+   * phase, edits {@linkplain #addEdit(UndoableEdit) may be\n+   * added}. After initialization has been terminated by calling\n+   * {@link #end()}, {@link #undo()} and {@link #redo()} can be used.\n+   *\n+   * @return <code>true</code> if the initialization phase is still in\n+   * progress; <code>false</code> if {@link #end()} has been called.\n+   *\n+   * @see #end()\n+   */\n+  public boolean isInProgress()\n+  {\n+    return inProgress;\n+  }\n+\n+\n+  /**\n+   * Determines whether this editing action is significant enough for\n+   * being seperately undoable by the user. A typical significant\n+   * action would be the resizing of an object. However, changing the\n+   * selection in a text document would usually not be considered\n+   * significant.\n+   *\n+   * <p>A <code>CompoundEdit</code> is significant if any of its\n+   * elements are significant.\n+   */\n+  public boolean isSignificant()\n+  {\n+    for (int i = edits.size() - 1; i >= 0; i--)\n+      if (((UndoableEdit) edits.elementAt(i)).isSignificant())\n+        return true;\n+\n+    return false;\n+  }\n+  \n+\n+  /**\n+   * Returns a human-readable, localized name that describes this\n+   * editing action and can be displayed to the user.\n+   *\n+   * <p>The implementation delegates the call to the {@linkplain\n+   * #lastEdit() last added edit action}. If no edit has been added\n+   * yet, the inherited implementation will be invoked, which always\n+   * returns an empty string.\n+   */\n+  public String getPresentationName()\n+  {\n+    UndoableEdit last;\n+\n+    last = lastEdit();\n+    if (last == null)\n+      return super.getPresentationName();\n+    else\n+      return last.getPresentationName();\n+  }\n+\n+\n+  /**\n+   * Calculates a localized message text for presenting the undo\n+   * action to the user.\n+   *\n+   * <p>The implementation delegates the call to the {@linkplain\n+   * #lastEdit() last added edit action}. If no edit has been added\n+   * yet, the {@linkplain\n+   * AbstractUndoableEdit#getUndoPresentationName() inherited\n+   * implementation} will be invoked.\n+   */\n+  public String getUndoPresentationName()\n+  {\n+    UndoableEdit last;\n+\n+    last = lastEdit();\n+    if (last == null)\n+      return super.getUndoPresentationName();\n+    else\n+      return last.getUndoPresentationName();\n+  }\n+\n+\n+  /**\n+   * Calculates a localized message text for presenting the redo\n+   * action to the user.\n+   *\n+   * <p>The implementation delegates the call to the {@linkplain\n+   * #lastEdit() last added edit action}. If no edit has been added\n+   * yet, the {@linkplain\n+   * AbstractUndoableEdit#getRedoPresentationName() inherited\n+   * implementation} will be invoked.\n+   */\n+  public String getRedoPresentationName()\n+  {\n+    UndoableEdit last;\n+\n+    last = lastEdit();\n+    if (last == null)\n+      return super.getRedoPresentationName();\n+    else\n+      return last.getRedoPresentationName();\n+  }\n+  \n+  \n+  /**\n+   * Calculates a string that may be useful for debugging.\n+   */\n+  public String toString()\n+  {\n+    return super.toString()\n+      + \" inProgress: \" + inProgress\n+      + \" edits: \" + edits;\n+  }\n+}"}, {"sha": "00f1e2d830c41b5f96f2455ac79a806ed1842e50", "filename": "libjava/javax/swing/undo/StateEdit.java", "status": "modified", "additions": 122, "deletions": 38, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FStateEdit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FStateEdit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FStateEdit.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,4 +1,4 @@\n-/* StateEdit.java --\n+/* StateEdit.java -- UndoableEdit for StateEditable implementations.\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -42,74 +42,132 @@\n import java.util.Iterator;\n \n /**\n- * StateEdit\n- * @author\tAndrew Selkirk\n+ * A helper class, making it easy to support undo and redo.\n+ *\n+ * <p>The following example shows how to use this class.\n+ *\n+ * <pre>  Foo foo; // class Foo implements {@link StateEditable}\n+ *  StateEdit edit;\n+ *\n+ *  edit = new StateEdit(foo, \"Name Change\");\n+ *  foo.setName(\"Jane Doe\");\n+ *  edit.end();\n+ *  undoManager.addEdit(edit);</pre>\n+ *\n+ * <p>If <code>Foo</code>&#x2019;s implementation of {@link\n+ * StateEditable} considers the name as part of the editable state,\n+ * the user can now choose &#x201c;Undo Name Change&#x201d; or\n+ * &#x201c;Redo Name Change&#x201d; from the respective menu. No\n+ * further undo support is needed from the application.\n+ *\n+ * <p>The following explains what happens in the example.\n+ *\n+ * <p><ol><li>When a <code>StateEdit</code> is created, the associated\n+ * {@link StateEditable} gets asked to store its state into a hash\n+ * table, {@link #preState}.</li>\n+ *\n+ * <li>The application will now perform some changes to the edited\n+ * object.  This typically happens by invoking methods on the edited\n+ * object.</li>\n+ *\n+ * <li>The editing phase is terminated by invoking the {@link #end()}\n+ * method of the <code>StateEdit</code>. The <code>end()</code> method\n+ * does two things.\n+ *\n+ *   <ul><li>The edited object receives a second request for storing\n+ *   its state.  This time, it will use a different hash table, {@link\n+ *   #postState}.</li>\n+ *\n+ *   <li>To increase efficiency, the <code>StateEdit</code> now removes\n+ *   any entries from {@link #preState} and {@link #postState} that have\n+ *   the same key, and whose values are equal. Equality is determined\n+ *   by invoking the <code>equals</code> method inherited from\n+ *   {@link java.lang.Object}.</li></ul></li>\n+ *\n+ * <li>When the user later chooses to undo the <code>StateEdit</code>,\n+ * the edited object is asked to {@linkplain StateEditable#restoreState\n+ * restore its state} from the {@link #preState} table.  Similarly,\n+ * when the user chooses to <i>redo</i> the <code>StateEdit</code>,\n+ * the edited object gets asked to restore its state from the {@link\n+ * #postState}.</li></ol>\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-public class StateEdit extends AbstractUndoableEdit\n+public class StateEdit\n+  extends AbstractUndoableEdit\n {\n-\n-  //-------------------------------------------------------------\n-  // Variables --------------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * RCSID\n+   * The ID of the Java source file in Sun&#x2019;s Revision Control\n+   * System (RCS).  This certainly should not be part of the API\n+   * specification. But in order to be API-compatible with\n+   * Sun&#x2019;s reference implementation, GNU Classpath also has to\n+   * provide this field. However, we do not try to match its value.\n    */\n-  protected static final String RCSID = \"\"; // TODO\n+  protected static final String RCSID = \"\";\n+\n \n   /**\n-   * object\n+   * The object which is being edited by this <code>StateEdit</code>.\n    */\n   protected StateEditable object;\n \n+\n   /**\n-   * preState\n+   * The state of <code>object</code> at the time of constructing\n+   * this <code>StateEdit</code>.\n    */\n   protected Hashtable preState;\n \n+\n   /**\n-   * postState\n+   * The state of <code>object</code> at the time when {@link #end()}\n+   * was called.\n    */\n   protected Hashtable postState;\n \n+\n   /**\n-   * undoRedoName\n+   * A human-readable name for this edit action.\n    */\n   protected String undoRedoName;\n \n \n-  //-------------------------------------------------------------\n-  // Initialization ---------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * Constructor StateEdit\n-   * @param obj Object to edit\n+   * Constructs a <code>StateEdit</code>, specifying the object whose\n+   * state is being edited.\n+   *\n+   * @param obj the object whose state is being edited by this\n+   * <code>StateEdit</code>.\n    */\n   public StateEdit(StateEditable obj)\n   {\n     init(obj, null);\n   }\n \n+\n   /**\n-   * Constructor StateEdit\n-   * @param obj Object to edit\n-   * @param name Presentation name\n+   * Constructs a <code>StateEdit</code>, specifying the object whose\n+   * state is being edited.\n+   *\n+   * @param obj the object whose state is being edited by this\n+   * <code>StateEdit</code>.\n+   *\n+   * @param name the human-readable name of the editing action.\n    */\n   public StateEdit(StateEditable obj, String name)\n   {\n     init(obj, name);\n   }\n \n \n-  //-------------------------------------------------------------\n-  // Methods ----------------------------------------------------\n-  //-------------------------------------------------------------\n-\n   /**\n-   * Initialize this object.\n-   * @param obj Object to edit\n-   * @param name Presentation name\n+   * Initializes this <code>StateEdit</code>. The edited object will\n+   * be asked to store its current state into {@link #preState}.\n+   *\n+   * @param obj the object being edited.\n+   *\n+   * @param name the human-readable name of the editing action.\n    */\n   protected void init(StateEditable obj, String name)\n   {\n@@ -120,43 +178,69 @@ protected void init(StateEditable obj, String name)\n     obj.storeState(preState);\n   }\n \n+\n   /**\n-   * Indicate that all edits are finished, and update this object\n-   * with final state.\n+   * Informs this <code>StateEdit</code> that all edits are finished.\n+   * The edited object will be asked to store its state into {@link\n+   * #postState}, and any redundant entries will get removed from\n+   * {@link #preState} and {@link #postState}.\n    */\n   public void end()\n   {\n     object.storeState(postState);\n     removeRedundantState();\n   }\n \n+\n   /**\n-   * Undo this edit by applying the initial state to the edited object.\n+   * Undoes this edit operation. The edited object will be asked to\n+   * {@linkplain StateEditable#restoreState restore its state} from\n+   * {@link #preState}.\n+   *\n+   * @throws CannotUndoException if {@link #canUndo()} returns\n+   * <code>false</code>, for example because this action has already\n+   * been undone.\n    */\n   public void undo()\n   {\n+    super.undo();\n     object.restoreState(preState);\n   }\n \n+\n   /**\n-   * Undo this edit by applying the final state to the edited object.\n+   * Redoes this edit operation. The edited object will be asked to\n+   * {@linkplain StateEditable#restoreState restore its state} from\n+   * {@link #postState}.\n+   *\n+   * @throws CannotRedoException if {@link #canRedo()} returns\n+   * <code>false</code>, for example because this action has not yet\n+   * been undone.\n    */\n   public void redo()\n   {\n+    super.redo();\n     object.restoreState(postState);\n   }\n \n+\n   /**\n-   * Return the presentation name of this object.\n-   * @returns The name, or null if not set\n+   * Returns a human-readable, localized name that describes this\n+   * editing action and can be displayed to the user.\n+   *\n+   * @return the name, or <code>null</code> if no presentation\n+   * name is available.\n    */\n   public String getPresentationName()\n   {\n     return undoRedoName;\n   }\n \n+\n   /**\n-   * removeRedundantState\n+   * Removes all redundant entries from the pre- and post-edit state\n+   * hash tables. An entry is considered redundant if it is present\n+   * both before and after the edit, and if the two values are equal.\n    */\n   protected void removeRedundantState()\n   {"}, {"sha": "d3f9d4c37381e59ada7a7e8e4706007a7efe549a", "filename": "libjava/javax/swing/undo/StateEditable.java", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FStateEditable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef81a9acb17a9eadc5df75007b4364fbfa3a9de/libjava%2Fjavax%2Fswing%2Fundo%2FStateEditable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fundo%2FStateEditable.java?ref=aef81a9acb17a9eadc5df75007b4364fbfa3a9de", "patch": "@@ -1,4 +1,4 @@\n-/* StateEditable.java --\n+/* StateEditable.java -- Interface for collaborating with StateEdit.\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,29 +37,76 @@\n \n package javax.swing.undo;\n \n-// Imports\n import java.util.Hashtable;\n \n+\n /**\n- * StateEditable public interface\n- * @author Andrew Selkirk\n+ * The interface for objects whose state can be undone or redone by a\n+ * {@link StateEdit} action.\n+ *\n+ * <p>The following example shows how to write a class that implements\n+ * this interface.\n+ *\n+ * <pre> class Foo\n+ *   implements StateEditable\n+ * {\n+ *   private String name;\n+ *\n+ *   public void setName(String n) { name = n; }\n+ *\n+ *   public void restoreState(Hashtable h)\n+ *   {\n+ *     if (h.containsKey(\"name\"))\n+ *       setName((String) h.get(\"name\"));\n+ *   }\n+ *\n+ *   public void storeState(Hashtable s)\n+ *   {\n+ *     s.put(\"name\", name);\n+ *   }\n+ * }</pre>\n+ *\n+ * @see StateEdit\n+ *\n+ * @author Andrew Selkirk (aselkirk@sympatico.ca)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n public interface StateEditable\n {\n   /**\n-   * Restore State\n-   * @param state State\n+   * The ID of the Java source file in Sun&#x2019;s Revision Control\n+   * System (RCS).  This certainly should not be part of the API\n+   * specification. But in order to be API-compatible with\n+   * Sun&#x2019;s reference implementation, GNU Classpath also has to\n+   * provide this field. However, we do not try to match its value.\n    */\n-  void restoreState(Hashtable state);\n+  static final String RCSID = \"\";\n+\n \n   /**\n-   * Store State\n-   * @param state State\n+   * Performs an edit action, taking any editable state information\n+   * from the specified hash table.\n+   *\n+   * <p><b>Note to implementors of this interface:</b> To increase\n+   * efficiency, the <code>StateEdit</code> class {@linkplan\n+   * StateEdit#removeRedundantState() removes redundant state\n+   * information}. Therefore, implementations of this interface must be\n+   * prepared for the case where certain keys were stored into the\n+   * table by {@link #storeState}, but are not present anymore\n+   * when the <code>restoreState</code> method gets called.\n+   *\n+   * @param state a hash table containing the relevant state\n+   * information.\n    */\n-  void storeState(Hashtable state);\n+  void restoreState(Hashtable state);\n+\n \n   /**\n-   * For some reason, Sun made the RCS IDs visible.\n+   * Stores any editable state information into the specified hash\n+   * table.\n+   *\n+   * @param state a hash table for storing relevant state\n+   * information.\n    */\n-  String RCSID = \"We aren't compatible\";\n-} // StateEditable\n+  void storeState(Hashtable state);\n+}"}]}