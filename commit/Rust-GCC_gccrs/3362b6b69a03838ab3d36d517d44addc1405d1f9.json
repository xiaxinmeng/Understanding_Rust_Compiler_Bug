{"sha": "3362b6b69a03838ab3d36d517d44addc1405d1f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM2MmI2YjY5YTAzODM4YWIzZDM2ZDUxN2Q0NGFkZGMxNDA1ZDFmOQ==", "commit": {"author": {"name": "Sterling Augustine", "email": "saugustine@google.com", "date": "2013-04-24T17:19:47Z"}, "committer": {"name": "Sterling Augustine", "email": "sterling@gcc.gnu.org", "date": "2013-04-24T17:19:47Z"}, "message": "2013-04-24  Sterling Augustine  <saugustine@google.com>\n\n\t* dwarf2out.c (skeleton_debug_str_hash, add_skeleton_AT_string)\n\t(comp_dir_string, debug_str_dwo_section): New.\n\t(DEBUG_STR_DWO_SECTION): Rename to ...\n\t(DEBUG_DWO_STR_SECTION): ... this.\n\t(DEBUG_NORM_STR_SECTION): Delete.\n\t(DEBUG_STR_SECTION, DEBUG_STR_SECTION_FLAGS): Edit definitions.\n\t(DEBUG_STR_DWO_SECTION_FLAGS): New.\n\t(find_AT_string): Move most logic to ...\n\t(find_AT_string_in_table): ... here.  New.\n\t(add_top_level_skeleton_die_attrs): Call comp_dir_string and\n\tadd_skeleton_AT_string.  Delete logic.\n\t(output_skeleton_debug_sections): Remove call to\n\tadd_top_level_skeleton_die_attrs.\n\t(add_comp_dir_attribute): Move logic to comp_dir_string.\n\t(dwarf2out_init): Initialize debug_str_dwo_section.\n\t(output_indirect_string): Call find_string_form.\n\t(output_indirect_strings): Rewrite.\n\t(prune_unused_types): Empty skeleton_debug_str_hash.\n\tCall get_skeleton_type_unit and add_top_level_skeleton_die_attrs.\n\t(dwarf2out_finish):  Call output_indirect_strings.\n\nFrom-SVN: r198259", "tree": {"sha": "ac6ab6bae3b76d544778a1282901baa9f189a6ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac6ab6bae3b76d544778a1282901baa9f189a6ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3362b6b69a03838ab3d36d517d44addc1405d1f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3362b6b69a03838ab3d36d517d44addc1405d1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3362b6b69a03838ab3d36d517d44addc1405d1f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3362b6b69a03838ab3d36d517d44addc1405d1f9/comments", "author": {"login": "Sterling-Augustine", "id": 56981066, "node_id": "MDQ6VXNlcjU2OTgxMDY2", "avatar_url": "https://avatars.githubusercontent.com/u/56981066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sterling-Augustine", "html_url": "https://github.com/Sterling-Augustine", "followers_url": "https://api.github.com/users/Sterling-Augustine/followers", "following_url": "https://api.github.com/users/Sterling-Augustine/following{/other_user}", "gists_url": "https://api.github.com/users/Sterling-Augustine/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sterling-Augustine/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sterling-Augustine/subscriptions", "organizations_url": "https://api.github.com/users/Sterling-Augustine/orgs", "repos_url": "https://api.github.com/users/Sterling-Augustine/repos", "events_url": "https://api.github.com/users/Sterling-Augustine/events{/privacy}", "received_events_url": "https://api.github.com/users/Sterling-Augustine/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e93e18e9f781043b5d579c357fa7a9fe9d549aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93e18e9f781043b5d579c357fa7a9fe9d549aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93e18e9f781043b5d579c357fa7a9fe9d549aef"}], "stats": {"total": 191, "additions": 146, "deletions": 45}, "files": [{"sha": "029023c51f2f64dcfc1f4881c7c7615cbf38b2da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3362b6b69a03838ab3d36d517d44addc1405d1f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3362b6b69a03838ab3d36d517d44addc1405d1f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3362b6b69a03838ab3d36d517d44addc1405d1f9", "patch": "@@ -1,3 +1,26 @@\n+2013-04-24  Sterling Augustine  <saugustine@google.com>\n+\n+\t* dwarf2out.c (skeleton_debug_str_hash, add_skeleton_AT_string)\n+\t(comp_dir_string, debug_str_dwo_section): New.\n+\t(DEBUG_STR_DWO_SECTION): Rename to ...\n+\t(DEBUG_DWO_STR_SECTION): ... this.\n+\t(DEBUG_NORM_STR_SECTION): Delete.\n+\t(DEBUG_STR_SECTION, DEBUG_STR_SECTION_FLAGS): Edit definitions.\n+\t(DEBUG_STR_DWO_SECTION_FLAGS): New.\n+\t(find_AT_string): Move most logic to ...\n+\t(find_AT_string_in_table): ... here.  New.\n+\t(add_top_level_skeleton_die_attrs): Call comp_dir_string and\n+\tadd_skeleton_AT_string.  Delete logic.\n+\t(output_skeleton_debug_sections): Remove call to\n+\tadd_top_level_skeleton_die_attrs.\n+\t(add_comp_dir_attribute): Move logic to comp_dir_string.\n+\t(dwarf2out_init): Initialize debug_str_dwo_section.\n+\t(output_indirect_string): Call find_string_form.\n+\t(output_indirect_strings): Rewrite.\n+\t(prune_unused_types): Empty skeleton_debug_str_hash.\n+\tCall get_skeleton_type_unit and add_top_level_skeleton_die_attrs.\n+\t(dwarf2out_finish):  Call output_indirect_strings.\n+\n 2013-04-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* doc/cpp.texi: Remove __GXX_EXPERIMENTAL_CXX1Y__."}, {"sha": "b4e5313ee4558992fd737ccb7433ea4e22d17f80", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 123, "deletions": 45, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3362b6b69a03838ab3d36d517d44addc1405d1f9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3362b6b69a03838ab3d36d517d44addc1405d1f9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3362b6b69a03838ab3d36d517d44addc1405d1f9", "patch": "@@ -157,6 +157,7 @@ static GTY(()) section *debug_loc_section;\n static GTY(()) section *debug_pubnames_section;\n static GTY(()) section *debug_pubtypes_section;\n static GTY(()) section *debug_str_section;\n+static GTY(()) section *debug_str_dwo_section;\n static GTY(()) section *debug_str_offsets_section;\n static GTY(()) section *debug_ranges_section;\n static GTY(()) section *debug_frame_section;\n@@ -206,6 +207,28 @@ struct GTY(()) indirect_string_node {\n \n static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n \n+/* With split_debug_info, both the comp_dir and dwo_name go in the\n+   main object file, rather than the dwo, similar to the force_direct\n+   parameter elsewhere but with additional complications:\n+\n+   1) The string is needed in both the main object file and the dwo.\n+   That is, the comp_dir and dwo_name will appear in both places.\n+\n+   2) Strings can use three forms: DW_FORM_string, DW_FORM_strp or\n+   DW_FORM_GNU_str_index.\n+\n+   3) GCC chooses the form to use late, depending on the size and\n+   reference count.\n+\n+   Rather than forcing the all debug string handling functions and\n+   callers to deal with these complications, simply use a separate,\n+   special-cased string table for any attribute that should go in the\n+   main object file.  This limits the complexity to just the places\n+   that need it.  */\n+\n+static GTY ((param_is (struct indirect_string_node)))\n+  htab_t skeleton_debug_str_hash;\n+\n static GTY(()) int dw2_string_counter;\n \n /* True if the compilation unit places functions in more than one section.  */\n@@ -3197,6 +3220,8 @@ static bool generic_type_p (tree);\n static void schedule_generic_params_dies_gen (tree t);\n static void gen_scheduled_generic_parms_dies (void);\n \n+static const char *comp_dir_string (void);\n+\n /* enum for tracking thread-local variables whose address is really an offset\n    relative to the TLS pointer, which will need link-time relocation, but will\n    not need relocation by the DWARF consumer.  */\n@@ -3310,11 +3335,11 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n   (!dwarf_split_debug_info                                              \\\n    ? (DEBUG_NORM_STR_OFFSETS_SECTION) : (DEBUG_DWO_STR_OFFSETS_SECTION))\n #endif\n-#define DEBUG_DWO_STR_SECTION   \".debug_str.dwo\"\n-#define DEBUG_NORM_STR_SECTION  \".debug_str\"\n+#ifndef DEBUG_STR_DWO_SECTION\n+#define DEBUG_STR_DWO_SECTION   \".debug_str.dwo\"\n+#endif\n #ifndef DEBUG_STR_SECTION\n-#define DEBUG_STR_SECTION                               \\\n-  (!dwarf_split_debug_info ? (DEBUG_NORM_STR_SECTION) : (DEBUG_DWO_STR_SECTION))\n+#define DEBUG_STR_SECTION  \".debug_str\"\n #endif\n #ifndef DEBUG_RANGES_SECTION\n #define DEBUG_RANGES_SECTION\t\".debug_ranges\"\n@@ -3326,16 +3351,17 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)\n #endif\n \n /* Section flags for .debug_macinfo/.debug_macro section.  */\n-#define DEBUG_MACRO_SECTION_FLAGS \\\n+#define DEBUG_MACRO_SECTION_FLAGS                                       \\\n   (dwarf_split_debug_info ? SECTION_DEBUG | SECTION_EXCLUDE : SECTION_DEBUG)\n \n /* Section flags for .debug_str section.  */\n-#define DEBUG_STR_SECTION_FLAGS \\\n-  (dwarf_split_debug_info \\\n-   ? SECTION_DEBUG | SECTION_EXCLUDE \\\n-   : (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings \\\n-      ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \\\n-      : SECTION_DEBUG))\n+#define DEBUG_STR_SECTION_FLAGS                                 \\\n+  (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings               \\\n+   ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \\\n+   : SECTION_DEBUG)\n+\n+/* Section flags for .debug_str.dwo section.  */\n+#define DEBUG_STR_DWO_SECTION_FLAGS (SECTION_DEBUG | SECTION_EXCLUDE)\n \n /* Labels we insert at beginning sections we can reference instead of\n    the section names themselves.  */\n@@ -3819,19 +3845,15 @@ debug_str_eq (const void *x1, const void *x2)\n \t\t (const char *)x2) == 0;\n }\n \n-/* Add STR to the indirect string hash table.  */\n+/* Add STR to the given string hash table.  */\n \n static struct indirect_string_node *\n-find_AT_string (const char *str)\n+find_AT_string_in_table (const char *str, htab_t table)\n {\n   struct indirect_string_node *node;\n   void **slot;\n \n-  if (! debug_str_hash)\n-    debug_str_hash = htab_create_ggc (10, debug_str_do_hash,\n-\t\t\t\t      debug_str_eq, NULL);\n-\n-  slot = htab_find_slot_with_hash (debug_str_hash, str,\n+  slot = htab_find_slot_with_hash (table, str,\n \t\t\t\t   htab_hash_string (str), INSERT);\n   if (*slot == NULL)\n     {\n@@ -3846,6 +3868,18 @@ find_AT_string (const char *str)\n   return node;\n }\n \n+/* Add STR to the indirect string hash table.  */\n+\n+static struct indirect_string_node *\n+find_AT_string (const char *str)\n+{\n+  if (! debug_str_hash)\n+    debug_str_hash = htab_create_ggc (10, debug_str_do_hash,\n+\t\t\t\t      debug_str_eq, NULL);\n+\n+  return find_AT_string_in_table (str, debug_str_hash);\n+}\n+\n /* Add a string attribute value to a DIE.  */\n \n static inline void\n@@ -8680,25 +8714,43 @@ add_AT_pubnames (dw_die_ref die)\n     add_AT_flag (die, DW_AT_GNU_pubnames, 1);\n }\n \n+/* Add a string attribute value to a skeleton DIE.  */\n+\n+static inline void\n+add_skeleton_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind,\n+                        const char *str)\n+{\n+  dw_attr_node attr;\n+  struct indirect_string_node *node;\n+\n+  if (! skeleton_debug_str_hash)\n+    skeleton_debug_str_hash = htab_create_ggc (10, debug_str_do_hash,\n+                                               debug_str_eq, NULL);\n+\n+  node = find_AT_string_in_table (str, skeleton_debug_str_hash);\n+  find_string_form (node);\n+  if (node->form == DW_FORM_GNU_str_index)\n+    node->form = DW_FORM_strp;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_str;\n+  attr.dw_attr_val.val_entry = NULL;\n+  attr.dw_attr_val.v.val_str = node;\n+  add_dwarf_attr (die, &attr);\n+}\n+\n /* Helper function to generate top-level dies for skeleton debug_info and\n    debug_types.  */\n \n static void\n add_top_level_skeleton_die_attrs (dw_die_ref die)\n {\n   const char *dwo_file_name = concat (aux_base_name, \".dwo\", NULL);\n-  dw_attr_ref attr;\n-\n-  add_comp_dir_attribute (die);\n-  add_AT_string (die, DW_AT_GNU_dwo_name, dwo_file_name);\n-  /* The specification suggests that these attributes be inline to avoid\n-     having a .debug_str section.  We know that they exist in the die because\n-     we just added them.  */\n-  attr = get_AT (die, DW_AT_GNU_dwo_name);\n-  attr->dw_attr_val.v.val_str->form = DW_FORM_string;\n-  attr = get_AT (die, DW_AT_comp_dir);\n-  attr->dw_attr_val.v.val_str->form = DW_FORM_string;\n+  const char *comp_dir = comp_dir_string ();\n \n+  add_skeleton_AT_string (die, DW_AT_GNU_dwo_name, dwo_file_name);\n+  if (comp_dir != NULL)\n+    add_skeleton_AT_string (die, DW_AT_comp_dir, comp_dir);\n   add_AT_pubnames (die);\n   add_AT_lineptr (die, DW_AT_GNU_addr_base, debug_addr_section_label);\n }\n@@ -8732,9 +8784,6 @@ output_skeleton_debug_sections (dw_die_ref comp_unit)\n   remove_AT (comp_unit, DW_AT_producer);\n   remove_AT (comp_unit, DW_AT_language);\n \n-  /* Add attributes common to skeleton compile_units and type_units.  */\n-  add_top_level_skeleton_die_attrs (comp_unit);\n-\n   switch_to_section (debug_skeleton_info_section);\n   ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_info_section_label);\n \n@@ -15787,16 +15836,21 @@ add_gnat_descriptive_type_attribute (dw_die_ref die, tree type,\n   add_AT_die_ref (die, DW_AT_GNAT_descriptive_type, dtype_die);\n }\n \n-/* Generate a DW_AT_comp_dir attribute for DIE.  */\n+/* Retrieve the comp_dir string suitable for use with DW_AT_comp_dir.  */\n \n-static void\n-add_comp_dir_attribute (dw_die_ref die)\n+static const char *\n+comp_dir_string (void)\n {\n-  const char *wd = get_src_pwd ();\n+  const char *wd;\n   char *wd1;\n+  static const char *cached_wd = NULL;\n+\n+  if (cached_wd != NULL)\n+    return cached_wd;\n \n+  wd = get_src_pwd ();\n   if (wd == NULL)\n-    return;\n+    return NULL;\n \n   if (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR)\n     {\n@@ -15810,7 +15864,18 @@ add_comp_dir_attribute (dw_die_ref die)\n       wd = wd1;\n     }\n \n-    add_AT_string (die, DW_AT_comp_dir, remap_debug_filename (wd));\n+  cached_wd = remap_debug_filename (wd);\n+  return cached_wd;\n+}\n+\n+/* Generate a DW_AT_comp_dir attribute for DIE.  */\n+\n+static void\n+add_comp_dir_attribute (dw_die_ref die)\n+{\n+  const char * wd = comp_dir_string ();\n+  if (wd != NULL)\n+    add_AT_string (die, DW_AT_comp_dir, wd);\n }\n \n /* Return the default for DW_AT_lower_bound, or -1 if there is not any\n@@ -21730,6 +21795,8 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n                                    DEBUG_SKELETON_INFO_SECTION_LABEL, 0);\n       debug_loc_section = get_section (DEBUG_DWO_LOC_SECTION,\n                                        SECTION_DEBUG | SECTION_EXCLUDE, NULL);\n+      debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,\n+                                           DEBUG_STR_DWO_SECTION_FLAGS, NULL);\n     }\n   debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,\n \t\t\t\t       SECTION_DEBUG, NULL);\n@@ -21854,7 +21921,6 @@ output_index_string (void **h, void *v)\n       /* Assert that the strings are output in the same order as their\n          indexes were assigned.  */\n       gcc_assert (*cur_idx == node->index);\n-      ASM_OUTPUT_LABEL (asm_out_file, node->label);\n       assemble_string (node->str, strlen (node->str) + 1);\n       *cur_idx += 1;\n     }\n@@ -21869,6 +21935,7 @@ output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n {\n   struct indirect_string_node *node = (struct indirect_string_node *) *h;\n \n+  node->form = find_string_form (node);\n   if (node->form == DW_FORM_strp && node->refcount > 0)\n     {\n       ASM_OUTPUT_LABEL (asm_out_file, node->label);\n@@ -21883,21 +21950,21 @@ output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n static void\n output_indirect_strings (void)\n {\n+  switch_to_section (debug_str_section);\n   if (!dwarf_split_debug_info)\n-    {\n-      switch_to_section (debug_str_section);\n-      htab_traverse (debug_str_hash, output_indirect_string, NULL);\n-    }\n+    htab_traverse (debug_str_hash, output_indirect_string, NULL);\n   else\n     {\n       unsigned int offset = 0;\n       unsigned int cur_idx = 0;\n \n+      htab_traverse (skeleton_debug_str_hash, output_indirect_string, NULL);\n+\n       switch_to_section (debug_str_offsets_section);\n       htab_traverse_noresize (debug_str_hash,\n                               output_index_string_offset,\n                               &offset);\n-      switch_to_section (debug_str_section);\n+      switch_to_section (debug_str_dwo_section);\n       htab_traverse_noresize (debug_str_hash,\n                               output_index_string,\n                               &cur_idx);\n@@ -22312,6 +22379,8 @@ prune_unused_types (void)\n \n   if (debug_str_hash)\n     htab_empty (debug_str_hash);\n+  if (skeleton_debug_str_hash)\n+    htab_empty (skeleton_debug_str_hash);\n   prune_unused_types_prune (comp_unit_die ());\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_prune (node->die);\n@@ -23781,9 +23850,18 @@ dwarf2out_finish (const char *filename)\n     optimize_location_lists (comp_unit_die ());\n \n   save_macinfo_strings ();\n+\n   if (dwarf_split_debug_info)\n     {\n       unsigned int index = 0;\n+\n+      /* Add attributes common to skeleton compile_units and\n+         type_units.  Because these attributes include strings, it\n+         must be done before freezing the string table.  Top-level\n+         skeleton die attrs are added when the skeleton type unit is\n+         created, so ensure it is created by this point.  */\n+      add_top_level_skeleton_die_attrs (main_comp_unit_die);\n+      (void) get_skeleton_type_unit ();\n       htab_traverse_noresize (debug_str_hash, index_string, &index);\n     }\n \n@@ -23931,7 +24009,7 @@ dwarf2out_finish (const char *filename)\n     }\n \n   /* If we emitted any indirect strings, output the string table too.  */\n-  if (debug_str_hash)\n+  if (debug_str_hash || skeleton_debug_str_hash)\n     output_indirect_strings ();\n }\n "}]}