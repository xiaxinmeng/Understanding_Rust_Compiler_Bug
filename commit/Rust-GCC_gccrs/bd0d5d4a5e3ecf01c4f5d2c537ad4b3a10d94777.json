{"sha": "bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQwZDVkNGE1ZTNlY2YwMWM0ZjVkMmM1MzdhZDRiM2ExMGQ5NDc3Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-02-08T15:54:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-02-08T15:54:39Z"}, "message": "search.c (shared_member_p): New function.\n\n        * search.c (shared_member_p): New function.\n        (lookup_field_r): Use it.\n        * cp-tree.h (SHARED_MEMBER_P): Remove.\n\n        * method.c (process_overload_item): Handle template-dependent array\n        bounds.\n        * pt.c (type_unification_real): If we end up with undeduced nontype\n        parms, try again.\n\n        * decl.c (lookup_name_real): Tweak warning to refer to decls, not\n        types.\n\n        * typeck2.c (friendly_abort): Don't say anything if we have\n        earlier errors or sorries.\n\n        * decl.c (check_tag_decl): Notice attempts to redefine bool and\n        wchar_t.  Ignore if in_system_header.\n\n        * decl.c (maybe_push_cleanup_level): New fn...\n        (start_decl_1): ...split out from here.\n        * cvt.c (build_up_reference): Use it.\n        * cp-tree.h: Declare it.\n\nFrom-SVN: r39540", "tree": {"sha": "f2dedc12f81ff4a7ee22feea5cba093301e449cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2dedc12f81ff4a7ee22feea5cba093301e449cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c1cf241c4a4fa72ead663cf55e443f6084eacae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c1cf241c4a4fa72ead663cf55e443f6084eacae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c1cf241c4a4fa72ead663cf55e443f6084eacae"}], "stats": {"total": 281, "additions": 232, "deletions": 49}, "files": [{"sha": "feb017726227dbd98f27256065664cb37434da1d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -1,3 +1,28 @@\n+2001-02-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* search.c (shared_member_p): New function.\n+\t(lookup_field_r): Use it.\n+\t* cp-tree.h (SHARED_MEMBER_P): Remove.\n+\n+\t* method.c (process_overload_item): Handle template-dependent array\n+\tbounds.\n+\t* pt.c (type_unification_real): If we end up with undeduced nontype\n+\tparms, try again.\n+\n+\t* decl.c (lookup_name_real): Tweak warning to refer to decls, not\n+\ttypes.\n+\n+\t* typeck2.c (friendly_abort): Don't say anything if we have\n+\tearlier errors or sorries.\n+\n+\t* decl.c (check_tag_decl): Notice attempts to redefine bool and \n+\twchar_t.  Ignore if in_system_header.\n+\n+\t* decl.c (maybe_push_cleanup_level): New fn...\n+\t(start_decl_1): ...split out from here.\n+\t* cvt.c (build_up_reference): Use it.\n+\t* cp-tree.h: Declare it.\n+\n 2001-02-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lang-specs.h: Use CPLUSPLUS_CPP_SPEC for the preprocessor "}, {"sha": "43a97143e25aa4b46418f9704fbf193c00826329", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -2070,12 +2070,6 @@ struct lang_decl\n    member function.  */\n #define DECL_STATIC_FUNCTION_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.static_function)\n \n-/* Nonzero for a class member means that it is shared between all objects\n-   of that class.  */\n-#define SHARED_MEMBER_P(NODE) \\\n-  (TREE_CODE (NODE) == VAR_DECL || TREE_CODE (NODE) == TYPE_DECL \\\n-   || TREE_CODE (NODE) == CONST_DECL)\n-\n /* Nonzero for FUNCTION_DECL means that this decl is a non-static\n    member function.  */\n #define DECL_NONSTATIC_MEMBER_FUNCTION_P(NODE) \\\n@@ -3785,6 +3779,7 @@ extern void keep_next_level\t\t\tPARAMS ((int));\n extern int kept_level_p\t\t\t\tPARAMS ((void));\n extern int template_parm_scope_p\t\tPARAMS ((void));\n extern void set_class_shadows\t\t\tPARAMS ((tree));\n+extern void maybe_push_cleanup_level\t\tPARAMS ((tree));\n extern void begin_scope                         PARAMS ((scope_kind));\n extern void finish_scope                        PARAMS ((void));\n extern void note_level_for_for\t\t\tPARAMS ((void));"}, {"sha": "9fa2a665e15397abc6f0dba732b641f2bd140f09", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -380,6 +380,7 @@ build_up_reference (type, arg, flags)\n \targ = get_temp_name (argtype);\n       else\n \t{\n+\t  maybe_push_cleanup_level (argtype);\n \t  arg = pushdecl (build_decl (VAR_DECL, NULL_TREE, argtype));\n \t  DECL_ARTIFICIAL (arg) = 1;\n \t}"}, {"sha": "dcf84e6ddac62a779dd56ddf885cde3cc8643e85", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -863,6 +863,24 @@ pushlevel (tag_transparent)\n   keep_next_level_flag = 0;\n }\n \n+/* We're defining an object of type TYPE.  If it needs a cleanup, but\n+   we're not allowed to add any more objects with cleanups to the current\n+   scope, create a new binding level.  */\n+\n+void\n+maybe_push_cleanup_level (type)\n+     tree type;\n+{\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+      && current_binding_level->more_cleanups_ok == 0)\n+    {\n+      keep_next_level (2);\n+      pushlevel (1);\n+      clear_last_expr ();\n+      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n+    }\n+}\n+  \n /* Enter a new scope.  The KIND indicates what kind of scope is being\n    created.  */\n \n@@ -5993,10 +6011,9 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t      && TREE_CODE (val) == TYPE_DECL\n \t      && ! same_type_p (TREE_TYPE (from_obj), TREE_TYPE (val)))\n \t    cp_pedwarn (\"\\\n-lookup of `%D' in the scope of `%#T' (`%#T') \\\n-does not match lookup in the current scope (`%#T')\",\n-\t\t\tname, got_object, TREE_TYPE (from_obj),\n-\t\t\tTREE_TYPE (val));\n+lookup of `%D' in the scope of `%#T' (`%#D') \\\n+does not match lookup in the current scope (`%#D')\",\n+\t\t\tname, got_object, from_obj, val);\n \n \t  /* We don't change val to from_obj if got_object depends on\n \t     template parms because that breaks implicit typename for\n@@ -6864,14 +6881,23 @@ check_tag_decl (declspecs)\n       register tree value = TREE_VALUE (link);\n \n       if (TYPE_P (value)\n+\t  || TREE_CODE (value) == TYPE_DECL\n \t  || (TREE_CODE (value) == IDENTIFIER_NODE\n \t      && IDENTIFIER_GLOBAL_VALUE (value)\n-\t      && TYPE_P (IDENTIFIER_GLOBAL_VALUE (value))))\n+\t      && TREE_CODE (IDENTIFIER_GLOBAL_VALUE (value)) == TYPE_DECL))\n \t{\n \t  ++found_type;\n \n-\t  if ((TREE_CODE (value) != TYPENAME_TYPE && IS_AGGR_TYPE (value))\n-\t      || TREE_CODE (value) == ENUMERAL_TYPE)\n+\t  if (found_type == 2 && TREE_CODE (value) == IDENTIFIER_NODE)\n+\t    {\n+\t      if (! in_system_header)\n+\t\tcp_pedwarn (\"redeclaration of C++ built-in type `%T'\", value);\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  if (TYPE_P (value)\n+\t      && ((TREE_CODE (value) != TYPENAME_TYPE && IS_AGGR_TYPE (value))\n+\t\t  || TREE_CODE (value) == ENUMERAL_TYPE))\n \t    {\n \t      my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n \t      t = value;\n@@ -7194,17 +7220,7 @@ start_decl_1 (decl)\n   if (type == error_mark_node)\n     return;\n \n-  /* If this type of object needs a cleanup, but we're not allowed to\n-     add any more objects with cleanups to the current scope, create a\n-     new binding level.  */\n-  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n-      && current_binding_level->more_cleanups_ok == 0)\n-    {\n-      keep_next_level (2);\n-      pushlevel (1);\n-      clear_last_expr ();\n-      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n-    }\n+  maybe_push_cleanup_level (type);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?"}, {"sha": "72702b402f13636f8ac33469a2044cee0406ea93", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -1359,8 +1359,12 @@ process_overload_item (parmtype, extra_Gcode)\n \t    tree length = array_type_nelts (parmtype);\n \t    if (TREE_CODE (length) != INTEGER_CST || flag_do_squangling)\n \t      {\n-\t\tlength = fold (build (PLUS_EXPR, TREE_TYPE (length),\n-\t\t\t\t      length, integer_one_node));\n+\t\tif (TREE_CODE (length) == MINUS_EXPR\n+\t\t    && TREE_OPERAND (length, 1) == integer_one_node)\n+\t\t  length = TREE_OPERAND (length, 0);\n+\t\telse\n+\t\t  length = fold (build (PLUS_EXPR, TREE_TYPE (length),\n+\t\t\t\t\tlength, integer_one_node));\n \t\tSTRIP_NOPS (length);\n \t      }\n \t    build_overload_value (sizetype, length, 1);\n@@ -1964,7 +1968,8 @@ hack_identifier (value, name)\n     {\n       if (current_class_name)\n \t{\n-\t  tree fields = lookup_fnfields (TYPE_BINFO (current_class_type), name, 1);\n+\t  tree fields = lookup_fnfields (TYPE_BINFO (current_class_type),\n+\t\t\t\t\t name, 1);\n \t  if (fields == error_mark_node)\n \t    return error_mark_node;\n \t  if (fields)\n@@ -2091,8 +2096,9 @@ hack_identifier (value, name)\n   else if (TREE_CODE (value) == TREE_LIST \n \t   && TREE_TYPE (value) == error_mark_node)\n     {\n-      error (\"request for member `%s' is ambiguous in multiple inheritance lattice\",\n-\t     IDENTIFIER_POINTER (name));\n+      cp_error (\"\\\n+request for member `%D' is ambiguous in multiple inheritance lattice\",\n+\t\tname);\n       print_candidates (value);\n       return error_mark_node;\n     }"}, {"sha": "181a00eb77b5ded0884f1906a16413aacb75b516", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -7930,25 +7930,28 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n    template).  */\n \n static int\n-type_unification_real (tparms, targs, parms, args, subr,\n-\t\t       strict, allow_incomplete, len)\n-     tree tparms, targs, parms, args;\n+type_unification_real (tparms, targs, xparms, xargs, subr,\n+\t\t       strict, allow_incomplete, xlen)\n+     tree tparms, targs, xparms, xargs;\n      int subr;\n      unification_kind_t strict;\n-     int allow_incomplete, len;\n+     int allow_incomplete, xlen;\n {\n   tree parm, arg;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   int sub_strict;\n+  int saw_undeduced = 0;\n+  tree parms, args;\n+  int len;\n \n   my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n-  my_friendly_assert (parms == NULL_TREE \n-\t\t      || TREE_CODE (parms) == TREE_LIST, 290);\n+  my_friendly_assert (xparms == NULL_TREE \n+\t\t      || TREE_CODE (xparms) == TREE_LIST, 290);\n   /* ARGS could be NULL (via a call from parse.y to\n      build_x_function_call).  */\n-  if (args)\n-    my_friendly_assert (TREE_CODE (args) == TREE_LIST, 291);\n+  if (xargs)\n+    my_friendly_assert (TREE_CODE (xargs) == TREE_LIST, 291);\n   my_friendly_assert (ntparms > 0, 292);\n \n   switch (strict)\n@@ -7974,9 +7977,14 @@ type_unification_real (tparms, targs, parms, args, subr,\n       my_friendly_abort (0);\n     }\n \n-  if (len == 0)\n+  if (xlen == 0)\n     return 0;\n \n+ again:\n+  parms = xparms;\n+  args = xargs;\n+  len = xlen;\n+\n   while (parms\n \t && parms != void_list_node\n \t && args\n@@ -8056,7 +8064,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \n       /* Are we done with the interesting parms?  */\n       if (--len == 0)\n-\treturn 0;\n+\tgoto done;\n     }\n   /* Fail if we've reached the end of the parm list, and more args\n      are present, and the parm list isn't variadic.  */\n@@ -8067,10 +8075,23 @@ type_unification_real (tparms, targs, parms, args, subr,\n       && parms != void_list_node\n       && TREE_PURPOSE (parms) == NULL_TREE)\n     return 1;\n+\n+ done:\n   if (!subr)\n     for (i = 0; i < ntparms; i++)\n       if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n \t{\n+\t  tree tparm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n+\n+\t  /* If this is an undeduced nontype parameter that depends on\n+\t     a type parameter, try another pass; its type may have been\n+\t     deduced from a later argument than the one from which\n+\t     this parameter can be deduced.  */\n+\t  if (TREE_CODE (tparm) == PARM_DECL\n+\t      && uses_template_parms (TREE_TYPE (tparm))\n+\t      && !saw_undeduced++)\n+\t    goto again;\n+\n \t  if (!allow_incomplete)\n \t    error (\"incomplete type unification\");\n \t  return 2;\n@@ -8742,13 +8763,17 @@ unify (tparms, targs, parm, arg, strict)\n \t template-parameter exactly, except that a template-argument\n \t deduced from an array bound may be of any integral type. \n \t The non-type parameter might use already deduced type parameters.  */\n-      if (same_type_p (TREE_TYPE (arg),\n-                       tsubst (TREE_TYPE (parm), targs, 0, NULL_TREE)))\n-\t/* OK */;\n+      tparm = tsubst (TREE_TYPE (parm), targs, 0, NULL_TREE);\n+      if (same_type_p (TREE_TYPE (arg), tparm))\n+\t  /* OK */;\n       else if ((strict & UNIFY_ALLOW_INTEGER)\n-\t       && (TREE_CODE (TREE_TYPE (parm)) == INTEGER_TYPE\n-\t\t   || TREE_CODE (TREE_TYPE (parm)) == BOOLEAN_TYPE))\n+\t       && (TREE_CODE (tparm) == INTEGER_TYPE\n+\t\t   || TREE_CODE (tparm) == BOOLEAN_TYPE))\n \t/* OK */;\n+      else if (uses_template_parms (tparm))\n+\t/* We haven't deduced the type of this parameter yet.  Try again\n+\t   later.  */\n+\treturn 0;\n       else\n \treturn 1;\n "}, {"sha": "620d75920857e6385d7f346eca6e608d18941988", "filename": "gcc/cp/search.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -119,6 +119,7 @@ static tree bfs_walk\n \tPARAMS ((tree, tree (*) (tree, void *), tree (*) (tree, void *),\n \t       void *));\n static tree lookup_field_queue_p PARAMS ((tree, void *));\n+static int shared_member_p PARAMS ((tree));\n static tree lookup_field_r PARAMS ((tree, void *));\n static tree canonical_binfo PARAMS ((tree));\n static tree shared_marked_p PARAMS ((tree, void *));\n@@ -1312,6 +1313,37 @@ template_self_reference_p (type, decl)\n \t   && DECL_NAME (decl) == constructor_name (type));\n }\n \n+\n+/* Nonzero for a class member means that it is shared between all objects\n+   of that class.\n+\n+   [class.member.lookup]:If the resulting set of declarations are not all\n+   from sub-objects of the same type, or the set has a  nonstatic  member\n+   and  includes members from distinct sub-objects, there is an ambiguity\n+   and the program is ill-formed.\n+\n+   This function checks that T contains no nonstatic members.  */\n+\n+static int\n+shared_member_p (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == TYPE_DECL \\\n+      || TREE_CODE (t) == CONST_DECL)\n+    return 1;\n+  if (is_overloaded_fn (t))\n+    {\n+      for (; t; t = OVL_NEXT (t))\n+\t{\n+\t  tree fn = OVL_CURRENT (t);\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+\t    return 0;\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n /* DATA is really a struct lookup_field_info.  Look for a field with\n    the name indicated there in BINFO.  If this function returns a\n    non-NULL value it is the result of the lookup.  Called from\n@@ -1392,7 +1424,7 @@ lookup_field_r (binfo, data)\n      hide the old one, we might have an ambiguity.  */\n   if (lfi->rval_binfo && !is_subobject_of_p (lfi->rval_binfo, binfo, lfi->type))\n     {\n-      if (nval == lfi->rval && SHARED_MEMBER_P (nval))\n+      if (nval == lfi->rval && shared_member_p (nval))\n \t/* The two things are really the same.  */\n \t;\n       else if (is_subobject_of_p (binfo, lfi->rval_binfo, lfi->type))"}, {"sha": "c62949ef405bff3734456e77aef83e67180a77d1", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -261,11 +261,15 @@ friendly_abort (where, file, line, func)\n      int line;\n      const char *func;\n {\n-  if (where > 0)\n-    error (\"Internal error #%d.\", where);\n+  if (errorcount > 0 || sorrycount > 0)\n+    /* Say nothing.  */;\n+  else if (where > 0)\n+    {\n+      error (\"Internal error #%d.\", where);\n \n-  /* Uncount this error, so finish_abort will do the right thing.  */\n-  --errorcount;\n+      /* Uncount this error, so internal_error will do the right thing.  */\n+      --errorcount;\n+    }\n \n   fancy_abort (file, line, func);\n }"}, {"sha": "69d0c7aabc0b0be81d515a1311b4e23725436d13", "filename": "gcc/testsuite/g++.old-deja/g++.ext/syshdr1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fsyshdr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fsyshdr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fsyshdr1.C?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -0,0 +1,11 @@\n+// Test that we don't complain about trying to define bool or wchar_t in a\n+// system header.\n+\n+// Special g++ Options:\n+// Build don't link:\n+\n+# 1 \"syshdr1.C\"\n+# 1 \"syshdr1.h\" 1 3\n+typedef int bool;\n+typedef int wchar_t;\n+# 2 \"syshdr1.C\" 2"}, {"sha": "1a9d58a5a8e24547ea3f02c22535441b82e1d661", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor12.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor12.C?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -0,0 +1,15 @@\n+// Test that we don't complain about calling a destructor on a const object.\n+\n+#include <new>\n+\n+struct A\n+{\n+  ~A() {}\n+};\n+\n+const A a = {};\n+int main()\n+{\n+  a.~A();\n+  a.A::~A();\t\t\t// gets bogus error - const violation\n+}"}, {"sha": "75461d44d840ee239320cb5c79ef6681a88cad3f", "filename": "gcc/testsuite/g++.old-deja/g++.other/goto4.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto4.C?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -0,0 +1,26 @@\n+// Test that we clean up temporaries bound to references properly when\n+// jumping out of their scope.\n+\n+int ret = 1;\n+\n+struct A\n+{\n+  ~A() { ret = 0; }\n+};\n+\n+void f()\n+{\n+  if (0)\n+    {\n+    out:\n+      return;\n+    }\n+  const A& a = A();\n+  goto out;\n+}\n+\n+int main()\n+{\n+  f();\n+  return ret;\n+}"}, {"sha": "09b3123b2fcf168dd212b1f6adf5061f054336e3", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup21.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup21.C?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -0,0 +1,16 @@\n+// Check that we don't complain about ambiguity between the same static\n+// member function in different subobjects.\n+\n+struct A {\n+  static void f() {}\n+};\n+\n+struct B: public A { };\n+struct C: public A { };\n+struct D: public B, public C { };\n+\n+int main()\n+{\n+  D d;\n+  d.f();\n+}"}, {"sha": "b80a932f7a4b4aeee3e997d28b3a6e68838306b9", "filename": "gcc/testsuite/g++.old-deja/g++.pt/deduct4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct4.C?ref=bd0d5d4a5e3ecf01c4f5d2c537ad4b3a10d94777", "patch": "@@ -0,0 +1,11 @@\n+// Test that we can deduce t even though T is deduced from a later argument.\n+\n+template <int I> struct A { };\n+\n+template <class T, T t> void f (A<t> &, T) { }\n+\n+int main ()\n+{\n+  A<42> a;\n+  f (a, 24);\n+}"}]}