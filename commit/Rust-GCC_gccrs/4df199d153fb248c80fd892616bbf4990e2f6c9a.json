{"sha": "4df199d153fb248c80fd892616bbf4990e2f6c9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmMTk5ZDE1M2ZiMjQ4YzgwZmQ4OTI2MTZiYmY0OTkwZTJmNmM5YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-24T17:12:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-24T17:12:28Z"}, "message": "gengtype-state.c (fatal_reading_state): Bring offline.\n\n\n\t* gengtype-state.c (fatal_reading_state): Bring offline.\n\t* optabs.c (widening_optab_handler): Bring offline.\n\t* optabs.h (widening_optab_handler): Likewise.\n\t* final.c (get_attr_length_1): Likewise.\n\nFrom-SVN: r210896", "tree": {"sha": "23f66d0110b53d7887c8334b7556e8179fb87566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23f66d0110b53d7887c8334b7556e8179fb87566"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df199d153fb248c80fd892616bbf4990e2f6c9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df199d153fb248c80fd892616bbf4990e2f6c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df199d153fb248c80fd892616bbf4990e2f6c9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df199d153fb248c80fd892616bbf4990e2f6c9a/comments", "author": null, "committer": null, "parents": [{"sha": "e0e349f3f25d1b2d8c492fc384506bf250cb1d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e349f3f25d1b2d8c492fc384506bf250cb1d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e349f3f25d1b2d8c492fc384506bf250cb1d6a"}], "stats": {"total": 65, "additions": 41, "deletions": 24}, "files": [{"sha": "b68063c7d3902ba9bf2e8531753d383d3b5eec80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -1,3 +1,10 @@\n+2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gengtype-state.c (fatal_reading_state): Bring offline.\n+\t* optabs.c (widening_optab_handler): Bring offline.\n+\t* optabs.h (widening_optab_handler): Likewise.\n+\t* final.c (get_attr_length_1): Likewise.\n+\n 2014-05-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* sched-int.h (sd_iterator_cond): Manually tail recurse."}, {"sha": "0ab8f21caecea4d5b4de707d8afdd5d8c3c51bd7", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -391,11 +391,19 @@ Interprocedural points-to information is located in\n \n @item Profiling\n \n-This pass rewrites the function in order to collect runtime block\n+This pass instruments the function in order to collect runtime block\n and value profiling data.  Such data may be fed back into the compiler\n on a subsequent run so as to allow optimization based on expected\n-execution frequencies.  The pass is located in @file{predict.c} and\n-is described by @code{pass_profile}.\n+execution frequencies.  The pass is located in @file{tree-profile.c} and\n+is described by @code{pass_ipa_tree_profile}.\n+\n+@item Static profile estimation\n+\n+This pass implements series of heuristics to guess propababilities\n+of branches.  The resulting predictions are turned into edge profile\n+by propagating branches across the control flow graphs.\n+The pass is located in @file{tree-profile.c} and is described by\n+@code{pass_profile}.\n \n @item Lower complex arithmetic\n "}, {"sha": "a5e6eb2149048a16f4242ffac29c3f94721f8765", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -371,7 +371,7 @@ init_insn_lengths (void)\n /* Obtain the current length of an insn.  If branch shortening has been done,\n    get its actual length.  Otherwise, use FALLBACK_FN to calculate the\n    length.  */\n-static inline int\n+static int\n get_attr_length_1 (rtx insn, int (*fallback_fn) (rtx))\n {\n   rtx body;"}, {"sha": "5b7017f1e3e114f97efbd6d863bc870d6221e291", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -282,7 +282,7 @@ state_writer::state_writer ()\n \n \n /* Fatal message while reading state.  */\n-static inline void \n+static void \n fatal_reading_state (struct state_token_st* tok, const char*msg)\n {\n   if (tok)"}, {"sha": "9af52270e9b4f407c38aa799da622db4e9764efc", "filename": "gcc/optabs.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -297,6 +297,25 @@ widened_mode (enum machine_mode to_mode, rtx op0, rtx op1)\n   return result;\n }\n \f\n+/* Like optab_handler, but for widening_operations that have a\n+   TO_MODE and a FROM_MODE.  */\n+\n+enum insn_code\n+widening_optab_handler (optab op, enum machine_mode to_mode,\n+\t\t\tenum machine_mode from_mode)\n+{\n+  unsigned scode = (op << 16) | to_mode;\n+  if (to_mode != from_mode && from_mode != VOIDmode)\n+    {\n+      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n+\t widen things that can't be widened?  E.g. add_optab... */\n+      if (op > LAST_CONV_OPTAB)\n+\treturn CODE_FOR_nothing;\n+      scode |= from_mode << 8;\n+    }\n+  return raw_optab_handler (scode);\n+}\n+\n /* Find a widening optab even if it doesn't widen as much as we want.\n    E.g. if from_mode is HImode, and to_mode is DImode, and there is no\n    direct HI->SI insn, then return SI->DI, if that exists."}, {"sha": "089b15a6fcd261bb15c898f185a157f1257284ba", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df199d153fb248c80fd892616bbf4990e2f6c9a/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=4df199d153fb248c80fd892616bbf4990e2f6c9a", "patch": "@@ -144,6 +144,8 @@ extern enum insn_code find_widening_optab_handler_and_mode (optab,\n \t\t\t\t\t\t\t    enum machine_mode,\n \t\t\t\t\t\t\t    int,\n \t\t\t\t\t\t\t    enum machine_mode *);\n+extern enum insn_code widening_optab_handler (optab, enum machine_mode,\n+\t\t\t\t\t      enum machine_mode);\n \n /* An extra flag to control optab_for_tree_code's behavior.  This is needed to\n    distinguish between machines with a vector shift that takes a scalar for the\n@@ -275,25 +277,6 @@ convert_optab_handler (convert_optab op, enum machine_mode to_mode,\n   return raw_optab_handler (scode);\n }\n \n-/* Like optab_handler, but for widening_operations that have a\n-   TO_MODE and a FROM_MODE.  */\n-\n-static inline enum insn_code\n-widening_optab_handler (optab op, enum machine_mode to_mode,\n-\t\t\tenum machine_mode from_mode)\n-{\n-  unsigned scode = (op << 16) | to_mode;\n-  if (to_mode != from_mode && from_mode != VOIDmode)\n-    {\n-      /* ??? Why does find_widening_optab_handler_and_mode attempt to\n-\t widen things that can't be widened?  E.g. add_optab... */\n-      if (op > LAST_CONV_OPTAB)\n-\treturn CODE_FOR_nothing;\n-      scode |= from_mode << 8;\n-    }\n-  return raw_optab_handler (scode);\n-}\n-\n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n "}]}