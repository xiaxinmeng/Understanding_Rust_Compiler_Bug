{"sha": "86a57ce103ce429afd7a47dc19fde1bd6fa93742", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhNTdjZTEwM2NlNDI5YWZkN2E0N2RjMTlmZGUxYmQ2ZmE5Mzc0Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-04-23T23:01:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-04-23T23:01:12Z"}, "message": "Implement LWG 2904 for std::variant assignment\n\n\t* include/std/variant (__variant_construct): Use template parameter\n\ttype instead of equivalent decltype-specifier.\n\t(_Move_ctor_base<false, Types...>::_Move_ctor_base(_Move_ctor_base&&)):\n\tReplace forward with move.\n\t(_Move_ctor_base<false, Types...>::_M_destructive_move)\n\t(_Move_ctor_base<false, Types...>::_M_destructive_copy)\n\t(_Move_ctor_base<true, Types...>::_M_destructive_move)\n\t(_Move_ctor_base<true, Types...>::_M_destructive_copy): Only set the\n\tindex after construction succeeds.\n\t(_Copy_assign_base<false, Types...>::operator=): Remove redundant\n\tif-constexpr checks that are always true. Use __remove_cvref_t instead\n\tof remove_reference so that is_nothrow_move_constructible check\n\tdoesn't use a const rvalue parameter. In the potentially-throwing case\n\tconstruct a temporary and move assign it, as per LWG 2904.\n\t(_Move_assign_base<false, Types...>::operator=): Remove redundant\n\tif-constexpr checks that are always true. Use emplace as per LWG 2904.\n\t(variant::operator=(T&&)): Only use emplace conditionally, otherwise\n\tconstruct a temporary and move assign from it, as per LWG 2904.\n\t* testsuite/20_util/variant/exception_safety.cc: Check that\n\tassignment operators have strong exception safety guarantee.\n\nFrom-SVN: r270525", "tree": {"sha": "b2c536fee70cd0d7fd4b0f936e13cabc730dc05d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c536fee70cd0d7fd4b0f936e13cabc730dc05d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86a57ce103ce429afd7a47dc19fde1bd6fa93742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a57ce103ce429afd7a47dc19fde1bd6fa93742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a57ce103ce429afd7a47dc19fde1bd6fa93742", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a57ce103ce429afd7a47dc19fde1bd6fa93742/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a012806011225b46f537c9e1ed8bdcf31f991916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a012806011225b46f537c9e1ed8bdcf31f991916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a012806011225b46f537c9e1ed8bdcf31f991916"}], "stats": {"total": 158, "additions": 96, "deletions": 62}, "files": [{"sha": "27fb4fed5e3c649f218ab15490e81eb442685569", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=86a57ce103ce429afd7a47dc19fde1bd6fa93742", "patch": "@@ -1,3 +1,26 @@\n+2019-04-24  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/variant (__variant_construct): Use template parameter\n+\ttype instead of equivalent decltype-specifier.\n+\t(_Move_ctor_base<false, Types...>::_Move_ctor_base(_Move_ctor_base&&)):\n+\tReplace forward with move.\n+\t(_Move_ctor_base<false, Types...>::_M_destructive_move)\n+\t(_Move_ctor_base<false, Types...>::_M_destructive_copy)\n+\t(_Move_ctor_base<true, Types...>::_M_destructive_move)\n+\t(_Move_ctor_base<true, Types...>::_M_destructive_copy): Only set the\n+\tindex after construction succeeds.\n+\t(_Copy_assign_base<false, Types...>::operator=): Remove redundant\n+\tif-constexpr checks that are always true. Use __remove_cvref_t instead\n+\tof remove_reference so that is_nothrow_move_constructible check\n+\tdoesn't use a const rvalue parameter. In the potentially-throwing case\n+\tconstruct a temporary and move assign it, as per LWG 2904.\n+\t(_Move_assign_base<false, Types...>::operator=): Remove redundant\n+\tif-constexpr checks that are always true. Use emplace as per LWG 2904.\n+\t(variant::operator=(T&&)): Only use emplace conditionally, otherwise\n+\tconstruct a temporary and move assign from it, as per LWG 2904.\n+\t* testsuite/20_util/variant/exception_safety.cc: Check that\n+\tassignment operators have strong exception safety guarantee.\n+\n 2019-04-23  Thomas Rodgers <trodgers@redhat.com>\n \n \tDocument PSTL linker flags"}, {"sha": "8c7d7f37fe28cdc9175442d9ca6a2a14b146be26", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=86a57ce103ce429afd7a47dc19fde1bd6fa93742", "patch": "@@ -477,9 +477,9 @@ namespace __variant\n \t\t -> __detail::__variant::__variant_cookie\n         {\n \t  __variant_construct_single(std::forward<_Tp>(__lhs),\n-\t      std::forward<decltype(__rhs_mem)>( __rhs_mem));\n+\t      std::forward<decltype(__rhs_mem)>(__rhs_mem));\n \t  return {};\n-\t}, __variant_cast<_Types...>(std::forward<decltype(__rhs)>(__rhs)));\n+\t}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));\n     }\n \n   // The following are (Copy|Move) (ctor|assign) layers for forwarding\n@@ -522,41 +522,23 @@ namespace __variant\n       _Move_ctor_base(_Move_ctor_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)\n       {\n-\t__variant_construct<_Types...>(*this,\n-\t  std::forward<_Move_ctor_base>(__rhs));\n+\t__variant_construct<_Types...>(*this, std::move(__rhs));\n       }\n \n       template<typename _Up>\n         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)\n         {\n \t  this->_M_reset();\n+\t  __variant_construct_single(*this, std::forward<_Up>(__rhs));\n \t  this->_M_index = __rhs_index;\n-\t  __try\n-\t    {\n-\t      __variant_construct_single(*this,\n-\t\t\t\t\t std::forward<_Up>(__rhs));\n-\t    }\n-\t  __catch (...)\n-\t    {\n-\t      this->_M_index = variant_npos;\n-\t      __throw_exception_again;\n-\t    }\n \t}\n \n       template<typename _Up>\n         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)\n         {\n \t  this->_M_reset();\n+\t  __variant_construct_single(*this, __rhs);\n \t  this->_M_index = __rhs_index;\n-\t  __try\n-\t    {\n-\t      __variant_construct_single(*this, __rhs);\n-\t    }\n-\t  __catch (...)\n-\t    {\n-\t      this->_M_index = variant_npos;\n-\t      __throw_exception_again;\n-\t    }\n \t}\n \n       _Move_ctor_base(const _Move_ctor_base&) = default;\n@@ -574,17 +556,16 @@ namespace __variant\n         void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)\n         {\n \t  this->_M_reset();\n+\t  __variant_construct_single(*this, std::forward<_Up>(__rhs));\n \t  this->_M_index = __rhs_index;\n-\t  __variant_construct_single(*this,\n-\t\t\t\t     std::forward<_Up>(__rhs));\n \t}\n \n       template<typename _Up>\n         void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)\n         {\n \t  this->_M_reset();\n-\t  this->_M_index = __rhs_index;\n \t  __variant_construct_single(*this, __rhs);\n+\t  this->_M_index = __rhs_index;\n \t}\n     };\n \n@@ -609,31 +590,23 @@ namespace __variant\n \t    if constexpr (__rhs_index != variant_npos)\n \t      {\n \t\tif (this->_M_index == __rhs_index)\n-\t\t  {\n-\t\t    if constexpr (__rhs_index != variant_npos)\n-\t\t      {\n-\t\t\tauto& __this_mem =\n-\t\t\t  __variant::__get<__rhs_index>(*this);\n-\t\t\tif constexpr (is_same_v<\n-\t\t\t\t      remove_reference_t<decltype(__this_mem)>,\n-\t\t\t\t      __remove_cvref_t<decltype(__rhs_mem)>>)\n-\t\t\t  __this_mem = __rhs_mem;\n-\t\t      }\n-\t\t  }\n+\t\t  __variant::__get<__rhs_index>(*this) = __rhs_mem;\n \t\telse\n \t\t  {\n-\t\t    using __rhs_type =\n-\t\t      remove_reference_t<decltype(__rhs_mem)>;\n-\t\t    if constexpr\n-\t\t      (is_nothrow_copy_constructible_v<__rhs_type>\n-\t\t       || !is_nothrow_move_constructible_v<__rhs_type>)\n-\t\t\tthis->_M_destructive_copy(__rhs_index, __rhs_mem);\n+\t\t    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;\n+\t\t    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>\n+\t\t\t|| !is_nothrow_move_constructible_v<__rhs_type>)\n+\t\t      // The standard says this->emplace<__rhs_type>(__rhs_mem)\n+\t\t      // should be used here, but _M_destructive_copy is\n+\t\t      // equivalent in this case. Either copy construction\n+\t\t      // doesn't throw, so _M_destructive_copy gives strong\n+\t\t      // exception safety guarantee, or both copy construction\n+\t\t      // and move construction can throw, so emplace only gives\n+\t\t      // basic exception safety anyway.\n+\t\t      this->_M_destructive_copy(__rhs_index, __rhs_mem);\n \t\t    else\n-\t\t      {\n-\t\t\tauto __tmp(__rhs_mem);\n-\t\t\tthis->_M_destructive_move(__rhs_index,\n-\t\t\t\t\t\t  std::move(__tmp));\n-\t\t      }\n+\t\t      __variant_cast<_Types...>(*this)\n+\t\t\t= variant<_Types...>(__rhs_mem);\n \t\t  }\n \t      }\n \t    else\n@@ -676,20 +649,10 @@ namespace __variant\n \t    if constexpr (__rhs_index != variant_npos)\n \t      {\n \t\tif (this->_M_index == __rhs_index)\n-\t\t  {\n-\t\t    if constexpr (__rhs_index != variant_npos)\n-\t\t      {\n-\t\t\tauto& __this_mem =\n-\t\t\t  __variant::__get<__rhs_index>(*this);\n-\t\t\tif constexpr (is_same_v<\n-\t\t\t\t      remove_reference_t<decltype(__this_mem)>,\n-\t\t\t\t      remove_reference_t<decltype(__rhs_mem)>>)\n-\t\t\t  __this_mem = std::move(__rhs_mem);\n-\t\t      }\n-\t\t  }\n+\t\t  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);\n \t\telse\n-\t\t  this->_M_destructive_move(__rhs_index,\n-\t\t\t\t\t    std::move(__rhs_mem));\n+\t\t  __variant_cast<_Types...>(*this)\n+\t\t    .template emplace<__rhs_index>(std::move(__rhs_mem));\n \t      }\n \t    else\n \t      this->_M_reset();\n@@ -1395,7 +1358,14 @@ namespace __variant\n \t  if (index() == __index)\n \t    std::get<__index>(*this) = std::forward<_Tp>(__rhs);\n \t  else\n-\t    this->emplace<__index>(std::forward<_Tp>(__rhs));\n+\t    {\n+\t      using _Tj = __accepted_type<_Tp&&>;\n+\t      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>\n+\t\t\t    || !is_nothrow_move_constructible_v<_Tj>)\n+\t\tthis->emplace<__index>(std::forward<_Tp>(__rhs));\n+\t      else\n+\t\toperator=(variant(std::forward<_Tp>(__rhs)));\n+\t    }\n \t  return *this;\n \t}\n "}, {"sha": "a339a80d0f86ebdb4d127fe73d0f2f7868947984", "filename": "libstdc++-v3/testsuite/20_util/variant/exception_safety.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a57ce103ce429afd7a47dc19fde1bd6fa93742/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fexception_safety.cc?ref=86a57ce103ce429afd7a47dc19fde1bd6fa93742", "patch": "@@ -169,10 +169,51 @@ test03()\n   VERIFY( bad_emplace<std::unique_ptr<int>>(v) );\n }\n \n+void\n+test04()\n+{\n+  // LWG 2904. Make variant move-assignment more exception safe\n+\n+  struct ThrowOnCopy\n+  {\n+    ThrowOnCopy() { }\n+    ThrowOnCopy(const ThrowOnCopy&) { throw 1; }\n+    ThrowOnCopy& operator=(const ThrowOnCopy&) { throw \"shouldn't happen\"; }\n+    ThrowOnCopy(ThrowOnCopy&&) noexcept { }\n+  };\n+\n+  std::variant<int, ThrowOnCopy> v1(std::in_place_type<ThrowOnCopy>), v2(2);\n+  try\n+  {\n+    v2 = v1; // uses variant<Types...>::operator=(const variant&)\n+    VERIFY( false );\n+  }\n+  catch (int)\n+  {\n+    VERIFY( !v2.valueless_by_exception() );\n+    VERIFY( v2.index() == 0 );\n+    VERIFY( std::get<0>(v2) == 2 );\n+  }\n+\n+  try\n+  {\n+    ThrowOnCopy toc;\n+    v2 = toc; // uses variant<Types...>::operator=(T&&)\n+    VERIFY( false );\n+  }\n+  catch (int)\n+  {\n+    VERIFY( !v2.valueless_by_exception() );\n+    VERIFY( v2.index() == 0 );\n+    VERIFY( std::get<0>(v2) == 2 );\n+  }\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n }"}]}