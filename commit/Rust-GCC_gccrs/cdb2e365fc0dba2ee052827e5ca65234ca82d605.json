{"sha": "cdb2e365fc0dba2ee052827e5ca65234ca82d605", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RiMmUzNjVmYzBkYmEyZWUwNTI4MjdlNWNhNjUyMzRjYTgyZDYwNQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-07-31T08:53:39Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-08-24T08:21:09Z"}, "message": "SLP: support entire BB.\n\ngcc/ChangeLog:\n\n\t* tree-vect-data-refs.c (dr_group_sort_cmp): Work on\n\tdata_ref_pair.\n\t(vect_analyze_data_ref_accesses): Work on groups.\n\t(vect_find_stmt_data_reference): Add group_id argument and fill\n\tup dataref_groups vector.\n\t* tree-vect-loop.c (vect_get_datarefs_in_loop): Pass new\n\targuments.\n\t(vect_analyze_loop_2): Likewise.\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Pass argument.\n\t(vect_slp_bb_region): Likewise.\n\t(vect_slp_region): Likewise.\n\t(vect_slp_bb):Work on the entire BB.\n\t* tree-vectorizer.h (vect_analyze_data_ref_accesses): Add new\n\targument.\n\t(vect_find_stmt_data_reference): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/vect/bb-slp-38.c: Adjust pattern as now we only process\n\ta single vectorization and now 2 partial.\n\t* gcc.dg/vect/bb-slp-45.c: New test.", "tree": {"sha": "7f37c2b6a9b46a3312078c93aa11aac56c20a00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f37c2b6a9b46a3312078c93aa11aac56c20a00b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdb2e365fc0dba2ee052827e5ca65234ca82d605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb2e365fc0dba2ee052827e5ca65234ca82d605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb2e365fc0dba2ee052827e5ca65234ca82d605", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb2e365fc0dba2ee052827e5ca65234ca82d605/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc646b10c7168c3c95373ee9321e3760fc4c5f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adc646b10c7168c3c95373ee9321e3760fc4c5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adc646b10c7168c3c95373ee9321e3760fc4c5f1"}], "stats": {"total": 196, "additions": 120, "deletions": 76}, "files": [{"sha": "9c57ea3c2c149d47834a51c19be3e8c033265f80", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-38.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-38.c?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -41,4 +41,4 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 2 \"slp2\" { target vect_perm } } } */\n+/* { dg-final { scan-tree-dump \"basic block part vectorized\" \"slp2\" { target vect_perm } } } */"}, {"sha": "4107a34cb9313e31334d3f3e12f3d5bbac8aa4bd", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-45.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-45.c?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-require-effective-target vect_double } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+\n+double a[8], b[8];\n+int x;\n+\n+void __attribute__((noinline,noclone))\n+bar (void)\n+{\n+  x = 1;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo(int i)\n+{\n+  double tem1 = a[2*i];\n+  double tem2 = 2*a[2*i+1];\n+  bar ();\n+  b[2*i] = 2*tem1;\n+  b[2*i+1] = tem2;\n+}\n+\n+int main()\n+{\n+  int i;\n+  check_vect ();\n+  for (i = 0; i < 8; ++i)\n+    b[i] = i;\n+  foo (2);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"basic block vectorized\" \"slp2\" } } */"}, {"sha": "88c5faed20d85a53a9dc00f56bf684447bbf6808", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -2757,25 +2757,33 @@ vect_analyze_data_ref_access (vec_info *vinfo, dr_vec_info *dr_info)\n   return vect_analyze_group_access (vinfo, dr_info);\n }\n \n+typedef std::pair<data_reference_p, int> data_ref_pair;\n+\n /* Compare two data-references DRA and DRB to group them into chunks\n    suitable for grouping.  */\n \n static int\n dr_group_sort_cmp (const void *dra_, const void *drb_)\n {\n-  data_reference_p dra = *(data_reference_p *)const_cast<void *>(dra_);\n-  data_reference_p drb = *(data_reference_p *)const_cast<void *>(drb_);\n+  data_ref_pair dra_pair = *(data_ref_pair *)const_cast<void *>(dra_);\n+  data_ref_pair drb_pair = *(data_ref_pair *)const_cast<void *>(drb_);\n+  data_reference_p dra = dra_pair.first;\n+  data_reference_p drb = drb_pair.first;\n   int cmp;\n \n   /* Stabilize sort.  */\n   if (dra == drb)\n     return 0;\n \n-  /* DRs in different loops never belong to the same group.  */\n-  loop_p loopa = gimple_bb (DR_STMT (dra))->loop_father;\n-  loop_p loopb = gimple_bb (DR_STMT (drb))->loop_father;\n-  if (loopa != loopb)\n-    return loopa->num < loopb->num ? -1 : 1;\n+  /* DRs in different basic-blocks never belong to the same group.  */\n+  int bb_index1 = gimple_bb (DR_STMT (dra))->index;\n+  int bb_index2 = gimple_bb (DR_STMT (drb))->index;\n+  if (bb_index1 != bb_index2)\n+    return bb_index1 < bb_index2 ? -1 : 1;\n+\n+  /* Different group IDs lead never belong to the same group.  */\n+  if (dra_pair.second != drb_pair.second)\n+    return dra_pair.second < drb_pair.second ? -1 : 1;\n \n   /* Ordering of DRs according to base.  */\n   cmp = data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n@@ -2881,11 +2889,11 @@ can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info,\n    FORNOW: handle only arrays and pointer accesses.  */\n \n opt_result\n-vect_analyze_data_ref_accesses (vec_info *vinfo)\n+vect_analyze_data_ref_accesses (vec_info *vinfo,\n+\t\t\t\tvec<int> *dataref_groups)\n {\n   unsigned int i;\n   vec<data_reference_p> datarefs = vinfo->shared->datarefs;\n-  struct data_reference *dr;\n \n   DUMP_VECT_SCOPE (\"vect_analyze_data_ref_accesses\");\n \n@@ -2895,14 +2903,21 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   /* Sort the array of datarefs to make building the interleaving chains\n      linear.  Don't modify the original vector's order, it is needed for\n      determining what dependencies are reversed.  */\n-  vec<data_reference_p> datarefs_copy = datarefs.copy ();\n+  vec<data_ref_pair> datarefs_copy;\n+  datarefs_copy.create (datarefs.length ());\n+  for (unsigned i = 0; i < datarefs.length (); i++)\n+    {\n+      int group_id = dataref_groups ? (*dataref_groups)[i] : 0;\n+      datarefs_copy.quick_push (data_ref_pair (datarefs[i], group_id));\n+    }\n   datarefs_copy.qsort (dr_group_sort_cmp);\n   hash_set<stmt_vec_info> to_fixup;\n \n   /* Build the interleaving chains.  */\n   for (i = 0; i < datarefs_copy.length () - 1;)\n     {\n-      data_reference_p dra = datarefs_copy[i];\n+      data_reference_p dra = datarefs_copy[i].first;\n+      int dra_group_id = datarefs_copy[i].second;\n       dr_vec_info *dr_info_a = vinfo->lookup_dr (dra);\n       stmt_vec_info stmtinfo_a = dr_info_a->stmt;\n       stmt_vec_info lastinfo = NULL;\n@@ -2914,7 +2929,8 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t}\n       for (i = i + 1; i < datarefs_copy.length (); ++i)\n \t{\n-\t  data_reference_p drb = datarefs_copy[i];\n+\t  data_reference_p drb = datarefs_copy[i].first;\n+\t  int drb_group_id = datarefs_copy[i].second;\n \t  dr_vec_info *dr_info_b = vinfo->lookup_dr (drb);\n \t  stmt_vec_info stmtinfo_b = dr_info_b->stmt;\n \t  if (!STMT_VINFO_VECTORIZABLE (stmtinfo_b)\n@@ -2927,10 +2943,14 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t     matters we can push those to a worklist and re-iterate\n \t     over them.  The we can just skip ahead to the next DR here.  */\n \n-\t  /* DRs in a different loop should not be put into the same\n+\t  /* DRs in a different BBs should not be put into the same\n \t     interleaving group.  */\n-\t  if (gimple_bb (DR_STMT (dra))->loop_father\n-\t      != gimple_bb (DR_STMT (drb))->loop_father)\n+\t  int bb_index1 = gimple_bb (DR_STMT (dra))->index;\n+\t  int bb_index2 = gimple_bb (DR_STMT (drb))->index;\n+\t  if (bb_index1 != bb_index2)\n+\t    break;\n+\n+\t  if (dra_group_id != drb_group_id)\n \t    break;\n \n \t  /* Check that the data-refs have same first location (except init)\n@@ -2977,15 +2997,15 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  HOST_WIDE_INT init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n \t  HOST_WIDE_INT init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n \t  HOST_WIDE_INT init_prev\n-\t    = TREE_INT_CST_LOW (DR_INIT (datarefs_copy[i-1]));\n+\t    = TREE_INT_CST_LOW (DR_INIT (datarefs_copy[i-1].first));\n \t  gcc_assert (init_a <= init_b\n \t\t      && init_a <= init_prev\n \t\t      && init_prev <= init_b);\n \n \t  /* Do not place the same access in the interleaving chain twice.  */\n \t  if (init_b == init_prev)\n \t    {\n-\t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1]))\n+\t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1].first))\n \t\t\t  < gimple_uid (DR_STMT (drb)));\n \t      /* Simply link in duplicates and fix up the chain below.  */\n \t    }\n@@ -3098,9 +3118,10 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n       to_fixup.add (newgroup);\n     }\n \n-  FOR_EACH_VEC_ELT (datarefs_copy, i, dr)\n+  data_ref_pair *dr_pair;\n+  FOR_EACH_VEC_ELT (datarefs_copy, i, dr_pair)\n     {\n-      dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n+      dr_vec_info *dr_info = vinfo->lookup_dr (dr_pair->first);\n       if (STMT_VINFO_VECTORIZABLE (dr_info->stmt)\n \t  && !vect_analyze_data_ref_access (vinfo, dr_info))\n \t{\n@@ -3991,7 +4012,8 @@ vect_check_gather_scatter (stmt_vec_info stmt_info, loop_vec_info loop_vinfo,\n \n opt_result\n vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n-\t\t\t       vec<data_reference_p> *datarefs)\n+\t\t\t       vec<data_reference_p> *datarefs,\n+\t\t\t       vec<int> *dataref_groups, int group_id)\n {\n   /* We can ignore clobbers for dataref analysis - they are removed during\n      loop vectorization and BB vectorization checks dependences with a\n@@ -4118,6 +4140,8 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n \t\t      newdr->aux = (void *) (-1 - tree_to_uhwi (arg2));\n \t\t      free_data_ref (dr);\n \t\t      datarefs->safe_push (newdr);\n+\t\t      if (dataref_groups)\n+\t\t\tdataref_groups->safe_push (group_id);\n \t\t      return opt_result::success ();\n \t\t    }\n \t\t}\n@@ -4127,6 +4151,8 @@ vect_find_stmt_data_reference (loop_p loop, gimple *stmt,\n     }\n \n   datarefs->safe_push (dr);\n+  if (dataref_groups)\n+    dataref_groups->safe_push (group_id);\n   return opt_result::success ();\n }\n "}, {"sha": "a92813eb2ac7903be360b12f59a83e54b3a9eb87", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -1865,7 +1865,8 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \tif (is_gimple_debug (stmt))\n \t  continue;\n \t++(*n_stmts);\n-\topt_result res = vect_find_stmt_data_reference (loop, stmt, datarefs);\n+\topt_result res = vect_find_stmt_data_reference (loop, stmt, datarefs,\n+\t\t\t\t\t\t\tNULL, 0);\n \tif (!res)\n \t  {\n \t    if (is_gimple_call (stmt) && loop->safelen)\n@@ -2087,7 +2088,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n      complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n \n-  ok = vect_analyze_data_ref_accesses (loop_vinfo);\n+  ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (dump_enabled_p ())"}, {"sha": "167db07645486089cbe5d611da6c859fc25f9ad9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 31, "deletions": 51, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -3217,7 +3217,8 @@ vect_slp_check_for_constructors (bb_vec_info bb_vinfo)\n    region.  */\n \n static bool\n-vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n+vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n+\t\t       vec<int> *dataref_groups)\n {\n   DUMP_VECT_SCOPE (\"vect_slp_analyze_bb\");\n \n@@ -3239,7 +3240,7 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n       return false;\n     }\n \n-  if (!vect_analyze_data_ref_accesses (bb_vinfo))\n+  if (!vect_analyze_data_ref_accesses (bb_vinfo, dataref_groups))\n     {\n      if (dump_enabled_p ())\n        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3348,10 +3349,11 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal)\n    given by DATAREFS.  */\n \n static bool\n-vect_slp_bb_region (gimple_stmt_iterator region_begin,\n-\t\t    gimple_stmt_iterator region_end,\n-\t\t    vec<data_reference_p> datarefs,\n-\t\t    unsigned int n_stmts)\n+vect_slp_region (gimple_stmt_iterator region_begin,\n+\t\t gimple_stmt_iterator region_end,\n+\t\t vec<data_reference_p> datarefs,\n+\t\t vec<int> *dataref_groups,\n+\t\t unsigned int n_stmts)\n {\n   bb_vec_info bb_vinfo;\n   auto_vector_modes vector_modes;\n@@ -3378,7 +3380,7 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n \tbb_vinfo->shared->check_datarefs ();\n       bb_vinfo->vector_mode = next_vector_mode;\n \n-      if (vect_slp_analyze_bb_1 (bb_vinfo, n_stmts, fatal)\n+      if (vect_slp_analyze_bb_1 (bb_vinfo, n_stmts, fatal, dataref_groups)\n \t  && dbg_cnt (vect_slp))\n \t{\n \t  if (dump_enabled_p ())\n@@ -3473,45 +3475,30 @@ vect_slp_bb_region (gimple_stmt_iterator region_begin,\n bool\n vect_slp_bb (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n-  bool any_vectorized = false;\n-\n-  gsi = gsi_after_labels (bb);\n-  while (!gsi_end_p (gsi))\n+  vec<data_reference_p> datarefs = vNULL;\n+  vec<int> dataref_groups = vNULL;\n+  int insns = 0;\n+  int current_group = 0;\n+  gimple_stmt_iterator region_begin = gsi_start_nondebug_after_labels_bb (bb);\n+  gimple_stmt_iterator region_end = gsi_last_bb (bb);\n+  if (!gsi_end_p (region_end))\n+    gsi_next (&region_end);\n+\n+  for (gimple_stmt_iterator gsi = gsi_after_labels (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n-      gimple_stmt_iterator region_begin = gsi;\n-      vec<data_reference_p> datarefs = vNULL;\n-      int insns = 0;\n-\n-      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_debug (stmt))\n-\t    {\n-\t      /* Skip leading debug stmts.  */\n-\t      if (gsi_stmt (region_begin) == stmt)\n-\t\tgsi_next (&region_begin);\n-\t      continue;\n-\t    }\n-\t  insns++;\n-\n-\t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-\t    vect_location = stmt;\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n \n-\t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs))\n-\t    break;\n-\t}\n-      if (gsi_end_p (region_begin))\n-\tbreak;\n+      insns++;\n \n-      /* Skip leading unhandled stmts.  */\n-      if (gsi_stmt (region_begin) == gsi_stmt (gsi))\n-\t{\n-\t  gsi_next (&gsi);\n-\t  continue;\n-\t}\n+      if (gimple_location (stmt) != UNKNOWN_LOCATION)\n+\tvect_location = stmt;\n \n-      gimple_stmt_iterator region_end = gsi;\n+      if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs,\n+\t\t\t\t\t  &dataref_groups, current_group))\n+\t++current_group;\n \n       if (insns > param_slp_max_insns_in_bb)\n \t{\n@@ -3520,17 +3507,10 @@ vect_slp_bb (basic_block bb)\n \t\t\t     \"not vectorized: too many instructions in \"\n \t\t\t     \"basic block.\\n\");\n \t}\n-      else if (vect_slp_bb_region (region_begin, region_end, datarefs, insns))\n-\tany_vectorized = true;\n-\n-      if (gsi_end_p (region_end))\n-\tbreak;\n-\n-      /* Skip the unhandled stmt.  */\n-      gsi_next (&gsi);\n     }\n \n-  return any_vectorized;\n+  return vect_slp_region (region_begin, region_end, datarefs,\n+\t\t\t  &dataref_groups, insns);\n }\n \n "}, {"sha": "8551b6866132f2a479d7625736d47e8ba898f5cd", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdb2e365fc0dba2ee052827e5ca65234ca82d605/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=cdb2e365fc0dba2ee052827e5ca65234ca82d605", "patch": "@@ -1917,14 +1917,15 @@ extern bool vect_slp_analyze_instance_dependence (vec_info *, slp_instance);\n extern opt_result vect_enhance_data_refs_alignment (loop_vec_info);\n extern opt_result vect_analyze_data_refs_alignment (loop_vec_info);\n extern bool vect_slp_analyze_instance_alignment (vec_info *, slp_instance);\n-extern opt_result vect_analyze_data_ref_accesses (vec_info *);\n+extern opt_result vect_analyze_data_ref_accesses (vec_info *, vec<int> *);\n extern opt_result vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_gather_scatter_fn_p (vec_info *, bool, bool, tree, tree,\n \t\t\t\t      tree, int, internal_fn *, tree *);\n extern bool vect_check_gather_scatter (stmt_vec_info, loop_vec_info,\n \t\t\t\t       gather_scatter_info *);\n extern opt_result vect_find_stmt_data_reference (loop_p, gimple *,\n-\t\t\t\t\t\t vec<data_reference_p> *);\n+\t\t\t\t\t\t vec<data_reference_p> *,\n+\t\t\t\t\t\t vec<int> *, int);\n extern opt_result vect_analyze_data_refs (vec_info *, poly_uint64 *, bool *);\n extern void vect_record_base_alignments (vec_info *);\n extern tree vect_create_data_ref_ptr (vec_info *,"}]}